Project Path: arc_gmh5225_WOW-WowAutoFishing_z6ywpztp

Source Tree:

```txt
arc_gmh5225_WOW-WowAutoFishing_z6ywpztp
├── CommUtil
│   ├── CommUtil.cpp
│   ├── CommUtil.hpp
│   ├── CommUtil.vcxproj
│   ├── CommUtil.vcxproj.filters
│   ├── DTW.h
│   ├── DTW.hpp
│   ├── FTimer.cpp
│   ├── FTimer.h
│   ├── Logger.cpp
│   ├── Logger.h
│   ├── StateBase.cpp
│   ├── StateBase.h
│   ├── StateMachine.cpp
│   ├── StateMachine.h
│   ├── StringUtil.cpp
│   ├── StringUtil.hpp
│   ├── VectorUtil.cpp
│   ├── VectorUtil.hpp
│   └── endian.h
├── DllInjecter
│   ├── DLLInjecter.cpp
│   ├── DllInjecter.vcxproj
│   ├── DllInjecter.vcxproj.filters
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
├── Intercepter
│   ├── CursorIntercepter.cpp
│   ├── CursorIntercepter.h
│   ├── Intercepter.vcxproj
│   ├── Intercepter.vcxproj.filters
│   ├── IntercepterBase.cpp
│   ├── IntercepterBase.h
│   ├── detours
│   │   ├── include
│   │   │   ├── detours.h
│   │   │   ├── detver.h
│   │   │   └── syelog.h
│   │   ├── lib.X64
│   │   │   └── detours.lib
│   │   └── lib.X86
│   │       └── detours.lib
│   ├── dllmain.cpp
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
├── WaveConverter
│   ├── WaveConverter.cpp
│   ├── WaveConverter.vcxproj
│   ├── WaveConverter.vcxproj.filters
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
├── WaveGraph
│   ├── Resource.h
│   ├── Util
│   │   ├── FFT.cpp
│   │   ├── FFT.h
│   │   ├── FastFourierTransform.cpp
│   │   └── FastFourierTransform.h
│   ├── WaveGraph.cpp
│   ├── WaveGraph.h
│   ├── WaveGraph.ico
│   ├── WaveGraph.rc
│   ├── WaveGraph.vcxproj
│   ├── WaveGraph.vcxproj.filters
│   ├── small.ico
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
├── WavePlayer
│   ├── WavePlayer.cpp
│   ├── WavePlayer.vcxproj
│   ├── WavePlayer.vcxproj.filters
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
├── WaveUtil
│   ├── WaveConverter.cpp
│   ├── WaveConverter.h
│   ├── WaveFile.cpp
│   ├── WaveFile.h
│   ├── WaveStreamConverter.cpp
│   ├── WaveStreamConverter.h
│   ├── WaveUtil.cpp
│   ├── WaveUtil.h
│   ├── WaveUtil.vcxproj
│   ├── WaveUtil.vcxproj.filters
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
├── Win32Util
│   ├── Audio
│   │   ├── AudioCapture.cpp
│   │   ├── AudioCapture.h
│   │   ├── AudioRender.cpp
│   │   ├── AudioRender.h
│   │   ├── AudioUtil.cpp
│   │   ├── AudioUtil.h
│   │   └── Extend
│   │       ├── AudioExtractor.cpp
│   │       ├── AudioExtractor.h
│   │       ├── AudioFingerprint.cpp
│   │       ├── AudioFingerprint.h
│   │       ├── AudioFrameStorage.cpp
│   │       ├── AudioFrameStorage.h
│   │       ├── AudioPainter.cpp
│   │       ├── AudioPainter.h
│   │       ├── AudioRecorder.cpp
│   │       ├── AudioRecorder.h
│   │       ├── AudioRenderer.cpp
│   │       └── AudioRenderer.h
│   ├── Image
│   │   ├── ImageUtil.cpp
│   │   ├── ImageUtil.h
│   │   ├── WindowPrinter.cpp
│   │   └── WindowPrinter.h
│   ├── Keyboard
│   │   ├── KeyboardBackground.cpp
│   │   ├── KeyboardBackground.h
│   │   ├── KeyboardBase.cpp
│   │   ├── KeyboardBase.h
│   │   ├── KeyboardGlobal.cpp
│   │   └── KeyboardGlobal.h
│   ├── Mouse
│   │   ├── MouseBackground.cpp
│   │   ├── MouseBackground.h
│   │   ├── MouseBase.cpp
│   │   ├── MouseBase.h
│   │   ├── MouseGlobal.cpp
│   │   └── MouseGlobal.h
│   ├── Util
│   │   ├── DLLInjecter.cpp
│   │   ├── DLLInjecter.h
│   │   ├── DcBuffer.cpp
│   │   ├── DcBuffer.h
│   │   ├── ShareMemory.cpp
│   │   ├── ShareMemory.h
│   │   ├── Utility.cpp
│   │   └── Utility.h
│   ├── Win32Util.vcxproj
│   ├── Win32Util.vcxproj.filters
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
├── WowAutoFishing.sln
├── WowFisher
│   ├── Fisher.cpp
│   ├── Fisher.h
│   ├── FisherConfig.cpp
│   ├── FisherConfig.h
│   ├── FisherStateBait.cpp
│   ├── FisherStateBait.h
│   ├── FisherStateBase.cpp
│   ├── FisherStateBase.h
│   ├── FisherStateCheckBait.cpp
│   ├── FisherStateCheckBait.h
│   ├── FisherStateDefine.h
│   ├── FisherStateFindFloat.cpp
│   ├── FisherStateFindFloat.h
│   ├── FisherStateJump.cpp
│   ├── FisherStateJump.h
│   ├── FisherStateMachine.cpp
│   ├── FisherStateMachine.h
│   ├── FisherStateShaduf.cpp
│   ├── FisherStateShaduf.h
│   ├── FisherStateThrowPole.cpp
│   ├── FisherStateThrowPole.h
│   ├── FisherStateWaitBite.cpp
│   ├── FisherStateWaitBite.h
│   ├── FisherStateWaitFloatHide.cpp
│   ├── FisherStateWaitFloatHide.h
│   ├── FishingSoundListener.cpp
│   ├── FishingSoundListener.h
│   ├── WowFisher.aps
│   ├── WowFisher.cpp
│   ├── WowFisher.h
│   ├── WowFisher.rc
│   ├── WowFisher.vcxproj
│   ├── WowFisher.vcxproj.filters
│   ├── WowFisherDlg.cpp
│   ├── WowFisherDlg.h
│   ├── config
│   │   └── Fisher.ini
│   ├── res
│   │   ├── WowFisher.ico
│   │   └── WowFisher.rc2
│   ├── resource.h
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
└── WowNpcScanAlertor
    ├── NpcScanAlertor.cpp
    ├── NpcScanAlertor.h
    ├── NpcScanAlertorMgr.cpp
    ├── NpcScanAlertorMgr.h
    ├── WowNpcScanAlertor.cpp
    ├── WowNpcScanAlertor.vcxproj
    ├── WowNpcScanAlertor.vcxproj.filters
    ├── stdafx.cpp
    ├── stdafx.h
    └── targetver.h

```

`CommUtil/CommUtil.cpp`:

```cpp
#include "CommUtil.hpp"

namespace comm_util
{

const float CommUtil::FLOAT_EPSILON = 1E-7f;
const double CommUtil::DOUBLE_EPSILON = 1E-15;

bool CommUtil::IsEqual(float a, float b)
{
	return IsEqualZero(a - b);
}

bool CommUtil::IsEqual(double a, double b)
{
	return IsEqualZero(a - b);
}

bool CommUtil::IsEqualZero(float a)
{
	return -FLOAT_EPSILON < a && a < FLOAT_EPSILON;
}

bool CommUtil::IsEqualZero(double a)
{
	return -DOUBLE_EPSILON < a && a < DOUBLE_EPSILON;
}

} // namespace comm_util
```

`CommUtil/CommUtil.hpp`:

```hpp
#pragma once

#undef min
#undef max

#define SAFE_FREE(p) if(p) { free(p); p = NULL; }
#define SAFE_DELETE(p) if(p) { delete p; p = NULL; }
#define SAFE_DELETE_A(p) if(p) { delete[] p; p = NULL; }

namespace comm_util
{

class CommUtil
{
public:
	static const float FLOAT_EPSILON;
	static const double DOUBLE_EPSILON;

	static bool IsEqual(float a, float b);
	static bool IsEqual(double a, double b);
	static bool IsEqualZero(float a);
	static bool IsEqualZero(double a);
};

template<typename T>
inline void swap(T &a, T &b)
{
	T tmp = a;
	a = b;
	b = tmp;
}

template<typename T>
inline T min(T a, T b)
{
	return a < b ? a : b;
}

template<typename T>
inline T max(T a, T b)
{
	return a > b ? a : b;
}

template<typename T>
inline T min(T a, T b, T c)
{
	if (a < b)
		return min(a, c);
	else
		return min(b, c);
}

template<typename T>
inline T max(T a, T b, T c)
{
	if (a > b)
		return max(a, c);
	else
		return max(b, c);
}

} // namespace comm_util
```

`CommUtil/CommUtil.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{413A4356-BD98-4A7D-A427-BAA93936627F}</ProjectGuid>
    <RootNamespace>CommUtil</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="DTW.h" />
    <ClInclude Include="endian.h" />
    <ClInclude Include="CommUtil.hpp" />
    <ClInclude Include="FTimer.h" />
    <ClInclude Include="Logger.h" />
    <ClInclude Include="StateBase.h" />
    <ClInclude Include="StateMachine.h" />
    <ClInclude Include="StringUtil.hpp" />
    <ClInclude Include="VectorUtil.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="CommUtil.cpp" />
    <ClCompile Include="DTW.hpp" />
    <ClCompile Include="FTimer.cpp" />
    <ClCompile Include="Logger.cpp" />
    <ClCompile Include="StateBase.cpp" />
    <ClCompile Include="StateMachine.cpp" />
    <ClCompile Include="StringUtil.cpp" />
    <ClCompile Include="VectorUtil.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CommUtil/CommUtil.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="VectorUtil.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="CommUtil.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="StringUtil.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="FTimer.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Logger.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="endian.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="StateMachine.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="StateBase.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="DTW.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="VectorUtil.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="StringUtil.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="CommUtil.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="FTimer.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="Logger.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="StateMachine.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="StateBase.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="DTW.hpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`CommUtil/DTW.h`:

```h
#pragma once

template <typename Numeric>
class DTW
{
public:
	DTW(size_t m, size_t n);
	~DTW();

	Numeric Calculate(const Numeric* data1, size_t len1, const Numeric* data2, size_t len2);

private:
	Numeric** m_dist;
	Numeric** m_cost;
	size_t M;
	size_t N;
};


```

`CommUtil/DTW.hpp`:

```hpp
#include "DTW.h"
#include <cstring>


template <typename Numeric>
DTW<Numeric>::DTW(size_t m, size_t n)
    : M(m)
    , N(n)
{
    m_dist = new Numeric * [m];
    m_cost = new Numeric * [m];
    for (size_t i = 0; i < m; i++)
    {
        m_dist[i] = new Numeric[n];
        m_cost[i] = new Numeric[n];
    }
}

template <typename Numeric>
DTW<Numeric>::~DTW()
{
    for (size_t i = 0; i < M; i++)
    {
        delete[] m_dist[i];
        delete[] m_cost[i];
    }
    delete[] m_dist;
    delete[] m_cost;
}

template <typename Numeric>
Numeric DTW<Numeric>::Calculate(const Numeric* v1, size_t len1, const Numeric* v2, size_t len2)
{
    if (len1 > M)
        len1 = M;
    if (len2 > N)
        len2 = N;

    // 清0
    for (size_t i = 0; i < M; ++i)
    {
        for (size_t j = 0; j < N; ++j)
        {
            m_dist[i][j] = 0;
            m_cost[i][j] = 0;
        }
    }

    // 帧匹配距离矩阵
    for (size_t i = 0; i < len1; i++)
    {
        for (size_t j = 0; j < len2; j++)
        {
            Numeric dist = v1[i] - v2[j];
            m_dist[i][j] = abs(dist);
        }
    }

    // 初始化累积距离矩阵
    m_cost[0][0] = m_dist[0][0];
    for (size_t i = 1; i < len1; i++)
    {
        m_cost[i][0] = m_cost[i - 1][0] + m_dist[i][0];
    }
    for (size_t j = 1; j < len2; j++)
    {
        m_cost[0][j] = m_cost[0][j - 1] + m_dist[0][j];
    }
    // 累积距离矩阵
    Numeric d1, d2, d3;
    for (size_t i = 1; i < len1; i++)
    {
        for (size_t j = 1; j < len2; j++)
        {
            d1 = m_cost[i - 1][j];
            d2 = m_cost[i - 1][j - 1];
            d3 = m_cost[i][j - 1];
            m_cost[i][j] = m_dist[i][j] + min(min(d1, d2), d3);
        }
    }

    Numeric result = m_cost[len1 - 1][len2 - 1];
    return result;
}
```

`CommUtil/FTimer.cpp`:

```cpp
#include "FTimer.h"

namespace comm_util
{

using namespace std::chrono;

FTimer::FTimer()
    : m_duration(0), m_running(false)
{
}

FTimer::~FTimer()
{
}

void FTimer::Start()
{
    m_begin = steady_clock::now();
    m_running = true;
}

void FTimer::Stop()
{
    if (m_running)
    {
        auto end = steady_clock::now();
        m_duration += duration_cast<duration<double>>(end - m_begin);
        m_running = false;
    }
}

void FTimer::Reset()
{
    m_duration = m_duration.zero();
    m_running = false;
}

int64_t FTimer::Seconds()
{
    if (m_running)
    {
        auto end = steady_clock::now();
        auto duration = m_duration + (end - m_begin);
        return duration_cast<seconds>(duration).count();
    }
    else
    {
        return duration_cast<seconds>(m_duration).count();
    }
}

int64_t FTimer::MilliSeconds()
{
    if (m_running)
    {
        auto end = steady_clock::now();
        auto duration = m_duration + (end - m_begin);
        return duration_cast<milliseconds>(duration).count();
    }
    else
    {
        return duration_cast<milliseconds>(m_duration).count();
    }
}

}
```

`CommUtil/FTimer.h`:

```h
#pragma once
#include<chrono>

namespace comm_util
{

class FTimer
{
public:
    FTimer();
    ~FTimer();

    void Start();
    void Stop();
    void Reset();

    int64_t Seconds();
    int64_t MilliSeconds();

private:
    std::chrono::steady_clock::time_point m_begin;
    std::chrono::duration<double> m_duration;
    bool m_running;
};

}


```

`CommUtil/Logger.cpp`:

```cpp
#include "Logger.h"
#include <cstdio>


namespace comm_util
{

#define VPRINTF_S(format) \
{\
	va_list ap;\
	va_start(ap, format);\
	vprintf_s(format, ap);\
	va_end(ap);\
}

Logger::LogLevel Logger::m_log_level = Logger::LogLevel::Error;

Logger::Logger()
{
}

Logger::~Logger()
{
}

Logger::LogLevel Logger::GetLogLevel()
{
	return m_log_level;
}

void Logger::SetLogLevel(LogLevel level)
{
	m_log_level = level;
}

void Logger::Log(LogLevel level, const char *format, ...)
{
	if (m_log_level >= level)
	{
		VPRINTF_S(format);
	}
}

void Logger::LogDebug(const char *format, ...)
{
	if (m_log_level >= LogLevel::Debug)
	{
		VPRINTF_S(format);
	}
}

void Logger::LogInfo(const char *format, ...)
{
	if (m_log_level >= LogLevel::Info)
	{
		VPRINTF_S(format);
	}
}

void Logger::LogError(const char *format, ...)
{
	if (m_log_level >= LogLevel::Error)
	{
		VPRINTF_S(format);
	}
}

} // end namespace comm_util

```

`CommUtil/Logger.h`:

```h
#pragma once
#include <cstdarg>

namespace comm_util
{

class Logger
{
public:
	enum class LogLevel
	{
		Debug,
		Info,
		Error,
	};

public:
	Logger();
	~Logger();

	static LogLevel GetLogLevel();
	static void SetLogLevel(LogLevel level);

	static void Log(LogLevel level, const char *format, ...);
	static void LogDebug(const char *format, ...);
	static void LogInfo(const char *format, ...);
	static void LogError(const char *format, ...);

private:
	static LogLevel m_log_level;
};

} // end namespace comm_util

```

`CommUtil/StateBase.cpp`:

```cpp
#include "StateBase.h"

namespace comm_util
{

StateBase::StateBase(int state_type)
    : m_state_type(state_type)
{
}

StateBase::~StateBase()
{
}

void StateBase::OnEnter(void* param)
{
}

void StateBase::OnLeave(void* param)
{
}

void StateBase::Update(int dt)
{
}

int StateBase::GetStateType() const
{
    return m_state_type;
}

} // namespace comm_util

```

`CommUtil/StateBase.h`:

```h
#ifndef _COMM_UTIL_STATE_BASE_H__
#define _COMM_UTIL_STATE_BASE_H__
#include "stddef.h"

namespace comm_util
{

class StateBase
{
public:
    StateBase(int state_type);
    virtual ~StateBase();

    virtual void OnEnter(void* param);
    virtual void OnLeave(void* param);
    virtual void Update(int dt);

    int GetStateType() const;

protected:
    int m_state_type;
};

} // namespace comm_util
#endif // !_COMM_UTIL_STATE_BASE_H__

```

`CommUtil/StateMachine.cpp`:

```cpp
#include "StateMachine.h"

namespace comm_util
{

StateMachine::StateMachine()
    : m_cur_state(NULL)
    , m_pre_state(0)
{
}


StateMachine::~StateMachine()
{
    for (auto iter = m_state_map.begin(); iter != m_state_map.end(); ++iter)
    {
        delete iter->second;
    }
    m_state_map.clear();
    m_cur_state = NULL;
}

void StateMachine::Init()
{
    // init m_state_map
}

void StateMachine::Update(int dt)
{
    if (m_cur_state != NULL)
    {
        m_cur_state->Update(dt);
    }
}

bool StateMachine::GotoState(int state_type, void* param)
{
    auto iter = m_state_map.find(state_type);
    if (iter == m_state_map.end())
    {
        _ASSERT(false);
        return false;
    }

    if (m_cur_state != NULL)
    {
        m_cur_state->OnLeave(param);
        m_pre_state = m_cur_state->GetStateType();
    }

    m_cur_state = iter->second;
    m_cur_state->OnEnter(param);

    return true;
}

StateBase* StateMachine::GetCurState() const
{
    return m_cur_state;
}

int StateMachine::GetCurStateType() const
{
    if (m_cur_state != NULL)
        return m_cur_state->GetStateType();
    else
        return 0;
}

int StateMachine::GetPreStateType() const
{
    return m_pre_state;
}

bool StateMachine::AddState(StateBase* state)
{
    if (state == NULL)
    {
        return false;
    }

    if (m_state_map.find(state->GetStateType()) != m_state_map.end())
    {
        return false;
    }

    m_state_map.insert(std::make_pair(state->GetStateType(), state));
    return true;
}

} // namespace comm_util

```

`CommUtil/StateMachine.h`:

```h
#ifndef _COMM_UTIL_STATE_MACHINE_H__
#define _COMM_UTIL_STATE_MACHINE_H__
#include "StateBase.h"
#include <map>

namespace comm_util
{

class StateMachine
{
public:
    StateMachine();
    virtual ~StateMachine();

    virtual void Init();
    virtual void Update(int dt);

    virtual bool GotoState(int state_type, void* param = NULL);

    virtual StateBase* GetCurState() const;
    virtual int GetCurStateType() const;
    virtual int GetPreStateType() const;

protected:
    virtual bool AddState(StateBase* state);

protected:
    std::map<int, StateBase*> m_state_map;
    StateBase * m_cur_state;
    int m_pre_state;
};

} // namespace comm_util
#endif // !_COMM_UTIL_STATE_MACHINE_H__

```

`CommUtil/StringUtil.cpp`:

```cpp
#include "StringUtil.hpp"

namespace comm_util
{

StringUtil::StringUtil()
{
}


StringUtil::~StringUtil()
{
}

float StringUtil::atof(const char *str)
{
	return (float)::atof(str);
}

std::list<std::string> StringUtil::Split(const char *str, const char *delimiter)
{
	std::list<string> strs;
	size_t size = strlen(str);
	std::shared_ptr<char> buf(new char[size + 1], std::default_delete<char[]>());
	assert(buf.get());

	buf.get()[0] = '\0';
	memcpy_s(buf.get(), size + 1, str, size);

	char *ptr = nullptr, *next = buf.get();
	while ((ptr = strtok_s(next, delimiter, &next)) != nullptr)
	{
		strs.push_back(string(ptr));
	}

	return strs;
}

} // namespace comm_util
```

`CommUtil/StringUtil.hpp`:

```hpp
#pragma once
#include <cstring>
#include <string>
#include <vector>
#include <list>
#include <memory>
#include <assert.h>

namespace comm_util
{

using namespace std;

class StringUtil
{
public:
	StringUtil();
	~StringUtil();

	static float atof(const char *str);

	static std::list<std::string> Split(const char *str, const char *delimiter);

	template<typename T>
	static std::vector<T> ParseValues(const char *str, const char *delimiter, T(*convert)(const char*));
};

template<typename T>
static std::vector<T> StringUtil::ParseValues(const char *str, const char *delimiter, T(*convert)(const char*))
{
	std::vector<T> data;
	size_t size = strlen(str);
	std::shared_ptr<char> buf(new char[size + 1], std::default_delete<char[]>());
	assert(buf.get());

	buf.get()[0] = '\0';
	memcpy_s(buf.get(), size + 1, str, size);

	char *ptr = nullptr, *next = buf.get();
	while ((ptr = strtok_s(next, delimiter, &next)) != nullptr)
	{
		data.push_back((*convert)(ptr));
	}

	return data;
}

} // namespace comm_util
```

`CommUtil/VectorUtil.cpp`:

```cpp
#include "VectorUtil.hpp"

namespace comm_util
{

} // namespace comm_util

```

`CommUtil/VectorUtil.hpp`:

```hpp
#pragma once
#include "CommUtil.hpp"
#include <vector>
#include <cmath>
#include <cfloat>
#include <vector>
#include <memory>

using std::vector;

namespace comm_util
{

class VectorUtil
{
public:
	template <typename Numeric>
	static Numeric GetCosA(const Numeric *v1, const Numeric *v2, const size_t length);
	template <typename Numeric>
	static Numeric GetCosA_Short(const Numeric *v1, size_t len1, const Numeric *v2, size_t len2);
	template <typename Numeric>
	static Numeric GetCosA_Long(const Numeric *v1, size_t len1, const Numeric *v2, size_t len2);
	template <typename Numeric>
	static Numeric GetCosA_First(const Numeric *v1, size_t len1, const Numeric *v2, size_t len2);

	template <typename Numeric>
	static Numeric GetLengthSqr(const Numeric *vec, const size_t length);

	template <typename Numeric>
	static Numeric GetAvg(const Numeric *vec, const size_t length);

	template <typename Numeric>
	static void Add(Numeric *v1, const size_t length, Numeric num);
	template <typename Numeric>
	static void Add(Numeric *v1, const Numeric *v2, const size_t length);
	template <typename Numeric>
	static void Sub(Numeric *v1, const Numeric *v2, const size_t length);
};


/*
Calculate vectorial angle cosine.
*/
template <typename Numeric>
Numeric VectorUtil::GetCosA(const Numeric *v1, const Numeric *v2, const size_t length)
{
	Numeric dot = 0, sum1 = 0, sum2 = 0;
	for (size_t i = 0; i < length; ++i)
	{
		dot += v1[i] * v2[i];
		sum1 += v1[i] * v1[i];
		sum2 += v2[i] * v2[i];
	}
	return ::sqrtf((dot* dot) / (sum1 * sum2));
}

/*
Calculate vectorial angle cosine. (optimal)
Length by the shorter one.
*/
template <typename Numeric>
Numeric VectorUtil::GetCosA_Short(const Numeric *v1, size_t len1, const Numeric *v2, size_t len2)
{
	if (len1 == len2)
	{
		return GetCosA(v1, v2, len1);
	}

	const Numeric *p1, *p2;
	if (len1 >= len2)
	{
		p1 = v1;
		p2 = v2;
	}
	else
	{
		p1 = v2;
		p2 = v1;
		swap(len1, len2);
	}

	Numeric max_value = FLT_MIN;
	size_t count = len1 - len2;
	for (size_t i = 0; i <= count; ++i)
	{
		Numeric value = GetCosA(p1 + i, p2, len2);
		if (max_value < value) // cos is in [-1, 1].
		{
			max_value = value;
		}
	}

	return max_value;
}

/*
Calculate vectorial angle cosine. (optimal)
Length by the longer one, and padding the shorter with longer's spare part.
*/
template <typename Numeric>
Numeric VectorUtil::GetCosA_Long(const Numeric *v1, size_t len1, const Numeric *v2, size_t len2)
{
	if (len1 == len2)
	{
		return GetCosA(v1, v2, len1);
	}

	const Numeric *p1, *p2;
	if (len1 >= len2)
	{
		p1 = v1;
		p2 = v2;
	}
	else
	{
		p1 = v2;
		p2 = v1;
		swap(len1, len2);
	}

	Numeric max_value = FLT_MIN;
	size_t count = len1 - len2;
	for (size_t k = 0; k <= count; ++k)
	{
		Numeric dot, sum1, sum2;
		Numeric tmp = 0;
		// left padding
		for (size_t i = 0; i < k; ++i)
		{
			tmp += p1[i] * p1[i];
		}
		dot = sum1 = sum2 = tmp;
		// middle
		for (size_t i = 0; i < len2; ++i)
		{
			tmp = p1[i + k];
			dot += tmp * p2[i];
			sum1 += tmp * tmp;
			sum2 += p2[i] * p2[i];
		}
		// right padding
		tmp = 0;
		for (size_t i = len2 + k; i < len1; ++i)
		{
			tmp += p1[i] * p1[i];
		}
		dot += tmp;
		sum1 += tmp;
		sum2 += tmp;
		// final calculate
		Numeric value = ::sqrtf((dot* dot) / (sum1 * sum2));
		if (max_value < value) // cos is in [-1, 1].
		{
			max_value = value;
		}
	}

	return max_value;
}

/*
Calculate vectorial angle cosine. (optimal)
Length by the first one.
*/
template <typename Numeric>
Numeric VectorUtil::GetCosA_First(const Numeric *v1, size_t len1, const Numeric *v2, size_t len2)
{
	if (len1 == len2)
		return GetCosA(v1, v2, len1);
	else if (len1 < len2)
		return GetCosA_Short(v2, len2, v1, len1);
	else
		return GetCosA_Long(v1, len1, v2, len2);
}

template <typename Numeric>
Numeric VectorUtil::GetLengthSqr(const Numeric *vec, const size_t length)
{
	double sum = 0;
	for (size_t i = 0; i < length; ++i)
	{
		sum += vec[i] * vec[i];
	}
	return sum;
}

template <typename Numeric>
Numeric VectorUtil::GetAvg(const Numeric *vec, const size_t length)
{
	Numeric avg = 0;
	for (size_t i = 0; i < length; ++i)
	{
		avg += vec[i];
	}
	if (length > 0)
	{
		avg /= length;
	}
	return avg;
}

template <typename Numeric>
void VectorUtil::Add(Numeric *v1, const size_t length, Numeric num)
{
	for (size_t i = 0; i < length; ++i)
	{
		v1[i] += num;
	}
}

template <typename Numeric>
void VectorUtil::Add(Numeric *v1, const Numeric *v2, const size_t length)
{
	for (size_t i = 0; i < length; ++i)
	{
		v1[i] += v2[i];
	}
}

template <typename Numeric>
void VectorUtil::Sub(Numeric *v1, const Numeric *v2, const size_t length)
{
	for (size_t i = 0; i < length; ++i)
	{
		v1[i] -= v2[i];
	}
}

} //namespace comm_util

```

`CommUtil/endian.h`:

```h
#pragma once

bool little_endian()
{
	const unsigned num = 0xAABBCCDD;
	return reinterpret_cast<const unsigned char*> (&num)[0] == 0xDD;
}

bool big_endian()
{
	const unsigned num = 0xAABBCCDD;
	return reinterpret_cast<const unsigned char*> (&num)[0] == 0xAA;
}

```

`DllInjecter/DLLInjecter.cpp`:

```cpp
// Win32Injecter.cpp: 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <iostream>
#include <Win32Util/Util/DLLInjecter.h>

void PrintHelp();

int main(int argc, char* argv[])
{
    if (argc != 4)
    {
        PrintHelp();
        return -1;
    }

    int pid = ::atoi(argv[1]);
    const char* dll_path = argv[2];
    bool inject = strcmp(argv[3], "true") == 0;

    bool res = false;
    if (inject)
    {
        res = DLLInjecter::Inject(pid, dll_path);
    }
    else
    {
        res = DLLInjecter::Eject(pid, dll_path);
    }

    return res ? 0 : -1;
}

void PrintHelp()
{
    std::cout << "Usage: DLLInjecter <pid> <dll_path>" << std::endl;
}


```

`DllInjecter/DllInjecter.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{FBD85DFD-8E2E-445E-99CB-03B1886BA959}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>DllInjecter</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>DLLInjecter</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <TargetName>$(ProjectName)</TargetName>
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <TargetName>$(ProjectName)</TargetName>
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Win32Util.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Win32Util.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Win32Util.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Win32Util.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="DLLInjecter.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DllInjecter/DllInjecter.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="DLLInjecter.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`DllInjecter/stdafx.cpp`:

```cpp
// stdafx.cpp : 只包括标准包含文件的源文件
// Win32Injecter.pch 将作为预编译标头
// stdafx.obj 将包含预编译类型信息

#include "stdafx.h"

// TODO: 在 STDAFX.H 中引用任何所需的附加头文件，
//而不是在此文件中引用

```

`DllInjecter/stdafx.h`:

```h
// stdafx.h : 标准系统包含文件的包含文件，
// 或是经常使用但不常更改的
// 特定于项目的包含文件
//

#pragma once

#include "targetver.h"

#include <stdio.h>
#include <tchar.h>



// TODO: 在此处引用程序需要的其他头文件

```

`DllInjecter/targetver.h`:

```h
#pragma once

// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。

// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将
// 将 _WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。

#include <SDKDDKVer.h>

```

`Intercepter/CursorIntercepter.cpp`:

```cpp
#include "stdafx.h"
#include "CursorIntercepter.h"
#include <Windows.h>
#include "Win32Util/Util/ShareMemory.h"
#include "detours/include/detours.h"


BOOL(WINAPI * pGetCursorPos)(_Out_ LPPOINT lpPoint) = GetCursorPos;
BOOL(WINAPI * pSetCursorPos)(_In_ int X, _In_ int Y) = SetCursorPos;

CursorIntercepter* CursorIntercepter::m_instance = NULL;

CursorIntercepter::CursorIntercepter(const std::string& name)
    : m_share_memory(name)
{
    m_instance = this;
}


CursorIntercepter::~CursorIntercepter()
{
}


bool CursorIntercepter::Attach()
{
    OpenLog(m_share_memory.GetName() + ".log");

    if (!m_share_memory.Create(sizeof(ShareData)))
    {
        PrintLog(std::string("[Attach] Create share memory failed, code = ").append(std::to_string(GetLastError())));
        return false;
    }

    ShareData *data = (ShareData*)m_share_memory.GetBuf();
    data->cursor_pos.x = 0;
    data->cursor_pos.y = 0;

    if (!IntercepterBase::Attach())
    {
        return false;
    }

    return true;
}


bool CursorIntercepter::Detach()
{
    IntercepterBase::Detach();

    m_share_memory.Close();

    CloseLog();

    return true;
}


bool CursorIntercepter::AttachFunctions()
{
    DetourAttach(&(PVOID&)pGetCursorPos, MyGetCursorPos);
    DetourAttach(&(PVOID&)pSetCursorPos, MySetCursorPos);
    return true;
}


bool CursorIntercepter::DetachFunctions()
{
    DetourDetach(&(PVOID&)pGetCursorPos, MyGetCursorPos);
    DetourDetach(&(PVOID&)pSetCursorPos, MySetCursorPos);
    return true;
}


bool CursorIntercepter::MyGetCursorPos(_Out_ LPPOINT lpPoint)
{
    DWORD cur_pid = GetCurrentProcessId();
    DWORD wnd_pid = 0;
    HWND hwnd = GetActiveWindow();
    GetWindowThreadProcessId(hwnd, &wnd_pid);

    if (cur_pid == wnd_pid)
    {
        return pGetCursorPos(lpPoint);
    }
    else
    {
        if (m_instance->m_share_memory.Lock())
        {
            ShareData* data = (ShareData*)m_instance->m_share_memory.GetBuf();
            *lpPoint = data->cursor_pos;
            m_instance->m_share_memory.Unlock();
        }
        else
        {
            *lpPoint = POINT();
        }
        return true;
    }
}


bool CursorIntercepter::MySetCursorPos(int x, int y)
{
    DWORD cur_pid = GetCurrentProcessId();
    DWORD wnd_pid = 0;
    HWND hwnd = GetActiveWindow();
    GetWindowThreadProcessId(hwnd, &wnd_pid);

    if (cur_pid == wnd_pid)
    {
        return pSetCursorPos(x, y);
    }
    else
    {
        // forbid SetCursorPos
        return true;
    }
}


```

`Intercepter/CursorIntercepter.h`:

```h
#pragma once
#include "IntercepterBase.h"
#include "Win32Util/Util/ShareMemory.h"
#include <Windows.h>
#include <string>

class CursorIntercepter : public IntercepterBase
{
public:
    struct ShareData
    {
        POINT cursor_pos;
    };

public:
    CursorIntercepter(const std::string& name);
    virtual ~CursorIntercepter();

    virtual bool Attach() override;
    virtual bool Detach() override;

protected:
    virtual bool AttachFunctions() override;
    virtual bool DetachFunctions() override;

    static bool MyGetCursorPos(_Out_ LPPOINT lpPoint);
    static bool MySetCursorPos(int x, int y);

private:
    ShareMemory m_share_memory;
    static CursorIntercepter* m_instance;
};


```

`Intercepter/Intercepter.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{C9695514-52DA-4E06-8A25-BE91B3346285}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>Intercepter</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);detours\lib.X86;$(LibraryPath)</LibraryPath>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <TargetName>$(ProjectName)</TargetName>
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);detours\lib.X64;$(LibraryPath)</LibraryPath>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <TargetName>$(ProjectName)</TargetName>
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);detours\lib.X86;$(LibraryPath)</LibraryPath>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <TargetName>$(ProjectName)</TargetName>
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);detours\lib.X64;$(LibraryPath)</LibraryPath>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <TargetName>$(ProjectName)</TargetName>
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;Intercepter_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>detours.lib;Win32Util.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;Intercepter_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>detours.lib;Win32Util.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;Intercepter_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>detours.lib;Win32Util.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;Intercepter_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>detours.lib;Win32Util.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="CursorIntercepter.h" />
    <ClInclude Include="IntercepterBase.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="CursorIntercepter.cpp" />
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="IntercepterBase.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Intercepter/Intercepter.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="stdafx.cpp" />
    <ClCompile Include="CursorIntercepter.cpp">
      <Filter>Intercepter</Filter>
    </ClCompile>
    <ClCompile Include="IntercepterBase.cpp">
      <Filter>Intercepter</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="CursorIntercepter.h">
      <Filter>Intercepter</Filter>
    </ClInclude>
    <ClInclude Include="IntercepterBase.h">
      <Filter>Intercepter</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Intercepter">
      <UniqueIdentifier>{cbaa26b7-c57f-4780-8f80-b78144213deb}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>
```

`Intercepter/IntercepterBase.cpp`:

```cpp
#include "stdafx.h"
#include "IntercepterBase.h"
#include "detours/include/detours.h"
#include <ctime>
#include <iomanip>


IntercepterBase::IntercepterBase()
{
}


IntercepterBase::~IntercepterBase()
{
}


bool IntercepterBase::Attach()
{
    long ret = NO_ERROR;

    PrintLog("[Attach] Attach start");

    do
    {
        ret = DetourTransactionBegin();
        if (ret != NO_ERROR)
        {
            PrintLog(std::string("[Attach] DetourTransactionBegin failed, code = ").append(std::to_string(ret)));
            break;
        }
        ret = DetourUpdateThread(GetCurrentThread());
        if (ret != NO_ERROR)
        {
            PrintLog(std::string("[Attach] DetourUpdateThread failed, code = ").append(std::to_string(ret)));
            DetourTransactionAbort();
            break;
        }
        if (!AttachFunctions())
        {
            PrintLog(std::string("[Attach] AttachFunctions failed"));
            DetourTransactionAbort();
            break;
        }
        ret = DetourTransactionCommit();
        if (ret != NO_ERROR)
        {
            PrintLog(std::string("[Attach] DetourTransactionBegin failed, code = ").append(std::to_string(ret)));
            DetourTransactionAbort();
            break;
        }

        PrintLog("[Attach] Attach success");

    } while (false);

    return ret == NO_ERROR;
}


bool IntercepterBase::Detach()
{
    long ret = NO_ERROR;

    PrintLog("[Detach] Detach start");

    do
    {
        ret = DetourTransactionBegin();
        if (ret != NO_ERROR)
        {
            PrintLog(std::string("[Detach] DetourTransactionBegin failed, code = ").append(std::to_string(ret)));
            break;
        }
        ret = DetourUpdateThread(GetCurrentThread());
        if (ret != NO_ERROR)
        {
            PrintLog(std::string("[Detach] DetourUpdateThread failed, code = ").append(std::to_string(ret)));
            DetourTransactionAbort();
            break;
        }
        if (!DetachFunctions())
        {
            PrintLog("[Detach] DetachFunctions failed");
            DetourTransactionAbort();
            break;
        }
        ret = DetourTransactionCommit();
        if (ret != NO_ERROR)
        {
            PrintLog(std::string("[Detach] DetourTransactionCommit failed, code = ").append(std::to_string(ret)));
            DetourTransactionAbort();
            break;
        }

        PrintLog("[Detach] Detach success");

    } while (false);

    return ret == NO_ERROR;
}

bool IntercepterBase::AttachFunctions()
{
    // DetourAttach(...);
    return true;
}


bool IntercepterBase::DetachFunctions()
{
    // DetourDetach(...);
    return true;
}


void IntercepterBase::OpenLog(const std::string& file)
{
    m_log_file.close();
    m_log_file.open(file, std::ios_base::app);
}

void IntercepterBase::CloseLog()
{
    m_log_file.close();
}

void IntercepterBase::PrintLog(const std::string& msg)
{
    if (m_log_file)
    {
        time_t t = ::time(NULL);
        struct tm ti;
        ::localtime_s(&ti, &t);

        m_log_file.fill('0');
        m_log_file << std::setw(2);
        m_log_file << ti.tm_year + 1900 << "-" << (ti.tm_mon + 1) << "-" << ti.tm_mday << " ";
        m_log_file << ti.tm_hour << ":" << ti.tm_min << ":" << ti.tm_sec << " ";
        m_log_file << msg.c_str() << std::endl;
    }
}

```

`Intercepter/IntercepterBase.h`:

```h
#pragma once
#include <fstream>
#include <string>

class IntercepterBase
{
public:
    IntercepterBase();
    virtual ~IntercepterBase();

    virtual bool Attach();
    virtual bool Detach();

protected:
    virtual bool AttachFunctions();
    virtual bool DetachFunctions();

    virtual void OpenLog(const std::string& file);
    virtual void CloseLog();
    virtual void PrintLog(const std::string& msg);

protected:
    std::fstream m_log_file;
};


```

`Intercepter/detours/include/detours.h`:

```h
/////////////////////////////////////////////////////////////////////////////
//
//  Core Detours Functionality (detours.h of detours.lib)
//
//  Microsoft Research Detours Package, Version 4.0.1
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#pragma once
#ifndef _DETOURS_H_
#define _DETOURS_H_

#define DETOURS_VERSION     0x4c0c1   // 0xMAJORcMINORcPATCH

//////////////////////////////////////////////////////////////////////////////
//

#ifdef DETOURS_INTERNAL

#define _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS 1
#define _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE 1

#pragma warning(disable:4068) // unknown pragma (suppress)

#if _MSC_VER >= 1900
#pragma warning(push)
#pragma warning(disable:4091) // empty typedef
#endif

// Suppress declspec(dllimport) for the sake of Detours
// users that provide kernel32 functionality themselves.
// This is ok in the mainstream case, it will just cost
// an extra instruction calling some functions, which
// LTCG optimizes away.
//
#define _KERNEL32_ 1
#define _USER32_ 1

#include <windows.h>
#if (_MSC_VER < 1310)
#else
#pragma warning(push)
#if _MSC_VER > 1400
#pragma warning(disable:6102 6103) // /analyze warnings
#endif
#include <strsafe.h>
#pragma warning(pop)
#endif

// From winerror.h, as this error isn't found in some SDKs:
//
// MessageId: ERROR_DYNAMIC_CODE_BLOCKED
//
// MessageText:
//
// The operation was blocked as the process prohibits dynamic code generation.
//
#define ERROR_DYNAMIC_CODE_BLOCKED       1655L

#endif // DETOURS_INTERNAL

//////////////////////////////////////////////////////////////////////////////
//

#undef DETOURS_X64
#undef DETOURS_X86
#undef DETOURS_IA64
#undef DETOURS_ARM
#undef DETOURS_ARM64
#undef DETOURS_BITS
#undef DETOURS_32BIT
#undef DETOURS_64BIT

#if defined(_X86_)
#define DETOURS_X86
#define DETOURS_OPTION_BITS 64

#elif defined(_AMD64_)
#define DETOURS_X64
#define DETOURS_OPTION_BITS 32

#elif defined(_IA64_)
#define DETOURS_IA64
#define DETOURS_OPTION_BITS 32

#elif defined(_ARM_)
#define DETOURS_ARM

#elif defined(_ARM64_)
#define DETOURS_ARM64

#else
#error Unknown architecture (x86, amd64, ia64, arm, arm64)
#endif

#ifdef _WIN64
#undef DETOURS_32BIT
#define DETOURS_64BIT 1
#define DETOURS_BITS 64
// If all 64bit kernels can run one and only one 32bit architecture.
//#define DETOURS_OPTION_BITS 32
#else
#define DETOURS_32BIT 1
#undef DETOURS_64BIT
#define DETOURS_BITS 32
// If all 64bit kernels can run one and only one 32bit architecture.
//#define DETOURS_OPTION_BITS 32
#endif

/////////////////////////////////////////////////////////////// Helper Macros.
//
#define DETOURS_STRINGIFY_(x)    #x
#define DETOURS_STRINGIFY(x)    DETOURS_STRINGIFY_(x)

#define VER_DETOURS_BITS    DETOURS_STRINGIFY(DETOURS_BITS)

//////////////////////////////////////////////////////////////////////////////
//

#if (_MSC_VER < 1299)
typedef LONG LONG_PTR;
typedef ULONG ULONG_PTR;
#endif

///////////////////////////////////////////////// SAL 2.0 Annotations w/o SAL.
//
//  These definitions are include so that Detours will build even if the
//  compiler doesn't have full SAL 2.0 support.
//
#ifndef DETOURS_DONT_REMOVE_SAL_20

#ifdef DETOURS_TEST_REMOVE_SAL_20
#undef _Analysis_assume_
#undef _Benign_race_begin_
#undef _Benign_race_end_
#undef _Field_range_
#undef _Field_size_
#undef _In_
#undef _In_bytecount_
#undef _In_count_
#undef __in_ecount
#undef _In_opt_
#undef _In_opt_bytecount_
#undef _In_opt_count_
#undef _In_opt_z_
#undef _In_range_
#undef _In_reads_
#undef _In_reads_bytes_
#undef _In_reads_opt_
#undef _In_reads_opt_bytes_
#undef _In_reads_or_z_
#undef _In_z_
#undef _Inout_
#undef _Inout_opt_
#undef _Inout_z_count_
#undef _Out_
#undef _Out_opt_
#undef _Out_writes_
#undef _Outptr_result_maybenull_
#undef _Readable_bytes_
#undef _Success_
#undef _Writable_bytes_
#undef _Pre_notnull_
#endif

#if defined(_Deref_out_opt_z_) && !defined(_Outptr_result_maybenull_)
#define _Outptr_result_maybenull_ _Deref_out_opt_z_
#endif

#if defined(_In_count_) && !defined(_In_reads_)
#define _In_reads_(x) _In_count_(x)
#endif

#if defined(_In_opt_count_) && !defined(_In_reads_opt_)
#define _In_reads_opt_(x) _In_opt_count_(x)
#endif

#if defined(_In_opt_bytecount_) && !defined(_In_reads_opt_bytes_)
#define _In_reads_opt_bytes_(x) _In_opt_bytecount_(x)
#endif

#if defined(_In_bytecount_) && !defined(_In_reads_bytes_)
#define _In_reads_bytes_(x) _In_bytecount_(x)
#endif

#ifndef _In_
#define _In_
#endif

#ifndef _In_bytecount_
#define _In_bytecount_(x)
#endif

#ifndef _In_count_
#define _In_count_(x)
#endif

#ifndef __in_ecount
#define __in_ecount(x)
#endif

#ifndef _In_opt_
#define _In_opt_
#endif

#ifndef _In_opt_bytecount_
#define _In_opt_bytecount_(x)
#endif

#ifndef _In_opt_count_
#define _In_opt_count_(x)
#endif

#ifndef _In_opt_z_
#define _In_opt_z_
#endif

#ifndef _In_range_
#define _In_range_(x,y)
#endif

#ifndef _In_reads_
#define _In_reads_(x)
#endif

#ifndef _In_reads_bytes_
#define _In_reads_bytes_(x)
#endif

#ifndef _In_reads_opt_
#define _In_reads_opt_(x)
#endif

#ifndef _In_reads_opt_bytes_
#define _In_reads_opt_bytes_(x)
#endif

#ifndef _In_reads_or_z_
#define _In_reads_or_z_
#endif

#ifndef _In_z_
#define _In_z_
#endif

#ifndef _Inout_
#define _Inout_
#endif

#ifndef _Inout_opt_
#define _Inout_opt_
#endif

#ifndef _Inout_z_count_
#define _Inout_z_count_(x)
#endif

#ifndef _Out_
#define _Out_
#endif

#ifndef _Out_opt_
#define _Out_opt_
#endif

#ifndef _Out_writes_
#define _Out_writes_(x)
#endif

#ifndef _Outptr_result_maybenull_
#define _Outptr_result_maybenull_
#endif

#ifndef _Writable_bytes_
#define _Writable_bytes_(x)
#endif

#ifndef _Readable_bytes_
#define _Readable_bytes_(x)
#endif

#ifndef _Success_
#define _Success_(x)
#endif

#ifndef _Pre_notnull_
#define _Pre_notnull_
#endif

#ifdef DETOURS_INTERNAL

#pragma warning(disable:4615) // unknown warning type (suppress with older compilers)

#ifndef _Benign_race_begin_
#define _Benign_race_begin_
#endif

#ifndef _Benign_race_end_
#define _Benign_race_end_
#endif

#ifndef _Field_size_
#define _Field_size_(x)
#endif

#ifndef _Field_range_
#define _Field_range_(x,y)
#endif

#ifndef _Analysis_assume_
#define _Analysis_assume_(x)
#endif

#endif // DETOURS_INTERNAL
#endif // DETOURS_DONT_REMOVE_SAL_20

//////////////////////////////////////////////////////////////////////////////
//
#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct  _GUID
{
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
} GUID;

#ifdef INITGUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#else
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    const GUID name
#endif // INITGUID
#endif // !GUID_DEFINED

#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#endif // !__cplusplus

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#endif

//
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/////////////////////////////////////////////////// Instruction Target Macros.
//
#define DETOUR_INSTRUCTION_TARGET_NONE          ((PVOID)0)
#define DETOUR_INSTRUCTION_TARGET_DYNAMIC       ((PVOID)(LONG_PTR)-1)
#define DETOUR_SECTION_HEADER_SIGNATURE         0x00727444   // "Dtr\0"

extern const GUID DETOUR_EXE_RESTORE_GUID;
extern const GUID DETOUR_EXE_HELPER_GUID;

#define DETOUR_TRAMPOLINE_SIGNATURE             0x21727444  // Dtr!
typedef struct _DETOUR_TRAMPOLINE DETOUR_TRAMPOLINE, *PDETOUR_TRAMPOLINE;

/////////////////////////////////////////////////////////// Binary Structures.
//
#pragma pack(push, 8)
typedef struct _DETOUR_SECTION_HEADER
{
    DWORD       cbHeaderSize;
    DWORD       nSignature;
    DWORD       nDataOffset;
    DWORD       cbDataSize;

    DWORD       nOriginalImportVirtualAddress;
    DWORD       nOriginalImportSize;
    DWORD       nOriginalBoundImportVirtualAddress;
    DWORD       nOriginalBoundImportSize;

    DWORD       nOriginalIatVirtualAddress;
    DWORD       nOriginalIatSize;
    DWORD       nOriginalSizeOfImage;
    DWORD       cbPrePE;

    DWORD       nOriginalClrFlags;
    DWORD       reserved1;
    DWORD       reserved2;
    DWORD       reserved3;

    // Followed by cbPrePE bytes of data.
} DETOUR_SECTION_HEADER, *PDETOUR_SECTION_HEADER;

typedef struct _DETOUR_SECTION_RECORD
{
    DWORD       cbBytes;
    DWORD       nReserved;
    GUID        guid;
} DETOUR_SECTION_RECORD, *PDETOUR_SECTION_RECORD;

typedef struct _DETOUR_CLR_HEADER
{
    // Header versioning
    ULONG                   cb;
    USHORT                  MajorRuntimeVersion;
    USHORT                  MinorRuntimeVersion;

    // Symbol table and startup information
    IMAGE_DATA_DIRECTORY    MetaData;
    ULONG                   Flags;

    // Followed by the rest of the IMAGE_COR20_HEADER
} DETOUR_CLR_HEADER, *PDETOUR_CLR_HEADER;

typedef struct _DETOUR_EXE_RESTORE
{
    DWORD               cb;
    DWORD               cbidh;
    DWORD               cbinh;
    DWORD               cbclr;

    PBYTE               pidh;
    PBYTE               pinh;
    PBYTE               pclr;

    IMAGE_DOS_HEADER    idh;
    union {
        IMAGE_NT_HEADERS    inh;        // all environments have this
#ifdef IMAGE_NT_OPTIONAL_HDR32_MAGIC    // some environments do not have this
        IMAGE_NT_HEADERS32  inh32;
#endif
#ifdef IMAGE_NT_OPTIONAL_HDR64_MAGIC    // some environments do not have this
        IMAGE_NT_HEADERS64  inh64;
#endif
#ifdef IMAGE_NT_OPTIONAL_HDR64_MAGIC    // some environments do not have this
        BYTE                raw[sizeof(IMAGE_NT_HEADERS64) +
                                sizeof(IMAGE_SECTION_HEADER) * 32];
#else
        BYTE                raw[0x108 + sizeof(IMAGE_SECTION_HEADER) * 32];
#endif
    };
    DETOUR_CLR_HEADER   clr;

} DETOUR_EXE_RESTORE, *PDETOUR_EXE_RESTORE;

#ifdef IMAGE_NT_OPTIONAL_HDR64_MAGIC
C_ASSERT(sizeof(IMAGE_NT_HEADERS64) == 0x108);
#endif

// The size can change, but assert for clarity due to the muddying #ifdefs.
#ifdef _WIN64
C_ASSERT(sizeof(DETOUR_EXE_RESTORE) == 0x688);
#else
C_ASSERT(sizeof(DETOUR_EXE_RESTORE) == 0x678);
#endif

typedef struct _DETOUR_EXE_HELPER
{
    DWORD               cb;
    DWORD               pid;
    DWORD               nDlls;
    CHAR                rDlls[4];
} DETOUR_EXE_HELPER, *PDETOUR_EXE_HELPER;

#pragma pack(pop)

#define DETOUR_SECTION_HEADER_DECLARE(cbSectionSize) \
{ \
      sizeof(DETOUR_SECTION_HEADER),\
      DETOUR_SECTION_HEADER_SIGNATURE,\
      sizeof(DETOUR_SECTION_HEADER),\
      (cbSectionSize),\
      \
      0,\
      0,\
      0,\
      0,\
      \
      0,\
      0,\
      0,\
      0,\
}

///////////////////////////////////////////////////////////// Binary Typedefs.
//
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_BYWAY_CALLBACK)(
    _In_opt_ PVOID pContext,
    _In_opt_ LPCSTR pszFile,
    _Outptr_result_maybenull_ LPCSTR *ppszOutFile);

typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FILE_CALLBACK)(
    _In_opt_ PVOID pContext,
    _In_ LPCSTR pszOrigFile,
    _In_ LPCSTR pszFile,
    _Outptr_result_maybenull_ LPCSTR *ppszOutFile);

typedef BOOL (CALLBACK *PF_DETOUR_BINARY_SYMBOL_CALLBACK)(
    _In_opt_ PVOID pContext,
    _In_ ULONG nOrigOrdinal,
    _In_ ULONG nOrdinal,
    _Out_ ULONG *pnOutOrdinal,
    _In_opt_ LPCSTR pszOrigSymbol,
    _In_opt_ LPCSTR pszSymbol,
    _Outptr_result_maybenull_ LPCSTR *ppszOutSymbol);

typedef BOOL (CALLBACK *PF_DETOUR_BINARY_COMMIT_CALLBACK)(
    _In_opt_ PVOID pContext);

typedef BOOL (CALLBACK *PF_DETOUR_ENUMERATE_EXPORT_CALLBACK)(_In_opt_ PVOID pContext,
                                                             _In_ ULONG nOrdinal,
                                                             _In_opt_ LPCSTR pszName,
                                                             _In_opt_ PVOID pCode);

typedef BOOL (CALLBACK *PF_DETOUR_IMPORT_FILE_CALLBACK)(_In_opt_ PVOID pContext,
                                                        _In_opt_ HMODULE hModule,
                                                        _In_opt_ LPCSTR pszFile);

typedef BOOL (CALLBACK *PF_DETOUR_IMPORT_FUNC_CALLBACK)(_In_opt_ PVOID pContext,
                                                        _In_ DWORD nOrdinal,
                                                        _In_opt_ LPCSTR pszFunc,
                                                        _In_opt_ PVOID pvFunc);

// Same as PF_DETOUR_IMPORT_FUNC_CALLBACK but extra indirection on last parameter.
typedef BOOL (CALLBACK *PF_DETOUR_IMPORT_FUNC_CALLBACK_EX)(_In_opt_ PVOID pContext,
                                                           _In_ DWORD nOrdinal,
                                                           _In_opt_ LPCSTR pszFunc,
                                                           _In_opt_ PVOID* ppvFunc);

typedef VOID * PDETOUR_BINARY;
typedef VOID * PDETOUR_LOADED_BINARY;

//////////////////////////////////////////////////////////// Transaction APIs.
//
LONG WINAPI DetourTransactionBegin(VOID);
LONG WINAPI DetourTransactionAbort(VOID);
LONG WINAPI DetourTransactionCommit(VOID);
LONG WINAPI DetourTransactionCommitEx(_Out_opt_ PVOID **pppFailedPointer);

LONG WINAPI DetourUpdateThread(_In_ HANDLE hThread);

LONG WINAPI DetourAttach(_Inout_ PVOID *ppPointer,
                         _In_ PVOID pDetour);

LONG WINAPI DetourAttachEx(_Inout_ PVOID *ppPointer,
                           _In_ PVOID pDetour,
                           _Out_opt_ PDETOUR_TRAMPOLINE *ppRealTrampoline,
                           _Out_opt_ PVOID *ppRealTarget,
                           _Out_opt_ PVOID *ppRealDetour);

LONG WINAPI DetourDetach(_Inout_ PVOID *ppPointer,
                         _In_ PVOID pDetour);

BOOL WINAPI DetourSetIgnoreTooSmall(_In_ BOOL fIgnore);
BOOL WINAPI DetourSetRetainRegions(_In_ BOOL fRetain);
PVOID WINAPI DetourSetSystemRegionLowerBound(_In_ PVOID pSystemRegionLowerBound);
PVOID WINAPI DetourSetSystemRegionUpperBound(_In_ PVOID pSystemRegionUpperBound);

////////////////////////////////////////////////////////////// Code Functions.
//
PVOID WINAPI DetourFindFunction(_In_ LPCSTR pszModule,
                                _In_ LPCSTR pszFunction);
PVOID WINAPI DetourCodeFromPointer(_In_ PVOID pPointer,
                                   _Out_opt_ PVOID *ppGlobals);
PVOID WINAPI DetourCopyInstruction(_In_opt_ PVOID pDst,
                                   _Inout_opt_ PVOID *ppDstPool,
                                   _In_ PVOID pSrc,
                                   _Out_opt_ PVOID *ppTarget,
                                   _Out_opt_ LONG *plExtra);
BOOL WINAPI DetourSetCodeModule(_In_ HMODULE hModule,
                                _In_ BOOL fLimitReferencesToModule);
PVOID WINAPI DetourAllocateRegionWithinJumpBounds(_In_ LPCVOID pbTarget,
                                                  _Out_ PDWORD pcbAllocatedSize);

///////////////////////////////////////////////////// Loaded Binary Functions.
//
HMODULE WINAPI DetourGetContainingModule(_In_ PVOID pvAddr);
HMODULE WINAPI DetourEnumerateModules(_In_opt_ HMODULE hModuleLast);
PVOID WINAPI DetourGetEntryPoint(_In_opt_ HMODULE hModule);
ULONG WINAPI DetourGetModuleSize(_In_opt_ HMODULE hModule);
BOOL WINAPI DetourEnumerateExports(_In_ HMODULE hModule,
                                   _In_opt_ PVOID pContext,
                                   _In_ PF_DETOUR_ENUMERATE_EXPORT_CALLBACK pfExport);
BOOL WINAPI DetourEnumerateImports(_In_opt_ HMODULE hModule,
                                   _In_opt_ PVOID pContext,
                                   _In_opt_ PF_DETOUR_IMPORT_FILE_CALLBACK pfImportFile,
                                   _In_opt_ PF_DETOUR_IMPORT_FUNC_CALLBACK pfImportFunc);

BOOL WINAPI DetourEnumerateImportsEx(_In_opt_ HMODULE hModule,
                                     _In_opt_ PVOID pContext,
                                     _In_opt_ PF_DETOUR_IMPORT_FILE_CALLBACK pfImportFile,
                                     _In_opt_ PF_DETOUR_IMPORT_FUNC_CALLBACK_EX pfImportFuncEx);

_Writable_bytes_(*pcbData)
_Readable_bytes_(*pcbData)
_Success_(return != NULL)
PVOID WINAPI DetourFindPayload(_In_opt_ HMODULE hModule,
                               _In_ REFGUID rguid,
                               _Out_ DWORD *pcbData);

_Writable_bytes_(*pcbData)
_Readable_bytes_(*pcbData)
_Success_(return != NULL)
PVOID WINAPI DetourFindPayloadEx(_In_ REFGUID rguid,
                                 _Out_ DWORD * pcbData);

DWORD WINAPI DetourGetSizeOfPayloads(_In_opt_ HMODULE hModule);

///////////////////////////////////////////////// Persistent Binary Functions.
//

PDETOUR_BINARY WINAPI DetourBinaryOpen(_In_ HANDLE hFile);

_Writable_bytes_(*pcbData)
_Readable_bytes_(*pcbData)
_Success_(return != NULL)
PVOID WINAPI DetourBinaryEnumeratePayloads(_In_ PDETOUR_BINARY pBinary,
                                           _Out_opt_ GUID *pGuid,
                                           _Out_ DWORD *pcbData,
                                           _Inout_ DWORD *pnIterator);

_Writable_bytes_(*pcbData)
_Readable_bytes_(*pcbData)
_Success_(return != NULL)
PVOID WINAPI DetourBinaryFindPayload(_In_ PDETOUR_BINARY pBinary,
                                     _In_ REFGUID rguid,
                                     _Out_ DWORD *pcbData);

PVOID WINAPI DetourBinarySetPayload(_In_ PDETOUR_BINARY pBinary,
                                    _In_ REFGUID rguid,
                                    _In_reads_opt_(cbData) PVOID pData,
                                    _In_ DWORD cbData);
BOOL WINAPI DetourBinaryDeletePayload(_In_ PDETOUR_BINARY pBinary, _In_ REFGUID rguid);
BOOL WINAPI DetourBinaryPurgePayloads(_In_ PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryResetImports(_In_ PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryEditImports(_In_ PDETOUR_BINARY pBinary,
                                    _In_opt_ PVOID pContext,
                                    _In_opt_ PF_DETOUR_BINARY_BYWAY_CALLBACK pfByway,
                                    _In_opt_ PF_DETOUR_BINARY_FILE_CALLBACK pfFile,
                                    _In_opt_ PF_DETOUR_BINARY_SYMBOL_CALLBACK pfSymbol,
                                    _In_opt_ PF_DETOUR_BINARY_COMMIT_CALLBACK pfCommit);
BOOL WINAPI DetourBinaryWrite(_In_ PDETOUR_BINARY pBinary, _In_ HANDLE hFile);
BOOL WINAPI DetourBinaryClose(_In_ PDETOUR_BINARY pBinary);

/////////////////////////////////////////////////// Create Process & Load Dll.
//
typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEA)(
    _In_opt_ LPCSTR lpApplicationName,
    _Inout_opt_ LPSTR lpCommandLine,
    _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
    _In_ BOOL bInheritHandles,
    _In_ DWORD dwCreationFlags,
    _In_opt_ LPVOID lpEnvironment,
    _In_opt_ LPCSTR lpCurrentDirectory,
    _In_ LPSTARTUPINFOA lpStartupInfo,
    _Out_ LPPROCESS_INFORMATION lpProcessInformation);

typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEW)(
    _In_opt_ LPCWSTR lpApplicationName,
    _Inout_opt_ LPWSTR lpCommandLine,
    _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
    _In_ BOOL bInheritHandles,
    _In_ DWORD dwCreationFlags,
    _In_opt_ LPVOID lpEnvironment,
    _In_opt_ LPCWSTR lpCurrentDirectory,
    _In_ LPSTARTUPINFOW lpStartupInfo,
    _Out_ LPPROCESS_INFORMATION lpProcessInformation);

BOOL WINAPI DetourCreateProcessWithDllA(_In_opt_ LPCSTR lpApplicationName,
                                        _Inout_opt_ LPSTR lpCommandLine,
                                        _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        _In_ BOOL bInheritHandles,
                                        _In_ DWORD dwCreationFlags,
                                        _In_opt_ LPVOID lpEnvironment,
                                        _In_opt_ LPCSTR lpCurrentDirectory,
                                        _In_ LPSTARTUPINFOA lpStartupInfo,
                                        _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                        _In_ LPCSTR lpDllName,
                                        _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);

BOOL WINAPI DetourCreateProcessWithDllW(_In_opt_ LPCWSTR lpApplicationName,
                                        _Inout_opt_ LPWSTR lpCommandLine,
                                        _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        _In_ BOOL bInheritHandles,
                                        _In_ DWORD dwCreationFlags,
                                        _In_opt_ LPVOID lpEnvironment,
                                        _In_opt_ LPCWSTR lpCurrentDirectory,
                                        _In_ LPSTARTUPINFOW lpStartupInfo,
                                        _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                        _In_ LPCSTR lpDllName,
                                        _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);

#ifdef UNICODE
#define DetourCreateProcessWithDll      DetourCreateProcessWithDllW
#define PDETOUR_CREATE_PROCESS_ROUTINE  PDETOUR_CREATE_PROCESS_ROUTINEW
#else
#define DetourCreateProcessWithDll      DetourCreateProcessWithDllA
#define PDETOUR_CREATE_PROCESS_ROUTINE  PDETOUR_CREATE_PROCESS_ROUTINEA
#endif // !UNICODE

BOOL WINAPI DetourCreateProcessWithDllExA(_In_opt_ LPCSTR lpApplicationName,
                                          _Inout_opt_ LPSTR lpCommandLine,
                                          _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                          _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                          _In_ BOOL bInheritHandles,
                                          _In_ DWORD dwCreationFlags,
                                          _In_opt_ LPVOID lpEnvironment,
                                          _In_opt_ LPCSTR lpCurrentDirectory,
                                          _In_ LPSTARTUPINFOA lpStartupInfo,
                                          _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                          _In_ LPCSTR lpDllName,
                                          _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);

BOOL WINAPI DetourCreateProcessWithDllExW(_In_opt_ LPCWSTR lpApplicationName,
                                          _Inout_opt_  LPWSTR lpCommandLine,
                                          _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                          _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                          _In_ BOOL bInheritHandles,
                                          _In_ DWORD dwCreationFlags,
                                          _In_opt_ LPVOID lpEnvironment,
                                          _In_opt_ LPCWSTR lpCurrentDirectory,
                                          _In_ LPSTARTUPINFOW lpStartupInfo,
                                          _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                          _In_ LPCSTR lpDllName,
                                          _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);

#ifdef UNICODE
#define DetourCreateProcessWithDllEx    DetourCreateProcessWithDllExW
#else
#define DetourCreateProcessWithDllEx    DetourCreateProcessWithDllExA
#endif // !UNICODE

BOOL WINAPI DetourCreateProcessWithDllsA(_In_opt_ LPCSTR lpApplicationName,
                                         _Inout_opt_ LPSTR lpCommandLine,
                                         _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                         _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                         _In_ BOOL bInheritHandles,
                                         _In_ DWORD dwCreationFlags,
                                         _In_opt_ LPVOID lpEnvironment,
                                         _In_opt_ LPCSTR lpCurrentDirectory,
                                         _In_ LPSTARTUPINFOA lpStartupInfo,
                                         _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                         _In_ DWORD nDlls,
                                         _In_reads_(nDlls) LPCSTR *rlpDlls,
                                         _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);

BOOL WINAPI DetourCreateProcessWithDllsW(_In_opt_ LPCWSTR lpApplicationName,
                                         _Inout_opt_ LPWSTR lpCommandLine,
                                         _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                         _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                         _In_ BOOL bInheritHandles,
                                         _In_ DWORD dwCreationFlags,
                                         _In_opt_ LPVOID lpEnvironment,
                                         _In_opt_ LPCWSTR lpCurrentDirectory,
                                         _In_ LPSTARTUPINFOW lpStartupInfo,
                                         _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                         _In_ DWORD nDlls,
                                         _In_reads_(nDlls) LPCSTR *rlpDlls,
                                         _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);

#ifdef UNICODE
#define DetourCreateProcessWithDlls     DetourCreateProcessWithDllsW
#else
#define DetourCreateProcessWithDlls     DetourCreateProcessWithDllsA
#endif // !UNICODE

BOOL WINAPI DetourProcessViaHelperA(_In_ DWORD dwTargetPid,
                                    _In_ LPCSTR lpDllName,
                                    _In_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);

BOOL WINAPI DetourProcessViaHelperW(_In_ DWORD dwTargetPid,
                                    _In_ LPCSTR lpDllName,
                                    _In_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);

#ifdef UNICODE
#define DetourProcessViaHelper          DetourProcessViaHelperW
#else
#define DetourProcessViaHelper          DetourProcessViaHelperA
#endif // !UNICODE

BOOL WINAPI DetourProcessViaHelperDllsA(_In_ DWORD dwTargetPid,
                                        _In_ DWORD nDlls,
                                        _In_reads_(nDlls) LPCSTR *rlpDlls,
                                        _In_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);

BOOL WINAPI DetourProcessViaHelperDllsW(_In_ DWORD dwTargetPid,
                                        _In_ DWORD nDlls,
                                        _In_reads_(nDlls) LPCSTR *rlpDlls,
                                        _In_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);

#ifdef UNICODE
#define DetourProcessViaHelperDlls      DetourProcessViaHelperDllsW
#else
#define DetourProcessViaHelperDlls      DetourProcessViaHelperDllsA
#endif // !UNICODE

BOOL WINAPI DetourUpdateProcessWithDll(_In_ HANDLE hProcess,
                                       _In_reads_(nDlls) LPCSTR *rlpDlls,
                                       _In_ DWORD nDlls);

BOOL WINAPI DetourUpdateProcessWithDllEx(_In_ HANDLE hProcess,
                                         _In_ HMODULE hImage,
                                         _In_ BOOL bIs32Bit,
                                         _In_reads_(nDlls) LPCSTR *rlpDlls,
                                         _In_ DWORD nDlls);

BOOL WINAPI DetourCopyPayloadToProcess(_In_ HANDLE hProcess,
                                       _In_ REFGUID rguid,
                                       _In_reads_bytes_(cbData) PVOID pvData,
                                       _In_ DWORD cbData);
BOOL WINAPI DetourRestoreAfterWith(VOID);
BOOL WINAPI DetourRestoreAfterWithEx(_In_reads_bytes_(cbData) PVOID pvData,
                                     _In_ DWORD cbData);
BOOL WINAPI DetourIsHelperProcess(VOID);
VOID CALLBACK DetourFinishHelperProcess(_In_ HWND,
                                        _In_ HINSTANCE,
                                        _In_ LPSTR,
                                        _In_ INT);

//
//////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif // __cplusplus

//////////////////////////////////////////////// Detours Internal Definitions.
//
#ifdef __cplusplus
#ifdef DETOURS_INTERNAL

#define NOTHROW
// #define NOTHROW (nothrow)

//////////////////////////////////////////////////////////////////////////////
//
#if (_MSC_VER < 1299)
#include <imagehlp.h>
typedef IMAGEHLP_MODULE IMAGEHLP_MODULE64;
typedef PIMAGEHLP_MODULE PIMAGEHLP_MODULE64;
typedef IMAGEHLP_SYMBOL SYMBOL_INFO;
typedef PIMAGEHLP_SYMBOL PSYMBOL_INFO;

static inline
LONG InterlockedCompareExchange(_Inout_ LONG *ptr, _In_ LONG nval, _In_ LONG oval)
{
    return (LONG)::InterlockedCompareExchange((PVOID*)ptr, (PVOID)nval, (PVOID)oval);
}
#else
#pragma warning(push)
#pragma warning(disable:4091) // empty typedef
#include <dbghelp.h>
#pragma warning(pop)
#endif

#ifdef IMAGEAPI // defined by DBGHELP.H
typedef LPAPI_VERSION (NTAPI *PF_ImagehlpApiVersionEx)(_In_ LPAPI_VERSION AppVersion);

typedef BOOL (NTAPI *PF_SymInitialize)(_In_ HANDLE hProcess,
                                       _In_opt_ LPCSTR UserSearchPath,
                                       _In_ BOOL fInvadeProcess);
typedef DWORD (NTAPI *PF_SymSetOptions)(_In_ DWORD SymOptions);
typedef DWORD (NTAPI *PF_SymGetOptions)(VOID);
typedef DWORD64 (NTAPI *PF_SymLoadModule64)(_In_ HANDLE hProcess,
                                            _In_opt_ HANDLE hFile,
                                            _In_ LPSTR ImageName,
                                            _In_opt_ LPSTR ModuleName,
                                            _In_ DWORD64 BaseOfDll,
                                            _In_opt_ DWORD SizeOfDll);
typedef BOOL (NTAPI *PF_SymGetModuleInfo64)(_In_ HANDLE hProcess,
                                            _In_ DWORD64 qwAddr,
                                            _Out_ PIMAGEHLP_MODULE64 ModuleInfo);
typedef BOOL (NTAPI *PF_SymFromName)(_In_ HANDLE hProcess,
                                     _In_ LPSTR Name,
                                     _Out_ PSYMBOL_INFO Symbol);

typedef struct _DETOUR_SYM_INFO
{
    HANDLE                  hProcess;
    HMODULE                 hDbgHelp;
    PF_ImagehlpApiVersionEx pfImagehlpApiVersionEx;
    PF_SymInitialize        pfSymInitialize;
    PF_SymSetOptions        pfSymSetOptions;
    PF_SymGetOptions        pfSymGetOptions;
    PF_SymLoadModule64      pfSymLoadModule64;
    PF_SymGetModuleInfo64   pfSymGetModuleInfo64;
    PF_SymFromName          pfSymFromName;
} DETOUR_SYM_INFO, *PDETOUR_SYM_INFO;

PDETOUR_SYM_INFO DetourLoadImageHlp(VOID);

#endif // IMAGEAPI

#if defined(_INC_STDIO) && !defined(_CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS)
#error detours.h must be included before stdio.h (or at least define _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS earlier)
#endif
#define _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS 1

#ifndef DETOUR_TRACE
#if DETOUR_DEBUG
#define DETOUR_TRACE(x) printf x
#define DETOUR_BREAK()  __debugbreak()
#include <stdio.h>
#include <limits.h>
#else
#define DETOUR_TRACE(x)
#define DETOUR_BREAK()
#endif
#endif

#if 1 || defined(DETOURS_IA64)

//
// IA64 instructions are 41 bits, 3 per bundle, plus 5 bit bundle template => 128 bits per bundle.
//

#define DETOUR_IA64_INSTRUCTIONS_PER_BUNDLE (3)

#define DETOUR_IA64_TEMPLATE_OFFSET (0)
#define DETOUR_IA64_TEMPLATE_SIZE   (5)

#define DETOUR_IA64_INSTRUCTION_SIZE (41)
#define DETOUR_IA64_INSTRUCTION0_OFFSET (DETOUR_IA64_TEMPLATE_SIZE)
#define DETOUR_IA64_INSTRUCTION1_OFFSET (DETOUR_IA64_TEMPLATE_SIZE + DETOUR_IA64_INSTRUCTION_SIZE)
#define DETOUR_IA64_INSTRUCTION2_OFFSET (DETOUR_IA64_TEMPLATE_SIZE + DETOUR_IA64_INSTRUCTION_SIZE + DETOUR_IA64_INSTRUCTION_SIZE)

C_ASSERT(DETOUR_IA64_TEMPLATE_SIZE + DETOUR_IA64_INSTRUCTIONS_PER_BUNDLE * DETOUR_IA64_INSTRUCTION_SIZE == 128);

__declspec(align(16)) struct DETOUR_IA64_BUNDLE
{
  public:
    union
    {
        BYTE    data[16];
        UINT64  wide[2];
    };

    enum {
        A_UNIT  = 1u,
        I_UNIT  = 2u,
        M_UNIT  = 3u,
        B_UNIT  = 4u,
        F_UNIT  = 5u,
        L_UNIT  = 6u,
        X_UNIT  = 7u,
    };
    struct DETOUR_IA64_METADATA
    {
        ULONG       nTemplate       : 8;    // Instruction template.
        ULONG       nUnit0          : 4;    // Unit for slot 0
        ULONG       nUnit1          : 4;    // Unit for slot 1
        ULONG       nUnit2          : 4;    // Unit for slot 2
    };

  protected:
    static const DETOUR_IA64_METADATA s_rceCopyTable[33];

    UINT RelocateBundle(_Inout_ DETOUR_IA64_BUNDLE* pDst, _Inout_opt_ DETOUR_IA64_BUNDLE* pBundleExtra) const;

    bool RelocateInstruction(_Inout_ DETOUR_IA64_BUNDLE* pDst,
                             _In_ BYTE slot,
                             _Inout_opt_ DETOUR_IA64_BUNDLE* pBundleExtra) const;

    // 120 112 104 96 88 80 72 64 56 48 40 32 24 16  8  0
    //  f.  e.  d. c. b. a. 9. 8. 7. 6. 5. 4. 3. 2. 1. 0.

    //                                      00
    // f.e. d.c. b.a. 9.8. 7.6. 5.4. 3.2. 1.0.
    // 0000 0000 0000 0000 0000 0000 0000 001f : Template [4..0]
    // 0000 0000 0000 0000 0000 03ff ffff ffe0 : Zero [ 41..  5]
    // 0000 0000 0000 0000 0000 3c00 0000 0000 : Zero [ 45.. 42]
    // 0000 0000 0007 ffff ffff c000 0000 0000 : One  [ 82.. 46]
    // 0000 0000 0078 0000 0000 0000 0000 0000 : One  [ 86.. 83]
    // 0fff ffff ff80 0000 0000 0000 0000 0000 : Two  [123.. 87]
    // f000 0000 0000 0000 0000 0000 0000 0000 : Two  [127..124]
    BYTE    GetTemplate() const;
    // Get 4 bit opcodes.
    BYTE    GetInst0() const;
    BYTE    GetInst1() const;
    BYTE    GetInst2() const;
    BYTE    GetUnit(BYTE slot) const;
    BYTE    GetUnit0() const;
    BYTE    GetUnit1() const;
    BYTE    GetUnit2() const;
    // Get 37 bit data.
    UINT64  GetData0() const;
    UINT64  GetData1() const;
    UINT64  GetData2() const;

    // Get/set the full 41 bit instructions.
    UINT64  GetInstruction(BYTE slot) const;
    UINT64  GetInstruction0() const;
    UINT64  GetInstruction1() const;
    UINT64  GetInstruction2() const;
    void    SetInstruction(BYTE slot, UINT64 instruction);
    void    SetInstruction0(UINT64 instruction);
    void    SetInstruction1(UINT64 instruction);
    void    SetInstruction2(UINT64 instruction);

    // Get/set bitfields.
    static UINT64 GetBits(UINT64 Value, UINT64 Offset, UINT64 Count);
    static UINT64 SetBits(UINT64 Value, UINT64 Offset, UINT64 Count, UINT64 Field);

    // Get specific read-only fields.
    static UINT64 GetOpcode(UINT64 instruction); // 4bit opcode
    static UINT64 GetX(UINT64 instruction); // 1bit opcode extension
    static UINT64 GetX3(UINT64 instruction); // 3bit opcode extension
    static UINT64 GetX6(UINT64 instruction); // 6bit opcode extension

    // Get/set specific fields.
    static UINT64 GetImm7a(UINT64 instruction);
    static UINT64 SetImm7a(UINT64 instruction, UINT64 imm7a);
    static UINT64 GetImm13c(UINT64 instruction);
    static UINT64 SetImm13c(UINT64 instruction, UINT64 imm13c);
    static UINT64 GetSignBit(UINT64 instruction);
    static UINT64 SetSignBit(UINT64 instruction, UINT64 signBit);
    static UINT64 GetImm20a(UINT64 instruction);
    static UINT64 SetImm20a(UINT64 instruction, UINT64 imm20a);
    static UINT64 GetImm20b(UINT64 instruction);
    static UINT64 SetImm20b(UINT64 instruction, UINT64 imm20b);

    static UINT64 SignExtend(UINT64 Value, UINT64 Offset);

    BOOL    IsMovlGp() const;

    VOID    SetInst(BYTE Slot, BYTE nInst);
    VOID    SetInst0(BYTE nInst);
    VOID    SetInst1(BYTE nInst);
    VOID    SetInst2(BYTE nInst);
    VOID    SetData(BYTE Slot, UINT64 nData);
    VOID    SetData0(UINT64 nData);
    VOID    SetData1(UINT64 nData);
    VOID    SetData2(UINT64 nData);
    BOOL    SetNop(BYTE Slot);
    BOOL    SetNop0();
    BOOL    SetNop1();
    BOOL    SetNop2();

  public:
    BOOL    IsBrl() const;
    VOID    SetBrl();
    VOID    SetBrl(UINT64 target);
    UINT64  GetBrlTarget() const;
    VOID    SetBrlTarget(UINT64 target);
    VOID    SetBrlImm(UINT64 imm);
    UINT64  GetBrlImm() const;

    UINT64  GetMovlGp() const;
    VOID    SetMovlGp(UINT64 gp);

    VOID    SetStop();

    UINT    Copy(_Out_ DETOUR_IA64_BUNDLE *pDst, _Inout_opt_ DETOUR_IA64_BUNDLE* pBundleExtra = NULL) const;
};
#endif // DETOURS_IA64

#ifdef DETOURS_ARM

#define DETOURS_PFUNC_TO_PBYTE(p)  ((PBYTE)(((ULONG_PTR)(p)) & ~(ULONG_PTR)1))
#define DETOURS_PBYTE_TO_PFUNC(p)  ((PBYTE)(((ULONG_PTR)(p)) | (ULONG_PTR)1))

#endif // DETOURS_ARM

//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#define DETOUR_OFFLINE_LIBRARY(x)                                       \
PVOID WINAPI DetourCopyInstruction##x(_In_opt_ PVOID pDst,              \
                                      _Inout_opt_ PVOID *ppDstPool,     \
                                      _In_ PVOID pSrc,                  \
                                      _Out_opt_ PVOID *ppTarget,        \
                                      _Out_opt_ LONG *plExtra);         \
                                                                        \
BOOL WINAPI DetourSetCodeModule##x(_In_ HMODULE hModule,                \
                                   _In_ BOOL fLimitReferencesToModule); \

DETOUR_OFFLINE_LIBRARY(X86)
DETOUR_OFFLINE_LIBRARY(X64)
DETOUR_OFFLINE_LIBRARY(ARM)
DETOUR_OFFLINE_LIBRARY(ARM64)
DETOUR_OFFLINE_LIBRARY(IA64)

#undef DETOUR_OFFLINE_LIBRARY

//////////////////////////////////////////////////////////////////////////////
//
// Helpers for manipulating page protection.
//

_Success_(return != FALSE)
BOOL WINAPI DetourVirtualProtectSameExecuteEx(_In_  HANDLE hProcess,
                                              _In_  PVOID pAddress,
                                              _In_  SIZE_T nSize,
                                              _In_  DWORD dwNewProtect,
                                              _Out_ PDWORD pdwOldProtect);

_Success_(return != FALSE)
BOOL WINAPI DetourVirtualProtectSameExecute(_In_  PVOID pAddress,
                                            _In_  SIZE_T nSize,
                                            _In_  DWORD dwNewProtect,
                                            _Out_ PDWORD pdwOldProtect);
#ifdef __cplusplus
}
#endif // __cplusplus

//////////////////////////////////////////////////////////////////////////////

#define MM_ALLOCATION_GRANULARITY 0x10000

//////////////////////////////////////////////////////////////////////////////

#endif // DETOURS_INTERNAL
#endif // __cplusplus

#endif // _DETOURS_H_
//
////////////////////////////////////////////////////////////////  End of File.

```

`Intercepter/detours/include/detver.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Common version parameters.
//
//  Microsoft Research Detours Package, Version 4.0.1
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#define _USING_V110_SDK71_ 1
#include "winver.h"
#if 0
#include <windows.h>
#include <detours.h>
#else
#ifndef DETOURS_STRINGIFY
#define DETOURS_STRINGIFY_(x)    #x
#define DETOURS_STRINGIFY(x)    DETOURS_STRINGIFY_(x)
#endif

#define VER_FILEFLAGSMASK   0x3fL
#define VER_FILEFLAGS       0x0L
#define VER_FILEOS          0x00040004L
#define VER_FILETYPE        0x00000002L
#define VER_FILESUBTYPE     0x00000000L
#endif
#define VER_DETOURS_BITS    DETOURS_STRINGIFY(DETOURS_BITS)

```

`Intercepter/detours/include/syelog.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (syelog.h of syelog.lib)
//
//  Microsoft Research Detours Package
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#pragma once
#ifndef _SYELOGD_H_
#define _SYELOGD_H_
#include <stdarg.h>

#pragma pack(push, 1)
#pragma warning(push)
#pragma warning(disable: 4200)

//////////////////////////////////////////////////////////////////////////////
//
//
#define SYELOG_PIPE_NAMEA       "\\\\.\\pipe\\syelog"
#define SYELOG_PIPE_NAMEW       L"\\\\.\\pipe\\syelog"
#ifdef UNICODE
#define SYELOG_PIPE_NAME        SYELOG_PIPE_NAMEW
#else
#define SYELOG_PIPE_NAME        SYELOG_PIPE_NAMEA
#endif

//////////////////////////////////////////////////////////////////////////////
//
#define SYELOG_MAXIMUM_MESSAGE  4086    // 4096 - sizeof(header stuff)

typedef struct _SYELOG_MESSAGE
{
    USHORT      nBytes;
    BYTE        nFacility;
    BYTE        nSeverity;
    DWORD       nProcessId;
    FILETIME    ftOccurance;
    BOOL        fTerminate;
    CHAR        szMessage[SYELOG_MAXIMUM_MESSAGE];
} SYELOG_MESSAGE, *PSYELOG_MESSAGE;


// Facility Codes.
//
#define SYELOG_FACILITY_KERNEL          0x10            // OS Kernel
#define SYELOG_FACILITY_SECURITY        0x20            // OS Security
#define SYELOG_FACILITY_LOGGING         0x30            // OS Logging-internal
#define SYELOG_FACILITY_SERVICE         0x40            // User-mode system daemon
#define SYELOG_FACILITY_APPLICATION     0x50            // User-mode application
#define SYELOG_FACILITY_USER            0x60            // User self-generated.
#define SYELOG_FACILITY_LOCAL0          0x70            // Locally defined.
#define SYELOG_FACILITY_LOCAL1          0x71            // Locally defined.
#define SYELOG_FACILITY_LOCAL2          0x72            // Locally defined.
#define SYELOG_FACILITY_LOCAL3          0x73            // Locally defined.
#define SYELOG_FACILITY_LOCAL4          0x74            // Locally defined.
#define SYELOG_FACILITY_LOCAL5          0x75            // Locally defined.
#define SYELOG_FACILITY_LOCAL6          0x76            // Locally defined.
#define SYELOG_FACILITY_LOCAL7          0x77            // Locally defined.
#define SYELOG_FACILITY_LOCAL8          0x78            // Locally defined.
#define SYELOG_FACILITY_LOCAL9          0x79            // Locally defined.

// Severity Codes.
//
#define SYELOG_SEVERITY_FATAL           0x00            // System is dead.
#define SYELOG_SEVERITY_ALERT           0x10            // Take action immediately.
#define SYELOG_SEVERITY_CRITICAL        0x20            // Critical condition.
#define SYELOG_SEVERITY_ERROR           0x30            // Error
#define SYELOG_SEVERITY_WARNING         0x40            // Warning
#define SYELOG_SEVERITY_NOTICE          0x50            // Significant condition.
#define SYELOG_SEVERITY_INFORMATION     0x60            // Informational
#define SYELOG_SEVERITY_AUDIT_FAIL      0x66            // Audit Failed
#define SYELOG_SEVERITY_AUDIT_PASS      0x67            // Audit Succeeeded
#define SYELOG_SEVERITY_DEBUG           0x70            // Debugging

// Logging Functions.
//
VOID SyelogOpen(PCSTR pszIdentifier, BYTE nFacility);
VOID Syelog(BYTE nSeverity, PCSTR pszMsgf, ...);
VOID SyelogV(BYTE nSeverity, PCSTR pszMsgf, va_list args);
VOID SyelogClose(BOOL fTerminate);

#pragma warning(pop)
#pragma pack(pop)

#endif //  _SYELOGD_H_
//
///////////////////////////////////////////////////////////////// End of File.

```

`Intercepter/dllmain.cpp`:

```cpp
// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include "stdafx.h"
#include "CursorIntercepter.h"

CursorIntercepter g_cursor_intercepter("Intercepter_CursorIntercepter");

BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        g_cursor_intercepter.Attach();
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    case DLL_PROCESS_DETACH:
        g_cursor_intercepter.Detach();
        break;
    }
    return TRUE;
}


```

`Intercepter/stdafx.cpp`:

```cpp
// stdafx.cpp : 只包括标准包含文件的源文件
// Win32Interception.pch 将作为预编译标头
// stdafx.obj 将包含预编译类型信息

#include "stdafx.h"

// TODO: 在 STDAFX.H 中引用任何所需的附加头文件，
//而不是在此文件中引用

```

`Intercepter/stdafx.h`:

```h
// stdafx.h : 标准系统包含文件的包含文件，
// 或是经常使用但不常更改的
// 特定于项目的包含文件
//

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN             // 从 Windows 头中排除极少使用的资料
// Windows 头文件: 
#include <windows.h>



// TODO: 在此处引用程序需要的其他头文件

```

`Intercepter/targetver.h`:

```h
#pragma once

// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。

// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将
// 将 _WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。

#include <SDKDDKVer.h>

```

`WaveConverter/WaveConverter.cpp`:

```cpp
// WaveConverter.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include "WaveUtil/WaveFile.h"
#include "WaveUtil/WaveUtil.h"
#include "WaveUtil/WaveStreamConverter.h"
#include "CommUtil/FTimer.h"
#include <string>
#include <sstream>
#include <memory>

using namespace comm_util;

int ConvertWave(std::string fileName, int sampleRate, int bitsPerSample, int channel);

int main(int argc, char *argv[])
{
	bool paramError = true;
	do
	{
		if (argc < 3 || argc > 5)
			break;

		int sampleRate = 0;
		int bitsPerSample = 0;
		int channel = 0;

		if (argc > 2)
			sampleRate = ::atoi(argv[2]);
		if (argc > 3)
			bitsPerSample = ::atoi(argv[3]);
		if (argc > 4)
			channel = ::atoi(argv[4]);

		ConvertWave(argv[1], sampleRate, bitsPerSample, channel);

		paramError = false;
	} while (false);

	if (paramError)
	{
		printf("Usage: WaveConverter [sampleRate] [bitsPerSample] [channel]\n");
		printf("\n[sampleRate]: e.g. 0, 44100, 48000\n");
		printf("\n[bitsPerSample]: e.g. 0, 16, 24, 32\n");
		printf("\n[channel]: e.g. 0, 1, 2\n");
		printf("\nIf param is 0, then will keep original.\n");
	}
}

int ConvertWave(std::string fileName, int sampleRate, int bitsPerSample, int channel)
{
	std::string inFileName = fileName;
	std::string outFileName;

	printf("process: %s\n", inFileName.c_str());

	FTimer timer;
	timer.Start();

	WaveFile inFile;
	if (!inFile.BeginRead(inFileName.c_str()))
	{
		return -1;
	}

	WAVEFORMATEX fwxIn;
	WaveUtil::ConvertFormat(inFile.GetFormat(), &fwxIn);

	if (sampleRate == 0)
		sampleRate = fwxIn.nSamplesPerSec;
	if (bitsPerSample == 0)
		bitsPerSample = fwxIn.wBitsPerSample;
	if (channel == 0)
		channel = fwxIn.nChannels;

	printf("src fmt: %d, %d, %d\n", fwxIn.nSamplesPerSec, fwxIn.wBitsPerSample, fwxIn.nChannels);
	printf("dst fmt: %d, %d, %d\n", sampleRate, bitsPerSample, channel);

	std::stringstream stream;
	stream << fileName.substr(0, fileName.find_last_of('.'));
	stream << "_" << sampleRate << "_" << bitsPerSample << "_" << channel;
	stream << ".wav";
	outFileName = stream.str();

	WAVEFORMATEX fwxOut = fwxIn;
	WaveFile::FormatChunk fmtOut;
	WaveUtil::SetFormat(&fwxOut, sampleRate, bitsPerSample, channel);
	WaveUtil::ConvertFormat(&fwxOut, &fmtOut);

	WaveStreamConverter converter;
	if (!converter.IsSupport(&fwxIn, &fwxOut))
	{
		printf("Convert format not support.\n");
		return -1;
	}

	WaveFile outFile;
	if (!outFile.SetFormat(fmtOut))
	{
		return -1;
	}
	if (!outFile.BeginWrite(outFileName.c_str(), true))
	{
		return -1;
	}

	uint32_t bufferFrameCount = 1000;
	std::shared_ptr<char> outBuffer(new char[bufferFrameCount * outFile.BytesPerFrame()], std::default_delete<char[]>());

	converter.SetStream(&inFile.InStream());
	converter.SetFormat(&fwxIn, &fwxOut, bufferFrameCount);

	float sampleRateRadio = ((float)outFile.GetFormat()->sampleRate / inFile.GetFormat()->sampleRate);
	uint32_t frameCount = (uint32_t)(inFile.FrameCount() * sampleRateRadio);

	for (uint32_t i = 0; i < frameCount;)
	{
		uint32_t count = min(frameCount - i, bufferFrameCount);
		uint32_t rcount = converter.ReadFrame(outBuffer.get(), count);
		if (rcount > 0)
			outFile.WriteFrame(outBuffer.get(), rcount);
		else
			break;
		i += rcount;
	}

	inFile.EndRead();
	outFile.EndWrite();

	timer.Stop();
	printf(" output: %s\n", outFileName.c_str());
	printf("   time: %lld\n", timer.Seconds());

	return 0;
}


```

`WaveConverter/WaveConverter.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{C23F0DA0-1DB4-4D73-B380-08DF35F5752C}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>WaveConverter</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <ReferencePath>$(ReferencePath)</ReferencePath>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <ReferencePath>$(ReferencePath)</ReferencePath>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <ReferencePath>$(ReferencePath)</ReferencePath>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <ReferencePath>$(ReferencePath)</ReferencePath>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>CommUtil.lib;WaveUtil.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>CommUtil.lib;WaveUtil.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>CommUtil.lib;WaveUtil.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>CommUtil.lib;WaveUtil.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="WaveConverter.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`WaveConverter/WaveConverter.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="WaveConverter.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`WaveConverter/stdafx.cpp`:

```cpp
// stdafx.cpp : 只包括标准包含文件的源文件
// WaveConverter.pch 将作为预编译头
// stdafx.obj 将包含预编译类型信息

#include "stdafx.h"

// TODO: 在 STDAFX.H 中引用任何所需的附加头文件，
//而不是在此文件中引用

```

`WaveConverter/stdafx.h`:

```h
// stdafx.h : 标准系统包含文件的包含文件，
// 或是经常使用但不常更改的
// 特定于项目的包含文件
//

#pragma once

#include "targetver.h"

#include <stdio.h>
#include <tchar.h>



// TODO:  在此处引用程序需要的其他头文件

```

`WaveConverter/targetver.h`:

```h
#pragma once

// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。

// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将
// 将 _WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。

#include <SDKDDKVer.h>

```

`WaveGraph/Resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by WaveGraph.rc
//

#define IDS_APP_TITLE			103

#define IDR_MAINFRAME			128
#define IDD_WAVEGRAPH_DIALOG	102
#define IDD_ABOUTBOX			103
#define IDM_ABOUT				104
#define IDM_EXIT				105
#define IDI_WAVEGRAPH			107
#define IDI_SMALL				108
#define IDC_WAVEGRAPH			109
#define IDC_MYICON				2
#ifndef IDC_STATIC
#define IDC_STATIC				-1
#endif
// 新对象的下一组默认值
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NO_MFC					130
#define _APS_NEXT_RESOURCE_VALUE	129
#define _APS_NEXT_COMMAND_VALUE		32771
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		110
#endif
#endif

```

`WaveGraph/Util/FFT.cpp`:

```cpp
#pragma execution_character_set("utf-8")
#include "stdafx.h"
#include "FFT.h"
#include <cmath>

#define PI 3.14159265358979323846

using std::vector;
using std::complex;
using std::bitset;

FFT::FFT()
{
}


FFT::~FFT()
{
}

void FFT::DoFFT(unsigned long &ulN, vector<complex<double> >& vecList)
{
	//得到幂数
	unsigned long ulPower = 0; //幂数
	unsigned long ulN1 = ulN - 1;
	while (ulN1 > 0)
	{
		ulPower++;
		ulN1 /= 2;
	}

	//反序
	bitset<sizeof(unsigned long) * 8> bsIndex; //二进制容器
	unsigned long ulIndex; //反转后的序号
	unsigned long ulK;

	for (unsigned long p = 0; p < ulN; p++)
	{
		ulIndex = 0;
		ulK = 1;
		bsIndex = bitset<sizeof(unsigned long) * 8>(p);

		for (unsigned long j = 0; j < ulPower; j++)
		{
			ulIndex += bsIndex.test(ulPower - j - 1) ? ulK : 0;
			ulK *= 2;
		}

		if (ulIndex > p)
		{
			complex<double> c = vecList[p];
			vecList[p] = vecList[ulIndex];
			vecList[ulIndex] = c;
		}
	}

	//计算旋转因子
	vector<complex<double> > vecW;
	for (unsigned long i = 0; i < ulN / 2; i++)
	{
		vecW.push_back(complex<double>(cos(2 * i * PI / ulN), -1 * sin(2 * i * PI / ulN)));
	}
	//for (unsigned long m = 0; m < ulN / 2; m++)
	//{
	//	cout << "\nvW[" << m << "]=" << vecW[m];
	//}


	//计算FFT
	unsigned long ulGroupLength = 1; //段的长度
	unsigned long ulHalfLength = 0; //段长度的一半
	unsigned long ulGroupCount = 0; //段的数量
	complex<double> cw; //WH(x)
	complex<double> c1; //G(x) + WH(x)
	complex<double> c2; //G(x) - WH(x)

	for (unsigned long b = 0; b < ulPower; b++)
	{
		ulHalfLength = ulGroupLength;
		ulGroupLength *= 2;

		for (unsigned long j = 0; j < ulN; j += ulGroupLength)
		{
			for (unsigned long k = 0; k < ulHalfLength; k++)
			{
				cw = vecW[k * ulN / ulGroupLength] * vecList[j + k + ulHalfLength];
				c1 = vecList[j + k] + cw;
				c2 = vecList[j + k] - cw;
				vecList[j + k] = c1;
				vecList[j + k + ulHalfLength] = c2;
			}
		}
	}
}

```

`WaveGraph/Util/FFT.h`:

```h
#pragma once
#pragma execution_character_set("utf-8")
#include <vector>
#include <bitset>
#include <complex>

class FFT
{
public:
	FFT();
	~FFT();

	static void DoFFT(unsigned long &ulN, std::vector<std::complex<double> >& vecList);
};


```

`WaveGraph/Util/FastFourierTransform.cpp`:

```cpp
#include "stdafx.h"
#include "FastFourierTransform.h"
#include <cmath>

/************************************************************************/
/* CFastFourierTransform                                                */
/************************************************************************/
CFastFourierTransform::CFastFourierTransform(int pSampleSize)
{
	xre = NULL;
	xim = NULL;
	mag = NULL;
	fftSin = NULL;
	fftCos = NULL;
	fftBr = NULL;

	ss = pSampleSize;
	ss2 = ss >> 1;
	nu = (int) (log((float)ss) / log((float)2));
	nu1 = nu - 1;

	xre = new float[ss]; // real part
	xim = new float[ss]; // image part
	mag = new float[ss2];

	PrepareFFTTables();
}

CFastFourierTransform::~CFastFourierTransform(void)
{
	if(xre != NULL)
		delete [] xre;

	if(xim != NULL)
		delete [] xim;

	if(mag != NULL)
		delete [] mag;

	if(fftSin != NULL)
		delete [] fftSin;

	if(fftCos != NULL)
		delete [] fftCos;

	if(fftBr != NULL)
		delete [] fftBr;

	xre = NULL;
	xim = NULL;
	mag = NULL;
	fftSin = NULL;
	fftCos = NULL;
	fftBr = NULL;
}

void CFastFourierTransform::PrepareFFTTables()
{
	int n2 = ss2;
	int nu1 = nu - 1;

	fftSin = new float[nu * n2];
	fftCos = new float[nu * n2];

	int k = 0;
	int x = 0;
	for (int l = 1; l <= nu; l++) {
		while (k < ss) {
			for (int i = 1; i <= n2; i++) {
				float p = (float)BitRev(k >> nu1, nu);
				float arg = (PI_2 * p) / (float) ss;
				fftSin[x] = (float) sin(arg);
				fftCos[x] = (float) cos(arg);
				k++;
				x++;
			}

			k += n2;
		}

		k = 0;
		nu1--;
		n2 >>= 1;
	}

	fftBr = new int[ss];
	for (k = 0; k < ss; k++)
		fftBr[k] = BitRev(k, nu);
}

int CFastFourierTransform::BitRev(int j, int nu) {
	int j1 = j;
	int k = 0;
	for (int i = 1; i <= nu; i++) {
		int j2 = j1 >> 1;
		k = ((k << 1) + j1) - (j2 << 1);
		j1 = j2;
	}

	return k;
}

float* CFastFourierTransform::Calculate(float* pSample, size_t pSampleSize) {
	int n2 = ss2;
	int nu1 = nu - 1;
	size_t wAps = pSampleSize / ss;
	size_t a = 0;

	for (size_t b = 0; a < pSampleSize; b++) {
		xre[b] = pSample[a];
		xim[b] = 0.0F;
		a += wAps;
	}

	int x = 0;
	for (int l = 1; l <= nu; l++) {
		for (int k = 0; k < ss; k += n2) {
			for (int i = 1; i <= n2; i++) {
				float c = fftCos[x];
				float s = fftSin[x];
				int kn2 = k + n2;
				float tr = xre[kn2] * c + xim[kn2] * s;
				float ti = xim[kn2] * c - xre[kn2] * s;
				xre[kn2] = xre[k] - tr;
				xim[kn2] = xim[k] - ti;
				xre[k] += tr;
				xim[k] += ti;
				k++;
				x++;
			}
		}

		nu1--;
		n2 >>= 1;
	}

	for (int k = 0; k < ss; k++) {
		int r = fftBr[k];
		if (r > k) {
			float tr = xre[k];
			float ti = xim[k];
			xre[k] = xre[r];
			xim[k] = xim[r];
			xre[r] = tr;
			xim[r] = ti;
		}
	}

	mag[0] = (float) sqrt(xre[0] * xre[0] + xim[0] * xim[0]) / (float) ss;
	for (int i = 1; i < ss2; i++)
		mag[i] = (2.0F * (float) sqrt(xre[i] * xre[i] + xim[i] * xim[i])) / (float) ss;

	return mag;
}

```

`WaveGraph/Util/FastFourierTransform.h`:

```h
#pragma once

#ifndef INCLUDE_FASTTOURIERTRANSFORM
#define INCLUDE_FASTTOURIERTRANSFORM

/************************************************************************/
/* CFastFourierTransform                                                */
/************************************************************************/
#define PI_2 6.283185F
#define PI   3.1415925F
class CFastFourierTransform
{
private:
	float* xre;
	float* xim;
	float* mag;
	float* fftSin;
	float* fftCos;
	int* fftBr;
	int ss;
	int ss2;
	int nu;
	int nu1;

	int BitRev(int j, int nu);
	void PrepareFFTTables();
public:
	CFastFourierTransform(int pSampleSize);
	~CFastFourierTransform(void);

	float* Calculate(float* pSample, size_t pSampleSize);
};

#endif

```

`WaveGraph/WaveGraph.cpp`:

```cpp
// WaveGraph.cpp : 定义应用程序的入口点。
//

#include "stdafx.h"
#include "WaveGraph.h"
#include "Win32Util/Audio/Extend/AudioRecorder.h"
#include "Win32Util/Audio/Extend/AudioRenderer.h"
#include "Win32Util/Audio/Extend/AudioExtractor.h"
#include "Win32Util/Audio/Extend/AudioPainter.h"
#include "Win32Util/Util/DcBuffer.h"
#include <cstdio>

#define MAX_LOADSTRING 100

#define WINDOW_WIDTH 600
#define WINDOW_HEIGHT 400

#define START_CAPTURE_ID    200
#define STOP_CAPTURE_ID     201
#define START_PLAY_ID       202
#define STOP_PLAY_ID        203
#define START_EXTRACT_ID    204
#define STOP_EXTRACT_ID     205

#define PAINT_RECORD_ID     300
#define PAINT_EXTRACT_ID    301
#define ADD_SCALE_ID        310
#define SUB_SCALE_ID        311

#define TIMER_ID_SOUND      999
UINT_PTR g_soundTimer = 0;


enum class ActionMode
{
	Mode_None,
	Mode_Record,
	Mode_Play,
	Mode_Extract,
};
static ActionMode g_mode = ActionMode::Mode_None;

// 全局变量:
static HINSTANCE hInst;								// 当前实例
static HWND g_hWndMain;
static TCHAR szTitle[MAX_LOADSTRING];					// 标题栏文本
static TCHAR szWindowClass[MAX_LOADSTRING];			// 主窗口类名

static RECT g_waveRect = { 0, 0, 500, 200 };
static DcBuffer *g_pDcBuffer;

static AudioRecorder *g_pAudioRecorder = NULL;
static AudioRenderer *g_pAudioRenderer = NULL;
static AudioExtractor *g_pAudioExtractor = NULL;
static AudioPainter *g_pAudioPainter = NULL;


// 此代码模块中包含的函数的前向声明:
ATOM				MyRegisterClass(HINSTANCE hInstance);
BOOL				InitInstance(HINSTANCE, int);
LRESULT CALLBACK	WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK	About(HWND, UINT, WPARAM, LPARAM);

VOID StartRecord();
VOID StopRecord();

VOID StartPlay();
VOID StopPlay();

VOID StartExtract();
VOID StopExtract();

VOID AddScale();
VOID SubScale();
VOID ClickRecorder();
VOID ClickExtractor();

static void Paint(HWND hWnd, HDC hdc);
static void PaintExtractor();
static void PaintRecorder();


int APIENTRY _tWinMain(_In_ HINSTANCE hInstance,
					   _In_opt_ HINSTANCE hPrevInstance,
					   _In_ LPTSTR    lpCmdLine,
					   _In_ int       nCmdShow)
{
	UNREFERENCED_PARAMETER(hPrevInstance);
	UNREFERENCED_PARAMETER(lpCmdLine);

	// TODO: 在此放置代码。
	MSG msg;
	HACCEL hAccelTable;

	// 初始化全局字符串
	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadString(hInstance, IDC_WAVEGRAPH, szWindowClass, MAX_LOADSTRING);
	MyRegisterClass(hInstance);

	// 执行应用程序初始化:
	if (!InitInstance (hInstance, nCmdShow))
	{
		return FALSE;
	}

	hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WAVEGRAPH));

    int hr = ::CoInitialize(NULL);
    if (FAILED(hr))
    {
        return FALSE;
    }

	if (::AllocConsole())
	{
		FILE *out;
		FILE *in;
		::freopen_s(&out, "CONOUT$", "w", stdout);
		::freopen_s(&in, "CONIN$", "r", stdin);
	}
	printf("Start ...\n");

	g_soundTimer = ::SetTimer(g_hWndMain, TIMER_ID_SOUND, 20, NULL);

	g_pAudioPainter = new AudioPainter();
	if (!g_pAudioPainter)
		return FALSE;
	g_pAudioPainter->SetEnable(false);

	g_pAudioRecorder = new AudioRecorder(true, false);
	if (!g_pAudioRecorder || FAILED(g_pAudioRecorder->Init()))
	{
		printf("Init AudioRecorder failed!\n");
		return FALSE;
	}

	g_pAudioRenderer = new AudioRenderer(false);
	if (!g_pAudioRenderer || FAILED(g_pAudioRenderer->Init()))
	{
		printf("Init AudioRenderer failed!\n");
		return FALSE;
	}

	g_pAudioExtractor = new AudioExtractor();
	if(!g_pAudioExtractor || FAILED(g_pAudioExtractor->Init()))
	{
		printf("Init AudioExtractor failed!\n");
		return FALSE;
	}
	g_pAudioExtractor->SetSegmentMaxCount(100);
	g_pAudioExtractor->SetSoundMaxCount(1);
	g_pAudioExtractor->SetAmpZcr(480, 0.1f, 0.2f, 0.3f, 0.5f);

	// 主消息循环:
	while (GetMessage(&msg, NULL, 0, 0))
	{
		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	::CoUninitialize();
	::FreeConsole();

	return (int) msg.wParam;
}



//
//  函数: MyRegisterClass()
//
//  目的: 注册窗口类。
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX);

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WAVEGRAPH));
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= NULL; // (HBRUSH)(COLOR_WINDOW + 1);
	wcex.lpszMenuName	= MAKEINTRESOURCE(IDC_WAVEGRAPH);
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

	return RegisterClassEx(&wcex);
}

//
//   函数: InitInstance(HINSTANCE, int)
//
//   目的: 保存实例句柄并创建主窗口
//
//   注释:
//
//        在此函数中，我们在全局变量中保存实例句柄并
//        创建和显示主程序窗口。
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
	HWND hWnd;

	hInst = hInstance; // 将实例句柄存储在全局变量中

	int cx = GetSystemMetrics( SM_CXSCREEN ) / 2 - WINDOW_WIDTH / 2;
	int cy = GetSystemMetrics( SM_CYSCREEN ) / 2 - WINDOW_HEIGHT / 2;

	hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
		cx, cy, WINDOW_WIDTH, WINDOW_HEIGHT, NULL, NULL, hInstance, NULL);

	if (!hWnd)
	{
		return FALSE;
	}

	g_pDcBuffer = new DcBuffer(hWnd, g_waveRect.right, g_waveRect.bottom);

	ShowWindow(hWnd, nCmdShow);
	//UpdateWindow(hWnd);

	g_hWndMain = hWnd;

	return TRUE;
}

VOID CreateControlButtons(HWND hWndParent)
{
	const INT w = 100;
	const INT h = 30;
	const DWORD dwButtonStyle = WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON | BS_TEXT;

	int x = 20;
	int y = 20;
	int w2 = w + 10;
	int h2 = h + 10;

	int c = -1;

	++c;
	HWND hWndStartPlay = CreateWindow(_T("BUTTON"), _T("+Scale"), dwButtonStyle,
		(x + w2 * c), (y + h2 * 0), w, h, hWndParent, (HMENU)ADD_SCALE_ID, hInst, NULL);
	HWND hWndStopPlay = CreateWindow(_T("BUTTON"), _T("-Scale"), dwButtonStyle,
		(x + w2 * c), (y + h2 * 1), w, h, hWndParent, (HMENU)SUB_SCALE_ID, hInst, NULL);

	++c;
	HWND hWndStartRecord = CreateWindow(_T("BUTTON"), _T("Start Record"), dwButtonStyle,
		(x + w2 * c), (y + h2 * 0), w, h, hWndParent, (HMENU)START_CAPTURE_ID, hInst, NULL);
	HWND hWndStopRecord = CreateWindow(_T("BUTTON"), _T("Stop Record"), dwButtonStyle,
		(x + w2 * c), (y + h2 * 1), w, h, hWndParent, (HMENU)STOP_CAPTURE_ID, hInst, NULL);

	++c;
	HWND hWndStartRender = CreateWindow(_T("BUTTON"), _T("Start Play"), dwButtonStyle,
		(x + w2 * c), (y + h2 * 0), w, h, hWndParent, (HMENU)START_PLAY_ID, hInst, NULL);
	HWND hWndStopRender = CreateWindow(_T("BUTTON"), _T("Stop Play"), dwButtonStyle,
		(x + w2 * c), (y + h2 * 1), w, h, hWndParent, (HMENU)STOP_PLAY_ID, hInst, NULL);

	++c;
	HWND hWndStartExtract = CreateWindow(_T("BUTTON"), _T("Start Extract"), dwButtonStyle,
		(x + w2 * c), (y + h2 * 0), w, h, hWndParent, (HMENU)START_EXTRACT_ID, hInst, NULL);
	HWND hWndStopExtract = CreateWindow(_T("BUTTON"), _T("Stop Extract"), dwButtonStyle,
		(x + w2 * c), (y + h2 * 1), w, h, hWndParent, (HMENU)STOP_EXTRACT_ID, hInst, NULL);

	++c;
	HWND hWndPaintRecord = CreateWindow(_T("BUTTON"), _T("Paint Record"), dwButtonStyle,
		(x + w2 * c), (y + h2 * 0), w, h, hWndParent, (HMENU)PAINT_RECORD_ID, hInst, NULL);
	HWND hWndPaintExtract = CreateWindow(_T("BUTTON"), _T("Paint Extract"), dwButtonStyle,
		(x + w2 * c), (y + h2 * 1), w, h, hWndParent, (HMENU)PAINT_EXTRACT_ID, hInst, NULL);
}

VOID UpdateButtonStatus()
{
	HWND hWndStartRecord = GetDlgItem(g_hWndMain, START_CAPTURE_ID);
	HWND hWndStopRecord = GetDlgItem(g_hWndMain, STOP_CAPTURE_ID);

	HWND hWndStartPlay = GetDlgItem(g_hWndMain, START_PLAY_ID);
	HWND hWndStopPlay = GetDlgItem(g_hWndMain, STOP_PLAY_ID);

	HWND hWndStartExtract = GetDlgItem(g_hWndMain, START_EXTRACT_ID);
	HWND hWndStopExtract = GetDlgItem(g_hWndMain, STOP_EXTRACT_ID);

	EnableWindow(hWndStartRecord, g_mode == ActionMode::Mode_None);
	EnableWindow(hWndStopRecord, g_mode == ActionMode::Mode_Record);
	
	EnableWindow(hWndStartPlay, g_mode == ActionMode::Mode_None);
	EnableWindow(hWndStopPlay,  g_mode == ActionMode::Mode_Play);

	EnableWindow(hWndStartExtract, g_mode == ActionMode::Mode_None);
	EnableWindow(hWndStopExtract, g_mode == ActionMode::Mode_Extract);
}

//
//  函数: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  目的: 处理主窗口的消息。
//
//  WM_COMMAND	- 处理应用程序菜单
//  WM_PAINT	- 绘制主窗口
//  WM_DESTROY	- 发送退出消息并返回
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;
	PAINTSTRUCT ps;
	HDC hdc;

	switch (message)
	{
	case WM_CREATE:
		{
			g_hWndMain = hWnd;
			CreateControlButtons(hWnd);
			UpdateButtonStatus();
		}
		break;
	case WM_COMMAND:
		wmId    = LOWORD(wParam);
		wmEvent = HIWORD(wParam);
		// 分析菜单选择:
		switch (wmId)
		{
		case IDM_ABOUT:
			DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
			break;
		case IDM_EXIT:
			DestroyWindow(hWnd);
			break;
		case START_CAPTURE_ID:
			StartRecord();
			break;
		case STOP_CAPTURE_ID:
			StopRecord();
			break;
		case START_PLAY_ID:
			StartPlay();
			break;
		case STOP_PLAY_ID:
			StopPlay();
			break;
		case START_EXTRACT_ID:
			StartExtract();
			break;
		case STOP_EXTRACT_ID:
			StopExtract();
			break;
		case ADD_SCALE_ID:
			AddScale();
			break;
		case SUB_SCALE_ID:
			SubScale();
			break;
		case PAINT_RECORD_ID:
			ClickRecorder();
			break;
		case PAINT_EXTRACT_ID:
			ClickExtractor();
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
		}
		break;
	case WM_PAINT:
		hdc = BeginPaint(hWnd, &ps);
		// TODO: 在此添加任意绘图代码...

		Paint(hWnd, hdc);

		EndPaint(hWnd, &ps);
		break;
	case WM_DESTROY:
		PostQuitMessage(0);
		break;
	case WM_TIMER:
		if (g_pAudioPainter->IsEnable())
		{
			if (g_mode == ActionMode::Mode_Extract)
			{
				PaintExtractor();
			}
			else if (g_mode == ActionMode::Mode_Record)
			{
				PaintRecorder();
			}
			RECT rect = { 0, 100,  WINDOW_WIDTH, WINDOW_HEIGHT };
			::InvalidateRect(hWnd, &rect, true);
		}
		break;
	default:
		return DefWindowProc(hWnd, message, wParam, lParam);
	}
	return 0;
}

// “关于”框的消息处理程序。
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	UNREFERENCED_PARAMETER(lParam);
	switch (message)
	{
	case WM_INITDIALOG:
		return (INT_PTR)TRUE;

	case WM_COMMAND:
		if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
		{
			EndDialog(hDlg, LOWORD(wParam));
			return (INT_PTR)TRUE;
		}
		break;
	}
	return (INT_PTR)FALSE;
}


VOID StartRecord()
{
	if (g_pAudioRecorder->Start())
	{
		g_mode = ActionMode::Mode_Record;
		UpdateButtonStatus();
	}
}

VOID StopRecord()
{
	g_mode = ActionMode::Mode_None;
	g_pAudioRecorder->Stop();
	UpdateButtonStatus();
}

VOID StartExtract()
{
	if (g_pAudioExtractor->Start())
	{
		g_mode = ActionMode::Mode_Extract;
		UpdateButtonStatus();
	}
}

VOID StopExtract()
{
	g_mode = ActionMode::Mode_None;
	g_pAudioExtractor->Stop();
	UpdateButtonStatus();
}

VOID StartPlay()
{
	g_pAudioRenderer->SetSource(g_pAudioRecorder->GetStorage());
	if (g_pAudioRenderer->Start())
	{
		g_mode = ActionMode::Mode_Play;
		UpdateButtonStatus();
	}
}

void StopPlay()
{
	g_mode = ActionMode::Mode_None;
	g_pAudioRenderer->Stop();
	UpdateButtonStatus();
}

VOID AddScale()
{
	g_pAudioPainter->AddScale(+0.5f);
	
	RECT rect = { 0, 0, 100, 20 };
	::InvalidateRect(g_hWndMain, &rect, true);
}

VOID SubScale()
{
	g_pAudioPainter->AddScale(-0.5f);

	RECT rect = { 0, 0, 100, 20 };
	::InvalidateRect(g_hWndMain, &rect, true);
}

VOID ClickRecorder()
{
	static bool enable = false;
	enable = !enable;
	if (enable)
	{
		g_pAudioPainter->SetFormat(g_pAudioExtractor->GetFormat());
	}
	g_pAudioPainter->SetEnable(enable);
}

VOID ClickExtractor()
{
	static bool enable = false;
	enable = !enable;
	if (enable)
	{
		g_pAudioPainter->SetFormat(g_pAudioRecorder->GetFormat());
	}
	g_pAudioPainter->SetEnable(enable);
}

void Paint(HWND hWnd, HDC hdc)
{
	if (g_pAudioPainter->IsEnable())
	{
		int w = g_waveRect.right;
		int h = g_waveRect.bottom;
		::StretchBlt(hdc, 10, 100, w, h, g_pDcBuffer->GetDC(), 0, 0, w, h, SRCCOPY);
	}

	wchar_t buf[20];
	wsprintf(buf, L"Scale: %d%%", (int)(g_pAudioPainter->GetScale() * 100));
	::TextOut(hdc, 0, 0, buf, (int)::wcslen(buf));
}

void PaintRecorder()
{
	g_pDcBuffer->Clear();
	g_pAudioPainter->Clear();

	g_pAudioRecorder->Lock();
	g_pAudioPainter->AddSource(g_pAudioRecorder->GetStorage());
	g_pAudioPainter->Paint(g_pDcBuffer->GetDC(), g_waveRect, 10.0f);
	g_pAudioRecorder->Unlock();

	g_pAudioPainter->Clear();
}

void PaintExtractor()
{
	g_pDcBuffer->Clear();
	g_pAudioPainter->Clear();

	g_pAudioExtractor->Lock();
	for (AudioExtractor::SegmentCIter iter = g_pAudioExtractor->cbegin(); iter != g_pAudioExtractor->cend(); ++iter)
	{
		g_pAudioPainter->AddSource(*iter);
	}
	g_pAudioPainter->Paint(g_pDcBuffer->GetDC(), g_waveRect, 10.0f);
	g_pAudioExtractor->Unlock();

	g_pAudioPainter->Clear();
}


```

`WaveGraph/WaveGraph.h`:

```h
#pragma once

#include "resource.h"

```

`WaveGraph/WaveGraph.rc`:

```rc
//Microsoft Visual C++ 生成的资源脚本。
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// 从 TEXTINCLUDE 2 资源生成。
//
#ifndef APSTUDIO_INVOKED
#include "targetver.h"
#endif
#define APSTUDIO_HIDDEN_SYMBOLS
#include "windows.h"
#undef APSTUDIO_HIDDEN_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE 4, 2

/////////////////////////////////////////////////////////////////////////////
//
// 图标
//

// ID 值最低的图标放在最前面，以确保应用程序图标
// 在所有系统中保持一致。

IDI_WAVEGRAPH       ICON         "WaveGraph.ico"
IDI_SMALL               ICON         "small.ico"

/////////////////////////////////////////////////////////////////////////////
//
// 菜单
//

IDC_WAVEGRAPH MENU
BEGIN
    POPUP "文件(&F)"
    BEGIN
        MENUITEM "退出(&X)",                IDM_EXIT
    END
    POPUP "帮助(&H)"
    BEGIN
        MENUITEM "关于(&A) ...",           IDM_ABOUT
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// 快捷键
//

IDC_WAVEGRAPH ACCELERATORS
BEGIN
    "?",            IDM_ABOUT,              ASCII,  ALT
    "/",            IDM_ABOUT,              ASCII,  ALT
END


/////////////////////////////////////////////////////////////////////////////
//
// 对话框
//

IDD_ABOUTBOX DIALOGEX 0, 0, 170, 62
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "关于 WaveGraph"
FONT 9, "MS Shell Dlg"
BEGIN
    ICON            IDR_MAINFRAME,IDC_STATIC,14,14,21,20
    LTEXT           "WaveGraph，1.0 版",IDC_STATIC,42,14,114,8,SS_NOPREFIX
    LTEXT           "Copyright (C) 2015",IDC_STATIC,42,26,114,8
    DEFPUSHBUTTON   "确定",IDOK,113,41,50,14,WS_GROUP
END

/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 163
        TOPMARGIN, 7
        BOTTOMMARGIN, 55
    END
END
#endif    // APSTUDIO_INVOKED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//
1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#ifndef APSTUDIO_INVOKED\r\n"
    "#include ""targetver.h""\r\n"
    "#endif\r\n"
    "#define APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "#include ""windows.h""\r\n"
    "#undef APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// 字符串表
//

STRINGTABLE
BEGIN
   IDC_WAVEGRAPH   "WAVEGRAPH"
   IDS_APP_TITLE       "WaveGraph"
END

#endif
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// 从 TEXTINCLUDE 3 资源生成。
//

/////////////////////////////////////////////////////////////////////////////
#endif    // 不是 APSTUDIO_INVOKED

```

`WaveGraph/WaveGraph.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{5BA80E0D-1DD3-43D3-94EE-40A805C63912}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>WaveGraph</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <SourcePath>$(SourcePath)</SourcePath>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <SourcePath>$(SourcePath)</SourcePath>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>CommUtil.lib;Win32Util.lib;WaveUtil.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>CommUtil.lib;Win32Util.lib;WaveUtil.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>CommUtil.lib;Win32Util.lib;WaveUtil.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>CommUtil.lib;Win32Util.lib;WaveUtil.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="Util\FastFourierTransform.h" />
    <ClInclude Include="Util\FFT.h" />
    <ClInclude Include="WaveGraph.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="Util\FastFourierTransform.cpp" />
    <ClCompile Include="Util\FFT.cpp" />
    <ClCompile Include="WaveGraph.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="WaveGraph.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="small.ico" />
    <Image Include="WaveGraph.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`WaveGraph/WaveGraph.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Util">
      <UniqueIdentifier>{c983ecbb-2774-455d-9fed-fe0865358c7c}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Util\FastFourierTransform.h">
      <Filter>Util</Filter>
    </ClInclude>
    <ClInclude Include="Util\FFT.h">
      <Filter>Util</Filter>
    </ClInclude>
    <ClInclude Include="WaveGraph.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="WaveGraph.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="Util\FastFourierTransform.cpp">
      <Filter>Util</Filter>
    </ClCompile>
    <ClCompile Include="Util\FFT.cpp">
      <Filter>Util</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="WaveGraph.rc">
      <Filter>资源文件</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="small.ico">
      <Filter>资源文件</Filter>
    </Image>
    <Image Include="WaveGraph.ico">
      <Filter>资源文件</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`WaveGraph/stdafx.cpp`:

```cpp
// stdafx.cpp : 只包括标准包含文件的源文件
// WaveGraph.pch 将作为预编译头
// stdafx.obj 将包含预编译类型信息

#include "stdafx.h"

// TODO: 在 STDAFX.H 中
// 引用任何所需的附加头文件，而不是在此文件中引用

```

`WaveGraph/stdafx.h`:

```h
// stdafx.h : 标准系统包含文件的包含文件，
// 或是经常使用但不常更改的
// 特定于项目的包含文件
//

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN             //  从 Windows 头文件中排除极少使用的信息
// Windows 头文件:
#include <windows.h>

// C 运行时头文件
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>


// TODO: 在此处引用程序需要的其他头文件

```

`WaveGraph/targetver.h`:

```h
#pragma once

// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。

// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将
// WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。

#include <SDKDDKVer.h>

```

`WavePlayer/WavePlayer.cpp`:

```cpp
// WavePlayer.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include "WaveUtil/WaveFile.h"
#include "WaveUtil/WaveUtil.h"
#include "Win32Util/Audio/Extend/AudioRenderer.h"

void PlayWave(const char *file);

int main(int argc, char *argv[])
{
    int res = ::CoInitialize(NULL);
    if (res != S_OK)
    {
        return res;
    }

	if (argc > 1)
	{
		PlayWave(argv[1]);
	}

	return 0;
}

void PlayWave(const char *file)
{
	AudioRenderer render;
	if (render.Init() == 0)
	{
		if (render.SetSourceFile(file))
		{
			render.Start();
			while (!render.IsDone())
			{
				Sleep(10);
			}
		}
	}
}




```

`WavePlayer/WavePlayer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{0F3C70B5-B074-4374-AA6F-A88A0C8A2B47}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>WavePlayer</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>CommUtil.lib;Win32Util.lib;WaveUtil.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>CommUtil.lib;Win32Util.lib;WaveUtil.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>CommUtil.lib;Win32Util.lib;WaveUtil.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>CommUtil.lib;Win32Util.lib;WaveUtil.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="WavePlayer.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`WavePlayer/WavePlayer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="WavePlayer.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`WavePlayer/stdafx.cpp`:

```cpp
// stdafx.cpp : 只包括标准包含文件的源文件
// WavePlayer.pch 将作为预编译头
// stdafx.obj 将包含预编译类型信息

#include "stdafx.h"

// TODO: 在 STDAFX.H 中引用任何所需的附加头文件，
//而不是在此文件中引用

```

`WavePlayer/stdafx.h`:

```h
// stdafx.h : 标准系统包含文件的包含文件，
// 或是经常使用但不常更改的
// 特定于项目的包含文件
//

#pragma once

#include "targetver.h"

#include <stdio.h>
#include <tchar.h>



// TODO:  在此处引用程序需要的其他头文件

```

`WavePlayer/targetver.h`:

```h
#pragma once

// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。

// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将
// 将 _WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。

#include <SDKDDKVer.h>

```

`WaveUtil/WaveConverter.cpp`:

```cpp
#include "stdafx.h"
#include "WaveConverter.h"
#include "CommUtil/CommUtil.hpp"
#include <cmath>
#include <assert.h>
#include <memory>

using namespace comm_util;

#define PI 3.14159265358979323846
#define PI_2 (PI * 2)

WaveConverter::WaveConverter()
    : m_sampleRateRatio(0)
    , m_srcBytesPerSample(0)
    , m_dstBytesPerSample(0)
    , m_srcBytesPerFrame(0)
    , m_dstBytesPerFrame(0)
    , m_srcMaxValue(0)
    , m_dstMaxValue(0)
    , m_srcFrameIndex(0)
    , m_dstFrameIndex(0)
    , m_srcBufferFrameCount(0)
    , m_srcFrameIndexFloat(0)
    , m_wndWidth(0)
    , m_wndWidth2(0)
    , m_bitsConvertType()
    , m_channelConvertType()
    , m_wfxSrc()
    , m_wfxDst()
{
	m_buffer1.pData = NULL;
	m_buffer2.pData = NULL;
}

WaveConverter::~WaveConverter()
{
	SAFE_DELETE_A(m_buffer1.pData);
	SAFE_DELETE_A(m_buffer2.pData);
}

void WaveConverter::SetFormat(const WAVEFORMATEX *pwfxSrc, const WAVEFORMATEX *pwfxDst, uint32_t bufferFrameCount)
{
	memcpy(&m_wfxSrc, pwfxSrc, sizeof(m_wfxSrc));
	memcpy(&m_wfxDst, pwfxDst, sizeof(m_wfxDst));
	m_sampleRateRatio = (float)m_wfxSrc.nSamplesPerSec / m_wfxDst.nSamplesPerSec;
	m_bitsConvertType = GetBitsConvertType(pwfxSrc, pwfxDst);
	m_channelConvertType = GetChannelConvertType(pwfxSrc, pwfxDst);

	m_srcBytesPerSample = m_wfxSrc.wBitsPerSample / 8;
	m_dstBytesPerSample = m_wfxDst.wBitsPerSample / 8;
	m_srcBytesPerFrame = m_srcBytesPerSample * m_wfxSrc.nChannels;
	m_dstBytesPerFrame = m_dstBytesPerSample * m_wfxDst.nChannels;
	m_srcMaxValue = (1UL << m_wfxSrc.wBitsPerSample) - 1;
	m_dstMaxValue = (1UL << m_wfxDst.wBitsPerSample) - 1;

	// Quality is half the window width
	m_wndWidth2 = 1;
	m_wndWidth = m_wndWidth2 * 2 + 1;

	if (bufferFrameCount == 0)
	{
		bufferFrameCount = m_wfxSrc.nSamplesPerSec / 2;
	}
	else if (m_wfxSrc.nSamplesPerSec != m_wfxDst.nSamplesPerSec)
	{
		bufferFrameCount = bufferFrameCount * m_wfxSrc.nSamplesPerSec / m_wfxDst.nSamplesPerSec + m_wndWidth;
	}

	if (m_srcBufferFrameCount != bufferFrameCount)
	{
		m_srcBufferFrameCount = bufferFrameCount;
		SAFE_DELETE_A(m_buffer1.pData);
		SAFE_DELETE_A(m_buffer2.pData);
		m_buffer1.pData = new char[m_srcBufferFrameCount * m_srcBytesPerFrame];
		m_buffer2.pData = new char[m_srcBufferFrameCount * m_srcBytesPerFrame];
	}
	m_buffer1.index = 0;
	m_buffer1.count = 0;
	m_buffer2.index = 0;
	m_buffer2.count = 0;
}

void WaveConverter::Reset()
{
	m_srcFrameIndexFloat = 0;
	m_srcFrameIndex = 0;
	m_dstFrameIndex = 0;
}

uint32_t WaveConverter::ReadFrame(char *pDataDst, uint32_t dstFrameCount)
{
	if (m_wfxSrc.nSamplesPerSec != m_wfxDst.nSamplesPerSec)
	{
		return ReadFrameResample(pDataDst, dstFrameCount);
	}
	else
	{
		return ReadFrameNormal(pDataDst, dstFrameCount);
	}
}

uint32_t WaveConverter::ReadFrameResample(char *pDataDst, uint32_t dstFrameCount)
{
	uint32_t dstCount = dstFrameCount;
	while (dstCount > 0)
	{
		if (m_srcFrameIndex + m_wndWidth2 < m_buffer1.index + m_buffer1.count)
		{
			uint32_t nwrite = ResampleSingle(pDataDst, dstCount);
			dstCount -= nwrite;
			pDataDst += nwrite * m_dstBytesPerFrame;
		}
		else
		{
			swap(m_buffer1, m_buffer2);
			m_buffer1.index = m_buffer2.index + m_buffer2.count;
			m_buffer1.count = LoadSrcFrame(m_buffer1.pData, m_srcBufferFrameCount);
			if (m_buffer1.count == 0)
				break;
		}
	}
	return dstFrameCount - dstCount;
}

uint32_t WaveConverter::ReadFrameNormal(char *pDataDst, uint32_t frameCount)
{
	if (frameCount <= m_srcBufferFrameCount)
	{
		uint32_t rcount = LoadSrcFrame(m_buffer1.pData, frameCount);
		uint32_t wcount = ConvertNormal(m_buffer1.pData, pDataDst, rcount);
		return wcount;
	}
	else
	{
		uint32_t dstCount = frameCount;
		while (dstCount > 0)
		{
			uint32_t rcount = LoadSrcFrame(m_buffer1.pData, min(dstCount, m_srcBufferFrameCount));
			if (rcount == 0)
				break;
			uint32_t wcount = ConvertNormal(m_buffer1.pData, pDataDst, rcount);
			dstCount -= wcount;
			pDataDst += wcount * m_dstBytesPerFrame;
		}
		return frameCount - dstCount;
	}
}

// need to repair!!!
uint32_t WaveConverter::Resample(char *pDataDst, uint32_t frameCount)
{
	// fmax : nyqist half of destination sampleRate
	// fmax / fsr = 0.5;
	float fmaxDivSR = 0.5;
	float r_g = 2 * fmaxDivSR;

	const uint32_t maxSrcIndex = m_buffer1.index + m_buffer1.count - m_wndWidth2;
	uint32_t index = 0;
	for (; index < frameCount; ++index)
	{
		if (m_srcFrameIndex >= maxSrcIndex)
			break;

		for (int c = 0; c < m_wfxDst.nChannels; ++c)
		{
			float r_y = 0;
			for (int tau = -m_wndWidth2; tau <= m_wndWidth2; ++tau)
			{
				// input sample index
				int j = (int)(m_srcFrameIndexFloat + tau);
				if (j < 0)
					continue;

				// Hann Window. Scale and calculate sinc
				//float r_w = 0.5 * (1 - cosf(PI_2 * (tau + m_wndWidth2) / m_wndWidth));
				float r_w = (float)(0.5 - 0.5 * cos(PI_2 *(0.5 + (j - m_srcFrameIndexFloat) / m_wndWidth)));
				float r_a = (float)(PI_2 * ((double)j - m_srcFrameIndexFloat) * fmaxDivSR);
				float r_snc = 1.0;
				if (r_a != 0)
				{
					r_snc = sinf(r_a) / r_a;
				}

				int32_t value;
				if ((uint32_t)j < m_buffer1.index)
				{
					value = ParseSample(m_buffer2.pData + (j - m_buffer2.index) * m_srcBytesPerFrame + c * m_srcBytesPerSample);
				}
				else
				{
					value = ParseSample(m_buffer1.pData + (j - m_buffer1.index) * m_srcBytesPerFrame + c * m_srcBytesPerSample);
				}

				r_y += r_g * r_w * r_snc * value;
			}

			WriteSample(pDataDst, (uint32_t)abs(r_y));
			pDataDst += m_dstBytesPerSample;
		}

		m_dstFrameIndex++;
		m_srcFrameIndexFloat = m_dstFrameIndex * m_sampleRateRatio;
		m_srcFrameIndex = (int)m_srcFrameIndexFloat;
	}

	return index;
}

uint32_t WaveConverter::ResampleSingle(char *pDataDst, uint32_t frameCount)
{
	const uint32_t maxSrcIndex = m_buffer1.index + m_buffer1.count;
	uint32_t index = 0;
	for (; index < frameCount; ++index)
	{
		const char *pDataSrc = NULL;
		if (m_srcFrameIndex < m_buffer1.index)
		{
			pDataSrc = m_buffer2.pData + (m_srcFrameIndex - m_buffer2.index) * m_srcBytesPerFrame;
		}
		else if (m_srcFrameIndex < maxSrcIndex)
		{
			pDataSrc = m_buffer1.pData + (m_srcFrameIndex - m_buffer1.index) * m_srcBytesPerFrame;
		}
		else
		{
			break;
		}

		ConvertFrame(pDataSrc, pDataDst);

		pDataDst += m_dstBytesPerFrame;

		m_dstFrameIndex++;
		m_srcFrameIndex = (uint32_t)roundf(m_dstFrameIndex * m_sampleRateRatio);
	}
	return index;
}

uint32_t WaveConverter::ResampleDouble(char *pDataDst, uint32_t frameCount)
{
	const uint32_t maxSrcIndex = m_buffer1.index + m_buffer1.count;
	uint32_t srcIndex1 = m_srcFrameIndex;
	uint32_t srcIndex2 = (uint32_t)ceilf(m_srcFrameIndexFloat);
	uint32_t index = 0;

	for (; index < frameCount; ++index)
	{
		const char *pDataSrc1 = NULL;
		if (srcIndex1 < m_buffer1.index) {
			pDataSrc1 = m_buffer2.pData + (srcIndex1 - m_buffer2.index) * m_srcBytesPerFrame;
		}
		else if (srcIndex1 < maxSrcIndex) {
			pDataSrc1 = m_buffer1.pData + (srcIndex1 - m_buffer1.index) * m_srcBytesPerFrame;
		}
		else {
			break;
		}

		if (srcIndex1 != srcIndex2 && srcIndex2 < maxSrcIndex)
		{
			const char *pDataSrc2 = NULL;
			if (srcIndex2 < m_buffer1.index) {
				pDataSrc2 = m_buffer2.pData + (srcIndex2 - m_buffer2.index) * m_srcBytesPerFrame;
			}
			else {
				pDataSrc2 = m_buffer1.pData + (srcIndex2 - m_buffer1.index) * m_srcBytesPerFrame;
			}

			float factor2 = m_srcFrameIndexFloat - srcIndex1;
			float factor1 = 1 - factor2;

			if (factor1 > factor2)
			{
				factor2 *= 0.01f;
				factor1 = 1 - factor2;
			}
			else
			{
				factor1 *= 0.01f;
				factor2 = 1 - factor1;
			}

			ConvertFrame(pDataDst, pDataSrc1, factor1, pDataSrc2, factor2);
		}
		else
		{
			ConvertFrame(pDataSrc1, pDataDst);
		}

		pDataDst += m_dstBytesPerFrame;

		m_dstFrameIndex++;
		m_srcFrameIndexFloat = m_dstFrameIndex * m_sampleRateRatio;
		srcIndex1 = (uint32_t)m_srcFrameIndexFloat;
		srcIndex2 = (uint32_t)ceilf(m_srcFrameIndexFloat);
	}

	m_srcFrameIndex = srcIndex1;
	return index;
}

uint32_t WaveConverter::ConvertNormal(const char *pDataSrc, char *pDataDst, uint32_t frameCount)
{
	for (uint32_t i = 0; i < frameCount; ++i)
	{
		ConvertFrame(pDataSrc, pDataDst);
		pDataSrc += m_srcBytesPerFrame;
		pDataDst += m_dstBytesPerFrame;
	}
	return frameCount;
}

void WaveConverter::ConvertFrame(const char *pDataSrc, char *pDataDst)
{
	switch (m_channelConvertType)
	{
	case WaveConverter::ChannelConvertType::CCT_1_1:
	case WaveConverter::ChannelConvertType::CCT_2_1:
		{
			ConvertSample(pDataSrc, pDataDst);
		}
		break;
	case WaveConverter::ChannelConvertType::CCT_1_2:
		{
			ConvertSample(pDataSrc, pDataDst);
			ConvertSample(pDataSrc, pDataDst + m_dstBytesPerSample);
		}
		break;
	case WaveConverter::ChannelConvertType::CCT_2_2:
		{
			ConvertSample(pDataSrc, pDataDst);
			ConvertSample(pDataSrc + m_srcBytesPerSample, pDataDst + m_dstBytesPerSample);
		}
		break;
	case WaveConverter::ChannelConvertType::CCT_EQ:
	case WaveConverter::ChannelConvertType::CCT_GT:
		{
			for (int c = 0; c < m_wfxDst.nChannels; ++c)
			{
				ConvertSample(pDataSrc + c * m_srcBytesPerSample, pDataDst + c * m_dstBytesPerSample);
			}
		}
		break;
	case WaveConverter::ChannelConvertType::CCT_LT:
		{
			for (int index = 0; index < m_wfxDst.nChannels; index += m_wfxSrc.nChannels)
			{
				for (int c = 0; c < m_wfxSrc.nChannels; ++c)
				{
					ConvertSample(pDataSrc + c * m_srcBytesPerSample, pDataDst + (index + c) * m_dstBytesPerSample);
				}
			}
		}
		break;
	default:
		assert(false);
		break;
	}
}

void WaveConverter::ConvertFrame(char *pDataDst, const char *pDataSrc1, float factor1, const char *pDataSrc2, float factor2)
{
	switch (m_channelConvertType)
	{
	case WaveConverter::ChannelConvertType::CCT_1_1:
	case WaveConverter::ChannelConvertType::CCT_2_1:
		{
			ConvertSample(pDataDst, pDataSrc1, factor1, pDataSrc2, factor2);
		}
		break;
	case WaveConverter::ChannelConvertType::CCT_1_2:
		{
			ConvertSample(pDataDst, pDataSrc1, factor1, pDataSrc2, factor2);
			pDataDst += m_dstBytesPerSample;
			ConvertSample(pDataDst, pDataSrc1, factor1, pDataSrc2, factor2);
		}
		break;
	case WaveConverter::ChannelConvertType::CCT_2_2:
		{
			ConvertSample(pDataDst, pDataSrc1, factor1, pDataSrc2, factor2);
			pDataSrc1 += m_srcBytesPerSample;
			pDataSrc2 += m_srcBytesPerSample;
			pDataDst += m_dstBytesPerSample;
			ConvertSample(pDataDst, pDataSrc1, factor1, pDataSrc2, factor2);
		}
		break;
	default:
		break;
	}
}

void WaveConverter::ConvertSample(char *pDataDst, const char *pDataSrc1, float factor1, const char *pDataSrc2, float factor2)
{
	uint32_t src1 = ParseSample(pDataSrc1);
	uint32_t src2 = ParseSample(pDataSrc2);

	float value = src1 * factor1 + src2 * factor2;
	uint32_t dst = value > m_srcMaxValue ? m_srcMaxValue : (uint32_t)value;;

	WriteSample(pDataDst, dst);
}

static inline uint8_t Parse08BitsValue(const char *pDataSrc)
{
	return *(int8_t*)pDataSrc + 128;
}

static inline void Write08BitsValue(char *pDataDst, uint8_t dst)
{
	*(int8_t*)pDataDst = dst - 128;
}

static inline uint16_t Parse16BitsValue(const char *pDataSrc)
{
	return *(uint16_t*)pDataSrc;
}

static inline void Write16BitsValue(char *pDataDst, uint16_t dst)
{
	*(uint16_t*)pDataDst = dst;
}

static inline uint32_t Parse24BitsValue(const char *pDataSrc)
{
	uint32_t src = *(uint8_t*)pDataSrc;
	src |= (uint32_t)(*(uint8_t*)(pDataSrc + 1)) << 8;
	src |= (uint32_t)(*(uint8_t*)(pDataSrc + 2)) << 16;
	return src;
}

static inline void Write24BitsValue(char *pDataDst, uint32_t dst)
{
	*(uint8_t*)(pDataDst + 0) = (dst) & 0xFF;
	*(uint8_t*)(pDataDst + 1) = (dst >> 8) & 0xFF;
	*(uint8_t*)(pDataDst + 2) = (dst >> 16) & 0xFF;
}

static inline uint32_t Parse32BitsValue(const char *pDataSrc, WORD formatTag)
{
	uint32_t src;
	if (formatTag == 3)
		src = (uint32_t)(*(float*)pDataSrc * (1U << 31));
	else
		src = *(uint32_t*)pDataSrc;
	return src;
}

static inline void Write32BitsValue(char *pDataDst, uint32_t dst, WORD formatTag)
{
	if (formatTag == 3)
		*(float*)pDataDst = (float)dst / (1U << 31);
	else
		*(uint32_t*)pDataDst = dst;
}

// little-endian !!!
void WaveConverter::ConvertSample(const char *pDataSrc, char *pDataDst)
{
	switch (m_bitsConvertType)
	{
	case WaveConverter::BitsConvertType::Bit_Equal:
		{
			memcpy(pDataDst, pDataSrc, m_dstBytesPerFrame);
		}
		break;
	case WaveConverter::BitsConvertType::Bit_08_08:
		{
			uint8_t src = *(uint8_t*)pDataSrc;
			*(uint8_t*)pDataDst = src;
		}
		break;
	case WaveConverter::BitsConvertType::Bit_08_16:
		{
			uint32_t src = Parse08BitsValue(pDataSrc);
			uint16_t dst = src << 8;
			Write16BitsValue(pDataDst, dst);
		}
		break;
	case WaveConverter::BitsConvertType::Bit_08_24:
		{
			uint32_t src = Parse08BitsValue(pDataSrc);
			uint32_t dst = src << 16;
			Write24BitsValue(pDataDst, dst);
		}
		break;
	case WaveConverter::BitsConvertType::Bit_08_32:
		{
			uint32_t src = Parse08BitsValue(pDataSrc);
			uint32_t dst = src << 24;
			Write32BitsValue(pDataDst, dst, m_wfxDst.wFormatTag);
		}
		break;
	case WaveConverter::BitsConvertType::Bit_16_08:
		{
			uint32_t src = Parse16BitsValue(pDataSrc);
			uint32_t dst = (src >> 8);
			Write08BitsValue(pDataDst, dst);
		}
		break;
	case WaveConverter::BitsConvertType::Bit_16_16:
		{
			uint16_t src = Parse16BitsValue(pDataSrc);
			Write16BitsValue(pDataDst, src);
		}
		break;
	case WaveConverter::BitsConvertType::Bit_16_24:
		{
			uint32_t src = Parse16BitsValue(pDataSrc);
			uint32_t dst = src << 8;
			Write24BitsValue(pDataDst, dst);
		}
		break;
	case WaveConverter::BitsConvertType::Bit_16_32:
		{
			uint32_t src = Parse16BitsValue(pDataSrc);
			uint32_t dst = src << 16;
			Write32BitsValue(pDataDst, dst, m_wfxDst.wFormatTag);
		}
		break;
	case WaveConverter::BitsConvertType::Bit_24_08:
		{
			uint32_t src = Parse24BitsValue(pDataSrc);
			uint32_t dst = (src >> 16);
			Write08BitsValue(pDataDst, dst);
		}
		break;
	case WaveConverter::BitsConvertType::Bit_24_16:
		{
			uint32_t src = Parse24BitsValue(pDataSrc);
			uint16_t dst = src >> 8;
			Write16BitsValue(pDataDst, dst);
		}
		break;
	case WaveConverter::BitsConvertType::Bit_24_24:
		{
			uint32_t src = Parse24BitsValue(pDataSrc);
			Write24BitsValue(pDataDst, src);
		}
		break;
	case WaveConverter::BitsConvertType::Bit_24_32:
		{
			uint32_t src = Parse24BitsValue(pDataSrc);
			uint32_t dst = src << 8;
			Write32BitsValue(pDataDst, dst, m_wfxDst.wFormatTag);
		}
		break;
	case WaveConverter::BitsConvertType::Bit_32_08:
		{
			uint32_t src = Parse32BitsValue(pDataSrc, m_wfxSrc.wFormatTag);
			uint32_t dst = (src >> 24);
			Write08BitsValue(pDataDst, dst);
		}
		break;
	case WaveConverter::BitsConvertType::Bit_32_16:
		{
			uint32_t src = Parse32BitsValue(pDataSrc, m_wfxSrc.wFormatTag);
			uint16_t dst = src >> 16;
			Write16BitsValue(pDataDst, dst);
		}
		break;
	case WaveConverter::BitsConvertType::Bit_32_24:
		{
			uint32_t src = Parse32BitsValue(pDataSrc, m_wfxSrc.wFormatTag);
			uint32_t dst = src >> 8;
			Write24BitsValue(pDataDst, dst);
		}
		break;
	case WaveConverter::BitsConvertType::Bit_32_32:
		{
			uint32_t src = *(uint32_t*)pDataSrc;
			*(uint32_t*)pDataDst = src;
		}
		break;
	case WaveConverter::BitsConvertType::Bit_32_32f:
		{
			uint32_t src = Parse32BitsValue(pDataSrc, m_wfxSrc.wFormatTag);
			Write32BitsValue(pDataDst, src, m_wfxDst.wFormatTag);
		}
		break;
	case WaveConverter::BitsConvertType::Bit_Undefined:
	default:
		memset(pDataDst, 0, m_dstBytesPerFrame);
		assert(false);
		break;
	}
}

WaveConverter::BitsConvertType WaveConverter::GetBitsConvertType(const WAVEFORMATEX *pwfxSrc, const WAVEFORMATEX *pwfxDst)
{
	switch (pwfxSrc->wBitsPerSample)
	{
	case 8:
		switch (pwfxDst->wBitsPerSample)
		{
		case 8:
			return BitsConvertType::Bit_08_08;
		case 16:
			return BitsConvertType::Bit_08_16;
		case 24:
			return BitsConvertType::Bit_08_24;
		case 32:
			return BitsConvertType::Bit_08_32;
		}
		break;
	case 16:
		switch (pwfxDst->wBitsPerSample)
		{
		case 8:
			return BitsConvertType::Bit_16_08;
		case 16:
			return BitsConvertType::Bit_16_16;
		case 24:
			return BitsConvertType::Bit_16_24;
		case 32:
			return BitsConvertType::Bit_16_32;
		}
		break;
	case 24:
		switch (pwfxDst->wBitsPerSample)
		{
		case 8:
			return BitsConvertType::Bit_24_08;
		case 16:
			return BitsConvertType::Bit_24_16;
		case 24:
			return BitsConvertType::Bit_24_24;
		case 32:
			return BitsConvertType::Bit_24_32;
		}
		break;
	case 32:
		switch (pwfxDst->wBitsPerSample)
		{
		case 8:
			return BitsConvertType::Bit_32_08;
		case 16:
			return BitsConvertType::Bit_32_16;
		case 24:
			return BitsConvertType::Bit_32_24;
		case 32:
			if (pwfxSrc->wFormatTag == pwfxDst->wFormatTag)
				return BitsConvertType::Bit_32_32;
			else
				return BitsConvertType::Bit_32_32f;
		}
		break;
	}

	if (pwfxSrc->wBitsPerSample == pwfxDst->wBitsPerSample &&
		pwfxSrc->wFormatTag == pwfxDst->wFormatTag)
		return BitsConvertType::Bit_Equal;
	else
		return BitsConvertType::Bit_Undefined;
}

WaveConverter::ChannelConvertType WaveConverter::GetChannelConvertType(const WAVEFORMATEX *pwfxSrc, const WAVEFORMATEX *pwfxDst)
{
	switch (pwfxSrc->nChannels)
	{
	case 1:
		{
			switch (pwfxDst->nChannels)
			{
			case 1:
				return ChannelConvertType::CCT_1_1;
			case 2:
				return ChannelConvertType::CCT_1_2;
			}
		}
		break;
	case 2:
		{
			switch (pwfxDst->nChannels)
			{
			case 1:
				return ChannelConvertType::CCT_2_1;
			case 2:
				return ChannelConvertType::CCT_2_2;
			}
		}
		break;
	}

	if (pwfxSrc->nChannels == pwfxDst->nChannels)
		return ChannelConvertType::CCT_EQ;
	else if (pwfxSrc->nChannels < pwfxDst->nChannels)
		return ChannelConvertType::CCT_LT;
	else
		return ChannelConvertType::CCT_GT;
}

uint32_t WaveConverter::ParseSample(const char *pDataSrc)
{
	switch (m_bitsConvertType)
	{
	case WaveConverter::BitsConvertType::Bit_08_08:
	case WaveConverter::BitsConvertType::Bit_08_16:
	case WaveConverter::BitsConvertType::Bit_08_24:
	case WaveConverter::BitsConvertType::Bit_08_32:
		return Parse08BitsValue(pDataSrc);
	case WaveConverter::BitsConvertType::Bit_16_08:
	case WaveConverter::BitsConvertType::Bit_16_16:
	case WaveConverter::BitsConvertType::Bit_16_24:
	case WaveConverter::BitsConvertType::Bit_16_32:
		return Parse16BitsValue(pDataSrc);
	case WaveConverter::BitsConvertType::Bit_24_08:
	case WaveConverter::BitsConvertType::Bit_24_16:
	case WaveConverter::BitsConvertType::Bit_24_24:
	case WaveConverter::BitsConvertType::Bit_24_32:
		return Parse24BitsValue(pDataSrc);
	case WaveConverter::BitsConvertType::Bit_32_08:
	case WaveConverter::BitsConvertType::Bit_32_16:
	case WaveConverter::BitsConvertType::Bit_32_24:
	case WaveConverter::BitsConvertType::Bit_32_32:
	case WaveConverter::BitsConvertType::Bit_32_32f:
		return Parse32BitsValue(pDataSrc, m_wfxSrc.wFormatTag);
	default:
		assert(false);
		return 0;
	}
}

void WaveConverter::WriteSample(char *pDataDst, uint32_t dst)
{
	switch (m_bitsConvertType)
	{
	case WaveConverter::BitsConvertType::Bit_08_08:
		Write08BitsValue(pDataDst, dst);
		break;
	case WaveConverter::BitsConvertType::Bit_08_16:
		Write16BitsValue(pDataDst, dst << 8);
		break;
	case WaveConverter::BitsConvertType::Bit_08_24:
		Write24BitsValue(pDataDst, dst << 16);
		break;
	case WaveConverter::BitsConvertType::Bit_08_32:
		Write32BitsValue(pDataDst, dst << 24, m_wfxDst.wFormatTag);
		break;
	case WaveConverter::BitsConvertType::Bit_16_08:
		Write08BitsValue(pDataDst, dst >> 8);
		break;
	case WaveConverter::BitsConvertType::Bit_16_16:
		Write16BitsValue(pDataDst, dst);
		break;
	case WaveConverter::BitsConvertType::Bit_16_24:
		Write24BitsValue(pDataDst, dst << 8);
		break;
	case WaveConverter::BitsConvertType::Bit_16_32:
		Write32BitsValue(pDataDst, dst << 16, m_wfxDst.wFormatTag);
		break;
	case WaveConverter::BitsConvertType::Bit_24_08:
		Write08BitsValue(pDataDst, dst >> 16);
		break;
	case WaveConverter::BitsConvertType::Bit_24_16:
		Write16BitsValue(pDataDst, dst >> 8);
		break;
	case WaveConverter::BitsConvertType::Bit_24_24:
		Write24BitsValue(pDataDst, dst);
		break;
	case WaveConverter::BitsConvertType::Bit_24_32:
		Write32BitsValue(pDataDst, dst << 8, m_wfxDst.wFormatTag);
		break;
	case WaveConverter::BitsConvertType::Bit_32_08:
		Write08BitsValue(pDataDst, dst >> 24);
		break;
	case WaveConverter::BitsConvertType::Bit_32_16:
		Write16BitsValue(pDataDst, dst >> 16);
		break;
	case WaveConverter::BitsConvertType::Bit_32_24:
		Write24BitsValue(pDataDst, dst >> 8);
		break;
	case WaveConverter::BitsConvertType::Bit_32_32:
	case WaveConverter::BitsConvertType::Bit_32_32f:
		Write32BitsValue(pDataDst, dst, m_wfxDst.wFormatTag);
		break;
	default:
		assert(false);
		memset(pDataDst, 0, m_dstBytesPerSample);
		break;
	}
}

bool WaveConverter::IsSupport(const WAVEFORMATEX *pwfxSrc, const WAVEFORMATEX *pwfxDst)
{
	auto bct = GetBitsConvertType(pwfxSrc, pwfxDst);
	if (bct == BitsConvertType::Bit_Undefined)
		return false;

	auto cct = GetChannelConvertType(pwfxSrc, pwfxDst);
	if (cct == ChannelConvertType::CCT_GT || cct == ChannelConvertType::CCT_LT)
		return false;

	return true;
}

```

`WaveUtil/WaveConverter.h`:

```h
#pragma once
#include "WaveFile.h"
#include "WaveUtil.h"

class WaveConverter
{
public:
	WaveConverter();
	~WaveConverter();

	void SetFormat(const WAVEFORMATEX *pwfxSrc, const WAVEFORMATEX *pwfxDst, uint32_t bufferFrameCount = 0);
	void Reset();

	uint32_t ReadFrame(char *pData, uint32_t frameCount);

	bool IsSupport(const WAVEFORMATEX *pwfxSrc, const WAVEFORMATEX *pwfxDst);

protected:
	virtual uint32_t LoadSrcFrame(char *pData, uint32_t frameCount) = 0;

private:
	uint32_t ReadFrameResample(char *pDataDst, uint32_t frameCount);
	uint32_t ReadFrameNormal(char *pDataDst, uint32_t frameCount);

	uint32_t Resample(char *pDataDst, uint32_t frameCount);
	uint32_t ResampleSingle(char *pDataDst, uint32_t frameCount);
	uint32_t ResampleDouble(char *pDataDst, uint32_t frameCount);
	uint32_t ConvertNormal(const char *pDataSrc, char *pDataDst, uint32_t frameCount);

	void ConvertFrame(const char *pDataSrc, char *pDataDst);
	void ConvertSample(const char *pDataSrc, char *pDataDst);

	void ConvertFrame(char *pDataDst, const char *pDataSrc1, float factor1, const char *pDataSrc2, float factor2);
	void ConvertSample(char *pDataDst, const char *pDataSrc1, float factor1, const char *pDataSrc2, float factor2);

	uint32_t ParseSample(const char *pDataSrc);
	void WriteSample(char *pDataDst, uint32_t value);

protected:
	WAVEFORMATEX m_wfxSrc;
	WAVEFORMATEX m_wfxDst;
	float m_sampleRateRatio;
	uint32_t m_srcBytesPerSample;
	uint32_t m_dstBytesPerSample;
	uint32_t m_srcBytesPerFrame;
	uint32_t m_dstBytesPerFrame;
	uint32_t m_srcMaxValue;
	uint32_t m_dstMaxValue;
private:
	uint32_t m_srcFrameIndex;
	uint32_t m_dstFrameIndex;
	uint32_t m_srcBufferFrameCount;
	float m_srcFrameIndexFloat;
	int m_wndWidth;
	int m_wndWidth2;

	struct Buffer
	{
		char *pData;
		uint32_t index;
		uint32_t count;
	};

	Buffer m_buffer1;
	Buffer m_buffer2;

private:
	enum class BitsConvertType
	{
		Bit_Equal,
		Bit_08_08,
		Bit_08_16,
		Bit_08_24,
		Bit_08_32,
		Bit_16_08,
		Bit_16_16,
		Bit_16_24,
		Bit_16_32,
		Bit_24_08,
		Bit_24_16,
		Bit_24_24,
		Bit_24_32,
		Bit_32_08,
		Bit_32_16,
		Bit_32_24,
		Bit_32_32,
		Bit_32_32f,
		Bit_Undefined,
	};

	enum class ChannelConvertType
	{
		CCT_1_1,
		CCT_1_2,
		CCT_2_2,
		CCT_2_1,
		CCT_EQ,
		CCT_LT,
		CCT_GT,
	};

	static BitsConvertType GetBitsConvertType(const WAVEFORMATEX *pwfxSrc, const WAVEFORMATEX *pwfxDst);
	static ChannelConvertType GetChannelConvertType(const WAVEFORMATEX *pwfxSrc, const WAVEFORMATEX *pwfxDst);

	BitsConvertType m_bitsConvertType;
	ChannelConvertType m_channelConvertType;
};


```

`WaveUtil/WaveFile.cpp`:

```cpp
#include "stdafx.h"
#include "WaveFile.h"
#include "CommUtil/CommUtil.hpp"
#include "CommUtil/Logger.h"
#include "CommUtil/endian.h"
#include <assert.h>

using namespace comm_util;

const uint32_t WaveFile::RIFF_CHUNK_ID = little_endian() ? 0x46464952 : 0x52494646; // "RIFF" big-endian
const uint32_t WaveFile::RIFF_CHUNK_FMT = little_endian() ? 0x45564157 : 0x57415645; // "WAVE" big-endian
const uint32_t WaveFile::FORMAT_CHUNK_ID = little_endian() ? 0x20746d66 : 0x666d7420; // "fmt " big-endian
const uint32_t WaveFile::DATA_CHUNK_ID = little_endian() ? 0x61746164 : 0x64617461; // "data" big-endian

WaveFile::WaveFile()
{
	memset(&m_info, 0, sizeof(m_info));
}

WaveFile::~WaveFile()
{
	Clear();
	m_inFile.close();
	m_outFile.close();
}

void WaveFile::Clear()
{
	SAFE_DELETE_A(m_info.fmt.pExtParam);
	SAFE_DELETE_A(m_info.data.pData);

	m_info.fmt.extParamSize = 0;
	m_info.fmt.chunkSize = 16; // !!!
	SetDataChunkSize(0);
}

bool WaveFile::Load(const char *fileName)
{
	bool bOk = false;
	do
	{
		if (!BeginRead(fileName))
			break;

		m_info.data.pData = new char[m_info.data.chunkSize];
		if (!m_info.data.pData)
		{
			Logger::LogError("alloc memory failed.\n");
			assert(false);
			break;
		}

		if (ReadData(m_info.data.pData, m_info.data.chunkSize) != m_info.data.chunkSize)
		{
			Logger::LogError("Wave data chunk size error.\n");
			break;
		}

		bOk = true;
	} while (false);

	EndRead();

	return bOk;
}

bool WaveFile::Save(const char *fileName)
{
	bool bOk = false;
	do
	{
		if (!BeginWrite(fileName, false))
			break;

		if (!WriteData(m_info.data.pData, m_info.data.chunkSize))
			break;

		bOk = true;
	} while (false);

	EndWrite();

	return bOk;
}

bool WaveFile::ReadHead(std::fstream &file)
{
	file.seekg(0, std::ios::end);
	long fileLen = (long)file.tellg();
	file.seekg(0, std::ios::beg);

	// riff chunk
	file.read((char*)&m_info.riff, 12);
	if (!file
		|| m_info.riff.chunkId != RIFF_CHUNK_ID
		|| m_info.riff.chunkSize != fileLen - 8
		|| m_info.riff.format != RIFF_CHUNK_FMT)
	{
		Logger::LogError("Wave RIFF chunk format error.\n");
		return false;
	}

	// format chunk
	file.read((char*)&m_info.fmt, 24);
	if (!file || m_info.fmt.chunkId != FORMAT_CHUNK_ID)
	{
		Logger::LogError("Wave fmt chunk format error.\n");
		return false;
	}

	if (m_info.fmt.chunkSize > 16)
	{
		file.read((char*)&m_info.fmt.extParamSize, 2);
		if (!file || m_info.fmt.chunkSize != m_info.fmt.extParamSize + 16 + 2)
		{
			Logger::LogError("Wave fmt chunk size error.\n");
			return false;
		}

		if (m_info.fmt.extParamSize > 0)
		{
			m_info.fmt.pExtParam = new char[m_info.fmt.extParamSize];
			if (!m_info.fmt.pExtParam)
			{
				Logger::LogError("alloc memory failed.\n");
				assert(false);
				return false;
			}

			file.read(m_info.fmt.pExtParam, m_info.fmt.extParamSize);
			if (!file)
			{
				Logger::LogError("Wave fmt chunk ext param error.\n");
				return false;
			}
		}
		else
		{
			m_info.fmt.pExtParam = NULL;
		}
	}
	else
	{
		m_info.fmt.extParamSize = 0;
		m_info.fmt.pExtParam = NULL;
	}

	// data chunk
	file.read((char*)&m_info.data, 8);
	if (!file || m_info.data.chunkId != DATA_CHUNK_ID)
	{
		Logger::LogError("Wave data chunk format error.\n");
		return false;
	}

	// many wave file's data chunk size invalid, so here just correct it.
	uint32_t dataSize = m_info.riff.chunkSize - m_info.fmt.chunkSize - 20;
	if (m_info.data.chunkSize > dataSize)
	{
		SetDataChunkSize(dataSize);
	}
	else if (m_info.data.chunkSize < dataSize)
	{
		SetDataChunkSize(m_info.data.chunkSize);
	}

	UpdateFormat();

	return true;
}

bool WaveFile::WriteHead(std::fstream &file)
{
	if (m_info.riff.chunkSize != m_info.fmt.chunkSize + m_info.data.chunkSize + 20)
	{
		Logger::LogError("Wave chunkSize error.\n");
		return false;
	}

	// riff chunk
	file.write((char*)&m_info.riff, 12);
	if (!file)
	{
		Logger::LogError("Write file error.\n");
		return false;
	}

	// format chunk
	file.write((char*)&m_info.fmt, 24);
	if (!file)
	{
		Logger::LogError("Write file error.\n");
		return false;
	}

	if (m_info.fmt.chunkSize > 16)
	{
		file.write((char*)&m_info.fmt.extParamSize, 2);
		if (!file)
		{
			Logger::LogError("Write file error.\n");
			return false;
		}

		if (m_info.fmt.extParamSize > 0)
		{
			file.write(m_info.fmt.pExtParam, m_info.fmt.extParamSize);
			if (!file)
			{
				Logger::LogError("Write file error.\n");
				return false;
			}
		}
	}

	// data chunk
	file.write((char*)&m_info.data, 8);
	if (!file)
	{
		Logger::LogError("Write file error.\n");
		return false;
	}

	return true;
}

bool WaveFile::BeginRead(const char *fileName)
{
	Clear();

	m_inFile.close();
	m_inFile.open(fileName, std::ios::in | std::ios::binary);
	if (!m_inFile.is_open())
	{
		Logger::LogError("Can't open file %s\n", fileName);
		return false;
	}


	return ReadHead(m_inFile);
}

uint32_t WaveFile::ReadData(char *pData, uint32_t count)
{
	m_inFile.read(pData, count);
	if (m_inFile)
		return count;
	else
		return (uint32_t)m_inFile.gcount();
}

uint32_t WaveFile::ReadFrame(char *pData, uint32_t frameCount)
{
	uint32_t count = frameCount * m_nBytesPerFrame;

	m_inFile.read(pData, count);
	if (m_inFile)
		return frameCount;
	else
		return (uint32_t)(m_inFile.gcount() / m_nBytesPerFrame);
}

void WaveFile::EndRead()
{
	m_inFile.close();
}

bool WaveFile::BeginWrite(const char *fileName, bool append)
{
	m_outFile.close();
	m_outFile.open(fileName, std::ios::out | std::ios::binary);
	if (!m_outFile.is_open())
	{
		Logger::LogError("Can't open file %s\n", fileName);
		return false;
	}

	m_info.riff.chunkId = RIFF_CHUNK_ID;
	m_info.riff.format = RIFF_CHUNK_FMT;
	m_info.fmt.chunkId = FORMAT_CHUNK_ID;
	m_info.data.chunkId = DATA_CHUNK_ID;

	m_bAppend = append;
	if (m_bAppend)
	{
		SetDataChunkSize(0);
	}

	return WriteHead(m_outFile);
}

bool WaveFile::WriteData(const char *pData, uint32_t count)
{
	m_outFile.write(pData, count);
	if (!m_outFile)
	{
		Logger::LogError("Write file error.\n");
		return false;
	}

	if (m_bAppend)
	{
		m_info.riff.chunkSize += count;
		m_info.data.chunkSize += count;
	}
	return true;
}

bool WaveFile::WriteFrame(const char *pData, uint32_t frameCount)
{
	return WriteData(pData, frameCount * m_nBytesPerFrame);
}

void WaveFile::EndWrite()
{
	if (m_bAppend)
	{
		m_outFile.seekp(4, std::ios::beg);
		m_outFile.write((char*)&m_info.riff.chunkSize, 4);
		m_outFile.seekp(24LL + m_info.fmt.chunkSize, std::ios::beg);
		m_outFile.write((char*)&m_info.data.chunkSize, 4);
	}
	m_outFile.close();
}

bool WaveFile::SetFormat(const FormatChunk &fmt)
{
	if (fmt.chunkSize != 16 && fmt.chunkSize != fmt.extParamSize + 18)
	{
		Logger::LogError("format chunkSize error.\n");
		return false;
	}

	if (fmt.chunkSize > 18 && fmt.pExtParam == NULL)
	{
		Logger::LogError("format chunkSize error.\n");
		return false;
	}

	memcpy_s(&m_info.fmt, sizeof(m_info.fmt), &fmt, sizeof(fmt));
	m_info.fmt.chunkId = FORMAT_CHUNK_ID;
	m_info.fmt.pExtParam = NULL; // !!!

	UpdateFormat();
	return true;
}

const WaveFile::FormatChunk* WaveFile::GetFormat() const
{
	return &m_info.fmt;
}

void WaveFile::UpdateFormat()
{
	m_nBytesPerSample = m_info.fmt.bitsPerSample / 8;
	m_nBytesPerFrame = m_info.fmt.numChannels * m_nBytesPerSample;
}

void WaveFile::SetDataChunkSize(uint32_t size)
{
	m_info.data.chunkSize = size;
	m_info.riff.chunkSize = m_info.fmt.chunkSize + m_info.data.chunkSize + 20;
}

void WaveFile::TakeData(char **ppData, uint32_t *pDataLen)
{
	*ppData = m_info.data.pData;
	*pDataLen = m_info.data.chunkSize;

	m_info.data.pData = NULL;
	SetDataChunkSize(0);
}

void WaveFile::GiveData(char *pData, uint32_t dataLen)
{
	SAFE_DELETE_A(m_info.data.pData);

	m_info.data.pData = pData;
	SetDataChunkSize(dataLen);
}

std::fstream& WaveFile::InStream()
{
	return m_inFile;
}

```

`WaveUtil/WaveFile.h`:

```h
#pragma once
#include <cstdint>
#include <fstream>

class WaveFile
{
public:
#pragma pack(push)
#pragma pack(2)
	const static uint32_t RIFF_CHUNK_ID; // "RIFF" big-endian
	const static uint32_t RIFF_CHUNK_FMT; // "WAVE" big-endian
	const static uint32_t FORMAT_CHUNK_ID; // "fmt " big-endian
	const static uint32_t DATA_CHUNK_ID; // "data" big-endian

	struct RiffChunk
	{
		uint32_t chunkId; // "RIFF"
		uint32_t chunkSize;
		uint32_t format; // "WAVE"
	};

	struct FormatChunk
	{
		uint32_t chunkId; // "fmt "
		uint32_t chunkSize;
		uint16_t audioFormat;
		uint16_t numChannels;
		uint32_t sampleRate;
		uint32_t byteRate;
		uint16_t blockAlign;
		uint16_t bitsPerSample;
		uint16_t extParamSize;
		char* pExtParam;
	};

	struct DataChunk
	{
		uint32_t chunkId; // "data"
		uint32_t chunkSize;
		char *pData;
	};

	struct WaveInfo
	{
		RiffChunk riff;
		FormatChunk fmt;
		DataChunk data;
	};
#pragma pack(pop)

public:
	WaveFile();
	~WaveFile();

	void Clear();

	bool Load(const char *fileName);
	bool Save(const char *fileName);

	bool BeginWrite(const char *fileName, bool append);
	bool WriteData(const char *pData, uint32_t count);
	bool WriteFrame(const char *pData, uint32_t frameCount);
	void EndWrite();

	bool BeginRead(const char *fileName);
	uint32_t ReadData(char *pData, uint32_t count);
	uint32_t ReadFrame(char *pData, uint32_t frameCount);
	void EndRead();

	inline uint32_t FrameCount() const;
	inline uint32_t BytesPerSample() const;
	inline uint32_t BytesPerFrame() const;

	bool SetFormat(const FormatChunk &fmt);
	const FormatChunk* GetFormat() const;

	void TakeData(char **ppData, uint32_t *pDataLen);
	void GiveData(char *pData, uint32_t dataLen);

	std::fstream& InStream();

protected:
	bool ReadHead(std::fstream &file);
	bool WriteHead(std::fstream &file);

	void UpdateFormat();
	void SetDataChunkSize(uint32_t size);

protected:
	WaveInfo m_info;

	std::fstream m_inFile;
	std::fstream m_outFile;
	bool m_bAppend;

	uint32_t m_nBytesPerSample;
	uint32_t m_nBytesPerFrame;
};


inline uint32_t WaveFile::BytesPerSample() const
{
	return m_nBytesPerSample;
}

inline uint32_t WaveFile::BytesPerFrame() const
{
	return m_nBytesPerFrame;
}

inline uint32_t WaveFile::FrameCount() const
{
	return m_info.data.chunkSize / BytesPerFrame();
}

```

`WaveUtil/WaveStreamConverter.cpp`:

```cpp
#include "stdafx.h"
#include "WaveStreamConverter.h"

WaveStreamConverter::WaveStreamConverter(std::istream *stream)
{
	SetStream(stream);
}

WaveStreamConverter::~WaveStreamConverter()
{
}

void WaveStreamConverter::SetStream(std::istream *stream)
{
	m_stream = stream;
}

uint32_t WaveStreamConverter::LoadSrcFrame(char *pData, uint32_t frameCount)
{
	m_stream->read(pData, (std::streamsize)frameCount * m_srcBytesPerFrame);
	if (*m_stream)
	{
		return frameCount;
	}
	else
	{
        std::streamsize readCount = m_stream->gcount();
        std::streamsize readFrameCount = readCount / m_srcBytesPerFrame;
        std::streamsize count = readFrameCount * m_srcBytesPerFrame;
        if (count < readCount)
        {
            m_stream->seekg(-(std::streamoff)(readCount - count), std::ios::cur);
        }
        return (uint32_t)readFrameCount;
	}
}
```

`WaveUtil/WaveStreamConverter.h`:

```h
#pragma once
#include "WaveConverter.h"
#include <istream>

class WaveStreamConverter : public WaveConverter
{
public:
	WaveStreamConverter(std::istream *stream = NULL);
	~WaveStreamConverter();

	void SetStream(std::istream *stream);

protected:
	virtual uint32_t LoadSrcFrame(char *pData, uint32_t frameCount);

private:
	std::istream *m_stream;
};


```

`WaveUtil/WaveUtil.cpp`:

```cpp
#include "stdafx.h"
#include "WaveUtil.h"

WaveUtil::WaveUtil()
{
}

WaveUtil::~WaveUtil()
{
}

void WaveUtil::ConvertFormat(const WaveFile::FormatChunk *pfmt, WAVEFORMATEX *pwfx)
{
	pwfx->wFormatTag = pfmt->audioFormat;
	pwfx->nChannels = pfmt->numChannels;
	pwfx->nSamplesPerSec = pfmt->sampleRate;
	pwfx->nAvgBytesPerSec = pfmt->byteRate;
	pwfx->nBlockAlign = pfmt->blockAlign;
	pwfx->wBitsPerSample = pfmt->bitsPerSample;
	pwfx->cbSize = 0;
}

void WaveUtil::ConvertFormat(const WAVEFORMATEX *pwfx, WaveFile::FormatChunk *pfmt)
{
	pfmt->audioFormat = pwfx->wFormatTag;
	pfmt->numChannels = pwfx->nChannels;
	pfmt->sampleRate = pwfx->nSamplesPerSec;
	pfmt->byteRate = pwfx->nAvgBytesPerSec;
	pfmt->blockAlign = pwfx->nBlockAlign;
	pfmt->bitsPerSample = pwfx->wBitsPerSample;
	pfmt->extParamSize = 0;
	pfmt->pExtParam = NULL;
	pfmt->chunkSize = 16;
}

void WaveUtil::SetFormat(WAVEFORMATEX *pwfx, int sampleRate, int bitsPerSample, int channel)
{
	pwfx->nChannels = channel;
	pwfx->nSamplesPerSec = sampleRate;
	pwfx->wBitsPerSample = bitsPerSample;
	pwfx->nBlockAlign = (channel * bitsPerSample) >> 3;
	pwfx->nAvgBytesPerSec = (sampleRate * channel * bitsPerSample) >> 3;
}

bool WaveUtil::IsSameFormat(const WAVEFORMATEX *pwfx, const WaveFile::FormatChunk *pfmt)
{
	return pwfx->nSamplesPerSec == pfmt->sampleRate
		&& pwfx->wBitsPerSample == pfmt->bitsPerSample
		&& pwfx->nChannels == pfmt->numChannels;
}

bool WaveUtil::IsSameFormat(const WAVEFORMATEX *pwfx, const WAVEFORMATEX *pwfx2)
{
	return pwfx->nSamplesPerSec == pwfx2->nSamplesPerSec
		&& pwfx->wBitsPerSample == pwfx2->wBitsPerSample
		&& pwfx->nChannels == pwfx2->nChannels;
}

bool WaveUtil::LoadWave(const char *path, WAVEFORMATEX *pwfx, char **ppData, uint32_t *pDataLen)
{
	WaveFile wave;
	if (wave.Load(path))
	{
		ConvertFormat(wave.GetFormat(), pwfx);
		wave.TakeData(ppData, pDataLen);
		return true;
	}
	return false;
}

bool WaveUtil::SaveWave(const char *path, WAVEFORMATEX *pwfx, char *pData, uint32_t dataLen)
{
	WaveFile wave;
	WaveFile::FormatChunk format;
	ConvertFormat(pwfx, &format);
	wave.SetFormat(format);
	wave.GiveData(pData, dataLen);
	bool ret = wave.Save(path);
	wave.TakeData(&pData, &dataLen);
	return ret;
}

```

`WaveUtil/WaveUtil.h`:

```h
#pragma once
#include <Audioclient.h>
#include "WaveFile.h"

class WaveUtil
{
public:
	WaveUtil();
	~WaveUtil();

	static bool LoadWave(const char *path, WAVEFORMATEX *pwfx, char **ppData, uint32_t *pDataLen);
	static bool SaveWave(const char *path, WAVEFORMATEX *pwfx, char *pData, uint32_t dataLen);

	static void ConvertFormat(const WaveFile::FormatChunk *pfmt, WAVEFORMATEX *pwfx);
	static void ConvertFormat(const WAVEFORMATEX *pwfx, WaveFile::FormatChunk *pfmt);

	static void SetFormat(WAVEFORMATEX *pwfx, int sampleRate, int bitsPerSample, int channel);

	static bool IsSameFormat(const WAVEFORMATEX *pwfx, const WaveFile::FormatChunk *pfmt);
	static bool IsSameFormat(const WAVEFORMATEX *pwfx, const WAVEFORMATEX *pwfx2);
};


```

`WaveUtil/WaveUtil.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{67493328-FEFE-4D0C-B747-AEBAF569E29D}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>WaveUtil</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="WaveConverter.h" />
    <ClInclude Include="WaveStreamConverter.h" />
    <ClInclude Include="WaveFile.h" />
    <ClInclude Include="WaveUtil.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="WaveConverter.cpp" />
    <ClCompile Include="WaveStreamConverter.cpp" />
    <ClCompile Include="WaveFile.cpp" />
    <ClCompile Include="WaveUtil.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`WaveUtil/WaveUtil.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="WaveConverter.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="WaveFile.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="WaveUtil.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="WaveStreamConverter.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="WaveConverter.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="WaveFile.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="WaveUtil.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="WaveStreamConverter.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`WaveUtil/stdafx.cpp`:

```cpp
// stdafx.cpp : 只包括标准包含文件的源文件
// WaveUtil.pch 将作为预编译头
// stdafx.obj 将包含预编译类型信息

#include "stdafx.h"

// TODO: 在 STDAFX.H 中引用任何所需的附加头文件，
//而不是在此文件中引用

```

`WaveUtil/stdafx.h`:

```h
// stdafx.h : 标准系统包含文件的包含文件，
// 或是经常使用但不常更改的
// 特定于项目的包含文件
//

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN             // 从 Windows 头中排除极少使用的资料



// TODO:  在此处引用程序需要的其他头文件

```

`WaveUtil/targetver.h`:

```h
#pragma once

// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。

// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将
// 将 _WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。

#include <SDKDDKVer.h>

```

`Win32Util/Audio/AudioCapture.cpp`:

```cpp
#pragma execution_character_set("utf-8")
#include "stdafx.h"
#include "AudioCapture.h"
#include "AudioUtil.h"
#include <cstdio>

AudioCapture::AudioCapture(bool bLoopback, bool bDefaultDevice)
    : m_pDevice(NULL)
    , m_pAudioClient(NULL)
    , m_pCaptureClient(NULL)
    , m_pwfx(NULL)
    , m_bInited(false)
    , m_bDone(true)
    , m_nBytesPerSample(0)
    , m_nBytesPerFrame(0)
    , m_midValue(0)
    , m_bLoopback(bLoopback)
    , m_bDefaultDevice(bDefaultDevice)
    , m_hnsActualDuration(0)
{
}

AudioCapture::~AudioCapture()
{
	Release();
}

//-----------------------------------------------------------
// Record an audio stream from the default audio capture
// device. The RecordAudioStream function allocates a shared
// buffer big enough to hold one second of PCM audio data.
// The function uses this buffer to stream data from the
// capture device. The main loop runs every 1/2 second.
//-----------------------------------------------------------

// REFERENCE_TIME time units per second and per millisecond
#define REFTIMES_PER_SEC  10000000
#define REFTIMES_PER_MILLISEC  10000

int AudioCapture::Init()
{
	if (m_bInited)
		return S_OK;

	HRESULT hr = E_FAIL;
	IMMDeviceEnumerator *pEnumerator = NULL;
	REFERENCE_TIME hnsRequestedDuration = REFTIMES_PER_SEC;
	UINT32 bufferFrameCount = 0;

	do
	{
		const CLSID CLSID_MMDeviceEnumerator = __uuidof(MMDeviceEnumerator);
		const IID IID_IMMDeviceEnumerator = __uuidof(IMMDeviceEnumerator);
		const IID IID_IAudioClient = __uuidof(IAudioClient);
		const IID IID_IAudioCaptureClient = __uuidof(IAudioCaptureClient);

		//hr = ::CoInitialize(NULL);
		//BREAK_ON_ERROR(hr);

		hr = ::CoCreateInstance(CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, IID_IMMDeviceEnumerator, (void**)&pEnumerator);
		BREAK_ON_ERROR(hr);

		if (!SelectDevice(pEnumerator))
			break;

		hr = m_pDevice->Activate(IID_IAudioClient, CLSCTX_ALL, NULL, (void**)&m_pAudioClient);
		BREAK_ON_ERROR(hr);

		hr = m_pAudioClient->GetMixFormat(&m_pwfx);
		BREAK_ON_ERROR(hr);

		if (m_bLoopback)
			hr = m_pAudioClient->Initialize(AUDCLNT_SHAREMODE_SHARED, AUDCLNT_STREAMFLAGS_LOOPBACK, 0, 0, m_pwfx, 0);
		else
			hr = m_pAudioClient->Initialize(AUDCLNT_SHAREMODE_SHARED, 0, hnsRequestedDuration, 0, m_pwfx, NULL);
		BREAK_ON_ERROR(hr);

		// Get the size of the allocated buffer.
		hr = m_pAudioClient->GetBufferSize(&bufferFrameCount);
		BREAK_ON_ERROR(hr);

		hr = m_pAudioClient->GetService(IID_IAudioCaptureClient, (void**)&m_pCaptureClient);
		BREAK_ON_ERROR(hr);

		// Notify the audio sink which format to use.
		hr = this->SetFormat(m_pwfx);
		BREAK_ON_ERROR(hr);

		// Calculate the actual duration of the allocated buffer.
		m_hnsActualDuration = (REFERENCE_TIME)((double)REFTIMES_PER_SEC * bufferFrameCount / m_pwfx->nSamplesPerSec);

		hr = S_OK;

	} while (false);

	SAFE_RELEASE(pEnumerator);

	if (hr != S_OK)
	{
		Release();
		::printf("Init failed, error code: 0x%x\n", hr);
		return hr;
	}
	else
	{
		m_bInited = true;
		return hr;
	}
}

void AudioCapture::Release()
{
	if (m_pwfx != NULL)
	{
		CoTaskMemFree(m_pwfx);
		m_pwfx = NULL;
	}
	SAFE_RELEASE(m_pDevice);
	SAFE_RELEASE(m_pAudioClient);
	SAFE_RELEASE(m_pCaptureClient);
	m_bInited = false;
	m_bDone = true;
}

bool AudioCapture::SelectDevice(IMMDeviceEnumerator *pEnumerator)
{
    EDataFlow eDataFlow = m_bLoopback ? EDataFlow::eRender : EDataFlow::eCapture;
	return AudioUtil::SelectDevice(pEnumerator, eDataFlow, m_bDefaultDevice, &m_pDevice);
}

int AudioCapture::StartCapture()
{
    int ret = E_FAIL;
    if (m_bInited && m_pAudioClient)
    {
        ret = m_pAudioClient->Start();  // Start recording.
    }
    return ret;
}

int AudioCapture::StopCapture()
{
    int ret = E_FAIL;
    if (m_bInited && m_pAudioClient)
    {
        ret = m_pAudioClient->Stop();  // Stop recording.
    }
    return ret;
}

int AudioCapture::Capture()
{
	if (!m_bInited)
	{
		return E_FAIL;
	}

	HRESULT hr = S_OK;
	UINT32 numFramesAvailable;
	UINT32 packetLength = 0;
	BYTE *pData;
	DWORD flags;

	// Each loop fills about half of the shared buffer.
	while (!IsDone())
	{
		// Sleep for half the buffer duration.
		Sleep((DWORD)(m_hnsActualDuration / REFTIMES_PER_MILLISEC / 2));

		hr = m_pCaptureClient->GetNextPacketSize(&packetLength);
		BREAK_ON_ERROR(hr);

		while (packetLength != 0 && !IsDone())
		{
			// Get the available data in the shared buffer.
			hr = m_pCaptureClient->GetBuffer(&pData, &numFramesAvailable, &flags, NULL, NULL);
			BREAK_ON_ERROR(hr);

			if (flags & AUDCLNT_BUFFERFLAGS_SILENT)
			{
				pData = NULL;  // Tell CopyData to write silence.
			}

			if (numFramesAvailable != 0)
			{
				// Copy the available capture data to the audio sink.
				hr = this->OnCaptureData(pData, numFramesAvailable);
				BREAK_ON_ERROR(hr);
			}

			hr = m_pCaptureClient->ReleaseBuffer(numFramesAvailable);
			BREAK_ON_ERROR(hr);

			hr = m_pCaptureClient->GetNextPacketSize(&packetLength);
			BREAK_ON_ERROR(hr);
		}
	}

	return hr;
}

HRESULT AudioCapture::OnCaptureData(BYTE *pData, UINT32 nFrameCount)
{
	//printf("OnCaptureData: %d\n", nFrameCount);
	return S_OK;
}

const WAVEFORMATEX* AudioCapture::GetFormat() const
{
	return m_pwfx;
}

HRESULT AudioCapture::SetFormat(WAVEFORMATEX *pwfx)
{
	//printf("Format:\n");
	//printf("  wFormatTag: %d\n", pwfx->wFormatTag);
	//printf("  nChannels: %d\n", pwfx->nChannels);
	//printf("  nSamplesPerSec: %d\n", pwfx->nSamplesPerSec);
	//printf("  nAvgBytesPerSec: %d\n", pwfx->nAvgBytesPerSec);
	//printf("  nBlockAlign: %d\n", pwfx->nBlockAlign);
	//printf("  wBitsPerSample: %d\n", pwfx->wBitsPerSample);
	//printf("  cbSize: %d\n", pwfx->cbSize);

	m_nBytesPerSample = pwfx->wBitsPerSample / 8;
	m_nBytesPerFrame = m_nBytesPerSample * m_pwfx->nChannels;
	m_midValue = AudioUtil::GetMidValue(m_pwfx);

	return S_OK;
}

bool AudioCapture::IsDone() const
{
	return m_bDone;
}

void AudioCapture::SetDone(bool bDone)
{
	m_bDone = bDone;
}

float AudioCapture::ParseValue(BYTE *pData, size_t index) const
{
	return AudioUtil::ParseValue(m_pwfx, pData, index, m_midValue);
}

```

`Win32Util/Audio/AudioCapture.h`:

```h
#pragma once
#pragma execution_character_set("utf-8")
#pragma comment(lib, "winmm.lib")
#include <Windows.h>
#include <mmdeviceapi.h>
#include <Audioclient.h>

class AudioCapture
{
public:
	AudioCapture(bool bLoopback = true, bool bDefaultDevice = true);
	virtual ~AudioCapture();

	virtual int Init();

	virtual const WAVEFORMATEX* GetFormat() const;

	virtual int Capture();

	virtual bool IsDone() const;
	virtual void SetDone(bool bDone);

protected:
	virtual void Release();
	virtual  int StartCapture();
	virtual  int StopCapture();
	virtual bool SelectDevice(IMMDeviceEnumerator *pEnumerator);

	virtual HRESULT SetFormat(WAVEFORMATEX *pwfx);

	virtual HRESULT OnCaptureData(BYTE *pData, UINT32 nFrameCount);

	float ParseValue(BYTE *pData, size_t index) const;

protected:
	WAVEFORMATEX *m_pwfx;
	bool m_bInited;
	bool m_bLoopback;
	bool m_bDefaultDevice;
	bool m_bDone;

	UINT m_nBytesPerSample;
	UINT m_nBytesPerFrame;
	int m_midValue;

private:
	IMMDevice *m_pDevice;
	IAudioClient *m_pAudioClient;
	IAudioCaptureClient *m_pCaptureClient;
	REFERENCE_TIME m_hnsActualDuration;
};

```

`Win32Util/Audio/AudioRender.cpp`:

```cpp
#pragma execution_character_set("utf-8")
#include "stdafx.h"
#include "AudioRender.h"
#include "AudioUtil.h"
#include <cstdio>

AudioRender::AudioRender(bool bDefaultDevice)
    : m_pDevice(NULL)
    , m_pAudioClient(NULL)
    , m_pRenderClient(NULL)
    , m_pwfx(NULL)
    , m_wfx()
    , m_bInited(false)
    , m_bDone(true)
    , m_nBytesPerSample(0)
    , m_nBytesPerFrame(0)
    , m_nBufferFrameCount(0)
    , m_bDefaultDevice(bDefaultDevice)
    , m_hnsActualDuration(0)
{
}

AudioRender::~AudioRender()
{
	ReleaseAudioClient();
}

//-----------------------------------------------------------
// Play an audio stream on the default audio rendering
// device. The PlayAudioStream function allocates a shared
// buffer big enough to hold one second of PCM audio data.
// The function uses this buffer to stream data to the
// rendering device. The inner loop runs every 1/2 second.
//-----------------------------------------------------------

// REFERENCE_TIME time units per second and per millisecond
#define REFTIMES_PER_SEC  10000000
#define REFTIMES_PER_MILLISEC  10000

int AudioRender::InitAudioClient()
{
	if (m_pAudioClient != NULL)
		return S_OK;

	HRESULT hr = E_FAIL;
	IMMDeviceEnumerator *pEnumerator = NULL;
	REFERENCE_TIME hnsRequestedDuration = REFTIMES_PER_SEC;

	do
	{
		const CLSID CLSID_MMDeviceEnumerator = __uuidof(MMDeviceEnumerator);
		const IID IID_IMMDeviceEnumerator = __uuidof(IMMDeviceEnumerator);
		const IID IID_IAudioClient = __uuidof(IAudioClient);

		hr = ::CoCreateInstance(CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, IID_IMMDeviceEnumerator, (void**)&pEnumerator);
		BREAK_ON_ERROR(hr);

		if (!SelectDevice(pEnumerator))
			break;

		hr = m_pDevice->Activate(IID_IAudioClient, CLSCTX_ALL, NULL, (void**)&m_pAudioClient);
		BREAK_ON_ERROR(hr);

		hr = S_OK;
	} while (false);

	SAFE_RELEASE(pEnumerator);

	if (hr != S_OK)
	{
		ReleaseAudioClient();
		::printf("InitAudioClient failed, error code: 0x%x\n", hr);
		return hr;
	}
	else
	{
		return hr;
	}
}

int AudioRender::InitRenderClient(WAVEFORMATEX *pwfx)
{
	HRESULT hr = E_FAIL;
	REFERENCE_TIME hnsRequestedDuration = REFTIMES_PER_SEC;

	do
	{
		if (m_pAudioClient == NULL)
			break;

		if (m_pRenderClient != NULL)
			ReleaseRenderClient();

		if (pwfx != NULL)
		{
			hr = m_pAudioClient->IsFormatSupported(AUDCLNT_SHAREMODE_SHARED, pwfx, &m_pwfx);
			if (hr == S_FALSE)
				pwfx = m_pwfx;
			else if (hr != S_OK)
				break;
		}
		else
		{
			hr = m_pAudioClient->GetMixFormat(&m_pwfx);
			BREAK_ON_ERROR(hr);
			pwfx = m_pwfx;
		}

		// Tell the audio source which format to use.
		if (!this->UseFormat(pwfx))
			break;

		hr = m_pAudioClient->Initialize(AUDCLNT_SHAREMODE_SHARED, 0, hnsRequestedDuration, 0, pwfx, NULL);
		BREAK_ON_ERROR(hr);

		// Get the actual size of the allocated buffer.
		hr = m_pAudioClient->GetBufferSize(&m_nBufferFrameCount);
		BREAK_ON_ERROR(hr);

		const IID IID_IAudioRenderClient = __uuidof(IAudioRenderClient);
		hr = m_pAudioClient->GetService(IID_IAudioRenderClient, (void**)&m_pRenderClient);
		BREAK_ON_ERROR(hr);

		// Calculate the actual duration of the allocated buffer.
		m_hnsActualDuration = (REFERENCE_TIME)((double)REFTIMES_PER_SEC * m_nBufferFrameCount / pwfx->nSamplesPerSec);

		hr = S_OK;
	} while (false);

	if (hr != S_OK)
	{
		ReleaseRenderClient();
		::printf("InitRenderClient failed, error code: 0x%x\n", hr);
		return false;
	}
	else
	{
		m_bInited = true;
		return true;
	}
}

int AudioRender::Init(WAVEFORMATEX *pwfx)
{
    int ret = S_OK;

    do
    {
        if (pwfx == NULL) ret = E_POINTER;
        BREAK_ON_ERROR(ret);

        ret = InitAudioClient();
        BREAK_ON_ERROR(ret);

        ret = InitRenderClient(pwfx);
        BREAK_ON_ERROR(ret);

    } while (false);

    return ret;
}

void AudioRender::ReleaseRenderClient()
{
	if (m_pwfx != NULL)
	{
		CoTaskMemFree(m_pwfx);
		m_pwfx = NULL;
	}
	SAFE_RELEASE(m_pRenderClient);
	m_bInited = false;
}

void AudioRender::ReleaseAudioClient()
{
	ReleaseRenderClient();
	SAFE_RELEASE(m_pAudioClient);
	SAFE_RELEASE(m_pDevice);
	m_bDone = true;
}

bool AudioRender::SelectDevice(IMMDeviceEnumerator *pEnumerator)
{
	return AudioUtil::SelectDevice(pEnumerator, eRender, m_bDefaultDevice, &m_pDevice);
}

int AudioRender::StartRender()
{
    int ret = E_FAIL;
    if (m_bInited && m_pAudioClient)
    {
        ret = m_pAudioClient->Start();
    }
    return ret;
}

int AudioRender::StopRender()
{
    int ret = E_FAIL;
    if (m_bInited && m_pAudioClient)
    {
        ret = m_pAudioClient->Stop();
    }
    return ret;
}

int AudioRender::Render()
{
	if (!m_bInited)
	{
		return E_FAIL;
	}

	HRESULT hr;
	DWORD frameCount = 0;
	DWORD flags = 0;

	do
	{
		hr = LoadData(&frameCount, &flags);
		BREAK_ON_ERROR(hr);

		hr = this->StartRender();
		BREAK_ON_ERROR(hr);

		while (!m_bDone)
		{
			// Sleep for half the buffer duration.
			DWORD time = (DWORD)(m_hnsActualDuration * frameCount / m_nBufferFrameCount / REFTIMES_PER_MILLISEC / 2);
			if (time < 10)
				time = 10; // Sleep at least 10 ms.
			Sleep(time);

			hr = LoadData(&frameCount, &flags);
			BREAK_ON_ERROR(hr);
		}

		// Wait for last data in buffer to play before stopping.
		Sleep((DWORD)(m_hnsActualDuration * frameCount / m_nBufferFrameCount / REFTIMES_PER_MILLISEC));

		hr = this->StopRender();
		BREAK_ON_ERROR(hr);

	} while (false);

	return hr;
}

inline HRESULT AudioRender::LoadData(DWORD *pFrameCount, DWORD *pFlags)
{
	HRESULT hr;
	UINT32 numFramesPadding;
	UINT32 numFramesAvailable;
	BYTE *pData;

	do
	{
		// See how much buffer space is available.
		hr = m_pAudioClient->GetCurrentPadding(&numFramesPadding);
		BREAK_ON_ERROR(hr);

		numFramesAvailable = m_nBufferFrameCount - numFramesPadding;

		// Grab the entire buffer for the initial fill operation.
		hr = m_pRenderClient->GetBuffer(numFramesAvailable, &pData);
		BREAK_ON_ERROR(hr);

		// Load the initial data into the shared buffer.
		hr = this->OnLoadData(pData, &numFramesAvailable, pFlags);
		BREAK_ON_ERROR(hr);

		hr = m_pRenderClient->ReleaseBuffer(numFramesAvailable, *pFlags);
		BREAK_ON_ERROR(hr);

		// return available frame count.
		*pFrameCount = numFramesPadding + numFramesAvailable;

	} while (false);

	return hr;
}

HRESULT AudioRender::OnLoadData(BYTE *pData, UINT32 *pFrameCount, DWORD *pFlags)
{
	*pFlags = AUDCLNT_BUFFERFLAGS_SILENT;

	return S_OK;
}

const WAVEFORMATEX* AudioRender::GetFormat() const
{
	return &m_wfx;
}

int AudioRender::SetFormat(WAVEFORMATEX *pwfx)
{
	return InitRenderClient(pwfx);
}

bool AudioRender::UseFormat(WAVEFORMATEX *pwfx)
{
	memcpy(&m_wfx, pwfx, sizeof(m_wfx));

	m_nBytesPerSample = pwfx->wBitsPerSample / 8;
	m_nBytesPerFrame = m_nBytesPerSample * pwfx->nChannels;

	return true;
}

bool AudioRender::IsFormatSupported(WAVEFORMATEX *pwfx)
{
	if (m_pAudioClient == NULL)
		return false;

	WAVEFORMATEX *pClosestMatch = NULL;
	auto hr = m_pAudioClient->IsFormatSupported(AUDCLNT_SHAREMODE_SHARED, pwfx, &pClosestMatch);
	if (pClosestMatch != NULL)
	{
		CoTaskMemFree(pClosestMatch);
	}
	return hr == S_OK;
}

bool AudioRender::IsDone() const
{
	return m_bDone;
}

void AudioRender::SetDone(bool bDone)
{
	m_bDone = bDone;
}
```

`Win32Util/Audio/AudioRender.h`:

```h
#pragma once
#pragma execution_character_set("utf-8")
#include <Windows.h>
#include <mmdeviceapi.h>
#include <Audioclient.h>

class AudioRender
{
public:
	AudioRender(bool bDefaultDevice = true);
	virtual ~AudioRender();

	virtual int Init(WAVEFORMATEX *pwfx = NULL);

	virtual int SetFormat(WAVEFORMATEX *pwfx);
	virtual const WAVEFORMATEX* GetFormat() const;

	virtual int Render();

	virtual bool IsDone() const;
	virtual void SetDone(bool bDone);

protected:
	virtual  int InitAudioClient();
	virtual void ReleaseAudioClient();

	virtual  int InitRenderClient(WAVEFORMATEX *pwfx);
	virtual void ReleaseRenderClient();

	virtual bool UseFormat(WAVEFORMATEX *pwfx);
	virtual bool IsFormatSupported(WAVEFORMATEX *pwfx);

	virtual  int StartRender();
	virtual  int StopRender();
	virtual bool SelectDevice(IMMDeviceEnumerator *pEnumerator);

	inline  HRESULT LoadData(DWORD *pFrameCount, DWORD *pFlags);
	virtual HRESULT OnLoadData(BYTE *pData, UINT32 *pFrameCount, DWORD *pFlags);

protected:
	WAVEFORMATEX *m_pwfx;
	WAVEFORMATEX m_wfx;
	bool m_bDefaultDevice;
	bool m_bInited;
	bool m_bDone;

	UINT m_nBytesPerSample;
	UINT m_nBytesPerFrame;
	UINT m_nBufferFrameCount;

private:
	IMMDevice *m_pDevice;
	IAudioClient *m_pAudioClient;
	IAudioRenderClient *m_pRenderClient;
	REFERENCE_TIME m_hnsActualDuration;
};


```

`Win32Util/Audio/AudioUtil.cpp`:

```cpp
#pragma execution_character_set("utf-8")
#include "stdafx.h"
#include "AudioUtil.h"
#include <functiondiscoverykeys.h>
#include <cstdio>
#include <iostream>
#include <string>
#include <assert.h>

float AudioUtil::ParseValue(const WAVEFORMATEX *pwfx, const void *pData, size_t index, int midValue)
{
	if (pData == nullptr)
		return 0;

	switch (pwfx->wBitsPerSample)
	{
	case 8:
		return (float)*((INT8*)pData + index) / midValue;
		break;
	case 16:
		return (float)*((INT16*)pData + index) / midValue;
		break;
	case 32:
		if (IsFloatFormat(pwfx))
			return (float)*((float*)pData + index);
		else
			return (float)*((INT32*)pData + index) / midValue;
		break;
	default:
		assert(false);
		break;
	}
	return 0;
}

int AudioUtil::GetMidValue(const WAVEFORMATEX *pwfx)
{
	return ((1L << (pwfx->wBitsPerSample - 1)) - 1) >> 1;
}

bool AudioUtil::IsFloatFormat(const WAVEFORMATEX *pwfx)
{
	if (pwfx->wFormatTag == WAVE_FORMAT_IEEE_FLOAT)
	{
		return true;
	}
	else if (pwfx->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
	{
		WAVEFORMATEXTENSIBLE *pfwxt = (WAVEFORMATEXTENSIBLE*)pwfx;
		if (pfwxt->SubFormat == KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)
		{
			return true;
		}
	}
	return false;
}

bool AudioUtil::SelectDevice(IMMDeviceEnumerator *pEnumerator, EDataFlow eDataFlow, bool bDefault, IMMDevice **ppDevice)
{
	HRESULT hr;
	if (bDefault)
	{
		hr = pEnumerator->GetDefaultAudioEndpoint(eDataFlow, eConsole, ppDevice);
		return hr == S_OK;
	}
	else
	{
		std::list<DeviceInfo> devices;
		int count = GetDevices(eDataFlow, pEnumerator, devices);

		// Print device name list
		printf("---------------------------------------\n");
		printf("Current Available Devices:\n");
		int index = 1;
		for (std::list<DeviceInfo>::const_iterator it = devices.cbegin(); it != devices.cend(); ++it)
		{
			wprintf_s(L"%d. %ls\n", index, it->sName);
			++index;
		}
		printf("---------------------------------------\n");

		// Select device by index
		index = GetSelectIndex(1, count);
		if (index >= 1 && index <= count)
		{
			std::list<DeviceInfo>::const_iterator it = devices.begin();
			for (int i = 1; i < index; ++i)
			{
				++it;
			}
			*ppDevice = it->pDevice;
		}

		// Release unselected devices
		for (std::list<DeviceInfo>::const_iterator it = devices.cbegin(); it != devices.cend(); ++it)
		{
			if (*ppDevice != it->pDevice)
			{
				IMMDevice *pDevice = it->pDevice;
				SAFE_RELEASE(pDevice);
			}
		}
		devices.clear();

		return count > 0 && *ppDevice != NULL;
	}
}

UINT AudioUtil::GetDevices(EDataFlow eDataFlow, IMMDeviceEnumerator *pEnumerator, std::list<DeviceInfo> &devices)
{
	HRESULT hr;
	IMMDeviceCollection *pCollection = NULL;
	IMMDevice *pDevice = NULL;
	IPropertyStore *pProps = NULL;
	//LPWSTR pwszID = NULL;
	UINT count = 0;

	do
	{
		hr = pEnumerator->EnumAudioEndpoints(eDataFlow, DEVICE_STATE_ACTIVE, &pCollection);
		BREAK_ON_ERROR(hr);

		hr = pCollection->GetCount(&count);
		BREAK_ON_ERROR(hr);

		for (UINT i = 0; i < count; ++i)
		{
			DeviceInfo devInfo = { 0 };
			do
			{
				hr = pCollection->Item(i, &pDevice);
				BREAK_ON_ERROR(hr);

				// Get the endpoint ID string.
				//hr = pDevice->GetId(&pwszID);
				//BREAK_ON_ERROR(hr);

				hr = pDevice->OpenPropertyStore(STGM_READ, &pProps);
				BREAK_ON_ERROR(hr);

				PROPVARIANT varName;
				::PropVariantInit(&varName);

				hr = pProps->GetValue(PKEY_Device_FriendlyName, &varName);
				if (hr == S_OK)
				{
					wsprintf(devInfo.sName, L"%ls", varName.pwszVal);
				}
				else
				{
					wsprintf(devInfo.sName, L"Unknown name");
				}

				::PropVariantClear(&varName);

				devInfo.pDevice = pDevice;
			} while (false);

			//if (pwszID)
			//{
			//	CoTaskMemFree(pwszID);
			//	pwszID = NULL;
			//}
			SAFE_RELEASE(pProps);

			if (devInfo.pDevice != NULL)
			{
				devices.push_back(devInfo);
			}
		}
	} while (false);

	SAFE_RELEASE(pCollection);

	return count;
}

int AudioUtil::GetSelectIndex(int min, int max)
{
	if (min == max)
		return min;

	int selectIndex = 0;
	bool printTip = true;
	std::string line;
	do
	{
		if (printTip)
			printf("Please select a device (index): ");

		if (!getline(std::cin, line))
			break;

		if (line.empty())
		{
			printTip = false;
			continue;
		}

		selectIndex = ::atoi(line.c_str());
		if (selectIndex >= min && selectIndex <= max)
		{
			break;
		}
		else
		{
			printf("Device index between %d and %d, please re-choose.\n", min, max);
			printTip = true;
		}
	} while (true);

	return selectIndex;
}

```

`Win32Util/Audio/AudioUtil.h`:

```h
#pragma once
#pragma execution_character_set("utf-8")
#pragma comment(lib, "winmm.lib")
#include <Windows.h>
#include <mmdeviceapi.h>
#include <Audioclient.h>
#include <list>

#define BREAK_ON_ERROR(hres)  \
	if (hres != S_OK) { break; }
#define SAFE_RELEASE(punk)  \
	if ((punk) != NULL) { (punk)->Release(); (punk) = NULL; }

class AudioUtil
{
public:
	static float ParseValue(const WAVEFORMATEX *pwfx, const void *pData, size_t index, int midValue);

	static int GetMidValue(const WAVEFORMATEX *pwfx);

	static bool IsFloatFormat(const WAVEFORMATEX *pwfx);

	static bool SelectDevice(IMMDeviceEnumerator *pEnumerator, EDataFlow eDataFlow, bool bDefault, IMMDevice **ppDevice);

protected:
	struct DeviceInfo
	{
		IMMDevice *pDevice;
		wchar_t sName[128];
	};

	static UINT GetDevices(EDataFlow eDataFlow, IMMDeviceEnumerator *pEnumerator, std::list<DeviceInfo> &devices);
	static int GetSelectIndex(int min, int max);
};


```

`Win32Util/Audio/Extend/AudioExtractor.cpp`:

```cpp
#include "stdafx.h"
#include "AudioExtractor.h"

static UINT __stdcall CaptureTheadProc(LPVOID param);

AudioExtractor::AudioExtractor(bool bLoopback, bool bDefaultDevice)
    : AudioCapture(bLoopback, bDefaultDevice)
    , m_pCurSegment(NULL)
    , m_eSoundState(SoundState::Silent)
    , m_silentCount(0)
    , m_silentMaxCount(0)
    , m_soundMinCount(0)
    , m_soundMaxCount(0)
    , m_segmentMaxCount(0)
    , m_hThreadCapture(NULL)
    , m_sAmpZcr()
{
	InitializeCriticalSection(&m_segmentSection);
}


AudioExtractor::~AudioExtractor()
{
	Stop();
	Clear();
	DeleteCriticalSection(&m_segmentSection);
}

void AudioExtractor::Clear()
{
	for(std::list<AudioFrameStorage*>::iterator it = m_segmentList.begin(); it != m_segmentList.end();)
	{
		AudioFrameStorage *pStorage = *it;
		if(pStorage != NULL)
		{
			pStorage->Clear();
			delete pStorage;
		}
		it = m_segmentList.erase(it);
	}
	if(m_pCurSegment != NULL)
	{
		m_pCurSegment->Clear();
		delete m_pCurSegment;
		m_pCurSegment = NULL;
	}
	m_silentFrames.Clear();

	// reset state:
	m_eSoundState = SoundState::Silent;
	m_silentCount = 0;
}

HRESULT AudioExtractor::SetFormat(WAVEFORMATEX *pwfx)
{
	AudioCapture::SetFormat(pwfx);

	SetSilentMaxCount(5); // empirical data.
	SetSoundMinCount(20); // empirical data.
	SetSoundMaxCount(pwfx->nSamplesPerSec / 100); // about 1 second.
	SetAmpZcr(pwfx->nSamplesPerSec / 100, 0.001f, 0.01f, 0.3f, 0.5f); // empirical data.

	return S_OK;
}

HRESULT AudioExtractor::OnCaptureData(BYTE *pData, UINT32 nFrameCount)
{
	float amp = 0, zcr = 0;
	char pre_sign = 0;
	for(UINT32 i = 0; i < nFrameCount; ++i)
	{
		UINT32 baseIndex = i * m_pwfx->nChannels;
		float value = ParseValue(pData, baseIndex);
		char sign;
		if (value < 0)
		{
			sign = -1;
			value = -value;
		}
		else
		{
			sign = 1;
		}
		for(int k = 1; k < m_pwfx->nChannels; ++k)
		{
			float tmp = ParseValue(pData, baseIndex + k);
			if (tmp < 0)
				tmp = -tmp;
			if (tmp > value)
				value = tmp;
		}
		amp += value * value;
		if(value > 1E-6) // need to repair!!!
		{
			zcr += (sign != pre_sign) ? 1 : 0;
			pre_sign = sign;
		}
	}
	amp = amp * nFrameCount / m_sAmpZcr.frameCount;
	zcr = zcr / nFrameCount;

	//if(amp > 1E-6 || zcr > 1E-6 || m_eSoundState == AudioExtractor::SoundState::Sound)
	//{
	//	printf("Segment: amp = %f, zcr = %f\n", amp, zcr);
	//}

	switch (m_eSoundState)
	{
	case AudioExtractor::SoundState::Silent:
		{
			if(amp > m_sAmpZcr.ampH || zcr > m_sAmpZcr.zcrH)
			{
				//printf("StartSegment: amp = %f, zcr = %f\n", amp, zcr);
				StartSegment();
				if(m_silentCount > 0)
				{
					AppendSilentFrames();
				}
				AddFrame(pData, nFrameCount, amp);
				m_eSoundState = SoundState::Sound;
			}
			else if(amp > m_sAmpZcr.ampL || zcr > m_sAmpZcr.zcrL)
			{
				if(m_silentCount < m_silentMaxCount)
				{
					++m_silentCount;
					AddSilentFrame(pData, nFrameCount, amp);
				}
				else
				{
					PopSilentFrame(pData, nFrameCount, amp);
				}
			}
			else
			{
				ClearSilentFrames();
			}
		}
		break;
	case AudioExtractor::SoundState::Sound:
		{
			if(amp > m_sAmpZcr.ampL || zcr > m_sAmpZcr.zcrL)
			{
				if(m_silentCount > 0)
				{
					AppendSilentFrames();
				}
				AddFrame(pData, nFrameCount, amp);
				if (GetCurFrameCount() >= m_soundMaxCount)
				{
					EndSegment();
					m_eSoundState = SoundState::Silent;
				}
			}
			else
			{
				if(m_silentCount < m_silentMaxCount)
				{
					++m_silentCount;
					AddSilentFrame(pData, nFrameCount, amp);
				}
				else
				{
					if (GetCurFrameCount() >= m_soundMinCount)
					{
						//printf("EndSegment: amp = %f, zcr = %f, frameCount = %d\n", amp, zcr, GetCurFrameCount());
						EndSegment();
					}
					else
					{
						//printf("CancelSegment: amp = %f, zcr = %f\n", amp, zcr);
						CancelSegment();
					}
					ClearSilentFrames();
					m_eSoundState = SoundState::Silent;
				}
			}
		}
		break;
	default:
		break;
	}

	return S_OK;
}

void AudioExtractor::SetSilentMaxCount(UINT count)
{
	m_silentMaxCount = count;
	m_silentFrames.SetCacheSize(count);
}

void AudioExtractor::SetSoundMinCount(UINT count)
{
	m_soundMinCount = count;
}

void AudioExtractor::SetSoundMaxCount(UINT count)
{
	m_soundMaxCount = count;
}

void AudioExtractor::SetAmpZcr(UINT frameCount, float ampL, float ampH, float zcrL, float zcrH)
{
	m_sAmpZcr.frameCount = frameCount;
	m_sAmpZcr.ampL = ampL;
	m_sAmpZcr.ampH = ampH;
	m_sAmpZcr.zcrL = zcrL;
	m_sAmpZcr.zcrH = zcrH;
}

void AudioExtractor::StartSegment()
{
	if(m_pCurSegment == NULL)
	{
		m_pCurSegment = new AudioFrameStorage();
		m_pCurSegment->SetCacheSize(m_soundMinCount);
	}
}

void AudioExtractor::EndSegment()
{
	if(m_pCurSegment != NULL)
	{
		Lock();
		m_segmentList.push_back(m_pCurSegment);
		if (m_segmentList.size() > m_segmentMaxCount)
		{
			m_pCurSegment = m_segmentList.front();
			m_pCurSegment->Reset();
			m_segmentList.pop_front();
		}
		else
		{
			m_pCurSegment = NULL;
		}
		Unlock();
	}
}

void AudioExtractor::CancelSegment()
{
	if(m_pCurSegment != NULL)
	{
		m_pCurSegment->Reset();
	}
}

void AudioExtractor::AppendSilentFrames()
{
	if(m_pCurSegment == NULL)
		return;

	while(m_silentFrames.GetSize() > 0)
	{
		m_pCurSegment->PushBack(m_silentFrames.PopFront());
	}
	m_silentCount = 0;
}

void AudioExtractor::ClearSilentFrames()
{
	m_silentFrames.Reset();
	m_silentCount = 0;
}

inline void AudioExtractor::AddFrame(BYTE *pData, UINT32 nFrameCount, float amp)
{
	m_pCurSegment->PushBack(pData, nFrameCount * m_nBytesPerFrame);
}

inline void AudioExtractor::AddSilentFrame(BYTE *pData, UINT32 nFrameCount, float amp)
{
	m_silentFrames.PushBack(pData, nFrameCount * m_nBytesPerFrame);
}

inline void AudioExtractor::PopSilentFrame(BYTE *pData, UINT32 nFrameCount, float amp)
{
	m_silentFrames.ReplaceFront(pData, nFrameCount * m_nBytesPerFrame);
}

inline size_t AudioExtractor::GetCurFrameCount()
{
	return m_pCurSegment->GetSize();
}

bool AudioExtractor::Start()
{
	if (m_hThreadCapture != NULL)
		return false;

	if (StartCapture() != S_OK)
		return false;

	SetDone(false);

	m_hThreadCapture = (HANDLE)::_beginthreadex(NULL, 0, &CaptureTheadProc, this, 0, NULL);
	if (m_hThreadCapture == NULL)
		return false;

	return true;
}

void AudioExtractor::Stop()
{
	SetDone(true);

	if (m_hThreadCapture != NULL)
	{
		::WaitForSingleObject(m_hThreadCapture, INFINITE);
		::CloseHandle(m_hThreadCapture);
		m_hThreadCapture = NULL;
	}

	StopCapture();
}

static UINT __stdcall CaptureTheadProc(LPVOID param)
{
	AudioExtractor *pAudio = (AudioExtractor*)param;
	return pAudio->Capture();
}

size_t AudioExtractor::GetSegmentCount() const
{
	return m_segmentList.size();
}

void AudioExtractor::SetSegmentMaxCount(UINT count)
{
	m_segmentMaxCount = count;
}

AudioExtractor::SegmentCIter AudioExtractor::cbegin() const
{
	return m_segmentList.cbegin();
}

AudioExtractor::SegmentCIter AudioExtractor::cend() const
{
	return m_segmentList.cend();
}

void AudioExtractor::Lock()
{
	::EnterCriticalSection(&m_segmentSection);
}

void AudioExtractor::Unlock()
{
	::LeaveCriticalSection(&m_segmentSection);
}

```

`Win32Util/Audio/Extend/AudioExtractor.h`:

```h
#pragma once
#include "Win32Util/Audio/AudioCapture.h"
#include "AudioFrameStorage.h"
#include <process.h>
#include <list>

class AudioExtractor :
	public AudioCapture
{
public:
	typedef std::list<AudioFrameStorage*>::const_iterator SegmentCIter;

public:
	AudioExtractor(bool bLoopback = true, bool bDefaultDevice = true);
	virtual ~AudioExtractor();

	bool Start();
	void Stop();

	void SetSilentMaxCount(UINT count);
	void SetSoundMinCount(UINT count);
	void SetSoundMaxCount(UINT count);
	void SetAmpZcr(UINT frameCount, float ampL, float ampH, float zcrL, float zcrH);

	void Clear();

	size_t GetSegmentCount() const;
	void SetSegmentMaxCount(UINT count);

	SegmentCIter cbegin() const;
	SegmentCIter cend() const;

	inline void Lock();
	inline void Unlock();

protected:
	virtual void StartSegment();
	virtual void EndSegment();
	virtual void CancelSegment();
	virtual void AppendSilentFrames();
	virtual void ClearSilentFrames();

	inline virtual void AddFrame(BYTE *pData, UINT32 nFrameCount, float amp);
	inline virtual void AddSilentFrame(BYTE *pData, UINT32 nFrameCount, float amp);
	inline virtual void PopSilentFrame(BYTE *pData, UINT32 nFrameCount, float amp);

	inline virtual size_t GetCurFrameCount();

	virtual HRESULT SetFormat(WAVEFORMATEX *pwfx);

	virtual HRESULT OnCaptureData(BYTE *pData, UINT32 nFrameCount);

protected:
	CRITICAL_SECTION m_segmentSection; // lock
	std::list<AudioFrameStorage*> m_segmentList;
	AudioFrameStorage *m_pCurSegment;
	AudioFrameStorage m_silentFrames;
	
	UINT m_silentCount;
	UINT m_silentMaxCount;
	UINT m_soundMinCount;
	UINT m_soundMaxCount;
	UINT m_segmentMaxCount;

	enum class SoundState
	{
		Silent,
		Sound,
	} m_eSoundState;
	struct
	{
		UINT frameCount; // 短时能量参考帧数。
		float ampL; // 短时能量低门限
		float ampH; // 短时能量高门限
		float zcrL; // 过零率低门限
		float zcrH; // 过零率高门限
	} m_sAmpZcr;
	
	HANDLE m_hThreadCapture;
};


```

`Win32Util/Audio/Extend/AudioFingerprint.cpp`:

```cpp
#include "stdafx.h"
#include "AudioFingerprint.h"
#include "Win32Util/Audio/AudioUtil.h"
#include "CommUtil/VectorUtil.hpp"

using comm_util::VectorUtil;

AudioFingerprint::AudioFingerprint()
{
}


AudioFingerprint::~AudioFingerprint()
{
}


const vector<float>& AudioFingerprint::GetFingerprint(const AudioFrameStorage *source, const WAVEFORMATEX *pwfx, ProcessFunc processFunc)
{
    m_finger.resize(source->GetSize());

    int nBytesPerSample = pwfx->wBitsPerSample / 8;
    int midValue = AudioUtil::GetMidValue(pwfx);

    int index = 0;
    for (auto it = source->cbegin(); it != source->cend(); ++it)
    {
        float min = FLT_MAX;
        float max = FLT_MIN;
        AudioFrameData *pFrames = *it;

        UINT count = pFrames->nDataLen / nBytesPerSample;
        for (UINT i = 0; i < count; i += pwfx->nChannels)
        {
            float value = AudioUtil::ParseValue(pwfx, pFrames->pData, i, midValue);
            if (min > value)
                min = value;
            if (max < value)
                max = value;
        }

        m_finger[index++] = max - min;
    }

    if (processFunc != nullptr)
    {
        processFunc(m_finger);
    }

    return m_finger;
}

void AudioFingerprint::ProcessDiff(vector<float> &data)
{
    size_t count = data.size();
    for (size_t i = 1; i < count; ++i)
    {
        data[i - 1] -= data[i];
    }
    if (count > 1)
    {
        data[count - 1] = 0;
    }
}

void AudioFingerprint::ProcessCutAvg(vector<float> &data)
{
    float avg = VectorUtil::GetAvg(&data[0], data.size());
    for (size_t i = 0, count = data.size(); i < count; ++i)
    {
        data[i] -= avg;
    }
}

void AudioFingerprint::ProcessRatioAvg(vector<float> &data)
{
    float avg = VectorUtil::GetAvg(&data[0], data.size());
    for (size_t i = 0, count = data.size(); i < count; ++i)
    {
        data[i] /= avg;
    }
}

```

`Win32Util/Audio/Extend/AudioFingerprint.h`:

```h
#pragma once
#include "AudioFrameStorage.h"
#include <Audioclient.h>
#include <vector>

using std::vector;

class AudioFingerprint
{
public:
    typedef void(*ProcessFunc)(vector<float> &data);

public:
    AudioFingerprint();
    ~AudioFingerprint();

    const vector<float>& GetFingerprint(const AudioFrameStorage *source, const WAVEFORMATEX *pwfx, ProcessFunc processFunc = nullptr);

    static void ProcessDiff(vector<float> &data);
    static void ProcessCutAvg(vector<float> &data);
    static void ProcessRatioAvg(vector<float> &data);

private:
    vector<float> m_finger;
};


```

`Win32Util/Audio/Extend/AudioFrameStorage.cpp`:

```cpp
#include "stdafx.h"
#include "AudioFrameStorage.h"

AudioFrameStorage::AudioFrameStorage()
	: m_totalBytes(0), m_cacheSize(0)
{
}

AudioFrameStorage::~AudioFrameStorage()
{
	Clear();
}

bool AudioFrameStorage::PushBack(AudioFrameData *pFrame)
{
	if(pFrame != NULL)
	{
		m_datas.push_back(pFrame);
		m_totalBytes += pFrame->nDataLen;
		return true;
	}
	return false;
}

AudioFrameData* AudioFrameStorage::PopFront()
{
	if(!m_datas.empty())
	{
		AudioFrameData *pFrame = m_datas.front();
		m_datas.pop_front();
		m_totalBytes -= pFrame->nDataLen;
		return pFrame;
	}
	return NULL;
}

bool AudioFrameStorage::PushBack(uint8_t *pData, uint32_t nDataLen)
{
	AudioFrameData *pFrame = NULL;
	if(!m_cache.empty())
	{
		pFrame = m_cache.front();
		if(pFrame->nDataLen < nDataLen)
		{
			if(!ResizeFrame(pFrame, nDataLen))
				return false;
		}
		m_cache.pop_front();
	}
	else
	{
		pFrame = new AudioFrameData();
		if(pFrame == NULL)
		{
			printf("new AudioFrameData failed.\n");
			return false;
		}
		pFrame->pData = (uint8_t*)::malloc(nDataLen);
		if(pFrame->pData == NULL)
		{
			delete pFrame;
			printf("malloc failed.\n");
			return false;
		}
		pFrame->nDataLen = nDataLen;
	}

	PushBack(pFrame, pData, nDataLen);

	return true;
}

inline void AudioFrameStorage::PushBack(AudioFrameData *pFrame, uint8_t *pData, uint32_t nDataLen)
{
	if (pData == NULL) // silent data.
		::memset(pFrame->pData, 0, nDataLen);
	else
		::memcpy(pFrame->pData, pData, nDataLen);

	m_datas.push_back(pFrame);
	m_totalBytes += nDataLen;
}

bool AudioFrameStorage::ReplaceFront(uint8_t *pData, uint32_t nDataLen)
{
	if(m_datas.empty())
		return false;

	AudioFrameData *pFrame = m_datas.front();
	uint32_t preLen = pFrame->nDataLen;
	if(pFrame->nDataLen < nDataLen)
	{
		if(!ResizeFrame(pFrame, nDataLen))
			return false;
	}

	m_datas.pop_front();
	m_totalBytes -= preLen;

	PushBack(pFrame, pData, nDataLen);

	return true;
}

inline bool AudioFrameStorage::ResizeFrame(AudioFrameData *pFrame, uint32_t nDataLen)
{
	void *pMem = ::realloc(pFrame->pData, nDataLen);
	if(pMem == NULL)
	{
		printf("realloc failed.\n");
		return false;
	}
	else
	{
		pFrame->pData = (uint8_t*)pMem;
		pFrame->nDataLen = nDataLen;
		return true;
	}
}

void AudioFrameStorage::Reset()
{
	for (AudioFrameCIter it = m_datas.begin(); it != m_datas.end();)
	{
		AudioFrameData *pFrame = *it;
		if(m_cache.size() < m_cacheSize)
		{
			m_cache.push_back(pFrame);
		}
		else
		{
			::free(pFrame->pData);
			delete pFrame;
		}
		it = m_datas.erase(it);
	}
	m_totalBytes = 0;
}

void AudioFrameStorage::Clear()
{
	Clear(m_datas);
	Clear(m_cache);
	m_totalBytes = 0;
}

void AudioFrameStorage::ClearCache()
{
	Clear(m_cache);
}

void AudioFrameStorage::Clear(AudioFrameList &list)
{
	for (AudioFrameCIter it = list.begin(); it != list.end(); ++it)
	{
		AudioFrameData *pFrame = *it;
		::free(pFrame->pData);
		delete pFrame;
	}
	list.clear();
}

void AudioFrameStorage::SetCacheSize(uint32_t size)
{
	m_cacheSize = size;
}

```

`Win32Util/Audio/Extend/AudioFrameStorage.h`:

```h
#pragma once
#include <list>
#include <stdint.h>

typedef struct
{
	uint32_t nDataLen;
	uint8_t *pData;
} AudioFrameData;

class AudioFrameStorage
{
public:
	typedef std::list<AudioFrameData*> AudioFrameList;
	typedef AudioFrameList::const_iterator AudioFrameCIter;

public:
	AudioFrameStorage();
	~AudioFrameStorage();

	bool PushBack(uint8_t *pData, uint32_t nDataLen);
	bool ReplaceFront(uint8_t *pData, uint32_t nDataLen);

	bool PushBack(AudioFrameData *pFrame);
	AudioFrameData* PopFront();

	void Reset();
	void Clear();
	void ClearCache();

	void SetCacheSize(uint32_t size);

	inline size_t GetSize() const;
	inline size_t GetTotalBytes() const;

	inline AudioFrameCIter cbegin() const;
	inline AudioFrameCIter cend() const;

private:
	inline void PushBack(AudioFrameData *pFrame, uint8_t *pData, uint32_t nDataLen);
	inline bool ResizeFrame(AudioFrameData *pFrame, uint32_t nDataLen);
	static void Clear(AudioFrameList &list);

private:
	AudioFrameList m_datas;
	AudioFrameList m_cache;
	uint32_t m_totalBytes;
	uint32_t m_cacheSize;
};

inline size_t AudioFrameStorage::GetSize() const
{
	return m_datas.size();
}

inline size_t AudioFrameStorage::GetTotalBytes() const
{
	return m_totalBytes;
}

inline AudioFrameStorage::AudioFrameCIter AudioFrameStorage::cbegin() const
{
	return m_datas.cbegin();
}

inline AudioFrameStorage::AudioFrameCIter AudioFrameStorage::cend() const
{
	return m_datas.cend();
}

```

`Win32Util/Audio/Extend/AudioPainter.cpp`:

```cpp
#include "stdafx.h"
#include "AudioPainter.h"
#include "Win32Util/Audio/AudioUtil.h"


AudioPainter::AudioPainter()
    : m_pwfx(NULL)
    , m_bFloatFormat(0)
    , m_nBytesPerSample(0)
    , m_nBytesPerFrame(0)
    , m_maxValue(0)
    , m_midValue(0)
    , m_pCurStorage(NULL)
    , m_dataIndex(0)
    , m_scaleY(1.0f)
    , m_bEnable(true)
{
}


AudioPainter::~AudioPainter()
{
}


void AudioPainter::SetFormat(const WAVEFORMATEX *pwfx)
{
	m_pwfx = pwfx;

	m_bFloatFormat = AudioUtil::IsFloatFormat(pwfx);

	m_nBytesPerSample = pwfx->wBitsPerSample / 8;
	m_nBytesPerFrame = m_nBytesPerSample * m_pwfx->nChannels;
	m_maxValue = (1L << (pwfx->wBitsPerSample - 1)) - 1;
	m_midValue = m_maxValue >> 1;
}

void AudioPainter::AddSource(const AudioFrameStorage *pStorage)
{
	m_dataList.push_back(pStorage);
}

void AudioPainter::Clear()
{
	m_dataList.clear();
}

void AudioPainter::Paint(HDC hdc, RECT rect, float maxTime)
{
	if (!m_bEnable || m_pwfx == NULL || m_dataList.empty())
		return;

	size_t maxBytes = 0;
	if (maxTime > 0.01f)
	{
		maxBytes = (size_t)(m_pwfx->nAvgBytesPerSec * maxTime);
	}
	else
	{
		for (std::list<const AudioFrameStorage *>::const_iterator it = m_dataList.begin(); it != m_dataList.end(); ++it)
		{
			maxBytes += (*it)->GetTotalBytes();
		}
	}
	

	int x = rect.left;
	int y = 0;

	int w = rect.right - rect.left;
	int h = rect.bottom - rect.top;
	int h2 = h / 2;
	int m = (rect.bottom + rect.top) / 2;

	::MoveToEx(hdc, x, m, NULL);
	::LineTo(hdc, x + w, m);

	::MoveToEx(hdc, x, m - h2, NULL);
	::LineTo(hdc, x + w, m - h2);

	::MoveToEx(hdc, x, m + h2, NULL);
	::LineTo(hdc, x + w, m + h2);

	size_t step = (maxBytes / w);
	if (step < m_nBytesPerFrame)
		step = m_nBytesPerFrame;

	float min, max;
	for (std::list<const AudioFrameStorage *>::const_iterator it = m_dataList.cbegin(); it != m_dataList.cend(); ++it)
	{
		ResetIter(*it);
		while (GetNext(step, &min, &max) > 0)
		{
			y = (int)(min * m_scaleY * h2);
			::MoveToEx(hdc, x, m, NULL);
			::LineTo(hdc, x, m + y);

			y = (int)(max * m_scaleY * h2);
			::MoveToEx(hdc, x, m, NULL);
			::LineTo(hdc, x, m + y);

			++x;
		}
	}
}


void AudioPainter::ResetIter(const AudioFrameStorage *pStorage)
{
	m_pCurStorage = pStorage;
	m_dataIter = m_pCurStorage->cbegin();
	m_dataIndex = 0;
}

size_t AudioPainter::GetNext(size_t range, float *pMin, float *pMax)
{
	size_t count = 0;
	range /= m_nBytesPerFrame;

	float value = 0, min = 0, max = 0;
	while (count < range && m_dataIter != m_pCurStorage->cend())
	{
		BYTE *pData = (*m_dataIter)->pData;
		size_t maxIndex = (*m_dataIter)->nDataLen / m_nBytesPerSample;

		for (; m_dataIndex < maxIndex; m_dataIndex += m_pwfx->nChannels) // 只处理1个声道
		{
			if (count >= range)
				break;

			value = ParseValue(pData, m_dataIndex);

			if (value < min)
				min = value;
			if (value > max)
				max = value;

			++count;
		}

		if (count < range)
		{
			++m_dataIter;
			m_dataIndex = 0;
		}
	}

	if (count > 0)
	{
		*pMin = min;
		*pMax = max;
	}

	return count;
}

float AudioPainter::ParseValue(BYTE *pData, size_t index)
{
	return AudioUtil::ParseValue(m_pwfx, pData, index, m_midValue);
}

void AudioPainter::AddScale(float scale)
{
	m_scaleY += scale;

	if (m_scaleY < 0)
		m_scaleY = 0;
}

float AudioPainter::GetScale()
{
	return m_scaleY;
}

bool AudioPainter::IsEnable() const
{
	return m_bEnable;
}

void AudioPainter::SetEnable(bool enable)
{
	m_bEnable = enable;
}
```

`Win32Util/Audio/Extend/AudioPainter.h`:

```h
#pragma once
#include "AudioFrameStorage.h"
#include <Audioclient.h>
#include <list>

class AudioPainter
{
public:
	AudioPainter();
	~AudioPainter();

	void SetFormat(const WAVEFORMATEX *pwfx);
	void AddSource(const AudioFrameStorage *pStorage);
	void Clear();

	void Paint(HDC hdc, RECT rect, float maxTime = 0.0f);

	void AddScale(float scale);
	float GetScale();

	bool IsEnable() const;
	void SetEnable(bool enable);

private:
	void ResetIter(const AudioFrameStorage *pStorage);
	size_t GetNext(size_t range, float *pMin, float *pMax);
	float ParseValue(BYTE *pData, size_t index);

private:
	std::list<const AudioFrameStorage*> m_dataList;
	const WAVEFORMATEX *m_pwfx;

	bool m_bFloatFormat;
	UINT m_nBytesPerSample;
	UINT m_nBytesPerFrame;
	int m_maxValue;
	int m_midValue;

	const AudioFrameStorage *m_pCurStorage;
	AudioFrameStorage::AudioFrameCIter m_dataIter;
	size_t m_dataIndex;

	float m_scaleY;
	bool m_bEnable;
};


```

`Win32Util/Audio/Extend/AudioRecorder.cpp`:

```cpp
#include "stdafx.h"
#include "AudioRecorder.h"
#include <process.h>

static UINT __stdcall CaptureTheadProc(LPVOID param);

AudioRecorder::AudioRecorder(bool bLoopback, bool bDefaultDevice)
    : AudioCapture(bLoopback, bDefaultDevice)
    , m_hThreadCapture(NULL)
    , m_dataMaxBytes(0)
{
	InitializeCriticalSection(&m_dataSection);
}

AudioRecorder::~AudioRecorder(void)
{
	Clear();
	DeleteCriticalSection(&m_dataSection);
}

HRESULT AudioRecorder::SetFormat(WAVEFORMATEX *pwfx)
{
	AudioCapture::SetFormat(pwfx);

	m_dataMaxBytes = (UINT)(pwfx->nAvgBytesPerSec * 10.0f);

	return S_OK;
}

HRESULT AudioRecorder::OnCaptureData(BYTE *pData, UINT32 nFrameCount)
{
	Lock();

	bool bSuccess = false;
	do
	{
		UINT32 nDataLen = nFrameCount * m_nBytesPerFrame;
		if (m_dataStorage.GetTotalBytes() + nDataLen > m_dataMaxBytes)
		{
			if (!m_dataStorage.ReplaceFront(pData, nDataLen))
			{
				break;
			}
		}
		else
		{
			if (!m_dataStorage.PushBack(pData, nDataLen))
			{
				break;
			}
		}
		bSuccess = true;
	} while (false);

	//printf("OnCaptureData: %d, %d\n", nDataLen, m_dataList.size());

	Unlock();

	return bSuccess ? S_OK : E_FAIL;
}

bool AudioRecorder::Start()
{
	Clear();

	if (m_hThreadCapture != NULL)
		return false;

	if (StartCapture() != S_OK)
		return false;

	SetDone(false);

	m_hThreadCapture = (HANDLE)::_beginthreadex(NULL, 0, &CaptureTheadProc, this, 0, NULL);
	if (m_hThreadCapture == NULL)
		return false;

	return true;
}

void AudioRecorder::Stop()
{
	SetDone(true);

	if (m_hThreadCapture != NULL)
	{
		::WaitForSingleObject(m_hThreadCapture, INFINITE);
		::CloseHandle(m_hThreadCapture);
		m_hThreadCapture = NULL;
	}

	StopCapture();
}

void AudioRecorder::Clear()
{
	Lock();
	m_dataStorage.Reset();
	Unlock();
}

static UINT __stdcall CaptureTheadProc(LPVOID param)
{
	AudioRecorder *pRecorder = (AudioRecorder*)param;
	return pRecorder->Capture();
}

const AudioFrameStorage* AudioRecorder::GetStorage() const
{
	return &m_dataStorage;
}

void AudioRecorder::Lock()
{
	::EnterCriticalSection(&m_dataSection);
}

void AudioRecorder::Unlock()
{
	::LeaveCriticalSection(&m_dataSection);
}
```

`Win32Util/Audio/Extend/AudioRecorder.h`:

```h
#pragma once
#include "Win32Util/Audio/AudioCapture.h"
#include "AudioFrameStorage.h"
#include <list>
#include <process.h>

typedef struct
{
	int nDataLen;
	BYTE *pData;
} AudioData;

class AudioRecorder :
	public AudioCapture
{
public:
	AudioRecorder(bool bLoopback = true, bool bDefaultDevice = true);
	~AudioRecorder(void);

	bool Start();
	void Stop();
	void Clear();

	inline void Lock();
	inline void Unlock();

	const AudioFrameStorage* GetStorage() const;

protected:
	virtual HRESULT SetFormat(WAVEFORMATEX *pwfx);
	virtual HRESULT OnCaptureData(BYTE *pData, UINT32 nFrameCount);

private:
	CRITICAL_SECTION m_dataSection; // lock
	AudioFrameStorage m_dataStorage;
	UINT m_dataMaxBytes;

	HANDLE m_hThreadCapture;
};


```

`Win32Util/Audio/Extend/AudioRenderer.cpp`:

```cpp
#include "stdafx.h"
#include "AudioRenderer.h"
#include "CommUtil/CommUtil.hpp"
#include "CommUtil/Logger.h"
#include <process.h>

using namespace comm_util;

static UINT __stdcall RenderTheadProc(LPVOID param);

AudioRenderer::AudioRenderer(bool bDefaultDevice)
    : AudioRender(bDefaultDevice)
    , m_srcType(SourceType::Wave)
    , m_bPlaying(false)
    , m_hThreadRenderer(NULL)
    , m_pWaveFile(NULL)
    , m_pConverter(NULL)
    , m_bConvert(false)
    , m_pStorage(NULL)
    , m_dataIndex(0)
{
}


AudioRenderer::~AudioRenderer()
{
	SAFE_DELETE(m_pWaveFile);
	SAFE_DELETE(m_pConverter);
}

void AudioRenderer::SetSource(const AudioFrameStorage *pStorage)
{
	m_srcType = SourceType::Storage;
	m_pStorage = pStorage;
}

bool AudioRenderer::SetSourceFile(const char *pWaveFile)
{
	m_srcType = SourceType::Wave;
	if (m_pWaveFile == NULL)
	{
		m_pWaveFile = new WaveFile();
	}
	if (!m_pWaveFile->BeginRead(pWaveFile))
	{
		return false;
	}

	WAVEFORMATEX wfx;
	WaveUtil::ConvertFormat(m_pWaveFile->GetFormat(), &wfx);
	return Init(&wfx) == S_OK;
}

bool AudioRenderer::Start()
{
	SetDone(false);

	if (m_srcType == SourceType::Storage)
	{
		m_dataIter = m_pStorage->cbegin();
		m_dataIndex = 0;
	}

	m_bPlaying = true;
	m_hThreadRenderer = (HANDLE)::_beginthreadex(NULL, 0, &RenderTheadProc, this, 0, NULL);
	if (m_hThreadRenderer == NULL)
	{
		m_bPlaying = false;
		return false;
	}

	return true;
}

void AudioRenderer::Stop()
{
	SetDone(true);

	if (m_hThreadRenderer != NULL)
	{
		::WaitForSingleObject(m_hThreadRenderer, INFINITE);
		::CloseHandle(m_hThreadRenderer);
		m_hThreadRenderer = NULL;
	}

	StopRender();

	if (m_srcType == SourceType::Wave)
	{
		m_pWaveFile->EndRead();
	}
}

static UINT __stdcall RenderTheadProc(LPVOID param)
{
	HRESULT hr = S_OK;
	AudioRenderer *pRender = (AudioRenderer*)param;
	if (pRender)
	{
		hr = pRender->Render();
		pRender->SetDone(true);
		pRender->m_bPlaying = false;
	}
	return hr;
}

bool AudioRenderer::UseFormat(WAVEFORMATEX *pwfx)
{
	if (m_srcType == SourceType::Wave)
	{
		m_bConvert = !WaveUtil::IsSameFormat(pwfx, m_pWaveFile->GetFormat());
		if (m_bConvert)
		{
			WAVEFORMATEX srcWfx;
			WaveUtil::ConvertFormat(m_pWaveFile->GetFormat(), &srcWfx);

			WAVEFORMATEX dstWfx = srcWfx;
			do
			{
				WaveUtil::SetFormat(&dstWfx, pwfx->nSamplesPerSec, srcWfx.wBitsPerSample, srcWfx.nChannels);
				if (IsFormatSupported(&dstWfx))
					break;

				WaveUtil::SetFormat(&dstWfx, pwfx->nSamplesPerSec, pwfx->wBitsPerSample, srcWfx.nChannels);
				if (IsFormatSupported(&dstWfx))
					break;

				WaveUtil::SetFormat(&dstWfx, pwfx->nSamplesPerSec, pwfx->wBitsPerSample, pwfx->nChannels);
				if (IsFormatSupported(&dstWfx))
					break;

				return false;
			} while (false);

			memcpy(pwfx, &dstWfx, sizeof(dstWfx));

			if (m_pConverter == NULL)
			{
				m_pConverter = new WaveStreamConverter(NULL);
			}

			if (!m_pConverter->IsSupport(&srcWfx, &dstWfx))
			{
				Logger::LogError("Format not support.\n");
				return false;
			}

			m_pConverter->SetStream(&m_pWaveFile->InStream());
			m_pConverter->SetFormat(&srcWfx, pwfx, pwfx->nSamplesPerSec);
		}
	}
	return AudioRender::UseFormat(pwfx);
}

HRESULT AudioRenderer::OnLoadData(BYTE *pData, UINT32 *pFrameCount, DWORD *pFlags)
{
	switch (m_srcType)
	{
	case SourceType::Storage:
		return LoadDataFromStorage(pData, pFrameCount, pFlags);
	case SourceType::Wave:
		return LoadDataFromFile(pData, pFrameCount, pFlags);
	default:
		*pFlags = AUDCLNT_BUFFERFLAGS_SILENT;
		return S_OK;
	}
}

HRESULT AudioRenderer::LoadDataFromStorage(BYTE *pData, UINT32 *pFrameCount, DWORD *pFlags)
{
	if (!IsDone())
	{
		UINT32 nDataLen = (*pFrameCount) * m_nBytesPerFrame;
		UINT32 nLoaded = 0;
		while (nLoaded < nDataLen && m_dataIter != m_pStorage->cend())
		{
			AudioFrameData *pFrame = *m_dataIter;
			UINT32 curLen = pFrame->nDataLen - m_dataIndex;
			UINT32 minLen = nDataLen < curLen ? nDataLen : curLen;

			::memcpy(pData + nLoaded, pFrame->pData + m_dataIndex, minLen);

			nLoaded += minLen;
			m_dataIndex += minLen;
			if (m_dataIndex >= pFrame->nDataLen)
			{
				++m_dataIter;
				m_dataIndex = 0;
			}
		}

		*pFrameCount = nLoaded / m_nBytesPerFrame;

		if (nLoaded < nDataLen)
		{
			m_bDone = true;
		}
	}

	if (m_bDone)
	{
		*pFlags = AUDCLNT_BUFFERFLAGS_SILENT;
	}

	return S_OK;
}

HRESULT AudioRenderer::LoadDataFromFile(BYTE *pData, UINT32 *pFrameCount, DWORD *pFlags)
{
	uint32_t readCount;
	if (m_bConvert)
	{
		readCount = m_pConverter->ReadFrame((char*)pData, *pFrameCount);
	}
	else
	{
		readCount = m_pWaveFile->ReadFrame((char*)pData, *pFrameCount);
	}

	if (readCount < *pFrameCount)
	{
		*pFrameCount = readCount;
		*pFlags = AUDCLNT_BUFFERFLAGS_SILENT;
		m_bDone = true;
	}

	return S_OK;
}

bool AudioRenderer::IsDone() const
{
	return m_bDone && !m_bPlaying;
}

```

`Win32Util/Audio/Extend/AudioRenderer.h`:

```h
#pragma once
#include "Win32Util/Audio/AudioRender.h"
#include "WaveUtil/WaveFile.h"
#include "WaveUtil/WaveStreamConverter.h"
#include "AudioFrameStorage.h"

class AudioRenderer :
	public AudioRender
{
public:
	AudioRenderer(bool bDefaultDevice = true);
	virtual ~AudioRenderer();

	void SetSource(const AudioFrameStorage *pStorage);
	bool SetSourceFile(const char *pWaveFile);

	virtual bool Start();
	virtual void Stop();

	virtual bool IsDone() const;

	friend UINT __stdcall RenderTheadProc(LPVOID param);

protected:
	virtual bool UseFormat(WAVEFORMATEX *pwfx);
	virtual HRESULT OnLoadData(BYTE *pData, UINT32 *pFrameCount, DWORD *pFlags);

	HRESULT LoadDataFromStorage(BYTE *pData, UINT32 *pFrameCount, DWORD *pFlags);
	HRESULT LoadDataFromFile(BYTE *pData, UINT32 *pFrameCount, DWORD *pFlags);

private:
	enum class SourceType
	{
		Wave,
		Storage,
	} m_srcType;

	WaveFile *m_pWaveFile;
	WaveStreamConverter *m_pConverter;
	bool m_bConvert;

	const AudioFrameStorage *m_pStorage;
	AudioFrameStorage::AudioFrameCIter m_dataIter;
	UINT m_dataIndex;

	HANDLE m_hThreadRenderer;
	bool m_bPlaying;
};


```

`Win32Util/Image/ImageUtil.cpp`:

```cpp
#pragma execution_character_set("utf-8")
#include "stdafx.h"
#include "ImageUtil.h"
#include "CommUtil/VectorUtil.hpp"
#include <cmath>

using namespace std;
using namespace comm_util;

ImageUtil::ImageUtil()
{
}

ImageUtil::~ImageUtil()
{
}


/*
计算图像指纹。图像数据格式为ARGB。
*/
vector<float> ImageUtil::GetFingerprint(const ImageData& image, Rect rect)
{
    vector<float> result(64);

    GetFingerprint(image, rect, result);

    return result;
}

/*
计算图像指纹。图像数据格式为ARGB。
*/
void ImageUtil::GetFingerprint(const ImageData& image, Rect rect, vector<float>& result)
{
    result.resize(64);
    memset(&result[0], 0, result.size() * sizeof(result[0]));

    int index;
    for (int i = 0; i < rect.h; ++i)
    {
        int basei = (i + rect.y) * image.w << 2;
        for (int j = 0; j < rect.w; ++j)
        {
            index = basei + ((j + rect.x) << 2);
            unsigned char r = image.lpBits[index + 2];
            unsigned char g = image.lpBits[index + 1];
            unsigned char b = image.lpBits[index + 0];
            index = (r / 64 << 4) + (g / 64 << 2) + b / 64;
            result[index]++;
        }
    }
}

/*
从图像中寻找小图。
*/
float ImageUtil::FindImage(const ImageData& image, Size size, const vector<float>& sample, Point& point)
{
    Rect rect = { 0, 0, size.w, size.h };
    vector<float> finger;
    float value, max_value = FLT_MIN;

    for (int k = 0; k < 1; ++k)
    {
        int off_w = k * size.w / 2;
        int off_h = k * size.h / 2;
        for (int i = off_w; i < image.w; i += size.w)
        {
            for (int j = off_h; j < image.h; j += size.h)
            {
                rect.x = i;
                rect.y = j;
                GetFingerprint(image, rect, finger);
                value = VectorUtil::GetCosA(&sample[0], &finger[0], sample.size());
                if (max_value < value)
                {
                    point.x = i;
                    point.y = j;
                    max_value = value;
                }
            }
        }
    }

    return max_value;
}

/*
截取指定窗口的图像。
lpBits: 返回的图像像素数据（其长度>=w*h*4）
pbi: 图像信息。
*/
bool ImageUtil::GetWindowSnapshot(HWND hWnd, int x, int y, int w, int h, char *lpBits, BITMAPINFOHEADER *pbi)
{
    bool bSuccess = false;
    bool bUseDesktop = true; // 使用窗口句柄时，可能出现一直获取到缓存帧，导致图像不刷新，使用桌面窗口句柄可解。

    // 通过内存DC复制客户区到DDB位图  
    HDC hdcWnd = bUseDesktop ? ::GetDC(NULL) : ::GetDC(hWnd);
    HDC hdcMem = NULL;
    HBITMAP hbmWnd = NULL;

    do
    {
        RECT rect;
        int px = x, py = y;

        if (bUseDesktop && ::GetWindowRect(hWnd, &rect))
        {
            px += rect.left;
            py += rect.top;
        }

        if ((bUseDesktop || w == 0 || h == 0)
            && ::GetClientRect(hWnd, &rect))
        {
            if (bUseDesktop)
            {
                px += rect.left + 8;
                py += rect.top + 32;
            }
            if (w == 0 || h == 0)
            {
                w = rect.right - rect.left;
                h = rect.bottom - rect.top;
            }
        }

        hdcMem = ::CreateCompatibleDC(hdcWnd);
        if (!hdcMem)
        {
            printf("CreateCompatibleDC failed.\n");
            break;
        }

        hbmWnd = ::CreateCompatibleBitmap(hdcWnd, w, h);
        if (!hbmWnd)
        {
            printf("CreateCompatibleBitmap failed.\n");
            break;
        }

        if (!::SelectObject(hdcMem, hbmWnd))
        {
            printf("SelectObject failed.\n");
            break;
        }

        if (!::BitBlt(hdcMem, 0, 0, w, h, hdcWnd, px, py, SRCCOPY))
        {
            printf("BitBlt has failed.\n");
            break;
        }

        BITMAP bmpWnd;
        ::GetObject(hbmWnd, sizeof(BITMAP), &bmpWnd);

        // 信息
        BITMAPINFOHEADER bi = { 0 };
        bi.biSize = sizeof(BITMAPINFOHEADER);
        bi.biWidth = bmpWnd.bmWidth;
        bi.biHeight = bmpWnd.bmHeight;
        bi.biPlanes = 1;
        bi.biBitCount = 32; // 按照每个像素用32bits表示转换  
        bi.biCompression = BI_RGB;
        bi.biSizeImage = 0;
        bi.biXPelsPerMeter = 0;
        bi.biYPelsPerMeter = 0;
        bi.biClrUsed = 0;
        bi.biClrImportant = 0;

        //DWORD dwBmpSize = ((bmpWnd.bmWidth * bi.biBitCount + 31) / 32) * 4 * bmpWnd.bmHeight; // 每一行像素位32对齐

        // Gets the "bits" from the bitmap and copies them into a buffer 
        // which is pointed to by lpbitmap.
        if (!GetDIBits(hdcMem, hbmWnd, 0, (WORD)bi.biHeight, lpBits, (BITMAPINFO*)&bi, DIB_RGB_COLORS))
        {
            printf("GetDIBits has failed. [%d]\n", GetLastError());
            break;
        }

        if (pbi != NULL)
        {
            ::memcpy_s(pbi, sizeof(BITMAPINFOHEADER), &bi, sizeof(BITMAPINFOHEADER));
        }

        //CreateBMPFile(L"capture.bmp", (BITMAPINFO*)&bi, lpBits);

        bSuccess = true;
    } while (false);

    if (hbmWnd)
    {
        ::DeleteObject(hbmWnd);
    }
    if (hdcMem)
    {
        ::DeleteObject(hdcMem);
    }
    ::ReleaseDC(hWnd, hdcWnd);

    return bSuccess;
}

/*
创建位图文件。
*/
bool ImageUtil::CreateBMPFile(LPTSTR pszFile, PBITMAPINFO pbi, char *lpBits)
{
    bool bSuccess = false;
    HANDLE hf;                  // file handle  
    BITMAPFILEHEADER hdr;       // bitmap file-header  
    PBITMAPINFOHEADER pbih;     // bitmap info-header  
    DWORD dwTotal;              // total count of bytes  
    DWORD dwTmp;

    do
    {
        pbih = (PBITMAPINFOHEADER)pbi;

        // Create the .BMP file.  
        hf = CreateFile(pszFile, GENERIC_READ | GENERIC_WRITE, (DWORD)0, NULL,
            CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
        if (hf == INVALID_HANDLE_VALUE)
        {
            printf("CreateFile failed.\n");
            break;
        }

        // init file-header
        {
            hdr.bfType = 0x4d42; // 0x42 = "B" 0x4d = "M"  
            // Compute the size of the entire file.  
            hdr.bfSize = (DWORD)(sizeof(BITMAPFILEHEADER)
                + pbih->biSize
                + pbih->biClrUsed * sizeof(RGBQUAD)
                + pbih->biSizeImage);
            hdr.bfReserved1 = 0;
            hdr.bfReserved2 = 0;
            // Compute the offset to the array of color indices.  
            hdr.bfOffBits = (DWORD) sizeof(BITMAPFILEHEADER)
                + pbih->biSize
                + pbih->biClrUsed * sizeof(RGBQUAD);
        }
        // Copy the BITMAPFILEHEADER into the .BMP file.  
        if (!WriteFile(hf, (LPVOID)&hdr, sizeof(BITMAPFILEHEADER), (LPDWORD)&dwTmp, NULL))
        {
            printf("WriteFile failed.\n");
            break;
        }
        // Copy the BITMAPINFOHEADER and RGBQUAD array into the file.  
        dwTotal = sizeof(BITMAPINFOHEADER) + pbih->biClrUsed * sizeof(RGBQUAD);
        if (!WriteFile(hf, (LPVOID)pbih, dwTotal, (LPDWORD)&dwTmp, (NULL)))
        {
            printf("WriteFile failed.\n");
            break;
        }
        // Copy the array of color indices into the .BMP file.  
        dwTotal = pbih->biSizeImage;
        if (!WriteFile(hf, (LPVOID)lpBits, dwTotal, (LPDWORD)&dwTmp, NULL))
        {
            printf("WriteFile failed. [%d]\n", ::GetLastError());
            break;
        }

        bSuccess = true;
    } while (false);

    // Close the .BMP file.  
    if (hf)
    {
        CloseHandle(hf);
    }

    return bSuccess;
}

/*
将指定的位图转换为灰度图。
*/
bool ImageUtil::TransToGray(BITMAP bitmap, LPTSTR pszFile)
{
    int w = bitmap.bmWidth;
    int h = bitmap.bmHeight;
    if (w == 0 || h == 0)
    {
        return false;
    }
    unsigned char *lpBits = (unsigned char *)bitmap.bmBits;
    unsigned char *buff = (unsigned char *)malloc(w * h * 4);
    if (!buff)
    {
        return false;
    }

    for (int i = 0; i < h; ++i)
    {
        int basei = i * w * 4;
        for (int j = 0; j < w; ++j)
        {
            int index = basei + j * 4;
            unsigned char a = lpBits[index + 3];
            unsigned char r = lpBits[index + 2];
            unsigned char g = lpBits[index + 1];
            unsigned char b = lpBits[index + 0];
            unsigned char gray = (r * 38 + g * 75 + b * 15) >> 7;

            buff[index] = buff[index + 1] = buff[index + 2] = gray;
            buff[index + 3] = a;
            if (gray <= 17)
            {
                printf("%d,%d\n", j, i);
            }
        }
    }

    BITMAPINFOHEADER bi = { 0 }; // 信息头  
    bi.biSize = sizeof(BITMAPINFOHEADER);
    bi.biWidth = bitmap.bmWidth;
    bi.biHeight = bitmap.bmHeight;
    bi.biPlanes = 1;
    bi.biBitCount = 32; // 按照每个像素用32bits表示转换  
    bi.biCompression = BI_RGB;
    bi.biSizeImage = bi.biWidth * bi.biHeight * 4;
    bi.biXPelsPerMeter = 0;
    bi.biYPelsPerMeter = 0;
    bi.biClrUsed = 0;
    bi.biClrImportant = 0;

    bool ret = CreateBMPFile(pszFile, (BITMAPINFO*)&bi, (char*)buff);

    ::free(buff);

    return ret;
}

/*
寻找图像中的指定颜色的像素点。
color: 目标颜色。
range: 阈值范围。
*/
void ImageUtil::FindColor(char *lpBits, int w, int h, int color, int range, std::list<POINT> &points)
{
    char r = RGB_R(color);
    char g = RGB_G(color);
    char b = RGB_B(color);
    char tr = RGB_R(range);
    char tg = RGB_G(range);
    char tb = RGB_B(range);

    POINT p;
    for (int i = 0; i < h; ++i)
    {
        int basei = i * w * 4;
        for (int j = 0; j < w; ++j)
        {
            int index = basei + j * 4;
            char dr = lpBits[index + 2] - r;
            char dg = lpBits[index + 1] - g;
            char db = lpBits[index + 0] - b;
            if (dr < tr && dr > -tr && dg < tg && dg >-tg && db < tb && db >-tb)
            {
                p.x = j;
                p.y = i;
                points.push_back(p);
                //printf("%d,%d\n", p.x, p.y);
            }
        }
    }
}

void ImageUtil::FindColor(char *lpBits, int w, int h, MatchColorProc match, std::list<POINT> &points)
{
    POINT p;
    for (int i = 0; i < h; ++i)
    {
        int basei = i * w * 4;
        for (int j = 0; j < w; ++j)
        {
            int index = basei + j * 4;
            char r = lpBits[index + 2];
            char g = lpBits[index + 1];
            char b = lpBits[index + 0];
            if (match(r, g, b))
            {
                p.x = j;
                p.y = i;
                points.push_back(p);
            }
        }
    }
}

void ImageUtil::FindColor(const CImage& image, MatchColorProc match, std::list<POINT> &points)
{
    int w = image.GetWidth();
    int h = image.GetHeight();
    int pitch = image.GetPitch();
    int pixelBytes = image.GetBPP() >> 3;
    char* bits = (char*)image.GetBits();

    for (int y = 0; y < h; ++y)
    {
        for (int x = 0; x < w; ++x)
        {
            int index = x * pixelBytes;
            char r = bits[index + 2];
            char g = bits[index + 1];
            char b = bits[index + 0];
            if (match(r, g, b))
            {
                POINT p{ x = x,y = y };
                points.push_back(p);
            }
        }
        bits += pitch;
    }
}

/*
寻找图像中的指定灰度值的像素点。
gray: 目标灰度值。
range: 阈值范围。
*/
void ImageUtil::FindGray(char *lpBits, int w, int h, int gray, int range, std::list<POINT> &points, unsigned int maxCount)
{
    POINT p;
    for (int i = 0; i < h; ++i)
    {
        int basei = i * w * 4;
        for (int j = 0; j < w; ++j)
        {
            int index = basei + j * 4;

            char r = lpBits[index + 2];
            char g = lpBits[index + 1];
            char b = lpBits[index + 0];
            char gg = (r * 38 + g * 75 + b * 15) >> 7;

            int diff = gg - gray;
            if (diff <= range && diff >= -range)
            {
                p.x = j;
                p.y = i;
                points.push_back(p);
                if (maxCount > 0 && maxCount <= points.size())
                {
                    return;
                }
                //printf("%d,%d\n", p.x, p.y);
            }
        }
    }
}

/*
将指定的坐标按照radius半径分组，并返回最大分组的中心点。
*/
bool ImageUtil::SelectBestPoint(std::list<POINT> points, int radius, POINT &p)
{
    radius = radius * radius;

    struct PointGroup
    {
        POINT center;
        std::list<POINT> points;

        bool operator < (PointGroup& b) {
            return points.size() > b.points.size(); // sort size by desc.
        }

        PointGroup()
            : center()
        { }
    };

    // 按照radius对坐标进行分组
    std::list<PointGroup> groups;
    for (std::list<POINT>::iterator it = points.begin(); it != points.end(); ++it)
    {
        bool find = false;
        for (std::list<PointGroup>::iterator it2 = groups.begin(); it2 != groups.end(); ++it2)
        {
            int dx = it2->center.x - it->x;
            int dy = it2->center.y - it->y;
            int s = dx * dx + dy * dy;
            if (s <= radius)
            {
                it2->center.x = (it2->center.x + it->x) / 2;
                it2->center.y = (it2->center.y + it->y) / 2;
                it2->points.push_back(*it);
                find = true;
            }
        }
        if (!find)
        {
            PointGroup group;
            group.center = *it;
            group.points.push_back(*it);
            groups.push_back(group);
        }
    }
    groups.sort();

    if (groups.size() > 0)
    {
        PointGroup group = *(groups.begin()); // 选择元素最多的分组
        // 选择离中心最近的点
        int min = INT_MAX;
        std::list<POINT>::iterator minIt = group.points.end();
        for (std::list<POINT>::iterator it = group.points.begin(); it != group.points.end(); ++it)
        {
            int dx = group.center.x - it->x;
            int dy = group.center.y - it->y;
            int s = dx * dx + dy * dy;
            if (s < min)
            {
                min = s;
                minIt = it;
            }
        }
        if (minIt != group.points.end())
        {
            p = *minIt;
            return true;
        }
    }
    return false;
}

int ImageUtil::GetColor(char *lpBits, int w, int h, int x, int y)
{
    int color = 0;
    if (x < w && y < h)
    {
        int index = (y * w + x) * 4;
        color = RGB(lpBits[index + 2], lpBits[index + 1], lpBits[index]);
    }
    return color;
}

bool ImageUtil::IsColorAlike(int c1, int c2, int range)
{
    char tr = RGB_R(range);
    char tg = RGB_G(range);
    char tb = RGB_B(range);
    char dr = RGB_R(c1) - RGB_R(c2);
    char dg = RGB_G(c1) - RGB_G(c2);
    char db = RGB_B(c1) - RGB_B(c2);
    return (dr < tr && dr > -tr && dg < tg && dg >-tg && db < tb && db >-tb);
}

```

`Win32Util/Image/ImageUtil.h`:

```h
#pragma once
#pragma execution_character_set("utf-8")
#include <Windows.h>
#include <list>
#include <vector>
#include <atlimage.h>

#define RGB(r,g,b) ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16)))
#define RGB_R(color) (color & 0xff)
#define RGB_G(color) ((color >> 8) & 0xff)
#define RGB_B(color) ((color >> 16) & 0xff)

class ImageUtil
{
public:
    struct Point
    {
        int x;
        int y;
    };

    struct Size
    {
        int w;
        int h;
    };

    struct Rect
    {
        int x;
        int y;
        int w;
        int h;
    };

    struct ImageData
    {
        char* lpBits;
        int w;
        int h;
    };

public:
    typedef bool (*MatchColorProc) (char r, char g, char b);

public:
    ImageUtil();
    ~ImageUtil();

    static std::vector<float> GetFingerprint(const ImageData& image, Rect rect);
    static void GetFingerprint(const ImageData& image, Rect rect, std::vector<float>& result);

    static float FindImage(const ImageData& image, Size rect, const std::vector<float>& sample, Point& point);

    static bool GetWindowSnapshot(HWND hwnd, int x, int y, int w, int h, char *lpBits, BITMAPINFOHEADER *pbi = NULL);
    static bool CreateBMPFile(LPTSTR pszFile, PBITMAPINFO pbi, char *lpBits);

    static bool TransToGray(BITMAP bitmap, LPTSTR pszFile);

    static void FindColor(const CImage& image, MatchColorProc match, std::list<POINT> &points);
    static void FindColor(char *lpBits, int w, int h, MatchColorProc match, std::list<POINT> &points);
    static void FindColor(char *lpBits, int w, int h, int color, int range, std::list<POINT> &points);
    static void FindGray(char *lpBits, int w, int h, int gray, int range, std::list<POINT> &points, unsigned int maxCount = 0);
    static bool SelectBestPoint(std::list<POINT> points, int radius, POINT &p);

    static int GetColor(char *lpBits, int w, int h, int x, int y);
    static bool IsColorAlike(int c1, int c2, int range);
};


```

`Win32Util/Image/WindowPrinter.cpp`:

```cpp
#pragma execution_character_set("utf-8")
#include "stdafx.h"
#include "WindowPrinter.h"
#include <Winspool.h>
#include <cstdio>
#include <cstdlib>

WindowPrinter::WindowPrinter()
{
}

WindowPrinter::~WindowPrinter()
{
}

/*
功能：获取当前默认打印机的DC
返回：成功返回打印机的DC，失败返回NULL
*/
HDC WindowPrinter::GetPrinterDC()
{
	DWORD dwNeeded, dwReturned;
	HDC hdc = 0;
	::EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 4, NULL, 0, &dwNeeded, &dwReturned);
	PRINTER_INFO_4* pinfo4 = (PRINTER_INFO_4*)malloc(dwNeeded);
    if (pinfo4)
    {
        ::EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 4, (BYTE*)pinfo4, dwNeeded, &dwNeeded, &dwReturned);
        hdc = ::CreateDC(NULL, pinfo4->pPrinterName, NULL, NULL);
    }
	free(pinfo4);
	return hdc;
}

/*
功能：打印窗口客户区内容到打印机，自动缩放居中打印
参数: hWnd-被打印窗口的句柄
*/
void WindowPrinter::PrintWindowClientArea(HWND hWnd)
{
	if (hWnd == NULL) return;

	RECT rectClient;
	::GetClientRect(hWnd, &rectClient);
	int width = rectClient.right - rectClient.left;
	int height = rectClient.bottom - rectClient.top;

	// 通过内存DC复制客户区到DDB位图
	HDC hdcWnd = ::GetDC(hWnd);
	HBITMAP hbmWnd = ::CreateCompatibleBitmap(hdcWnd, width, height);
	HDC hdcMem = ::CreateCompatibleDC(hdcWnd);
	::SelectObject(hdcMem, hbmWnd);
	::BitBlt(hdcMem, 0, 0, width, height, hdcWnd, 0, 0, SRCCOPY);

	// 把窗口DDB转为DIB
	BITMAP bmpWnd;
	::GetObject(hbmWnd, sizeof(BITMAP), &bmpWnd);
	BITMAPINFOHEADER bi; // 信息头
	bi.biSize = sizeof(BITMAPINFOHEADER);
	bi.biWidth = bmpWnd.bmWidth;
	bi.biHeight = bmpWnd.bmHeight;
	bi.biPlanes = 1;
	bi.biBitCount = 32; // 按照每个像素用32bits表示转换
	bi.biCompression = BI_RGB;
	bi.biSizeImage = 0;
	bi.biXPelsPerMeter = 0;
	bi.biYPelsPerMeter = 0;
	bi.biClrUsed = 0;
	bi.biClrImportant = 0;

	DWORD dwBmpSize = ((bmpWnd.bmWidth * bi.biBitCount + 31) / 32) * 4 * bmpWnd.bmHeight; // 每一行像素位32对齐
	char *lpbitmap = (char*)malloc(dwBmpSize); // 像素位指针
	::GetDIBits(hdcMem, hbmWnd, 0, (UINT)bmpWnd.bmHeight, lpbitmap, (BITMAPINFO*)&bi, DIB_RGB_COLORS);
	::DeleteDC(hdcMem);
	::DeleteObject(hbmWnd);
	::ReleaseDC(hWnd, hdcWnd);

	// 存为文件（可选）
	BITMAPFILEHEADER bmfHeader; // 文件头
	DWORD dwSizeofDIB = dwBmpSize + sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
	bmfHeader.bfOffBits = (DWORD)sizeof(BITMAPFILEHEADER) + (DWORD)sizeof(BITMAPINFOHEADER);
	bmfHeader.bfSize = dwSizeofDIB;
	bmfHeader.bfType = 0x4D42;

	FILE* fp = NULL;
	::_wfopen_s(&fp, L"capture.bmp", L"w");
    if (fp)
    {
        ::fwrite(&bmfHeader, sizeof(BITMAPFILEHEADER), 1, fp); // 写入文件头
        ::fwrite(&bi, sizeof(BITMAPINFOHEADER), 1, fp);        // 写入信息头
        ::fwrite(lpbitmap, dwBmpSize, 1, fp);                  // 写入像素位
        ::fclose(fp);
        fp = NULL;
    }

	// StretchDIBits()缩放打印DIB
	HDC hdcPrinter = WindowPrinter::GetPrinterDC();
	if (hdcPrinter == NULL)
		return;

	int pageWidth = ::GetDeviceCaps(hdcPrinter, HORZRES);
	int pageHeight = ::GetDeviceCaps(hdcPrinter, VERTRES);

	float scaleX = (float)pageWidth / (float)bmpWnd.bmWidth;
	float scaleY = (float)pageHeight / (float)bmpWnd.bmHeight;
	float scale = scaleX < scaleY ? scaleX : scaleY;

	int xDst, yDst, cxDst, cyDst;
	cxDst = (int)((float)bmpWnd.bmWidth * scale);
	cyDst = (int)((float)bmpWnd.bmHeight * scale);
	xDst = (int)((pageWidth - cxDst) / 2);
	yDst = (int)((pageHeight - cyDst) / 2);

	static DOCINFO di = { sizeof(DOCINFO), L"PRINTJOBNAME" };
	if (::StartDoc(hdcPrinter, &di) > 0)
	{
		if (::StartPage(hdcPrinter) > 0)
		{
			::StretchDIBits(hdcPrinter,
				xDst, yDst, cxDst, cyDst,
				0, 0, bmpWnd.bmWidth, bmpWnd.bmHeight,
				lpbitmap,
				(BITMAPINFO*)&bi,
				DIB_RGB_COLORS,
				SRCCOPY);
			::EndPage(hdcPrinter);
		}
		::EndDoc(hdcPrinter);
	}
	::DeleteDC(hdcPrinter);
	::free(lpbitmap);
}
```

`Win32Util/Image/WindowPrinter.h`:

```h
#pragma once
#pragma execution_character_set("utf-8")
#include <Windows.h>

/********************************************************************************
WindowPrinter 打印窗口类
功能描述：
提供截屏窗口并通过默认打印机，自动进行居中缩放打印

使用说明：
样例代码如下。
HWND hwnd = this->GetSafeWnd();
WindowPrinter::PrintWindowClientArea(hwnd);
********************************************************************************/
class WindowPrinter
{
public:
	WindowPrinter();
	~WindowPrinter();
public:
	/*
	功能：获取当前默认打印机的DC
	返回：成功返回打印机的DC，失败返回NULL
	*/
	static HDC GetPrinterDC();

	/*
	功能：打印窗口客户区内容到打印机，自动缩放居中打印
	参数: hWnd-被打印窗口的句柄
	*/
	static void PrintWindowClientArea(HWND hwnd);
};


```

`Win32Util/Keyboard/KeyboardBackground.cpp`:

```cpp
#include "stdafx.h"
#include "KeyboardBackground.h"


KeyboardBackground::KeyboardBackground(HWND hwnd)
    : m_hwnd(hwnd)
{
}


KeyboardBackground::~KeyboardBackground()
{
}


void KeyboardBackground::KeyDown(int key)
{
    ::PostMessage(m_hwnd, WM_KEYDOWN, key, 0);
}


void KeyboardBackground::KeyUp(int key)
{
    ::PostMessage(m_hwnd, WM_KEYUP, key, 0);
}


```

`Win32Util/Keyboard/KeyboardBackground.h`:

```h
#pragma once
#include "KeyboardBase.h"

class KeyboardBackground : public KeyboardBase
{
public:
    KeyboardBackground(HWND hwnd);
    virtual ~KeyboardBackground();

    virtual HWND GetHwnd() const override { return m_hwnd; }
    virtual void SetHwnd(HWND hwnd) override { m_hwnd = hwnd; }

protected:
    virtual void KeyDown(int key) override;
    virtual void KeyUp(int key) override;

private:
    HWND m_hwnd;
};


```

`Win32Util/Keyboard/KeyboardBase.cpp`:

```cpp
#include "stdafx.h"
#include "KeyboardBase.h"
#include <CommCtrl.h>


KeyboardBase::KeyboardBase()
{
}


KeyboardBase::~KeyboardBase()
{
}


void KeyboardBase::PressKey(int key)
{
    KeyDown(key);
    KeyUp(key);
}


void KeyboardBase::PressKey(int key, int modifiers)
{
    PressModifier(modifiers, true);
    KeyDown(key);
    KeyUp(key);
    PressModifier(modifiers, false);
}


void KeyboardBase::PressKey(int key, const std::string& modifiers)
{
    for (size_t i = 0; i < modifiers.size(); ++i)
    {
        PressModifier(modifiers[i], true);
    }

    KeyDown(key);
    KeyUp(key);

    for (size_t i = modifiers.size(); i > 0; --i)
    {
        PressModifier(modifiers[i - 1], false);
    }
}


void KeyboardBase::PressModifier(int modifiers, bool press)
{
    if (press)
    {
        if (modifiers & HOTKEYF_CONTROL)
            KeyDown(VK_CONTROL); // Ctrl
        if (modifiers & HOTKEYF_ALT)
            KeyDown(VK_MENU); // Alt
        if (modifiers & HOTKEYF_SHIFT)
            KeyDown(VK_SHIFT); // Shift
    }
    else
    {
        if (modifiers & HOTKEYF_SHIFT)
            KeyUp(VK_SHIFT); // Shift
        if (modifiers & HOTKEYF_ALT)
            KeyUp(VK_MENU); // Alt
        if (modifiers & HOTKEYF_CONTROL)
            KeyUp(VK_CONTROL); // Ctrl
    }
}

void KeyboardBase::PressModifier(char modifier, bool press)
{
    int key = 0;
    switch (modifier)
    {
    case 'C':
        key = VK_CONTROL;
        break;
    case 'A':
        key = VK_MENU;
        break;
    case 'S':
        key = VK_SHIFT;
        break;
    default:
        break;
    }

    if (key != 0)
    {
        if (press)
            KeyDown(key);
        else
            KeyUp(key);
    }
}

```

`Win32Util/Keyboard/KeyboardBase.h`:

```h
#pragma once
#include <Windows.h>
#include <string>

class KeyboardBase
{
public:
    KeyboardBase();
    virtual ~KeyboardBase() = 0;

    virtual bool Init() { return true; }
    virtual void Close() {}

    virtual void PressKey(int key);
    virtual void PressKey(int key, int modifiers);
    virtual void PressKey(int key, const std::string& modifiers);

    virtual HWND GetHwnd() const { return 0; }
    virtual void SetHwnd(HWND hwnd) {}

protected:
    virtual void PressModifier(int modifiers, bool press);
    virtual void PressModifier(char modifier, bool press);
    virtual void KeyDown(int key) = 0;
    virtual void KeyUp(int key) = 0;
};


```

`Win32Util/Keyboard/KeyboardGlobal.cpp`:

```cpp
#include "stdafx.h"
#include "KeyboardGlobal.h"


KeyboardGlobal::KeyboardGlobal()
{
}


KeyboardGlobal::~KeyboardGlobal()
{
}


void KeyboardGlobal::KeyDown(int key)
{
    INPUT input[1];

    input[0].type = INPUT_KEYBOARD;
    input[0].ki.dwFlags = 0;
    input[0].ki.wVk = key;

    ::SendInput(sizeof(input) / sizeof(INPUT), input, sizeof(INPUT));
}


void KeyboardGlobal::KeyUp(int key)
{
    INPUT input[1];

    input[0].type = INPUT_KEYBOARD;
    input[0].ki.dwFlags = KEYEVENTF_KEYUP;
    input[0].ki.wVk = key;

    ::SendInput(sizeof(input) / sizeof(INPUT), input, sizeof(INPUT));
}
```

`Win32Util/Keyboard/KeyboardGlobal.h`:

```h
#pragma once
#include "KeyboardBase.h"

class KeyboardGlobal : public KeyboardBase
{
public:
    KeyboardGlobal();
    virtual ~KeyboardGlobal();

protected:
    virtual void KeyDown(int key) override;
    virtual void KeyUp(int key) override;
};


```

`Win32Util/Mouse/MouseBackground.cpp`:

```cpp
#include "stdafx.h"
#include "MouseBackground.h"
#include "Win32Util/Util/ShareMemory.h"
#include "Win32Util/Util/DLLInjecter.h"
#include <Intercepter/CursorIntercepter.h>
#include <iostream>


MouseBackground::MouseBackground(HWND hwnd)
    : m_hwnd(hwnd)
    , m_pid(0)
    , m_share_memory(NULL)
{
    m_cursor_pos.x = 0;
    m_cursor_pos.y = 0;
}


MouseBackground::~MouseBackground()
{
    Close();
}


bool MouseBackground::Init()
{
    Close();

    m_pid = 0;
    GetWindowThreadProcessId(m_hwnd, &m_pid);
    if (m_pid == 0)
    {
        std::cout << "Error: GetWindowThreadProcessId failed! " << GetLastError() << std::endl;
        return false;
    }

    { // Intercepter.dll need put in the same dir with exe.
        const int size = 255;
        TCHAR buf[size + 1] = { 0 };
        GetModuleFileName(NULL, buf, size);

        m_dll_path = buf;
        size_t pos = m_dll_path.find_last_of(L'\\');
        if (pos != std::string::npos)
        {
            m_dll_path = m_dll_path.substr(0, pos);
        }
        m_dll_path.append(L"\\Intercepter.dll");
    }

    DLLInjecter::Eject(m_pid, m_dll_path.c_str());

    if (!DLLInjecter::Inject(m_pid, m_dll_path.c_str()))
    {
        std::cout << "Error: Inject dll failed! " << std::endl;
        return false;
    }

    if (m_share_memory)
    {
        delete m_share_memory;
        m_share_memory = NULL;
    }
    m_share_memory = new ShareMemory("Intercepter_CursorIntercepter");
    if (!m_share_memory->Open(sizeof(CursorIntercepter::ShareData), FILE_MAP_WRITE))
    {
        std::cout << "Error: Open ShareMemory failed! " << GetLastError() << std::endl;
        return false;
    }

    return true;
}


void MouseBackground::Close()
{
    if (m_share_memory)
    {
        delete m_share_memory;
        m_share_memory = NULL;
    }

    if (m_pid)
    {
        DLLInjecter::Eject(m_pid, m_dll_path.c_str());
        m_pid = 0;
    }
}


bool MouseBackground::GetCursorPos(POINT &point)
{
    point = m_cursor_pos;
    return true;
}


void MouseBackground::SetCursorPos(const POINT &point)
{
    this->SetCursorPos(point.x, point.y);
}


void MouseBackground::SetCursorPos(int x, int y)
{
    m_cursor_pos.x = x;
    m_cursor_pos.y = y;

    if (m_share_memory && m_share_memory->Lock())
    {
        POINT* cursor_pos = &((CursorIntercepter::ShareData*)m_share_memory->GetBuf())->cursor_pos;
        cursor_pos->x = x;
        cursor_pos->y = y;
        m_share_memory->Unlock();
    }

    POINT client_pos = m_cursor_pos;
    ::ScreenToClient(m_hwnd, &client_pos);

    LPARAM lParam = MAKELPARAM(client_pos.x, client_pos.y);
    ::PostMessage(m_hwnd, WM_MOUSEMOVE, 0, lParam);
}


void MouseBackground::ClickLeftButton()
{
    LPARAM lParam = MAKELPARAM(m_cursor_pos.x, m_cursor_pos.y);
    ::PostMessage(m_hwnd, WM_LBUTTONDOWN, MK_LBUTTON, lParam);
    ::PostMessage(m_hwnd, WM_LBUTTONUP, MK_LBUTTON, lParam);
}


void MouseBackground::ClickRightButton()
{
    LPARAM lParam = MAKELPARAM(m_cursor_pos.x, m_cursor_pos.y);
    ::PostMessage(m_hwnd, WM_RBUTTONDOWN, MK_RBUTTON, lParam);
    ::PostMessage(m_hwnd, WM_RBUTTONUP, MK_RBUTTON, lParam);
}

```

`Win32Util/Mouse/MouseBackground.h`:

```h
#pragma once
#include "MouseBase.h"
#include <string>

class ShareMemory;

class MouseBackground : public MouseBase
{
public:
    MouseBackground(HWND hwnd);
    virtual ~MouseBackground();

    virtual HWND GetHwnd() const override { return m_hwnd; }
    virtual void SetHwnd(HWND hwnd) override { m_hwnd = hwnd; }

    virtual bool Init() override;
    virtual void Close() override;

    virtual bool GetCursorPos(POINT &point) override;
    virtual void SetCursorPos(const POINT &point) override;
    virtual void SetCursorPos(int x, int y) override;

    virtual void ClickLeftButton() override;
    virtual void ClickRightButton() override;

private:
    HWND m_hwnd;
    DWORD m_pid;
    POINT m_cursor_pos;
    ShareMemory* m_share_memory;
    std::wstring m_dll_path;
};


```

`Win32Util/Mouse/MouseBase.cpp`:

```cpp
#include "stdafx.h"
#include "MouseBase.h"


MouseBase::MouseBase()
{
}


MouseBase::~MouseBase()
{
}

```

`Win32Util/Mouse/MouseBase.h`:

```h
#pragma once
#include <Windows.h>

class MouseBase
{
public:
    MouseBase();
    virtual ~MouseBase() = 0;

    virtual bool Init() { return true; }
    virtual void Close() {}

    virtual bool GetCursorPos(POINT& point) = 0;
    virtual void SetCursorPos(const POINT& point) = 0;
    virtual void SetCursorPos(int x, int y) = 0;

    virtual void ClickLeftButton() = 0;
    virtual void ClickRightButton() = 0;

    virtual HWND GetHwnd() const { return 0; }
    virtual void SetHwnd(HWND hwnd) {}
};


```

`Win32Util/Mouse/MouseGlobal.cpp`:

```cpp
#include "stdafx.h"
#include "MouseGlobal.h"


MouseGlobal::MouseGlobal()
{
}


MouseGlobal::~MouseGlobal()
{
}


bool MouseGlobal::GetCursorPos(POINT &point)
{
    return ::GetCursorPos(&point);
}


void MouseGlobal::SetCursorPos(const POINT &point)
{
    this->SetCursorPos(point.x, point.y);
}


void MouseGlobal::SetCursorPos(int x, int y)
{
    ::SetCursorPos(x, y);
}


void MouseGlobal::ClickLeftButton()
{
    INPUT input[2];

    input[0].type = INPUT_MOUSE;
    input[0].mi.dwFlags = MOUSEEVENTF_LEFTDOWN;

    input[1].type = INPUT_MOUSE;
    input[1].mi.dwFlags = MOUSEEVENTF_LEFTUP;

    ::SendInput(sizeof(input) / sizeof(INPUT), input, sizeof(INPUT));
}


void MouseGlobal::ClickRightButton()
{
    INPUT input[2];

    input[0].type = INPUT_MOUSE;
    input[0].mi.dwFlags = MOUSEEVENTF_RIGHTDOWN;

    input[1].type = INPUT_MOUSE;
    input[1].mi.dwFlags = MOUSEEVENTF_RIGHTUP;

    ::SendInput(sizeof(input) / sizeof(INPUT), input, sizeof(INPUT));
}

```

`Win32Util/Mouse/MouseGlobal.h`:

```h
#pragma once
#include "MouseBase.h"

class MouseGlobal : public MouseBase
{
public:
    MouseGlobal();
    virtual ~MouseGlobal();

    virtual bool GetCursorPos(POINT &point) override;
    virtual void SetCursorPos(const POINT &point) override;
    virtual void SetCursorPos(int x, int y) override;

    virtual void ClickLeftButton() override;
    virtual void ClickRightButton() override;
};


```

`Win32Util/Util/DLLInjecter.cpp`:

```cpp
#include "stdafx.h"
#include "DLLInjecter.h"
#include <Tlhelp32.h>
#include <iostream>
#include "Utility.h"


DLLInjecter::DLLInjecter()
{
}


DLLInjecter::~DLLInjecter()
{
}


bool DLLInjecter::Inject(int pid, PCSTR dll_path)
{
    PWSTR wpath = (PWSTR)_malloca((lstrlenA(dll_path) + 1) * sizeof(WCHAR));
    if (wpath)
    {
        wsprintfW(wpath, L"%S", dll_path);
        return Inject(pid, wpath);
    }
    return false;
}


bool DLLInjecter::Inject(int pid, PCWSTR dll_path)
{
    bool bOk = false;
    HANDLE hProcess = NULL;
    HANDLE hThread = NULL;
    LPVOID pRemotePath = NULL;

    __try
    {
        do
        {
            hProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE, false, pid);
            if (hProcess == NULL)
            {
                PrintLastError(L"Error: OpenProcess failed");
                break;
            }

            size_t len = lstrlenW(dll_path) + 1;
            size_t size = len * sizeof(WCHAR);
            pRemotePath = VirtualAllocEx(hProcess, NULL, size, MEM_COMMIT, PAGE_READWRITE);
            if (pRemotePath == NULL)
            {
                PrintLastError(L"Error: VirtualAllocEx failed");
                break;
            }

            if (!WriteProcessMemory(hProcess, pRemotePath, dll_path, size, NULL))
            {
                PrintLastError(L"Error: WriteProcessMemory failed");
                break;
            }

            HMODULE hModule = GetModuleHandle(TEXT("Kernel32"));
            if (hModule == 0)
            {
                break;
            }
            PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE)GetProcAddress(hModule, "LoadLibraryW");
            if (pfnThreadRtn == NULL)
            {
                PrintLastError(L"Error: GetProcAddress failed");
                break;
            }

            hThread = CreateRemoteThread(hProcess, NULL, 0, pfnThreadRtn, pRemotePath, 0, NULL);
            if (hThread == NULL)
            {
                PrintLastError(L"Error: CreateRemoteThread failed");
                break;
            }

            WaitForSingleObject(hThread, INFINITE);

            bOk = true;
            wprintf(L"Inject success.\n");

        } while (false);
    }
    __finally
    {
        if (pRemotePath != NULL)
        {
            VirtualFreeEx(hProcess, pRemotePath, 0, MEM_RELEASE);
        }
        if (hThread != NULL)
        {
            CloseHandle(hThread);
        }
        if (hProcess != NULL)
        {
            CloseHandle(hProcess);
        }
    }

    return bOk;
}


bool DLLInjecter::Eject(int pid, PCSTR dll_path)
{
    PWSTR wpath = (PWSTR)_malloca((lstrlenA(dll_path) + 1) * sizeof(WCHAR));
    if (wpath)
    {
        wsprintfW(wpath, L"%S", dll_path);
        return Eject(pid, wpath);
    }
    return false;
}


bool DLLInjecter::Eject(int pid, PCWSTR dll_path)
{
    bool bOk = false;
    HANDLE hSnapshot = NULL;
    HANDLE hProcess = NULL;
    HANDLE hThread = NULL;

    __try
    {
        do
        {
            hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
            if (hSnapshot == NULL)
            {
                PrintLastError(L"Error: CreateToolhelp32Snapshot failed");
                break;
            }

            MODULEENTRY32W me = { sizeof(me) };
            bool bFound = false;
            bool bHasMore = Module32FirstW(hSnapshot, &me);
            while (bHasMore)
            {
                if (lstrcmpiW(me.szModule, dll_path) == 0 ||
                    lstrcmpiW(me.szExePath, dll_path) == 0)
                {
                    bFound = true;
                    break;
                }
                bHasMore = Module32NextW(hSnapshot, &me);
            }
            if (!bFound)
            {
                PrintError(L"Error: Module not found");
                break;
            }

            hProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION, false, pid);
            if (hProcess == NULL)
            {
                PrintLastError(L"Error: OpenProcess failed");
                break;
            }

            HMODULE hModule = GetModuleHandle(TEXT("Kernel32"));
            if (hModule == 0)
            {
                break;
            }
            PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE) GetProcAddress(hModule, "FreeLibrary");
            if (pfnThreadRtn == NULL)
            {
                PrintLastError(L"Error: GetProcAddress failed");
                break;
            }

            hThread = CreateRemoteThread(hProcess, NULL, 0, pfnThreadRtn, me.modBaseAddr, 0, NULL);
            if (hThread == NULL)
            {
                PrintLastError(L"Error: CreateRemoteThread failed");
                break;
            }

            WaitForSingleObject(hThread, INFINITE);

            bOk = true;
            wprintf(L"Eject success.\n");

        } while (false);
    }
    __finally
    {
        if (hSnapshot != NULL)
        {
            CloseHandle(hSnapshot);
        }
        if (hThread != NULL)
        {
            CloseHandle(hThread);
        }
        if (hProcess != NULL)
        {
            CloseHandle(hProcess);
        }
    }

    return bOk;
}

void DLLInjecter::PrintError(LPCWSTR msg)
{
    wprintf(L"%s\n", msg);
}

void DLLInjecter::PrintLastError(LPCWSTR msg)
{
    DWORD error_code = GetLastError();
    wprintf(L"%s, error [%d] %s\n", msg, error_code, Utility::GetErrorMsg(error_code).c_str());
}

```

`Win32Util/Util/DLLInjecter.h`:

```h
#pragma once
#include <Windows.h>

class DLLInjecter
{
public:
    DLLInjecter();
    ~DLLInjecter();

    static bool Inject(int pid, PCSTR dll_path);
    static bool Inject(int pid, PCWSTR dll_path);

    static bool Eject(int pid, PCSTR dll_path);
    static bool Eject(int pid, PCWSTR dll_path);

private:
    static void PrintError(LPCWSTR msg);
    static void PrintLastError(LPCWSTR msg);
};


```

`Win32Util/Util/DcBuffer.cpp`:

```cpp
#include "stdafx.h"
#include "DcBuffer.h"


DcBuffer::DcBuffer(HWND hwnd, int w, int h)
{
	m_hwnd = hwnd;

	m_rect.left = 0;
	m_rect.top = 0;
	m_rect.right = w;
	m_rect.bottom = h;

	Init();
}


DcBuffer::~DcBuffer()
{
}

void DcBuffer::Init()
{
	HDC hdc = ::GetDC(m_hwnd);
	m_hdcMem = ::CreateCompatibleDC(hdc);
	m_hBitMap = ::CreateCompatibleBitmap(hdc, m_rect.right, m_rect.bottom);
	m_hBrush = ::CreateSolidBrush(::GetBkColor(hdc));
	::SelectObject(m_hdcMem, m_hBitMap);
	::ReleaseDC(m_hwnd, hdc);
}

HDC DcBuffer::GetDC()
{
	return m_hdcMem;
}

void DcBuffer::Clear()
{
	::FillRect(m_hdcMem, &m_rect, m_hBrush);
}
```

`Win32Util/Util/DcBuffer.h`:

```h
#pragma once
#include <Windows.h>

class DcBuffer
{
public:
	DcBuffer(HWND hwnd, int w, int h);
	~DcBuffer();

	HDC GetDC();
	void Clear();

private:
	void Init();

private:
	HWND m_hwnd;
	HDC m_hdcMem;
	HBITMAP m_hBitMap;
	HBRUSH m_hBrush;
	RECT m_rect;
};


```

`Win32Util/Util/ShareMemory.cpp`:

```cpp
#include "stdafx.h"
#include "ShareMemory.h"
#include <mutex>


ShareMemory::ShareMemory(const std::string& name)
    : m_name(name)
    , m_size(0)
    , m_hMutex(NULL)
    , m_hFileMap(NULL)
    , m_pMemory(NULL)
{
}

ShareMemory::~ShareMemory()
{
    Close();
    Unlock();
}

bool ShareMemory::Create(size_t size)
{
    Close();

    if (size <= 0)
    {
        return false;
    }

    m_size = size;

    m_hFileMap = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, (DWORD)size, m_name.c_str());
    if (m_hFileMap == NULL)
    {
        return false;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        Close();
        return false;
    }

    return Map(FILE_MAP_ALL_ACCESS);
}

bool ShareMemory::Open(size_t size, DWORD access)
{
    Close();

    m_size = size;

    m_hFileMap = OpenFileMappingA(access, false, m_name.c_str());
    if (!m_hFileMap)
    {
        return false;
    }

    return Map(access);
}

void ShareMemory::Close()
{
    UnMap();

    if (m_hFileMap)
    {
        CloseHandle(m_hFileMap);
        m_hFileMap = NULL;
    }
}

bool ShareMemory::Map(DWORD access)
{
    if (!m_hFileMap)
    {
        return false;
    }

    m_pMemory = MapViewOfFile(m_hFileMap, access, 0, 0, m_size);
    if (!m_pMemory)
    {
        Close();
        return false;
    }

    return true;
}

void ShareMemory::UnMap()
{
    if (m_pMemory)
    {
        UnmapViewOfFile(m_pMemory);
        m_pMemory = NULL;
    }
}

const std::string& ShareMemory::GetName() const
{
    return m_name;
}

size_t ShareMemory::GetSize() const
{
    return m_size;
}

LPVOID ShareMemory::GetBuf()
{
    return m_pMemory;
}

bool ShareMemory::Lock(DWORD dwMilliseconds)
{
    if (!m_hMutex)
    {
        std::string mutex_name = m_name + "_Lock";
        m_hMutex = CreateMutexA(NULL, false, mutex_name.c_str());
        if (!m_hMutex)
        {
            return false;
        }
    }

    DWORD ret = WaitForSingleObject(m_hMutex, dwMilliseconds);
    return (ret == WAIT_OBJECT_0 || ret == WAIT_ABANDONED);
}

void ShareMemory::Unlock()
{
    if (m_hMutex)
    {
        ReleaseMutex(m_hMutex);
    }
}
```

`Win32Util/Util/ShareMemory.h`:

```h
#pragma once
#include <Windows.h>
#include <string>

class ShareMemory
{
public:
    ShareMemory(const std::string& name);
    ~ShareMemory();

    bool Create(size_t size);
    bool Open(size_t size, DWORD access);
    void Close();

    bool Lock(DWORD dwMilliseconds = INFINITE);
    void Unlock();

    const std::string& GetName() const;
    size_t GetSize() const;
    LPVOID GetBuf();

private:
    bool Map(DWORD access);
    void UnMap();

private:
    std::string m_name;
    size_t m_size;
    HANDLE m_hMutex;
    HANDLE m_hFileMap;
    LPVOID m_pMemory;
};


```

`Win32Util/Util/Utility.cpp`:

```cpp
#include "stdafx.h"
#include "Utility.h"
#include <cstdio>
#include <ctime>
#include <cstdarg>
#include <sstream>
#include <Windows.h>
#include <io.h>


Utility::Utility()
{
}


Utility::~Utility()
{
}

void Utility::printf_t(const char *fmt, ...)
{
    time_t t = ::time(NULL);
    struct tm ti;
    int ret = ::localtime_s(&ti, &t);
    ::printf("[%04d-%02d-%02d %02d:%02d:%02d] ", (ti.tm_year + 1900), (ti.tm_mon + 1), ti.tm_mday, ti.tm_hour, ti.tm_min, ti.tm_sec);

    va_list arg_ptr;
    va_start(arg_ptr, fmt);
    ::vprintf(fmt, arg_ptr);
    va_end(arg_ptr);
}

std::wstring Utility::GetErrorMsg(int error_code)
{
    const int size = 256;
    WCHAR buf[size + 1];

    if (FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        GetLastError(),
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        buf,
        size,
        NULL))
    {
        return std::wstring(buf);
    }
    else
    {
        std::wstringstream stream;
        stream << L"Unknown error code " << error_code;
        return stream.str();
    }
}

size_t Utility::Split(string str, std::list<string> &result)
{
    result.clear();
    size_t sp = 0, ep = 0;
    do
    {
        size_t pos = str.find_first_not_of(' ', sp);
        if (pos != string::npos)
        {
            sp = pos;
        }
        ep = str.find_first_of(' ', sp + 1);
        if (ep == string::npos)
        {
            result.push_back(str.substr(sp));
            break;
        }

        result.push_back(str.substr(sp, ep - sp));
        sp = ep + 1;
    } while (true);

    return result.size();
}

bool Utility::GetWndExePath(HWND hwnd, std::wstring &path)
{
    DWORD pid = 0;
    GetWindowThreadProcessId(hwnd, &pid);

    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, false, pid);
    if (!hProcess)
    {
        return false;
    }

    wchar_t buf[MAX_PATH + 1];
    DWORD size = MAX_PATH;
    QueryFullProcessImageNameW(hProcess, 0, buf, &size);

    path = buf;

    CloseHandle(hProcess);

    return true;
}

bool Utility::FindLatestFile(const std::wstring& dir_path, std::wstring& file_path)
{
    __time64_t lastest_time = 0;
    std::wstring lastest_name;

    struct _wfinddata_t fileinfo;
    std::wstring path(dir_path + L"\\*");
    intptr_t hFile = 0;
    if ((hFile = _wfindfirst(path.c_str(), &fileinfo)) != -1)
    {
        do
        {
            if ((fileinfo.attrib &  _A_SUBDIR) != 0)
            {
                continue;
            }
            if (lastest_time < fileinfo.time_create)
            {
                lastest_time = fileinfo.time_create;
                lastest_name = fileinfo.name;
            }
        } while (_wfindnext(hFile, &fileinfo) == 0);
        _findclose(hFile);
    }

    if (lastest_name.empty())
    {
        return false;
    }

    file_path.assign(dir_path).append(L"\\").append(lastest_name);
    return true;
}

std::wstring Utility::StrToWStr(const std::string& str)
{
    PWSTR wstr = (PWSTR)_malloca((lstrlenA(str.c_str()) + 1) * sizeof(WCHAR));
    if (wstr)
    {
        wsprintfW(wstr, L"%S", str.c_str());
        return std::wstring(wstr);
    }
    else
    {
        return std::wstring();
    }
}

```

`Win32Util/Util/Utility.h`:

```h
#pragma once
#include <string>
#include <list>
#include <Windows.h>

using std::string;

class Utility
{
public:
    Utility();
    ~Utility();

    static void printf_t(const char *fmt, ...);

    static std::wstring GetErrorMsg(int error_code);

    static size_t Split(string str, std::list<string> &result);

    static bool GetWndExePath(HWND hwnd, std::wstring &path);

    static bool FindLatestFile(const std::wstring& dir_path, std::wstring& file_path);

    static std::wstring StrToWStr(const std::string& src);
};


```

`Win32Util/Win32Util.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{82597547-3A6D-4E82-9979-32D4CDAD7AB1}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>Win32Util</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
    <ReferencePath>$(ReferencePath)</ReferencePath>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
    <ReferencePath>$(ReferencePath)</ReferencePath>
    <IncludePath>$(ProjectDir);$(SolutionDir);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
    <ReferencePath>$(ReferencePath)</ReferencePath>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)Libs\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
    <ReferencePath>$(ReferencePath)</ReferencePath>
    <IncludePath>$(ProjectDir);$(SolutionDir);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Audio\AudioCapture.h" />
    <ClInclude Include="Audio\AudioRender.h" />
    <ClInclude Include="Audio\AudioUtil.h" />
    <ClInclude Include="Audio\Extend\AudioExtractor.h" />
    <ClInclude Include="Audio\Extend\AudioFingerprint.h" />
    <ClInclude Include="Audio\Extend\AudioFrameStorage.h" />
    <ClInclude Include="Audio\Extend\AudioPainter.h" />
    <ClInclude Include="Audio\Extend\AudioRecorder.h" />
    <ClInclude Include="Audio\Extend\AudioRenderer.h" />
    <ClInclude Include="Image\ImageUtil.h" />
    <ClInclude Include="Image\WindowPrinter.h" />
    <ClInclude Include="Keyboard\KeyboardBackground.h" />
    <ClInclude Include="Keyboard\KeyboardBase.h" />
    <ClInclude Include="Keyboard\KeyboardGlobal.h" />
    <ClInclude Include="Mouse\MouseBackground.h" />
    <ClInclude Include="Mouse\MouseBase.h" />
    <ClInclude Include="Mouse\MouseGlobal.h" />
    <ClInclude Include="Util\DcBuffer.h" />
    <ClInclude Include="Util\DLLInjecter.h" />
    <ClInclude Include="Util\ShareMemory.h" />
    <ClInclude Include="Util\Utility.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Audio\AudioCapture.cpp" />
    <ClCompile Include="Audio\AudioRender.cpp" />
    <ClCompile Include="Audio\AudioUtil.cpp" />
    <ClCompile Include="Audio\Extend\AudioExtractor.cpp" />
    <ClCompile Include="Audio\Extend\AudioFingerprint.cpp" />
    <ClCompile Include="Audio\Extend\AudioFrameStorage.cpp" />
    <ClCompile Include="Audio\Extend\AudioPainter.cpp" />
    <ClCompile Include="Audio\Extend\AudioRecorder.cpp" />
    <ClCompile Include="Audio\Extend\AudioRenderer.cpp" />
    <ClCompile Include="Image\ImageUtil.cpp" />
    <ClCompile Include="Image\WindowPrinter.cpp" />
    <ClCompile Include="Keyboard\KeyboardBackground.cpp" />
    <ClCompile Include="Keyboard\KeyboardBase.cpp" />
    <ClCompile Include="Keyboard\KeyboardGlobal.cpp" />
    <ClCompile Include="Mouse\MouseBackground.cpp" />
    <ClCompile Include="Mouse\MouseBase.cpp" />
    <ClCompile Include="Mouse\MouseGlobal.cpp" />
    <ClCompile Include="Util\DcBuffer.cpp" />
    <ClCompile Include="Util\DLLInjecter.cpp" />
    <ClCompile Include="Util\ShareMemory.cpp" />
    <ClCompile Include="Util\Utility.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Win32Util/Win32Util.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util\DcBuffer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util\DLLInjecter.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util\ShareMemory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util\Utility.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Image\ImageUtil.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Image\WindowPrinter.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Keyboard\KeyboardBackground.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Keyboard\KeyboardBase.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Keyboard\KeyboardGlobal.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Mouse\MouseBackground.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Mouse\MouseBase.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Mouse\MouseGlobal.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Audio\AudioCapture.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Audio\Extend\AudioExtractor.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Audio\Extend\AudioFingerprint.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Audio\Extend\AudioFrameStorage.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Audio\Extend\AudioPainter.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Audio\Extend\AudioRecorder.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Audio\AudioRender.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Audio\Extend\AudioRenderer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Audio\AudioUtil.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Util\DcBuffer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Util\DLLInjecter.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Util\ShareMemory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Util\Utility.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Image\ImageUtil.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Audio\Extend\AudioRecorder.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Audio\Extend\AudioRenderer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Audio\Extend\AudioExtractor.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Audio\Extend\AudioPainter.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Audio\Extend\AudioFingerprint.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Audio\Extend\AudioFrameStorage.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Audio\AudioCapture.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Audio\AudioRender.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Audio\AudioUtil.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Image\WindowPrinter.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Keyboard\KeyboardBackground.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Keyboard\KeyboardBase.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Keyboard\KeyboardGlobal.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Mouse\MouseBackground.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Mouse\MouseBase.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Mouse\MouseGlobal.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Win32Util/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// Win32Util.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`Win32Util/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers



// TODO: reference additional headers your program requires here

```

`Win32Util/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`WowAutoFishing.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29509.3
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Win32Util", "Win32Util\Win32Util.vcxproj", "{82597547-3A6D-4E82-9979-32D4CDAD7AB1}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "WaveGraph", "WaveGraph\WaveGraph.vcxproj", "{5BA80E0D-1DD3-43D3-94EE-40A805C63912}"
	ProjectSection(ProjectDependencies) = postProject
		{82597547-3A6D-4E82-9979-32D4CDAD7AB1} = {82597547-3A6D-4E82-9979-32D4CDAD7AB1}
		{413A4356-BD98-4A7D-A427-BAA93936627F} = {413A4356-BD98-4A7D-A427-BAA93936627F}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "WowNpcScanAlertor", "WowNpcScanAlertor\WowNpcScanAlertor.vcxproj", "{34C289A8-7D4F-45DA-B95B-6282972CE776}"
	ProjectSection(ProjectDependencies) = postProject
		{82597547-3A6D-4E82-9979-32D4CDAD7AB1} = {82597547-3A6D-4E82-9979-32D4CDAD7AB1}
		{413A4356-BD98-4A7D-A427-BAA93936627F} = {413A4356-BD98-4A7D-A427-BAA93936627F}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "WowFisher", "WowFisher\WowFisher.vcxproj", "{4F30B56B-0430-4752-9A62-C191BF675B86}"
	ProjectSection(ProjectDependencies) = postProject
		{82597547-3A6D-4E82-9979-32D4CDAD7AB1} = {82597547-3A6D-4E82-9979-32D4CDAD7AB1}
		{413A4356-BD98-4A7D-A427-BAA93936627F} = {413A4356-BD98-4A7D-A427-BAA93936627F}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CommUtil", "CommUtil\CommUtil.vcxproj", "{413A4356-BD98-4A7D-A427-BAA93936627F}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "WavePlayer", "WavePlayer\WavePlayer.vcxproj", "{0F3C70B5-B074-4374-AA6F-A88A0C8A2B47}"
	ProjectSection(ProjectDependencies) = postProject
		{67493328-FEFE-4D0C-B747-AEBAF569E29D} = {67493328-FEFE-4D0C-B747-AEBAF569E29D}
		{82597547-3A6D-4E82-9979-32D4CDAD7AB1} = {82597547-3A6D-4E82-9979-32D4CDAD7AB1}
		{413A4356-BD98-4A7D-A427-BAA93936627F} = {413A4356-BD98-4A7D-A427-BAA93936627F}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "WaveUtil", "WaveUtil\WaveUtil.vcxproj", "{67493328-FEFE-4D0C-B747-AEBAF569E29D}"
	ProjectSection(ProjectDependencies) = postProject
		{413A4356-BD98-4A7D-A427-BAA93936627F} = {413A4356-BD98-4A7D-A427-BAA93936627F}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "WaveConverter", "WaveConverter\WaveConverter.vcxproj", "{C23F0DA0-1DB4-4D73-B380-08DF35F5752C}"
	ProjectSection(ProjectDependencies) = postProject
		{67493328-FEFE-4D0C-B747-AEBAF569E29D} = {67493328-FEFE-4D0C-B747-AEBAF569E29D}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DLLInjecter", "DllInjecter\DllInjecter.vcxproj", "{FBD85DFD-8E2E-445E-99CB-03B1886BA959}"
	ProjectSection(ProjectDependencies) = postProject
		{82597547-3A6D-4E82-9979-32D4CDAD7AB1} = {82597547-3A6D-4E82-9979-32D4CDAD7AB1}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Intercepter", "Intercepter\Intercepter.vcxproj", "{C9695514-52DA-4E06-8A25-BE91B3346285}"
	ProjectSection(ProjectDependencies) = postProject
		{82597547-3A6D-4E82-9979-32D4CDAD7AB1} = {82597547-3A6D-4E82-9979-32D4CDAD7AB1}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Any CPU = Release|Any CPU
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{82597547-3A6D-4E82-9979-32D4CDAD7AB1}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{82597547-3A6D-4E82-9979-32D4CDAD7AB1}.Debug|Win32.ActiveCfg = Debug|Win32
		{82597547-3A6D-4E82-9979-32D4CDAD7AB1}.Debug|Win32.Build.0 = Debug|Win32
		{82597547-3A6D-4E82-9979-32D4CDAD7AB1}.Debug|Win32.Deploy.0 = Debug|Win32
		{82597547-3A6D-4E82-9979-32D4CDAD7AB1}.Debug|x64.ActiveCfg = Debug|x64
		{82597547-3A6D-4E82-9979-32D4CDAD7AB1}.Debug|x64.Build.0 = Debug|x64
		{82597547-3A6D-4E82-9979-32D4CDAD7AB1}.Release|Any CPU.ActiveCfg = Release|Win32
		{82597547-3A6D-4E82-9979-32D4CDAD7AB1}.Release|Win32.ActiveCfg = Release|Win32
		{82597547-3A6D-4E82-9979-32D4CDAD7AB1}.Release|Win32.Build.0 = Release|Win32
		{82597547-3A6D-4E82-9979-32D4CDAD7AB1}.Release|x64.ActiveCfg = Release|x64
		{82597547-3A6D-4E82-9979-32D4CDAD7AB1}.Release|x64.Build.0 = Release|x64
		{5BA80E0D-1DD3-43D3-94EE-40A805C63912}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{5BA80E0D-1DD3-43D3-94EE-40A805C63912}.Debug|Win32.ActiveCfg = Debug|Win32
		{5BA80E0D-1DD3-43D3-94EE-40A805C63912}.Debug|Win32.Build.0 = Debug|Win32
		{5BA80E0D-1DD3-43D3-94EE-40A805C63912}.Debug|x64.ActiveCfg = Debug|x64
		{5BA80E0D-1DD3-43D3-94EE-40A805C63912}.Debug|x64.Build.0 = Debug|x64
		{5BA80E0D-1DD3-43D3-94EE-40A805C63912}.Release|Any CPU.ActiveCfg = Release|Win32
		{5BA80E0D-1DD3-43D3-94EE-40A805C63912}.Release|Win32.ActiveCfg = Release|Win32
		{5BA80E0D-1DD3-43D3-94EE-40A805C63912}.Release|Win32.Build.0 = Release|Win32
		{5BA80E0D-1DD3-43D3-94EE-40A805C63912}.Release|x64.ActiveCfg = Release|x64
		{5BA80E0D-1DD3-43D3-94EE-40A805C63912}.Release|x64.Build.0 = Release|x64
		{34C289A8-7D4F-45DA-B95B-6282972CE776}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{34C289A8-7D4F-45DA-B95B-6282972CE776}.Debug|Win32.ActiveCfg = Debug|Win32
		{34C289A8-7D4F-45DA-B95B-6282972CE776}.Debug|Win32.Build.0 = Debug|Win32
		{34C289A8-7D4F-45DA-B95B-6282972CE776}.Debug|x64.ActiveCfg = Debug|x64
		{34C289A8-7D4F-45DA-B95B-6282972CE776}.Debug|x64.Build.0 = Debug|x64
		{34C289A8-7D4F-45DA-B95B-6282972CE776}.Release|Any CPU.ActiveCfg = Release|Win32
		{34C289A8-7D4F-45DA-B95B-6282972CE776}.Release|Win32.ActiveCfg = Release|Win32
		{34C289A8-7D4F-45DA-B95B-6282972CE776}.Release|Win32.Build.0 = Release|Win32
		{34C289A8-7D4F-45DA-B95B-6282972CE776}.Release|x64.ActiveCfg = Release|x64
		{34C289A8-7D4F-45DA-B95B-6282972CE776}.Release|x64.Build.0 = Release|x64
		{4F30B56B-0430-4752-9A62-C191BF675B86}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{4F30B56B-0430-4752-9A62-C191BF675B86}.Debug|Win32.ActiveCfg = Debug|Win32
		{4F30B56B-0430-4752-9A62-C191BF675B86}.Debug|Win32.Build.0 = Debug|Win32
		{4F30B56B-0430-4752-9A62-C191BF675B86}.Debug|x64.ActiveCfg = Debug|x64
		{4F30B56B-0430-4752-9A62-C191BF675B86}.Debug|x64.Build.0 = Debug|x64
		{4F30B56B-0430-4752-9A62-C191BF675B86}.Release|Any CPU.ActiveCfg = Release|Win32
		{4F30B56B-0430-4752-9A62-C191BF675B86}.Release|Win32.ActiveCfg = Release|Win32
		{4F30B56B-0430-4752-9A62-C191BF675B86}.Release|Win32.Build.0 = Release|Win32
		{4F30B56B-0430-4752-9A62-C191BF675B86}.Release|x64.ActiveCfg = Release|x64
		{4F30B56B-0430-4752-9A62-C191BF675B86}.Release|x64.Build.0 = Release|x64
		{413A4356-BD98-4A7D-A427-BAA93936627F}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{413A4356-BD98-4A7D-A427-BAA93936627F}.Debug|Win32.ActiveCfg = Debug|Win32
		{413A4356-BD98-4A7D-A427-BAA93936627F}.Debug|Win32.Build.0 = Debug|Win32
		{413A4356-BD98-4A7D-A427-BAA93936627F}.Debug|x64.ActiveCfg = Debug|x64
		{413A4356-BD98-4A7D-A427-BAA93936627F}.Debug|x64.Build.0 = Debug|x64
		{413A4356-BD98-4A7D-A427-BAA93936627F}.Release|Any CPU.ActiveCfg = Release|Win32
		{413A4356-BD98-4A7D-A427-BAA93936627F}.Release|Win32.ActiveCfg = Release|Win32
		{413A4356-BD98-4A7D-A427-BAA93936627F}.Release|Win32.Build.0 = Release|Win32
		{413A4356-BD98-4A7D-A427-BAA93936627F}.Release|x64.ActiveCfg = Release|x64
		{413A4356-BD98-4A7D-A427-BAA93936627F}.Release|x64.Build.0 = Release|x64
		{0F3C70B5-B074-4374-AA6F-A88A0C8A2B47}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{0F3C70B5-B074-4374-AA6F-A88A0C8A2B47}.Debug|Win32.ActiveCfg = Debug|Win32
		{0F3C70B5-B074-4374-AA6F-A88A0C8A2B47}.Debug|Win32.Build.0 = Debug|Win32
		{0F3C70B5-B074-4374-AA6F-A88A0C8A2B47}.Debug|x64.ActiveCfg = Debug|x64
		{0F3C70B5-B074-4374-AA6F-A88A0C8A2B47}.Debug|x64.Build.0 = Debug|x64
		{0F3C70B5-B074-4374-AA6F-A88A0C8A2B47}.Release|Any CPU.ActiveCfg = Release|Win32
		{0F3C70B5-B074-4374-AA6F-A88A0C8A2B47}.Release|Win32.ActiveCfg = Release|Win32
		{0F3C70B5-B074-4374-AA6F-A88A0C8A2B47}.Release|Win32.Build.0 = Release|Win32
		{0F3C70B5-B074-4374-AA6F-A88A0C8A2B47}.Release|x64.ActiveCfg = Release|x64
		{0F3C70B5-B074-4374-AA6F-A88A0C8A2B47}.Release|x64.Build.0 = Release|x64
		{67493328-FEFE-4D0C-B747-AEBAF569E29D}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{67493328-FEFE-4D0C-B747-AEBAF569E29D}.Debug|Win32.ActiveCfg = Debug|Win32
		{67493328-FEFE-4D0C-B747-AEBAF569E29D}.Debug|Win32.Build.0 = Debug|Win32
		{67493328-FEFE-4D0C-B747-AEBAF569E29D}.Debug|x64.ActiveCfg = Debug|x64
		{67493328-FEFE-4D0C-B747-AEBAF569E29D}.Debug|x64.Build.0 = Debug|x64
		{67493328-FEFE-4D0C-B747-AEBAF569E29D}.Release|Any CPU.ActiveCfg = Release|Win32
		{67493328-FEFE-4D0C-B747-AEBAF569E29D}.Release|Win32.ActiveCfg = Release|Win32
		{67493328-FEFE-4D0C-B747-AEBAF569E29D}.Release|Win32.Build.0 = Release|Win32
		{67493328-FEFE-4D0C-B747-AEBAF569E29D}.Release|x64.ActiveCfg = Release|x64
		{67493328-FEFE-4D0C-B747-AEBAF569E29D}.Release|x64.Build.0 = Release|x64
		{C23F0DA0-1DB4-4D73-B380-08DF35F5752C}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{C23F0DA0-1DB4-4D73-B380-08DF35F5752C}.Debug|Win32.ActiveCfg = Debug|Win32
		{C23F0DA0-1DB4-4D73-B380-08DF35F5752C}.Debug|Win32.Build.0 = Debug|Win32
		{C23F0DA0-1DB4-4D73-B380-08DF35F5752C}.Debug|x64.ActiveCfg = Debug|x64
		{C23F0DA0-1DB4-4D73-B380-08DF35F5752C}.Debug|x64.Build.0 = Debug|x64
		{C23F0DA0-1DB4-4D73-B380-08DF35F5752C}.Release|Any CPU.ActiveCfg = Release|Win32
		{C23F0DA0-1DB4-4D73-B380-08DF35F5752C}.Release|Win32.ActiveCfg = Release|Win32
		{C23F0DA0-1DB4-4D73-B380-08DF35F5752C}.Release|Win32.Build.0 = Release|Win32
		{C23F0DA0-1DB4-4D73-B380-08DF35F5752C}.Release|x64.ActiveCfg = Release|x64
		{C23F0DA0-1DB4-4D73-B380-08DF35F5752C}.Release|x64.Build.0 = Release|x64
		{FBD85DFD-8E2E-445E-99CB-03B1886BA959}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{FBD85DFD-8E2E-445E-99CB-03B1886BA959}.Debug|Win32.ActiveCfg = Debug|Win32
		{FBD85DFD-8E2E-445E-99CB-03B1886BA959}.Debug|Win32.Build.0 = Debug|Win32
		{FBD85DFD-8E2E-445E-99CB-03B1886BA959}.Debug|x64.ActiveCfg = Debug|x64
		{FBD85DFD-8E2E-445E-99CB-03B1886BA959}.Debug|x64.Build.0 = Debug|x64
		{FBD85DFD-8E2E-445E-99CB-03B1886BA959}.Release|Any CPU.ActiveCfg = Release|Win32
		{FBD85DFD-8E2E-445E-99CB-03B1886BA959}.Release|Win32.ActiveCfg = Release|Win32
		{FBD85DFD-8E2E-445E-99CB-03B1886BA959}.Release|Win32.Build.0 = Release|Win32
		{FBD85DFD-8E2E-445E-99CB-03B1886BA959}.Release|x64.ActiveCfg = Release|x64
		{FBD85DFD-8E2E-445E-99CB-03B1886BA959}.Release|x64.Build.0 = Release|x64
		{C9695514-52DA-4E06-8A25-BE91B3346285}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{C9695514-52DA-4E06-8A25-BE91B3346285}.Debug|Win32.ActiveCfg = Debug|Win32
		{C9695514-52DA-4E06-8A25-BE91B3346285}.Debug|Win32.Build.0 = Debug|Win32
		{C9695514-52DA-4E06-8A25-BE91B3346285}.Debug|x64.ActiveCfg = Debug|x64
		{C9695514-52DA-4E06-8A25-BE91B3346285}.Debug|x64.Build.0 = Debug|x64
		{C9695514-52DA-4E06-8A25-BE91B3346285}.Release|Any CPU.ActiveCfg = Release|Win32
		{C9695514-52DA-4E06-8A25-BE91B3346285}.Release|Win32.ActiveCfg = Release|Win32
		{C9695514-52DA-4E06-8A25-BE91B3346285}.Release|Win32.Build.0 = Release|Win32
		{C9695514-52DA-4E06-8A25-BE91B3346285}.Release|x64.ActiveCfg = Release|x64
		{C9695514-52DA-4E06-8A25-BE91B3346285}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A8E819A5-D073-4E38-96A9-8972A53858C9}
	EndGlobalSection
EndGlobal

```

`WowFisher/Fisher.cpp`:

```cpp
#pragma execution_character_set("utf-8")
#include "stdafx.h"
#include "Fisher.h"
#include "WowFisherDlg.h"
#include "FisherStateMachine.h"
#include "FishingSoundListener.h"
#include "CommUtil/CommUtil.hpp"
#include "CommUtil/FTimer.h"
#include "Win32Util/Util/Utility.h"
#include "Win32Util/Mouse/MouseGlobal.h"
#include "Win32Util/Keyboard/KeyboardBackground.h"
#include "Win32Util/Image/ImageUtil.h"
#include <ctime>


static UINT __stdcall FishingTheadProc(LPVOID param);


Fisher::Fisher(HWND hwnd, int x, int y, int w, int h)
    : m_hWndWOW(hwnd)
    , m_hWndMain(0)
    , m_bInited(false)
    , m_bFishing(false)
    , m_bHasBite(false)
    , m_floatPoint()
    , m_hotkeyThrow(0)
    , m_hotkeyBite1(0)
    , m_hotkeyBite2(0)
    , m_hotkeyBite3(0)
    , m_hThreadFishing(NULL)
{
    m_throwCount = m_timeoutCount = m_findFloatFailCount = 0;
    m_jumpTime = 0;
    m_baitTime = 0;
    m_state_machine = new FisherStateMachine(this);
    m_sound = new FishingSoundListener(this);
    m_keyboard = new KeyboardBackground(m_hWndWOW);
    m_mouse = new MouseGlobal();
}

Fisher::~Fisher()
{
    Stop();

    SAFE_DELETE(m_state_machine);
    SAFE_DELETE(m_sound);
    SAFE_DELETE(m_keyboard);
    SAFE_DELETE(m_mouse);
}

bool Fisher::Init()
{
    if (m_bInited)
        return true;

    if (!m_sound->Init())
    {
        return false;
    }

    m_state_machine->Init();

    m_bInited = true;
    return true;
}

void Fisher::SetWowHWnd(HWND hwnd)
{
    m_hWndWOW = hwnd;
}

void Fisher::SetMainHWnd(HWND hwnd)
{
    m_hWndMain = hwnd;
}

void Fisher::PressKeyboard(int key)
{
    m_keyboard->PressKey(key & 0xff, (key >> 8) & 0xff);
}

void Fisher::PressKey(int key)
{
    m_keyboard->PressKey(key);
}

bool Fisher::Start()
{
    if (m_mouse->GetHwnd() != m_hWndWOW)
    {
        m_mouse->SetHwnd(m_hWndWOW);
        if (!m_mouse->Init())
        {
            wprintf(L"初始化鼠标失败！\n");
            return false;
        }
    }

    if (m_keyboard->GetHwnd() != m_hWndWOW)
    {
        m_keyboard->SetHwnd(m_hWndWOW);
        if (!m_keyboard->Init())
        {
            wprintf(L"初始化键盘失败！\n");
            return false;
        }
    }

    if (Utility::GetWndExePath(m_hWndWOW, m_wowPath))
    {
        size_t pos = m_wowPath.find_last_of('\\');
        if (pos != std::string::npos)
            m_screenshotPath = m_wowPath.substr(0, pos) + L"\\Screenshots";
        else
            m_screenshotPath = m_wowPath;
    }
    else
    {
        wprintf(L"查找安装路径失败！\n");
        return false;
    }

    m_hThreadFishing = (HANDLE)::_beginthreadex(NULL, 0, &FishingTheadProc, this, 0, NULL);
    if (m_hThreadFishing == NULL)
    {
        wprintf(L"创建线程失败！\n");
        return false;
    }

    m_bFishing = true;
    return true;
}

void Fisher::Stop()
{
    m_bFishing = false;

    if (m_hThreadFishing != NULL)
    {
        CloseHandle(m_hThreadFishing);
        m_hThreadFishing = NULL;
    }

    m_sound->Stop();
	m_sound->Save();
}

static UINT __stdcall FishingTheadProc(LPVOID param)
{
    Fisher* pFisher = (Fisher*)param;
    if (pFisher)
    {
        pFisher->StartFishing();
    }
    return 0;
}

FisherStateMachine& Fisher::GetStateMachine()
{
    return *m_state_machine;
}

void Fisher::StartFishing()
{
    m_bFishing = true;
    m_baitTime = 0;

    wprintf(L"---------------------------------------\n");

    m_state_machine->GotoState(FisherStateType::FisherState_Start);

    comm_util::FTimer timer;
    timer.Start();

    int64_t last_time = timer.MilliSeconds();

    while (m_bFishing)
    {
        int64_t cur_time = timer.MilliSeconds();
        int dt = (int)(cur_time - last_time);

        m_state_machine->Update(dt);

        last_time = cur_time;
        ::Sleep((DWORD)10);
    }

    timer.Stop();
}

void Fisher::SetBaitTime(time_t time)
{
    m_baitTime = time;
}

time_t Fisher::GetBaitTime() const
{
    return m_baitTime;
}

// 甩竿
bool Fisher::ThrowPole()
{
    m_throwCount++;
    PressKeyboard(m_hotkeyThrow);
    ::SendMessage(m_hWndMain, WMU_UPDATE_STATISTICS, 0, 0);
    return true;
}

static bool MatchFloatColor(char _r, char _g, char _b)
{
    unsigned r = (unsigned char)_r;
    unsigned g = (unsigned char)_g;
    unsigned b = (unsigned char)_b;
    if (r > g && r > b)
    {
        if (g == 0)
            g = 1;
        if (b == 0)
            b = 1;
        float r_g = (float)r / g;
        float r_b = (float)r / b;
        if (r_g > 2.0f && r_b > 2.0f)
        {
            return true;
        }
    }
    return false;
}

// 寻找鱼漂
bool Fisher::FindFloat()
{
    std::wstring path;
    if (!Utility::FindLatestFile(m_screenshotPath, path))
    {
        wprintf(L"未找到截图: %s\n", m_screenshotPath.c_str());
        return false;
    }

    CImage image;
    HRESULT res = image.Load(path.c_str());
    if (res != S_OK)
    {
        wprintf(L"图片读取失败: %s\n", path.c_str());
        return false;
    }

    ::DeleteFileW(path.c_str());

    m_points.clear();
    ImageUtil::FindColor(image, MatchFloatColor, m_points);
    image.Destroy();

    {
        if (m_points.size() >= 2000) // 找多太多点，可能是UI开着或水域不合适，无法定位鱼漂
            m_points.clear();

        if (m_points.size() == 0)
            wprintf(L"寻找鱼漂失败。\n");

        POINT p;
        if (ImageUtil::SelectBestPoint(m_points, 30, p)) // 根据鱼漂的大概半径选择最优的点
        {
            wprintf(L"找到鱼漂: %d, %d\n", p.x, p.y);

            m_floatPoint = p;

            ::ClientToScreen(m_hWndWOW, &p);
            m_mouse->SetCursorPos(p.x, p.y);

            return true;
        }
    }

    ++m_findFloatFailCount;
    ::SendMessage(m_hWndMain, WMU_UPDATE_STATISTICS, 0, 0);

    return false;
}

// 等待上钩
bool Fisher::StartListenBite()
{
    m_bHasBite = false;
    return m_sound->Start();
}

void Fisher::StopListenBite()
{
    m_sound->Stop();

    if (!m_bHasBite)
    {
        ++m_timeoutCount;
        ::SendMessage(m_hWndMain, WMU_UPDATE_STATISTICS, 0, 0);
    }
}

bool Fisher::HasBite() const
{
    return m_bHasBite;
}

// 提竿
bool Fisher::Shaduf()
{
    bool res = true;

    POINT p = m_floatPoint;
    ::ClientToScreen(m_hWndWOW, &p);

    m_mouse->SetCursorPos(p.x, p.y); // 重新设定鼠标，防止中间移动而在错误的位置。
    m_mouse->ClickRightButton();

    return res;
}


void Fisher::Jump()
{
    m_jumpTime = time(NULL);
    m_keyboard->PressKey(VK_SPACE);
}

bool Fisher::NeedJump() const
{
    time_t now = time(NULL);
    bool jump = (now >= m_jumpTime + 10 * 60);
    return jump;
}

void Fisher::TurnEnd()
{
    wprintf(L"throw: %d, timeout: %d, float: %d\n", m_throwCount, m_timeoutCount, m_findFloatFailCount);
    wprintf(L"---------------------------------------\n");
}

void Fisher::NotifyBite()
{
    PrintStatus(L"咬钩了！\n");
    m_bHasBite = true;
}

void Fisher::PrintStatus(LPCWSTR msg)
{
    wprintf(L"%ls", msg);
    ::SendMessage(m_hWndMain, WMU_UPDATE_STATUS, (WPARAM)msg, 0);
}

void Fisher::SetAmpL(float ampL)
{
    m_sound->SetAmpL(ampL);
}

void Fisher::SetAmpH(float ampH)
{
    m_sound->SetAmpH(ampH);
}

void Fisher::SetSilentMax(int count)
{
    m_sound->SetSilentMaxCount(count);
}

void Fisher::SetSoundMin(int count)
{
    m_sound->SetSoundMinCount(count);
}

void Fisher::SetHotkeyThrow(DWORD hotkey)
{
    m_hotkeyThrow = hotkey;
}

void Fisher::SetHotkeyBite1(DWORD hotkey)
{
    m_hotkeyBite1 = hotkey;
}
void Fisher::SetHotkeyBite2(DWORD hotkey)
{
    m_hotkeyBite2 = hotkey;
}

void Fisher::SetHotkeyBite3(DWORD hotkey)
{
    m_hotkeyBite3 = hotkey;
}

int Fisher::GetThrowCount()
{
    return m_throwCount;
}

int Fisher::GetFindFloatFailCount()
{
    return m_findFloatFailCount;
}

int Fisher::GetTimeoutCount()
{
    return m_timeoutCount;
}

void Fisher::SetThrowCount(int count)
{
    m_throwCount = count;
}

void Fisher::SetFindFloatFailCount(int count)
{
    m_findFloatFailCount = count;
}

void Fisher::SetTimeoutCount(int count)
{
    m_timeoutCount = count;
}

```

`WowFisher/Fisher.h`:

```h
#pragma once
#pragma execution_character_set("utf-8")
#include "FisherStateDefine.h"
#include <Windows.h>
#include <list>
#include <string>

const int MAX_BAIT_TIME = 10 * 60; // 鱼饵持续时间，单位秒
const int MAX_BITE_TIME = 23; // 最长等待咬钩时间，单位秒

class MouseBase;
class KeyboardBase;
class FishingSoundListener;
class FisherStateMachine;

class Fisher
{
    friend static UINT __stdcall FishingTheadProc(LPVOID param);
    friend class FisherStateCheckBait;
    friend class FisherStateBait;
    friend class FisherStateThrowPole;
    friend class FisherStateFindFloat;
    friend class FisherStateWaitBite;
    friend class FisherStateShaduf;
    friend class FisherStateWaitFloatHide;
    friend class FisherStateJump;
public:
    Fisher(HWND hwnd, int x, int y, int w, int h);
    ~Fisher();

    bool Init();
    void SetWowHWnd(HWND hwnd);
    void SetMainHWnd(HWND hwnd);

    bool Start();
    void Stop();

    void NotifyBite(); // used by FishingSoundListener.

    void SetAmpL(float ampL);
    void SetAmpH(float ampH);
    void SetSilentMax(int count);
    void SetSoundMin(int count);

    void SetHotkeyThrow(DWORD hotkey);
    void SetHotkeyBite1(DWORD hotkey);
    void SetHotkeyBite2(DWORD hotkey);
    void SetHotkeyBite3(DWORD hotkey);

    int GetThrowCount();
    int GetFindFloatFailCount();
    int GetTimeoutCount();
    void SetThrowCount(int count);
    void SetFindFloatFailCount(int count);
    void SetTimeoutCount(int count);

private:
    void PressKeyboard(int key);
    void PressKey(int key);

    FisherStateMachine& GetStateMachine();

    void SetBaitTime(time_t time);
    time_t GetBaitTime() const;

    void StartFishing();
    bool ThrowPole();
    bool FindFloat();
    bool StartListenBite();
    void StopListenBite();
    bool HasBite() const;
    bool Shaduf();
    void Jump();
    bool NeedJump() const;
    void TurnEnd();

    void PrintStatus(LPCWSTR msg);

private:
    HWND m_hWndWOW; // 魔兽世界窗口句柄
    HWND m_hWndMain;

    time_t m_jumpTime; // 跳跃时间
    time_t m_baitTime; // 上饵时间
    bool m_bHasBite; // 是否已咬钩
    POINT m_floatPoint;

    DWORD m_hotkeyThrow;
    DWORD m_hotkeyBite1;
    DWORD m_hotkeyBite2;
    DWORD m_hotkeyBite3;

    int m_throwCount;
    int m_findFloatFailCount;
    int m_timeoutCount;

    std::list<POINT> m_points;

    MouseBase* m_mouse;
    KeyboardBase* m_keyboard;
    FishingSoundListener* m_sound;
    FisherStateMachine* m_state_machine;

    HANDLE m_hThreadFishing;

    bool m_bInited;
    bool m_bFishing;

    std::wstring m_wowPath;
    std::wstring m_screenshotPath;
};


```

`WowFisher/FisherConfig.cpp`:

```cpp
#include "stdafx.h"
#include "FisherConfig.h"
#include <locale.h>


FisherConfig::FisherConfig(LPCWSTR path)
    : m_filePath(path)
    , m_nAmpMax(0)
    , m_nAmpL(0)
    , m_nAmpH(0)
    , m_nSilentMaxCount(0)
    , m_nSoundMinCount(0)
    , m_nThrowCount(0)
    , m_nTimeoutCount(0)
    , m_nFloatCount(0)
    , m_bShowConsole(0)
    , m_hotkeyThrow(0)
    , m_hotkeyBite1(0)
    , m_hotkeyBite2(0)
    , m_hotkeyBite3(0)
{
}

FisherConfig::~FisherConfig()
{
}

int FisherConfig::GetPrivateProfileInt(LPCWSTR key, int defaultValue)
{
    int value = ::GetPrivateProfileInt(L"Fisher", key, defaultValue, m_filePath.c_str());
    return value;
}

void FisherConfig::WritePrivateProfileInt(LPCWSTR key, int value)
{
    WCHAR buf[20];
    wsprintf(buf, L"%d", value);
    ::WritePrivateProfileString(L"", key, buf, m_filePath.c_str());
}

bool FisherConfig::LoadConfig()
{
    m_nAmpMax = GetPrivateProfileInt(L"AmpMax", 10);
    m_nAmpH = GetPrivateProfileInt(L"AmpH", 200);
    m_nAmpL = GetPrivateProfileInt(L"AmpL", 5);

    m_hotkeyThrow = GetPrivateProfileInt(L"HotkeyThrow", 0x31);
    m_hotkeyBite1 = GetPrivateProfileInt(L"HotkeyBite1", 0x33);
    m_hotkeyBite2 = GetPrivateProfileInt(L"HotkeyBite2", 0x34);
    m_hotkeyBite3 = GetPrivateProfileInt(L"HotkeyBite3", 0x35);

    m_nSilentMaxCount = GetPrivateProfileInt(L"SilentMaxCount", 10);
    m_nSoundMinCount = GetPrivateProfileInt(L"SoundMinCount", 20);

    m_bShowConsole = GetPrivateProfileInt(L"ShowConsole", 0);

    m_nThrowCount = GetPrivateProfileInt(L"ThrowCount", 0);
    m_nTimeoutCount = GetPrivateProfileInt(L"TimeoutCount", 0);
    m_nFloatCount = GetPrivateProfileInt(L"FloatCount", 0);

    return true;
}

void FisherConfig::SaveConfig()
{
    WritePrivateProfileInt(L"AmpMax", m_nAmpMax);
    WritePrivateProfileInt(L"AmpH", m_nAmpH);
    WritePrivateProfileInt(L"AmpL", m_nAmpL);

    WritePrivateProfileInt(L"HotkeyThrow", m_hotkeyThrow);
    WritePrivateProfileInt(L"HotkeyBite1", m_hotkeyBite1);
    WritePrivateProfileInt(L"HotkeyBite2", m_hotkeyBite2);
    WritePrivateProfileInt(L"HotkeyBite3", m_hotkeyBite3);

    WritePrivateProfileInt(L"SilentMaxCount", m_nSilentMaxCount);
    WritePrivateProfileInt(L"SoundMinCount", m_nSoundMinCount);

    WritePrivateProfileInt(L"ShowConsole", m_bShowConsole);

    WritePrivateProfileInt(L"ThrowCount", m_nThrowCount);
    WritePrivateProfileInt(L"TimeoutCount", m_nTimeoutCount);
    WritePrivateProfileInt(L"FloatCount", m_nFloatCount);
}

```

`WowFisher/FisherConfig.h`:

```h
#pragma once
#include <string>

class FisherConfig
{
public:
    FisherConfig(LPCWSTR path);
    ~FisherConfig();

    bool LoadConfig();
    void SaveConfig();

private:
    int GetPrivateProfileInt(LPCWSTR key, int defaultValue);
    void WritePrivateProfileInt(LPCWSTR key, int value);

public:
    int m_nAmpMax;
    int m_nAmpL;
    int m_nAmpH;
    int m_nSilentMaxCount;
    int m_nSoundMinCount;

    int m_nThrowCount;
    int m_nTimeoutCount;
    int m_nFloatCount;

    int m_bShowConsole;

    DWORD m_hotkeyThrow;
    DWORD m_hotkeyBite1;
    DWORD m_hotkeyBite2;
    DWORD m_hotkeyBite3;

private:
    std::wstring m_filePath;
};


```

`WowFisher/FisherStateBait.cpp`:

```cpp
#pragma execution_character_set("utf-8")
#include "stdafx.h"
#include "FisherStateBait.h"
#include "FisherStateMachine.h"
#include "Fisher.h"


FisherStateBait::FisherStateBait(FisherStateType state_type, Fisher* fisher)
    : FisherStateBase(state_type, fisher)
    , m_has_press_bite1(false)
    , m_has_press_bite2(false)
    , m_has_press_bite3(false)
{
}

FisherStateBait::~FisherStateBait()
{
}

void FisherStateBait::OnEnter(void* param)
{
    m_fisher->PrintStatus(L"上饵...\n");

    m_has_press_bite1 = false;
    m_has_press_bite2 = false;
    m_has_press_bite3 = false;
    m_timer = 0;
}

void FisherStateBait::OnLeave(void* param)
{
}

void FisherStateBait::Update(int dt)
{
    FisherStateBase::Update(dt);

    if (m_timer > 0)
    {
        return;
    }

    if (!m_has_press_bite1)
    {
        m_has_press_bite1 = true;
        if (m_fisher->m_hotkeyBite1 != 0)
        {
            m_fisher->PressKeyboard(m_fisher->m_hotkeyBite1);
            SetRandomTimer(2100);
            return;
        }
    }

    if (!m_has_press_bite2)
    {
        m_has_press_bite2 = true;
        if (m_fisher->m_hotkeyBite2 != 0)
        {
            m_fisher->PressKeyboard(m_fisher->m_hotkeyBite2);
            SetRandomTimer(2100);
            return;
        }
    }

    if (!m_has_press_bite3)
    {
        m_has_press_bite3 = true;
        if (m_fisher->m_hotkeyBite3 != 0)
        {
            m_fisher->PressKeyboard(m_fisher->m_hotkeyBite3);
            SetRandomTimer(2100);
            return;
        }
    }

    if (m_timer <= 0)
    {
        m_fisher->SetBaitTime(time(NULL));
        m_fisher->GetStateMachine().GotoState(FisherStateType::FisherState_ThrowPole);
    }
}

```

`WowFisher/FisherStateBait.h`:

```h
#pragma once
#include "FisherStateBase.h"

class FisherStateBait : public FisherStateBase
{
public:
    FisherStateBait(FisherStateType state_type, Fisher* fisher);
    virtual ~FisherStateBait();

    virtual void OnEnter(void* param) override;
    virtual void OnLeave(void* param) override;
    virtual void Update(int dt) override;

private:
    bool m_has_press_bite1;
    bool m_has_press_bite2;
    bool m_has_press_bite3;
};


```

`WowFisher/FisherStateBase.cpp`:

```cpp
#pragma execution_character_set("utf-8")
#include "stdafx.h"
#include "FisherStateBase.h"
#include "Fisher.h"
#include <ctime>

std::default_random_engine FisherStateBase::m_random_engine((unsigned int)time(NULL));

using comm_util::StateBase;

FisherStateBase::FisherStateBase(FisherStateType state_type, Fisher* fisher)
    : StateBase((int)state_type)
    , m_fisher(fisher)
{
}


FisherStateBase::~FisherStateBase()
{
}


void FisherStateBase::OnEnter(void* param)
{
    m_timer = 0;
}

void FisherStateBase::OnLeave(void* param)
{
}

void FisherStateBase::Update(int dt)
{
    if (m_timer > 0)
    {
        m_timer -= dt;
        if (m_timer < 0)
        {
            m_timer = 0;
        }
    }
}

void FisherStateBase::SetRandomTimer(int time)
{
    m_timer = time + GetRandomDelay();
}

int FisherStateBase::GetRandomDelay()
{
    static std::uniform_int_distribution<int> dis(0, 30);
    return dis(m_random_engine) + 20;
}

```

`WowFisher/FisherStateBase.h`:

```h
#pragma once
#include <CommUtil/StateBase.h>
#include <random>
#include "FisherStateDefine.h"

class Fisher;

class FisherStateBase : public comm_util::StateBase
{
public:
    FisherStateBase(FisherStateType state_type, Fisher* fisher);
    virtual ~FisherStateBase();

    virtual void OnEnter(void* param) override;
    virtual void OnLeave(void* param) override;
    virtual void Update(int dt) override;

protected:
    virtual void SetRandomTimer(int time);
    virtual int GetRandomDelay();

protected:
    Fisher * m_fisher;
    int m_timer;
    static std::default_random_engine m_random_engine;
};


```

`WowFisher/FisherStateCheckBait.cpp`:

```cpp
#pragma execution_character_set("utf-8")
#include "stdafx.h"
#include "FisherStateCheckBait.h"
#include "FisherStateMachine.h"
#include "Fisher.h"


FisherStateCheckBait::FisherStateCheckBait(FisherStateType state_type, Fisher* fisher)
    : FisherStateBase(state_type, fisher)
{
}

FisherStateCheckBait::~FisherStateCheckBait()
{
}

void FisherStateCheckBait::OnEnter(void* param)
{
    m_timer = 0;
}

void FisherStateCheckBait::OnLeave(void* param)
{
}

void FisherStateCheckBait::Update(int dt)
{
    bool is_bait_timeout = false;
    time_t bait_time = m_fisher->GetBaitTime();
    if (bait_time == 0)
    {
        is_bait_timeout = true;
    }
    else
    {
        time_t now = time(NULL);
        is_bait_timeout = (now - bait_time) > (MAX_BAIT_TIME - MAX_BITE_TIME);
    }

    if (is_bait_timeout)
    {
        m_fisher->GetStateMachine().GotoState(FisherStateType::FisherState_Bait);
    }
    else
    {
        m_fisher->GetStateMachine().GotoState(FisherStateType::FisherState_ThrowPole);
    }
}

```

`WowFisher/FisherStateCheckBait.h`:

```h
#pragma once
#include "FisherStateBase.h"
class FisherStateCheckBait :
    public FisherStateBase
{
public:
    FisherStateCheckBait(FisherStateType state_type, Fisher* fisher);
    virtual ~FisherStateCheckBait();

    virtual void OnEnter(void* param) override;
    virtual void OnLeave(void* param) override;
    virtual void Update(int dt) override;
};


```

`WowFisher/FisherStateDefine.h`:

```h
#pragma once

enum FisherStateType
{
    FisherState_Start,
    FisherState_CheckBait, // 检查状态
    FisherState_Bait, // 上鱼饵
    FisherState_ThrowPole, // 甩竿
    FisherState_FindFloat, // 定位浮标
    FisherState_WaitBite, // 等待咬钩
    FisherState_Shaduf, // 提竿
    FisherState_WaitFloatHide, // 等待浮标消失
    FisherState_Jump, // 跳跃
};

```

`WowFisher/FisherStateFindFloat.cpp`:

```cpp
#pragma execution_character_set("utf-8")
#include "stdafx.h"
#include "FisherStateFindFloat.h"
#include "FisherStateMachine.h"
#include "Fisher.h"


FisherStateFindFloat::FisherStateFindFloat(FisherStateType state_type, Fisher* fisher)
    : FisherStateBase(state_type, fisher)
    , m_has_find_start(false)
    , m_has_find_float(false)
{
}

FisherStateFindFloat::~FisherStateFindFloat()
{
}

void FisherStateFindFloat::OnEnter(void* param)
{
    m_fisher->PrintStatus(L"寻找鱼漂...\n");
    m_fisher->PressKey(VK_SNAPSHOT); // 使用游戏截图的方式
    m_timer = 1500; // 等待截屏

    m_has_find_start = false;
    m_has_find_float = false;
}

void FisherStateFindFloat::OnLeave(void* param)
{
}

void FisherStateFindFloat::Update(int dt)
{
    FisherStateBase::Update(dt);

    if (!m_has_find_start && m_timer <= 0)
    {
        m_has_find_start = true;
        m_has_find_float = m_fisher->FindFloat();
        if (!m_has_find_float)
        {
            m_fisher->Jump();
            m_timer = 2000; // 寻找鱼漂失败，等现鱼漂消失再重新抛竿。
        }
        else
        {
            m_timer = 0;
        }
        return;
    }

    if (m_timer <= 0)
    {
        if (m_has_find_float)
        {
            m_fisher->GetStateMachine().GotoState(FisherStateType::FisherState_WaitBite);
        }
        else
        {
            m_fisher->GetStateMachine().GotoState(FisherStateType::FisherState_ThrowPole);
        }
    }
}

```

`WowFisher/FisherStateFindFloat.h`:

```h
#pragma once
#include "FisherStateBase.h"
class FisherStateFindFloat :
    public FisherStateBase
{
public:
    FisherStateFindFloat(FisherStateType state_type, Fisher* fisher);
    virtual ~FisherStateFindFloat();

    virtual void OnEnter(void* param) override;
    virtual void OnLeave(void* param) override;
    virtual void Update(int dt) override;

private:
    bool m_has_find_start;
    bool m_has_find_float;
};


```

`WowFisher/FisherStateJump.cpp`:

```cpp
#pragma execution_character_set("utf-8")
#include "stdafx.h"
#include "FisherStateJump.h"
#include "FisherStateMachine.h"
#include "Fisher.h"


FisherStateJump::FisherStateJump(FisherStateType state_type, Fisher* fisher)
    : FisherStateBase(state_type, fisher)
{
}

FisherStateJump::~FisherStateJump()
{
}

void FisherStateJump::OnEnter(void* param)
{
    m_fisher->Jump();
    SetRandomTimer(1500);
}

void FisherStateJump::OnLeave(void* param)
{
}

void FisherStateJump::Update(int dt)
{
    FisherStateBase::Update(dt);

    if (m_timer <= 0)
    {
        m_fisher->GetStateMachine().GotoState(FisherStateType::FisherState_Start);
    }
}

```

`WowFisher/FisherStateJump.h`:

```h
#pragma once
#include "FisherStateBase.h"
class FisherStateJump :
    public FisherStateBase
{
public:
    FisherStateJump(FisherStateType state_type, Fisher* fisher);
    virtual ~FisherStateJump();

    virtual void OnEnter(void* param) override;
    virtual void OnLeave(void* param) override;
    virtual void Update(int dt) override;
};


```

`WowFisher/FisherStateMachine.cpp`:

```cpp
#pragma execution_character_set("utf-8")
#include "stdafx.h"
#include "FisherStateMachine.h"
#include "FisherStateBase.h"
#include "FisherStateBait.h"
#include "FisherStateCheckBait.h"
#include "FisherStateFindFloat.h"
#include "FisherStateShaduf.h"
#include "FisherStateThrowPole.h"
#include "FisherStateWaitBite.h"
#include "FisherStateWaitFloatHide.h"
#include "FisherStateJump.h"
#include "Fisher.h"


FisherStateMachine::FisherStateMachine(Fisher* fisher)
    : m_fisher(fisher)
{
}

FisherStateMachine::~FisherStateMachine()
{
}

void FisherStateMachine::Init()
{
    AddState(CreateState(FisherStateType::FisherState_Start));
    AddState(CreateState(FisherStateType::FisherState_CheckBait));
    AddState(CreateState(FisherStateType::FisherState_Bait));
    AddState(CreateState(FisherStateType::FisherState_ThrowPole));
    AddState(CreateState(FisherStateType::FisherState_FindFloat));
    AddState(CreateState(FisherStateType::FisherState_WaitBite));
    AddState(CreateState(FisherStateType::FisherState_Shaduf));
    AddState(CreateState(FisherStateType::FisherState_WaitFloatHide));
    AddState(CreateState(FisherStateType::FisherState_Jump));
}

FisherStateBase* FisherStateMachine::CreateState(FisherStateType state_type)
{
    switch (state_type)
    {
    case FisherState_Start:
    case FisherState_CheckBait:
        return new FisherStateCheckBait(state_type, m_fisher);
    case FisherState_Bait:
        return new FisherStateBait(state_type, m_fisher);
    case FisherState_ThrowPole:
        return new FisherStateThrowPole(state_type, m_fisher);
    case FisherState_FindFloat:
        return new FisherStateFindFloat(state_type, m_fisher);
    case FisherState_WaitBite:
        return new FisherStateWaitBite(state_type, m_fisher);
    case FisherState_Shaduf:
        return new FisherStateShaduf(state_type, m_fisher);
    case FisherState_WaitFloatHide:
        return new FisherStateWaitFloatHide(state_type, m_fisher);
    case FisherState_Jump:
        return new FisherStateJump(state_type, m_fisher);
    default:
        return new FisherStateBase(state_type, m_fisher);
        break;
    }
}

```

`WowFisher/FisherStateMachine.h`:

```h
#pragma once
#include <CommUtil/StateMachine.h>
#include "FisherStateDefine.h"

class FisherStateBase;
class Fisher;

class FisherStateMachine : public comm_util::StateMachine
{
public:
    FisherStateMachine(Fisher* fisher);
    virtual ~FisherStateMachine();

    virtual void Init() override;

private:
    FisherStateBase * CreateState(FisherStateType state_type);

private:
    Fisher * m_fisher;
};


```

`WowFisher/FisherStateShaduf.cpp`:

```cpp
#pragma execution_character_set("utf-8")
#include "stdafx.h"
#include "FisherStateShaduf.h"
#include "FisherStateMachine.h"
#include "Fisher.h"


FisherStateShaduf::FisherStateShaduf(FisherStateType state_type, Fisher* fisher)
    : FisherStateBase(state_type, fisher)
{
}

FisherStateShaduf::~FisherStateShaduf()
{
}

void FisherStateShaduf::OnEnter(void* param)
{
    m_fisher->Shaduf();
    m_timer = 500;
}

void FisherStateShaduf::OnLeave(void* param)
{
}

void FisherStateShaduf::Update(int dt)
{
    FisherStateBase::Update(dt);

    if (m_timer <= 0)
    {
        m_fisher->GetStateMachine().GotoState(FisherStateType::FisherState_WaitFloatHide);
    }
}

```

`WowFisher/FisherStateShaduf.h`:

```h
#pragma once
#include "FisherStateBase.h"
class FisherStateShaduf :
    public FisherStateBase
{
public:
    FisherStateShaduf(FisherStateType state_type, Fisher* fisher);
    virtual ~FisherStateShaduf();

    virtual void OnEnter(void* param) override;
    virtual void OnLeave(void* param) override;
    virtual void Update(int dt) override;
};


```

`WowFisher/FisherStateThrowPole.cpp`:

```cpp
#pragma execution_character_set("utf-8")
#include "stdafx.h"
#include "FisherStateThrowPole.h"
#include "FisherStateMachine.h"
#include "Fisher.h"


FisherStateThrowPole::FisherStateThrowPole(FisherStateType state_type, Fisher* fisher)
    : FisherStateBase(state_type, fisher)
{
}

FisherStateThrowPole::~FisherStateThrowPole()
{
}

void FisherStateThrowPole::OnEnter(void* param)
{
    m_fisher->PrintStatus(L"甩竿...\n");
    m_fisher->ThrowPole();

    SetRandomTimer(1500);
}

void FisherStateThrowPole::OnLeave(void* param)
{
}

void FisherStateThrowPole::Update(int dt)
{
    FisherStateBase::Update(dt);

    if (m_timer <= 0)
    {
        m_fisher->GetStateMachine().GotoState(FisherStateType::FisherState_FindFloat);
    }
}

```

`WowFisher/FisherStateThrowPole.h`:

```h
#pragma once
#include "FisherStateBase.h"
class FisherStateThrowPole :
    public FisherStateBase
{
public:
    FisherStateThrowPole(FisherStateType state_type, Fisher* fisher);
    virtual ~FisherStateThrowPole();

    virtual void OnEnter(void* param) override;
    virtual void OnLeave(void* param) override;
    virtual void Update(int dt) override;
};


```

`WowFisher/FisherStateWaitBite.cpp`:

```cpp
#pragma execution_character_set("utf-8")
#include "stdafx.h"
#include "FisherStateWaitBite.h"
#include "FisherStateMachine.h"
#include "Fisher.h"


FisherStateWaitBite::FisherStateWaitBite(FisherStateType state_type, Fisher* fisher)
    : FisherStateBase(state_type, fisher)
{
}

FisherStateWaitBite::~FisherStateWaitBite()
{
}

void FisherStateWaitBite::OnEnter(void* param)
{
    m_fisher->PrintStatus(L"等待上钩...\n");
    m_fisher->StartListenBite();

    SetRandomTimer(MAX_BITE_TIME * 1000);
}

void FisherStateWaitBite::OnLeave(void* param)
{
    m_fisher->StopListenBite();
}

void FisherStateWaitBite::Update(int dt)
{
    FisherStateBase::Update(dt);

    bool has_bite = m_fisher->HasBite();
    if (has_bite)
    {
        m_fisher->GetStateMachine().GotoState(FisherStateType::FisherState_Shaduf);
    }
    else if (m_timer <= 0)
    {
        m_fisher->PrintStatus(L"没有鱼儿上钩！\n");
        m_fisher->GetStateMachine().GotoState(FisherStateType::FisherState_WaitFloatHide);
    }
}

```

`WowFisher/FisherStateWaitBite.h`:

```h
#pragma once
#include "FisherStateBase.h"
class FisherStateWaitBite :
    public FisherStateBase
{
public:
    FisherStateWaitBite(FisherStateType state_type, Fisher* fisher);
    virtual ~FisherStateWaitBite();

    virtual void OnEnter(void* param) override;
    virtual void OnLeave(void* param) override;
    virtual void Update(int dt) override;
};


```

`WowFisher/FisherStateWaitFloatHide.cpp`:

```cpp
#pragma execution_character_set("utf-8")
#include "stdafx.h"
#include "FisherStateWaitFloatHide.h"
#include "FisherStateMachine.h"
#include "Fisher.h"


FisherStateWaitFloatHide::FisherStateWaitFloatHide(FisherStateType state_type, Fisher* fisher)
    : FisherStateBase(state_type, fisher)
{
}

FisherStateWaitFloatHide::~FisherStateWaitFloatHide()
{
}

void FisherStateWaitFloatHide::OnEnter(void* param)
{
    SetRandomTimer(2500);
}

void FisherStateWaitFloatHide::OnLeave(void* param)
{
}

void FisherStateWaitFloatHide::Update(int dt)
{
    FisherStateBase::Update(dt);

    if (m_timer <= 0)
    {
        if (m_fisher->NeedJump())
        {
            m_fisher->GetStateMachine().GotoState(FisherStateType::FisherState_Jump);
        }
        else
        {
            m_fisher->TurnEnd();
            m_fisher->GetStateMachine().GotoState(FisherStateType::FisherState_Start);
        }
    }
}

```

`WowFisher/FisherStateWaitFloatHide.h`:

```h
#pragma once
#include "FisherStateBase.h"
class FisherStateWaitFloatHide :
    public FisherStateBase
{
public:
    FisherStateWaitFloatHide(FisherStateType state_type, Fisher* fisher);
    virtual ~FisherStateWaitFloatHide();

    virtual void OnEnter(void* param) override;
    virtual void OnLeave(void* param) override;
    virtual void Update(int dt) override;
};


```

`WowFisher/FishingSoundListener.cpp`:

```cpp
#include "stdafx.h"
#include "FishingSoundListener.h"
#include "Fisher.h"
#include "Win32Util/Audio/Extend/AudioFingerprint.h"
#include "CommUtil/StringUtil.hpp"
#include "CommUtil/VectorUtil.hpp"
#include <functiondiscoverykeys.h>
#include <ctime>
#include <map>

using namespace std;
using namespace comm_util;

#define CFG_HIT "#hit = "
#define SAMPLE_FILE "config/fishing sample.txt"

FishingSoundListener::FishingSoundListener(Fisher* pFisher)
    : AudioExtractor(true, true)
    , m_pwfx(NULL)
    , m_pFisher(pFisher)
    , m_sampleCount(0)
    , m_dtw(256, 256)
{
    m_pAudioFingerprint = new AudioFingerprint();
}

FishingSoundListener::~FishingSoundListener()
{
    if (m_sampleFile.is_open())
    {
        m_sampleFile.close();
    }

    SAFE_DELETE(m_pAudioFingerprint);
}

int FishingSoundListener::Init()
{
    if (!m_sampleFile.is_open())
    {
        char buf[128];
        time_t t = ::time(NULL);
        struct tm ti;
        ::localtime_s(&ti, &t);
        ::sprintf_s(buf, "config/fishing sample %04d-%02d-%02d %02d.%02d.%02d.txt", (ti.tm_year + 1900), (ti.tm_mon + 1), ti.tm_mday, ti.tm_hour, ti.tm_min, ti.tm_sec);

        m_sampleFile.open(buf, ios::app | ios::out);
        if (!m_sampleFile.is_open())
        {
            printf("Can't open file: %s\n", buf);
        }
    }

    LoadSamples();

    return AudioExtractor::Init() == 0;
}

HRESULT FishingSoundListener::SetFormat(WAVEFORMATEX* pwfx)
{
    AudioCapture::SetFormat(pwfx);

    m_pwfx = pwfx;
    SetSilentMaxCount(10);
    SetSoundMinCount(20);
    SetSoundMaxCount(pwfx->nSamplesPerSec / 100 / pwfx->nChannels); // about 1 second.
    SetAmpZcr(480, 0.05f, 2.0f, 1.0f, 1.0f); // disable zcr

    return S_OK;
}

void FishingSoundListener::EndSegment()
{
    if (m_pCurSegment->GetSize() < 100)
    {
        m_pCurSegment->Reset();
        return;
    }

    auto sample = m_pAudioFingerprint->GetFingerprint(m_pCurSegment, m_pwfx, AudioFingerprint::ProcessCutAvg);
    m_pCurSegment->Reset();

    bool isMatch = IsSampleMatch(sample);

    if (m_sampleFile.is_open() && !isMatch)
    {
        SaveSample(sample, 0, m_sampleFile);
    }

    if (isMatch)
    {
        m_pFisher->NotifyBite();
    }
}

bool FishingSoundListener::IsDone() const
{
    return m_bDone;
}

void FishingSoundListener::SetAmpL(float ampL)
{
    m_sAmpZcr.ampL = ampL;
}

void FishingSoundListener::SetAmpH(float ampH)
{
    m_sAmpZcr.ampH = ampH;
}

void FishingSoundListener::Save()
{
    SaveSamples();
}

void FishingSoundListener::AddSample(const char* str, int hit)
{
    auto data = StringUtil::ParseValues<float>(str, ",", StringUtil::atof);
    if (!data.empty())
    {
        auto it = m_samples.begin();
        while (it != m_samples.end())
        {
            //float cosa = VectorUtil::getCosA_First(&it->sample[0], it->sample.size(), &data[0], data.size());
            float dtw = m_dtw.Calculate(&it->sample[0], it->sample.size(), &data[0], data.size());
            if (dtw < 3) // if (cosa >= 0.95f)
            {
                it->hit += hit;
                return;
            }
            ++it;
        }
        SampleInfo samp = { data, hit };
        m_samples.push_back(samp);
    }
}

bool FishingSoundListener::IsSampleMatch(const std::vector<float>& data)
{
    printf("sound: %zu\n", data.size());
    if (data.empty())
        return false;

    auto it = m_samples.begin();
    while (it != m_samples.end())
    {
        float cosa = VectorUtil::GetCosA_First(&it->sample[0], it->sample.size(), &data[0], data.size());
        float dtw = m_dtw.Calculate(&it->sample[0], it->sample.size(), &data[0], data.size());
        printf("cosa = %f, dtw = %f\n", cosa, dtw);
        if (dtw < 5) // if (cosa >= 0.88f)
        {
            it->hit++;
            printf("matched!\n");
            return true;
        }
        ++it;
    }
    printf("not matched!\n");
    return false;
}

void FishingSoundListener::LoadSamples()
{
    ifstream file(SAMPLE_FILE, ios::in);
    if (file.is_open())
    {
        char buf[10240] = { 0 };
        int hit = 0;
        while (file.getline(buf, sizeof(buf)))
        {
            if (buf[0] == '\0')
                continue;
            if (buf[0] == '#')
            {
                if (strncmp(buf, CFG_HIT, strlen(CFG_HIT)) == 0)
                {
                    hit = atoi(buf + strlen(CFG_HIT));
                }
                continue;
            }
            AddSample(buf, hit);
        }
        file.close();
    }

    SaveSamples();
}

void FishingSoundListener::SaveSamples()
{
    SortSamples();
    ofstream file(SAMPLE_FILE, ios::trunc | ios::out);
    if (file.is_open())
    {
        auto it = m_samples.begin();
        while (it != m_samples.end())
        {
            //if (it->hit > 0)
            {
                SaveSample(it->sample, it->hit, file);
            }
            ++it;
        }
        file.close();
    }
}

void FishingSoundListener::SaveSample(const std::vector<float>& sample, int hit, std::ofstream& file)
{
    file << "#size = " << sample.size() << endl;
    file << CFG_HIT << hit << endl;
    file.precision(3);
    bool isFirst = true;
    auto it = sample.cbegin();
    while (it != sample.cend())
    {
        if (!isFirst)
            file << ",";
        else
            isFirst = false;
        file << *it++;
    }
    file << endl << endl;
}

void FishingSoundListener::SortSamples()
{
    m_samples.sort([](SampleInfo a, SampleInfo b) {
        return a.hit > b.hit;
    });
}

```

`WowFisher/FishingSoundListener.h`:

```h
#pragma once
#include "Win32Util/Audio/Extend/AudioExtractor.h"
#include "CommUtil/DTW.hpp"
#include <vector>
#include <list>
#include <fstream>

class Fisher;
class AudioFingerprint;

class FishingSoundListener :
    public AudioExtractor
{
    struct SampleInfo
    {
        std::vector<float> sample;
        int hit;
    };

public:
    FishingSoundListener(Fisher* pFisher);
    virtual ~FishingSoundListener();

    virtual int Init();

    virtual HRESULT SetFormat(WAVEFORMATEX* pwfx);
    virtual bool IsDone() const;

    void SetAmpL(float ampL);
    void SetAmpH(float ampH);

    void Save();

protected:
    virtual void EndSegment();

    void AddSample(const char* str, int hit = 0);
    void SaveSample(const std::vector<float>& sample, int hit, std::ofstream& file);
    void LoadSamples();
    void SaveSamples();
    void SortSamples();
    bool IsSampleMatch(const std::vector<float>& data);

private:
    const WAVEFORMATEX* m_pwfx;
    Fisher* m_pFisher;
    AudioFingerprint* m_pAudioFingerprint;
    std::ofstream m_sampleFile;

    DTW<float> m_dtw;
    std::list<SampleInfo> m_samples;
    int m_sampleCount;
};


```

`WowFisher/WowFisher.cpp`:

```cpp

// WowFisher.cpp : 定义应用程序的类行为。
//

#include "stdafx.h"
#include "WowFisher.h"
#include "WowFisherDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CWowFisherApp

BEGIN_MESSAGE_MAP(CWowFisherApp, CWinApp)
    ON_COMMAND(ID_HELP, &CWinApp::OnHelp)
END_MESSAGE_MAP()


// CWowFisherApp 构造

CWowFisherApp::CWowFisherApp()
{
    // 支持重新启动管理器
    m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;

    // TODO:  在此处添加构造代码，
    // 将所有重要的初始化放置在 InitInstance 中
}


// 唯一的一个 CWowFisherApp 对象

CWowFisherApp theApp;


// CWowFisherApp 初始化

BOOL CWowFisherApp::InitInstance()
{
    //_CrtSetBreakAlloc(3165);

    // 如果一个运行在 Windows XP 上的应用程序清单指定要
    // 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，
    //则需要 InitCommonControlsEx()。  否则，将无法创建窗口。
    INITCOMMONCONTROLSEX InitCtrls;
    InitCtrls.dwSize = sizeof(InitCtrls);
    // 将它设置为包括所有要在应用程序中使用的
    // 公共控件类。
    InitCtrls.dwICC = ICC_WIN95_CLASSES;
    InitCommonControlsEx(&InitCtrls);

    CWinApp::InitInstance();


    AfxEnableControlContainer();

    // 创建 shell 管理器，以防对话框包含
    // 任何 shell 树视图控件或 shell 列表视图控件。
    CShellManager *pShellManager = new CShellManager;

    // 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题
    CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));

    // 标准初始化
    // 如果未使用这些功能并希望减小
    // 最终可执行文件的大小，则应移除下列
    // 不需要的特定初始化例程
    // 更改用于存储设置的注册表项
    // TODO:  应适当修改该字符串，
    // 例如修改为公司或组织名
    SetRegistryKey(_T("应用程序向导生成的本地应用程序"));

    CWowFisherDlg dlg;
    m_pMainWnd = &dlg;
    INT_PTR nResponse = dlg.DoModal();
    if (nResponse == IDOK)
    {
        // TODO:  在此放置处理何时用
        //  “确定”来关闭对话框的代码
    }
    else if (nResponse == IDCANCEL)
    {
        // TODO:  在此放置处理何时用
        //  “取消”来关闭对话框的代码
    }
    else if (nResponse == -1)
    {
        TRACE(traceAppMsg, 0, "警告: 对话框创建失败，应用程序将意外终止。\n");
        TRACE(traceAppMsg, 0, "警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\n");
    }

    // 删除上面创建的 shell 管理器。
    if (pShellManager != NULL)
    {
        delete pShellManager;
    }

    // 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序，
    //  而不是启动应用程序的消息泵。
    return FALSE;
}


```

`WowFisher/WowFisher.h`:

```h

// WowFisher.h : PROJECT_NAME 应用程序的主头文件
//

#pragma once

#ifndef __AFXWIN_H__
#error "在包含此文件之前包含“stdafx.h”以生成 PCH 文件"
#endif

#include "resource.h"		// 主符号


// CWowFisherApp: 
// 有关此类的实现，请参阅 WowFisher.cpp
//

class CWowFisherApp : public CWinApp
{
public:
    CWowFisherApp();

    // 重写
public:
    virtual BOOL InitInstance();

    // 实现

    DECLARE_MESSAGE_MAP()
};

extern CWowFisherApp theApp;
```

`WowFisher/WowFisher.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#ifndef APSTUDIO_INVOKED
#include "targetver.h"
#endif
#include "afxres.h"
#include "verrsrc.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Chinese (Simplified, PRC) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#ifndef APSTUDIO_INVOKED\r\n"
    "#include ""targetver.h""\r\n"
    "#endif\r\n"
    "#include ""afxres.h""\r\n"
    "#include ""verrsrc.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "#define _AFX_NO_SPLITTER_RESOURCES\r\n"
    "#define _AFX_NO_OLE_RESOURCES\r\n"
    "#define _AFX_NO_TRACKER_RESOURCES\r\n"
    "#define _AFX_NO_PROPERTY_RESOURCES\r\n"
    "\r\n"
    "#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)\r\n"
    "LANGUAGE 4, 2\r\n"
    "#include ""res\\WowFisher.rc2""  // 非 Microsoft Visual C++ 编辑的资源\r\n"
    "#include ""l.CHS\\afxres.rc""      // 标准组件\r\n"
    "#if !defined(_AFXDLL)\r\n"
    "#include ""l.CHS\\afxribbon.rc""   // MFC 功能区和控制条资源\r\n"
    "#endif\r\n"
    "#endif\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDR_MAINFRAME           ICON                    "res\\WowFisher.ico"

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ABOUTBOX DIALOGEX 0, 0, 170, 62
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "关于 WowFisher"
FONT 9, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    ICON            IDR_MAINFRAME,IDC_STATIC,14,14,20,20
    LTEXT           "WowFisher，1.0 版",IDC_STATIC,42,14,114,8,SS_NOPREFIX
    LTEXT           "Copyright (C) 2015 freeyxm",IDC_STATIC,42,26,114,8
    DEFPUSHBUTTON   "确定",IDOK,113,41,50,14,WS_GROUP
END

IDD_WOWFISHER_DIALOG DIALOGEX 0, 0, 280, 213
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
EXSTYLE WS_EX_APPWINDOW
CAPTION "WowFisher"
FONT 9, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    DEFPUSHBUTTON   "保存",IDOK,115,182,50,14
    COMBOBOX        IDC_COMBO1,7,15,48,30,CBS_DROPDOWN | CBS_SORT | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON      "刷新",IDC_BUTTON_REFRESH,60,14,32,14
    PUSHBUTTON      "开始",IDC_BUTTON_START,100,14,32,14
    CONTROL         "",IDC_SLIDER_AMP_L,"msctls_trackbar32",TBS_BOTH | TBS_NOTICKS | WS_TABSTOP,35,42,100,15
    LTEXT           "AMP L",IDC_STATIC,14,46,20,8
    LTEXT           "10.00/10.00",IDC_TXT_AMP_L,138,46,40,8
    CONTROL         "",IDC_SLIDER_AMP_H,"msctls_trackbar32",TBS_BOTH | TBS_NOTICKS | WS_TABSTOP,35,64,100,15
    LTEXT           "AMP H",IDC_STATIC,14,66,22,8
    LTEXT           "10.00/10.00",IDC_TXT_AMP_H,138,66,40,8
    GROUPBOX        "按键设置",IDC_STATIC,7,86,129,95
    CONTROL         "",IDC_HOTKEY_FISHING,"msctls_hotkey32",WS_BORDER | WS_TABSTOP,40,100,80,14
    CONTROL         "",IDC_HOTKEY_BAIT_1,"msctls_hotkey32",WS_BORDER | WS_TABSTOP,40,120,80,14
    CONTROL         "",IDC_HOTKEY_BAIT_2,"msctls_hotkey32",WS_BORDER | WS_TABSTOP,40,140,80,14
    CONTROL         "",IDC_HOTKEY_BAIT_3,"msctls_hotkey32",WS_BORDER | WS_TABSTOP,40,160,80,14
    CTEXT           "钓鱼",IDC_STATIC,15,102,15,8
    CTEXT           "鱼饵1",IDC_STATIC,15,124,19,8
    CTEXT           "鱼饵2",IDC_STATIC,15,144,19,8
    CTEXT           "鱼饵3",IDC_STATIC,15,164,19,8
    LTEXT           "状态",IDC_STATIC_STATUS,7,198,155,8
    GROUPBOX        "AMP",IDC_STATIC,7,36,266,44
    GROUPBOX        "统计",IDC_STATIC,191,86,82,95
    LTEXT           "甩竿：",IDC_STATIC,196,102,22,8
    LTEXT           "99999",IDC_STATIC_THROW,220,102,20,8
    LTEXT           "超时：",IDC_STATIC,196,116,22,8
    LTEXT           "0",IDC_STATIC_TIMEOUT,220,116,20,8
    LTEXT           "浮漂：",IDC_STATIC,196,130,22,8
    LTEXT           "0",IDC_STATIC_FLOAT,220,130,20,8
    PUSHBUTTON      "重置",IDC_BUTTON_RESET,217,150,38,14
    LTEXT           "静音最长帧",IDC_STATIC,191,46,35,8
    LTEXT           "声音最短帧",IDC_STATIC,191,66,35,8
    EDITTEXT        IDC_EDIT_SILENT_MIN,230,44,30,14,ES_AUTOHSCROLL
    EDITTEXT        IDC_EDIT_SOUND_MAX,230,63,30,14,ES_AUTOHSCROLL
    CONTROL         "控制台",IDC_CHECK_CONSOLE,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,141,91,37,10
END


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "080404B0"
        BEGIN
            VALUE "CompanyName", "TODO:  <公司名>"
            VALUE "FileDescription", "WowFisher"
            VALUE "FileVersion", "1.0.0.1"
            VALUE "InternalName", "WowFisher.exe"
            VALUE "LegalCopyright", "TODO:  (C) <公司名>。  保留所有权利。"
            VALUE "OriginalFilename", "WowFisher.exe"
            VALUE "ProductName", "TODO:  <产品名>"
            VALUE "ProductVersion", "1.0.0.1"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x804, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 163
        TOPMARGIN, 7
        BOTTOMMARGIN, 55
    END

    IDD_WOWFISHER_DIALOG, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 273
        TOPMARGIN, 7
        BOTTOMMARGIN, 206
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
    IDS_ABOUTBOX            "关于 WowFisher(&A)..."
    IDS_START               "开始"
    IDS_STOP                "停止"
END

#endif    // Chinese (Simplified, PRC) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define _AFX_NO_SPLITTER_RESOURCES
#define _AFX_NO_OLE_RESOURCES
#define _AFX_NO_TRACKER_RESOURCES
#define _AFX_NO_PROPERTY_RESOURCES

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE 4, 2
#include "res\WowFisher.rc2"  // 非 Microsoft Visual C++ 编辑的资源
#include "l.CHS\afxres.rc"      // 标准组件
#if !defined(_AFXDLL)
#include "l.CHS\afxribbon.rc"   // MFC 功能区和控制条资源
#endif
#endif

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`WowFisher/WowFisher.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{4F30B56B-0430-4752-9A62-C191BF675B86}</ProjectGuid>
    <RootNamespace>WowFisher</RootNamespace>
    <Keyword>MFCProj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;_AFXDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>CommUtil.lib;Win32Util.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
    <PostBuildEvent>
      <Command>copy $(SolutionDir)Libs\$(Platform)\$(Configuration)\Intercepter.dll bin\$(Platform)\$(Configuration)\</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;_AFXDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>CommUtil.lib;Win32Util.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
    <PostBuildEvent>
      <Command>copy $(SolutionDir)Libs\$(Platform)\$(Configuration)\Intercepter.dll bin\$(Platform)\$(Configuration)\</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;_AFXDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>CommUtil.lib;Win32Util.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
    <PostBuildEvent>
      <Command>copy $(SolutionDir)Libs\$(Platform)\$(Configuration)\Intercepter.dll bin\$(Platform)\$(Configuration)\</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;_AFXDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>CommUtil.lib;Win32Util.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
    <PostBuildEvent>
      <Command>copy $(SolutionDir)Libs\$(Platform)\$(Configuration)\Intercepter.dll bin\$(Platform)\$(Configuration)\</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Fisher.h" />
    <ClInclude Include="FisherConfig.h" />
    <ClInclude Include="FisherStateBait.h" />
    <ClInclude Include="FisherStateBase.h" />
    <ClInclude Include="FisherStateCheckBait.h" />
    <ClInclude Include="FisherStateDefine.h" />
    <ClInclude Include="FisherStateFindFloat.h" />
    <ClInclude Include="FisherStateJump.h" />
    <ClInclude Include="FisherStateMachine.h" />
    <ClInclude Include="FisherStateShaduf.h" />
    <ClInclude Include="FisherStateThrowPole.h" />
    <ClInclude Include="FisherStateWaitBite.h" />
    <ClInclude Include="FisherStateWaitFloatHide.h" />
    <ClInclude Include="FishingSoundListener.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="WowFisher.h" />
    <ClInclude Include="WowFisherDlg.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Fisher.cpp" />
    <ClCompile Include="FisherConfig.cpp" />
    <ClCompile Include="FisherStateBait.cpp" />
    <ClCompile Include="FisherStateBase.cpp" />
    <ClCompile Include="FisherStateCheckBait.cpp" />
    <ClCompile Include="FisherStateFindFloat.cpp" />
    <ClCompile Include="FisherStateJump.cpp" />
    <ClCompile Include="FisherStateMachine.cpp" />
    <ClCompile Include="FisherStateShaduf.cpp" />
    <ClCompile Include="FisherStateThrowPole.cpp" />
    <ClCompile Include="FisherStateWaitBite.cpp" />
    <ClCompile Include="FisherStateWaitFloatHide.cpp" />
    <ClCompile Include="FishingSoundListener.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="WowFisher.cpp" />
    <ClCompile Include="WowFisherDlg.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="WowFisher.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="res\WowFisher.rc2" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\WowFisher.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
  <ProjectExtensions>
    <VisualStudio>
      <UserProperties RESOURCE_FILE="WowFisher.rc" />
    </VisualStudio>
  </ProjectExtensions>
</Project>
```

`WowFisher/WowFisher.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="StateMachine">
      <UniqueIdentifier>{4b4c42ad-b88c-41a4-8f23-b15c4f5c567f}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="WowFisher.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="WowFisherDlg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Fisher.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="FishingSoundListener.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="FisherStateMachine.h">
      <Filter>StateMachine</Filter>
    </ClInclude>
    <ClInclude Include="FisherStateBase.h">
      <Filter>StateMachine</Filter>
    </ClInclude>
    <ClInclude Include="FisherStateBait.h">
      <Filter>StateMachine</Filter>
    </ClInclude>
    <ClInclude Include="FisherStateCheckBait.h">
      <Filter>StateMachine</Filter>
    </ClInclude>
    <ClInclude Include="FisherStateThrowPole.h">
      <Filter>StateMachine</Filter>
    </ClInclude>
    <ClInclude Include="FisherStateFindFloat.h">
      <Filter>StateMachine</Filter>
    </ClInclude>
    <ClInclude Include="FisherStateShaduf.h">
      <Filter>StateMachine</Filter>
    </ClInclude>
    <ClInclude Include="FisherStateWaitBite.h">
      <Filter>StateMachine</Filter>
    </ClInclude>
    <ClInclude Include="FisherStateWaitFloatHide.h">
      <Filter>StateMachine</Filter>
    </ClInclude>
    <ClInclude Include="FisherStateDefine.h">
      <Filter>StateMachine</Filter>
    </ClInclude>
    <ClInclude Include="FisherStateJump.h">
      <Filter>StateMachine</Filter>
    </ClInclude>
    <ClInclude Include="FisherConfig.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="WowFisher.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="WowFisherDlg.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Fisher.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="FishingSoundListener.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="FisherStateMachine.cpp">
      <Filter>StateMachine</Filter>
    </ClCompile>
    <ClCompile Include="FisherStateBase.cpp">
      <Filter>StateMachine</Filter>
    </ClCompile>
    <ClCompile Include="FisherStateBait.cpp">
      <Filter>StateMachine</Filter>
    </ClCompile>
    <ClCompile Include="FisherStateCheckBait.cpp">
      <Filter>StateMachine</Filter>
    </ClCompile>
    <ClCompile Include="FisherStateThrowPole.cpp">
      <Filter>StateMachine</Filter>
    </ClCompile>
    <ClCompile Include="FisherStateFindFloat.cpp">
      <Filter>StateMachine</Filter>
    </ClCompile>
    <ClCompile Include="FisherStateShaduf.cpp">
      <Filter>StateMachine</Filter>
    </ClCompile>
    <ClCompile Include="FisherStateWaitBite.cpp">
      <Filter>StateMachine</Filter>
    </ClCompile>
    <ClCompile Include="FisherStateWaitFloatHide.cpp">
      <Filter>StateMachine</Filter>
    </ClCompile>
    <ClCompile Include="FisherStateJump.cpp">
      <Filter>StateMachine</Filter>
    </ClCompile>
    <ClCompile Include="FisherConfig.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="WowFisher.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="res\WowFisher.rc2">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\WowFisher.ico">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`WowFisher/WowFisherDlg.cpp`:

```cpp

// WowFisherDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "WowFisher.h"
#include "WowFisherDlg.h"
#include "afxdialogex.h"
#include "Resource.h"
#include <exception>
#include <cstdio>
#include <locale.h>
#include "CommUtil/CommUtil.hpp"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define CONFIG_FILE L".//config/Fisher.ini"

// 用于应用程序“关于”菜单项的 CAboutDlg 对话框

class CAboutDlg : public CDialogEx
{
public:
    CAboutDlg();

    // 对话框数据
    enum { IDD = IDD_ABOUTBOX };

protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

// 实现
protected:
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialogEx(CAboutDlg::IDD)
{
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()


// CWowFisherDlg 对话框



CWowFisherDlg::CWowFisherDlg(CWnd* pParent /*=NULL*/)
    : CDialogEx(CWowFisherDlg::IDD, pParent)
    , m_pComboBox(NULL)
    , m_pBtnRefresh(NULL)
    , m_pBtnStart(NULL)
    , m_pSliderAmpL(NULL)
    , m_pSliderAmpH(NULL)
    , m_pTxtAmpL(NULL)
    , m_pTxtAmpH(NULL)
    , m_pTxtStatus(NULL)
    , m_pTxtThrowCount(NULL)
    , m_pTxtTimeoutCount(NULL)
    , m_pTxtFloatCount(NULL)
    , m_pHotKeyFishing(NULL)
    , m_pHotKeyBite1(NULL)
    , m_pHotKeyBite2(NULL)
    , m_pHotKeyBite3(NULL)
    , m_pEditSilentMax(NULL)
    , m_pEditSoundMin(NULL)
    , m_pCbConsole(NULL)
    , m_bStart(false)
    , m_pFisher(NULL)
    , m_config(CONFIG_FILE)
{
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

CWowFisherDlg::~CWowFisherDlg()
{
    SAFE_DELETE(m_pFisher);
}

void CWowFisherDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CWowFisherDlg, CDialogEx)
    ON_WM_SYSCOMMAND()
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_WM_DESTROY()
    ON_MESSAGE(WMU_UPDATE_STATISTICS, &CWowFisherDlg::OnUpdateStatistics)
    ON_MESSAGE(WMU_UPDATE_STATUS, &CWowFisherDlg::OnUpdateStatus)
    ON_CBN_SELCHANGE(IDC_COMBO1, &CWowFisherDlg::OnCbnSelchangeCombo1)
    ON_NOTIFY(NM_CUSTOMDRAW, IDC_SLIDER_AMP_L, &CWowFisherDlg::OnNMCustomdrawSliderAmpL)
    ON_NOTIFY(NM_CUSTOMDRAW, IDC_SLIDER_AMP_H, &CWowFisherDlg::OnNMCustomdrawSliderAmpH)
    ON_BN_CLICKED(IDC_BUTTON_REFRESH, &CWowFisherDlg::OnBnClickedButtonRefresh)
    ON_BN_CLICKED(IDC_BUTTON_START, &CWowFisherDlg::OnBnClickedButtonStart)
    ON_BN_CLICKED(IDOK, &CWowFisherDlg::OnBnClickedOk)
    ON_BN_CLICKED(IDC_BUTTON_RESET, &CWowFisherDlg::OnBnClickedButtonReset)
    ON_BN_CLICKED(IDC_CHECK_CONSOLE, &CWowFisherDlg::OnBnClickedCheckConsole)
END_MESSAGE_MAP()


// CWowFisherDlg 消息处理程序

BOOL CWowFisherDlg::OnInitDialog()
{
    CDialogEx::OnInitDialog();

    // 将“关于...”菜单项添加到系统菜单中。

    // IDM_ABOUTBOX 必须在系统命令范围内。
    ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
    ASSERT(IDM_ABOUTBOX < 0xF000);

    CMenu* pSysMenu = GetSystemMenu(FALSE);
    if (pSysMenu != NULL)
    {
        BOOL bNameValid;
        CString strAboutMenu;
        bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
        ASSERT(bNameValid);
        if (!strAboutMenu.IsEmpty())
        {
            pSysMenu->AppendMenu(MF_SEPARATOR);
            pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
        }
    }

    // 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动
    //  执行此操作
    SetIcon(m_hIcon, TRUE);			// 设置大图标
    SetIcon(m_hIcon, FALSE);		// 设置小图标

    // TODO:  在此添加额外的初始化代码
    Init();

    return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE
}

void CWowFisherDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
    if ((nID & 0xFFF0) == IDM_ABOUTBOX)
    {
        CAboutDlg dlgAbout;
        dlgAbout.DoModal();
    }
    else
    {
        CDialogEx::OnSysCommand(nID, lParam);
    }
}

// 如果向对话框添加最小化按钮，则需要下面的代码
//  来绘制该图标。  对于使用文档/视图模型的 MFC 应用程序，
//  这将由框架自动完成。

void CWowFisherDlg::OnPaint()
{
    if (IsIconic())
    {
        CPaintDC dc(this); // 用于绘制的设备上下文

        SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

        // 使图标在工作区矩形中居中
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // 绘制图标
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CDialogEx::OnPaint();
    }
}

//当用户拖动最小化窗口时系统调用此函数取得光标
//显示。
HCURSOR CWowFisherDlg::OnQueryDragIcon()
{
    return static_cast<HCURSOR>(m_hIcon);
}

afx_msg void CWowFisherDlg::OnDestroy()
{
    SaveConfig();
}

bool CWowFisherDlg::LoadConfig()
{
    return m_config.LoadConfig();
}

void CWowFisherDlg::SaveConfig()
{
    m_config.m_hotkeyThrow = m_pHotKeyFishing->GetHotKey();
    m_config.m_hotkeyBite1 = m_pHotKeyBite1->GetHotKey();
    m_config.m_hotkeyBite2 = m_pHotKeyBite2->GetHotKey();
    m_config.m_hotkeyBite3 = m_pHotKeyBite3->GetHotKey();

    CString str;
    m_pEditSilentMax->GetWindowTextW(str);
    m_config.m_nSilentMaxCount = _ttoi(str);
    m_pEditSoundMin->GetWindowTextW(str);
    m_config.m_nSoundMinCount = _ttoi(str);

    m_config.m_bShowConsole = m_pCbConsole->GetCheck();

    m_config.SaveConfig();
}

void CWowFisherDlg::ApplyConfig()
{
    UpdateAmpMax(m_config.m_nAmpMax);

    m_pHotKeyFishing->SetHotKey(m_config.m_hotkeyThrow & 0xff, (m_config.m_hotkeyThrow >> 8) & 0xff);
    m_pHotKeyBite1->SetHotKey(m_config.m_hotkeyBite1 & 0xff, (m_config.m_hotkeyBite1 >> 8) & 0xff);
    m_pHotKeyBite2->SetHotKey(m_config.m_hotkeyBite2 & 0xff, (m_config.m_hotkeyBite2 >> 8) & 0xff);
    m_pHotKeyBite3->SetHotKey(m_config.m_hotkeyBite3 & 0xff, (m_config.m_hotkeyBite3 >> 8) & 0xff);

    CString str;
    str.Format(L"%d", m_config.m_nSilentMaxCount);
    m_pEditSilentMax->SetWindowTextW(str);
    str.Format(L"%d", m_config.m_nSoundMinCount);
    m_pEditSoundMin->SetWindowTextW(str);

    m_pCbConsole->SetCheck(m_config.m_bShowConsole);

    if (m_pFisher != NULL)
    {
        m_pFisher->SetAmpL(m_config.m_nAmpL / 100.0f);
        m_pFisher->SetAmpH(m_config.m_nAmpH / 100.0f);
        m_pFisher->SetSilentMax(m_config.m_nSilentMaxCount);
        m_pFisher->SetSoundMin(m_config.m_nSoundMinCount);
        m_pFisher->SetHotkeyThrow(m_config.m_hotkeyThrow);
        m_pFisher->SetHotkeyBite1(m_config.m_hotkeyBite1);
        m_pFisher->SetHotkeyBite2(m_config.m_hotkeyBite2);
        m_pFisher->SetHotkeyBite3(m_config.m_hotkeyBite3);
        m_pFisher->SetThrowCount(m_config.m_nThrowCount);
        m_pFisher->SetTimeoutCount(m_config.m_nTimeoutCount);
        m_pFisher->SetFindFloatFailCount(m_config.m_nFloatCount);
    }
}

bool CWowFisherDlg::InitComponents()
{
    m_pComboBox = (CComboBox*)GetDlgItem(IDC_COMBO1);
    m_pBtnRefresh = (CButton*)GetDlgItem(IDC_BUTTON_REFRESH);
    m_pBtnStart = (CButton*)GetDlgItem(IDC_BUTTON_START);
    m_pSliderAmpL = (CSliderCtrl*)GetDlgItem(IDC_SLIDER_AMP_L);
    m_pSliderAmpH = (CSliderCtrl*)GetDlgItem(IDC_SLIDER_AMP_H);
    m_pTxtAmpL = (CStatic*)GetDlgItem(IDC_TXT_AMP_L);
    m_pTxtAmpH = (CStatic*)GetDlgItem(IDC_TXT_AMP_H);
    m_pTxtStatus = (CStatic*)GetDlgItem(IDC_STATIC_STATUS);
    m_pTxtThrowCount = (CStatic*)GetDlgItem(IDC_STATIC_THROW);
    m_pTxtTimeoutCount = (CStatic*)GetDlgItem(IDC_STATIC_TIMEOUT);
    m_pTxtFloatCount = (CStatic*)GetDlgItem(IDC_STATIC_FLOAT);
    m_pHotKeyFishing = (CHotKeyCtrl*)GetDlgItem(IDC_HOTKEY_FISHING);
    m_pHotKeyBite1 = (CHotKeyCtrl*)GetDlgItem(IDC_HOTKEY_BAIT_1);
    m_pHotKeyBite2 = (CHotKeyCtrl*)GetDlgItem(IDC_HOTKEY_BAIT_2);
    m_pHotKeyBite3 = (CHotKeyCtrl*)GetDlgItem(IDC_HOTKEY_BAIT_3);
    m_pEditSilentMax = (CEdit*)GetDlgItem(IDC_EDIT_SILENT_MIN);
    m_pEditSoundMin = (CEdit*)GetDlgItem(IDC_EDIT_SOUND_MAX);
    m_pCbConsole = (CButton*)GetDlgItem(IDC_CHECK_CONSOLE);

    m_pBtnStart->EnableWindow(FALSE);

    return true;
}

bool CWowFisherDlg::Init()
{
    int ret = ::CoInitialize(NULL);
    if (ret != 0)
    {
        return false;
    }

    LoadConfig();
    InitComponents();

    int x = 200, y = 20;
    int w = 600, h = 400;
    m_pFisher = new Fisher(NULL, x, y, w, h);
    if (m_pFisher == NULL)
    {
        MessageBox(L"Fisher new failed");
        return false;
    }

    if (!m_pFisher->Init())
    {
        MessageBox(L"Fisher init failed");
        return false;
    }

    if (m_config.m_bShowConsole != 0)
    {
        OpenConsole();
    }

    ApplyConfig();
    OnUpdateStatistics(0, 0);

    return true;
}

void CWowFisherDlg::FindWindows()
{
    m_wnds.clear();
    m_pComboBox->ResetContent();

    HWND hwnd = NULL;
    DWORD pid;
    do
    {
        hwnd = ::FindWindowEx(NULL, hwnd, NULL, L"魔兽世界");
        if (hwnd != NULL)
        {
            DWORD tid = ::GetWindowThreadProcessId(hwnd, &pid);
            if (tid == 0)
            {
                printf("GetWindowThreadProcessId faield.\n");
                continue;
            }
            else
            {
                WndInfo info;
                info.hwnd = hwnd;
                info.pid = pid;
                m_wnds.push_back(info);

                CString str;
                str.Format(L"%d", pid);
                m_pComboBox->AddString(str);
            }
        }
    } while (hwnd != NULL);

    if (m_pComboBox->GetCount() > 0)
    {
        m_pComboBox->SetCurSel(0);
    }
    OnCbnSelchangeCombo1();
}

void CWowFisherDlg::UpdateAmpMax(int max)
{
    m_pSliderAmpL->SetRange(0, max * 100);
    m_pSliderAmpH->SetRange(0, max * 100);
    m_pSliderAmpL->SetPos(m_config.m_nAmpL * max / m_config.m_nAmpMax);
    m_pSliderAmpH->SetPos(m_config.m_nAmpH * max / m_config.m_nAmpMax);

    m_config.m_nAmpMax = max;

    UpdateAmpText(m_pTxtAmpL, m_config.m_nAmpL, m_pSliderAmpL->GetRangeMax());
    UpdateAmpText(m_pTxtAmpH, m_config.m_nAmpH, m_pSliderAmpH->GetRangeMax());
}

void CWowFisherDlg::UpdateAmpText(CStatic* pStatic, int value, int max)
{
    CString str;
    str.Format(L"%.2lf/%.2lf", (double)value * m_config.m_nAmpMax / max, (double)m_config.m_nAmpMax);
    pStatic->SetWindowTextW(str);
}

void CWowFisherDlg::OpenConsole()
{
    ::setlocale(LC_CTYPE, "");
    if (::AllocConsole())
    {
        FILE* file;
        if (::freopen_s(&file, "CONOUT$", "w", stdout) == 0 && file)
        {
            *stdout = *file;
        }
        if (::freopen_s(&file, "CONIN$", "r", stdin) == 0 && file)
        {
            *stdin = *file;
        }
    }
}

void CWowFisherDlg::CloseConsole()
{
    ::FreeConsole();
}

LRESULT CWowFisherDlg::OnUpdateStatistics(WPARAM wParam, LPARAM lParam)
{
    if (m_pFisher != NULL)
    {
        m_config.m_nThrowCount = m_pFisher->GetThrowCount();
        m_config.m_nTimeoutCount = m_pFisher->GetTimeoutCount();
        m_config.m_nFloatCount = m_pFisher->GetFindFloatFailCount();
    }

    CString str;
    str.Format(L"%d", m_config.m_nThrowCount);
    m_pTxtThrowCount->SetWindowTextW(str);

    str.Format(L"%d", m_config.m_nTimeoutCount);
    m_pTxtTimeoutCount->SetWindowTextW(str);

    str.Format(L"%d", m_config.m_nFloatCount);
    m_pTxtFloatCount->SetWindowTextW(str);

    return 0;
}

LRESULT CWowFisherDlg::OnUpdateStatus(WPARAM wParam, LPARAM lParam)
{
    LPCWSTR msg = (LPCWSTR)wParam;
    m_pTxtStatus->SetWindowTextW(msg);

    return 0;
}

void CWowFisherDlg::OnCbnSelchangeCombo1()
{
    int index = m_pComboBox->GetCurSel();
    m_pBtnStart->EnableWindow(index != CB_ERR);
}

void CWowFisherDlg::OnBnClickedButtonRefresh()
{
    FindWindows();
}

void CWowFisherDlg::OnBnClickedButtonStart()
{
    static CString txtStart, txtStop;
    if (txtStart.IsEmpty())
    {
        bool res = txtStart.LoadStringW(IDS_START);
        if (!res) txtStart = "start";
    }
    if (txtStop.IsEmpty())
    {
        bool res = txtStop.LoadStringW(IDS_STOP);
        if (!res) txtStop = "stop";
    }

    m_bStart = !m_bStart;
    m_pBtnStart->SetWindowTextW(m_bStart ? txtStop : txtStart);
    m_pBtnRefresh->EnableWindow(!m_bStart);
    m_pComboBox->EnableWindow(!m_bStart);

    if (m_bStart)
    {
        int index = m_pComboBox->GetCurSel();
        if (index >= 0 && index < (int)m_wnds.size())
        {
            std::list<WndInfo>::iterator it = m_wnds.begin();
            for (int i = 0; i < index; ++i)
            {
                ++it;
            }
            if (m_pFisher != NULL)
            {
                m_pFisher->SetMainHWnd(GetSafeHwnd());
                m_pFisher->SetWowHWnd(it->hwnd);
                m_pFisher->Start();
            }
        }
    }
    else
    {
        if (m_pFisher != NULL)
        {
            m_pFisher->Stop();
            m_pTxtStatus->SetWindowTextW(L"");
        }
    }
}

void CWowFisherDlg::OnNMCustomdrawSliderAmpL(NMHDR* pNMHDR, LRESULT* pResult)
{
    LPNMCUSTOMDRAW pNMCD = reinterpret_cast<LPNMCUSTOMDRAW>(pNMHDR);
    // TODO: Add your control notification handler code here

    int pos = m_pSliderAmpL->GetPos();
    if (pos != m_config.m_nAmpL)
    {
        //if (pos > m_nAmpH)
        //{
        //	m_pSliderAmpL->SetPos(m_nAmpH);
        //}
        //else
        {
            m_config.m_nAmpL = pos;
            UpdateAmpText(m_pTxtAmpL, m_config.m_nAmpL, m_pSliderAmpL->GetRangeMax());
            if (m_pFisher != NULL)
            {
                m_pFisher->SetAmpL(m_config.m_nAmpL * m_config.m_nAmpMax / 100.0f);
            }
        }
    }

    *pResult = 0;
}

void CWowFisherDlg::OnNMCustomdrawSliderAmpH(NMHDR* pNMHDR, LRESULT* pResult)
{
    LPNMCUSTOMDRAW pNMCD = reinterpret_cast<LPNMCUSTOMDRAW>(pNMHDR);
    // TODO: Add your control notification handler code here

    int pos = m_pSliderAmpH->GetPos();
    //if (pos >= m_pSliderAmpH->GetRangeMax() && pos == m_nAmpH)
    //{
    //	UpdateAmpMax(m_nAmpMax * 10);
    //}
    //else if (pos <= m_pSliderAmpH->GetRangeMin() && pos == m_nAmpH)
    //{
    //	UpdateAmpMax(m_nAmpMax / 10);
    //}
    //else 
    if (pos != m_config.m_nAmpH)
    {
        m_config.m_nAmpH = pos;
        UpdateAmpText(m_pTxtAmpH, m_config.m_nAmpH, m_pSliderAmpH->GetRangeMax());
        if (m_pFisher != NULL)
        {
            m_pFisher->SetAmpH((float)m_config.m_nAmpH * m_config.m_nAmpMax / m_pSliderAmpH->GetRangeMax());
        }
    }

    *pResult = 0;
}


void CWowFisherDlg::OnBnClickedOk()
{
    SaveConfig();
    ApplyConfig();
    //CDialogEx::OnOK();
}


void CWowFisherDlg::OnBnClickedButtonReset()
{
    if (m_pFisher != NULL)
    {
        m_config.m_nThrowCount = m_config.m_nFloatCount = m_config.m_nTimeoutCount = 0;
        m_pFisher->SetThrowCount(m_config.m_nThrowCount);
        m_pFisher->SetFindFloatFailCount(m_config.m_nFloatCount);
        m_pFisher->SetTimeoutCount(m_config.m_nTimeoutCount);
    }
    OnUpdateStatistics(0, 0);
}


void CWowFisherDlg::OnBnClickedCheckConsole()
{
    m_config.m_bShowConsole = m_pCbConsole->GetCheck();
    if (m_config.m_bShowConsole == 0)
    {
        CloseConsole();
    }
    else if (m_config.m_bShowConsole == 1)
    {
        OpenConsole();
    }
}

```

`WowFisher/WowFisherDlg.h`:

```h

// WowFisherDlg.h : 头文件
//

#pragma once
#include <list>
#include "resource.h"
#include "Fisher.h"
#include "FisherConfig.h"

#define WMU_UPDATE_STATISTICS (WM_USER + 100)
#define WMU_UPDATE_STATUS     (WM_USER + 101)

// CWowFisherDlg 对话框
class CWowFisherDlg : public CDialogEx
{
    // 构造
public:
    CWowFisherDlg(CWnd* pParent = NULL);	// 标准构造函数
    virtual ~CWowFisherDlg();

    // 对话框数据
    enum { IDD = IDD_WOWFISHER_DIALOG };

protected:
    virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV 支持


// 实现
protected:
    HICON m_hIcon;

    // 生成的消息映射函数
    virtual BOOL OnInitDialog();
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    afx_msg void OnDestroy();
    DECLARE_MESSAGE_MAP()

    bool LoadConfig();
    void SaveConfig();
    void ApplyConfig();

    bool Init();
    bool InitComponents();

    void FindWindows();

    void UpdateAmpMax(int max);
    void UpdateAmpText(CStatic *pStatic, int value, int max);

    LRESULT OnUpdateStatistics(WPARAM wParam, LPARAM lParam);
    LRESULT OnUpdateStatus(WPARAM wParam, LPARAM lParam);

    void OpenConsole();
    void CloseConsole();

protected:
    CComboBox* m_pComboBox;
    CButton* m_pBtnRefresh;
    CButton* m_pBtnStart;
    CSliderCtrl* m_pSliderAmpL;
    CSliderCtrl* m_pSliderAmpH;
    CStatic* m_pTxtAmpL;
    CStatic* m_pTxtAmpH;
    CStatic* m_pTxtStatus;
    CStatic* m_pTxtThrowCount;
    CStatic* m_pTxtTimeoutCount;
    CStatic* m_pTxtFloatCount;
    CHotKeyCtrl* m_pHotKeyFishing;
    CHotKeyCtrl* m_pHotKeyBite1;
    CHotKeyCtrl* m_pHotKeyBite2;
    CHotKeyCtrl* m_pHotKeyBite3;
    CEdit* m_pEditSilentMax;
    CEdit* m_pEditSoundMin;
    CButton* m_pCbConsole;

    bool m_bStart;
    Fisher* m_pFisher;
    FisherConfig m_config;

    struct WndInfo
    {
        HWND hwnd;
        DWORD pid;
    };
    std::list<WndInfo> m_wnds;

public:
    afx_msg void OnCbnSelchangeCombo1();
    afx_msg void OnNMCustomdrawSliderAmpL(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnNMCustomdrawSliderAmpH(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnBnClickedButtonRefresh();
    afx_msg void OnBnClickedButtonStart();
    afx_msg void OnBnClickedOk();
    afx_msg void OnBnClickedButtonReset();
    afx_msg void OnBnClickedCheckConsole();
};

```

`WowFisher/config/Fisher.ini`:

```ini
[Fisher]
AmpMax=10
AmpH=200
AmpL=5
HotkeyThrow=49
HotkeyBite1=0
HotkeyBite2=0
HotkeyBite3=0
SilentMaxCount=10
SoundMinCount=50
ShowConsole=1
ThrowCount=20
TimeoutCount=0
FloatCount=0

```

`WowFisher/res/WowFisher.rc2`:

```rc2
//
// WowFisher.RC2 - Microsoft Visual C++ 不会直接编辑的资源
//

#ifdef APSTUDIO_INVOKED
#error 此文件不能用 Microsoft Visual C++ 编辑
#endif //APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
// 在此处添加手动编辑的资源...

/////////////////////////////////////////////////////////////////////////////

```

`WowFisher/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by WowFisher.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_WOWFISHER_DIALOG            102
#define IDS_START                       102
#define IDS_STRING_STOP                 103
#define IDS_STOP                        103
#define IDR_MAINFRAME                   128
#define IDC_COMBO1                      1000
#define IDC_BUTTON_REFRESH              1001
#define IDC_BUTTON_START                1002
#define IDC_SLIDER_AMP_L                1003
#define IDC_SLIDER_AMP_H                1004
#define IDC_TXT_AMP_H                   1008
#define IDC_TXT_AMP_L                   1009
#define IDC_CHECK1                      1010
#define IDC_CHECK_CONSOLE               1010
#define IDC_CHECK2                      1011
#define IDC_HOTKEY_FISHING              1014
#define IDC_HOTKEY_BAIT_1               1015
#define IDC_HOTKEY_BAIT_2               1016
#define IDC_HOTKEY_BAIT_3               1017
#define IDC_STATIC_STATUS               1018
#define IDC_STATIC_TIMEOUT              1021
#define IDC_STATIC_FLOAT                1022
#define IDC_STATIC_THROW                1023
#define IDC_BUTTON_RESET                1024
#define IDC_EDIT_SILENT_MIN             1025
#define IDC_EDIT_SOUND_MAX              1026
#define IDC_COMBO2                      1027

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1028
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`WowFisher/stdafx.cpp`:

```cpp

// stdafx.cpp : 只包括标准包含文件的源文件
// WowFisher.pch 将作为预编译头
// stdafx.obj 将包含预编译类型信息

#include "stdafx.h"



```

`WowFisher/stdafx.h`:

```h

// stdafx.h : 标准系统包含文件的包含文件，
// 或是经常使用但不常更改的
// 特定于项目的包含文件

#pragma once

#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN            // 从 Windows 头中排除极少使用的资料
#endif

#include "targetver.h"

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS      // 某些 CString 构造函数将是显式的

// 关闭 MFC 对某些常见但经常可放心忽略的警告消息的隐藏
#define _AFX_ALL_WARNINGS

#include <afxwin.h>         // MFC 核心组件和标准组件
#include <afxext.h>         // MFC 扩展


#include <afxdisp.h>        // MFC 自动化类



#ifndef _AFX_NO_OLE_SUPPORT
#include <afxdtctl.h>           // MFC 对 Internet Explorer 4 公共控件的支持
#endif
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>             // MFC 对 Windows 公共控件的支持
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxcontrolbars.h>     // 功能区和控件条的 MFC 支持









#ifdef _UNICODE
#if defined _M_IX86
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\"")
#elif defined _M_X64
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\"")
#else
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
#endif
#endif



```

`WowFisher/targetver.h`:

```h
#pragma once

// 包括 SDKDDKVer.h 将定义最高版本的可用 Windows 平台。

// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将
// WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。

#include <SDKDDKVer.h>

```

`WowNpcScanAlertor/NpcScanAlertor.cpp`:

```cpp
#pragma execution_character_set("utf-8")
#include "stdafx.h"
#include "NpcScanAlertor.h"
#include "Win32Util/Image/ImageUtil.h"
#include "Win32Util/Util/Utility.h"


NpcScanAlertor::NpcScanAlertor(HWND hwnd, AudioRenderer* pAudioPlayer)
    : m_hwnd(hwnd)
    , m_pid(0)
    , m_pAudioPlayer(pAudioPlayer)
    , m_keyboard(hwnd)
    , m_lpBits(NULL)
    , m_bRare(true)
    , m_colorType(0)
    , m_bRunning(false)
    , m_searchTargetTime(0)
    , m_moveTime(0)
    , m_moveLeft(false)
{
	//RECT rect;
	//::GetWindowRect(hwnd, &rect);

	// 头像矩形框
	m_targetRect.left = 280;
	m_targetRect.right = m_targetRect.left + 190;
	m_targetRect.top = 0;
	m_targetRect.bottom = m_targetRect.top + 90;
}


NpcScanAlertor::~NpcScanAlertor()
{
	if (m_lpBits)
	{
		delete[] m_lpBits;
		m_lpBits = NULL;
	}
}

bool NpcScanAlertor::Init()
{
	int w = m_targetRect.right - m_targetRect.left;
	int h = m_targetRect.bottom - m_targetRect.top;
	
	DWORD tid = ::GetWindowThreadProcessId(m_hwnd, &m_pid);
	if (tid == 0)
	{
		printf("GetWindowThreadProcessId faield.\n");
		return false;
	}

	m_lpBits = new char[w * h * 4];
	if (!m_lpBits)
		return false;

	Utility::printf_t("Alerter[%d] \"%s\": Init success.\n", m_pid, m_name.c_str());
	return true;
}

void NpcScanAlertor::Start(int colorType, bool bRare)
{
	m_colorType = colorType;
	m_bRare = bRare;

	Start();
}

void NpcScanAlertor::Start()
{
	m_searchTargetTime = 0;
	m_moveTime = 0;
	m_moveLeft = true;
	m_bRunning = true;
}

void NpcScanAlertor::Stop()
{
	m_bRunning = false;
}

bool NpcScanAlertor::IsRunning() const
{
	return m_bRunning;
}

long NpcScanAlertor::GetPid() const
{
	return m_pid;
}

void NpcScanAlertor::SetName(const char* name)
{
	m_name = name;
}

const char* NpcScanAlertor::GetName() const
{
	return m_name.c_str();
}

void NpcScanAlertor::SetColorType(int colorType)
{
	m_colorType = colorType;
}

int NpcScanAlertor::GetColorType()
{
	return m_colorType;
}

void NpcScanAlertor::SetRare(bool bRare)
{
	m_bRare = bRare;
}

bool NpcScanAlertor::IsRare()
{
	return m_bRare;
}

void NpcScanAlertor::Update(int deltaTime)
{
	if (!m_bRunning)
		return;

	m_searchTargetTime -= deltaTime;
	if (m_searchTargetTime <= 0)
	{
		m_keyboard.PressKey(VK_F9, "A+C");

		if (CheckNpcHeadIcon())
		{
			PlayAlarm();
		}

		m_searchTargetTime = 2000 + ::rand() % 500;
	}

	m_moveTime -= deltaTime;
	if (m_moveTime <= 0)
	{
		// 定时转向，防止掉线
		if (m_moveLeft)
			m_keyboard.PressKey(VK_F7, "A+C"); // 左转
		else
			m_keyboard.PressKey(VK_F8, "A+C"); // 右转
		m_moveLeft = !m_moveLeft;

		m_moveTime = 10000 + ::rand() % 5000; // 10s - 15s
	}
}

void NpcScanAlertor::PlayAlarm()
{
	if (m_pAudioPlayer && m_pAudioPlayer->IsDone())
	{
		m_pAudioPlayer->Start();
	}
}

bool NpcScanAlertor::CheckNpcHeadIcon()
{
	int x = m_targetRect.left;
	int y = m_targetRect.top;
	int w = m_targetRect.right - m_targetRect.left;
	int h = m_targetRect.bottom - m_targetRect.top;

	if (!ImageUtil::GetWindowSnapshot(m_hwnd, x, y, w, h, m_lpBits))
	{
		Utility::printf_t("Alerter[%d] \"%s\" : GetWindowSnapshot failed!\n", m_pid, m_name.c_str());
		Stop();
		return false;
	}

	const int color_yellow = RGB(175, 175, 0); // 中立怪血条颜色 (300, 33)
	const int color_yellow_range = RGB(30, 30, 10);

	const int color_red = RGB(181, 0, 0); // 敌对怪血条颜色 (300, 33)
	const int color_red_range = RGB(20, 10, 10);

	// 根据血条颜色判断是否选中了目标
	int yellow_count = 0, red_count = 0;
	int min_x = 8, max_x = 108, step_x = 2; // 目标头像面板位置
	int ty = 33;
	for (int tx = min_x; tx <= max_x; tx += step_x)
	{
		int color = ImageUtil::GetColor(m_lpBits, w, h, tx, h - ty);
		if (ImageUtil::IsColorAlike(color, color_yellow, color_yellow_range))
			++yellow_count;
		else if(ImageUtil::IsColorAlike(color, color_red, color_red_range))
			++red_count;
	}
	bool hasTarget = max(yellow_count, red_count) * step_x * 1.0f / (max_x - min_x) > 0.4f; // 大于40%颜色符合，判定为已选择目标。
	if (!hasTarget)
	{
		//Utility::printf_t("hasTarget failed\n");
		return false;
	}

	bool isRed = red_count > yellow_count;
	bool isYellow = yellow_count > red_count;
	if (isRed && !(m_colorType & (int)ColorType::Color_Red)
		&& isYellow && !(m_colorType & (int)ColorType::Color_Yellow))
	{
		return false;
	}

	if (m_bRare)
	{
		// 稀有精英，银龙标识采样区域
		RECT rects[] = {
			{ 104, 12, 28, 12 }, // left, top, w, h
			{ 132, 9, 27, 6 },
			{ 170, 28, 12, 30 },
		};
		const int rare_range = 10;
		int total_count = sizeof(rects) / sizeof(RECT);
		int rare_count = 0;
		for (int i = 0; i < total_count; ++i)
		{
			int min_x = rects[i].left;
			int max_x = min_x + rects[i].right;
			int min_y = rects[i].top;
			int max_y = min_y + rects[i].bottom;

			int count = 0;
			for (int x = min_x; x < max_x; ++x)
			{
				for (int y = min_y; y < max_y; ++y)
				{
					int color = ImageUtil::GetColor(m_lpBits, w, h, x, y);
					char r = RGB_R(color);
					char g = RGB_G(color);
					char b = RGB_B(color);
					if (r >= 40 && r <= 90 && abs(r - g) < rare_range && abs(r - b) < rare_range) // 银龙标识为近似灰色
						++count;
				}
			}

			if (count * 1.0f / (rects[i].right * rects[i].bottom) > 0.4f)
			{
				++rare_count;
			}
		}
		if (rare_count <= total_count / 2)
		{
			//Utility::printf_t("isRare failed.\n");
			return false;
		}
	}

	Utility::printf_t("Alerter[%d] \"%s\" : Find target, rare = %d, color = %s\n",
		               m_pid, m_name.c_str(), m_bRare, isRed ? "red" : "yellow");
	return true;
}

```

`WowNpcScanAlertor/NpcScanAlertor.h`:

```h
#pragma once
#pragma execution_character_set("utf-8")
#include "Win32Util/Audio/Extend/AudioRenderer.h"
#include "Win32Util/Keyboard/KeyboardBackground.h"
#include <string>

class NpcScanAlertor
{
public:
    enum class ColorType
    {
        Color_Red = 0x01,
        Color_Yellow = 0x02,
    };

public:
    NpcScanAlertor(HWND hwnd, AudioRenderer *pAudioPlayer);
    ~NpcScanAlertor();

    bool Init();
    void Start(int colorType, bool bRare);
    void Start();
    void Stop();
    void Update(int deltaTime);

    bool IsRunning() const;

    long GetPid() const;

    void SetName(const char* name);
    const char* GetName() const;

    void SetColorType(int colorType);
    int GetColorType();

    void SetRare(bool bRare);
    bool IsRare();

private:
    void PlayAlarm();
    bool CheckNpcHeadIcon();

private:
    HWND m_hwnd;
    DWORD m_pid; // 窗口所属进程ID
    AudioRenderer *m_pAudioPlayer;
    KeyboardBackground m_keyboard;

    char *m_lpBits; // 窗口位图像素数据
    RECT m_targetRect; // 头像矩形框

    bool m_bRare;
    int m_colorType;

    bool m_bRunning;
    long m_searchTargetTime;
    long m_moveTime;
    bool m_moveLeft;

    std::string m_name;
};


```

`WowNpcScanAlertor/NpcScanAlertorMgr.cpp`:

```cpp
#include "stdafx.h"
#include "NpcScanAlertorMgr.h"
#include "Win32Util/Util/Utility.h"
#include "WaveUtil/WaveUtil.h"
#include <conio.h>
#include <iostream>
#include <string>

NpcScanAlertorMgr::NpcScanAlertorMgr()
    : m_bRunning(false)
{
}

NpcScanAlertorMgr::~NpcScanAlertorMgr()
{
	ClearAlertor();
}

void NpcScanAlertorMgr::RegistAlertor(NpcScanAlertor *pAlertor)
{
	if (pAlertor)
	{
		m_alertors.push_back(pAlertor);
	}
}

void NpcScanAlertorMgr::ClearAlertor()
{
	for (std::list<NpcScanAlertor*>::iterator it = m_alertors.begin(); it != m_alertors.end();)
	{
		delete *it;
		it = m_alertors.erase(it);
	}
}

bool NpcScanAlertorMgr::InitAudioPlayer()
{
	AudioFrameData *pFrame = new AudioFrameData();
	if (!pFrame)
		return false;

	WAVEFORMATEX wfx;
	if (!WaveUtil::LoadWave("./npcscan.wav", &wfx, (char**)&pFrame->pData, &pFrame->nDataLen))
		return false;

	m_alarm.PushBack(pFrame);
	m_audioPlayer.SetSource(&m_alarm);

	if (m_audioPlayer.Init(&wfx) != 0)
	{
		Utility::printf_t("Init audio player failed.\n");
		return false;
	}

	return true;
}

bool NpcScanAlertorMgr::Init()
{
	if (!InitAudioPlayer())
		return false;

	HWND preHWnd = NULL;
	do
	{
		preHWnd = ::FindWindowEx(NULL, preHWnd, NULL, L"魔兽世界");
		if (preHWnd != NULL)
		{
			BindWindow(preHWnd);
		}
	} while (preHWnd != NULL);

	Utility::printf_t("Find %d window.\n", m_alertors.size());

	StopAllAlertor(false);

	return m_alertors.size() > 0;
}

void NpcScanAlertorMgr::Run()
{
	Utility::printf_t("Ready ...\n");

	m_bRunning = true;

	int delta = 100;
	while (m_bRunning)
	{
		if (_kbhit())
		{
			ReadCmd();
		}
		for (std::list<NpcScanAlertor*>::iterator it = m_alertors.begin(); it != m_alertors.end(); ++it)
		{
			NpcScanAlertor *p = *it;
			if (p && p->IsRunning())
			{
				(*it)->Update(delta); // need to repair!!!
			}
		}
		::Sleep(delta);
	}
}

void NpcScanAlertorMgr::BindWindow(HWND hwnd)
{
	NpcScanAlertor *pAlertor = new NpcScanAlertor(hwnd, &m_audioPlayer);
	if (!pAlertor)
		return;

	if (!pAlertor->Init())
	{
		delete pAlertor;
		return;
	}

	int colorType = (int)NpcScanAlertor::ColorType::Color_Red | (int)NpcScanAlertor::ColorType::Color_Yellow;
	pAlertor->Start(colorType, false);

	RegistAlertor(pAlertor);
}

void NpcScanAlertorMgr::ReadCmd()
{
	m_cmdLine.clear();
	if (!getline(std::cin, m_cmdLine))
		return;

	size_t count = Utility::Split(m_cmdLine, m_cmdElems);
	if (count == 0)
		return;

	std::list<string>::const_iterator it = m_cmdElems.cbegin();
	if (strcmp("start", it->c_str()) == 0)
	{
		if (count > 1)
		{
			++it;
			if (strcmp("all", it->c_str()) == 0)
			{
				StartAllAlertor();
			}
			else
			{
				int pid = ::atoi(it->c_str());
				StartAlertor(pid);
			}
		}
	}
	else if (strcmp("stop", it->c_str()) == 0)
	{
		if (count > 1)
		{
			++it;
			if (strcmp("all", it->c_str()) == 0)
			{
				StopAllAlertor(true);
			}
			else
			{
				int pid = ::atoi(it->c_str());
				StopAlertor(pid);
			}
		}
	}
	else if (strcmp("remove", it->c_str()) == 0)
	{
		if (count > 1)
		{
			++it;
			int pid = ::atoi(it->c_str());
			RemoveAlertor(pid);
		}
	}
	else if (strcmp("setname", it->c_str()) == 0)
	{
		if (count > 2)
		{
			++it;
			int pid = ::atoi(it->c_str());
			++it;
			const char* name = it->c_str();

			NpcScanAlertor* pAlertor = FindAlertor(pid);
			if (pAlertor != NULL)
			{
				pAlertor->SetName(name);
				printf("Alerter[%d] set name to \"%s\".\n", pid, name);
			}
		}
	}
	else if (strcmp("setrare", it->c_str()) == 0)
	{
		if (count > 2)
		{
			++it;
			int pid = ::atoi(it->c_str());
			++it;
			int rare = ::atoi(it->c_str());

			NpcScanAlertor* pAlertor = FindAlertor(pid);
			if (pAlertor != NULL)
			{
				pAlertor->SetRare(rare ? true : false);
				printf("Alerter[%d] set rare to %d.\n", pid, rare);
			}
		}
	}
	else if (strcmp("setcolor", it->c_str()) == 0)
	{
		if (count > 2)
		{
			++it;
			int pid = ::atoi(it->c_str());
			++it;
			int color = ::atoi(it->c_str());

			NpcScanAlertor* pAlertor = FindAlertor(pid);
			if (pAlertor != NULL)
			{
				pAlertor->SetColorType(color);
				printf("Alerter[%d] set color type to %d.\n", pid, color);
			}
		}
	}
	else if (strcmp("list", it->c_str()) == 0)
	{
		PrintAlertors();
	}
	else if (strcmp("exit", it->c_str()) == 0)
	{
		m_bRunning = false;
	}
	else
	{
		printf("Unexpected CMD: %s\n", m_cmdLine.c_str());
	}
}

void NpcScanAlertorMgr::RemoveAlertor(int pid)
{
	std::list<NpcScanAlertor*>::iterator it = FindAlertorByPid(pid);
	if (it != m_alertors.end())
	{
		NpcScanAlertor *pAlertor = *it;
		printf("Alerter[%d] \"%s\" : removed.\n", pid, (*it)->GetName());
		delete pAlertor;
		m_alertors.erase(it);
	}
}

std::list<NpcScanAlertor*>::iterator NpcScanAlertorMgr::FindAlertorByPid(int pid)
{
	std::list<NpcScanAlertor*>::iterator it = m_alertors.begin();
	while (it != m_alertors.end())
	{
		if ((*it)->GetPid() == pid)
			break;
		++it;
	}
	if (it == m_alertors.end())
	{
		printf("Can't find alerter [%d].\n", pid);
	}
	return it;
}

NpcScanAlertor* NpcScanAlertorMgr::FindAlertor(int pid)
{
	std::list<NpcScanAlertor*>::iterator it = FindAlertorByPid(pid);
	if (it != m_alertors.end())
		return *it;
	else
		return NULL;
}

void NpcScanAlertorMgr::StartAlertor(int pid)
{
	NpcScanAlertor* pAlertor = FindAlertor(pid);
	if (pAlertor != NULL)
	{
		pAlertor->Start();
		printf("Alerter[%d] \"%s\" : started.\n", pid, pAlertor->GetName());
	}
}

void NpcScanAlertorMgr::StopAlertor(int pid)
{
	NpcScanAlertor* pAlertor = FindAlertor(pid);
	if (pAlertor != NULL)
	{
		pAlertor->Stop();
		printf("Alerter[%d] \"%s\" : stopped.\n", pid, pAlertor->GetName());
	}
}

void NpcScanAlertorMgr::StartAllAlertor()
{
	for (std::list<NpcScanAlertor*>::iterator it = m_alertors.begin(); it != m_alertors.end(); ++it)
	{
		(*it)->Start();
		printf("Alerter[%d] \"%s\" : started.\n", (*it)->GetPid(), (*it)->GetName());
	}
}

void NpcScanAlertorMgr::StopAllAlertor(bool printMsg)
{
	for (std::list<NpcScanAlertor*>::iterator it = m_alertors.begin(); it != m_alertors.end(); ++it)
	{
		(*it)->Stop();
		if (printMsg)
		{
			printf("Alerter[%d] \"%s\" : stopped.\n", (*it)->GetPid(), (*it)->GetName());
		}
	}
}

void NpcScanAlertorMgr::PrintAlertors()
{
	int index = 0;
	for (std::list<NpcScanAlertor*>::iterator it = m_alertors.begin(); it != m_alertors.end(); ++it)
	{
		++index;
		NpcScanAlertor *pAlertor = *it;
		printf("%d. pid: %d, name: \"%s\", rare: %d, color: %d, status: %d\n", index
			, pAlertor->GetPid(), pAlertor->GetName(), pAlertor->IsRare(), pAlertor->GetColorType(), pAlertor->IsRunning());
	}
}

```

`WowNpcScanAlertor/NpcScanAlertorMgr.h`:

```h
#pragma once
#include "NpcScanAlertor.h"
#include "Win32Util/Audio/Extend/AudioRenderer.h"
#include <list>
#include <string>

class NpcScanAlertorMgr
{
public:
	NpcScanAlertorMgr();
	~NpcScanAlertorMgr();

	bool Init();
	void Run();

private:
	void RegistAlertor(NpcScanAlertor *pAlertor);
	void ClearAlertor();

	std::list<NpcScanAlertor*>::iterator FindAlertorByPid(int pid);
	NpcScanAlertor* FindAlertor(int pid);
	void RemoveAlertor(int pid);
	void StartAlertor(int pid);
	void StopAlertor(int pid);
	void StartAllAlertor();
	void StopAllAlertor(bool printMsg);
	void PrintAlertors();

	bool InitAudioPlayer();

	void BindWindow(HWND hwnd);

	void ReadCmd();

private:
	static NpcScanAlertorMgr *m_pInstance;
	std::list<NpcScanAlertor*> m_alertors;

	bool m_bRunning;
	std::string m_cmdLine;
	std::list<std::string> m_cmdElems;

	AudioFrameStorage m_alarm;
	AudioRenderer m_audioPlayer;
};


```

`WowNpcScanAlertor/WowNpcScanAlertor.cpp`:

```cpp
// WowNpcScanAlertor.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "NpcScanAlertorMgr.h"
#include <cstdio>

int _tmain(int argc, _TCHAR* argv[])
{
    int ret = ::CoInitialize(NULL);
    if (ret != 0)
    {
        return ret;
    }

	NpcScanAlertorMgr alertorMgr;
	if (alertorMgr.Init())
	{
		alertorMgr.Run();
	}

	::CoUninitialize();
	
	printf("Press Enter to quit ... ");
	int c = getchar();

	return 0;
}


```

`WowNpcScanAlertor/WowNpcScanAlertor.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{34C289A8-7D4F-45DA-B95B-6282972CE776}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>WowNpcScanAlertor</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)Libs\$(Platform)\$(Configuration);$(LibraryPath)</LibraryPath>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>CommUtil.lib;Win32Util.lib;WaveUtil.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>CommUtil.lib;Win32Util.lib;WaveUtil.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>CommUtil.lib;Win32Util.lib;WaveUtil.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>CommUtil.lib;Win32Util.lib;WaveUtil.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="NpcScanAlertor.h" />
    <ClInclude Include="NpcScanAlertorMgr.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="NpcScanAlertor.cpp" />
    <ClCompile Include="NpcScanAlertorMgr.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="WowNpcScanAlertor.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`WowNpcScanAlertor/WowNpcScanAlertor.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="NpcScanAlertor.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="NpcScanAlertorMgr.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="WowNpcScanAlertor.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="NpcScanAlertor.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="NpcScanAlertorMgr.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`WowNpcScanAlertor/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// WowNpcScanAlertor.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`WowNpcScanAlertor/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#include <stdio.h>
#include <tchar.h>



// TODO: reference additional headers your program requires here

```

`WowNpcScanAlertor/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```