Project Path: arc_gmh5225_vscript_lua51_6t4z11y3

Source Tree:

```txt
arc_gmh5225_vscript_lua51_6t4z11y3
├── CMakeLists.txt
├── README.md
├── lauxlib.h
├── lua.h
├── luaconf.h
├── lualib.h
├── luametahook.cpp
├── metahook.h
├── signatures.h
├── vscript_lua51.cpp
└── vscript_patch.cpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)
set(CMAKE_CXX_STANDARD 17)
add_library(lua5.1 SHARED vscript_lua51.cpp)

add_library(vscript SHARED vscript_patch.cpp)
target_link_libraries(vscript PUBLIC lua5.1)

add_library(luametahook SHARED luametahook.cpp)
target_link_libraries(luametahook PUBLIC lua5.1)

```

`README.md`:

```md
# vscript_lua51
This extension enables Lua VScript from CS2 to load external lua module dll. Tested on Mar 24th (9640) and Mar 30th (9652) version. 

# Usage
1. Prepare build environment: VS2022 + CMake
2. Build lua51.dll and vscript.dll
3. Rename vscript.dll to vscript2.dll in CAGO\game\bin\win64
4. Copy lua51.dll and vscript.dll into CAGO\game\bin\win64
5. Put any other external lua module dll (like luasocket.dll) into CAGO\game\bin\win64
6. Load module by `local luasocket = require("luasocket")` \
Warning: This is a client-side hack, NEVER install it under VAC, or you may get banned. 

# Support
PRs and issues are welcomed. 
```

`lauxlib.h`:

```h
/*
** $Id: lauxlib.h,v 1.88.1.1 2007/12/27 13:02:25 roberto Exp $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/


#ifndef lauxlib_h
#define lauxlib_h


#include <stddef.h>
#include <stdio.h>

#include "lua.h"


#if defined(LUA_COMPAT_GETN)
LUALIB_API int (luaL_getn) (lua_State *L, int t);
LUALIB_API void (luaL_setn) (lua_State *L, int t, int n);
#else
#define luaL_getn(L,i)          ((int)lua_objlen(L, i))
#define luaL_setn(L,i,j)        ((void)0)  /* no op! */
#endif

#if defined(LUA_COMPAT_OPENLIB)
#define luaI_openlib	luaL_openlib
#endif


/* extra error code for `luaL_load' */
#define LUA_ERRFILE     (LUA_ERRERR+1)


typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;



LUALIB_API void (luaI_openlib) (lua_State *L, const char *libname,
                                const luaL_Reg *l, int nup);
LUALIB_API void (luaL_register) (lua_State *L, const char *libname,
                                const luaL_Reg *l);
LUALIB_API int (luaL_getmetafield) (lua_State *L, int obj, const char *e);
LUALIB_API int (luaL_callmeta) (lua_State *L, int obj, const char *e);
LUALIB_API int (luaL_typerror) (lua_State *L, int narg, const char *tname);
LUALIB_API int (luaL_argerror) (lua_State *L, int numarg, const char *extramsg);
LUALIB_API const char *(luaL_checklstring) (lua_State *L, int numArg,
                                                          size_t *l);
LUALIB_API const char *(luaL_optlstring) (lua_State *L, int numArg,
                                          const char *def, size_t *l);
LUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int numArg);
LUALIB_API lua_Number (luaL_optnumber) (lua_State *L, int nArg, lua_Number def);

LUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int numArg);
LUALIB_API lua_Integer (luaL_optinteger) (lua_State *L, int nArg,
                                          lua_Integer def);

LUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);
LUALIB_API void (luaL_checktype) (lua_State *L, int narg, int t);
LUALIB_API void (luaL_checkany) (lua_State *L, int narg);

LUALIB_API int   (luaL_newmetatable) (lua_State *L, const char *tname);
LUALIB_API void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);

LUALIB_API void (luaL_where) (lua_State *L, int lvl);
LUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...);

LUALIB_API int (luaL_checkoption) (lua_State *L, int narg, const char *def,
                                   const char *const lst[]);

LUALIB_API int (luaL_ref) (lua_State *L, int t);
LUALIB_API void (luaL_unref) (lua_State *L, int t, int ref);

LUALIB_API int (luaL_loadfile) (lua_State *L, const char *filename);
LUALIB_API int (luaL_loadbuffer) (lua_State *L, const char *buff, size_t sz,
                                  const char *name);
LUALIB_API int (luaL_loadstring) (lua_State *L, const char *s);

LUALIB_API lua_State *(luaL_newstate) (void);


LUALIB_API const char *(luaL_gsub) (lua_State *L, const char *s, const char *p,
                                                  const char *r);

LUALIB_API const char *(luaL_findtable) (lua_State *L, int idx,
                                         const char *fname, int szhint);




/*
** ===============================================================
** some useful macros
** ===============================================================
*/

#define luaL_argcheck(L, cond,numarg,extramsg)	\
		((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
#define luaL_checkstring(L,n)	(luaL_checklstring(L, (n), NULL))
#define luaL_optstring(L,n,d)	(luaL_optlstring(L, (n), (d), NULL))
#define luaL_checkint(L,n)	((int)luaL_checkinteger(L, (n)))
#define luaL_optint(L,n,d)	((int)luaL_optinteger(L, (n), (d)))
#define luaL_checklong(L,n)	((long)luaL_checkinteger(L, (n)))
#define luaL_optlong(L,n,d)	((long)luaL_optinteger(L, (n), (d)))

#define luaL_typename(L,i)	lua_typename(L, lua_type(L,(i)))

#define luaL_dofile(L, fn) \
	(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))

#define luaL_dostring(L, s) \
	(luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))

#define luaL_getmetatable(L,n)	(lua_getfield(L, LUA_REGISTRYINDEX, (n)))

#define luaL_opt(L,f,n,d)	(lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))

/*
** {======================================================
** Generic Buffer manipulation
** =======================================================
*/



typedef struct luaL_Buffer {
  char *p;			/* current position in buffer */
  int lvl;  /* number of strings in the stack (level) */
  lua_State *L;
  char buffer[LUAL_BUFFERSIZE];
} luaL_Buffer;

#define luaL_addchar(B,c) \
  ((void)((B)->p < ((B)->buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), \
   (*(B)->p++ = (char)(c)))

/* compatibility only */
#define luaL_putchar(B,c)	luaL_addchar(B,c)

#define luaL_addsize(B,n)	((B)->p += (n))

LUALIB_API void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);
LUALIB_API char *(luaL_prepbuffer) (luaL_Buffer *B);
LUALIB_API void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);
LUALIB_API void (luaL_addstring) (luaL_Buffer *B, const char *s);
LUALIB_API void (luaL_addvalue) (luaL_Buffer *B);
LUALIB_API void (luaL_pushresult) (luaL_Buffer *B);


/* }====================================================== */


/* compatibility with ref system */

/* pre-defined references */
#define LUA_NOREF       (-2)
#define LUA_REFNIL      (-1)

#define lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : \
      (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))

#define lua_unref(L,ref)        luaL_unref(L, LUA_REGISTRYINDEX, (ref))

#define lua_getref(L,ref)       lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))


#define luaL_reg	luaL_Reg

#endif



```

`lua.h`:

```h
/*
** $Id: lua.h,v 1.218.1.7 2012/01/13 20:36:20 roberto Exp $
** Lua - An Extensible Extension Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/


#ifndef lua_h
#define lua_h

#include <stdarg.h>
#include <stddef.h>


#include "luaconf.h"


#define LUA_VERSION	"Lua 5.1"
#define LUA_RELEASE	"Lua 5.1.5"
#define LUA_VERSION_NUM	501
#define LUA_COPYRIGHT	"Copyright (C) 1994-2012 Lua.org, PUC-Rio"
#define LUA_AUTHORS 	"R. Ierusalimschy, L. H. de Figueiredo & W. Celes"


/* mark for precompiled code (`<esc>Lua') */
#define	LUA_SIGNATURE	"\033Lua"

/* option for multiple returns in `lua_pcall' and `lua_call' */
#define LUA_MULTRET	(-1)


/*
** pseudo-indices
*/
#define LUA_REGISTRYINDEX	(-10000)
#define LUA_ENVIRONINDEX	(-10001)
#define LUA_GLOBALSINDEX	(-10002)
#define lua_upvalueindex(i)	(LUA_GLOBALSINDEX-(i))


/* thread status; 0 is OK */
#define LUA_YIELD	1
#define LUA_ERRRUN	2
#define LUA_ERRSYNTAX	3
#define LUA_ERRMEM	4
#define LUA_ERRERR	5


typedef struct lua_State lua_State;

typedef int (*lua_CFunction) (lua_State *L);


/*
** functions that read/write blocks when loading/dumping Lua chunks
*/
typedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);

typedef int (*lua_Writer) (lua_State *L, const void* p, size_t sz, void* ud);


/*
** prototype for memory-allocation functions
*/
typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);


/*
** basic types
*/
#define LUA_TNONE		(-1)

#define LUA_TNIL		0
#define LUA_TBOOLEAN		1
#define LUA_TLIGHTUSERDATA	2
#define LUA_TNUMBER		3
#define LUA_TSTRING		4
#define LUA_TTABLE		5
#define LUA_TFUNCTION		6
#define LUA_TUSERDATA		7
#define LUA_TTHREAD		8



/* minimum Lua stack available to a C function */
#define LUA_MINSTACK	20


/*
** generic extra include file
*/
#if defined(LUA_USER_H)
#include LUA_USER_H
#endif


/* type of numbers in Lua */
typedef LUA_NUMBER lua_Number;


/* type for integer functions */
typedef LUA_INTEGER lua_Integer;



/*
** state manipulation
*/
LUA_API lua_State *(lua_newstate) (lua_Alloc f, void *ud);
LUA_API void       (lua_close) (lua_State *L);
LUA_API lua_State *(lua_newthread) (lua_State *L);

LUA_API lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);


/*
** basic stack manipulation
*/
LUA_API int   (lua_gettop) (lua_State *L);
LUA_API void  (lua_settop) (lua_State *L, int idx);
LUA_API void  (lua_pushvalue) (lua_State *L, int idx);
LUA_API void  (lua_remove) (lua_State *L, int idx);
LUA_API void  (lua_insert) (lua_State *L, int idx);
LUA_API void  (lua_replace) (lua_State *L, int idx);
LUA_API int   (lua_checkstack) (lua_State *L, int sz);

LUA_API void  (lua_xmove) (lua_State *from, lua_State *to, int n);


/*
** access functions (stack -> C)
*/

LUA_API int             (lua_isnumber) (lua_State *L, int idx);
LUA_API int             (lua_isstring) (lua_State *L, int idx);
LUA_API int             (lua_iscfunction) (lua_State *L, int idx);
LUA_API int             (lua_isuserdata) (lua_State *L, int idx);
LUA_API int             (lua_type) (lua_State *L, int idx);
LUA_API const char     *(lua_typename) (lua_State *L, int tp);

LUA_API int            (lua_equal) (lua_State *L, int idx1, int idx2);
LUA_API int            (lua_rawequal) (lua_State *L, int idx1, int idx2);
LUA_API int            (lua_lessthan) (lua_State *L, int idx1, int idx2);

LUA_API lua_Number      (lua_tonumber) (lua_State *L, int idx);
LUA_API lua_Integer     (lua_tointeger) (lua_State *L, int idx);
LUA_API int             (lua_toboolean) (lua_State *L, int idx);
LUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);
LUA_API size_t          (lua_objlen) (lua_State *L, int idx);
LUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);
LUA_API void	       *(lua_touserdata) (lua_State *L, int idx);
LUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);
LUA_API const void     *(lua_topointer) (lua_State *L, int idx);


/*
** push functions (C -> stack)
*/
LUA_API void  (lua_pushnil) (lua_State *L);
LUA_API void  (lua_pushnumber) (lua_State *L, lua_Number n);
LUA_API void  (lua_pushinteger) (lua_State *L, lua_Integer n);
LUA_API void  (lua_pushlstring) (lua_State *L, const char *s, size_t l);
LUA_API void  (lua_pushstring) (lua_State *L, const char *s);
LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,
                                                      va_list argp);
LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);
LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);
LUA_API void  (lua_pushboolean) (lua_State *L, int b);
LUA_API void  (lua_pushlightuserdata) (lua_State *L, void *p);
LUA_API int   (lua_pushthread) (lua_State *L);


/*
** get functions (Lua -> stack)
*/
LUA_API void  (lua_gettable) (lua_State *L, int idx);
LUA_API void  (lua_getfield) (lua_State *L, int idx, const char *k);
LUA_API void  (lua_rawget) (lua_State *L, int idx);
LUA_API void  (lua_rawgeti) (lua_State *L, int idx, int n);
LUA_API void  (lua_createtable) (lua_State *L, int narr, int nrec);
LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz);
LUA_API int   (lua_getmetatable) (lua_State *L, int objindex);
LUA_API void  (lua_getfenv) (lua_State *L, int idx);


/*
** set functions (stack -> Lua)
*/
LUA_API void  (lua_settable) (lua_State *L, int idx);
LUA_API void  (lua_setfield) (lua_State *L, int idx, const char *k);
LUA_API void  (lua_rawset) (lua_State *L, int idx);
LUA_API void  (lua_rawseti) (lua_State *L, int idx, int n);
LUA_API int   (lua_setmetatable) (lua_State *L, int objindex);
LUA_API int   (lua_setfenv) (lua_State *L, int idx);


/*
** `load' and `call' functions (load and run Lua code)
*/
LUA_API void  (lua_call) (lua_State *L, int nargs, int nresults);
LUA_API int   (lua_pcall) (lua_State *L, int nargs, int nresults, int errfunc);
LUA_API int   (lua_cpcall) (lua_State *L, lua_CFunction func, void *ud);
LUA_API int   (lua_load) (lua_State *L, lua_Reader reader, void *dt,
                                        const char *chunkname);

LUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data);


/*
** coroutine functions
*/
LUA_API int  (lua_yield) (lua_State *L, int nresults);
LUA_API int  (lua_resume) (lua_State *L, int narg);
LUA_API int  (lua_status) (lua_State *L);

/*
** garbage-collection function and options
*/

#define LUA_GCSTOP		0
#define LUA_GCRESTART		1
#define LUA_GCCOLLECT		2
#define LUA_GCCOUNT		3
#define LUA_GCCOUNTB		4
#define LUA_GCSTEP		5
#define LUA_GCSETPAUSE		6
#define LUA_GCSETSTEPMUL	7

LUA_API int (lua_gc) (lua_State *L, int what, int data);


/*
** miscellaneous functions
*/

LUA_API int   (lua_error) (lua_State *L);

LUA_API int   (lua_next) (lua_State *L, int idx);

LUA_API void  (lua_concat) (lua_State *L, int n);

LUA_API lua_Alloc (lua_getallocf) (lua_State *L, void **ud);
LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);



/* 
** ===============================================================
** some useful macros
** ===============================================================
*/

#define lua_pop(L,n)		lua_settop(L, -(n)-1)

#define lua_newtable(L)		lua_createtable(L, 0, 0)

#define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))

#define lua_pushcfunction(L,f)	lua_pushcclosure(L, (f), 0)

#define lua_strlen(L,i)		lua_objlen(L, (i))

#define lua_isfunction(L,n)	(lua_type(L, (n)) == LUA_TFUNCTION)
#define lua_istable(L,n)	(lua_type(L, (n)) == LUA_TTABLE)
#define lua_islightuserdata(L,n)	(lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
#define lua_isnil(L,n)		(lua_type(L, (n)) == LUA_TNIL)
#define lua_isboolean(L,n)	(lua_type(L, (n)) == LUA_TBOOLEAN)
#define lua_isthread(L,n)	(lua_type(L, (n)) == LUA_TTHREAD)
#define lua_isnone(L,n)		(lua_type(L, (n)) == LUA_TNONE)
#define lua_isnoneornil(L, n)	(lua_type(L, (n)) <= 0)

#define lua_pushliteral(L, s)	\
	lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)

#define lua_setglobal(L,s)	lua_setfield(L, LUA_GLOBALSINDEX, (s))
#define lua_getglobal(L,s)	lua_getfield(L, LUA_GLOBALSINDEX, (s))

#define lua_tostring(L,i)	lua_tolstring(L, (i), NULL)



/*
** compatibility macros and functions
*/

#define lua_open()	luaL_newstate()

#define lua_getregistry(L)	lua_pushvalue(L, LUA_REGISTRYINDEX)

#define lua_getgccount(L)	lua_gc(L, LUA_GCCOUNT, 0)

#define lua_Chunkreader		lua_Reader
#define lua_Chunkwriter		lua_Writer


/* hack */
LUA_API void lua_setlevel	(lua_State *from, lua_State *to);


/*
** {======================================================================
** Debug API
** =======================================================================
*/


/*
** Event codes
*/
#define LUA_HOOKCALL	0
#define LUA_HOOKRET	1
#define LUA_HOOKLINE	2
#define LUA_HOOKCOUNT	3
#define LUA_HOOKTAILRET 4


/*
** Event masks
*/
#define LUA_MASKCALL	(1 << LUA_HOOKCALL)
#define LUA_MASKRET	(1 << LUA_HOOKRET)
#define LUA_MASKLINE	(1 << LUA_HOOKLINE)
#define LUA_MASKCOUNT	(1 << LUA_HOOKCOUNT)

typedef struct lua_Debug lua_Debug;  /* activation record */


/* Functions to be called by the debuger in specific events */
typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);


LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar);
LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);
LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);
LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);
LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n);
LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n);

LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count);
LUA_API lua_Hook lua_gethook (lua_State *L);
LUA_API int lua_gethookmask (lua_State *L);
LUA_API int lua_gethookcount (lua_State *L);


struct lua_Debug {
  int event;
  const char *name;	/* (n) */
  const char *namewhat;	/* (n) `global', `local', `field', `method' */
  const char *what;	/* (S) `Lua', `C', `main', `tail' */
  const char *source;	/* (S) */
  int currentline;	/* (l) */
  int nups;		/* (u) number of upvalues */
  int linedefined;	/* (S) */
  int lastlinedefined;	/* (S) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  int i_ci;  /* active function */
};

/* }====================================================================== */


/******************************************************************************
* Copyright (C) 1994-2012 Lua.org, PUC-Rio.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
******************************************************************************/


#endif

```

`luaconf.h`:

```h
/*
** $Id: luaconf.h,v 1.82.1.7 2008/02/11 16:25:08 roberto Exp $
** Configuration file for Lua
** See Copyright Notice in lua.h
*/


#ifndef lconfig_h
#define lconfig_h

#include <limits.h>
#include <stddef.h>


/*
** ==================================================================
** Search for "@@" to find all configurable definitions.
** ===================================================================
*/


/*
@@ LUA_ANSI controls the use of non-ansi features.
** CHANGE it (define it) if you want Lua to avoid the use of any
** non-ansi feature or library.
*/
#if defined(__STRICT_ANSI__)
#define LUA_ANSI
#endif


#if !defined(LUA_ANSI) && defined(_WIN32)
#define LUA_WIN
#endif

#if defined(LUA_USE_LINUX)
#define LUA_USE_POSIX
#define LUA_USE_DLOPEN		/* needs an extra library: -ldl */
#define LUA_USE_READLINE	/* needs some extra libraries */
#endif

#if defined(LUA_USE_MACOSX)
#define LUA_USE_POSIX
#define LUA_DL_DYLD		/* does not need extra library */
#endif



/*
@@ LUA_USE_POSIX includes all functionallity listed as X/Open System
@* Interfaces Extension (XSI).
** CHANGE it (define it) if your system is XSI compatible.
*/
#if defined(LUA_USE_POSIX)
#define LUA_USE_MKSTEMP
#define LUA_USE_ISATTY
#define LUA_USE_POPEN
#define LUA_USE_ULONGJMP
#endif


/*
@@ LUA_PATH and LUA_CPATH are the names of the environment variables that
@* Lua check to set its paths.
@@ LUA_INIT is the name of the environment variable that Lua
@* checks for initialization code.
** CHANGE them if you want different names.
*/
#define LUA_PATH        "LUA_PATH"
#define LUA_CPATH       "LUA_CPATH"
#define LUA_INIT	"LUA_INIT"


/*
@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for
@* Lua libraries.
@@ LUA_CPATH_DEFAULT is the default path that Lua uses to look for
@* C libraries.
** CHANGE them if your machine has a non-conventional directory
** hierarchy or if you want to install your libraries in
** non-conventional directories.
*/
#if defined(_WIN32)
/*
** In Windows, any exclamation mark ('!') in the path is replaced by the
** path of the directory of the executable file of the current process.
*/
#define LUA_LDIR	"!\\lua\\"
#define LUA_CDIR	"!\\"
#define LUA_PATH_DEFAULT  \
		".\\?.lua;"  LUA_LDIR"?.lua;"  LUA_LDIR"?\\init.lua;" \
		             LUA_CDIR"?.lua;"  LUA_CDIR"?\\init.lua"
#define LUA_CPATH_DEFAULT \
	".\\?.dll;"  LUA_CDIR"?.dll;" LUA_CDIR"loadall.dll"

#else
#define LUA_ROOT	"/usr/local/"
#define LUA_LDIR	LUA_ROOT "share/lua/5.1/"
#define LUA_CDIR	LUA_ROOT "lib/lua/5.1/"
#define LUA_PATH_DEFAULT  \
		"./?.lua;"  LUA_LDIR"?.lua;"  LUA_LDIR"?/init.lua;" \
		            LUA_CDIR"?.lua;"  LUA_CDIR"?/init.lua"
#define LUA_CPATH_DEFAULT \
	"./?.so;"  LUA_CDIR"?.so;" LUA_CDIR"loadall.so"
#endif


/*
@@ LUA_DIRSEP is the directory separator (for submodules).
** CHANGE it if your machine does not use "/" as the directory separator
** and is not Windows. (On Windows Lua automatically uses "\".)
*/
#if defined(_WIN32)
#define LUA_DIRSEP	"\\"
#else
#define LUA_DIRSEP	"/"
#endif


/*
@@ LUA_PATHSEP is the character that separates templates in a path.
@@ LUA_PATH_MARK is the string that marks the substitution points in a
@* template.
@@ LUA_EXECDIR in a Windows path is replaced by the executable's
@* directory.
@@ LUA_IGMARK is a mark to ignore all before it when bulding the
@* luaopen_ function name.
** CHANGE them if for some reason your system cannot use those
** characters. (E.g., if one of those characters is a common character
** in file/directory names.) Probably you do not need to change them.
*/
#define LUA_PATHSEP	";"
#define LUA_PATH_MARK	"?"
#define LUA_EXECDIR	"!"
#define LUA_IGMARK	"-"


/*
@@ LUA_INTEGER is the integral type used by lua_pushinteger/lua_tointeger.
** CHANGE that if ptrdiff_t is not adequate on your machine. (On most
** machines, ptrdiff_t gives a good choice between int or long.)
*/
#define LUA_INTEGER	ptrdiff_t


/*
@@ LUA_API is a mark for all core API functions.
@@ LUALIB_API is a mark for all standard library functions.
** CHANGE them if you need to define those functions in some special way.
** For instance, if you want to create one Windows DLL with the core and
** the libraries, you may want to use the following definition (define
** LUA_BUILD_AS_DLL to get it).
*/
#if defined(LUA_BUILD_AS_DLL)

#if defined(LUA_CORE) || defined(LUA_LIB)
#define LUA_API __declspec(dllexport)
#else
#define LUA_API __declspec(dllimport)
#endif

#else

#define LUA_API		extern

#endif

/* more often than not the libs go together with the core */
#define LUALIB_API	LUA_API


/*
@@ LUAI_FUNC is a mark for all extern functions that are not to be
@* exported to outside modules.
@@ LUAI_DATA is a mark for all extern (const) variables that are not to
@* be exported to outside modules.
** CHANGE them if you need to mark them in some special way. Elf/gcc
** (versions 3.2 and later) mark them as "hidden" to optimize access
** when Lua is compiled as a shared library.
*/
#if defined(luaall_c)
#define LUAI_FUNC	static
#define LUAI_DATA	/* empty */

#elif defined(__GNUC__) && ((__GNUC__*100 + __GNUC_MINOR__) >= 302) && \
      defined(__ELF__)
#define LUAI_FUNC	__attribute__((visibility("hidden"))) extern
#define LUAI_DATA	LUAI_FUNC

#else
#define LUAI_FUNC	extern
#define LUAI_DATA	extern
#endif



/*
@@ LUA_QL describes how error messages quote program elements.
** CHANGE it if you want a different appearance.
*/
#define LUA_QL(x)	"'" x "'"
#define LUA_QS		LUA_QL("%s")


/*
@@ LUA_IDSIZE gives the maximum size for the description of the source
@* of a function in debug information.
** CHANGE it if you want a different size.
*/
#define LUA_IDSIZE	60


/*
** {==================================================================
** Stand-alone configuration
** ===================================================================
*/

#if defined(lua_c) || defined(luaall_c)

/*
@@ lua_stdin_is_tty detects whether the standard input is a 'tty' (that
@* is, whether we're running lua interactively).
** CHANGE it if you have a better definition for non-POSIX/non-Windows
** systems.
*/
#if defined(LUA_USE_ISATTY)
#include <unistd.h>
#define lua_stdin_is_tty()	isatty(0)
#elif defined(LUA_WIN)
#include <io.h>
#include <stdio.h>
#define lua_stdin_is_tty()	_isatty(_fileno(stdin))
#else
#define lua_stdin_is_tty()	1  /* assume stdin is a tty */
#endif


/*
@@ LUA_PROMPT is the default prompt used by stand-alone Lua.
@@ LUA_PROMPT2 is the default continuation prompt used by stand-alone Lua.
** CHANGE them if you want different prompts. (You can also change the
** prompts dynamically, assigning to globals _PROMPT/_PROMPT2.)
*/
#define LUA_PROMPT		"> "
#define LUA_PROMPT2		">> "


/*
@@ LUA_PROGNAME is the default name for the stand-alone Lua program.
** CHANGE it if your stand-alone interpreter has a different name and
** your system is not able to detect that name automatically.
*/
#define LUA_PROGNAME		"lua"


/*
@@ LUA_MAXINPUT is the maximum length for an input line in the
@* stand-alone interpreter.
** CHANGE it if you need longer lines.
*/
#define LUA_MAXINPUT	512


/*
@@ lua_readline defines how to show a prompt and then read a line from
@* the standard input.
@@ lua_saveline defines how to "save" a read line in a "history".
@@ lua_freeline defines how to free a line read by lua_readline.
** CHANGE them if you want to improve this functionality (e.g., by using
** GNU readline and history facilities).
*/
#if defined(LUA_USE_READLINE)
#include <stdio.h>
#include <readline/readline.h>
#include <readline/history.h>
#define lua_readline(L,b,p)	((void)L, ((b)=readline(p)) != NULL)
#define lua_saveline(L,idx) \
	if (lua_strlen(L,idx) > 0)  /* non-empty line? */ \
	  add_history(lua_tostring(L, idx));  /* add it to history */
#define lua_freeline(L,b)	((void)L, free(b))
#else
#define lua_readline(L,b,p)	\
	((void)L, fputs(p, stdout), fflush(stdout),  /* show prompt */ \
	fgets(b, LUA_MAXINPUT, stdin) != NULL)  /* get line */
#define lua_saveline(L,idx)	{ (void)L; (void)idx; }
#define lua_freeline(L,b)	{ (void)L; (void)b; }
#endif

#endif

/* }================================================================== */


/*
@@ LUAI_GCPAUSE defines the default pause between garbage-collector cycles
@* as a percentage.
** CHANGE it if you want the GC to run faster or slower (higher values
** mean larger pauses which mean slower collection.) You can also change
** this value dynamically.
*/
#define LUAI_GCPAUSE	200  /* 200% (wait memory to double before next GC) */


/*
@@ LUAI_GCMUL defines the default speed of garbage collection relative to
@* memory allocation as a percentage.
** CHANGE it if you want to change the granularity of the garbage
** collection. (Higher values mean coarser collections. 0 represents
** infinity, where each step performs a full collection.) You can also
** change this value dynamically.
*/
#define LUAI_GCMUL	200 /* GC runs 'twice the speed' of memory allocation */



/*
@@ LUA_COMPAT_GETN controls compatibility with old getn behavior.
** CHANGE it (define it) if you want exact compatibility with the
** behavior of setn/getn in Lua 5.0.
*/
#undef LUA_COMPAT_GETN

/*
@@ LUA_COMPAT_LOADLIB controls compatibility about global loadlib.
** CHANGE it to undefined as soon as you do not need a global 'loadlib'
** function (the function is still available as 'package.loadlib').
*/
#undef LUA_COMPAT_LOADLIB

/*
@@ LUA_COMPAT_VARARG controls compatibility with old vararg feature.
** CHANGE it to undefined as soon as your programs use only '...' to
** access vararg parameters (instead of the old 'arg' table).
*/
#define LUA_COMPAT_VARARG

/*
@@ LUA_COMPAT_MOD controls compatibility with old math.mod function.
** CHANGE it to undefined as soon as your programs use 'math.fmod' or
** the new '%' operator instead of 'math.mod'.
*/
#define LUA_COMPAT_MOD

/*
@@ LUA_COMPAT_LSTR controls compatibility with old long string nesting
@* facility.
** CHANGE it to 2 if you want the old behaviour, or undefine it to turn
** off the advisory error when nesting [[...]].
*/
#define LUA_COMPAT_LSTR		1

/*
@@ LUA_COMPAT_GFIND controls compatibility with old 'string.gfind' name.
** CHANGE it to undefined as soon as you rename 'string.gfind' to
** 'string.gmatch'.
*/
#define LUA_COMPAT_GFIND

/*
@@ LUA_COMPAT_OPENLIB controls compatibility with old 'luaL_openlib'
@* behavior.
** CHANGE it to undefined as soon as you replace to 'luaL_register'
** your uses of 'luaL_openlib'
*/
#define LUA_COMPAT_OPENLIB



/*
@@ luai_apicheck is the assert macro used by the Lua-C API.
** CHANGE luai_apicheck if you want Lua to perform some checks in the
** parameters it gets from API calls. This may slow down the interpreter
** a bit, but may be quite useful when debugging C code that interfaces
** with Lua. A useful redefinition is to use assert.h.
*/
#if defined(LUA_USE_APICHECK)
#include <assert.h>
#define luai_apicheck(L,o)	{ (void)L; assert(o); }
#else
#define luai_apicheck(L,o)	{ (void)L; }
#endif


/*
@@ LUAI_BITSINT defines the number of bits in an int.
** CHANGE here if Lua cannot automatically detect the number of bits of
** your machine. Probably you do not need to change this.
*/
/* avoid overflows in comparison */
#if INT_MAX-20 < 32760
#define LUAI_BITSINT	16
#elif INT_MAX > 2147483640L
/* int has at least 32 bits */
#define LUAI_BITSINT	32
#else
#error "you must define LUA_BITSINT with number of bits in an integer"
#endif


/*
@@ LUAI_UINT32 is an unsigned integer with at least 32 bits.
@@ LUAI_INT32 is an signed integer with at least 32 bits.
@@ LUAI_UMEM is an unsigned integer big enough to count the total
@* memory used by Lua.
@@ LUAI_MEM is a signed integer big enough to count the total memory
@* used by Lua.
** CHANGE here if for some weird reason the default definitions are not
** good enough for your machine. (The definitions in the 'else'
** part always works, but may waste space on machines with 64-bit
** longs.) Probably you do not need to change this.
*/
#if LUAI_BITSINT >= 32
#define LUAI_UINT32	unsigned int
#define LUAI_INT32	int
#define LUAI_MAXINT32	INT_MAX
#define LUAI_UMEM	size_t
#define LUAI_MEM	ptrdiff_t
#else
/* 16-bit ints */
#define LUAI_UINT32	unsigned long
#define LUAI_INT32	long
#define LUAI_MAXINT32	LONG_MAX
#define LUAI_UMEM	unsigned long
#define LUAI_MEM	long
#endif


/*
@@ LUAI_MAXCALLS limits the number of nested calls.
** CHANGE it if you need really deep recursive calls. This limit is
** arbitrary; its only purpose is to stop infinite recursion before
** exhausting memory.
*/
#define LUAI_MAXCALLS	20000


/*
@@ LUAI_MAXCSTACK limits the number of Lua stack slots that a C function
@* can use.
** CHANGE it if you need lots of (Lua) stack space for your C
** functions. This limit is arbitrary; its only purpose is to stop C
** functions to consume unlimited stack space. (must be smaller than
** -LUA_REGISTRYINDEX)
*/
#define LUAI_MAXCSTACK	8000



/*
** {==================================================================
** CHANGE (to smaller values) the following definitions if your system
** has a small C stack. (Or you may want to change them to larger
** values if your system has a large C stack and these limits are
** too rigid for you.) Some of these constants control the size of
** stack-allocated arrays used by the compiler or the interpreter, while
** others limit the maximum number of recursive calls that the compiler
** or the interpreter can perform. Values too large may cause a C stack
** overflow for some forms of deep constructs.
** ===================================================================
*/


/*
@@ LUAI_MAXCCALLS is the maximum depth for nested C calls (short) and
@* syntactical nested non-terminals in a program.
*/
#define LUAI_MAXCCALLS		200


/*
@@ LUAI_MAXVARS is the maximum number of local variables per function
@* (must be smaller than 250).
*/
#define LUAI_MAXVARS		200


/*
@@ LUAI_MAXUPVALUES is the maximum number of upvalues per function
@* (must be smaller than 250).
*/
#define LUAI_MAXUPVALUES	60


/*
@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
*/
#define LUAL_BUFFERSIZE		BUFSIZ

/* }================================================================== */




/*
** {==================================================================
@@ LUA_NUMBER is the type of numbers in Lua.
** CHANGE the following definitions only if you want to build Lua
** with a number type different from double. You may also need to
** change lua_number2int & lua_number2integer.
** ===================================================================
*/

#define LUA_NUMBER_DOUBLE
#define LUA_NUMBER	double

/*
@@ LUAI_UACNUMBER is the result of an 'usual argument conversion'
@* over a number.
*/
#define LUAI_UACNUMBER	double


/*
@@ LUA_NUMBER_SCAN is the format for reading numbers.
@@ LUA_NUMBER_FMT is the format for writing numbers.
@@ lua_number2str converts a number to a string.
@@ LUAI_MAXNUMBER2STR is maximum size of previous conversion.
@@ lua_str2number converts a string to a number.
*/
#define LUA_NUMBER_SCAN		"%lf"
#define LUA_NUMBER_FMT		"%.14g"
#define lua_number2str(s,n)	sprintf((s), LUA_NUMBER_FMT, (n))
#define LUAI_MAXNUMBER2STR	32 /* 16 digits, sign, point, and \0 */
#define lua_str2number(s,p)	strtod((s), (p))


/*
@@ The luai_num* macros define the primitive operations over numbers.
*/
#if defined(LUA_CORE)
#include <math.h>
#define luai_numadd(a,b)	((a)+(b))
#define luai_numsub(a,b)	((a)-(b))
#define luai_nummul(a,b)	((a)*(b))
#define luai_numdiv(a,b)	((a)/(b))
#define luai_nummod(a,b)	((a) - floor((a)/(b))*(b))
#define luai_numpow(a,b)	(pow(a,b))
#define luai_numunm(a)		(-(a))
#define luai_numeq(a,b)		((a)==(b))
#define luai_numlt(a,b)		((a)<(b))
#define luai_numle(a,b)		((a)<=(b))
#define luai_numisnan(a)	(!luai_numeq((a), (a)))
#endif


/*
@@ lua_number2int is a macro to convert lua_Number to int.
@@ lua_number2integer is a macro to convert lua_Number to lua_Integer.
** CHANGE them if you know a faster way to convert a lua_Number to
** int (with any rounding method and without throwing errors) in your
** system. In Pentium machines, a naive typecast from double to int
** in C is extremely slow, so any alternative is worth trying.
*/

/* On a Pentium, resort to a trick */
#if defined(LUA_NUMBER_DOUBLE) && !defined(LUA_ANSI) && !defined(__SSE2__) && \
    (defined(__i386) || defined (_M_IX86) || defined(__i386__))

/* On a Microsoft compiler, use assembler */
#if defined(_MSC_VER)

#define lua_number2int(i,d)   __asm fld d   __asm fistp i
#define lua_number2integer(i,n)		lua_number2int(i, n)

/* the next trick should work on any Pentium, but sometimes clashes
   with a DirectX idiosyncrasy */
#else

union luai_Cast { double l_d; long l_l; };
#define lua_number2int(i,d) \
  { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
#define lua_number2integer(i,n)		lua_number2int(i, n)

#endif


/* this option always works, but may be slow */
#else
#define lua_number2int(i,d)	((i)=(int)(d))
#define lua_number2integer(i,d)	((i)=(lua_Integer)(d))

#endif

/* }================================================================== */


/*
@@ LUAI_USER_ALIGNMENT_T is a type that requires maximum alignment.
** CHANGE it if your system requires alignments larger than double. (For
** instance, if your system supports long doubles and they must be
** aligned in 16-byte boundaries, then you should add long double in the
** union.) Probably you do not need to change this.
*/
#define LUAI_USER_ALIGNMENT_T	union { double u; void *s; long l; }


/*
@@ LUAI_THROW/LUAI_TRY define how Lua does exception handling.
** CHANGE them if you prefer to use longjmp/setjmp even with C++
** or if want/don't to use _longjmp/_setjmp instead of regular
** longjmp/setjmp. By default, Lua handles errors with exceptions when
** compiling as C++ code, with _longjmp/_setjmp when asked to use them,
** and with longjmp/setjmp otherwise.
*/
#if defined(__cplusplus)
/* C++ exceptions */
#define LUAI_THROW(L,c)	throw(c)
#define LUAI_TRY(L,c,a)	try { a } catch(...) \
	{ if ((c)->status == 0) (c)->status = -1; }
#define luai_jmpbuf	int  /* dummy variable */

#elif defined(LUA_USE_ULONGJMP)
/* in Unix, try _longjmp/_setjmp (more efficient) */
#define LUAI_THROW(L,c)	_longjmp((c)->b, 1)
#define LUAI_TRY(L,c,a)	if (_setjmp((c)->b) == 0) { a }
#define luai_jmpbuf	jmp_buf

#else
/* default handling with long jumps */
#define LUAI_THROW(L,c)	longjmp((c)->b, 1)
#define LUAI_TRY(L,c,a)	if (setjmp((c)->b) == 0) { a }
#define luai_jmpbuf	jmp_buf

#endif


/*
@@ LUA_MAXCAPTURES is the maximum number of captures that a pattern
@* can do during pattern-matching.
** CHANGE it if you need more captures. This limit is arbitrary.
*/
#define LUA_MAXCAPTURES		32


/*
@@ lua_tmpnam is the function that the OS library uses to create a
@* temporary name.
@@ LUA_TMPNAMBUFSIZE is the maximum size of a name created by lua_tmpnam.
** CHANGE them if you have an alternative to tmpnam (which is considered
** insecure) or if you want the original tmpnam anyway.  By default, Lua
** uses tmpnam except when POSIX is available, where it uses mkstemp.
*/
#if defined(loslib_c) || defined(luaall_c)

#if defined(LUA_USE_MKSTEMP)
#include <unistd.h>
#define LUA_TMPNAMBUFSIZE	32
#define lua_tmpnam(b,e)	{ \
	strcpy(b, "/tmp/lua_XXXXXX"); \
	e = mkstemp(b); \
	if (e != -1) close(e); \
	e = (e == -1); }

#else
#define LUA_TMPNAMBUFSIZE	L_tmpnam
#define lua_tmpnam(b,e)		{ e = (tmpnam(b) == NULL); }
#endif

#endif


/*
@@ lua_popen spawns a new process connected to the current one through
@* the file streams.
** CHANGE it if you have a way to implement it in your system.
*/
#if defined(LUA_USE_POPEN)

#define lua_popen(L,c,m)	((void)L, fflush(NULL), popen(c,m))
#define lua_pclose(L,file)	((void)L, (pclose(file) != -1))

#elif defined(LUA_WIN)

#define lua_popen(L,c,m)	((void)L, _popen(c,m))
#define lua_pclose(L,file)	((void)L, (_pclose(file) != -1))

#else

#define lua_popen(L,c,m)	((void)((void)c, m),  \
		luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
#define lua_pclose(L,file)		((void)((void)L, file), 0)

#endif

/*
@@ LUA_DL_* define which dynamic-library system Lua should use.
** CHANGE here if Lua has problems choosing the appropriate
** dynamic-library system for your platform (either Windows' DLL, Mac's
** dyld, or Unix's dlopen). If your system is some kind of Unix, there
** is a good chance that it has dlopen, so LUA_DL_DLOPEN will work for
** it.  To use dlopen you also need to adapt the src/Makefile (probably
** adding -ldl to the linker options), so Lua does not select it
** automatically.  (When you change the makefile to add -ldl, you must
** also add -DLUA_USE_DLOPEN.)
** If you do not want any kind of dynamic library, undefine all these
** options.
** By default, _WIN32 gets LUA_DL_DLL and MAC OS X gets LUA_DL_DYLD.
*/
#if defined(LUA_USE_DLOPEN)
#define LUA_DL_DLOPEN
#endif

#if defined(LUA_WIN)
#define LUA_DL_DLL
#endif


/*
@@ LUAI_EXTRASPACE allows you to add user-specific data in a lua_State
@* (the data goes just *before* the lua_State pointer).
** CHANGE (define) this if you really need that. This value must be
** a multiple of the maximum alignment required for your machine.
*/
#define LUAI_EXTRASPACE		0


/*
@@ luai_userstate* allow user-specific actions on threads.
** CHANGE them if you defined LUAI_EXTRASPACE and need to do something
** extra when a thread is created/deleted/resumed/yielded.
*/
#define luai_userstateopen(L)		((void)L)
#define luai_userstateclose(L)		((void)L)
#define luai_userstatethread(L,L1)	((void)L)
#define luai_userstatefree(L)		((void)L)
#define luai_userstateresume(L,n)	((void)L)
#define luai_userstateyield(L,n)	((void)L)


/*
@@ LUA_INTFRMLEN is the length modifier for integer conversions
@* in 'string.format'.
@@ LUA_INTFRM_T is the integer type correspoding to the previous length
@* modifier.
** CHANGE them if your system supports long long or does not support long.
*/

#if defined(LUA_USELONGLONG)

#define LUA_INTFRMLEN		"ll"
#define LUA_INTFRM_T		long long

#else

#define LUA_INTFRMLEN		"l"
#define LUA_INTFRM_T		long

#endif



/* =================================================================== */

/*
** Local configuration. You can use this space to add your redefinitions
** without modifying the main part of the file.
*/



#endif


```

`lualib.h`:

```h
/*
** $Id: lualib.h,v 1.36.1.1 2007/12/27 13:02:25 roberto Exp $
** Lua standard libraries
** See Copyright Notice in lua.h
*/


#ifndef lualib_h
#define lualib_h

#include "lua.h"


/* Key to file-handle type */
#define LUA_FILEHANDLE		"FILE*"


#define LUA_COLIBNAME	"coroutine"
LUALIB_API int (luaopen_base) (lua_State *L);

#define LUA_TABLIBNAME	"table"
LUALIB_API int (luaopen_table) (lua_State *L);

#define LUA_IOLIBNAME	"io"
LUALIB_API int (luaopen_io) (lua_State *L);

#define LUA_OSLIBNAME	"os"
LUALIB_API int (luaopen_os) (lua_State *L);

#define LUA_STRLIBNAME	"string"
LUALIB_API int (luaopen_string) (lua_State *L);

#define LUA_MATHLIBNAME	"math"
LUALIB_API int (luaopen_math) (lua_State *L);

#define LUA_DBLIBNAME	"debug"
LUALIB_API int (luaopen_debug) (lua_State *L);

#define LUA_LOADLIBNAME	"package"
LUALIB_API int (luaopen_package) (lua_State *L);


/* open all previous libraries */
LUALIB_API void (luaL_openlibs) (lua_State *L); 



#ifndef lua_assert
#define lua_assert(x)	((void)0)
#endif


#endif

```

`luametahook.cpp`:

```cpp


extern "C" {
#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
}

#include "Windows.h"
#include "metahook.h"

// function SearchPattern(string ModuleName, string Pattern)
int LuaMH_SearchPattern(lua_State* L)
{
	const char* name = lua_tostring(L, 1);
	size_t pattern_len = 0;
	const char* pattern = lua_tolstring(L, 2, &pattern_len);
	HMODULE hModule = GetModuleHandleA(name);
	if (!hModule)
		return luaL_error(L, "invalid module");

	BYTE* pBase = (BYTE*)MH_GetModuleBase(hModule);
	auto dwModuleSize = MH_GetModuleSize(hModule);
	VirtualProtect(pBase, dwModuleSize, PAGE_EXECUTE_READWRITE, NULL);
	auto addr = MH_SearchPattern(pBase, dwModuleSize, pattern, pattern_len);
	if (!addr)
	{
		return luaL_error(L, "signature not found");
	}

	lua_pushlightuserdata(L, addr);
	return 1;
}

// function GetModuleRange(string ModuleName) => Base, Size
int LuaMH_GetModuleRange(lua_State* L)
{
	const char* name = lua_tostring(L, 1);
	HMODULE hModule = GetModuleHandleA(name);
	if (!hModule)
		return luaL_error(L, "invalid module");
	BYTE* pBase = (BYTE*)MH_GetModuleBase(hModule);
	auto dwModuleSize = MH_GetModuleSize(hModule);

	lua_pushlightuserdata(L, pBase);
	lua_pushinteger(L, (lua_Integer)dwModuleSize);
	return 2;
}

const luaL_reg lib[] = {
	{ "SearchPattern", LuaMH_SearchPattern},
	{ "GetModuleRange", LuaMH_GetModuleRange},
	{ nullptr, nullptr }
};

extern "C" __declspec(dllexport) int luaopen_luametahook(lua_State* L)
{
	luaL_register(L, "luametahook", lib);
	return 1;
}
```

`metahook.h`:

```h
#pragma once

inline PVOID MH_GetModuleBase(HMODULE hModule)
{
	MEMORY_BASIC_INFORMATION mem;

	if (!VirtualQuery(hModule, &mem, sizeof(MEMORY_BASIC_INFORMATION)))
		return 0;

	return (PVOID)mem.AllocationBase;
}

inline LONG_PTR MH_GetModuleSize(HMODULE hModule)
{
	return ((IMAGE_NT_HEADERS*)((LONG_PTR)hModule + ((IMAGE_DOS_HEADER*)hModule)->e_lfanew))->OptionalHeader.SizeOfImage;
}

inline void* MH_SearchPattern(void* pStartSearch, LONG_PTR dwSearchLen, const char* pPattern, LONG_PTR dwPatternLen)
{
	BYTE *dwStartAddr = (BYTE *)pStartSearch;
	BYTE *dwEndAddr = dwStartAddr + dwSearchLen - dwPatternLen;

	while (dwStartAddr < dwEndAddr)
	{
		bool found = true;

		for (LONG_PTR i = 0; i < dwPatternLen; i++)
		{
			if ((BYTE)pPattern[i] != 0x2A && (BYTE)pPattern[i] != dwStartAddr[i])
			{
				found = false;
				break;
			}
		}

		if (found)
			return dwStartAddr;

		dwStartAddr++;
	}

	return 0;
}
```

`signatures.h`:

```h
F_DEF(index2adr, "\x4C\x8B\xC1\x85\xD2\x7E\x2A\x48\x8B\x41\x20\x48\x63\xD2")
F_DEF(lj_obj_equal, "\x4C\x8B\x09\x4C\x8B\x12")
F_DEF(lj_err_callermsg, "\x40\x53\x48\x83\xEC\x20\x48\x8B\x41\x10\x45\x33\xC9")
F_DEF(luaL_loadbufferx, "\x4C\x8B\xDC\x49\x89\x5B\x08\x57\x48\x81\xEC\xF0\x00\x00\x00\x4D\x85\xC9\x48\x89\x54\x24\x20\x48\x8D\x05\x32\x06\x00\x00")
F_DEF(lj_err_run, "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x4C\x8B\x51\x10")
F_DEF(lj_err_argtype, "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x48\x63\xDA")
F_DEF(err_argmsg, "\x48\x89\x5C\x24\x10\x48\x89\x74\x24\x18\x57\x48\x83\xEC\x30\x8B\xDA")

F_DEF(lua_newstate, "\x48\x89\x5C\x24\x20\x55\x56\x41\x56\x48\x83\xEC\x50")
F_DEF(lua_close, "\x48\x89\x5C\x24\x08\x48\x89\x6C\x24\x10\x48\x89\x74\x24\x18\x57\x48\x83\xEC\x20\x48\x8B\x79\x10\x48\x8B\x9F\xC0\x00\x00\x00")
F_DEF(lua_newthread, "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x48\x8B\x51\x10")
F_DEF(lua_atpanic, "\x4C\x8B\x41\x10\x49\x8B\x80\x60\x01\x00\x00")

F_DEF(lua_gettop, "\x48\x8B\x41\x28\x48\x2B\x41\x20")
F_DEF(lua_settop, "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x48\x63\xFA")
F_DEF(lua_pushvalue, "\x48\x83\xEC\x28\x4C\x8B\xD1\xE8\x2A\x2A\x2A\x2A\x49\x8B\x52\x28")
F_DEF(lua_remove, "\x4C\x8B\xC1\x85\xD2\x7E\x2A\x48\x8B\x41\x20\x48\x8B\x49\x28")
F_DEF(lua_insert, "\x4C\x8B\xC9\x85\xD2")
//F_N(lua_replace, 2, ?)
F_DEF(lua_checkstack, "\x48\x83\xEC\x28\x4C\x8B\xC9")
F_DEF(lua_xmove, "\x48\x3B\xCA\x74\x2A\x48\x89\x5C\x24\x08")

F_DEF(lua_isnumber, "\x48\x83\xEC\x28\xE8\x2A\x2A\x2A\x2A\x48\x8B\x08\x48\x8B\xC1\x48\xC1\xF8\x2F\x83\xF8\xF2")
F_DEF(lua_isstring, "\x48\x83\xEC\x28\xE8\x2A\x2A\x2A\x2A\x48\x8B\x08\x48\xC1\xF9\x2F")
F_DEF(lua_iscfunction, "\x48\x83\xEC\x28\xE8\x2A\x2A\x2A\x2A\x48\x8B\x08\x48\x8B\xC1\x48\xC1\xF8\x2F\x83\xF8\xF7")
//F_N(lua_isuserdata, 2, ?)
F_DEF(lua_type, "\x48\x83\xEC\x28\x4C\x8B\xD1\xE8\x2A\x2A\x2A\x2A\x4C\x8B\xD8")
F_DEF(lua_typename, "\x48\x63\xC2\x48\x8D\x0D\x2A\x2A\x0B\x00")

F_DEF(lua_equal, "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x45\x8B\xD0\x48\x8B\xD9")
//F_N(lua_rawequal, 3, ?)
F_DEF(lua_lessthan, "\x40\x53\x48\x83\xEC\x20\x45\x8B\xD0")

F_DEF(lua_tonumber, "\x48\x83\xEC\x28\xE8\x2A\x2A\x2A\x2A\x48\x8B\x08\x48\x8B\xD1\x48\xC1\xFA\x2F\x83\xFA\xF2\x77\x2A")
F_DEF(lua_tointeger, "\x48\x83\xEC\x28\xE8\x2A\x2A\x2A\x2A\x48\x8B\x08\x48\x8B\xD1\x48\xC1\xFA\x2F\x83\xFA\xF2\x73\x2A")
F_DEF(lua_toboolean, "\x48\x83\xEC\x28\xE8\x2A\x2A\x2A\x2A\x48\x8B\x08\x33\xC0")
F_DEF(lua_tolstring, "\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x57\x48\x83\xEC\x20\x49\x8B\xF8\x8B\xDA\x48\x8B\xF1\xE8\x2A\x2A\x2A\x2A")
F_DEF(lua_objlen, "\x40\x53\x48\x83\xEC\x20\x4C\x8B\xD1\xE8\x2A\x2A\x2A\x2A")
//F_N(lua_tocfunction, 2, ?)
F_DEF(lua_touserdata, "\x48\x83\xEC\x28\x4C\x8B\xD1\xE8\x2A\x2A\x2A\x2A\x48\x8B\x10")
//F_N(lua_tothread, 2, ?)
//F_N(lua_topointer, 2, ?)

F_DEF(lua_pushnil, "\x48\x8B\x41\x28\x48\xC7\x00\xFF\xFF\xFF\xFF\x48\x83\x41\x28\x08")
F_DEF(lua_pushnumber, "\x48\x8B\x41\x28\xF2\x0F\x11\x08")
F_DEF(lua_pushinteger, "\x48\x8B\x41\x28\x0F\x57\xC0")
F_DEF(lua_pushlstring, "\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x57\x48\x83\xEC\x20\x4C\x8B\x49\x10\x49\x8B\xF8")
F_DEF(lua_pushstring, "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x48\x8B\xFA\x48\x8B\xD9\x48\x85\xD2")
F_DEF(lua_pushvfstring, "\x40\x53\x55\x48\x83\xEC\x48\x48\x8B\x59\x10")
// F_N(lua_pushfstring, 2, "\x48\x89\x54\x24\x10\x4C\x89\x44\x24\x18\x4C\x89\x4C\x24\x20\x53\x48\x83\xEC\x20\x4C\x8B\x41\x10")
F_DEF(lua_pushcclosure, "\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x57\x48\x83\xEC\x20\x48\x8B\xD9\x49\x63\xF8")
F_DEF(lua_pushboolean, "\x48\x8B\x41\x28\x45\x33\xC0")
F_DEF(lua_pushlightuserdata, "\x40\x53\x48\x83\xEC\x20\x48\x8B\xD9\xE8\x2A\x2A\x2A\x2A\x48\x8B\x53\x28")
F_DEF(lua_pushthread, "\x40\x53\x48\x83\xEC\x20\x48\xB8\x00\x00\x00\x00\x00\x80\xFC\xFF")

F_DEF(lua_gettable, "\x40\x53\x48\x83\xEC\x20\x48\x8B\xD9\xE8\x2A\x2A\x2A\x2A\x4C\x8B\x43\x28\x48\x8B\xD0\x49\x83\xE8\x08")
F_DEF(lua_getfield, "\x48\x89\x5C\x24\x10\x57\x48\x83\xEC\x20\x4D\x8B\xD0")
F_DEF(lua_rawget, "\x40\x53\x48\x83\xEC\x20\x48\x8B\xD9\xE8\x2A\x2A\x2A\x2A\x4C\x8B\x43\x28\x48\x8B\xCB")
F_DEF(lua_rawgeti, "\x40\x53\x48\x83\xEC\x20\x4D\x63\xD0")
F_DEF(lua_createtable, "\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x57\x48\x83\xEC\x20\x4C\x8B\x49\x10\x41\x8B\xF8")
F_DEF(lua_newuserdata, "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x4C\x8B\x41\x10")
F_DEF(lua_getmetatable, "\x48\x83\xEC\x28\x4C\x8B\xD1\xE8\x2A\x2A\x2A\x2A\x48\x8B\x08\x48\x8B\xC1\x48\xC1\xF8\x2F\x83\xF8\xF4")
F_DEF(lua_getfenv, "\x48\x83\xEC\x28\x4C\x8B\xD1\xE8\x2A\x2A\x2A\x2A\x48\x8B\x08\x48\x8B\xC1\x48\xC1\xF8\x2F\x83\xF8\xF7")

F_DEF(lua_settable, "\x40\x53\x48\x83\xEC\x20\x48\x8B\xD9\xE8\x2A\x2A\x2A\x2A\x4C\x8B\x43\x28\x48\x8B\xD0\x49\x83\xE8\x10")
F_DEF(lua_setfield, "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x4D\x8B\xD0\x48\x8B\xD9")
F_DEF(lua_rawset, "\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x57\x48\x83\xEC\x20\x48\x8B\xD9\xE8\x2A\x2A\x2A\x2A")
F_DEF(lua_rawseti, "\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x57\x48\x83\xEC\x20\x4D\x63\xD0")
F_DEF(lua_setmetatable, "\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x48\x89\x7C\x24\x18\x41\x56\x48\x83\xEC\x20\x48\x8B\xF9\xE8\x2A\x2A\x2A\x2A")
F_DEF(lua_setfenv, "\x40\x53\x48\x83\xEC\x20\x48\x8B\xD9\xE8\x2A\x2A\x2A\x2A\x4C\x8B\x4B\x28")

F_DEF(lua_call, "\x48\x63\xC2\x4C\x8B\xD1")
F_DEF(lua_pcall, "\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x57\x48\x83\xEC\x20\x48\x8B\x59\x10\x41\x8B\xF0")
F_DEF(lua_cpcall, "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x48\x8B\x59\x10\x4C\x8D\x0D\xDB\xF4\xFF\xFF")
F_DEF(lua_load, "\x4C\x8B\xDC\x49\x89\x5B\x08\x57\x48\x81\xEC\xF0\x00\x00\x00\x4D\x85\xC9\x48\x89\x54\x24\x20\x48\x8D\x05\xE2\x06\x00\x00")
//F_N(lua_dump, 3, ?)

//F_N(lua_yield, 2, ?)
//F_N(lua_resume, 2, ?)
//F_N(lua_status, 1, ?)

F_DEF(lua_gc, "\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x57\x48\x83\xEC\x20\x48\x8B\x59\x10\x33\xFF")
//F_DEF(lua_error, 0x58170) // "\x48\x83\xEC\x28\xE8\x2A\x2A\x2A\x2A\xCC" function is too short...
F_DEF(lua_next, "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x48\x8B\xD9\xE8\x2A\x2A\x2A\x2A\x48\x8B\x53\x28")
F_DEF(lua_concat, "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x8B\xFA\x48\x8B\xD9\x83\xFA\x02")
//F_N(lua_getallocf, 2, ?)
//F_N(lua_setallocf, 3, ? )

F_DEF(luaL_openlib, "\x48\x89\x5C\x24\x20\x55\x56\x41\x56\x48\x83\xEC\x20")
//F_DEF(luaL_register, 0x5BDB0) // "\x45\x33\xC9\xE9\x2A\x2A\x2A\x2A\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC" function is too short...
//F_N(luaL_getmetafield, 3, ?)
F_DEF(luaL_callmeta, "\x48\x89\x5C\x24\x10\x48\x89\x6C\x24\x18\x56\x57\x41\x56\x48\x83\xEC\x20\x48\x8B\x59\x10\x48\x8B\xF1")
//F_DEF(luaL_typerror, 0x58100) // "\x48\x83\x23\xEC\x28\xE8\x2A\x2A\x2A\x2A\xCC" function is too short...
//F_DEF(luaL_argerror, 0x580C0) // "\x48\x83\xEC\x28\xE8\x2A\x2A\x2A\x2A\xCC" function is too short...
F_DEF(luaL_checklstring, "\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x57\x48\x83\xEC\x20\x49\x8B\xF0")
F_DEF(luaL_optlstring, "\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x57\x48\x83\xEC\x20\x49\x8B\xF1")
F_DEF(luaL_checknumber, "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x8B\xDA\x48\x8B\xF9\xE8\x2A\x2A\x2A\x2A\x48\x8B\x08\x4C\x8B\xC1\x49\xC1\xF8\x2F\x41\x83\xF8\xF2\x77\x2A\xF2\x0F\x10\x00\x48\x8B\x5C\x24\x30\x48\x83\xC4\x20\x5F\xC3\x41\x83\xF8\xFB")
F_DEF(luaL_optnumber, "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x8B\xDA\x48\x8B\xF9\xE8\x2A\x2A\x2A\x2A\x48\x8B\x08\x4C\x8B\xC1\x49\xC1\xF8\x2F\x41\x83\xF8\xF2\x77\x2A\xF2\x0F\x10\x00\x48\x8B\x5C\x24\x30\x48\x83\xC4\x20\x5F\xC3\x48\x83\xF9\xFF")
//F_N(luaL_checkinteger, 2, ?)
F_DEF(luaL_optinteger, "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x4D\x8B\xD0\x8B\xDA")

F_DEF(luaL_checkstack, "\x48\x83\xEC\x28\x4C\x8B\xD1\x81\xFA\x40\x1F\x00\x00")
F_DEF(luaL_checktype, "\x40\x53\x48\x83\xEC\x20\x45\x8B\xD8")
//F_N(luaL_checkany, 3, ?)
F_DEF(luaL_newmetatable, "\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x57\x48\x83\xEC\x20\x48\x8B\x41\x10\x48\x8B\xD9")
F_DEF(luaL_checkudata, "\x48\x89\x5C\x24\x08\x48\x89\x6C\x24\x10\x48\x89\x74\x24\x18\x48\x89\x7C\x24\x20\x41\x56\x48\x83\xEC\x20\x49\x8B\xD8")
F_DEF(luaL_where, "\x40\x53\x48\x83\xEC\x20\x4C\x8D\x44\x24\x40")
//F_N(luaL_error, 2, "\x40\x53\x48\x83\xEC\x20\x4C\x8D\x44\x24\x40")
//F_N(luaL_checkoption, 4, ?)
F_DEF(luaL_ref, "\x48\x89\x5C\x24\x10\x57\x48\x83\xEC\x20\x8D\x82\x0F\x27\x00\x00")
F_DEF(luaL_unref, "\x45\x85\xC0\x78\x2A\x48\x89\x5C\x24\x08")
F_DEF(luaL_loadfile, "\x40\x53\x56\x57\x48\x81\xEC\x00\x03\x00\x00")
//F_N(luaL_loadbuffer, 4, ?)
F_DEF(luaL_loadstring, "\x48\x89\x5C\x24\x08\x57\x48\x81\xEC\xF0\x00\x00\x00")
F_DEF(luaL_newstate, "\x48\x83\xEC\x28\x33\xD2\xB9\x50\x4D\x00\x00")
F_DEF(luaL_gsub, "\x40\x55\x53\x56\x57\x41\x54\x41\x55\x41\x56\x41\x57\x48\x8D\xAC\x24\xA8\xFE\xFF\xFF")
F_DEF(luaL_findtable, "\x48\x89\x5C\x24\x08\x48\x89\x6C\x24\x10\x48\x89\x74\x24\x18\x57\x41\x56\x41\x57\x48\x83\xEC\x20\x45\x8B\xF1")

F_DEF(luaL_buffinit, "\x48\x8D\x42\x18\x48\x89\x4A\x10")
F_DEF(luaL_prepbuffer, "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x20\x4C\x8B\x01")
F_DEF(luaL_addlstring, "\x40\x55\x57\x41\x57\x48\x83\xEC\x20\x48\x8B\xF9")
//F_N(luaL_addstring, 2, ?)
F_DEF(luaL_addvalue, "\x48\x89\x6C\x24\x20\x57\x48\x83\xEC\x20\x48\x8B\x69\x10")
F_DEF(luaL_pushresult, "\x48\x89\x74\x24\x10\x48\x89\x7C\x24\x18\x41\x56\x48\x83\xEC\x20\x4C\x8B\x01")

F_DEF(luaopen_base, "\x48\x89\x5C\x24\x08\x48\x89\x6C\x24\x10\x48\x89\x74\x24\x18\x57\x48\x83\xEC\x20\x48\x8B\x71\x48")
F_DEF(luaopen_io, "\x48\x89\x5C\x24\x08\x48\x89\x6C\x24\x10\x48\x89\x74\x24\x18\x57\x48\x83\xEC\x20\x4C\x8D\x0D\x2A\x2A\x0A\x00")
//F_N(luaopen_os, 1, ?)
F_DEF(luaopen_string, "\x48\x89\x5C\x24\x08\x48\x89\x6C\x24\x10\x48\x89\x74\x24\x18\x57\x48\x83\xEC\x20\x4C\x8D\x0D\x2A\x2A\x0A\x00")
F_DEF(luaopen_math, "\x40\x53\x48\x83\xEC\x20\xBA\x20\x00\x00\x00")
F_DEF(luaopen_debug, "\x48\x83\xEC\x28\x4C\x8D\x0D\x2A\x2A\x0A\x00")
F_DEF(luaopen_package, "\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x48\x89\x7C\x24\x18\x41\x56\x48\x83\xEC\x30\x48\x8D\x15\x2A\x2A\x0A\x00")
F_DEF(luaopen_bit, "\x48\x83\xEC\x28\x4C\x8D\x0D\x05\x35\x0A\x00") // find by "rshift"
F_DEF(luaopen_ffi, "\x48\x89\x5C\x24\x08\x48\x89\x6C\x24\x10\x48\x89\x74\x24\x18\x57\x41\x56\x41\x57\x48\x83\xEC\x20\x48\x8B\xE9") // find by "Windows" & "x64"
F_DEF(luaopen_string_buffer, "\x40\x53\x48\x83\xEC\x20\x4C\x8D\x0D\xD3\x11\x09\x00") // called in luaopen_string

F_DEF(luaJIT_setmode, "\x48\x89\x6C\x24\x10\x48\x89\x74\x24\x18\x57\x48\x83\xEC\x20\x48\x8B\x79\x10\x4C\x8B\xC9")

F_DEF(lua_getstack, "\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x48\x89\x7C\x24\x18\x4C\x8B\x59\x38")
F_DEF(lua_getinfo, "\x48\x89\x5C\x24\x08\x44\x89\x4C\x24\x20\x55")
F_DEF(lua_getlocal, "\x40\x53\x48\x83\xEC\x20\x48\xC7\x44\x24\x38\x00\x00\x00\x00")
F_DEF(lua_setlocal, "\x40\x53\x48\x83\xEC\x20\x45\x8B\xC8")
F_DEF(lua_getupvalue, "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x30\x48\x8B\xD9\x45\x8D\x50\xFF")
F_DEF(lua_setupvalue, "\x48\x89\x5C\x24\x08\x57\x48\x83\xEC\x30\x45\x8B\xD0")

F_DEF(lua_sethook, "\x48\x83\xEC\x28\x48\x8B\x49\x10")
F_DEF(lua_gethook, "\x48\x8B\x41\x10\x48\x8B\x80\x50\x01\x00\x00")
F_DEF(lua_gethookmask, "\x48\x8B\x41\x10\x0F\xB6\x80\x91\x00\x00\x00")
F_DEF(lua_gethookcount, "\x48\x8B\x41\x10\x8B\x80\x4C\x01\x00\x00")

//F_N(luaL_openlibs, 1, ?)

```

`vscript_lua51.cpp`:

```cpp
#include <Windows.h>
#include <mutex>

extern "C" {
#define LUA_BUILD_AS_DLL
#define LUA_CORE
#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
}

#include "metahook.h"

inline ptrdiff_t FindFunction(const char* funcname, ptrdiff_t offset)
{
	auto hModule = LoadLibrary("vscript2.dll");
	BYTE* pBase = (BYTE*)MH_GetModuleBase(hModule);
	auto dwModuleSize = MH_GetModuleSize(hModule);
	auto addr = pBase + offset;
	return (ptrdiff_t)addr;
}

template<size_t N>
inline ptrdiff_t FindFunction(const char *funcname, const char(&pattern)[N])
{
	auto hModule = LoadLibrary("vscript2.dll");
	BYTE* pBase = (BYTE*)MH_GetModuleBase(hModule);
	auto dwModuleSize = MH_GetModuleSize(hModule);
	VirtualProtect(pBase, dwModuleSize, PAGE_EXECUTE_READWRITE, NULL);
	auto addr = MH_SearchPattern(pBase, dwModuleSize, pattern, N - 1);
	if (!addr)
	{
		char buffer[256];
		snprintf(buffer, sizeof(buffer), "Error: signature not found for %s", funcname);
		MessageBoxA(NULL, buffer, "vscript_lua51", MB_ICONINFORMATION);
	}
	return (ptrdiff_t)addr;
}

#define F_DEF(FUNCNAME, ...) ptrdiff_t g_addr_##FUNCNAME;
#include "signatures.h"
#undef F_DEF

bool SearchSignatures()
{
	bool failed = false;
#define F_DEF(FUNCNAME, ...) \
	if(g_addr_##FUNCNAME == 0) \
	{ \
		g_addr_##FUNCNAME = FindFunction(#FUNCNAME, __VA_ARGS__); \
		failed = failed || (g_addr_##FUNCNAME == 0); \
	}

#include "signatures.h"
#undef F_DEF
	return !failed;
}
std::once_flag g_bSearchSignaturesCalled;

typedef union TValue TValue;
typedef const TValue cTValue;

// declearation for internal methods
static TValue* index2adr(lua_State* L, int idx);
int lj_obj_equal(cTValue* o1, cTValue* o2);
void lj_err_callermsg(lua_State* L, const char* msg);
int luaL_loadbufferx(lua_State* L, const char* buff, size_t sz, const char* name, const char* mode);
void lj_err_run(lua_State* L);
void lj_err_argtype(lua_State* L, int narg, const char* xname);
static void err_argmsg(lua_State* L, int narg, const char* msg);

// take back luajit functions
extern "C" {
	LUALIB_API int luaopen_bit(lua_State* L);
	//LUALIB_API int luaopen_jit(lua_State* L);
	LUALIB_API int luaopen_ffi(lua_State* L);
	LUALIB_API int luaopen_string_buffer(lua_State* L);

	LUA_API int luaJIT_setmode(lua_State* L, int idx, int mode);
}

// implementation for default functions

LUA_API void (lua_replace)(lua_State* L, int idx) 
{
	// TODO : is this right?
	lua_remove(L, idx);
	lua_insert(L, idx);
}

LUA_API int (lua_isuserdata)(lua_State* L, int idx)
{
	return lua_type(L, idx) == LUA_TLIGHTUSERDATA || lua_type(L, idx) == LUA_TUSERDATA;
}

LUA_API int (lua_rawequal)(lua_State* L, int idx1, int idx2)
{
	TValue* ptr1 = index2adr(L, idx1);
	TValue* ptr2 = index2adr(L, idx2);

	BYTE* gState = *(BYTE**)((BYTE*)L + 0x10);
	void* luaNull = (void*)(gState + 0xf8);

	if (ptr1 != luaNull && ptr2 != luaNull) {
		return lj_obj_equal(ptr1, ptr2);
	}
	return false;
}

#define LJ_TFUNC		(~8u)
#define itype(o)	((uint32_t)(*(int64_t *)(o) >> 47))
#define tvisfunc(o)	(itype(o) == LJ_TFUNC)
#define LJ_GCVMASK 0x7FFFFFFFFFFFULL

LUA_API lua_CFunction(lua_tocfunction) (lua_State* L, int idx)
{
	TValue* o = index2adr(L, idx);
	uintptr_t gcptr = (*(int64_t *)o & LJ_GCVMASK);

	if (tvisfunc(o)) {
		BYTE op = **(BYTE**)(gcptr + 32);
		if (op == 95 || op == 96)
			return (lua_CFunction)(gcptr + 40);
	}
	return nullptr;
}

LUA_API lua_State* (lua_tothread)(lua_State* L, int idx)
{
	// TODO : not yet implemented
	abort();
}

LUA_API const void* (lua_topointer)(lua_State* L, int idx)
{
	// TODO : not yet implemented
	abort();
}

// implementation for other apis
LUA_API const char* (lua_pushfstring)(lua_State* L, const char* fmt, ...)
{
	const char* ret;
	va_list argp;
	va_start(argp, fmt);
	ret = lua_pushvfstring(L, fmt, argp);
	va_end(argp);
	return ret;
}

LUA_API int (lua_dump)(lua_State* L, lua_Writer writer, void* data)
{
	// TODO : not yet implemented
	return luaL_error(L, "lua_dump : not yet implemented");
}

LUA_API int  (lua_yield)(lua_State* L, int nresults)
{
	// TODO : not yet implemented
	abort();
}

LUA_API int  (lua_resume)(lua_State* L, int narg)
{
	// TODO : not yet implemented
	abort();
}

LUA_API int  (lua_status)(lua_State* L)
{
	// TODO : not yet implemented
	abort();
}

LUA_API lua_Alloc(lua_getallocf) (lua_State* L, void** ud)
{
  	BYTE* gState = *(BYTE**)((BYTE*)L + 0x10);
	if (ud != nullptr) {
    		*ud = *(void**)(gState + 0x18);
	}
  	return *(lua_Alloc*)(gState + 0x10);
}

LUA_API void lua_setallocf(lua_State* L, lua_Alloc f, void* ud)
{
	BYTE* gState = *(BYTE**)((BYTE*)L + 0x10);
	*(void**)(gState + 0x18) = ud;
	*(lua_Alloc*)(gState + 0x10) = f;
}

LUALIB_API int (luaL_getmetafield)(lua_State* L, int obj, const char* e)
{
	if (!lua_getmetatable(L, obj))  /* no metatable? */
		return 0;
	lua_pushstring(L, e);
	lua_rawget(L, -2);
	if (lua_isnil(L, -1)) {
		lua_pop(L, 2);  /* remove metatable and metafield */
		return 0;
	}
	else {
		lua_remove(L, -2);  /* remove only metatable */
		return 1;
	}
}

LUALIB_API lua_Integer(luaL_checkinteger) (lua_State* L, int numArg)
{
	return luaL_optinteger(L, numArg, 0);
}

LUALIB_API void (luaL_checkany)(lua_State* L, int narg)
{
	if (lua_type(L, narg) == LUA_TNONE)
	{
		luaL_argerror(L, narg, "value expected");
	}
}

LUALIB_API int (luaL_error)(lua_State* L, const char* fmt, ...) // variadic
{
	const char* msg;
	va_list argp;
	va_start(argp, fmt);
	msg = lua_pushvfstring(L, fmt, argp);
	va_end(argp);
	lj_err_callermsg(L, msg);
	return 0;  /* unreachable */
}

LUALIB_API int (luaL_checkoption)(lua_State* L, int narg, const char* def, const char* const lst[])
{
	ptrdiff_t i;
	const char* s = lua_tolstring(L, narg, NULL);
	if (s == NULL && (s = def) == NULL)
		luaL_typerror(L, narg, lua_typename(L, LUA_TSTRING));
	for (i = 0; lst[i]; i++)
		if (strcmp(lst[i], s) == 0)
			return (int)i;
	return luaL_argerror(L, narg, lua_pushfstring(L, "invalid option %s", s));
}

LUALIB_API int (luaL_loadbuffer)(lua_State* L, const char* buff, size_t sz, const char* name) // not found
{
	return luaL_loadbufferx(L, buff, sz, name, NULL);
}

LUALIB_API int (luaopen_os)(lua_State* L) // not found
{
	return luaL_error(L, "luaopen_os : not yet implemented");
}

LUALIB_API int (luaopen_jit)(lua_State* L) // not found
{
	return luaL_error(L, "luaopen_jit : not yet implemented");
}

LUALIB_API void (luaL_openlibs)(lua_State* L) // inlined
{
	luaL_error(L, "luaopen_os : not yet implemented");
}

LUA_API int lua_error(lua_State* L)
{
	lj_err_run(L);
	return 0;  /* unreachable */
}

LUALIB_API void luaL_register(lua_State* L, const char* libname, const luaL_Reg* l)
{
	luaL_openlib(L, libname, l, 0);
}

LUALIB_API int luaL_argerror(lua_State* L, int narg, const char* msg)
{
	err_argmsg(L, narg, msg);
	return 0;  /* unreachable */
}

LUALIB_API int luaL_typerror(lua_State* L, int narg, const char* xname)
{
	lj_err_argtype(L, narg, xname);
	return 0;  /* unreachable */
}

// find signature

template<class T> struct TypeIdentity { using type = T; };
template<int N> struct IntWrapper { static constexpr int value = N; };
struct Invalid {};
template<size_t N, class...> struct Varadaic_GetN : TypeIdentity<Invalid> {};
template<class First, class...Rest> struct Varadaic_GetN<0, First, Rest...> : TypeIdentity<First> {};
template<size_t N, class First, class...Rest> struct Varadaic_GetN<N, First, Rest...> : Varadaic_GetN<N - 1, Rest...> {};
template<class F> struct F_ReturnType;
template<class Ret, class...Arg> struct F_ReturnType<Ret(Arg...)> : TypeIdentity<Ret> {};
template<class F, size_t N> struct F_ArgType;
template<class Ret, size_t N, class...Arg> struct F_ArgType<Ret(Arg...), N> : Varadaic_GetN<N, Arg...> {};
template<class F> struct F_ArgNum;
template<class Ret, class...Arg> struct F_ArgNum<Ret(Arg...)> : IntWrapper<sizeof...(Arg)> {};

#define PP_TUPLE_FIRST(X, ...) X
#define PP_TUPLE_REST(X, ...) __VA_ARGS__
#define PP_TUPLE_INVOKE(X, TUPLE) X TUPLE

#define PP_CAT(a, b) PP_CAT_I(a, b)
#define PP_CAT_I(a, b) PP_CAT_II(~, a ## b)
#define PP_CAT_II(p, res) res
#define PP_COMMA() ,
#define PP_EMPTY() 
#define PP_REPEAT_0(CTX, PATTERN, JOINER)
#define PP_REPEAT_1(CTX, PATTERN, JOINER) PATTERN(CTX, 0)
#define PP_REPEAT_2(CTX, PATTERN, JOINER) PP_REPEAT_1(CTX, PATTERN, JOINER) JOINER() PATTERN(CTX, 1)
#define PP_REPEAT_3(CTX, PATTERN, JOINER) PP_REPEAT_2(CTX, PATTERN, JOINER) JOINER() PATTERN(CTX, 2)
#define PP_REPEAT_4(CTX, PATTERN, JOINER) PP_REPEAT_3(CTX, PATTERN, JOINER) JOINER() PATTERN(CTX, 3)
#define PP_REPEAT_5(CTX, PATTERN, JOINER) PP_REPEAT_4(CTX, PATTERN, JOINER) JOINER() PATTERN(CTX, 4)
#define PP_REPEAT_6(CTX, PATTERN, JOINER) PP_REPEAT_5(CTX, PATTERN, JOINER) JOINER() PATTERN(CTX, 5)
#define PP_REPEAT_N(CTX, PATTERN, JOINER, N) PP_TUPLE_INVOKE(PP_CAT(PP_REPEAT_,N),(CTX, PATTERN, JOINER))
#define PP_REPEAT_MAX 6

#define ARG_N(FUNCTYPE, N) _##N
#define ARG_DEF_N(FUNCTYPE, N) typename F_ArgType<FUNCTYPE, N>::type ARG_N(FUNCTYPE, N)
#define F_N(FUNCNAME, N, ...) \
extern "C" LUA_API typename F_ReturnType<decltype(FUNCNAME)>::type (FUNCNAME)(PP_REPEAT_N(FUNCNAME, ARG_DEF_N, PP_COMMA, N)) \
{ \
	static const auto pfn = (decltype(FUNCNAME)*)FindFunction(#FUNCNAME, __VA_ARGS__); \
	return pfn(PP_REPEAT_N(FUNCNAME, ARG_N, PP_COMMA, N)); \
}

#define F_DEF_HELPER_N(FUNCNAME, N) \
template<class DependentFunctionType> struct PP_CAT(FUNCNAME,_FuncDefHelper)<DependentFunctionType, N> \
{ \
	friend typename F_ReturnType<DependentFunctionType>::type \
		(FUNCNAME)(PP_REPEAT_N(DependentFunctionType, ARG_DEF_N, PP_COMMA, N)) \
	{ \
		return PP_CAT(FUNCNAME,_FindFunctionHelper)()(PP_REPEAT_N(DependentFunctionType, ARG_N, PP_COMMA, N)); \
	} \
};

#define F_DEF(FUNCNAME, ...) \
static decltype(FUNCNAME) *PP_CAT(FUNCNAME,_FindFunctionHelper) () \
{ \
	std::call_once(g_bSearchSignaturesCalled, SearchSignatures); \
	static auto pfn = reinterpret_cast<decltype(FUNCNAME)*>(g_addr_##FUNCNAME); \
	return pfn; \
} \
template<class DependentFunctionType, int ArgNum> struct PP_CAT(FUNCNAME,_FuncDefHelper); \
PP_REPEAT_N(FUNCNAME, F_DEF_HELPER_N, PP_EMPTY, PP_REPEAT_MAX) \
template struct PP_CAT(FUNCNAME,_FuncDefHelper)<decltype(FUNCNAME), F_ArgNum<decltype(FUNCNAME)>::value>;

#include "signatures.h"
#undef F_DEF
```

`vscript_patch.cpp`:

```cpp

#include <assert.h>
#include <Windows.h>

extern "C" {
#define LUA_BUILD_AS_DLL
#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
}

extern "C" {
    LUALIB_API int luaopen_ffi(lua_State* L);
    LUA_API int luaJIT_setmode(lua_State* L, int idx, int mode);
}

typedef void* (*CreateInterfaceFn)(const char *pName, int *pReturnCode);

struct AppSystemInfo_t
{
    const char* m_pModuleName;
    const char* m_pInterfaceName;
};

enum InitReturnVal_t
{
    INIT_FAILED = 0,
    INIT_OK,

    INIT_LAST_VAL,
};

enum AppSystemTier_t
{
    APP_SYSTEM_TIER0 = 0,
    APP_SYSTEM_TIER1,
    APP_SYSTEM_TIER2,
    APP_SYSTEM_TIER3,

    APP_SYSTEM_TIER_OTHER,
};

enum BuildType_t
{
    kBuildTypeRelease = 2
};

class IAppSystem
{
public:
    // Here's where the app systems get to learn about each other
    virtual bool Connect( CreateInterfaceFn factory ) = 0;
    virtual void Disconnect() = 0;

    // Here's where systems can access other interfaces implemented by this object
    // Returns NULL if it doesn't implement the requested interface
    virtual void *QueryInterface( const char *pInterfaceName ) = 0;

    // Init, shutdown
    virtual InitReturnVal_t Init() = 0;
    virtual void Shutdown() = 0;
    virtual void PreShutdown() = 0;

    // Returns all dependent libraries
    virtual const AppSystemInfo_t* GetDependencies() = 0;

    // Returns the tier
    virtual AppSystemTier_t GetTier() = 0;

    // Reconnect to a particular interface
    virtual void Reconnect(CreateInterfaceFn factory, const char* pInterfaceName) = 0;

    // Returns whether or not the app system is a singleton
    virtual bool IsSingleton() = 0;

    // Source 2 Added
    virtual BuildType_t	GetBuildType() = 0;
};

enum ScriptLanguage_t
{
    SL_NONE,
    SL_LUA,

    SL_DEFAULT = SL_LUA
};

class IScriptVMPartA
{
public:
    virtual void DeleteThis() = 0; // ?
    virtual bool Init() = 0;
    virtual bool ConnectDebugger() = 0;
    virtual void DisconnectDebugger() = 0;

    virtual ScriptLanguage_t GetLanguage() = 0;
    virtual const char* GetLanguageName() = 0;

    virtual void* GetInternalVM() = 0;

    // TODO : more
};

class IScriptVM;
class IScriptDebugger;

class IScriptManager : public IAppSystem
{
public:
    virtual IScriptVM *CreateVM( ScriptLanguage_t language = SL_DEFAULT ) = 0;
    virtual void DestroyVM( IScriptVM * ) = 0;
    virtual IScriptDebugger* GetDebugger() = 0;
};
#define VSCRIPT_INTERFACE_VERSION		"VScriptManager010"

CreateInterfaceFn GetOrigFactory()
{
    auto dl = LoadLibrary("vscript2.dll");
    return (CreateInterfaceFn)GetProcAddress(dl, "CreateInterface");
}

IScriptManager *g_pScriptManager = nullptr;

class CScriptManagerExt : public IScriptManager
{
public:
    bool Connect( CreateInterfaceFn factory ) override
    {
        return g_pScriptManager->Connect(factory);
    }

    void Disconnect() override
    {
        return g_pScriptManager->Disconnect();
    }

    void *QueryInterface( const char *pInterfaceName ) override
    {
        return g_pScriptManager->QueryInterface(pInterfaceName);
    }

    InitReturnVal_t Init() override
    {
        return g_pScriptManager->Init();
    }

    void Shutdown() override
    {
        return g_pScriptManager->Shutdown();
    }

    void PreShutdown() override
    {
        return g_pScriptManager->PreShutdown();
    }

    const AppSystemInfo_t* GetDependencies() override
    {
        return g_pScriptManager->GetDependencies();
    }

    AppSystemTier_t GetTier() override
    {
        return g_pScriptManager->GetTier();
    }

    void Reconnect(CreateInterfaceFn factory, const char* pInterfaceName) override
    {
        return g_pScriptManager->Reconnect(factory, pInterfaceName);
    }

    bool IsSingleton() override
    {
        return g_pScriptManager->IsSingleton();
    }

    BuildType_t	GetBuildType() override
    {
        return g_pScriptManager->GetBuildType();
    }

    IScriptVM *CreateVM( ScriptLanguage_t language = SL_DEFAULT ) override
    {
        auto vm = g_pScriptManager->CreateVM(language);
        auto vm2 = (IScriptVMPartA*)vm;
        
        lua_State *L = (lua_State *)vm2->GetInternalVM();

        // moemod : turn on jit again
#define LUAJIT_MODE_OFF		0x0000	/* Turn feature off. */
#define LUAJIT_MODE_ON		0x0100	/* Turn feature on. */
#define LUAJIT_MODE_FLUSH	0x0200	/* Flush JIT-compiled code. */
        luaJIT_setmode(L, 0, LUAJIT_MODE_ON);

        lua_getglobal(L, "print"); // #1
        lua_pushstring(L, "vscript patch: hello, world !!!"); // #2
        lua_call(L, 1, 0); // #0
        
        // moemod hack : restore package
        // valve sets package.loaders[*] and package.loadlib to nil
        // here we are going to restore them

        lua_getglobal(L, "package"); // #1 = package
        lua_getfield(L, -1, "loaders"); // #2 = package.loaders
        lua_pushinteger(L, 2); // #3 = 2
        lua_gettable(L, -2); // #3 = package.loaders[2]

        int valve_loader_ref = luaL_ref(L, LUA_REGISTRYINDEX); // #2 = package.loaders
        lua_pop(L, 2); // #0

        lua_pushcfunction(L, luaopen_package); // #1
        lua_call(L, 0, 0); // #0

        lua_getglobal(L, "table"); // #1 = table
        lua_getfield(L, -1, "insert"); // #2 = table.insert
        lua_remove(L, -2); // #1 = table.insert

        lua_getglobal(L, "package"); // #2 = package
        lua_getfield(L, -1, "loaders"); // #3 = package.loaders
        lua_remove(L, -2); // #2 = package.loaders

        lua_pushinteger(L, 2); // #3 = 2
        lua_rawgeti(L, LUA_REGISTRYINDEX, valve_loader_ref); // #4 = valve_loader
        lua_call(L, 3, 0); // #0

        luaL_unref(L, LUA_REGISTRYINDEX, valve_loader_ref);

        // moemod hack : restore io
        // not working, use local io = require("cio")
        //lua_pushcfunction(L, luaopen_io);
        //lua_pushstring(L, "io");
        //lua_pcall(L, 1, 0, 0);
        
        // moemod hack : restore ffi
        // not working, use local io = require("cffi")
        //luaL_findtable(L, LUA_REGISTRYINDEX, "_PRELOAD", 1);
        //lua_pushcfunction(L, luaopen_ffi);
        //lua_setfield(L, -2, "ffi");
        //lua_pop(L, 1);
        
        return vm;
    }

    void DestroyVM( IScriptVM *vm ) override
    {
        return g_pScriptManager->DestroyVM(vm);
    }

    IScriptDebugger* GetDebugger() override
    {
        return g_pScriptManager->GetDebugger();
    }
} g_ScriptManagerExt;

#if defined( _WIN32 )

// Used for dll exporting and importing
#define  DLL_EXPORT   extern "C" __declspec( dllexport )
#define  DLL_IMPORT   extern "C" __declspec( dllimport )

// Can't use extern "C" when DLL exporting a class
#define  DLL_CLASS_EXPORT   __declspec( dllexport )
#define  DLL_CLASS_IMPORT   __declspec( dllimport )

// Can't use extern "C" when DLL exporting a global
#define  DLL_GLOBAL_EXPORT   extern __declspec( dllexport )
#define  DLL_GLOBAL_IMPORT   extern __declspec( dllimport )

#elif defined(_LINUX) || defined(__APPLE__)
// Used for dll exporting and importing
#define  DLL_EXPORT   extern "C" __attribute__ ((visibility("default")))
#define  DLL_IMPORT   extern "C"

// Can't use extern "C" when DLL exporting a class
#define  DLL_CLASS_EXPORT __attribute__ ((visibility("default")))
#define  DLL_CLASS_IMPORT

// Can't use extern "C" when DLL exporting a global
#define  DLL_GLOBAL_EXPORT   extern __attribute ((visibility("default")))
#define  DLL_GLOBAL_IMPORT   extern

#else
#error "Unsupported Platform."
#endif

// EXPORT
DLL_EXPORT void * CreateInterface(const char *pName, int *pReturnCode)
{
    static CreateInterfaceFn vscript_factory = GetOrigFactory();
    if(!strcmp(pName, VSCRIPT_INTERFACE_VERSION))
    {
        g_pScriptManager = (IScriptManager *)vscript_factory(pName, pReturnCode);
        return &g_ScriptManagerExt;
    }
    return vscript_factory(pName, pReturnCode);
}

```