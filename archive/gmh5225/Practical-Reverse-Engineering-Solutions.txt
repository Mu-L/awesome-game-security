Project Path: arc_gmh5225_Practical-Reverse-Engineering-Solutions_p9my6jk1

Source Tree:

```txt
arc_gmh5225_Practical-Reverse-Engineering-Solutions_p9my6jk1
├── ApcDumper
│   ├── ApcDumper.c
│   ├── ApcDumper.inf
│   ├── ApcDumper.vcxproj
│   ├── ApcDumper.vcxproj.filters
│   ├── ApcSignatures.h
│   └── README.md
├── DpcDumper
│   ├── DpcDumper.c
│   ├── DpcDumper.inf
│   ├── DpcDumper.vcxproj
│   ├── DpcDumper.vcxproj.filters
│   ├── DpcSignatures.h
│   └── README.md
├── NotifyRoutinesDumper
│   ├── NotifyRoutinesDumper.c
│   ├── NotifyRoutinesDumper.inf
│   ├── NotifyRoutinesDumper.vcxproj
│   ├── NotifyRoutinesDumper.vcxproj.filters
│   ├── README.md
│   ├── undocumented.c
│   └── undocumented.h
├── ObCallbacksDumper
│   ├── ObCallbacksDumper.cpp
│   ├── ObCallbacksDumper.hpp
│   ├── ObCallbacksDumper.inf
│   ├── ObCallbacksDumper.vcxproj
│   ├── ObCallbacksDumper.vcxproj.filters
│   ├── README.md
│   ├── ob_callbacks.cpp
│   └── ob_callbacks.hpp
├── Practical Reverse Engineering Solutions.sln
└── README.md

```

`ApcDumper/ApcDumper.c`:

```c
#include <ntddk.h>
#include <intrin.h>
#include "ApcSignatures.h"

void DriverUnload(_In_ PDRIVER_OBJECT DriverObject);
NTSTATUS DriverCreateClose(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp);

inline void ResolveKernelRoutines() {
	UNICODE_STRING InitializeApcRoutineName = RTL_CONSTANT_STRING(L"KeInitializeApc");
	KeInitializeApc = (KeInitializeApcFunc) MmGetSystemRoutineAddress(&InitializeApcRoutineName);

	UNICODE_STRING InsertApcRoutineName = RTL_CONSTANT_STRING(L"KeInsertQueueApc");
	KeInsertQueueApc = (KeInsertQueueApcFunc) MmGetSystemRoutineAddress(&InsertApcRoutineName);

	if (!KeInitializeApc || !KeInsertQueueApc) {
		DbgBreakPoint();
	}

	KdPrint(("[+] KeInsertQueueApc at: %p\n", KeInsertQueueApc));
	KdPrint(("[+] KeInitializeApc at: %p\n", KeInitializeApc));
}

void TestApc(
	PVOID SystemArgument1,
	PVOID SystemArgument2,
	PVOID SystemArgument3,
	PCONTEXT ContextRecord
) {
	KdPrint(("[+] TestApc called\n"));
	UNREFERENCED_PARAMETER(SystemArgument1);
	UNREFERENCED_PARAMETER(SystemArgument2);
	UNREFERENCED_PARAMETER(SystemArgument3);
	UNREFERENCED_PARAMETER(ContextRecord);
}

inline void DumpCurrentThreadApcs() {
	KThread* CurrentThread = (KThread*) KeGetCurrentThread();
	PKAPC_STATE ApcState = &CurrentThread->ApcState;

	KeAcquireSpinLockAtDpcLevel(&CurrentThread->ThreadLock);

	// dump kernelmode apc's in the current thread
	for (LIST_ENTRY* CurrentApcListEntry = ApcState->ApcListHead[KernelMode].Flink; CurrentApcListEntry != &ApcState->ApcListHead[KernelMode] ; CurrentApcListEntry = CurrentApcListEntry->Flink) {
		KAPC* CurrentApc = (KAPC*)((unsigned __int8*)CurrentApcListEntry - offsetof(KAPC, ApcListEntry));
		
		// KAPC->Reserved[2] == ApcRoutine
		KdPrint(("[+] KernelMode Apc: %p\n", CurrentApc->Reserved[2]));
	}

	// dump usermode apc's in the current thread
	for (LIST_ENTRY* CurrentApcListEntry = ApcState->ApcListHead[UserMode].Flink; CurrentApcListEntry != &ApcState->ApcListHead[UserMode]; CurrentApcListEntry = CurrentApcListEntry->Flink) {
		KAPC* CurrentApc = (KAPC*)((unsigned __int8*)CurrentApcListEntry - offsetof(KAPC, ApcListEntry));
		
		// KAPC->Reserved[2] == ApcRoutine
		KdPrint(("[+] UserMode Apc: %p\n", CurrentApc->Reserved[2]));
	}

	KeReleaseSpinLockFromDpcLevel(&CurrentThread->ThreadLock);
}

NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) {
	UNREFERENCED_PARAMETER(RegistryPath);
	KdPrint(("[+] Driver Entry\n"));

	DriverObject->DriverUnload = DriverUnload;
	DriverObject->MajorFunction[IRP_MJ_CREATE] = DriverCreateClose;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = DriverCreateClose;
	
	ResolveKernelRoutines();
	PKAPC Apc = ExAllocatePool(NonPagedPool, sizeof(KAPC));

	KIRQL OldIrql;
	KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

	// queue a test apc so we'll see something
	KeInitializeApc(Apc, KeGetCurrentThread(), OriginalApcEnvironment, (void*)ExFreePool, (void*)ExFreePool, (void*)TestApc, KernelMode, NULL);
	KeInsertQueueApc(Apc, NULL, NULL, 0);

	DumpCurrentThreadApcs();

	KeLowerIrql(OldIrql);

	return STATUS_SUCCESS;
}

NTSTATUS DriverCreateClose(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp) {
	UNREFERENCED_PARAMETER(DeviceObject);
	KdPrint(("[+] Driver Create\\Close Called\n"));

	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

void DriverUnload(_In_ PDRIVER_OBJECT DriverObject) {
	UNREFERENCED_PARAMETER(DriverObject);
	KdPrint(("[+] Driver Unload\n"));
}
```

`ApcDumper/ApcDumper.inf`:

```inf
;
; ApcDumper.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=ApcDumper.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
ApcDumper_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
ApcDumper.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%ApcDumper.DeviceDesc%=ApcDumper_Device, Root\ApcDumper ; TODO: edit hw-id

[ApcDumper_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
ApcDumper.sys

;-------------- Service installation
[ApcDumper_Device.NT.Services]
AddService = ApcDumper,%SPSVCINST_ASSOCSERVICE%, ApcDumper_Service_Inst

; -------------- ApcDumper driver install sections
[ApcDumper_Service_Inst]
DisplayName    = %ApcDumper.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\ApcDumper.sys

;
;--- ApcDumper_Device Coinstaller installation ------
;

[ApcDumper_Device.NT.CoInstallers]
AddReg=ApcDumper_Device_CoInstaller_AddReg
CopyFiles=ApcDumper_Device_CoInstaller_CopyFiles

[ApcDumper_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[ApcDumper_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[ApcDumper_Device.NT.Wdf]
KmdfService =  ApcDumper, ApcDumper_wdfsect
[ApcDumper_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "ApcDumper Installation Disk"
ApcDumper.DeviceDesc = "ApcDumper Device"
ApcDumper.SVCDESC = "ApcDumper Service"

```

`ApcDumper/ApcDumper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="ApcDumper.inf" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{87B1F195-0799-44B4-853B-2F0BC59102A6}</ProjectGuid>
    <TemplateGuid>{497e31cb-056b-4f31-abb8-447fd55ee5a5}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>ApcDumper</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WppEnabled>false</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WppEnabled>false</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ApcDumper.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ApcSignatures.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ApcDumper/ApcDumper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="ApcDumper.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ApcDumper.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ApcSignatures.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`ApcDumper/ApcSignatures.h`:

```h
#pragma once

typedef void (*KeInitializeApcFunc)(PRKAPC, PRKTHREAD, __int64, PVOID, PVOID, PVOID, KPROCESSOR_MODE, PVOID);
KeInitializeApcFunc KeInitializeApc;

typedef __int64 (*KeInsertQueueApcFunc)(PRKAPC, PVOID, PVOID, KPRIORITY);
KeInsertQueueApcFunc KeInsertQueueApc;

typedef enum _KAPC_ENVIRONMENT {
	OriginalApcEnvironment,
	AttachedApcEnvironment,
	CurrentApcEnvironment,
	InsertApcEnvironment
} KAPC_ENVIRONMENT;

// nameless struct/union
#pragma warning(disable : 4201)

//0x30 bytes (sizeof)
typedef struct _KAPC_STATE
{
    struct _LIST_ENTRY ApcListHead[2];                                      //0x0
    struct _KPROCESS* Process;                                              //0x20
    union
    {
        UCHAR InProgressFlags;                                              //0x28
        struct
        {
            UCHAR KernelApcInProgress : 1;                                    //0x28
            UCHAR SpecialApcInProgress : 1;                                   //0x28
        };
    };
    UCHAR KernelApcPending;                                                 //0x29
    union
    {
        UCHAR UserApcPendingAll;                                            //0x2a
        struct
        {
            UCHAR SpecialUserApcPending : 1;                                  //0x2a
            UCHAR UserApcPending : 1;                                         //0x2a
        };
    };
} KAPC_STATE, *PKAPC_STATE;

//0x5f0 bytes (sizeof)
typedef struct
{
    struct _DISPATCHER_HEADER Header;                                       //0x0
    VOID* SListFaultAddress;                                                //0x18
    ULONGLONG QuantumTarget;                                                //0x20
    VOID* InitialStack;                                                     //0x28
    VOID* volatile StackLimit;                                              //0x30
    VOID* StackBase;                                                        //0x38
    ULONGLONG ThreadLock;                                                   //0x40
    volatile ULONGLONG CycleTime;                                           //0x48
    ULONG CurrentRunTime;                                                   //0x50
    ULONG ExpectedRunTime;                                                  //0x54
    VOID* KernelStack;                                                      //0x58
    struct _XSAVE_FORMAT* StateSaveArea;                                    //0x60
    struct _KSCHEDULING_GROUP* volatile SchedulingGroup;                    //0x68
    char WaitRegister;                                                      //0x70
    volatile UCHAR Running;                                                 //0x71
    UCHAR Alerted[2];                                                       //0x72
    union
    {
        struct
        {
            ULONG AutoBoostActive : 1;                                        //0x74
            ULONG ReadyTransition : 1;                                        //0x74
            ULONG WaitNext : 1;                                               //0x74
            ULONG SystemAffinityActive : 1;                                   //0x74
            ULONG Alertable : 1;                                              //0x74
            ULONG UserStackWalkActive : 1;                                    //0x74
            ULONG ApcInterruptRequest : 1;                                    //0x74
            ULONG QuantumEndMigrate : 1;                                      //0x74
            ULONG UmsDirectedSwitchEnable : 1;                                //0x74
            ULONG TimerActive : 1;                                            //0x74
            ULONG SystemThread : 1;                                           //0x74
            ULONG ProcessDetachActive : 1;                                    //0x74
            ULONG CalloutActive : 1;                                          //0x74
            ULONG ScbReadyQueue : 1;                                          //0x74
            ULONG ApcQueueable : 1;                                           //0x74
            ULONG ReservedStackInUse : 1;                                     //0x74
            ULONG UmsPerformingSyscall : 1;                                   //0x74
            ULONG TimerSuspended : 1;                                         //0x74
            ULONG SuspendedWaitMode : 1;                                      //0x74
            ULONG SuspendSchedulerApcWait : 1;                                //0x74
            ULONG CetShadowStack : 1;                                         //0x74
            ULONG Reserved : 11;                                              //0x74
        };
        LONG MiscFlags;                                                     //0x74
    };
    union
    {
        struct
        {
            ULONG BamQosLevel : 2;                                            //0x78
            ULONG AutoAlignment : 1;                                          //0x78
            ULONG DisableBoost : 1;                                           //0x78
            ULONG AlertedByThreadId : 1;                                      //0x78
            ULONG QuantumDonation : 1;                                        //0x78
            ULONG EnableStackSwap : 1;                                        //0x78
            ULONG GuiThread : 1;                                              //0x78
            ULONG DisableQuantum : 1;                                         //0x78
            ULONG ChargeOnlySchedulingGroup : 1;                              //0x78
            ULONG DeferPreemption : 1;                                        //0x78
            ULONG QueueDeferPreemption : 1;                                   //0x78
            ULONG ForceDeferSchedule : 1;                                     //0x78
            ULONG SharedReadyQueueAffinity : 1;                               //0x78
            ULONG FreezeCount : 1;                                            //0x78
            ULONG TerminationApcRequest : 1;                                  //0x78
            ULONG AutoBoostEntriesExhausted : 1;                              //0x78
            ULONG KernelStackResident : 1;                                    //0x78
            ULONG TerminateRequestReason : 2;                                 //0x78
            ULONG ProcessStackCountDecremented : 1;                           //0x78
            ULONG RestrictedGuiThread : 1;                                    //0x78
            ULONG VpBackingThread : 1;                                        //0x78
            ULONG ThreadFlagsSpare : 1;                                       //0x78
            ULONG EtwStackTraceApcInserted : 8;                               //0x78
        };
        volatile LONG ThreadFlags;                                          //0x78
    };
    volatile UCHAR Tag;                                                     //0x7c
    UCHAR SystemHeteroCpuPolicy;                                            //0x7d
    UCHAR UserHeteroCpuPolicy : 7;                                            //0x7e
    UCHAR ExplicitSystemHeteroCpuPolicy : 1;                                  //0x7e
    union
    {
        struct
        {
            UCHAR RunningNonRetpolineCode : 1;                                //0x7f
            UCHAR SpecCtrlSpare : 7;                                          //0x7f
        };
        UCHAR SpecCtrl;                                                     //0x7f
    };
    ULONG SystemCallNumber;                                                 //0x80
    ULONG ReadyTime;                                                        //0x84
    VOID* FirstArgument;                                                    //0x88
    struct _KTRAP_FRAME* TrapFrame;                                         //0x90
    union
    {
        struct _KAPC_STATE ApcState;                                        //0x98
        struct
        {
            UCHAR ApcStateFill[43];                                         //0x98
            CHAR Priority;                                                  //0xc3
            ULONG UserIdealProcessor;                                       //0xc4
        };
    };
    volatile LONGLONG WaitStatus;                                           //0xc8
    struct _KWAIT_BLOCK* WaitBlockList;                                     //0xd0
    union
    {
        struct _LIST_ENTRY WaitListEntry;                                   //0xd8
        struct _SINGLE_LIST_ENTRY SwapListEntry;                            //0xd8
    };
    struct _DISPATCHER_HEADER* volatile Queue;                              //0xe8
    VOID* Teb;                                                              //0xf0
    ULONGLONG RelativeTimerBias;                                            //0xf8
    struct _KTIMER Timer;                                                   //0x100
    union
    {
        struct _KWAIT_BLOCK WaitBlock[4];                                   //0x140
        struct
        {
            UCHAR WaitBlockFill4[20];                                       //0x140
            ULONG ContextSwitches;                                          //0x154
        };
        struct
        {
            UCHAR WaitBlockFill5[68];                                       //0x140
            volatile UCHAR State;                                           //0x184
            CHAR Spare13;                                                   //0x185
            UCHAR WaitIrql;                                                 //0x186
            CHAR WaitMode;                                                  //0x187
        };
        struct
        {
            UCHAR WaitBlockFill6[116];                                      //0x140
            ULONG WaitTime;                                                 //0x1b4
        };
        struct
        {
            UCHAR WaitBlockFill7[164];                                      //0x140
            union
            {
                struct
                {
                    SHORT KernelApcDisable;                                 //0x1e4
                    SHORT SpecialApcDisable;                                //0x1e6
                };
                ULONG CombinedApcDisable;                                   //0x1e4
            };
        };
        struct
        {
            UCHAR WaitBlockFill8[40];                                       //0x140
            struct _KTHREAD_COUNTERS* ThreadCounters;                       //0x168
        };
        struct
        {
            UCHAR WaitBlockFill9[88];                                       //0x140
            struct _XSTATE_SAVE* XStateSave;                                //0x198
        };
        struct
        {
            UCHAR WaitBlockFill10[136];                                     //0x140
            VOID* volatile Win32Thread;                                     //0x1c8
        };
        struct
        {
            UCHAR WaitBlockFill11[176];                                     //0x140
            struct _UMS_CONTROL_BLOCK* Ucb;                                 //0x1f0
            struct _KUMS_CONTEXT_HEADER* volatile Uch;                      //0x1f8
        };
    };
    VOID* Spare21;                                                          //0x200
    struct _LIST_ENTRY QueueListEntry;                                      //0x208
    union
    {
        volatile ULONG NextProcessor;                                       //0x218
        struct
        {
            ULONG NextProcessorNumber : 31;                                   //0x218
            ULONG SharedReadyQueue : 1;                                       //0x218
        };
    };
    LONG QueuePriority;                                                     //0x21c
    struct _KPROCESS* Process;                                              //0x220
    union
    {
        struct _GROUP_AFFINITY UserAffinity;                                //0x228
        struct
        {
            UCHAR UserAffinityFill[10];                                     //0x228
            CHAR PreviousMode;                                              //0x232
            CHAR BasePriority;                                              //0x233
            union
            {
                CHAR PriorityDecrement;                                     //0x234
                struct
                {
                    UCHAR ForegroundBoost : 4;                                //0x234
                    UCHAR UnusualBoost : 4;                                   //0x234
                };
            };
            UCHAR Preempted;                                                //0x235
            UCHAR AdjustReason;                                             //0x236
            CHAR AdjustIncrement;                                           //0x237
        };
    };
    ULONGLONG AffinityVersion;                                              //0x238
    union
    {
        struct _GROUP_AFFINITY Affinity;                                    //0x240
        struct
        {
            UCHAR AffinityFill[10];                                         //0x240
            UCHAR ApcStateIndex;                                            //0x24a
            UCHAR WaitBlockCount;                                           //0x24b
            ULONG IdealProcessor;                                           //0x24c
        };
    };
    ULONGLONG NpxState;                                                     //0x250
    union
    {
        struct _KAPC_STATE SavedApcState;                                   //0x258
        struct
        {
            UCHAR SavedApcStateFill[43];                                    //0x258
            UCHAR WaitReason;                                               //0x283
            CHAR SuspendCount;                                              //0x284
            CHAR Saturation;                                                //0x285
            USHORT SListFaultCount;                                         //0x286
        };
    };
    union
    {
        struct _KAPC SchedulerApc;                                          //0x288
        struct
        {
            UCHAR SchedulerApcFill0[1];                                     //0x288
            UCHAR ResourceIndex;                                            //0x289
        };
        struct
        {
            UCHAR SchedulerApcFill1[3];                                     //0x288
            UCHAR QuantumReset;                                             //0x28b
        };
        struct
        {
            UCHAR SchedulerApcFill2[4];                                     //0x288
            ULONG KernelTime;                                               //0x28c
        };
        struct
        {
            UCHAR SchedulerApcFill3[64];                                    //0x288
            struct _KPRCB* volatile WaitPrcb;                               //0x2c8
        };
        struct
        {
            UCHAR SchedulerApcFill4[72];                                    //0x288
            VOID* LegoData;                                                 //0x2d0
        };
        struct
        {
            UCHAR SchedulerApcFill5[83];                                    //0x288
            UCHAR CallbackNestingLevel;                                     //0x2db
            ULONG UserTime;                                                 //0x2dc
        };
    };
    struct _KEVENT SuspendEvent;                                            //0x2e0
    struct _LIST_ENTRY ThreadListEntry;                                     //0x2f8
    struct _LIST_ENTRY MutantListHead;                                      //0x308
    UCHAR AbEntrySummary;                                                   //0x318
    UCHAR AbWaitEntryCount;                                                 //0x319
    UCHAR AbAllocationRegionCount;                                          //0x31a
    CHAR SystemPriority;                                                    //0x31b
    ULONG SecureThreadCookie;                                               //0x31c
    char LockEntries[0x240];                                                //0x320
    struct _SINGLE_LIST_ENTRY PropagateBoostsEntry;                         //0x560
    struct _SINGLE_LIST_ENTRY IoSelfBoostsEntry;                            //0x568
    UCHAR PriorityFloorCounts[16];                                          //0x570
    ULONG PriorityFloorSummary;                                             //0x580
    volatile LONG AbCompletedIoBoostCount;                                  //0x584
    volatile LONG AbCompletedIoQoSBoostCount;                               //0x588
    volatile SHORT KeReferenceCount;                                        //0x58c
    UCHAR AbOrphanedEntrySummary;                                           //0x58e
    UCHAR AbOwnedEntryCount;                                                //0x58f
    ULONG ForegroundLossTime;                                               //0x590
    union
    {
        struct _LIST_ENTRY GlobalForegroundListEntry;                       //0x598
        struct
        {
            struct _SINGLE_LIST_ENTRY ForegroundDpcStackListEntry;          //0x598
            ULONGLONG InGlobalForegroundList;                               //0x5a0
        };
    };
    LONGLONG ReadOperationCount;                                            //0x5a8
    LONGLONG WriteOperationCount;                                           //0x5b0
    LONGLONG OtherOperationCount;                                           //0x5b8
    LONGLONG ReadTransferCount;                                             //0x5c0
    LONGLONG WriteTransferCount;                                            //0x5c8
    LONGLONG OtherTransferCount;                                            //0x5d0
    struct _KSCB* QueuedScb;                                                //0x5d8
    volatile ULONG ThreadTimerDelay;                                        //0x5e0
    union
    {
        volatile LONG ThreadFlags2;                                         //0x5e4
        struct
        {
            ULONG PpmPolicy : 2;                                              //0x5e4
            ULONG ThreadFlags2Reserved : 30;                                  //0x5e4
        };
    };
    VOID* SchedulerAssist;                                                  //0x5e8
} KThread;

```

`ApcDumper/README.md`:

```md
# APC's
(Stolen from Practical Reverse Engineering):  
APCs are functions that execute in a particular thread context.  
They can be divided into two types: kernel-mode and user-mode.  
Kernel-mode APCs can be either normal or special; normal ones execute at PASSIVE_LEVEL,  
whereas special ones execute at APC_LEVEL (both execute in kernel mode).  
User APCs execute at PASSIVE_LEVEL in user mode when the thread is in an alertable state.  

## NtQueueApcThreadEx
```c
NTSTATUS NtQueueApcThreadEx(
	HANDLE ThreadHandle, 
	HANDLE MemoryReserveHandle, 
	PVOID ApcRoutine, 
	PVOID NormalContext, 
	PVOID SystemArgument1, 
	PVOID SystemArgument2
){
	_KTHREAD* CurrentThread = KeGetCurrentThread();
	_KTHREAD* TargetApcThread = NULL;
	PVOID MemoryReserver = NULL;
	KAPC* ApcObj = NULL;

	NTSTATUS status = ObReferenceObjectByHandle(
		ThreadHandle,
		THREAD_SET_CONTEXT,
		PsThreadType,
		CurrentThread->PreviousMode,
		&TargetApcThread,
		NULL
	);

	if (!NT_SUCCESS(status)) {
		// return the status from ObReferenceObjectByHandle
		goto cleanup;
	}

	if (!TargetApcThread->SystemThread) {
		status = STATUS_INVALID_HANDLE;
		goto cleanup;
	}

	_EWOW64PROCESS* Wow64Process = TargetApcThread->Process->Wow64Process;
	_EWOW64PROCESS* ApcStateWow64Process = TargetApcThread->ApcState.Process->Wow64Process;
	if (ApcStateWow64Process && 
		ApcStateWow64Process->Machine != IMAGE_FILE_MACHINE_I386 && 
		ApcStateWow64Process->Machine != IMAGE_FILE_MACHINE_ARMNT &&
		Wow64Process &&
		Wow64Process->Machine != IMAGE_FILE_MACHINE_AMD64 &&
		(__int64)ApcRoutine >> 2 > 0xffffffff
	) {
		status = STATUS_INVALID_HANDLE;
		goto cleanup;
	}

	PVOID KernelRoutine = NULL;
	PVOID RundownRoutine = NULL;

	if (MemoryReserveHandle && MemoryReserveHandle != (HANDLE) 1) {
		NTSTATUS status = ObReferenceObjectByHandle(
			MemoryReserveHandle,
			0x2, // non-documented access type
			PspMemoryReserveObjectTypes,
			CurrentThread->PreviousMode,
			&MemoryReserver,
			NULL
		);

		if(!NT_SUCCESS(status)){
			goto cleanup;
		}
		
		// this is my hypothesis for this check:
		// atomically, check if the MemoryReserver is occupied.
		// if it is: return an err.
		// else: atomically mark it as occupied and continue
		// 
		// (pseudocode)
		// struct MEMORY_RESERVER {
		//     unsigned int IsOccupied;
		//     char pad[4]; 
		//     char ReservedMemory[sizeof(RESERVED_TYPE)] 
		// } 
		//
		// unsigned int IsMemoryReserverOccupied = MemoryReserver->IsOccupied;
		// MemoryReserver->IsOccupied = MemoryReserver->IsOccupied == FALSE ? TRUE : FALSE;
		// if (!IsMemoryReserverOccupied) {...}
		if(!_InterlockedCompareExchange((unsigned int*)MemoryReserver, 1, 0)) {
			status = STATUS_INVALID_PARAMETER_2;
			goto cleanup;
		}

		ApcObj = (KAPC*) ((BYTE*)MemoryReserver + 8);
		RundownRoutine = PspUserApcReserveKernelRoutine;
		KernelRoutine = PspUserApcReserveKernelRoutine;
		// NTSTATUS __fastcall PspUserApcReserveKernelRoutine(void *ReservedObject) {
		//   MEMORY_RESERVER* MemoryReserver = (char *)ReservedObject - 8;
		//   MemoryReserver->IsOccupied = FALSE;
		//   return ObfDereferenceObject(MemoryReserver);
		// }
	}
	else {
		ApcObj = (KAPC*) ExAllocatePoolWithQuotaTag(sizeof(KAPC), NonPagedPoolNx, 'Psap');
		RundownRoutine = ExFreePool;
		KernelRoutine = ExFreePool;
	}


	KeInitializeApc(
		ApcObj, 
		TargetApcThread,
		OriginalApcEnvironment,
		(PKKERNEL_ROUTINE)ExFreePool,
		(PKRUNDOWN_ROUTINE)ExFreePool,
		ApcRoutine,
		UserMode,
		NormalContext
	);

	if(!KeInsertApcQueue(ApcObj, SystemArgument1, SystemArgument2, 0)){
		// wrapper around indirect calls
		_guard_dispatch_icall(RundownRoutine, ApcObj);

		status = STATUS_UNSUCCESSFUL;	
		goto cleanup;
	}

	status = STATUS_SUCCESS;

cleanup:
	if (TargetApcThread)
		ObfDereferenceObject(TargetApcThread);
	
	if (MemoryReserver)
		ObfDereferenceObject(MemoryReserver);

	return status;
}
```

## NtQueueApcThread
```c
NTSTATUS NtQueueApcThread(
	HANDLE ThreadHandle, 
	PKNORMAL_ROUTINE ApcRoutine, 
	PVOID NormalContext,
	PVOID SystemArgument1, 
	PVOID SystemArgument2
){
	return NtQueueApcThreadEx(
		ThreadHandle,
		0, // MemoryReserveHandle = NULL
		ApcRoutine,
		NormalContext
		SystemArgument1,
		SystemArgument2,
	);
}
```
## KeInsertQueueApc
```c
BOOLEAN KeInsertQueueApc(
	PRKAPC Apc,
	PVOID SystemArgument1,
	PVOID SystemArgument2,
	KPRIORITY Increment
) {
	BOOLEAN Inserted;
	KIRQL OldIrql;
	KiAcquireThreadLockRaiseToDpc(Apc->Thread, &OldIrql);
	KPRCB* CurrentCPU = KeGetCurrentPcrb();

	if (Apc->Inserted || Apc->Thread->ApcQueueable) {
		Inserted = FALSE;
	}
	else {
		Apc->Inserted = TRUE;
		Apc->SystemArgument1 = SystemArgument1;
		Apc->SystemArgument2 = SystemArgument2;
	
		KiInsertQueueApc(Apc);
		KiSignalThreadForApc(CurrentCPU, Apc, OldIrql);		
	
		Inserted = TRUE;
	}

	KiReleaseThreadLockSafe(TargetThread);
	KiExitDispatcher(CurrentCPU, 0, 1, Increment, OldIrql);
	
	return Inserted;
}
```

## KiInsertQueueApc
```c
void KiInsertQueueApc(KAPC* Apc) {
	PKTHREAD ApcThread = Apc->Thread;
	APC_STATE* ApcState = !Apc->ApcStateIndex && ApcThread->ApcStateIndex ? ApcThread->ApcState : ApcThread->SavedApcState;
	InsertTailList(&ApcState->ApcListHead[Apc->ApcMode], &Apc->ApcListEntry);
}
```

## KiDeliverApc
```c
void KiDeliverApc(KPROCESSOR_MODE PreviouseMode, _LIST_ENTRY *a2, _KTRAP_FRAME *NewTrapFrame) {
	PKTHREAD CurrentThread = KeGetCurrentThread();
	
	PKTRAP_FRAME CurrentTrapFrame = CurrentThread->TrapFrame;
	PKPROCESS SavedApcStateProcess = CurrentThread->ApcState.Process;
	CurrentThread->TrapFrame = NewTrapFrame;
	CurrentThread->ApcState.KernelApcPending = 0;

	BOOLEAN IsSpecialApcEnabled = CurrentThread->SpecialApcDisable == 0;
	if (!IsSpecialApcEnabled)
		goto cleanup;

	PKAPC_STATE CurrentThreadApcState = &CurrentThread->ApcState;

	// check if apc queue is empty
	if (CurrentThreadApcState->ApcListHead[0].Flink == CurrentThreadApcState)
		goto cleanup;

	KIRQL OldIrql;
	KiAcquireThreadLockRaiseToDpc(CurrentThread, &OldIrql);

	// check if apc queue is empty (again)
    if (CurrentThreadApcState->ApcListHead[0].Flink == CurrentThreadApcState)
		goto cleanup;

	LIST_ENTRY* ApcListEntry = CurrentThreadApcState->ApcListHead[0].Flink;
	CurrentThread->ApcState.KernelApcPending = 0;
	PKAPC TargetApc = CONTAINING_RECORD(ApcListEntry, _KAPC, ApcListEntry);

	PVOID KernelRoutine = TargetApc->KernelRoutine;
	PVOID NormalRoutine = TargetApc->NormalRoutine;
	PVOID NormalContext = TargetApc->NormalContext;
	PVOID SystemArgument1 = TargetApc->SystemArgument1;
	PVOID SystemArgument2 = TargetApc->SystemArgument2;

	// NOTE: this is simplified. it'll be different for different types of apc's
	if (NormalRoutine) {
		if (CurrentThread->ApcState.InProgressFlags || CurrentThread->KernelApcDisable) {
			KiReleaseThreadLockSafe(CurrentThread);
			KeLowerIrql(APC_LEVEL);
			goto cleanup;
		}

		LIST_ENTRY *ApcFlink = TargetApc->Flink;
		LIST_ENTRY *ApcBlink = TargetApc->Blink;
		
		// check for curropted list
		if (ApcFlink->Blink != ApcListEntry || Blink->Flink != ApcListEntry)
			__fastfail(3);

		// unlink apc entry
		ApcBlink->Flink = ApcFlink;
		ApcFlink->Blink = ApcBlink;
		TargetApc->Inserted = FALSE;

		// also lowers irql
		KiReleaseThreadLockSafe(CurrentThread);

		KeRaiseIrql(APC_LEVEL, &OldIrql);
		KernelRoutine(
			TargetApc,
			&NormalRoutine, 
			&NormalContext, 
			&SystemArgument1, 
			&SystemArgument2
		);

		if (NormalRoutine) {
			KeLowerIrql(PASSIVE_LEVEL);
			NormalRoutine(NormalContext, SystemArgument1, SystemArgument2);
			KeRaiseIrql(APC_LEVEL, &OldIrql);
		}

		CurrentThread->ApcState.InProgressFlags = 0;

		if(PreviouseMode == UserMode) {
			KiInitializeUserApc(
			ExceptionFrame,
			TrapFrame,
			NormalRoutine,
			NormalContext,
			SystemArgument1,
			SystemArgument2,
			...
			...
		);
		}
	}
}
```

```

`DpcDumper/DpcDumper.c`:

```c
#include <ntddk.h>
#include "DpcSignatures.h"

ULONG_PTR ProcessorDumpDpcQueueIpi(ULONG_PTR);

void DumpDpcData(KDPC_DATA* DpcData);

void TestDpcFunction(struct _KDPC* Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2);

void DriverUnload(_In_ PDRIVER_OBJECT DriverObject);

NTSTATUS DriverCreateClose(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp);

NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) {
	UNREFERENCED_PARAMETER(RegistryPath);
	KdPrint(("[+] Driver Entry\n"));

	DriverObject->DriverUnload = DriverUnload;
	DriverObject->MajorFunction[IRP_MJ_CREATE] = DriverCreateClose;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = DriverCreateClose;

	KIRQL OldIrql;
	KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
	
	// Queue a test DPC so we'll see something
	KDPC TestDpc;
	KeInitializeDpc(&TestDpc, &TestDpcFunction, NULL);
	KeInsertQueueDpc(&TestDpc, NULL, NULL);

	KeIpiGenericCall(ProcessorDumpDpcQueueIpi, 0);
	
	KeLowerIrql(OldIrql);

	return STATUS_SUCCESS;
}

ULONG_PTR ProcessorDumpDpcQueueIpi(ULONG_PTR Arg) {
	UNREFERENCED_PARAMETER(Arg);
	
	KIRQL OldIrql;
	KeRaiseIrql(HIGH_LEVEL, &OldIrql);

	KPRCB* CurrentCpu = KeGetCurrentPrcb();
	
	unsigned __int8 ProcessorNumber = (unsigned __int8) CurrentCpu->Number;
	KdPrint(("[+] Dumping Dpc's for Processor: %x\n", ProcessorNumber));

	DumpDpcData(&CurrentCpu->DpcData[NORMAL_DPC_DATA_INDEX]);
	DumpDpcData(&CurrentCpu->DpcData[THREADED_DPC_DATA_INDEX]);
	
	KeLowerIrql(OldIrql);
	return 0;
}

void DumpDpcData(KDPC_DATA* DpcData) {
	KeAcquireSpinLockAtDpcLevel(&DpcData->DpcLock);
	
	for (SINGLE_LIST_ENTRY* CurrentDpcEntry = DpcData->DpcList.ListHead.Next; CurrentDpcEntry; CurrentDpcEntry = CurrentDpcEntry->Next) {
		KDPC* CurrentDpc = (KDPC*)((unsigned __int8*)CurrentDpcEntry - offsetof(KDPC, DpcListEntry));
		KdPrint(("[+] Dpc routine at: %p\n", CurrentDpc->DeferredRoutine));
	}

	KeReleaseSpinLockFromDpcLevel(&DpcData->DpcLock);
}

void TestDpcFunction(
	struct _KDPC* Dpc,
	PVOID DeferredContext,
	PVOID SystemArgument1,
	PVOID SystemArgument2
) {
	UNREFERENCED_PARAMETER(Dpc);
	UNREFERENCED_PARAMETER(DeferredContext);
	UNREFERENCED_PARAMETER(SystemArgument1);
	UNREFERENCED_PARAMETER(SystemArgument2);
}

NTSTATUS DriverCreateClose(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp) {
	UNREFERENCED_PARAMETER(DeviceObject);
	KdPrint(("[+] Driver Create\\Close Called\n"));

	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

void DriverUnload(_In_ PDRIVER_OBJECT DriverObject) {
	UNREFERENCED_PARAMETER(DriverObject);
	KdPrint(("[+] Driver Unload\n"));
}

```

`DpcDumper/DpcDumper.inf`:

```inf
;
; DpcDumper.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=DpcDumper.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
DpcDumper_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
DpcDumper.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%DpcDumper.DeviceDesc%=DpcDumper_Device, Root\DpcDumper ; TODO: edit hw-id

[DpcDumper_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
DpcDumper.sys

;-------------- Service installation
[DpcDumper_Device.NT.Services]
AddService = DpcDumper,%SPSVCINST_ASSOCSERVICE%, DpcDumper_Service_Inst

; -------------- DpcDumper driver install sections
[DpcDumper_Service_Inst]
DisplayName    = %DpcDumper.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\DpcDumper.sys

;
;--- DpcDumper_Device Coinstaller installation ------
;

[DpcDumper_Device.NT.CoInstallers]
AddReg=DpcDumper_Device_CoInstaller_AddReg
CopyFiles=DpcDumper_Device_CoInstaller_CopyFiles

[DpcDumper_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[DpcDumper_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[DpcDumper_Device.NT.Wdf]
KmdfService =  DpcDumper, DpcDumper_wdfsect
[DpcDumper_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "DpcDumper Installation Disk"
DpcDumper.DeviceDesc = "DpcDumper Device"
DpcDumper.SVCDESC = "DpcDumper Service"

```

`DpcDumper/DpcDumper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="DpcDumper.inf" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{ACB164A0-5D83-4221-B43E-9E68D1B5F937}</ProjectGuid>
    <TemplateGuid>{497e31cb-056b-4f31-abb8-447fd55ee5a5}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>DpcDumper</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>true</EnableInf2cat>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>true</EnableInf2cat>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WppEnabled>false</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WppEnabled>false</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DpcDumper.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DpcSignatures.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DpcDumper/DpcDumper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="DpcDumper.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DpcDumper.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DpcSignatures.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`DpcDumper/DpcSignatures.h`:

```h
#pragma once
#include <ntddk.h>
#include <intrin.h>

/*
* NOTE: This is correct for windows Redstone 5 (October Update) build 10.0.17763.107.
* It'll be a miracle if it works on any other version.
*/

// Indices for the KPRCB.DpcData array
#define THREADED_DPC_DATA_INDEX 1
#define NORMAL_DPC_DATA_INDEX 0

// nameless struct/union
#pragma warning(disable : 4201)

//0x10 bytes (sizeof)
typedef struct _KDPC_LIST
{
    struct _SINGLE_LIST_ENTRY ListHead;                                     //0x0
    struct _SINGLE_LIST_ENTRY* LastEntry;                                   //0x8
} KDPC_LIST;

//0x28 bytes (sizeof)
typedef struct _KDPC_DATA
{
    struct _KDPC_LIST DpcList;                                              //0x0
    ULONGLONG DpcLock;                                                      //0x10
    volatile LONG DpcQueueDepth;                                            //0x18
    ULONG DpcCount;                                                         //0x1c
    struct _KDPC* volatile ActiveDpc;                                       //0x20
} KDPC_DATA;

//0x7ec0 bytes (sizeof)
typedef struct _KPRCB
{
    unsigned long MxCsr;                                                            //0x0
    unsigned __int8 LegacyNumber;                                                     //0x4
    unsigned __int8 ReservedMustBeZero;                                               //0x5
    unsigned __int8 InterruptRequest;                                                 //0x6
    unsigned __int8 IdleHalt;                                                         //0x7
    struct _KTHREAD* CurrentThread;                                         //0x8
    struct _KTHREAD* NextThread;                                            //0x10
    struct _KTHREAD* IdleThread;                                            //0x18
    unsigned __int8 NestingLevel;                                                     //0x20
    unsigned __int8 ClockOwner;                                                       //0x21
    union
    {
        unsigned __int8 PendingTickFlags;                                             //0x22
        struct
        {
            unsigned __int8 PendingTick : 1;                                            //0x22
            unsigned __int8 PendingBackupTick : 1;                                      //0x22
        };
    };
    unsigned __int8 IdleState;                                                        //0x23
    unsigned long Number;                                                           //0x24
    unsigned __int64 RspBase;                                                      //0x28
    unsigned __int64 PrcbLock;                                                     //0x30
    char* PriorityState;                                                    //0x38
    char CpuType;                                                           //0x40
    char CpuID;                                                             //0x41
    union
    {
        unsigned __int8 CpuStep;                                                     //0x42
        struct
        {
            unsigned __int8 CpuStepping;                                              //0x42
            unsigned __int8 CpuModel;                                                 //0x43
        };
    };
    unsigned long MHz;                                                              //0x44
    unsigned __int64 HalReserved[8];                                               //0x48
    unsigned __int8 MinorVersion;                                                    //0x88
    unsigned __int8 MajorVersion;                                                    //0x8a
    unsigned __int8 BuildType;                                                        //0x8c
    unsigned __int8 CpuVendor;                                                        //0x8d
    unsigned __int8 CoresPerPhysicalProcessor;                                        //0x8e
    unsigned __int8 LogicalProcessorsPerCore;                                         //0x8f
    unsigned __int64 PrcbPad04[6];                                                 //0x90
    struct _KNODE* ParentNode;                                              //0xc0
    unsigned __int64 GroupSetMember;                                               //0xc8
    unsigned __int8 Group;                                                            //0xd0
    unsigned __int8 GroupIndex;                                                       //0xd1
    unsigned __int8 PrcbPad05[2];                                                     //0xd2
    unsigned long InitialApicId;                                                    //0xd4
    unsigned long ScbOffset;                                                        //0xd8
    unsigned long ApicMask;                                                         //0xdc
    void* AcpiReserved;                                                     //0xe0
    unsigned long CFlushSize;                                                       //0xe8
    unsigned char pad[4];                                                   //0xec
    union
    {
        struct
        {
            unsigned __int64 TrappedSecurityDomain;                                //0xf0
            union
            {
                unsigned __int8 BpbState;                                             //0xf8
                struct
                {
                    unsigned __int8 BpbCpuIdle : 1;                                     //0xf8
                    unsigned __int8 BpbFlushRsbOnTrap : 1;                              //0xf8
                    unsigned __int8 BpbIbpbOnReturn : 1;                                //0xf8
                    unsigned __int8 BpbIbpbOnTrap : 1;                                  //0xf8
                    unsigned __int8 BpbIbpbOnRetpolineExit : 1;                         //0xf8
                    unsigned __int8 BpbStateReserved : 3;                               //0xf8
                };
            };
            union
            {
                unsigned __int8 BpbFeatures;                                          //0xf9
                struct
                {
                    unsigned __int8 BpbClearOnIdle : 1;                                 //0xf9
                    unsigned __int8 BpbEnabled : 1;                                     //0xf9
                    unsigned __int8 BpbSmep : 1;                                        //0xf9
                    unsigned __int8 BpbFeaturesReserved : 5;                            //0xf9
                };
            };
            unsigned __int8 BpbCurrentSpecCtrl;                                       //0xfa
            unsigned __int8 BpbKernelSpecCtrl;                                        //0xfb
            unsigned __int8 BpbNmiSpecCtrl;                                           //0xfc
            unsigned __int8 BpbUserSpecCtrl;                                          //0xfd
            volatile SHORT PairRegister;                                    //0xfe
        };
        unsigned __int64 PrcbPad11[2];                                             //0xf0
    };
    unsigned char ProcessorState[0x5c0];                                //0x100
    struct _XSAVE_AREA_HEADER* ExtendedSupervisorState;                     //0x6c0
    unsigned long ProcessorSignature;                                               //0x6c8
    unsigned long ProcessorFlags;                                                   //0x6cc
    union
    {
        struct
        {
            unsigned __int8 BpbRetpolineExitSpecCtrl;                                 //0x6d0
            unsigned __int8 BpbTrappedRetpolineExitSpecCtrl;                          //0x6d1
            union
            {
                unsigned __int8 BpbTrappedBpbState;                                   //0x6d2
                struct
                {
                    unsigned __int8 BpbTrappedCpuIdle : 1;                              //0x6d2
                    unsigned __int8 BpbTrappedFlushRsbOnTrap : 1;                       //0x6d2
                    unsigned __int8 BpbTrappedIbpbOnReturn : 1;                         //0x6d2
                    unsigned __int8 BpbTrappedIbpbOnTrap : 1;                           //0x6d2
                    unsigned __int8 BpbTrappedIbpbOnRetpolineExit : 1;                  //0x6d2
                    unsigned __int8 BpbtrappedBpbStateReserved : 3;                     //0x6d2
                };
            };
            union
            {
                unsigned __int8 BpbRetpolineState;                                    //0x6d3
                struct
                {
                    unsigned __int8 BpbRunningNonRetpolineCode : 1;                     //0x6d3
                    unsigned __int8 BpbIndirectCallsSafe : 1;                           //0x6d3
                    unsigned __int8 BpbRetpolineEnabled : 1;                            //0x6d3
                    unsigned __int8 BpbRetpolineStateReserved : 5;                      //0x6d3
                };
            };
            unsigned long PrcbPad12b;                                               //0x6d4
        };
        unsigned __int64 PrcbPad12a;                                               //0x6d0
    };
    unsigned __int64 PrcbPad12[3];                                                 //0x6d8
    struct _KSPIN_LOCK_QUEUE LockQueue[17];                                 //0x6f0
    unsigned char PPLookasideList[0x100];                          //0x800
    struct _GENERAL_LOOKASIDE_POOL PPNxPagedLookasideList[32];              //0x900
    struct _GENERAL_LOOKASIDE_POOL PPNPagedLookasideList[32];               //0x1500
    struct _GENERAL_LOOKASIDE_POOL PPPagedLookasideList[32];                //0x2100
    unsigned __int64 PrcbPad20;                                                    //0x2d00
    struct _SINGLE_LIST_ENTRY DeferredReadyListHead;                        //0x2d08
    volatile long MmPageFaultCount;                                         //0x2d10
    volatile long MmCopyOnWriteCount;                                       //0x2d14
    volatile long MmTransitionCount;                                        //0x2d18
    volatile long MmDemandZeroCount;                                        //0x2d1c
    volatile long MmPageReadCount;                                          //0x2d20
    volatile long MmPageReadIoCount;                                        //0x2d24
    volatile long MmDirtyPagesWriteCount;                                   //0x2d28
    volatile long MmDirtyWriteIoCount;                                      //0x2d2c
    volatile long MmMappedPagesWriteCount;                                  //0x2d30
    volatile long MmMappedWriteIoCount;                                     //0x2d34
    unsigned long KeSystemCalls;                                                    //0x2d38
    unsigned long KeContextSwitches;                                                //0x2d3c
    unsigned long PrcbPad40;                                                        //0x2d40
    unsigned long CcFastReadNoWait;                                                 //0x2d44
    unsigned long CcFastReadWait;                                                   //0x2d48
    unsigned long CcFastReadNotPossible;                                            //0x2d4c
    unsigned long CcCopyReadNoWait;                                                 //0x2d50
    unsigned long CcCopyReadWait;                                                   //0x2d54
    unsigned long CcCopyReadNoWaitMiss;                                             //0x2d58
    volatile long IoReadOperationCount;                                     //0x2d5c
    volatile long IoWriteOperationCount;                                    //0x2d60
    volatile long IoOtherOperationCount;                                    //0x2d64
    union _LARGE_INTEGER IoReadTransferCount;                               //0x2d68
    union _LARGE_INTEGER IoWriteTransferCount;                              //0x2d70
    union _LARGE_INTEGER IoOtherTransferCount;                              //0x2d78
    volatile long PacketBarrier;                                            //0x2d80
    volatile long TargetCount;                                              //0x2d84
    volatile unsigned long IpiFrozen;                                               //0x2d88
    unsigned long PrcbPad30;                                                        //0x2d8c
    void* IsrDpcStats;                                                      //0x2d90
    unsigned long DeviceInterrupts;                                                 //0x2d98
    long LookasideIrpFloat;                                                 //0x2d9c
    unsigned long InterruptLastCount;                                               //0x2da0
    unsigned long InterruptRate;                                                    //0x2da4
    unsigned __int64 LastNonHrTimerExpiration;                                     //0x2da8
    struct _KPRCB* PairPrcb;                                                //0x2db0
    unsigned __int64 PrcbPad35[1];                                                 //0x2db8
    union _SLIST_HEADER InterruptObjectPool;                                //0x2dc0
    unsigned __int64 PrcbPad41[6];                                                 //0x2dd0
    KDPC_DATA DpcData[2];                                           //0x2e00
    void* DpcStack;                                                         //0x2e50
    long MaximumDpcQueueDepth;                                              //0x2e58
    unsigned long DpcRequestRate;                                                   //0x2e5c
    unsigned long MinimumDpcRate;                                                   //0x2e60
    unsigned long DpcLastCount;                                                     //0x2e64
    unsigned __int8 ThreadDpcEnable;                                                  //0x2e68
    volatile unsigned __int8 QuantumEnd;                                              //0x2e69
    volatile unsigned __int8 DpcRoutineActive;                                        //0x2e6a
    volatile unsigned __int8 IdleSchedule;                                            //0x2e6b
    union
    {
        volatile long DpcRequestSummary;                                    //0x2e6c
        SHORT DpcRequestSlot[2];                                            //0x2e6c
        struct
        {
            SHORT NormalDpcState;                                           //0x2e6c
            SHORT ThreadDpcState;                                           //0x2e6e
        };
        struct
        {
            unsigned long DpcNormalProcessingActive : 1;                              //0x2e6c
            unsigned long DpcNormalProcessingRequested : 1;                           //0x2e6c
            unsigned long DpcNormalThreadSignal : 1;                                  //0x2e6c
            unsigned long DpcNormalTimerExpiration : 1;                               //0x2e6c
            unsigned long DpcNormalDpcPresent : 1;                                    //0x2e6c
            unsigned long DpcNormalLocalInterrupt : 1;                                //0x2e6c
            unsigned long DpcNormalSpare : 10;                                        //0x2e6c
            unsigned long DpcThreadActive : 1;                                        //0x2e6c
            unsigned long DpcThreadRequested : 1;                                     //0x2e6c
            unsigned long DpcThreadSpare : 14;                                        //0x2e6c
        };
    };
    unsigned long LastTimerHand;                                                    //0x2e70
    unsigned long LastTick;                                                         //0x2e74
    unsigned long ClockInterrupts;                                                  //0x2e78
    unsigned long ReadyScanTick;                                                    //0x2e7c
    void* InterruptObject[256];                                             //0x2e80
    unsigned char TimerTable[0x2200];                                        //0x3680
    struct _KGATE DpcGate;                                                  //0x5880
    void* PrcbPad52;                                                        //0x5898
    struct _KDPC CallDpc;                                                   //0x58a0
    long ClockKeepAlive;                                                    //0x58e0
    unsigned __int8 PrcbPad60[2];                                                     //0x58e4
    unsigned __int8 NmiActive;                                                       //0x58e6
    long DpcWatchdogPeriod;                                                 //0x58e8
    long DpcWatchdogCount;                                                  //0x58ec
    volatile long KeSpinLockOrdering;                                       //0x58f0
    unsigned long DpcWatchdogProfileCumulativeDpcThreshold;                         //0x58f4
    void* CachedPtes;                                                       //0x58f8
    struct _LIST_ENTRY WaitListHead;                                        //0x5900
    unsigned __int64 WaitLock;                                                     //0x5910
    unsigned long ReadySummary;                                                     //0x5918
    long AffinitizedSelectionMask;                                          //0x591c
    unsigned long QueueIndex;                                                       //0x5920
    unsigned long PrcbPad75[3];                                                     //0x5924
    struct _KDPC TimerExpirationDpc;                                        //0x5930
    unsigned char ScbQueue[0x10];                                           //0x5970
    struct _LIST_ENTRY DispatcherReadyListHead[32];                         //0x5980
    unsigned long InterruptCount;                                                   //0x5b80
    unsigned long KernelTime;                                                       //0x5b84
    unsigned long UserTime;                                                         //0x5b88
    unsigned long DpcTime;                                                          //0x5b8c
    unsigned long InterruptTime;                                                    //0x5b90
    unsigned long AdjustDpcThreshold;                                               //0x5b94
    unsigned __int8 DebuggerSavedIRQL;                                                //0x5b98
    unsigned __int8 GroupSchedulingOverQuota;                                         //0x5b99
    volatile unsigned __int8 DeepSleep;                                               //0x5b9a
    unsigned __int8 PrcbPad80;                                                        //0x5b9b
    unsigned long DpcTimeCount;                                                     //0x5b9c
    unsigned long DpcTimeLimit;                                                     //0x5ba0
    unsigned long PeriodicCount;                                                    //0x5ba4
    unsigned long PeriodicBias;                                                     //0x5ba8
    unsigned long AvailableTime;                                                    //0x5bac
    unsigned long KeExceptionDispatchCount;                                         //0x5bb0
    unsigned long ReadyThreadCount;                                                 //0x5bb4
    unsigned __int64 ReadyQueueExpectedRunTime;                                    //0x5bb8
    unsigned __int64 StartCycles;                                                  //0x5bc0
    unsigned __int64 TaggedCyclesStart;                                            //0x5bc8
    unsigned __int64 TaggedCycles[2];                                              //0x5bd0
    unsigned __int64 GenerationTarget;                                             //0x5be0
    unsigned __int64 AffinitizedCycles;                                            //0x5be8
    unsigned __int64 ImportantCycles;                                              //0x5bf0
    unsigned __int64 UnimportantCycles;                                            //0x5bf8
    unsigned long DpcWatchdogProfileSingleDpcThreshold;                             //0x5c00
    volatile long MmSpinLockOrdering;                                       //0x5c04
    void* volatile CachedStack;                                             //0x5c08
    unsigned long PageColor;                                                        //0x5c10
    unsigned long NodeColor;                                                        //0x5c14
    unsigned long NodeShiftedColor;                                                 //0x5c18
    unsigned long SecondaryColorMask;                                               //0x5c1c
    unsigned __int8 PrcbPad81[7];                                                     //0x5c20
    unsigned __int8 TbFlushListActive;                                                //0x5c27
    unsigned __int64 PrcbPad82[2];                                                 //0x5c28
    unsigned __int64 CycleTime;                                                    //0x5c38
    unsigned __int64 Cycles[4][2];                                                 //0x5c40
    unsigned long CcFastMdlReadNoWait;                                              //0x5c80
    unsigned long CcFastMdlReadWait;                                                //0x5c84
    unsigned long CcFastMdlReadNotPossible;                                         //0x5c88
    unsigned long CcMapDataNoWait;                                                  //0x5c8c
    unsigned long CcMapDataWait;                                                    //0x5c90
    unsigned long CcPinMappedDataCount;                                             //0x5c94
    unsigned long CcPinReadNoWait;                                                  //0x5c98
    unsigned long CcPinReadWait;                                                    //0x5c9c
    unsigned long CcMdlReadNoWait;                                                  //0x5ca0
    unsigned long CcMdlReadWait;                                                    //0x5ca4
    unsigned long CcLazyWriteHotSpots;                                              //0x5ca8
    unsigned long CcLazyWriteIos;                                                   //0x5cac
    unsigned long CcLazyWritePages;                                                 //0x5cb0
    unsigned long CcDataFlushes;                                                    //0x5cb4
    unsigned long CcDataPages;                                                      //0x5cb8
    unsigned long CcLostDelayedWrites;                                              //0x5cbc
    unsigned long CcFastReadResourceMiss;                                           //0x5cc0
    unsigned long CcCopyReadWaitMiss;                                               //0x5cc4
    unsigned long CcFastMdlReadResourceMiss;                                        //0x5cc8
    unsigned long CcMapDataNoWaitMiss;                                              //0x5ccc
    unsigned long CcMapDataWaitMiss;                                                //0x5cd0
    unsigned long CcPinReadNoWaitMiss;                                              //0x5cd4
    unsigned long CcPinReadWaitMiss;                                                //0x5cd8
    unsigned long CcMdlReadNoWaitMiss;                                              //0x5cdc
    unsigned long CcMdlReadWaitMiss;                                                //0x5ce0
    unsigned long CcReadAheadIos;                                                   //0x5ce4
    volatile long MmCacheTransitionCount;                                   //0x5ce8
    volatile long MmCacheReadCount;                                         //0x5cec
    volatile long MmCacheIoCount;                                           //0x5cf0
    unsigned long PrcbPad91;                                                        //0x5cf4
    void* MmInternal;                                                       //0x5cf8
    unsigned char PowerState[0x200];                               //0x5d00
    void* HyperPte;                                                         //0x5f00
    struct _LIST_ENTRY ScbList;                                             //0x5f08
    struct _KDPC ForceIdleDpc;                                              //0x5f18
    struct _KDPC DpcWatchdogDpc;                                            //0x5f58
    struct _KTIMER DpcWatchdogTimer;                                        //0x5f98
    struct _CACHE_DESCRIPTOR Cache[5];                                      //0x5fd8
    unsigned long CacheCount;                                                       //0x6014
    volatile unsigned long CachedCommit;                                            //0x6018
    volatile unsigned long CachedResidentAvailable;                                 //0x601c
    void* WheaInfo;                                                         //0x6020
    void* EtwSupport;                                                       //0x6028
    void* ExSaPageArray;                                                    //0x6030
    unsigned long KeAlignmentFixupCount;                                            //0x6038
    unsigned long PrcbPad95;                                                        //0x603c
    union _SLIST_HEADER HypercallPageList;                                  //0x6040
    unsigned __int64* StatisticsPage;                                              //0x6050
    unsigned __int64 PrcbPad85[5];                                                 //0x6058
    void* HypercallCachedPages;                                             //0x6080
    void* VirtualApicAssist;                                                //0x6088
    unsigned char PackageProcessorSet[0xa8];                               //0x6090
    unsigned __int64 PrcbPad86;                                                    //0x6138
    unsigned __int64 SharedReadyQueueMask;                                         //0x6140
    struct _KSHARED_READY_QUEUE* SharedReadyQueue;                          //0x6148
    unsigned long SharedQueueScanOwner;                                             //0x6150
    unsigned long ScanSiblingIndex;                                                 //0x6154
    unsigned __int64 CoreProcessorSet;                                             //0x6158
    unsigned __int64 ScanSiblingMask;                                              //0x6160
    unsigned __int64 LLCMask;                                                      //0x6168
    unsigned __int64 CacheProcessorMask[5];                                        //0x6170
    struct _PROCESSOR_PROFILE_CONTROL_AREA* ProcessorProfileControlArea;    //0x6198
    void* ProfileEventIndexAddress;                                         //0x61a0
    void** DpcWatchdogProfile;                                              //0x61a8
    void** DpcWatchdogProfileCurrentEmptyCapture;                           //0x61b0
    void* SchedulerAssist;                                                  //0x61b8
    unsigned char SynchCounters[0xb8];                                   //0x61c0
    unsigned __int64 PrcbPad94;                                                    //0x6278
    unsigned char FsCounters[0x10];                            //0x6280
    unsigned __int8 VendorString[13];                                                 //0x6290
    unsigned __int8 PrcbPad100[3];                                                    //0x629d
    unsigned __int64 FeatureBits;                                                  //0x62a0
    union _LARGE_INTEGER UpdateSignature;                                   //0x62a8
    unsigned __int64 PteBitCache;                                                  //0x62b0
    unsigned long PteBitOffset;                                                     //0x62b8
    unsigned long PrcbPad105;                                                       //0x62bc
    struct _CONTEXT* Context;                                               //0x62c0
    unsigned long ContextFlagsInit;                                                 //0x62c8
    unsigned long PrcbPad115;                                                       //0x62cc
    struct _XSAVE_AREA* ExtendedState;                                      //0x62d0
    void* IsrStack;                                                         //0x62d8
    unsigned char EntropyTimingState[0x150];                       //0x62e0
    unsigned __int64 PrcbPad110;                                                   //0x6430
    struct
    {
        unsigned long UpdateCycle;                                                  //0x6438
        union
        {
            SHORT PairLocal;                                                //0x643c
            struct
            {
                unsigned __int8 PairLocalLow;                                         //0x643c
                unsigned __int8 PairLocalForceStibp : 1;                                //0x643d
                unsigned __int8 Reserved : 4;                                           //0x643d
                unsigned __int8 Frozen : 1;                                             //0x643d
                unsigned __int8 ForceUntrusted : 1;                                     //0x643d
                unsigned __int8 SynchIpi : 1;                                           //0x643d
            };
        };
        union
        {
            SHORT PairRemote;                                               //0x643e
            struct
            {
                unsigned __int8 PairRemoteLow;                                        //0x643e
                unsigned __int8 Reserved2;                                            //0x643f
            };
        };
        unsigned __int8 Trace[24];                                                    //0x6440
        unsigned __int64 LocalDomain;                                              //0x6458
        unsigned __int64 RemoteDomain;                                             //0x6460
        struct _KTHREAD* Thread;                                            //0x6468
    } StibpPairingTrace;                                                    //0x6438
    struct _SINGLE_LIST_ENTRY AbSelfIoBoostsList;                           //0x6470
    struct _SINGLE_LIST_ENTRY AbPropagateBoostsList;                        //0x6478
    struct _KDPC AbDpc;                                                     //0x6480
    unsigned char IoIrpStackProfilerCurrent[0x54];               //0x64c0
    unsigned char IoIrpStackProfilerPrevious[0x54];              //0x6514
    unsigned char SecureFault[0x10];                          //0x6568
    unsigned __int64 PrcbPad120;                                                   //0x6578
    unsigned char LocalSharedReadyQueue[0x270];                      //0x6580
    unsigned __int64 PrcbPad125[2];                                                //0x67f0
    unsigned long TimerExpirationTraceCount;                                        //0x6800
    unsigned long PrcbPad127;                                                       //0x6804
    unsigned char TimerExpirationTrace[0x100];               //0x6808
    unsigned __int64 PrcbPad128[7];                                                //0x6908
    struct _REQUEST_MAILBOX* Mailbox;                                       //0x6940
    unsigned __int64 PrcbPad130[7];                                                //0x6948
    unsigned char McheckContext[0x50 * 2];                         //0x6980
    unsigned __int64 PrcbPad134[4];                                                //0x6a20
    struct _KLOCK_QUEUE_HANDLE SelfmapLockHandle[4];                        //0x6a40
    unsigned __int64 PrcbPad134a[4];                                               //0x6aa0
    unsigned __int8 PrcbPad138[960];                                                  //0x6ac0
    unsigned __int64 KernelDirectoryTableBase;                                     //0x6e80
    unsigned __int64 RspBaseShadow;                                                //0x6e88
    unsigned __int64 UserRspShadow;                                                //0x6e90
    unsigned long ShadowFlags;                                                      //0x6e98
    unsigned long DbgMceNestingLevel;                                               //0x6e9c
    unsigned long DbgMceFlags;                                                      //0x6ea0
    unsigned long PrcbPad139;                                                       //0x6ea4
    unsigned __int64 PrcbPad140[507];                                              //0x6ea8
    unsigned char RequestMailbox[0x40];                              //0x7e80
} KPRCB;

__forceinline KPRCB* KeGetCurrentPrcb() {
    return (KPRCB*)__readgsqword(FIELD_OFFSET(KPCR, CurrentPrcb));
}

```

`DpcDumper/README.md`:

```md
# DPC's

## Background
Deferred procedure calls (DPCs) are routines executed at DISPATCH_LEVEL in arbitrary thread context on a particular processor(by default, the processor that queued the DPC).

They are called in three places:
* `KiIdleLoop`: While “idling,” it checks the PRCB to determine if DPCs are waiting and if so to call *KiRetireDpcList* to process all DPCs.
* `KiExecuteDpc`:  *KiStartDpcThread* creates a thread (*KiExecuteDpc*) for each processor, which processes the DPC queue whenever it runs.
* `IRQL` drops: when the irql of a processor drops to DISPATCH_LEVEL or, it processes all of it's DPC's.

## Some minimized pseudocode of stuff I reversed:

* **KeInsertDpc**
```c
BOOLEAN KeInsertQueueDpc(PRKDPC Dpc, PVOID SystemArgument1, PVOID SystemArgument2) {
	return KiInsertQueueDpc(Dpc, SystemArgument1, SystemArgument2, 0, 0);
}
```

* **KiInsertQueueDpc**
```c
BOOLEAN KiInsertQueueDpc(Dpc, SystemArgument1, SystemArgument2, 0, 0){
	uint16_t current_irql = KeGetCurrentIrql();
	uint16_t old_irql = current_irql;
	KeRaiseIrql(0xF);

	PKPRCB TargetCPU;
	uint8_t is_dpc_processor_num_not_equal_to_current = FALSE;
	if(KDPC->Number >= 500) {
		 TargetCPU = KiProcessorBlock[0x500 - KDPC->Number];
		 if (!dpc_target_proc){
		 	KeBugCheckEx();
		 }
	}
	else {
		TargetCPU = KeGetCurretPrcb();
		if(KDPC->Number != KPCRB->Number){
			is_dpc_processor_num_not_equal_to_current = TRUE;
		} 
	}


	uint8_t dpc_data_offset = (TargetCPU->type == ThreadedDpcObjet && TargetCPU.ThreadDpcEnable) ? 1 : 0;
	DpcData dpc_data = KPRCB.DpcData[dpc_data_offset];

	if (KDPC->Importance == 2) { // High Importance
		if(!DpcData.DpcList.ListHead.Next) {
			DpcData->DpcList.LastEntry =  &TargetCPU->DpcListEntry;
		}

		TargetCPU->DpcListEntry.Next = &DpcData->DpcList.ListHead.Next;
		DpcData->DpcList.ListHead.Next = &TargetCPU->DpcListEntry;
	}
	else {
		TargetCPU->DpcListEntry.Next = NULL;
		DpcData->DpcList.LastEntry->Next = TargetCPU->DpcListEntry;
		DpcData->DPcList.LastEntry = TargetCPU->DpcListEntry;
	}
}
```

* **KiRetireDpcList**
```c
// a whole bunch of flags and cycles stuff....
// ...
NTSTATUS KiRetireDpcList(_KPRCB* KPRCB) {
	KiExecuteAllDpcs(KPRCB, CurrentThread, &zero_inintialized, 0i64);
	if ( (KPRCB->DpcRequestSlot[0] & 4) != 0 )
	{
	 	_enable(); // sti
	 	KeSignalGate(&KPRCB->DpcGate, 0);
	 	_disable(); // cli
	}	
}

```

* **KiExecuteDpc**
```c
BOOLEAN KiTryToEndDpcProcessing(uint32_t* ThreadDpcState, DPC_DATA* DpcData) {
	// using a lock cmpxhg
	if (*ThreadDpcState == 1) { // maybe executing?
		*ThreadDpcState = 0;
		ActiveDpc = NULL;
		return TRUE;
	}

	return FALSE;
}

// Created as a system thread to execute dpc's
void KiExecuteDpc(_KPRCB *KPRCB) {
	PKTHREAD CurrentThread = KeGetCurrentThread();
	KeSetPriorityThread(CurrentThread, 0x1f);

	// sets the current thread to run on the dpc's processor(maybe)
	KiSetSystemAffinityThreadToProcessor(KPRCB->Number);

	while(TRUE) {
		uint64_t OutValue;
		KiExecuteAllDpcs(KPRCB, CurrentThread, &OutValue, 1);
		KiTryToEndDpcProcessing(&KPRCB->ThreadDpcState, &KPRCB.DpcData[1]); // 1 is the threaded dpc index
	}
}
```

* **KiExecuteAllDpcs**
```c
__int64 KiExecuteAllDpcs(
	_KPRCB *KPRCB,
	_KTHREAD *ExecThread, 
	void *OutValue, 
	_QWORD DpcDataArrOffIsThreaded
){
	// equivalent to: _KDPC_DATA* DpcData = &KPRCB->DpcData[DpcDataArrOffIsThreaded]
	__int64 PrcbDpcDataOffset = 0x5c0 + DpcDataArrOffIsThreaded * 5;
	_KDPC_DATA* DpcData = (_KDPC_DATA*) ((BYTE*)KPRCB + 8 * PrcbDpcDataOffset);
	
	while(DpcData.DpcQueueDepth != 0) {
		KxWaitForSpinLockAndAcquire(&DpcData->Lock);

		SingleListEntry* CurrentDpcListEntry = DpcData->DpcList.ListHead.Next;
		SingleListEntry* NextDpcListEntry = CurrentDpcListEntry->Next;
		DpcData->DpcList.ListHead.Next = NextDpcListEntry->Next;

		if(NextDpcListEntry == NULL){
			DpcData->DpcList.LastEntry = &(DpcList->Dpclist.ListHead);
		}

		_KDPC* KDPC = (*KDPC) ((*BYTE)CurrentDpcListEntry - 8);
		PKDEFERRED_ROUTINE DeferredRoutine = KDPC->DeferredRoutine;
		void* DeferredContext = KDPC->DeferredContext;
		void* SystemArgument1 = KDPC->SystemArgument1;
		void* SystemArgument2 = KDPC->SystemArgument2;
		void* DpcEntryDpcData = KDPC->DpcData;

		// the processor's DpcData NOT the KDPC's DpcData
		DpcData.DpcQueueDepth--;

		KxReleaseSpinLock(&DpcData->Lock);

		// a wrapper for dispatching indirect calls while making some checks.
		// rax = FuncPtr
		// rcx = arg1
		// rdx = arg2
		// ...
		__guard_dispatch_icall(_KDPC* Dpc, DeferredContext, SystemArgument1, SystemArgument2);
	}
}

```

```

`NotifyRoutinesDumper/NotifyRoutinesDumper.c`:

```c
#include <ntddk.h>
#include <intrin.h>
#include "undocumented.h"

void DriverUnload(_In_ PDRIVER_OBJECT DriverObject);
NTSTATUS DriverCreateClose(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp);

void DumpNotifyRoutinesArr(CallbackBlock** NotifyRoutines) {
	for (unsigned __int64 i = 0; i < NOTIFY_ROUTINE_ARR_SIZE; i++) {
		if (!NotifyRoutines[i]) {
			continue;
		}

		CallbackBlock* CurrentCallback = (CallbackBlock*)(((unsigned __int64)NotifyRoutines[i]) & 0xfffffffffffffff0);

		ExAcquireRundownProtection(&CurrentCallback->RundownProtection);
		KdPrint(("[+] Callback at: %p\n", CurrentCallback->CallbackRoutine));
		ExReleaseRundownProtection(&CurrentCallback->RundownProtection);
	}
}

NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) {
	UNREFERENCED_PARAMETER(RegistryPath);
	KdPrint(("[+] Driver Entry\n"));

	DriverObject->DriverUnload = DriverUnload;
	DriverObject->MajorFunction[IRP_MJ_CREATE] = DriverCreateClose;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = DriverCreateClose;

	unsigned __int8* NtoskrnlBase = (unsigned __int8*) GetNtoskrnlBase();
	KdPrint(("[+] Ntoskrnl base at: %p\n", NtoskrnlBase));
	
	CallbackBlock** PsCreateThreadNotifyRoutinesArray = (CallbackBlock**) (NtoskrnlBase + THREAD_NOTIFY_ROUTINE_ARR_OFFSET);
	KdPrint(("[+] ***************DUMPING CREATE THREAD NOTIFY ROUTINES***************\n"));
	DumpNotifyRoutinesArr(PsCreateThreadNotifyRoutinesArray);

	CallbackBlock** PsCreateProcessNotifyRoutinesArray = (CallbackBlock**) (NtoskrnlBase + PROCESS_NOTIFY_ROUTINE_ARR_OFFSET);
	KdPrint(("[+] ***************DUMPING CREATE PROCESS NOTIFY ROUTINES***************\n"));
	DumpNotifyRoutinesArr(PsCreateProcessNotifyRoutinesArray);

	CallbackBlock** PsImageLoadNotifyRoutinesArray = (CallbackBlock**) (NtoskrnlBase + IMAGE_LOAD_NOTIFY_ROUTINE_ARR_OFFSET);
	KdPrint(("[+] ***************DUMPING IMAGE LOAD NOTIFY ROUTINES***************\n"));
	DumpNotifyRoutinesArr(PsImageLoadNotifyRoutinesArray);

	return STATUS_SUCCESS;
}

NTSTATUS DriverCreateClose(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp) {
	UNREFERENCED_PARAMETER(DeviceObject);
	KdPrint(("[+] Driver Create\\Close Called\n"));

	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

void DriverUnload(_In_ PDRIVER_OBJECT DriverObject) {
	UNREFERENCED_PARAMETER(DriverObject);
	KdPrint(("[+] Driver Unload\n"));
}

```

`NotifyRoutinesDumper/NotifyRoutinesDumper.inf`:

```inf
;
; NotifyRoutinesDumper.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=NotifyRoutinesDumper.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
NotifyRoutinesDumper_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
NotifyRoutinesDumper.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%NotifyRoutinesDumper.DeviceDesc%=NotifyRoutinesDumper_Device, Root\NotifyRoutinesDumper ; TODO: edit hw-id

[NotifyRoutinesDumper_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
NotifyRoutinesDumper.sys

;-------------- Service installation
[NotifyRoutinesDumper_Device.NT.Services]
AddService = NotifyRoutinesDumper,%SPSVCINST_ASSOCSERVICE%, NotifyRoutinesDumper_Service_Inst

; -------------- NotifyRoutinesDumper driver install sections
[NotifyRoutinesDumper_Service_Inst]
DisplayName    = %NotifyRoutinesDumper.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\NotifyRoutinesDumper.sys

;
;--- NotifyRoutinesDumper_Device Coinstaller installation ------
;

[NotifyRoutinesDumper_Device.NT.CoInstallers]
AddReg=NotifyRoutinesDumper_Device_CoInstaller_AddReg
CopyFiles=NotifyRoutinesDumper_Device_CoInstaller_CopyFiles

[NotifyRoutinesDumper_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[NotifyRoutinesDumper_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[NotifyRoutinesDumper_Device.NT.Wdf]
KmdfService =  NotifyRoutinesDumper, NotifyRoutinesDumper_wdfsect
[NotifyRoutinesDumper_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "NotifyRoutinesDumper Installation Disk"
NotifyRoutinesDumper.DeviceDesc = "NotifyRoutinesDumper Device"
NotifyRoutinesDumper.SVCDESC = "NotifyRoutinesDumper Service"

```

`NotifyRoutinesDumper/NotifyRoutinesDumper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="NotifyRoutinesDumper.c" />
    <ClCompile Include="undocumented.c" />
  </ItemGroup>
  <ItemGroup>
    <Inf Include="NotifyRoutinesDumper.inf" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{488DEC0F-CC81-442E-AE88-821F5BB0D645}</ProjectGuid>
    <TemplateGuid>{497e31cb-056b-4f31-abb8-447fd55ee5a5}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>NotifyRoutinesDumper</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WppEnabled>false</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
    <Link>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
      <IgnoreSpecificDefaultLibraries>LIBCMT.lib;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WppEnabled>false</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
    <Link>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
      <IgnoreSpecificDefaultLibraries>LIBCMT.lib;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="undocumented.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`NotifyRoutinesDumper/NotifyRoutinesDumper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="NotifyRoutinesDumper.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="NotifyRoutinesDumper.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="undocumented.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="undocumented.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`NotifyRoutinesDumper/README.md`:

```md
# Notify Routines - Relevant Function Decompilations

## PsSetCreateThreadNotifyRoutine
```c
NTSTATUS PsSetCreateThreadNotifyRoutine(PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine) {
	return PspSetCreateThreadNotifyRoutine(NotifyRoutine, 0i64);
}
```

## PspSetCreateThreadNotifyRoutine
```c
struct CallbackObj {
	_EX_RUNDOWN_REF RundownProtection;
	void *CallbackRoutine;
	__int64 Flags;
};

CallbackObj* ExAllocateCallBack(void *CallbackRoutine, __int64 Flags) {
	CallbackObj* Callback = (CallbackObj *)ExAllocatePoolWithTag(NonPagedPoolNx, sizeof(CallbackObj), 'brbC');
	if (Callback) {
    	// 0 initializes the RundownProtection field
    	ExInitializePushLock(&Callback->RundownProtection.Count);

    	Callback->CallbackRoutine = CallbackRoutine;
    	Callback->Flags = Flags;
  }

  return Callback;
}

NTSTATUS PspSetCreateThreadNotifyRoutine(PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine, __int64 Flags) {
	CallbackRoutine* Callback = ExAllocateCallback(NotifyRoutine, Flags);
	if (!Callback)
    	return STATUS_INSUFFICIENT_RESOURCES;

	// find an empty place in the array of thread notifications (size = 0x40)
	// and store the callback object ptr in it
    unsigned __int64 FailedCallbackInsertionCount = 0;
    while (!ExCompareExchangeCallBack(
    	(signed __int64 *)&PspCreateThreadNotifyRoutine.Ptr + FailedCallbackInsertionCount,
		Callback,
		0
	)) {
    	FailedCallbackInsertionCount++;
    	if (FailedCallbackInsertionCount >= 0x40) {
    		// no free space in the callback array
    		ExFreePoolWithTag(Callback, 0);
    		return STATUS_INSUFFICIENT_RESOURCES;
    	}
  	}

  	// check if callback flags 0th bit is set(likely indicates a nonsystem notify routine)
  	if ( (flags_ & 1) != 0 ) {
  		// increase count of nonsystem thread notify routines 
		_InterlockedIncrement(&PspCreateThreadNotifyRoutineNonSystemCount);
    
		// if the 3rd bit of PspNotifyEnableMask is off, turn it on
		// this bit likely points out whether normal nonsystem notify routines are enalbed or not
		if ( (PspNotifyEnableMask & 0x10) == 0 )
			_interlockedbittestandset(&PspNotifyEnableMask, 4u);
  }

	// notify routine is of normal type
	else {
  
  		// increase count of normal thread notify routines 
    	_InterlockedIncrement(&PspCreateThreadNotifyRoutineCount);
    
    	// if the 3rd bit of PspNotifyEnableMask is off, turn it on
    	// this bit likely points out whether normal thread notify routines are enalbed or not
    	if ( (PspNotifyEnableMask & 8) == 0 )
      		_interlockedbittestandset(&PspNotifyEnableMask, 3u);
  }
}
```

```

`NotifyRoutinesDumper/undocumented.c`:

```c
#include "undocumented.h"
#include <intrin.h>
#include <aux_klib.h>
#pragma comment(lib, "aux_klib.lib")

void* GetNtoskrnlBase() {
	AuxKlibInitialize();
	ULONG BufferSize = 0;
	NTSTATUS status = AuxKlibQueryModuleInformation(&BufferSize, sizeof(AUX_MODULE_EXTENDED_INFO), NULL);
	if (!NT_SUCCESS(status)) {
		return NULL;
	}

	AUX_MODULE_EXTENDED_INFO* QueryModuleInfo = (AUX_MODULE_EXTENDED_INFO*)ExAllocatePool(PagedPool, BufferSize);
	if (!QueryModuleInfo) {
		return NULL;
	}

	for (AUX_MODULE_EXTENDED_INFO* CurrentModuleInfo = QueryModuleInfo; CurrentModuleInfo != (AUX_MODULE_EXTENDED_INFO*)(((unsigned char*)QueryModuleInfo) + BufferSize); CurrentModuleInfo++) {
		if (strstr((const char*)CurrentModuleInfo->FullPathName, "ntoskrnl.exe")){
			return CurrentModuleInfo->BasicInfo.ImageBase;
		}
	}

	DbgBreakPoint();
	return NULL;
}
```

`NotifyRoutinesDumper/undocumented.h`:

```h
#pragma once
#include <ntddk.h>

// this is very build dependent
// I'm too lazy to make it generic for this exercise
#define THREAD_NOTIFY_ROUTINE_ARR_OFFSET 0x4da7f0
#define PROCESS_NOTIFY_ROUTINE_ARR_OFFSET 0x4dabf0
#define IMAGE_LOAD_NOTIFY_ROUTINE_ARR_OFFSET 0x4da9f0

#define NOTIFY_ROUTINE_ARR_SIZE 0x40

typedef struct {
	EX_RUNDOWN_REF RundownProtection;
	void* CallbackRoutine;
	__int64 Flags;
} CallbackBlock;

void* GetNtoskrnlBase();

```

`ObCallbacksDumper/ObCallbacksDumper.cpp`:

```cpp
#include <ntddk.h>
#include <intrin.h>
#include "ObCallbacksDumper.hpp"
#include "ob_callbacks.hpp"


extern "C" 
NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) {
	UNREFERENCED_PARAMETER(DriverObject);
	UNREFERENCED_PARAMETER(RegistryPath);
	KdPrint(("[+] Driver Entry\n"));

	DriverObject->DriverUnload = driver_routines::driver_unload;
	DriverObject->MajorFunction[IRP_MJ_CREATE] = driver_routines::driver_create_close;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = driver_routines::driver_create_close;

	if (!ob_callbacks::register_dummy_callback()) {
		__debugbreak();
		return STATUS_FAILED_DRIVER_ENTRY;
	}
	ob_callbacks::dump_callbacks();

	return STATUS_SUCCESS;
}

NTSTATUS driver_routines::driver_create_close(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp) {
	UNREFERENCED_PARAMETER(DeviceObject);
	KdPrint(("[+] Driver Create\\Close Called\n"));

	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}

void driver_routines::driver_unload(_In_ PDRIVER_OBJECT DriverObject) {
	UNREFERENCED_PARAMETER(DriverObject);
	KdPrint(("[+] Driver Unload\n"));

	ob_callbacks::unregister_dummy_callback();
}

```

`ObCallbacksDumper/ObCallbacksDumper.hpp`:

```hpp
#pragma once
#include <ntddk.h>


namespace driver_routines {
	NTSTATUS driver_create_close(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp);
	void driver_unload(_In_ PDRIVER_OBJECT DriverObject);
}

```

`ObCallbacksDumper/ObCallbacksDumper.inf`:

```inf
;
; ObCallbacksDumper.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=ObCallbacksDumper.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
ObCallbacksDumper_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
ObCallbacksDumper.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%ObCallbacksDumper.DeviceDesc%=ObCallbacksDumper_Device, Root\ObCallbacksDumper ; TODO: edit hw-id

[ObCallbacksDumper_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
ObCallbacksDumper.sys

;-------------- Service installation
[ObCallbacksDumper_Device.NT.Services]
AddService = ObCallbacksDumper,%SPSVCINST_ASSOCSERVICE%, ObCallbacksDumper_Service_Inst

; -------------- ObCallbacksDumper driver install sections
[ObCallbacksDumper_Service_Inst]
DisplayName    = %ObCallbacksDumper.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\ObCallbacksDumper.sys

;
;--- ObCallbacksDumper_Device Coinstaller installation ------
;

[ObCallbacksDumper_Device.NT.CoInstallers]
AddReg=ObCallbacksDumper_Device_CoInstaller_AddReg
CopyFiles=ObCallbacksDumper_Device_CoInstaller_CopyFiles

[ObCallbacksDumper_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[ObCallbacksDumper_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[ObCallbacksDumper_Device.NT.Wdf]
KmdfService =  ObCallbacksDumper, ObCallbacksDumper_wdfsect
[ObCallbacksDumper_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "ObCallbacksDumper Installation Disk"
ObCallbacksDumper.DeviceDesc = "ObCallbacksDumper Device"
ObCallbacksDumper.SVCDESC = "ObCallbacksDumper Service"

```

`ObCallbacksDumper/ObCallbacksDumper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{6145AEB4-744B-4290-A80D-25E6FF7571B6}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>ObCallbacksDumper</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="ObCallbacksDumper.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ObCallbacksDumper.cpp" />
    <ClCompile Include="ob_callbacks.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ObCallbacksDumper.hpp" />
    <ClInclude Include="ob_callbacks.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ObCallbacksDumper/ObCallbacksDumper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="ObCallbacksDumper.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ObCallbacksDumper.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ob_callbacks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ObCallbacksDumper.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ob_callbacks.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`ObCallbacksDumper/README.md`:

```md
# Object Manager Callbacks

The two main API's interfacing with the object manager callbacks are: `ObRegisterCallbacks` and `ObUnRegisterCallbacks`.

## ObRegisterCallbacks

(simplified)

```c
typedef struct {
    LIST_ENTRY CallbackListEntry;                                    // 0x0
    OB_OPERATION Operations;                                         // 0x10
    PINTERNAL_OB_REGISTRATION_STRUCT InternalRegistrationContextPtr; // 0x18
    POBJECT_TYPE ObjectType;                                         // 0x20
    POB_PRE_OPERATION_CALLBACK  PreOperation;                        // 0x28
    POB_POST_OPERATION_CALLBACK PostOperation;                       // 0x30
	EX_PUSH_LOCK Lock;                                               // 0x38
} INTERNAL_REGISTRATION_RECORD, *PINTERNAL_REGISTRATION_RECORD; // sizeof = 0x64


typedef struct {
    USHORT Version;                                                // 0x0
    USHORT RegisteredCallbacksCount;                               // 0x2
    PVOID RegistrationContext;                                     // 0x8
    UNICODE_STRING Altitude;                                       // 0x10
    INTERNAL_REGISTRATION_RECORD Callbacks[1];                     // 0x20
    CHAR AltitudeBuffer[1];
} INTERNAL_OB_REGISTRATION_STRUCT, *PINTERNAL_OB_REGISTRATION_STRUCT;

NTSTATUS ObRegisterCallbacks(POB_CALLBACK_REGISTRATION CallbackRegistration, PVOID *RegistrationHandle) {
    if (CallbackRegistration->Version != OB_FLT_REGISTRATION_VERSION ||
        CallbackRegistration.OperationRegistrationCount == 0) {
        return STATUS_INVALID_PARAMETER;
    }

    uint32_t InnerContextSize = CallbackRegistration->Altitude.Length + 0x20 + CallbackRegistration->OperationRegistrationCount * sizeof(INTERNAL_REGISTRATION_RECORD);    
    PINTERNAL_OB_REGISTRATION_STRUCT InnerContext = ExAllocatePoolWithTag(
        PagedPool, 
        InnerContextSize,
        'ObFl'
    );
    if (!InnerContext) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    memmove(InnerContext, 0, InnerContextSize);
    
	NTSTATUS status = STATUS_SUCCESS;
    for (unsigned int i = 0; i < CallbackRegistration->OperationRegistrationCount; i++) {
        POB_OPERATION_REGISTRATION CurrentEntry = CallbackRegistration->OperationRegistration[i];
        if (CurrentEntry->Operation == 0 || !IS_VALID_OBJECT_TYPE(CurrentEntry->ObjectType)
           || (CurrentEntry->PreOperation == NULL && CurrentEntry->PostOperation == NULL)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        
        if ((CurrentEntry->PreOperation && !MmVerifyCallbackFunctionCheckFlags(CurrentEntry->PreOperation, 0x20)) ||
            (CurrentEntry->PostOperation && !MmVerifyCallbackFunctionCheckFlags(CurrentEntry->PostOperation, 0x20))) {
            status = STATUS_ACCESS_DEFINED;
            break;
        }
        
        PINTERNAL_REGISTRATION_RECORD CallbackRecord = &InnerContext->Callbacks[i];
        InitializeListHead(&CallbackRecord->CallbackListEntry);
        ExInitializePushLock(&CallbackRecord->Lock);
        CallbackRecord->InternalRegistrationContextPtr = InnerContext;
        CallbackRecord->PreOperation = CurrentEntry->PreOperation;
        CallbackRecord->PostOperation = CurrentEntry->PostOperation;
        
        POBJECT_TYPE ObjectType = *CurrentEntry->ObjectType;
        CallbackRecord->ObjectType = ObjectType;
        
        // Inserts callback by altitude to the linked list ObjectType->CallbackList
        ObpInsertCallbackByAltitude(ObjectType, CallbackRecord);
        InnerContext->RegisteredCallbacksCount++;
    }
    
    if (status == STATUS_SUCCESS) {
        *RegistrationHandle = InnerContext;
    }
    return status;
}
```
```

`ObCallbacksDumper/ob_callbacks.cpp`:

```cpp
#include "ob_callbacks.hpp"


namespace ob_callbacks {
	static void dump_object_type_callbacks(POBJECT_TYPE object_type);

	static OB_PREOP_CALLBACK_STATUS dummy_callback(
		PVOID RegistrationContext,
		POB_PRE_OPERATION_INFORMATION OperationInformation
	);

	static PVOID registration_handle;
}


void ob_callbacks::dump_callbacks() {
	POBJECT_TYPE object_types[] = { 
		reinterpret_cast<ob_callbacks::POBJECT_TYPE>(*PsProcessType), 
		reinterpret_cast<ob_callbacks::POBJECT_TYPE>(*PsThreadType)
	};

	for (auto object_type : object_types) {
		dump_object_type_callbacks(object_type);
	}
}

void ob_callbacks::dump_object_type_callbacks(ob_callbacks::POBJECT_TYPE object_type) {
	KdPrint(("Dumping callbacks for object type: %wZ\n", &object_type->Name));

	ExAcquirePushLockExclusive(&object_type->TypeLock);
	for (PLIST_ENTRY callback_entry = object_type->CallbackList.Flink; callback_entry != &object_type->CallbackList; callback_entry = callback_entry->Flink) {
		auto callback = reinterpret_cast<PINTERNAL_REGISTRATION_RECORD>(callback_entry);
		KdPrint(("PreOperation: %p, PostOperation: %p\n", callback->PreOperation, callback->PostOperation));
	}
	ExReleasePushLockExclusive(&object_type->TypeLock);
}

bool ob_callbacks::register_dummy_callback() {
	OB_OPERATION_REGISTRATION operation_registration{ 0 };
	operation_registration.ObjectType = PsProcessType;
	operation_registration.PostOperation = nullptr;
	operation_registration.PreOperation = ob_callbacks::dummy_callback;
	operation_registration.Operations = OB_OPERATION_HANDLE_CREATE;

	OB_CALLBACK_REGISTRATION callback_registration{ 0 };
	callback_registration.Version = OB_FLT_REGISTRATION_VERSION;
	callback_registration.OperationRegistrationCount = 1;
	callback_registration.Altitude = RTL_CONSTANT_STRING(L"alt");
	callback_registration.RegistrationContext = 0;
	callback_registration.OperationRegistration = &operation_registration;

	return NT_SUCCESS(ObRegisterCallbacks(&callback_registration, &registration_handle));
}

void ob_callbacks::unregister_dummy_callback() {
	ObUnRegisterCallbacks(ob_callbacks::registration_handle);
}

OB_PREOP_CALLBACK_STATUS ob_callbacks::dummy_callback(PVOID RegistrationContext, 
	POB_PRE_OPERATION_INFORMATION OperationInformation) {
	UNREFERENCED_PARAMETER(RegistrationContext);
	UNREFERENCED_PARAMETER(OperationInformation);
	return OB_PREOP_SUCCESS;
}

```

`ObCallbacksDumper/ob_callbacks.hpp`:

```hpp
#pragma once
#include <ntddk.h>
#include <intrin.h>
#pragma warning( disable : 4201 )


namespace ob_callbacks {
	void dump_callbacks();
	bool register_dummy_callback();
	void unregister_dummy_callback();

    typedef struct _OBJECT_TYPE {
        struct _LIST_ENTRY TypeList;                                            //0x0
        struct _UNICODE_STRING Name;                                            //0x10
        VOID* DefaultObject;                                                    //0x20
        UCHAR Index;                                                            //0x28
        ULONG TotalNumberOfObjects;                                             //0x2c
        ULONG TotalNumberOfHandles;                                             //0x30
        ULONG HighWaterNumberOfObjects;                                         //0x34
        ULONG HighWaterNumberOfHandles;                                         //0x38
        unsigned char pad[0x78];                                                //0x40
        EX_PUSH_LOCK TypeLock;                                                  //0xb8
        ULONG Key;                                                              //0xc0
        struct _LIST_ENTRY CallbackList;                                        //0xc8
    } OBJECT_TYPE, *POBJECT_TYPE;

    typedef struct {
        LIST_ENTRY CallbackListEntry;                                    // 0x0
        OB_OPERATION Operations;                                         // 0x10
        PVOID InternalRegistrationContextPtr;                            // 0x18
        POBJECT_TYPE ObjectType;                                         // 0x20
        POB_PRE_OPERATION_CALLBACK  PreOperation;                        // 0x28
        POB_POST_OPERATION_CALLBACK PostOperation;                       // 0x30
        EX_PUSH_LOCK Lock;                                               // 0x38
    } INTERNAL_REGISTRATION_RECORD, * PINTERNAL_REGISTRATION_RECORD; // sizeof = 0x64

}

```

`Practical Reverse Engineering Solutions.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31624.102
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DpcDumper", "DpcDumper\DpcDumper.vcxproj", "{ACB164A0-5D83-4221-B43E-9E68D1B5F937}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ApcDumper", "ApcDumper\ApcDumper.vcxproj", "{87B1F195-0799-44B4-853B-2F0BC59102A6}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NotifyRoutinesDumper", "NotifyRoutinesDumper\NotifyRoutinesDumper.vcxproj", "{488DEC0F-CC81-442E-AE88-821F5BB0D645}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ObCallbacksDumper", "ObCallbacksDumper\ObCallbacksDumper.vcxproj", "{6145AEB4-744B-4290-A80D-25E6FF7571B6}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Debug|ARM.ActiveCfg = Debug|ARM
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Debug|ARM.Build.0 = Debug|ARM
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Debug|ARM.Deploy.0 = Debug|ARM
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Debug|ARM64.Build.0 = Debug|ARM64
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Debug|x64.ActiveCfg = Debug|x64
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Debug|x64.Build.0 = Debug|x64
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Debug|x64.Deploy.0 = Debug|x64
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Debug|x86.ActiveCfg = Debug|Win32
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Debug|x86.Build.0 = Debug|Win32
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Debug|x86.Deploy.0 = Debug|Win32
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Release|ARM.ActiveCfg = Release|ARM
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Release|ARM.Build.0 = Release|ARM
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Release|ARM.Deploy.0 = Release|ARM
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Release|ARM64.ActiveCfg = Release|ARM64
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Release|ARM64.Build.0 = Release|ARM64
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Release|ARM64.Deploy.0 = Release|ARM64
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Release|x64.ActiveCfg = Release|x64
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Release|x64.Build.0 = Release|x64
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Release|x64.Deploy.0 = Release|x64
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Release|x86.ActiveCfg = Release|Win32
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Release|x86.Build.0 = Release|Win32
		{ACB164A0-5D83-4221-B43E-9E68D1B5F937}.Release|x86.Deploy.0 = Release|Win32
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Debug|ARM.ActiveCfg = Debug|ARM
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Debug|ARM.Build.0 = Debug|ARM
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Debug|ARM.Deploy.0 = Debug|ARM
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Debug|ARM64.Build.0 = Debug|ARM64
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Debug|x64.ActiveCfg = Debug|x64
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Debug|x64.Build.0 = Debug|x64
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Debug|x64.Deploy.0 = Debug|x64
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Debug|x86.ActiveCfg = Debug|Win32
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Debug|x86.Build.0 = Debug|Win32
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Debug|x86.Deploy.0 = Debug|Win32
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Release|ARM.ActiveCfg = Release|ARM
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Release|ARM.Build.0 = Release|ARM
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Release|ARM.Deploy.0 = Release|ARM
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Release|ARM64.ActiveCfg = Release|ARM64
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Release|ARM64.Build.0 = Release|ARM64
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Release|ARM64.Deploy.0 = Release|ARM64
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Release|x64.ActiveCfg = Release|x64
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Release|x64.Build.0 = Release|x64
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Release|x64.Deploy.0 = Release|x64
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Release|x86.ActiveCfg = Release|Win32
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Release|x86.Build.0 = Release|Win32
		{87B1F195-0799-44B4-853B-2F0BC59102A6}.Release|x86.Deploy.0 = Release|Win32
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Debug|ARM.ActiveCfg = Debug|ARM
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Debug|ARM.Build.0 = Debug|ARM
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Debug|ARM.Deploy.0 = Debug|ARM
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Debug|ARM64.Build.0 = Debug|ARM64
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Debug|x64.ActiveCfg = Debug|x64
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Debug|x64.Build.0 = Debug|x64
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Debug|x64.Deploy.0 = Debug|x64
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Debug|x86.ActiveCfg = Debug|Win32
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Debug|x86.Build.0 = Debug|Win32
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Debug|x86.Deploy.0 = Debug|Win32
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Release|ARM.ActiveCfg = Release|ARM
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Release|ARM.Build.0 = Release|ARM
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Release|ARM.Deploy.0 = Release|ARM
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Release|ARM64.ActiveCfg = Release|ARM64
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Release|ARM64.Build.0 = Release|ARM64
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Release|ARM64.Deploy.0 = Release|ARM64
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Release|x64.ActiveCfg = Release|x64
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Release|x64.Build.0 = Release|x64
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Release|x64.Deploy.0 = Release|x64
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Release|x86.ActiveCfg = Release|Win32
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Release|x86.Build.0 = Release|Win32
		{488DEC0F-CC81-442E-AE88-821F5BB0D645}.Release|x86.Deploy.0 = Release|Win32
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Debug|ARM.ActiveCfg = Debug|ARM
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Debug|ARM.Build.0 = Debug|ARM
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Debug|ARM.Deploy.0 = Debug|ARM
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Debug|ARM64.Build.0 = Debug|ARM64
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Debug|x64.ActiveCfg = Debug|x64
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Debug|x64.Build.0 = Debug|x64
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Debug|x64.Deploy.0 = Debug|x64
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Debug|x86.ActiveCfg = Debug|Win32
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Debug|x86.Build.0 = Debug|Win32
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Debug|x86.Deploy.0 = Debug|Win32
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Release|ARM.ActiveCfg = Release|ARM
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Release|ARM.Build.0 = Release|ARM
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Release|ARM.Deploy.0 = Release|ARM
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Release|ARM64.ActiveCfg = Release|ARM64
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Release|ARM64.Build.0 = Release|ARM64
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Release|ARM64.Deploy.0 = Release|ARM64
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Release|x64.ActiveCfg = Release|x64
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Release|x64.Build.0 = Release|x64
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Release|x64.Deploy.0 = Release|x64
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Release|x86.ActiveCfg = Release|Win32
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Release|x86.Build.0 = Release|Win32
		{6145AEB4-744B-4290-A80D-25E6FF7571B6}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {BC90928B-8849-4020-8B47-9BC9CCA24433}
	EndGlobalSection
EndGlobal

```

`README.md`:

```md
# Practical Reverse Engineering Solutions
Some drivers + re work I've done while solving exercises from Practical Reverse Engineering.

**Note:** This was done on windows Redstone 5 (October Update) build 10.0.17763.107.  
It'll be a miracle if it works on any other version.

```