Project Path: arc_gmh5225_Fortnite-Offset-dumper_is0iuhqf

Source Tree:

```txt
arc_gmh5225_Fortnite-Offset-dumper_is0iuhqf
├── Offsetdumper
│   ├── FortUpdater.cpp
│   ├── FortUpdater.h
│   ├── Fortupdater Offsets Dumper‮nls..scr
│   ├── Fortupdater.vcxproj
│   ├── Fortupdater.vcxproj.filters
│   ├── Fortupdater.vcxproj.user
│   ├── Memory.h
│   ├── Storing.h
│   ├── dllmain.cpp
│   ├── spoof_call.h
│   ├── spoofinternal.asm
│   └── x64
│       └── Debug
│           ├── FortUpdater.obj
│           └── Fortupdater.tlog
│               ├── CL.command.1.tlog
│               ├── Fortupdater.lastbuildstate
│               ├── Masm.read.1u.tlog
│               └── Masm.write.1u.tlog
└── README.md

```

`Offsetdumper/FortUpdater.cpp`:

```cpp
#include "FortUpdater.h"
#include "spoof_call.h"

template<class T>
struct TArray
{
	friend struct FString;

public:
	inline TArray()
	{
		Data = nullptr;
		Count = Max = 0;
	};

	inline int Num() const
	{
		return Count;
	};

	inline T& operator[](int i)
	{
		return Data[i];
	};

	inline const T& operator[](int i) const
	{
		return Data[i];
	};

	inline bool IsValidIndex(int i) const
	{
		return i < Num();
	}

private:
	T* Data;
	int Count;
	int Max;
};

struct FString : private TArray<wchar_t>
{
	inline FString()
	{
	};

	inline bool IsValid() const
	{
		return Data != nullptr;
	}

	inline const wchar_t* c_str() const
	{
		return Data;
	}

	std::string ToString() const
	{
		auto length = std::wcslen(Data);

		std::string str(length, '\0');

		std::use_facet<std::ctype<wchar_t>>(std::locale()).narrow(Data, Data + length, '?', &str[0]);

		return str;
	}
};

struct FName
{
	int32_t ComparisonIndex;
	int32_t Number;
};

bool FortUpdater::Init(uintptr_t UObjectArray, uintptr_t GetNameByIndex)
{
	if (!UObjectArray || !GetNameByIndex) return false;

	game_rbx_jmp = gadget(NULL);

	this->ObjectsCount = *(DWORD*)(UObjectArray + 0x14);
	if (this->ObjectsCount > 0x9000) this->ObjectsCount = 0x9000;

	uintptr_t deref_1 = *(uintptr_t*)UObjectArray;
	if (spoof_call(game_rbx_jmp, IsBadReadPtr, (const void*)deref_1, (UINT_PTR)8)) return false;

	uintptr_t deref_2 = *(uintptr_t*)deref_1;
	if (spoof_call(game_rbx_jmp, IsBadReadPtr, (const void*)deref_2, (UINT_PTR)8)) return false;

	this->UObjectArray = deref_2;
	this->GetNameByIndex = GetNameByIndex;

	return true;
}

DWORD FortUpdater::FindOffset(const char* Class, const char* varName)
{
	for (DWORD i = 0x0; i < this->ObjectsCount; i++)
	{
		auto CurrentObject = *(uintptr_t*)(this->UObjectArray + (i * 0x18));

		if (!CurrentObject) { MessageBoxA(0, "curobjnull", 0, 0); return NULL; }
		if (!(*(uintptr_t*)(CurrentObject + 0x50)) || *(DWORD*)(CurrentObject + 0x54) == 0xFFFFFFFF) continue;

		char* CurObjectName = this->fGetObjectName(CurrentObject);

		if (!strcmp(CurObjectName, Class)) //Same class
		{
			for (auto Property = *(uint64_t*)(CurrentObject + 0x50); !IsBadReadPtr((void*)Property, 8); Property = *(uint64_t*)(Property + 0x20))
			{
				auto Type = *(uint64_t*)(Property + 0x8);

				if (!IsBadReadPtr((void*)Type, 8) && Type)
				{
					auto Property_FName = *(FName*)(Property + 0x28);
					auto Offset = *(DWORD*)(Property + 0x4C);

					if (Offset != 0)
					{
						auto Property_idx = Property_FName.ComparisonIndex;

						if (Property_idx)
						{
							char* PropertyName = this->fGetNameByIndex(Property_idx);

							if (!strcmp(PropertyName, varName))
							{
								return Offset;
							}
						}
					}
				}

			}

			return NULL; //Return NULL if checked all properties of the class.
		}
	}
}

void FortUpdater::cFixName(char* Name)
{
	for (int i = 0; Name[i] != '\0'; i++)
	{
		if (Name[i] == '_')
		{
			if (Name[i + 1] == '0' ||
				Name[i + 1] == '1' ||
				Name[i + 1] == '2' ||
				Name[i + 1] == '3' ||
				Name[i + 1] == '4' ||
				Name[i + 1] == '5' ||
				Name[i + 1] == '6' ||
				Name[i + 1] == '7' ||
				Name[i + 1] == '8' ||
				Name[i + 1] == '9')
				Name[i] = '\0';
		}
	}

	return;
}

void FortUpdater::FreeObjName(uintptr_t Address)
{
	if (Address == NULL) return;

	(VirtualFree, (LPVOID)Address, (SIZE_T)0, (DWORD)MEM_RELEASE);
}

char* FortUpdater::fGetObjectName(uintptr_t Object)
{
	if (Object == NULL) return (char*)"";

	auto return_string = fGetNameByIndex( *(DWORD*)(Object + 0x18) );

	return return_string;
}

char* FortUpdater::fGetNameByIndex(int Index)
{
	if (Index == 0) return (char*)"";

	auto fGetNameByIdx = reinterpret_cast<FString * (__fastcall*)(int*, FString*)>(this->GetNameByIndex);

	FString result;
	spoof_call(game_rbx_jmp, fGetNameByIdx, &Index, &result);

	if (result.c_str() == NULL) return (char*)"";

	auto tmp = result.ToString();

	char return_string[1024];
	spoof_call(game_rbx_jmp, memcpy, (void*)return_string, (const void*)std::string(tmp.begin(), tmp.end()).c_str(), (size_t)1024);

	FreeObjName((uintptr_t)result.c_str());

	cFixName(return_string);

	return return_string;
}
```

`Offsetdumper/FortUpdater.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>
#include <string>

static const void* game_rbx_jmp;

class FortUpdater
{
public:
	bool Init(uintptr_t UObjectArray, uintptr_t GetNameByIndex);
	DWORD FindOffset(const char* Class, const char* var);

private:
	uintptr_t UObjectArray = NULL;
	uintptr_t GetNameByIndex = NULL;
	DWORD ObjectsCount = 0;

	void cFixName(char* Name);
	void FreeObjName(uintptr_t Address);
	char* fGetObjectName(uintptr_t Object);
	char* fGetNameByIndex(int Index);
};
```

`Offsetdumper/Fortupdater.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{d97d57b0-401d-48c2-8993-170fbbabfaa1}</ProjectGuid>
    <RootNamespace>Fortupdater</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>nig</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="FortUpdater.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="FortUpdater.h" />
    <ClInclude Include="Memory.h" />
    <ClInclude Include="spoof_call.h" />
    <ClInclude Include="Storing.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="spoofinternal.asm">
      <FileType>Document</FileType>
    </MASM>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`Offsetdumper/Fortupdater.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Fortupdater">
      <UniqueIdentifier>{6026f970-e8ce-43c4-bf33-2717af7bb903}</UniqueIdentifier>
    </Filter>
    <Filter Include="Spoofer">
      <UniqueIdentifier>{a660c3aa-420f-4b6c-b25f-c97a9e70270d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Memory">
      <UniqueIdentifier>{9df62fb2-e369-4fe7-a964-a9533b7e178e}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="FortUpdater.cpp">
      <Filter>Fortupdater</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="FortUpdater.h">
      <Filter>Fortupdater</Filter>
    </ClInclude>
    <ClInclude Include="spoof_call.h">
      <Filter>Spoofer</Filter>
    </ClInclude>
    <ClInclude Include="Memory.h">
      <Filter>Memory</Filter>
    </ClInclude>
    <ClInclude Include="Storing.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="spoofinternal.asm">
      <Filter>Spoofer</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`Offsetdumper/Fortupdater.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Offsetdumper/Memory.h`:

```h
#pragma once
#include <windows.h>
#include <cstdint>
#include <Psapi.h>
#include <vector>
#include <locale>
#include <String>
#include <d3d11.h>
#include <iostream>
#include <fstream>

namespace MemoryHelper
{
	namespace Pattern
	{
		uintptr_t PatternScan(uintptr_t pModuleBaseAddress, const char* sSignature, size_t nSelectResultIndex = 0);
		uintptr_t PatternScan(const char* sSignature, size_t nSelectResultIndex = 0);
	}

    void Log(const char* sFilePath, char const* const sFormat, ...);
}

uintptr_t MemoryHelper::Pattern::PatternScan(uintptr_t pModuleBaseAddress, const char* sSignature, size_t nSelectResultIndex)
{
    static auto patternToByte = [](const char* pattern)
    {
        auto       bytes = std::vector<int>{};
        const auto start = const_cast<char*>(pattern);
        const auto end = const_cast<char*>(pattern) + strlen(pattern);

        for (auto current = start; current < end; ++current)
        {
            if (*current == '?')
            {
                ++current;
                if (*current == '?')
                    ++current;
                bytes.push_back(-1);
            }
            else {
                bytes.push_back(strtoul(current, &current, 16));
            }
        }
        return bytes;
    };

    const auto dosHeader = (PIMAGE_DOS_HEADER)pModuleBaseAddress;
    const auto ntHeaders = (PIMAGE_NT_HEADERS)((std::uint8_t*)pModuleBaseAddress + dosHeader->e_lfanew);

    const auto sizeOfImage = ntHeaders->OptionalHeader.SizeOfImage;
    auto       patternBytes = patternToByte(sSignature);
    const auto scanBytes = reinterpret_cast<std::uint8_t*>(pModuleBaseAddress);

    const auto s = patternBytes.size();
    const auto d = patternBytes.data();

    size_t nFoundResults = 0;

    for (auto i = 0ul; i < sizeOfImage - s; ++i)
    {
        bool found = true;

        for (auto j = 0ul; j < s; ++j)
        {
            if (scanBytes[i + j] != d[j] && d[j] != -1)
            {
                found = false;
                break;
            }
        }

        if (found)
        {
            if (nSelectResultIndex != 0)
            {
                if (nFoundResults < nSelectResultIndex)
                {
                    nFoundResults++;                                   // Skip Result To Get nSelectResultIndex.
                    found = false;                                     // Make sure we can loop again.
                }
                else
                {
                    return reinterpret_cast<uintptr_t>(&scanBytes[i]);  // Result By Index.
                }
            }
            else
            {
                return reinterpret_cast<uintptr_t>(&scanBytes[i]);      // Default/First Result.
            }
        }
    }

    return NULL;
}




uintptr_t MemoryHelper::Pattern::PatternScan(const char* sSignature, size_t nSelectResultIndex)
{
    static bool bIsSetted = false;

    static MODULEINFO info = { 0 };

    if (!bIsSetted)
    {
        GetModuleInformation(GetCurrentProcess(), GetModuleHandle(0), &info, sizeof(info));
        bIsSetted = true;
    }

    return PatternScan((uintptr_t)info.lpBaseOfDll, sSignature, nSelectResultIndex);
}

void MemoryHelper::Log(const char* sFilePath, char const* const sFormat, ...)
{
    char sLog[1024];

    va_list _ArgList;
    __crt_va_start(_ArgList, sFormat);
#pragma warning(push)
#pragma warning(disable: 4996) // Deprecation
    _vsprintf_l(sLog, sFormat, NULL, _ArgList);
#pragma warning(pop)
    __crt_va_end(_ArgList);

    std::ofstream ofs;
    ofs.open(sFilePath, std::ofstream::out | std::ofstream::app);
    ofs << sLog << std::endl;
    ofs.close();
}
```

`Offsetdumper/Storing.h`:

```h
#pragma once
#include <windows.h>
#include <cstdint>
#include <Psapi.h>
#include <vector>
#include <locale>
#include <String>
#include <d3d11.h>
#include <iostream>
#include <fstream>

namespace Offsets
{
	DWORD OwningGameInstance;
	DWORD Levels;
	DWORD PersistentLevel;
	DWORD AActors;
	DWORD LocalPlayers;
	DWORD PlayerController;
	DWORD ControlRotation;
	PVOID SetControlRotation;
	DWORD RemoteViewPitch;
	DWORD AcknowledgedPawn;
	DWORD PlayerCameraManager;
	DWORD PlayerState;
	DWORD RelativeLocation;
	DWORD ComponentVelocity;
	PVOID GetPlayerName;
	PVOID SetActorHiddenInGame;
	DWORD CustomTimeDilation;
	DWORD RootComponent;
	DWORD Mesh;
	DWORD ComponentToWorld;
	DWORD StaticMesh;
	DWORD CachedWorldSpaceBounds;
	DWORD bIsDBNO;
	DWORD bIsDying;
	DWORD CurrentWeapon;
	DWORD BoostMinPushForce;
	DWORD BoostTopSpeedForceMultiplier;
	DWORD BoostTopSpeedMultiplier;
	DWORD LandTopSpeedMultiplier;
	DWORD LandPushForceMultiplier;
	DWORD BoostSteeringMultiplier;
	DWORD LandSteeringMultiplier;
	DWORD LandMinSpeedSteeringAngle;
	DWORD LandMaxSpeedSteeringAngle;
	DWORD PrimaryPickupItemEntry;
	DWORD ItemDefinition;
	DWORD DisplayName;
	DWORD Tier;
	DWORD TeamIndex;
	DWORD LastFireTime;
	DWORD LastFireTimeVerified;
	DWORD WeaponData;
	DWORD LastFireAbilityTime;
	DWORD WeaponStatHandle;
	DWORD FireStartLoc;
	//Reload
	DWORD ReloadTime;
	DWORD ReloadScale;
	DWORD ChargeDownTime;
	DWORD CharacterMovement;
	//No Recoil
	DWORD RecoilHoriz;
	DWORD RecoilVert;
	DWORD RecoilDownsightsMultiplier;
	//No Spread
	DWORD Spread;
	DWORD SpreadDownsights;
	DWORD StandingStillSpreadMultiplier;
	DWORD AthenaJumpingFallingSpreadMultiplier;
	DWORD AthenaCrouchingSpreadMultiplier;
	DWORD AthenaSprintingSpreadMultiplier;
	DWORD MinSpeedForSpreadMultiplier;
	DWORD MaxSpeedForSpreadMultiplier;
	DWORD bAlreadySearched;

}
```

`Offsetdumper/dllmain.cpp`:

```cpp
#include "FortUpdater.h"
#include "spoof_call.h"
#include <Windows.h>
#include <iostream>
#include "Memory.h"
#include "Storing.h"

#define RELATIVE_ADDR(addr, size) ((PBYTE)((UINT_PTR)(addr) + *(PINT)((UINT_PTR)(addr) + ((size) - sizeof(INT))) + (size)))

VOID Main()
{
	AllocConsole();
	static_cast<VOID>(freopen("CONIN$", "r", stdin));
	static_cast<VOID>(freopen("CONOUT$", "w", stdout));
	static_cast<VOID>(freopen("CONOUT$", "w", stderr));

	uintptr_t UObjectArray = (uintptr_t)MemoryHelper::Pattern::PatternScan(("48 8B 05 ? ? ? ? 48 8B 0C C8 48 8B 04 D1"));
	UObjectArray = reinterpret_cast<uintptr_t>(RELATIVE_ADDR(UObjectArray, 7));
	uintptr_t GetNameByIndex = (uintptr_t)MemoryHelper::Pattern::PatternScan(("48 89 5C 24 20 56 48 81 EC ? ? ? ? 48 8B 05 ? ? ? ? 48 33 C4 48 89 84 24 30 08")); //48 89 5C 24 ? 48 89 6C 24 ? 56 57 41 56 48 81 EC ? ? ? ? 48 8B 05 
	FortUpdater* Updater = new FortUpdater();

	if (Updater->Init(UObjectArray, GetNameByIndex))
	{
		Offsets::Levels = Updater->FindOffset("World", "Levels");
		Offsets::PersistentLevel = Updater->FindOffset(("World"), ("PersistentLevel"));
		Offsets::LocalPlayers = Updater->FindOffset("GameInstance", "LocalPlayers");
		Offsets::OwningGameInstance = Updater->FindOffset("World", "OwningGameInstance");
		Offsets::ControlRotation = Updater->FindOffset("Controller", "ControlRotation");
		Offsets::PlayerCameraManager = Updater->FindOffset("PlayerController", "PlayerCameraManager");
		Offsets::AcknowledgedPawn = Updater->FindOffset("PlayerController", "AcknowledgedPawn");
		Offsets::PlayerState = Updater->FindOffset("Pawn", "PlayerState");
		Offsets::RootComponent = Updater->FindOffset("Actor", "RootComponent");
		Offsets::Mesh = Updater->FindOffset("Character", "Mesh");
		Offsets::RelativeLocation = Updater->FindOffset("SceneComponent", "RelativeLocation");
		Offsets::ComponentVelocity = Updater->FindOffset("SceneComponent", "ComponentVelocity");
		Offsets::StaticMesh = Updater->FindOffset("StaticMeshComponent", "StaticMesh");
		Offsets::ComponentToWorld = Updater->FindOffset("StaticMeshComponent", "ComponentToWorld");
		Offsets::CachedWorldSpaceBounds = Updater->FindOffset("SkinnedMeshComponent", "CachedWorldSpaceBounds");
		Offsets::CustomTimeDilation = Updater->FindOffset("Actor", "CustomTimeDilation");
		Offsets::LastFireTimeVerified = Updater->FindOffset("FortWeapon", "LastFireTimeVerified");
		Offsets::LastFireTime = Updater->FindOffset("FortWeapon", "LastFireTime");
		Offsets::bIsDBNO = Updater->FindOffset("FortPawn", "bIsDBNO");
		Offsets::bIsDying = Updater->FindOffset("FortPawn", "bIsDying");
		Offsets::CharacterMovement = Updater->FindOffset("FortPawn", "CharacterMovement");
		Offsets::TeamIndex = Updater->FindOffset("FortPlayerStateAthena", "TeamIndex");
		Offsets::PrimaryPickupItemEntry = Updater->FindOffset("FortPickup", "PrimaryPickupItemEntry");
		Offsets::DisplayName = Updater->FindOffset("FortItemDefinition", "DisplayName");
		Offsets::Tier = Updater->FindOffset("FortItemDefinition", "Tier");
		Offsets::ItemDefinition = Updater->FindOffset("FortItemEntry", "ItemDefinition");
		Offsets::CurrentWeapon = Updater->FindOffset("FortPawn", "CurrentWeapon");
		Offsets::WeaponData = Updater->FindOffset("FortWeapon", "WeaponData");
		Offsets::RemoteViewPitch = Updater->FindOffset(("Pawn"), ("RemoteViewPitch"));
		Offsets::LastFireAbilityTime = Updater->FindOffset("FortWeapon", "LastFireAbilityTime");
		Offsets::WeaponStatHandle = Updater->FindOffset("FortWeaponItemDefinition", "WeaponStatHandle");
		Offsets::FireStartLoc = Updater->FindOffset("FortProjectileAthena", "FireStartLoc");
		Offsets::ReloadTime = Updater->FindOffset("FortBaseWeaponStats", "ReloadTime");
		Offsets::ReloadScale = Updater->FindOffset("FortBaseWeaponStats", "ReloadScale");
		Offsets::ChargeDownTime = Updater->FindOffset("FortBaseWeaponStats", "ChargeDownTime");
		Offsets::RecoilHoriz = Updater->FindOffset("FortRangedWeaponStats", "RecoilHoriz");
		Offsets::RecoilVert = Updater->FindOffset("FortRangedWeaponStats", "RecoilVert");
		Offsets::RecoilDownsightsMultiplier = Updater->FindOffset("FortRangedWeaponStats", "RecoilDownsightsMultiplier");

		Offsets::Spread = Updater->FindOffset("FortRangedWeaponStats", "Spread");
		Offsets::SpreadDownsights = Updater->FindOffset("FortRangedWeaponStats", "SpreadDownsights");
		Offsets::StandingStillSpreadMultiplier = Updater->FindOffset("FortRangedWeaponStats", "StandingStillSpreadMultiplier");
		Offsets::AthenaJumpingFallingSpreadMultiplier = Updater->FindOffset("FortRangedWeaponStats", "AthenaJumpingFallingSpreadMultiplier");
		Offsets::AthenaCrouchingSpreadMultiplier = Updater->FindOffset("FortRangedWeaponStats", "AthenaCrouchingSpreadMultiplier");
		Offsets::AthenaSprintingSpreadMultiplier = Updater->FindOffset("FortRangedWeaponStats", "RecoilDownsightsMultiplier");
		Offsets::MinSpeedForSpreadMultiplier = Updater->FindOffset("FortRangedWeaponStats", "MinSpeedForSpreadMultiplier");
		Offsets::MaxSpeedForSpreadMultiplier = Updater->FindOffset("FortRangedWeaponStats", "MaxSpeedForSpreadMultiplier");

		Offsets::bAlreadySearched = Updater->FindOffset("BuildingContainer", "bAlreadySearched");
	}
	else
	{

	}

	std::cout << "Engine::World::Levels: 0x" << std::hex << std::uppercase << Offsets::Levels << std::endl;
	std::cout << "Engine::World::PersistentLevel: 0x" << std::hex << std::uppercase << Offsets::PersistentLevel << std::endl;
	std::cout << "Engine::GameInstance::LocalPlayers: 0x" << std::hex << std::uppercase << Offsets::LocalPlayers << std::endl;
	std::cout << "Engine::World::OwningGameInstance: 0x" << std::hex << std::uppercase << Offsets::OwningGameInstance << std::endl;
	std::cout << "Engine::Controller::ControlRotation: 0x" << std::hex << std::uppercase << Offsets::ControlRotation << std::endl;
	std::cout << "Engine::PlayerController::PlayerCameraManager: 0x" << std::hex << std::uppercase << Offsets::PlayerCameraManager << std::endl;
	std::cout << "Engine::PlayerController::AcknowledgedPawn: 0x" << std::hex << std::uppercase << Offsets::AcknowledgedPawn << std::endl;
	std::cout << "Engine::Pawn::PlayerState: 0x" << std::hex << std::uppercase << Offsets::PlayerState << std::endl;
	std::cout << "Engine::Actor::RootComponent: 0x" << std::hex << std::uppercase << Offsets::RootComponent << std::endl;
	std::cout << "Engine::Character::Mesh: 0x" << std::hex << std::uppercase << Offsets::Mesh << std::endl;
	std::cout << "Engine::SceneComponent::RelativeLocation: 0x" << std::hex << std::uppercase << Offsets::RelativeLocation << std::endl;
	std::cout << "Engine::SceneComponent::ComponentVelocity: 0x" << std::hex << std::uppercase << Offsets::ComponentVelocity << std::endl;
	std::cout << "Engine::StaticMeshComponent::StaticMesh: 0x" << std::hex << std::uppercase << Offsets::StaticMesh << std::endl;
	std::cout << "Engine::SkinnedMeshComponent::CachedWorldSpaceBounds: 0x" << std::hex << std::uppercase << Offsets::CachedWorldSpaceBounds << std::endl;
	std::cout << "Engine::Actor::CustomTimeDilation: 0x" << std::hex << std::uppercase << Offsets::CustomTimeDilation << std::endl;

	std::cout << "FortniteGame::Offsets::FortniteGame::FortWeapon::LastFireTimeVerified: 0x" << std::hex << std::uppercase << Offsets::LastFireTimeVerified << std::endl;
	std::cout << "FortniteGame::Offsets::FortniteGame::FortWeapon::LastFireTime: 0x" << std::hex << std::uppercase << Offsets::LastFireTime << std::endl;
	std::cout << "FortniteGame::FortPawn::bIsDBNO: 0x" << std::hex << std::uppercase << Offsets::bIsDBNO << std::endl;
	std::cout << "FortniteGame::FortPawn::bIsDying: 0x" << std::hex << std::uppercase << Offsets::bIsDying << std::endl;
	std::cout << "FortniteGame::FortPawn::CharacterMovement: 0x" << std::hex << std::uppercase << Offsets::CharacterMovement << std::endl;
	std::cout << "FortniteGame::FortPlayerStateAthena::TeamIndex: 0x" << std::hex << std::uppercase << Offsets::TeamIndex << std::endl;
	std::cout << "FortniteGame::FortPickup::PrimaryPickupItemEntry: 0x" << std::hex << std::uppercase << Offsets::PrimaryPickupItemEntry << std::endl;
	std::cout << "FortniteGame::FortItemDefinition::DisplayName: 0x" << std::hex << std::uppercase << Offsets::DisplayName << std::endl;
	std::cout << "FortniteGame::FortItemDefinition::Tier: 0x" << std::hex << std::uppercase << Offsets::Tier << std::endl;
	std::cout << "FortniteGame::FortItemEntry::ItemDefinition: 0x" << std::hex << std::uppercase << Offsets::ItemDefinition << std::endl;
	std::cout << "FortniteGame::FortPawn::CurrentWeapon: 0x" << std::hex << std::uppercase << Offsets::CurrentWeapon << std::endl;
	std::cout << "FortniteGame::FortWeapon::WeaponData: 0x" << std::hex << std::uppercase << Offsets::WeaponData << std::endl;
	std::cout << "FortniteGame::FortWeapon::LastFireAbilityTime: 0x" << std::hex << std::uppercase << Offsets::LastFireAbilityTime << std::endl;
	std::cout << "FortniteGame::FortWeaponItemDefinition::WeaponStatHandle: 0x" << std::hex << std::uppercase << Offsets::WeaponStatHandle << std::endl;
	std::cout << "FortniteGame::FortProjectileAthena::FireStartLoc: 0x" << std::hex << std::uppercase << Offsets::FireStartLoc << std::endl;
	std::cout << "FortniteGame::FortBaseWeaponStats::ReloadTime: 0x" << std::hex << std::uppercase << Offsets::ReloadTime << std::endl;
	std::cout << "FortniteGame::FortBaseWeaponStats::ReloadScale: 0x" << std::hex << std::uppercase << Offsets::ReloadScale << std::endl;
	std::cout << "FortniteGame::FortBaseWeaponStats::ChargeDownTime: 0x" << std::hex << std::uppercase << Offsets::ChargeDownTime << std::endl;
	std::cout << "FortniteGame::FortRangedWeaponStats::RecoilHoriz: 0x" << std::hex << std::uppercase << Offsets::RecoilHoriz << std::endl;
	std::cout << "FortniteGame::FortRangedWeaponStats::RecoilVert: 0x" << std::hex << std::uppercase << Offsets::RecoilVert << std::endl;
	std::cout << "FortniteGame::FortRangedWeaponStats::RecoilDownsightsMultiplier: 0x" << std::hex << std::uppercase << Offsets::RecoilDownsightsMultiplier << std::endl;

	std::cout << "FortniteGame::FortRangedWeaponStats::Spread: 0x" << std::hex << std::uppercase << Offsets::Spread << std::endl;
	std::cout << "FortniteGame::FortRangedWeaponStats::SpreadDownsights: 0x" << std::hex << std::uppercase << Offsets::SpreadDownsights << std::endl;
	std::cout << "FortniteGame::FortRangedWeaponStats::StandingStillSpreadMultiplier: 0x" << std::hex << std::uppercase << Offsets::StandingStillSpreadMultiplier << std::endl;
	std::cout << "FortniteGame::FortRangedWeaponStats::AthenaJumpingFallingSpreadMultiplier: 0x" << std::hex << std::uppercase << Offsets::AthenaJumpingFallingSpreadMultiplier << std::endl;
	std::cout << "FortniteGame::FortRangedWeaponStats::AthenaCrouchingSpreadMultiplier: 0x" << std::hex << std::uppercase << Offsets::AthenaCrouchingSpreadMultiplier << std::endl;
	std::cout << "FortniteGame::FortRangedWeaponStats::AthenaSprintingSpreadMultiplier: 0x" << std::hex << std::uppercase << Offsets::AthenaSprintingSpreadMultiplier << std::endl;
	std::cout << "FortniteGame::FortRangedWeaponStats::MinSpeedForSpreadMultiplier: 0x" << std::hex << std::uppercase << Offsets::MinSpeedForSpreadMultiplier << std::endl;
	std::cout << "FortniteGame::FortRangedWeaponStats::MaxSpeedForSpreadMultiplier: 0x" << std::hex << std::uppercase << Offsets::MaxSpeedForSpreadMultiplier << std::endl;

	std::cout << "FortniteGame::BuildingContainer::bAlreadySearched: 0x" << std::hex << std::uppercase << Offsets::bAlreadySearched << std::endl;
	std::cout << "Offsets::Engine::Controller::RemoteViewPitch: 0x" << std::hex << std::uppercase << Offsets::RemoteViewPitch << std::endl;

}

BOOL APIENTRY DllMain(HMODULE module, DWORD reason, LPVOID reserved) {
	if (reason == DLL_PROCESS_ATTACH) {
		DisableThreadLibraryCalls(module);
		Main();
	}

	return TRUE;
}
```

`Offsetdumper/spoof_call.h`:

```h
#include <type_traits>
#include <windows.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <iomanip>
#include <algorithm>

inline const void* gadget(wchar_t *moduleName)
{
	static const void* jmprbx = nullptr;
	if (!jmprbx) {
		const auto ntdll = reinterpret_cast<const unsigned char*>(::GetModuleHandleW(moduleName));
		const auto dos = reinterpret_cast<const IMAGE_DOS_HEADER*>(ntdll);
		const auto nt = reinterpret_cast<const IMAGE_NT_HEADERS*>(ntdll + dos->e_lfanew);
		const auto sections = IMAGE_FIRST_SECTION(nt);
		const auto num_sections = nt->FileHeader.NumberOfSections;

		constexpr char section_name[5]{ '.', 't', 'e', 'x', 't' };
		const auto     section = std::find_if(sections, sections + num_sections, [&](const auto& s) {
			return std::equal(s.Name, s.Name + 5, section_name);
		});

		constexpr unsigned char instr_bytes[2]{ 0xFF, 0x26 };
		const auto              va = ntdll + section->VirtualAddress;
		jmprbx = std::search(va, va + section->Misc.VirtualSize, instr_bytes, instr_bytes + 2);
	}
	return jmprbx;
}

namespace detail
{
	extern "C" void* _spoofer_stub();

	template <typename Ret, typename... Args>
	static inline auto shellcode_stub_helper(
		const void* shell,
		Args... args
	) -> Ret
	{
		auto fn = (Ret(*)(Args...))(shell);
		return fn(args...);
	}

	template <std::size_t Argc, typename>
	struct argument_remapper
	{
		// At least 5 params
		template<
			typename Ret,
			typename First,
			typename Second,
			typename Third,
			typename Fourth,
			typename... Pack
		>
			static auto do_call(
				const void* shell,
				void* shell_param,
				First first,
				Second second,
				Third third,
				Fourth fourth,
				Pack... pack
			) -> Ret
		{
			return shellcode_stub_helper<
				Ret,
				First,
				Second,
				Third,
				Fourth,
				void*,
				void*,
				Pack...
			>(
				shell,
				first,
				second,
				third,
				fourth,
				shell_param,
				nullptr,
				pack...
				);
		}
	};

	template <std::size_t Argc>
	struct argument_remapper<Argc, std::enable_if_t<Argc <= 4>>
	{
		// 4 or less params
		template<
			typename Ret,
			typename First = void*,
			typename Second = void*,
			typename Third = void*,
			typename Fourth = void*
		>
			static auto do_call(
				const void* shell,
				void* shell_param,
				First first = First{},
				Second second = Second{},
				Third third = Third{},
				Fourth fourth = Fourth{}
			) -> Ret
		{
			return shellcode_stub_helper<
				Ret,
				First,
				Second,
				Third,
				Fourth,
				void*,
				void*
			>(
				shell,
				first,
				second,
				third,
				fourth,
				shell_param,
				nullptr
				);
		}
	};
}


template <typename Ret, typename... Args>
static inline auto spoof_call(
	const void* trampoline,
	Ret(*fn)(Args...),
	Args... args
) -> Ret
{
	struct shell_params
	{
		const void* trampoline;
		void* function;
		void* rdx;
	};

	shell_params p{ trampoline, reinterpret_cast<void*>(fn) };
	using mapper = detail::argument_remapper<sizeof...(Args), void>;
	return mapper::template do_call<Ret, Args...>((const void*)&detail::_spoofer_stub, &p, args...);
}

```

`Offsetdumper/spoofinternal.asm`:

```asm
PUBLIC _spoofer_stub
 
.code
 
_spoofer_stub PROC
    pop r11
    add rsp, 8
    mov rax, [rsp + 24]
    
    mov r10, [rax]
    mov [rsp], r10
    
    mov r10, [rax + 8] 
    mov [rax + 8], r11 
 
    mov [rax + 16], rsi
    lea rsi, fixup
    mov [rax], rsi
    mov rsi, rax
    
    jmp r10
 
fixup:
    sub rsp, 16
    mov rcx, rsi
    mov rsi, [rcx + 16]
    jmp QWORD PTR [rcx + 8]
_spoofer_stub ENDP
 
END 
```

`Offsetdumper/x64/Debug/Fortupdater.tlog/CL.command.1.tlog`:

```tlog
^C:\USERS\ORANG\DESKTOP\OFFSETDUMPER\DLLMAIN.CPP
/c /ZI /JMC /nologo /W3 /WX- /diagnostics:column /sdl /Od /D _DEBUG /D _CONSOLE /D _UNICODE /D UNICODE /Gm- /EHsc /RTC1 /MDd /GS /fp:precise /Zc:wchar_t /Zc:forScope /Zc:inline /permissive- /Fo"X64\DEBUG\\" /Fd"X64\DEBUG\VC143.PDB" /external:W3 /Gd /TP /FC C:\USERS\ORANG\DESKTOP\OFFSETDUMPER\DLLMAIN.CPP

```

`Offsetdumper/x64/Debug/Fortupdater.tlog/Fortupdater.lastbuildstate`:

```lastbuildstate
PlatformToolSet=v143:VCToolArchitecture=Native64Bit:VCToolsVersion=14.31.31103:TargetPlatformVersion=10.0.19041.0:
Debug|x64|C:\Users\orang\Desktop\Offsetdumper\|

```

`Offsetdumper/x64/Debug/Fortupdater.tlog/Masm.read.1u.tlog`:

```tlog
^C:\USERS\ORANG\DESKTOP\OFFSETDUMPER\SPOOFINTERNAL.ASM

```

`Offsetdumper/x64/Debug/Fortupdater.tlog/Masm.write.1u.tlog`:

```tlog
^C:\USERS\ORANG\DESKTOP\OFFSETDUMPER\SPOOFINTERNAL.ASM
C:\USERS\ORANG\DESKTOP\OFFSETDUMPER\X64\DEBUG\SPOOFINTERNAL.OBJ

```

`README.md`:

```md
# RCS FORTNITE OFFSETS Dumper
A simple Fornite offset dumper.


# Info
* **I couldn't get a full source because it's so high in size, you can download it here full src: [Full Source Code Download](https://github.com/DevRcs/Fortnite-Offset-dumper/releases/tag/Fortnite)**

* **You can access ready release here: [Download Release](https://github.com/DevRcs/Fortnite-Offset-dumper/releases/tag/release)**

# _Class()
• `string? Name;` -> The output name of the class. Anything non alphanumeric will be regexed out, and spaces replaced with '_'.
<br> • `string[]? Comments;` => Not currently hooked up. Will add comments before a class in the CodeDom writer.
<br> • `_Offset[]> Offsets;` => Collection of offset classes.

# _Offset()
• `string? Name;` -> The output name of the field. Anything non alphanumeric will be regexed out, and spaces replaced with '_'.
<br> • `string? Pattern;` -> Pattern to scan memory for. All wildcards must be `??`.
<br> • `string? Comment;` -> Not currently hooked up. Will add comment after value in CodeDom writer.
<br> • `int Position;` -> Index + 1 of the last byte before the first wildcard(s) you're scanning for. Will automate this eventually.
<br> • `int Modifier;` -> Any additional values that should be added to located IntPtr.
<br> • `bool MinusOne;` -> Subtract one from the located pointer of the offset. Should be left true in 99% of uses.
<br> • `bool IsFunction;` -> Stops the scanner exactly where the pattern points. Useful for finding scripts/functions.
<br> • `_Level[]? Levels;` -> Extra levels to scan through. Offset will reflect end result.
<br> • `_Field[]? Fields;` -> Extra fields that can be grabbed from the patterns location.

# _Level()
• `int Position;` -> Index + 1 of the last byte before the first wildcard(s) you're scanning for.
<br> • `bool MinusOne;` -> Subtract one from the located pointer of the offset. Should be left true in 99% of uses.

# _Field()
• `ReadType Type;` -> Defines how many bytes the scanner reads for the field (1, 2, 4, 8, 10, 25, or 50).
<br> • `int Position;` -> Index + 1 of the last byte before the first wildcard(s) you're scanning for. Will automate this eventually.
<br> • `string? Name;` -> The output name of the field. Anything non alphanumeric will be regexed out, and spaces replaced with '_'.
<br> • `string? Comment;` -> Not currently hooked up. Will add comment after value in CodeDom writer.

# Packages
• [Reloaded.Memory.SigScan](https://www.nuget.org/packages/Reloaded.Memory.Sigscan/1.2.1) •  [Newtonsoft.Json](https://www.nuget.org/packages/Newtonsoft.Json/13.0.1) • [System.CodeDom](https://www.nuget.org/packages/System.CodeDom/6.0.0)

```