Project Path: arc_gmh5225_anti-cheat_c97kmc2g

Source Tree:

```txt
arc_gmh5225_anti-cheat_c97kmc2g
├── Anti_Hack_Shield
│   ├── AH_internal.h
│   ├── Anti_Hack_Shield.aps
│   ├── Anti_Hack_Shield.cpp
│   ├── Anti_Hack_Shield.rc
│   ├── Anti_Hack_Shield.vcxproj
│   ├── Anti_Hack_Shield.vcxproj.filters
│   ├── Anti_Hack_Shield.vcxproj.user
│   ├── antihack.cpp
│   ├── antihack.h
│   ├── dllload_blocker.h
│   ├── message_filterproc.h
│   ├── process_scanner.h
│   ├── resource.h
│   ├── sendinput_blocker.h
│   ├── sendmessage_blocker.h
│   ├── sendmsg_dispatcher.h
│   ├── sendmsg_dispatcher_old.h
│   ├── stdafx.cpp
│   ├── stdafx.h
│   ├── thread_blocker.h
│   ├── window.cpp
│   └── window.h
├── Anti_Hack_Shield.VC.db
├── Anti_Hack_Shield.sln
└── README.md

```

`Anti_Hack_Shield.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Anti_Hack_Shield", "Anti_Hack_Shield\Anti_Hack_Shield.vcxproj", "{7ACCF76F-D8BC-404F-9B10-01D96219F8B0}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7ACCF76F-D8BC-404F-9B10-01D96219F8B0}.Debug|x64.ActiveCfg = Debug|x64
		{7ACCF76F-D8BC-404F-9B10-01D96219F8B0}.Debug|x64.Build.0 = Debug|x64
		{7ACCF76F-D8BC-404F-9B10-01D96219F8B0}.Debug|x86.ActiveCfg = Debug|Win32
		{7ACCF76F-D8BC-404F-9B10-01D96219F8B0}.Debug|x86.Build.0 = Debug|Win32
		{7ACCF76F-D8BC-404F-9B10-01D96219F8B0}.Release|x64.ActiveCfg = Release|x64
		{7ACCF76F-D8BC-404F-9B10-01D96219F8B0}.Release|x64.Build.0 = Release|x64
		{7ACCF76F-D8BC-404F-9B10-01D96219F8B0}.Release|x86.ActiveCfg = Release|Win32
		{7ACCF76F-D8BC-404F-9B10-01D96219F8B0}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Anti_Hack_Shield/AH_internal.h`:

```h
#pragma once


#define ANTIHACK_DLL   1
#define ANTIHACK_MSG   2
#define ANTIHACK_MSG_1 4


#define THREAD_REASON_REMOTE 1
#define THREAD_REASON_UNBASE 2
#define THREAD_REASON_SUSPECTED_ADDRESS 3



#define STATUS_SUCCESS  ((NTSTATUS)0x0)
#define STATUS_INFO_LENGTH_MISMATCH 0xc0000004

#define ObjectBasicInformation 0
#define ObjectNameInformation 1
#define ObjectTypeInformation 2
#define SystemHandleInformation 16


struct __keyallow{
	bool Key;
	DWORD Block_WM_KEY_DOWN_counter;
	DWORD Block_WM_KEY_UP_counter;
};


typedef struct _SYSTEM_HANDLE
{
	ULONG ProcessId;
	BYTE ObjectTypeNumber;
	BYTE Flags;
	USHORT Handle;
	PVOID Object;
	ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE, *PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG HandleCount;
	SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef enum _POOL_TYPE
{
	NonPagedPool,
	PagedPool,
	NonPagedPoolMustSucceed,
	DontUseThisType,
	NonPagedPoolCacheAligned,
	PagedPoolCacheAligned,
	NonPagedPoolCacheAlignedMustS
} POOL_TYPE, *PPOOL_TYPE;

typedef struct _OBJECT_TYPE_INFORMATION
{
	UNICODE_STRING Name;
	ULONG TotalNumberOfObjects;
	ULONG TotalNumberOfHandles;
	ULONG TotalPagedPoolUsage;
	ULONG TotalNonPagedPoolUsage;
	ULONG TotalNamePoolUsage;
	ULONG TotalHandleTableUsage;
	ULONG HighWaterNumberOfObjects;
	ULONG HighWaterNumberOfHandles;
	ULONG HighWaterPagedPoolUsage;
	ULONG HighWaterNonPagedPoolUsage;
	ULONG HighWaterNamePoolUsage;
	ULONG HighWaterHandleTableUsage;
	ULONG InvalidAttributes;
	GENERIC_MAPPING GenericMapping;
	ULONG ValidAccess;
	BOOLEAN SecurityRequired;
	BOOLEAN MaintainHandleCount;
	USHORT MaintainTypeList;
	POOL_TYPE PoolType;
	ULONG PagedPoolUsage;
	ULONG NonPagedPoolUsage;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;


typedef NTSTATUS(WINAPI* _NtQueryInformationThread)(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);
typedef NTSTATUS(WINAPI* _NtQuerySystemInformation)(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
typedef NTSTATUS(WINAPI* _NtQueryObject)(HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);

```

`Anti_Hack_Shield/Anti_Hack_Shield.cpp`:

```cpp
#pragma once

#include "stdafx.h"


extern c_anti_hack* anti_cheat;



VOID NTAPI anti_cheat_timer(PVOID, BOOLEAN) {
	MessageBox(0, 0, 0, 0);
}
int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                  _In_opt_ HINSTANCE hPrevInstance,
                      _In_ LPWSTR    lpCmdLine,
                      _In_ int       nCmdShow)
{
	if (AllocConsole()) { freopen("CONOUT$", "w", stdout); setlocale(LC_ALL, "RUS"); }

	
	window* main_window = new window("Anti-Hack", "Anti-Hack_Class");

	if (main_window->getSelfHandle()) {
		anti_cheat->protectHWND(main_window->getSelfHandle());
		main_window->onMessage();
		anti_cheat->unprotectHWND();
	}

	delete main_window;

	return 0;
}


```

`Anti_Hack_Shield/Anti_Hack_Shield.rc`:

```rc
// Скрипт ресурсов, созданный в Microsoft Visual C++.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Создано из ресурса TEXTINCLUDE 2.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// ресурсы Русский (Россия)

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE 25, 1

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE  
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE  
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // ресурсы Русский (Россия)
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Создано из ресурса TEXTINCLUDE 3.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // не APSTUDIO_INVOKED

```

`Anti_Hack_Shield/Anti_Hack_Shield.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{7ACCF76F-D8BC-404F-9B10-01D96219F8B0}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>Anti_Hack_Shield</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="AH_internal.h" />
    <ClInclude Include="antihack.h" />
    <ClInclude Include="dllload_blocker.h" />
    <ClInclude Include="message_filterproc.h" />
    <ClInclude Include="process_scanner.h" />
    <ClInclude Include="sendmsg_dispatcher.h" />
    <ClInclude Include="sendmsg_dispatcher_old.h" />
    <ClInclude Include="thread_blocker.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="window.h" />
    <ClInclude Include="sendinput_blocker.h" />
    <ClInclude Include="sendmessage_blocker.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="antihack.cpp" />
    <ClCompile Include="Anti_Hack_Shield.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="window.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Anti_Hack_Shield.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Anti_Hack_Shield/Anti_Hack_Shield.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Файлы исходного кода">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Заголовочные файлы">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Файлы ресурсов">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Заголовочные файлы\Anti-Hack">
      <UniqueIdentifier>{80ca435f-8ba8-41ba-9b26-37931a3d1062}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\Anti-Hack\External">
      <UniqueIdentifier>{4e12da04-857e-48b4-86a2-b2919f1de84d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\Anti-Hack\External\Process">
      <UniqueIdentifier>{8bf1b8ce-459b-448e-bb98-6fb4bd7b8e38}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\Anti-Hack\Internal">
      <UniqueIdentifier>{91105686-d3eb-48e1-98a2-8e87c04952c8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\Anti-Hack\Internal\LoadDll">
      <UniqueIdentifier>{8905f0ad-916d-4a05-9eae-95ffa7ec2f20}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\Anti-Hack\Internal\AntiEmulation">
      <UniqueIdentifier>{bfc54243-a03d-4e9b-b369-68c75d5bc8e9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\Anti-Hack\Internal\Thread">
      <UniqueIdentifier>{edaf7b56-5ce0-4990-a2d0-91b26ea93add}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\TestWindow">
      <UniqueIdentifier>{e9c78af7-54be-48b8-bb4d-2472e038437d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\Anti-Hack\Internal\AntiEmulation\sendmessage">
      <UniqueIdentifier>{1bbf0996-3118-43a8-ad27-732dff4fd2ab}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\Anti-Hack\Internal\AntiEmulation\sendinput">
      <UniqueIdentifier>{0f792633-e9b9-4dd3-9633-df5dabe9b921}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Заголовочные файлы</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Заголовочные файлы</Filter>
    </ClInclude>
    <ClInclude Include="window.h">
      <Filter>Заголовочные файлы\TestWindow</Filter>
    </ClInclude>
    <ClInclude Include="dllload_blocker.h">
      <Filter>Заголовочные файлы\Anti-Hack\Internal\LoadDll</Filter>
    </ClInclude>
    <ClInclude Include="thread_blocker.h">
      <Filter>Заголовочные файлы\Anti-Hack\Internal\Thread</Filter>
    </ClInclude>
    <ClInclude Include="process_scanner.h">
      <Filter>Заголовочные файлы\Anti-Hack\External\Process</Filter>
    </ClInclude>
    <ClInclude Include="AH_internal.h">
      <Filter>Заголовочные файлы\Anti-Hack</Filter>
    </ClInclude>
    <ClInclude Include="antihack.h">
      <Filter>Заголовочные файлы\Anti-Hack</Filter>
    </ClInclude>
    <ClInclude Include="sendmsg_dispatcher_old.h">
      <Filter>Заголовочные файлы\Anti-Hack\Internal\AntiEmulation\sendmessage</Filter>
    </ClInclude>
    <ClInclude Include="sendmsg_dispatcher.h">
      <Filter>Заголовочные файлы\Anti-Hack\Internal\AntiEmulation\sendmessage</Filter>
    </ClInclude>
    <ClInclude Include="sendmessage_blocker.h">
      <Filter>Заголовочные файлы\Anti-Hack\Internal\AntiEmulation\sendmessage</Filter>
    </ClInclude>
    <ClInclude Include="sendinput_blocker.h">
      <Filter>Заголовочные файлы\Anti-Hack\Internal\AntiEmulation\sendinput</Filter>
    </ClInclude>
    <ClInclude Include="message_filterproc.h">
      <Filter>Заголовочные файлы\Anti-Hack\Internal\AntiEmulation</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Файлы исходного кода</Filter>
    </ClCompile>
    <ClCompile Include="Anti_Hack_Shield.cpp">
      <Filter>Файлы исходного кода</Filter>
    </ClCompile>
    <ClCompile Include="window.cpp">
      <Filter>Заголовочные файлы\TestWindow</Filter>
    </ClCompile>
    <ClCompile Include="antihack.cpp">
      <Filter>Заголовочные файлы\Anti-Hack</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Anti_Hack_Shield.rc">
      <Filter>Файлы ресурсов</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`Anti_Hack_Shield/Anti_Hack_Shield.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Anti_Hack_Shield/antihack.cpp`:

```cpp
#include "stdafx.h"
#include "antihack.h"


c_anti_hack *anti_cheat =  new c_anti_hack();


#include "dllload_blocker.h"
#include "thread_blocker.h"

#include "message_filterproc.h"

#include "sendinput_blocker.h"
#include "sendmessage_blocker.h"

#include "process_scanner.h"

c_anti_hack::c_anti_hack() {
	//this->set_privileges();

	ZeroMemory(KeyBoardArray, sizeof(KeyBoardArray));
	ZeroMemory(MouseButtonsArray, sizeof(MouseButtonsArray));

#ifdef _M_IX86 
	IsWow64Process(GetCurrentProcess(), &this->IsWow64);
#else
	this->IsWow64 = true;
#endif

#ifdef _M_IX86 
	PPEB pPeb =  (PPEB)(__readfsdword(0x30));
#else
	PPEB pPeb = (PPEB)(__readgsqword(0x60));
#endif

	if (pPeb->BeingDebugged) {
		//TerminateThread(GetCurrentThread(), 0);
	}
	

	 __NtQueryInformationThread = (_NtQueryInformationThread)GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQueryInformationThread");
	 __NtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQuerySystemInformation");
	            __NtQueryObject = (_NtQueryObject)GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQueryObject");

	this->init_dll_profiler();
	this->init_fakemsg_profiler();

	HMODULE kernel32   = GetModuleHandle("kernel32.dll");
	HMODULE kernelbase = GetModuleHandle("kernelbase.dll");

	this->suspected_threadbase.push_back(GetProcAddress(kernel32,	"LoadLibraryA"));
	this->suspected_threadbase.push_back(GetProcAddress(kernel32,	"LoadLibraryW"));
	this->suspected_threadbase.push_back(GetProcAddress(kernel32,	"ExitProcess"));
	this->suspected_threadbase.push_back(GetProcAddress(kernel32,	"FreeLibrary"));

	if (kernelbase) {
		this->suspected_threadbase.push_back(GetProcAddress(kernelbase, "LoadLibraryA"));
		this->suspected_threadbase.push_back(GetProcAddress(kernelbase, "LoadLibraryW"));
		this->suspected_threadbase.push_back(GetProcAddress(kernelbase, "ExitProcess"));
		this->suspected_threadbase.push_back(GetProcAddress(kernelbase, "FreeLibrary"));
	}
}


c_anti_hack::~c_anti_hack() {
	if (this->init_state&ANTIHACK_DLL) { 
		this->uninit_dll_profiler();     
	}

	if (this->init_state&ANTIHACK_MSG || this->init_state&ANTIHACK_MSG_1) {
		this->uninit_fakemsg_profiler(); 
	}
}



#define SE_MIN_WELL_KNOWN_PRIVILEGE       (2L)
#define SE_MAX_WELL_KNOWN_PRIVILEGE       (30L)

typedef NTSTATUS(WINAPI* _RtlAdjustPrivilege)(ULONG    Privilege, BOOLEAN  Enable, BOOLEAN  CurrentThread, PBOOLEAN Enabled);

void c_anti_hack::set_privileges() {
	_RtlAdjustPrivilege __RtlAdjustPrivilege = (_RtlAdjustPrivilege)GetProcAddress(GetModuleHandle("ntdll.dll"), "RtlAdjustPrivilege");

	BOOLEAN bWasEnabled;
	for (ULONG priv = SE_MIN_WELL_KNOWN_PRIVILEGE; priv <= SE_MAX_WELL_KNOWN_PRIVILEGE; priv++) {
		__RtlAdjustPrivilege(priv, TRUE, FALSE, &bWasEnabled);
	}
	
}

void NTAPI anticheat_thread_profiler(void*  dll, DWORD reason, void* reserved) {

	switch (reason) {
		case DLL_THREAD_ATTACH: {
			if (anti_cheat) {
				anti_cheat->onStartThread(); 
			}
			break;
		}
		case DLL_THREAD_DETACH: {
			if (anti_cheat) {
				anti_cheat->onEndThread();
			}
			break;
		}

		case DLL_PROCESS_ATTACH: {
			if (!anti_cheat) {
				// ( new ) on release x86 dont works here \_(0_0)_/
				//anti_cheat = new c_anti_hack();
			}
			break;
		}
		case DLL_PROCESS_DETACH: {
			if (anti_cheat) {
				anti_cheat->~c_anti_hack();
			}
			break;
		}
	}
}


#ifdef _WIN64
     #pragma comment (linker, "/INCLUDE:_tls_used")  
     #pragma comment (linker, "/INCLUDE:tls_callback_func") 
#else
     #pragma comment (linker, "/INCLUDE:__tls_used")
     #pragma comment (linker, "/INCLUDE:_tls_callback_func")
#endif

#ifdef _WIN64
    #pragma const_seg(".CRT$XLF")
    EXTERN_C const
#else
    #pragma data_seg(".CRT$XLF")
    EXTERN_C
#endif
PIMAGE_TLS_CALLBACK tls_callback_func = anticheat_thread_profiler;
#ifdef _WIN64
    #pragma const_seg()
#else
    #pragma data_seg()
#endif 
```

`Anti_Hack_Shield/antihack.h`:

```h
#pragma once
#pragma pack(push, 1)

#include "AH_internal.h"

class c_anti_hack {
	DWORD init_state = 0;
	bool IsDebugger = false;
	BOOL IsWow64;
	DWORD ProcessId = GetCurrentProcessId();

	HHOOK h_winhook = 0;

	BYTE ObjectTypeNumberOfThread  = 0xFF;
	BYTE ObjectTypeNumberOfProcess = 0xFF;

	WNDPROC ProcOriginal = 0;

	LPVOID dll_notify_cookie = 0;

	HWND wnd_protected = 0;
  
	_NtQueryInformationThread __NtQueryInformationThread = 0;
	_NtQuerySystemInformation __NtQuerySystemInformation = 0;
	_NtQueryObject            __NtQueryObject =            0;

	std::vector<LPVOID> suspected_threadbase;

	PVOID c_anti_hack::GetCurrentThreadStartAddress();
	bool  c_anti_hack::IsRemoteThread(DWORD ID);
	DWORD  c_anti_hack::check_current_thread();

	bool c_anti_hack::init_dll_profiler();
	bool c_anti_hack::init_fakemsg_profiler();
	bool c_anti_hack::init_fakemsg_oldprofiler();

	void c_anti_hack::uninit_dll_profiler();
	void c_anti_hack::uninit_fakemsg_profiler();
	void c_anti_hack::uninit_fakemsg_oldprofiler();
	 
	void c_anti_hack::set_privileges();
public:
	bool		MouseButtonsArray[3];
	__keyallow  KeyBoardArray[256];

	void c_anti_hack::on_load_dll(HMODULE hmod, std::wstring path);
	bool c_anti_hack::check_dll_on_legit(std::wstring path);

	void c_anti_hack::scan_process();

	bool c_anti_hack::protectHWND(HWND wnd);
	void c_anti_hack::unprotectHWND();

	void c_anti_hack::onStartThread();
	void c_anti_hack::onEndThread();

	DWORD   c_anti_hack::getState()   { return this->init_state;   }
	WNDPROC c_anti_hack::getMsgProc() { return this->ProcOriginal; }

	c_anti_hack::c_anti_hack();
	c_anti_hack::~c_anti_hack();
};
#pragma pack(pop)


/*
 new anti-sendmessage works only on windows 10 x64 
 old anti-sendmessage works everywhere
 sendinput			  works everywhere
 thread detect        tested on windows 7 x86 and windows 10 x64
 load dll			  works only on windows vista and later versions
*/
```

`Anti_Hack_Shield/dllload_blocker.h`:

```h
#pragma once

struct SWH_DATA {
	DWORD unk_0;				
	DWORD unk_4;				
	DWORD unk_8;				
	DWORD unk_c;			
	DWORD unk_10;		
	DWORD unk_14;	
	UNICODE_STRING lpDllPath;
	DWORD unk_20;
};

#define LDR_DLL_NOTIFICATION_REASON_LOADED   1
#define LDR_DLL_NOTIFICATION_REASON_UNLOADED 2

#define ThreadQuerySetWin32StartAddress 9

#define __ClientLoadLibrary_idx 74


typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA {
	ULONG Flags;                    //Reserved.
	PCUNICODE_STRING FullDllName;   //The full path name of the DLL module.
	PCUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
	PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
	ULONG SizeOfImage;              //The size of the DLL image, in bytes.
} LDR_DLL_LOADED_NOTIFICATION_DATA, *PLDR_DLL_LOADED_NOTIFICATION_DATA;

typedef struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA {
	ULONG Flags;                    //Reserved.
	PCUNICODE_STRING FullDllName;   //The full path name of the DLL module.
	PCUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
	PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
	ULONG SizeOfImage;              //The size of the DLL image, in bytes.
} LDR_DLL_UNLOADED_NOTIFICATION_DATA, *PLDR_DLL_UNLOADED_NOTIFICATION_DATA;


typedef union _LDR_DLL_NOTIFICATION_DATA {
	LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;
	LDR_DLL_UNLOADED_NOTIFICATION_DATA Unloaded;
} LDR_DLL_NOTIFICATION_DATA, *PLDR_DLL_NOTIFICATION_DATA;

typedef VOID (CALLBACK* PLDR_DLL_NOTIFICATION_FUNCTION)(ULONG NotificationReason,
	_In_     PLDR_DLL_NOTIFICATION_DATA NotificationData,
	_In_opt_ PVOID Context
);

typedef int (WINAPI * _ClientLoadLibrary)(SWH_DATA * data);

typedef NTSTATUS (WINAPI* _LdrRegisterDllNotification)(ULONG Flags,PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,PVOID Context,PVOID *Cookie);
typedef NTSTATUS (WINAPI* _LdrUnregisterDllNotification)(PVOID Cookie);


_ClientLoadLibrary o_ClientLoadLibrary = 0;


LPVOID * Get_apfnDispatch() {
#ifdef _M_IX86 
	return (LPVOID *)*(DWORD *)(__readfsdword(0x30) + 0x2C);
#else
	return (LPVOID *)*(DWORD64 *)(__readgsqword(0x60) + 0x58);
#endif
}


int WINAPI h_ClientLoadLibrary(SWH_DATA * data) {

	wprintf(L"window hook load dll %s\n", data->lpDllPath.Buffer);

	if (!anti_cheat->check_dll_on_legit(data->lpDllPath.Buffer)) {
		return 0;
	}

	return o_ClientLoadLibrary(data);
}


VOID WINAPI dll_notify(ULONG NotificationReason,
	_In_     PLDR_DLL_NOTIFICATION_DATA NotificationData,
	_In_opt_ PVOID Context
) {

	switch (NotificationReason) {
		case LDR_DLL_NOTIFICATION_REASON_LOADED: {
			anti_cheat->on_load_dll((HMODULE)NotificationData->Loaded.DllBase, NotificationData->Loaded.FullDllName->Buffer);
			break;
		}

		case LDR_DLL_NOTIFICATION_REASON_UNLOADED: {

			break;
		}
	}
}

bool c_anti_hack::check_dll_on_legit(std::wstring path) {
	int filename_idx = 0;
	for (filename_idx = path.length(); filename_idx > 0; filename_idx--) { if (path[filename_idx] == '\\') { filename_idx++;  break; } }

	if (!lstrcmpW(&path[filename_idx], L"TestDll.dll")) {
		return false;
	}

	return true;
}


void c_anti_hack::on_load_dll(HMODULE hmod, std::wstring path) {
	if (check_dll_on_legit(path) && !check_current_thread()) {
		wprintf(L"passed load dll [%s]\n", path.c_str());
		return;
	}
	else {
		wprintf(L"blocked load dll [%s]\n", path.c_str());
		TerminateThread(GetCurrentThread(), 1);
	}
}

bool c_anti_hack::init_dll_profiler() {

	//dll load callback
	//DllNotification works only on Vista or later
	_LdrRegisterDllNotification LdrRegisterDllNotification = (_LdrRegisterDllNotification)GetProcAddress(GetModuleHandle("ntdll.dll"), "LdrRegisterDllNotification");
	
	if (LdrRegisterDllNotification) {
		LdrRegisterDllNotification(0, dll_notify, 0, &this->dll_notify_cookie);
	}

	//setwindowshook load dll
	DWORD oldprot;
	LPVOID * apfnDispatch = Get_apfnDispatch();
	if (apfnDispatch) {
		o_ClientLoadLibrary = (_ClientLoadLibrary)apfnDispatch[__ClientLoadLibrary_idx];

		VirtualProtect(apfnDispatch, 117 * sizeof(LPVOID), PAGE_EXECUTE_READWRITE, &oldprot);
		apfnDispatch[__ClientLoadLibrary_idx] = h_ClientLoadLibrary;
		VirtualProtect(apfnDispatch, 117 * sizeof(LPVOID), oldprot, &oldprot);

		this->init_state |= ANTIHACK_DLL;
		return true;
	}
	else {
		return false;
	}
}


void c_anti_hack::uninit_dll_profiler() {

	_LdrUnregisterDllNotification LdrUnregisterDllNotification = (_LdrUnregisterDllNotification)GetProcAddress(GetModuleHandle("ntdll.dll"), "LdrUnregisterDllNotification");

	if (LdrUnregisterDllNotification) {
		LdrUnregisterDllNotification(this->dll_notify_cookie);
	}

	DWORD oldprot;
	LPVOID * apfnDispatch = Get_apfnDispatch();
	if (apfnDispatch && o_ClientLoadLibrary) {
		VirtualProtect(apfnDispatch, 117 * sizeof(LPVOID), PAGE_EXECUTE_READWRITE, &oldprot);
		apfnDispatch[__ClientLoadLibrary_idx] = o_ClientLoadLibrary;
		VirtualProtect(apfnDispatch, 117 * sizeof(LPVOID), oldprot, &oldprot);
	}
}
```

`Anti_Hack_Shield/message_filterproc.h`:

```h
#pragma once

//Наш обработчик сообщений окна
LRESULT CALLBACK ProcFilter(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {

	switch (message) {
			//Mouse
		case WM_LBUTTONDOWN: { 
			if (!anti_cheat->MouseButtonsArray[0]) {
				printf("Device Emulation [SendMessage]\n");
				return 0;
			}
			break;
		}
		case WM_MBUTTONDOWN: {
			if (!anti_cheat->MouseButtonsArray[1]) {
				printf("Device Emulation [SendMessage]\n");
				return 0;
			}
			break;
		}
		case WM_RBUTTONDOWN: {
			if (!anti_cheat->MouseButtonsArray[2]) {			
				printf("Device Emulation [SendMessage]\n");
				return 0;
			}
			break;
		}

            //KeyBoard
		case WM_KEYDOWN: { 
			if (!anti_cheat->KeyBoardArray[wParam].Key || anti_cheat->KeyBoardArray[wParam].Block_WM_KEY_DOWN_counter) {
				if (anti_cheat->KeyBoardArray[wParam].Block_WM_KEY_DOWN_counter) {
					anti_cheat->KeyBoardArray[wParam].Block_WM_KEY_DOWN_counter--;
				}
				printf("Device Emulation [SendMessage]\n");
				return 0;
			}
			break;
		}
		case WM_KEYUP: { 
			if (anti_cheat->KeyBoardArray[wParam].Block_WM_KEY_UP_counter) {
				anti_cheat->KeyBoardArray[wParam].Block_WM_KEY_UP_counter--;
				printf("Device Emulation [SendMessage]\n");
				return 0;
			}
			break;
		}


		case WM_INPUT: {
			UINT dwSize = sizeof(RAWINPUT);
			BYTE *lpb = NULL;
			RAWINPUT raw_i;

			if (GET_RAWINPUT_CODE_WPARAM(wParam) == RIM_INPUT) {//Нажатие в момент того как окно было в фокусе
																//Получаем размер сообщения
				GetRawInputData((HRAWINPUT)lParam, RID_INPUT, NULL, &dwSize, sizeof(RAWINPUTHEADER));
				lpb = new BYTE[dwSize];

				//Получаем сообщение от девайса
				if (GetRawInputData((HRAWINPUT)lParam, RID_INPUT, lpb, &dwSize, sizeof(RAWINPUTHEADER)) != dwSize)
					return 0;

				//hDevice == 0 если устройства нет,что значит что это эмуляция нажатия
				if (((RAWINPUT*)(lpb))->header.hDevice) {
					delete[] lpb;
				}
				else {
					if (((RAWINPUT*)(lpb))->data.keyboard.Message == WM_KEYDOWN) {
						anti_cheat->KeyBoardArray[((RAWINPUT*)(lpb))->data.keyboard.VKey].Block_WM_KEY_DOWN_counter++;
					}
					if (((RAWINPUT*)(lpb))->data.keyboard.Message == WM_KEYUP) {
						anti_cheat->KeyBoardArray[((RAWINPUT*)(lpb))->data.keyboard.VKey].Block_WM_KEY_UP_counter++;
					}
					delete[] lpb;
					printf("Device Emulation [SendInput]\n");
					return 0;
				}
			}
			break;
		}

		default: break;
	}

	
	WNDPROC OriginalProc = anti_cheat->getMsgProc();
	if (anti_cheat->getMsgProc()) {
		OriginalProc(hWnd, message, wParam, lParam);//Вызываем оригинальный обработчик окна
	}
	else {
		return 0;
	}
}

```

`Anti_Hack_Shield/process_scanner.h`:

```h
#pragma once

#define PROCESS_SUSPECT_FLAGS (PROCESS_VM_WRITE | PROCESS_CREATE_THREAD | PROCESS_SET_INFORMATION | PROCESS_SET_LIMITED_INFORMATION |PROCESS_DUP_HANDLE | PROCESS_SET_QUOTA | PROCESS_SUSPEND_RESUME | PROCESS_VM_OPERATION)
#define THREAD_SUSPECT_FLAGS  (THREAD_SET_INFORMATION | THREAD_SET_LIMITED_INFORMATION | THREAD_SET_CONTEXT | THREAD_SUSPEND_RESUME)

void c_anti_hack::scan_process() {


}

```

`Anti_Hack_Shield/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Anti_Hack_Shield.rc

// Следующие стандартные значения для новых объектов
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Anti_Hack_Shield/sendinput_blocker.h`:

```h
#pragma once

bool c_anti_hack::protectHWND(HWND def_hwnd) {
	if (!wnd_protected && IsWindow(def_hwnd)) {
		wnd_protected = def_hwnd;

		printf("SetWindowLongPtrA\n");

		//Подмена оригинального обработчика сообщений на наш
		if (this->ProcOriginal = (WNDPROC)SetWindowLongPtrA(def_hwnd, GWLP_WNDPROC, (LONG_PTR)ProcFilter)) {

			RAWINPUTDEVICE rid;
			rid.usUsagePage = 0x01;
			rid.usUsage = 0x06;
			rid.dwFlags = RIDEV_INPUTSINK;
			rid.hwndTarget = def_hwnd;
			printf("RegisterRawInputDevices\n");
			//Регистрация для сообщения WM_INPUT
			if (RegisterRawInputDevices(&rid, 1, sizeof(RAWINPUTDEVICE))) {
				return true;
			}
			else {
				SetWindowLongPtrA(def_hwnd, GWLP_WNDPROC, (LONG_PTR)this->ProcOriginal);
				return false;
			}
		}
		else {
			return false;
		}
	}
	return false;
}

void c_anti_hack::unprotectHWND() {
	if (wnd_protected){
		SetWindowLongPtrA(wnd_protected, GWLP_WNDPROC, (LONG_PTR)this->ProcOriginal);
	}
}
```

`Anti_Hack_Shield/sendmessage_blocker.h`:

```h
#pragma once

#ifdef _M_IX86
	#define POINTER_TYPE DWORD
#else
	#define POINTER_TYPE DWORD64
#endif

typedef struct _fnClient {
	struct pfnelement {
		void * pFunc;
#ifdef _M_IX86
		DWORD aling_x32;
#endif
	}element[40];
}fnClient, *pfnClient;

typedef struct _fnClient32 {
	struct pfnelement {
		void * pFunc;
	}element[40];
}fnClient32, *pfnClient32;


#define _DispatchClientMessage_idx 21

typedef int (WINAPI * _RtlRetrieveNtUserPfn)(void** clientA, void** clientW, void** Unk);

typedef int (WINAPI * _DispatchClientMessagex64)(HWND *hwnd,
#ifdef _M_IX86 
	DWORD aling_32, 
#endif
	DWORD msg, WPARAM wparam, LPARAM lparam, WNDPROC proc);

typedef int (WINAPI * _DispatchClientMessagex32)(HWND *hwnd,DWORD msg, WPARAM wparam, LPARAM lparam, WNDPROC proc);


LPVOID o_DispatchClientMessage_A = 0;
LPVOID o_DispatchClientMessage_W = 0;

void * fnClientA,* fnClientW,* fnClientWorker;

POINTER_TYPE * vtbl_pDispatchA = 0;
POINTER_TYPE * vtbl_pDispatchW = 0;


#include "sendmsg_dispatcher.h"
#include "sendmsg_dispatcher_old.h"



bool c_anti_hack::init_fakemsg_profiler() {
	_RtlRetrieveNtUserPfn RtlRetrieveNtUserPfn = (_RtlRetrieveNtUserPfn)GetProcAddress(GetModuleHandle("ntdll.dll"), "RtlRetrieveNtUserPfn");

	if (RtlRetrieveNtUserPfn && RtlRetrieveNtUserPfn(&fnClientA, &fnClientW, &fnClientWorker) == STATUS_SUCCESS) {
		//tested on windows 10 x64

		/*
		pfnClient->
		0x0 pFunc  ----->[ jmp [ntdll_vtbl[1]] ]->_user32_func1
		0x8 pFunc  ----->[ jmp [ntdll_vtbl[2]] ]->_user32_func2
		0x10 pFunc ----->[ jmp [ntdll_vtbl[3]] ]->_user32_func3
		0x18 pFunc ----->[ jmp [ntdll_vtbl[4]] ]->_user32_func4
		...
		...
		*/

		if (this->IsWow64) {
#ifdef _M_IX86
			vtbl_pDispatchA = (POINTER_TYPE*)*(DWORD*)((DWORD)((pfnClient)fnClientA)->element[_DispatchClientMessage_idx].pFunc + 2);
			vtbl_pDispatchW = (POINTER_TYPE*)*(DWORD*)((DWORD)((pfnClient)fnClientW)->element[_DispatchClientMessage_idx].pFunc + 2);
#else
			vtbl_pDispatchA = (POINTER_TYPE*)(*(DWORD*)((DWORD64)((pfnClient)fnClientA)->element[_DispatchClientMessage_idx].pFunc + 2) + (POINTER_TYPE)((pfnClient)fnClientA)->element[_DispatchClientMessage_idx].pFunc + 6);
			vtbl_pDispatchW = (POINTER_TYPE*)(*(DWORD*)((DWORD64)((pfnClient)fnClientA)->element[_DispatchClientMessage_idx].pFunc + 2) + (POINTER_TYPE)((pfnClient)fnClientA)->element[_DispatchClientMessage_idx].pFunc + 6);
#endif
		}
		else {
			vtbl_pDispatchA = (POINTER_TYPE*)*(DWORD*)((DWORD)((pfnClient32)fnClientA)->element[_DispatchClientMessage_idx].pFunc + 2);
			vtbl_pDispatchW = (POINTER_TYPE*)*(DWORD*)((DWORD)((pfnClient32)fnClientW)->element[_DispatchClientMessage_idx].pFunc + 2);
		}

		

		o_DispatchClientMessage_A = (_DispatchClientMessagex64)*vtbl_pDispatchA;
		o_DispatchClientMessage_W = (_DispatchClientMessagex64)*vtbl_pDispatchW;

		DWORD lastProt;
		VirtualProtect((void*)vtbl_pDispatchA, 0xB8, PAGE_EXECUTE_READWRITE, &lastProt);
		if (this->IsWow64) {
			*vtbl_pDispatchA = (POINTER_TYPE)h_DispatchClientMessage_A_win64;
		}
		else {
			*vtbl_pDispatchA = (POINTER_TYPE)h_DispatchClientMessage_A_win32;
		}

		VirtualProtect((void*)vtbl_pDispatchA, 0xB8, lastProt, &lastProt);


		VirtualProtect((void*)vtbl_pDispatchW, 0xB8, PAGE_EXECUTE_READWRITE, &lastProt);
		if (this->IsWow64) {
			*vtbl_pDispatchW = (POINTER_TYPE)h_DispatchClientMessage_W_win64;
		}
		else {
			*vtbl_pDispatchW = (POINTER_TYPE)h_DispatchClientMessage_W_win32;
		}
		VirtualProtect((void*)vtbl_pDispatchW, 0xB8, lastProt, &lastProt);


		this->init_state |= ANTIHACK_MSG;
		return true;
	}

	return init_fakemsg_oldprofiler();
}

void c_anti_hack::uninit_fakemsg_profiler() {
	if (this->init_state&ANTIHACK_MSG_1) {
		uninit_fakemsg_oldprofiler();
	}

	if(this->init_state&ANTIHACK_MSG){
		DWORD lastProt;
		VirtualProtect((void*)vtbl_pDispatchA, 0xB8, PAGE_EXECUTE_READWRITE, &lastProt);
		*vtbl_pDispatchA = (POINTER_TYPE)o_DispatchClientMessage_A;
		VirtualProtect((void*)vtbl_pDispatchA, 0xB8, lastProt, &lastProt);

		VirtualProtect((void*)vtbl_pDispatchW, 0xB8, PAGE_EXECUTE_READWRITE, &lastProt);
		*vtbl_pDispatchW = (POINTER_TYPE)o_DispatchClientMessage_W;
		VirtualProtect((void*)vtbl_pDispatchW, 0xB8, lastProt, &lastProt);
	}
}


bool c_anti_hack::init_fakemsg_oldprofiler() {
	SetWindowsHookA(WH_GETMESSAGE, winhook_profiler);
	this->init_state |= ANTIHACK_MSG_1;
	return true;
}


void c_anti_hack::uninit_fakemsg_oldprofiler() {
	UnhookWindowsHook(WH_GETMESSAGE, winhook_profiler);
}
```

`Anti_Hack_Shield/sendmsg_dispatcher.h`:

```h
#pragma once


bool validate_msg(DWORD msg) {
	switch (msg) {
		//выборка оконных сообщений эмуляция которых будет блокироваться

		//keyborad
	case WM_KEYDOWN:case WM_KEYUP:
		//mouse
	case WM_RBUTTONDOWN:case WM_LBUTTONDOWN:case WM_LBUTTONDBLCLK:
	case WM_LBUTTONUP:case WM_RBUTTONUP:case WM_RBUTTONDBLCLK:
	case WM_MBUTTONDOWN: case WM_MBUTTONUP: case WM_MBUTTONDBLCLK:
	case WM_MOUSEWHEEL: case WM_MOUSEHWHEEL:
	{
		printf("Device Emulation [SendMessage]\n");
		return false;
	}
	default:
		return true;
	}
}

int WINAPI h_DispatchClientMessage_W_win64(HWND* hwnd,
#ifdef _M_IX86
	DWORD aling_32,
#endif	
	DWORD msg, WPARAM wparam, LPARAM lparam, WNDPROC proc) {

	if (hwnd) {
		if (!validate_msg(msg)) {
			return 0;
		}
	}

	return ((_DispatchClientMessagex64)o_DispatchClientMessage_W)(hwnd,
#ifdef _M_IX86
		aling_32,
#endif
		msg, wparam, lparam, proc);
}

int WINAPI h_DispatchClientMessage_A_win64(HWND* hwnd,
#ifdef _M_IX86
	DWORD aling_32,
#endif	
	DWORD msg, WPARAM wparam, LPARAM lparam, WNDPROC proc) {

	switch (msg) {
		if (!validate_msg(msg)) {
			return 0;
		}
	}

	return  ((_DispatchClientMessagex64)o_DispatchClientMessage_A)(hwnd,
#ifdef _M_IX86
		aling_32,
#endif
		msg, wparam, lparam, proc);
}


int WINAPI h_DispatchClientMessage_W_win32(HWND* hwnd,DWORD msg, WPARAM wparam, LPARAM lparam, WNDPROC proc) {

	if (hwnd) {
		if (!validate_msg(msg)) {
			return 0;
		}
	}

	return ((_DispatchClientMessagex32)o_DispatchClientMessage_W)(hwnd,msg, wparam, lparam, proc);
}

int WINAPI h_DispatchClientMessage_A_win32(HWND* hwnd,DWORD msg, WPARAM wparam, LPARAM lparam, WNDPROC proc) {

	switch (msg) {
		if (!validate_msg(msg)) {
			return 0;
		}
	}

	return ((_DispatchClientMessagex32)o_DispatchClientMessage_A)(hwnd,msg, wparam, lparam, proc);
}
```

`Anti_Hack_Shield/sendmsg_dispatcher_old.h`:

```h
#pragma once


LRESULT CALLBACK winhook_profiler(int code, WPARAM wParam, LPARAM lParam) {

	MSG * message = (MSG*)lParam;

	switch (message->message) {
		case WM_LBUTTONDOWN: {
			anti_cheat->MouseButtonsArray[0] = true;
			break;
		}
		case WM_LBUTTONUP: {
			anti_cheat->MouseButtonsArray[0] = false;
			break;
		}
		case WM_MBUTTONDOWN: {
			anti_cheat->MouseButtonsArray[1] = true;
			break;
		}
		case WM_MBUTTONUP: {
			anti_cheat->MouseButtonsArray[1] = false;
			break;
		}
		case WM_RBUTTONDOWN: {
			anti_cheat->MouseButtonsArray[2] = true;
			break;
		}
		case WM_RBUTTONUP: {
			anti_cheat->MouseButtonsArray[2] = false;
			break;
		}

		case WM_KEYDOWN: {
			anti_cheat->KeyBoardArray[message->wParam].Key = true;
			break;
		}

		case WM_KEYUP: {
			anti_cheat->KeyBoardArray[message->wParam].Key = false;
			break;
		}
       

		default:break;
	}


	return CallNextHookEx(0, code, wParam, lParam);
}

```

`Anti_Hack_Shield/stdafx.cpp`:

```cpp
// stdafx.cpp: исходный файл, содержащий только стандартные включаемые модули
// Anti_Hack_Shield.pch будет предкомпилированным заголовком
// stdafx.obj будет содержать предварительно откомпилированные сведения о типе

#include "stdafx.h"

// TODO: Установите ссылки на любые требующиеся дополнительные заголовки в файле STDAFX.H
// , а не в данном файле

```

`Anti_Hack_Shield/stdafx.h`:

```h
#pragma once
#define WIN32_LEAN_AND_MEAN   

#include <windows.h>
#include <winternl.h>
#include <string>
#include <vector>
#include <TlHelp32.h>



#include "antihack.h"
#include "window.h"



```

`Anti_Hack_Shield/thread_blocker.h`:

```h
#pragma once

PVOID c_anti_hack::GetCurrentThreadStartAddress() {
	NTSTATUS ntStatus;
	PVOID dwStartAddress;
		
	ntStatus = __NtQueryInformationThread(GetCurrentThread(), (THREADINFOCLASS)ThreadQuerySetWin32StartAddress, &dwStartAddress, sizeof(dwStartAddress), NULL);

	if (ntStatus != STATUS_SUCCESS) return 0;
	return dwStartAddress;
}

bool  c_anti_hack::IsRemoteThread(DWORD ID) {
	ULONG retlen = 1;
	ULONG table_length = 0;
	SYSTEM_HANDLE_INFORMATION * HandleTable = 0;
	bool ret_status = true;

	while (retlen) {
	  NTSTATUS status =	__NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, HandleTable, table_length, &retlen);
	  table_length += retlen;

	  if (status == STATUS_SUCCESS) {
		  break;
	  }
	  
	  if (status == STATUS_INFO_LENGTH_MISMATCH) {
		  if (HandleTable) { delete[]HandleTable; }
		  HandleTable = (SYSTEM_HANDLE_INFORMATION *)new BYTE[table_length];
	  }

	}

	if (this->ObjectTypeNumberOfThread == 0xFF) { //Получаем id хандла потоков
		POBJECT_TYPE_INFORMATION objInfo = (POBJECT_TYPE_INFORMATION)new BYTE[0x1000];
		for (int i = 0; i < HandleTable->HandleCount; i++) {
			if (HandleTable->Handles[i].ProcessId == this->ProcessId) {
				if (__NtQueryObject((HANDLE)HandleTable->Handles[i].Handle, (OBJECT_INFORMATION_CLASS)ObjectTypeInformation, objInfo, 0x1000, NULL) == STATUS_SUCCESS) {
					if (!lstrcmpW(objInfo->Name.Buffer, L"Thread")) {
						this->ObjectTypeNumberOfThread = HandleTable->Handles[i].ObjectTypeNumber;
						this->ObjectTypeNumberOfProcess = this->ObjectTypeNumberOfThread - 1;
					}
				}
			}
		}
		delete[]objInfo;
	}

	if (this->ObjectTypeNumberOfThread != 0xFF) {
		for (int i = 0; i < HandleTable->HandleCount; i++) { //Перебор всех хандлов нашего процесса и получение хандла текущего потока
			if (HandleTable->Handles[i].ProcessId == this->ProcessId && HandleTable->Handles[i].ObjectTypeNumber == this->ObjectTypeNumberOfThread) {
				if (ID == GetThreadId((HANDLE)HandleTable->Handles[i].Handle)) {
					ret_status = false;
				}
			}
		}
	}
	else {
		ret_status = false;
	}

	delete[]HandleTable;

	return ret_status;
}

DWORD c_anti_hack::check_current_thread() {

	if (!IsRemoteThread(GetCurrentThreadId())) {
		PVOID StartAddress = GetCurrentThreadStartAddress();
		if (StartAddress) {

#ifdef _M_IX86
			MEMORY_BASIC_INFORMATION32 MBI;
#else
			MEMORY_BASIC_INFORMATION64 MBI;
#endif
			DWORD mbi_size = sizeof(MBI);

			if (VirtualQuery(StartAddress, (MEMORY_BASIC_INFORMATION*)&MBI, mbi_size)) { //Получаем информацию о памяти с адресом старта

				if (MBI.Type&MEM_IMAGE) {  //если память выделена под образ

					for (unsigned int i = 0; i < this->suspected_threadbase.size(); i++) { //Проверка подозрительных адресов
						if (this->suspected_threadbase[i] == StartAddress) {
							return THREAD_REASON_SUSPECTED_ADDRESS;
						}
					}

					return 0;
				}
			}
		}
		return THREAD_REASON_UNBASE;
	}

	return THREAD_REASON_REMOTE;
}



void c_anti_hack::onStartThread() {
	printf("new thread [%x]\n", GetCurrentThreadId());

	DWORD thread_code = check_current_thread();
	  if(thread_code){
		  printf("thread [%x] was closed reason : ", GetCurrentThreadId());

		  switch (thread_code) {
			  case THREAD_REASON_REMOTE: {
				  printf("[Remoted thread]\n");
				  break;
			  }
			  case THREAD_REASON_UNBASE: {
				  printf("[Base address not IMAGE]\n");
				  break;
			  }
			  case THREAD_REASON_SUSPECTED_ADDRESS: {
				  printf("[Suspected base address]\n");
				  break;
			  }
		  }

		TerminateThread(GetCurrentThread(), 1);
	  }
}


void c_anti_hack::onEndThread() {


}



```

`Anti_Hack_Shield/window.cpp`:

```cpp
#include "stdafx.h"
#include "Window.h"


LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message) {

	case WM_DESTROY:
		PostQuitMessage(0);
		break;
	case WM_KEYDOWN: {
		printf("Key down opcode %c!\n", wParam);
		break;
	}
	case WM_LBUTTONDOWN: {
		printf("You are lclicked in window!\n");
		break;
	}
	case WM_RBUTTONDOWN: {
		printf("You are rclicked in window!\n");
		break;
	}

	default:
		return DefWindowProc(hWnd, message, wParam, lParam);
	}
	return 0;
}



window::window(std::string name, std::string winclass){
	WRegisterClass(winclass);

	wnd = CreateWindowA(winclass.c_str(), name.c_str(), WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,
		CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, nullptr, nullptr, GetModuleHandle(0), nullptr);

	ShowWindow(wnd, SW_SHOW);
	UpdateWindow(wnd);
}


window::~window(){
	DestroyWindow(this->wnd);
}


bool window::onMessage() {
	MSG msg;
	while (GetMessage(&msg, nullptr, 0, 0)) {
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	return true;
}
HWND window::getSelfHandle() {
	return this->wnd;
}

ATOM window::WRegisterClass(std::string winclass) {
	WNDCLASSEXA wcex;
	wcex.cbSize = sizeof(WNDCLASSEX);
    wcex.style = CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc = WndProc;
	wcex.cbClsExtra = 0;
	wcex.cbWndExtra = 0;
	wcex.hInstance = GetModuleHandle(0);
	wcex.hIcon = 0;
	wcex.hCursor = LoadCursor(nullptr, IDC_ARROW);
	wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wcex.lpszMenuName = 0;
	wcex.lpszClassName = winclass.c_str();
	wcex.hIconSm = 0;
	return RegisterClassEx(&wcex);
}
```

`Anti_Hack_Shield/window.h`:

```h
#pragma once
class window
{
	HWND wnd;

	ATOM window::WRegisterClass(std::string winclass);
public:
	window::window(std::string name,std::string winclass);
	window::~window();

	bool window::onMessage();
	HWND window::getSelfHandle();
};


```

`README.md`:

```md
# Приемущества
1. Античит не может быть выведен из строя такими антируткит утилитами как (PCHunter\gmer) снимающими хуки
2. Не использует отдельные потоки для работы,а значит не перестанет работать после заморозки всех потоков процесса
3. Не использует драйвера

# Реализовано
1. anti remote thread
2. anti keyboard and mouse emulation
3. anti dll inject
4. anti shellcode inject

Весь функционал проверялся на windows 10 x64 и windows 7 x86

# В возможном будущем 
* Написание драйвера для защиты от external хаков


```