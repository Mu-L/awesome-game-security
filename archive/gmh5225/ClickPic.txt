Project Path: arc_gmh5225_ClickPic_i8piie1i

Source Tree:

```txt
arc_gmh5225_ClickPic_i8piie1i
├── CMakeLists.txt
├── build.bat
├── cmake
│   └── FindWDK.cmake
├── package.json
├── readme.md
└── src
    ├── app.hpp
    ├── base
    │   ├── clicker.hpp
    │   ├── matcher.hpp
    │   └── screen.h
    ├── constant.hpp
    ├── definitions.hpp
    ├── driver
    │   ├── definitions.hpp
    │   ├── dispatch.cpp
    │   ├── dispatch.hpp
    │   ├── driver.cpp
    │   ├── driver.h
    │   ├── memory.cpp
    │   ├── memory.hpp
    │   ├── mouse.cpp
    │   ├── mouse.hpp
    │   ├── ntapi.hpp
    │   └── ntstructs.hpp
    ├── driver_control.cpp
    ├── driver_control.hpp
    ├── main.cpp
    ├── utils
    │   ├── logger.hpp
    │   └── timecalc.hpp
    └── windows
        └── screen.hpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.19)


if(NOT DRIVER)

set(CMAKE_TOOLCHAIN_FILE "$ENV{VCPKG_ROOT}\\scripts\\buildsystems\\vcpkg.cmake" CACHE STRING "" FORCE)
message(STATUS "Use toolchain file ${CMAKE_TOOLCHAIN_FILE}")

set(VCPKG_TARGET_TRIPLET "x86-windows-static")
message(STATUS "Use triplet ${VCPKG_TARGET_TRIPLET}")

project(automation CXX)

message(STATUS "${CMAKE_SYSTEM_NAME}")

if(NOT CMAKE_SYSTEM_NAME MATCHES "Windows")
  message(FATAL_ERROR "Please build on Windows")
endif()

message(STATUS "Welcome Build")

if(NOT DEFINED ENV{VCPKG_ROOT})
  message(FATAL_ERROR "Need vcpkg")
endif()

message(STATUS "Base Flags ${CMAKE_CXX_FLAGS}") 
message(STATUS "Release Flags ${CMAKE_CXX_FLAGS_RELEASE}") 


set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_EXTENSIONS OFF)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

if(NOT DEFINED ${CMAKE_BUILD_TYPE})
  message(STATUS "Not define build type, default Release")
  set(CMAKE_BUILD_TYPE Release)
endif()

find_package(OpenCV CONFIG REQUIRED)
if(OpenCV_FOUND)
  message(STATUS "Found ${OpenCV_DIR} ${OpenCV_LIBS}")
else() 
  message(FATAL_ERROR, "Can not found Opencv library")
endif()

add_executable(main 
  src/main.cpp
  src/driver_control.cpp
  )

set_property(TARGET main PROPERTY
  MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>")


set(LUA_INCLUDE_DIR $ENV{VCPKG_ROOT}/installed/x86-windows-static/include)
if(CMAKE_BUILD_TYPE STREQUAL "Release") 
set(LUA_LIBRARIES $ENV{VCPKG_ROOT}/installed/x86-windows-static/lib/lua.lib)
else()
set(LUA_LIBRARIES $ENV{VCPKG_ROOT}/installed/x86-windows-static/debug/lib/lua.lib)
endif()

message(STATUS "Lua ${LUA_INCLUDE_DIR}")
message(STATUS "Lua ${LUA_LIBRARIES}")


target_compile_options(main PRIVATE /utf-8)

target_include_directories(main PRIVATE src ${LUA_INCLUDE_DIR})

target_link_libraries(main PRIVATE ${OpenCV_LIBS} ${LUA_LIBRARIES})

else()

project(automation CXX)

set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

if(NOT DEFINED ${CMAKE_BUILD_TYPE})
  message(STATUS "Not define build type, default Release")
  set(CMAKE_BUILD_TYPE Release)
endif()

list(APPEND CMAKE_MODULE_PATH "cmake")
find_package(WDK REQUIRED)

if(WDK_FOUND)
message(STATUS "Find WDK ${WDK_ROOT}")
endif()

wdk_add_driver(click 
  src/driver/dispatch.cpp
  src/driver/mouse.cpp
  src/driver/memory.cpp
  src/driver/driver.cpp
)
target_compile_options(click PRIVATE /utf-8)
target_include_directories(click PRIVATE src/driver)

endif()
```

`build.bat`:

```bat
@SET CURRENTDIR="%cd%"
@call "C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Auxiliary\Build\vcvars32.bat"
@cd %CURRENTDIR%
cmake -G Ninja -B build
cmake --build build --target main
@call "C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Auxiliary\Build\vcvars64.bat"
@cd %CURRENTDIR%
cmake -G Ninja -B build_driver -D DRIVER=1
cmake --build build_driver --target click


```

`cmake/FindWDK.cmake`:

```cmake
# Redistribution and use is allowed under the OSI-approved 3-clause BSD license.
# Copyright (c) 2018 Sergey Podobry (sergey.podobry at gmail.com). All rights reserved.

#.rst:
# FindWDK
# ----------
#
# This module searches for the installed Windows Development Kit (WDK) and 
# exposes commands for creating kernel drivers and kernel libraries.
#
# Output variables:
# - `WDK_FOUND` -- if false, do not try to use WDK
# - `WDK_ROOT` -- where WDK is installed
# - `WDK_VERSION` -- the version of the selected WDK
# - `WDK_WINVER` -- the WINVER used for kernel drivers and libraries 
#        (default value is `0x0601` and can be changed per target or globally)
#
# Example usage:
#
#   find_package(WDK REQUIRED)
#
#   wdk_add_library(KmdfCppLib STATIC KMDF 1.15
#       KmdfCppLib.h 
#       KmdfCppLib.cpp
#       )
#   target_include_directories(KmdfCppLib INTERFACE .)
#
#   wdk_add_driver(KmdfCppDriver KMDF 1.15
#       Main.cpp
#       )
#   target_link_libraries(KmdfCppDriver KmdfCppLib)
#

if(DEFINED ENV{WDKContentRoot})
    file(GLOB WDK_NTDDK_FILES
        "$ENV{WDKContentRoot}/Include/*/km/ntddk.h"
    )
else()
    file(GLOB WDK_NTDDK_FILES
        "C:/Program Files*/Windows Kits/10/Include/*/km/ntddk.h"
    )
endif()

if(WDK_NTDDK_FILES)
    list(GET WDK_NTDDK_FILES -1 WDK_LATEST_NTDDK_FILE)
endif()

include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(WDK REQUIRED_VARS WDK_LATEST_NTDDK_FILE)

if (NOT WDK_LATEST_NTDDK_FILE)
    return()
endif()

get_filename_component(WDK_ROOT ${WDK_LATEST_NTDDK_FILE} DIRECTORY)
get_filename_component(WDK_ROOT ${WDK_ROOT} DIRECTORY)
get_filename_component(WDK_VERSION ${WDK_ROOT} NAME)
get_filename_component(WDK_ROOT ${WDK_ROOT} DIRECTORY)
get_filename_component(WDK_ROOT ${WDK_ROOT} DIRECTORY)

message(STATUS "WDK_ROOT: " ${WDK_ROOT})
message(STATUS "WDK_VERSION: " ${WDK_VERSION})

set(WDK_WINVER "0x0601" CACHE STRING "Default WINVER for WDK targets")

set(WDK_ADDITIONAL_FLAGS_FILE "${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/wdkflags.h")
file(WRITE ${WDK_ADDITIONAL_FLAGS_FILE} "#pragma runtime_checks(\"suc\", off)")

set(WDK_COMPILE_FLAGS
    "/Zp8" # set struct alignment
    "/GF"  # enable string pooling
    "/GR-" # disable RTTI
    "/Gz" # __stdcall by default
    "/kernel"  # create kernel mode binary
    "/FIwarning.h" # disable warnings in WDK headers
    "/FI${WDK_ADDITIONAL_FLAGS_FILE}" # include file to disable RTC
    )

set(WDK_COMPILE_DEFINITIONS "WINNT=1")
set(WDK_COMPILE_DEFINITIONS_DEBUG "MSC_NOOPT;DEPRECATE_DDK_FUNCTIONS=1;DBG=1")

if(CMAKE_SIZEOF_VOID_P EQUAL 4)
    list(APPEND WDK_COMPILE_DEFINITIONS "_X86_=1;i386=1;STD_CALL")
    set(WDK_PLATFORM "x86")
elseif(CMAKE_SIZEOF_VOID_P EQUAL 8)
    list(APPEND WDK_COMPILE_DEFINITIONS "_WIN64;_AMD64_;AMD64")
    set(WDK_PLATFORM "x64")
else()
    message(FATAL_ERROR "Unsupported architecture")
endif()

string(CONCAT WDK_LINK_FLAGS
    "/MANIFEST:NO " #
    "/DRIVER " #
    "/OPT:REF " #
    "/INCREMENTAL:NO " #
    "/OPT:ICF " #
    "/SUBSYSTEM:NATIVE " #
    "/MERGE:_TEXT=.text;_PAGE=PAGE " #
    "/NODEFAULTLIB " # do not link default CRT
    "/SECTION:INIT,d " #
    "/VERSION:10.0 " #
    )

# Generate imported targets for WDK lib files
file(GLOB WDK_LIBRARIES "${WDK_ROOT}/Lib/${WDK_VERSION}/km/${WDK_PLATFORM}/*.lib")    
foreach(LIBRARY IN LISTS WDK_LIBRARIES)
    get_filename_component(LIBRARY_NAME ${LIBRARY} NAME_WE)
    string(TOUPPER ${LIBRARY_NAME} LIBRARY_NAME)
    add_library(WDK::${LIBRARY_NAME} INTERFACE IMPORTED)
    set_property(TARGET WDK::${LIBRARY_NAME} PROPERTY INTERFACE_LINK_LIBRARIES  ${LIBRARY})
endforeach(LIBRARY)
unset(WDK_LIBRARIES)

function(wdk_add_driver _target)
    cmake_parse_arguments(WDK "" "KMDF;WINVER" "" ${ARGN})

    add_executable(${_target} ${WDK_UNPARSED_ARGUMENTS})

    set_target_properties(${_target} PROPERTIES SUFFIX ".sys")
    set_target_properties(${_target} PROPERTIES COMPILE_OPTIONS "${WDK_COMPILE_FLAGS}")
    set_target_properties(${_target} PROPERTIES COMPILE_DEFINITIONS
        "${WDK_COMPILE_DEFINITIONS};$<$<CONFIG:Debug>:${WDK_COMPILE_DEFINITIONS_DEBUG}>;_WIN32_WINNT=${WDK_WINVER}"
        )
    set_target_properties(${_target} PROPERTIES LINK_FLAGS "${WDK_LINK_FLAGS}")

    target_include_directories(${_target} SYSTEM PRIVATE
        "${WDK_ROOT}/Include/${WDK_VERSION}/shared"
        "${WDK_ROOT}/Include/${WDK_VERSION}/km"
        "${WDK_ROOT}/Include/${WDK_VERSION}/km/crt"
        )

    target_link_libraries(${_target} WDK::NTOSKRNL WDK::HAL WDK::BUFFEROVERFLOWK WDK::WMILIB)

    if(CMAKE_SIZEOF_VOID_P EQUAL 4)
        target_link_libraries(${_target} WDK::MEMCMP)
    endif()

    if(DEFINED WDK_KMDF)
        target_include_directories(${_target} SYSTEM PRIVATE "${WDK_ROOT}/Include/wdf/kmdf/${WDK_KMDF}")
        target_link_libraries(${_target}
            "${WDK_ROOT}/Lib/wdf/kmdf/${WDK_PLATFORM}/${WDK_KMDF}/WdfDriverEntry.lib"
            "${WDK_ROOT}/Lib/wdf/kmdf/${WDK_PLATFORM}/${WDK_KMDF}/WdfLdr.lib"
            )

        if(CMAKE_SIZEOF_VOID_P EQUAL 4)
            set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:FxDriverEntry@8")
        elseif(CMAKE_SIZEOF_VOID_P  EQUAL 8)
            set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:FxDriverEntry")
        endif()
    else()
        if(CMAKE_SIZEOF_VOID_P EQUAL 4)
            set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:GsDriverEntry@8")
        elseif(CMAKE_SIZEOF_VOID_P  EQUAL 8)
            set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:GsDriverEntry")
        endif()
    endif()
endfunction()

function(wdk_add_library _target)
    cmake_parse_arguments(WDK "" "KMDF;WINVER" "" ${ARGN})

    add_library(${_target} ${WDK_UNPARSED_ARGUMENTS})

    set_target_properties(${_target} PROPERTIES COMPILE_OPTIONS "${WDK_COMPILE_FLAGS}")
    set_target_properties(${_target} PROPERTIES COMPILE_DEFINITIONS 
        "${WDK_COMPILE_DEFINITIONS};$<$<CONFIG:Debug>:${WDK_COMPILE_DEFINITIONS_DEBUG};_WIN32_WINNT=${WDK_WINVER}>"
        )

    target_include_directories(${_target} SYSTEM PRIVATE
        "${WDK_ROOT}/Include/${WDK_VERSION}/shared"
        "${WDK_ROOT}/Include/${WDK_VERSION}/km"
        "${WDK_ROOT}/Include/${WDK_VERSION}/km/crt"
        )

    if(DEFINED WDK_KMDF)
        target_include_directories(${_target} SYSTEM PRIVATE "${WDK_ROOT}/Include/wdf/kmdf/${WDK_KMDF}")
    endif()
endfunction()
```

`package.json`:

```json
{
  "name": "automation",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "build.bat && build\\main.exe 1920 1080 scripts/test.lua pics/test 234234",
    "rongda": "build.bat && build\\main.exe 1920 1080 rongda",
    "wenxiu": "build.bat && build\\main.exe 1920 1080 wenxiu",
    "qugou": "build.bat && build\\main.exe 1920 1080 qugou"
  },
  "author": "",
  "license": "ISC"
}
```

`readme.md`:

```md

## 介绍
这是一个基于 OpenCV 实现的自动化工具.


1. 基于 OpenCV 的模板匹配, 目前一张图在 1920x1080 分辨率下是 200ms 左右的检测速度.
1. 精简的操作逻辑封装, 你写的脚本可处理任何误操作.
1. 基于图片匹配, 因此适合各种使用系统控件和自绘类型程序的自动化.
1. 使用 LUA 快速编写自动化逻辑.
1. 驱动层模拟鼠标和键盘.


`目前驱动只适配了 Windows 7, Windows 10 64位, 要适配其他系统大概需要解决一下驱动层 ClassServiceCallback 的问题`


## Build
1. Install Visual Studio 2019
1. Install CMake
1. Install Vcpkg
1. Install Node.js
1. `vcpkg install opencv4 --triplet=x86-windows-static`
1. Add `VCPKG_ROOT` to env
1. Run `npm run test` to build this project

## Usage

1. First you need load the driver
1. Write you lua script, and do command

```
main.exe <screen width> <screen height> <lua file path> <pics path>
```

## C API
|      | 行为 |
| ---- | ---- |
| forceClick | 等待一个图出现然后点击它, 最多等待 15s, 超时抛出 ScriptTimeout 异常 |
| click | 点击一个图, 图不存在返回 false |
| dclick | 双击一个图, 图不存在返回 false |
| dforceClick | 等待一个图出现然后双击, 15s 超时, 抛出异常 |
| refreshScreen | 刷新屏幕图 |
| paste | Ctrl+V 的方式输入内容 |
| picExists | 判断图是否出现 |
| forceWait | 等待一个图出现 |


## Lua API
|      | 行为 |
| ---- | ---- |
| forceClick | 等待一个图出现然后点击它, 最多等待 15s, 超时抛出 ScriptTimeout 异常 |
| click | 点击一个图, 图不存在返回 false |
| dclick | 双击一个图, 图不存在返回 false |
| dforceClick | 等待一个图出现然后双击, 15s 超时, 抛出异常 |
| refreshScreen | 刷新屏幕图 |
| paste | 粘贴 |
| picExists | 判断图是否出现 |
| forceWait | 等待一个图出现 |
| sleep | 睡眠, 毫秒 |

## Thanks
1. https://github.com/nbqofficial/norsefire
1. https://github.com/SergiusTheBest/FindWDK

```

`src/app.hpp`:

```hpp
#pragma once

#include "app.hpp"
#include "base/clicker.hpp"
#include "base/matcher.hpp"
#include "definitions.hpp"
#include "driver_control.hpp"
#include "opencv2/core.hpp"
extern "C" {
#include "lauxlib.h"
#include "lua.h"
#include "lualib.h"
}
#include "opencv2/core/cvstd.hpp"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "utils/logger.hpp"
#include "windows/screen.hpp"
#include <cstdio>
#include <cstdlib>
#include <exception>
#include <filesystem>
#include <list>
#include <map>
#include <optional>
#include <stdexcept>
#include <stdio.h>
#include <string>
#include <thread>
#include <vector>

#define REGLUAFUN(x, y)                                                        \
    lua_register(luaState, x, y);                                              \
    logd("Lua function: %s", x);

using namespace std::chrono_literals;

class ScriptTimeout : public std::exception {
    std::string name;

  public:
    ScriptTimeout(std::string name) { this->name = "Timeout " + name; }
    const char *what() const override { return name.c_str(); }
};

class App {
    std::vector<std::filesystem::path> pathList{};
    std::map<std::string, cv::Mat> cacheMat;
    std::string hospital_name;
    std::string picsDir;
    ScreenImpl screen;
    Matcher matcher;
    Clicker clicker;
    cv::Mat screenMat;
    std::vector<std::string> extentsArgument;
    driver_control dr;
    lua_State *luaState;

  public:
    static App *_app;

    App(int argc, char **argv)
        : screen(1920, 1080), dr("\\\\.\\norsefire"),
          clicker(&dr, screen.get_screenWidth(), screen.get_screenHeight()) {

        _app = this;

        for (int i = 0; i < argc; i++) {
            char *x = argv[i];
            logd("%d %s", i, x);
        }

        if (argc <= 4) {
            printf("Arguments error");
            exit(0);
        }

        // load driver
        if (!dr.ready()) {
            logd("Driver load error");
            exit(-4);
        } else {
            logd("Driver load successful");
        }

        for (int i = 5; i < argc; i++) {
            extentsArgument.push_back(argv[i]);
        }

        int x = std::atoi(argv[1]);
        int y = std::atoi(argv[2]);

        clicker.setsx(x);
        clicker.setsy(y);

        screen.set_screenHeight(y);
        screen.set_screenWidth(x);

        logd("Device Height %d", y);
        logd("Device Width %d", x);

        using namespace std::filesystem;

        hospital_name = argv[3];
        picsDir = argv[4];
        logd("Script Path: %s", hospital_name.c_str());
        logd("Pictures Path: %s", picsDir.c_str());

        logd("Init lua..");
        luaState = luaL_newstate();
        luaL_openlibs(luaState);
        registerLuaRuntime();
    }

    void doFile(std::string filename) {
        if (filename.find(".lua") == std::string::npos) {
            filename += ".lua";
        }
        logd("Load script %s", filename.c_str());
        if (0 != luaL_dofile(luaState, filename.c_str())) {
            const char *err = lua_tostring(luaState, -1);
            lua_pop(luaState, 1);
            throw std::runtime_error(err);
        } else {
            logd("Script done");
        }
    }

    void registerLuaRuntime() {

        REGLUAFUN("getarg", [](lua_State *L) -> int {
            int arg_counts = lua_gettop(L);
            if (arg_counts != 1) {
                luaL_error(L, "getarg arguments error");
            } else {
                auto i = lua_tonumber(L, 1);
                if (App::_app->extentsArgument.size() <= i) {
                    luaL_error(L, "getarg index outrange");
                } else {
                    auto r = App::_app->extentsArgument.at(i);
                    lua_pushstring(L, r.c_str());
                    return 1;
                }
            }
            return 0;
        });

        REGLUAFUN("forceWait", [](lua_State *L) -> int {
            try {
                int arg_counts = lua_gettop(L);

                if (arg_counts == 1) {
                    std::string info;
                    info = lua_tostring(L, 1);
                    App::_app->forceWait(info);
                } else {
                    luaL_error(L, "forceWait arguments error");
                }
            } catch (...) {
                luaL_error(L, "forceWait exception");
            }
            return 0;
        })

        REGLUAFUN("log", [](lua_State *L) -> int {
            try {
                int arg_counts = lua_gettop(L);

                if (arg_counts == 1) {
                    std::string info;
                    info = lua_tostring(L, 1);
                    logd("LUA: %s", info.c_str());
                } else {
                    luaL_error(L, "log arguments error");
                }
            } catch (...) {
                luaL_error(L, "log exception");
            }
            return 0;
        });

        REGLUAFUN("paste", [](lua_State *L) -> int {
            int arg_counts = lua_gettop(L);

            if (arg_counts == 1) {
                std::string info;
                info = lua_tostring(L, 1);
                App::_app->paste(info);
            } else {
                luaL_error(L, "paste arguments error");
            }
            return 0;
        });

        REGLUAFUN("picExists", [](lua_State *L) -> int {
            int arg_counts = lua_gettop(L);
            if (arg_counts != 1) {
                luaL_error(L, "picExists arguments error");
            } else {
                const char *a = lua_tostring(L, 1);
                auto r = App::_app->picExists(a);
                lua_pushboolean(L, r);
                return 1;
            }
            return 0;
        });

        REGLUAFUN("forceClick", [](lua_State *L) -> int {
            try {
                int arg_counts = lua_gettop(L);

                if (arg_counts == 1) {
                    std::string info;
                    info = lua_tostring(L, 1);
                    App::_app->forceClick(info);
                } else if (arg_counts == 2) {
                    std::string info;
                    info = lua_tostring(L, 1);
                    int offx = lua_tonumber(L, 2);
                    App::_app->forceClick(info, offx);
                } else if (arg_counts == 3) {
                    std::string info;
                    info = lua_tostring(L, 1);
                    int offx = lua_tonumber(L, 2);
                    int offy = lua_tonumber(L, 3);
                    App::_app->forceClick(info, offx, offy);
                } else {
                    luaL_error(L, "forceClick arguments error");
                }
            } catch (const std::exception &err) {
                luaL_error(L, "forceClick exception %s", err.what());
            }
            return 0;
        });

        REGLUAFUN("dforceClick", [](lua_State *L) -> int {
            try {
                int arg_counts = lua_gettop(L);

                if (arg_counts == 1) {
                    std::string info;
                    info = lua_tostring(L, 1);
                    App::_app->dforceClick(info);
                } else if (arg_counts == 2) {
                    std::string info;
                    info = lua_tostring(L, 1);
                    int offx = lua_tonumber(L, 2);
                    App::_app->dforceClick(info, offx);
                } else if (arg_counts == 3) {
                    std::string info;
                    info = lua_tostring(L, 1);
                    int offx = lua_tonumber(L, 2);
                    int offy = lua_tonumber(L, 3);
                    App::_app->dforceClick(info, offx, offy);
                } else {
                    luaL_error(L, "dforceClick arguments error");
                }
            } catch (const std::exception &err) {
                luaL_error(L, "dforceClick exception %s", err.what());
            }

            return 0;
        })

        REGLUAFUN("dclick", [](lua_State *L) -> int {
            try {
                int arg_counts = lua_gettop(L);
                if (arg_counts == 1) {
                    auto r = lua_tostring(L, 1);
                    App::_app->dclick(r);
                } else if (arg_counts == 2) {
                    auto r = lua_tostring(L, 1);
                    int offx = lua_tonumber(L, 2);
                    App::_app->dclick(r, offx);
                } else if (arg_counts == 3) {
                    auto r = lua_tostring(L, 1);
                    int offx = lua_tonumber(L, 2);
                    int offy = lua_tonumber(L, 3);
                    App::_app->dclick(r, offx, offy);
                } else {
                    luaL_error(L, "dclick arguments error");
                }
            } catch (const std::exception &err) {
                luaL_error(L, "dclick exception %s", err.what());
            }
            return 0;
        });

        REGLUAFUN("sleep", [](lua_State *L) -> int {
            int arg_counts = lua_gettop(L);
            if (arg_counts != 1) {
                luaL_error(L, "sleep arguments error");
            } else {
                auto r = lua_tonumber(L, 1);
                App::_app->sleep(r);
            }
            return 0;
        });

        REGLUAFUN("click", [](lua_State *L) -> int {
            try {
                int arg_counts = lua_gettop(L);

                if (arg_counts == 1) {
                    std::string info;
                    info = lua_tostring(L, 1);
                    App::_app->click(info);
                } else if (arg_counts == 3) {
                    std::string info;
                    info = lua_tostring(L, 1);
                    int offx = lua_tonumber(L, 2);
                    int offy = lua_tonumber(L, 3);
                    App::_app->click(info, offx, offy);
                } else {
                    luaL_error(L, "click arguments error");
                }
            } catch (const std::exception &err) {
                luaL_error(L, "click exception %s", err.what());
            }
            return 0;
        });

        REGLUAFUN("refreshScreen", [](lua_State *L) -> int {
            int arg_counts = lua_gettop(L);
            if (arg_counts != 0) {
                luaL_error(L, "refreshScreen arguments error");
            }
            App::_app->refreshScreen();
            return 0;
        });
    }

    // sleep and then refresh screen
    void sleep(int ms) {
        std::this_thread::sleep_for(1ms * ms);
        refreshScreen();
    }

    void loadCache(const std::string &hospital_name) {
        logd("Loading pictures from %s..", hospital_name.c_str());
        using namespace std::filesystem;
        for (auto r : recursive_directory_iterator(hospital_name)) {
            pathList.push_back(r.path());
        }
        if (pathList.size() == 0) {
            printf("No pictures loaded");
            std::terminate();
        }

        for (auto r : pathList) {
            cv::Mat mat = cv::imread(r.string(), cv::IMREAD_COLOR);
            cacheMat[r.u8string()] = mat;
            printf("Load %s type %d\n", r.u8string().c_str(), mat.type());
        }

        std::printf("Load done, pictures count %d\n", cacheMat.size());
    }

    const HWND hwndFromClass(const std::string &classname) {
        HWND wnd = FindWindowExA(NULL, NULL, classname.c_str(), NULL);
        if (wnd != NULL) {
            return wnd;
        }
        return NULL;
    }

    // Wait util visible
    bool forceWait(const std::string &name) {
        for (int i = 0; i < 10; i++) {
            std::this_thread::sleep_for(1s);
            refreshScreen();
            if (picExists(name)) {
                return true;
            }
        }
        throw ScriptTimeout(name);
    }

    bool picExists(const std::string &name) {
        const cv::Mat &mat = fetchMat(name);
        auto r = matcher.matchTemplate(name, screenMat, mat);
        if (r != std::nullopt) {
            return true;
        }
        return false;
    }

    bool click(const std::string &name, int offx = 0, int offy = 0) {
        using namespace std::chrono_literals;
        auto r = matcher.matchTemplate(name, screenMat, fetchMat(name));
        if (r == std::nullopt) {
            printf("click fail %s\n", name.c_str());
            return false;
        }
        clicker.click(r->x + offx, r->y + offy);
        refreshScreen();
        return true;
    }

    const cv::Mat &fetchMat(const std::string &name) {
        auto r = normalizeName(name);
        if (cacheMat.find(r) == cacheMat.end()) {
            throw std::runtime_error("Pic not exists " + r);
        }
        return cacheMat[r];
    }

    std::string normalizeName(std::string name) {
        name = picsDir + "\\" + name + ".png";
        return name;
    }

    // Wait target visible and click, timeout 15s
    void forceClick(const std::string &name, int offx = 0, int offy = 0) {
        for (int i = 0; i < 15; i++) {
            if (auto r =
                    matcher.matchTemplate(name, screenMat, fetchMat(name))) {
                clicker.click(r->x + offx, r->y + offy);
                refreshScreen();
                return;
            }
            std::this_thread::sleep_for(1s);
            refreshScreen();
        }
        throw ScriptTimeout(name);
    }

    void refreshScreen() {
        auto screenMatv = screen.fetch();
        if (screenMatv == std::nullopt) {
            throw std::runtime_error("Screen null\n");
        }

        screenMat = screenMatv.value();
    }

    int run() {
        try {
            loadCache(picsDir);
            doFile(hospital_name);
        } catch (std::filesystem::filesystem_error &err) {
            printf("Load pictures error %s\n", hospital_name.c_str());
            return -1;
        } catch (std::exception &err) {
            printf("Exception %s\n", err.what());
            return -2;
        } catch (...) {
            printf("Unhandled exception\n");
            return -3;
        }
        logd("Automation exit");
        return 0;
    }

    void paste(const std::string &name) {
        logd("Paste %s", name.c_str());
        clicker.paste(name);
        std::this_thread::sleep_for(UI_WAITTIME);
        refreshScreen();
    }

    void test() {
        // std::this_thread::sleep_for(3s);
        // paste("11115555");
        // paste("中文也可以");
        // paste("149mfqwefkmasdf");
        // paste("91fw0%$@!#$@%+_");
        doFile("example/" + hospital_name);
    }

    void dforceClick(std::string name, int offx = 0, int offy = 0) {
        for (int i = 0; i < 15; i++) {
            if (auto r =
                    matcher.matchTemplate(name, screenMat, fetchMat(name))) {
                clicker.dclick(r->x + offx, r->y + offy);
                refreshScreen();
                return;
            }
            std::this_thread::sleep_for(1s);
            refreshScreen();
        }
        throw ScriptTimeout(name);
    }

    void dclick(std::string name, int offx = 0, int offy = 0) {
        auto r = matcher.matchTemplate(name, screenMat, fetchMat(name));
        if (r == std::nullopt) {
            throw std::runtime_error("pic not exists");
        }
        clicker.dclick(r->x + offx, r->y + offy);
        refreshScreen();
    }
};
```

`src/base/clicker.hpp`:

```hpp
#pragma once
#include "constant.hpp"
#include "driver_control.hpp"
#include "utils/logger.hpp"
#include <Windows.h>
#include <iostream>
#include <stdexcept>
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <thread>
#include <vector>

class Clicker {

  private:
    double scale = 1.25;
    double sx;
    double sy;
    driver_control *dr;

  public:
    Clicker(driver_control *dr, int sx, int sy) {
        this->sx = sx;
        this->sy = sy;
        this->dr = dr;
    }

    void paste(const std::string &text) {
        auto h = ::OpenClipboard(::GetDesktopWindow());
        ::EmptyClipboard();

        auto hglbCopy = GlobalAlloc(GMEM_MOVEABLE, text.length() + 1);
        if (hglbCopy == NULL) {
            CloseClipboard();
            return;
        }

        auto lptstrCopy = (char *)GlobalLock(hglbCopy);
        memcpy(lptstrCopy, text.data(), text.length());
        lptstrCopy[text.length()] = 0;
        GlobalUnlock(hglbCopy);

        ::SetClipboardData(CF_TEXT, hglbCopy);

        paste();
        ::CloseClipboard();
    }

    void paste() {

        // 1d ctrl
        // 2f v
        dr->keyboard_event(0, 0x1d, 0x0, 0, 0);
        dr->keyboard_event(0, 0x2f, 0x0, 0, 0);
        dr->keyboard_event(0, 0x2f, 0x1, 0, 0);
        dr->keyboard_event(0, 0x1d, 0x1, 0, 0);

        // INPUT inputs[4] = {};
        // ZeroMemory(inputs, sizeof(inputs));

        // inputs[0].type = INPUT_KEYBOARD;
        // inputs[0].ki.wVk = VK_LCONTROL;

        // inputs[1].type = INPUT_KEYBOARD;
        // inputs[1].ki.wVk = 'V';

        // inputs[2].type = INPUT_KEYBOARD;
        // inputs[2].ki.wVk = 'V';
        // inputs[2].ki.dwFlags = KEYEVENTF_KEYUP;

        // inputs[3].type = INPUT_KEYBOARD;
        // inputs[3].ki.wVk = VK_LCONTROL;
        // inputs[3].ki.dwFlags = KEYEVENTF_KEYUP;

        // UINT uSent = SendInput(ARRAYSIZE(inputs), inputs, sizeof(INPUT));
        // if (uSent != ARRAYSIZE(inputs)) {
        //     printf("SendInput failed: 0x%x\n",
        //            HRESULT_FROM_WIN32(GetLastError()));
        // }
    }

    void input(std::wstring text) {
        int len = text.length();
        if (len == 0) {
            throw std::runtime_error("err len while input");
        }

        std::vector<INPUT> vec;

        logd("Input %ls", text.c_str());
        for (int i = 0; i < len; i++) {
            wchar_t c = text[i];
            INPUT input;
            memset(&input, 0, sizeof(INPUT));
            input.type = INPUT_KEYBOARD;
            input.ki.dwFlags = KEYEVENTF_UNICODE;
            input.ki.wScan = c;
            vec.push_back(input);

            input.ki.dwFlags |= KEYEVENTF_KEYUP;
            vec.push_back(input);
        }
        SendInput(vec.size(), vec.data(), sizeof(INPUT));
        std::this_thread::sleep_for(UI_WAITTIME);
    }

    void setsy(int v) { sy = v; }

    void setsx(int v) { sx = v; }

    void toDesktop() {

        INPUT inputs[4] = {};
        ZeroMemory(inputs, sizeof(inputs));

        inputs[0].type = INPUT_KEYBOARD;
        inputs[0].ki.wVk = VK_LWIN;

        inputs[1].type = INPUT_KEYBOARD;
        inputs[1].ki.wVk = 'D';

        inputs[2].type = INPUT_KEYBOARD;
        inputs[2].ki.wVk = 'D';
        inputs[2].ki.dwFlags = KEYEVENTF_KEYUP;

        inputs[3].type = INPUT_KEYBOARD;
        inputs[3].ki.wVk = VK_LWIN;
        inputs[3].ki.dwFlags = KEYEVENTF_KEYUP;

        UINT uSent = SendInput(ARRAYSIZE(inputs), inputs, sizeof(INPUT));
        if (uSent != ARRAYSIZE(inputs)) {
            printf("SendInput failed: 0x%x\n",
                   HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    void click(HWND hwnd, int x, int y) {

        POINT point;
        point.x = x;
        point.y = y;

        // point.x = toPixelX(point.x);
        // point.y = toPixelX(point.y);

        // ::GetCursorPos(&point);
        // printf("after get cursor pos to client %d %d\n", point.x, point.y);

        ::ScreenToClient(hwnd, &point);
        printf("after screen to client %d %d\n", point.x, point.y);

        // ::MapWindowPoints(GetDesktopWindow(), hwnd, &point, 1);

        // point.x = x * scale;
        // point.y = y * scale;

        ::SendMessageA(hwnd, WM_PARENTNOTIFY, WM_LBUTTONDOWN,
                       MAKELPARAM(point.x, point.y));
        ::SendMessageA(hwnd, WM_MOUSEACTIVATE, (WPARAM)hwnd,
                       MAKELPARAM(1, WM_LBUTTONDOWN));
        // ::PostMessageA(hwnd, WM_LBUTTONUP, 0, MAKELPARAM(point.x, point.y));
    }

    int toPixelX(int x) { return x * (65535.0 / sx); }

    int toPixelY(int y) { return y * (65535.0 / sy); }

    void dclick(int x, int y) {
        _click(x, y);
        std::this_thread::sleep_for(30ms);
        _click(x, y);
        std::this_thread::sleep_for(UI_WAITTIME);
    }

    void click(int x, int y) {
        _click(x, y);
        std::this_thread::sleep_for(UI_WAITTIME);
    }

    void _click(int x, int y) {

        dr->mouse_event(65535.0 / this->sx * x, 65535.0 / this->sy * y, 0x1, 0);
        std::this_thread::sleep_for(300ms);
        dr->mouse_event(65535.0 / this->sx * x, 65535.0 / this->sy * y, 0x2, 0);

        // using namespace std::chrono;

        // INPUT inputs[3] = {};
        // ZeroMemory(inputs, sizeof(inputs));

        // int i = 0;
        // inputs[i].type = INPUT_MOUSE;
        // inputs[i].mi.dwFlags = MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE;
        // inputs[i].mi.mouseData = 0;
        // inputs[i].mi.dx = x * (65536.0 / sx);
        // inputs[i].mi.dy = y * (65536.0 / sy);

        // i++;
        // inputs[i].type = INPUT_MOUSE;
        // inputs[i].mi.dwFlags = MOUSEEVENTF_LEFTDOWN;
        // inputs[i].mi.mouseData = 0;
        // inputs[i].mi.dx = x * (65536.0 / sx);
        // inputs[i].mi.dy = y * (65536.0 / sy);

        // std::this_thread::sleep_for(30ms);

        // i++;
        // inputs[i].type = INPUT_MOUSE;
        // inputs[i].mi.dwFlags = MOUSEEVENTF_LEFTUP;
        // inputs[i].mi.mouseData = 0;
        // inputs[i].mi.dx = x * (65536.0 / sx);
        // inputs[i].mi.dy = y * (65536.0 / sy);

        // SendInput(ARRAYSIZE(inputs), inputs, sizeof(INPUT));
    }
};
```

`src/base/matcher.hpp`:

```hpp
#pragma once
#include "opencv2/core/types.hpp"
#include "opencv2/imgproc.hpp"
#include "utils/timecalc.hpp"
#include <cstddef>
#include <opencv2/opencv.hpp>
#include <optional>
#include <stdexcept>
#include <stdio.h>

class Matcher {
  public:
    Matcher() {}
    ~Matcher() {}

    std::optional<cv::Point> matchTemplate(const std::string &name,
                                           const cv::Mat &matchscreen,
                                           const cv::Mat &matchpic) {

        // printf("1type %d 2type %d\n", matchscreen.type(), matchpic.type());

        TimeCalc calc("cost time");

        double minVal;
        double maxVal = 0;
        cv::Point minLoc;
        cv::Point maxLoc;
        cv::Mat result;
        cv::Point r;

        //匹配方式
        int match_method = cv::TM_CCOEFF_NORMED;

        if (matchpic.rows > matchscreen.rows ||
            matchpic.cols > matchscreen.cols) {
            throw std::runtime_error("Fatal: target big than screen " + name);
        }
        cv::matchTemplate(matchscreen, matchpic, result, match_method);
        cv::minMaxLoc(result, &minVal, &maxVal, &minLoc, &maxLoc, cv::Mat());

        if (match_method == cv::TM_SQDIFF ||
            match_method == cv::TM_SQDIFF_NORMED) {
            r.x = minLoc.x;
            r.y = minLoc.y;
        } else {
            r.x = maxLoc.x;
            r.y = maxLoc.y;
        }

        r.x += matchpic.cols / 2;
        r.y += matchpic.rows / 2;

        printf("Match result %s %f %d %d %s\n", name.c_str(), maxVal, r.x, r.y,
               calc.finish().c_str());

        if (maxVal > 0.9) {
            return r;
        }

        return std::nullopt;
    }
};
```

`src/base/screen.h`:

```h
#pragma once
#include "opencv2/core/mat.hpp"
#include "opencv2/opencv.hpp"
#include <optional>
class Screen {
  public:
    virtual std::optional<cv::Mat> fetch() = 0;
};
```

`src/constant.hpp`:

```hpp
#include <chrono>

using namespace std::chrono_literals;

constexpr auto UI_WAITTIME = 1500ms;
```

`src/definitions.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <iostream>

#define NF_GET_PROCESS_ID                                                      \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0xf9000, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define NF_GET_MODULE                                                          \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0xf9001, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define NF_READ_MEMORY                                                         \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0xf9002, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define NF_WRITE_MEMORY                                                        \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0xf9003, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define NF_MOUSE_EVENT                                                         \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0xf9004, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define NF_KB_EVENT                                                            \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0xf9005, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

typedef struct _NF_PROCESS_ID_REQUEST {
    ULONG process_id;
    char process_name[64];
} NF_PROCESS_ID_REQUEST, *PNF_PROCESS_ID_REQUEST;

typedef struct _NF_MODULE_REQUEST {
    ULONG process_id;
    ULONG address;
    wchar_t module_name[64];
} NF_MODULE_REQUEST, *PNF_MODULE_REQUEST;

typedef struct _NF_READ_REQUEST {
    ULONG process_id;
    ULONG address;
    ULONG buffer;
    ULONG size;
} NF_READ_REQUEST, *PNF_READ_REQUEST;

typedef struct _NF_WRITE_REQUEST {
    ULONG process_id;
    ULONG address;
    ULONG buffer;
    ULONG size;
} NF_WRITE_REQUEST, *PNF_WRITE_REQUEST;

typedef struct _NF_MOUSE_REQUEST {
    long x;
    long y;
    unsigned short button_flags;
    unsigned short flags;
} NF_MOUSE_REQUEST, *PNF_MOUSE_REQUEST;

typedef struct _NF_KEYBOARD_REQUEST {
    USHORT UnitId;
    USHORT MakeCode;
    USHORT Flags;
    USHORT Reserved;
    ULONG ExtraInformation;
} NF_KEYBOARD_REQUEST, *PNF_KEYBOARD_REQUEST;

#define MOUSE_ERROR_VALUE_BASE 20000

#define MOUSE_LEFT_BUTTON_DOWN 0x0001

#define MOUSE_LEFT_BUTTON_UP 0x0002

#define MOUSE_RIGHT_BUTTON_DOWN 0x0004

#define MOUSE_RIGHT_BUTTON_UP 0x0008

#define MOUSE_MIDDLE_BUTTON_DOWN 0x0010

#define MOUSE_MIDDLE_BUTTON_UP 0x0020

#define MOUSE_BUTTON_4_DOWN 0x0040

#define MOUSE_BUTTON_4_UP 0x0080

#define MOUSE_BUTTON_5_DOWN 0x0100

#define MOUSE_BUTTON_5_UP 0x0200

#define MOUSE_WHEEL 0x0400

#define MOUSE_HWHEEL 0x0800

#define MOUSE_MOVE_RELATIVE 0

#define MOUSE_MOVE_ABSOLUTE 1
```

`src/driver/definitions.hpp`:

```hpp
#pragma once

#include "ntapi.hpp"

#define ACTIVE_PROCESS_LINKS_FLINK 0x2f0
#define IMAGE_FILE_NAME 0x450

#define NF_GET_PROCESS_ID                                                      \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0xf9000, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define NF_GET_MODULE                                                          \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0xf9001, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define NF_READ_MEMORY                                                         \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0xf9002, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define NF_WRITE_MEMORY                                                        \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0xf9003, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define NF_MOUSE_EVENT                                                         \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0xf9004, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define NF_KB_EVENT                                                            \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0xf9005, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

typedef struct _NF_PROCESS_ID_REQUEST {
    ULONG process_id;
    char process_name[64];
} NF_PROCESS_ID_REQUEST, *PNF_PROCESS_ID_REQUEST;

typedef struct _NF_MODULE_REQUEST {
    ULONG process_id;
    ULONG address;
    wchar_t module_name[64];
} NF_MODULE_REQUEST, *PNF_MODULE_REQUEST;

typedef struct _NF_READ_REQUEST {
    ULONG process_id;
    ULONG address;
    ULONG buffer;
    ULONG size;
} NF_READ_REQUEST, *PNF_READ_REQUEST;

typedef struct _NF_WRITE_REQUEST {
    ULONG process_id;
    ULONG address;
    ULONG buffer;
    ULONG size;
} NF_WRITE_REQUEST, *PNF_WRITE_REQUEST;

typedef struct _NF_MOUSE_REQUEST {
    long x;
    long y;
    unsigned short button_flags;
    unsigned short flags;
} NF_MOUSE_REQUEST, *PNF_MOUSE_REQUEST;

typedef struct _NF_KEYBOARD_REQUEST {
    USHORT UnitId;
    USHORT MakeCode;
    USHORT Flags;
    USHORT Reserved;
    ULONG ExtraInformation;
} NF_KEYBOARD_REQUEST, *PNF_KEYBOARD_REQUEST;

```

`src/driver/dispatch.cpp`:

```cpp
#include "dispatch.hpp"
#include "definitions.hpp"
#include "mouse.hpp"
#include <ntdef.h>
#include <ntstatus.h>

MOUSE_OBJECT mouse_obj = {0};
KEYBOARD_OBJECT keyboard_obj = {0};

NTSTATUS failIRP(PIRP irp) {
    irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
    irp->IoStatus.Information = 0;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS dispatch::handler(PDEVICE_OBJECT device_object, PIRP irp) {
    UNREFERENCED_PARAMETER(device_object);

    if (!mouse_obj.service_callback || !mouse_obj.mouse_device) {
        if (!NT_SUCCESS(mouse::init_mouse(&mouse_obj))) {
            return failIRP(irp);
        };
    }

    if (!keyboard_obj.service_callback) {
        if (!NT_SUCCESS(mouse::init_keyboard(&keyboard_obj))) {
            return failIRP(irp);
        }
    }

    NTSTATUS status = STATUS_INVALID_PARAMETER;
    ULONG bytes_io = 0;
    PIO_STACK_LOCATION pio = IoGetCurrentIrpStackLocation(irp);
    ULONG ioctl = pio->Parameters.DeviceIoControl.IoControlCode;

    if (ioctl == NF_GET_PROCESS_ID) {
        PNF_PROCESS_ID_REQUEST process_id_request =
            (PNF_PROCESS_ID_REQUEST)irp->AssociatedIrp.SystemBuffer;
        process_id_request->process_id = memory::get_process_id_by_name(
            IoGetCurrentProcess(), process_id_request->process_name);
        if (process_id_request->process_id) {
            status = STATUS_SUCCESS;
        }
        bytes_io = sizeof(NF_PROCESS_ID_REQUEST);
        DbgPrintEx(0, 0, "[norsefire]: NF_GET_PROCESS_ID\n");
    } else if (ioctl == NF_GET_MODULE) {
        PNF_MODULE_REQUEST module_request =
            (PNF_MODULE_REQUEST)irp->AssociatedIrp.SystemBuffer;
        PEPROCESS target_process = 0;
        if (NT_SUCCESS(PsLookupProcessByProcessId(
                (HANDLE)module_request->process_id, &target_process))) {
            KAPC_STATE apc;
            KeStackAttachProcess(target_process, &apc);
            ULONG base = memory::get_module_base(target_process,
                                                 module_request->module_name);
            KeUnstackDetachProcess(&apc);
            if (base) {
                module_request->address = base;
                status = STATUS_SUCCESS;
            }
            bytes_io = sizeof(NF_MODULE_REQUEST);
            DbgPrintEx(0, 0, "[norsefire]: NF_GET_MODULE\n");
        }
    } else if (ioctl == NF_READ_MEMORY) {
        PNF_READ_REQUEST read_request =
            (PNF_READ_REQUEST)irp->AssociatedIrp.SystemBuffer;
        PEPROCESS target_process = 0;
        if (NT_SUCCESS(PsLookupProcessByProcessId(
                (HANDLE)read_request->process_id, &target_process))) {
            status = memory::read_memory(
                target_process, (void *)read_request->address,
                &read_request->buffer, read_request->size);
        }
        bytes_io = sizeof(NF_READ_REQUEST);
        DbgPrintEx(0, 0, "[norsefire]: NF_READ_MEMORY\n");
    } else if (ioctl == NF_WRITE_MEMORY) {
        PNF_WRITE_REQUEST write_request =
            (PNF_WRITE_REQUEST)irp->AssociatedIrp.SystemBuffer;
        PEPROCESS target_process = 0;
        if (NT_SUCCESS(PsLookupProcessByProcessId(
                (HANDLE)write_request->process_id, &target_process))) {
            status = memory::write_memory(
                target_process, &write_request->buffer,
                (void *)write_request->address, write_request->size);
        }
        bytes_io = sizeof(NF_WRITE_REQUEST);
        DbgPrintEx(0, 0, "[norsefire]: NF_WRITE_MEMORY\n");
    } else if (ioctl == NF_MOUSE_EVENT) {
        PNF_MOUSE_REQUEST mouse_request =
            (PNF_MOUSE_REQUEST)irp->AssociatedIrp.SystemBuffer;
        mouse::mouse_event(mouse_obj, mouse_request->x, mouse_request->y,
                           mouse_request->button_flags, mouse_request->flags);
        status = STATUS_SUCCESS;
        bytes_io = sizeof(NF_MOUSE_REQUEST);
        DbgPrintEx(0, 0, "[norsefire]: NF_MOUSE_EVENT\n");
    } else if (ioctl == NF_KB_EVENT) {
        PNF_KEYBOARD_REQUEST mouse_request =
            (PNF_KEYBOARD_REQUEST)irp->AssociatedIrp.SystemBuffer;
        mouse::keyboard_event(keyboard_obj,
                              (PNF_KEYBOARD_REQUEST)mouse_request);
        status = STATUS_SUCCESS;
        bytes_io = sizeof(NF_KEYBOARD_REQUEST);
        DbgPrintEx(0, 0, "[norsefire]: NF_KEYBOARD_EVENT\n");
    } else {
        status = STATUS_INVALID_PARAMETER;
        bytes_io = 0;
        DbgPrintEx(0, 0, "[norsefire]: NF_FAILED_REQUEST\n");
    }

    irp->IoStatus.Status = status;
    irp->IoStatus.Information = bytes_io;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS dispatch::create_call(PDEVICE_OBJECT device_object, PIRP irp) {
    UNREFERENCED_PARAMETER(device_object);
    irp->IoStatus.Status = STATUS_SUCCESS;
    irp->IoStatus.Information = 0;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS dispatch::close_call(PDEVICE_OBJECT device_object, PIRP irp) {
    UNREFERENCED_PARAMETER(device_object);
    irp->IoStatus.Status = STATUS_SUCCESS;
    irp->IoStatus.Information = 0;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

```

`src/driver/dispatch.hpp`:

```hpp
#pragma once

#include "memory.hpp"

namespace dispatch {
NTSTATUS handler(PDEVICE_OBJECT device_object, PIRP irp);

NTSTATUS create_call(PDEVICE_OBJECT device_object, PIRP irp);

NTSTATUS close_call(PDEVICE_OBJECT device_object, PIRP irp);
} // namespace dispatch
```

`src/driver/driver.cpp`:

```cpp
#include "dispatch.hpp"
#include "wdm.h"

PDEVICE_OBJECT device_object;
UNICODE_STRING dev, dos;
RTL_OSVERSIONINFOW osv = {0};

void unload(PDRIVER_OBJECT driver_object) {
    IoDeleteSymbolicLink(&dos);
    IoDeleteDevice(driver_object->DeviceObject);
    DbgPrintEx(0, 0, "[norsefire]: Driver unloaded\n");
}

extern "C" NTSTATUS DriverEntry(PDRIVER_OBJECT driver_object,
                                PUNICODE_STRING registry_path) {
    UNREFERENCED_PARAMETER(registry_path);

    RtlInitUnicodeString(&dev, L"\\Device\\norsefire");
    RtlInitUnicodeString(&dos, L"\\DosDevices\\norsefire");

    IoCreateDevice(driver_object, 0, &dev, FILE_DEVICE_UNKNOWN,
                   FILE_DEVICE_SECURE_OPEN, FALSE, &device_object);
    IoCreateSymbolicLink(&dos, &dev);

    driver_object->MajorFunction[IRP_MJ_CREATE] = dispatch::create_call;
    driver_object->MajorFunction[IRP_MJ_CLOSE] = dispatch::close_call;
    driver_object->MajorFunction[IRP_MJ_DEVICE_CONTROL] = dispatch::handler;
    driver_object->DriverUnload = unload;

    device_object->Flags |= DO_DIRECT_IO;
    device_object->Flags &= ~DO_DEVICE_INITIALIZING;

    osv = {0};
    osv.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOW);
    RtlGetVersion(&osv);

    DbgPrintEx(0, 0, "[norsefire]: Driver loaded\n");
    return STATUS_SUCCESS;
}
```

`src/driver/driver.h`:

```h
#include "wdm.h"

extern RTL_OSVERSIONINFOW osv;
```

`src/driver/memory.cpp`:

```cpp
#include "memory.hpp"

ULONG memory::get_process_id_by_name(PEPROCESS start_process,
                                     const char *process_name) {
    PLIST_ENTRY active_process_links;
    PEPROCESS current_process = start_process;

    do {
        PKPROCESS kproc = (PKPROCESS)current_process;
        PDISPATCHER_HEADER header = (PDISPATCHER_HEADER)kproc;
        LPSTR current_process_name =
            (LPSTR)((PUCHAR)current_process + IMAGE_FILE_NAME);

        if (header->SignalState == 0 &&
            strcmp(current_process_name, process_name) == 0) {
            return (ULONG)PsGetProcessId(current_process);
        }

        active_process_links =
            (PLIST_ENTRY)((PUCHAR)current_process + ACTIVE_PROCESS_LINKS_FLINK);
        current_process = (PEPROCESS)(active_process_links->Flink);
        current_process =
            (PEPROCESS)((PUCHAR)current_process - ACTIVE_PROCESS_LINKS_FLINK);

    } while (start_process != current_process);

    return 0;
}

ULONG memory::get_module_base(PEPROCESS process, wchar_t *module_name) {
    if (!process) {
        return 0;
    }

    __try {
        PPEB32 peb32 = (PPEB32)PsGetProcessWow64Process(process);
        if (!peb32 || !peb32->Ldr) {
            return 0;
        }

        for (PLIST_ENTRY32 plist_entry =
                 (PLIST_ENTRY32)((PPEB_LDR_DATA32)peb32->Ldr)
                     ->InLoadOrderModuleList.Flink;
             plist_entry !=
             &((PPEB_LDR_DATA32)peb32->Ldr)->InLoadOrderModuleList;
             plist_entry = (PLIST_ENTRY32)plist_entry->Flink) {
            PLDR_DATA_TABLE_ENTRY32 pentry = CONTAINING_RECORD(
                plist_entry, LDR_DATA_TABLE_ENTRY32, InLoadOrderLinks);

            if (wcscmp((PWCH)pentry->BaseDllName.Buffer, module_name) == 0) {
                return pentry->DllBase;
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
    }

    return 0;
}

NTSTATUS memory::read_memory(PEPROCESS target_process, void *source,
                             void *target, size_t size) {
    if (!target_process) {
        return STATUS_INVALID_PARAMETER;
    }

    SIZE_T bytes = 0;
    NTSTATUS status =
        MmCopyVirtualMemory(target_process, source, IoGetCurrentProcess(),
                            target, size, KernelMode, &bytes);
    if (!NT_SUCCESS(status) || !bytes) {
        return STATUS_INVALID_ADDRESS;
    }
    return status;
}

NTSTATUS memory::write_memory(PEPROCESS target_process, void *source,
                              void *target, size_t size) {
    if (!target_process) {
        return STATUS_INVALID_PARAMETER;
    }

    SIZE_T bytes = 0;
    NTSTATUS status =
        MmCopyVirtualMemory(IoGetCurrentProcess(), source, target_process,
                            target, size, KernelMode, &bytes);
    if (!NT_SUCCESS(status) || !bytes) {
        return STATUS_INVALID_ADDRESS;
    }
    return status;
}

```

`src/driver/memory.hpp`:

```hpp
#pragma once

#include "mouse.hpp"

namespace memory {
ULONG get_process_id_by_name(PEPROCESS start_process, const char *process_name);

ULONG get_module_base(PEPROCESS process, wchar_t *module_name);

NTSTATUS read_memory(PEPROCESS target_process, void *source, void *target,
                     size_t size);

NTSTATUS write_memory(PEPROCESS target_process, void *source, void *target,
                      size_t size);
} // namespace memory
```

`src/driver/mouse.cpp`:

```cpp
#include "mouse.hpp"
#include "definitions.hpp"
#include "driver.h"
#include "wdm.h"
#include <basetsd.h>
#include <ntdef.h>
#include <ntstatus.h>

NTSTATUS mouse::init_keyboard(PKEYBOARD_OBJECT keyboard_obj) {
    UNICODE_STRING class_string;
    RtlInitUnicodeString(&class_string, L"\\Driver\\KbdClass");

    PDRIVER_OBJECT class_driver_object = NULL;
    NTSTATUS status = ObReferenceObjectByName(
        &class_string, OBJ_CASE_INSENSITIVE, NULL, 0, *IoDriverObjectType,
        KernelMode, NULL, (PVOID *)&class_driver_object);
    if (!NT_SUCCESS(status)) {
        DbgPrintEx(0, 0, "[norsefire]: kbdclass ref error");
        return status;
    }

    if (osv.dwMajorVersion == 10) {
        hid:
        UNICODE_STRING hid_string;
        RtlInitUnicodeString(&hid_string, L"\\Driver\\KbdHID");

        PDRIVER_OBJECT hid_driver_object = NULL;
        status = ObReferenceObjectByName(
            &hid_string, OBJ_CASE_INSENSITIVE, NULL, 0, *IoDriverObjectType,
            KernelMode, NULL, (PVOID *)&hid_driver_object);
        if (!NT_SUCCESS(status)) {
            if (class_driver_object) {
                ObDereferenceObject(class_driver_object);
            }
            DbgPrintEx(0, 0, "[norsefire]: kbdhid ref error");
            return status;
        }

        PVOID class_driver_base = NULL;
        ULONG class_driver_size = 0;

        PDEVICE_OBJECT hid_device_object = hid_driver_object->DeviceObject;
        while (hid_device_object && !keyboard_obj->service_callback) {
            PDEVICE_OBJECT class_device_object =
                class_driver_object->DeviceObject;
            while (class_device_object && !keyboard_obj->service_callback) {
                if (!class_device_object->NextDevice &&
                    !keyboard_obj->kb_device) {
                    keyboard_obj->kb_device = class_device_object;
                }

                PULONG_PTR device_extension =
                    (PULONG_PTR)hid_device_object->DeviceExtension;
                ULONG_PTR device_ext_size =
                    ((ULONG_PTR)hid_device_object->DeviceObjectExtension -
                     (ULONG_PTR)hid_device_object->DeviceExtension) /
                    4;
                class_driver_base = class_driver_object->DriverStart;
                class_driver_size = class_driver_object->DriverSize;
                for (ULONG_PTR i = 0; i < device_ext_size; i++) {
                    if (device_extension[i] == (ULONG_PTR)class_device_object &&
                        device_extension[i + 1] >
                            (ULONG_PTR)class_driver_base &&
                        device_extension[i + 1] <
                            (ULONG_PTR)((PUCHAR)class_driver_base +
                                        class_driver_size)) {
                        keyboard_obj->service_callback =
                            (KeyboardClassServiceCallback)(device_extension[i +
                                                                            1]);
                        break;
                    }
                }
                class_device_object = class_device_object->NextDevice;
            }
            hid_device_object = hid_device_object->AttachedDevice;
        }

        if (!keyboard_obj->kb_device) {
            PDEVICE_OBJECT target_device_object =
                class_driver_object->DeviceObject;
            while (target_device_object) {
                if (!target_device_object->NextDevice) {
                    keyboard_obj->kb_device = target_device_object;
                    break;
                }
                target_device_object = target_device_object->NextDevice;
            }
        }

        ObDereferenceObject(class_driver_object);
        ObDereferenceObject(hid_driver_object);

        if (keyboard_obj->service_callback) {
            DbgPrintEx(0, 0, "[norsefire]: Keyboard initialized\n");
            return STATUS_SUCCESS;
        }
        DbgPrintEx(0, 0, "[norsefire]: Keyboard initialized fail\n");
        return STATUS_UNSUCCESSFUL;
    }

    if (osv.dwMajorVersion == 6) {

        PDRIVER_OBJECT hid_driver_object = NULL;
        UNICODE_STRING hid_string;
        RtlInitUnicodeString(&hid_string, L"\\Driver\\i8042prt");
        auto status = ObReferenceObjectByName(
            &hid_string, OBJ_CASE_INSENSITIVE, NULL, 0, *IoDriverObjectType,
            KernelMode, NULL, (PVOID *)&hid_driver_object);

        if (!NT_SUCCESS(status)) {
            if (class_driver_object) {
                ObDereferenceObject(class_driver_object);
            }
            DbgPrintEx(0, 0, "[norsefire]: i8042prt ref fail\n");
            goto hid;
            return STATUS_UNSUCCESSFUL;
        }

        keyboard_obj->service_callback =
            (KeyboardClassServiceCallback)(((PUCHAR)class_driver_object
                                                ->DriverStart) +
                                           0x2990);
        DbgPrintEx(0, 0, "[norsefire]: keyboard class service callback %p\n",
                   keyboard_obj->service_callback);

        if (!keyboard_obj->kb_device) {
            PDEVICE_OBJECT target_device_object =
                class_driver_object->DeviceObject;
            while (target_device_object) {
                if (!target_device_object->NextDevice) {
                    keyboard_obj->kb_device = target_device_object;
                    break;
                }
                target_device_object = target_device_object->NextDevice;
            }
        }

        ObDereferenceObject(class_driver_object);
        ObDereferenceObject(hid_driver_object);

        if (keyboard_obj->service_callback) {
            DbgPrintEx(0, 0, "[norsefire]: Keyboard initialized\n");
            return STATUS_SUCCESS;
        }

        DbgPrintEx(0, 0, "[norsefire]: Keyboard initialized fail\n");
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS mouse::init_mouse(PMOUSE_OBJECT mouse_obj) {
    UNICODE_STRING class_string;
    RtlInitUnicodeString(&class_string, L"\\Driver\\MouClass");

    PDRIVER_OBJECT class_driver_object = NULL;
    NTSTATUS status = ObReferenceObjectByName(
        &class_string, OBJ_CASE_INSENSITIVE, NULL, 0, *IoDriverObjectType,
        KernelMode, NULL, (PVOID *)&class_driver_object);
    if (!NT_SUCCESS(status)) {
        DbgPrintEx(0, 0, "[norsefire]: mouclass ref error");
        return status;
    }

    UNICODE_STRING hid_string;
    RtlInitUnicodeString(&hid_string, L"\\Driver\\MouHID");

    PDRIVER_OBJECT hid_driver_object = NULL;
    status = ObReferenceObjectByName(&hid_string, OBJ_CASE_INSENSITIVE, NULL, 0,
                                     *IoDriverObjectType, KernelMode, NULL,
                                     (PVOID *)&hid_driver_object);
    if (!NT_SUCCESS(status)) {
        if (class_driver_object) {
            ObDereferenceObject(class_driver_object);
        }
        DbgPrintEx(0, 0, "[norsefire]: mouhid ref error");
        return status;
    }

    PVOID class_driver_base = NULL;
    ULONG class_driver_size = 0;

    PDEVICE_OBJECT hid_device_object = hid_driver_object->DeviceObject;
    while (hid_device_object && !mouse_obj->service_callback) {
        PDEVICE_OBJECT class_device_object = class_driver_object->DeviceObject;
        while (class_device_object && !mouse_obj->service_callback) {
            if (!class_device_object->NextDevice && !mouse_obj->mouse_device) {
                mouse_obj->mouse_device = class_device_object;
            }

            PULONG_PTR device_extension =
                (PULONG_PTR)hid_device_object->DeviceExtension;
            ULONG_PTR device_ext_size =
                ((ULONG_PTR)hid_device_object->DeviceObjectExtension -
                 (ULONG_PTR)hid_device_object->DeviceExtension) /
                4;
            class_driver_base = class_driver_object->DriverStart;
            class_driver_size = class_driver_object->DriverSize;
            for (ULONG_PTR i = 0; i < device_ext_size; i++) {
                if (device_extension[i] == (ULONG_PTR)class_device_object &&
                    device_extension[i + 1] > (ULONG_PTR)class_driver_base &&
                    device_extension[i + 1] <
                        (ULONG_PTR)((ULONG_PTR)class_driver_base +
                                    class_driver_size)) {
                    mouse_obj->service_callback =
                        (MouseClassServiceCallback)(device_extension[i + 1]);
                    DbgPrintEx(0, 0,
                               "[norsefire]: Mouse class service callback %p\n",
                               device_extension[i + 1]);
                    break;
                }
            }
            class_device_object = class_device_object->NextDevice;
        }
        hid_device_object = hid_device_object->AttachedDevice;
    }

    if (!mouse_obj->mouse_device) {
        PDEVICE_OBJECT target_device_object = class_driver_object->DeviceObject;
        while (target_device_object) {
            if (!target_device_object->NextDevice) {
                mouse_obj->mouse_device = target_device_object;
                break;
            }
            target_device_object = target_device_object->NextDevice;
        }
    }

    ObDereferenceObject(class_driver_object);
    ObDereferenceObject(hid_driver_object);

    if (mouse_obj->service_callback) {
        DbgPrintEx(0, 0, "[norsefire]: Mouse initialized\n");
        return STATUS_SUCCESS;
    }
    DbgPrintEx(0, 0, "[norsefire]: Mouse initialized fail\n");
    return STATUS_UNSUCCESSFUL;
}

void mouse::keyboard_event(KEYBOARD_OBJECT kb_obj, PNF_KEYBOARD_REQUEST kr) {
    ULONG input_data;
    KIRQL irql;
    KEYBOARD_INPUT_DATA mid = {0};

    mid.ExtraInformation = kr->ExtraInformation;
    mid.Flags = kr->Flags;
    mid.MakeCode = kr->MakeCode;
    mid.Reserved = kr->Reserved;
    mid.UnitId = kr->UnitId;

    KeRaiseIrql(DISPATCH_LEVEL, &irql);
    kb_obj.service_callback(kb_obj.kb_device, &mid,
                            (PKEYBOARD_INPUT_DATA)&mid + 1, &input_data);
    KeLowerIrql(irql);
}

void mouse::mouse_event(MOUSE_OBJECT mouse_obj, long x, long y,
                        unsigned short button_flags, USHORT flags) {
    ULONG input_data;
    KIRQL irql;
    MOUSE_INPUT_DATA mid = {0};

    mid.LastX = x;
    mid.LastY = y;
    mid.Flags = flags | MOUSE_VIRTUAL_DESKTOP | MOUSE_MOVE_ABSOLUTE;
    mid.ButtonFlags = button_flags;

    KeRaiseIrql(DISPATCH_LEVEL, &irql);
    mouse_obj.service_callback(mouse_obj.mouse_device, &mid,
                               (PMOUSE_INPUT_DATA)&mid + 1, &input_data);
    KeLowerIrql(irql);
}

```

`src/driver/mouse.hpp`:

```hpp
#pragma once

#include "definitions.hpp"

extern "C" POBJECT_TYPE *IoDriverObjectType;

typedef VOID (*MouseClassServiceCallback)(PDEVICE_OBJECT DeviceObject,
                                          PMOUSE_INPUT_DATA InputDataStart,
                                          PMOUSE_INPUT_DATA InputDataEnd,
                                          PULONG InputDataConsumed);

typedef VOID (*KeyboardClassServiceCallback)(
    PDEVICE_OBJECT DeviceObject, PKEYBOARD_INPUT_DATA InputDataStart,
    PKEYBOARD_INPUT_DATA InputDataEnd, PULONG InputDataConsumed);

typedef struct _MOUSE_OBJECT {
    PDEVICE_OBJECT mouse_device;
    MouseClassServiceCallback service_callback;
} MOUSE_OBJECT, *PMOUSE_OBJECT;

typedef struct _KB_OBJECT {
    PDEVICE_OBJECT kb_device;
    KeyboardClassServiceCallback service_callback;
} KEYBOARD_OBJECT, *PKEYBOARD_OBJECT;

namespace mouse {
NTSTATUS init_mouse(PMOUSE_OBJECT mouse_obj);
NTSTATUS init_keyboard(PKEYBOARD_OBJECT kb_obj);

void keyboard_event(KEYBOARD_OBJECT kb_obj, PNF_KEYBOARD_REQUEST kr);
void mouse_event(MOUSE_OBJECT mouse_obj, long x, long y,
                 unsigned short button_flags, USHORT flags);
} // namespace mouse
```

`src/driver/ntapi.hpp`:

```hpp
#pragma once

#include "ntstructs.hpp"

extern "C" NTKERNELAPI PVOID NTAPI
PsGetProcessWow64Process(_In_ PEPROCESS Process);

extern "C" NTKERNELAPI NTSTATUS NTAPI MmCopyVirtualMemory(
    _In_ PEPROCESS FromProcess, _In_ PVOID FromAddress,
    _In_ PEPROCESS ToProcess, _Out_ PVOID ToAddress, _In_ SIZE_T BufferSize,
    _In_ KPROCESSOR_MODE PreviousMode, _Out_ PSIZE_T NumberOfBytesCopied);

extern "C" NTSYSAPI NTSTATUS NTAPI ObReferenceObjectByName(
    _In_ PUNICODE_STRING ObjectName, _In_ ULONG Attributes,
    _In_opt_ PACCESS_STATE AccessState, _In_opt_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_TYPE ObjectType, _In_ KPROCESSOR_MODE AccessMode,
    _Inout_opt_ PVOID ParseContext, _Out_ PVOID *Object);
```

`src/driver/ntstructs.hpp`:

```hpp
#pragma once

#include <ntdef.h>
#include <guiddef.h>
#include <ntddmou.h>
#include <ntddkbd.h>
#include <ntifs.h>


typedef struct _PEB_LDR_DATA32 {
    ULONG Length;
    UCHAR Initialized;
    ULONG SsHandle;
    LIST_ENTRY32 InLoadOrderModuleList;
    LIST_ENTRY32 InMemoryOrderModuleList;
    LIST_ENTRY32 InInitializationOrderModuleList;
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

typedef struct _LDR_DATA_TABLE_ENTRY32 {
    LIST_ENTRY32 InLoadOrderLinks;
    LIST_ENTRY32 InMemoryOrderLinks;
    LIST_ENTRY32 InInitializationOrderLinks;
    ULONG DllBase;
    ULONG EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING32 FullDllName;
    UNICODE_STRING32 BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    LIST_ENTRY32 HashLinks;
    ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;

typedef struct _PEB32 {
    UCHAR InheritedAddressSpace;
    UCHAR ReadImageFileExecOptions;
    UCHAR BeingDebugged;
    UCHAR BitField;
    ULONG Mutant;
    ULONG ImageBaseAddress;
    ULONG Ldr;
    ULONG ProcessParameters;
    ULONG SubSystemData;
    ULONG ProcessHeap;
    ULONG FastPebLock;
    ULONG AtlThunkSListPtr;
    ULONG IFEOKey;
    ULONG CrossProcessFlags;
    ULONG UserSharedInfoPtr;
    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    ULONG ApiSetMap;
} PEB32, *PPEB32;
```

`src/driver_control.cpp`:

```cpp
#include "driver_control.hpp"
#include <exception>

driver_control::driver_control(const char *path) {
    this->driver_handle =
        CreateFileA(path, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);
}

bool driver_control::ready() { return driver_handle != 0; }

driver_control::~driver_control() { CloseHandle(this->driver_handle); }

ULONG driver_control::get_process_id_by_name(const char *process_name,
                                             size_t process_name_size) {
    if (this->driver_handle) {
        ULONG bytes;
        NF_PROCESS_ID_REQUEST process_id_request = {0};
        memcpy(process_id_request.process_name, process_name,
               process_name_size);
        if (DeviceIoControl(driver_handle, NF_GET_PROCESS_ID,
                            &process_id_request, sizeof(process_id_request),
                            &process_id_request, sizeof(process_id_request),
                            &bytes, 0)) {
            return process_id_request.process_id;
        } else {
            return 0;
        }
    }
    return 0;
}

ULONG driver_control::get_module_base(ULONG process_id,
                                      const wchar_t *module_name,
                                      size_t module_name_size) {
    if (this->driver_handle) {
        ULONG bytes;
        NF_MODULE_REQUEST module_request = {0};
        module_request.process_id = process_id;
        memcpy(module_request.module_name, module_name, module_name_size);
        if (DeviceIoControl(driver_handle, NF_GET_MODULE, &module_request,
                            sizeof(module_request), &module_request,
                            sizeof(module_request), &bytes, 0)) {
            return module_request.address;
        } else {
            return 0;
        }
    }
    return 0;
}

void driver_control::keyboard_event(USHORT unitId, USHORT makecode,
                                    USHORT flags, USHORT reserved,
                                    ULONG extraInformation) {
    if (this->driver_handle) {
        ULONG bytes;
        NF_KEYBOARD_REQUEST kb_request = {0};
        kb_request.ExtraInformation = extraInformation;
        kb_request.Flags = flags;
        kb_request.MakeCode = makecode;
        kb_request.Reserved = reserved;
        kb_request.UnitId = unitId;
        DeviceIoControl(driver_handle, NF_KB_EVENT, &kb_request,
                        sizeof(kb_request), &kb_request, sizeof(kb_request),
                        &bytes, 0);
    }
}

void driver_control::mouse_event(long x, long y, unsigned short button_flags,
                                 unsigned short flags) {
    if (this->driver_handle) {
        ULONG bytes;
        NF_MOUSE_REQUEST mouse_request = {0};
        mouse_request.x = x;
        mouse_request.y = y;
        mouse_request.flags = flags;
        mouse_request.button_flags = button_flags;
        DeviceIoControl(driver_handle, NF_MOUSE_EVENT, &mouse_request,
                        sizeof(mouse_request), &mouse_request,
                        sizeof(mouse_request), &bytes, 0);
    }
}

```

`src/driver_control.hpp`:

```hpp
#pragma once

#include "definitions.hpp"

class driver_control {
  private:
    HANDLE driver_handle = 0;

  public:
    driver_control(const char *path);

    ~driver_control();
    bool ready();

    ULONG get_process_id_by_name(const char *process_name,
                                 size_t process_name_size);

    ULONG get_module_base(ULONG process_id, const wchar_t *module_name,
                          size_t module_name_size);

    template <typename t> t read_memory(ULONG process_id, ULONG address);

    template <typename t>
    void write_memory(ULONG process_id, ULONG address, t buffer);

    void mouse_event(long x, long y, unsigned short button_flags,
                     unsigned short flags);
    void keyboard_event(USHORT unitId, USHORT makecode, USHORT flags,
                        USHORT reserved, ULONG extraInformation);
};

template <typename t>
inline t driver_control::read_memory(ULONG process_id, ULONG address) {
    if (this->driver_handle) {
        ULONG bytes;
        NF_READ_REQUEST read_request = {0};
        read_request.process_id = process_id;
        read_request.address = address;
        read_request.size = sizeof(t);
        if (DeviceIoControl(driver_handle, NF_READ_MEMORY, &read_request,
                            sizeof(read_request), &read_request,
                            sizeof(read_request), &bytes, 0)) {
            return *(t *)&read_request.buffer;
        } else {
            return 0;
        }
    }
    return 0;
}

template <typename t>
inline void driver_control::write_memory(ULONG process_id, ULONG address,
                                         t buffer) {
    if (this->driver_handle) {
        ULONG bytes;
        NF_WRITE_REQUEST write_request = {0};
        write_request.process_id = process_id;
        write_request.address = address;
        write_request.buffer = buffer;
        write_request.size = sizeof(t);
        DeviceIoControl(driver_handle, NF_WRITE_MEMORY, &write_request,
                        sizeof(write_request), &write_request,
                        sizeof(write_request), &bytes, 0);
    }
}

```

`src/main.cpp`:

```cpp
#include "app.hpp"
#include <exception>
#include <stdexcept>

App *App::_app = nullptr;

int main(int argc, char **argv) {
    try {
        App app(argc, argv);
        return app.run();
    } catch (const std::exception &err) {
        logd("Exception %s", err.what());
        return -1;
    }
}
```

`src/utils/logger.hpp`:

```hpp
#pragma once

#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <string>

class Logger {};

inline void logd(std::string format, ...) {
    format += '\n';
    va_list va;
    va_start(va, format);
    vprintf(format.c_str(), va);
    va_end(va);
}
```

`src/utils/timecalc.hpp`:

```hpp
#pragma once

#include <chrono>
#include <stdio.h>
#include <string>

class TimeCalc {

  public:
    TimeCalc(const char *tag) {
        this->tag = tag;
        begin = clock.now().time_since_epoch().count();
    }
    ~TimeCalc() {
        if (mfinish) {
            return;
        }
        end = clock.now().time_since_epoch().count();
        printf("%s %lldms", tag, (end - begin) / 1000000);
    }

    std::string finish() {
        mfinish = true;
        end = clock.now().time_since_epoch().count();
        char buff[200];
        sprintf(buff, "%s %lldms", tag, (end - begin) / 1000000);
        return buff;
    }

  private:
    std::chrono::high_resolution_clock clock;
    const char *tag;
    long long begin;
    long long end;
    bool mfinish = false;
};
```

`src/windows/screen.hpp`:

```hpp
#pragma once
#include "Windows.h"
#include "base/screen.h"
#include "opencv2/core/mat.hpp"
#include "opencv2/opencv.hpp"
#include "utils/logger.hpp"
#include <exception>
#include <optional>
#include <stdio.h>

class ScreenImpl : public Screen {

  private:
    int screenx;
    int screeny;
    int screenWidth;
    int screenHeight;
    HWND deskH;
    HDC desktopDC;

  public:
    void set_screenHeight(int v) { screenHeight = v; }
    void set_screenWidth(int v) { screenWidth = v; }
    int get_screenHeight() { return screenHeight; }
    int get_screenWidth() { return screenWidth; }

    ScreenImpl(int x, int y) {
        screenx = 0;
        screeny = 0;
        screenHeight = y;
        screenWidth = x;

        deskH = ::GetDesktopWindow();
        desktopDC = ::GetDC(deskH);
    }

    ScreenImpl() {
        screenx = GetSystemMetrics(SM_YVIRTUALSCREEN);
        screeny = GetSystemMetrics(SM_XVIRTUALSCREEN);

        screenWidth = GetSystemMetrics(SM_CXSCREEN);
        screenHeight = GetSystemMetrics(SM_CYSCREEN);

        printf("screenx %d\n", screenx);
        printf("screeny %d\n", screeny);

        printf("screenWidth %d\n", screenWidth);
        printf("screenHeight %d\n", screenHeight);

        deskH = ::GetDesktopWindow();
        desktopDC = ::GetDC(deskH);

        RECT rect;
        ::GetWindowRect(deskH, &rect);
        screenHeight = rect.bottom - rect.top;
        screenWidth = rect.right - rect.left;
        printf("screenWidth %d\n", screenWidth);
        printf("screenHeight %d\n", screenHeight);
    }

    ~ScreenImpl() { ReleaseDC(deskH, desktopDC); }

    std::optional<cv::Mat> fetch() {

        cv::Mat mat;

        HDC memDC;
        HBITMAP desktopBitmap;
        BITMAP bmpScreen;

        try {
            memDC = ::CreateCompatibleDC(desktopDC);
            if (!memDC) {
                printf("create cdc error");
                return std::nullopt;
            }
            SetStretchBltMode(memDC, COLORONCOLOR);

            desktopBitmap = ::CreateCompatibleBitmap(
                desktopDC, this->screenWidth, this->screenHeight);
            if (!desktopBitmap) {
                printf("create compatibl bitmap error");
                return std::nullopt;
            }
            mat.create(screenHeight, screenWidth, CV_8UC3);
            // printf("mat x%d\n", mat.cols);
            // printf("mat y%d\n", mat.rows);

            SelectObject(memDC, desktopBitmap);
            StretchBlt(memDC, 0, 0, screenWidth, screenHeight, desktopDC, 0, 0,
                       screenWidth, screenHeight, SRCCOPY);

            GetObject(desktopBitmap, sizeof(BITMAP), &bmpScreen);
            // printf("x %ld\n", bmpScreen.bmWidth);
            // printf("y %ld\n", bmpScreen.bmHeight);

            BITMAPINFOHEADER bi;
            memset(&bi, 0, sizeof(BITMAPINFOHEADER));
            bi.biSize = sizeof(BITMAPINFOHEADER);
            bi.biWidth = bmpScreen.bmWidth;
            bi.biHeight = -bmpScreen.bmHeight;
            bi.biPlanes = 1;
            bi.biBitCount = 24;
            bi.biCompression = BI_RGB;
            bi.biSizeImage = 0;
            bi.biXPelsPerMeter = 0;
            bi.biYPelsPerMeter = 0;
            bi.biClrUsed = 0;
            bi.biClrImportant = 0;

            ::GetDIBits(memDC, desktopBitmap, 0, (UINT)bmpScreen.bmHeight,
                        mat.data, (BITMAPINFO *)&bi, DIB_RGB_COLORS);

        } catch (...) {
            logd("unknow exception");
            std::terminate();
        }

        DeleteObject(desktopBitmap);
        DeleteDC(memDC);

        return mat;
    }
};
```