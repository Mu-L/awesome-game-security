Project Path: arc_gmh5225_AntiDebug-AntiVM_g2pnaw84

Source Tree:

```txt
arc_gmh5225_AntiDebug-AntiVM_g2pnaw84
├── AntiDebug
│   ├── AntiDebug.cpp
│   ├── AntiDebug.h
│   ├── InvalidHandle.cpp
│   ├── InvalidHandle.h
│   ├── PEB.cpp
│   ├── PEB.h
│   ├── RunningProcesses.cpp
│   ├── RunningProcesses.h
│   ├── Timing.cpp
│   └── Timing.h
├── AntiDebug.vcxproj
├── AntiDebug.vcxproj.filters
├── AntiDebug.vcxproj.user
├── AntiVM
│   ├── AntiVM.cpp
│   ├── AntiVM.h
│   ├── DLLCheck.cpp
│   ├── DLLCheck.h
│   ├── Devices.cpp
│   ├── Devices.h
│   ├── Drivers.cpp
│   ├── Drivers.h
│   ├── Power.cpp
│   ├── Power.h
│   ├── Provider.cpp
│   ├── Provider.h
│   ├── Screen.cpp
│   ├── Screen.h
│   ├── TimeCheck.cpp
│   └── TimeCheck.h
├── README.md
└── Source.cpp

```

`AntiDebug.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{20b2e5f9-e73e-4d88-8f0f-f2f12d86d48b}</ProjectGuid>
    <RootNamespace>AntiDebug</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="AntiDebug\AntiDebug.cpp" />
    <ClCompile Include="AntiVM\Power.cpp" />
    <ClCompile Include="AntiVM\TimeCheck.cpp" />
    <ClCompile Include="AntiDebug\Timing.cpp" />
    <ClCompile Include="AntiVM\Devices.cpp" />
    <ClCompile Include="AntiVM\DLLCheck.cpp" />
    <ClCompile Include="AntiVM\Drivers.cpp" />
    <ClCompile Include="AntiDebug\InvalidHandle.cpp" />
    <ClCompile Include="AntiDebug\PEB.cpp" />
    <ClCompile Include="AntiVM\Provider.cpp" />
    <ClCompile Include="AntiDebug\RunningProcesses.cpp" />
    <ClCompile Include="AntiVM\AntiVM.cpp" />
    <ClCompile Include="AntiVM\Screen.cpp" />
    <ClCompile Include="Source.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="AntiDebug\AntiDebug.h" />
    <ClInclude Include="AntiVM\Power.h" />
    <ClInclude Include="AntiVM\TimeCheck.h" />
    <ClInclude Include="AntiDebug\Timing.h" />
    <ClInclude Include="AntiVM\Devices.h" />
    <ClInclude Include="AntiVM\DLLCheck.h" />
    <ClInclude Include="AntiVM\Drivers.h" />
    <ClInclude Include="AntiDebug\InvalidHandle.h" />
    <ClInclude Include="AntiDebug\PEB.h" />
    <ClInclude Include="AntiVM\Provider.h" />
    <ClInclude Include="AntiDebug\RunningProcesses.h" />
    <ClInclude Include="AntiVM\AntiVM.h" />
    <ClInclude Include="AntiVM\Screen.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`AntiDebug.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AntiDebug\PEB.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AntiDebug\AntiDebug.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AntiDebug\RunningProcesses.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AntiVM\Drivers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AntiVM\Provider.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AntiDebug\InvalidHandle.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AntiVM\AntiVM.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AntiVM\Screen.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AntiDebug\Timing.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AntiVM\DLLCheck.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AntiVM\Devices.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AntiVM\TimeCheck.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AntiVM\Power.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="AntiDebug\AntiDebug.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AntiDebug\PEB.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AntiDebug\RunningProcesses.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AntiVM\Drivers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AntiVM\Provider.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AntiDebug\InvalidHandle.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AntiVM\AntiVM.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AntiVM\Screen.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AntiDebug\Timing.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AntiVM\DLLCheck.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AntiVM\Devices.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AntiVM\TimeCheck.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AntiVM\Power.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`AntiDebug.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`AntiDebug/AntiDebug.cpp`:

```cpp
#include <iostream>
#include <Windows.h>

#include "AntiDebug.h"

void AntiDebug() noexcept
{
	printf("|---------ANTI DEBUG---------|\n\n");

	if (IsDebuggerPresent())
		printf("[DBG] Caught by IsDebuggerPresent!\n");

	if (CheckPEB())
		printf("[DBG] Caught by PEB check!\n");

	if (CheckRunningProcesses())
		printf("[DBG] Caught by illgal processes running!\n");

	if (CloseInvalidHandle())
		printf("[DBG] Caught by closing invalid handle!\n");

	if (CheckTime())
		printf("[DBG] Caught by invalid timings!\n");
}
```

`AntiDebug/AntiDebug.h`:

```h
#pragma once
#include "PEB.h"
#include "RunningProcesses.h"
#include "InvalidHandle.h"
#include "Timing.h"

void AntiDebug() noexcept;
```

`AntiDebug/InvalidHandle.cpp`:

```cpp
#include <windows.h>
#include "InvalidHandle.h"

bool CloseInvalidHandle() noexcept
{
	HANDLE h = (HANDLE)0xDEADBEEF;

	__try {
		CloseHandle(h);
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {
		return true;
	}

	return false;
}
```

`AntiDebug/InvalidHandle.h`:

```h
#pragma once

bool CloseInvalidHandle() noexcept;
```

`AntiDebug/PEB.cpp`:

```cpp
#include <iostream>
#include <windows.h>
#include <winternl.h>

#include "PEB.h"

typedef struct _S_PEB
{
    BYTE pad1[2];
    BOOLEAN BeingDebugged;
    BYTE pad2[17];
    PPEB_LDR_DATA Ldr;
	BYTE pad3[156];
    ULONG NtGlobalFlag;
} S_PEB, * PS_PEB;

using f_NtQueryInformationProcess = NTSTATUS(__stdcall*)(
	_In_ HANDLE,
	_In_  unsigned int,
	_Out_ PVOID,
	_In_ ULONG,
	_Out_ PULONG
	);


bool CheckPEB() noexcept
{
	PROCESS_BASIC_INFORMATION ProcInfo = { 0 };
	ULONG length = 0;

	f_NtQueryInformationProcess NtQueryInformationProcess = (f_NtQueryInformationProcess)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtQueryInformationProcess");

	if (NtQueryInformationProcess == NULL)
		return false;

    if (NT_SUCCESS(NtQueryInformationProcess(GetCurrentProcess(), ProcessBasicInformation, &ProcInfo, sizeof(ProcInfo), &length)))
    {
        PS_PEB Peb = NULL;

        if (Peb = (PS_PEB)ProcInfo.PebBaseAddress; Peb == NULL)
            return false;

        //Peb->CloudFileFlags could potentially indicate VM if zero??
        //Peb->PlaceholderCompatibilityMode could indicate VM if empty?? 

		if (Peb->BeingDebugged)
			return true;

        if (Peb->NtGlobalFlag != 0) //0x70 when debugger is attached it seems
            return true;
	}

	return false;
}
```

`AntiDebug/PEB.h`:

```h
#pragma once

bool CheckPEB() noexcept;
```

`AntiDebug/RunningProcesses.cpp`:

```cpp
#include <string>
#include <windows.h>
#include <tlhelp32.h>
#include <vector>

#include "RunningProcesses.h"

std::vector<std::string> IllegalPrograms = {
	"ida",
	"x32dbg",
	"x64dbg",
	"ida64",
	"x86_64-SSE4-AVX2",
	"wireshark",
	"processhacker",
	"netstat",
	"netmon",
	"tcpview",
	"filemon",
	"regmon",
	"cain"
};

bool CheckRunningProcesses() noexcept
{
	HANDLE ProcSnap = NULL;

	if (ProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); ProcSnap == INVALID_HANDLE_VALUE)
		return false;

	PROCESSENTRY32 currProc32;

	currProc32.dwSize = sizeof(PROCESSENTRY32);

	if (!Process32First(ProcSnap, &currProc32))
		return false;

	while (Process32Next(ProcSnap, &currProc32))
		for (auto x : IllegalPrograms)
			if (strcmp((char*)currProc32.szExeFile, (x + ".exe").c_str()) == 0)
				return true;

	CloseHandle(ProcSnap);
	return false;
}
```

`AntiDebug/RunningProcesses.h`:

```h
#pragma once

bool CheckRunningProcesses() noexcept;
```

`AntiDebug/Timing.cpp`:

```cpp
#include <Windows.h>
#include <winternl.h>
#include <iostream>

#include "Timing.h"

using f_NtDelayExecution = NTSTATUS(__stdcall*) (
	IN BOOLEAN				Alertable,
	IN PLARGE_INTEGER       DelayInterval
	);


bool CheckTime() noexcept
{
	f_NtDelayExecution NtDelayExecution = (f_NtDelayExecution)(GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtDelayExecution"));
	if (NtDelayExecution == NULL)
		return false;

	DWORD before = GetTickCount64();
	LARGE_INTEGER time;
	time.QuadPart = -100000000;

	NtDelayExecution(false, &time);

	DWORD after = GetTickCount64();

	if (after - before < 10)
		return true;

	return false;
}
```

`AntiDebug/Timing.h`:

```h
#pragma once

bool CheckTime() noexcept;
```

`AntiVM/AntiVM.cpp`:

```cpp
#include "AntiVM.h"
#include <iostream>

void AntiVM() noexcept
{
	LPNETRESOURCEA lpnr = NULL;

	printf("|-----------ANTI VM----------|\n\n");

	if (CheckDevices())
		printf("[VM] Caught by illegal Device Vendor IDs!\n");

	if (DriverCheck())
		printf("[VM] Caught by illegal drivers!\n");

	if (CheckScreenSize())
		printf("[VM] Caught by odd screen size!\n");

	if (ProviderCheck(lpnr))
		printf("[VM] Caught by illegal provider!\n");

	if (CheckDlls())
		printf("[VM] Caught by illegal DLL's!\n");

	// NOTE:
	// This CAN be an indicator of a virtual environment since
	// the person setting up the VM might not care to configure
	// touch input. Some users might have this off by choice though
	// so one should not rely very heavily on this detection method.
	if (GetSystemMetrics(SM_MAXIMUMTOUCHES) == 0)
		printf("[VM] Potential VM detected (Touches)!\n");

	// NOTE:
	// This is NOT very accurate but can indicate usage of VM.
	// I would argue it's worth checking but nothing to rely on ...
	// ... needs more testing :>)
	if (TimeCheck())
		printf("[VM] Potential VM detected (Time Check)!\n");

	if (PowerCheck())
		printf("[VM] Potential VM detected (Power Check)!\n");
}
```

`AntiVM/AntiVM.h`:

```h
#pragma once
#include "Devices.h"
#include "DLLCheck.h"
#include "Drivers.h"
#include "Power.h"
#include "Provider.h"
#include "Screen.h"
#include "TimeCheck.h"

void AntiVM() noexcept;
```

`AntiVM/DLLCheck.cpp`:

```cpp
#include <vector>
#include <string>
#include <filesystem>
#include <iostream>

#include "DLLCheck.h"

std::vector<std::string> IllegalDlls = {
	"SbieDll",
	"SxIn",
	"Sd2",
	"snxhk",
	"cmdvrt32",
	"VBoxDispD3D",
	"VBoxGL",
	"VBoxHook",
	"VBoxICD",
	"VBoxMRXNP",
	"VBoxNine",
	"VBoxSVGA",
	"VBoxTray"
};

bool CheckDlls() noexcept
{
	std::string path = "C:\\Windows\\System32\\";

	for (auto& x : std::filesystem::directory_iterator(path))
	{
		if (!x.exists() || x.is_directory())
			continue;

		for (auto& y : IllegalDlls)
		{
			if (y == x.path().string().substr(path.length()))
				return true;
		}
	}

	return false;
}
```

`AntiVM/DLLCheck.h`:

```h
#pragma once

bool CheckDlls() noexcept;
```

`AntiVM/Devices.cpp`:

```cpp
#include <windows.h>
#include <winuser.h>
#include <iostream>
#include <vector>

#include "Devices.h"

std::vector<std::wstring> IllegalVendors = {
	L"VID_80EE", //VirtualBox
	L"PNP0F03"  //Unitek UPS Systems Alpha 1200Sx
};

bool CheckDevices() noexcept
{
	UINT devices = 0;
	PRAWINPUTDEVICELIST deviceList = NULL;

	while (true)
	{
		if (GetRawInputDeviceList(NULL, &devices, sizeof(RAWINPUTDEVICELIST)) != 0)
			break;

		if (devices == 0)
			break;

		deviceList = (RAWINPUTDEVICELIST*)malloc(sizeof(RAWINPUTDEVICELIST) * devices);

		if (deviceList == NULL)
			break;

		devices = GetRawInputDeviceList(deviceList, &devices, sizeof(RAWINPUTDEVICELIST));
		if (devices == (UINT)-1)
		{
			free(deviceList);
			continue;
		}
		break;
	}

	if (deviceList == NULL)
		goto END;

	for(int i = 0; i < devices; i ++)
	{
		UINT numChars = 0u;
		GetRawInputDeviceInfoW(deviceList[i].hDevice, RIDI_DEVICENAME, nullptr, &numChars);
		
		std::wstring test(numChars, 0);
		GetRawInputDeviceInfoW(deviceList[i].hDevice, RIDI_DEVICENAME, test.data(), &numChars);
		
		for (auto x : IllegalVendors)
		{
			if (test.find(x) != std::wstring::npos)
			{
				free(deviceList);
				return true;
			}
		}
	}

	END:
	free(deviceList);
	return false;
}
```

`AntiVM/Devices.h`:

```h
#pragma once

bool CheckDevices() noexcept;
```

`AntiVM/Drivers.cpp`:

```cpp
#include <windows.h>
#include <psapi.h>
#include <vector>
#include <string>

#include "Drivers.h"

std::vector<std::string> IllegalDrivers = {
	"VBoxSF",
	"VBoxGuest",
	"VBoxMouse",
	"VBoxWddm"
};

bool DriverCheck() noexcept
{
	LPVOID drivers[1024];
	DWORD cb;

	if (EnumDeviceDrivers(drivers, sizeof(drivers), &cb) && cb < sizeof(drivers))
	{
		int count = cb / sizeof(drivers[0]);
		TCHAR buffer[1024];

		for (auto& i : drivers)
		{
			if (GetDeviceDriverBaseName(i, buffer, sizeof(buffer)))
				for (auto x : IllegalDrivers)
					if ((char*)buffer == x + ".sys")
						return true;
		}
	}

	return false;
}
```

`AntiVM/Drivers.h`:

```h
#pragma once

bool DriverCheck() noexcept;
```

`AntiVM/Power.cpp`:

```cpp
#include <windows.h>
#include <winternl.h>
#include <iostream>

#include "Power.h"

using f_NtPowerInformation = NTSTATUS(__stdcall*)(
	_In_    POWER_INFORMATION_LEVEL InformationLevel,
	_In_	PVOID                   InputBuffer OPTIONAL,
	_In_    ULONG                   InputBufferLength,
	_Out_	PVOID                   OutputBuffer OPTIONAL,
	_In_	ULONG                   OutputBufferLength
	);

bool PowerCheck() noexcept
{
	
	f_NtPowerInformation NtPowerInformation = (f_NtPowerInformation)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtPowerInformation");
	if (NtPowerInformation == NULL)
		return false;
	
	SYSTEM_POWER_CAPABILITIES state = {};

	if(!NT_SUCCESS(NtPowerInformation(SystemPowerCapabilities, NULL, 0, &state, sizeof(SYSTEM_POWER_CAPABILITIES))))
		return false;

	// NOTE:
	// Hybrid Sleep State (FastSystemS4) is on by default ON desktop whilst OFF by default on laptops
	// ... however, my VM's seem to have it OFF by default. Can check and compare with if 
	// SystemBatteriesPresent is TRUE and LidPresent

	bool isLaptop = false;
	if (state.SystemBatteriesPresent || state.LidPresent)
		isLaptop = true;

	if ((isLaptop && state.FastSystemS4) || (!isLaptop && !state.FastSystemS4))
		return true;


	// NOTE:
	// *MAYBE* if all but SystemS1 and SystemS1 are true then probably real, if all false then VM. (Not counting 5)
	if (!state.SystemS1 && !state.SystemS2 && !!state.SystemS3 && !state.SystemS4 && state.SystemS5)
		return true;

	// NOTE:
	// If HiberState or HiberFilePresent is false might be VM.
	if (!state.Hiberboot || !state.HiberFilePresent)
		return true;

	// NOTE:
	// If RtcWake is 5 it seems to be legit system, if 0 maybe virtual environment...
	if (state.RtcWake == 0)
		return true;

	return false;
}
```

`AntiVM/Power.h`:

```h
#pragma once

bool PowerCheck() noexcept;
```

`AntiVM/Provider.cpp`:

```cpp
#include "Provider.h"

std::vector<std::string> IllegalProviders = {
	"VirtualBox Shared Folders"
};

bool ProviderCheck(LPNETRESOURCEA lpnr) noexcept
{
	DWORD result, localResult, entries = -1, buffer = 16384;
	HANDLE resourceHandle;
	LPNETRESOURCEA lpnrLocal;


	result = WNetOpenEnumA(RESOURCE_GLOBALNET, RESOURCETYPE_ANY, 0, lpnr, &resourceHandle);

	if (result != NO_ERROR)
		return false;


	lpnrLocal = (LPNETRESOURCEA)GlobalAlloc(GPTR, buffer);

	if (lpnrLocal == NULL)
		return false;

	do {
		ZeroMemory(lpnrLocal, buffer);

		localResult = WNetEnumResourceA(resourceHandle, &entries, lpnrLocal, &buffer);

		if (localResult == NO_ERROR)
		{
			for (DWORD i = 0; i < entries; i++)
			{
				for (auto x : IllegalProviders)
				{
					if (x == lpnrLocal[i].lpProvider)
						return true;
				}

				if (RESOURCEUSAGE_CONTAINER == (lpnrLocal[i].dwUsage & RESOURCEUSAGE_CONTAINER) && entries > 0)
				{
					ProviderCheck(&lpnrLocal[i]);
				}
			}
		}
		else if (localResult != ERROR_NO_MORE_ITEMS)
			break;

	} while (localResult != ERROR_NO_MORE_ITEMS);

	GlobalFree((HGLOBAL)lpnrLocal);
	WNetCloseEnum(resourceHandle);

	return false;
}
```

`AntiVM/Provider.h`:

```h
#pragma once
#include <windows.h>
#include <winnetwk.h>
#include <vector>
#include <string>

bool ProviderCheck(LPNETRESOURCEA lpnr) noexcept;
```

`AntiVM/Screen.cpp`:

```cpp
#include <windows.h>
#include <vector>

#include "Screen.h"

std::vector<int> CommonHeights = {
	1080,
	768,
	900,
	864,
	768
};

std::vector<int> CommonWidths = {
	1920,
	1366,
	1440,
	1536,
	1024
};

bool CheckScreenSize() noexcept
{
	if (GetSystemMetrics(SM_CMONITORS) != 1)
		return false;

	bool found = false;

	int h = GetSystemMetrics(SM_CYVIRTUALSCREEN),
		w = GetSystemMetrics(SM_CXVIRTUALSCREEN);

	for (auto i : CommonHeights)
	{
		if (i == h)
		{
			for (auto j : CommonWidths)
			{
				if (j == w)
				{
					found = true;
					break;
				}
			}
			break;
		}
	}
	
	return !found;
}
```

`AntiVM/Screen.h`:

```h
#pragma once

bool CheckScreenSize() noexcept;
```

`AntiVM/TimeCheck.cpp`:

```cpp
#include <windows.h>
#include <winternl.h>
#include <iostream>

#include "TimeCheck.h"

using f_NtQuerySystemInformation = NTSTATUS(__stdcall*)(
	_In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
	_Out_ PVOID	SystemInformation,
	_In_ ULONG SystemInformationLength,
	_Out_ PULONG ReturnLength OPTIONAL
	);

bool TimeCheck() noexcept
{
    bool detected = false;
    BYTE* outputBuffer = NULL;
    ULONG length = 0;

	f_NtQuerySystemInformation NtQuerySystemInformation = (f_NtQuerySystemInformation)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtQuerySystemInformation");

    if (NtQuerySystemInformation == NULL)
        return detected;

    if (NtQuerySystemInformation(SystemProcessorPerformanceInformation, outputBuffer, length, &length) == ((NTSTATUS)0xC0000004))
    {
        //std::cout << outputBuffer->NumberOfThreads << "\n";
        outputBuffer = (BYTE*)LocalAlloc(LMEM_FIXED, length);
    }
    
    if (NtQuerySystemInformation(SystemProcessorPerformanceInformation, outputBuffer, length, &length))
    {
        printf("Failed!\n");
        return detected;
    }

    if (outputBuffer != NULL)
    {
        auto info = (SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION*)outputBuffer;

        __int64 threshold = 10; //Needs more testing, this should be changed
        if (info->KernelTime.QuadPart / info->UserTime.QuadPart > threshold)
            detected = true;
    }

    LocalFree(outputBuffer);

    return detected;
}
```

`AntiVM/TimeCheck.h`:

```h
#pragma once

bool TimeCheck() noexcept;
```

`README.md`:

```md
# AntiDebug/AntiVM

## Purpose

This repository hosts the different debug/vm detection methods I have come across whilst looking through the WinAPI. This is not intended to be compiled and ran but rather to show examples of how to implement these different methods into your existing projects. Each file in the `AntiDebug` and `AntiVM` folder can be looked at independently, which is also the reason why `GetModuleHandle` is used.

```

`Source.cpp`:

```cpp
#include "AntiDebug/AntiDebug.h"
#include "AntiVM/AntiVM.h"

#pragma comment(lib, "mpr.lib")

int main()
{
	AntiDebug();
	AntiVM();
	getchar();

	return 0;
}
```