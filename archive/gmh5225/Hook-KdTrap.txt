Project Path: arc_gmh5225_Hook-KdTrap_cvig42vn

Source Tree:

```txt
arc_gmh5225_Hook-KdTrap_cvig42vn
├── DriverEntry.cpp
├── DriverEntry.h
├── HookKdTrap.inf
├── HookKdTrap.sln
├── HookKdTrap.vcxproj
├── HookKdTrap.vcxproj.filters
├── HookKdtrap.cpp
├── HookKdtrap.h
├── README.md
├── Utils.cpp
├── Utils.h
├── asm.asm
└── pic
    ├── 18362.png
    ├── 19045.png
    ├── 19045_2.png
    └── how.jpg

```

`DriverEntry.cpp`:

```cpp
#include "Utils.h"
#include "HookKdTrap.h"
#include "DriverEntry.h"

int _fltused = 0;

VOID DriverUnload(PDRIVER_OBJECT pDriverObject)
{
	DbgPrintEx(0, 0, "UnLoad\n");

	//todo Stop thread exceptionfun
	UnHookKdTrap();

	//__db();
}

bool Handler(PEXCEPTION_RECORD ExceptionRecord, PCONTEXT Context)
{
	if (Context->Rip - (u64)exceptionfun < 0x500)
	{		
		if (ExceptionRecord->ExceptionCode == STATUS_ACCESS_VIOLATION)
		{
			// mov al,[00000000]
			if (*(u32*)Context->Rip == 0x25048A)
			{
				Context->Rip += 7;
				return true;
			}
		}

		if (ExceptionRecord->ExceptionCode == STATUS_PRIVILEGED_INSTRUCTION)
		{
			if (*(USHORT*)(Context->Rip) == 0x220F) // mov cr
			{
				Context->Rip += 3;
				return true;
			}
		}

	}

	return false;
}

NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegPath)
{
	HookKdTrap(Handler);

	HANDLE thread = NULL;
	PsCreateSystemThread(&thread, 0L, NULL, NULL, NULL, (PKSTART_ROUTINE)exceptionfun, 0);

	return STATUS_SUCCESS;
}

noinl void TestSeh()
{
	_disable();
	__try
	{
		__nop();
		__debugbreak();
		KeBugCheck(0);
	}
	__except (1)
	{
		__nop();
		_enable();
	}

	__try
	{
		auto a = (volatile u64)1;
		auto b = (volatile u64)0;
		__nop();
		volatile u64 c = a / b;
		KeBugCheck(0);
	}
	__except (1)
	{
		__nop();
	}
}

void exceptionfun()
{
	while (1)
	{
		//test seh are working
		TestSeh();
		
		//try some dangerous, see Handler
		*(vu8*)0;
		__writecr3(__readcr3() | 1ui64 << 63);
		*(vu8*)0;

		//can't do this since this kind of fault doesn't go into KdTrap 
		//KiPageFault->MmAccessFault->MiSystemFault->BugCheck 
		//*(u64*)exceptionfun = 0x6969696969696969;

		KSleep(5000);
	}

}

```

`DriverEntry.h`:

```h
#pragma once

void exceptionfun();

NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegPath);

ULONG GetWinver();

extern "C" int _fltused;


```

`HookKdTrap.inf`:

```inf
;
; HookKdTrap.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=HookKdTrap.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
HookKdTrap_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
HookKdTrap.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%HookKdTrap.DeviceDesc%=HookKdTrap_Device, Root\HookKdTrap ; TODO: edit hw-id

[HookKdTrap_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
HookKdTrap.sys

;-------------- Service installation
[HookKdTrap_Device.NT.Services]
AddService = HookKdTrap,%SPSVCINST_ASSOCSERVICE%, HookKdTrap_Service_Inst

; -------------- HookKdTrap driver install sections
[HookKdTrap_Service_Inst]
DisplayName    = %HookKdTrap.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\HookKdTrap.sys

;
;--- HookKdTrap_Device Coinstaller installation ------
;

[HookKdTrap_Device.NT.CoInstallers]
AddReg=HookKdTrap_Device_CoInstaller_AddReg
CopyFiles=HookKdTrap_Device_CoInstaller_CopyFiles

[HookKdTrap_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[HookKdTrap_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[HookKdTrap_Device.NT.Wdf]
KmdfService =  HookKdTrap, HookKdTrap_wdfsect
[HookKdTrap_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "HookKdTrap Installation Disk"
HookKdTrap.DeviceDesc = "HookKdTrap Device"
HookKdTrap.SVCDESC = "HookKdTrap Service"

```

`HookKdTrap.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.33027.164
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HookKdTrap", "HookKdTrap.vcxproj", "{A7DCA271-14EA-44C7-AF3C-26801007FF52}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A7DCA271-14EA-44C7-AF3C-26801007FF52}.Debug|x64.ActiveCfg = Debug|x64
		{A7DCA271-14EA-44C7-AF3C-26801007FF52}.Debug|x64.Build.0 = Debug|x64
		{A7DCA271-14EA-44C7-AF3C-26801007FF52}.Debug|x64.Deploy.0 = Debug|x64
		{A7DCA271-14EA-44C7-AF3C-26801007FF52}.Release|x64.ActiveCfg = Release|x64
		{A7DCA271-14EA-44C7-AF3C-26801007FF52}.Release|x64.Build.0 = Release|x64
		{A7DCA271-14EA-44C7-AF3C-26801007FF52}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {4835FC19-F810-48E3-A537-6EC4C7AF0C7A}
	EndGlobalSection
EndGlobal

```

`HookKdTrap.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{A7DCA271-14EA-44C7-AF3C-26801007FF52}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>HookKdTrap</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="HookKdTrap.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DriverEntry.cpp" />
    <ClCompile Include="HookKdtrap.cpp" />
    <ClCompile Include="Utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DriverEntry.h" />
    <ClInclude Include="HookKdtrap.h" />
    <ClInclude Include="Utils.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="asm.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`HookKdTrap.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="HookKdTrap.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DriverEntry.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HookKdtrap.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DriverEntry.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="HookKdtrap.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="asm.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`HookKdtrap.cpp`:

```cpp
#include "Utils.h"
#include "HookKdtrap.h"

PVOID NtBase = 0;

struct CONTEXT_RETURN {
	PVOID   Stack;//rsp
	u64 Function;//rip
	u64 RCX;
	u64 RDX;
	u64 R8;
	u64 R9;
	u64 RAX;

	u64 R12;
	u64 R13;
	u64 R14;
	u64 R15;

	u64 RDI;
	u64 RSI;
	u64 RBX;
	u64 RBP;

	u64 RFlags;
};

extern"C"
{
	void HalpTscQueryCounterOrdered(u64 a1, u64 a2);
	void HookPosition(u64 a1, u64 a2);
	UINT64 CalledHookTimes = 0;//will be big
	void* CalloutReturn(CONTEXT_RETURN*);
	u64 GetR12();
	u64 GetR13();
	void SetR13(u64 NewR13);
	void SetR12(u64 NewR12);
	u64 HalpStallCounter = 0;
	u64 OldHalQueryCounter = 0;
}

using KdAcquireDebuggerLockFn = void(__fastcall*) (unsigned __int8* a1);
KdAcquireDebuggerLockFn KdAcquireDebuggerLock = 0;

using KdReleaseDebuggerLockFn = __int64(__fastcall*) (unsigned __int8 a1);
KdReleaseDebuggerLockFn KdReleaseDebuggerLock = 0;

/*
 
00 ffffe104`e7d16598 fffff801`11871824 nt!KeBugCheckEx
01 ffffe104`e7d165a0 fffff801`1164233f nt!MiRaisedIrqlFault+0x15a42c
02 ffffe104`e7d165f0 fffff801`11809cd8 nt!MmAccessFault+0x4ef
03 ffffe104`e7d16790 fffff801`11955e46 nt!KiPageFault+0x358
04 ffffe104`e7d16920 fffff801`11956d63 nt!MiBuildForkPte+0x5fa
05 ffffe104`e7d16a50 fffff801`11cd94b1 nt!MiCloneVads+0x4ab
06 ffffe104`e7d16ce0 fffff801`11be3d87 nt!MiCloneProcessAddressSpace+0x261
07 ffffe104`e7d16dc0 fffff801`11a58a57 nt!MmInitializeProcessAddressSpace+0x20764b
08 ffffe104`e7d16fb0 fffff801`11bc6162 nt!PspAllocateProcess+0x1d13
09 ffffe104`e7d17720 fffff801`11d071f5 nt!PspCreateProcess+0x242
0a ffffe104`e7d179f0 fffff801`1180d9f5 nt!NtCreateProcessEx+0x85
0b ffffe104`e7d17a50 00007ffe`3fd6da64 nt!KiSystemServiceCopyEnd+0x25
0c 000000cb`29e8f118 00000000`00000000 ntdll!NtCreateProcessEx+0x14

0: kd > k
#  Call Site
00 KMDFDriver1!HookPosition[E:\Visual_Studio_File\HelloWorld\KMDF Driver1\asm.asm @ 19]
01 nt!KeStallExecutionProcessor + 0x120
02 nt!KeFreezeExecution + 0x110
03 nt!KdEnterDebugger + 0x6d
04 nt!KdpReport + 0x74
05 nt!KdpTrap + 0x160
06 nt!KdTrap + 0x2d
07 nt!KiDispatchException + 0x177
08 nt!KxExceptionDispatchOnExceptionStack + 0x12
09 nt!KiExceptionDispatchOnExceptionStackContinue
0a nt!KiExceptionDispatch + 0x125
0b nt!KiGeneralProtectionFault + 0x320
0c nt!KiCustomRecurseRoutine0 + 0xd
0d nt!KiCustomRecurseRoutine9 + 0xd
0e nt!KiCustomRecurseRoutine8 + 0xd
0f nt!KiCustomRecurseRoutine7 + 0xd
10 nt!KiCustomAccessRoutine7 + 0x22
11 nt!ExpTimeRefreshDpcRoutine + 0x9f
12 nt!KiSwInterruptDispatch + 0xfe6
13 nt!KiProcessExpiredTimerList + 0x172
14 nt!KiRetireDpcList + 0x5dd
15 nt!KiIdleLoop + 0x9e
*/

//modify if not enough
#define MAX_CORE 32

struct DBGCTX
{
	struct
	{
		EXCEPTION_RECORD ExceptionContex[MAX_CORE];
		CONTEXT ExceptionRecord[MAX_CORE];
		CONTEXT_RETURN ReturnContex[MAX_CORE];
	}ThisCtx;

	struct
	{
		EXCEPTION_RECORD ExceptionContex[MAX_CORE];
		CONTEXT ExceptionRecord[MAX_CORE];
		CONTEXT_RETURN ReturnContex[MAX_CORE];
	}LastCtx;

};

__declspec(dllexport) DBGCTX DbgCtx;

u64 KiDispatchException = 0;
u64 KdTrap = 0;
u64 KdpTrap = 0;
u64 KdEnterDebugger = 0;
u64 KdpReport = 0;
u64 KeFreezeExecution = 0;
//u64* pKdDebuggerLock = 0;
volatile i64 bpCnt = 0;
volatile i64 hkCnt = 0;

void NTContinue(PCONTEXT Context, ULONG64 Rip)
{
	CONTEXT_RETURN Ctx{};
	Ctx.Stack = (pv)Context->Rsp;
	Ctx.Function = Rip;
	Ctx.RAX = Context->Rax;

	Ctx.RCX = Context->Rcx;
	Ctx.RDX = Context->Rdx;
	Ctx.R8 = Context->R8;
	Ctx.R9 = Context->R9;

	Ctx.R12 = Context->R12;
	Ctx.R13 = Context->R13;
	Ctx.R14 = Context->R14;
	Ctx.R15 = Context->R15;

	Ctx.RDI = Context->Rdi;
	Ctx.RSI = Context->Rsi;
	Ctx.RBX = Context->Rbx;
	Ctx.RBP = Context->Rbp;

	Ctx.RFlags = Context->EFlags;

	CalloutReturn(&Ctx);

	BpMe(__LINE__);
	KeBugCheck(0);
}

u32 LastLine = 0;
u32 ThisLine = 0;
u64 BpMe(u64 line)
{
	LastLine = ThisLine;
	ThisLine = line;
	//ba e1 KMDFDriver1!BpMe
	//DbgPrintEx(0, 0, "line:%lld\n", line);
	//__debugbreak();
	return line;
}

ULONG g_Winver = 0;
ULONG GetWinver()
{
	if (!g_Winver)
	{
		PsGetVersion(0, 0, &g_Winver, 0);
	}
	return g_Winver;
}

u32 ExceptionStackOffset = 0;
u32 GetExceptionStackOffset()
{
	if (!ExceptionStackOffset)
	{
		if (GetWinver() >= 22000)
		{
			ExceptionStackOffset = 0x8268;
		}
		else
		{
			switch (GetWinver())
			{
			case 19045:
			case 19044:
			case 19043:
			case 19042:
			case 19041:
				ExceptionStackOffset = 0x7f28;
				break;

			case 18363:
			case 18362:
				ExceptionStackOffset = 0x5c28;
				break;

			default:
				break;
			}
		}

	}

	if (ExceptionStackOffset)
	{
		ExceptionStackOffset += 0x180;
	}
	else
	{
		__db();
	}

	return ExceptionStackOffset;
}

bool IsCurrentExceptionOnExceptionStack()
{
	//winver too low, windows is not implementing Exception Stack
	if (!ExceptionStackOffset)
		return false;

	if (
		__readgsbyte(ExceptionStackOffset - 2)	/* ExceptionStackActive */
		)
	{
		return false;
	}

	return __readgsqword(ExceptionStackOffset) - (u64)_AddressOfReturnAddress() < 0x6000ui64;
}

template<typename F>
BOOLEAN DoStackTrace(F const& f, void* CustomStackFrame = 0, bool ReverseDirection = false)
{
	//__writegsbyte(0x5DA6, 1);// no exception stack

	void** stack_max = (void**)__readgsqword(0x1a8);
	void** stack_frame = (void**)_AddressOfReturnAddress();
	if (CustomStackFrame)
		stack_frame = (pv*)CustomStackFrame;

	bool bExceptionOnExceptionStack = IsCurrentExceptionOnExceptionStack();

	if (bExceptionOnExceptionStack)
	{
		//BpMe(__LINE__);
		void** ExceptionStack_max = (pv*)__readgsqword(ExceptionStackOffset);
		stack_max = ExceptionStack_max;
	}
	else
	{
		if ((u64)stack_max - (u64)stack_frame > 0x6000 || stack_frame > stack_max)
		{
			//BpMe(__LINE__);
			return FALSE;
		}
	}

	if (ReverseDirection)
	{
		for (void** stack_current = stack_frame; stack_current < stack_max; ++stack_current)
		{
			if (f(stack_current))
			{
				return TRUE;
			}
		}
	}
	else
	{
		for (void** stack_current = stack_max; stack_current > stack_frame; --stack_current)
		{
			if (f(stack_current))
			{
				return TRUE;
			}
		}
	}

	return FALSE;
}

ExceptionCallback g_Handler = 0;
/*

00 KMDFDriver1!HookPosition
01 nt!KeStallExecutionProcessor+0x9b
02 nt!KeFreezeExecution+0x110
03 nt!KdEnterDebugger+0x6d
04 nt!KdpReport+0x74
05 nt!KdpTrap+0x160
06 nt!KdTrap+0x2d
07 nt!KiDispatchException+0x177
08 nt!KxExceptionDispatchOnExceptionStack+0x12
09 nt!KiExceptionDispatchOnExceptionStackContinue
0a nt!KiExceptionDispatch+0x125
0b nt!KiPageFault+0x443
0c nt!MiFastLockLeafPageTable+0x108
0d nt!MiMakeHyperRangeAccessible+0x20f
0e nt!MiExpandVadBitMap+0x8c
0f nt!MiInitializeVadBitMap+0x91
10 nt!MmInitializeProcessAddressSpace+0x19b
11 nt!PspAllocateProcess+0x1d42
12 nt!NtCreateUserProcess+0xa17
13 nt!KiSystemServiceCopyEnd+0x25
14 0x00007ffc`7c14e614


00 KMDFDriver1!ExceptionHandler
01 KMDFDriver1!HookPosition+0xa9
02 hal!KeStallExecutionProcessor+0xac
03 nt!KeFreezeExecution+0x26a
04 nt!KdEnterDebugger+0x64
05 nt!KdpReport+0x71
06 nt!KdpTrap+0x14d
07 nt!KdTrap+0x2c
08 nt!KiDispatchException+0x15f
09 nt!KiExceptionDispatch+0x11d
0a nt!KiBreakpointTrap+0x318
0b KMDFDriver1!DriverEntry+0xe0
0c nt!IopLoadDriver+0x4c2
0d nt!IopLoadUnloadDriver+0x4e
0e nt!ExpWorkerThread+0x105
0f nt!PspSystemThreadStartup+0x55
10 nt!KiStartSystemThread+0x2a
*/
extern"C" void ExceptionHandler(PEXCEPTION_RECORD ExceptionRecord, PCONTEXT Context)
{
	//enviroment: interrupt disabled 
	//todo : relpace unreliable SetR1X/GetR1X 

	InterlockedIncrement64(&bpCnt);

	if (!ExceptionRecord || !Context || (u64)ExceptionRecord->ExceptionAddress != Context->Rip)
	{
		BpMe(__LINE__);
		KeBugCheck(0);
	}

	auto CurrentCpuNumber = __readgsdword(0x24 + 0x180);
	DbgCtx.LastCtx.ExceptionContex[CurrentCpuNumber] = DbgCtx.ThisCtx.ExceptionContex[CurrentCpuNumber];
	DbgCtx.LastCtx.ExceptionRecord[CurrentCpuNumber] = DbgCtx.ThisCtx.ExceptionRecord[CurrentCpuNumber];

	DbgCtx.ThisCtx.ExceptionContex[CurrentCpuNumber] = *ExceptionRecord;
	DbgCtx.ThisCtx.ExceptionRecord[CurrentCpuNumber] = *Context;


	if ((u64)ExceptionRecord->ExceptionAddress > KdpTrap &&
		(u64)ExceptionRecord->ExceptionAddress - KdpTrap < 0x250)
		KeBugCheck(0);

	if (g_Handler)
	{
		if (g_Handler(ExceptionRecord, Context))
		{
			NTContinue(Context, Context->Rip);
			KeBugCheck(0);
		}
	}

	/*
		it's other type of exception, continue to:

		kernel:
				|| !(unsigned __int8)KdTrap(a3, v14, (int)ExceptionRecord, (int)&v29, 0, 0)
			here->    && !RtlDispatchException(ExceptionRecord, (PCONTEXT)&v29))
				&& !(unsigned __int8)KdTrap(a3, v14, (int)ExceptionRecord, (int)&v29, 0, 1) )

		user:
			 if ( !KeGetCurrentThread()->ApcState.Process[1].AffinityPadding[9] && !KdIgnoreUmExceptions && v19 != -2147483597
			  || IsThisAKdTrap )
				{
					if ( KdTrap((__int64)TrapFrame, (__int64)ExceptionFrame_1, ExceptionRecord, (__int64)&Context, Context, 0) )
					{
						WILL NOT EXECUTE;
					}
			here->

	*/

	CONTEXT_RETURN ReturnCtx{};
	ReturnCtx.RAX = 0;

	// cost 8 hour for writing this stupid code 
	//ReturnCtx.RFlags = Context->EFlags;		
	//if (!IsCurrentExceptionOnExceptionStack())
	//	ReturnCtx.RFlags |= 0x200;
	//
	//if (ExGetPreviousMode() == UserMode)
	//	ReturnCtx.RFlags |= 0x40000;
	//
	////if((Context->SegCs & 3) == 0)
	////	ReturnCtx.RFlags = Context->EFlags | 0x200;
	////else
	////	ReturnCtx.RFlags = __readeflags() | 0x200;


	bool
		bRbxFound = false,
		bNonVolatileRegFound = false,
		bStackFound = false,
		bRFlagsFound = false
		;

	auto traceResult = DoStackTrace([&](void** stack_current) -> BOOLEAN
		{
			if (!bRFlagsFound)
			{
				if (*(u64*)(stack_current) > KdEnterDebugger &&
					*(u64*)(stack_current)-KdEnterDebugger < 0x100 &&
					*(u8*)(*(u64*)(stack_current)-5) == 0xE8 &&			/* Make sure it's a call */
					*(u32*)(*(u64*)(stack_current)) == 0x48f08a44			/* mov r14b, al;  mov xxx */
					)
				{
					//BpMe(__LINE__);
					ReturnCtx.RFlags = *(u64*)((u64)stack_current - 0x8);
					bRFlagsFound = true;
				}
				return FALSE;
			}

			if (!bNonVolatileRegFound)
			{
				if (*(u64*)(stack_current) > KdpTrap && *(u64*)(stack_current)-KdpTrap < 0x250)
				{
					ReturnCtx.RBP = *(u64*)((u64)stack_current + 0x10);
					ReturnCtx.RSI = *(u64*)((u64)stack_current + 0x18);
					ReturnCtx.RDI = *(u64*)((u64)stack_current + 0x20);

					ReturnCtx.R13 = *(u64*)((u64)stack_current - 0x8);
					ReturnCtx.R14 = *(u64*)((u64)stack_current - 0x10);
					ReturnCtx.R15 = *(u64*)((u64)stack_current - 0x18);

					ReturnCtx.R12 = GetR12();
					bNonVolatileRegFound = true;
				}
				return FALSE;
			}

			if (!bRbxFound)
			{
				if (*(u64*)(stack_current) > KdTrap && *(u64*)(stack_current)-KdTrap < 0x50)
				{
					if (MmIsAddressValid(*(pv*)((u64)stack_current + 8)))
					{
						ReturnCtx.RBX = *(u64*)((u64)stack_current + 8);
						bRbxFound = true;
					}
				}
				return FALSE;
			}

			if (!bStackFound)
			{
				if (*(u64*)(stack_current) > KiDispatchException + 0x100 &&
					*(u64*)(stack_current)-KiDispatchException < 0x400)
				{
					ReturnCtx.Function = *(u64*)(stack_current);
					//ctx.RBX = *(u64*)((u64)stack_current + 8);
					ReturnCtx.Stack = (pv)((u64)stack_current + 8);
					bStackFound = true;
				}
				return FALSE;
			}

			return TRUE;

		}, _AddressOfReturnAddress(), true);


	if (!traceResult)
	{
		BpMe(__LINE__);
		KeBugCheck(0);
	}

	//DbgPrintEx(0, 0, "Stack:%p, Function:%llx, RAX:%llx, R12:%llx, R13:%llx, R14:%llx, R15:%llx, RDI:%llx, RSI:%llx, RBX:%llx, RBP:%llx\n",
	//	ctx.Stack, ctx.Function, ctx.RAX, ctx.R12, ctx.R13, ctx.R14, ctx.R15, ctx.RDI, ctx.RSI, ctx.RBX, ctx.RBP);
	DbgCtx.LastCtx.ReturnContex[CurrentCpuNumber] = DbgCtx.ThisCtx.ReturnContex[CurrentCpuNumber];
	DbgCtx.ThisCtx.ReturnContex[CurrentCpuNumber] = ReturnCtx;

	//BpMe(__LINE__);

	CalloutReturn(&ReturnCtx);

	BpMe(__LINE__);
	KeBugCheck(0);
}

extern"C" u64 CheckCallCtx()
{
	/*
	Find :
		nt!KeStallExecutionProcessor+0x120
		nt!KeFreezeExecution+0x110
		//nt!KdEnterDebugger+0x6dba
		nt!KdpReport+0x74
		nt!KdpTrap+0x160
		nt!KdTrap+0x2d
		nt!KiDispatchException+0x177

	todo :
		Increase code efficiency by recognize irrevalent calls and return early.
	*/

	bool
		bKeStallExecutionProcessor = false,
		bKeFreezeExecution = false,
		bKdpReport = false,
		bKdpTrap = false,
		bKdTrap = false,
		bKiDispatchException = false
		;

	auto traceResult = DoStackTrace([&](void** stack_current) -> BOOLEAN
		{
			if (*(u64*)stack_current == 0)
				return FALSE;

			if (!bKeStallExecutionProcessor)
			{
				if (*(u64*)stack_current > (u64)KeStallExecutionProcessor + 0x50 &&
					*(u64*)stack_current - (u64)KeStallExecutionProcessor < 0x200)
					bKeStallExecutionProcessor = true;

				return FALSE;
			}

			if (!bKeFreezeExecution)
			{
				if (*(u64*)stack_current > KeFreezeExecution + 0x50 &&
					*(u64*)stack_current - KeFreezeExecution < 0x200)
					bKeFreezeExecution = true;

				return FALSE;
			}

			if (!bKdpReport)
			{
				if (*(u64*)stack_current > KdpReport + 0x50 &&
					*(u64*)stack_current - KdpReport < 0x150)
					bKdpReport = true;

				return FALSE;
			}

			if (!bKdpTrap)
			{
				if (*(u64*)stack_current > KdpTrap + 0x50 &&
					*(u64*)stack_current - KdpTrap < 0x250)
					bKdpTrap = true;

				return FALSE;
			}

			if (!bKdTrap)
			{
				if (*(u64*)stack_current > KdTrap &&
					*(u64*)stack_current - KdTrap < 0x50)
					bKdTrap = true;

				return FALSE;
			}

			if (!bKiDispatchException)
			{
				if (*(u64*)stack_current > KiDispatchException + 0x100 &&
					*(u64*)stack_current - KiDispatchException < 0x400)
					bKiDispatchException = true;

				return FALSE;
			}

			return TRUE;

		}, _AddressOfReturnAddress(), true);

	return traceResult;
}

extern"C" u64 FindExceptionRecord()
{
	u64 ExceptionRecord = 0;

	u64 CorruptContext = 0, CorruptR12 = 0;
	//if (GetWinver() > 18363)
	//{
	CorruptContext = GetR13();
	//}

	bool bFoundExceptionRecord = false;
	bool bFoundCorruptReg = false;

	//Find exception record and context. 
	//Trace from bottom to top since there will be nested exception
	auto traceResult = DoStackTrace([&](void** stack_current) -> BOOLEAN
		{
			if (!bFoundCorruptReg)
			{
				if (*(u64*)(stack_current) > KeFreezeExecution &&
					*(u64*)(stack_current)-KeFreezeExecution < 0x200)
				{
					//BpMe(__LINE__);
					if (GetWinver() <= 18363)
					{
						//BpMe(__LINE__);
						//r14
						auto NewIrql = *(u64*)((u64)stack_current - 4 * 8);
						__writecr8(NewIrql);
					}
					else
					{
						if (CorruptContext)
						{
							if ((*(u64*)((u64)stack_current - 3 * 8) & ~0xFF) != CorruptContext)
							{
								//something went wrong
								BpMe(__LINE__);
								return FALSE;
								//__fastfail(0);
							}

							//r13
							CorruptContext = *(u64*)((u64)stack_current - 3 * 8);
						}

						//mov [rsp+10h], rbp
						auto OrigIrql = *(u64*)((u64)stack_current + 0x10);
						__writecr8(OrigIrql);
					}

					//r12
					CorruptR12 = *(u64*)((u64)stack_current - 2 * 8);
					bFoundCorruptReg = true;
				}
				return FALSE;
			}

			if (!bFoundExceptionRecord)
			{
				if (*(u64*)(stack_current) > KdEnterDebugger &&
					*(u64*)(stack_current)-KdEnterDebugger < 0x100 &&
					*(u8*)(*(u64*)(stack_current)-5) == 0xE8 &&			/* Make sure it's a call */
					*(u32*)(*(u64*)(stack_current)) == 0x48f08a44			/* mov r14b, al;  mov xxx */
					)
				{
					//r15
					ExceptionRecord = *(u64*)((u64)stack_current - 3 * 8);
					if (!ExceptionRecord)
						BpMe(__LINE__);
					bFoundExceptionRecord = true;

					if (!CorruptContext)
					{
						BpMe(__LINE__);

						// Context from rsi in KiDispatchException
						CorruptContext = *(u64*)((u64)stack_current + 3 * 8);
					}
				}
				return FALSE;
			}

			return TRUE;

		}, _AddressOfReturnAddress(), true);

	if (!traceResult || !CorruptContext)
	{
		BpMe(__LINE__);
		KeBugCheck(0);
	}

	//if (GetWinver() > 18363)
	//{
	SetR13(CorruptContext);
	//}

	SetR12(CorruptR12);

	return ExceptionRecord;
}

void HookKdTrap(ExceptionCallback Handler)
{

	//KeIpiGenericCall(ipicallback, 0);

	/*
	ba e1 nt!PnpCallDriverEntry
	ba e1 nt!guard_wrap_icall_retpoline_exit
	.reload;ba e1 nt!guard_wrap_icall_retpoline_exit;g

	ba e1 nt!KeStallExecutionProcessor
	ba e1 nt!KeBugCheck2
	ba e1 nt!KdpTrap
	ba e1 KMDFDriver1!HookPosition
	ba e1 KMDFDriver1!BpMe
	ba e1 KMDFDriver1!ExceptionHandler
	ba e1 KMDFDriver1!FindExceptionRecord
	*/

	//InitMemoryManager();
	//pDriverObject->DriverUnload = DriverUnload;

	hkCnt = 0;
	CalledHookTimes = 0;
	pv halDll = 0;
	pv nt = 0;
	getKernelModuleByName("hal.dll", &halDll, 0);
	getKernelModuleByName("ntoskrnl.exe", &nt, 0);
	GetExceptionStackOffset();
	if (GetWinver() == 18362 || GetWinver() == 18363)
	{
		if (*KdDebuggerEnabled)
			__db();
	}
	else if (GetWinver() == 19043)
	{
		//ba e1 nt!guard_wrap_icall_retpoline_exit
		u64 guard_wrap_icall_retpoline_exit = (u64)nt + (0xfffff806579fea80 - 0xfffff80657600000);
		if (MmIsAddressValid((pv)guard_wrap_icall_retpoline_exit) &&
			*(u8*)guard_wrap_icall_retpoline_exit == 0xC3)
			((void(*)())guard_wrap_icall_retpoline_exit)();
	}

	//KiSwapToUmsThread+3E6
	KiDispatchException = (u64)FindPatternSect(nt, "PAGE", "41 B1 01 48 83 65 20 00 C7 45 28 02 00 00 00 48 89 45 30 48 89 7D 38 C7 45 10 1C 07 00 C0 C7 45 14 01 00 00 00 C6 44 24 20 00 E8");
	if (KiDispatchException)
	{
		KiDispatchException = RVA(KiDispatchException + 42, 5);
	}
	else
	{
		KiDispatchException = (u64)FindPatternSect(nt, ".text", "4C 8D 45 ? 48 8B D4 48 8B C8 E8 ? ? ? ? 48 8D 8C 24");
		KiDispatchException = RVA(KiDispatchException + 10, 5);
	}


	KdTrap = (u64)FindPatternSect(nt, ".text", "48 83 EC 38 ? ? ? ? ? ? ? 8A 44 24 68 88 44 24 28 8A 44 24 60 88 44 24 20");
	KdpTrap = (u64)FindPatternRange((pv)KdTrap, 0x50, "E8 ? ? ? ? EB");
	KdpTrap = RVA(KdpTrap, 5);


	KdEnterDebugger = (u64)FindPatternSect(nt, ".text", "E8 ? ? ? ? 65 48 8B 2C 25 20 00 00 00 4D 8B C5");
	if (KdEnterDebugger)
	{
		KdEnterDebugger = RVA(KdEnterDebugger, 5);
	}
	else
	{
		KdEnterDebugger = (u64)FindPatternSect(nt, "PAGEKD", "33 D2 33 C9 E8 ? ? ? ? 44 8A E0 33 D2");
		KdEnterDebugger = RVA(KdEnterDebugger + 4, 5);
	}

	KdpReport = (u64)FindPatternSect(nt, "PAGEKD", "8A 44 24 78 88 44 24 28 E8");
	if (KdpReport)
	{
		KdpReport = RVA(KdpReport + 8, 5);
	}
	else
	{
		KdpReport = (u64)FindPatternSect(nt, "PAGEKD", "E8 ? ? ? ? 44 8A D0 48 8B 5C 24 50");
		KdpReport = RVA(KdpReport, 5);
	}

	KeFreezeExecution = (u64)FindPatternSect(nt, "PAGEKD", "E8 ? ? ? ? 44 8A F0 48 8B");
	KeFreezeExecution = RVA(KeFreezeExecution, 5);

	KdReleaseDebuggerLock = (KdReleaseDebuggerLockFn)GetProcAddress(nt, "KdReleaseDebuggerLock");
	KdAcquireDebuggerLock = (KdAcquireDebuggerLockFn)GetProcAddress(nt, "KdAcquireDebuggerLock");
	u8 now_irql = 0;
	KdAcquireDebuggerLock(&now_irql);
	KeLowerIrql(now_irql);
	//u64 KdDebuggerLockRva = (u64)FindPatternSect(nt, ".text", "");
	//pKdDebuggerLock = (u64*)RVA(KdDebuggerLockRva, 7);
	//*pKdDebuggerLock = 1;

	//HalpHpetQueryCounter


	//HalpTimerStallCounterPowerChange
	auto rva = FindPatternSect(halDll, ".text", "48 83 25 ? ? ? ? 00 48 89 1D ? ? ? ? EB");
	if (!rva)
	{
		rva = FindPatternSect(nt, ".text", "48 83 25 ? ? ? ? 00 48 89 1D ? ? ? ? EB");
		if (!rva)
			return;
	}
	//u poi(poi(nt!HalpStallCounter) + 70)
	HalpStallCounter = *(u64*)RVA(rva + 8, 7);
	OldHalQueryCounter = *(u64*)(HalpStallCounter + 0x70);
	*(u64*)(HalpStallCounter + 0x70) = (u64)HookPosition;


	//*(u64*)0xfffff8017398d280 = 1;//KdDebuggerLock
	//*(u64*)0xfffff8017398d2c0 = 0;//KiFreezeExecutionLock


	//KdpDebugRoutineSelect

	auto pKdpDebugRoutineSelect = RVA2(KdTrap + 4, 7, 2);
	*(u32*)(pKdpDebugRoutineSelect) = 1;

	//catch first time execption
	auto aa = &NtGlobalFlag;
	auto phys = MmGetPhysicalAddress(*(pv*)aa);
	int one = 1;
	WritePhysicalSafe2(phys.QuadPart, &one, 4);

	g_Handler = Handler;

	//*(u64*)0xfffff8007e450c64 = 1;

	//exceptionfun();

	//*(volatile char*)0;
	//int a = 1;
	//__debugbreak();
	//a = 1;
	//__debugbreak();
	//a = 1;
	//__debugbreak();
	//
	//DbgPrintEx(0, 0, "bpCnt %lld\n", bpCnt);
	//__debugbreak();
	//DbgPrintEx(0, 0, "bpCnt %lld\n", bpCnt);
	//
	//DbgPrintEx(0, 0, "bpCnt %lld\n", bpCnt);

	/*
		00 nt!DbgBreakPointWithStatus
		01 nt!KiBugCheckDebugBreak+0x12
		02 nt!KeBugCheck2+0x952
		03 nt!KeBugCheckEx+0x107
		04 nt!PspSystemThreadStartup$filt$0+0x44
		05 nt!_C_specific_handler+0xac
		06 nt!RtlpExecuteHandlerForException+0x12
		07 nt!RtlDispatchException+0x4a5
		08 nt!KiDispatchException+0x16e
		09 nt!KiExceptionDispatch+0x11d
		0a nt!KiPageFault+0x445
		0b KMDFDriver1!DriverEntry+0xf1 [E:\Visual_Studio_File\HelloWorld\KMDF Driver1\Drivermain.cpp @ 1288]
		0c nt!IopLoadDriver+0x4c2
		0d nt!IopLoadUnloadDriver+0x4e
		0e nt!ExpWorkerThread+0x105
		0f nt!PspSystemThreadStartup+0x55
		10 nt!KiStartSystemThread+0x2a
	*/

	//InitMemoryManager();
	//getKernelModuleByName("ntoskrnl.exe", &NtBase, 0);

	//__debugbreak(); 
	//EptBuildMtrrMap();
	//auto PhyRange = MmGetPhysicalMemoryRanges();
	//PVOID TestPage = ExAllocatePool(NonPagedPool, 0x1000);
	//memset(TestPage, 0, 0x1000);
	//ULONG64 Physical = 0;
	//ULONG64 RemoveSize = 0x1000;
	//MmRemovePhysicalMemory((PPHYSICAL_ADDRESS )&Physical, (PLARGE_INTEGER)&RemoveSize);


	//HANDLE InsertPid = 0;
	//GetProcessIdByProcessName(L"dwm.exe", &InsertPid);
	//if(!InsertPid)
	//	return STATUS_UNSUCCESSFUL;
	//
	//PEPROCESS TargetProcess;
	//if (!NT_SUCCESS(PsLookupProcessByProcessId(InsertPid, &TargetProcess)))
	//{
	//	//__debugbreak();
	//	return STATUS_UNSUCCESSFUL;
	//}
	//
	//ULONG64 pBBTBuffer = (u64)FindPatternSect(NtBase, ".text", "49 83 C2 08 49 83 C6 08 48 FF C5 44 03 DF 75 ? 48");
	//DbgPrintEx(0, 0, "pBBTBuffer %llx\n", pBBTBuffer);
	//if (pBBTBuffer)
	//{
	//	pBBTBuffer += 16;
	//	pBBTBuffer = RVA2(pBBTBuffer, 8, 3);
	//	*(ULONG64*)pBBTBuffer = 1;
	//	u64 UserCr3 = *(u64*)((u64)TargetProcess + 0x388);//0x388
	//	DbgPrintEx(0, 0, "UserCr3 %llx\n", UserCr3);
	//	PVOID Allocated = AllocateProcessUserSpace(UserCr3,1,true);
	//	DbgPrintEx(0, 0, "Allocated %llx\n", Allocated);
	//}

}

void UnHookKdTrap()
{
	//indicates the things are working
	if (NtGlobalFlag == 1)
	{
		//todo halt processor

		auto aa = &NtGlobalFlag;
		auto phys = MmGetPhysicalAddress(*(pv*)aa);
		int zero = 0;
		WritePhysicalSafe2(phys.QuadPart, &zero, 4);

		auto pKdpDebugRoutineSelect = RVA2(KdTrap + 4, 7, 2);
		*(u32*)(pKdpDebugRoutineSelect) = 0;

		*(u64*)(HalpStallCounter + 0x70) = OldHalQueryCounter;

		KdReleaseDebuggerLock(__readcr8());
	}

}

```

`HookKdtrap.h`:

```h
#pragma once

using ExceptionCallback = bool(__stdcall*)(PEXCEPTION_RECORD ExceptionRecord, PCONTEXT Context);

void HookKdTrap(ExceptionCallback Handler);

void UnHookKdTrap();

u64 BpMe(u64 line);


```

`README.md`:

```md
# Hook KdTrap -- Windows global exception handler

KdTrap is the very first function get called when an exception occur, by hooking it, your code can gain full control of kernel. 

HookKdtrap modifies HalpStallCounter and other variables to take over control flow.  


## Result
Accessing 0 address and setting reserved bit in cr3 will normally cause a bsod, but it's safe after we use our custom exception handler  
```
*(vu8*)0;
__writecr3(__readcr3() | 1ui64 << 63);
*(vu8*)0;    
```  

Set NtGlobalFlag to 1 will catch global exception, normal system will instantly crash if NtGlobalFlag is 1.  
![Result1](/pic/18362.png)
  
## How to build
Open .sln file, choose debug-x64 and press build. 
  
## BSOD
![WhatHappen](/pic/how.jpg)  
The exported "DbgCtx" variable is useful for debugging, but using a actual debugger is more helpful for debug.  
Setting up [Qemu+Windbg](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-qemu-kernel-mode-debugging-using-exdi) so that the debugger can step through/in KdTrap  

## Compatibility
ONLY TEST IN Win10-18362/3 and Win10-19041/5, using other version of windows may leads to unexpected behaviour! 
  
## Limitations
Some exception in kernel such as excuting NX pages and write to read only memory are not be able to catch by kdtrap and therefore won't goes into our handler. 
  
For executing NX page in kernel:  
```KiPageFault->MmAccessFault->MiSystemFault->MiCheckSystemNxFault->BugCheck ```
  
For write to read only pages in kernel:  
```KiPageFault->MmAccessFault->MiSystemFault->BugCheck ```  

## Stack trace  
HookKdtrap extensively use stack trace to gather register, different winver may have different offset in stack.  

### Sample Stack trace when exception handler get called  

Inserting __debugbreak() in Drivermain:  
```
00 KMDFDriver1!ExceptionHandler
01 KMDFDriver1!HookPosition+0xa9
02 hal!KeStallExecutionProcessor+0xac
03 nt!KeFreezeExecution+0x26a
04 nt!KdEnterDebugger+0x64
05 nt!KdpReport+0x71
06 nt!KdpTrap+0x14d
07 nt!KdTrap+0x2c
08 nt!KiDispatchException+0x15f
09 nt!KiExceptionDispatch+0x11d
0a nt!KiBreakpointTrap+0x318
0b KMDFDriver1!DriverEntry+0xe0
0c nt!IopLoadDriver+0x4c2
0d nt!IopLoadUnloadDriver+0x4e
0e nt!ExpWorkerThread+0x105
0f nt!PspSystemThreadStartup+0x55
10 nt!KiStartSystemThread+0x2a
```  
  
Exception in PatchGuard routine:  
```
00 KMDFDriver1!HookPosition
01 nt!KeStallExecutionProcessor + 0x120
02 nt!KeFreezeExecution + 0x110
03 nt!KdEnterDebugger + 0x6d
04 nt!KdpReport + 0x74
05 nt!KdpTrap + 0x160
06 nt!KdTrap + 0x2d
07 nt!KiDispatchException + 0x177
08 nt!KxExceptionDispatchOnExceptionStack + 0x12
09 nt!KiExceptionDispatchOnExceptionStackContinue
0a nt!KiExceptionDispatch + 0x125
0b nt!KiGeneralProtectionFault + 0x320
0c nt!KiCustomRecurseRoutine0 + 0xd
0d nt!KiCustomRecurseRoutine9 + 0xd
0e nt!KiCustomRecurseRoutine8 + 0xd
0f nt!KiCustomRecurseRoutine7 + 0xd
10 nt!KiCustomAccessRoutine7 + 0x22
11 nt!ExpTimeRefreshDpcRoutine + 0x9f
12 nt!KiSwInterruptDispatch + 0xfe6
13 nt!KiProcessExpiredTimerList + 0x172
14 nt!KiRetireDpcList + 0x5dd
15 nt!KiIdleLoop + 0x9e
```  

## Some Test
![Result2](/pic/19045_2.png)

## Credit (copy from)

[DarkCode](https://github.com/Rythorndoran) for helping in setup qemu debug  
[busy10](https://www.unknowncheats.me/forum/anti-cheat-bypass/500156-hook-kdtrap-windows-global-exception-hander.html) for pattern search functions  
[DemonJames](https://git.back.engineering/DemonJames) for helping in exception handling  
eac for the idea (maybe)  


```

`Utils.cpp`:

```cpp
#include "utils.h"

NTSTATUS getKernelModuleByName(const char* moduleName, PVOID* moduleStart, size_t* moduleSize)
{
	if (!moduleStart)
		return STATUS_INVALID_PARAMETER;

	size_t size{};
	ZwQuerySystemInformation(SystemModuleInformation, nullptr, size, reinterpret_cast<PULONG>(&size));

	const auto listHeader = ExAllocatePool(NonPagedPool, size);
	if (!listHeader)
		return STATUS_MEMORY_NOT_ALLOCATED;

	if (const auto status = ZwQuerySystemInformation(SystemModuleInformation, listHeader, size, reinterpret_cast<PULONG>(&size)))
		return status;

	auto currentModule = reinterpret_cast<PSYSTEM_MODULE_INFORMATION>(listHeader)->Module;
	for (size_t i = 0; i < reinterpret_cast<PSYSTEM_MODULE_INFORMATION>(listHeader)->Count; ++i, ++currentModule)
	{
		const auto currentModuleName = reinterpret_cast<const char*>(currentModule->FullPathName + currentModule->OffsetToFileName);
		if (!strcmp(moduleName, currentModuleName))
		{
			*moduleStart = currentModule->ImageBase;
			if (moduleSize)
				*moduleSize = currentModule->ImageSize;
			return STATUS_SUCCESS;
		}
	}
	return STATUS_NOT_FOUND;
}

#define SizeAlign(Size) ((Size + 0xFFF) & 0xFFFFFFFFFFFFF000)
#define IMAGE_FIRST_SECTION(NtHeader) (PIMAGE_SECTION_HEADER)(NtHeader + 1)
#define NT_HEADER(ModBase) (PIMAGE_NT_HEADERS)((ULONG64)(ModBase) + ((PIMAGE_DOS_HEADER)(ModBase))->e_lfanew)

BOOLEAN StrICmp(const char* Str, const char* InStr, BOOLEAN Two)
{
#define ToLower(Char) ((Char >= 'A' && Char <= 'Z') ? (Char + 32) : Char)

	if (!Str || !InStr)
		return FALSE;

	WCHAR c1, c2; do {
		c1 = *Str++; c2 = *InStr++;
		c1 = ToLower(c1); c2 = ToLower(c2);
		if (!c1 && (Two ? !c2 : 1))
			return TRUE;
	} while (c1 == c2);

	return FALSE;
}

PVOID FindSection(PVOID ModBase, const char* Name, PULONG SectSize)
{
	//get & enum sections
	PIMAGE_NT_HEADERS NT_Header = NT_HEADER(ModBase);
	PIMAGE_SECTION_HEADER Sect = IMAGE_FIRST_SECTION(NT_Header);

	for (PIMAGE_SECTION_HEADER pSect = Sect; pSect < Sect + NT_Header->FileHeader.NumberOfSections; pSect++)
	{
		//copy section name
		char SectName[9]; SectName[8] = 0;
		*(ULONG64*)&SectName[0] = *(ULONG64*)&pSect->Name[0];

		//check name
		if (StrICmp(Name, SectName, true))
		{
			//save size
			if (SectSize) {
				ULONG SSize = SizeAlign(max(pSect->Misc.VirtualSize, pSect->SizeOfRawData));
				*SectSize = SSize;
			}

			//ret full sect ptr
			return (PVOID)((ULONG64)ModBase + pSect->VirtualAddress);
		}
	}

	//no section
	return nullptr;
}

bool readByte(PVOID addr, UCHAR* ret)
{
	*ret = *(volatile char*)addr;
	return true;
}

PUCHAR FindPatternSect(PVOID ModBase, const char* SectName, const char* Pattern)
{
	//find pattern utils
#define InRange(x, a, b) (x >= a && x <= b) 
#define GetBits(x) (InRange(x, '0', '9') ? (x - '0') : ((x - 'A') + 0xA))
#define GetByte(x) ((UCHAR)(GetBits(x[0]) << 4 | GetBits(x[1])))

//get sect range
	ULONG SectSize;
	PUCHAR ModuleStart = (PUCHAR)FindSection(ModBase, SectName, &SectSize);
	PUCHAR ModuleEnd = ModuleStart + SectSize;

	if (!ModuleStart) return nullptr;

	//scan pattern main
	PUCHAR FirstMatch = nullptr;
	const char* CurPatt = Pattern;
	if (*Pattern == '\0')
		CurPatt++;

	for (; ModuleStart < ModuleEnd; ++ModuleStart)
	{
		bool SkipByte = (*CurPatt == '\?');

		//hp(ModuleStart);
		UCHAR byte1;
		if (!readByte(ModuleStart, &byte1)) {
			auto addr2 = (u64)ModuleStart;
			addr2 &= 0xFFFFFFFFFFFFF000;
			addr2 += 0xFFF;
			ModuleStart = (PUCHAR)addr2;
			//sp("123");
			goto Skip;
		}

		if (SkipByte || byte1 == GetByte(CurPatt)) {
			if (!FirstMatch) FirstMatch = ModuleStart;
			if (SkipByte)
				CurPatt += 2;
			else
				CurPatt += 3;
			if (CurPatt[-1] == 0) return FirstMatch;
		}

		else if (FirstMatch) {
			ModuleStart = FirstMatch;
		Skip:
			FirstMatch = nullptr;
			CurPatt = Pattern;
		}
	}

	//failed
	return nullptr;
}

PUCHAR FindPatternRange(PVOID Start, u32 size, const char* Pattern)
{
	//find pattern utils
#define InRange(x, a, b) (x >= a && x <= b) 
#define GetBits(x) (InRange(x, '0', '9') ? (x - '0') : ((x - 'A') + 0xA))
#define GetByte(x) ((UCHAR)(GetBits(x[0]) << 4 | GetBits(x[1])))

//get sect range
	ULONG SectSize;
	PUCHAR ModuleStart = (PUCHAR)Start;
	PUCHAR ModuleEnd = ModuleStart + size;

	//scan pattern main
	PUCHAR FirstMatch = nullptr;
	const char* CurPatt = Pattern;
	if (*Pattern == '\0')
		CurPatt++;

	for (; ModuleStart < ModuleEnd; ++ModuleStart)
	{
		bool SkipByte = (*CurPatt == '\?');

		//hp(ModuleStart);
		UCHAR byte1;
		if (!readByte(ModuleStart, &byte1)) {
			auto addr2 = (u64)ModuleStart;
			addr2 &= 0xFFFFFFFFFFFFF000;
			addr2 += 0xFFF;
			ModuleStart = (PUCHAR)addr2;
			//sp("123");
			goto Skip;
		}

		if (SkipByte || byte1 == GetByte(CurPatt)) {
			if (!FirstMatch) FirstMatch = ModuleStart;
			SkipByte ? CurPatt += 2 : CurPatt += 3;
			if (CurPatt[-1] == 0) return FirstMatch;
		}

		else if (FirstMatch) {
			ModuleStart = FirstMatch;
		Skip:
			FirstMatch = nullptr;
			CurPatt = Pattern;
		}
	}

	//failed
	return nullptr;
}

NTSTATUS CopyPhysics(void* Dst, const void* PhySics, size_t _MaxCount)
{
	MM_COPY_ADDRESS copyaddr;
	copyaddr.PhysicalAddress.QuadPart = (LONGLONG)PhySics;
	SIZE_T copyed = 0;
	return MmCopyMemory(Dst, copyaddr, _MaxCount, MM_COPY_MEMORY_PHYSICAL, &copyed);
}

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION
{
	BOOLEAN DebuggerEnabled;
	BOOLEAN DebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, * PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

BOOLEAN IsKernelDebuggerPresent()
{
	SYSTEM_KERNEL_DEBUGGER_INFORMATION DebuggerInfo;
	ULONG RetLen = 0;
	ZwQuerySystemInformation(SystemKernelDebuggerInformation, &DebuggerInfo, 8, &RetLen);

	return !DebuggerInfo.DebuggerNotPresent;
}

PVOID GetProcAddress(PVOID ModBase, const char* Name)
{
	if (!ModBase) return 0;
	//parse headers
	PIMAGE_NT_HEADERS NT_Head = NT_HEADER(ModBase);
	PIMAGE_EXPORT_DIRECTORY ExportDir = (PIMAGE_EXPORT_DIRECTORY)((ULONG64)ModBase + NT_Head->OptionalHeader.DataDirectory[0].VirtualAddress);

	//process records
	for (ULONG i = 0; i < ExportDir->NumberOfNames; i++)
	{
		//get ordinal & name
		USHORT Ordinal = ((USHORT*)((ULONG64)ModBase + ExportDir->AddressOfNameOrdinals))[i];
		const char* ExpName = (const char*)ModBase + ((ULONG*)((ULONG64)ModBase + ExportDir->AddressOfNames))[i];

		//check export name
		if (StrICmp(Name, ExpName, true))
			return (PVOID)((ULONG64)ModBase + ((ULONG*)((ULONG64)ModBase + ExportDir->AddressOfFunctions))[Ordinal]);
	}

	//no export
	return nullptr;
}

//MmMapIoSpace, not allow write to page table 
NTSTATUS WritePhysicalSafe2(DWORD64 PhysicalAddress, pv Buffer, u64 Length)
{
	PHYSICAL_ADDRESS phy; phy.QuadPart = PhysicalAddress;
	PVOID MapedVirt = MmMapIoSpace(phy, Length, MmNonCached);
	if (!MapedVirt)
		return STATUS_UNSUCCESSFUL;

	memcpy(MapedVirt, Buffer, Length);
	MmUnmapIoSpace(MapedVirt, Length);
	return STATUS_SUCCESS;
}

```

`Utils.h`:

```h
#pragma once
#include <ntifs.h>
#include <ntddk.h>
#include <ntimage.h>
#include <ntstrsafe.h>
#include <intrin.h>

typedef unsigned long long u64;
typedef signed long long i64;
typedef volatile unsigned long long vu64;
typedef unsigned int u32;
typedef void* pv;
typedef void* pv64;
typedef unsigned short u16;
typedef unsigned char u8;
typedef volatile unsigned char vu8;
#define __db __debugbreak
#define noinl __declspec(noinline)
#define naked __declspec(naked)
#define inl __forceinline

#define RVA(Instr, InstrSize) ((DWORD64)Instr + InstrSize + *(LONG*)((DWORD64)Instr + (InstrSize - sizeof(LONG))))
#define RVA2(Instr, InstrSize, Off) ((DWORD64)Instr + InstrSize + *(LONG*)((DWORD64)Instr + Off))

typedef enum _SYSTEM_INFORMATION_CLASS
{
    SystemBasicInformation = 0x0,
    SystemProcessorInformation = 0x1,
    SystemPerformanceInformation = 0x2,
    SystemTimeOfDayInformation = 0x3,
    SystemPathInformation = 0x4,
    SystemProcessInformation = 0x5,
    SystemCallCountInformation = 0x6,
    SystemDeviceInformation = 0x7,
    SystemProcessorPerformanceInformation = 0x8,
    SystemFlagsInformation = 0x9,
    SystemCallTimeInformation = 0xa,
    SystemModuleInformation = 0xb,
    SystemLocksInformation = 0xc,
    SystemStackTraceInformation = 0xd,
    SystemPagedPoolInformation = 0xe,
    SystemNonPagedPoolInformation = 0xf,
    SystemHandleInformation = 0x10,
    SystemObjectInformation = 0x11,
    SystemPageFileInformation = 0x12,
    SystemVdmInstemulInformation = 0x13,
    SystemVdmBopInformation = 0x14,
    SystemFileCacheInformation = 0x15,
    SystemPoolTagInformation = 0x16,
    SystemInterruptInformation = 0x17,
    SystemDpcBehaviorInformation = 0x18,
    SystemFullMemoryInformation = 0x19,
    SystemLoadGdiDriverInformation = 0x1a,
    SystemUnloadGdiDriverInformation = 0x1b,
    SystemTimeAdjustmentInformation = 0x1c,
    SystemSummaryMemoryInformation = 0x1d,
    SystemMirrorMemoryInformation = 0x1e,
    SystemPerformanceTraceInformation = 0x1f,
    SystemObsolete0 = 0x20,
    SystemExceptionInformation = 0x21,
    SystemCrashDumpStateInformation = 0x22,
    SystemKernelDebuggerInformation = 0x23,
    SystemContextSwitchInformation = 0x24,
    SystemRegistryQuotaInformation = 0x25,
    SystemExtendServiceTableInformation = 0x26,
    SystemPrioritySeperation = 0x27,
    SystemVerifierAddDriverInformation = 0x28,
    SystemVerifierRemoveDriverInformation = 0x29,
    SystemProcessorIdleInformation = 0x2a,
    SystemLegacyDriverInformation = 0x2b,
    SystemCurrentTimeZoneInformation = 0x2c,
    SystemLookasideInformation = 0x2d,
    SystemTimeSlipNotification = 0x2e,
    SystemSessionCreate = 0x2f,
    SystemSessionDetach = 0x30,
    SystemSessionInformation = 0x31,
    SystemRangeStartInformation = 0x32,
    SystemVerifierInformation = 0x33,
    SystemVerifierThunkExtend = 0x34,
    SystemSessionProcessInformation = 0x35,
    SystemLoadGdiDriverInSystemSpace = 0x36,
    SystemNumaProcessorMap = 0x37,
    SystemPrefetcherInformation = 0x38,
    SystemExtendedProcessInformation = 0x39,
    SystemRecommendedSharedDataAlignment = 0x3a,
    SystemComPlusPackage = 0x3b,
    SystemNumaAvailableMemory = 0x3c,
    SystemProcessorPowerInformation = 0x3d,
    SystemEmulationBasicInformation = 0x3e,
    SystemEmulationProcessorInformation = 0x3f,
    SystemExtendedHandleInformation = 0x40,
    SystemLostDelayedWriteInformation = 0x41,
    SystemBigPoolInformation = 0x42,
    SystemSessionPoolTagInformation = 0x43,
    SystemSessionMappedViewInformation = 0x44,
    SystemHotpatchInformation = 0x45,
    SystemObjectSecurityMode = 0x46,
    SystemWatchdogTimerHandler = 0x47,
    SystemWatchdogTimerInformation = 0x48,
    SystemLogicalProcessorInformation = 0x49,
    SystemWow64SharedInformationObsolete = 0x4a,
    SystemRegisterFirmwareTableInformationHandler = 0x4b,
    SystemFirmwareTableInformation = 0x4c,
    SystemModuleInformationEx = 0x4d,
    SystemVerifierTriageInformation = 0x4e,
    SystemSuperfetchInformation = 0x4f,
    SystemMemoryListInformation = 0x50,
    SystemFileCacheInformationEx = 0x51,
    SystemThreadPriorityClientIdInformation = 0x52,
    SystemProcessorIdleCycleTimeInformation = 0x53,
    SystemVerifierCancellationInformation = 0x54,
    SystemProcessorPowerInformationEx = 0x55,
    SystemRefTraceInformation = 0x56,
    SystemSpecialPoolInformation = 0x57,
    SystemProcessIdInformation = 0x58,
    SystemErrorPortInformation = 0x59,
    SystemBootEnvironmentInformation = 0x5a,
    SystemHypervisorInformation = 0x5b,
    SystemVerifierInformationEx = 0x5c,
    SystemTimeZoneInformation = 0x5d,
    SystemImageFileExecutionOptionsInformation = 0x5e,
    SystemCoverageInformation = 0x5f,
    SystemPrefetchPatchInformation = 0x60,
    SystemVerifierFaultsInformation = 0x61,
    SystemSystemPartitionInformation = 0x62,
    SystemSystemDiskInformation = 0x63,
    SystemProcessorPerformanceDistribution = 0x64,
    SystemNumaProximityNodeInformation = 0x65,
    SystemDynamicTimeZoneInformation = 0x66,
    SystemCodeIntegrityInformation = 0x67,
    SystemProcessorMicrocodeUpdateInformation = 0x68,
    SystemProcessorBrandString = 0x69,
    SystemVirtualAddressInformation = 0x6a,
    SystemLogicalProcessorAndGroupInformation = 0x6b,
    SystemProcessorCycleTimeInformation = 0x6c,
    SystemStoreInformation = 0x6d,
    SystemRegistryAppendString = 0x6e,
    SystemAitSamplingValue = 0x6f,
    SystemVhdBootInformation = 0x70,
    SystemCpuQuotaInformation = 0x71,
    SystemNativeBasicInformation = 0x72,
    SystemErrorPortTimeouts = 0x73,
    SystemLowPriorityIoInformation = 0x74,
    SystemBootEntropyInformation = 0x75,
    SystemVerifierCountersInformation = 0x76,
    SystemPagedPoolInformationEx = 0x77,
    SystemSystemPtesInformationEx = 0x78,
    SystemNodeDistanceInformation = 0x79,
    SystemAcpiAuditInformation = 0x7a,
    SystemBasicPerformanceInformation = 0x7b,
    SystemQueryPerformanceCounterInformation = 0x7c,
    SystemSessionBigPoolInformation = 0x7d,
    SystemBootGraphicsInformation = 0x7e,
    SystemScrubPhysicalMemoryInformation = 0x7f,
    SystemBadPageInformation = 0x80,
    SystemProcessorProfileControlArea = 0x81,
    SystemCombinePhysicalMemoryInformation = 0x82,
    SystemEntropyInterruptTimingInformation = 0x83,
    SystemConsoleInformation = 0x84,
    SystemPlatformBinaryInformation = 0x85,
    SystemThrottleNotificationInformation = 0x86,
    SystemHypervisorProcessorCountInformation = 0x87,
    SystemDeviceDataInformation = 0x88,
    SystemDeviceDataEnumerationInformation = 0x89,
    SystemMemoryTopologyInformation = 0x8a,
    SystemMemoryChannelInformation = 0x8b,
    SystemBootLogoInformation = 0x8c,
    SystemProcessorPerformanceInformationEx = 0x8d,
    SystemSpare0 = 0x8e,
    SystemSecureBootPolicyInformation = 0x8f,
    SystemPageFileInformationEx = 0x90,
    SystemSecureBootInformation = 0x91,
    SystemEntropyInterruptTimingRawInformation = 0x92,
    SystemPortableWorkspaceEfiLauncherInformation = 0x93,
    SystemFullProcessInformation = 0x94,
    SystemKernelDebuggerInformationEx = 0x95,
    SystemBootMetadataInformation = 0x96,
    SystemSoftRebootInformation = 0x97,
    SystemElamCertificateInformation = 0x98,
    SystemOfflineDumpConfigInformation = 0x99,
    SystemProcessorFeaturesInformation = 0x9a,
    SystemRegistryReconciliationInformation = 0x9b,
    MaxSystemInfoClass = 0x9c,
} SYSTEM_INFORMATION_CLASS;
typedef struct _SYSTEM_MODULE_ENTRY {
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR FullPathName[256];
} SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;
typedef struct _SYSTEM_MODULE_INFORMATION {
    ULONG Count;
    SYSTEM_MODULE_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;
typedef struct _SYSTEM_THREAD_INFORMATION
{
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    KPRIORITY Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    ULONG ThreadState;
    KWAIT_REASON WaitReason;
}SYSTEM_THREAD_INFORMATION, * PSYSTEM_THREAD_INFORMATION;
typedef struct _SYSTEM_PROCESS_INFO
{
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER WorkingSetPrivateSize;
    ULONG HardFaultCount;
    ULONG NumberOfThreadsHighWatermark;
    ULONGLONG CycleTime;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    ULONG_PTR UniqueProcessKey;
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
    LARGE_INTEGER ReadOperationCount;
    LARGE_INTEGER WriteOperationCount;
    LARGE_INTEGER OtherOperationCount;
    LARGE_INTEGER ReadTransferCount;
    LARGE_INTEGER WriteTransferCount;
    LARGE_INTEGER OtherTransferCount;
    SYSTEM_THREAD_INFORMATION Threads[1];
}SYSTEM_PROCESS_INFO, * PSYSTEM_PROCESS_INFO;

extern "C"
{
    NTKERNELAPI NTSTATUS NTAPI ZwQuerySystemInformation(
        ULONG SystemInformationClass,
        PVOID SystemInformation,
        ULONG SystemInformationLength,
        PULONG ReturnLength
    );

    NTKERNELAPI PVOID NTAPI RtlFindExportedRoutineByName(
        _In_ PVOID ImageBase,
        _In_ PCCH RoutineNam
    );

    NTKERNELAPI PVOID PsGetProcessSectionBaseAddress(
        PEPROCESS Process
    );

    //phy and PhysicalLength must be 0x1000 align
    NTKERNELAPI NTSTATUS MmMarkPhysicalMemoryAsBad(
        IN PPHYSICAL_ADDRESS phy,
        IN OUT PLARGE_INTEGER PhysicalLength
    );

    NTKERNELAPI NTSTATUS MmMarkPhysicalMemoryAsGood(
        IN PPHYSICAL_ADDRESS phy,
        IN OUT PLARGE_INTEGER PhysicalLength
    );

    NTKERNELAPI NTSTATUS NTAPI MmCopyVirtualMemory(
        PEPROCESS SourceProcess,
        PVOID SourceAddress,
        PEPROCESS TargetProcess,
        PVOID TargetAddress,
        SIZE_T BufferSize,
        KPROCESSOR_MODE PreviousMode,
        PSIZE_T ReturnSize
    );
}

NTSTATUS getKernelModuleByName(const char* moduleName, PVOID* moduleStart, size_t* moduleSize);

NTSTATUS GetProcessIdByProcessName(LPWCH ImageName, OUT HANDLE* OutPid);

PUCHAR FindPatternSect(PVOID ModBase, const char* SectName, const char* Pattern);

PUCHAR FindPatternRange(PVOID Start, u32 size, const char* Pattern);

NTSTATUS RtlSuperCopyMemory(IN VOID* Dst, IN CONST VOID* Src, IN ULONG Length);

NTSTATUS RtlSuperWriteMemoryPipi(IN VOID* Dst, IN CONST VOID* Src, IN ULONG Length);

void Log2File(const char* format, ...);

BOOLEAN IsKernelDebuggerPresent();

PVOID GetProcAddress(PVOID ModBase, const char* Name);

NTSTATUS WritePhysicalSafe2(DWORD64 PhysicalAddress, pv Buffer, u64 Length);

inl void KSleep(u64 ms)
{
    LARGE_INTEGER delay;
    delay.QuadPart = -1000 * ms;
    KeDelayExecutionThread(KernelMode, TRUE, &delay);
}

///**
// * The 32-bit EFLAGS register contains a group of status flags, a control flag, and a group of system flags. The status
// * flags (bits 0, 2, 4, 6, 7, and 11) of the EFLAGS register indicate the results of arithmetic instructions, such as the
// * ADD, SUB, MUL, and DIV instructions.
// * The system flags and IOPL field in the EFLAGS register control operating-system or executive operations.
// *
// * @see Vol1[3.4.3(EFLAGS)] (reference)
// */
//typedef union
//{
//    struct
//    {
//        /**
//         * @brief Carry flag
//         *
//         * [Bit 0] Set if an arithmetic operation generates a carry or a borrow out of the mostsignificant bit of the result;
//         * cleared otherwise. This flag indicates an overflow condition for unsigned-integer arithmetic. It is also used in
//         * multiple-precision arithmetic.
//         */
//        UINT32 CarryFlag : 1;
//
//        /**
//         * [Bit 1] Reserved - always 1
//         */
//        UINT32 ReadAs1 : 1;
//
//        /**
//         * @brief Parity flag
//         *
//         * [Bit 2] Set if the least-significant byte of the result contains an even number of 1 bits; cleared otherwise.
//         */
//        UINT32 ParityFlag : 1;
//        UINT32 Reserved1 : 1;
//
//        /**
//         * @brief Auxiliary Carry flag
//         *
//         * [Bit 4] Set if an arithmetic operation generates a carry or a borrow out of bit 3 of the result; cleared otherwise. This
//         * flag is used in binary-coded decimal (BCD) arithmetic.
//         */
//        UINT32 AuxiliaryCarryFlag : 1;
//        UINT32 Reserved2 : 1;
//
//        /**
//         * @brief Zero flag
//         *
//         * [Bit 6] Set if the result is zero; cleared otherwise.
//         */
//        UINT32 ZeroFlag : 1;
//
//        /**
//         * @brief Sign flag
//         *
//         * [Bit 7] Set equal to the most-significant bit of the result, which is the sign bit of a signed integer. (0 indicates a
//         * positive value and 1 indicates a negative value.)
//         */
//        UINT32 SignFlag : 1;
//
//        /**
//         * @brief Trap flag
//         *
//         * [Bit 8] Set to enable single-step mode for debugging; clear to disable single-step mode.
//         */
//        UINT32 TrapFlag : 1;
//
//        /**
//         * @brief Interrupt enable flag
//         *
//         * [Bit 9] Controls the response of the processor to maskable interrupt requests. Set to respond to maskable interrupts;
//         * cleared to inhibit maskable interrupts.
//         */
//        UINT32 InterruptEnableFlag : 1;
//
//        /**
//         * @brief Direction flag
//         *
//         * [Bit 10] Controls string instructions (MOVS, CMPS, SCAS, LODS, and STOS). Setting the DF flag causes the string
//         * instructions to auto-decrement (to process strings from high addresses to low addresses). Clearing the DF flag causes
//         * the string instructions to auto-increment (process strings from low addresses to high addresses).
//         */
//        UINT32 DirectionFlag : 1;
//
//        /**
//         * @brief Overflow flag
//         *
//         * [Bit 11] Set if the integer result is too large a positive number or too small a negative number (excluding the
//         * sign-bit) to fit in the destination operand; cleared otherwise. This flag indicates an overflow condition for
//         * signed-integer (two's complement) arithmetic.
//         */
//        UINT32 OverflowFlag : 1;
//
//        /**
//         * @brief I/O privilege level field
//         *
//         * [Bits 13:12] Indicates the I/O privilege level of the currently running program or task. The current privilege level
//         * (CPL) of the currently running program or task must be less than or equal to the I/O privilege level to access the I/O
//         * address space. The POPF and IRET instructions can modify this field only when operating at a CPL of 0.
//         */
//        UINT32 IoPrivilegeLevel : 2;
//
//        /**
//         * @brief Nested task flag
//         *
//         * [Bit 14] Controls the chaining of interrupted and called tasks. Set when the current task is linked to the previously
//         * executed task; cleared when the current task is not linked to another task.
//         */
//        UINT32 NestedTaskFlag : 1;
//        UINT32 Reserved3 : 1;
//
//        /**
//         * @brief Resume flag
//         *
//         * [Bit 16] Controls the processor's response to debug exceptions.
//         */
//        UINT32 ResumeFlag : 1;
//
//        /**
//         * @brief Virtual-8086 mode flag
//         *
//         * [Bit 17] Set to enable virtual-8086 mode; clear to return to protected mode without virtual-8086 mode semantics.
//         */
//        UINT32 Virtual8086ModeFlag : 1;
//
//        /**
//         * @brief Alignment check (or access control) flag
//         *
//         * [Bit 18] If the AM bit is set in the CR0 register, alignment checking of user-mode data accesses is enabled if and only
//         * if this flag is 1. If the SMAP bit is set in the CR4 register, explicit supervisor-mode data accesses to user-mode pages
//         * are allowed if and only if this bit is 1.
//         *
//         * @see Vol3A[4.6(ACCESS RIGHTS)]
//         */
//        UINT32 AlignmentCheckFlag : 1;
//
//        /**
//         * @brief Virtual interrupt flag
//         *
//         * [Bit 19] Virtual image of the IF flag. Used in conjunction with the VIP flag. (To use this flag and the VIP flag the
//         * virtual mode extensions are enabled by setting the VME flag in control register CR4.)
//         */
//        UINT32 VirtualInterruptFlag : 1;
//
//        /**
//         * @brief Virtual interrupt pending flag
//         *
//         * [Bit 20] Set to indicate that an interrupt is pending; clear when no interrupt is pending. (Software sets and clears
//         * this flag; the processor only reads it.) Used in conjunction with the VIF flag.
//         */
//        UINT32 VirtualInterruptPendingFlag : 1;
//
//        /**
//         * @brief Identification flag
//         *
//         * [Bit 21] The ability of a program to set or clear this flag indicates support for the CPUID instruction.
//         */
//        UINT32 IdentificationFlag : 1;
//        UINT32 Reserved4 : 10;
//    };
//
//    UINT32 AsUInt;
//} EFLAGS;
//
///**
// * The 64-bit RFLAGS register contains a group of status flags, a control flag, and a group of system flags in 64-bit mode.
// * The upper 32 bits of RFLAGS register is reserved. The lower 32 bits of RFLAGS is the same as EFLAGS.
// *
// * @see EFLAGS
// * @see Vol1[3.4.3.4(RFLAGS Register in 64-Bit Mode)] (reference)
// */
//typedef union
//{
//    struct
//    {
//        /**
//         * @brief Carry flag
//         *
//         * [Bit 0] See the description in EFLAGS.
//         */
//        UINT64 CarryFlag : 1;
//
//        /**
//         * [Bit 1] Reserved - always 1
//         */
//        UINT64 ReadAs1 : 1;
//
//        /**
//         * @brief Parity flag
//         *
//         * [Bit 2] See the description in EFLAGS.
//         */
//        UINT64 ParityFlag : 1;
//        UINT64 Reserved1 : 1;
//
//        /**
//         * @brief Auxiliary Carry flag
//         *
//         * [Bit 4] See the description in EFLAGS.
//         */
//        UINT64 AuxiliaryCarryFlag : 1;
//        UINT64 Reserved2 : 1;
//
//        /**
//         * @brief Zero flag
//         *
//         * [Bit 6] See the description in EFLAGS.
//         */
//        UINT64 ZeroFlag : 1;
//
//        /**
//         * @brief Sign flag
//         *
//         * [Bit 7] See the description in EFLAGS.
//         */
//        UINT64 SignFlag : 1;
//
//        /**
//         * @brief Trap flag
//         *
//         * [Bit 8] See the description in EFLAGS.
//         */
//        UINT64 TrapFlag : 1;
//
//        /**
//         * @brief Interrupt enable flag
//         *
//         * [Bit 9] See the description in EFLAGS.
//         */
//        UINT64 InterruptEnableFlag : 1;
//
//        /**
//         * @brief Direction flag
//         *
//         * [Bit 10] See the description in EFLAGS.
//         */
//        UINT64 DirectionFlag : 1;
//
//        /**
//         * @brief Overflow flag
//         *
//         * [Bit 11] See the description in EFLAGS.
//         */
//        UINT64 OverflowFlag : 1;
//
//        /**
//         * @brief I/O privilege level field
//         *
//         * [Bits 13:12] See the description in EFLAGS.
//         */
//        UINT64 IoPrivilegeLevel : 2;
//
//        /**
//         * @brief Nested task flag
//         *
//         * [Bit 14] See the description in EFLAGS.
//         */
//        UINT64 NestedTaskFlag : 1;
//        UINT64 Reserved3 : 1;
//
//        /**
//         * @brief Resume flag
//         *
//         * [Bit 16] See the description in EFLAGS.
//         */
//        UINT64 ResumeFlag : 1;
//
//        /**
//         * @brief Virtual-8086 mode flag
//         *
//         * [Bit 17] See the description in EFLAGS.
//         */
//        UINT64 Virtual8086ModeFlag : 1;
//
//        /**
//         * @brief Alignment check (or access control) flag
//         *
//         * [Bit 18] See the description in EFLAGS.
//         *
//         * @see Vol3A[4.6(ACCESS RIGHTS)]
//         */
//        UINT64 AlignmentCheckFlag : 1;
//
//        /**
//         * @brief Virtual interrupt flag
//         *
//         * [Bit 19] See the description in EFLAGS.
//         */
//        UINT64 VirtualInterruptFlag : 1;
//
//        /**
//         * @brief Virtual interrupt pending flag
//         *
//         * [Bit 20] See the description in EFLAGS.
//         */
//        UINT64 VirtualInterruptPendingFlag : 1;
//
//        /**
//         * @brief Identification flag
//         *
//         * [Bit 21] See the description in EFLAGS.
//         */
//        UINT64 IdentificationFlag : 1;
//        UINT64 Reserved4 : 42;
//    };
//
//    UINT64 AsUInt;
//} RFLAGS;
//
```

`asm.asm`:

```asm
.code
extern CalledHookTimes:dq
extern CheckCallCtx:PROC
extern ExceptionHandler:PROC
extern FindExceptionRecord:PROC
extern KeBugCheck:PROC
extern OldHalQueryCounter:dq

HalpTscQueryCounterOrdered PROC

	rdtscp
	shl      rdx, 20h
	or       rax, rdx
	ret
HalpTscQueryCounterOrdered ENDP;

;r13 = exception context
HookPosition PROC

	push rcx
	push rdx
    sub rsp,0E8h  

    lea rax, CalledHookTimes
    lock inc qword ptr [rax]
       
	call CheckCallCtx
	cmp rax,1
	jne filt
    
    ;to do clear KiFreezeFlag
    ;fix: not neccessary to clear since no other function use it

    ;is an exception
	call FindExceptionRecord
    cmp rax,0
    je dbgbreak

	mov rcx, rax
	mov rdx, r13
	call ExceptionHandler
    
    ; still here so it's a debug break or something

dbgbreak:
    xor rcx, rcx
    call KeBugCheck

filt:
    add rsp, 0E8h  
	pop rdx
	pop rcx
	;jmp HalpTscQueryCounterOrdered

    jmp [OldHalQueryCounter]

HookPosition ENDP

CalloutReturn proc
    ;push stack segment selector
    mov eax, ss
    push rax

    ;push stack pointer
    mov rax, [rcx + 0]
    push rax

    ;push arithmetic/system flags   rflags
    mov rax, [rcx + 78h]    
    ;xor rax, 200h ; enable interrupts
    push rax

    ;push code segment selector
    mov eax, cs
    push rax

    ;push instruction pointer
    mov rax, [rcx + 8]
    push rax

    ;set arguments

    mov rdx, [rcx + 18h]
    mov r8,  [rcx + 20h]
    mov r9,  [rcx + 28h]
    mov rax, [rcx + 30h]

    mov r12, [rcx + 38h]
    mov r13, [rcx + 40h]
    mov r14, [rcx + 48h]
    mov r15, [rcx + 50h]
    mov rdi, [rcx + 58h]
    mov rsi, [rcx + 60h]
    mov rbx, [rcx + 68h]
    mov rbp, [rcx + 70h]

    mov rcx, [rcx + 10h]

    ;clear trace
    xor rax, rax

    ;goto code
    iretq
CalloutReturn endp

GetR12 proc
    mov rax,r12
    ret
GetR12 endp

SetR12 proc
    mov r12,rcx
    ret
SetR12 endp

GetR13 proc
    mov rax,r13
    ret
GetR13 endp

SetR13 proc
    mov r13,rcx
    ret
SetR13 endp

end
```