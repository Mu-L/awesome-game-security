Project Path: arc_gmh5225_ida_medigate_l6d47z5t

Source Tree:

```txt
arc_gmh5225_ida_medigate_l6d47z5t
├── README.md
├── __init__.py
├── cpp_plugin
│   ├── __init__.py
│   ├── hooks.py
│   └── plugin.py
├── cpp_utils.py
├── decompiler_utils.py
├── examples
│   ├── a.cpp
│   ├── a32_stripped
│   └── a64_stripped
├── images
│   ├── f_b_after.png
│   ├── f_b_before.png
│   ├── f_b_choose_vtable.png
│   ├── f_b_union_choose.png
│   ├── f_b_xrefs.png
│   ├── main_after.png
│   ├── main_before.png
│   └── vtable_c_z.png
├── medigate_cpp_plugin.py
├── plugins
│   └── ida-referee
│       ├── LICENSE
│       ├── README.md
│       └── referee.py
├── rtti_parser.py
└── utils.py

```

`README.md`:

```md
ida_medigate C++ plugin for IDA Pro

# 

[TOC]

# Motivation And Background

Reverse engineering of compiled C++  code is not fun. Static Reverse engineering of compiled C++ code is **frustrating.** The main reason which makes it so hard is virtual functions. In contrast to compiled C code, there is no clear code flow. Too many times one can spend much time trying to understand what is the next virtual function is called, rather than just see the function like in compiled C code.

When one investigates a virtual function, the amount of time he or she needs to effort in order to find its xref, is not sense.

After too many C++ RE projects, I gave up and decided I need a flexible (Python) and stable (which I can easily maintain) tool for this type of research. Most of this plugin was written in January 2018, and recently I decided to clean the dust and add support of the new IDA (7.2) classes support.

This plugin isn't intended to work always "out of the box", but to be another tool for the reverser.

# **About**

The plugin consists of two parts:

1. Implementation of C++ classes and polymorphism over IDA
2. A RTTI parser which rebuilds the classes hierarchy

This first part is not dependent on the second part, so it possible to use the plugin to reverse engineering a binary that doesn't contain RTTI, by defining those classes manually based on the plugin's API.

What makes the plugin unique is the fact it uses the same environment the researcher is already familiar with, and doesn't add any new menu or object, and based on the known IDA building blocks (structure, union, type for structure's members, etc) - **This enable the plugin to support C++ abstracting for every architecture IDA supports**.

**Note:** The RTTI parser parses x86/x64 g++ RTTI, but its structure enables to add support for more architectures and compilers **easily.**

# Requirements

* IDA 7.5 SP  + Hex-Rays Decompiler + Python 3
  * This version we partially support disassembly with no decompiler
* Linux - There is no anything that really depends on Linux, but the plugin was tested on IDA Linux version.
* [ida-referee](https://github.com/joeleong/ida-referee): We use this useful plugin to save xrefs for struct's members uses in the decompiler. The original plugin doesn't support Python3 so we port it (under the directory `plugins/`)

# Installation:

Copy `medigate_cpp_plugin` to the `plugins` directory and add the source code path to your `idapythonrc.py` file

Copy `plugins/ida-referee/referee.py`to the same directory.

# Features:

Assuming the binary original source code is the following (`examples/a.cpp`):

```c++

using namespace std;

class A {
	public:
	int x_a;
	virtual int f_a()=0;
};

class B : public A{ 
	public:
	int x_b;
	int f_a(){x_a = 0;}
	virtual int f_b(){this->f_a();}
};

class Z {
	public:
	virtual int f_z1(){cout << "f_z1";}
	virtual int f_z2(){cout << "f_z2";}
};

class C: public B, public Z{
	public:
    int f_a(){x_a = 5;}
	int x_c;
	int f_c(){x_c = 0;}
	virtual int f_z1(){cout << "f_z3";}
};


int main()
{
	C *c = new C();
    c->f_a();
    c->f_b();
    c->f_z1();
    c->f_z2();
    
	return 0;
}
```

The binary is stripped but contains RTTI.

## RTTI Classes Hierarchy Rebuilding

When we just load the binary, the `main` function (`sub_84D` in the 32 bit version) looks like:

![](images/main_before.png)

Initiate the g++ RTTI parser and run it, using:

`from ida_medigate.rtti_parser import GccRTTIParser`

`GccRTTIParser.init_parser()` 

`GccRTTIParser.build_all()`

Now refresh struct C (see Remarks section), cast `v0` to be `C *`, decompile again:

![](images/main_after.png)

## Manual Classes Hierarchy Rebuilding

For cases that there are no RTTI, our infrastructure still enables to manually define c++ class. For the same example (examples/a32_stripped) you can create manually struct B, then select it's virtual table and type



![](images/f_b_choose_vtable.png)

`from ida_medigate import cpp_utils`

`cpp_utils.make_vtable("B")`

`make_vtable` can also get `vtable_ea` and `vtable_ea_stop` instead of the selected area.

Then create struct C, and apply the inheritance:

`cpp_utils.add_baseclass("C", "B")`

Now you can rebuild class C vtable by selecting it and typing:

`cpp_utils.make_vtable("C")`

Add structure Z, rebuild its vtable too, and now is the cool part:

`cpp_utils.add_baseclass("C", "Z", 0x0c, to_update=True)` which apply C inheritance of Z at offset 0x0c and refresh the struct too (see remarks).

The last thing remained is too update the second vtable of C, the one that implements the interface of Z. Mark this vtable and type:

`cpp_utils.make_vtable("C", offset_in_class=0x0c)`

ida_medigate knows that this vtable is the vtable of class Z and the result will be:

![](images/vtable_c_z.png)

The final result is the same like in the RTTI case:

![](images/main_after.png)

## Synchronization between functions and vtable members

When new a vtable struct is created (by the RTTI parser of manually by the user) each function which hasn't changed yet is renamed, decompiled, and set its first argument to `this`.

Double click on a structure's member which corresponds to such a function will navigate to the function, so the user can read the C++ code flow in a convenient way!

Every name or type changing of a function or its corresponding function pointer member in vtables is hooked and synchronized among all of them. This means for example, the user could change the vtable member type through the decompiler window, and this new type (prototype) will be applied on the target function too.

## Convenient reading of polymorphic code

In line 15 at the previous image, there is a call to B::sub_9A8 (B::f_b in the source code). This function argument is `B *`:

![](images/f_b_before.png)

But, this function also might be called by a `C` instance (up-casting). we want to see the virtual function it's instance would call. Assume there are many potential derived classes so casting `this` to `C *` not always possible. For that reason, we implement a union for each baseclass that has sons that have a different virtual table. One can choose to show a different derived virtual table of `B `'s derivatives by click alt+y (the shortcut for choosing different union member):

![](images/f_b_union_choose.png)

so ultimately we can "cast" only specific calls to different virtual function:

![](images/f_b_after.png)

## **Virtual Functions xref**

The holy-grail of frustrated C++ reverse engineers. We maintain xrefs from virtual functions to the vtable struct's members which represents them!

Combining this with `ida-referee` enables us to track all the xrefs of virtual functions calls!

![](images/f_b_xrefs.png)

*A limitation: we can only track virtual calls which already been decompiled. Fortunately, the auto-analysis knows to populate an argument type between functions, so with the iterative process of casting more arguments->decompiling all the relevant functions -> reading the code again and casting more arguments (...) this ability becomes really **powerful!***

# Remarks

* The way we mark structure members as subclasses in IDAPython isn't synchronized right away to the IDB. The hack we do is to edit the structure so a synchronization will be triggered. You also may use

  `utils.refresh_struct(struct_ptr)`

  which adds a dummy field at the end of the struct and then undefined it.
```

`__init__.py`:

```py
__all__ = ["utils", "rtti_parser", "cpp_utils", "decompiler_utils"]

```

`cpp_plugin/hooks.py`:

```py
import logging
import ida_frame
import ida_funcs
import ida_hexrays
import ida_idp
import ida_kernwin
import ida_nalt
import ida_name
import ida_struct
import idaapi
import idc
from idc import BADADDR
from .. import cpp_utils, utils


logging.basicConfig(
    filename="/tmp/cpp_plugin.log",
    filemode="a",
    level=logging.DEBUG,
    format="%(asctime)s - %(levelname)s - %(message)s",
)


class CPPHooks(ida_idp.IDB_Hooks):
    def __init__(self, is_decompiler_on):
        super(CPPHooks, self).__init__()
        self.is_decompiler_on = is_decompiler_on

    def renamed(self, ea, new_name, local_name):
        if utils.is_func(ea):
            func, args_list = cpp_utils.post_func_name_change(new_name, ea)
            self.unhook()
            for args in args_list:
                func(*args)
            self.hook()
        return 0

    def func_updated(self, pfn):
        func, args_list = cpp_utils.post_func_type_change(pfn)
        self.unhook()
        for args in args_list:
            func(*args)
        self.hook()
        return 0

    def renaming_struc_member(self, sptr, mptr, newname):
        if sptr.is_frame():
            return 0
        cpp_utils.post_struct_member_name_change(mptr, newname)
        return 0

    def struc_member_changed(self, sptr, mptr):
        cpp_utils.post_struct_member_type_change(mptr)
        return 0

    def ti_changed(self, ea, typeinf, fnames):
        if self.is_decompiler_on:
            res = ida_struct.get_member_by_id(ea)
            if res is not None:
                m, name, sptr = res
                if sptr.is_frame():
                    func = ida_funcs.get_func(ida_frame.get_func_by_frame(sptr.id))
                    if func is not None:
                        return self.func_updated(func)
            elif utils.is_func(ea):
                return self.func_updated(ida_funcs.get_func(ea))
        return 0


class CPPUIHooks(ida_kernwin.View_Hooks):
    def view_dblclick(self, viewer, point):
        widget_type = ida_kernwin.get_widget_type(viewer)
        if not (widget_type == 48 or widget_type == 28):
            return
        # Decompiler or Structures window
        func_cand_name = None
        place, x, y = ida_kernwin.get_custom_viewer_place(viewer, False)
        if place.name() == "structplace_t":  # Structure window:
            structplace = ida_kernwin.place_t_as_structplace_t(place)
            if structplace is not None:
                s = ida_struct.get_struc(ida_struct.get_struc_by_idx(structplace.idx))
                if s:
                    member = ida_struct.get_member(s, structplace.offset)
                    if member:
                        func_cand_name = ida_struct.get_member_name(member.id)
        if func_cand_name is None:
            line = utils.get_curline_striped_from_viewer(viewer)
            func_cand_name = cpp_utils.find_valid_cppname_in_line(line, x)
        if func_cand_name is not None:
            func_cand_ea = ida_name.get_name_ea(BADADDR, func_cand_name)
            if func_cand_ea is not None and utils.is_func(func_cand_ea):
                idc.jumpto(func_cand_ea)


class Polymorphism_fixer_visitor_t(ida_hexrays.ctree_visitor_t):
    def __init__(self, cfunc):
        ida_hexrays.ctree_visitor_t.__init__(self, ida_hexrays.CV_PARENTS)
        self.cfunc = cfunc
        self.counter = 0
        self.selections = []

    def get_vtables_union_name(self, expr):
        if expr.op != ida_hexrays.cot_memref:
            return None
        typeinf = expr.type
        if typeinf is None:
            return None
        if not typeinf.is_union():
            return None
        union_name = typeinf.get_type_name()
        if not cpp_utils.is_vtables_union_name(union_name):
            return None
        return union_name

    def build_classes_chain(self, expr):
        chain = []
        n_expr = expr.x
        while n_expr.op == ida_hexrays.cot_memref:
            chain.insert(0, n_expr.type.get_type_name())
            n_expr = n_expr.x
        chain.insert(0, n_expr.type.get_type_name())
        if n_expr.op == ida_hexrays.cot_memptr:
            chain.insert(0, n_expr.x.type.get_pointed_object().get_type_name())
        elif n_expr.op == ida_hexrays.cot_idx:
            logging.debug("encountered idx, skipping")
            return None
        return chain

    def find_best_member(self, chain, union_name):
        for cand in chain:
            result = ida_struct.get_member_by_fullname(union_name + "." + cand)
            if result:
                m, s = result
                logging.debug("Found class: %s, offset=%d", cand, m.soff)
                return m
        return None

    def get_vtable_sptr(self, m):
        vtable_type = utils.get_member_tinfo(m)
        if not (vtable_type and vtable_type.is_ptr()):
            logging.debug("vtable_type isn't ptr %s", vtable_type)
            return None

        vtable_struc_typeinf = vtable_type.get_pointed_object()
        if not (vtable_struc_typeinf and vtable_struc_typeinf.is_struct()):
            logging.debug("vtable isn't struct (%s)", vtable_struc_typeinf.dstr())
            return None

        vtable_struct_name = vtable_struc_typeinf.get_type_name()
        vtable_sptr = utils.get_sptr_by_name(vtable_struct_name)
        if vtable_sptr is None:
            logging.debug(
                "0x%x: Oh no %s is not a valid struct",
                self.cfunc.entry_ea,
                vtable_struct_name,
            )
            return None

        return vtable_sptr

    def get_ancestors(self):
        vtable_expr = self.parents.back().cexpr
        if vtable_expr.op not in (ida_hexrays.cot_memptr, ida_hexrays.cot_memref):
            return None

        if self.parents.size() < 2:
            logging.debug("parents size less than 2 (%d)", self.parents.size())
            return None

        idx_cexpr = None
        funcptr_parent = None
        funcptr_item = self.parents.at(self.parents.size() - 2)
        if not funcptr_item.is_expr():
            logging.debug(
                "funcptr_item is not expr!: %s %s %d",
                type(funcptr_item),
                funcptr_item.is_expr(),
                funcptr_item.op,
            )
            return None
        funcptr_expr = funcptr_item.cexpr
        if funcptr_expr.op == ida_hexrays.cot_idx:
            idx_cexpr = funcptr_expr
            if self.parents.size() < 4:
                logging.debug(
                    "there is idx but parents size less than 3 (%d)",
                    self.parents.size(),
                )
                return None

            funcptr_expr = self.parents.at(self.parents.size() - 3)
            if not funcptr_expr.is_expr():
                logging.debug("funcptr isn't expr")
                return None
            funcptr_expr = funcptr_expr.cexpr
            funcptr_parent = self.parents.at(self.parents.size() - 4)
            if not funcptr_parent.is_expr():
                logging.debug("funcptr_parent isn't expr")
                return None
            funcptr_parent = funcptr_parent.cexpr
        if funcptr_expr.op not in (ida_hexrays.cot_memptr, ida_hexrays.cot_memref):

            logging.debug("funcptr_expr isn't -> (%s)", funcptr_expr.opname)
            return None

        return funcptr_parent, funcptr_expr, idx_cexpr, vtable_expr

    def fix_member_idx(self, idx_cexpr):
        num = 0
        if idx_cexpr:
            # wrong vtable*, so it might be too short struct, like:
            #   .vtable.PdmAcqServiceIf[1].___cxa_pure_virtual_2
            if idx_cexpr.y.op != ida_hexrays.cot_num:
                logging.debug(
                    "0x%x: idx doesn't contains a num but %s",
                    self.cfunc.entry_ea,
                    idx_cexpr.y.opname,
                )
                return -1
            num = idx_cexpr.y.get_const_value()
            if not (idx_cexpr.type and idx_cexpr.type.is_struct()):
                logging.debug(
                    "0x%x idx type isn't struct %s", self.cfunc.entry_ea, idx_cexpr.type
                )
                return -1
            idx_struct = utils.get_struc_from_tinfo(idx_cexpr.type)
            if idx_struct is None:
                logging.debug(
                    "0x%x idx type isn't pointing to struct %s",
                    self.cfunc.entry_ea,
                    idx_cexpr.type,
                )
                return -1
            struct_size = ida_struct.get_struc_size(idx_struct)
            num *= struct_size
        return num

    def get_vtable_member_type(self, vtable_sptr, offset):
        vtable_struct_name = ida_struct.get_struc_name(vtable_sptr.id)
        try:
            funcptr_member = ida_struct.get_member(vtable_sptr, offset)
        except TypeError as e:
            logging.exception("0x%x: bad offset: 0x%x", self.cfunc.entry_ea, offset)
            return None

        if funcptr_member is None:
            logging.debug(
                "0x%x:  %s.%d is not a valid struct member",
                self.cfunc.entry_ea,
                vtable_struct_name,
                offset,
            )
            return None

        funcptr_member_type = utils.get_member_tinfo(funcptr_member)
        if not funcptr_member_type.is_funcptr():
            logging.debug(
                "0x%x: member type (%s) isn't funcptr!",
                self.cfunc.entry_ea,
                funcptr_member_type.dstr(),
            )
            return None

        return funcptr_member_type

    def find_funcptr(self, m):
        ancestors = self.get_ancestors()
        if ancestors is None:
            return None
        funcptr_parent, funcptr_expr, idx_cexpr, vtable_expr = ancestors

        vtable_sptr = self.get_vtable_sptr(m)
        if vtable_sptr is None:
            return None
        offset = self.fix_member_idx(idx_cexpr)
        if offset == -1:
            return None
        funcptr_member_type = self.get_vtable_member_type(
            vtable_sptr, funcptr_expr.m + offset
        )
        return funcptr_member_type

    def dump_expr(self, e):
        logging.debug("dump: %s", e.opname)
        while e.op in [
            ida_hexrays.cot_memref,
            ida_hexrays.cot_memptr,
            ida_hexrays.cot_cast,
            ida_hexrays.cot_call,
        ]:
            if e.op in [ida_hexrays.cot_memref, ida_hexrays.cot_memptr]:
                logging.debug("(%s, %d, %s", e.opname, e.m, e.type.dstr())
            else:
                logging.debug("(%s, %s", e.opname, e.type.dstr())
            e = e.x

    def find_ea(self):
        i = self.parents.size() - 1
        parent = self.parents.at(i)
        ea = BADADDR
        while i >= 0 and (parent.is_expr() or parent.op == ida_hexrays.cit_expr):
            if parent.cexpr.ea != BADADDR:
                ea = parent.cexpr.ea
                break
            i -= 1
            parent = self.parents.at(i)
        return ea

    def visit_expr(self, expr):
        union_name = self.get_vtables_union_name(expr)
        if union_name is None:
            return 0
        logging.debug("Found union -%s", union_name)

        chain = self.build_classes_chain(expr)
        if chain is None:
            return 0

        m = self.find_best_member(chain, union_name)
        if m is None:
            return 0

        ea = self.find_ea()

        funcptr_member_type = self.find_funcptr(m)

        if ea == BADADDR:
            logging.debug("BADADDR")
            return 0
        logging.debug("Found VTABLES, ea: 0x%x", ea)
        self.selections.append((ea, m.soff, funcptr_member_type))
        return 0


class HexRaysHooks(idaapi.Hexrays_Hooks):
    def __init__(self, *args):
        idaapi.Hexrays_Hooks.__init__(self, *args)
        self.another_decompile_ea = False

    def maturity(self, cfunc, maturity):
        if maturity in [idaapi.CMAT_FINAL]:
            if self.another_decompile_ea:
                self.another_decompile_ea = None
                return 0
            # if maturity in [idaapi. CMAT_CPA]:
            # if maturity in [idaapi.CPA]:
            pfv = Polymorphism_fixer_visitor_t(cfunc)
            pfv.apply_to_exprs(cfunc.body, None)
            logging.debug("results: %s", pfv.selections)
            if pfv.selections != []:
                for ea, offset, funcptr_member_type in pfv.selections:
                    intvec = idaapi.intvec_t()
                    # TODO: Think if needed to distinguished between user
                    #   union members chooses and plugin chooses
                    if not cfunc.get_user_union_selection(ea, intvec):
                        intvec.push_back(offset)
                        cfunc.set_user_union_selection(ea, intvec)
                        if funcptr_member_type is not None:
                            ida_nalt.set_op_tinfo(ea, 0, funcptr_member_type)
                cfunc.save_user_unions()
                self.another_decompile_ea = cfunc.entry_ea

        return 0

    def refresh_pseudocode(self, vu):
        if self.another_decompile_ea:
            logging.debug("decompile again")
            ea = self.another_decompile_ea
            ida_hexrays.mark_cfunc_dirty(ea, False)
            cfunc = ida_hexrays.decompile(ea)
            self.another_decompile_ea = None
            vu.switch_to(cfunc, True)
        return 0

```

`cpp_plugin/plugin.py`:

```py
import ida_idaapi
import ida_kernwin
import idaapi
from .hooks import CPPHooks, CPPUIHooks, HexRaysHooks


class CPPPlugin(ida_idaapi.plugin_t):
    """
    This is the main class of the plugin. It subclasses plugin_t as required
    by IDA. It holds the modules of plugin, which themselves provides the
    functionality of the plugin (hooking/events, interface, networking, etc.).
    """

    # Mandatory definitions
    PLUGIN_NAME = "ida_cpp"
    PLUGIN_VERSION = "0.0.1"
    PLUGIN_AUTHORS = "Medigate"
    TOGGLE_HOTKEY = "CTRL+ALT+C"

    # These flags specify that the plugin should persist between databases
    # loading and saving, and should not have a menu entry.
    flags = ida_idaapi.PLUGIN_FIX | ida_idaapi.PLUGIN_HIDE
    comment = "CPP support plugin"
    help = ""
    wanted_name = PLUGIN_NAME
    wanted_hotkey = ""

    def __init__(self):
        print("Im up")
        self.core_hook = None
        self.gui_hook = None
        self.hexrays_hooks = None
        self.hooking = False
        self.is_decompiler_on = False

    def init(self):
        """
        This method is called when IDA is loading the plugin. It will first
        load the configuration file, then initialize all the modules.
        """
        if idaapi.init_hexrays_plugin():
            self.hexrays_hooks = HexRaysHooks()
            self.is_decompiler_on = True
        self.core_hook = CPPHooks(self.is_decompiler_on)
        self.gui_hook = CPPUIHooks()
        self.hook()
        self.install_hotkey()
        keep = ida_idaapi.PLUGIN_KEEP
        return keep

    def toggle_hooks(self):
        if self.hooking:
            self.unhook()
        else:
            self.hook()
        print("C++ plugin is now: %s" % ("On" if self.hooking else "Off"))

    def hook(self):
        if self.hexrays_hooks:
            self.hexrays_hooks.hook()
        self.core_hook.hook()
        self.gui_hook.hook()
        self.hooking = True

    def unhook(self):
        if self.hexrays_hooks:
            self.hexrays_hooks.unhook()
        self.core_hook.unhook()
        self.gui_hook.unhook()
        self.hooking = False

    def install_hotkey(self):
        ida_kernwin.add_hotkey(self.TOGGLE_HOTKEY, self.toggle_hooks)

    @classmethod
    def description(cls):
        """Return the description displayed in the console."""
        return "{} v{}".format(cls.PLUGIN_NAME, cls.PLUGIN_VERSION)

    def run(self, _):
        """
        This method is called when IDA is running the plugin as a script.
        """
        ida_kernwin.warning("IDACpp cannot be run as a script")
        return False

    def term(self):
        """
        This method is called when IDA is unloading the plugin. It will
        terminated all the modules, then save the configuration file.
        """
        self.unhook()
        idaapi.term_hexrays_plugin()

```

`cpp_utils.py`:

```py
import logging
from functools import partial

import ida_bytes
import ida_hexrays
import ida_name
import ida_struct
import ida_typeinf
import ida_xref
import idaapi
import idautils
import idc
from idaapi import BADADDR
from . import utils
from .utils import batchmode

VTABLE_KEYWORD = "vtbl"
VTABLE_UNION_KEYWORD = "VTABLES"
# VTABLES_UNION_VTABLE_FIELD_POSTFIX = "_vtable"
VTABLES_UNION_VTABLE_FIELD_POSTFIX = ""
VTABLE_DELIMITER = "__"
VTABLE_POSTFIX = "_vtbl"
VTABLE_FIELD_NAME = "__vftable"  # Name For vtable * field
VTABLE_INSTANCE_DELIMITER = VTABLE_DELIMITER
VTABLE_INSTANCE_KEYWORD = "vtable"
VTABLE_INSTANCE_POSTFIX = VTABLE_INSTANCE_DELIMITER + VTABLE_INSTANCE_KEYWORD


def get_vtable_instance_name(class_name, parent_name=None):
    name = class_name + VTABLE_INSTANCE_POSTFIX
    if parent_name is not None:
        name += VTABLE_INSTANCE_DELIMITER + parent_name
    return name


def get_base_member_name(parent_name, offset):
    return "baseclass_%x" % offset


def get_vtable_line(ea, stop_ea=None, ignore_list=None, pure_virtual_name=None):
    if ignore_list is None:
        ignore_list = []
    func_ea = utils.get_ptr(ea)
    if (
        utils.is_func(func_ea)
        and (stop_ea is None or ea < stop_ea)
        and (
            func_ea not in ignore_list
            or (
                pure_virtual_name is not None
                and idc.GetDisasm(ea).endswith(pure_virtual_name)
            )
        )
    ):
        return func_ea, ea + utils.WORD_LEN
    return None, 0


def is_valid_vtable_name(member_name):
    return VTABLE_FIELD_NAME in member_name


def is_valid_vtable_type(member, member_type):
    if member_type.is_ptr():
        struct = utils.deref_struct_from_tinfo(member_type)
        return is_struct_vtable(struct)
    return False


def is_member_vtable(member):
    member_type = utils.get_member_tinfo(member)
    member_name = ida_struct.get_member_name(member.id)
    if not is_valid_vtable_name(member_name):
        return False
    if not is_valid_vtable_type(member, member_type):
        return False
    return True


def is_struct_vtable(struct):
    if struct is None:
        return False
    struct_name = ida_struct.get_struc_name(struct.id)
    return VTABLE_POSTFIX in struct_name


def is_vtables_union(union):
    if union is None:
        return False
    if not union.is_union():
        return False
    union_name = ida_struct.get_struc_name(union.id)
    return is_vtables_union_name(union_name)


def is_vtables_union_name(union_name):
    return union_name.endswith(VTABLE_UNION_KEYWORD)


def find_vtable_at_offset(struct_ptr, vtable_offset):
    current_struct = struct_ptr
    current_offset = 0
    member = ida_struct.get_member(current_struct, vtable_offset)
    if member is None:
        return None
    parents_vtables_classes = []
    current_offset += member.get_soff()
    while current_offset < vtable_offset and member is not None:
        current_struct = utils.get_member_substruct(member)
        if current_struct is None:
            return
        parents_vtables_classes.append(
            [
                ida_struct.get_struc_name(current_struct.id),
                vtable_offset - current_offset,
            ]
        )
        member = ida_struct.get_member(current_struct, vtable_offset - current_offset)
        if member is None:
            logging.exception(
                "Couldn't find vtable at offset %d for %d",
                vtable_offset - current_offset,
                struct_ptr.id,
            )
        current_offset += member.get_soff()

    if current_offset != vtable_offset:
        return None

    while member is not None:
        if is_member_vtable(member):
            return member, current_struct, parents_vtables_classes
        current_struct = utils.get_member_substruct(member)
        if current_struct is None:
            return None
        parents_vtables_classes.append(
            [ida_struct.get_struc_name(current_struct.id), 0]
        )
        member = ida_struct.get_member(current_struct, 0)

    return None


def get_class_vtable_struct_name(class_name, vtable_offset_in_class):
    if vtable_offset_in_class == 0:
        return class_name + "_vtbl"
    return "%s_%04X_vtbl" % (class_name, vtable_offset_in_class)


def get_class_vtable_field_name(class_name):
    return VTABLE_FIELD_NAME


def get_class_vtables_union_name(class_name):
    return class_name + VTABLE_DELIMITER + VTABLE_UNION_KEYWORD


def get_class_vtables_field_name(child_name):
    return child_name + VTABLES_UNION_VTABLE_FIELD_POSTFIX


def get_interface_empty_vtable_name():
    return "INTERFACE"


def install_vtables_union(
    class_name, class_vtable_member=None, vtable_member_tinfo=None, offset=0
):
    logging.debug(
        "install_vtables_union(%s, %s, %s)",
        class_name,
        class_vtable_member,
        str(vtable_member_tinfo),
    )
    if class_vtable_member and vtable_member_tinfo:
        old_vtable_sptr = utils.extract_struct_from_tinfo(vtable_member_tinfo)
        old_vtable_class_name = ida_struct.get_struc_name(old_vtable_sptr.id)
    else:
        old_vtable_class_name = get_class_vtable_struct_name(class_name, offset)
        old_vtable_sptr = utils.get_sptr_by_name(old_vtable_class_name)
    vtables_union_name = old_vtable_class_name
    if old_vtable_sptr and not ida_struct.set_struc_name(
        old_vtable_sptr.id, old_vtable_class_name + "_orig"
    ):
        logging.exception(
            f"Failed changing {old_vtable_class_name}->"
            f"{old_vtable_class_name+'orig'}"
        )
        return -1
    vtables_union_id = utils.get_or_create_struct_id(vtables_union_name, True)
    vtable_member_tinfo = utils.get_typeinf(old_vtable_class_name + "_orig")
    if vtables_union_id == BADADDR:
        logging.exception(
            f"Cannot create union vtable for {class_name}(){vtables_union_name}"
        )
        return -1

    vtables_union = ida_struct.get_struc(vtables_union_id)
    if not vtables_union:
        logging.exception(f"Could retrieve vtables union for {class_name}")
    if vtable_member_tinfo is not None:
        vtables_union_vtable_field_name = get_class_vtables_field_name(class_name)
    else:
        vtables_union_vtable_field_name = get_interface_empty_vtable_name()
    utils.add_to_struct(
        vtables_union, vtables_union_vtable_field_name, vtable_member_tinfo
    )
    parent_struct = utils.get_sptr_by_name(class_name)
    flag = idaapi.FF_STRUCT
    mt = idaapi.opinfo_t()
    mt.tid = vtables_union_id
    struct_size = ida_struct.get_struc_size(vtables_union_id)
    vtables_union_ptr_type = utils.get_typeinf_ptr(vtables_union_name)
    if class_vtable_member:
        member_ptr = class_vtable_member
    else:
        member_id = ida_struct.add_struc_member(
            parent_struct,
            get_class_vtable_field_name(class_name),
            offset,
            flag,
            mt,
            struct_size,
        )
        member_ptr = ida_struct.get_member_by_id(member_id)
    ida_struct.set_member_tinfo(
        parent_struct, member_ptr, 0, vtables_union_ptr_type, idaapi.TINFO_DEFINITE
    )
    return vtables_union


def add_child_vtable(parent_name, child_name, child_vtable_id, offset):
    logging.debug(
        "add_child_vtable (%s, %s, %s)",
        parent_name,
        child_name,
        child_vtable_id,
    )
    parent_vtable_member = ida_struct.get_member(
        utils.get_sptr_by_name(parent_name), offset
    )
    vtable_member_tinfo = utils.get_member_tinfo(parent_vtable_member)
    parent_vtable_struct = utils.get_sptr_by_name(
        get_class_vtable_struct_name(parent_name, offset)
    )
    if parent_vtable_struct is None:
        return None
    pointed_struct = utils.extract_struct_from_tinfo(vtable_member_tinfo)
    logging.debug("pointed_struct: %s", str(pointed_struct))
    if (
        (pointed_struct is None)
        or (not is_struct_vtable(pointed_struct))
        or (parent_vtable_struct.id != pointed_struct.id)
    ):
        parent_vtable_member = None
        logging.debug("Not a struct vtable: %s", str(vtable_member_tinfo))

    # TODO: Check that struct is a valid vtable by name
    if not parent_vtable_struct.is_union():
        logging.debug("%s vtable isn't union -> unionize it!", parent_name)
        parent_vtable_struct = install_vtables_union(
            parent_name, parent_vtable_member, vtable_member_tinfo, offset
        )

    child_vtable_name = ida_struct.get_struc_name(child_vtable_id)
    child_vtable = utils.get_typeinf(child_vtable_name)
    logging.debug(
        "add_to_struct %s %s", parent_vtable_struct.id, str(child_vtable)
    )
    if ida_struct.get_struc_size(child_vtable_id) == 0:
        utils.add_to_struct(
            ida_struct.get_struc(child_vtable_id), "dummy", None
        )
    new_member = utils.add_to_struct(
        parent_vtable_struct, get_class_vtables_field_name(child_name), child_vtable
    )
    ida_xref.add_dref(
        new_member.id, child_vtable_id, ida_xref.XREF_USER | ida_xref.dr_O
    )


def update_func_name_with_class(func_ea, class_name):
    name = ida_name.get_ea_name(func_ea)
    if name.startswith("sub_"):
        new_name = class_name + VTABLE_DELIMITER + name
        return utils.set_func_name(func_ea, new_name), True
    return name, False


def update_func_this(func_ea, this_type=None):
    functype = None
    try:
        func_details = utils.get_func_details(func_ea)
        if func_details is None:
            return None
        if this_type:
            if len(func_details) > 0:
                func_details[0].name = "this"
                func_details[0].type = this_type
        functype = utils.update_func_details(func_ea, func_details)
    except ida_hexrays.DecompilationFailure as e:
        logging.exception("Couldn't decompile 0x%x", func_ea)
    return functype


def add_class_vtable(struct_ptr, vtable_name, offset=BADADDR, vtable_field_name=None):
    if vtable_field_name is None:
        class_name = ida_struct.get_struc_name(struct_ptr.id)
        vtable_field_name = get_class_vtable_field_name(class_name)
    vtable_id = ida_struct.get_struc_id(vtable_name)
    vtable_type_ptr = utils.get_typeinf_ptr(vtable_name)
    new_member = utils.add_to_struct(
        struct_ptr, vtable_field_name, vtable_type_ptr, offset, overwrite=True
    )
    if new_member is None:
        logging.warning(
            "vtable of %s couldn't added at offset %d", str(vtable_type_ptr), offset
        )
    else:
        ida_xref.add_dref(new_member.id, vtable_id, ida_xref.XREF_USER | ida_xref.dr_O)


@batchmode
def post_func_name_change(new_name, ea):
    xrefs = idautils.XrefsTo(ea, ida_xref.XREF_USER)
    xrefs = filter(lambda x: x.type == ida_xref.dr_I and x.user == 1, xrefs)
    args_list = []
    for xref in xrefs:
        member, old_name, struct = ida_struct.get_member_by_id(xref.frm)
        if member is not None and struct is not None:
            args_list.append([struct, member.get_soff(), new_name])

    return utils.set_member_name, args_list


def post_struct_member_name_change(member, new_name):
    xrefs = idautils.XrefsFrom(member.id)
    xrefs = filter(lambda x: x.type == ida_xref.dr_I and x.user == 1, xrefs)
    for xref in xrefs:
        if utils.is_func(xref.to):
            utils.set_func_name(xref.to, new_name)


def post_struct_member_type_change(member):
    xrefs = idautils.XrefsFrom(member.id)
    xrefs = filter(lambda x: x.type == ida_xref.dr_I and x.user == 1, xrefs)
    for xref in xrefs:
        if utils.is_func(xref.to):
            function_ptr_tinfo = idaapi.tinfo_t()
            ida_struct.get_member_tinfo(function_ptr_tinfo, member)
            if function_ptr_tinfo.is_funcptr():
                function_tinfo = function_ptr_tinfo.get_pointed_object()
                if function_tinfo is not None:
                    ida_typeinf.apply_tinfo(
                        xref.to, function_tinfo, idaapi.TINFO_DEFINITE
                    )


@batchmode
def post_func_type_change(pfn):
    ea = pfn.start_ea
    xrefs = idautils.XrefsTo(ea, ida_xref.XREF_USER)
    xrefs = list(filter(lambda x: x.type == ida_xref.dr_I and x.user == 1, xrefs))
    args_list = []
    if len(xrefs) == 0:
        return None, []
    try:
        xfunc = ida_hexrays.decompile(ea)
        func_ptr_typeinf = utils.get_typeinf_ptr(xfunc.type)
        for xref in xrefs:
            member, old_name, struct = ida_struct.get_member_by_id(xref.frm)
            if member is not None and struct is not None:
                args_list.append(
                    [struct, member, 0, func_ptr_typeinf, idaapi.TINFO_DEFINITE]
                )
    except Exception:
        pass
    return ida_struct.set_member_tinfo, args_list


def make_funcptr_pt(func, this_type):
    return utils.get_typeinf(f"void (*)({str(this_type)} *)")


def update_vtable_struct(
    functions_ea,
    vtable_struct,
    class_name,
    this_type=None,
    get_next_func_callback=get_vtable_line,
    vtable_head=None,
    ignore_list=None,
    add_dummy_member=False,
    pure_virtual_name=None,
    parent_name=None,
    add_func_this=True,
):
    is_first_member = True
    if this_type is None:
        this_type = utils.get_typeinf_ptr(class_name)
    if not add_func_this:
        this_type = None
    func, next_func = get_next_func_callback(
        functions_ea, ignore_list=ignore_list, pure_virtual_name=pure_virtual_name
    )
    dummy_i = 1
    while func is not None:
        new_func_name, is_name_changed = update_func_name_with_class(func, class_name)
        func_ptr = None
        if ida_hexrays.init_hexrays_plugin():
            if is_name_changed:
                func_type = update_func_this(func, this_type)
            else:
                func_type = update_func_this(func, None)
            if func_type is not None:
                func_ptr = utils.get_typeinf_ptr(func_type)
        else:
            func_ptr = make_funcptr_pt(func, this_type)
        if add_dummy_member:
            utils.add_to_struct(vtable_struct, f"dummy_{dummy_i}", func_ptr)
            dummy_i += 1
        if is_first_member:
            # We did an hack for vtables contained in union vtable with one dummy member
            ptr_member = utils.add_to_struct(
                vtable_struct, new_func_name, func_ptr, 0, overwrite=True
            )
            is_first_member = False
        else:
            ptr_member = utils.add_to_struct(
                vtable_struct, new_func_name, func_ptr, is_offset=True
            )
        if ptr_member is None:
            logging.exception(
                "Couldn't add %s(%s) to %d",
                new_func_name,
                str(func_ptr),
                vtable_struct.id,
            )
        ida_xref.add_dref(ptr_member.id, func, ida_xref.XREF_USER | ida_xref.dr_I)
        func, next_func = get_next_func_callback(
            next_func, ignore_list=ignore_list, pure_virtual_name=pure_virtual_name
        )

    vtable_size = ida_struct.get_struc_size(vtable_struct)

    if vtable_head is None:
        vtable_head = functions_ea
    ida_bytes.del_items(vtable_head, ida_bytes.DELIT_SIMPLE, vtable_size)
    ida_bytes.create_struct(vtable_head, vtable_size, vtable_struct.id)
    if parent_name is None and this_type:
        parent = utils.deref_struct_from_tinfo(this_type)
        parent_name = ida_struct.get_struc_name(parent.id)
        if parent_name == class_name:
            parent_name = None
    utils.set_name_retry(vtable_head, get_vtable_instance_name(class_name, parent_name))


def is_valid_func_char(c):
    ALLOWED_CHARS = [":", "_"]
    return c.isalnum() or c in ALLOWED_CHARS


def find_valid_cppname_in_line(line, idx):
    end_idx = idx
    start_idx = idx
    if len(line) < idx:
        return None
    while start_idx >= 0 and is_valid_func_char(line[start_idx]):
        if line[start_idx] == ":":
            if line[start_idx - 1] == ":":
                start_idx -= 1
            else:
                break
        start_idx -= 1
    while end_idx < len(line) and is_valid_func_char(line[end_idx]):
        if line[end_idx] == ":":
            if line[end_idx + 1] == ":":
                end_idx += 1
            else:
                break
        end_idx += 1
    if end_idx > start_idx:
        return line[start_idx + 1 : end_idx]
    return None


def get_overriden_func_names(union_name, offset, get_not_funcs_members=False):
    sptr = utils.get_sptr_by_name(union_name)
    res = []
    if not sptr.is_union:
        return res

    for i in range(ida_struct.get_max_offset(sptr)):
        member = ida_struct.get_member(sptr, i)
        cls = ida_struct.get_member_name(member.id)
        tinfo = utils.get_member_tinfo(member)
        logging.debug("Trying %s", cls)
        if cls == get_interface_empty_vtable_name() or not tinfo.is_ptr():
            continue
        pointed_obj = tinfo.get_pointed_object()
        if not pointed_obj.is_struct():
            continue
        vtable_sptr = utils.get_sptr_by_name(pointed_obj.get_final_type_name())
        if ida_struct.get_max_offset(vtable_sptr) <= offset:
            continue
        funcptr_member = ida_struct.get_member(vtable_sptr, offset)
        funcptr_type = utils.get_member_tinfo(funcptr_member)
        func_name = ida_struct.get_member_name(funcptr_member.id)
        if not funcptr_type.is_funcptr() and not get_not_funcs_members:
            continue
        res.append((cls, func_name))
    return res


def set_polymorhpic_func_name(union_name, offset, name, force=False):
    for _, func_name in get_overriden_func_names(union_name, offset):
        func_name_splitted = func_name.split(VTABLE_DELIMITER)
        local_func_name = func_name_splitted[-1]
        if local_func_name != name and (force or local_func_name.startswith("sub_")):
            ea = utils.get_func_ea_by_name(func_name)
            if ea != BADADDR:
                new_func_name = VTABLE_DELIMITER.join(func_name_splitted[:-1])
                if new_func_name != "":
                    new_func_name += VTABLE_DELIMITER
                new_func_name += name
                logging.debug("0x%x -> %s", ea, new_func_name)
                utils.set_func_name(ea, new_func_name)


def create_class(class_name, has_vtable, parent_class=None):
    class_id = ida_struct.add_struc(BADADDR, class_name)
    class_ptr = ida_struct.get_struc(class_id)
    # if parent class ->
    # if has_vtable-> if not parent- create vtable, if parent - install vtable
    return class_ptr


def create_vtable_struct(sptr, name, vtable_offset, parent_name=None):
    logging.debug("create_vtable_struct(%s, %d)", name, vtable_offset)
    vtable_details = find_vtable_at_offset(sptr, vtable_offset)
    parent_vtable_member = None
    parent_vtable_struct = None
    parent_name = None
    parents_chain = None
    if vtable_details is not None:
        logging.debug("Found parent vtable %s %d", name, vtable_offset)
        parent_vtable_member, parent_vtable_struct, parents_chain = vtable_details
    else:
        logging.debug("Couldn't found parent vtable %s %d", name, vtable_offset)
    if parent_vtable_member is not None:
        parent_name = ida_struct.get_struc_name(parent_vtable_struct.id)
    vtable_name = get_class_vtable_struct_name(name, vtable_offset)
    if vtable_offset == 0:
        this_type = utils.get_typeinf_ptr(name)
    else:
        this_type = utils.get_typeinf_ptr(parent_name)
    if vtable_name is None:
        logging.exception(
            "create_vtable_struct(%s, %d): vtable_name is" " None", name, vtable_offset
        )
    vtable_id = ida_struct.add_struc(BADADDR, vtable_name, False)
    if vtable_id == BADADDR:
        logging.exception("Couldn't create struct %s", vtable_name)
    vtable_struct = ida_struct.get_struc(vtable_id)
    if parents_chain:
        for parent_name, offset in parents_chain:
            add_child_vtable(parent_name, name, vtable_id, offset)
    else:
        add_class_vtable(sptr, vtable_name, vtable_offset)

    return vtable_struct, this_type


def make_vtable(
        class_name,
        vtable_ea=None,
        vtable_ea_stop=None,
        offset_in_class=0,
        parent_name=None,
        add_func_this=True,
        _get_vtable_line=get_vtable_line,
):
    if not vtable_ea and not vtable_ea_stop:
        vtable_ea, vtable_ea_stop = utils.get_selected_range_or_line()
    vtable_struct, this_type = create_vtable_struct(
        utils.get_or_create_struct(class_name), class_name, offset_in_class,
        parent_name=parent_name
    )
    update_vtable_struct(
        vtable_ea,
        vtable_struct,
        class_name,
        this_type=this_type,
        get_next_func_callback=partial(_get_vtable_line, stop_ea=vtable_ea_stop),
        parent_name=parent_name,
        add_func_this=add_func_this,
    )


def add_baseclass(class_name, baseclass_name, baseclass_offset=0, to_refresh=False):
    member_name = get_base_member_name(baseclass_name, baseclass_offset)
    struct_ptr = utils.get_sptr_by_name(class_name)
    baseclass_ptr = utils.get_sptr_by_name(baseclass_name)
    if not struct_ptr or not baseclass_ptr:
        return False
    member = utils.add_to_struct(struct_ptr, member_name,
                                 member_type=utils.get_typeinf(baseclass_name),
                                 offset=baseclass_offset,
                                 overwrite=True)
    if not member:
        logging.debug(f"add_baseclass({class_name}. {baseclass_name}): member not found")
        return False
    member.props |= ida_struct.MF_BASECLASS
    if to_refresh:
        utils.refresh_struct(struct_ptr)
    return True

```

`decompiler_utils.py`:

```py
import logging

import ida_hexrays
import idc
from . import utils
from idaapi import BADADDR


def get_insn(ea=None):
    if ea is None:
        ea = idc.here()
    xfunc = ida_hexrays.decompile(ea)
    return xfunc.get_eamap()[ea][0]


def get_str_from_expr(expr, make_str=True):
    if expr is None:
        return None
    str_addr = get_obj_ea_from_expr(expr)
    if str_addr == BADADDR:
        return None
    ret = idc.get_strlit_contents(str_addr)
    if ret is not None:
        ret = ret.decode()
    return ret


def extract_op_from_expr(expr, op):
    if expr is None:
        return BADADDR
    while expr.is_expr() and expr.op != op:
        expr = expr.x
        if expr is None:
            return BADADDR
    if expr.op == op:
        return expr


def get_obj_ea_from_expr(expr):
    expr = extract_op_from_expr(expr, ida_hexrays.cot_obj)
    if expr is None:
        return BADADDR
    return expr.obj_ea


def get_num_from_expr(expr):
    expr = extract_op_from_expr(expr, ida_hexrays.cot_num)
    if expr is None:
        return None
    return expr.get_const_value()


def get_call_from_insn(insn):
    expr = None
    if type(insn) == ida_hexrays.cinsn_t and insn.op == ida_hexrays.cit_expr:
        expr = insn.cexpr
    elif type(insn) == ida_hexrays.cexpr_t:
        expr = insn
    else:
        return None
    if expr.op != ida_hexrays.cot_call:
        return None
    return expr


def run_operation_on_func_xrefs(func_name, operation, exception_msg=None):
    if exception_msg is None:
        exception_msg = "exception in %s xrefs" % func_name
    ea = utils.get_func_ea_by_name(func_name)
    for xref in utils.get_code_xrefs(ea):
        try:
            insn = get_insn(xref)
            operation(insn, xref)
        except Exception as e:
            logging.exception("0x%x: %s", ea, exception_msg)

```

`examples/a.cpp`:

```cpp
#include <iostream>

using namespace std;

class A{
	public:
	int x_a;
	virtual int f_a()=0;
};

class B : public A{
	public:
	int x_b;
	int f_a(){x_a = 0;}
	virtual int f_b(){this->f_a();}
};
class Z{
	public:
	virtual int f_z1(){cout << "f_z1";}
	virtual int f_z2(){cout << "f_z2";}
};

class C: public B, public Z{
	public:
    int f_a(){x_a = 5;}
	int x_c;
	int f_c(){x_c = 0;}
	virtual int f_z1(){cout << "f_z3";}
};


int main()
{
	C *c = new C();
    c->f_a();
    c->f_b();
    c->f_z1();
    c->f_z2();
    
	return 0;
}



```

`medigate_cpp_plugin.py`:

```py
try:
    from ida_medigate.cpp_plugin.plugin import CPPPlugin

    def PLUGIN_ENTRY():
        return CPPPlugin()


except ImportError:
    print(
        "[WARN] Couldn't load ida_medigate_cpp plugin. ida_medigate Python package doesn't seem "
        "to be installed"
    )

```

`plugins/ida-referee/LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2011 James Koppel	
   Modifications copyright 2015 Joseph Leong

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`plugins/ida-referee/README.md`:

```md
# Referee

This is a python port of James Koppel's Referee IDA plugin with some updates:  
https://github.com/jkoppel/project-ironfist/tree/master/tools/Revitalize/Referee


## What it is

It's much easier to reverse-engineer a structure when you can find every place its members are used. If you wish to reengineer the binary and modify a structure, finding every use is essential. Referee makes both of these tasks easier by marking accesses of structures in decompiled functions.

## Requirements

 * IDA 6.2 or higher
 * Hex-Rays Decompiler 1.6 or higher

## Installation

Copy the plugin into the IDA "plugins" folder

## Usage

Referee will automatically run whenever a function is decompiled. It is recommended that you decompile the entire binary for maximum information. You can see the cross-references that Referee adds by opening a structure in the Structures window, highlighting a field of a structure, and pressing "X."

Referee does not do type inference; you will still need to give types to your functions for it to find structure uses.

## Notes

 * If you annotate a function to remove a struct-member usage, decompiling the function again will remove the corresponding xrefs.
 * Referee only tracks accesses to structure members, not pointer-passing.
 * Configuring debug output: `logging.getLogger('referee').setLevel(logging.DEBUG)`

## Related
- http://reverseengineering.stackexchange.com/questions/2139/is-it-possible-to-create-data-xrefs-manually

```

`plugins/ida-referee/referee.py`:

```py
# -*- coding: utf-8 -*-
"""
Referee creates struct xrefs for decompiled functions
"""
import logging
import traceback

import idaapi

logging.basicConfig(level=logging.WARN)
log = logging.getLogger("referee")


NETNODE_NAME = '$ referee-xrefs'
NETNODE_TAG = 'X'


def is_assn(t):
    return (
        t == idaapi.cot_asg or
        t == idaapi.cot_asgbor or
        t == idaapi.cot_asgxor or
        t == idaapi.cot_asgband or
        t == idaapi.cot_asgsub or
        t == idaapi.cot_asgmul or
        t == idaapi.cot_asgsshr or
        t == idaapi.cot_asgushr or
        t == idaapi.cot_asgsdiv or
        t == idaapi.cot_asgudiv or
        t == idaapi.cot_asgsmod or
        t == idaapi.cot_asgumod)


def is_incdec(t):
    return (
        t == idaapi.cot_postinc or  # = 53,  ///< x++
        t == idaapi.cot_postdec or  # = 54,  ///< x--
        t == idaapi.cot_preinc  or  # = 55,  ///< ++x
        t == idaapi.cot_predec)     # = 56,  ///< --x


def add_struct_xrefs(cfunc):
    class xref_adder_t(idaapi.ctree_visitor_t):
        def __init__(self, cfunc):
            idaapi.ctree_visitor_t.__init__(self, idaapi.CV_PARENTS)
            self.cfunc = cfunc
            self.node = idaapi.netnode()
            self.clear_struct_xrefs()
            self.xrefs = {}

        def load(self):
            try:
                data = self.node.getblob_ea(self.cfunc.entry_ea, NETNODE_TAG)
                if data:
                    xrefs = eval(data.replace(b"L", b""))
                    log.debug('Loaded {} xrefs'.format(len(xrefs)))
                    return xrefs
            except:
                log.error('Failed to load xrefs from netnode')
                traceback.print_exc()
            return {}

        def save(self):
            try:
                self.node.setblob_ea(repr(self.xrefs).encode(),
                                     self.cfunc.entry_ea,
                                     NETNODE_TAG)
            except:
                log.error('Failed to save xrefs to netnode')
                traceback.print_exc()

        def clear_struct_xrefs(self):
            if not self.node.create(NETNODE_NAME):
                xrefs = self.load()
                for (ea, struct_id, member_id) in xrefs.keys():
                    if member_id is None:
                        idaapi.del_dref(ea, struct_id)
                    else:
                        idaapi.del_dref(ea, member_id)
                self.xrefs = {}
                self.save()
                log.debug('Cleared {} xrefs'.format(len(xrefs)))

        def find_addr(self, e):
            if e.ea != idaapi.BADADDR:
                ea = e.ea
            else:
                while True:
                    e = self.cfunc.body.find_parent_of(e)
                    if e is None:
                        ea = self.cfunc.entry_ea
                        break
                    if e.ea != idaapi.BADADDR:
                        ea = e.ea
                        break
            return ea

        def add_dref(self, ea, struct_id, flags, member_id=None):
            if ((ea, struct_id, member_id) not in self.xrefs or
                    flags < self.xrefs[(ea, struct_id, member_id)]):
                self.xrefs[(ea, struct_id, member_id)] = flags
                strname = idaapi.get_struc_name(struct_id)
                if member_id is None:
                    idaapi.add_dref(ea, struct_id, flags)
                    log.debug((" 0x{:X} \t"
                               "struct {} \t"
                               "{}").format(
                               ea, strname, flags_to_str(flags)))
                else:
                    idaapi.add_dref(ea, member_id, flags)
                    log.debug((" 0x{:X} \t"
                               "member {}.{} \t"
                               "{}").format(
                               ea, strname,
                               idaapi.get_member_name(member_id),
                               flags_to_str(flags)))
            self.save()

        def visit_expr(self, e):
            dr = idaapi.dr_R | idaapi.XREF_USER
            ea = self.find_addr(e)

            # We wish to know what context a struct usage occurs in
            # so we can determine what kind of xref to create. Unfortunately,
            # a post-order traversal makes this difficult.

            # For assignments, we visit the left, instead
            # Note that immediate lvalues will be visited twice,
            # and will be eronneously marked with a read dref.
            # However, it is safer to overapproximate than underapproximate
            if is_assn(e.op) or is_incdec(e.op):
                e = e.x
                dr = idaapi.dr_W | idaapi.XREF_USER

            # &x
            if e.op == idaapi.cot_ref:
                e = e.x
                dr = idaapi.dr_O | idaapi.XREF_USER

            # x.m, x->m
            if (e.op == idaapi.cot_memref or e.op == idaapi.cot_memptr):
                moff = e.m

                # The only way I could figure out how
                # to get the structure/member associated with its use
                typ = e.x.type

                if e.op == idaapi.cot_memptr:
                    typ.remove_ptr_or_array()

                strname = typ.dstr()
                if strname.startswith("struct "):
                    strname = strname[len("struct "):]

                stid = idaapi.get_struc_id(strname)
                struc = idaapi.get_struc(stid)
                mem = idaapi.get_member(struc, moff)

                if struc is not None:
                    self.add_dref(ea, stid, dr)
                    if mem is not None:
                        self.add_dref(ea, stid, dr, mem.id)

                else:
                    log.error(("failure from 0x{:X} "
                               "on struct {} (id: 0x{:X}) {}").format(
                               ea, strname, stid, flags_to_str(dr)))

            elif idaapi.is_lvalue(e.op) and e.type.is_struct():
                strname = e.type.dstr()
                if strname.startswith("struct "):
                    strname = strname[len("struct "):]

                stid = idaapi.get_struc_id(strname)
                struc = idaapi.get_struc(stid)

                if struc is not None:
                    self.add_dref(ea, stid, dr)

            return 0

    adder = xref_adder_t(cfunc)
    adder.apply_to_exprs(cfunc.body, None)


def callback(*args):
    if args[0] == idaapi.hxe_maturity:
        cfunc = args[1]
        mat = args[2]
        if mat == idaapi.CMAT_FINAL:
            log.debug("analyzing function at 0x{:X}".format(
                cfunc.entry_ea))
            add_struct_xrefs(cfunc)
    return 0


class Referee(idaapi.plugin_t):
    flags = idaapi.PLUGIN_HIDE
    comment = "Adds struct xref info from decompilation"
    help = ""

    wanted_name = "Referee"
    wanted_hotkey = ""

    def __init__(self):
        self.inited = False

    def init(self):
        if not idaapi.init_hexrays_plugin():
            return idaapi.PLUGIN_SKIP

        idaapi.install_hexrays_callback(callback)
        log.info(("Hex-Rays version {} has been detected; "
                  "{} is ready to use").format(
                  idaapi.get_hexrays_version(), self.wanted_name))
        self.inited = True
        return idaapi.PLUGIN_KEEP

    def run(self, arg):
        # never called
        pass

    def term(self):
        if self.inited:
            idaapi.remove_hexrays_callback(callback)
            idaapi.term_hexrays_plugin()


def PLUGIN_ENTRY():
    return Referee()


def flags_to_str(num):
    match = []
    if num & idaapi.dr_R == idaapi.dr_R:
        match.append('dr_R')
        num ^= idaapi.dr_R
    if num & idaapi.dr_O == idaapi.dr_O:
        match.append('dr_O')
        num ^= idaapi.dr_O
    if num & idaapi.dr_W == idaapi.dr_W:
        match.append('dr_W')
        num ^= idaapi.dr_W
    if num & idaapi.dr_I == idaapi.dr_I:
        match.append('dr_I')
        num ^= idaapi.dr_I
    if num & idaapi.dr_T == idaapi.dr_T:
        match.append('dr_T')
        num ^= idaapi.dr_T
    if num & idaapi.XREF_USER == idaapi.XREF_USER:
        match.append('XREF_USER')
        num ^= idaapi.XREF_USER
    if num & idaapi.XREF_DATA == idaapi.XREF_DATA:
        match.append('XREF_DATA')
        num ^= idaapi.XREF_DATA
    res = ' | '.join(match)
    if num:
        res += ' unknown: 0x{:X}'.format(num)
    return res


def clear_output_window():
    idaapi.process_ui_action('msglist:Clear')

```

`rtti_parser.py`:

```py
import logging

import ida_name
import ida_struct
import idaapi
import idautils
import idc
from idaapi import BADADDR

from . import cpp_utils
from . import utils


class RTTIParser(object):
    RTTI_OBJ_STRUC_NAME = "rtti_obj"

    @classmethod
    def init_parser(cls):
        logging.basicConfig(
            filename="/tmp/cpp.log",
            filemode="a",
            level=logging.DEBUG,
            format="%(asctime)s - %(levelname)s - %(message)s",
        )
        cls.found_classes = set()

    @classmethod
    def extract_rtti_info_from_data(cls, ea=None):
        if ea is None:
            ea = idc.here()
        typeinfo = cls.parse_rtti_header(ea)
        return cls.extract_rtti_info_from_typeinfo(typeinfo)

    @classmethod
    def extract_rtti_info_from_typeinfo(cls, typeinfo):
        if typeinfo in cls.found_classes:
            return
        rtti_obj = cls.parse_typeinfo(typeinfo)
        if rtti_obj is None:
            return
        logging.info("%s: Parsed typeinfo", rtti_obj.name)
        cls.found_classes.add(rtti_obj.typeinfo)
        for parent_typeinfo, _, offset in rtti_obj.raw_parents:
            parent_updated_name = None
            parent_rtti_obj = cls.extract_rtti_info_from_typeinfo(parent_typeinfo)
            if parent_rtti_obj:
                parent_updated_name = parent_rtti_obj.name
            else:
                built_rtti_obj_name = ida_name.get_ea_name(parent_typeinfo)
                if built_rtti_obj_name.endswith(cls.RTTI_OBJ_STRUC_NAME):
                    parent_updated_name = built_rtti_obj_name.rstrip(
                        "_" + cls.RTTI_OBJ_STRUC_NAME
                    )
            if parent_updated_name is not None:
                rtti_obj.updated_parents.append((parent_updated_name, offset))

        logging.debug("%s: Finish setup parents", rtti_obj.name)
        if not rtti_obj.create_structs():
            return False
        rtti_obj.make_rtti_obj_pretty()
        rtti_obj.find_vtables()
        return rtti_obj

    def __init__(self, parents, typeinfo):
        self.raw_parents = []
        self.updated_parents = []
        self.typeinfo = typeinfo
        self.orig_name = self.name = self.get_typeinfo_name(self.typeinfo)
        for parent_typeinf, parent_offset in parents:
            parent_name = self.get_typeinfo_name(parent_typeinf)
            if parent_name is not None:
                self.raw_parents.append((parent_typeinf, parent_name, parent_offset))
        self.struct_id = None
        self.struct_ptr = None

    def create_structs(self):
        self.name, self.struct_id = utils.add_struc_retry(self.name)
        if self.struct_id == BADADDR or self.name is None:
            return False
        self.struct_ptr = ida_struct.get_struc(self.struct_id)
        if self.struct_ptr is None:
            logging.exception("self.struct_ptr is None at %s", self.name)
        previous_parent_offset = 0
        previous_parent_size = 0
        previous_parent_struct_id = BADADDR
        for parent_name, parent_offset in self.updated_parents:
            if (
                parent_offset - previous_parent_offset > previous_parent_size
                and previous_parent_struct_id != BADADDR
            ):
                utils.expand_struct(
                    previous_parent_struct_id, parent_offset - previous_parent_offset
                )
            baseclass_id = ida_struct.get_struc_id(parent_name)
            baseclass_size = ida_struct.get_struc_size(baseclass_id)
            if baseclass_id == BADADDR or baseclass_size == 0:
                logging.warning(
                    "bad struct id or size: %s(0x%x:%s) - %s, %d",
                    self.name,
                    parent_offset,
                    parent_name,
                    baseclass_id,
                    baseclass_size,
                )

            cpp_utils.add_baseclass(self.name, parent_name, parent_offset)
            previous_parent_offset = parent_offset
            previous_parent_size = baseclass_size
            previous_parent_struct_id = baseclass_id
        if self.updated_parents:
            utils.refresh_struct(self.struct_ptr)

        return True

    def find_vtables(self):
        is_vtable_found = False
        for xref in utils.get_drefs(self.typeinfo):
            if self.try_parse_vtable(xref) is not None:
                is_vtable_found = True
        if not is_vtable_found:
            logging.debug(
                "find_vtable(%s): Couldn't find any vtable ->" " Interface!", self.name
            )
            if len(self.updated_parents) == 0:
                cpp_utils.install_vtables_union(self.name)
                pass

    def try_parse_vtable(self, ea):
        pass

    def create_vtable_struct(self, vtable_offset):
        return cpp_utils.create_vtable_struct(self.struct_ptr, self.name, vtable_offset)

    def make_rtti_obj_pretty(self):
        pass

    @classmethod
    def parse_rtti_header(cls, ea):
        pass

    @classmethod
    def parse_typeinfo(cls, typeinfo):
        pass

    def get_typeinfo_name(self, typeinfo):
        pass


class GccRTTIParser(RTTIParser):
    VMI = "_ZTVN10__cxxabiv121__vmi_class_type_infoE"
    SI = "_ZTVN10__cxxabiv120__si_class_type_infoE"
    NONE = "_ZTVN10__cxxabiv117__class_type_infoE"
    OFFSET_FROM_TYPEINF_SYM = 2 * utils.WORD_LEN

    RECORD_TYPEINFO_OFFSET = utils.WORD_LEN
    # class_type_info consts
    CLASS_TYPE_TYPEINFO_OFFSET = 0
    CLASS_TYPE_NAME_OFFSET = utils.WORD_LEN
    CLASS_TYPE_SIZE = 2 * utils.WORD_LEN

    # si_class_type_info consts
    SI_TYPEINFO_BASE_OFFSET = CLASS_TYPE_SIZE

    # vmi_class_type_info consts
    VMI_TYPEINFO_BASE_CLASSES_NUM_OFFSET = CLASS_TYPE_SIZE + 4
    VMI_TYPEINFO_BASE_CLASSES_OFFSET = VMI_TYPEINFO_BASE_CLASSES_NUM_OFFSET + 4

    # base_class vmi helper
    BASE_CLASS_TYPEINFO_OFFSET = 0
    BASE_CLASS_ATTRS_OFFSET = BASE_CLASS_TYPEINFO_OFFSET + utils.WORD_LEN
    BASE_CLASS_SIZE = utils.WORD_LEN * 2

    pure_virtual_name = "__cxa_pure_virtual"

    @classmethod
    def init_parser(cls):
        super(GccRTTIParser, cls).init_parser()
        cls.type_vmi = (
            ida_name.get_name_ea(idaapi.BADADDR, cls.VMI) + cls.OFFSET_FROM_TYPEINF_SYM
        )
        cls.type_si = (
            ida_name.get_name_ea(idaapi.BADADDR, cls.SI) + cls.OFFSET_FROM_TYPEINF_SYM
        )
        cls.type_none = (
            ida_name.get_name_ea(idaapi.BADADDR, cls.NONE) + cls.OFFSET_FROM_TYPEINF_SYM
        )
        cls.types = (cls.type_vmi, cls.type_si, cls.type_none)

    @classmethod
    def build_all(cls):
        for class_type in cls.types:
            logging.debug("Starting :%s %s" % (class_type, hex(class_type)))
            cls.build_class_type(class_type)
            logging.info("Done %s", class_type)

    @classmethod
    @utils.batchmode
    def build_class_type(cls, class_type):
        idx = 0
        for xref in idautils.XrefsTo(class_type - cls.OFFSET_FROM_TYPEINF_SYM):
            if (idx + 1) % 200 == 0:
                # idc.batch(0)
                logging.info("\t Done %s", idx)
                # ida_loader.save_database(None, 0)
                # idc.batch(1)
            if utils.get_ptr(xref.frm) != class_type:
                continue
            try:
                cls.extract_rtti_info_from_typeinfo(xref.frm)
            except Exception as e:
                logging.exception("Exception at 0x%x:", xref.frm)
            idx += 1

    @classmethod
    def parse_rtti_header(cls, ea):
        # offset = cls.read_offset(ea)
        typeinfo = cls.get_typeinfo_ea(ea)
        return typeinfo

    @classmethod
    def parse_typeinfo(cls, typeinfo):
        typeinfo_type = utils.get_ptr(typeinfo + cls.CLASS_TYPE_TYPEINFO_OFFSET)
        if typeinfo_type == cls.type_none:
            parents = []
        elif typeinfo_type == cls.type_si:
            parents = cls.parse_si_typeinfo(typeinfo)
        elif typeinfo_type == cls.type_vmi:
            parents = cls.parse_vmi_typeinfo(typeinfo)
        else:
            return None
        return GccRTTIParser(parents, typeinfo)

    @classmethod
    def parse_si_typeinfo(cls, typeinfo_ea):
        parent_typinfo_ea = utils.get_ptr(typeinfo_ea + cls.SI_TYPEINFO_BASE_OFFSET)
        return [(parent_typinfo_ea, 0)]

    @classmethod
    def parse_vmi_typeinfo(cls, typeinfo_ea):
        base_classes_num = idaapi.get_32bit(
            typeinfo_ea + cls.VMI_TYPEINFO_BASE_CLASSES_NUM_OFFSET
        )
        parents = []
        for i in range(base_classes_num):
            base_class_desc_ea = (
                typeinfo_ea
                + cls.VMI_TYPEINFO_BASE_CLASSES_OFFSET
                + i * cls.BASE_CLASS_SIZE
            )
            parent_typeinfo_ea = utils.get_ptr(
                base_class_desc_ea + cls.BASE_CLASS_TYPEINFO_OFFSET
            )
            parent_attrs = utils.get_word(
                base_class_desc_ea + cls.BASE_CLASS_ATTRS_OFFSET
            )
            parent_offset_in_cls = parent_attrs >> 8
            parents.append((parent_typeinfo_ea, parent_offset_in_cls))
        return parents

    @classmethod
    def get_typeinfo_ea(cls, ea):
        return utils.get_ptr(ea + cls.RECORD_TYPEINFO_OFFSET)

    @classmethod
    def get_typeinfo_name(cls, typeinfo_ea):
        name_ea = utils.get_ptr(typeinfo_ea + cls.CLASS_TYPE_NAME_OFFSET)
        if name_ea is None or name_ea == BADADDR:
            mangled_class_name = ida_name.get_ea_name(typeinfo_ea)
        else:
            mangled_class_name = "_Z" + idc.get_strlit_contents(name_ea).decode()
        class_name = ida_name.demangle_name(mangled_class_name, idc.INF_LONG_DN)
        return cls.strip_class_name(class_name)

    @classmethod
    def strip_class_name(cls, cls_name):
        pre_dict = {"`typeinfo for": ":"}
        words_dict = {
            "`anonymous namespace'": "ANONYMOUS",
            "`anonymous_namespace'": "ANONYMOUS",
            "`typeinfo for'": "",
        }
        chars_dict = {
            "<": "X",
            ">": "Z",
            "&": "A",
            "*": "P",
            " ": "_",
            ",": "C",
            "'": "U",
            "`": "T",
            "[": "O",
            "]": "P",
        }
        for target, strip in words_dict.items():
            cls_name = cls_name.replace(target, strip)
        for target, strip in chars_dict.items():
            cls_name = cls_name.replace(target, strip)
        return cls_name

    def try_parse_vtable(self, ea):
        functions_ea = ea + utils.WORD_LEN
        func_ea, _ = cpp_utils.get_vtable_line(
            functions_ea,
            ignore_list=self.types,
            pure_virtual_name=self.pure_virtual_name,
        )
        if func_ea is None:
            return
        vtable_offset = utils.get_signed_int(ea - utils.WORD_LEN) * (-1)
        vtable_struct, this_type = self.create_vtable_struct(vtable_offset)
        cpp_utils.update_vtable_struct(
            functions_ea,
            vtable_struct,
            self.name,
            this_type,
            ignore_list=self.types,
            pure_virtual_name=self.pure_virtual_name,
        )
        return vtable_struct

```

`utils.py`:

```py
import logging
import random

import ida_bytes
import ida_enum
import ida_funcs
import ida_hexrays
import ida_kernwin
import ida_lines
import ida_nalt
import ida_name
import ida_search
import ida_struct
import ida_typeinf
import ida_xref
import idaapi
import idautils
import idc

from idc import BADADDR

# WORD length in bytes
WORD_LEN = None


def update_word_len(code, old=0):
    global WORD_LEN
    info = idaapi.get_inf_structure()
    if info.is_64bit():
        logging.debug("is 32 bit")
        WORD_LEN = 8
    elif info.is_32bit():
        logging.debug("is 32 bit")
        WORD_LEN = 4


idaapi.notify_when(idaapi.NW_OPENIDB, update_word_len)


def get_word(ea):
    if WORD_LEN == 4:
        return idaapi.get_32bit(ea)
    elif WORD_LEN == 8:
        return idaapi.get_64bit(ea)
    return None


def get_ptr(ea):
    return get_word(ea)


def make_word(ea):
    if WORD_LEN == 4:
        return ida_bytes.create_dword(ea, 4)
    elif WORD_LEN == 8:
        return ida_bytes.create_qword(ea, 8)
    return None


def make_ptr(ea):
    return make_word(ea)


def is_func(ea):
    func = ida_funcs.get_func(ea)
    if func is not None and func.start_ea == ea:
        return True
    return None


def get_funcs_list():
    pass


def get_drefs(ea):
    xref = ida_xref.get_first_dref_to(ea)
    while xref != BADADDR:
        yield xref
        xref = ida_xref.get_next_dref_to(ea, xref)


def get_typeinf(typestr):
    tif = idaapi.tinfo_t()
    tif.get_named_type(idaapi.get_idati(), typestr)
    return tif


def get_typeinf_ptr(typeinf):
    old_typeinf = typeinf
    if isinstance(typeinf, str):
        typeinf = get_typeinf(typeinf)
    if typeinf is None:
        logging.warning("Couldn't find typeinf %s", old_typeinf or typeinf)
        return None
    tif = idaapi.tinfo_t()
    tif.create_ptr(typeinf)
    return tif


def get_func_details(func_ea):
    xfunc = ida_hexrays.decompile(func_ea)
    if xfunc is None:
        return None
    func_details = idaapi.func_type_data_t()
    xfunc.type.get_func_details(func_details)
    return func_details


def update_func_details(func_ea, func_details):
    function_tinfo = idaapi.tinfo_t()
    function_tinfo.create_func(func_details)
    if not ida_typeinf.apply_tinfo(func_ea, function_tinfo, idaapi.TINFO_DEFINITE):
        return None
    return function_tinfo


def add_to_struct(
    struct,
    member_name,
    member_type=None,
    offset=BADADDR,
    is_offset=False,
    overwrite=False,
):
    mt = None
    flag = idaapi.FF_DWORD
    member_size = WORD_LEN
    if member_type is not None and (member_type.is_struct() or member_type.is_union()):
        logging.debug("Is struct!")
        substruct = extract_struct_from_tinfo(member_type)
        if substruct is not None:
            flag = idaapi.FF_STRUCT
            mt = ida_nalt.opinfo_t()
            mt.tid = substruct.id
            logging.debug(
                f"Is struct: {ida_struct.get_struc_name(substruct.id)}/{substruct.id}"
            )
            member_size = ida_struct.get_struc_size(substruct.id)
    elif WORD_LEN == 4:
        flag = idaapi.FF_DWORD
    elif WORD_LEN == 8:
        flag = idaapi.FF_QWORD
    if is_offset:
        flag |= idaapi.FF_0OFF
        mt = ida_nalt.opinfo_t()
        r = ida_nalt.refinfo_t()
        r.init(ida_nalt.get_reftype_by_size(WORD_LEN) | ida_nalt.REFINFO_NOBASE)
        mt.ri = r

    new_member_name = member_name
    member_ptr = ida_struct.get_member(struct, offset)
    if overwrite and member_ptr:
        if ida_struct.get_member_name(member_ptr.id) != member_name:
            logging.debug("Overwriting!")
            ret_val = ida_struct.set_member_name(struct, offset, member_name)
            i = 0
            while ret_val == ida_struct.STRUC_ERROR_MEMBER_NAME:
                new_member_name = "%s_%d" % (member_name, i)
                i += 1
                if i > 250:
                    logging.debug("failed change name")
                    return
                ret_val = ida_struct.set_member_name(struct, offset, new_member_name)

    else:
        ret_val = ida_struct.add_struc_member(
            struct, new_member_name, offset, flag, mt, member_size
        )
        i = 0
        while ret_val == ida_struct.STRUC_ERROR_MEMBER_NAME:
            new_member_name = "%s_%d" % (member_name, i)
            i += 1
            if i > 250:
                return
            ret_val = ida_struct.add_struc_member(
                struct, new_member_name, offset, flag, mt, member_size
            )
        if ret_val != 0:
            logging.debug(f"ret_val: {ret_val}")
        member_ptr = ida_struct.get_member_by_name(struct, new_member_name)
    if member_type is not None and member_ptr is not None:
        ida_struct.set_member_tinfo(
            struct, member_ptr, 0, member_type, idaapi.TINFO_DEFINITE
        )
    return member_ptr


def set_func_name(func_ea, func_name):
    counter = 0
    new_name = func_name
    while not ida_name.set_name(func_ea, new_name):
        new_name = func_name + "_%d" % counter
        counter += 1
    return new_name


def deref_tinfo(tinfo):
    pointed_obj = None
    if tinfo.is_ptr():
        pointed_obj = tinfo.get_pointed_object()
    return pointed_obj


def get_struc_from_tinfo(struct_tinfo):

    if ida_hexrays.init_hexrays_plugin() and (
        not (struct_tinfo.is_struct() or struct_tinfo.is_union())
    ):
        return None
    struct_id = ida_struct.get_struc_id(struct_tinfo.get_type_name())
    if struct_id == BADADDR:
        return None
    struct = ida_struct.get_struc(struct_id)
    return struct


def deref_struct_from_tinfo(tinfo):
    struct_tinfo = deref_tinfo(tinfo)
    if struct_tinfo is None:
        return None
    return get_struc_from_tinfo(struct_tinfo)


def extract_struct_from_tinfo(tinfo):
    struct = get_struc_from_tinfo(tinfo)
    if struct is None:
        struct = deref_struct_from_tinfo(tinfo)
    return struct


def get_member_tinfo(member, member_typeinf=None):
    if member_typeinf is None:
        member_typeinf = idaapi.tinfo_t()
    ida_struct.get_member_tinfo(member_typeinf, member)
    return member_typeinf


def get_sptr_by_name(struct_name):
    s_id = ida_struct.get_struc_id(struct_name)
    return ida_struct.get_struc(s_id)


def get_member_substruct(member):
    member_type = get_member_tinfo(member)
    if member_type is not None and member_type.is_struct():
        current_struct_id = ida_struct.get_struc_id(member_type.get_type_name())
        return ida_struct.get_struc(current_struct_id)
    elif member.flag & idaapi.FF_STRUCT == idaapi.FF_STRUCT:
        return ida_struct.get_sptr(member)
    return None


def set_member_name(struct, offset, new_name):
    i = 0
    ret_val = ida_struct.set_member_name(struct, offset, new_name)
    while not ret_val:
        formatted_new_name = "%s_%d" % (new_name, i)
        i += 1
        if i > 250:
            return False
        ret_val = ida_struct.set_member_name(struct, offset, formatted_new_name)
    return True


def get_or_create_struct_id(struct_name, is_union=False):
    struct_id = ida_struct.get_struc_id(struct_name)
    if struct_id != BADADDR:
        return struct_id
    struct_id = ida_struct.add_struc(BADADDR, struct_name, is_union)
    return struct_id


def get_or_create_struct(struct_name):
    struct_id = get_or_create_struct_id(struct_name)
    return ida_struct.get_struc(struct_id)


def get_signed_int(ea):
    x = idaapi.get_dword(ea)
    if x & (1 << 31):
        return ((1 << 32) - x) * (-1)
    return x


def expand_struct(struct_id, new_size):
    struct = ida_struct.get_struc(struct_id)
    if struct is None:
        logging.warning("Struct id 0x%x wasn't found", struct_id)
        return
    logging.debug(
        "Expanding struc %s 0x%x -> 0x%x",
        ida_struct.get_struc_name(struct_id),
        ida_struct.get_struc_size(struct_id),
        new_size,
    )
    if ida_struct.get_struc_size(struct_id) > new_size - WORD_LEN:
        return
    fix_list = []
    xrefs = idautils.XrefsTo(struct.id)
    for xref in xrefs:
        if xref.type == ida_xref.dr_R and xref.user == 0 and xref.iscode == 0:
            member, full_name, x_struct = ida_struct.get_member_by_id(xref.frm)
            if x_struct is not None:
                old_name = ida_struct.get_member_name(member.id)
                offset = member.soff
                marker_name = "marker_%d" % random.randint(0, 0xFFFFFF)
                idc.add_struc_member(
                    x_struct.id,
                    marker_name,
                    member.soff + new_size,
                    idaapi.FF_DATA | idaapi.FF_BYTE,
                    -1,
                    0,
                )
                logging.debug(
                    "Delete member (0x%x-0x%x)", member.soff, member.soff + new_size - 1
                )
                ida_struct.del_struc_members(
                    x_struct, member.soff, member.soff + new_size - 1
                )
                fix_list.append(
                    [
                        x_struct.id,
                        old_name,
                        offset,
                        idaapi.FF_STRUCT | idaapi.FF_DATA,
                        struct_id,
                        new_size,
                    ]
                )
            else:
                logging.warning("Xref wasn't struct_member 0x%x", xref.frm)

    ret = add_to_struct(
        ida_struct.get_struc(struct_id), None, None, new_size - WORD_LEN
    )
    logging.debug("Now fix args:")
    for fix_args in fix_list:
        ret = idc.add_struc_member(*fix_args)
        logging.debug("%s = %d", fix_args, ret)
        x_struct_id = fix_args[0]
        idc.del_struc_member(x_struct_id, ida_struct.get_struc_size(x_struct_id))


def get_curline_striped_from_viewer(viewer):
    line = ida_kernwin.get_custom_viewer_curline(viewer, False)
    line = ida_lines.tag_remove(line)
    return line


strings = None


def refresh_strings():
    global strings
    strings = idautils.Strings()


def get_strings():
    if strings is None:
        refresh_strings()
    return strings


def get_xrefs_for_string(s, filter_func=None):
    """filter_func(x,s) choose x if True for magic str (s)"""
    if filter_func is None:

        def filter_func(x, string):
            return str(x) == string

    filtered_strings = filter(lambda x: filter_func(x, s), get_strings())
    strings_xrefs = []
    for s in filtered_strings:
        xrefs = []
        xref = ida_xref.get_first_dref_to(s.ea)
        while xref != BADADDR:
            xrefs.append(xref)
            xref = ida_xref.get_next_dref_to(s.ea, xref)
        strings_xrefs.append([str(s), xrefs])
    return strings_xrefs


def get_func_ea_by_name(name):
    loc = idc.get_name_ea_simple(name)
    func = ida_funcs.get_func(loc)
    if func is None:
        return BADADDR
    return func.start_ea


def get_funcs_contains_string(s):
    def filter_func(x, string):
        return string in str(x)

    strings_xrefs = get_xrefs_for_string(s, filter_func)
    strings_funcs = []
    for found_str, xrefs in strings_xrefs:
        funcs = set()
        for xref in xrefs:
            contained_func = ida_funcs.get_func(xref)
            if contained_func is not None:
                funcs.add(contained_func)
        strings_funcs.append([found_str, funcs])
    return strings_funcs


def batchmode(func):
    def wrapper(*args, **kwargs):
        old_batch = idc.batch(1)
        try:
            val = func(*args, **kwargs)
        except Exception:
            raise
        finally:
            idc.batch(old_batch)
        return val

    return wrapper


def get_code_xrefs(ea):
    xref = ida_xref.get_first_cref_to(ea)
    while xref != BADADDR:
        yield xref
        xref = ida_xref.get_next_cref_to(ea, xref)


def get_enum_const_name(enum_name, const_val):
    enum = ida_enum.get_enum(enum_name)
    if enum != BADADDR:
        const = ida_enum.get_const(enum, const_val, 0, BADADDR)
        if const != BADADDR:
            return ida_enum.get_const_name(const)
    return None


def find_hex_string(start_ea, stop_ea, hex_string):
    curr_ea = ida_search.find_binary(
        start_ea, stop_ea, hex_string, 16, ida_search.SEARCH_DOWN
    )
    while curr_ea != BADADDR:
        yield curr_ea
        curr_ea = ida_search.find_binary(
            curr_ea + len(hex_string), stop_ea, hex_string, 16, ida_search.SEARCH_DOWN
        )


def force_make_struct(ea, struct_name):
    sptr = get_sptr_by_name(struct_name)
    if sptr == BADADDR:
        return False
    s_size = ida_struct.get_struc_size(sptr)
    ida_bytes.del_items(ea, ida_bytes.DELIT_SIMPLE, s_size)
    return ida_bytes.create_struct(ea, s_size, sptr.id)


@batchmode
def set_name_retry(ea, name, name_func=ida_name.set_name, max_attempts=100):
    i = 0
    suggested_name = name
    while not name_func(ea, suggested_name):
        suggested_name = name + "_" + str(i)
        i += 1
        if i == max_attempts:
            return None
    return suggested_name


def add_struc_retry(name, max_attempts=100):
    i = 0
    suggested_name = name
    sid = ida_struct.add_struc(BADADDR, suggested_name)
    while sid == BADADDR:
        suggested_name = name + "_" + str(i)
        sid = ida_struct.add_struc(BADADDR, suggested_name)
        i += 1
        if i == max_attempts:
            return None, sid
    return suggested_name, sid


def get_selected_range_or_line():
    selection, startaddr, endaddr = ida_kernwin.read_range_selection(None)
    if selection:
        return startaddr, endaddr
    else:
        return ida_kernwin.get_screen_ea(), None


def refresh_struct(sptr):
    #  Hack: need to refresh structure so MF_BASECLASS will be updated
    member_ptr = add_to_struct(sptr, "dummy")
    ida_struct.del_struc_member(sptr, member_ptr.soff)


```