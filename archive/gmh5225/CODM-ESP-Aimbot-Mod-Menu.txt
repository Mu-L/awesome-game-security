Project Path: arc_gmh5225_CODM-ESP-Aimbot-Mod-Menu_a1s83012

Source Tree:

```txt
arc_gmh5225_CODM-ESP-Aimbot-Mod-Menu_a1s83012
├── README.md
├── app
│   ├── app.iml
│   ├── build.gradle
│   ├── proguard-rules.pro
│   └── src
│       └── main
│           ├── AndroidManifest.xml
│           ├── assets
│           │   └── fonts
│           │       └── fox.ttf
│           ├── java
│           │   └── com
│           │       └── gotoubun
│           │           ├── Floating.java
│           │           ├── Launcher.java
│           │           └── MainActivity.java
│           ├── jni
│           │   ├── Android.mk
│           │   ├── Application.mk
│           │   ├── CODM.h
│           │   ├── Engine
│           │   │   ├── Canvas.cpp
│           │   │   ├── Canvas.h
│           │   │   ├── Const.h
│           │   │   ├── Paint.cpp
│           │   │   ├── Paint.h
│           │   │   ├── Path.cpp
│           │   │   ├── Path.h
│           │   │   ├── Rect.cpp
│           │   │   ├── Rect.h
│           │   │   ├── Typeface.cpp
│           │   │   └── Typeface.h
│           │   ├── Il2Cpp.cpp
│           │   ├── Il2Cpp.h
│           │   ├── Includes.h
│           │   ├── Main.cpp
│           │   ├── Quaternion.hpp
│           │   ├── Substrate
│           │   │   ├── And64InlineHook.cpp
│           │   │   ├── And64InlineHook.hpp
│           │   │   ├── Buffer.hpp
│           │   │   ├── CydiaSubstrate.h
│           │   │   ├── SubstrateARM.hpp
│           │   │   ├── SubstrateDebug.cpp
│           │   │   ├── SubstrateDebug.hpp
│           │   │   ├── SubstrateHook.cpp
│           │   │   ├── SubstrateHook.h
│           │   │   ├── SubstrateLog.hpp
│           │   │   ├── SubstratePosixMemory.cpp
│           │   │   ├── SubstrateX86.hpp
│           │   │   ├── hde64.c
│           │   │   ├── hde64.h
│           │   │   └── table64.h
│           │   ├── Tools.cpp
│           │   ├── Tools.h
│           │   ├── Vector2.hpp
│           │   ├── Vector3.hpp
│           │   ├── fake_dlfcn.cpp
│           │   ├── fake_dlfcn.h
│           │   └── symbols.ver
│           └── res
│               ├── drawable
│               │   └── ic_launcher_background.xml
│               ├── drawable-v24
│               │   └── ic_launcher_foreground.xml
│               ├── layout
│               │   └── activity_main.xml
│               ├── mipmap-anydpi-v26
│               │   ├── ic_launcher.xml
│               │   └── ic_launcher_round.xml
│               ├── mipmap-hdpi
│               │   ├── ic_launcher.png
│               │   └── ic_launcher_round.png
│               ├── mipmap-mdpi
│               │   ├── ic_launcher.png
│               │   └── ic_launcher_round.png
│               ├── mipmap-xhdpi
│               │   ├── ic_launcher.png
│               │   └── ic_launcher_round.png
│               ├── mipmap-xxhdpi
│               │   ├── ic_launcher.png
│               │   └── ic_launcher_round.png
│               ├── mipmap-xxxhdpi
│               │   ├── ic_launcher.png
│               │   └── ic_launcher_round.png
│               └── values
│                   ├── colors.xml
│                   ├── strings.xml
│                   └── styles.xml
├── build.gradle
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
└── settings.gradle

```

`README.md`:

```md
# CoDM ESP & Aimbot Mod Menu
This project was been shared on a telegram group, I will reshare here publicly so it is more known

![](https://i.imgur.com/EpttQ8B.png)

# Features
- Auto update
- ESP Player Line, Box, Health, Name, Distance
- Aimbot
- Aim Location
- Arm Target
- Size POV
- Trigger
- AS and AIDE supported

# Credits
Pmods Sausage

# DISCLAIMER
**THE SOURCE IS OLD AND MAY NOT WORK ON LATEST VERSION DUE TO CHANGES. YOU MUST UPDATE AND FIX CODES BY YOURSELF! NO QUESTION ASKED!**

**THIS PROJECT IS FOR EDUCATIONAL USE ONLY. WE DO NOT CONDONE THIS PROJECT BEING USED TO GAIN AN ADVANTAGE AGAINST OTHER PEOPLE. WE ARE NOT RESPONSIBLE FOR ANY DAMAGES**

```

`app/app.iml`:

```iml
<?xml version="1.0" encoding="UTF-8"?>
<module external.linked.project.id=":app" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="Android-Mod-Menu" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
  <component name="FacetManager">
    <facet type="android-gradle" name="Android-Gradle">
      <configuration>
        <option name="GRADLE_PROJECT_PATH" value=":app" />
        <option name="LAST_SUCCESSFUL_SYNC_AGP_VERSION" value="4.0.1" />
        <option name="LAST_KNOWN_AGP_VERSION" value="4.0.1" />
      </configuration>
    </facet>
    <facet type="native-android-gradle" name="Native-Android-Gradle">
      <configuration>
        <option name="SELECTED_BUILD_VARIANT" value="debug-x86" />
      </configuration>
    </facet>
    <facet type="android" name="Android">
      <configuration>
        <option name="SELECTED_BUILD_VARIANT" value="debug" />
        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
        <afterSyncTasks>
          <task>generateDebugSources</task>
        </afterSyncTasks>
        <option name="ALLOW_USER_CONFIGURATION" value="false" />
        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />
        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />
        <option name="RES_FOLDERS_RELATIVE_PATH" value="file://$MODULE_DIR$/src/main/res;file://$MODULE_DIR$/src/debug/res;file://$MODULE_DIR$/build/generated/res/rs/debug" />
        <option name="TEST_RES_FOLDERS_RELATIVE_PATH" value="file://$MODULE_DIR$/src/androidTest/res;file://$MODULE_DIR$/src/test/res;file://$MODULE_DIR$/src/androidTestDebug/res;file://$MODULE_DIR$/src/testDebug/res;file://$MODULE_DIR$/build/generated/res/rs/androidTest/debug" />
        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />
      </configuration>
    </facet>
  </component>
  <component name="NewModuleRootManager" LANGUAGE_LEVEL="JDK_1_7">
    <output url="file://$MODULE_DIR$/build/intermediates/javac/debug/classes" />
    <output-test url="file://$MODULE_DIR$/build/intermediates/javac/debugUnitTest/classes" />
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src/main/jni/src/And64InlineHook" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/jni/src/Includes" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/jni/src/KittyMemory" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/jni/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/jni/src/Substrate" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/ap_generated_sources/debug/out" isTestSource="false" generated="true" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/aidl_source_output_dir/debug/out" isTestSource="false" generated="true" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/renderscript_source_output_dir/debug/out" isTestSource="false" generated="true" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" generated="true" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/ap_generated_sources/debugAndroidTest/out" isTestSource="true" generated="true" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/aidl_source_output_dir/debugAndroidTest/out" isTestSource="true" generated="true" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/androidTest/debug" isTestSource="true" generated="true" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/renderscript_source_output_dir/debugAndroidTest/out" isTestSource="true" generated="true" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/androidTest/debug" type="java-test-resource" generated="true" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/ap_generated_sources/debugUnitTest/out" isTestSource="true" generated="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/debug/aidl" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/debug/java" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/debug/jni" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/debug/rs" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/debug/shaders" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTestDebug/res" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTestDebug/resources" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTestDebug/assets" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTestDebug/aidl" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTestDebug/java" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTestDebug/jni" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTestDebug/rs" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTestDebug/shaders" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/testDebug/res" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/testDebug/resources" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/testDebug/assets" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/testDebug/aidl" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/testDebug/java" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/testDebug/jni" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/testDebug/rs" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/testDebug/shaders" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/res" type="java-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/assets" type="java-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/aidl" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/shaders" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/shaders" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/res" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/assets" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/aidl" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/jni" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/rs" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/shaders" isTestSource="true" />
      <excludeFolder url="file://$MODULE_DIR$/.cxx" />
      <excludeFolder url="file://$MODULE_DIR$/.externalNativeBuild" />
      <excludeFolder url="file://$MODULE_DIR$/build" />
    </content>
    <orderEntry type="jdk" jdkName="Android API 30 Platform" jdkType="Android SDK" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
```

`app/build.gradle`:

```gradle
apply plugin: 'com.android.application'

android {
    compileSdkVersion 30
    defaultConfig {
        applicationId "com.gotoubun"
        minSdkVersion 21
        targetSdkVersion 30
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        ndk {
            abiFilters "armeabi-v7a", "arm64-v8a"
        }
        multiDexEnabled false
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
        debug {
            jniDebuggable = true
        }
    }
    externalNativeBuild {
        ndkBuild {
            path file("src/main/jni/Android.mk")
        }
    }
    compileOptions {
        // This library uses Java 8 features, this is required
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}

dependencies {
}

```

`app/proguard-rules.pro`:

```pro
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
#-dontobfuscate
-keepclassmembers class ** {
   public static void Start (***);
}
-keep public class uk.lgl.MainActivity

```

`app/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    package="com.gotoubun">
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"
        tools:ignore="ScopedStorage" />
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/>
    <uses-permission android:name="android.permission.READ_PHONE_STATE" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:requestLegacyExternalStorage="true">
        <activity android:name="com.gotoubun.MainActivity"
            android:theme="@android:style/Theme.NoTitleBar.Fullscreen">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <service android:name="com.gotoubun.Floating" android:stopWithTask="true"/>
    </application>

</manifest>

```

`app/src/main/java/com/gotoubun/Floating.java`:

```java
package com.gotoubun;

import android.annotation.SuppressLint;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.res.ColorStateList;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.PixelFormat;
import android.graphics.Point;
import android.graphics.Typeface;
import android.graphics.drawable.GradientDrawable;
import android.os.Build;
import android.os.Handler;
import android.os.IBinder;
import android.os.Message;
import android.util.Base64;
import android.util.TypedValue;
import android.view.Display;
import android.view.Gravity;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.CompoundButton;
import android.widget.HorizontalScrollView;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.RadioButton;
import android.widget.RadioGroup;
import android.widget.RelativeLayout;
import android.widget.ScrollView;
import android.widget.SeekBar;
import android.widget.Spinner;
import android.widget.Switch;
import android.widget.TextView;


import android.view.ViewConfiguration;
import android.app.AlertDialog;
import android.content.DialogInterface;
import java.util.Random;
import android.widget.CheckBox;
import android.widget.Toast;
import java.util.Map;

public class Floating extends Service {

    static {
        System.loadLibrary("nino");
    }

    WindowManager windowManager;

    int screenWidth, screenHeight, type, screenDpi;
    float density;


    WindowManager.LayoutParams iconLayoutParams, mainLayoutParams, canvasLayoutParams;
    RelativeLayout iconLayout;
    LinearLayout mainLayout;
    CanvasView canvasLayout;

    RelativeLayout closeLayout, maximizeLayout, minimizeLayout;
    RelativeLayout.LayoutParams closeLayoutParams, maximizeLayoutParams, minimizeLayoutParams;
	
    ImageView iconImg;

    SharedPreferences configPrefs;
    SharedPreferences.Editor configEditor;

    String[] listTab = new String[]{"Player Visual", "Aim Menu", "Settings"};
    LinearLayout[] pageLayouts = new LinearLayout[listTab.length];
    int lastSelectedPage = 0;
	
	String M_RAND_TITLE = "-";
	
    
    long sleepTime = 4000 / 60;
	TextView textTitle;
    boolean isMaximized = false;
    int lastMaximizedX = 0, lastMaximizedY = 0;
    int lastMaximizedW = 0, lastMaximizedH = 0;

    int layoutWidth = 100;
    int layoutHeight = 200;
    int iconSize = 40;
    int menuButtonSize = 30;
	int tabWidth = 150;
    int tabHeight = 50;

	
	//private native void onSendConfig(String s, long v);
	
   private native void onSendConfig(String s, String v);
//public static native void DrawOn(ESPView espView, Canvas canvas);
	
    public static native void onCanvasDraw(Canvas canvas, int w, int h, float d);
    
	static native void Switch(int i, boolean jboolean1);
	
	//ESPView canvasLayout;
	
    void CreateCanvas() {
		
		int LAYOUT_FLAG;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            LAYOUT_FLAG = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;
        } else {
            LAYOUT_FLAG = WindowManager.LayoutParams.TYPE_SYSTEM_OVERLAY;
        }
        final WindowManager.LayoutParams canvasLayoutParams = new WindowManager.LayoutParams(
            WindowManager.LayoutParams.MATCH_PARENT,
            WindowManager.LayoutParams.MATCH_PARENT, 0, getNavigationBarHeight(),
            LAYOUT_FLAG,
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
            | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_FULLSCREEN,
            PixelFormat.RGBA_8888);

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P)
            canvasLayoutParams.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES;

        canvasLayoutParams.gravity = Gravity.TOP | Gravity.START;        //Initially view will be added to top-left corner
        canvasLayoutParams.x = 0;
        canvasLayoutParams.y = 0;
        windowManager = (WindowManager) getSystemService(WINDOW_SERVICE);
		canvasLayout = new CanvasView(this);
		windowManager.addView(canvasLayout, canvasLayoutParams);
		
    }
	private int getNavigationBarHeight() {
        boolean hasMenuKey = ViewConfiguration.get(this).hasPermanentMenuKey();
        int resourceId = getResources().getIdentifier("navigation_bar_height", "dimen", "android");
        if (resourceId > 0 && !hasMenuKey) {
            return getResources().getDimensionPixelSize(resourceId);
        }
        return 0;
    }
    private class CanvasView extends View {
        public CanvasView(Context context) {
            super(context);
        }
		
        @Override
        protected void onDraw(Canvas canvas) {
            try {
                onCanvasDraw(canvas, screenWidth, screenHeight, density);
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
    }

	private void UpdateConfiguration(String s, Object v) {
        try {
            onSendConfig(s, v.toString());
            SharedPreferences.Editor configEditor = configPrefs.edit();
            configEditor.putString(s, v.toString());
            configEditor.apply();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
    

    @Override
    public void onDestroy() {
        super.onDestroy();
        if (mUpdateCanvas.isAlive()) {
            mUpdateCanvas.interrupt();
        }
        if (mUpdateThread.isAlive()) {
            mUpdateThread.interrupt();
        }
        if (iconLayout != null) {
            windowManager.removeView(iconLayout);
        }
        if (mainLayout != null) {
            windowManager.removeView(mainLayout);
        }
        if (canvasLayout != null) {
            windowManager.removeView(canvasLayout);
        }
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        super.onStartCommand(intent, flags, startId);
        return START_NOT_STICKY;
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onCreate() {
        super.onCreate();	
		    configPrefs = getSharedPreferences("config", MODE_PRIVATE);
          //  configEditor = configPrefs.edit();
            windowManager = (WindowManager) getSystemService(WINDOW_SERVICE);
            Point screenSize = new Point();
            Display display = windowManager.getDefaultDisplay();
            display.getRealSize(screenSize);
            screenWidth = screenSize.x;
            screenHeight = screenSize.y;
            screenDpi = getResources().getDisplayMetrics().densityDpi;
            density = getResources().getDisplayMetrics().density;
            layoutWidth = convertSizeToDp(400);
            layoutHeight = convertSizeToDp(225);
            iconSize = convertSizeToDp(40);
            menuButtonSize = convertSizeToDp(30);
            tabWidth = convertSizeToDp(0);
            tabHeight = convertSizeToDp(0);
		    
		
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                type = 2038;
            } else {
                type = 2002;
            }
            CreateIcon();
            CreateLayout();
            CreateCanvas();
            mUpdateThread.start();
            mUpdateCanvas.start();
        }
	

    void AddFeatures() {    
        AddText(0, "Menu ESP :", 10, Typeface.BOLD, "#FFFFFFFF");
		AddSwitch(0, "ESP Player Line", false, new CompoundButton.OnCheckedChangeListener() {
				@Override
				public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
					UpdateConfiguration("ESP::LINE", isChecked ? 1 : 0);
				}
			});
		
        AddSwitch(0, "ESP Player Box", false, new CompoundButton.OnCheckedChangeListener() {
				@Override
				public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
					UpdateConfiguration("ESP::BOX", isChecked ? 1 : 0);
				}
			});

        AddSwitch(0, "ESP Player Health", false, new CompoundButton.OnCheckedChangeListener() {
				@Override
				public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
					UpdateConfiguration("ESP::HEALTH", isChecked ? 1 : 0);
				}
			});

        AddSwitch(0, "ESP Player Name", false, new CompoundButton.OnCheckedChangeListener() {
				@Override
				public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
					UpdateConfiguration("ESP::NAME", isChecked ? 1 : 0);
				}
			});

        AddSwitch(0, "ESP Player Distance", false, new CompoundButton.OnCheckedChangeListener() {
				@Override
				public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
					UpdateConfiguration("ESP::DISTANCE", isChecked ? 1 : 0);
				}
			});
			   AddText(0, "AIM Menu :", 13, Typeface.BOLD, "#FFFFFFFF");
        AddSwitch(0, "Aim Bot", false, new CompoundButton.OnCheckedChangeListener() {
				@Override
				public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
					UpdateConfiguration("AIM::AIMBOT", isChecked ? 1 : 0);
				}
			});

        AddText2(0, "Location : ", 5.0f, Color.BLACK);
        AddRadioButton(0, new String[]{"Head", "Chest", "Body"}, 0, new RadioGroup.OnCheckedChangeListener() {
				@Override
				public void onCheckedChanged(RadioGroup group, int checkedId) {
					UpdateConfiguration("AIM::LOCATION", checkedId);
				}
			});

        AddText2(0, "Target : ", 5.0f, Color.BLACK);
        AddRadioButton(0, new String[]{"Closest To Distance", "Inside POV"}, 0, new RadioGroup.OnCheckedChangeListener() {
				@Override
				public void onCheckedChanged(RadioGroup group, int checkedId) {
					UpdateConfiguration("AIM::TARGET", checkedId);
				}
			});
        AddSeekbar(0, "Size POV", 0, 500, 0, "", "", new SeekBar.OnSeekBarChangeListener() {
				@Override
				public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
					UpdateConfiguration("AIM::SIZE", (progress));
				}

				@Override
				public void onStartTrackingTouch(SeekBar seekBar) {

				}

				@Override
				public void onStopTrackingTouch(SeekBar seekBar) {

				}
			});
        AddText2(0, "Trigger : ", 5.0f, Color.BLACK);
        AddRadioButton(0, new String[]{"None", "Shooting", "Scoping"}, 0, new RadioGroup.OnCheckedChangeListener() {
				@Override
				public void onCheckedChanged(RadioGroup group, int checkedId) {
					UpdateConfiguration("AIM::TRIGGER", checkedId);
				}
			});
		
        
        
        AddText(0, "", 14, Typeface.BOLD, "#FFFFFFFF");
        AddText(0, "Main Settings :", 10, Typeface.BOLD, "#FFFFFFFF");
		
        AddSeekbar(0, "Menu Opacity", 1, 100, 100, "", "%", new SeekBar.OnSeekBarChangeListener() {
				@Override
				public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
					mainLayout.setAlpha((float) progress / 100.f);
				}

				@Override
				public void onStartTrackingTouch(SeekBar seekBar) {

				}

				@Override
				public void onStopTrackingTouch(SeekBar seekBar) {
				}
			});

        AddSeekbar(0, "Icon Size", 50, 200, 100, "", "%", new SeekBar.OnSeekBarChangeListener() {
				@Override
				public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
					ViewGroup.LayoutParams iconParams = iconImg.getLayoutParams();
					iconParams.width = (int) ((float) iconSize * ((float) progress / 100.f));
					iconParams.height = (int) ((float) iconSize * ((float) progress / 100.f));
					iconImg.setLayoutParams(iconParams);
				}

				@Override
				public void onStartTrackingTouch(SeekBar seekBar) {
					iconLayout.setVisibility(View.VISIBLE);
				}

				@Override
				public void onStopTrackingTouch(SeekBar seekBar) {
					iconLayout.setVisibility(View.GONE);
				}
			});
        AddSeekbar(0, "Icon Opacity", 0, 100, 100, "", "%", new SeekBar.OnSeekBarChangeListener() {
				@Override
				public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
					iconLayout.setAlpha((float) progress / 100.f);
				}

				@Override
				public void onStartTrackingTouch(SeekBar seekBar) {
					iconLayout.setVisibility(View.VISIBLE);
				}

				@Override
				public void onStopTrackingTouch(SeekBar seekBar) {
					iconLayout.setVisibility(View.GONE);
				}
			});
    }
	
    @SuppressLint("ClickableViewAccessibility")
    void CreateLayout() {
        mainLayoutParams = new WindowManager.LayoutParams(layoutWidth, layoutHeight, type, WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS, PixelFormat.RGBA_8888);

        mainLayoutParams.x = 0;
        mainLayoutParams.y = 0;
        mainLayoutParams.gravity = Gravity.START | Gravity.TOP;

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            mainLayoutParams.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES;
        }

        mainLayout = new LinearLayout(this);
        mainLayout.setOrientation(LinearLayout.VERTICAL);
        mainLayout.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));

        GradientDrawable mainLayoutBg = new GradientDrawable();
        //mainLayoutBg.setColor(Color.parseColor("#A39FC4"));
        mainLayoutBg.setColor(Color.parseColor("#D5151416"));
        mainLayout.setBackground(mainLayoutBg);

        RelativeLayout headerLayout = new RelativeLayout(this);
        headerLayout.setLayoutParams(new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, menuButtonSize + convertSizeToDp(4)));
        headerLayout.setClickable(true);
        headerLayout.setFocusable(true);
        headerLayout.setFocusableInTouchMode(true);
        //headerLayout.setBackgroundColor(Color.argb(255, 13, 13, 13));
        //headerLayout.setBackgroundColor(Color.parseColor("#D5151416"));
        headerLayout.setPadding(10, 5, 10, 5);
        headerLayout.setGravity(Gravity.CENTER_HORIZONTAL);
        headerLayout.setBackgroundColor(Color.BLACK);
        mainLayout.addView(headerLayout);

        /*TextView textTitle = new TextView(this);
        textTitle.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.MATCH_PARENT));
        textTitle.setGravity(Gravity.CENTER);
        textTitle.setClickable(true);
        textTitle.setFocusable(true);
        textTitle.setFocusableInTouchMode(true);
		textTitle.setText(Title());
		textTitle.setTypeface(Typeface.createFromAsset(getAssets(),"fonts/fox.ttf"));
        textTitle.setTextSize(convertSizeToDp(11.f));
        textTitle.setTextColor(Color.BLACK);
        headerLayout.addView(textTitle);*/
		
		textTitle = new TextView(this);
        textTitle.setTextSize(16);
        textTitle.setGravity(Gravity.CENTER_HORIZONTAL);
		textTitle.setText(Title());
		//textTitle.setTypeface(Typeface.DEFAULT_BOLD);
        textTitle.setTypeface(Typeface.createFromAsset(getAssets(), "fonts/fox.ttf"));
        textTitle.setTextColor(Color.WHITE);
        headerLayout.addView(textTitle);
        
        textTitle.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					mainLayout.setVisibility(View.GONE);
					iconLayout.setVisibility(View.VISIBLE);
				}
			});
			
        View.OnTouchListener onTitleListener = new View.OnTouchListener() {
            float pressedX;
            float pressedY;
            float deltaX;
            float deltaY;
            float newX;
            float newY;
            float maxX;
            float maxY;

            @Override
            public boolean onTouch(View v, MotionEvent event) {
                switch (event.getActionMasked()) {
                    case MotionEvent.ACTION_DOWN:

                        deltaX = mainLayoutParams.x - event.getRawX();
                        deltaY = mainLayoutParams.y - event.getRawY();

                        pressedX = event.getRawX();
                        pressedY = event.getRawY();

                        break;
                    case MotionEvent.ACTION_MOVE:
                        newX = event.getRawX() + deltaX;
                        newY = event.getRawY() + deltaY;

                        maxX = screenWidth - mainLayout.getWidth();
                        maxY = screenHeight - mainLayout.getHeight();

                        if (newX < 0)
                            newX = 0;
                        if (newX > maxX)
                            newX = (int) maxX;
                        if (newY < 0)
                            newY = 0;
                        if (newY > maxY)
                            newY = (int) maxY;

                        mainLayoutParams.x = (int) newX;
                        mainLayoutParams.y = (int) newY;
                        windowManager.updateViewLayout(mainLayout, mainLayoutParams);

                        break;

                    default:
                        break;
                }

                return false;
            }
        };

        headerLayout.setOnTouchListener(onTitleListener);
        textTitle.setOnTouchListener(onTitleListener);

        LinearLayout tabLayout = new LinearLayout(this);
        tabLayout.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
        tabLayout.setOrientation(LinearLayout.HORIZONTAL);

        HorizontalScrollView tabScrollView = new HorizontalScrollView(this);
        tabScrollView.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
        tabScrollView.setBackgroundColor(Color.argb(255, 230, 230, 230));

        tabScrollView.addView(tabLayout);

        mainLayout.addView(tabScrollView);

        final RelativeLayout[] tabButtons = new RelativeLayout[listTab.length];
        for (int i = 0; i < tabButtons.length; i++) {
            pageLayouts[i] = new LinearLayout(this);
            pageLayouts[i].setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
            pageLayouts[i].setOrientation(LinearLayout.VERTICAL);

            ScrollView scrollView = new ScrollView(this);
            scrollView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
            scrollView.addView(pageLayouts[i]);

            tabButtons[i] = new RelativeLayout(this);
            tabButtons[i].setLayoutParams(new RelativeLayout.LayoutParams(tabWidth, tabHeight));
            if (i != 0) {
                tabButtons[i].setBackgroundColor(Color.argb(255, 230, 230, 230));
                pageLayouts[i].setVisibility(View.GONE);
            } else {
                tabButtons[i].setBackgroundColor(Color.WHITE);
                pageLayouts[i].setVisibility(View.VISIBLE);
            }

            TextView tabText = new TextView(this);
            tabText.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
            tabText.setGravity(Gravity.CENTER);
            tabText.setText(listTab[i]);
            tabText.setTextSize(convertSizeToDp(11.f));
            tabText.setTextColor(Color.BLACK);
            tabButtons[i].addView(tabText);

            final int curTab = i;
            tabButtons[i].setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View v) {
						if (curTab != lastSelectedPage) {
							tabButtons[curTab].setBackgroundColor(Color.WHITE);
							pageLayouts[curTab].setVisibility(View.VISIBLE);

							pageLayouts[lastSelectedPage].setVisibility(View.GONE);
							lastSelectedPage = curTab;

							for (int j = 0; j < tabButtons.length; j++) {
								if (j != curTab) {
									tabButtons[j].setBackgroundColor(Color.argb(255, 230, 230, 230));
								}
							}
						}
					}
				});

            tabLayout.addView(tabButtons[i]);
            mainLayout.addView(scrollView);
        }

        windowManager.addView(mainLayout, mainLayoutParams);

        AddFeatures();
}

    @SuppressLint("ClickableViewAccessibility")
    void CreateIcon() {
        iconLayout = new RelativeLayout(this);
        RelativeLayout.LayoutParams iconParams = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
        iconLayout.setLayoutParams(iconParams);

        iconImg = new ImageView(this);
        ViewGroup.LayoutParams iconImgParams = new ViewGroup.LayoutParams(iconSize, iconSize);

        iconImg.setLayoutParams(iconImgParams);

        iconLayout.addView(iconImg);

        try {
            String iconBase64 = "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";
            byte[] iconData = Base64.decode(iconBase64, Base64.DEFAULT);

            Bitmap bmp = BitmapFactory.decodeByteArray(iconData, 0, iconData.length);
            iconImg.setImageBitmap(bmp);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        iconLayoutParams = new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT, type, WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS, PixelFormat.TRANSLUCENT);
        iconLayoutParams.gravity = Gravity.START | Gravity.TOP;

        iconLayoutParams.x = 0;
        iconLayoutParams.y = 0;

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            iconLayoutParams.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES;
        }

        iconLayout.setVisibility(View.GONE);

        iconLayout.setOnTouchListener(new View.OnTouchListener() {
				float pressedX;
				float pressedY;
				float deltaX;
				float deltaY;
				float newX;
				float newY;

				@Override
				public boolean onTouch(View v, MotionEvent event) {

					switch (event.getActionMasked()) {
						case MotionEvent.ACTION_DOWN:

							deltaX = iconLayoutParams.x - event.getRawX();
							deltaY = iconLayoutParams.y - event.getRawY();

							pressedX = event.getRawX();
							pressedY = event.getRawY();

							break;
						case MotionEvent.ACTION_UP:
							int Xdiff = (int) (event.getRawX() - pressedX);
							int Ydiff = (int) (event.getRawY() - pressedY);

							if (Xdiff == 0 && Ydiff == 0) {
								mainLayout.setVisibility(View.VISIBLE);
								iconLayout.setVisibility(View.GONE);
							}
							return true;
						case MotionEvent.ACTION_MOVE:
							newX = event.getRawX() + deltaX;
							newY = event.getRawY() + deltaY;

							float maxX = screenWidth - v.getWidth();
							float maxY = screenHeight - v.getHeight();

							if (newX < 0)
								newX = 0;
							if (newX > maxX)
								newX = (int) maxX;
							if (newY < 0)
								newY = 0;
							if (newY > maxY)
								newY = (int) maxY;

							iconLayoutParams.x = (int) newX;
							iconLayoutParams.y = (int) newY;

							windowManager.updateViewLayout(iconLayout, iconLayoutParams);
							break;

						default:
							break;
					}

					return false;
				}
			});

        windowManager.addView(iconLayout, iconLayoutParams);
    }

    LinearLayout CreateHolder(Object data) {
        RelativeLayout parentHolder = new RelativeLayout(this);
        parentHolder.setLayoutParams(new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
        LinearLayout childHolder = new LinearLayout(this);
        childHolder.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
        childHolder.setOrientation(LinearLayout.HORIZONTAL);
        parentHolder.addView(childHolder);

        if (data instanceof Integer)
            pageLayouts[(Integer) data].addView(parentHolder);
        else if (data instanceof ViewGroup)
            ((ViewGroup) data).addView(parentHolder);

        return childHolder;
    }
	void AddText(Object data, String text, int size, int typeface, String color) {
        TextView textView = new TextView(this);
        textView.setText(text);
        textView.setTextColor(Color.parseColor(color));
        textView.setTypeface(null, typeface);
        textView.setPadding(convertSizeToDp(5), convertSizeToDp(5), convertSizeToDp(5), convertSizeToDp(5));
        textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, size);
        textView.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));

        if (data instanceof ViewGroup)
            ((ViewGroup) data).addView(textView);
        else if (data instanceof Integer)
            pageLayouts[(int) data].addView(textView);
    }
    void AddText2(Object data, String text, float size, int color) {
        TextView textView = new TextView(this);
        textView.setText(text);
        textView.setTextColor(Color.WHITE);
        textView.setPadding(15, 15, 15, 15);
        textView.setTextSize(convertSizeToDp(size));
        textView.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));

        if (data instanceof Integer)
            pageLayouts[(Integer) data].addView(textView);
        else if (data instanceof ViewGroup)
            ((ViewGroup) data).addView(textView);
    }
	void AddCheckbox(Object data, String text, boolean checked, CompoundButton.OnCheckedChangeListener listener) {
        CheckBox checkBox = new CheckBox(this);
        checkBox.setText(text);
        checkBox.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 11.f);
        checkBox.setTextColor(Color.BLACK);
        checkBox.setChecked(checked);
        checkBox.setOnCheckedChangeListener(listener);
        checkBox.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));

        if (Build.VERSION.SDK_INT >= 21) {
            ColorStateList colorStateList = new ColorStateList(
				new int[][]{
					new int[]{-android.R.attr.state_checked}, // unchecked
					new int[]{android.R.attr.state_checked}  // checked
				},
				new int[]{
					Color.BLACK,
					Color.BLACK
				}
            );
            checkBox.setButtonTintList(colorStateList);
        }
        if (data instanceof ViewGroup)
            ((ViewGroup) data).addView(checkBox);
        else if (data instanceof Integer)
            pageLayouts[(int) data].addView(checkBox);
    }
	
    void AddCenteredText(Object data, String text, int size, int typeface, String color) {
        TextView textView = new TextView(this);
        textView.setText(text);
        textView.setTextColor(Color.parseColor(color));
        textView.setTypeface(null, typeface);
        textView.setPadding(15, 15, 15, 15);
        textView.setTextSize(convertSizeToDp(size));
        textView.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
        textView.setGravity(Gravity.CENTER);

        if (data instanceof Integer)
            pageLayouts[(Integer) data].addView(textView);
        else if (data instanceof ViewGroup)
            ((ViewGroup) data).addView(textView);
    }

    void AddHeader(Object data, String text) {
        LinearLayout headerLayout = new LinearLayout(this);
        headerLayout.setLayoutParams(new WindowManager.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
        headerLayout.setOrientation(LinearLayout.VERTICAL);
        headerLayout.setBackgroundColor(Color.argb(255, 10, 10, 10));

        TextView textView = new TextView(this);
        textView.setText(text);
        textView.setTextColor(Color.WHITE);
        textView.setTypeface(Typeface.DEFAULT_BOLD);
        textView.setPadding(10, 10, 10, 10);
        textView.setTextSize(convertSizeToDp(7.5f));
        textView.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
        headerLayout.addView(textView);

        if (data instanceof Integer)
            pageLayouts[(Integer) data].addView(headerLayout);
        else if (data instanceof ViewGroup)
            ((ViewGroup) data).addView(headerLayout);
    }

    void AddSwitch(Object data, String text, boolean checked, CompoundButton.OnCheckedChangeListener listener) {
        Switch toggle = new Switch(this);
        toggle.setText(text);
        toggle.setTextSize(convertSizeToDp(5.f));
        toggle.setTextColor(Color.WHITE);
        toggle.setChecked(checked);
        toggle.setPadding(15, 15, 15, 15);
        toggle.setOnCheckedChangeListener(listener);
        toggle.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));

        if (Build.VERSION.SDK_INT >= 21) {
            ColorStateList colorStateList = new ColorStateList(
                    new int[][]{
                            new int[]{-android.R.attr.state_checked}, // unchecked
                            new int[]{android.R.attr.state_checked}  // checked
                    },
                    new int[]{
                            Color.BLACK,
                            Color.BLACK
                    }
            );
            toggle.setButtonTintList(colorStateList);
        }

        if (data instanceof Integer)
            pageLayouts[(Integer) data].addView(toggle);
        else if (data instanceof ViewGroup)
            ((ViewGroup) data).addView(toggle);
    }
	void AddFloatSeekbar(Object data, String text, int min, int max, int value, final String prefix, final String suffix, final SeekBar.OnSeekBarChangeListener listener) {
        LinearLayout linearLayout = new LinearLayout(this);
        linearLayout.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
        linearLayout.setOrientation(LinearLayout.HORIZONTAL);

        TextView textV = new TextView(this);
        textV.setText(text + ":");
        textV.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 11.f);
        textV.setPadding(convertSizeToDp(10), convertSizeToDp(5), convertSizeToDp(10), convertSizeToDp(5));
        textV.setTextColor(Color.BLACK);
        textV.setLayoutParams(new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
        textV.setGravity(Gravity.LEFT);

        SeekBar seekBar = new SeekBar(this);
        seekBar.setMax(max);
        if (Build.VERSION.SDK_INT >= 26) {
            seekBar.setMin(min);
            seekBar.setProgress(min);
        }
        if (Build.VERSION.SDK_INT >= 21) {
            seekBar.setThumbTintList(ColorStateList.valueOf(Color.BLACK));
            seekBar.setProgressTintList(ColorStateList.valueOf(Color.BLACK));
        }
        seekBar.setPadding(convertSizeToDp(15), convertSizeToDp(5), convertSizeToDp(15), convertSizeToDp(5));

        final TextView textValue = new TextView(this);
        textValue.setText(prefix + String.valueOf((float) min / 10) + suffix);
        textValue.setGravity(Gravity.RIGHT);
        textValue.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 11.f);
        textValue.setLayoutParams(new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
        textValue.setPadding(convertSizeToDp(15), convertSizeToDp(5), convertSizeToDp(15), convertSizeToDp(5));
        textValue.setTextColor(Color.BLACK);

        if (value != 0) {
            if (value < min)
                value = min;
            if (value > max)
                value = max;

            textValue.setText(prefix + (float) value / max + suffix);
            seekBar.setProgress(value);
        }

        final int minimValue = min;
        seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
				@Override
				public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
					if (progress < minimValue) {
						progress = minimValue;
						seekBar.setProgress(progress);
					}

					if (listener != null) listener.onProgressChanged(seekBar, progress, fromUser);
					textValue.setText(prefix + String.valueOf((float) progress / 10) + suffix);
				}

				@Override
				public void onStartTrackingTouch(SeekBar seekBar) {
					if (listener != null) listener.onStartTrackingTouch(seekBar);
				}

				@Override
				public void onStopTrackingTouch(SeekBar seekBar) {
					if (listener != null) listener.onStopTrackingTouch(seekBar);
				}
			});

        linearLayout.addView(textV);
        linearLayout.addView(textValue);

        if (data instanceof ViewGroup) {
            ((ViewGroup) data).addView(linearLayout);
            ((ViewGroup) data).addView(seekBar);
        } else if (data instanceof Integer) {
            pageLayouts[(int) data].addView(linearLayout);
            pageLayouts[(int) data].addView(seekBar);
        }
    }
	
    void AddSeekbar(Object data, String text, int min, int max, int value, final String prefix, final String suffix, final SeekBar.OnSeekBarChangeListener listener) {
        LinearLayout linearLayout = new LinearLayout(this);
        linearLayout.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
        linearLayout.setOrientation(LinearLayout.HORIZONTAL);

        TextView textV = new TextView(this);
        textV.setText(text + ":");
        textV.setTextSize(convertSizeToDp(6.f));
        textV.setPadding(15, 15, 15, 15);
        textV.setTextColor(Color.WHITE);
        textV.setLayoutParams(new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
        textV.setGravity(Gravity.LEFT);

        SeekBar seekBar = new SeekBar(this);
        seekBar.setMax(max);
        if (Build.VERSION.SDK_INT >= 26) {
            seekBar.setMin(min);
            seekBar.setProgress(min);
        }
        if (Build.VERSION.SDK_INT >= 21) {
            seekBar.setThumbTintList(ColorStateList.valueOf(Color.WHITE));
            seekBar.setProgressTintList(ColorStateList.valueOf(Color.argb(255, 110, 110, 110)));
        }
        seekBar.setPadding(20, 15, 20, 15);

        final TextView textValue = new TextView(this);
        textValue.setText(prefix + min + suffix);
        textValue.setGravity(Gravity.RIGHT);
        textValue.setTextSize(convertSizeToDp(6.f));
        textValue.setLayoutParams(new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
        textValue.setPadding(20, 15, 20, 15);
        textValue.setTextColor(Color.WHITE);

        final int minimValue = min;
        seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                if (progress < minimValue) {
                    progress = minimValue;
                    seekBar.setProgress(progress);
                }

                if (listener != null) listener.onProgressChanged(seekBar, progress, fromUser);
                textValue.setText(prefix + progress + suffix);
            }

            @Override
            public void onStartTrackingTouch(SeekBar seekBar) {
                if (listener != null) listener.onStartTrackingTouch(seekBar);
            }

            @Override
            public void onStopTrackingTouch(SeekBar seekBar) {
                if (listener != null) listener.onStopTrackingTouch(seekBar);
            }
        });

        if (value != 0) {
            if (value < min)
                value = min;
            if (value > max)
                value = max;

            textValue.setText(prefix + value + suffix);
            seekBar.setProgress(value);
        }

        linearLayout.addView(textV);
        linearLayout.addView(textValue);

        if (data instanceof Integer) {
            pageLayouts[(Integer) data].addView(linearLayout);
            pageLayouts[(Integer) data].addView(seekBar);
        } else if (data instanceof ViewGroup) {
            ((ViewGroup) data).addView(linearLayout);
            ((ViewGroup) data).addView(seekBar);
        }
    }

    void AddRadioButton(Object data, String[] list, int defaultCheckedId, RadioGroup.OnCheckedChangeListener listener) {
        RadioGroup rg = new RadioGroup(this);
        RadioButton[] rb = new RadioButton[list.length];
        rg.setOrientation(RadioGroup.VERTICAL);
        for (int i = 0; i < list.length; i++) {
            rb[i] = new RadioButton(this);
            if (i == defaultCheckedId) rb[i].setChecked(true);
            rb[i].setPadding(15, 15, 15, 15);
            rb[i].setText(list[i]);
            rb[i].setTextSize(convertSizeToDp(6.f));
            rb[i].setId(i);
            rb[i].setGravity(Gravity.RIGHT);
            rb[i].setTextColor(Color.WHITE);
            rb[i].setButtonTintList(ColorStateList.valueOf(Color.WHITE));

            rg.addView(rb[i]);
        }
        rg.setOnCheckedChangeListener(listener);
        RelativeLayout.LayoutParams toggleP = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
        rg.setLayoutParams(toggleP);

        if (data instanceof Integer)
            pageLayouts[(Integer) data].addView(rg);
        else if (data instanceof ViewGroup)
            ((ViewGroup) data).addView(rg);
    }

    void AddDropdown(Object data, String[] list, AdapterView.OnItemSelectedListener listener) {
        LinearLayout holderLayout = new LinearLayout(this);
        holderLayout.setOrientation(LinearLayout.VERTICAL);
        holderLayout.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
        holderLayout.setPadding(15, 15, 15, 15);
        holderLayout.setGravity(Gravity.CENTER);

        Spinner sp = new Spinner(this, Spinner.MODE_DROPDOWN);

        GradientDrawable drawable = new GradientDrawable();
        drawable.setColor(Color.argb(255, 233, 233, 233));
        drawable.setStroke(1, Color.BLACK);
        sp.setPopupBackgroundDrawable(drawable);
        sp.setBackground(drawable);

        sp.setLayoutParams(new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
        ArrayAdapter<String> dataAdapter = new ArrayAdapter<String>(this, android.R.layout.simple_spinner_item, list) {
            @Override
            public View getView(int position, View convertView, ViewGroup parent) {
                View v = super.getView(position, convertView, parent);

                ((TextView) v).setTextColor(Color.WHITE);
                ((TextView) v).setTypeface(null, Typeface.BOLD);
                ((TextView) v).setGravity(Gravity.CENTER);

                return v;
            }

            @Override
            public View getDropDownView(int position, View convertView, ViewGroup parent) {
                View v = super.getDropDownView(position, convertView, parent);

                ((TextView) v).setTextColor(Color.WHITE);
                ((TextView) v).setTypeface(null, Typeface.BOLD);
                ((TextView) v).setGravity(Gravity.CENTER);

                return v;
            }
        };
        dataAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        sp.setAdapter(dataAdapter);
        sp.setOnItemSelectedListener(listener);
        sp.setPadding(0, 5, 0, 5);

        holderLayout.addView(sp);

        if (data instanceof Integer)
            pageLayouts[(Integer) data].addView(holderLayout);
        else if (data instanceof ViewGroup)
            ((ViewGroup) data).addView(holderLayout);
    }

    void AddButton(Object data, String text, int width, int height, int padding, View.OnClickListener listener) {
        LinearLayout holderLayout = new LinearLayout(this);
        holderLayout.setOrientation(LinearLayout.VERTICAL);
        holderLayout.setLayoutParams(new LinearLayout.LayoutParams(width, height));
        holderLayout.setPadding(padding, padding, padding, padding);
        holderLayout.setGravity(Gravity.CENTER);

        Button btn = new Button(this);
        btn.setText(text);
        btn.setTextColor(Color.WHITE);
        btn.setOnClickListener(listener);
        btn.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));

        GradientDrawable drawable = new GradientDrawable();
        drawable.setColor(Color.argb(255, 244, 244, 244));
        drawable.setStroke(2, Color.argb(255, 0, 0, 0));

        btn.setBackground(drawable);

        holderLayout.addView(btn);

        if (data instanceof Integer)
            pageLayouts[(Integer) data].addView(holderLayout);
        else if (data instanceof ViewGroup)
            ((ViewGroup) data).addView(holderLayout);
    }

    float convertSizeToDp(float size) {
        return TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP,
                size,
                getResources().getDisplayMetrics()
        );
    }

    int convertSizeToDp(int size) {
        return Math.round(TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP,
                size,
                getResources().getDisplayMetrics()
        ));
    }
	@SuppressLint("HandlerLeak")
    Handler handler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            if (msg.what == 0) {
                try {
                    Point screenSize = new Point();
                    Display display = windowManager.getDefaultDisplay();
                    display.getRealSize(screenSize);

                    screenWidth = screenSize.x;
                    screenHeight = screenSize.y;

                    android.view.ViewGroup.LayoutParams LayoutParams = null;
					windowManager.updateViewLayout(canvasLayout, LayoutParams);

                } catch (Exception ex) {
                    ex.printStackTrace();
                }
            }
            if (msg.what == 1) {
                Random random = new Random();
				int randIdx = random.nextInt(Title().length());
                int randChoose = random.nextInt(M_RAND_TITLE.length());
                char[] newTitle =Title().toCharArray();
                newTitle[randIdx] = M_RAND_TITLE.charAt(randChoose);
                textTitle.setText(String.valueOf(newTitle));
            }
        }
    };

	
 
	
	native String Title();
	
    Thread mUpdateCanvas = new Thread() {
        @Override
        public void run() {
            android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_DISPLAY);
            while (isAlive() && !isInterrupted()) {
                try {
                    long t1 = System.currentTimeMillis();
                    canvasLayout.postInvalidate();
                    long td = System.currentTimeMillis() - t1;
                    Thread.sleep(Math.max(Math.min(0, sleepTime - td), sleepTime));
                } catch (Exception ex) {
                    ex.printStackTrace();
                }
            }
        }
    };

    Thread mUpdateThread = new Thread() {
        @Override
        public void run() {
            android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_DISPLAY);
            while (isAlive() && !isInterrupted()) {
                try {
                    long t1 = System.currentTimeMillis();
                    Point screenSize = new Point();
                    Display display = windowManager.getDefaultDisplay();
                    display.getRealSize(screenSize);

                    if (screenWidth != screenSize.x || screenHeight != screenSize.y) {
                        handler.sendEmptyMessage(0);
                    }
                    handler.sendEmptyMessage(1);

                    long td = System.currentTimeMillis() - t1;
                    Thread.sleep(Math.max(Math.min(0, sleepTime - td), sleepTime));
                } catch (Exception ex) {
                    ex.printStackTrace();
                }
            }
        }
    };
}

```

`app/src/main/java/com/gotoubun/Launcher.java`:

```java
package com.gotoubun;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.Uri;
import android.os.Build;
import android.provider.Settings;

public class Launcher {

    static {
        System.loadLibrary("nino");
    }

    private static SharedPreferences m_Prefs;
    public static void Init(Object object) {
        Context m_Context = (Context) object;
        Activity m_Activity = (Activity) object;
        Init(m_Context);
        if (Build.VERSION.SDK_INT >= 23) {
            if (!Settings.canDrawOverlays(m_Context)) {
                Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse("package:" + m_Context.getPackageName()));
                m_Activity.startActivity(intent);
            }
        }
            Intent i = new Intent(m_Context.getApplicationContext(), Floating.class);
            m_Context.startService(i);
        }
    private static native void Init(Context mContext);
}

```

`app/src/main/java/com/gotoubun/MainActivity.java`:

```java
package com.gotoubun;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;

public class MainActivity extends Activity {
static {
        System.loadLibrary("nino");
    }
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        Launcher.Init(this);
    }
}

```

`app/src/main/jni/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

# Here is the name of your lib.
# When you change the lib name, change also on System.loadLibrary("") under OnCreate method on StaticActivity.java
# Both must have same name
LOCAL_MODULE    := nino

# Code optimization
# -std=c++17 is required to support AIDE app with NDK support
LOCAL_CFLAGS += -Wno-error=format-security -fvisibility=hidden -ffunction-sections -fdata-sections -w
LOCAL_CPPFLAGS += -Wno-error=format-security -fvisibility=hidden -ffunction-sections -fdata-sections -w -Werror -s  -fms-extensions
LOCAL_LDFLAGS += -Wl,--gc-sections,--strip-all
LOCAL_ARM_MODE := arm

# Here you add the cpp file

LOCAL_SRC_FILES 		:= Main.cpp \
                              Tools.cpp \
                              fake_dlfcn.cpp \
							  Il2Cpp.cpp \
                              Engine/Paint.cpp \
                              Engine/Canvas.cpp \
                              Engine/Rect.cpp \
                              Engine/Typeface.cpp \
                              Engine/Path.cpp \
                              Substrate/hde64.c \
                              Substrate/SubstrateDebug.cpp \
                              Substrate/SubstrateHook.cpp \
                              Substrate/SubstratePosixMemory.cpp \
                              Substrate/And64InlineHook.cpp
	
LOCAL_CPP_FEATURES                      := exceptions
LOCAL_LDLIBS                            := -llog -landroid -lz

include $(BUILD_SHARED_LIBRARY)




```

`app/src/main/jni/Application.mk`:

```mk
APP_ABI := armeabi-v7a 
#APP_PLATFORM := android-18 #APP_PLATFORM does not need to be set. It will automatically defaulting
APP_STL := c++_static
APP_OPTIM := release
APP_THIN_ARCHIVE := true
APP_PIE 		:= true

```

`app/src/main/jni/CODM.h`:

```h
#include "Includes.h"
#include "Tools.h"
#include "Engine/Canvas.h"
#include "fake_dlfcn.h"
#include "Il2Cpp.h"
#include "Vector2.hpp"
#include "Vector3.hpp"
#include "Quaternion.hpp"
//extern void StartRuntimeHook(const char *);
// ================================================================================================================================ //
#define SLEEP_TIME 1000LL / 120LL

std::map<std::string, u_long> Config;

int g_screenWidth = 0, g_screenHeight = 0;
bool bInitDone = false;
int screenWidth = 0, screenHeight = 0;
uintptr_t g_il2cpp;
// ================================================================================================================================ //
std::map<std::string, uintptr_t> Fields;
std::map<std::string, uintptr_t> Methods;


// ================================================================================================================================ //
class Transform {
public:
    Vector3 get_position() {
        auto Transform_get_position = (Vector3 (*)(Transform *)) (Methods["Transform::get_position"]);
        return Transform_get_position(this);
    }
};

class Component {
public:
    Transform *get_transform() {
        auto Component_get_transform = (Transform *(*)(Component *)) (Methods["Component::get_transform"]);
        return Component_get_transform(this);
    }
};

class Camera {
public:
    static Camera *get_main() {
        auto Camera_get_main = (Camera *(*)()) (Methods["Camera::get_main"]);
        return Camera_get_main();
    }
};

Vector3 WorldToScreen(Vector3 pos) {
    auto main = Camera::get_main();
    if (main) {
        auto Camera_WorldToScreenPoint = (Vector3 (*)(Camera *, Vector3)) (Methods["Camera::WorldToScreenPoint"]);
        return Camera_WorldToScreenPoint(main, pos);
    }
    return {0, 0, 0};
}

uintptr_t GetClosestTarget() {
    uintptr_t result = 0;

    float MaxDist = std::numeric_limits<float>::infinity();

    void *BaseWorld_Instance = 0;
    Il2CppGetStaticFieldValue("Assembly-CSharp.dll", "GameEngine", "BaseWorld", "Instance", &BaseWorld_Instance);
    if (BaseWorld_Instance) {
        auto m_Game = *(uintptr_t *) ((uintptr_t) BaseWorld_Instance + Fields["BaseWorld::m_Game"]);
        if (m_Game) {
            auto Gameplay_get_LocalPawn = (uintptr_t (*)()) (Methods["Gameplay::get_LocalPawn"]);
            auto LocalPawn = Gameplay_get_LocalPawn();
            if (LocalPawn) {
                Vector3 MyPos{0, 0, 0};

                auto local_m_Mesh = *(Transform **) (LocalPawn + Fields["Pawn::m_Mesh"]);
                if (local_m_Mesh) {
                    MyPos = local_m_Mesh->get_position();
                }

                auto EnemyPawns = *(List<uintptr_t> **) (m_Game + Fields["BaseGame::EnemyPawns"]);
                if (EnemyPawns) {
                    auto Items = EnemyPawns->getItems();
                    if (Items) {
                        for (int i = 0; i < EnemyPawns->getSize(); i++) {
                            auto Pawn = Items[i];
                            if (Pawn) {
                                if (!*(bool *) (Pawn + Fields["Pawn::m_IsAlive"]))
                                    continue;

                                auto m_Mesh = *(Transform **) (Pawn + Fields["Pawn::m_Mesh"]);
                                if (!m_Mesh)
                                    continue;

                                auto RootPos = m_Mesh->get_position();
                                float Distance = Vector3::Distance(MyPos, RootPos);

                                if (Distance < MaxDist) {
                                    result = Pawn;
                                    MaxDist = Distance;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return result;
}

bool isInsideFOV(int x, int y) {
    if (!Config["AIM::SIZE"])
        return true;

    int circle_x = g_screenWidth / 2;
    int circle_y = g_screenHeight / 2;
    int rad = Config["AIM::SIZE"];
    return (x - circle_x) * (x - circle_x) + (y - circle_y) * (y - circle_y) <= rad * rad;
}

uintptr_t GetInsideFOVTarget() {
    uintptr_t result = 0;

    float MaxDist = std::numeric_limits<float>::infinity();

    void *BaseWorld_Instance = 0;
    Il2CppGetStaticFieldValue("Assembly-CSharp.dll", "GameEngine", "BaseWorld", "Instance", &BaseWorld_Instance);
    if (BaseWorld_Instance) {
        auto m_Game = *(uintptr_t *) ((uintptr_t) BaseWorld_Instance + Fields["BaseWorld::m_Game"]);
        if (m_Game) {
            auto Gameplay_get_LocalPawn = (uintptr_t (*)()) (Methods["Gameplay::get_LocalPawn"]);
            auto LocalPawn = Gameplay_get_LocalPawn();
            if (LocalPawn) {
                Vector3 MyPos{0, 0, 0};

                auto local_m_Mesh = *(Transform **) (LocalPawn + Fields["Pawn::m_Mesh"]);
                if (local_m_Mesh) {
                    MyPos = local_m_Mesh->get_position();
                }

                auto EnemyPawns = *(List<uintptr_t> **) (m_Game + Fields["BaseGame::EnemyPawns"]);
                if (EnemyPawns) {
                    auto Items = EnemyPawns->getItems();
                    if (Items) {
                        for (int i = 0; i < EnemyPawns->getSize(); i++) {
                            auto Pawn = Items[i];
                            if (Pawn) {
                                if (!*(bool *) (Pawn + Fields["Pawn::m_IsAlive"]))
                                    continue;

                                auto m_HeadBone = *(Transform **) (Pawn + Fields["Pawn::m_HeadBone"]);
                                if (!m_HeadBone)
                                    continue;

                                auto HeadSc = WorldToScreen(m_HeadBone->get_position());

                                Vector2 v2Middle = Vector2((float) (g_screenWidth / 2), (float) (g_screenHeight / 2));
                                Vector2 v2Loc = Vector2(HeadSc.X, HeadSc.Y);

                                if (isInsideFOV((int) HeadSc.X, (int) HeadSc.Y)) {
                                    float Distance = Vector2::Distance(v2Middle, v2Loc);

                                    if (Distance < MaxDist) {
                                        result = Pawn;
                                        MaxDist = Distance;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return result;
}
// ================================================================================================================================ //

// ================================================================================================================================ //
void native_onCanvasDraw(JNIEnv *env, jobject obj, jobject canvas, int screenWidth, int screenHeight, float screenDensity) {
    static Canvas *m_Canvas = 0;
    if (!m_Canvas) {
        LOGI("Canvas Object: %p | Width: %d | Height: %d | Density: %f", canvas, screenWidth, screenHeight, screenDensity);
        m_Canvas = new Canvas(env, screenWidth, screenHeight, screenDensity);
    }

    m_Canvas->UpdateCanvas(canvas);

    g_screenWidth = screenWidth;
    g_screenHeight = screenHeight;
	
    float lineSize = m_Canvas->scaleSize(0.8f);
	
    if (!bInitDone)
        return;

    auto Screen_SetResolution = (void (*)(void *, int, int, bool)) (Methods["Screen::SetResolution"]);
    Screen_SetResolution(0, screenWidth, screenHeight, true);

    void *BaseWorld_Instance = 0;
    Il2CppGetStaticFieldValue("Assembly-CSharp.dll", "GameEngine", "BaseWorld", "Instance", &BaseWorld_Instance);
    if (Tools::IsPtrValid(BaseWorld_Instance)) {
        auto m_Game = *(uintptr_t *) ((uintptr_t) BaseWorld_Instance + Fields["BaseWorld::m_Game"]);
        if (Tools::IsPtrValid((void *) m_Game)) {
            auto Gameplay_get_LocalPawn = (uintptr_t (*)()) (Methods["Gameplay::get_LocalPawn"]);
            auto LocalPawn = Gameplay_get_LocalPawn();
              if (Tools::IsPtrValid((void *) LocalPawn)) {
                if (Config["AIM::TARGET"] == 1) {
                    m_Canvas->drawCircle(screenWidth / 2, screenHeight / 2, Config["AIM::SIZE"], 1.5f, false, ARGB(255, 0, 255, 0));
                }

                Vector3 MyPos{0, 0, 0};

                auto local_m_Mesh = *(Transform **) (LocalPawn + Fields["Pawn::m_Mesh"]);
                if (Tools::IsPtrValid(local_m_Mesh)) {
                    MyPos = local_m_Mesh->get_position();
                }

                auto EnemyPawns = *(List<uintptr_t> **) (m_Game + Fields["BaseGame::EnemyPawns"]);
                if (Tools::IsPtrValid(EnemyPawns)) {
                    auto Items = EnemyPawns->getItems();
                    if (Tools::IsPtrValid(Items)) {
                        for (int i = 0; i < EnemyPawns->getSize(); i++) {
                            auto Pawn = Items[i];
                            if (Tools::IsPtrValid((void *) Pawn)) {
                                auto m_PlayerInfo = *(uintptr_t *) (Pawn + Fields["Pawn::m_PlayerInfo"]);
                                if (Tools::IsPtrValid((void *) m_PlayerInfo)) {
                                    auto m_HeadBone = *(Transform **) (Pawn + Fields["Pawn::m_HeadBone"]);
                                    if (!Tools::IsPtrValid(m_HeadBone))
                                        continue;

                                    auto m_Mesh = *(Transform **) (Pawn + Fields["Pawn::m_Mesh"]);
                                    if (!m_Mesh)
                                        continue;

                                    auto HeadPos = m_HeadBone->get_position();
                                    auto HeadSc = WorldToScreen(HeadPos);                                 
                                    auto RootPos = m_Mesh->get_position();
                                    auto RootSc = WorldToScreen(RootPos);

                                    float Distance = Vector3::Distance(MyPos, RootPos);
                                      if (HeadSc.Z > 0) {
                                      if (Config["ESP::LINE"]) {
                                        m_Canvas->drawLine(screenWidth / 2, 0, HeadSc.X, screenHeight - HeadSc.Y, lineSize, RED);
                                       }					                                        
                                        if (Config["ESP::BOX"]) {
                                            float boxHeight = abs(HeadSc.Y - RootSc.Y);
                                            float boxWidth = boxHeight * 0.65f;
                                            Vector2 vBox = {HeadSc.X - (boxWidth / 2), HeadSc.Y};

                                            m_Canvas->drawBorder(vBox.X, screenHeight - vBox.Y, boxWidth, boxHeight, 1.5f, RED);
                                        }
                                        if (Config["ESP::HEALTH"]) {
                                            auto m_AttackableInfo = *(uintptr_t *) (Pawn + Fields["AttackableTarget::m_AttackableInfo"]);
                                            if (m_AttackableInfo) {
                                                int CurHP = (int) *(float *) (m_AttackableInfo + Fields["AttackableTargetInfo::m_Health"]);
                                                int MaxHP = (int) *(float *) (m_AttackableInfo + Fields["AttackableTargetInfo::m_MaxHealth"]);

                                                long Color = ARGB(155, std::min(((510 * (MaxHP - CurHP)) / MaxHP), 255), std::min(((510 * CurHP) / MaxHP), 255), 0);

                                                auto AboveHead = HeadPos;
                                                Vector3 AboveHeadSc = WorldToScreen(AboveHead);
                                                if (AboveHeadSc.Z > 0) {
                                                    auto mWidth = m_Canvas->scaleSize(35.f);
                                                    auto mHeight = mWidth * 0.175f;

                                                    AboveHeadSc.X -= (mWidth / 2);
                                                    AboveHeadSc.Y += (mHeight * 2);

                                                    m_Canvas->drawBox(AboveHeadSc.X, screenHeight - AboveHeadSc.Y, (CurHP * mWidth / MaxHP), mHeight, Color);
                                                    m_Canvas->drawBorder(AboveHeadSc.X, screenHeight - AboveHeadSc.Y, mWidth, mHeight, 1.0f, BLACK);
                                                }
                                            }
                                        }
                                        if (Config["ESP::NAME"] || Config["ESP::DISTANCE"]) {
                                            Vector3 BelowRoot = RootPos;
                                            Vector3 BelowRootSc = WorldToScreen(BelowRoot);
                                            if (BelowRootSc.Z > 0) {
                                                std::wstring ws;

                                                if (Config["ESP::NAME"]) {
                                                    auto m_NickName = *(String **) (m_PlayerInfo + Fields["PlayerInfo::m_NickName"]);
                                                    if (m_NickName) {
                                                        ws += m_NickName->WCString();
                                                    }

                                                    if (Config["ESP::DISTANCE"]) {
                                                        if (!ws.empty())
                                                            ws += L" [";
                                                        ws += std::to_wstring((int) Distance);
                                                        ws += L"m]";
                                                    }

                                                    auto mText = m_Canvas->getTextBounds(ws.c_str(), 0, ws.size());
                                                    m_Canvas->drawText(ws.c_str(), BelowRootSc.X, screenHeight - BelowRootSc.Y + mText->getHeight(), 7.5f, Align::CENTER,PINK, BLACK);
													}                                        
											}
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
void *Main_Thread(void *) {
    while (g_il2cpp) {
        auto t1 = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();

        void *BaseWorld_Instance = 0;
        Il2CppGetStaticFieldValue("Assembly-CSharp.dll", "GameEngine", "BaseWorld", "Instance", &BaseWorld_Instance);
        if (BaseWorld_Instance) {
            auto m_Game = *(uintptr_t *) ((uintptr_t) BaseWorld_Instance + Fields["BaseWorld::m_Game"]);
            if (m_Game) {
                auto Gameplay_get_LocalPawn = (uintptr_t (*)()) (Methods["Gameplay::get_LocalPawn"]);
                auto LocalPawn = Gameplay_get_LocalPawn();
                if (LocalPawn) {
                    if (Config["AIM::AIMBOT"]) {
                        bool bTriggerReady = Config["AIM::TRIGGER"] == 0;
                        if (Config["AIM::TRIGGER"] == 1) {
                            auto Pawn_get_IsFiring = (bool (*)(uintptr_t)) (Methods["Pawn::get_IsFiring"]);
                            bTriggerReady = Pawn_get_IsFiring(LocalPawn);
                        } else if (Config["AIM::TRIGGER"] == 2) {
                            auto Pawn_IsAiming = (bool (*)(uintptr_t)) (Methods["Pawn::IsAiming"]);
                            bTriggerReady = Pawn_IsAiming(LocalPawn);
                        }
                        if (bTriggerReady) {
                            uintptr_t Target = 0;
                            if (Config["AIM::TARGET"] == 0) {
                                Target = GetClosestTarget();
                            }
                            if (Config["AIM::TARGET"] == 1) {
                                Target = GetInsideFOVTarget();
                            }
                            if (Target) {
                                Vector3 targetPos;
                                if (Config["AIM::LOCATION"] == 0) {
                                   auto m_HeadBone = *(Transform **) (Target + Fields["Pawn::m_HeadBone"]);
                                if (!m_HeadBone)
                                    continue; 

                                targetPos = m_HeadBone->get_position();
                            }
                                if (Config["AIM::LOCATION"] == 1) {
                                   auto m_HeadBone = *(Transform **) (Target + Fields["Pawn::m_HeadBone"]);
                                if (!m_HeadBone)
                                    continue;

                                targetPos = m_HeadBone->get_position();
                                targetPos.Y -= 0.2f;
                            }
                                if (Config["AIM::LOCATION"] == 2) {
                                   auto m_HeadBone = *(Transform **) (Target + Fields["Pawn::m_HeadBone"]);
                                if (!m_HeadBone)
                                    continue;

                                targetPos = m_HeadBone->get_position();
                                targetPos.Y -= 0.4f;
                            }

                                auto main = Camera::get_main();
                                if (main) {
                                    auto mainView = ((Component *) main)->get_transform();
                                    if (mainView) {
                                        auto Pawn_SetAimRotation = (void (*)(uintptr_t, Quaternion)) (Methods["Pawn::SetAimRotation"]);
                                        Pawn_SetAimRotation(LocalPawn, Quaternion::LookRotation(targetPos - mainView->get_position(), Vector3::Up()));
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        auto td = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count() - t1;
        std::this_thread::sleep_for(std::chrono::milliseconds(std::max(std::min(0LL, SLEEP_TIME - td), SLEEP_TIME)));
    }
    return 0;
}
// ================================================================================================================================ //

void AutoAdjustResolution(uintptr_t thiz) {
    return;
}

// ================================================================================================================================ //
void *Init_Thread(void *) {
    while (!g_il2cpp) {
        g_il2cpp = Tools::GetBaseAddress("libil2cpp.so");
        sleep(1);
    }

    LOGI("libil2cpp.so: %p", g_il2cpp);

    Il2CppAttach();

    sleep(5);

    Methods["Transform::get_position"] = (uintptr_t) Il2CppGetMethodOffset("UnityEngine.dll", "UnityEngine", "Transform", "get_position");
    
    Methods["Camera::get_main"] = (uintptr_t) Il2CppGetMethodOffset("UnityEngine.dll", "UnityEngine", "Camera", "get_main");
    
    Methods["Camera::WorldToScreenPoint"] = (uintptr_t) Il2CppGetMethodOffset("UnityEngine.dll", "UnityEngine", "Camera", "WorldToScreenPoint", 1);
    
    Methods["Component::get_transform"] = (uintptr_t) Il2CppGetMethodOffset("UnityEngine.dll", "UnityEngine", "Component", "get_transform");
    
   Methods["Screen::SetResolution"] = (uintptr_t) Il2CppGetMethodOffset("UnityEngine.dll", "UnityEngine", "Screen", "SetResolution", 3);
    
    Methods["Gameplay::get_LocalPawn"] = (uintptr_t) Il2CppGetMethodOffset("Assembly-CSharp.dll", "GameEngine", "GamePlay", "get_LocalPawn");

    Fields["BaseWorld::m_Game"] = Il2CppGetFieldOffset("Assembly-CSharp.dll", "GameEngine", "BaseWorld", "m_Game");
    Fields["BaseGame::AllPawns"] = Il2CppGetFieldOffset("Assembly-CSharp.dll", "GameBase", "BaseGame", "AllPawns");
    Fields["BaseGame::EnemyPawns"] = Il2CppGetFieldOffset("Assembly-CSharp.dll", "GameBase", "BaseGame", "EnemyPawns");

    Methods["Pawn::SetAimRotation"] = (uintptr_t) Il2CppGetMethodOffset("Assembly-CSharp.dll", "GameBase", "Pawn", "SetAimRotation", 1);
    Methods["Pawn::get_IsFiring"] = (uintptr_t) Il2CppGetMethodOffset("Assembly-CSharp.dll", "GameBase", "Pawn", "get_IsFiring");
    Methods["Pawn::IsAiming"] = (uintptr_t) Il2CppGetMethodOffset("Assembly-CSharp.dll", "GameBase", "Pawn", "IsAiming");

    Fields["Pawn::m_PlayerInfo"] = Il2CppGetFieldOffset("Assembly-CSharp.dll", "GameBase", "Pawn", "m_PlayerInfo");
    Fields["Pawn::get_HeadBone"] = Il2CppGetFieldOffset("Assembly-CSharp.dll", "GameBase", "Pawn", "get_HeadBone");
    Fields["Pawn::m_HeadBone"] = Il2CppGetFieldOffset("Assembly-CSharp.dll", "GameBase", "Pawn", "m_HeadBone");
    Fields["Pawn::m_Mesh"] = Il2CppGetFieldOffset("Assembly-CSharp.dll", "GameBase", "Pawn", "m_Mesh");
    Fields["Pawn::m_IsAlive"] = Il2CppGetFieldOffset("Assembly-CSharp.dll", "GameBase", "Pawn", "m_IsAlive");

    Fields["AttackableTarget::m_AttackableInfo"] = Il2CppGetFieldOffset("Assembly-CSharp.dll", "GameEngine", "AttackableTarget", "m_AttackableInfo");
    Fields["AttackableTargetInfo::m_Health"] = Il2CppGetFieldOffset("Assembly-CSharp.dll", "GameEngine", "AttackableTargetInfo", "m_Health");
    Fields["AttackableTargetInfo::m_MaxHealth"] = Il2CppGetFieldOffset("Assembly-CSharp.dll", "GameEngine", "AttackableTargetInfo", "m_MaxHealth");

    Fields["PlayerInfo::m_NickName"] = Il2CppGetFieldOffset("Assembly-CSharp.dll", "GameEngine", "PlayerInfo", "m_NickName");


    bInitDone = true;

    return 0;
}

void native_Init(JNIEnv *env, jclass clazz, jobject mContext) {
    pthread_t t;
    pthread_create(&t, 0, Init_Thread, 0);
}


```

`app/src/main/jni/Engine/Canvas.cpp`:

```cpp
//
// Created by aimar on 1/13/2020.
//

#include "Canvas.h"
#include "Rect.h"
#include "Path.h"
#include <wchar.h>
#include <string.h>

jstring wcstojstr(JNIEnv *env, const wchar_t *input) {
    jobject bb = env->NewDirectByteBuffer((void *) input, wcslen(input) * sizeof(wchar_t));
    static jstring UTF32LE = 0;
    if (!UTF32LE)
        UTF32LE = (jstring) env->NewGlobalRef(env->NewStringUTF("UTF-32LE"));

    static jclass charsetClass = 0;
    if (!charsetClass)
        charsetClass = env->FindClass("java/nio/charset/Charset");

    static jmethodID forNameMethod = 0;
    if (!forNameMethod)
        forNameMethod = env->GetStaticMethodID(charsetClass, "forName", "(Ljava/lang/String;)Ljava/nio/charset/Charset;");

    static jobject charset = 0;
    if (!charset)
        charset = env->NewGlobalRef(env->CallStaticObjectMethod(charsetClass, forNameMethod, UTF32LE));

    static jmethodID decodeMethod = 0;
    if (!decodeMethod)
        decodeMethod = env->GetMethodID(charsetClass, "decode", "(Ljava/nio/ByteBuffer;)Ljava/nio/CharBuffer;");

    jobject cb = env->CallObjectMethod(charset, decodeMethod, bb);

    static jclass charBufferClass = 0;
    if (!charBufferClass)
        charBufferClass = env->FindClass("java/nio/CharBuffer");

    static jmethodID toStringMethod = 0;
    if (!toStringMethod)
        toStringMethod = env->GetMethodID(charBufferClass, "toString", "()Ljava/lang/String;");

    auto ret = (jstring) env->CallObjectMethod(cb, toStringMethod);

    env->DeleteLocalRef(bb);
    env->DeleteLocalRef(cb);

    return ret;
}

Canvas::Canvas(JNIEnv *env, int width, int height, float density) {
    this->env = env;

    this->low = false;

    this->m_Width = width;
    this->m_Height = height;
    this->m_Density = density;

    jclass canvasClass = env->FindClass("android/graphics/Canvas");
    drawTextId = env->GetMethodID(canvasClass, "drawText", "(Ljava/lang/String;FFLandroid/graphics/Paint;)V");
    drawRectId = env->GetMethodID(canvasClass, "drawRect", "(FFFFLandroid/graphics/Paint;)V");
    drawLineId = env->GetMethodID(canvasClass, "drawLine", "(FFFFLandroid/graphics/Paint;)V");
    drawCircleId = env->GetMethodID(canvasClass, "drawCircle", "(FFFLandroid/graphics/Paint;)V");
    drawColorId = env->GetMethodID(canvasClass, "drawColor", "(ILandroid/graphics/PorterDuff$Mode;)V");
    drawPathId = env->GetMethodID(canvasClass, "drawPath", "(Landroid/graphics/Path;Landroid/graphics/Paint;)V");
    rotateId = env->GetMethodID(canvasClass, "rotate", "(F)V");
    restoreId = env->GetMethodID(canvasClass, "restore", "()V");
    env->DeleteLocalRef(canvasClass);

    jclass cls = env->FindClass("android/graphics/PorterDuff$Mode");
    auto id = env->GetStaticFieldID(cls, "CLEAR", "Landroid/graphics/PorterDuff$Mode;");
    clearObj = env->NewGlobalRef(env->GetStaticObjectField(cls, id));
    env->DeleteLocalRef(cls);

    m_Rect = new Rect(this->env);
    m_Typeface = new Typeface(this->env);
    m_CurrentTypeface = env->NewGlobalRef(m_Typeface->create("Arial Rounded MT", (int) FontStyle::BOLD));
    m_Path = new Path(this->env);

    m_TextPaint = new Paint(this->env);
    m_TextPaint->setTypeface(this->m_CurrentTypeface);
    m_TextPaint->setStyle(Style::FILL);
    m_TextPaint->setAntiAlias(true);

    m_LinePaint = new Paint(this->env);
    m_LinePaint->setStyle(Style::STROKE);
    m_LinePaint->setAntiAlias(true);

    m_FillPaint = new Paint(this->env);
    m_FillPaint->setStyle(Style::FILL);
    m_FillPaint->setAntiAlias(true);

    m_Paint = new Paint(this->env);
    m_Paint->setStyle(Style::FILL_AND_STROKE);
    m_Paint->setAntiAlias(true);
}

float Canvas::scaleSize(float size) {
    return size * m_Density;
}

int Canvas::scaleSize(int size) {
    return (int) ((float) size * m_Density);
}

void Canvas::UpdateCanvas(jobject canvas) {
    this->m_CanvasObj = canvas;
}

void Canvas::LowMode(bool b) {
    this->low = b;

    m_TextPaint->setAntiAlias(b);
    m_LinePaint->setAntiAlias(b);
    m_FillPaint->setAntiAlias(b);
    m_Paint->setAntiAlias(b);
}

void Canvas::drawText(const char *text, float X, float Y, float size, Align align, int textColor, int outlineColor) {
    Paint *paint = this->m_TextPaint;

    paint->setTextSize(this->scaleSize(size));
    paint->setTextAlign(align);

    jstring str = env->NewStringUTF(text);

    if (!low) {
        paint->setColor(outlineColor);
        env->CallVoidMethod(this->m_CanvasObj, this->drawTextId, str, X - 1, Y - 1, paint->paintObj);
        env->CallVoidMethod(this->m_CanvasObj, this->drawTextId, str, X + 1, Y + 1, paint->paintObj);
        env->CallVoidMethod(this->m_CanvasObj, this->drawTextId, str, X - 1, Y + 1, paint->paintObj);
        env->CallVoidMethod(this->m_CanvasObj, this->drawTextId, str, X + 1, Y - 1, paint->paintObj);
    }

    paint->setColor(textColor);
    env->CallVoidMethod(this->m_CanvasObj, this->drawTextId, str, X, Y, paint->paintObj);

    env->DeleteLocalRef(str);
}

void Canvas::drawText(const wchar_t *text, float X, float Y, float size, Align align, int textColor, int outlineColor) {
    Paint *paint = this->m_TextPaint;

    paint->setTextSize(this->scaleSize(size));
    paint->setTextAlign(align);

    jstring convertedStr = wcstojstr(env, text);

    if (!low) {
        paint->setColor(outlineColor);
        env->CallVoidMethod(this->m_CanvasObj, this->drawTextId, convertedStr, X - 1, Y - 1, paint->paintObj);
        env->CallVoidMethod(this->m_CanvasObj, this->drawTextId, convertedStr, X + 1, Y + 1, paint->paintObj);
        env->CallVoidMethod(this->m_CanvasObj, this->drawTextId, convertedStr, X - 1, Y + 1, paint->paintObj);
        env->CallVoidMethod(this->m_CanvasObj, this->drawTextId, convertedStr, X + 1, Y - 1, paint->paintObj);
    }

    paint->setColor(textColor);
    env->CallVoidMethod(this->m_CanvasObj, this->drawTextId, convertedStr, X, Y, paint->paintObj);

    env->DeleteLocalRef(convertedStr);
}

void Canvas::drawText(std::vector<std::string> s, float X, float Y, float size, Align align, std::vector<int> textColor, std::vector<int> outlineColor) {
    std::vector<float> centerPos;
    if (align == CENTER) {

    }
    int lastTextColor = 0, lastOutlineColor = 0;
    for (int i = 0; i < s.size(); i++) {
        int c = textColor.size() >= i ? textColor[i] : lastTextColor;
        lastTextColor = c;
        int oc = outlineColor.size() >= i ? outlineColor[i] : lastOutlineColor;
        lastOutlineColor = oc;
        drawText(s[i].c_str(), X, Y, size, align, c, oc);

        if (align == LEFT)
            X += m_TextPaint->measureText(s[i].c_str());
        else if (align == CENTER)
            X -= m_TextPaint->measureText(s[i].c_str());
        else if (align == RIGHT)
            X -= m_TextPaint->measureText(s[i].c_str());
    }
}

void Canvas::drawText(std::vector<std::wstring> s, float X, float Y, float size, Align align, std::vector<int> textColor, std::vector<int> outlineColor) {
    int lastTextColor = 0, lastOutlineColor = 0;
    for (int i = 0; i < s.size(); i++) {
        int c = textColor.size() >= i ? textColor[i] : lastTextColor;
        lastTextColor = c;
        int oc = outlineColor.size() >= i ? outlineColor[i] : lastOutlineColor;
        lastOutlineColor = oc;
        drawText(s[i].c_str(), X, Y, size, align, c, oc);

        if (align == LEFT)
            X += m_TextPaint->measureText(s[i].c_str());
        else if (align == CENTER)
            X += m_TextPaint->measureText(s[i].c_str()) + (m_TextPaint->measureText(s[i].c_str()) / 2);
        else if (align == RIGHT)
            X -= m_TextPaint->measureText(s[i].c_str());
    }
}

void Canvas::drawBox(float X, float Y, float width, float height, int color) {
    Paint *paint = this->m_FillPaint;

    paint->setColor(color);

    env->CallVoidMethod(this->m_CanvasObj, this->drawRectId, X, Y, X + width, Y + height, paint->paintObj);
}

void Canvas::drawBorder(float X, float Y, float width, float height, float thicc, int color) {
    Paint *paint = this->m_LinePaint;

    paint->setColor(color);
    paint->setStrokeWidth(thicc);

    env->CallVoidMethod(this->m_CanvasObj, this->drawRectId, X, Y, X + width, Y + height, paint->paintObj);
}

void Canvas::drawBorderRect(float left, float top, float right, float bottom, float thicc, int color) {
    Paint *paint = this->m_LinePaint;

    paint->setColor(color);
    paint->setStrokeWidth(thicc);

    env->CallVoidMethod(this->m_CanvasObj, this->drawRectId, left, top, right, bottom, paint->paintObj);
}

void Canvas::drawLine(float startX, float startY, float stopX, float stopY, float thicc, int color) {
    Paint *paint = this->m_LinePaint;

    paint->setColor(color);
    paint->setStrokeWidth(thicc);

    env->CallVoidMethod(this->m_CanvasObj, this->drawLineId, startX, startY, stopX, stopY, paint->paintObj);
}

void Canvas::drawCircle(float x, float y, float radius, float thicc, bool fill, int color) {
    Paint *paint = this->m_Paint;

    if (!fill)
        paint->setStyle(Style::STROKE);
    else
        paint->setStyle(Style::FILL);

    paint->setColor(color);
    paint->setStrokeWidth(thicc);

    env->CallVoidMethod(this->m_CanvasObj, this->drawCircleId, x, y, radius, paint->paintObj);
}

void Canvas::drawFilledTriangle(Point a, Point b, Point c, int color) {
    Paint *paint = this->m_FillPaint;

    paint->setColor(color);

    Path *path = this->m_Path;
    path->reset();
    path->moveTo(a.x, a.y);
    path->lineTo(b.x, b.y);
    path->lineTo(c.x, c.y);
    path->lineTo(a.x, a.y);
    path->close();

    env->CallVoidMethod(this->m_CanvasObj, this->drawPathId, path->pathObj, paint->paintObj);
}

void Canvas::rotate(float degrees) {
    return env->CallVoidMethod(this->m_CanvasObj, this->rotateId, degrees);
}

void Canvas::restore() {
    return env->CallVoidMethod(this->m_CanvasObj, this->restoreId);
}

Rect *Canvas::getTextBounds(const char *text, int start, int end) {
    return m_TextPaint->getTextBounds(text, start, end);
}

Rect *Canvas::getTextBounds(const wchar_t *text, int start, int end) {
    return m_TextPaint->getTextBounds(text, start, end);
}

float Canvas::measureText(const char *text) {
    return m_TextPaint->measureText(text);
}

float Canvas::measureText(const wchar_t *text) {
    return m_TextPaint->measureText(text);
}

```

`app/src/main/jni/Engine/Canvas.h`:

```h
//
// Created by aimar on 1/13/2020.
//

#ifndef CANVAS_H
#define CANVAS_H

#include <jni.h>

#include "Const.h"

#include "Typeface.h"
#include "Rect.h"
#include "Path.h"
#include "Paint.h"

class Canvas
{
private:
    jobject m_CanvasObj, m_CurrentTypeface, clearObj;
    jmethodID drawTextId;
    jmethodID drawRectId;
    jmethodID drawLineId;
    jmethodID drawCircleId;
    jmethodID drawColorId;
    jmethodID drawPathId;
    jmethodID rotateId;
    jmethodID restoreId;

    int m_Width, m_Height; float m_Density;
    bool low;

    Rect *m_Rect;
    Typeface *m_Typeface;
    Path* m_Path;

    class Paint *m_TextPaint;
    class Paint *m_LinePaint;
    class Paint *m_FillPaint;
    class Paint *m_Paint;
public:
    JNIEnv *env;
    Canvas(JNIEnv *env, int width, int height, float density);

    void UpdateCanvas(jobject canvas);
    void LowMode(bool b);

    float scaleSize(float size);
    int scaleSize(int size);

    void drawText(const char *text, float X, float Y, float size = 10, Align align = Align::LEFT, int textColor = 0xFFFFFFFF, int outlineColor = 0x0);
    void drawText(const wchar_t *text, float X, float Y, float size = 10, Align align = Align::LEFT, int textColor = 0xFFFFFFFF, int outlineColor = 0x0);
    void drawText(std::vector<std::string> s, float X, float Y, float size = 10, Align align = Align::LEFT, std::vector<int> textColor=std::vector<int>(), std::vector<int> outlineColor=std::vector<int>());
    void drawText(std::vector<std::wstring> s, float X, float Y, float size = 10, Align align = Align::LEFT, std::vector<int> textColor=std::vector<int>(), std::vector<int> outlineColor=std::vector<int>());
    void drawBox(float X, float Y, float width, float height, int color = 0xFFFFFFFF);
    void drawBorder(float X, float Y, float width, float height, float thicc, int color = 0xFFFFFFFF);
    void drawBorderRect(float left, float top, float right, float bottom, float thicc, int color = 0xFFFFFFFF);
    void drawLine(float startX, float startY, float stopX, float stopY, float thicc, int color = 0xFFFFFFFF);
    void drawCircle(float x, float y, float radius, float thicc, bool fill = false, int color = 0xFFFFFFFF);
    void drawFilledTriangle(Point a, Point b, Point c, int color = 0xFFFFFFFF);
    void rotate(float degrees);
    void restore();

    Rect *getTextBounds(const char *text, int start, int end);
    Rect *getTextBounds(const wchar_t *text, int start, int end);

    float measureText(const char *text);
    float measureText(const wchar_t *text);
};


#endif //ML_CANVAS_H

```

`app/src/main/jni/Engine/Const.h`:

```h
#pragma once

#include <map>
#include <stdio.h>
#include <vector>
#include <string>

#ifndef ENGINE_CONST
#define ENGINE_CONST

#define ARGB(a, r, g, b) 0 | a << 24 | r << 16 | g << 8 | b

#define WHITE               ARGB(255, 255, 255, 255)
#define RED                 ARGB(255, 255, 000, 000)
#define GREEN               ARGB(255, 000, 128, 000)
#define LIME                ARGB(255, 000, 255, 000)
#define BLUE                ARGB(255, 000, 000, 255)
#define BLACK               ARGB(255, 000, 000, 000)
#define PURPLE              ARGB(255, 125, 000, 255)
#define GREY                ARGB(255, 128, 128, 128)
#define YELLOW              ARGB(255, 255, 255, 000)
#define ORANGE              ARGB(255, 255, 125, 000)
#define DARK_GREEN          ARGB(255, 000, 100, 000)
#define PINK                ARGB(255, 255, 192, 203)
#define BROWN               ARGB(255, 210, 105, 30)
#define CYAN                ARGB(255, 000, 255, 255)

enum Style {
    FILL = 0,
    STROKE = 1,
    FILL_AND_STROKE = 2
};

enum Align {
    LEFT = 0,
    RIGHT = 1,
    CENTER
};

struct Point {
    float x, y;
};

#endif
```

`app/src/main/jni/Engine/Paint.cpp`:

```cpp
//
// Created by aimar on 1/13/2020.
//

#include "Paint.h"
#include "Canvas.h"
#include <wchar.h>

jstring wcstojstr2(JNIEnv *env, const wchar_t *input) {
    jobject bb = env->NewDirectByteBuffer((void *) input, wcslen(input) * sizeof(wchar_t));
    static jstring UTF32LE = 0;
    if (!UTF32LE)
        UTF32LE = (jstring) env->NewGlobalRef(env->NewStringUTF("UTF-32LE"));

    static jclass charsetClass = 0;
    if (!charsetClass)
        charsetClass = env->FindClass("java/nio/charset/Charset");

    static jmethodID forNameMethod = 0;
    if (!forNameMethod)
        forNameMethod = env->GetStaticMethodID(charsetClass, "forName", "(Ljava/lang/String;)Ljava/nio/charset/Charset;");

    static jobject charset = 0;
    if (!charset)
        charset = env->NewGlobalRef(env->CallStaticObjectMethod(charsetClass, forNameMethod, UTF32LE));

    static jmethodID decodeMethod = 0;
    if (!decodeMethod)
        decodeMethod = env->GetMethodID(charsetClass, "decode", "(Ljava/nio/ByteBuffer;)Ljava/nio/CharBuffer;");

    jobject cb = env->CallObjectMethod(charset, decodeMethod, bb);

    static jclass charBufferClass = 0;
    if (!charBufferClass)
        charBufferClass = env->FindClass("java/nio/CharBuffer");

    static jmethodID toStringMethod = 0;
    if (!toStringMethod)
        toStringMethod = env->GetMethodID(charBufferClass, "toString", "()Ljava/lang/String;");

    auto ret = (jstring) env->CallObjectMethod(cb, toStringMethod);

    env->DeleteLocalRef(bb);
    env->DeleteLocalRef(cb);

    return ret;
}

void Paint::setTextSize(float size) {
    env->CallVoidMethod(this->paintObj, this->setTextSizeId, size);
}

void Paint::setColor(int color) {
    env->CallVoidMethod(this->paintObj, this->setColorId, color);
}

void Paint::setStyle(Style style) {
    if (style == Style::FILL)
        env->CallVoidMethod(this->paintObj, this->setStyleId, this->Style_FILL);
    if (style == Style::STROKE)
        env->CallVoidMethod(this->paintObj, this->setStyleId, this->Style_STROKE);
    if (style == Style::FILL_AND_STROKE)
        env->CallVoidMethod(this->paintObj, this->setStyleId, this->Style_FILL_AND_STROKE);
}

Rect *Paint::getTextBounds(const char *text, int start, int end) {
    jstring str = env->NewStringUTF(text);
    env->CallVoidMethod(this->paintObj, this->getTextBoundsId, str, start, end, m_Rect->rectObj);
    env->DeleteLocalRef(str);
    return m_Rect;
}

Rect *Paint::getTextBounds(const wchar_t *text, int start, int end) {
    jstring str = wcstojstr2(this->env, text);
    env->CallVoidMethod(this->paintObj, this->getTextBoundsId, str, start, end, m_Rect->rectObj);
    env->DeleteLocalRef(str);
    return m_Rect;
}

void Paint::setStrokeWidth(float size) {
    env->CallVoidMethod(this->paintObj, this->setStrokeWidthId, size);
}

void Paint::setTextAlign(Align align) {
    if (align == Align::LEFT)
        env->CallVoidMethod(this->paintObj, this->setTextAlignId, this->Align_LEFT);
    if (align == Align::RIGHT)
        env->CallVoidMethod(this->paintObj, this->setTextAlignId, this->Align_RIGHT);
    if (align == Align::CENTER)
        env->CallVoidMethod(this->paintObj, this->setTextAlignId, this->Align_CENTER);
}

float Paint::ascent() {
    return env->CallFloatMethod(this->paintObj, this->ascentId);
}

float Paint::descent() {
    return env->CallFloatMethod(this->paintObj, this->descentId);
}

void Paint::setShadowLayer(float radius, float dx, float dy, int shadowColor) {
    return env->CallVoidMethod(this->paintObj, this->setShadowLayerId, radius, dx, dy, shadowColor);
}

void Paint::setTypeface(jobject typeface) {
    auto result = env->CallObjectMethod(this->paintObj, this->setTypefaceId, typeface);
    env->DeleteLocalRef(result);
}

void Paint::setAntiAlias(bool bUseAA) {
    return env->CallVoidMethod(this->paintObj, this->setAntiAliasId, bUseAA);
}

float Paint::measureText(const char *text) {
    auto str = env->NewStringUTF(text);
    auto f = env->CallFloatMethod(this->paintObj, this->measureTextId, str);
    env->DeleteLocalRef(str);
    return f;
}

float Paint::measureText(const wchar_t *text) {
    auto str = wcstojstr2(env, text);
    auto f = env->CallFloatMethod(this->paintObj, this->measureTextId, str);
    env->DeleteLocalRef(str);
    return f;
}
```

`app/src/main/jni/Engine/Paint.h`:

```h
//
// Created by aimar on 1/13/2020.
//

#ifndef PAINT_H
#define PAINT_H

#include <jni.h>

#include "Const.h"

#include "Canvas.h"
#include "Typeface.h"

class Paint {
public:
    JNIEnv *env;

    Rect *m_Rect;
    jobject paintObj;

    jmethodID setStyleId;
    jmethodID setTextSizeId;
    jmethodID setColorId;
    jmethodID getTextBoundsId;
    jmethodID setStrokeWidthId;
    jmethodID setTextAlignId;
    jmethodID ascentId;
    jmethodID descentId;
    jmethodID setShadowLayerId;
    jmethodID setTypefaceId;
    jmethodID setAntiAliasId;
    jmethodID measureTextId;

    jobject Style_FILL, Style_STROKE, Style_FILL_AND_STROKE;
    jobject Align_LEFT, Align_RIGHT, Align_CENTER;

    Paint(JNIEnv *env) {
        this->env = env;

        m_Rect = new Rect(env);

        jclass paintClass = env->FindClass("android/graphics/Paint");
        jmethodID init = env->GetMethodID(paintClass, "<init>", "()V");
        this->paintObj = env->NewGlobalRef(env->NewObject(paintClass, init));

        setStyleId = env->GetMethodID(paintClass, "setStyle", "(Landroid/graphics/Paint$Style;)V");
        setTextSizeId = env->GetMethodID(paintClass, "setTextSize", "(F)V");
        setColorId = env->GetMethodID(paintClass, "setColor", "(I)V");
        getTextBoundsId = env->GetMethodID(paintClass, "getTextBounds", "(Ljava/lang/String;IILandroid/graphics/Rect;)V");
        setStrokeWidthId = env->GetMethodID(paintClass, "setStrokeWidth", "(F)V");
        setTextAlignId = env->GetMethodID(paintClass, "setTextAlign", "(Landroid/graphics/Paint$Align;)V");
        ascentId = env->GetMethodID(paintClass, "ascent", "()F");
        descentId = env->GetMethodID(paintClass, "descent", "()F");
        setShadowLayerId = env->GetMethodID(paintClass, "setShadowLayer", "(FFFI)V");
        setTypefaceId = env->GetMethodID(paintClass, "setTypeface", "(Landroid/graphics/Typeface;)Landroid/graphics/Typeface;");
        setAntiAliasId = env->GetMethodID(paintClass, "setAntiAlias", "(Z)V");
        measureTextId = env->GetMethodID(paintClass, "measureText", "(Ljava/lang/String;)F");
        env->DeleteLocalRef(paintClass);

        jclass styleClass = env->FindClass("android/graphics/Paint$Style");
        jfieldID id = env->GetStaticFieldID(styleClass, "FILL", "Landroid/graphics/Paint$Style;");
        Style_FILL = env->NewGlobalRef(env->GetStaticObjectField(styleClass, id));
        id = env->GetStaticFieldID(styleClass, "STROKE", "Landroid/graphics/Paint$Style;");
        Style_STROKE = env->NewGlobalRef(env->GetStaticObjectField(styleClass, id));
        id = env->GetStaticFieldID(styleClass, "FILL_AND_STROKE", "Landroid/graphics/Paint$Style;");
        Style_FILL_AND_STROKE = env->NewGlobalRef(env->GetStaticObjectField(styleClass, id));
        env->DeleteLocalRef(styleClass);

        jclass alignClass = env->FindClass("android/graphics/Paint$Align");
        id = env->GetStaticFieldID(alignClass, "LEFT", "Landroid/graphics/Paint$Align;");
        Align_LEFT = env->NewGlobalRef(env->GetStaticObjectField(alignClass, id));
        id = env->GetStaticFieldID(alignClass, "RIGHT", "Landroid/graphics/Paint$Align;");
        Align_RIGHT = env->NewGlobalRef(env->GetStaticObjectField(alignClass, id));
        id = env->GetStaticFieldID(alignClass, "CENTER", "Landroid/graphics/Paint$Align;");
        Align_CENTER = env->NewGlobalRef(env->GetStaticObjectField(alignClass, id));
        env->DeleteLocalRef(alignClass);
    }

    void setStyle(Style style);
    void setTextSize(float size);
    void setColor(int color);
    Rect *getTextBounds(const char *text, int start, int end);
    Rect *getTextBounds(const wchar_t *text, int start, int end);
    void setStrokeWidth(float size = 1.0f);
    void setShadowLayer(float radius, float dx, float dy, int shadowColor);
    void setTextAlign(Align align);
    void setTypeface(jobject typeface);
    void setAntiAlias(bool bUseAA);
    float measureText(const char *text);
    float measureText(const wchar_t *text);
    float ascent();
    float descent();
};


#endif //ML_PAINT_H

```

`app/src/main/jni/Engine/Path.cpp`:

```cpp
//
// Created by ASUS on 23/11/2020.
//

#include "Path.h"

void Path::lineTo(float x, float y) {
    return env->CallVoidMethod(this->pathObj, this->lineToId, x, y);
}

void Path::moveTo(float x, float y) {
    return env->CallVoidMethod(this->pathObj, this->moveToId, x, y);
}

void Path::close() {
    return env->CallVoidMethod(this->pathObj, this->closeId);
}

void Path::reset() {
    return env->CallVoidMethod(this->pathObj, this->resetId);
}
```

`app/src/main/jni/Engine/Path.h`:

```h
//
// Created by ASUS on 23/11/2020.
//

#ifndef PATH_H
#define PATH_H

#include <jni.h>

#include "Const.h"

class Path {
public:
    JNIEnv *env;
    jobject pathObj;

    jmethodID lineToId;
    jmethodID moveToId;
    jmethodID closeId;
    jmethodID resetId;

    Path(JNIEnv *env) {
        this->env = env;

        jclass pathClass = env->FindClass("android/graphics/Path");
        jmethodID init = env->GetMethodID(pathClass, "<init>", "()V");
        this->pathObj = env->NewGlobalRef(env->NewObject(pathClass, init));

        lineToId = env->GetMethodID(pathClass, "lineTo", "(FF)V");
        moveToId = env->GetMethodID(pathClass, "moveTo", "(FF)V");
        closeId = env->GetMethodID(pathClass, "close", "()V");
        resetId = env->GetMethodID(pathClass, "reset", "()V");

        env->DeleteLocalRef(pathClass);
    }

    void lineTo(float x, float y);
    void moveTo(float x, float y);
    void close();
    void reset();
};


#endif //PUBG_PATH_H

```

`app/src/main/jni/Engine/Rect.cpp`:

```cpp
//
// Created by aimar on 1/13/2020.
//

#include "Rect.h"

int Rect::getLeft() {
    return env->GetIntField(this->rectObj, this->leftId);
}

int Rect::getRight(){
    return env->GetIntField(this->rectObj, this->rightId);
}

int Rect::getTop(){
    return env->GetIntField(this->rectObj, this->topId);
}

int Rect::getBottom(){
    return env->GetIntField(this->rectObj, this->bottomId);
}

int Rect::getWidth() {
    return getRight() - getLeft();
}

int Rect::getHeight() {
    return getBottom() - getTop();
}
```

`app/src/main/jni/Engine/Rect.h`:

```h
//
// Created by aimar on 1/13/2020.
//

#ifndef RECT_H
#define RECT_H

#include <jni.h>

#include "Const.h"

class Rect {
public:
    JNIEnv *env;
    jobject rectObj;

    jfieldID leftId, topId, rightId, bottomId;

    Rect(JNIEnv *env) {
        this->env = env;

        jclass rectClass = env->FindClass("android/graphics/Rect");
        jmethodID init = env->GetMethodID(rectClass, "<init>", "()V");
        this->rectObj = env->NewGlobalRef(env->NewObject(rectClass, init));

        leftId = env->GetFieldID(rectClass, "left", "I");
        topId = env->GetFieldID(rectClass, "top", "I");
        rightId = env->GetFieldID(rectClass, "right", "I");
        bottomId = env->GetFieldID(rectClass, "bottom", "I");

        env->DeleteLocalRef(rectClass);
    }

    int getLeft();
    int getRight();
    int getTop();
    int getBottom();
    int getWidth();
    int getHeight();
};


#endif //MENU_RECT_H

```

`app/src/main/jni/Engine/Typeface.cpp`:

```cpp
//
// Created by aimar on 5/3/2020.
//

#include "Typeface.h"

jobject Typeface::create(const char *family, int style) {
    jstring fam = env->NewStringUTF(family);

    jobject result = env->CallStaticObjectMethod(this->typefaceObj, this->createMethod, fam, style);

    env->DeleteLocalRef(fam);

    return result;
}
```

`app/src/main/jni/Engine/Typeface.h`:

```h
//
// Created by aimar on 5/3/2020.
//

#ifndef TYPEFACE_H
#define TYPEFACE_H

#include <jni.h>

enum FontStyle
{
    NORMAL = 0,
    BOLD = 1,
    ITALIC = 2,
    BOLD_ITALIC = 3
};

class Typeface {
public:
    JNIEnv *env;
    jclass typefaceObj;

    jmethodID createMethod;

    Typeface(JNIEnv *env)
    {
        this->env = env;

        typefaceObj = env->FindClass("android/graphics/Typeface");
        createMethod = env->GetStaticMethodID(typefaceObj, "create", "(Ljava/lang/String;I)Landroid/graphics/Typeface;");
    }

    jobject create(const char *family, int style);
};


#endif //PUBG_TYPEFACE_H

```

`app/src/main/jni/Il2Cpp.cpp`:

```cpp
#include "Il2Cpp.h"

#include "Includes.h"
#include "fake_dlfcn.h"

#define LOG_TAG "Chitoge-Il2Cpp"

#define IL2CPP_LOGI(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)
#define IL2CPP_LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,LOG_TAG,__VA_ARGS__)
#define IL2CPP_LOGW(...) __android_log_print(ANDROID_LOG_WARN,LOG_TAG,__VA_ARGS__)
#define IL2CPP_LOGE(...) __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)
// =========================================================================== //
namespace {
    const void *(*il2cpp_assembly_get_image)(const void *assembly);
    void *(*il2cpp_domain_get)();
    void **(*il2cpp_domain_get_assemblies)(const void *domain, size_t *size);
    const char *(*il2cpp_image_get_name)(void *image);
    void *(*il2cpp_class_from_name)(const void *image, const char *namespaze, const char *name);
    void *(*il2cpp_class_get_field_from_name)(void *klass, const char *name);
    void *(*il2cpp_class_get_method_from_name)(void *klass, const char *name, int argsCount);
    size_t (*il2cpp_field_get_offset)(void *field);
    void (*il2cpp_field_static_get_value)(void *field, void *value);
    void (*il2cpp_field_static_set_value)(void *field, void *value);
    void *(*il2cpp_array_new)(void *elementTypeInfo, size_t length);
    uint16_t *(*il2cpp_string_chars)(void *str);
    Il2CppString *(*il2cpp_string_new)(const char *str);
    Il2CppString *(*il2cpp_string_new_utf16)(const wchar_t *str, int32_t length);
    char *(*il2cpp_type_get_name)(void *type);
    void* (*il2cpp_method_get_param)(void *method, uint32_t index);
    void* (*il2cpp_class_get_methods)(void *klass, void* *iter);
    const char* (*il2cpp_method_get_name)(void *method);
    void *(*il2cpp_object_new)(void *klass);
}
// =========================================================================== //
void Il2CppAttach(const char *name)
{
    void *handle = dlopen_ex(name, 0);
    while (!handle) {
        handle = dlopen_ex(name, 0);
        sleep(1);
    }

    il2cpp_assembly_get_image = (const void *(*)(const void *)) dlsym_ex(handle, "il2cpp_assembly_get_image");
    il2cpp_domain_get = (void *(*)()) dlsym_ex(handle, "il2cpp_domain_get");
    il2cpp_domain_get_assemblies = (void **(*)(const void* , size_t*)) dlsym_ex(handle, "il2cpp_domain_get_assemblies");
    il2cpp_image_get_name = (const char *(*)(void *)) dlsym_ex(handle, "il2cpp_image_get_name");
    il2cpp_class_from_name = (void* (*)(const void*, const char*, const char *)) dlsym_ex(handle, "il2cpp_class_from_name");
    il2cpp_class_get_field_from_name = (void* (*)(void*, const char *)) dlsym_ex(handle, "il2cpp_class_get_field_from_name");
    il2cpp_class_get_method_from_name = (void* (*)(void *, const char*, int)) dlsym_ex(handle, "il2cpp_class_get_method_from_name");
    il2cpp_field_get_offset = (size_t (*)(void *)) dlsym_ex(handle, "il2cpp_field_get_offset");
    il2cpp_field_static_get_value = (void (*)(void*, void *)) dlsym_ex(handle, "il2cpp_field_static_get_value");
    il2cpp_field_static_set_value = (void (*)(void*, void *)) dlsym_ex(handle, "il2cpp_field_static_set_value");
    il2cpp_array_new = (void *(*)(void*, size_t)) dlsym_ex(handle, "il2cpp_array_new");
    il2cpp_string_chars = (uint16_t *(*)(void*)) dlsym_ex(handle, "il2cpp_string_chars");
    il2cpp_string_new = (Il2CppString *(*)(const char *)) dlsym_ex(handle, "il2cpp_string_new");
    il2cpp_string_new_utf16 = (Il2CppString *(*)(const wchar_t *, int32_t)) dlsym_ex(handle, "il2cpp_string_new");
    il2cpp_type_get_name = (char *(*)(void *)) dlsym_ex(handle, "il2cpp_type_get_name");
    il2cpp_method_get_param = (void *(*)(void *, uint32_t)) dlsym_ex(handle, "il2cpp_method_get_param");
    il2cpp_class_get_methods = (void *(*)(void *, void **)) dlsym_ex(handle, "il2cpp_class_get_methods");
    il2cpp_method_get_name = (const char *(*)(void *)) dlsym_ex(handle, "il2cpp_method_get_name");
    il2cpp_object_new = (void *(*)(void *)) dlsym_ex(handle, "il2cpp_object_new");

    dlclose_ex(handle);
}
// =========================================================================== //
typedef unsigned short UTF16;
typedef wchar_t UTF32;
typedef char UTF8;

int is_surrogate(UTF16 uc) {
    return (uc - 0xd800u) < 2048u;
}

int is_high_surrogate(UTF16 uc) {
    return (uc & 0xfffffc00) == 0xd800;
}

int is_low_surrogate(UTF16 uc) {
    return (uc & 0xfffffc00) == 0xdc00;
}

UTF32 surrogate_to_utf32(UTF16 high, UTF16 low) {
    return (high << 10) + low - 0x35fdc00;
}

const char* utf16_to_utf8(const UTF16* source, size_t len) {
    std::u16string s(source, source + len);
    std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t> convert;
    return convert.to_bytes(s).c_str();
}

const wchar_t* utf16_to_utf32(const UTF16* source, size_t len) {
    auto output = new UTF32[len + 1];

    for (int i = 0; i < len; i++) {
        const UTF16 uc = source[i];
        if (!is_surrogate(uc)) {
            output[i] = uc;
        }
        else {
            if (is_high_surrogate(uc) && is_low_surrogate(source[i]))
                output[i] = surrogate_to_utf32(uc, source[i]);
            else
                output[i] = L'?';
        }
    }

    output[len] = L'\0';
    return output;
}
// =========================================================================== //
const char* Il2CppString::CString() {
    return utf16_to_utf8(&this->start_char, this->length);
}

const wchar_t* Il2CppString::WCString() {
    return utf16_to_utf32(&this->start_char, this->length);
}

Il2CppString *Il2CppString::Create(const char *s)
{
    return il2cpp_string_new(s);
}

Il2CppString *Il2CppString::Create(const wchar_t *s, int len)
{
    return il2cpp_string_new_utf16(s, len);
}
// =========================================================================== //
void *Il2CppGetImageByName(const char *image) {
    size_t size;
    void **assemblies = il2cpp_domain_get_assemblies(il2cpp_domain_get(), &size);
    for(int i = 0; i < size; ++i)
    {
        void *img = (void *)il2cpp_assembly_get_image(assemblies[i]);

        const char *img_name = il2cpp_image_get_name(img);

        if(strcmp(img_name, image) == 0)
        {
            return img;
        }
    }
    return 0;
}
// ================================================================================================================ //
void *  Il2CppGetClassType(const char *image, const char *namespaze, const char *clazz) {
    static std::map<std::string, void *> cache;

    std::string s = image;
    s += namespaze;
    s += clazz;

    if (cache.count(s) > 0)
        return cache[s];

    void *img = Il2CppGetImageByName(image);
    if(!img) {
        IL2CPP_LOGE("Can't find image %s!", image);
        return 0;
    }

    void *klass = il2cpp_class_from_name(img, namespaze, clazz);
    if(!klass) {
        IL2CPP_LOGE("Can't find class %s!", clazz);
        return 0;
    }

    cache[s] = klass;
    return klass;
}
// ================================================================================================================ //
void *Il2CppCreateClassInstance(const char *image, const char *namespaze, const char *clazz) {
    void *img = Il2CppGetImageByName(image);
    if(!img) {
        IL2CPP_LOGE("Can't find image %s!", image);
        return 0;
    }

    void *klass = Il2CppGetClassType(image, namespaze, clazz);
    if(!klass) {
        IL2CPP_LOGE("Can't find class %s!", clazz);
        return 0;
    }

    void *obj = il2cpp_object_new(klass);
    if(!obj)
    {
        IL2CPP_LOGE("Can't create object for %s", clazz);
        return 0;
    }

    return obj;
}
// ================================================================================================================ //
void* Il2CppCreateArray(const char *image, const char *namespaze, const char *clazz, size_t length) {
    void *img = Il2CppGetImageByName(image);
    if(!img) {
        IL2CPP_LOGE("Can't find image %s!", image);
        return 0;
    }
    void *klass = Il2CppGetClassType(image, namespaze, clazz);
    if(!klass) {
        IL2CPP_LOGE("Can't find class %s!", clazz);
        return 0;
    }

    return il2cpp_array_new(klass, length);
}
// ================================================================================================================ //
void Il2CppGetStaticFieldValue(const char *image, const char *namespaze, const char *clazz, const char *name, void *output) {
    void *img = Il2CppGetImageByName(image);
    if(!img) {
        IL2CPP_LOGE("Can't find image %s!", image);
        return;
    }
    void *klass = Il2CppGetClassType(image, namespaze, clazz);
    if(!klass) {
        IL2CPP_LOGE("Can't find class %s for field %s!", clazz, name);
        return;
    }

    void *field = il2cpp_class_get_field_from_name(klass, name);
    if(!field) {
        IL2CPP_LOGE("Can't find field %s in class %s!", name, clazz);
        return;
    }

    il2cpp_field_static_get_value(field, output);
}
// ================================================================================================================ //
void Il2CppSetStaticFieldValue(const char *image, const char *namespaze, const char *clazz, const char *name, void* value) {
    void *img = Il2CppGetImageByName(image);
    if(!img) {
        IL2CPP_LOGE("Can't find image %s!", image);
        return;
    }
    void *klass = Il2CppGetClassType(image, namespaze, clazz);
    if(!klass) {
        IL2CPP_LOGE("Can't find class %s for field %s!", clazz, name);
        return;
    }

    void *field = il2cpp_class_get_field_from_name(klass, name);
    if(!field) {
        IL2CPP_LOGE("Can't find field %s in class %s!", name, clazz);
        return;
    }

    il2cpp_field_static_set_value(field, value);
}
// ================================================================================================================ //
void *Il2CppGetMethodOffset(const char *image, const char *namespaze, const char *clazz, const char *name, int argsCount) {
    void *img = Il2CppGetImageByName(image);
    if(!img) {
        IL2CPP_LOGE("Can't find image %s!", image);
        return 0;
    }

    void *klass = Il2CppGetClassType(image, namespaze, clazz);
    if(!klass) {
        IL2CPP_LOGE("Can't find class %s for method %s!", clazz, name);
        return 0;
    }

    void **method = (void**)il2cpp_class_get_method_from_name(klass, name, argsCount);
    if(!method) {
        IL2CPP_LOGE("Can't find method %s in class %s!", name, clazz);
        return 0;
    }
    IL2CPP_LOGD("%s - [%s] %s::%s: %p", image, namespaze, clazz, name, *method);
    return *method;
}
// ================================================================================================================ //
void *Il2CppGetMethodOffset(const char *image, const char *namespaze, const char *clazz, const char *name, char** args, int argsCount) {
    void *img = Il2CppGetImageByName(image);
    if(!img) {
        IL2CPP_LOGE("Can't find image %s!", image);
        return 0;
    }

    void *klass = Il2CppGetClassType(image, namespaze, clazz);
    if(!klass) {
        IL2CPP_LOGE("Can't find class %s for method %s!", clazz, name);
        return 0;
    }

    void *iter = 0;

    int score = 0;

    void **method = (void**) il2cpp_class_get_methods(klass, &iter);
    while(method) {
        const char *fname = il2cpp_method_get_name(method);
        if(strcmp(fname, name) == 0) {
            for (int i = 0; i < argsCount; i++) {
                void *arg = il2cpp_method_get_param(method, i);
                if (arg) {
                    const char *tname = il2cpp_type_get_name(arg);
                    if (strcmp(tname, args[i]) == 0) {
                        score++;
                    } else {
                        IL2CPP_LOGI("Argument at index %d didn't matched requested argument!\n\tRequested: %s\n\tActual: %s\nnSkipping function...", i, args[i], tname);
                        score = 0;
goto skip;
                    }
                }
            }
        }
        skip:

        if(score == argsCount)
        {
            IL2CPP_LOGD("%s - [%s] %s::%s: %p", image, namespaze, clazz, name, *method);
            return *method;
        }

        method = (void **) il2cpp_class_get_methods(klass, &iter);
    }
    IL2CPP_LOGE("Cannot find function %s in class %s!", name, clazz);
    return 0;
}
// ================================================================================================================ //
size_t Il2CppGetFieldOffset(const char *image, const char *namespaze, const char *clazz, const char *name) {
    void *img = Il2CppGetImageByName(image);
    if(!img) {
        IL2CPP_LOGE("Can't find image %s!", image);
        return -1;
    }
    void *klass = Il2CppGetClassType(image, namespaze, clazz);
    if(!klass) {
        IL2CPP_LOGE("Can't find class %s for field %s!", clazz, name);
        return -1;
    }

    void *field = il2cpp_class_get_field_from_name(klass, name);
    if(!field) {
        IL2CPP_LOGE("Can't find field %s in class %s!", name, clazz);
        return -1;
    }
    auto result = il2cpp_field_get_offset(field);
    IL2CPP_LOGD("%s - [%s] %s::%s: %p", image, namespaze, clazz, name, (void *) result);
    return result;
}
// ================================================================================================================ //
bool Il2CppIsAssembliesLoaded() {
    size_t size;
    void **assemblies = il2cpp_domain_get_assemblies(il2cpp_domain_get(), &size);

    return size != 0 && assemblies != 0;
}
// ================================================================================================================ //
```

`app/src/main/jni/Il2Cpp.h`:

```h
//
// Created by aimar on 12/28/2019.
//
#pragma once

#include <stdio.h>
#include <string>
#include <inttypes.h>
#include <codecvt>
#include <locale>
#include <dlfcn.h>

using namespace std;

#ifndef IL2CPP_H
#define IL2CPP_H

// ================================================================================================================================ //
typedef void(*Il2CppMethodPointer)();

struct MethodInfo;

struct VirtualInvokeData
{
    Il2CppMethodPointer methodPtr;
    const MethodInfo* method;
};

struct Il2CppType
{
    void* data;
    unsigned int bits;
};

struct Il2CppClass;

struct Il2CppObject
{
    Il2CppClass *klass;
    void *monitor;
};

union Il2CppRGCTXData
{
    void* rgctxDataDummy;
    const MethodInfo* method;
    const Il2CppType* type;
    Il2CppClass* klass;
};

struct Il2CppClass_1
{
    void* image;
    void* gc_desc;
    const char* name;
    const char* namespaze;
    Il2CppType* byval_arg;
    Il2CppType* this_arg;
    Il2CppClass* element_class;
    Il2CppClass* castClass;
    Il2CppClass* declaringType;
    Il2CppClass* parent;
    void *generic_class;
    void* typeDefinition;
    void* interopData;
    void* fields;
    void* events;
    void* properties;
    void* methods;
    Il2CppClass** nestedTypes;
    Il2CppClass** implementedInterfaces;
    void* interfaceOffsets;
};

struct Il2CppClass_2
{
    Il2CppClass** typeHierarchy;
    uint32_t cctor_started;
    uint32_t cctor_finished;
    uint64_t cctor_thread;
    int32_t genericContainerIndex;
    int32_t customAttributeIndex;
    uint32_t instance_size;
    uint32_t actualSize;
    uint32_t element_size;
    int32_t native_size;
    uint32_t static_fields_size;
    uint32_t thread_static_fields_size;
    int32_t thread_static_fields_offset;
    uint32_t flags;
    uint32_t token;
    uint16_t method_count;
    uint16_t property_count;
    uint16_t field_count;
    uint16_t event_count;
    uint16_t nested_type_count;
    uint16_t vtable_count;
    uint16_t interfaces_count;
    uint16_t interface_offsets_count;
    uint8_t typeHierarchyDepth;
    uint8_t genericRecursionDepth;
    uint8_t rank;
    uint8_t minimumAlignment;
    uint8_t packingSize;
    uint8_t bitflags1;
    uint8_t bitflags2;
};

struct Il2CppClass
{
    Il2CppClass_1 _1;
    void* static_fields;
    Il2CppRGCTXData* rgctx_data;
    Il2CppClass_2 _2;
    VirtualInvokeData vtable[255];
};

typedef int32_t il2cpp_array_size_t;
typedef int32_t il2cpp_array_lower_bound_t;
struct Il2CppArrayBounds
{
    il2cpp_array_size_t length;
    il2cpp_array_lower_bound_t lower_bound;
};

struct MethodInfo
{
    Il2CppMethodPointer methodPointer;
    void* invoker_method;
    const char* name;
    Il2CppClass *declaring_type;
    const Il2CppType *return_type;
    const void* parameters;
    union
    {
        const Il2CppRGCTXData* rgctx_data;
        const void* methodDefinition;
    };
    union
    {
        const void* genericMethod;
        const void* genericContainer;
    };
    int32_t customAttributeIndex;
    uint32_t token;
    uint16_t flags;
    uint16_t iflags;
    uint16_t slot;
    uint8_t parameters_count;
    uint8_t bitflags;
};

template<typename T> struct Il2CppArray {
    Il2CppClass *klass;
    void *monitor;
    void *bounds;
    int max_length;
    T m_Items[65535];

    int getLength() {
        return max_length;
    }

    T *getPointer() {
        return (T *)m_Items;
    }

    T &operator[](int i) {
        return m_Items[i];
    }

    T &operator[](int i) const {
        return m_Items[i];
    }
};

template<typename T>
using Array = Il2CppArray<T>;

struct Il2CppString {
    Il2CppClass *klass;
    void *monitor;
    int32_t length;
    uint16_t start_char;

    const char *CString();

    const wchar_t *WCString();

    static Il2CppString *Create(const char *s);
    static Il2CppString *Create(const wchar_t *s, int len);

    int getLength() {
        return length;
    }
};

typedef Il2CppString String;

template<typename T> struct Il2CppList {
    Il2CppClass *klass;
    void *unk1;
    Il2CppArray<T> *items;
    int size;
    int version;

    T *getItems() {
        return items->getPointer();
    }

    int getSize() {
        return size;
    }

    int getVersion() {
        return version;
    }

    T &operator[](int i) {
        return items->m_Items[i];
    }

    T &operator[](int i) const {
        return items->m_Items[i];
    }
};

template<typename T>
using List = Il2CppList<T>;

template<typename K, typename V> struct Il2CppDictionary {
    Il2CppClass *klass;
    void *unk1;
    Il2CppArray<int **> *table;
    Il2CppArray<void **> *linkSlots;
    Il2CppArray<K> *keys;
    Il2CppArray<V> *values;
    int touchedSlots;
    int emptySlot;
    int size;

    K *getKeys() {
        return keys->getPointer();
    }

    V *getValues() {
        return values->getPointer();
    }

    int getNumKeys() {
        return keys->getLength();
    }

    int getNumValues() {
        return values->getLength();
    }

    int getSize() {
        return size;
    }
};

template<typename K, typename V>
using Dictionary = Il2CppDictionary<K, V>;

void Il2CppAttach(const char *name = "libil2cpp.so");
void *Il2CppGetImageByName(const char *image);
void *Il2CppGetClassType(const char *image, const char *namespaze, const char *clazz);
void *Il2CppCreateClassInstance(const char *image, const char *namespaze, const char *clazz);
void* Il2CppCreateArray(const char *image, const char *namespaze, const char *clazz, size_t length);

void Il2CppGetStaticFieldValue(const char *image, const char *namespaze, const char *clazz, const char *name, void *output);
void Il2CppSetStaticFieldValue(const char *image, const char *namespaze, const char *clazz, const char *name, void* value);

void *Il2CppGetMethodOffset(const char *image, const char *namespaze, const char *clazz, const char *name, int argsCount = 0);
void *Il2CppGetMethodOffset(const char *image, const char *namespaze, const char *clazz, const char *name, char** args, int argsCount);

size_t Il2CppGetFieldOffset(const char *image, const char *namespaze, const char *clazz, const char *name);

bool Il2CppIsAssembliesLoaded();
#endif

```

`app/src/main/jni/Includes.h`:

```h
#include <iostream>
#include <stdio.h>
#include <string>
#include <unistd.h>
#include <stdint.h>
#include <inttypes.h>

#include <vector>
#include <map>
#include <chrono>
#include <fstream>
#include <thread>

#include <pthread.h>
#include <dirent.h>
#include <libgen.h>

#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/uio.h>

#include <fcntl.h>

#include <jni.h>
#include <android/log.h>

#define IS_DEBUG

#if defined(IS_DEBUG)
#define LOG_TAG "Chitoge"
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,LOG_TAG,__VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN,LOG_TAG,__VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)
#else
#define LOGI(...)
#define LOGD(...)
#define LOGW(...)
#define LOGE(...)
#endif
```

`app/src/main/jni/Main.cpp`:

```cpp
#include "Includes.h"
#include "CODM.h"

bool titleValid = false;


extern "C" {
JNIEXPORT jstring
JNICALL
Java_com_gotoubun_Floating_Title(JNIEnv *env, jobject thiz) {
    titleValid = true;
    return env->NewStringUTF(("PMods Sausage"));
}
}
void native_onSendConfig(JNIEnv *env, jobject thiz, jstring s, jstring v) {
    const char *config = env->GetStringUTFChars(s, 0);
    const char *value = env->GetStringUTFChars(v, 0);

    Config[config] = (u_long) strtoul(value, 0, 0);
}

jclass (*orig_FindClass)(JNIEnv *env, const char *name);
int Register1(JNIEnv *env) {
    JNINativeMethod methods[] = {{"onSendConfig", "(Ljava/lang/String;Ljava/lang/String;)V", (void *) native_onSendConfig},
                                 {"onCanvasDraw", "(Landroid/graphics/Canvas;IIF)V",         (void *) native_onCanvasDraw}};


    jclass clazz = env->FindClass("com/gotoubun/Floating");
    if (!clazz)
        return -1;

    if (env->RegisterNatives(clazz, methods, sizeof(methods) / sizeof(methods[0])) != 0)
        return -1;

    return 0;
}

int Register2(JNIEnv *env) {
    JNINativeMethod methods[] = {{"Init",  "(Landroid/content/Context;)V",                   (void *) native_Init}};

    jclass clazz = env->FindClass("com/gotoubun/Launcher");
    if (!clazz)
        return -1;

    if (env->RegisterNatives(clazz, methods, sizeof(methods) / sizeof(methods[0])) != 0)
        return -1;

    return 0;
}

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {
    JNIEnv *env;
    vm->GetEnv((void **) &env, JNI_VERSION_1_6);
    if (Register1(env) != 0)
        return -1;
    if (Register2(env) != 0)
        return -1;
    
    return JNI_VERSION_1_6;
}

JNIEXPORT void JNICALL
JNI_OnUnload(JavaVM *vm, void *reserved) {
}

```

`app/src/main/jni/Quaternion.hpp`:

```hpp
#pragma once

#define _USE_MATH_DEFINES
#include <math.h>
#include <iostream>

#define SMALL_float 0.0000000001


/**
 * Attempt to include a header file if the file exists.
 * If the file does not exist, create a dummy data structure for that type.
 * If it cannot be determined if it exists, just attempt to include it.
 */
#ifdef __has_include
#   if __has_include("Vector3.hpp")
#       include "Vector3.hpp"
#   elif !defined(GMATH_VECTOR3)
#define GMATH_VECTOR3
        struct Vector3
        {
            union
            {
                struct
                {
                    float X;
                    float Y;
                    float Z;
                };
                float data[3];
            };

            inline Vector3() : X(0), Y(0), Z(0) {}
            inline Vector3(float data[]) : X(data[0]), Y(data[1]), Z(data[2])
                {}
            inline Vector3(float value) : X(value), Y(value), Z(value) {}
            inline Vector3(float x, float y) : X(x), Y(y), Z(0) {}
            inline Vector3(float x, float y, float z) : X(x), Y(y), Z(z) {}

            static inline Vector3 Cross(Vector3 lhs, Vector3 rhs)
            {
                float x = lhs.Y * rhs.Z - lhs.Z * rhs.Y;
                float y = lhs.Z * rhs.X - lhs.X * rhs.Z;
                float z = lhs.X * rhs.Y - lhs.Y * rhs.X;
                return Vector3(x, y, z);
            }

            static inline float Dot(Vector3 lhs, Vector3 rhs)
            {
                return lhs.X * rhs.X + lhs.Y * rhs.Y + lhs.Z * rhs.Z;
            }

            static inline Vector3 Normalized(Vector3 v)
            {
                float mag = sqrt(v.X * v.X + v.Y * v.Y + v.Z * v.Z);
                if (mag == 0)
                    return Vector3::Zero();
                return v / mag;
            }

            static inline Vector3 Orthogonal(Vector3 v)
            {
                return v.Z < v.X ?
                    Vector3(v.Y, -v.X, 0) : Vector3(0, -v.Z, v.Y);
            }

            static inline float SqrMagnitude(Vector3 v)
            {
                return v.X * v.X + v.Y * v.Y + v.Z * v.Z;
            }
        };


        inline Vector3 operator+(Vector3 lhs, const Vector3 rhs)
        {
            return Vector3(lhs.X + rhs.X, lhs.Y + rhs.Y, lhs.Z + rhs.Z);
        }

        inline Vector3 operator*(Vector3 lhs, const float rhs)
        {
            return Vector3(lhs.X * rhs, lhs.Y * rhs, lhs.Z * rhs);
        }
#   endif
#else
#   include "Vector3.hpp"
#endif


struct Quaternion
{
    union
    {
        struct
        {
            float X;
            float Y;
            float Z;
            float W;
        };
        float data[4];
    };


    /**
     * Constructors.
     */
    inline Quaternion();
    inline Quaternion(float data[]);
    inline Quaternion(Vector3 vector, float scalar);
    inline Quaternion(float x, float y, float z, float w);


    /**
     * Constants for common quaternions.
     */
    static inline Quaternion Identity();


    /**
     * Returns the angle between two quaternions.
     * The quaternions must be normalized.
     * @param a: The first quaternion.
     * @param b: The second quaternion.
     * @return: A scalar value.
     */
    static inline float Angle(Quaternion a, Quaternion b);

    /**
     * Returns the conjugate of a quaternion.
     * @param rotation: The quaternion in question.
     * @return: A new quaternion.
     */
    static inline Quaternion Conjugate(Quaternion rotation);

    /**
     * Returns the dot product of two quaternions.
     * @param lhs: The left side of the multiplication.
     * @param rhs: The right side of the multiplication.
     * @return: A scalar value.
     */
    static inline float Dot(Quaternion lhs, Quaternion rhs);

    /**
     * Creates a new quaternion from the angle-axis representation of
     * a rotation.
     * @param angle: The rotation angle in radians.
     * @param axis: The vector about which the rotation occurs.
     * @return: A new quaternion.
     */
    static inline Quaternion FromAngleAxis(float angle, Vector3 axis);

    /**
     * Create a new quaternion from the euler angle representation of
     * a rotation. The z, x and y values represent rotations about those
     * axis in that respective order.
     * @param rotation: The x, y and z rotations.
     * @return: A new quaternion.
     */
    static inline Quaternion FromEuler(Vector3 rotation);

    /**
     * Create a new quaternion from the euler angle representation of
     * a rotation. The z, x and y values represent rotations about those
     * axis in that respective order.
     * @param x: The rotation about the x-axis in radians.
     * @param y: The rotation about the y-axis in radians.
     * @param z: The rotation about the z-axis in radians.
     * @return: A new quaternion.
     */
    static inline Quaternion FromEuler(float x, float y, float z);

    /**
     * Create a quaternion rotation which rotates "fromVector" to "toVector".
     * @param fromVector: The vector from which to start the rotation.
     * @param toVector: The vector at which to end the rotation.
     * @return: A new quaternion.
     */
    static inline Quaternion FromToRotation(Vector3 fromVector,
                                            Vector3 toVector);

    /**
     * Returns the inverse of a rotation.
     * @param rotation: The quaternion in question.
     * @return: A new quaternion.
     */
    static inline Quaternion Inverse(Quaternion rotation);

    /**
     * Interpolates between a and b by t, which is clamped to the range [0-1].
     * The result is normalized before being returned.
     * @param a: The starting rotation.
     * @param b: The ending rotation.
     * @return: A new quaternion.
     */
    static inline Quaternion Lerp(Quaternion a, Quaternion b, float t);

    /**
     * Interpolates between a and b by t. This normalizes the result when
     * complete.
     * @param a: The starting rotation.
     * @param b: The ending rotation.
     * @param t: The interpolation value.
     * @return: A new quaternion.
     */
    static inline Quaternion LerpUnclamped(Quaternion a, Quaternion b,
                                           float t);

    /**
     * Creates a rotation with the specified forward direction. This is the
     * same as calling LookRotation with (0, 1, 0) as the upwards vector.
     * The output is undefined for parallel vectors.
     * @param forward: The forward direction to look toward.
     * @return: A new quaternion.
     */
    static inline Quaternion LookRotation(Vector3 forward);

    /**
     * Creates a rotation with the specified forward and upwards directions.
     * The output is undefined for parallel vectors.
     * @param forward: The forward direction to look toward.
     * @param upwards: The direction to treat as up.
     * @return: A new quaternion.
     */
    static inline Quaternion LookRotation(Vector3 forward, Vector3 upwards);

    /**
     * Returns the norm of a quaternion.
     * @param rotation: The quaternion in question.
     * @return: A scalar value.
     */
    static inline float Norm(Quaternion rotation);

    /**
     * Returns a quaternion with identical rotation and a norm of one.
     * @param rotation: The quaternion in question.
     * @return: A new quaternion.
     */
    static inline Quaternion Normalized(Quaternion rotation);

    /**
     * Returns a new Quaternion created by rotating "from" towards "to" by
     * "maxRadiansDelta". This will not overshoot, and if a negative delta is
     * applied, it will rotate till completely opposite "to" and then stop.
     * @param from: The rotation at which to start.
     * @param to: The rotation at which to end.
     # @param maxRadiansDelta: The maximum number of radians to rotate.
     * @return: A new Quaternion.
     */
    static inline Quaternion RotateTowards(Quaternion from, Quaternion to,
                                           float maxRadiansDelta);

    /**
     * Returns a new quaternion interpolated between a and b, using spherical
     * linear interpolation. The variable t is clamped to the range [0-1]. The
     * resulting quaternion will be normalized.
     * @param a: The starting rotation.
     * @param b: The ending rotation.
     * @param t: The interpolation value.
     * @return: A new quaternion.
     */
    static inline Quaternion Slerp(Quaternion a, Quaternion b, float t);

    /**
     * Returns a new quaternion interpolated between a and b, using spherical
     * linear interpolation. The resulting quaternion will be normalized.
     * @param a: The starting rotation.
     * @param b: The ending rotation.
     * @param t: The interpolation value.
     * @return: A new quaternion.
     */
    static inline Quaternion SlerpUnclamped(Quaternion a, Quaternion b,
                                            float t);

    /**
     * Outputs the angle axis representation of the provided quaternion.
     * @param rotation: The input quaternion.
     * @param angle: The output angle.
     * @param axis: The output axis.
     */
    static inline void ToAngleAxis(Quaternion rotation, float &angle,
                                   Vector3 &axis);

    /**
     * Returns the Euler angle representation of a rotation. The resulting
     * vector contains the rotations about the z, x and y axis, in that order.
     * @param rotation: The quaternion to convert.
     * @return: A new vector.
     */
    static inline Vector3 ToEuler(Quaternion rotation);

    /**
     * Operator overloading.
     */
    inline struct Quaternion& operator+=(const float rhs);
    inline struct Quaternion& operator-=(const float rhs);
    inline struct Quaternion& operator*=(const float rhs);
    inline struct Quaternion& operator/=(const float rhs);
    inline struct Quaternion& operator+=(const Quaternion rhs);
    inline struct Quaternion& operator-=(const Quaternion rhs);
    inline struct Quaternion& operator*=(const Quaternion rhs);
};

inline Quaternion operator-(Quaternion rhs);
inline Quaternion operator+(Quaternion lhs, const float rhs);
inline Quaternion operator-(Quaternion lhs, const float rhs);
inline Quaternion operator*(Quaternion lhs, const float rhs);
inline Quaternion operator/(Quaternion lhs, const float rhs);
inline Quaternion operator+(const float lhs, Quaternion rhs);
inline Quaternion operator-(const float lhs, Quaternion rhs);
inline Quaternion operator*(const float lhs, Quaternion rhs);
inline Quaternion operator/(const float lhs, Quaternion rhs);
inline Quaternion operator+(Quaternion lhs, const Quaternion rhs);
inline Quaternion operator-(Quaternion lhs, const Quaternion rhs);
inline Quaternion operator*(Quaternion lhs, const Quaternion rhs);
inline Vector3 operator*(Quaternion lhs, const Vector3 rhs);
inline bool operator==(const Quaternion lhs, const Quaternion rhs);
inline bool operator!=(const Quaternion lhs, const Quaternion rhs);



/*******************************************************************************
 * Implementation
 */

Quaternion::Quaternion() : X(0), Y(0), Z(0), W(1) {}
Quaternion::Quaternion(float data[]) : X(data[0]), Y(data[1]), Z(data[2]),
                                       W(data[3]) {}
Quaternion::Quaternion(Vector3 vector, float scalar) : X(vector.X),
                                                       Y(vector.Y), Z(vector.Z), W(scalar) {}
Quaternion::Quaternion(float x, float y, float z, float w) : X(x), Y(y),
                                                             Z(z), W(w) {}


Quaternion Quaternion::Identity() { return Quaternion(0, 0, 0, 1); }


float Quaternion::Angle(Quaternion a, Quaternion b)
{
    float dot = Dot(a, b);
    return acos(fmin(fabs(dot), 1)) * 2;
}

Quaternion Quaternion::Conjugate(Quaternion rotation)
{
    return Quaternion(-rotation.X, -rotation.Y, -rotation.Z, rotation.W);
}

float Quaternion::Dot(Quaternion lhs, Quaternion rhs)
{
    return lhs.X * rhs.X + lhs.Y * rhs.Y + lhs.Z * rhs.Z + lhs.W * rhs.W;
}

Quaternion Quaternion::FromAngleAxis(float angle, Vector3 axis)
{
    Quaternion q;
    float m = sqrt(axis.X * axis.X + axis.Y * axis.Y + axis.Z * axis.Z);
    float s = sin(angle / 2) / m;
    q.X = axis.X * s;
    q.Y = axis.Y * s;
    q.Z = axis.Z * s;
    q.W = cos(angle / 2);
    return q;
}

Quaternion Quaternion::FromEuler(Vector3 rotation)
{
    return FromEuler(rotation.X, rotation.Y, rotation.Z);
}

Quaternion Quaternion::FromEuler(float x, float y, float z)
{
    float cx = cos(x * 0.5);
    float cy = cos(y * 0.5);
    float cz = cos(z * 0.5);
    float sx = sin(x * 0.5);
    float sy = sin(y * 0.5);
    float sz = sin(z * 0.5);
    Quaternion q;
    q.X = cx * sy * sz + cy * cz * sx;
    q.Y = cx * cz * sy - cy * sx * sz;
    q.Z = cx * cy * sz - cz * sx * sy;
    q.W = sx * sy * sz + cx * cy * cz;
    return q;
}

Quaternion Quaternion::FromToRotation(Vector3 fromVector, Vector3 toVector)
{
    float dot = Vector3::Dot(fromVector, toVector);
    float k = sqrt(Vector3::SqrMagnitude(fromVector) *
                   Vector3::SqrMagnitude(toVector));
    if (fabs(dot / k + 1) < 0.00001)
    {
        Vector3 ortho = Vector3::Orthogonal(fromVector);
        return Quaternion(Vector3::Normalized(ortho), 0);
    }
    Vector3 cross = Vector3::Cross(fromVector, toVector);
    return Normalized(Quaternion(cross, dot + k));
}

Quaternion Quaternion::Inverse(Quaternion rotation)
{
    float n = Norm(rotation);
    return Conjugate(rotation) / (n * n);
}

Quaternion Quaternion::Lerp(Quaternion a, Quaternion b, float t)
{
    if (t < 0) return Normalized(a);
    else if (t > 1) return Normalized(b);
    return LerpUnclamped(a, b, t);
}

Quaternion Quaternion::LerpUnclamped(Quaternion a, Quaternion b, float t)
{
    Quaternion quaternion;
    if (Dot(a, b) >= 0)
        quaternion = a * (1 - t) + b * t;
    else
        quaternion = a * (1 - t) - b * t;
    return Normalized(quaternion);
}

Quaternion Quaternion::LookRotation(Vector3 forward)
{
    return LookRotation(forward, Vector3(0, 1, 0));
}

Quaternion Quaternion::LookRotation(Vector3 forward, Vector3 upwards)
{
    // Normalize inputs
    forward = Vector3::Normalized(forward);
    upwards = Vector3::Normalized(upwards);
    // Don't allow zero vectors
    if (Vector3::SqrMagnitude(forward) < SMALL_float || Vector3::SqrMagnitude(upwards) < SMALL_float)
        return Quaternion::Identity();
    // Handle alignment with up direction
    if (1 - fabs(Vector3::Dot(forward, upwards)) < SMALL_float)
        return FromToRotation(Vector3::Forward(), forward);
    // Get orthogonal vectors
    Vector3 right = Vector3::Normalized(Vector3::Cross(upwards, forward));
    upwards = Vector3::Cross(forward, right);
    // Calculate rotation
    Quaternion quaternion;
    float radicand = right.X + upwards.Y + forward.Z;
    if (radicand > 0)
    {
        quaternion.W = sqrt(1.0 + radicand) * 0.5;
        float recip = 1.0 / (4.0 * quaternion.W);
        quaternion.X = (upwards.Z - forward.Y) * recip;
        quaternion.Y = (forward.X - right.Z) * recip;
        quaternion.Z = (right.Y - upwards.X) * recip;
    }
    else if (right.X >= upwards.Y && right.X >= forward.Z)
    {
        quaternion.X = sqrt(1.0 + right.X - upwards.Y - forward.Z) * 0.5;
        float recip = 1.0 / (4.0 * quaternion.X);
        quaternion.W = (upwards.Z - forward.Y) * recip;
        quaternion.Z = (forward.X + right.Z) * recip;
        quaternion.Y = (right.Y + upwards.X) * recip;
    }
    else if (upwards.Y > forward.Z)
    {
        quaternion.Y = sqrt(1.0 - right.X + upwards.Y - forward.Z) * 0.5;
        float recip = 1.0 / (4.0 * quaternion.Y);
        quaternion.Z = (upwards.Z + forward.Y) * recip;
        quaternion.W = (forward.X - right.Z) * recip;
        quaternion.X = (right.Y + upwards.X) * recip;
    }
    else
    {
        quaternion.Z = sqrt(1.0 - right.X - upwards.Y + forward.Z) * 0.5;
        float recip = 1.0 / (4.0 * quaternion.Z);
        quaternion.Y = (upwards.Z + forward.Y) * recip;
        quaternion.X = (forward.X + right.Z) * recip;
        quaternion.W = (right.Y - upwards.X) * recip;
    }
    return quaternion;
}

float Quaternion::Norm(Quaternion rotation)
{
    return sqrt(rotation.X * rotation.X +
                rotation.Y * rotation.Y +
                rotation.Z * rotation.Z +
                rotation.W * rotation.W);
}

Quaternion Quaternion::Normalized(Quaternion rotation)
{
    return rotation / Norm(rotation);
}

Quaternion Quaternion::RotateTowards(Quaternion from, Quaternion to,
                                     float maxRadiansDelta)
{
    float angle = Quaternion::Angle(from, to);
    if (angle == 0)
        return to;
    maxRadiansDelta = fmax(maxRadiansDelta, angle - M_PI);
    float t = fmin(1, maxRadiansDelta / angle);
    return Quaternion::SlerpUnclamped(from, to, t);
}

Quaternion Quaternion::Slerp(Quaternion a, Quaternion b, float t)
{
    if (t < 0) return Normalized(a);
    else if (t > 1) return Normalized(b);
    return SlerpUnclamped(a, b, t);
}

Quaternion Quaternion::SlerpUnclamped(Quaternion a, Quaternion b, float t)
{
    float n1;
    float n2;
    float n3 = Dot(a, b);
    bool flag = false;
    if (n3 < 0)
    {
        flag = true;
        n3 = -n3;
    }
    if (n3 > 0.999999)
    {
        n2 = 1 - t;
        n1 = flag ? -t : t;
    }
    else
    {
        float n4 = acos(n3);
        float n5 = 1 / sin(n4);
        n2 = sin((1 - t) * n4) * n5;
        n1 = flag ? -sin(t * n4) * n5 : sin(t * n4) * n5;
    }
    Quaternion quaternion;
    quaternion.X = (n2 * a.X) + (n1 * b.X);
    quaternion.Y = (n2 * a.Y) + (n1 * b.Y);
    quaternion.Z = (n2 * a.Z) + (n1 * b.Z);
    quaternion.W = (n2 * a.W) + (n1 * b.W);
    return Normalized(quaternion);
}

void Quaternion::ToAngleAxis(Quaternion rotation, float &angle, Vector3 &axis)
{
    if (rotation.W > 1)
        rotation = Normalized(rotation);
    angle = 2 * acos(rotation.W);
    float s = sqrt(1 - rotation.W * rotation.W);
    if (s < 0.00001) {
        axis.X = 1;
        axis.Y = 0;
        axis.Z = 0;
    } else {
        axis.X = rotation.X / s;
        axis.Y = rotation.Y / s;
        axis.Z = rotation.Z / s;
    }
}

Vector3 Quaternion::ToEuler(Quaternion rotation)
{
    float sqw = rotation.W * rotation.W;
    float sqx = rotation.X * rotation.X;
    float sqy = rotation.Y * rotation.Y;
    float sqz = rotation.Z * rotation.Z;
    // If normalized is one, otherwise is correction factor
    float unit = sqx + sqy + sqz + sqw;
    float test = rotation.X * rotation.W - rotation.Y * rotation.Z;
    Vector3 v;
    // Singularity at north pole
    if (test > 0.4995f * unit)
    {
        v.Y = 2 * atan2(rotation.Y, rotation.X);
        v.X = M_PI_2;
        v.Z = 0;
        return v;
    }
    // Singularity at south pole
    if (test < -0.4995f * unit)
    {
        v.Y = -2 * atan2(rotation.Y, rotation.X);
        v.X = -M_PI_2;
        v.Z = 0;
        return v;
    }
    // Yaw
    v.Y = atan2(2 * rotation.W * rotation.Y + 2 * rotation.Z * rotation.X,
                1 - 2 * (rotation.X * rotation.X + rotation.Y * rotation.Y));
    // Pitch
    v.X = asin(2 * (rotation.W * rotation.X - rotation.Y * rotation.Z));
    // Roll
    v.Z = atan2(2 * rotation.W * rotation.Z + 2 * rotation.X * rotation.Y,
                1 - 2 * (rotation.Z * rotation.Z + rotation.X * rotation.X));
    return v;
}

struct Quaternion& Quaternion::operator+=(const float rhs)
{
    X += rhs;
    Y += rhs;
    Z += rhs;
    W += rhs;
    return *this;
}

struct Quaternion& Quaternion::operator-=(const float rhs)
{
    X -= rhs;
    Y -= rhs;
    Z -= rhs;
    W -= rhs;
    return *this;
}

struct Quaternion& Quaternion::operator*=(const float rhs)
{
    X *= rhs;
    Y *= rhs;
    Z *= rhs;
    W *= rhs;
    return *this;
}

struct Quaternion& Quaternion::operator/=(const float rhs)
{
    X /= rhs;
    Y /= rhs;
    Z /= rhs;
    W /= rhs;
    return *this;
}

struct Quaternion& Quaternion::operator+=(const Quaternion rhs)
{
    X += rhs.X;
    Y += rhs.Y;
    Z += rhs.Z;
    W += rhs.W;
    return *this;
}

struct Quaternion& Quaternion::operator-=(const Quaternion rhs)
{
    X -= rhs.X;
    Y -= rhs.Y;
    Z -= rhs.Z;
    W -= rhs.W;
    return *this;
}

struct Quaternion& Quaternion::operator*=(const Quaternion rhs)
{
    Quaternion q;
    q.W = W * rhs.W - X * rhs.X - Y * rhs.Y - Z * rhs.Z;
    q.X = X * rhs.W + W * rhs.X + Y * rhs.Z - Z * rhs.Y;
    q.Y = W * rhs.Y - X * rhs.Z + Y * rhs.W + Z * rhs.X;
    q.Z = W * rhs.Z + X * rhs.Y - Y * rhs.X + Z * rhs.W;
    *this = q;
    return *this;
}

Quaternion operator-(Quaternion rhs) { return rhs * -1; }
Quaternion operator+(Quaternion lhs, const float rhs) { return lhs += rhs; }
Quaternion operator-(Quaternion lhs, const float rhs) { return lhs -= rhs; }
Quaternion operator*(Quaternion lhs, const float rhs) { return lhs *= rhs; }
Quaternion operator/(Quaternion lhs, const float rhs) { return lhs /= rhs; }
Quaternion operator+(const float lhs, Quaternion rhs) { return rhs += lhs; }
Quaternion operator-(const float lhs, Quaternion rhs) { return rhs -= lhs; }
Quaternion operator*(const float lhs, Quaternion rhs) { return rhs *= lhs; }
Quaternion operator/(const float lhs, Quaternion rhs) { return rhs /= lhs; }
Quaternion operator+(Quaternion lhs, const Quaternion rhs)
{
    return lhs += rhs;
}
Quaternion operator-(Quaternion lhs, const Quaternion rhs)
{
    return lhs -= rhs;
}
Quaternion operator*(Quaternion lhs, const Quaternion rhs)
{
    return lhs *= rhs;
}

Vector3 operator*(Quaternion lhs, const Vector3 rhs)
{
    Vector3 u = Vector3(lhs.X, lhs.Y, lhs.Z);
    float s = lhs.W;
    return u * (Vector3::Dot(u, rhs) * 2)
           + rhs * (s * s - Vector3::Dot(u, u))
           + Vector3::Cross(u, rhs) * (2.0 * s);
}

bool operator==(const Quaternion lhs, const Quaternion rhs)
{
    return lhs.X == rhs.X &&
           lhs.Y == rhs.Y &&
           lhs.Z == rhs.Z &&
           lhs.W == rhs.W;
}

bool operator!=(const Quaternion lhs, const Quaternion rhs)
{
    return !(lhs == rhs);
}
```

`app/src/main/jni/Substrate/And64InlineHook.cpp`:

```cpp
/*
 *  @date   : 2018/04/18
 *  @author : Rprop (r_prop@outlook.com)
 *  https://github.com/Rprop/And64InlineHook
 */
/*
 MIT License

 Copyright (c) 2018 Rprop (r_prop@outlook.com)

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
#define  __STDC_FORMAT_MACROS

#if defined(__aarch64__)

#include <string.h>
#include <stdlib.h>
#include <sys/mman.h>
#include "And64InlineHook.hpp"
#define   A64_MAX_INSTRUCTIONS 5
#define   A64_MAX_REFERENCES   (A64_MAX_INSTRUCTIONS * 2)
#define   A64_NOP              0xd503201fu
#define   A64_JNIEXPORT        __attribute__((visibility("hidden")))
#define __flush_cache(c, n)        __builtin___clear_cache(reinterpret_cast<char *>(c), reinterpret_cast<char *>(c) + n)


typedef uint32_t *__restrict *__restrict instruction;
typedef struct
{
    struct fix_info
    {
        uint32_t *bp;
        uint32_t  ls; // left-shift counts
        uint32_t  ad; // & operand
    };
    struct insns_info
    {
        union
        {
            uint64_t insu;
            int64_t  ins;
            void    *insp;
        };
        fix_info fmap[A64_MAX_REFERENCES];
    };
    int64_t    basep;
    int64_t    endp;
    insns_info dat[A64_MAX_INSTRUCTIONS];

public:
    inline bool is_in_fixing_range(const int64_t absolute_addr) {
        return absolute_addr >= this->basep && absolute_addr < this->endp;
    }
    inline intptr_t get_ref_ins_index(const int64_t absolute_addr) {
        return static_cast<intptr_t>((absolute_addr - this->basep) / sizeof(uint32_t));
    }
    inline intptr_t get_and_set_current_index(uint32_t *__restrict inp, uint32_t *__restrict outp) {
        intptr_t current_idx = this->get_ref_ins_index(reinterpret_cast<int64_t>(inp));
        this->dat[current_idx].insp = outp;
        return current_idx;
    }
    inline void reset_current_ins(const intptr_t idx, uint32_t *__restrict outp) {
        this->dat[idx].insp = outp;
    }
    void insert_fix_map(const intptr_t idx, uint32_t *bp, uint32_t ls = 0u, uint32_t ad = 0xffffffffu) {
        for (auto &f : this->dat[idx].fmap) {
            if (f.bp == NULL) {
                f.bp = bp;
                f.ls = ls;
                f.ad = ad;
                return;
            } //if
        }
        // What? GGing..
    }
    void process_fix_map(const intptr_t idx) {
        for (auto &f : this->dat[idx].fmap) {
            if (f.bp == NULL) break;
            *(f.bp) = *(f.bp) | (((int32_t(this->dat[idx].ins - reinterpret_cast<int64_t>(f.bp)) >> 2) << f.ls) & f.ad);
            f.bp = NULL;
        }
    }
} context;

//-------------------------------------------------------------------------

static bool __fix_branch_imm(instruction inpp, instruction outpp, context *ctxp)
{
    static constexpr uint32_t mbits = 6u;
    static constexpr uint32_t mask  = 0xfc000000u; // 0b11111100000000000000000000000000
    static constexpr uint32_t rmask = 0x03ffffffu; // 0b00000011111111111111111111111111
    static constexpr uint32_t op_b  = 0x14000000u; // "b"  ADDR_PCREL26
    static constexpr uint32_t op_bl = 0x94000000u; // "bl" ADDR_PCREL26

    const uint32_t ins = *(*inpp);
    const uint32_t opc = ins & mask;
    switch (opc) {
        case op_b:
        case op_bl:
        {
            intptr_t current_idx  = ctxp->get_and_set_current_index(*inpp, *outpp);
            int64_t absolute_addr = reinterpret_cast<int64_t>(*inpp) + (static_cast<int32_t>(ins << mbits) >> (mbits - 2u)); // sign-extended
            int64_t new_pc_offset = static_cast<int64_t>(absolute_addr - reinterpret_cast<int64_t>(*outpp)) >> 2; // shifted
            bool special_fix_type = ctxp->is_in_fixing_range(absolute_addr);
            // whether the branch should be converted to absolute jump
            if (!special_fix_type && llabs(new_pc_offset) >= (rmask >> 1)) {
                bool b_aligned = (reinterpret_cast<uint64_t>(*outpp + 2) & 7u) == 0u;
                if (opc == op_b) {
                    if (b_aligned != true) {
                        (*outpp)[0] = A64_NOP;
                        ctxp->reset_current_ins(current_idx, ++(*outpp));
                    } //if
                    (*outpp)[0] = 0x58000051u; // LDR X17, #0x8
                    (*outpp)[1] = 0xd61f0220u; // BR X17
                    memcpy(*outpp + 2, &absolute_addr, sizeof(absolute_addr));
                    *outpp += 4;
                } else {
                    if (b_aligned == true) {
                        (*outpp)[0] = A64_NOP;
                        ctxp->reset_current_ins(current_idx, ++(*outpp));
                    } //if
                    (*outpp)[0] = 0x58000071u; // LDR X17, #12
                    (*outpp)[1] = 0x1000009eu; // ADR X30, #16
                    (*outpp)[2] = 0xd61f0220u; // BR X17
                    memcpy(*outpp + 3, &absolute_addr, sizeof(absolute_addr));
                    *outpp += 5;
                } //if
            } else {
                if (special_fix_type) {
                    intptr_t ref_idx = ctxp->get_ref_ins_index(absolute_addr);
                    if (ref_idx <= current_idx) {
                        new_pc_offset = static_cast<int64_t>(ctxp->dat[ref_idx].ins - reinterpret_cast<int64_t>(*outpp)) >> 2;
                    } else {
                        ctxp->insert_fix_map(ref_idx, *outpp, 0u, rmask);
                        new_pc_offset = 0;
                    } //if
                } //if

                (*outpp)[0] = opc | (new_pc_offset & ~mask);
                ++(*outpp);
            } //if

            ++(*inpp);
            return ctxp->process_fix_map(current_idx), true;
        }
    }
    return false;
}

//-------------------------------------------------------------------------

static bool __fix_cond_comp_test_branch(instruction inpp, instruction outpp, context *ctxp)
{
    static constexpr uint32_t lsb     = 5u;
    static constexpr uint32_t lmask01 = 0xff00001fu; // 0b11111111000000000000000000011111
    static constexpr uint32_t mask0   = 0xff000010u; // 0b11111111000000000000000000010000
    static constexpr uint32_t op_bc   = 0x54000000u; // "b.c"  ADDR_PCREL19
    static constexpr uint32_t mask1   = 0x7f000000u; // 0b01111111000000000000000000000000
    static constexpr uint32_t op_cbz  = 0x34000000u; // "cbz"  Rt, ADDR_PCREL19
    static constexpr uint32_t op_cbnz = 0x35000000u; // "cbnz" Rt, ADDR_PCREL19
    static constexpr uint32_t lmask2  = 0xfff8001fu; // 0b11111111111110000000000000011111
    static constexpr uint32_t mask2   = 0x7f000000u; // 0b01111111000000000000000000000000
    static constexpr uint32_t op_tbz  = 0x36000000u; // 0b00110110000000000000000000000000 "tbz"  Rt, BIT_NUM, ADDR_PCREL14
    static constexpr uint32_t op_tbnz = 0x37000000u; // 0b00110111000000000000000000000000 "tbnz" Rt, BIT_NUM, ADDR_PCREL14

    const uint32_t ins = *(*inpp);
    uint32_t     lmask = lmask01;
    if ((ins & mask0) != op_bc) {
        uint32_t opc   = ins & mask1;
        if (opc != op_cbz && opc != op_cbnz) {
            opc = ins & mask2;
            if (opc != op_tbz && opc != op_tbnz) {
                return false;
            } //if
            lmask = lmask2;
        } //if
    } //if

    intptr_t current_idx  = ctxp->get_and_set_current_index(*inpp, *outpp);
    int64_t absolute_addr = reinterpret_cast<int64_t>(*inpp) + ((ins & ~lmask) >> (lsb - 2u));
    int64_t new_pc_offset = static_cast<int64_t>(absolute_addr - reinterpret_cast<int64_t>(*outpp)) >> 2; // shifted
    bool special_fix_type = ctxp->is_in_fixing_range(absolute_addr);
    if (!special_fix_type && llabs(new_pc_offset) >= (~lmask >> (lsb + 1))) {
        if ((reinterpret_cast<uint64_t>(*outpp + 4) & 7u) != 0u) {
            (*outpp)[0] = A64_NOP;
            ctxp->reset_current_ins(current_idx, ++(*outpp));
        } //if
        (*outpp)[0] = (((8u >> 2u) << lsb) & ~lmask) | (ins & lmask); // B.C #0x8
        (*outpp)[1] = 0x14000005u; // B #0x14
        (*outpp)[2] = 0x58000051u; // LDR X17, #0x8
        (*outpp)[3] = 0xd61f0220u; // BR X17
        memcpy(*outpp + 4, &absolute_addr, sizeof(absolute_addr));
        *outpp += 6;
    } else {
        if (special_fix_type) {
            intptr_t ref_idx = ctxp->get_ref_ins_index(absolute_addr);
            if (ref_idx <= current_idx) {
                new_pc_offset = static_cast<int64_t>(ctxp->dat[ref_idx].ins - reinterpret_cast<int64_t>(*outpp)) >> 2;
            } else {
                ctxp->insert_fix_map(ref_idx, *outpp, lsb, ~lmask);
                new_pc_offset = 0;
            } //if
        } //if

        (*outpp)[0] = (static_cast<uint32_t>(new_pc_offset << lsb) & ~lmask) | (ins & lmask);
        ++(*outpp);
    } //if

    ++(*inpp);
    return ctxp->process_fix_map(current_idx), true;
}

//-------------------------------------------------------------------------

static bool __fix_loadlit(instruction inpp, instruction outpp, context *ctxp)
{
    const uint32_t ins = *(*inpp);

    // memory prefetch("prfm"), just skip it
    // http://infocenter.arm.com/help/topic/com.arm.doc.100069_0608_00_en/pge1427897420050.html
    if ((ins & 0xff000000u) == 0xd8000000u) {
        ctxp->process_fix_map(ctxp->get_and_set_current_index(*inpp, *outpp));
        ++(*inpp);
        return true;
    } //if

    static constexpr uint32_t msb        = 8u;
    static constexpr uint32_t lsb        = 5u;
    static constexpr uint32_t mask_30    = 0x40000000u; // 0b01000000000000000000000000000000
    static constexpr uint32_t mask_31    = 0x80000000u; // 0b10000000000000000000000000000000
    static constexpr uint32_t lmask      = 0xff00001fu; // 0b11111111000000000000000000011111
    static constexpr uint32_t mask_ldr   = 0xbf000000u; // 0b10111111000000000000000000000000
    static constexpr uint32_t op_ldr     = 0x18000000u; // 0b00011000000000000000000000000000 "LDR Wt/Xt, label" | ADDR_PCREL19
    static constexpr uint32_t mask_ldrv  = 0x3f000000u; // 0b00111111000000000000000000000000
    static constexpr uint32_t op_ldrv    = 0x1c000000u; // 0b00011100000000000000000000000000 "LDR St/Dt/Qt, label" | ADDR_PCREL19
    static constexpr uint32_t mask_ldrsw = 0xff000000u; // 0b11111111000000000000000000000000
    static constexpr uint32_t op_ldrsw   = 0x98000000u; // "LDRSW Xt, label" | ADDR_PCREL19 | load register signed word
    // LDR S0, #0 | 0b00011100000000000000000000000000 | 32-bit
    // LDR D0, #0 | 0b01011100000000000000000000000000 | 64-bit
    // LDR Q0, #0 | 0b10011100000000000000000000000000 | 128-bit
    // INVALID    | 0b11011100000000000000000000000000 | may be 256-bit

    uint32_t  mask     = mask_ldr;
    uintptr_t faligned = (ins & mask_30) ? 7u : 3u;
    if ((ins & mask_ldr) != op_ldr) {
        mask = mask_ldrv;
        if (faligned != 7u)
            faligned = (ins & mask_31) ? 15u : 3u;
        if ((ins & mask_ldrv) != op_ldrv) {
            if ((ins & mask_ldrsw) != op_ldrsw) {
                return false;
            } //if
            mask     = mask_ldrsw;
            faligned = 7u;
        } //if
    } //if

    intptr_t current_idx  = ctxp->get_and_set_current_index(*inpp, *outpp);
    int64_t absolute_addr = reinterpret_cast<int64_t>(*inpp) + ((static_cast<int32_t>(ins << msb) >> (msb + lsb - 2u)) & ~3u);
    int64_t new_pc_offset = static_cast<int64_t>(absolute_addr - reinterpret_cast<int64_t>(*outpp)) >> 2; // shifted
    bool special_fix_type = ctxp->is_in_fixing_range(absolute_addr);
    // special_fix_type may encounter issue when there are mixed data and code
    if (special_fix_type || (llabs(new_pc_offset) + (faligned + 1u - 4u) / 4u) >= (~lmask >> (lsb + 1))) { // inaccurate, but it works
        while ((reinterpret_cast<uint64_t>(*outpp + 2) & faligned) != 0u) {
            *(*outpp)++ = A64_NOP;
        }
        ctxp->reset_current_ins(current_idx, *outpp);

        // Note that if memory at absolute_addr is writeable (non-const), we will fail to fetch it.
        // And what's worse, we may unexpectedly overwrite something if special_fix_type is true...
        uint32_t ns = static_cast<uint32_t>((faligned + 1) / sizeof(uint32_t));
        (*outpp)[0] = (((8u >> 2u) << lsb) & ~mask) | (ins & lmask); // LDR #0x8
        (*outpp)[1] = 0x14000001u + ns; // B #0xc
        memcpy(*outpp + 2, reinterpret_cast<void *>(absolute_addr), faligned + 1);
        *outpp += 2 + ns;
    } else {
        faligned >>= 2; // new_pc_offset is shifted and 4-byte aligned
        while ((new_pc_offset & faligned) != 0) {
            *(*outpp)++   = A64_NOP;
            new_pc_offset = static_cast<int64_t>(absolute_addr - reinterpret_cast<int64_t>(*outpp)) >> 2;
        }
        ctxp->reset_current_ins(current_idx, *outpp);

        (*outpp)[0] = (static_cast<uint32_t>(new_pc_offset << lsb) & ~mask) | (ins & lmask);
        ++(*outpp);
    } //if

    ++(*inpp);
    return ctxp->process_fix_map(current_idx), true;
}

//-------------------------------------------------------------------------

static bool __fix_pcreladdr(instruction inpp, instruction outpp, context *ctxp)
{
    // Load a PC-relative address into a register
    // http://infocenter.arm.com/help/topic/com.arm.doc.100069_0608_00_en/pge1427897645644.html
    static constexpr uint32_t msb     = 8u;
    static constexpr uint32_t lsb     = 5u;
    static constexpr uint32_t mask    = 0x9f000000u; // 0b10011111000000000000000000000000
    static constexpr uint32_t rmask   = 0x0000001fu; // 0b00000000000000000000000000011111
    static constexpr uint32_t lmask   = 0xff00001fu; // 0b11111111000000000000000000011111
    static constexpr uint32_t fmask   = 0x00ffffffu; // 0b00000000111111111111111111111111
    static constexpr uint32_t max_val = 0x001fffffu; // 0b00000000000111111111111111111111
    static constexpr uint32_t op_adr  = 0x10000000u; // "adr"  Rd, ADDR_PCREL21
    static constexpr uint32_t op_adrp = 0x90000000u; // "adrp" Rd, ADDR_ADRP

    const uint32_t ins = *(*inpp);
    intptr_t current_idx;
    switch (ins & mask) {
        case op_adr:
        {
            current_idx           = ctxp->get_and_set_current_index(*inpp, *outpp);
            int64_t lsb_bytes     = static_cast<uint32_t>(ins << 1u) >> 30u;
            int64_t absolute_addr = reinterpret_cast<int64_t>(*inpp) + (((static_cast<int32_t>(ins << msb) >> (msb + lsb - 2u)) & ~3u) | lsb_bytes);
            int64_t new_pc_offset = static_cast<int64_t>(absolute_addr - reinterpret_cast<int64_t>(*outpp));
            bool special_fix_type = ctxp->is_in_fixing_range(absolute_addr);
            if (!special_fix_type && llabs(new_pc_offset) >= (max_val >> 1)) {
                if ((reinterpret_cast<uint64_t>(*outpp + 2) & 7u) != 0u) {
                    (*outpp)[0] = A64_NOP;
                    ctxp->reset_current_ins(current_idx, ++(*outpp));
                } //if

                (*outpp)[0] = 0x58000000u | (((8u >> 2u) << lsb) & ~mask) | (ins & rmask); // LDR #0x8
                (*outpp)[1] = 0x14000003u; // B #0xc
                memcpy(*outpp + 2, &absolute_addr, sizeof(absolute_addr));
                *outpp += 4;
            } else {
                if (special_fix_type) {
                    intptr_t ref_idx = ctxp->get_ref_ins_index(absolute_addr & ~3ull);
                    if (ref_idx <= current_idx) {
                        new_pc_offset = static_cast<int64_t>(ctxp->dat[ref_idx].ins - reinterpret_cast<int64_t>(*outpp));
                    } else {
                        ctxp->insert_fix_map(ref_idx, *outpp, lsb, fmask);
                        new_pc_offset = 0;
                    } //if
                } //if

                // the lsb_bytes will never be changed, so we can use lmask to keep it
                (*outpp)[0] = (static_cast<uint32_t>(new_pc_offset << (lsb - 2u)) & fmask) | (ins & lmask);
                ++(*outpp);
            } //if
        }
            break;
        case op_adrp:
        {
            current_idx           = ctxp->get_and_set_current_index(*inpp, *outpp);
            int32_t lsb_bytes     = static_cast<uint32_t>(ins << 1u) >> 30u;
            int64_t absolute_addr = (reinterpret_cast<int64_t>(*inpp) & ~0xfffll) + ((((static_cast<int32_t>(ins << msb) >> (msb + lsb - 2u)) & ~3u) | lsb_bytes) << 12);
            if (ctxp->is_in_fixing_range(absolute_addr)) {
                intptr_t ref_idx = ctxp->get_ref_ins_index(absolute_addr/* & ~3ull*/);
                if (ref_idx > current_idx) {
                    // the bottom 12 bits of absolute_addr are masked out,
                    // so ref_idx must be less than or equal to current_idx!
                } //if

                // *absolute_addr may be changed due to relocation fixing
                *(*outpp)++ = ins; // 0x90000000u;
            } else {
                if ((reinterpret_cast<uint64_t>(*outpp + 2) & 7u) != 0u) {
                    (*outpp)[0] = A64_NOP;
                    ctxp->reset_current_ins(current_idx, ++(*outpp));
                } //if

                (*outpp)[0] = 0x58000000u | (((8u >> 2u) << lsb) & ~mask) | (ins & rmask); // LDR #0x8
                (*outpp)[1] = 0x14000003u; // B #0xc
                memcpy(*outpp + 2, &absolute_addr, sizeof(absolute_addr)); // potential overflow?
                *outpp += 4;
            } //if
        }
            break;
        default:
            return false;
    }

    ctxp->process_fix_map(current_idx);
    ++(*inpp);
    return true;
}

//-------------------------------------------------------------------------

static void __fix_instructions(uint32_t *__restrict inp, int32_t count, uint32_t *__restrict outp)
{
    context ctx;
    ctx.basep = reinterpret_cast<int64_t>(inp);
    ctx.endp  = reinterpret_cast<int64_t>(inp + count);
    memset(ctx.dat, 0, sizeof(ctx.dat));
    static_assert(sizeof(ctx.dat) / sizeof(ctx.dat[0]) == A64_MAX_INSTRUCTIONS,
                  "please use A64_MAX_INSTRUCTIONS!");

    if (count > A64_MAX_INSTRUCTIONS) {
        //A64_LOGE("too many fixing instructions!");
    }

    uint32_t *const outp_base = outp;

    while (--count >= 0) {
        if (__fix_branch_imm(&inp, &outp, &ctx)) continue;
        if (__fix_cond_comp_test_branch(&inp, &outp, &ctx)) continue;
        if (__fix_loadlit(&inp, &outp, &ctx)) continue;
        if (__fix_pcreladdr(&inp, &outp, &ctx)) continue;

        // without PC-relative offset
        ctx.process_fix_map(ctx.get_and_set_current_index(inp, outp));
        *(outp++) = *(inp++);
    }

    static constexpr uint_fast64_t mask = 0x03ffffffu; // 0b00000011111111111111111111111111
    auto callback  = reinterpret_cast<int64_t>(inp);
    auto pc_offset = static_cast<int64_t>(callback - reinterpret_cast<int64_t>(outp)) >> 2;
    if (llabs(pc_offset) >= (mask >> 1)) {
        if ((reinterpret_cast<uint64_t>(outp + 2) & 7u) != 0u) {
            outp[0] = A64_NOP;
            ++outp;
        } //if
        outp[0] = 0x58000051u; // LDR X17, #0x8
        outp[1] = 0xd61f0220u; // BR X17
        *reinterpret_cast<int64_t *>(outp + 2) = callback;
        outp += 4;
    } else {
        outp[0] = 0x14000000u | (pc_offset & mask); // "B" ADDR_PCREL26
        ++outp;
    } //if

    const uintptr_t total = (outp - outp_base) * sizeof(uint32_t);
    __flush_cache(outp_base, total); // necessary
}

//-------------------------------------------------------------------------

extern "C" {
#define __attribute                __attribute__
#define aligned(x)                 __aligned__(x)
#define __intval(p)                reinterpret_cast<intptr_t>(p)
#define __uintval(p)               reinterpret_cast<uintptr_t>(p)
#define __ptr(p)                   reinterpret_cast<void *>(p)
#define __page_size                4096
#define __page_align(n)            __align_up(static_cast<uintptr_t>(n), __page_size)
#define __ptr_align(x)             __ptr(__align_down(reinterpret_cast<uintptr_t>(x), __page_size))
#define __align_up(x, n)           (((x) + ((n) - 1)) & ~((n) - 1))
#define __align_down(x, n)         ((x) & -(n))
#define __countof(x)               static_cast<intptr_t>(sizeof(x) / sizeof((x)[0])) // must be signed
#define __atomic_increase(p)       __sync_add_and_fetch(p, 1)
#define __sync_cmpswap(p, v, n)    __sync_bool_compare_and_swap(p, v, n)
#define __predict_true(exp)        __builtin_expect((exp) != 0, 1)
#define __make_rwx(p, n)           ::mprotect(__ptr_align(p), \
                                              __page_align(__uintval(p) + n) != __page_align(__uintval(p)) ? __page_align(n) + __page_size : __page_align(n), \
                                              PROT_READ | PROT_WRITE | PROT_EXEC)

//-------------------------------------------------------------------------

static __attribute((aligned(__page_size))) uint32_t __insns_pool[A64_MAX_BACKUPS][A64_MAX_INSTRUCTIONS * 10];

//-------------------------------------------------------------------------

class A64HookInit
{
public:
    A64HookInit()
    {
        __make_rwx(__insns_pool, sizeof(__insns_pool));
    }
};
static A64HookInit __init;

//-------------------------------------------------------------------------

static uint32_t *FastAllocateTrampoline()
{
    static_assert((A64_MAX_INSTRUCTIONS * 10 * sizeof(uint32_t)) % 8 == 0, "8-byte align");
    static volatile int32_t __index = -1;

    int32_t i = __atomic_increase(&__index);
    if (__predict_true(i >= 0 && i < __countof(__insns_pool))) {
        return __insns_pool[i];
    } //if

    return NULL;
}

//-------------------------------------------------------------------------

A64_JNIEXPORT void *A64HookFunctionV(void *const symbol, void *const replace,
                                     void *const rwx, const uintptr_t rwx_size)
{
    static constexpr uint_fast64_t mask = 0x03ffffffu; // 0b00000011111111111111111111111111

    uint32_t *trampoline = static_cast<uint32_t *>(rwx), *original = static_cast<uint32_t *>(symbol);

    static_assert(A64_MAX_INSTRUCTIONS >= 5, "please fix A64_MAX_INSTRUCTIONS!");
    auto pc_offset = static_cast<int64_t>(__intval(replace) - __intval(symbol)) >> 2;
    if (llabs(pc_offset) >= (mask >>1)) {
        int32_t count = (reinterpret_cast<uint64_t>(original + 2) & 7u) != 0u ? 5 : 4;
        if (trampoline) {
            if (rwx_size < count * 10u) {
                return NULL;
            } //if
            __fix_instructions(original, count, trampoline);
        } //if

        if (__make_rwx(original, 5 * sizeof(uint32_t)) == 0) {
            if (count == 5) {
                original[0] = A64_NOP;
                ++original;
            } //if
            original[0] = 0x58000051u; // LDR X17, #0x8
            original[1] = 0xd61f0220u; // BR X17
            *reinterpret_cast<int64_t *>(original + 2) = __intval(replace);
            __flush_cache(symbol, 5 * sizeof(uint32_t));

        } else {
            trampoline = NULL;
        } //if
    } else {
        if (trampoline) {
            if (rwx_size < 1u * 10u) {
                return NULL;
            } //if
            __fix_instructions(original, 1, trampoline);
        } //if

        if (__make_rwx(original, 1 * sizeof(uint32_t)) == 0) {
            __sync_cmpswap(original, *original, 0x14000000u | (pc_offset & mask)); // "B" ADDR_PCREL26
            __flush_cache(symbol, 1 * sizeof(uint32_t));

        } else {
            trampoline = NULL;
        } //if
    } //if

    return trampoline;
}

//-------------------------------------------------------------------------

A64_JNIEXPORT void A64HookFunction(void *const symbol, void *const replace, void **result)
{
    void *trampoline = NULL;
    if (result != NULL) {
        trampoline = FastAllocateTrampoline();
        *result = trampoline;
        if (trampoline == NULL) return;
    } //if

    trampoline = A64HookFunctionV(symbol, replace, trampoline, A64_MAX_INSTRUCTIONS * 10u);
    if (trampoline == NULL && result != NULL) {
        *result = NULL;
    } //if
}
}

#endif // defined(__aarch64__)
```

`app/src/main/jni/Substrate/And64InlineHook.hpp`:

```hpp
/*
 *  @date   : 2018/04/18
 *  @author : Rprop (r_prop@outlook.com)
 *  https://github.com/Rprop/And64InlineHook
 */
/*
 MIT License

 Copyright (c) 2018 Rprop (r_prop@outlook.com)

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
#pragma once

#include <stdint.h>

#define A64_MAX_BACKUPS 256
#define NDEBUG

#ifdef __cplusplus
extern "C" {
#endif

void A64HookFunction(void *const symbol, void *const replace, void **result);
void *A64HookFunctionV(void *const symbol, void *const replace,
                       void *const rwx, const uintptr_t rwx_size);

#ifdef __cplusplus
}
#endif
```

`app/src/main/jni/Substrate/Buffer.hpp`:

```hpp
/* Cydia Substrate - Powerful Code Insertion Platform
 * Copyright (C) 2008-2011  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Substrate is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Substrate is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

#ifndef SUBSTRATE_BUFFER_HPP
#define SUBSTRATE_BUFFER_HPP

#include <string.h>

template <typename Type_>
_disused static _finline void MSWrite(uint8_t *&buffer, Type_ value) {
    *reinterpret_cast<Type_ *>(buffer) = value;
    buffer += sizeof(Type_);
}

_disused static _finline void MSWrite(uint8_t *&buffer, uint8_t *data, size_t size) {
    memcpy(buffer, data, size);
    buffer += size;
}

#endif//SUBSTRATE_BUFFER_HPP

```

`app/src/main/jni/Substrate/CydiaSubstrate.h`:

```h
/* Cydia Substrate - Powerful Code Insertion Platform
 * Copyright (C) 2008-2011  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Substrate is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Substrate is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

#ifndef SUBSTRATE_H_
#define SUBSTRATE_H_

#ifdef __APPLE__
#ifdef __cplusplus
extern "C" {
#endif
#include <mach-o/nlist.h>
#ifdef __cplusplus
}
#endif

#include <objc/runtime.h>
#include <objc/message.h>
#endif

#include <dlfcn.h>
#include <stdlib.h>

#define _finline \
    inline __attribute__((__always_inline__))
#define _disused \
    __attribute__((__unused__))

#define _extern \
    extern "C" __attribute__((__visibility__("hidden")))

#ifdef __cplusplus
#define _default(value) = value
#else
#define _default(value)
#endif

#ifdef __cplusplus
extern "C" {
#endif

bool MSHookProcess(pid_t pid, const char *library);

typedef const void *MSImageRef;

MSImageRef MSGetImageByName(const char *file);
void *MSFindSymbol(MSImageRef image, const char *name);

void MSHookFunction(void *symbol, void *replace, void **result);

#ifdef __APPLE__
#ifdef __arm__
__attribute__((__deprecated__))
IMP MSHookMessage(Class _class, SEL sel, IMP imp, const char *prefix _default(NULL));
#endif
void MSHookMessageEx(Class _class, SEL sel, IMP imp, IMP *result);
#endif

#ifdef SubstrateInternal
typedef void *SubstrateAllocatorRef;
typedef struct __SubstrateProcess *SubstrateProcessRef;
typedef struct __SubstrateMemory *SubstrateMemoryRef;

SubstrateProcessRef SubstrateProcessCreate(SubstrateAllocatorRef allocator, pid_t pid);
void SubstrateProcessRelease(SubstrateProcessRef process);

SubstrateMemoryRef SubstrateMemoryCreate(SubstrateAllocatorRef allocator, SubstrateProcessRef process, void *data, size_t size);
void SubstrateMemoryRelease(SubstrateMemoryRef memory);
#endif

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus

#ifdef SubstrateInternal
struct SubstrateHookMemory {
    SubstrateMemoryRef handle_;

    SubstrateHookMemory(SubstrateProcessRef process, void *data, size_t size) :
        handle_(SubstrateMemoryCreate(NULL, NULL, data, size))
    {
    }

    ~SubstrateHookMemory() {
        if (handle_ != NULL)
            SubstrateMemoryRelease(handle_);
    }
};
#endif


template<typename Type_>
static inline void MSHookFunction(Type_ *symbol, Type_ *replace, Type_ **result) {
    MSHookFunction(
            reinterpret_cast<void *>(symbol),
            reinterpret_cast<void *>(replace),
            reinterpret_cast<void **>(result)
    );
}

template<typename Type_>
static inline void MSHookFunction(Type_ *symbol, Type_ *replace) {
    return MSHookFunction(symbol, replace, reinterpret_cast<Type_ **>(NULL));
}

template<typename Type_>
static inline void MSHookSymbol(Type_ *&value, const char *name, MSImageRef image = NULL) {
    value = reinterpret_cast<Type_ *>(MSFindSymbol(image, name));
}

template<typename Type_>
static inline void MSHookFunction(const char *name, Type_ *replace, Type_ **result = NULL) {
    Type_ *symbol;
    MSHookSymbol(symbol, name);
    return MSHookFunction(symbol, replace, result);
}

#endif

#define MSHook(type, name, args...) \
    _disused static type (*_ ## name)(args); \
    static type $ ## name(args)

#ifdef __cplusplus
#define MSHake(name) \
    &$ ## name, &_ ## name
#else
#define MSHake(name) \
    &$ ## name, (void **) &_ ## name
#endif


#endif//SUBSTRATE_H_

```

`app/src/main/jni/Substrate/SubstrateARM.hpp`:

```hpp
/* Cydia Substrate - Powerful Code Insertion Platform
 * Copyright (C) 2008-2011  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Substrate is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Substrate is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

#ifndef SUBSTRATE_ARM_HPP
#define SUBSTRATE_ARM_HPP

enum A$r {
    A$r0, A$r1, A$r2, A$r3,
    A$r4, A$r5, A$r6, A$r7,
    A$r8, A$r9, A$r10, A$r11,
    A$r12, A$r13, A$r14, A$r15,
    A$sp = A$r13,
    A$lr = A$r14,
    A$pc = A$r15
};

enum A$c {
    A$eq, A$ne, A$cs, A$cc,
    A$mi, A$pl, A$vs, A$vc,
    A$hi, A$ls, A$ge, A$lt,
    A$gt, A$le, A$al,
    A$hs = A$cs,
    A$lo = A$cc
};

#define _abs(im) abs((int)im)

#define A$mrs_rm_cpsr(rd) /* mrs rd, cpsr */ \
    (0xe10f0000 | ((rd) << 12))
#define A$msr_cpsr_f_rm(rm) /* msr cpsr_f, rm */ \
    (0xe128f000 | (rm))
#define A$ldr_rd_$rn_im$(rd, rn, im) /* ldr rd, [rn, #im] */ \
    (0xe5100000 | ((im) < 0 ? 0 : 1 << 23) | ((rn) << 16) | ((rd) << 12) | _abs(im))
#define A$str_rd_$rn_im$(rd, rn, im) /* sr rd, [rn, #im] */ \
    (0xe5000000 | ((im) < 0 ? 0 : 1 << 23) | ((rn) << 16) | ((rd) << 12) | _abs(im))
#define A$sub_rd_rn_$im(rd, rn, im) /* sub, rd, rn, #im */ \
    (0xe2400000 | ((rn) << 16) | ((rd) << 12) | (im & 0xff))
#define A$blx_rm(rm) /* blx rm */ \
    (0xe12fff30 | (rm))
#define A$mov_rd_rm(rd, rm) /* mov rd, rm */ \
    (0xe1a00000 | ((rd) << 12) | (rm))
#define A$ldmia_sp$_$rs$(rs) /* ldmia sp!, {rs} */ \
    (0xe8b00000 | (A$sp << 16) | (rs))
#define A$stmdb_sp$_$rs$(rs) /* stmdb sp!, {rs} */ \
    (0xe9200000 | (A$sp << 16) | (rs))
#define A$stmia_sp$_$r0$  0xe8ad0001 /* stmia sp!, {r0}   */
#define A$bx_r0           0xe12fff10 /* bx r0             */

#endif//SUBSTRATE_ARM_HPP

```

`app/src/main/jni/Substrate/SubstrateDebug.cpp`:

```cpp
/* Cydia Substrate - Powerful Code Insertion Platform
 * Copyright (C) 2008-2011  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Substrate is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Substrate is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

#include "SubstrateHook.h"
#include "SubstrateDebug.hpp"

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

_extern bool MSDebug;
bool MSDebug = false;

static char _MSHexChar(uint8_t value) {
    return value < 0x20 || value >= 0x80 ? '.' : value;
}

#define HexWidth_ 16
#define HexDepth_ 4

void MSLogHexEx(const void *vdata, size_t size, size_t stride, const char *mark) {
    const uint8_t *data((const uint8_t *) vdata);

    size_t i(0), j;

    char d[256];
    size_t b(0);
    d[0] = '\0';

    while (i != size) {
        if (i % HexWidth_ == 0) {
            if (mark != NULL)
                b += sprintf(d + b, "\n[%s] ", mark);
            b += sprintf(d + b, "0x%.3zx:", i);
        }

        b += sprintf(d + b, " ");

        for (size_t q(0); q != stride; ++q)
            b += sprintf(d + b, "%.2x", data[i + stride - q - 1]);

        i += stride;

        for (size_t q(1); q != stride; ++q)
            b += sprintf(d + b, " ");

        if (i % HexDepth_ == 0)
            b += sprintf(d + b, " ");

        if (i % HexWidth_ == 0) {
            b += sprintf(d + b, " ");
            for (j = i - HexWidth_; j != i; ++j)
                b += sprintf(d + b, "%c", _MSHexChar(data[j]));

            lprintf("%s", d);
            b = 0;
            d[0] = '\0';
        }
    }

    if (i % HexWidth_ != 0) {
        for (j = i % HexWidth_; j != HexWidth_; ++j)
            b += sprintf(d + b, "   ");
        for (j = 0; j != (HexWidth_ - i % HexWidth_ + HexDepth_ - 1) / HexDepth_; ++j)
            b += sprintf(d + b, " ");
        b += sprintf(d + b, " ");
        for (j = i / HexWidth_ * HexWidth_; j != i; ++j)
            b += sprintf(d + b, "%c", _MSHexChar(data[j]));

        lprintf("%s", d);
        b = 0;
        d[0] = '\0';
    }
}

void MSLogHex(const void *vdata, size_t size, const char *mark) {
	return;
}

```

`app/src/main/jni/Substrate/SubstrateDebug.hpp`:

```hpp
/* Cydia Substrate - Powerful Code Insertion Platform
 * Copyright (C) 2008-2011  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Substrate is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Substrate is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

#ifndef SUBSTRATE_DEBUG_HPP
#define SUBSTRATE_DEBUG_HPP

#include "SubstrateLog.hpp"
#define lprintf(format, ...) \
    MSLog(MSLogLevelNotice, format, ## __VA_ARGS__)

extern "C" bool MSDebug;
void MSLogHexEx(const void *vdata, size_t size, size_t stride, const char *mark = 0);
void MSLogHex(const void *vdata, size_t size, const char *mark = 0);

#endif//SUBSTRATE_DEBUG_HPP

```

`app/src/main/jni/Substrate/SubstrateHook.cpp`:

```cpp
/* Cydia Substrate - Powerful Code Insertion Platform
 * Copyright (C) 2008-2011  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Substrate is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Substrate is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

#define SubstrateInternal

#include "CydiaSubstrate.h"
#include "And64InlineHook.hpp"

#include <sys/mman.h>

#define _trace() do { \
    //MSLog(MSLogLevelNotice, "_trace(%u)", __LINE__); \
} while (false)

#if defined(__i386__) || defined(__x86_64__)
#include "hde64.h"
#endif

#include "SubstrateDebug.hpp"

#include <errno.h>
#include <stdio.h>
#include <string.h>

#ifdef __arm__
/* WebCore (ARM) PC-Relative:
X    1  ldr r*,[pc,r*] !=
     2 fldd d*,[pc,#*]
X    5  str r*,[pc,r*] !=
     8 flds s*,[pc,#*]
   400  ldr r*,[pc,r*] ==
   515  add r*, pc,r*  ==
X 4790  ldr r*,[pc,#*]    */

// x=0; while IFS= read -r line; do if [[ ${#line} -ne 0 && $line == +([^\;]): ]]; then x=2; elif [[ $line == ' +'* && $x -ne 0 ]]; then ((--x)); echo "$x${line}"; fi; done <WebCore.asm >WebCore.pc
// grep pc WebCore.pc | cut -c 40- | sed -Ee 's/^ldr *(ip|r[0-9]*),\[pc,\#0x[0-9a-f]*\].*/ ldr r*,[pc,#*]/;s/^add *r[0-9]*,pc,r[0-9]*.*/ add r*, pc,r*/;s/^(st|ld)r *r([0-9]*),\[pc,r([0-9]*)\].*/ \1r r\2,[pc,r\3]/;s/^fld(s|d) *(s|d)[0-9]*,\[pc,#0x[0-9a-f]*].*/fld\1 \2*,[pc,#*]/' | sort | uniq -c | sort -n

#include "SubstrateARM.hpp"
#include "And64InlineHook.hpp"

#define T$Label(l, r) \
    (((r) - (l)) * 2 - 4 + ((l) % 2 == 0 ? 0 : 2))

#define T$pop_$r0$ 0xbc01 // pop {r0}
#define T$b(im) /* b im */ \
    (0xde00 | (im & 0xff))
#define T$blx(rm) /* blx rm */ \
    (0x4780 | (rm << 3))
#define T$bx(rm) /* bx rm */ \
    (0x4700 | (rm << 3))
#define T$nop /* nop */ \
    (0x46c0)

#define T$add_rd_rm(rd, rm) /* add rd, rm */ \
    (0x4400 | (((rd) & 0x8) >> 3 << 7) | (((rm) & 0x8) >> 3 << 6) | (((rm) & 0x7) << 3) | ((rd) & 0x7))
#define T$push_r(r) /* push r... */ \
    (0xb400 | (((r) & (1 << A$lr)) >> A$lr << 8) | ((r) & 0xff))
#define T$pop_r(r) /* pop r... */ \
    (0xbc00 | (((r) & (1 << A$pc)) >> A$pc << 8) | ((r) & 0xff))
#define T$mov_rd_rm(rd, rm) /* mov rd, rm */ \
    (0x4600 | (((rd) & 0x8) >> 3 << 7) | (((rm) & 0x8) >> 3 << 6) | (((rm) & 0x7) << 3) | ((rd) & 0x7))
#define T$ldr_rd_$rn_im_4$(rd, rn, im) /* ldr rd, [rn, #im * 4] */ \
    (0x6800 | (((im) & 0x1f) << 6) | ((rn) << 3) | (rd))
#define T$ldr_rd_$pc_im_4$(rd, im) /* ldr rd, [PC, #im * 4] */ \
    (0x4800 | ((rd) << 8) | ((im) & 0xff))
#define T$cmp_rn_$im(rn, im) /* cmp rn, #im */ \
    (0x2000 | ((rn) << 8) | ((im) & 0xff))
#define T$it$_cd(cd, ms) /* it<ms>, cd */ \
    (0xbf00 | ((cd) << 4) | (ms))
#define T$cbz$_rn_$im(op, rn, im) /* cb<op>z rn, #im */ \
    (0xb100 | ((op) << 11) | (((im) & 0x40) >> 6 << 9) | (((im) & 0x3e) >> 1 << 3) | (rn))
#define T$b$_$im(cond, im) /* b<cond> #im */ \
    (cond == A$al ? 0xe000 | (((im) >> 1) & 0x7ff) : 0xd000 | ((cond) << 8) | (((im) >> 1) & 0xff))

#define T1$ldr_rt_$rn_im$(rt, rn, im) /* ldr rt, [rn, #im] */ \
    (0xf850 | ((im < 0 ? 0 : 1) << 7) | (rn))
#define T2$ldr_rt_$rn_im$(rt, rn, im) /* ldr rt, [rn, #im] */ \
    (((rt) << 12) | _abs(im))

#define T1$mrs_rd_apsr(rd) /* mrs rd, apsr */ \
    (0xf3ef)
#define T2$mrs_rd_apsr(rd) /* mrs rd, apsr */ \
    (0x8000 | ((rd) << 8))

#define T1$msr_apsr_nzcvqg_rn(rn) /* msr apsr, rn */ \
    (0xf380 | (rn))
#define T2$msr_apsr_nzcvqg_rn(rn) /* msr apsr, rn */ \
    (0x8c00)
#define T$msr_apsr_nzcvqg_rn(rn) /* msr apsr, rn */ \
    (T2$msr_apsr_nzcvqg_rn(rn) << 16 | T1$msr_apsr_nzcvqg_rn(rn))

static inline bool A$pcrel$r(uint32_t ic) {
    return (ic & 0x0c000000) == 0x04000000 && (ic & 0xf0000000) != 0xf0000000 &&
           (ic & 0x000f0000) == 0x000f0000;
}

static inline bool T$32bit$i(uint16_t ic) {
    return ((ic & 0xe000) == 0xe000 && (ic & 0x1800) != 0x0000);
}

static inline bool T$pcrel$cbz(uint16_t ic) {
    return (ic & 0xf500) == 0xb100;
}

static inline bool T$pcrel$b(uint16_t ic) {
    return (ic & 0xf000) == 0xd000 && (ic & 0x0e00) != 0x0e00;
}

static inline bool T2$pcrel$b(uint16_t *ic) {
    return (ic[0] & 0xf800) == 0xf000 &&
           ((ic[1] & 0xd000) == 0x9000 || (ic[1] & 0xd000) == 0x8000 && (ic[0] & 0x0380) != 0x0380);
}

static inline bool T$pcrel$bl(uint16_t *ic) {
    return (ic[0] & 0xf800) == 0xf000 && ((ic[1] & 0xd000) == 0xd000 || (ic[1] & 0xd001) == 0xc000);
}

static inline bool T$pcrel$ldr(uint16_t ic) {
    return (ic & 0xf800) == 0x4800;
}

static inline bool T$pcrel$add(uint16_t ic) {
    return (ic & 0xff78) == 0x4478;
}

static inline bool T$pcrel$ldrw(uint16_t ic) {
    return (ic & 0xff7f) == 0xf85f;
}

static size_t MSGetInstructionWidthThumb(void *start) {
    uint16_t *thumb(reinterpret_cast<uint16_t *>(start));
    return T$32bit$i(thumb[0]) ? 4 : 2;
}

static size_t MSGetInstructionWidthARM(void *start) {
    return 4;
}

extern "C" size_t MSGetInstructionWidth(void *start) {
    if ((reinterpret_cast<uintptr_t>(start) & 0x1) == 0)
        return MSGetInstructionWidthARM(start);
    else
        return MSGetInstructionWidthThumb(
                reinterpret_cast<void *>(reinterpret_cast<uintptr_t>(start) & ~0x1));
}

static size_t SubstrateHookFunctionThumb(SubstrateProcessRef process, void *symbol, void *replace,
                                         void **result) {
    if (symbol == NULL)
        return 0;
    //printf("SubstrateHookFunctionThumb\n");
    uint16_t *area(reinterpret_cast<uint16_t *>(symbol));

    unsigned align((reinterpret_cast<uintptr_t>(area) & 0x2) == 0 ? 0 : 1);
    uint16_t *thumb(area + align);

    uint32_t *arm(reinterpret_cast<uint32_t *>(thumb + 2));
    uint16_t *trail(reinterpret_cast<uint16_t *>(arm + 2));

    if (
            (align == 0 || area[0] == T$nop) &&
            thumb[0] == T$bx(A$pc) &&
            thumb[1] == T$nop &&
            arm[0] == A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8)
            ) {
        if (result != NULL)
            *result = reinterpret_cast<void *>(arm[1]);

        SubstrateHookMemory code(process, arm + 1, sizeof(uint32_t) * 1);

        arm[1] = reinterpret_cast<uint32_t>(replace);

        return sizeof(arm[0]);
    }

    size_t required((trail - area) * sizeof(uint16_t));

    size_t used(0);
    while (used < required)
        used += MSGetInstructionWidthThumb(reinterpret_cast<uint8_t *>(area) + used);
    used = (used + sizeof(uint16_t) - 1) / sizeof(uint16_t) * sizeof(uint16_t);

    size_t blank((used - required) / sizeof(uint16_t));

    uint16_t backup[used / sizeof(uint16_t)];
    memcpy(backup, area, used);

    if (MSDebug) {
        char name[16];
        sprintf(name, "%p", area);
        MSLogHexEx(area, used + sizeof(uint16_t), 2, name);
    }

    if (result != NULL) {

        size_t length(used);
        for (unsigned offset(0); offset != used / sizeof(uint16_t); ++offset)
            if (T$pcrel$ldr(backup[offset]))
                length += 3 * sizeof(uint16_t);
            else if (T$pcrel$b(backup[offset]))
                length += 6 * sizeof(uint16_t);
            else if (T2$pcrel$b(backup + offset)) {
                length += 5 * sizeof(uint16_t);
                ++offset;
            } else if (T$pcrel$bl(backup + offset)) {
                length += 5 * sizeof(uint16_t);
                ++offset;
            } else if (T$pcrel$cbz(backup[offset])) {
                length += 16 * sizeof(uint16_t);
            } else if (T$pcrel$ldrw(backup[offset])) {
                length += 4 * sizeof(uint16_t);
                ++offset;
            } else if (T$pcrel$add(backup[offset]))
                length += 6 * sizeof(uint16_t);
            else if (T$32bit$i(backup[offset]))
                ++offset;

        unsigned pad((length & 0x2) == 0 ? 0 : 1);
        length += (pad + 2) * sizeof(uint16_t) + 2 * sizeof(uint32_t);

        uint16_t *buffer(reinterpret_cast<uint16_t *>(mmap(
                NULL, length, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0
        )));

        if (buffer == MAP_FAILED) {
            //MSLog(MSLogLevelError, "MS:Error:mmap() = %d", errno);
            *result = NULL;
            return 0;
        }

        if (false)
            fail:
            {
                munmap(buffer, length);
                *result = NULL;
                return 0;
            }

        size_t start(pad), end(length / sizeof(uint16_t));
        uint32_t *trailer(reinterpret_cast<uint32_t *>(buffer + end));
        for (unsigned offset(0); offset != used / sizeof(uint16_t); ++offset) {
            if (T$pcrel$ldr(backup[offset])) {
                union {
                    uint16_t value;

                    struct {
                        uint16_t immediate : 8;
                        uint16_t rd : 3;
                        uint16_t : 5;
                    };
                } bits = {backup[offset + 0]};

                buffer[start + 0] = T$ldr_rd_$pc_im_4$(bits.rd, T$Label(start + 0, end - 2) / 4);
                buffer[start + 1] = T$ldr_rd_$rn_im_4$(bits.rd, bits.rd, 0);

                // XXX: this code "works", but is "wrong": the mechanism is more complex than this
                *--trailer = ((reinterpret_cast<uint32_t>(area + offset) + 4) & ~0x2) +
                             bits.immediate * 4;

                start += 2;
                end -= 2;
            } else if (T$pcrel$b(backup[offset])) {
                union {
                    uint16_t value;

                    struct {
                        uint16_t imm8 : 8;
                        uint16_t cond : 4;
                        uint16_t /*1101*/ : 4;
                    };
                } bits = {backup[offset + 0]};

                intptr_t jump(bits.imm8 << 1);
                jump |= 1;
                jump <<= 23;
                jump >>= 23;

                buffer[start + 0] = T$b$_$im(bits.cond, (end - 6 - (start + 0)) * 2 - 4);

                *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4 + jump;
                *--trailer = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
                *--trailer = T$nop << 16 | T$bx(A$pc);

                start += 1;
                end -= 6;
            } else if (T2$pcrel$b(backup + offset)) {
                union {
                    uint16_t value;

                    struct {
                        uint16_t imm6 : 6;
                        uint16_t cond : 4;
                        uint16_t s : 1;
                        uint16_t : 5;
                    };
                } bits = {backup[offset + 0]};

                union {
                    uint16_t value;

                    struct {
                        uint16_t imm11 : 11;
                        uint16_t j2 : 1;
                        uint16_t a : 1;
                        uint16_t j1 : 1;
                        uint16_t : 2;
                    };
                } exts = {backup[offset + 1]};

                intptr_t jump(1);
                jump |= exts.imm11 << 1;
                jump |= bits.imm6 << 12;

                if (exts.a) {
                    jump |= bits.s << 24;
                    jump |= (~(bits.s ^ exts.j1) & 0x1) << 23;
                    jump |= (~(bits.s ^ exts.j2) & 0x1) << 22;
                    jump |= bits.cond << 18;
                    jump <<= 7;
                    jump >>= 7;
                } else {
                    jump |= bits.s << 20;
                    jump |= exts.j2 << 19;
                    jump |= exts.j1 << 18;
                    jump <<= 11;
                    jump >>= 11;
                }

                buffer[start + 0] = T$b$_$im(exts.a ? A$al : bits.cond,
                                             (end - 6 - (start + 0)) * 2 - 4);

                *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4 + jump;
                *--trailer = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
                *--trailer = T$nop << 16 | T$bx(A$pc);

                ++offset;
                start += 1;
                end -= 6;
            } else if (T$pcrel$bl(backup + offset)) {
                union {
                    uint16_t value;

                    struct {
                        uint16_t immediate : 10;
                        uint16_t s : 1;
                        uint16_t : 5;
                    };
                } bits = {backup[offset + 0]};

                union {
                    uint16_t value;

                    struct {
                        uint16_t immediate : 11;
                        uint16_t j2 : 1;
                        uint16_t x : 1;
                        uint16_t j1 : 1;
                        uint16_t : 2;
                    };
                } exts = {backup[offset + 1]};

                int32_t jump(0);
                jump |= bits.s << 24;
                jump |= (~(bits.s ^ exts.j1) & 0x1) << 23;
                jump |= (~(bits.s ^ exts.j2) & 0x1) << 22;
                jump |= bits.immediate << 12;
                jump |= exts.immediate << 1;
                jump |= exts.x;
                jump <<= 7;
                jump >>= 7;

                buffer[start + 0] = T$push_r(1 << A$r7);
                buffer[start + 1] = T$ldr_rd_$pc_im_4$(A$r7,
                                                       ((end - 2 - (start + 1)) * 2 - 4 + 2) / 4);
                buffer[start + 2] = T$mov_rd_rm(A$lr, A$r7);
                buffer[start + 3] = T$pop_r(1 << A$r7);
                buffer[start + 4] = T$blx(A$lr);

                *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4 + jump;

                ++offset;
                start += 5;
                end -= 2;
            } else if (T$pcrel$cbz(backup[offset])) {
                union {
                    uint16_t value;

                    struct {
                        uint16_t rn : 3;
                        uint16_t immediate : 5;
                        uint16_t : 1;
                        uint16_t i : 1;
                        uint16_t : 1;
                        uint16_t op : 1;
                        uint16_t : 4;
                    };
                } bits = {backup[offset + 0]};

                intptr_t jump(1);
                jump |= bits.i << 6;
                jump |= bits.immediate << 1;

                //jump <<= 24;
                //jump >>= 24;

                unsigned rn(bits.rn);
                unsigned rt(rn == A$r7 ? A$r6 : A$r7);

                buffer[start + 0] = T$push_r(1 << rt);
                buffer[start + 1] = T1$mrs_rd_apsr(rt);
                buffer[start + 2] = T2$mrs_rd_apsr(rt);
                buffer[start + 3] = T$cbz$_rn_$im(bits.op, rn, (end - 10 - (start + 3)) * 2 - 4);
                buffer[start + 4] = T1$msr_apsr_nzcvqg_rn(rt);
                buffer[start + 5] = T2$msr_apsr_nzcvqg_rn(rt);
                buffer[start + 6] = T$pop_r(1 << rt);

                *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4 + jump;
                *--trailer = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
                *--trailer = T$nop << 16 | T$bx(A$pc);
                *--trailer = T$nop << 16 | T$pop_r(1 << rt);
                *--trailer = T$msr_apsr_nzcvqg_rn(rt);

#if 0
                if ((start & 0x1) == 0)
                    buffer[start++] = T$nop;
                buffer[start++] = T$bx(A$pc);
                buffer[start++] = T$nop;

                uint32_t *arm(reinterpret_cast<uint32_t *>(buffer + start));
                arm[0] = A$add(A$lr, A$pc, 1);
                arm[1] = A$ldr_rd_$rn_im$(A$pc, A$pc, (trailer - arm) * sizeof(uint32_t) - 8);
#endif

                start += 7;
                end -= 10;
            } else if (T$pcrel$ldrw(backup[offset])) {
                union {
                    uint16_t value;

                    struct {
                        uint16_t : 7;
                        uint16_t u : 1;
                        uint16_t : 8;
                    };
                } bits = {backup[offset + 0]};

                union {
                    uint16_t value;

                    struct {
                        uint16_t immediate : 12;
                        uint16_t rt : 4;
                    };
                } exts = {backup[offset + 1]};

                buffer[start + 0] = T1$ldr_rt_$rn_im$(exts.rt, A$pc, T$Label(start + 0, end - 2));
                buffer[start + 1] = T2$ldr_rt_$rn_im$(exts.rt, A$pc, T$Label(start + 0, end - 2));

                buffer[start + 2] = T1$ldr_rt_$rn_im$(exts.rt, exts.rt, 0);
                buffer[start + 3] = T2$ldr_rt_$rn_im$(exts.rt, exts.rt, 0);

                // XXX: this code "works", but is "wrong": the mechanism is more complex than this
                *--trailer = ((reinterpret_cast<uint32_t>(area + offset) + 4) & ~0x2) +
                             (bits.u == 0 ? -exts.immediate : exts.immediate);

                ++offset;
                start += 4;
                end -= 2;
            } else if (T$pcrel$add(backup[offset])) {
                union {
                    uint16_t value;

                    struct {
                        uint16_t rd : 3;
                        uint16_t rm : 3;
                        uint16_t h2 : 1;
                        uint16_t h1 : 1;
                        uint16_t : 8;
                    };
                } bits = {backup[offset + 0]};

                if (bits.h1) {
                    //MSLog(MSLogLevelError, "MS:Error:pcrel(%u):add (rd > r7)", offset);
                    goto fail;
                }

                unsigned rt(bits.rd == A$r7 ? A$r6 : A$r7);

                buffer[start + 0] = T$push_r(1 << rt);
                buffer[start + 1] = T$mov_rd_rm(rt, (bits.h1 << 3) | bits.rd);
                buffer[start + 2] = T$ldr_rd_$pc_im_4$(bits.rd, T$Label(start + 2, end - 2) / 4);
                buffer[start + 3] = T$add_rd_rm((bits.h1 << 3) | bits.rd, rt);
                buffer[start + 4] = T$pop_r(1 << rt);
                *--trailer = reinterpret_cast<uint32_t>(area + offset) + 4;

                start += 5;
                end -= 2;
            } else if (T$32bit$i(backup[offset])) {
                buffer[start++] = backup[offset];
                buffer[start++] = backup[++offset];
            } else {
                buffer[start++] = backup[offset];
            }
        }

        buffer[start++] = T$bx(A$pc);
        buffer[start++] = T$nop;

        uint32_t *transfer = reinterpret_cast<uint32_t *>(buffer + start);
        transfer[0] = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
        transfer[1] = reinterpret_cast<uint32_t>(area + used / sizeof(uint16_t)) + 1;

        if (mprotect(buffer, length, PROT_READ | PROT_EXEC) == -1) {
            //MSLog(MSLogLevelError, "MS:Error:mprotect():%d", errno);
            return 0;
        }

        *result = reinterpret_cast<uint8_t *>(buffer + pad) + 1;

        if (MSDebug) {
            char name[16];
            sprintf(name, "%p", *result);
            MSLogHexEx(buffer, length, 2, name);
        }

    }

    {
        SubstrateHookMemory code(process, area, used);

        if (align != 0)
            area[0] = T$nop;

        thumb[0] = T$bx(A$pc);
        thumb[1] = T$nop;

        arm[0] = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
        arm[1] = reinterpret_cast<uint32_t>(replace);

        for (unsigned offset(0); offset != blank; ++offset)
            trail[offset] = T$nop;
    }

    if (MSDebug) {
        char name[16];
        sprintf(name, "%p", area);
        MSLogHexEx(area, used + sizeof(uint16_t), 2, name);
    }

    return used;
}

static size_t
SubstrateHookFunctionARM(SubstrateProcessRef process, void *symbol, void *replace, void **result) {
    if (symbol == NULL)
        return 0;
    //printf("SubstrateHookFunctionARM\n");
    uint32_t *area(reinterpret_cast<uint32_t *>(symbol));
    uint32_t *arm(area);

    const size_t used(8);

    uint32_t backup[used / sizeof(uint32_t)] = {arm[0], arm[1]};

    if (MSDebug) {
        char name[16];
        sprintf(name, "%p", area);
        MSLogHexEx(area, used + sizeof(uint32_t), 4, name);
    }

    if (result != NULL) {

        if (backup[0] == A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8)) {
            *result = reinterpret_cast<void *>(backup[1]);

            return sizeof(backup[0]);
        }

        size_t length(used);
        for (unsigned offset(0); offset != used / sizeof(uint32_t); ++offset)
            if (A$pcrel$r(backup[offset])) {
                if ((backup[offset] & 0x02000000) == 0 ||
                    (backup[offset] & 0x0000f000 >> 12) != (backup[offset] & 0x0000000f))
                    length += 2 * sizeof(uint32_t);
                else
                    length += 4 * sizeof(uint32_t);
            }

        length += 2 * sizeof(uint32_t);

        uint32_t *buffer(reinterpret_cast<uint32_t *>(mmap(
                NULL, length, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0
        )));

        if (buffer == MAP_FAILED) {
            //MSLog(MSLogLevelError, "MS:Error:mmap() = %d", errno);
            *result = NULL;
            return 0;
        }

        if (false)
            fail:
            {
                munmap(buffer, length);
                *result = NULL;
                return 0;
            }

        size_t start(0), end(length / sizeof(uint32_t));
        uint32_t *trailer(reinterpret_cast<uint32_t *>(buffer + end));
        for (unsigned offset(0); offset != used / sizeof(uint32_t); ++offset)
            if (A$pcrel$r(backup[offset])) {
                union {
                    uint32_t value;

                    struct {
                        uint32_t rm : 4;
                        uint32_t : 1;
                        uint32_t shift : 2;
                        uint32_t shiftamount : 5;
                        uint32_t rd : 4;
                        uint32_t rn : 4;
                        uint32_t l : 1;
                        uint32_t w : 1;
                        uint32_t b : 1;
                        uint32_t u : 1;
                        uint32_t p : 1;
                        uint32_t mode : 1;
                        uint32_t type : 2;
                        uint32_t cond : 4;
                    };
                } bits = {backup[offset + 0]}, copy(bits);

                bool guard;
                if (bits.mode == 0 || bits.rd != bits.rm) {
                    copy.rn = bits.rd;
                    guard = false;
                } else {
                    copy.rn = bits.rm != A$r0 ? A$r0 : A$r1;
                    guard = true;
                }

                if (guard)
                    buffer[start++] = A$stmdb_sp$_$rs$((1 << copy.rn));

                buffer[start + 0] = A$ldr_rd_$rn_im$(copy.rn, A$pc,
                                                     (end - 1 - (start + 0)) * 4 - 8);
                buffer[start + 1] = copy.value;

                start += 2;

                if (guard)
                    buffer[start++] = A$ldmia_sp$_$rs$((1 << copy.rn));

                *--trailer = reinterpret_cast<uint32_t>(area + offset) + 8;
                end -= 1;
            } else
                buffer[start++] = backup[offset];

        buffer[start + 0] = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
        buffer[start + 1] = reinterpret_cast<uint32_t>(area + used / sizeof(uint32_t));

        if (mprotect(buffer, length, PROT_READ | PROT_EXEC) == -1) {
            //MSLog(MSLogLevelError, "MS:Error:mprotect():%d", errno);
            goto fail;
        }

        *result = buffer;

        if (MSDebug) {
            char name[16];
            sprintf(name, "%p", *result);
            MSLogHexEx(buffer, length, 4, name);
        }

    }

    {
        SubstrateHookMemory code(process, symbol, used);

        arm[0] = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
        arm[1] = reinterpret_cast<uint32_t>(replace);
    }

    if (MSDebug) {
        char name[16];
        sprintf(name, "%p", area);
        MSLogHexEx(area, used + sizeof(uint32_t), 4, name);
    }

    return used;
}

static size_t
SubstrateHookFunction(SubstrateProcessRef process, void *symbol, void *replace, void **result) {
    if (MSDebug)
        //MSLog(MSLogLevelNotice, "SubstrateHookFunction(%p, %p, %p, %p)\n", process, symbol, replace,result);

    if ((reinterpret_cast<uintptr_t>(symbol) & 0x1) == 0)
        return SubstrateHookFunctionARM(process, symbol, replace, result);
    else
        return SubstrateHookFunctionThumb(process, reinterpret_cast<void *>(
                reinterpret_cast<uintptr_t>(symbol) & ~0x1), replace, result);
}

#endif

#if defined(__i386__) || defined(__x86_64__)

#include "SubstrateX86.hpp"

static size_t MSGetInstructionWidthIntel(void *start) {
    hde64s decode;
    return hde64_disasm(start, &decode);
}

static void SubstrateHookFunction(SubstrateProcessRef process, void *symbol, void *replace, void **result) {
    if (MSDebug)
        //MSLog(MSLogLevelNotice, "MSHookFunction(%p, %p, %p)\n", symbol, replace, result);
    if (symbol == NULL)
        return;

    uintptr_t source(reinterpret_cast<uintptr_t>(symbol));
    uintptr_t target(reinterpret_cast<uintptr_t>(replace));

    uint8_t *area(reinterpret_cast<uint8_t *>(symbol));

    size_t required(MSSizeOfJump(target, source));

    if (MSDebug) {
        char name[16];
        sprintf(name, "%p", area);
        MSLogHex(area, 32, name);
    }

    size_t used(0);
    while (used < required) {
        size_t width(MSGetInstructionWidthIntel(area + used));
        if (width == 0) {
            //MSLog(MSLogLevelError, "MS:Error:MSGetInstructionWidthIntel(%p) == 0", area + used);
            return;
        }

        used += width;
    }

    size_t blank(used - required);

    if (MSDebug) {
        char name[16];
        sprintf(name, "%p", area);
        MSLogHex(area, used + sizeof(uint16_t), name);
    }

    uint8_t backup[used];
    memcpy(backup, area, used);

    if (result != NULL) {

    if (backup[0] == 0xe9) {
        *result = reinterpret_cast<void *>(source + 5 + *reinterpret_cast<uint32_t *>(backup + 1));
        return;
    }

    if (!ia32 && backup[0] == 0xff && backup[1] == 0x25) {
        *result = *reinterpret_cast<void **>(source + 6 + *reinterpret_cast<uint32_t *>(backup + 2));
        return;
    }

    size_t length(used + MSSizeOfJump(source + used));

    for (size_t offset(0), width; offset != used; offset += width) {
        hde64s decode;
        hde64_disasm(backup + offset, &decode);
        width = decode.len;
        //_assert(width != 0 && offset + width <= used);

#ifdef __LP64__
        if ((decode.modrm & 0xc7) == 0x05) {
            if (decode.opcode == 0x8b) {
                void *destiny(area + offset + width + int32_t(decode.disp.disp32));
                uint8_t reg(decode.rex_r << 3 | decode.modrm_reg);
                length -= decode.len;
                length += MSSizeOfPushPointer(destiny);
                length += MSSizeOfPop(reg);
                length += MSSizeOfMove64();
            } else {
                //MSLog(MSLogLevelError, "MS:Error: Unknown RIP-Relative (%.2x %.2x)", decode.opcode, decode.opcode2);
                continue;
            }
        } else
#endif

        if (backup[offset] == 0xe8) {
            int32_t relative(*reinterpret_cast<int32_t *>(backup + offset + 1));
            void *destiny(area + offset + decode.len + relative);

            if (relative == 0) {
                length -= decode.len;
                length += MSSizeOfPushPointer(destiny);
            } else {
                length += MSSizeOfSkip();
                length += MSSizeOfJump(destiny);
            }
        } else if (backup[offset] == 0xeb) {
            length -= decode.len;
            length += MSSizeOfJump(area + offset + decode.len + *reinterpret_cast<int8_t *>(backup + offset + 1));
        } else if (backup[offset] == 0xe9) {
            length -= decode.len;
            length += MSSizeOfJump(area + offset + decode.len + *reinterpret_cast<int32_t *>(backup + offset + 1));
        } else if (
            backup[offset] == 0xe3 ||
            (backup[offset] & 0xf0) == 0x70
            // XXX: opcode2 & 0xf0 is 0x80?
        ) {
            length += decode.len;
            length += MSSizeOfJump(area + offset + decode.len + *reinterpret_cast<int8_t *>(backup + offset + 1));
        }
    }

    uint8_t *buffer(reinterpret_cast<uint8_t *>(mmap(
        NULL, length, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0
    )));

    if (buffer == MAP_FAILED) {
        //MSLog(MSLogLevelError, "MS:Error:mmap() = %d", errno);
        *result = NULL;
        return;
    }

    if (false) fail: {
        munmap(buffer, length);
        *result = NULL;
        return;
    }

    {
        uint8_t *current(buffer);

        for (size_t offset(0), width; offset != used; offset += width) {
            hde64s decode;
            hde64_disasm(backup + offset, &decode);
            width = decode.len;
            //_assert(width != 0 && offset + width <= used);

#ifdef __LP64__
            if ((decode.modrm & 0xc7) == 0x05) {
                if (decode.opcode == 0x8b) {
                    void *destiny(area + offset + width + int32_t(decode.disp.disp32));
                    uint8_t reg(decode.rex_r << 3 | decode.modrm_reg);
                    MSPushPointer(current, destiny);
                    MSWritePop(current, reg);
                    MSWriteMove64(current, reg, reg);
                } else {
                    //MSLog(MSLogLevelError, "MS:Error: Unknown RIP-Relative (%.2x %.2x)", decode.opcode, decode.opcode2);
                    goto copy;
                }
            } else
#endif

            if (backup[offset] == 0xe8) {
                int32_t relative(*reinterpret_cast<int32_t *>(backup + offset + 1));
                if (relative == 0)
                    MSPushPointer(current, area + offset + decode.len);
                else {
                    MSWrite<uint8_t>(current, 0xe8);
                    MSWrite<int32_t>(current, MSSizeOfSkip());
                    void *destiny(area + offset + decode.len + relative);
                    MSWriteSkip(current, MSSizeOfJump(destiny, current + MSSizeOfSkip()));
                    MSWriteJump(current, destiny);
                }
            } else if (backup[offset] == 0xeb)
                MSWriteJump(current, area + offset + decode.len + *reinterpret_cast<int8_t *>(backup + offset + 1));
            else if (backup[offset] == 0xe9)
                MSWriteJump(current, area + offset + decode.len + *reinterpret_cast<int32_t *>(backup + offset + 1));
            else if (
                backup[offset] == 0xe3 ||
                (backup[offset] & 0xf0) == 0x70
            ) {
                MSWrite<uint8_t>(current, backup[offset]);
                MSWrite<uint8_t>(current, 2);
                MSWrite<uint8_t>(current, 0xeb);
                void *destiny(area + offset + decode.len + *reinterpret_cast<int8_t *>(backup + offset + 1));
                MSWrite<uint8_t>(current, MSSizeOfJump(destiny, current + 1));
                MSWriteJump(current, destiny);
            } else
#ifdef __LP64__
                copy:
#endif
            {
                MSWrite(current, backup + offset, width);
            }
        }

        MSWriteJump(current, area + used);
    }

    if (mprotect(buffer, length, PROT_READ | PROT_EXEC) == -1) {
        //MSLog(MSLogLevelError, "MS:Error:mprotect():%d", errno);
        goto fail;
    }

    *result = buffer;

    if (MSDebug) {
        char name[16];
        sprintf(name, "%p", *result);
        MSLogHex(buffer, length, name);
    }

    }

    {
        SubstrateHookMemory code(process, area, used);

        uint8_t *current(area);
        MSWriteJump(current, target);
        for (unsigned offset(0); offset != blank; ++offset)
            MSWrite<uint8_t>(current, 0x90);
    }

    if (MSDebug) {
        char name[16];
        sprintf(name, "%p", area);
        MSLogHex(area, used + sizeof(uint16_t), name);
    }
}
#endif

_extern void MSHookFunction(void *symbol, void *replace, void **result) {
#ifdef __aarch64__
    A64HookFunction(symbol, replace, result);
#else
    SubstrateHookFunction(NULL, symbol, replace, result);
#endif
}

#if defined(__APPLE__) && defined(__arm__)
_extern void _Z14MSHookFunctionPvS_PS_(void *symbol, void *replace, void **result) {
    return MSHookFunction(symbol, replace, result);
}
#endif

```

`app/src/main/jni/Substrate/SubstrateHook.h`:

```h
#ifndef __SUBSTRATEHOOK_H__
#define __SUBSTRATEHOOK_H__


#include <stdlib.h>

#define _extern extern "C" __attribute__((__visibility__("hidden")))

#ifdef __cplusplus
extern "C" {
#endif

void MSHookFunction(void *symbol, void *replace, void **result);

#ifdef __cplusplus
}
#endif

#endif

```

`app/src/main/jni/Substrate/SubstrateLog.hpp`:

```hpp
/* Cydia Substrate - Powerful Code Insertion Platform
 * Copyright (C) 2008-2011  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Substrate is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Substrate is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

#ifndef SUBSTRATE_LOG_HPP
#define SUBSTRATE_LOG_HPP

#if 0
#include <android/log.h>

#define MSLog(level, format, ...) //((void)__android_log_print(level, "NNNN", format, __VA_ARGS__))

#define MSLogLevelNotice ANDROID_LOG_INFO
#define MSLogLevelWarning ANDROID_LOG_WARN
#define MSLogLevelError ANDROID_LOG_ERROR

#else

#define MSLog(level, format, ...) //printf(format, __VA_ARGS__)

#endif

#endif//SUBSTRATE_LOG_HPP

```

`app/src/main/jni/Substrate/SubstratePosixMemory.cpp`:

```cpp
/* Cydia Substrate - Powerful Code Insertion Platform
 * Copyright (C) 2008-2011  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Substrate is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Substrate is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

#define SubstrateInternal
#include "CydiaSubstrate.h"
#include "SubstrateLog.hpp"

#include <sys/mman.h>

#include <errno.h>
#include <stdio.h>
#include <unistd.h>

extern "C" void __clear_cache (void *beg, void *end);

struct __SubstrateMemory {
    void *address_;
    size_t width_;

    __SubstrateMemory(void *address, size_t width) :
        address_(address),
        width_(width)
    {
    }
};

extern "C" SubstrateMemoryRef SubstrateMemoryCreate(SubstrateAllocatorRef allocator, SubstrateProcessRef process, void *data, size_t size) {
    if (allocator != NULL) {
        //MSLog(MSLogLevelError, "MS:Error:allocator != %d", 0);
        return NULL;
    }

    if (size == 0)
        return NULL;

    long page(sysconf(_SC_PAGESIZE)); // Portable applications should employ sysconf(_SC_PAGESIZE) instead of getpagesize

    uintptr_t base(reinterpret_cast<uintptr_t>(data) / page * page);
    size_t width(((reinterpret_cast<uintptr_t>(data) + size - 1) / page + 1) * page - base);
    void *address(reinterpret_cast<void *>(base));

    if (mprotect(address, width, PROT_READ | PROT_WRITE | PROT_EXEC) == -1) {
        //MSLog(MSLogLevelError, "MS:Error:mprotect() = %d", errno);
        return NULL;
    }

    return new __SubstrateMemory(address, width);
}

extern "C" void SubstrateMemoryRelease(SubstrateMemoryRef memory) {
    if (mprotect(memory->address_, memory->width_, PROT_READ | PROT_WRITE | PROT_EXEC) == -1)
        //MSLog(MSLogLevelError, "MS:Error:mprotect() = %d", errno);

    __clear_cache(reinterpret_cast<char *>(memory->address_), reinterpret_cast<char *>(memory->address_) + memory->width_);

    delete memory;
}

```

`app/src/main/jni/Substrate/SubstrateX86.hpp`:

```hpp
/* Cydia Substrate - Powerful Code Insertion Platform
 * Copyright (C) 2008-2011  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Substrate is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Substrate is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Substrate.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

#ifndef SUBSTRATE_X86_HPP
#define SUBSTRATE_X86_HPP

#include "Buffer.hpp"

#ifdef __LP64__
static const bool ia32 = false;
#else
static const bool ia32 = true;
#endif

enum I$r {
    I$rax, I$rcx, I$rdx, I$rbx,
    I$rsp, I$rbp, I$rsi, I$rdi,
    I$r8, I$r9, I$r10, I$r11,
    I$r12, I$r13, I$r14, I$r15,
};

_disused static bool MSIs32BitOffset(uintptr_t target, uintptr_t source) {
    intptr_t offset(target - source);
    return int32_t(offset) == offset;
}

_disused static size_t MSSizeOfSkip() {
    return 5;
}

_disused static size_t MSSizeOfPushPointer(uintptr_t target) {
    return uint64_t(target) >> 32 == 0 ? 5 : 13;
}

_disused static size_t MSSizeOfPushPointer(void *target) {
    return MSSizeOfPushPointer(reinterpret_cast<uintptr_t>(target));
}

_disused static size_t MSSizeOfJump(bool blind, uintptr_t target, uintptr_t source = 0) {
    if (ia32 || !blind && MSIs32BitOffset(target, source + 5))
        return MSSizeOfSkip();
    else
        return MSSizeOfPushPointer(target) + 1;
}

_disused static size_t MSSizeOfJump(uintptr_t target, uintptr_t source) {
    return MSSizeOfJump(false, target, source);
}

_disused static size_t MSSizeOfJump(uintptr_t target) {
    return MSSizeOfJump(true, target);
}

_disused static size_t MSSizeOfJump(void *target, void *source) {
    return MSSizeOfJump(reinterpret_cast<uintptr_t>(target), reinterpret_cast<uintptr_t>(source));
}

_disused static size_t MSSizeOfJump(void *target) {
    return MSSizeOfJump(reinterpret_cast<uintptr_t>(target));
}

_disused static void MSWriteSkip(uint8_t *&current, ssize_t size) {
    MSWrite<uint8_t>(current, 0xe9);
    MSWrite<uint32_t>(current, size);
}

_disused static void MSPushPointer(uint8_t *&current, uintptr_t target) {
    MSWrite<uint8_t>(current, 0x68);
    MSWrite<uint32_t>(current, target);

    if (uint32_t high = uint64_t(target) >> 32) {
        MSWrite<uint8_t>(current, 0xc7);
        MSWrite<uint8_t>(current, 0x44);
        MSWrite<uint8_t>(current, 0x24);
        MSWrite<uint8_t>(current, 0x04);
        MSWrite<uint32_t>(current, high);
    }
}

_disused static void MSPushPointer(uint8_t *&current, void *target) {
    return MSPushPointer(current, reinterpret_cast<uintptr_t>(target));
}

_disused static void MSWriteCall(uint8_t *&current, I$r target) {
    if (target >> 3 != 0)
        MSWrite<uint8_t>(current, 0x40 | (target & 0x08) >> 3);
    MSWrite<uint8_t>(current, 0xff);
    MSWrite<uint8_t>(current, 0xd0 | target & 0x07);
}

_disused static void MSWriteCall(uint8_t *&current, uintptr_t target) {
    uintptr_t source(reinterpret_cast<uintptr_t>(current));

    if (ia32 || MSIs32BitOffset(target, source + 5)) {
        MSWrite<uint8_t>(current, 0xe8);
        MSWrite<uint32_t>(current, target - (source + 5));
    } else {
        MSPushPointer(current, target);

        MSWrite<uint8_t>(current, 0x83);
        MSWrite<uint8_t>(current, 0xc4);
        MSWrite<uint8_t>(current, 0x08);

        MSWrite<uint8_t>(current, 0x67);
        MSWrite<uint8_t>(current, 0xff);
        MSWrite<uint8_t>(current, 0x54);
        MSWrite<uint8_t>(current, 0x24);
        MSWrite<uint8_t>(current, 0xf8);
    }
}

template <typename Type_>
_disused static void MSWriteCall(uint8_t *&current, Type_ *target) {
    return MSWriteCall(current, reinterpret_cast<uintptr_t>(target));
}

_disused static void MSWriteJump(uint8_t *&current, uintptr_t target) {
    uintptr_t source(reinterpret_cast<uintptr_t>(current));

    if (ia32 || MSIs32BitOffset(target, source + 5))
        MSWriteSkip(current, target - (source + 5));
    else {
        MSPushPointer(current, target);
        MSWrite<uint8_t>(current, 0xc3);
    }
}

_disused static void MSWriteJump(uint8_t *&current, void *target) {
    return MSWriteJump(current, reinterpret_cast<uintptr_t>(target));
}

_disused static void MSWriteJump(uint8_t *&current, I$r target) {
    if (target >> 3 != 0)
        MSWrite<uint8_t>(current, 0x40 | (target & 0x08) >> 3);
    MSWrite<uint8_t>(current, 0xff);
    MSWrite<uint8_t>(current, 0xe0 | target & 0x07);
}

_disused static void MSWritePop(uint8_t *&current, uint8_t target) {
    if (target >> 3 != 0)
        MSWrite<uint8_t>(current, 0x40 | (target & 0x08) >> 3);
    MSWrite<uint8_t>(current, 0x58 | target & 0x07);
}

_disused static size_t MSSizeOfPop(uint8_t target) {
    return target >> 3 != 0 ? 2 : 1;
}

_disused static void MSWritePush(uint8_t *&current, I$r target) {
    if (target >> 3 != 0)
        MSWrite<uint8_t>(current, 0x40 | (target & 0x08) >> 3);
    MSWrite<uint8_t>(current, 0x50 | target & 0x07);
}

_disused static void MSWriteAdd(uint8_t *&current, I$r target, uint8_t source) {
    MSWrite<uint8_t>(current, 0x83);
    MSWrite<uint8_t>(current, 0xc4 | target & 0x07);
    MSWrite<uint8_t>(current, source);
}

_disused static void MSWriteSet64(uint8_t *&current, I$r target, uintptr_t source) {
    MSWrite<uint8_t>(current, 0x48 | (target & 0x08) >> 3 << 2);
    MSWrite<uint8_t>(current, 0xb8 | target & 0x7);
    MSWrite<uint64_t>(current, source);
}

template <typename Type_>
_disused static void MSWriteSet64(uint8_t *&current, I$r target, Type_ *source) {
    return MSWriteSet64(current, target, reinterpret_cast<uintptr_t>(source));
}

_disused static void MSWriteMove64(uint8_t *&current, uint8_t source, uint8_t target) {
    MSWrite<uint8_t>(current, 0x48 | (target & 0x08) >> 3 << 2 | (source & 0x08) >> 3);
    MSWrite<uint8_t>(current, 0x8b);
    MSWrite<uint8_t>(current, (target & 0x07) << 3 | source & 0x07);
}

_disused static size_t MSSizeOfMove64() {
    return 3;
}

#endif//SUBSTRATE_X86_HPP

```

`app/src/main/jni/Substrate/hde64.c`:

```c
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#include <stdint.h>
#include <string.h>

#include "hde64.h"
#include "table64.h"

unsigned int hde64_disasm(const void *code, hde64s *hs)
{
    uint8_t x, c, *p = (uint8_t *)code, cflags, opcode, pref = 0;
    uint8_t *ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
    uint8_t op64 = 0;

    memset(hs,0,sizeof(hde64s));
    char *tmp=(char*)hs;

    for (x = 16; x; x--)
        switch (c = *p++) {
            case 0xf3:
                hs->p_rep = c;
                pref |= PRE_F3;
                break;
            case 0xf2:
                hs->p_rep = c;
                pref |= PRE_F2;
                break;
            case 0xf0:
                hs->p_lock = c;
                pref |= PRE_LOCK;
                break;
            case 0x26: case 0x2e: case 0x36:
            case 0x3e: case 0x64: case 0x65:
                hs->p_seg = c;
                pref |= PRE_SEG;
                break;
            case 0x66:
                hs->p_66 = c;
                pref |= PRE_66;
                break;
            case 0x67:
                hs->p_67 = c;
                pref |= PRE_67;
                break;
            default:
                goto pref_done;
        }
  pref_done:

    hs->flags = (uint32_t)pref << 23;

    if (!pref)
        pref |= PRE_NONE;

    if ((c & 0xf0) == 0x40) {
        hs->flags |= F_PREFIX_REX;
        if ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)
            op64++;
        hs->rex_r = (c & 7) >> 2;
        hs->rex_x = (c & 3) >> 1;
        hs->rex_b = c & 1;
        if (((c = *p++) & 0xf0) == 0x40) {
            opcode = c;
            goto error_opcode;
        }
    }

    if ((hs->opcode = c) == 0x0f) {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    } else if (c >= 0xa0 && c <= 0xa3) {
        op64++;
        if (pref & PRE_67)
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
      error_opcode:
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)
            cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16_t t;
        t = *(uint16_t *)(ht + (cflags & 0x7f));
        cflags = (uint8_t)t;
        x = (uint8_t)(t >> 8);
    }

    if (hs->opcode2) {
        ht = hde64_table + DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8_t t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = hde64_table + DELTA_FPU_MODRM + t*8;
                t = ht[m_reg] << m_rm;
            } else {
                ht = hde64_table + DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            } else {
                uint8_t *table_end, op = opcode;
                if (hs->opcode2) {
                    ht = hde64_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
                } else {
                    ht = hde64_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
              no_lock_error:
                ;
            }
        }

        if (hs->opcode2) {
            switch (opcode) {
                case 0x20: case 0x22:
                    m_mod = 3;
                    if (m_reg > 4 || m_reg == 1)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x21: case 0x23:
                    m_mod = 3;
                    if (m_reg == 4 || m_reg == 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        } else {
            switch (opcode) {
                case 0x8c:
                    if (m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x8e:
                    if (m_reg == 1 || m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        }

        if (m_mod == 3) {
            uint8_t *table_end;
            if (hs->opcode2) {
                ht = hde64_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;
            } else {
                ht = hde64_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
            }
            for (; ht != table_end; ht += 2)
                if (*ht++ == opcode) {
                    if (*ht++ & pref && !((*ht << m_reg) & 0x80))
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        } else if (hs->opcode2) {
            switch (opcode) {
                case 0x50: case 0xd7: case 0xf7:
                    if (pref & (PRE_NONE | PRE_66))
                        goto error_operand;
                    break;
                case 0xd6:
                    if (pref & (PRE_F2 | PRE_F3))
                        goto error_operand;
                    break;
                case 0xc5:
                    goto error_operand;
            }
            goto no_error_operand;
        } else
            goto no_error_operand;

      error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
      no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)
                cflags |= C_IMM8;
            else if (opcode == 0xf7)
                cflags |= C_IMM_P66;
        }

        switch (m_mod) {
            case 0:
                if (pref & PRE_67) {
                    if (m_rm == 6)
                        disp_size = 2;
                } else
                    if (m_rm == 5)
                        disp_size = 4;
                break;
            case 1:
                disp_size = 1;
                break;
            case 2:
                disp_size = 2;
                if (!(pref & PRE_67))
                    disp_size <<= 1;
        }

        if (m_mod != 3 && m_rm == 4) {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = (c & 0x3f) >> 3;
            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
                disp_size = 4;
        }

        p--;
        switch (disp_size) {
            case 1:
                hs->flags |= F_DISP8;
                hs->disp.disp8 = *p;
                break;
            case 2:
                hs->flags |= F_DISP16;
                hs->disp.disp16 = *(uint16_t *)p;
                break;
            case 4:
                hs->flags |= F_DISP32;
                hs->disp.disp32 = *(uint32_t *)p;
        }
        p += disp_size;
    } else if (pref & PRE_LOCK)
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *(uint16_t *)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if (op64) {
            hs->flags |= F_IMM64;
            hs->imm.imm64 = *(uint64_t *)p;
            p += 8;
        } else if (!(pref & PRE_66)) {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *(uint32_t *)p;
            p += 4;
        } else
            goto imm16_ok;
    }


    if (cflags & C_IMM16) {
      imm16_ok:
        hs->flags |= F_IMM16;
        hs->imm.imm16 = *(uint16_t *)p;
        p += 2;
    }
    if (cflags & C_IMM8) {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
      rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *(uint32_t *)p;
        p += 4;
    } else if (cflags & C_REL8) {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

  disasm_done:

    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return (unsigned int)hs->len;
}

```

`app/src/main/jni/Substrate/hde64.h`:

```h
/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.h: C/C++ header file
 *
 */

#ifndef _HDE64_H_
#define _HDE64_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include <stdint.h>

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t rex;
    uint8_t rex_w;
    uint8_t rex_r;
    uint8_t rex_x;
    uint8_t rex_b; 
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
        uint64_t imm64;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde64s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde64_disasm(const void *code, hde64s *hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE64_H_ */

```

`app/src/main/jni/Substrate/table64.h`:

```h
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xfd
#define DELTA_FPU_MODRM    0x104
#define DELTA_PREFIXES     0x13c
#define DELTA_OP_LOCK_OK   0x1ae
#define DELTA_OP2_LOCK_OK  0x1c6
#define DELTA_OP_ONLY_MEM  0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

unsigned char hde64_table[] = {
  0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
  0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
  0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
  0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
  0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
  0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
  0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
  0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
  0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
  0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
  0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
  0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
  0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
  0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
  0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
  0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
  0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
  0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
  0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
  0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
  0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
  0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
  0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
  0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
  0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
  0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
  0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
  0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
  0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
  0x00,0xf0,0x02,0x00
};

```

`app/src/main/jni/Tools.cpp`:

```cpp
#include "Tools.h"

#if defined(__arm__)
#define process_vm_readv_syscall 376
#define process_vm_writev_syscall 377
#elif defined(__aarch64__)
#define process_vm_readv_syscall 270
#define process_vm_writev_syscall 271
#elif defined(__i386__)
#define process_vm_readv_syscall 347
#define process_vm_writev_syscall 348
#else
#define process_vm_readv_syscall 310
#define process_vm_writev_syscall 311
#endif

pid_t target_pid = -1;

ssize_t process_v(pid_t __pid, const struct iovec *__local_iov, unsigned long __local_iov_count, const struct iovec *__remote_iov, unsigned long __remote_iov_count, unsigned long __flags, bool iswrite) {
    return syscall((iswrite ? process_vm_writev_syscall : process_vm_readv_syscall), __pid, __local_iov, __local_iov_count, __remote_iov, __remote_iov_count, __flags);
}

bool pvm(void *address, void *buffer, size_t size, bool write = false) {
    struct iovec local[1];
    struct iovec remote[1];

    local[0].iov_base = buffer;
    local[0].iov_len = size;
    remote[0].iov_base = address;
    remote[0].iov_len = size;

    if (target_pid == -1) {
        target_pid = getpid();
    }

    ssize_t bytes = process_v(target_pid, local, 1, remote, 1, 0, write);
    return bytes == size;
}

void Tools::Hook(void *target, void *replace, void **backup) {
    unsigned long page_size = sysconf(_SC_PAGESIZE);
    unsigned long size = page_size * sizeof(uintptr_t);
    void *p = (void *) ((uintptr_t) target - ((uintptr_t) target % page_size) - page_size);
    if (mprotect(p, (size_t) size, PROT_EXEC | PROT_READ | PROT_WRITE) == 0) {
        MSHookFunction(target, replace, backup);
    }
}

bool Tools::Read(void *addr, void *buffer, size_t length) {
    return memcpy(buffer, addr, length) != 0;
}

bool Tools::Write(void *addr, void *buffer, size_t length) {
    return memcpy(addr, buffer, length) != 0;
}

bool Tools::ReadAddr(void *addr, void *buffer, size_t length) {
    unsigned long page_size = sysconf(_SC_PAGESIZE);
    unsigned long size = page_size * sizeof(uintptr_t);
    return mprotect((void *) ((uintptr_t) addr - ((uintptr_t) addr % page_size) - page_size), (size_t) size, PROT_EXEC | PROT_READ | PROT_WRITE) == 0 && memcpy(buffer, addr, length) != 0;
}

bool Tools::WriteAddr(void *addr, void *buffer, size_t length) {
    unsigned long page_size = sysconf(_SC_PAGESIZE);
    unsigned long size = page_size * sizeof(uintptr_t);
    return mprotect((void *) ((uintptr_t) addr - ((uintptr_t) addr % page_size) - page_size), (size_t) size, PROT_EXEC | PROT_READ | PROT_WRITE) == 0 && memcpy(addr, buffer, length) != 0;
}

bool Tools::PVM_ReadAddr(void *addr, void *buffer, size_t length) {
    return pvm(addr, buffer, length, false);
}

bool Tools::PVM_WriteAddr(void *addr, void *buffer, size_t length) {
    return pvm(addr, buffer, length, true);
}

bool Tools::IsPtrValid(void *addr) {
    static int fd = -1;
    if (fd == -1) {
        fd = open("/dev/random", O_WRONLY);
    }
    return write(fd, addr, 4) >= 0;
}

uintptr_t Tools::GetBaseAddress(const char *name) {
    uintptr_t base = 0;
    char line[512];

    FILE *f = fopen("/proc/self/maps", "r");

    if (!f) {
        return 0;
    }

    while (fgets(line, sizeof line, f)) {
        uintptr_t tmpBase;
        char tmpName[256];
        if (sscanf(line, "%" PRIXPTR "-%*" PRIXPTR " %*s %*s %*s %*s %s", &tmpBase, tmpName) > 0) {
            if (!strcmp(basename(tmpName), name)) {
                base = tmpBase;
                break;
            }
        }
    }

    fclose(f);
    return base;
}

uintptr_t Tools::GetEndAddress(const char *name) {
    uintptr_t end = 0;
    char line[512];

    FILE *f = fopen("/proc/self/maps", "r");

    if (!f) {
        return 0;
    }

    bool found = false;
    while (fgets(line, sizeof line, f)) {
        uintptr_t tmpEnd;
        char tmpName[256];
        if (sscanf(line, "%*" PRIXPTR "-%" PRIXPTR " %*s %*s %*s %*s %s", &tmpEnd, tmpName) > 0) {
            if (!strcmp(basename(tmpName), name)) {
                if (!found) {
                    found = true;
                }
            } else {
                if (found) {
                    end = tmpEnd;
                    break;
                }
            }
        }
    }

    fclose(f);
    return end;
}

#define INRANGE(x, a, b)        (x >= a && x <= b)
#define getBits(x)              (INRANGE(x,'0','9') ? (x - '0') : ((x&(~0x20)) - 'A' + 0xa))
#define getByte(x)              (getBits(x[0]) << 4 | getBits(x[1]))

uintptr_t Tools::FindPattern(const char *lib, const char *pattern) {
    auto start = GetBaseAddress(lib);
    if (!start)
        return 0;

    auto end = GetEndAddress(lib);
    if (!end)
        return 0;

    auto curPat = reinterpret_cast<const unsigned char *>(pattern);
    uintptr_t firstMatch = 0;
    for (uintptr_t pCur = start; pCur < end; ++pCur) {
        if (*(uint8_t *) curPat == (uint8_t) '\?' || *(uint8_t *) pCur == getByte(curPat)) {
            if (!firstMatch) {
                firstMatch = pCur;
            }
            curPat += (*(uint16_t *) curPat == (uint16_t) '\?\?' || *(uint8_t *) curPat != (uint8_t) '\?') ? 2 : 1;
            if (!*curPat) {
                return firstMatch;
            }
            curPat++;
            if (!*curPat) {
                return firstMatch;
            }
        } else if (firstMatch) {
            pCur = firstMatch;
            curPat = reinterpret_cast<const unsigned char *>(pattern);
            firstMatch = 0;
        }
    }
    return 0;
}

std::string Tools::RandomString(const int len) {
    static const char alphanumerics[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    srand((unsigned) time(0) * getpid());

    std::string tmp;
    tmp.reserve(len);
    for (int i = 0; i < len; ++i) {
        tmp += alphanumerics[rand() % (sizeof(alphanumerics) - 1)];
    }
    return tmp;
}

std::string Tools::GetPackageName(JNIEnv *env, jobject context) {
    jclass contextClass = env->FindClass("android/content/Context");
    jmethodID getPackageNameId = env->GetMethodID(contextClass, "getPackageName", "()Ljava/lang/String;");

    auto str = (jstring) env->CallObjectMethod(context, getPackageNameId);
    return env->GetStringUTFChars(str, 0);
}
```

`app/src/main/jni/Tools.h`:

```h
#include "Includes.h"
#include "Substrate/CydiaSubstrate.h"

namespace Tools
{
    void Hook(void *target, void *replace, void **backup);
    bool Read(void *addr, void *buffer, size_t length);
    bool Write(void *addr, void *buffer, size_t length);
    bool ReadAddr(void *addr, void *buffer, size_t length);
    bool WriteAddr(void *addr, void *buffer, size_t length);

    bool PVM_ReadAddr(void *addr, void *buffer, size_t length);
    bool PVM_WriteAddr(void *addr, void *buffer, size_t length);

    bool IsPtrValid(void *addr);

    uintptr_t GetBaseAddress(const char *name);
    uintptr_t GetEndAddress(const char *name);
    uintptr_t FindPattern(const char *lib, const char* pattern);

    std::string RandomString(const int len);
    std::string GetPackageName(JNIEnv *env, jobject context);
}
```

`app/src/main/jni/Vector2.hpp`:

```hpp
#pragma once

#define _USE_MATH_DEFINES
#include <math.h>


struct Vector2
{
    union
    {
        struct
        {
            float X;
            float Y;
        };
        float data[2];
    };


    /**
     * Constructors.
     */
    inline Vector2();
    inline Vector2(float data[]);
    inline Vector2(float value);
    inline Vector2(float x, float y);


    /**
     * Constants for common vectors.
     */
    static inline Vector2 Zero();
    static inline Vector2 One();
    static inline Vector2 Right();
    static inline Vector2 Left();
    static inline Vector2 Up();
    static inline Vector2 Down();


    /**
     * Returns the angle between two vectors in radians.
     * @param a: The first vector.
     * @param b: The second vector.
     * @return: A scalar value.
     */
    static inline float Angle(Vector2 a, Vector2 b);

    /**
     * Returns a vector with its magnitude clamped to maxLength.
     * @param vector: The target vector.
     * @param maxLength: The maximum length of the return vector.
     * @return: A new vector.
     */
    static inline Vector2 ClampMagnitude(Vector2 vector, float maxLength);

    /**
     * Returns the component of a in the direction of b (scalar projection).
     * @param a: The target vector.
     * @param b: The vector being compared against.
     * @return: A scalar value.
     */
    static inline float Component(Vector2 a, Vector2 b);

    /**
     * Returns the distance between a and b.
     * @param a: The first point.
     * @param b: The second point.
     * @return: A scalar value.
     */
    static inline float Distance(Vector2 a, Vector2 b);

    /**
     * Returns the dot product of two vectors.
     * @param lhs: The left side of the multiplication.
     * @param rhs: The right side of the multiplication.
     * @return: A scalar value.
     */
    static inline float Dot(Vector2 lhs, Vector2 rhs);

    /**
     * Converts a polar representation of a vector into cartesian
     * coordinates.
     * @param rad: The magnitude of the vector.
     * @param theta: The angle from the X axis.
     * @return: A new vector.
     */
    static inline Vector2 FromPolar(float rad, float theta);

    /**
     * Returns a vector linearly interpolated between a and b, moving along
     * a straight line. The vector is clamped to never go beyond the end points.
     * @param a: The starting point.
     * @param b: The ending point.
     * @param t: The interpolation value [0-1].
     * @return: A new vector.
     */
    static inline Vector2 Lerp(Vector2 a, Vector2 b, float t);

    /**
     * Returns a vector linearly interpolated between a and b, moving along
     * a straight line.
     * @param a: The starting point.
     * @param b: The ending point.
     * @param t: The interpolation value [0-1] (no actual bounds).
     * @return: A new vector.
     */
    static inline Vector2 LerpUnclamped(Vector2 a, Vector2 b, float t);

    /**
     * Returns the magnitude of a vector.
     * @param v: The vector in question.
     * @return: A scalar value.
     */
    static inline float Magnitude(Vector2 v);

    /**
     * Returns a vector made from the largest components of two other vectors.
     * @param a: The first vector.
     * @param b: The second vector.
     * @return: A new vector.
     */
    static inline Vector2 Max(Vector2 a, Vector2 b);

    /**
     * Returns a vector made from the smallest components of two other vectors.
     * @param a: The first vector.
     * @param b: The second vector.
     * @return: A new vector.
     */
    static inline Vector2 Min(Vector2 a, Vector2 b);

    /**
     * Returns a vector "maxDistanceDelta" units closer to the target. This
     * interpolation is in a straight line, and will not overshoot.
     * @param current: The current position.
     * @param target: The destination position.
     * @param maxDistanceDelta: The maximum distance to move.
     * @return: A new vector.
     */
    static inline Vector2 MoveTowards(Vector2 current, Vector2 target,
                               float maxDistanceDelta);

    /**
     * Returns a new vector with magnitude of one.
     * @param v: The vector in question.
     * @return: A new vector.
     */
    static inline Vector2 Normalized(Vector2 v);

    /**
     * Creates a new coordinate system out of the two vectors.
     * Normalizes "normal" and normalizes "tangent" and makes it orthogonal to
     * "normal"..
     * @param normal: A reference to the first axis vector.
     * @param tangent: A reference to the second axis vector.
     */
    static inline void OrthoNormalize(Vector2 &normal, Vector2 &tangent);

    /**
     * Returns the vector projection of a onto b.
     * @param a: The target vector.
     * @param b: The vector being projected onto.
     * @return: A new vector.
     */
    static inline Vector2 Project(Vector2 a, Vector2 b);

    /**
     * Returns a vector reflected about the provided line.
     * This behaves as if there is a plane with the line as its normal, and the
     * vector comes in and bounces off this plane.
     * @param vector: The vector traveling inward at the imaginary plane.
     * @param line: The line about which to reflect.
     * @return: A new vector pointing outward from the imaginary plane.
     */
    static inline Vector2 Reflect(Vector2 vector, Vector2 line);

    /**
     * Returns the vector rejection of a on b.
     * @param a: The target vector.
     * @param b: The vector being projected onto.
     * @return: A new vector.
     */
    static inline Vector2 Reject(Vector2 a, Vector2 b);

    /**
     * Rotates vector "current" towards vector "target" by "maxRadiansDelta".
     * This treats the vectors as directions and will linearly interpolate
     * between their magnitudes by "maxMagnitudeDelta". This function does not
     * overshoot. If a negative delta is supplied, it will rotate away from
     * "target" until it is pointing the opposite direction, but will not
     * overshoot that either.
     * @param current: The starting direction.
     * @param target: The destination direction.
     * @param maxRadiansDelta: The maximum number of radians to rotate.
     * @param maxMagnitudeDelta: The maximum delta for magnitude interpolation.
     * @return: A new vector.
     */
    static inline Vector2 RotateTowards(Vector2 current, Vector2 target,
                                 float maxRadiansDelta,
                                 float maxMagnitudeDelta);

    /**
     * Multiplies two vectors component-wise.
     * @param a: The lhs of the multiplication.
     * @param b: The rhs of the multiplication.
     * @return: A new vector.
     */
    static inline Vector2 Scale(Vector2 a, Vector2 b);

    /**
     * Returns a vector rotated towards b from a by the percent t.
     * Since interpolation is done spherically, the vector moves at a constant
     * angular velocity. This rotation is clamped to 0 <= t <= 1.
     * @param a: The starting direction.
     * @param b: The ending direction.
     * @param t: The interpolation value [0-1].
     */
    static inline Vector2 Slerp(Vector2 a, Vector2 b, float t);

    /**
     * Returns a vector rotated towards b from a by the percent t.
     * Since interpolation is done spherically, the vector moves at a constant
     * angular velocity. This rotation is unclamped.
     * @param a: The starting direction.
     * @param b: The ending direction.
     * @param t: The interpolation value [0-1].
     */
    static inline Vector2 SlerpUnclamped(Vector2 a, Vector2 b, float t);

    /**
     * Returns the squared magnitude of a vector.
     * This is useful when comparing relative lengths, where the exact length
     * is not important, and much time can be saved by not calculating the
     * square root.
     * @param v: The vector in question.
     * @return: A scalar value.
     */
    static inline float SqrMagnitude(Vector2 v);

    /**
     * Calculates the polar coordinate space representation of a vector.
     * @param vector: The vector to convert.
     * @param rad: The magnitude of the vector.
     * @param theta: The angle from the X axis.
     */
    static inline void ToPolar(Vector2 vector, float &rad, float &theta);


    /**
     * Operator overloading.
     */
    inline struct Vector2& operator+=(const float rhs);
    inline struct Vector2& operator-=(const float rhs);
    inline struct Vector2& operator*=(const float rhs);
    inline struct Vector2& operator/=(const float rhs);
    inline struct Vector2& operator+=(const Vector2 rhs);
    inline struct Vector2& operator-=(const Vector2 rhs);
};

inline Vector2 operator-(Vector2 rhs);
inline Vector2 operator+(Vector2 lhs, const float rhs);
inline Vector2 operator-(Vector2 lhs, const float rhs);
inline Vector2 operator*(Vector2 lhs, const float rhs);
inline Vector2 operator/(Vector2 lhs, const float rhs);
inline Vector2 operator+(const float lhs, Vector2 rhs);
inline Vector2 operator-(const float lhs, Vector2 rhs);
inline Vector2 operator*(const float lhs, Vector2 rhs);
inline Vector2 operator/(const float lhs, Vector2 rhs);
inline Vector2 operator+(Vector2 lhs, const Vector2 rhs);
inline Vector2 operator-(Vector2 lhs, const Vector2 rhs);
inline bool operator==(const Vector2 lhs, const Vector2 rhs);
inline bool operator!=(const Vector2 lhs, const Vector2 rhs);



/*******************************************************************************
 * Implementation
 */

Vector2::Vector2() : X(0), Y(0) {}
Vector2::Vector2(float data[]) : X(data[0]), Y(data[1]) {}
Vector2::Vector2(float value) : X(value), Y(value) {}
Vector2::Vector2(float x, float y) : X(x), Y(y) {}


Vector2 Vector2::Zero() { return Vector2(0, 0); }
Vector2 Vector2::One() { return Vector2(1, 1); }
Vector2 Vector2::Right() { return Vector2(1, 0); }
Vector2 Vector2::Left() { return Vector2(-1, 0); }
Vector2 Vector2::Up() { return Vector2(0, 1); }
Vector2 Vector2::Down() { return Vector2(0, -1); }


float Vector2::Angle(Vector2 a, Vector2 b)
{
    float v = Dot(a, b) / (Magnitude(a) * Magnitude(b));
    v = fmax(v, -1.0);
    v = fmin(v, 1.0);
    return acos(v);
}

Vector2 Vector2::ClampMagnitude(Vector2 vector, float maxLength)
{
    float length = Magnitude(vector);
    if (length > maxLength)
        vector *= maxLength / length;
    return vector;
}

float Vector2::Component(Vector2 a, Vector2 b)
{
    return Dot(a, b) / Magnitude(b);
}

float Vector2::Distance(Vector2 a, Vector2 b)
{
    return Vector2::Magnitude(a - b);
}

float Vector2::Dot(Vector2 lhs, Vector2 rhs)
{
    return lhs.X * rhs.X + lhs.Y * rhs.Y;
}

Vector2 Vector2::FromPolar(float rad, float theta)
{
    Vector2 v;
    v.X = rad * cos(theta);
    v.Y = rad * sin(theta);
    return v;
}

Vector2 Vector2::Lerp(Vector2 a, Vector2 b, float t)
{
    if (t < 0) return a;
    else if (t > 1) return b;
    return LerpUnclamped(a, b, t);
}

Vector2 Vector2::LerpUnclamped(Vector2 a, Vector2 b, float t)
{
    return (b - a) * t + a;
}

float Vector2::Magnitude(Vector2 v)
{
    return sqrt(SqrMagnitude(v));
}

Vector2 Vector2::Max(Vector2 a, Vector2 b)
{
    float x = a.X > b.X ? a.X : b.X;
    float y = a.Y > b.Y ? a.Y : b.Y;
    return Vector2(x, y);
}

Vector2 Vector2::Min(Vector2 a, Vector2 b)
{
    float x = a.X > b.X ? b.X : a.X;
    float y = a.Y > b.Y ? b.Y : a.Y;
    return Vector2(x, y);
}

Vector2 Vector2::MoveTowards(Vector2 current, Vector2 target,
                             float maxDistanceDelta)
{
    Vector2 d = target - current;
    float m = Magnitude(d);
    if (m < maxDistanceDelta || m == 0)
        return target;
    return current + (d * maxDistanceDelta / m);
}

Vector2 Vector2::Normalized(Vector2 v)
{
    float mag = Magnitude(v);
    if (mag == 0)
        return Vector2::Zero();
    return v / mag;
}

void Vector2::OrthoNormalize(Vector2 &normal, Vector2 &tangent)
{
    normal = Normalized(normal);
    tangent = Reject(tangent, normal);
    tangent = Normalized(tangent);
}

Vector2 Vector2::Project(Vector2 a, Vector2 b)
{
    float m = Magnitude(b);
    return Dot(a, b) / (m * m) * b;
}

Vector2 Vector2::Reflect(Vector2 vector, Vector2 planeNormal)
{
    return vector - 2 * Project(vector, planeNormal);
}

Vector2 Vector2::Reject(Vector2 a, Vector2 b)
{
    return a - Project(a, b);
}

Vector2 Vector2::RotateTowards(Vector2 current, Vector2 target,
                               float maxRadiansDelta,
                               float maxMagnitudeDelta)
{
    float magCur = Magnitude(current);
    float magTar = Magnitude(target);
    float newMag = magCur + maxMagnitudeDelta *
        ((magTar > magCur) - (magCur > magTar));
    newMag = fmin(newMag, fmax(magCur, magTar));
    newMag = fmax(newMag, fmin(magCur, magTar));

    float totalAngle = Angle(current, target) - maxRadiansDelta;
    if (totalAngle <= 0)
        return Normalized(target) * newMag;
    else if (totalAngle >= M_PI)
        return Normalized(-target) * newMag;

    float axis = current.X * target.Y - current.Y * target.X;
    axis = axis / fabs(axis);
    if (!(1 - fabs(axis) < 0.00001))
        axis = 1;
    current = Normalized(current);
    Vector2 newVector = current * cos(maxRadiansDelta) +
        Vector2(-current.Y, current.X) * sin(maxRadiansDelta) * axis;
    return newVector * newMag;
}

Vector2 Vector2::Scale(Vector2 a, Vector2 b)
{
    return Vector2(a.X * b.X, a.Y * b.Y);
}

Vector2 Vector2::Slerp(Vector2 a, Vector2 b, float t)
{
    if (t < 0) return a;
    else if (t > 1) return b;
    return SlerpUnclamped(a, b, t);
}

Vector2 Vector2::SlerpUnclamped(Vector2 a, Vector2 b, float t)
{
    float magA = Magnitude(a);
    float magB = Magnitude(b);
    a /= magA;
    b /= magB;
    float dot = Dot(a, b);
    dot = fmax(dot, -1.0);
    dot = fmin(dot, 1.0);
    float theta = acos(dot) * t;
    Vector2 relativeVec = Normalized(b - a * dot);
    Vector2 newVec = a * cos(theta) + relativeVec * sin(theta);
    return newVec * (magA + (magB - magA) * t);
}

float Vector2::SqrMagnitude(Vector2 v)
{
    return v.X * v.X + v.Y * v.Y;
}

void Vector2::ToPolar(Vector2 vector, float &rad, float &theta)
{
    rad = Magnitude(vector);
    theta = atan2(vector.Y, vector.X);
}


struct Vector2& Vector2::operator+=(const float rhs)
{
    X += rhs;
    Y += rhs;
    return *this;
}

struct Vector2& Vector2::operator-=(const float rhs)
{
    X -= rhs;
    Y -= rhs;
    return *this;
}

struct Vector2& Vector2::operator*=(const float rhs)
{
    X *= rhs;
    Y *= rhs;
    return *this;
}

struct Vector2& Vector2::operator/=(const float rhs)
{
    X /= rhs;
    Y /= rhs;
    return *this;
}

struct Vector2& Vector2::operator+=(const Vector2 rhs)
{
    X += rhs.X;
    Y += rhs.Y;
    return *this;
}

struct Vector2& Vector2::operator-=(const Vector2 rhs)
{
    X -= rhs.X;
    Y -= rhs.Y;
    return *this;
}

Vector2 operator-(Vector2 rhs) { return rhs * -1; }
Vector2 operator+(Vector2 lhs, const float rhs) { return lhs += rhs; }
Vector2 operator-(Vector2 lhs, const float rhs) { return lhs -= rhs; }
Vector2 operator*(Vector2 lhs, const float rhs) { return lhs *= rhs; }
Vector2 operator/(Vector2 lhs, const float rhs) { return lhs /= rhs; }
Vector2 operator+(const float lhs, Vector2 rhs) { return rhs += lhs; }
Vector2 operator-(const float lhs, Vector2 rhs) { return rhs -= lhs; }
Vector2 operator*(const float lhs, Vector2 rhs) { return rhs *= lhs; }
Vector2 operator/(const float lhs, Vector2 rhs) { return rhs /= lhs; }
Vector2 operator+(Vector2 lhs, const Vector2 rhs) { return lhs += rhs; }
Vector2 operator-(Vector2 lhs, const Vector2 rhs) { return lhs -= rhs; }

bool operator==(const Vector2 lhs, const Vector2 rhs)
{
    return lhs.X == rhs.X && lhs.Y == rhs.Y;
}

bool operator!=(const Vector2 lhs, const Vector2 rhs)
{
    return !(lhs == rhs);
}
```

`app/src/main/jni/Vector3.hpp`:

```hpp
#pragma once

#define _USE_MATH_DEFINES
#include <math.h>


struct Vector3
{
    union
    {
        struct
        {
            float X;
            float Y;
            float Z;
        };
        float data[3];
    };


    /**
     * Constructors.
     */
    inline Vector3();
    inline Vector3(float data[]);
    inline Vector3(float value);
    inline Vector3(float x, float y);
    inline Vector3(float x, float y, float z);


    /**
     * Constants for common vectors.
     */
    static inline Vector3 Zero();
    static inline Vector3 One();
    static inline Vector3 Right();
    static inline Vector3 Left();
    static inline Vector3 Up();
    static inline Vector3 Down();
    static inline Vector3 Forward();
    static inline Vector3 Backward();


    /**
     * Returns the angle between two vectors in radians.
     * @param a: The first vector.
     * @param b: The second vector.
     * @return: A scalar value.
     */
    static inline float Angle(Vector3 a, Vector3 b);

    /**
     * Returns a vector with its magnitude clamped to maxLength.
     * @param vector: The target vector.
     * @param maxLength: The maximum length of the return vector.
     * @return: A new vector.
     */
    static inline Vector3 ClampMagnitude(Vector3 vector, float maxLength);

    /**
     * Returns the component of a in the direction of b (scalar projection).
     * @param a: The target vector.
     * @param b: The vector being compared against.
     * @return: A scalar value.
     */
    static inline float Component(Vector3 a, Vector3 b);

    /**
     * Returns the cross product of two vectors.
     * @param lhs: The left side of the multiplication.
     * @param rhs: The right side of the multiplication.
     * @return: A new vector.
     */
    static inline Vector3 Cross(Vector3 lhs, Vector3 rhs);

    /**
     * Returns the distance between a and b.
     * @param a: The first point.
     * @param b: The second point.
     * @return: A scalar value.
     */
    static inline float Distance(Vector3 a, Vector3 b);

    static inline char ToChar(Vector3 a);

    /**
     * Returns the dot product of two vectors.
     * @param lhs: The left side of the multiplication.
     * @param rhs: The right side of the multiplication.
     * @return: A scalar value.
     */
    static inline float Dot(Vector3 lhs, Vector3 rhs);

    /**
     * Converts a spherical representation of a vector into cartesian
     * coordinates.
     * This uses the ISO convention (radius r, inclination theta, azimuth phi).
     * @param rad: The magnitude of the vector.
     * @param theta: The angle in the XY plane from the X axis.
     * @param phi: The angle from the positive Z axis to the vector.
     * @return: A new vector.
     */
    static inline Vector3 FromSpherical(float rad, float theta, float phi);

    /**
     * Returns a vector linearly interpolated between a and b, moving along
     * a straight line. The vector is clamped to never go beyond the end points.
     * @param a: The starting point.
     * @param b: The ending point.
     * @param t: The interpolation value [0-1].
     * @return: A new vector.
     */
    static inline Vector3 Lerp(Vector3 a, Vector3 b, float t);

    /**
     * Returns a vector linearly interpolated between a and b, moving along
     * a straight line.
     * @param a: The starting point.
     * @param b: The ending point.
     * @param t: The interpolation value [0-1] (no actual bounds).
     * @return: A new vector.
     */
    static inline Vector3 LerpUnclamped(Vector3 a, Vector3 b, float t);

    /**
     * Returns the magnitude of a vector.
     * @param v: The vector in question.
     * @return: A scalar value.
     */
    static inline float Magnitude(Vector3 v);

    /**
     * Returns a vector made from the largest components of two other vectors.
     * @param a: The first vector.
     * @param b: The second vector.
     * @return: A new vector.
     */
    static inline Vector3 Max(Vector3 a, Vector3 b);

    /**
     * Returns a vector made from the smallest components of two other vectors.
     * @param a: The first vector.
     * @param b: The second vector.
     * @return: A new vector.
     */
    static inline Vector3 Min(Vector3 a, Vector3 b);

    /**
     * Returns a vector "maxDistanceDelta" units closer to the target. This
     * interpolation is in a straight line, and will not overshoot.
     * @param current: The current position.
     * @param target: The destination position.
     * @param maxDistanceDelta: The maximum distance to move.
     * @return: A new vector.
     */
    static inline Vector3 MoveTowards(Vector3 current, Vector3 target,
                                      float maxDistanceDelta);

    /**
     * Returns a new vector with magnitude of one.
     * @param v: The vector in question.
     * @return: A new vector.
     */
    static inline Vector3 Normalized(Vector3 v);

    /**
     * Returns an arbitrary vector orthogonal to the input.
     * This vector is not normalized.
     * @param v: The input vector.
     * @return: A new vector.
     */
    static inline Vector3 Orthogonal(Vector3 v);

    /**
     * Creates a new coordinate system out of the three vectors.
     * Normalizes "normal", normalizes "tangent" and makes it orthogonal to
     * "normal" and normalizes "binormal" and makes it orthogonal to both
     * "normal" and "tangent".
     * @param normal: A reference to the first axis vector.
     * @param tangent: A reference to the second axis vector.
     * @param binormal: A reference to the third axis vector.
     */
    static inline void OrthoNormalize(Vector3 &normal, Vector3 &tangent,
                                      Vector3 &binormal);

    /**
     * Returns the vector projection of a onto b.
     * @param a: The target vector.
     * @param b: The vector being projected onto.
     * @return: A new vector.
     */
    static inline Vector3 Project(Vector3 a, Vector3 b);

    /**
     * Returns a vector projected onto a plane orthogonal to "planeNormal".
     * This can be visualized as the shadow of the vector onto the plane, if
     * the light source were in the direction of the plane normal.
     * @param vector: The vector to project.
     * @param planeNormal: The normal of the plane onto which to project.
     * @param: A new vector.
     */
    static inline Vector3 ProjectOnPlane(Vector3 vector, Vector3 planeNormal);

    /**
     * Returns a vector reflected off the plane orthogonal to the normal.
     * The input vector is pointed inward, at the plane, and the return vector
     * is pointed outward from the plane, like a beam of light hitting and then
     * reflecting off a mirror.
     * @param vector: The vector traveling inward at the plane.
     * @param planeNormal: The normal of the plane off of which to reflect.
     * @return: A new vector pointing outward from the plane.
     */
    static inline Vector3 Reflect(Vector3 vector, Vector3 planeNormal);

    /**
     * Returns the vector rejection of a on b.
     * @param a: The target vector.
     * @param b: The vector being projected onto.
     * @return: A new vector.
     */
    static inline Vector3 Reject(Vector3 a, Vector3 b);

    /**
     * Rotates vector "current" towards vector "target" by "maxRadiansDelta".
     * This treats the vectors as directions and will linearly interpolate
     * between their magnitudes by "maxMagnitudeDelta". This function does not
     * overshoot. If a negative delta is supplied, it will rotate away from
     * "target" until it is pointing the opposite direction, but will not
     * overshoot that either.
     * @param current: The starting direction.
     * @param target: The destination direction.
     * @param maxRadiansDelta: The maximum number of radians to rotate.
     * @param maxMagnitudeDelta: The maximum delta for magnitude interpolation.
     * @return: A new vector.
     */
    static inline Vector3 RotateTowards(Vector3 current, Vector3 target,
                                        float maxRadiansDelta,
                                        float maxMagnitudeDelta);

    /**
     * Multiplies two vectors element-wise.
     * @param a: The lhs of the multiplication.
     * @param b: The rhs of the multiplication.
     * @return: A new vector.
     */
    static inline Vector3 Scale(Vector3 a, Vector3 b);

    /**
     * Returns a vector rotated towards b from a by the percent t.
     * Since interpolation is done spherically, the vector moves at a constant
     * angular velocity. This rotation is clamped to 0 <= t <= 1.
     * @param a: The starting direction.
     * @param b: The ending direction.
     * @param t: The interpolation value [0-1].
     */
    static inline Vector3 Slerp(Vector3 a, Vector3 b, float t);

    /**
     * Returns a vector rotated towards b from a by the percent t.
     * Since interpolation is done spherically, the vector moves at a constant
     * angular velocity. This rotation is unclamped.
     * @param a: The starting direction.
     * @param b: The ending direction.
     * @param t: The interpolation value [0-1].
     */
    static inline Vector3 SlerpUnclamped(Vector3 a, Vector3 b, float t);

    /**
     * Returns the squared magnitude of a vector.
     * This is useful when comparing relative lengths, where the exact length
     * is not important, and much time can be saved by not calculating the
     * square root.
     * @param v: The vector in question.
     * @return: A scalar value.
     */
    static inline float SqrMagnitude(Vector3 v);

    /**
     * Calculates the spherical coordinate space representation of a vector.
     * This uses the ISO convention (radius r, inclination theta, azimuth phi).
     * @param vector: The vector to convert.
     * @param rad: The magnitude of the vector.
     * @param theta: The angle in the XY plane from the X axis.
     * @param phi: The angle from the positive Z axis to the vector.
     */
    static inline void ToSpherical(Vector3 vector, float &rad, float &theta,
                                   float &phi);


    /**
     * Operator overloading.
     */
    inline struct Vector3& operator+=(const float rhs);
    inline struct Vector3& operator-=(const float rhs);
    inline struct Vector3& operator*=(const float rhs);
    inline struct Vector3& operator/=(const float rhs);
    inline struct Vector3& operator+=(const Vector3 rhs);
    inline struct Vector3& operator-=(const Vector3 rhs);
};

inline Vector3 operator-(Vector3 rhs);
inline Vector3 operator+(Vector3 lhs, const float rhs);
inline Vector3 operator-(Vector3 lhs, const float rhs);
inline Vector3 operator*(Vector3 lhs, const float rhs);
inline Vector3 operator/(Vector3 lhs, const float rhs);
inline Vector3 operator+(const float lhs, Vector3 rhs);
inline Vector3 operator-(const float lhs, Vector3 rhs);
inline Vector3 operator*(const float lhs, Vector3 rhs);
inline Vector3 operator/(const float lhs, Vector3 rhs);
inline Vector3 operator+(Vector3 lhs, const Vector3 rhs);
inline Vector3 operator-(Vector3 lhs, const Vector3 rhs);
inline bool operator==(const Vector3 lhs, const Vector3 rhs);
inline bool operator!=(const Vector3 lhs, const Vector3 rhs);



/*******************************************************************************
 * Implementation
 */

Vector3::Vector3() : X(0), Y(0), Z(0) {}
Vector3::Vector3(float data[]) : X(data[0]), Y(data[1]), Z(data[2]) {}
Vector3::Vector3(float value) : X(value), Y(value), Z(value) {}
Vector3::Vector3(float x, float y) : X(x), Y(y), Z(0) {}
Vector3::Vector3(float x, float y, float z) : X(x), Y(y), Z(z) {}


Vector3 Vector3::Zero() { return Vector3(0, 0, 0); }
Vector3 Vector3::One() { return Vector3(1, 1, 1); }
Vector3 Vector3::Right() { return Vector3(1, 0, 0); }
Vector3 Vector3::Left() { return Vector3(-1, 0, 0); }
Vector3 Vector3::Up() { return Vector3(0, 1, 0); }
Vector3 Vector3::Down() { return Vector3(0, -1, 0); }
Vector3 Vector3::Forward() { return Vector3(0, 0, 1); }
Vector3 Vector3::Backward() { return Vector3(0, 0, -1); }


float Vector3::Angle(Vector3 a, Vector3 b)
{
    float v = Dot(a, b) / (Magnitude(a) * Magnitude(b));
    v = fmax(v, -1.0);
    v = fmin(v, 1.0);
    return acos(v);
}

Vector3 Vector3::ClampMagnitude(Vector3 vector, float maxLength)
{
    float length = Magnitude(vector);
    if (length > maxLength)
        vector *= maxLength / length;
    return vector;
}

float Vector3::Component(Vector3 a, Vector3 b)
{
    return Dot(a, b) / Magnitude(b);
}

Vector3 Vector3::Cross(Vector3 lhs, Vector3 rhs)
{
    float x = lhs.Y * rhs.Z - lhs.Z * rhs.Y;
    float y = lhs.Z * rhs.X - lhs.X * rhs.Z;
    float z = lhs.X * rhs.Y - lhs.Y * rhs.X;
    return Vector3(x, y, z);
}

float Vector3::Distance(Vector3 a, Vector3 b)
{
    return Vector3::Magnitude(a - b);
}

float Vector3::Dot(Vector3 lhs, Vector3 rhs)
{
    return lhs.X * rhs.X + lhs.Y * rhs.Y + lhs.Z * rhs.Z;
}

Vector3 Vector3::FromSpherical(float rad, float theta, float phi)
{
    Vector3 v;
    v.X = rad * sin(theta) * cos(phi);
    v.Y = rad * sin(theta) * sin(phi);
    v.Z = rad * cos(theta);
    return v;
}

Vector3 Vector3::Lerp(Vector3 a, Vector3 b, float t)
{
    if (t < 0) return a;
    else if (t > 1) return b;
    return LerpUnclamped(a, b, t);
}

Vector3 Vector3::LerpUnclamped(Vector3 a, Vector3 b, float t)
{
    return (b - a) * t + a;
}

float Vector3::Magnitude(Vector3 v)
{
    return sqrt(SqrMagnitude(v));
}

Vector3 Vector3::Max(Vector3 a, Vector3 b)
{
    float x = a.X > b.X ? a.X : b.X;
    float y = a.Y > b.Y ? a.Y : b.Y;
    float z = a.Z > b.Z ? a.Z : b.Z;
    return Vector3(x, y, z);
}

Vector3 Vector3::Min(Vector3 a, Vector3 b)
{
    float x = a.X > b.X ? b.X : a.X;
    float y = a.Y > b.Y ? b.Y : a.Y;
    float z = a.Z > b.Z ? b.Z : a.Z;
    return Vector3(x, y, z);
}

Vector3 Vector3::MoveTowards(Vector3 current, Vector3 target,
                             float maxDistanceDelta)
{
    Vector3 d = target - current;
    float m = Magnitude(d);
    if (m < maxDistanceDelta || m == 0)
        return target;
    return current + (d * maxDistanceDelta / m);
}

Vector3 Vector3::Normalized(Vector3 v)
{
    float mag = Magnitude(v);
    if (mag == 0)
        return Vector3::Zero();
    return v / mag;
}

Vector3 Vector3::Orthogonal(Vector3 v)
{
    return v.Z < v.X ? Vector3(v.Y, -v.X, 0) : Vector3(0, -v.Z, v.Y);
}

void Vector3::OrthoNormalize(Vector3 &normal, Vector3 &tangent,
                             Vector3 &binormal)
{
    normal = Normalized(normal);
    tangent = ProjectOnPlane(tangent, normal);
    tangent = Normalized(tangent);
    binormal = ProjectOnPlane(binormal, tangent);
    binormal = ProjectOnPlane(binormal, normal);
    binormal = Normalized(binormal);
}

Vector3 Vector3::Project(Vector3 a, Vector3 b)
{
    float m = Magnitude(b);
    return Dot(a, b) / (m * m) * b;
}

Vector3 Vector3::ProjectOnPlane(Vector3 vector, Vector3 planeNormal)
{
    return Reject(vector, planeNormal);
}

Vector3 Vector3::Reflect(Vector3 vector, Vector3 planeNormal)
{
    return vector - 2 * Project(vector, planeNormal);
}

Vector3 Vector3::Reject(Vector3 a, Vector3 b)
{
    return a - Project(a, b);
}

Vector3 Vector3::RotateTowards(Vector3 current, Vector3 target,
                               float maxRadiansDelta,
                               float maxMagnitudeDelta)
{
    float magCur = Magnitude(current);
    float magTar = Magnitude(target);
    float newMag = magCur + maxMagnitudeDelta *
                            ((magTar > magCur) - (magCur > magTar));
    newMag = fmin(newMag, fmax(magCur, magTar));
    newMag = fmax(newMag, fmin(magCur, magTar));

    float totalAngle = Angle(current, target) - maxRadiansDelta;
    if (totalAngle <= 0)
        return Normalized(target) * newMag;
    else if (totalAngle >= M_PI)
        return Normalized(-target) * newMag;

    Vector3 axis = Cross(current, target);
    float magAxis = Magnitude(axis);
    if (magAxis == 0)
        axis = Normalized(Cross(current, current + Vector3(3.95, 5.32, -4.24)));
    else
        axis /= magAxis;
    current = Normalized(current);
    Vector3 newVector = current * cos(maxRadiansDelta) +
                        Cross(axis, current) * sin(maxRadiansDelta);
    return newVector * newMag;
}

Vector3 Vector3::Scale(Vector3 a, Vector3 b)
{
    return Vector3(a.X * b.X, a.Y * b.Y, a.Z * b.Z);
}

Vector3 Vector3::Slerp(Vector3 a, Vector3 b, float t)
{
    if (t < 0) return a;
    else if (t > 1) return b;
    return SlerpUnclamped(a, b, t);
}

Vector3 Vector3::SlerpUnclamped(Vector3 a, Vector3 b, float t)
{
    float magA = Magnitude(a);
    float magB = Magnitude(b);
    a /= magA;
    b /= magB;
    float dot = Dot(a, b);
    dot = fmax(dot, -1.0);
    dot = fmin(dot, 1.0);
    float theta = acos(dot) * t;
    Vector3 relativeVec = Normalized(b - a * dot);
    Vector3 newVec = a * cos(theta) + relativeVec * sin(theta);
    return newVec * (magA + (magB - magA) * t);
}

float Vector3::SqrMagnitude(Vector3 v)
{
    return v.X * v.X + v.Y * v.Y + v.Z * v.Z;
}

void Vector3::ToSpherical(Vector3 vector, float &rad, float &theta,
                          float &phi)
{
    rad = Magnitude(vector);
    float v = vector.Z / rad;
    v = fmax(v, -1.0);
    v = fmin(v, 1.0);
    theta = acos(v);
    phi = atan2(vector.Y, vector.X);
}


struct Vector3& Vector3::operator+=(const float rhs)
{
    X += rhs;
    Y += rhs;
    Z += rhs;
    return *this;
}

struct Vector3& Vector3::operator-=(const float rhs)
{
    X -= rhs;
    Y -= rhs;
    Z -= rhs;
    return *this;
}

struct Vector3& Vector3::operator*=(const float rhs)
{
    X *= rhs;
    Y *= rhs;
    Z *= rhs;
    return *this;
}

struct Vector3& Vector3::operator/=(const float rhs)
{
    X /= rhs;
    Y /= rhs;
    Z /= rhs;
    return *this;
}

struct Vector3& Vector3::operator+=(const Vector3 rhs)
{
    X += rhs.X;
    Y += rhs.Y;
    Z += rhs.Z;
    return *this;
}

struct Vector3& Vector3::operator-=(const Vector3 rhs)
{
    X -= rhs.X;
    Y -= rhs.Y;
    Z -= rhs.Z;
    return *this;
}

char Vector3::ToChar(Vector3 a) {
    const char* x = (const char*)(int)a.X;
    const char* y = (const char*)(int)a.Y;
    const char* z = (const char*)(int)a.Z;
    char buffer[25];
    strncpy(buffer, x, sizeof(buffer));
    strncpy(buffer, ", ", sizeof(buffer));
    strncpy(buffer, y, sizeof(buffer));
    strncpy(buffer, ", ", sizeof(buffer));
    strncpy(buffer, z, sizeof(buffer));
    strncpy(buffer, ", ", sizeof(buffer));
    return buffer[25];
}

Vector3 operator-(Vector3 rhs) { return rhs * -1; }
Vector3 operator+(Vector3 lhs, const float rhs) { return lhs += rhs; }
Vector3 operator-(Vector3 lhs, const float rhs) { return lhs -= rhs; }
Vector3 operator*(Vector3 lhs, const float rhs) { return lhs *= rhs; }
Vector3 operator/(Vector3 lhs, const float rhs) { return lhs /= rhs; }
Vector3 operator+(const float lhs, Vector3 rhs) { return rhs += lhs; }
Vector3 operator-(const float lhs, Vector3 rhs) { return rhs -= lhs; }
Vector3 operator*(const float lhs, Vector3 rhs) { return rhs *= lhs; }
Vector3 operator/(const float lhs, Vector3 rhs) { return rhs /= lhs; }
Vector3 operator+(Vector3 lhs, const Vector3 rhs) { return lhs += rhs; }
Vector3 operator-(Vector3 lhs, const Vector3 rhs) { return lhs -= rhs; }

bool operator==(const Vector3 lhs, const Vector3 rhs)
{
    return lhs.X == rhs.X && lhs.Y == rhs.Y && lhs.Z == rhs.Z;
}

bool operator!=(const Vector3 lhs, const Vector3 rhs)
{
    return !(lhs == rhs);
}
```

`app/src/main/jni/fake_dlfcn.cpp`:

```cpp

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <elf.h>
#include <dlfcn.h>
#include <sys/system_properties.h>
#include <android/log.h>

#define TAG_NAME    "dlfcn_ex"
#define LOG_DBG
#ifdef LOG_DBG
#define log_info(fmt, args...) __android_log_print(ANDROID_LOG_INFO, TAG_NAME, (const char *) fmt, ##args)
#define log_err(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, TAG_NAME, (const char *) fmt, ##args)
#define log_dbg log_info
#else
#define log_dbg(...)
#define log_info(fmt, args...)
#define log_err(fmt, args...)
#endif

#ifdef __LP64__
#define Elf_Ehdr Elf64_Ehdr
#define Elf_Shdr Elf64_Shdr
#define Elf_Sym  Elf64_Sym
#else
#define Elf_Ehdr Elf32_Ehdr
#define Elf_Shdr Elf32_Shdr
#define Elf_Sym  Elf32_Sym
#endif


struct ctx {
    void *load_addr;
    void *dynstr;
    void *dynsym;
    int nsyms;
    off_t bias;
};

extern "C" {

static int fake_dlclose(void *handle) {
    if (handle) {
        struct ctx *ctx = (struct ctx *) handle;
        if (ctx->dynsym) free(ctx->dynsym);    /* we're saving dynsym and dynstr */
        if (ctx->dynstr) free(ctx->dynstr);    /* from library file just in case */
        free(ctx);
    }
    return 0;
}

/* flags are ignored */
static void *fake_dlopen_with_path(const char *libpath, int flags) {
    FILE *maps;
    char buff[256], name[256];
    struct ctx *ctx = 0;
    off_t load_addr, size;
    int k, fd = -1, found = 0;
    char *shoff;
    Elf_Ehdr *elf = (Elf_Ehdr *) MAP_FAILED;

#define fatal(fmt, args...) do { log_err(fmt,##args); goto err_exit; } while(0)

    maps = fopen("/proc/self/maps", "r");
    if (!maps) fatal("failed to open maps");

    while (!found && fgets(buff, sizeof(buff), maps)) {
        if (strstr(buff, libpath) && (strstr(buff, "r-xp") || strstr(buff, "r--p"))) found = 1;
    }
    fclose(maps);

    if (!found) fatal("%s not found in my userspace", libpath);

    if (sscanf(buff, "%lx-%*lx %*s %*s %*s %*s %s", &load_addr, name) != 2)
        fatal("failed to read load address for %s", libpath);

    log_info("%s loaded in Android at 0x%08lx", libpath, load_addr);

    libpath = name;

    /* Now, mmap the same library once again */

    fd = open(libpath, O_RDONLY);
    if (fd < 0) fatal("failed to open %s", libpath);

    size = lseek(fd, 0, SEEK_END);
    if (size <= 0) fatal("lseek() failed for %s", libpath);

    elf = (Elf_Ehdr *) mmap(0, size, PROT_READ, MAP_SHARED, fd, 0);
    close(fd);
    fd = -1;

    if (elf == MAP_FAILED) fatal("mmap() failed for %s", libpath);

    ctx = (struct ctx *) calloc(1, sizeof(struct ctx));
    if (!ctx) fatal("no memory for %s", libpath);

    ctx->load_addr = (void *) load_addr;
    shoff = ((char *) elf) + elf->e_shoff;

    for (k = 0; k < elf->e_shnum; k++, shoff += elf->e_shentsize) {

        Elf_Shdr *sh = (Elf_Shdr *) shoff;
        log_dbg("%s: k=%d shdr=%p type=%x", __func__, k, sh, sh->sh_type);

        switch (sh->sh_type) {

            case SHT_DYNSYM:
                if (ctx->dynsym) fatal("%s: duplicate DYNSYM sections", libpath); /* .dynsym */
                ctx->dynsym = malloc(sh->sh_size);
                if (!ctx->dynsym) fatal("%s: no memory for .dynsym", libpath);
                memcpy(ctx->dynsym, ((char *) elf) + sh->sh_offset, sh->sh_size);
                ctx->nsyms = (sh->sh_size / sizeof(Elf_Sym));
                break;

            case SHT_STRTAB:
                if (ctx->dynstr) break;    /* .dynstr is guaranteed to be the first STRTAB */
                ctx->dynstr = malloc(sh->sh_size);
                if (!ctx->dynstr) fatal("%s: no memory for .dynstr", libpath);
                memcpy(ctx->dynstr, ((char *) elf) + sh->sh_offset, sh->sh_size);
                break;

            case SHT_PROGBITS:
                if (!ctx->dynstr || !ctx->dynsym) break;
                /* won't even bother checking against the section name */
                ctx->bias = (off_t) sh->sh_addr - (off_t) sh->sh_offset;
                k = elf->e_shnum;  /* exit for */
                break;
        }
    }

    munmap(elf, size);
    elf = 0;

    if (!ctx->dynstr || !ctx->dynsym) fatal("dynamic sections not found in %s", libpath);

#undef fatal

    log_dbg("%s: ok, dynsym = %p, dynstr = %p", libpath, ctx->dynsym, ctx->dynstr);

    return ctx;

    err_exit:
    if (fd >= 0) close(fd);
    if (elf != MAP_FAILED) munmap(elf, size);
    fake_dlclose(ctx);
    return 0;
}


#if defined(__LP64__)
static const char *const kSystemLibDir = "/system/lib64/";
static const char *const kOdmLibDir = "/odm/lib64/";
static const char *const kVendorLibDir = "/vendor/lib64/";
static const char *const kApexLibDir = "/apex/com.android.runtime/lib64/";
static const char *const kApexArtNsLibDir = "/apex/com.android.art/lib64/";
#else
static const char *const kSystemLibDir = "/system/lib/";
static const char *const kOdmLibDir = "/odm/lib/";
static const char *const kVendorLibDir = "/vendor/lib/";
static const char *const kApexLibDir = "/apex/com.android.runtime/lib/";
static const char *const kApexArtNsLibDir = "/apex/com.android.art/lib/";
#endif

static void *fake_dlopen(const char *filename, int flags) {
    if (strlen(filename) > 0 && filename[0] == '/') {
        return fake_dlopen_with_path(filename, flags);
    } else {
        char buf[512] = {0};
        void *handle = NULL;
        //sysmtem
        strcpy(buf, kSystemLibDir);
        strcat(buf, filename);
        handle = fake_dlopen_with_path(buf, flags);
        if (handle) {
            return handle;
        }

        // apex in ns com.android.runtime
        memset(buf, 0, sizeof(buf));
        strcpy(buf, kApexLibDir);
        strcat(buf, filename);
        handle = fake_dlopen_with_path(buf, flags);
        if (handle) {
            return handle;
        }

        // apex in ns com.android.art
        memset(buf, 0, sizeof(buf));
        strcpy(buf, kApexArtNsLibDir);
        strcat(buf, filename);
        handle = fake_dlopen_with_path(buf, flags);
        if (handle) {
            return handle;
        }

        //odm
        memset(buf, 0, sizeof(buf));
        strcpy(buf, kOdmLibDir);
        strcat(buf, filename);
        handle = fake_dlopen_with_path(buf, flags);
        if (handle) {
            return handle;
        }

        //vendor
        memset(buf, 0, sizeof(buf));
        strcpy(buf, kVendorLibDir);
        strcat(buf, filename);
        handle = fake_dlopen_with_path(buf, flags);
        if (handle) {
            return handle;
        }

        return fake_dlopen_with_path(filename, flags);
    }
}

static void *fake_dlsym(void *handle, const char *name) {
    int k;
    struct ctx *ctx = (struct ctx *) handle;
    Elf_Sym *sym = (Elf_Sym *) ctx->dynsym;
    char *strings = (char *) ctx->dynstr;

    for (k = 0; k < ctx->nsyms; k++, sym++)
        if (strcmp(strings + sym->st_name, name) == 0) {
            /*  NB: sym->st_value is an offset into the section for relocatables,
            but a VMA for shared libs or exe files, so we have to subtract the bias */
            void *ret = (char *) ctx->load_addr + sym->st_value - ctx->bias;
            log_info("%s found at %p", name, ret);
            return ret;
        }
    return 0;
}


static const char *fake_dlerror() {
    return NULL;
}

// =============== implementation for compat ==========
static int SDK_INT = -1;
static int get_sdk_level() {
    if (SDK_INT > 0) {
        return SDK_INT;
    }
    char sdk[PROP_VALUE_MAX] = {0};;
    __system_property_get("ro.build.version.sdk", sdk);
    SDK_INT = atoi(sdk);
    return SDK_INT;
}

int dlclose_ex(void *handle) {
    if (get_sdk_level() >= 24) {
        return fake_dlclose(handle);
    } else {
        return dlclose(handle);
    }
}

void *dlopen_ex(const char *filename, int flags) {
    log_info("dlopen: %s", filename);
    if (get_sdk_level() >= 24) {
        return fake_dlopen(filename, flags);
    } else {
        return dlopen(filename, flags);
    }
}

void *dlsym_ex(void *handle, const char *symbol) {
    if (get_sdk_level() >= 24) {
        return fake_dlsym(handle, symbol);
    } else {
        return dlsym(handle, symbol);
    }
}

const char *dlerror_ex() {
    if (get_sdk_level() >= 24) {
        return fake_dlerror();
    } else {
        return dlerror();
    }
}
}

```

`app/src/main/jni/fake_dlfcn.h`:

```h

#ifndef DEXPOSED_DLFCN_H
#define DEXPOSED_DLFCN_H

#include <cstdlib>
#include <string.h>
#include <unistd.h>

extern "C" {

void *dlopen_ex(const char *filename, int flags);

void *dlsym_ex(void *handle, const char *symbol);

int dlclose_ex(void *handle);

const char *dlerror_ex();

};
#endif //DEXPOSED_DLFCN_H

```

`app/src/main/jni/symbols.ver`:

```ver
{ global:
JNI_OnLoad;
local: *; };
```

`app/src/main/res/drawable-v24/ic_launcher_foreground.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path
        android:fillType="evenOdd"
        android:pathData="M32,64C32,64 38.39,52.99 44.13,50.95C51.37,48.37 70.14,49.57 70.14,49.57L108.26,87.69L108,109.01L75.97,107.97L32,64Z"
        android:strokeWidth="1"
        android:strokeColor="#00000000">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="78.5885"
                android:endY="90.9159"
                android:startX="48.7653"
                android:startY="61.0927"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M66.94,46.02L66.94,46.02C72.44,50.07 76,56.61 76,64L32,64C32,56.61 35.56,50.11 40.98,46.06L36.18,41.19C35.45,40.45 35.45,39.3 36.18,38.56C36.91,37.81 38.05,37.81 38.78,38.56L44.25,44.05C47.18,42.57 50.48,41.71 54,41.71C57.48,41.71 60.78,42.57 63.68,44.05L69.11,38.56C69.84,37.81 70.98,37.81 71.71,38.56C72.44,39.3 72.44,40.45 71.71,41.19L66.94,46.02ZM62.94,56.92C64.08,56.92 65,56.01 65,54.88C65,53.76 64.08,52.85 62.94,52.85C61.8,52.85 60.88,53.76 60.88,54.88C60.88,56.01 61.8,56.92 62.94,56.92ZM45.06,56.92C46.2,56.92 47.13,56.01 47.13,54.88C47.13,53.76 46.2,52.85 45.06,52.85C43.92,52.85 43,53.76 43,54.88C43,56.01 43.92,56.92 45.06,56.92Z"
        android:strokeWidth="1"
        android:strokeColor="#00000000" />
</vector>

```

`app/src/main/res/drawable/ic_launcher_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path
        android:fillColor="#008577"
        android:pathData="M0,0h108v108h-108z" />
    <path
        android:fillColor="#00000000"
        android:pathData="M9,0L9,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,0L19,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,0L29,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,0L39,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,0L49,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,0L59,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,0L69,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,0L79,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M89,0L89,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M99,0L99,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,9L108,9"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,19L108,19"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,29L108,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,39L108,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,49L108,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,59L108,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,69L108,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,79L108,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,89L108,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,99L108,99"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,29L89,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,39L89,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,49L89,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,59L89,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,69L89,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,79L89,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,19L29,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,19L39,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,19L49,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,19L59,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,19L69,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,19L79,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
</vector>

```

`app/src/main/res/layout/activity_main.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context="com.gotoubun.MainActivity">
</androidx.constraintlayout.widget.ConstraintLayout>

```

`app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
```

`app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>
```

`app/src/main/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="colorPrimary">#008577</color>
    <color name="colorPrimaryDark">#00574B</color>
    <color name="colorAccent">#D81B60</color>
</resources>

```

`app/src/main/res/values/strings.xml`:

```xml
<resources>
    <string name="app_name">Test</string>
</resources>

```

`app/src/main/res/values/styles.xml`:

```xml
<resources>

</resources>

```

`build.gradle`:

```gradle
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        google()
        jcenter()

    }
    dependencies {
        classpath 'com.android.tools.build:gradle:7.1.0'
        
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        google()
        jcenter()
        maven { url 'https://jitpack.io' }
        
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

```

`gradle.properties`:

```properties
## For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
#
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
# Default value: -Xmx1024m -XX:MaxPermSize=256m
# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
#
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true
#Sat Oct 03 02:07:22 SGT 2020
android.useAndroidX=true
org.gradle.jvmargs=-Xmx2048M -Dkotlin.daemon.jvm.options\="-Xmx2048M"

```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
#Tue Oct 13 13:18:25 SGT 2020
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-7.2-bin.zip

```

`gradlew`:

```
#!/usr/bin/env sh

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS=""

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin, switch paths to Windows format before running java
if $cygwin ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=$((i+1))
    done
    case $i in
        (0) set -- ;;
        (1) set -- "$args0" ;;
        (2) set -- "$args0" "$args1" ;;
        (3) set -- "$args0" "$args1" "$args2" ;;
        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=$(save "$@")

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
  cd "$(dirname "$0")"
fi

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS=

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto init

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto init

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:init
@rem Get command-line arguments, handling Windows variants

if not "%OS%" == "Windows_NT" goto win9xME_args

:win9xME_args
@rem Slurp the command line arguments.
set CMD_LINE_ARGS=
set _SKIP=2

:win9xME_args_slurp
if "x%~1" == "x" goto execute

set CMD_LINE_ARGS=%*

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar

@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`settings.gradle`:

```gradle
include ':app'
rootProject.name='CODM'
```