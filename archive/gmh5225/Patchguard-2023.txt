Project Path: arc_gmh5225_Patchguard-2023_e09mi91v

Source Tree:

```txt
arc_gmh5225_Patchguard-2023_e09mi91v
├── Ctx.c
├── Ctx.h
├── Except.c
├── Except.h
├── Guard.c
├── Guard.h
├── Makefile
├── PatchGuard.c
├── PatchGuard.h
├── Reload.c
├── Reload.h
├── Rtx.c
├── Rtx.h
├── Scan.c
├── Scan.h
├── Sea.c
├── Sea.def
├── Sea.h
├── Sea.ico
├── Sea.rc
├── Sea.vcxproj
├── Sea.vcxproj.filters
├── Sea.vcxproj.user
├── Shark.c
├── Shark.def
├── Shark.h
├── Shark.rc
├── Shark.vcxproj
├── Shark.vcxproj.filters
├── Shark.vcxproj.user
├── Space.c
├── Space.h
├── Stack.c
├── Stack.h
├── Support.c
└── Support.h

```

`Ctx.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Ctx.h"

#include "Guard.h"
#include "Reload.h"
#include "Scan.h"

```

`Ctx.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _CTX_H_
#define _CTX_H_

#include "Reload.h"

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

#ifdef _WIN64
    typedef struct _EXCEPTION_FRAME {
        //
        // Home address for the parameter registers.
        //

        u64 P1Home;
        u64 P2Home;
        u64 P3Home;
        u64 P4Home;
        u64 P5;

        //
        // Kernel callout initial stack value.
        //

        u64 InitialStack;

        //
        // Saved nonvolatile floating registers.
        //

        M128A Xmm6;
        M128A Xmm7;
        M128A Xmm8;
        M128A Xmm9;
        M128A Xmm10;
        M128A Xmm11;
        M128A Xmm12;
        M128A Xmm13;
        M128A Xmm14;
        M128A Xmm15;

        //
        // Kernel callout frame variables.
        //

        u64 TrapFrame;
        u64 CallbackStack;
        u64 OutputBuffer;
        u64 OutputLength;

        //
        // Saved MXCSR when a thread is interrupted in kernel mode via a dispatch
        // interrupt.
        //

        u64 MxCsr;

        //
        // Saved nonvolatile register - not always saved.
        //

        u64 Rbp;

        //
        // Saved nonvolatile registers.
        //

        u64 Rbx;
        u64 Rdi;
        u64 Rsi;
        u64 R12;
        u64 R13;
        u64 R14;
        u64 R15;

        //
        // EFLAGS and return address.
        //

        u64 Return;
    }EXCEPTION_FRAME, *PEXCEPTION_FRAME;

#define EXCEPTION_FRAME_LENGTH sizeof(EXCEPTION_FRAME)

    C_ASSERT((sizeof(EXCEPTION_FRAME) & STACK_ROUND) == 0);

#endif // _WIN64

#define GetBaseTrapFrame(Thread) GetBaseTrapFrameThread(Thread)

    PKTRAP_FRAME
        NTAPI
        GetBaseTrapFrameThread(
            __in PETHREAD Thread
        );

    FORCEINLINE
        PKAPC_STATE
        NTAPI
        GetApcStateThread(
            __in PKTHREAD Thread
        )
    {
        return CONTAINING_RECORD(
            (u)Thread +
            RtBlock.DebuggerDataBlock.OffsetKThreadApcProcess,
            KAPC_STATE,
            Process);
    }

    FORCEINLINE
        KTHREAD_STATE
        NTAPI
        GetThreadState(
            __in PKTHREAD Thread
        )
    {
        return *(PCCHAR)((u)Thread +
            RtBlock.DebuggerDataBlock.OffsetKThreadState);
    }

    FORCEINLINE
        PLIST_ENTRY
        NTAPI
        GetProcessThreadListHead(
            __inout PRTB RtBlock,
            __inout PEPROCESS Process
        )
    {
        return (PLIST_ENTRY)((u8ptr)Process +
            RtBlock->OffsetKProcessThreadListHead);
    }

    FORCEINLINE
        PETHREAD
        NTAPI
        GetProcessFirstThread(
            __inout PRTB RtBlock,
            __inout PEPROCESS Process
        )
    {
        return (PETHREAD)
            ((u8ptr)GetProcessThreadListHead(
                RtBlock, Process)->Flink -
                RtBlock->OffsetKThreadThreadListEntry);
    }

    FORCEINLINE
        PLIST_ENTRY
        NTAPI
        GetThreadListEntry(
            __inout PRTB RtBlock,
            __inout PETHREAD Thread
        )
    {
        return (PLIST_ENTRY)((u8ptr)Thread +
            RtBlock->OffsetKThreadThreadListEntry);
    }

    FORCEINLINE
        PETHREAD
        NTAPI
        GetNexThread(
            __inout PRTB RtBlock,
            __inout PETHREAD Thread
        )
    {
        return (PETHREAD)
            ((u8ptr)(((PLIST_ENTRY)((u8ptr)Thread +
                RtBlock->OffsetKThreadThreadListEntry))->Flink) -
                RtBlock->OffsetKThreadThreadListEntry);
    }

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_CTX_H_

```

`Except.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Except.h"

void
NTAPI
CaptureImageExceptionValues(
    __in ptr Base,
    __out ptr * FunctionTable,
    __out u32ptr TableSize
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    PIMAGE_LOAD_CONFIG_DIRECTORY32 LoadConfig = NULL;
    u32 LoadConfigSize = 0;
    PIMAGE_COR20_HEADER Cor20Header = NULL;
    u32 Cor20HeaderSize = 0;

    NtHeaders = RtlImageNtHeader(Base);

    if (NULL != NtHeaders) {
        if (IMAGE_NT_OPTIONAL_HDR32_MAGIC == NtHeaders->OptionalHeader.Magic) {
            if (IMAGE_DLLCHARACTERISTICS_NO_SEH ==
                (((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.DllCharacteristics &
                    IMAGE_DLLCHARACTERISTICS_NO_SEH)) {
                *FunctionTable = LongToPtr(-1);
                *TableSize = -1;
            }
            else {
                LoadConfig = (PIMAGE_LOAD_CONFIG_DIRECTORY32)
                    RtlImageDirectoryEntryToData(
                        Base,
                        TRUE,
                        IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                        &LoadConfigSize);

                if (NULL != LoadConfig &&
                    LoadConfig->Size >= RTL_SIZEOF_THROUGH_FIELD(
                        IMAGE_LOAD_CONFIG_DIRECTORY32,
                        SEHandlerCount) &&
                    0 != LoadConfig->SEHandlerTable &&
                    0 != LoadConfig->SEHandlerCount) {
                    *FunctionTable = UlongToPtr(LoadConfig->SEHandlerTable);
                    *TableSize = LoadConfig->SEHandlerCount;
                }
                else {
                    Cor20Header = RtlImageDirectoryEntryToData(
                        Base,
                        TRUE,
                        IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
                        &Cor20HeaderSize);

                    if (Cor20Header && ((Cor20Header->Flags & COMIMAGE_FLAGS_ILONLY) ==
                        COMIMAGE_FLAGS_ILONLY)) {
                        *FunctionTable = LongToPtr(-1);
                        *TableSize = -1;
                    }
                    else {
                        *FunctionTable = NULL;
                        *TableSize = 0;
                    }
                }
            }
        }
        else if (IMAGE_NT_OPTIONAL_HDR64_MAGIC == NtHeaders->OptionalHeader.Magic) {
            *FunctionTable = RtlImageDirectoryEntryToData(
                Base,
                TRUE,
                IMAGE_DIRECTORY_ENTRY_EXCEPTION,
                TableSize);
        }
    }
}

```

`Except.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _EXCEPT_H_
#define _EXCEPT_H_

#include "Reload.h"

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

    void
        NTAPI
        CaptureImageExceptionValues(
            __in ptr Base,
            __out ptr * FunctionTable,
            __out u32ptr TableSize
        );

    void
        NTAPI
        InitializeExcept(
            __inout PRTB Block
        );

#ifndef _WIN64
    typedef struct _DISPATCHER_CONTEXT {
        PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
    } DISPATCHER_CONTEXT;
#else
    void
        NTAPI
        InsertInvertedFunctionTable(
            __in ptr ImageBase,
            __in u32 SizeOfImage
        );

    void
        NTAPI
        RemoveInvertedFunctionTable(
            __in ptr ImageBase
        );

    PRUNTIME_FUNCTION
        NTAPI
        UnwindPrologue(
            __in u64 ImageBase,
            __in u64 ControlPc,
            __in u64 FrameBase,
            __in PRUNTIME_FUNCTION FunctionEntry,
            __inout PCONTEXT ContextRecord,
            __inout_opt PKNONVOLATILE_CONTEXT_POINTERS ContextPointers
        );

    PEXCEPTION_ROUTINE
        NTAPI
        VirtualUnwind(
            __in u32 HandlerType,
            __in u64 ImageBase,
            __in u64 ControlPc,
            __in PRUNTIME_FUNCTION FunctionEntry,
            __inout PCONTEXT ContextRecord,
            __out ptr * HandlerData,
            __out u64ptr EstablisherFrame,
            __inout_opt PKNONVOLATILE_CONTEXT_POINTERS ContextPointers
        );
#endif // !_WIN64

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_EXCEPT_H_

```

`Guard.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Guard.h"

#include "Scan.h"
#include "Reload.h"

ptr
NTAPI
GuardAllocateTrampoline(
    __in u8 NumberOfBytes
)
{
    ptr Result = NULL;

    Result = __malloc(NumberOfBytes);

    if (NULL != Result) {
        RtlZeroMemory(Result, NumberOfBytes);
    }

    return Result;
}

void
NTAPI
GuardFreeTrampoline(
    __in ptr BaseAddress,
    __in u8 NumberOfBytes
)
{
    __free(BaseAddress);
}

void
NTAPI
MapLockedCopyInstruction(
    __in ptr Destination,
    __in ptr Source,
    __in u32 Length
)
{
    s8 Instruction[4] = { 0 };
    PHYSICAL_ADDRESS PhysicalAddress = { 0 };
    ptr VirtualAddress = NULL;

    if (Length > sizeof(u32)) {
        RtlCopyMemory(Instruction, Source, sizeof(u32));
    }
    else {
        RtlCopyMemory(Instruction, Source, Length);

        RtlCopyMemory(
            Instruction + Length,
            (u8ptr)Destination + Length,
            sizeof(u32) - Length);
    }

    PhysicalAddress = MmGetPhysicalAddress(Destination);

    VirtualAddress = MmMapIoSpace(
        PhysicalAddress,
        Length,
        MmNonCached);

    if (NULL != VirtualAddress) {
        if (Length > sizeof(u32)) {
            InterlockedExchange(VirtualAddress, JUMP_SELF);

            RtlCopyMemory(
                (u8ptr)VirtualAddress + sizeof(u32),
                (u8ptr)Source + sizeof(u32),
                Length - sizeof(u32));
        }

        InterlockedExchange(VirtualAddress, *(u32ptr)Instruction);

        MmUnmapIoSpace(VirtualAddress, Length);
    }
}

void
NTAPI
MapLockedBuildJumpCode(
    __inout ptr * Pointer,
    __in ptr Guard
)
{
    GUARD_BODY GuardBody = { 0 };

    SetGuardBody(&GuardBody, Guard);

    MapLockedCopyInstruction(
        *Pointer,
        &GuardBody,
        GUARD_BODY_CODE_LENGTH);
}

void
NTAPI
LockedCopyInstruction(
    __in ptr Destination,
    __in ptr Source,
    __in u32 Length
)
{
    s8 Instruction[4] = { 0 };

    if (Length > sizeof(s32)) {
        RtlCopyMemory(Instruction, Source, sizeof(s32));
    }
    else {
        RtlCopyMemory(Instruction, Source, Length);

        RtlCopyMemory(
            Instruction + Length,
            (u8ptr)Destination + Length,
            sizeof(s32) - Length);
    }

    if (Length > sizeof(s32)) {
        InterlockedExchange(Destination, JUMP_SELF);

        RtlCopyMemory(
            (u8ptr)Destination + sizeof(s32),
            (u8ptr)Source + sizeof(s32),
            Length - sizeof(s32));
    }

    InterlockedExchange(Destination, *(s32ptr)Instruction);
}

void
NTAPI
LockedBuildJumpCode(
    __inout ptr * Pointer,
    __in ptr Guard
)
{
    GUARD_BODY GuardBody = { 0 };

    SetGuardBody(&GuardBody, Guard);

    LockedCopyInstruction(
        *Pointer,
        &GuardBody,
        GUARD_BODY_CODE_LENGTH);
}

void
NTAPI
BuildJumpCode(
    __inout ptr * Pointer,
    __in ptr Guard
)
{
    GUARD_BODY GuardBody = { 0 };

    SetGuardBody(&GuardBody, Guard);

    RtlCopyMemory(
        *Pointer,
        &GuardBody,
        GUARD_BODY_CODE_LENGTH);
}

#ifdef _WIN64
ptr
NTAPI
DisCopy8B(
    __in_opt ptr Dst,
    __in_opt ptr * DstPool,
    __in ptr Src,
    __out_opt ptr * Target,
    __out s32 * Extra
)
{
    PCHAR Instruction = NULL;
    u8 Prefix = 0;
    u8 Code = 0;
    u32 Length = 0;
    u32 GpReg = 0;
    ptr RealAddress = 0;
    ptr ReturnAddress = NULL;

    struct {
        u8 Source : 3;
        u8 Destination : 3;
        u8 Mod : 2;
    }*ModRM;

    C_ASSERT(sizeof(*ModRM) == 1);

    struct DECLSPEC_ALIGN(1) {
        u8 Prefix;

        struct {
            u8 GpReg : 3;
            u8 Inst : 5;
        }Code;

        u8 RealAddress[8];

        u8 CopyPrefix;
        u8 CopyInst;

        struct {
            u8 Source : 3;
            u8 Destination : 3;
            u8 Mod : 2;
        }CopyMod;
    }*CopyOpCode;

    C_ASSERT(sizeof(*CopyOpCode) == 13);

    Instruction = Src;

    Prefix = Instruction[0];
    Code = Instruction[1];
    ModRM = &Instruction[2];

    Instruction += 3;

    if (0 == ModRM->Mod &&
        5 == ModRM->Source) {
        // [--][--]
        // [--][--] + disp8
        // [--][--] + disp32

        GpReg = ModRM->Destination;
        RealAddress = __rva_to_va(Instruction);

        if (NULL != Target) {
            *Target = NULL;
        }

        if (NULL != Extra) {
            *Extra += 6;
        }

        if (NULL != Dst && NULL != DstPool) {
            if ((u8ptr)*DstPool - (u8ptr)Dst >= sizeof(CopyOpCode)) {
                CopyOpCode = Dst;

                CopyOpCode->Prefix = Prefix;
                CopyOpCode->Code.Inst = 0x17; // Reg <- Immediate
                CopyOpCode->Code.GpReg = GpReg;

                *(ptr *)&CopyOpCode->RealAddress = RealAddress;

                CopyOpCode->CopyPrefix = Prefix;
                CopyOpCode->CopyInst = 0x8b; // Reg <- [Reg]
                CopyOpCode->CopyMod.Destination = GpReg;
                CopyOpCode->CopyMod.Source = GpReg;
                CopyOpCode->CopyMod.Mod = 0;
            }
        }

        ReturnAddress = Instruction + sizeof(s32);
    }

    return ReturnAddress;
}
#endif // _WIN64

#ifndef _WIN64
PPATCH_HEADER
NTAPI
HotpatchAttach(
    __inout ptr * Pointer,
    __in ptr Hotpatch
)
{
    PHOTPATCH_OBJECT HotpatchObjct = NULL;
    PHOTPATCH_BODY HotpatchBody = NULL;
    s32 Relative = 0;

    HotpatchObjct = GuardAllocateTrampoline(sizeof(HOTPATCH_OBJECT));

    if (NULL != HotpatchObjct) {
        RtlZeroMemory(HotpatchObjct, sizeof(HOTPATCH_OBJECT));

        HotpatchObjct->Header.Length = sizeof(HOTPATCH_OBJECT);

        HotpatchBody = CONTAINING_RECORD(
            *Pointer,
            HOTPATCH_BODY,
            JmpSelf);

        MapLockedCopyInstruction(
            &HotpatchBody->Jmp,
            HOTPATCH_BODY_CODE,
            HOTPATCH_BODY_CODE_LENGTH - HOTPATCH_MASK_LENGTH);

        Relative =
            PtrToLong(Hotpatch) - PtrToLong(&HotpatchBody->JmpSelf);

        MapLockedCopyInstruction(
            &HotpatchBody->Hotpatch,
            &Relative,
            sizeof(s32));

        MapLockedCopyInstruction(
            &HotpatchBody->JmpSelf,
            HOTPATCH_BODY_CODE + FIELD_OFFSET(HOTPATCH_BODY, JmpSelf),
            RTL_FIELD_SIZE(HOTPATCH_BODY, JmpSelf));

        HotpatchObjct->Header.Entry = HotpatchBody + 1;
        HotpatchObjct->Header.ProgramCounter = *Pointer;
        HotpatchObjct->Header.Target = Hotpatch;

        MapLockedCopyInstruction(
            Pointer,
            &HotpatchObjct->Header.Entry,
            sizeof(ptr));
    }

    return HotpatchObjct;
}

void
NTAPI
HotpatchDetach(
    __inout ptr * Pointer,
    __in PPATCH_HEADER PatchHeader,
    __in ptr Hotpatch
)
{
    PHOTPATCH_OBJECT HotpatchObjct = NULL;
    PHOTPATCH_BODY HotpatchBody = NULL;

    HotpatchObjct = CONTAINING_RECORD(
        PatchHeader,
        HOTPATCH_OBJECT,
        Header);

    HotpatchBody = CONTAINING_RECORD(
        HotpatchObjct->Header.ProgramCounter,
        HOTPATCH_BODY,
        JmpSelf);

    MapLockedCopyInstruction(
        &HotpatchBody->JmpSelf,
        HOTPATCH_MASK,
        HOTPATCH_MASK_LENGTH);

    MapLockedCopyInstruction(
        Pointer,
        &HotpatchObjct->Header.ProgramCounter,
        sizeof(ptr));

    GuardFreeTrampoline(HotpatchObjct, HotpatchObjct->Header.Length);
}
#endif // !_WIN64

PPATCH_HEADER
NTAPI
GuardAttach(
    __inout ptr * Pointer,
    __in ptr Guard
)
{
    PGUARD_OBJECT GuardObject = NULL;
    u8ptr GuardBody = NULL;
    u8ptr Import = NULL;
    ptr Address = NULL;
    u8ptr ControlPc = NULL;
    u8ptr TargetPc = NULL;
    u32 Length = 0;
    s32 Extra = 0;
    u8ptr Target = NULL;
    u32 BytesCopied = 0;
    u8ptr Header = NULL;
    u32 FunctionCount = 1;
    u32 CodeLength = 0;

#ifdef _WIN64
    u32 FunctionIndex = 1;
    u8ptr FunctionEntry = NULL;
    u32 Index = 0;
    u8ptr Instruction = NULL;
    u32 InstructionLength = 0;
    u8ptr RealAddress = NULL;
#endif // _WIN64

    struct {
        u8 B : 1;
        u8 X : 1;
        u8 R : 1;

        // 0 = Operand size determined by CS.D
        // 1 = 64 Bit Operand Size

        u8 W : 1;
        u8 Reserved : 4; // always 0100
    }*Rex;

    struct {
        u8 Source : 3;
        u8 Destination : 3;
        u8 Mod : 2;
    }*ModRM;

    C_ASSERT(sizeof(*ModRM) == 1);

    Address = *Pointer;
    *Pointer = NULL;

    ControlPc = Address;

    while (Length < GUARD_BODY_CODE_LENGTH) {
        TargetPc = DetourCopyInstruction(
            NULL,
            NULL,
            ControlPc,
            &Target,
            &Extra);

        if (NULL != TargetPc) {
#ifdef _WIN64
            if (7 == TargetPc - ControlPc) {
                Rex = ControlPc;

                if ((4 == Rex->Reserved && 1 == Rex->W) &&
                    0 == _cmpbyte(ControlPc[1], 0x8b)) {
                    ModRM = &ControlPc[2];

                    if (0 == ModRM->Mod &&
                        5 == ModRM->Source) {
                        // [--][--]
                        // [--][--] + disp8
                        // [--][--] + disp32

                        TargetPc = DisCopy8B(
                            NULL,
                            NULL,
                            ControlPc,
                            &Target,
                            &Extra);
                    }
                }
            }
#endif // _WIN64

#ifdef _WIN64
            if (NULL != Target) {
                FunctionCount++;
            }
#endif // _WIN64

            Length += TargetPc - ControlPc;
            CodeLength += TargetPc - ControlPc + Extra;

            if (Length >= GUARD_BODY_CODE_LENGTH) {
                GuardObject = GuardAllocateTrampoline(
                    sizeof(GUARD_OBJECT) +
                    Length +
                    CodeLength +
                    GUARD_BODY_CODE_LENGTH * FunctionCount);

                if (NULL != GuardObject) {
                    RtlZeroMemory(
                        GuardObject,
                        sizeof(GUARD_OBJECT)
                        + Length
                        + CodeLength
                        + GUARD_BODY_CODE_LENGTH * FunctionCount);

                    GuardObject->Header.Length = sizeof(GUARD_OBJECT)
                        + Length
                        + CodeLength
                        + GUARD_BODY_CODE_LENGTH * FunctionCount;

                    GuardObject->Original = GuardObject + 1;
                    GuardObject->Length = Length;

                    GuardBody = (u8ptr)GuardObject->Original + GuardObject->Length;
                    Import = GuardBody + CodeLength;

                    RtlCopyMemory(GuardObject->Original, Address, GuardObject->Length);

                    ControlPc = Address;
                    Length = 0;

                    while (Length < GUARD_BODY_CODE_LENGTH) {
                        TargetPc = DetourCopyInstruction(
                            GuardBody + BytesCopied,
                            &Import,
                            ControlPc,
                            &Target,
                            &Extra);

                        if (NULL != TargetPc) {
#ifdef _WIN64
                            if (7 == TargetPc - ControlPc) {
                                Rex = ControlPc;

                                if ((4 == Rex->Reserved && 1 == Rex->W) &&
                                    0 == _cmpbyte(ControlPc[1], 0x8b)) {
                                    ModRM = &ControlPc[2];

                                    if (0 == ModRM->Mod &&
                                        5 == ModRM->Source) {
                                        // [--][--]
                                        // [--][--] + disp8
                                        // [--][--] + disp32

                                        TargetPc = DisCopy8B(
                                            GuardBody + BytesCopied,
                                            &Import,
                                            ControlPc,
                                            &Target,
                                            &Extra);
                                    }
                                }
                            }
#endif // _WIN64

#ifdef _WIN64
                            if (NULL != Target) {
                                Instruction = GuardBody + BytesCopied;
                                InstructionLength = TargetPc - ControlPc + Extra;

                                FunctionEntry =
                                    Import + GUARD_BODY_CODE_LENGTH * FunctionIndex;

                                LockedBuildJumpCode(&FunctionEntry, Target);

                                for (Index = 0;
                                    Index <= InstructionLength - sizeof(s32);
                                    Index++) {
                                    RealAddress = __rva_to_va(Instruction + Index);

                                    if (*(s32ptr)&Target == *(s32ptr)&RealAddress) {
                                        *(s32ptr)(Instruction + Index) =
                                            FunctionEntry - ((Instruction + Index) + sizeof(s32));
                                    }
                                }

                                FunctionIndex++;
                            }
#endif // _WIN64

                            Length += TargetPc - ControlPc;
                            BytesCopied += TargetPc - ControlPc + Extra;

                            if (Length >= GUARD_BODY_CODE_LENGTH) {
                                LockedBuildJumpCode(&Import, TargetPc);
                                MapLockedBuildJumpCode(&Address, Guard);

                                GuardObject->Header.Entry = GuardBody;
                                GuardObject->Header.ProgramCounter = Address;
                                GuardObject->Header.Target = Guard;

                                LockedCopyInstruction(
                                    Pointer,
                                    &GuardObject->Header.Entry,
                                    sizeof(ptr));

                                break;
                            }

                            ControlPc = TargetPc;
                        }
                        else {
                            break;
                        }
                    }
                }

                break;
            }

            ControlPc = TargetPc;
        }
        else {
            break;
        }
    }

    return GuardObject;
}

void
NTAPI
GuardDetach(
    __inout ptr * Pointer,
    __in PPATCH_HEADER PatchHeader,
    __in ptr Guard
)
{
    PGUARD_OBJECT GuardObject = NULL;

    GuardObject = CONTAINING_RECORD(
        PatchHeader,
        GUARD_OBJECT,
        Header);

    if (PatchHeader->Target == Guard &&
        *Pointer == GuardObject->Header.Entry) {
        MapLockedCopyInstruction(
            GuardObject->Header.ProgramCounter,
            GuardObject->Original,
            GuardObject->Length);

        LockedCopyInstruction(
            Pointer,
            &GuardObject->Header.ProgramCounter,
            sizeof(ptr));

        GuardFreeTrampoline(GuardObject, GuardObject->Header.Length);
    }
}

PPATCH_HEADER
NTAPI
SafeGuardAttach(
    __inout ptr * Pointer,
    __in PGUARD_CALLBACK Callback,
    __in_opt ptr CaptureContext,
    __in_opt ptr Parameter,
    __in_opt ptr Reserved
)
{
    PSAFEGUARD_OBJECT GuardObject = NULL;
    u8ptr GuardBody = NULL;
    u8ptr Import = NULL;
    ptr Address = NULL;
    u8ptr ControlPc = NULL;
    u8ptr TargetPc = NULL;
    u32 Length = 0;
    s32 Extra = 0;
    u8ptr Target = NULL;
    u32 BytesCopied = 0;
    u8ptr Header = NULL;
    u32 FunctionCount = 1;
    u32 CodeLength = 0;

#ifdef _WIN64
    u32 FunctionIndex = 1;
    u8ptr FunctionEntry = NULL;
    u32 Index = 0;
    u8ptr Instruction = NULL;
    u32 InstructionLength = 0;
    u8ptr RealAddress = NULL;
#endif // _WIN64

    struct {
        u8 B : 1;
        u8 X : 1;
        u8 R : 1;

        // 0 = Operand size determined by CS.D
        // 1 = 64 Bit Operand Size

        u8 W : 1;
        u8 Reserved : 4; // always 0100
    }*Rex;

    struct {
        u8 Source : 3;
        u8 Destination : 3;
        u8 Mod : 2;
    }*ModRM;

    C_ASSERT(sizeof(*ModRM) == 1);

    Address = *Pointer;
    *Pointer = NULL;

    ControlPc = Address;

    while (Length < GUARD_BODY_CODE_LENGTH) {
        TargetPc = DetourCopyInstruction(
            NULL,
            NULL,
            ControlPc,
            &Target,
            &Extra);

        if (NULL != TargetPc) {
#ifdef _WIN64
            if (7 == TargetPc - ControlPc) {
                Rex = ControlPc;

                if ((4 == Rex->Reserved && 1 == Rex->W) &&
                    0 == _cmpbyte(ControlPc[1], 0x8b)) {
                    ModRM = &ControlPc[2];

                    if (0 == ModRM->Mod &&
                        5 == ModRM->Source) {
                        // [--][--]
                        // [--][--] + disp8
                        // [--][--] + disp32

                        TargetPc = DisCopy8B(
                            NULL,
                            NULL,
                            ControlPc,
                            &Target,
                            &Extra);
                    }
                }
            }
#endif // _WIN64

#ifdef _WIN64
            if (NULL != Target) {
                FunctionCount++;
            }
#endif // _WIN64

            Length += TargetPc - ControlPc;
            CodeLength += TargetPc - ControlPc + Extra;

            if (Length >= GUARD_BODY_CODE_LENGTH) {
                GuardObject = GuardAllocateTrampoline(
                    sizeof(SAFEGUARD_OBJECT) +
                    Length +
                    CodeLength +
                    GUARD_BODY_CODE_LENGTH * FunctionCount);

                if (NULL != GuardObject) {
                    RtlZeroMemory(
                        GuardObject,
                        sizeof(SAFEGUARD_OBJECT)
                        + Length
                        + CodeLength
                        + GUARD_BODY_CODE_LENGTH * FunctionCount);

                    GuardObject->Header.Length = sizeof(SAFEGUARD_OBJECT)
                        + Length
                        + CodeLength
                        + GUARD_BODY_CODE_LENGTH * FunctionCount;

                    GuardObject->Original = GuardObject + 1;
                    GuardObject->Length = Length;

                    GuardBody = (u8ptr)GuardObject->Original + GuardObject->Length;
                    Import = GuardBody + CodeLength;

                    RtlCopyMemory(GuardObject->Original, Address, GuardObject->Length);

                    ControlPc = Address;
                    Length = 0;

                    while (Length < GUARD_BODY_CODE_LENGTH) {
                        TargetPc = DetourCopyInstruction(
                            GuardBody + BytesCopied,
                            &Import,
                            ControlPc,
                            &Target,
                            &Extra);

                        if (NULL != TargetPc) {
#ifdef _WIN64
                            if (7 == TargetPc - ControlPc) {
                                Rex = ControlPc;

                                if ((4 == Rex->Reserved && 1 == Rex->W) &&
                                    0 == _cmpbyte(ControlPc[1], 0x8b)) {
                                    ModRM = &ControlPc[2];

                                    if (0 == ModRM->Mod &&
                                        5 == ModRM->Source) {
                                        // [--][--]
                                        // [--][--] + disp8
                                        // [--][--] + disp32

                                        TargetPc = DisCopy8B(
                                            GuardBody + BytesCopied,
                                            &Import,
                                            ControlPc,
                                            &Target,
                                            &Extra);
                                    }
                                }
                            }
#endif // _WIN64

#ifdef _WIN64
                            if (NULL != Target) {
                                Instruction = GuardBody + BytesCopied;
                                InstructionLength = TargetPc - ControlPc + Extra;

                                FunctionEntry =
                                    Import + GUARD_BODY_CODE_LENGTH * FunctionIndex;

                                LockedBuildJumpCode(&FunctionEntry, Target);

                                for (Index = 0;
                                    Index <= InstructionLength - sizeof(s32);
                                    Index++) {
                                    RealAddress = __rva_to_va(Instruction + Index);

                                    if (*(s32ptr)&Target == *(s32ptr)&RealAddress) {
                                        *(s32ptr)(Instruction + Index) =
                                            FunctionEntry - ((Instruction + Index) + sizeof(s32));
                                    }
                                }

                                FunctionIndex++;
                            }
#endif // _WIN64

                            Length += TargetPc - ControlPc;
                            BytesCopied += TargetPc - ControlPc + Extra;

                            if (Length >= GUARD_BODY_CODE_LENGTH) {
                                LockedBuildJumpCode(&Import, TargetPc);

                                CaptureContext =
                                    NULL == CaptureContext ?
                                    _CaptureContext : CaptureContext;

                                SetStackBody(
                                    &GuardObject->Body,
                                    Reserved,
                                    Parameter,
                                    Callback,
                                    GuardBody,
                                    Address,
                                    CaptureContext);

                                MapLockedBuildJumpCode(&Address, &GuardObject->Body);

                                GuardObject->Header.Entry = GuardBody;
                                GuardObject->Header.ProgramCounter = Address;
                                GuardObject->Header.Target = Callback;

                                LockedCopyInstruction(
                                    Pointer,
                                    &GuardObject->Header.Entry,
                                    sizeof(ptr));

                                break;
                            }

                            ControlPc = TargetPc;
                        }
                        else {
                            break;
                        }
                    }
                }

                break;
            }

            ControlPc = TargetPc;
        }
        else {
            break;
        }
    }

    return GuardObject;
}

void
NTAPI
SafeGuardDetach(
    __inout ptr * Pointer,
    __in PPATCH_HEADER PatchHeader,
    __in PGUARD_CALLBACK Callback
)
{
    PSAFEGUARD_OBJECT GuardObject = NULL;

    GuardObject = CONTAINING_RECORD(
        PatchHeader,
        SAFEGUARD_OBJECT,
        Header);

    if (PatchHeader->Target == Callback &&
        *Pointer == GuardObject->Header.Entry) {
        MapLockedCopyInstruction(
            GuardObject->Header.ProgramCounter,
            GuardObject->Original,
            GuardObject->Length);

        LockedCopyInstruction(
            Pointer,
            &GuardObject->Header.ProgramCounter,
            sizeof(ptr));

        GuardFreeTrampoline(GuardObject, GuardObject->Header.Length);
    }
}

```

`Guard.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _GUARD_H_
#define _GUARD_H_

#include <guarddefs.h>

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

    //////////////////////////////////////////////////////////////////////////////
    //
    //  Function:
    //      DetourCopyInstruction(ptr pDst,
    //                            ptr *ppDstPool
    //                            ptr pSrc,
    //                            ptr *ppTarget,
    //                            s32 *plExtra)
    //  Purpose:
    //      Copy a single instruction from pSrc to pDst.
    //
    //  Arguments:
    //      pDst:
    //          Destination address for the instruction.  May be NULL in which
    //          case DetourCopyInstruction is used to measure an instruction.
    //          If not NULL then the source instruction is copied to the
    //          destination instruction and any relative arguments are adjusted.
    //      ppDstPool:
    //          Destination address for the end of the constant pool.  The
    //          constant pool works backwards toward pDst.  All memory between
    //          pDst and *ppDstPool must be available for use by this function.
    //          ppDstPool may be NULL if pDst is NULL.
    //      pSrc:
    //          Source address of the instruction.
    //      ppTarget:
    //          Out parameter for any target instruction address pointed to by
    //          the instruction.  For example, a branch or a jump insruction has
    //          a target, but a load or store instruction doesn't.  A target is
    //          another instruction that may be executed as a result of this
    //          instruction.  ppTarget may be NULL.
    //      plExtra:
    //          Out parameter for the number of extra bytes needed by the
    //          instruction to reach the target.  For example, lExtra = 3 if the
    //          instruction had an 8-bit relative offset, but needs a 32-bit
    //          relative offset.
    //
    //  Returns:
    //      Returns the address of the next instruction (following in the source)
    //      instruction.  By subtracting pSrc from the return value, the caller
    //      can determinte the size of the instruction copied.
    //
    //  Comments:
    //      By following the pTarget, the caller can follow alternate
    //      instruction streams.  However, it is not always possible to determine
    //      the target based on static analysis.  For example, the destination of
    //      a jump relative to a register cannot be determined from just the
    //      instruction stream.  The output value, pTarget, can have any of the
    //      following outputs:
    //          DETOUR_INSTRUCTION_TARGET_NONE:
    //              The instruction has no targets.
    //          DETOUR_INSTRUCTION_TARGET_DYNAMIC:
    //              The instruction has a non-deterministic (dynamic) target.
    //              (i.e. the jump is to an address held in a register.)
    //          Address:   The instruction has the specified target.
    //
    //      When copying instructions, DetourCopyInstruction insures that any
    //      targets remain constant.  It does so by adjusting any IP relative
    //      offsets.
    //
    //////////////////////////////////////////////////////////////////////////////

    ptr
        NTAPI
        DetourCopyInstruction(
            __in_opt ptr pDst,
            __in_opt ptr * ppDstPool,
            __in ptr pSrc,
            __out_opt ptr * ppTarget,
            __out s32 * plExtra
        );

    DECLSPEC_NORETURN
        void
        NTAPI
        _CaptureContext(
            __in u32 ProgramCounter,
            __in ptr Guard,
            __in PGUARD_CALLBACK Callback,
            __in_opt ptr Parameter,
            __in_opt ptr Reserved
        );

    void
        NTAPI
        MapLockedCopyInstruction(
            __in ptr Destination,
            __in ptr Source,
            __in u32 Length
        );

    void
        NTAPI
        MapLockedBuildJumpCode(
            __inout ptr * Pointer,
            __in ptr Guard
        );

    void
        NTAPI
        LockedCopyInstruction(
            __in ptr Destination,
            __in ptr Source,
            __in u32 Length
        );

    void
        NTAPI
        LockedBuildJumpCode(
            __inout ptr * Pointer,
            __in ptr Guard
        );

    void
        NTAPI
        BuildJumpCode(
            __inout ptr * Pointer,
            __in ptr Guard
        );

#ifndef _WIN64
    PPATCH_HEADER
        NTAPI
        HotpatchAttach(
            __inout ptr * Pointer,
            __in ptr Hotpatch
        );

    void
        NTAPI
        HotpatchDetach(
            __inout ptr * Pointer,
            __in PPATCH_HEADER PatchHeader,
            __in ptr Hotpatch
        );
#endif // !_WIN64

    PPATCH_HEADER
        NTAPI
        GuardAttach(
            __inout ptr * Pointer,
            __in ptr Guard
        );

    void
        NTAPI
        GuardDetach(
            __inout ptr * Pointer,
            __in PPATCH_HEADER PatchHeader,
            __in ptr Guard
        );

    PPATCH_HEADER
        NTAPI
        SafeGuardAttach(
            __inout ptr * Pointer,
            __in PGUARD_CALLBACK Callback,
            __in_opt ptr CaptureContext,
            __in_opt ptr Parameter,
            __in_opt ptr Reserved
        );

    void
        NTAPI
        SafeGuardDetach(
            __inout ptr * Pointer,
            __in PPATCH_HEADER PatchHeader,
            __in PGUARD_CALLBACK Callback
        );

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_GUARD_H_

```

`Makefile`:

```
#
#
# Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
#
# The contents of this file are subject to the Mozilla Public License Version
# 2.0 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
# for the specific language governing rights and limitations under the
# License.
#
# The Initial Developer of the Original Code is blindtiger.
#
#

LABS=..\..\..

!if "$(PLATFORM)" == "x86"
ARCTARG = I386
!if "$(PROCESSOR_ARCHITEW6432)" == "AMD64"
PATH = C:\Windows;C:\Windows\System32;$(LABS)\MiniSDK\bin\Hostx64\x86
!else
PATH = C:\Windows;C:\Windows\System32;$(LABS)\MiniSDK\bin\Hostx86\x86
!endif
!else if "$(PLATFORM)" == "x64"
ARCTARG = AMD64
!if "$(PROCESSOR_ARCHITEW6432)" == "AMD64"
PATH = C:\Windows;C:\Windows\System32;$(LABS)\MiniSDK\bin\Hostx64\x64
!else
PATH = C:\Windows;C:\Windows\System32;$(LABS)\MiniSDK\bin\Hostx86\x64
!endif
!else
!ERROR Usage: nmake (PLATFORM=x86|x64) (PROJ=ProjectName) (SLND=SolutionDir) [build|clean|rebuild]
!endif

BIND = $(SLND)Build\Bins\$(ARCTARG)

PROJTARG = $(BIND)\$(PROJ)
PROJD = $(SLND)Projects\$(PROJ)

BUILD: $(PROJTARG).sys

OBJD = $(SLND)Build\Objs\$(PROJ)\$(ARCTARG)
                           
PROJENTRY = __security_init_cookie

ASOBJS = \
    $(OBJD)\$(ARCTARG).obj \
    $(OBJD)\Cmp$(ARCTARG).obj

CCARCHOBJS = \
    $(OBJD)\Context$(ARCTARG).obj \
    $(OBJD)\Except$(ARCTARG).obj \
    $(OBJD)\PatchGuard$(ARCTARG).obj \
    $(OBJD)\Space$(ARCTARG).obj \
    $(OBJD)\Stack$(ARCTARG).obj

CCOBJS = \
    $(OBJD)\$(PROJ).obj \
    $(OBJD)\Ctx.obj \
    $(OBJD)\Guard.obj \
    $(OBJD)\Except.obj \
    $(OBJD)\PatchGuard.obj \
    $(OBJD)\Reload.obj \
    $(OBJD)\Rtx.obj \
    $(OBJD)\Scan.obj \
    $(OBJD)\Space.obj \
    $(OBJD)\Stack.obj
    
RCOBJS = $(OBJD)\$(PROJ).res

PROJOBJS = $(ASOBJS) $(CCARCHOBJS) $(CCOBJS) $(RCOBJS)

!if "$(ARCTARG)" == "I386"
TARGDEFS = /D_X86_=1 /Di386=1 /DSTD_CALL /DFPO=0 /DDOSWIN32 /DDETOURS_X86 /DDETOURS_32BIT
TARGAOPTS = /safeseh /coff /Zm
TARGCOPTS = /Gz /Gm- /EHs-c- /Od /Oy-
TARGLOPTS = 
HOTPATCH = /stub:$(LABS)\WRK\base\ntos\BUILD\PREBUILT\$(ARCTARG)\STUB512.com
ARCH = X86
ARCHML = ml
!else if "$(ARCTARG)" == "AMD64"
TARGDEFS = /D_WIN64 /D_AMD64_ /DAMD64 /DDETOURS_X64 /DDETOURS_64BIT
TARGAOPTS = 
TARGCOPTS = /Od /EHs-c- /Gs12288
TARGLOPTS = /IGNORE:4108,4088,4218,4218,4235
HOTPATCH = $(LABS)\WRK\base\ntos\BUILD\PREBUILT\$(ARCTARG)\HOTPATCH.obj
ARCH = AMD64
ARCHML = ml64
!endif

PROJLOPTS = /SUBSYSTEM:NATIVE /ENTRY:$(PROJENTRY) /DEF:$(PROJ).def

INCS = \
    /I$(LABS)\MiniSDK\inc\ddk \
    /I$(LABS)\MiniSDK\inc\halkit \
    /I$(LABS)\MiniSDK\inc\internal\base \
    /I$(LABS)\MiniSDK\inc\internal\ds \
    /I$(LABS)\MiniSDK\inc\internal\sdktools \
    /I$(LABS)\MiniSDK\inc\sdk \
    /I$(LABS)\MiniSDK\inc\sdk\crt \
    /I$(LABS)\MiniSDK\inc\sdk\crt\gl \
    /I$(LABS)\MiniSDK\inc\sdk\crt\sys \
    /I$(LABS)\MiniSDK\inc\base \
    /I$(LABS)\MiniSDK\inc\base\ntos \
    /I$(LABS)\MiniSDK\inc\base\ntos\VERIFIER \
    /I$(SLND)\Include \
    /I$(PROJD)

DEFS = /DUNICODE /D_UNICODE $(TARGDEFS) /DCONDITION_HANDLING=1 /DNT_INST=0 /DWIN32=100 /D_NT1X_=100 /DWINNT=1 \
    /DDEVL=1 /DNDEBUG /D_NTSYSTEM_ /DNT_SMT /DNTOS_KERNEL_RUNTIME=1 /D_NTDRIVER_

COPTS = /Z7 /Zl /Zp8 /Gy /cbstring /W3 /WX /GR- /GF /GS $(TARGCOPTS)
COMPILERWARNINGS = /FI$(LABS)\WRK\base\ntos\BUILD\WARNING.h /FI$(SLND)\Include\WARNING.h

AOPTS = /Cx /Zi /Zd $(TARGAOPTS)
AS = $(ARCHML).exe /nologo
AFLAGS = $(AOPTS) $(INCS) /Fo$(OBJD)\ $(DEFS) $(SPECIALAFLAGS)

CC = cl.exe /nologo
CFLAGS = $(COPTS) $(INCS) /Fo$(OBJD)\ $(DEFS) $(SPECIALCFLAGS) $(COMPILERWARNINGS)

RC = rc.exe /nologo
RFLAGS = $(INCS) /fo$(RCOBJS)
                  
LINKLIBPATH = \
    /LIBPATH:$(LABS)\MiniSDK\lib\$(ARCTARG) \
    /LIBPATH:$(LABS)\MiniSDK\lib\Crt\$(ARCTARG) \
    /LIBPATH:$(SLND)\Lib\$(ARCTARG)

LINKIGNORE = /IGNORE:4087,4001,4010,4037,4039,4065,4070,4078,4087,4089,4221,4198
BUILDLIBS = hal.lib ntoskrnl.lib bufferoverflowk.lib \
!if "$(ARCTARG)" == "I386"
    \
!else if "$(ARCTARG)" == "AMD64"
    gshandler.obj gshandlerseh.obj \
!endif
    disasm.obj detours.obj

LINK = link.exe /nologo
LINKFLAGS = $(LINKIGNORE) /WX /NODEFAULTLIB /machine:$(ARCH) /debug /debugtype:cv,fixup

LINKPROJNAMES = /out:$(PROJTARG).sys /map:$(PROJTARG).map /pdb:$(PROJTARG).pdb

$(PROJTARG).sys: $(PROJOBJS)
    @$(LINK) $(LINKFLAGS) $(PROJLOPTS) $(LINKPROJNAMES) $** $(HOTPATCH) $(LINKLIBPATH) $(BUILDLIBS)

# assembly files
{$(ARCTARG)\}.asm{$(OBJD)\}.obj::
    @$(AS) $(AFLAGS) /c $<

# arch-specific C files
{$(ARCTARG)\}.c{$(OBJD)\}.obj::
    @$(CC) $(CFLAGS) /c $<

# C files
.c{$(OBJD)\}.obj::
    @$(CC) $(CFLAGS) /c $<
    
# RC files
.rc{$(OBJD)\}.res::
    @$(RC) $(RFLAGS) $<

# CLEAN pseudo targets

CLEAN:
    @if exist $(OBJD)\*.res del /F /Q $(OBJD)\*.res
    @if exist $(OBJD)\*.obj del /F /Q $(OBJD)\*.obj
    @if exist $(PROJTARG).exe del /F /Q $(PROJTARG).exe
    @if exist $(PROJTARG).sys del /F /Q $(PROJTARG).sys
    @if exist $(PROJTARG).dll del /F /Q $(PROJTARG).dll
    @if exist $(PROJTARG).lib del /F /Q $(PROJTARG).lib
    @if exist $(PROJTARG).simg del /F /Q $(PROJTARG).simg
    @if exist $(PROJTARG).exp del /F /Q $(PROJTARG).exp
    @if exist $(PROJTARG).map del /F /Q $(PROJTARG).map
    @if exist $(PROJTARG).pdb del /F /Q $(PROJTARG).pdb

REBUILD: CLEAN BUILD

```

`PatchGuard.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "PatchGuard.h"


```

`PatchGuard.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _PATCHGUARD_H_
#define _PATCHGUARD_H_

#include "..\..\WRK\base\ntos\mm\mi.h"

#include "Guard.h"
#include "Reload.h"

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

#define POOL_BIG_TABLE_ENTRY_FREE 0x1

    typedef struct _POOL_BIG_PAGES {
        ptr Va;
        u32 Key;
        u32 PoolType;
        u NumberOfPages;
    } POOL_BIG_PAGES, *PPOOL_BIG_PAGES;

#ifdef _WIN64                                           
    C_ASSERT(sizeof(POOL_BIG_PAGES) == sizeof(u) * 3);
#endif // _WIN64

    typedef struct _POOL_BIG_PAGESEX {
        ptr Va;
        u32 Key;
        u32 PoolType;
        u NumberOfPages;
        u Unuse;
    } POOL_BIG_PAGESEX, *PPOOL_BIG_PAGESEX;

#ifdef _WIN64                                       
    C_ASSERT(sizeof(POOL_BIG_PAGES) == sizeof(u) * 3);
#endif // _WIN64

    enum {
        PgPoolBigPage,
        PgSystemPtes,
        PgMaximumType
    };

    enum {
        PgDeclassified,
        PgEncrypted,
        PgDoubleEncrypted
    };

    typedef struct _PGOBJECT {
        LIST_ENTRY Entry;
        WORK_QUEUE_ITEM Worker;
        b Encrypted;
        u64 Key;
        uptr Context;
        u ContextSize;
        u8 Type;
        ptr BaseAddress;
        u RegionSize;
        SAFEGUARD_BODY Body;
    }PGOBJECT, *PPGOBJECT;

    // build number > 20000
    typedef enum _MI_SYSTEM_VA_TYPE {
        MiVaUnused = 0,
        MiVaSessionSpace = 1,
        MiVaProcessSpace = 2,
        MiVaBootLoaded = 3,
        MiVaPfnDatabase = 4,
        MiVaNonPagedPool = 5,
        MiVaPagedPool = 6,
        MiVaSpecialPoolPaged = 7,
        MiVaSystemCache = 8,
        MiVaSystemPtes = 9,
        MiVaHal = 10,
        MiVaSessionGlobalSpace = 11,
        MiVaDriverImages = 12,
        MiVaSystemPtesLarge = 13,
        MiVaKernelStacks = 14,
        MiVaSecureNonPagedPool = 15,
        MiVaKernelShadowStacks = 16,
        MiVaMaximumType
    }MI_SYSTEM_VA_TYPE, *PMI_SYSTEM_VA_TYPE;

    typedef struct _PGBLOCK {
        struct _RTB * RtBlock;

#define GetRtBlock(pgb) (pgb->RtBlock)

#define PG_MAXIMUM_CONTEXT_COUNT 0x00000003UI32 // The maximum number of context that may exist
#define PG_FIRST_FIELD_OFFSET 0x00000100UI32 // offset of the first context member used by the search
#define PG_CMP_APPEND_DLL_SECTION_END 0x000000c0UI32 // CmpAppendDllSection length
#define PG_COMPARE_FIELDS_COUNT 0x00000004UI32 // number of context members compared during search
#define PG_COMPARE_BYTE_COUNT 0x00000010UI32 // number of bytes compared when searching for workers

        // EntryPoint cache size used to search the code fragment of the header 
        // (minimum length = max(2 * 8 + 7, sizeof(GUARD_BODY)))
#define PG_MAXIMUM_EP_BUFFER_COUNT ((max(2 * 8 + 7, sizeof(GUARD_BODY)) + 7) & ~7)

#define PG_FIELD_BITS \
            ((u32)((((PG_FIRST_FIELD_OFFSET + PG_COMPARE_FIELDS_COUNT * sizeof(ptr)) \
                - PG_CMP_APPEND_DLL_SECTION_END) / sizeof(ptr)) - 1))

        struct {
            u8 Count : 3;
            b BtcEnable : 1;
            b IsDebug : 1;
        };

        u32 OffsetEntryPoint;
        u32 SizeCmpAppendDllSection;
        u32 SizeINITKDBG;
        ptr INITKDBG;
        s32 BuildKey;
        s32 BranchKey[12];

        uptr OriginalCmpAppendDllSection;
        uptr CacheCmpAppendDllSection;

        uptr KiWaitNever;
        uptr KiWaitAlways;

        struct {
            union {
                PPOOL_BIG_PAGES * PoolBigPageTable;
                PPOOL_BIG_PAGESEX * PoolBigPageTableEx;
            };

            uptr PoolBigPageTableSize;

            b
            (NTAPI * MmIsNonPagedSystemAddressValid)(
                __in ptr VirtualAddress
                );
        }Pool; // pool big page

        struct {
            u NumberOfPtes;
            PMMPTE BasePte;
        }SystemPtes; // system ptes       

        struct {
            ptr WorkerContext;

            void
            (NTAPI * ExpWorkerThread)(
                __in ptr StartContext
                );

            void
            (NTAPI * PspSystemThreadStartup)(
                __in PKSTART_ROUTINE StartRoutine,
                __in ptr StartContext
                );

            void
            (NTAPI * KiStartSystemThread)(
                void
                );

            u32 OffsetSameThreadPassive;
            u32 OffsetExpWorkerThreadReturn;
            ptr ExpWorkerThreadReturn;

            struct {
                u64 BeginAddress;
                u64 EndAddress;
            } KiScbQueueScanWorker;
        }; // restart ExpWorkerThread

        ptr
        (NTAPI * MmAllocateIndependentPages)(
            __in u NumberOfBytes,
            __in u32 Node
            );

        void
        (NTAPI * MmFreeIndependentPages)(
            __in ptr VirtualAddress,
            __in u NumberOfBytes
            );

        b
        (NTAPI * MmSetPageProtection)(
            __in_bcount(NumberOfBytes) ptr VirtualAddress,
            __in u NumberOfBytes,
            __in u32 NewProtect
            );

        b
        (NTAPI * MmIsAddressValid)(
            __in ptr VirtualAddress
            );

        ptr
        (NTAPI * RtlLookupFunctionEntry)(
            __in u64 ControlPc,
            __out u64ptr ImageBase,
            __inout_opt ptr HistoryTable
            );

        PEXCEPTION_ROUTINE
        (NTAPI * RtlVirtualUnwind)(
            __in u32 HandlerType,
            __in u64 ImageBase,
            __in u64 ControlPc,
            __in ptr FunctionEntry,
            __inout PCONTEXT ContextRecord,
            __out ptr * HandlerData,
            __out u64ptr EstablisherFrame,
            __inout_opt ptr ContextPointers
            );

        void
        (NTAPI * ExQueueWorkItem)(
            __inout PWORK_QUEUE_ITEM WorkItem,
            __in WORK_QUEUE_TYPE QueueType
            );

        void
        (NTAPI * FreeWorker)(
            __in struct _PGOBJECT * Object
            );

        void
        (NTAPI * ClearCallback)(
            __in PCONTEXT Context,
            __in_opt ptr ProgramCounter,
            __in_opt ptr Parameter,
            __in_opt ptr Reserved
            );

        u
        (FASTCALL * CmpDecode)(
            __in u Value,
            __in u8 Count
            );

        u
        (FASTCALL * Ror64)(
            __in u Value,
            __in u8 Count
            );

        u
        (FASTCALL * Rol64)(
            __in u Value,
            __in u8 Count
            );

        u64
        (FASTCALL *  RorWithBtc64)(
            __in u64 Value,
            __in u64 Count
            );

        void
        (NTAPI * CaptureContext)(
            __in u32 ProgramCounter,
            __in ptr Guard,
            __in ptr Stack,
            __in_opt ptr Parameter,
            __in_opt ptr Reserved
            );

        u
        (FASTCALL * PostCache)(
            __in u Index,
            __in ptr Context
            );

        u
        (FASTCALL * PostKey)(
            __in u Index,
            __in u Original
            );

        cptr ClearMessage[3];

        LIST_ENTRY Object;
        KSPIN_LOCK Lock;

        u64 Fields[PG_COMPARE_FIELDS_COUNT];
        u8 Header[PG_MAXIMUM_EP_BUFFER_COUNT];
        u8 _Ror64[8];
        u8 _Rol64[8];
        u8 _RorWithBtc64[16];
        u8 _PostCache[16];
        u8 _PostKey[64];

#ifndef _WIN64
        u8 _CaptureContext[0x100];
#else
        u8 _CaptureContext[0x200];
#endif // !_WIN64

        u8 _ClearMessage[0x120];
        u8 _FreeWorker[0xB0];
        u8 _ClearCallback[0x380];

        u8 _OriginalCmpAppendDllSection[0xC8];
        u8 _CacheCmpAppendDllSection[0xC8];
    }PGBLOCK, *PPGBLOCK;

    void
        NTAPI
        PgClear(
            __inout PPGBLOCK Block
        );

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_PATCHGUARD_H_

```

`Reload.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Reload.h"

#include "Ctx.h"
#include "Guard.h"
#include "Except.h"
#include "Scan.h"

void
NTAPI
InitializeGpBlock(
    __in PRTB Rtb
)
{
    PKLDR_DATA_TABLE_ENTRY DataTableEntry = NULL;
    PIMAGE_SECTION_HEADER NtSection = NULL;
    PCHAR SectionBase = NULL;
    u32 SizeToLock = 0;
    u8ptr ControlPc = NULL;
    PDUMP_HEADER DumpHeader = NULL;
    PKDDEBUGGER_DATA64 KdDebuggerDataBlock = NULL;
    PKDDEBUGGER_DATA_ADDITION64 KdDebuggerDataAdditionBlock = NULL;
    ptr RoutineAddress = NULL;
    PLIST_ENTRY ActiveProcessEntry = NULL;
    s32 Number = -1;
    u8ptr TargetPc = NULL;
    u32 FirstLength = 0;
    u32 Length = 0;
    CONTEXT Context = { 0 };
    UNICODE_STRING String = { 0 };

#ifndef _WIN64
    // 6A 01                            push 1
    // 68 A0 D7 69 00                   push offset _PsLoadedModuleResource
    // E8 FB E4 E9 FF                   call _ExAcquireResourceSharedLite@8

    u8 PsLoadedModuleResource[] = "6A 01 68 ?? ?? ?? ?? E8";

    // 8B DA                            mov ebx, edx
    // F6 05 C8 E0 52 00 40             test byte ptr ds:dword_52E0C8, 40h
    // 0F 95 45 12                      setnz byte ptr [ebp + 12h]
    // 0F 85 8C 03 00 00                jnz loc_435C04
    // FF D3                            call ebx

    u8 PerfGlobalGroupMask[] =
        "8B DA F6 05 ?? ?? ?? ?? 40 0F 95 45 ?? 0F 85 ?? ?? ?? ?? FF D3";
#else
    // 48 89 A3 D8 01 00 00             mov [rbx + 1D8h], rsp
    // 8B F8                            mov edi, eax
    // C1 EF 07                         shr edi, 7
    // 83 E7 20                         and edi, 20h
    // 25 FF 0F 00 00                   and eax, 0FFFh
    // 4C 8D 15 C7 20 23 00             lea r10, KeServiceDescriptorTable
    // 4C 8D 1D 00 21 23 00             lea r11, KeServiceDescriptorTableShadow

    u8 KiSystemCall64[] =
        "48 89 A3 ?? ?? ?? ?? 8B F8 C1 EF 07 83 E7 20 25 FF 0F 00 00 4C 8D 15 ?? ?? ?? ?? 4C 8D 1D";

    // F7 05 3E C0 2D 00 40 00 00 00    test dword ptr cs:PerfGlobalGroupMask + 8, 40h
    // 0F 85 56 02 00 00                jnz loc_14007A2A6
    // 41 FF D2                         call r10

    u8 PerfGlobalGroupMask[] =
        "F7 05 ?? ?? ?? ?? 40 00 00 00 0F 85";

    // 48 8D 0D FD DA 19 00             rcx, PsLoadedModuleResource
    // E8 B8 B8 E3 FF call              ExReleaseResourceLite

    u8 PsLoadedModuleResource[] = "48 8D 0D ?? ?? ?? ?? E8";
#endif // !_WIN64

    Rtb->Linkage[0] = 0x33;
    Rtb->Linkage[1] = 0xc0;
    Rtb->Linkage[2] = 0xc3;

    PsGetVersion(NULL, NULL, &Rtb->BuildNumber, NULL);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > BuildNumber\n",
            Rtb->BuildNumber);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"PsInitialSystemProcess");

    RoutineAddress = MmGetSystemRoutineAddress(&String);

    RtlCopyMemory(
        &Rtb->PsInitialSystemProcess,
        RoutineAddress,
        sizeof(ptr));

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > PsInitialSystemProcess\n",
            Rtb->PsInitialSystemProcess);
#endif // DEBUG                              
    }

    RtlInitUnicodeString(&String, L"KeNumberProcessors");

    RoutineAddress = MmGetSystemRoutineAddress(&String);

    RtlCopyMemory(
        &Rtb->NumberProcessors,
        RoutineAddress,
        sizeof(u8));

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > NumberProcessors\n",
            Rtb->NumberProcessors);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"KeEnterCriticalRegion");

    Rtb->KeEnterCriticalRegion = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > KeEnterCriticalRegion\n",
            Rtb->KeEnterCriticalRegion);
#endif // DEBUG                              
    }

    RtlInitUnicodeString(&String, L"KeLeaveCriticalRegion");

    Rtb->KeLeaveCriticalRegion = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > KeLeaveCriticalRegion\n",
            Rtb->KeLeaveCriticalRegion);
#endif // DEBUG              
    }

    RtlInitUnicodeString(&String, L"ExAcquireSpinLockShared");

    Rtb->ExAcquireSpinLockShared = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > ExAcquireSpinLockShared\n",
            Rtb->ExAcquireSpinLockShared);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"ExReleaseSpinLockShared");

    Rtb->ExReleaseSpinLockShared = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > ExReleaseSpinLockShared\n",
            Rtb->ExReleaseSpinLockShared);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"DbgPrint");

    Rtb->DbgPrint = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > DbgPrint\n",
            Rtb->DbgPrint);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"KeWaitForSingleObject");

    Rtb->KeWaitForSingleObject = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > KeWaitForSingleObject\n",
            Rtb->KeWaitForSingleObject);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"RtlCompareMemory");

    Rtb->RtlCompareMemory = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > RtlCompareMemory\n",
            Rtb->RtlCompareMemory);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"RtlRestoreContext");

    Rtb->RtlRestoreContext = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > RtlRestoreContext\n",
            Rtb->RtlRestoreContext);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"ExQueueWorkItem");

    Rtb->ExQueueWorkItem = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > ExQueueWorkItem\n",
            Rtb->ExQueueWorkItem);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"ExFreePoolWithTag");

    Rtb->ExFreePoolWithTag = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > ExFreePoolWithTag\n",
            Rtb->ExFreePoolWithTag);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"KeBugCheckEx");

    Rtb->KeBugCheckEx = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > KeBugCheckEx\n",
            Rtb->KeBugCheckEx);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"ExInterlockedRemoveHeadList");

    Rtb->ExInterlockedRemoveHeadList = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > ExInterlockedRemoveHeadList\n",
            Rtb->ExInterlockedRemoveHeadList);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"ExAcquireRundownProtection");

    Rtb->ExAcquireRundownProtection = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > ExAcquireRundownProtection\n",
            Rtb->ExAcquireRundownProtection);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"ExReleaseRundownProtection");

    Rtb->ExReleaseRundownProtection = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > ExReleaseRundownProtection\n",
            Rtb->ExReleaseRundownProtection);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"ExWaitForRundownProtectionRelease");

    Rtb->ExWaitForRundownProtectionRelease = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > ExWaitForRundownProtectionRelease\n",
            Rtb->ExWaitForRundownProtectionRelease);
#endif // DEBUG
    }

    Context.ContextFlags = CONTEXT_FULL;

    RtlCaptureContext(&Context);

    DumpHeader = __malloc(DUMP_BLOCK_SIZE);

    if (NULL != DumpHeader) {
        KeCapturePersistentThreadState(
            &Context,
            NULL,
            0,
            0,
            0,
            0,
            0,
            DumpHeader);

        KdDebuggerDataBlock = (u8ptr)DumpHeader + KDDEBUGGER_DATA_OFFSET;

        RtlCopyMemory(
            &Rtb->DebuggerDataBlock,
            KdDebuggerDataBlock,
            sizeof(KDDEBUGGER_DATA64));

        KdDebuggerDataAdditionBlock = (PKDDEBUGGER_DATA_ADDITION64)(KdDebuggerDataBlock + 1);

        RtlCopyMemory(
            &Rtb->DebuggerDataAdditionBlock,
            KdDebuggerDataAdditionBlock,
            sizeof(KDDEBUGGER_DATA_ADDITION64));

        Rtb->PsLoadedModuleList =
            (PLIST_ENTRY)Rtb->DebuggerDataBlock.PsLoadedModuleList;

        Rtb->KernelDataTableEntry = CONTAINING_RECORD(
            Rtb->PsLoadedModuleList->Flink,
            KLDR_DATA_TABLE_ENTRY,
            InLoadOrderLinks);

        if (CmdReload !=
            (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
            /// vDbgPrint("[SHARK] < %p > Header\n", KdDebuggerDataBlock->Header);
            //vDbgPrint("[SHARK] < %p > KernBase\n", KdDebuggerDataBlock->KernBase);
            /// vDbgPrint("[SHARK] < %p > BreakpointWithStatus\n", KdDebuggerDataBlock->BreakpointWithStatus);
            /// vDbgPrint("[SHARK] < %p > SavedContext\n", KdDebuggerDataBlock->SavedContext);
            /// vDbgPrint("[SHARK] < %p > ThCallbackStack\n", KdDebuggerDataBlock->ThCallbackStack);
            /// vDbgPrint("[SHARK] < %p > NextCallback\n", KdDebuggerDataBlock->NextCallback);
            /// vDbgPrint("[SHARK] < %p > FramePointer\n", KdDebuggerDataBlock->FramePointer);
            // vDbgPrint("[SHARK] < %p > PaeEnabled\n", KdDebuggerDataBlock->PaeEnabled);
            /// vDbgPrint("[SHARK] < %p > KiCallUserMode\n", KdDebuggerDataBlock->KiCallUserMode);
            /// vDbgPrint("[SHARK] < %p > KeUserCallbackDispatcher\n", KdDebuggerDataBlock->KeUserCallbackDispatcher);
            // vDbgPrint("[SHARK] < %p > PsLoadedModuleList\n", KdDebuggerDataBlock->PsLoadedModuleList);
            // vDbgPrint("[SHARK] < %p > PsActiveProcessHead\n", KdDebuggerDataBlock->PsActiveProcessHead);
            // vDbgPrint("[SHARK] < %p > PspCidTable\n", KdDebuggerDataBlock->PspCidTable);
            /// vDbgPrint("[SHARK] < %p > ExpSystemResourcesList\n", KdDebuggerDataBlock->ExpSystemResourcesList);
            /// vDbgPrint("[SHARK] < %p > ExpPagedPoolDescriptor\n", KdDebuggerDataBlock->ExpPagedPoolDescriptor);
            /// vDbgPrint("[SHARK] < %p > ExpNumberOfPagedPools\n", KdDebuggerDataBlock->ExpNumberOfPagedPools);
            /// vDbgPrint("[SHARK] < %p > KeTimeIncrement\n", KdDebuggerDataBlock->KeTimeIncrement);
            /// vDbgPrint("[SHARK] < %p > KeBugCheckCallbackListHead\n", KdDebuggerDataBlock->KeBugCheckCallbackListHead);
            /// vDbgPrint("[SHARK] < %p > KiBugcheckData\n", KdDebuggerDataBlock->KiBugcheckData);
            /// vDbgPrint("[SHARK] < %p > IopErrorLogListHead\n", KdDebuggerDataBlock->IopErrorLogListHead);
            /// vDbgPrint("[SHARK] < %p > ObpRootDirectoryObject\n", KdDebuggerDataBlock->ObpRootDirectoryObject);
            /// vDbgPrint("[SHARK] < %p > ObpTypeObjectType\n", KdDebuggerDataBlock->ObpTypeObjectType);
            /// vDbgPrint("[SHARK] < %p > MmSystemCacheStart\n", KdDebuggerDataBlock->MmSystemCacheStart);
            /// vDbgPrint("[SHARK] < %p > MmSystemCacheEnd\n", KdDebuggerDataBlock->MmSystemCacheEnd);
            /// vDbgPrint("[SHARK] < %p > MmSystemCacheWs\n", KdDebuggerDataBlock->MmSystemCacheWs);
            // vDbgPrint("[SHARK] < %p > MmPfnDatabase\n", KdDebuggerDataBlock->MmPfnDatabase);
            /// vDbgPrint("[SHARK] < %p > MmSystemPtesStart\n", KdDebuggerDataBlock->MmSystemPtesStart);
            /// vDbgPrint("[SHARK] < %p > MmSystemPtesEnd\n", KdDebuggerDataBlock->MmSystemPtesEnd);
            /// vDbgPrint("[SHARK] < %p > MmSubsectionBase\n", KdDebuggerDataBlock->MmSubsectionBase);
            /// vDbgPrint("[SHARK] < %p > MmNumberOfPagingFiles\n", KdDebuggerDataBlock->MmNumberOfPagingFiles);
            /// vDbgPrint("[SHARK] < %p > MmLowestPhysicalPage\n", KdDebuggerDataBlock->MmLowestPhysicalPage);
            /// vDbgPrint("[SHARK] < %p > MmHighestPhysicalPage\n", KdDebuggerDataBlock->MmHighestPhysicalPage);
            /// vDbgPrint("[SHARK] < %p > MmNumberOfPhysicalPages\n", KdDebuggerDataBlock->MmNumberOfPhysicalPages);
            /// vDbgPrint("[SHARK] < %p > MmMaximumNonPagedPoolInBytes\n", KdDebuggerDataBlock->MmMaximumNonPagedPoolInBytes);
            /// vDbgPrint("[SHARK] < %p > MmNonPagedSystemStart\n", KdDebuggerDataBlock->MmNonPagedSystemStart);
            /// vDbgPrint("[SHARK] < %p > MmNonPagedPoolStart\n", KdDebuggerDataBlock->MmNonPagedPoolStart);
            /// vDbgPrint("[SHARK] < %p > MmNonPagedPoolEnd\n", KdDebuggerDataBlock->MmNonPagedPoolEnd);
            /// vDbgPrint("[SHARK] < %p > MmPagedPoolStart\n", KdDebuggerDataBlock->MmPagedPoolStart);
            /// vDbgPrint("[SHARK] < %p > MmPagedPoolEnd\n", KdDebuggerDataBlock->MmPagedPoolEnd);
            /// vDbgPrint("[SHARK] < %p > MmPagedPoolInformation\n", KdDebuggerDataBlock->MmPagedPoolInformation);
            /// vDbgPrint("[SHARK] < %p > MmPageSize\n", KdDebuggerDataBlock->MmPageSize);
            /// vDbgPrint("[SHARK] < %p > MmSizeOfPagedPoolInBytes\n", KdDebuggerDataBlock->MmSizeOfPagedPoolInBytes);
            /// vDbgPrint("[SHARK] < %p > MmTotalCommitLimit\n", KdDebuggerDataBlock->MmTotalCommitLimit);
            /// vDbgPrint("[SHARK] < %p > MmTotalCommittedPages\n", KdDebuggerDataBlock->MmTotalCommittedPages);
            /// vDbgPrint("[SHARK] < %p > MmSharedCommit\n", KdDebuggerDataBlock->MmSharedCommit);
            /// vDbgPrint("[SHARK] < %p > MmDriverCommit\n", KdDebuggerDataBlock->MmDriverCommit);
            /// vDbgPrint("[SHARK] < %p > MmProcessCommit\n", KdDebuggerDataBlock->MmProcessCommit);
            /// vDbgPrint("[SHARK] < %p > MmPagedPoolCommit\n", KdDebuggerDataBlock->MmPagedPoolCommit);
            /// vDbgPrint("[SHARK] < %p > MmExtendedCommit\n", KdDebuggerDataBlock->MmExtendedCommit);
            /// vDbgPrint("[SHARK] < %p > MmZeroedPageListHead\n", KdDebuggerDataBlock->MmZeroedPageListHead);
            /// vDbgPrint("[SHARK] < %p > MmFreePageListHead\n", KdDebuggerDataBlock->MmFreePageListHead);
            /// vDbgPrint("[SHARK] < %p > MmStandbyPageListHead\n", KdDebuggerDataBlock->MmStandbyPageListHead);
            /// vDbgPrint("[SHARK] < %p > MmModifiedPageListHead\n", KdDebuggerDataBlock->MmModifiedPageListHead);
            /// vDbgPrint("[SHARK] < %p > MmModifiedNoWritePageListHead\n", KdDebuggerDataBlock->MmModifiedNoWritePageListHead);
            /// vDbgPrint("[SHARK] < %p > MmAvailablePages\n", KdDebuggerDataBlock->MmAvailablePages);
            /// vDbgPrint("[SHARK] < %p > MmResidentAvailablePages\n", KdDebuggerDataBlock->MmResidentAvailablePages);
            /// vDbgPrint("[SHARK] < %p > PoolTrackTable\n", KdDebuggerDataBlock->PoolTrackTable);
            /// vDbgPrint("[SHARK] < %p > NonPagedPoolDescriptor\n", KdDebuggerDataBlock->NonPagedPoolDescriptor);
            /// vDbgPrint("[SHARK] < %p > MmHighestUserAddress\n", KdDebuggerDataBlock->MmHighestUserAddress);
            /// vDbgPrint("[SHARK] < %p > MmSystemRangeStart\n", KdDebuggerDataBlock->MmSystemRangeStart);
            /// vDbgPrint("[SHARK] < %p > MmUserProbeAddress\n", KdDebuggerDataBlock->MmUserProbeAddress);
            /// vDbgPrint("[SHARK] < %p > KdPrintCircularBuffer\n", KdDebuggerDataBlock->KdPrintCircularBuffer);
            /// vDbgPrint("[SHARK] < %p > KdPrintCircularBufferEnd\n", KdDebuggerDataBlock->KdPrintCircularBufferEnd);
            /// vDbgPrint("[SHARK] < %p > KdPrintWritePointer\n", KdDebuggerDataBlock->KdPrintWritePointer);
            /// vDbgPrint("[SHARK] < %p > KdPrintRolloverCount\n", KdDebuggerDataBlock->KdPrintRolloverCount);
            /// vDbgPrint("[SHARK] < %p > MmLoadedUserImageList\n", KdDebuggerDataBlock->MmLoadedUserImageList);
            /// vDbgPrint("[SHARK] < %p > NtBuildLab\n", KdDebuggerDataBlock->NtBuildLab);
            /// vDbgPrint("[SHARK] < %p > KiNormalSystemCall\n", KdDebuggerDataBlock->KiNormalSystemCall);
            /// vDbgPrint("[SHARK] < %p > KiProcessorBlock\n", KdDebuggerDataBlock->KiProcessorBlock);
            /// vDbgPrint("[SHARK] < %p > MmUnloadedDrivers\n", KdDebuggerDataBlock->MmUnloadedDrivers);
            /// vDbgPrint("[SHARK] < %p > MmLastUnloadedDriver\n", KdDebuggerDataBlock->MmLastUnloadedDriver);
            /// vDbgPrint("[SHARK] < %p > MmTriageActionTaken\n", KdDebuggerDataBlock->MmTriageActionTaken);
            /// vDbgPrint("[SHARK] < %p > MmSpecialPoolTag\n", KdDebuggerDataBlock->MmSpecialPoolTag);
            /// vDbgPrint("[SHARK] < %p > KernelVerifier\n", KdDebuggerDataBlock->KernelVerifier);
            /// vDbgPrint("[SHARK] < %p > MmVerifierData\n", KdDebuggerDataBlock->MmVerifierData);
            /// vDbgPrint("[SHARK] < %p > MmAllocatedNonPagedPool\n", KdDebuggerDataBlock->MmAllocatedNonPagedPool);
            /// vDbgPrint("[SHARK] < %p > MmPeakCommitment\n", KdDebuggerDataBlock->MmPeakCommitment);
            /// vDbgPrint("[SHARK] < %p > MmTotalCommitLimitMaximum\n", KdDebuggerDataBlock->MmTotalCommitLimitMaximum);
            /// vDbgPrint("[SHARK] < %p > CmNtCSDVersion\n", KdDebuggerDataBlock->CmNtCSDVersion);
            /// vDbgPrint("[SHARK] < %p > MmPhysicalMemoryBlock\n", KdDebuggerDataBlock->MmPhysicalMemoryBlock);
            /// vDbgPrint("[SHARK] < %p > MmSessionBase\n", KdDebuggerDataBlock->MmSessionBase);
            /// vDbgPrint("[SHARK] < %p > MmSessionSize\n", KdDebuggerDataBlock->MmSessionSize);
            /// vDbgPrint("[SHARK] < %p > MmSystemParentTablePage\n", KdDebuggerDataBlock->MmSystemParentTablePage);
            /// vDbgPrint("[SHARK] < %p > MmVirtualTranslationBase\n", KdDebuggerDataBlock->MmVirtualTranslationBase);
            // vDbgPrint("[SHARK] < %p > OffsetKThreadNextProcessor\n", KdDebuggerDataBlock->OffsetKThreadNextProcessor);
            // vDbgPrint("[SHARK] < %p > OffsetKThreadTeb\n", KdDebuggerDataBlock->OffsetKThreadTeb);
            // vDbgPrint("[SHARK] < %p > OffsetKThreadKernelStack\n", KdDebuggerDataBlock->OffsetKThreadKernelStack);
            // vDbgPrint("[SHARK] < %p > OffsetKThreadInitialStack\n", KdDebuggerDataBlock->OffsetKThreadInitialStack);
            // vDbgPrint("[SHARK] < %p > OffsetKThreadApcProcess\n", KdDebuggerDataBlock->OffsetKThreadApcProcess);
            // vDbgPrint("[SHARK] < %p > OffsetKThreadState\n", KdDebuggerDataBlock->OffsetKThreadState);
            // vDbgPrint("[SHARK] < %p > OffsetKThreadBStore\n", KdDebuggerDataBlock->OffsetKThreadBStore);
            // vDbgPrint("[SHARK] < %p > OffsetKThreadBStoreLimit\n", KdDebuggerDataBlock->OffsetKThreadBStoreLimit);
            // vDbgPrint("[SHARK] < %p > SizeEProcess\n", KdDebuggerDataBlock->SizeEProcess);
            // vDbgPrint("[SHARK] < %p > OffsetEprocessPeb\n", KdDebuggerDataBlock->OffsetEprocessPeb);
            // vDbgPrint("[SHARK] < %p > OffsetEprocessParentCID\n", KdDebuggerDataBlock->OffsetEprocessParentCID);
            // vDbgPrint("[SHARK] < %p > OffsetEprocessDirectoryTableBase\n", KdDebuggerDataBlock->OffsetEprocessDirectoryTableBase);
            // vDbgPrint("[SHARK] < %p > SizePrcb\n", KdDebuggerDataBlock->SizePrcb);
            // vDbgPrint("[SHARK] < %p > OffsetPrcbDpcRoutine\n", KdDebuggerDataBlock->OffsetPrcbDpcRoutine);
            // vDbgPrint("[SHARK] < %p > OffsetPrcbCurrentThread\n", KdDebuggerDataBlock->OffsetPrcbCurrentThread);
            // vDbgPrint("[SHARK] < %p > OffsetPrcbMhz\n", KdDebuggerDataBlock->OffsetPrcbMhz);
            // vDbgPrint("[SHARK] < %p > OffsetPrcbCpuType\n", KdDebuggerDataBlock->OffsetPrcbCpuType);
            // vDbgPrint("[SHARK] < %p > OffsetPrcbVendorString\n", KdDebuggerDataBlock->OffsetPrcbVendorString);
            // vDbgPrint("[SHARK] < %p > OffsetPrcbProcStateContext\n", KdDebuggerDataBlock->OffsetPrcbProcStateContext);
            // vDbgPrint("[SHARK] < %p > OffsetPrcbNumber\n", KdDebuggerDataBlock->OffsetPrcbNumber);
            // vDbgPrint("[SHARK] < %p > SizeEThread\n", KdDebuggerDataBlock->SizeEThread);
            /// vDbgPrint("[SHARK] < %p > KdPrintCircularBufferPtr\n", KdDebuggerDataBlock->KdPrintCircularBufferPtr);
            /// vDbgPrint("[SHARK] < %p > KdPrintBufferSize\n", KdDebuggerDataBlock->KdPrintBufferSize);
            /// vDbgPrint("[SHARK] < %p > KeLoaderBlock\n", KdDebuggerDataBlock->KeLoaderBlock);
            // vDbgPrint("[SHARK] < %p > SizePcr\n", KdDebuggerDataBlock->SizePcr);
            // vDbgPrint("[SHARK] < %p > OffsetPcrSelfPcr\n", KdDebuggerDataBlock->OffsetPcrSelfPcr);
            // vDbgPrint("[SHARK] < %p > OffsetPcrCurrentPrcb\n", KdDebuggerDataBlock->OffsetPcrCurrentPrcb);
            // vDbgPrint("[SHARK] < %p > OffsetPcrContainedPrcb\n", KdDebuggerDataBlock->OffsetPcrContainedPrcb);
            // vDbgPrint("[SHARK] < %p > OffsetPcrInitialBStore\n", KdDebuggerDataBlock->OffsetPcrInitialBStore);
            // vDbgPrint("[SHARK] < %p > OffsetPcrBStoreLimit\n", KdDebuggerDataBlock->OffsetPcrBStoreLimit);
            // vDbgPrint("[SHARK] < %p > OffsetPcrInitialStack\n", KdDebuggerDataBlock->OffsetPcrInitialStack);
            // vDbgPrint("[SHARK] < %p > OffsetPcrStackLimit\n", KdDebuggerDataBlock->OffsetPcrStackLimit);
            // vDbgPrint("[SHARK] < %p > OffsetPrcbPcrPage\n", KdDebuggerDataBlock->OffsetPrcbPcrPage);
            // vDbgPrint("[SHARK] < %p > OffsetPrcbProcStateSpecialReg\n", KdDebuggerDataBlock->OffsetPrcbProcStateSpecialReg);
            // vDbgPrint("[SHARK] < %p > GdtR0Code\n", KdDebuggerDataBlock->GdtR0Code);
            // vDbgPrint("[SHARK] < %p > GdtR0Data\n", KdDebuggerDataBlock->GdtR0Data);
            // vDbgPrint("[SHARK] < %p > GdtR0Pcr\n", KdDebuggerDataBlock->GdtR0Pcr);
            // vDbgPrint("[SHARK] < %p > GdtR3Code\n", KdDebuggerDataBlock->GdtR3Code);
            // vDbgPrint("[SHARK] < %p > GdtR3Data\n", KdDebuggerDataBlock->GdtR3Data);
            // vDbgPrint("[SHARK] < %p > GdtR3Teb\n", KdDebuggerDataBlock->GdtR3Teb);
            // vDbgPrint("[SHARK] < %p > GdtLdt\n", KdDebuggerDataBlock->GdtLdt);
            // vDbgPrint("[SHARK] < %p > GdtTss\n", KdDebuggerDataBlock->GdtTss);
            // vDbgPrint("[SHARK] < %p > Gdt64R3CmCode\n", KdDebuggerDataBlock->Gdt64R3CmCode);
            // vDbgPrint("[SHARK] < %p > Gdt64R3CmTeb\n", KdDebuggerDataBlock->Gdt64R3CmTeb);
            /// vDbgPrint("[SHARK] < %p > IopNumTriageDumpDataBlocks\n", KdDebuggerDataBlock->IopNumTriageDumpDataBlocks);
            /// vDbgPrint("[SHARK] < %p > IopTriageDumpDataBlocks\n", KdDebuggerDataBlock->IopTriageDumpDataBlocks);

            if (Rtb->BuildNumber >= 10586) {
                // vDbgPrint("[SHARK] < %p > PteBase\n", KdDebuggerDataAdditionBlock->PteBase);
            }
#endif // DEBUG
        }

        __free(DumpHeader);
    }

#ifndef _WIN64
    Rtb->OffsetKProcessThreadListHead = 0x2c;

    if (Rtb->BuildNumber < 9200) {
        Rtb->OffsetKThreadThreadListEntry = 0x1e0;
    }
    else {
        Rtb->OffsetKThreadThreadListEntry = 0x1d4;
    }
#else
    Rtb->OffsetKProcessThreadListHead = 0x30;
    Rtb->OffsetKThreadThreadListEntry = 0x2f8;
#endif // !_WIN64

#ifndef _WIN64
    RtlInitUnicodeString(&String, L"KeCapturePersistentThreadState");

    ControlPc = MmGetSystemRoutineAddress(&String);

    ControlPc = ScanBytes(
        ControlPc,
        ControlPc + PAGE_SIZE,
        PsLoadedModuleResource);

    if (NULL != ControlPc) {
        Rtb->PsLoadedModuleResource = *(PERESOURCE *)(ControlPc + 3);
    }

    RtlInitUnicodeString(&String, L"KeServiceDescriptorTable");

    Rtb->KeServiceDescriptorTable = MmGetSystemRoutineAddress(&String);

    NtSection = LdrFindSection(
        (ptr)Rtb->DebuggerDataBlock.KernBase,
        ".text");

    if (NULL != NtSection) {
        SectionBase =
            (u8ptr)Rtb->DebuggerDataBlock.KernBase + NtSection->VirtualAddress;

        SizeToLock = max(
            NtSection->SizeOfRawData,
            NtSection->Misc.VirtualSize);

        ControlPc = ScanBytes(
            SectionBase,
            (u8ptr)SectionBase + SizeToLock,
            PerfGlobalGroupMask);

        if (NULL != ControlPc) {
            Rtb->PerfInfoLogSysCallEntry = ControlPc + 0xd;

            RtlCopyMemory(
                Rtb->KiSystemServiceCopyEnd,
                Rtb->PerfInfoLogSysCallEntry,
                sizeof(Rtb->KiSystemServiceCopyEnd));

            Rtb->PerfGlobalGroupMask = UlongToPtr(*(u32 *)(ControlPc + 4) - 8);
        }
    }
#else
    RtlInitUnicodeString(&String, L"KeCapturePersistentThreadState");

    ControlPc = MmGetSystemRoutineAddress(&String);

    ControlPc = ScanBytes(
        ControlPc,
        ControlPc + PAGE_SIZE,
        PsLoadedModuleResource);

    if (NULL != ControlPc) {
        Rtb->PsLoadedModuleResource = (PERESOURCE)__rva_to_va(ControlPc + 3);
    }

    NtSection = LdrFindSection(
        (ptr)Rtb->DebuggerDataBlock.KernBase,
        ".text");

    if (NULL != NtSection) {
        SectionBase =
            (u8ptr)Rtb->DebuggerDataBlock.KernBase + NtSection->VirtualAddress;

        SizeToLock = max(
            NtSection->SizeOfRawData,
            NtSection->Misc.VirtualSize);

        ControlPc = ScanBytes(
            SectionBase,
            (u8ptr)SectionBase + SizeToLock,
            KiSystemCall64);

        if (NULL != ControlPc) {
            Rtb->KeServiceDescriptorTable = __rva_to_va(ControlPc + 23);
            Rtb->KeServiceDescriptorTableShadow = __rva_to_va(ControlPc + 30);

            ControlPc = ScanBytes(
                ControlPc,
                (u8ptr)SectionBase + SizeToLock,
                PerfGlobalGroupMask);

            if (NULL != ControlPc) {
                Rtb->PerfInfoLogSysCallEntry = ControlPc + 0xa;

                RtlCopyMemory(
                    Rtb->KiSystemServiceCopyEnd,
                    Rtb->PerfInfoLogSysCallEntry,
                    sizeof(Rtb->KiSystemServiceCopyEnd));

                Rtb->PerfGlobalGroupMask = __rva_to_va_ex(ControlPc + 2, 0 - sizeof(s32));
            }
        }
    }
#endif // !_WIN64

    RtlInitUnicodeString(&String, L"PsGetThreadProcessId");

    ControlPc = MmGetSystemRoutineAddress(&String);

    if (NULL != ControlPc) {
#ifndef _WIN64
        Rtb->OffsetKThreadProcessId = *(u32*)(ControlPc + 10);
#else
        Rtb->OffsetKThreadProcessId = *(u32*)(ControlPc + 3);
#endif // !_WIN64
    }

    InitializeListHead(&Rtb->LoadedModuleList);

    if (FALSE == IsListEmpty(
        (PLIST_ENTRY)Rtb->DebuggerDataBlock.PsActiveProcessHead)) {
        ActiveProcessEntry =
            ((PLIST_ENTRY)Rtb->DebuggerDataBlock.PsActiveProcessHead)->Flink;

        while ((u)ActiveProcessEntry !=
            (u)Rtb->DebuggerDataBlock.PsActiveProcessHead) {
            if ((u)PsGetCurrentThreadProcessId() ==
                __rduptr((u)ActiveProcessEntry - sizeof(u))) {

                Rtb->OffsetEProcessActiveProcessLinks =
                    (u)ActiveProcessEntry - (u)PsGetCurrentThreadProcess();

                break;
            }

            ActiveProcessEntry = ActiveProcessEntry->Flink;
        }
    }

    RtlInitUnicodeString(&String, L"ZwClose");

    ControlPc = MmGetSystemRoutineAddress(&String);

    FirstLength = DetourGetInstructionLength(ControlPc);

    TargetPc = ControlPc + FirstLength;

    while (TRUE) {
        Length = DetourGetInstructionLength(TargetPc);

        if (FirstLength == Length) {
#ifndef _WIN64
            if (0 == _cmpbyte(TargetPc[0], ControlPc[0]) &&
                1 == *(u32ptr)&TargetPc[1] - *(u32ptr)&ControlPc[1]) {
                Rtb->NameInterval = TargetPc - ControlPc;

                break;
            }
#else
            if (FirstLength == RtlCompareMemory(
                TargetPc,
                ControlPc,
                FirstLength)) {
                Rtb->NameInterval = TargetPc - ControlPc;

                break;
            }
#endif // !_WIN64
        }

        TargetPc += Length;
    }
}

u32
NTAPI
LdrGetPlatform(
    __in ptr ImageBase
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    u32 Platform = 0;

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        Platform = NtHeaders->OptionalHeader.Magic;
    }

    return Platform;
}

ptr
NTAPI
LdrGetEntryPoint(
    __in ptr ImageBase
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    u32 Offset = 0;
    ptr EntryPoint = NULL;

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        if (IMAGE_NT_OPTIONAL_HDR32_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Offset = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.AddressOfEntryPoint;
        }

        if (IMAGE_NT_OPTIONAL_HDR64_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Offset = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.AddressOfEntryPoint;
        }

        if (0 != Offset) {
            EntryPoint = (u8ptr)ImageBase + Offset;
        }
    }

    return EntryPoint;
}

u32
NTAPI
LdrGetTimeStamp(
    __in ptr ImageBase
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    u32 TimeStamp = 0;

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        TimeStamp = NtHeaders->FileHeader.TimeDateStamp;
    }

    return TimeStamp;
}

u16
NTAPI
LdrGetSubsystem(
    __in ptr ImageBase
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    u16 Subsystem = 0;

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        if (IMAGE_NT_OPTIONAL_HDR32_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Subsystem = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.Subsystem;
        }

        if (IMAGE_NT_OPTIONAL_HDR64_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Subsystem = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.Subsystem;
        }
    }

    return Subsystem;
}

u32
NTAPI
LdrGetSize(
    __in ptr ImageBase
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    u32 SizeOfImage = 0;

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        if (IMAGE_NT_OPTIONAL_HDR32_MAGIC == NtHeaders->OptionalHeader.Magic) {
            SizeOfImage = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.SizeOfImage;
        }

        if (IMAGE_NT_OPTIONAL_HDR64_MAGIC == NtHeaders->OptionalHeader.Magic) {
            SizeOfImage = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.SizeOfImage;
        }
    }

    return SizeOfImage;
}

PIMAGE_SECTION_HEADER
NTAPI
SectionTableFromVirtualAddress(
    __in ptr ImageBase,
    __in ptr Address
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    u32 Index = 0;
    u32 Offset = 0;
    PIMAGE_SECTION_HEADER FoundSection = NULL;
    PIMAGE_SECTION_HEADER NtSection = NULL;
    u32 SizeToLock = 0;

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        FoundSection = IMAGE_FIRST_SECTION(NtHeaders);
        Offset = (u32)((u)Address - (u)ImageBase);

        for (Index = 0;
            Index < NtHeaders->FileHeader.NumberOfSections;
            Index++) {
            SizeToLock = max(
                FoundSection[Index].SizeOfRawData,
                FoundSection[Index].Misc.VirtualSize);

            if (Offset >= FoundSection[Index].VirtualAddress &&
                Offset < FoundSection[Index].VirtualAddress + SizeToLock) {
                NtSection = &FoundSection[Index];

                break;
            }
        }
    }

    return NtSection;
}

PIMAGE_SECTION_HEADER
NTAPI
LdrFindSection(
    __in ptr ImageBase,
    __in u8ptr SectionName
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    PIMAGE_SECTION_HEADER NtSection = NULL;
    PIMAGE_SECTION_HEADER FoundSection = NULL;
    u32 Index = 0;
    u32 Maximun = 0;
    u8 Name[IMAGE_SIZEOF_SHORT_NAME] = { 0 };

    strcpy_s(Name, IMAGE_SIZEOF_SHORT_NAME, SectionName);

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        FoundSection = IMAGE_FIRST_SECTION(NtHeaders);

        for (Index = 0;
            Index < NtHeaders->FileHeader.NumberOfSections;
            Index++) {
            if (0 == _strnicmp(
                FoundSection[Index].Name,
                Name,
                IMAGE_SIZEOF_SHORT_NAME)) {
                NtSection = &FoundSection[Index];

                break;
            }
        }
    }

    return NtSection;
}

FORCEINLINE
u32
NTAPI
LdrGetRelocCount(
    __in u32 SizeOfBlock
)
{
    u32 Count = 0;

    Count = (SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(u16);

    return Count;
}

PIMAGE_BASE_RELOCATION
NTAPI
LdrRelocBlock(
    __in ptr VA,
    __in u32 Count,
    __in u16ptr NextOffset,
    __in s Diff
)
{
    u16ptr FixupVA = NULL;
    u16 Offset = 0;
    u16 Type = 0;

    while (Count--) {
        Offset = *NextOffset & 0xfff;
        FixupVA = (u8ptr)VA + Offset;
        Type = (*NextOffset >> 12) & 0xf;

        switch (Type) {
        case IMAGE_REL_BASED_ABSOLUTE: {
            break;
        }

        case IMAGE_REL_BASED_HIGH: {
            FixupVA[1] += (u16)((Diff >> 16) & 0xffff);
            break;
        }

        case IMAGE_REL_BASED_LOW: {
            FixupVA[0] += (u16)(Diff & 0xffff);
            break;
        }

        case IMAGE_REL_BASED_HIGHLOW: {
            *(u32ptr)FixupVA += (u32)Diff;
            break;
        }

        case IMAGE_REL_BASED_HIGHADJ: {
            FixupVA[0] += NextOffset[1] & 0xffff;
            FixupVA[1] += (u16)((Diff >> 16) & 0xffff);

            ++NextOffset;
            --Count;
            break;
        }

        case IMAGE_REL_BASED_MIPS_JMPADDR:
        case IMAGE_REL_BASED_SECTION:
        case IMAGE_REL_BASED_REL32:
            // case IMAGE_REL_BASED_VXD_RELATIVE:
            // case IMAGE_REL_BASED_MIPS_JMPADDR16: 

        case IMAGE_REL_BASED_IA64_IMM64: {
            break;
        }

        case IMAGE_REL_BASED_DIR64: {
            *(uptr)FixupVA += Diff;
            break;
        }

        default: {
            return NULL;
        }
        }

        ++NextOffset;
    }

    return (PIMAGE_BASE_RELOCATION)NextOffset;
}

void
NTAPI
LdrRelocImage(
    __in ptr ImageBase,
    __in s Diff
)
{
    PIMAGE_BASE_RELOCATION RelocDirectory = NULL;
    u32 Size = 0;
    ptr VA = 0;

    RelocDirectory = RtlImageDirectoryEntryToData(
        ImageBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_BASERELOC,
        &Size);

    if (0 != Size) {
        if (0 != Diff) {
            while (0 != Size) {
                VA = (u8ptr)ImageBase + RelocDirectory->VirtualAddress;
                Size -= RelocDirectory->SizeOfBlock;

                RelocDirectory = LdrRelocBlock(
                    VA,
                    LdrGetRelocCount(RelocDirectory->SizeOfBlock),
                    (u16ptr)(RelocDirectory + 1),
                    Diff);
            }
        }
    }
}

status
NTAPI
FindEntryForImage(
    __in PUNICODE_STRING ImageFileName,
    __out PKLDR_DATA_TABLE_ENTRY * DataTableEntry
)
{
    status Status = STATUS_NO_MORE_ENTRIES;
    PKLDR_DATA_TABLE_ENTRY FoundDataTableEntry = NULL;

    RtBlock.KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(RtBlock.PsLoadedModuleResource, TRUE);

    if (FALSE == IsListEmpty(RtBlock.PsLoadedModuleList)) {
        FoundDataTableEntry = CONTAINING_RECORD(
            RtBlock.PsLoadedModuleList->Flink,
            KLDR_DATA_TABLE_ENTRY,
            InLoadOrderLinks);

        while ((u)FoundDataTableEntry !=
            (u)RtBlock.PsLoadedModuleList) {
            if (FALSE != RtlEqualUnicodeString(
                ImageFileName,
                &FoundDataTableEntry->BaseDllName,
                TRUE)) {
                *DataTableEntry = FoundDataTableEntry;
                Status = STATUS_SUCCESS;
                break;
            }

            FoundDataTableEntry = CONTAINING_RECORD(
                FoundDataTableEntry->InLoadOrderLinks.Flink,
                KLDR_DATA_TABLE_ENTRY,
                InLoadOrderLinks);
        }
    }

    if (Status < 0) {
        if (FALSE == IsListEmpty(&RtBlock.LoadedModuleList)) {
            FoundDataTableEntry = CONTAINING_RECORD(
                RtBlock.LoadedModuleList.Flink,
                KLDR_DATA_TABLE_ENTRY,
                InLoadOrderLinks);

            while ((u)FoundDataTableEntry != (u)&RtBlock.LoadedModuleList) {
                if (FALSE != RtlEqualUnicodeString(
                    ImageFileName,
                    &FoundDataTableEntry->BaseDllName,
                    TRUE)) {
                    *DataTableEntry = FoundDataTableEntry;
                    Status = STATUS_SUCCESS;
                    break;
                }

                FoundDataTableEntry = CONTAINING_RECORD(
                    FoundDataTableEntry->InLoadOrderLinks.Flink,
                    KLDR_DATA_TABLE_ENTRY,
                    InLoadOrderLinks);
            }
        }
    }

    ExReleaseResourceLite(RtBlock.PsLoadedModuleResource);
    RtBlock.KeLeaveCriticalRegion();

    return Status;
}

status
NTAPI
FindEntryForImageAddress(
    __in ptr Address,
    __out PKLDR_DATA_TABLE_ENTRY * DataTableEntry
)
{
    status Status = STATUS_NO_MORE_ENTRIES;
    PKLDR_DATA_TABLE_ENTRY FoundDataTableEntry = NULL;

    RtBlock.KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(RtBlock.PsLoadedModuleResource, TRUE);

    if (FALSE == IsListEmpty(RtBlock.PsLoadedModuleList)) {
        FoundDataTableEntry = CONTAINING_RECORD(
            (RtBlock.PsLoadedModuleList)->Flink,
            KLDR_DATA_TABLE_ENTRY,
            InLoadOrderLinks);

        while ((u)FoundDataTableEntry !=
            (u)RtBlock.PsLoadedModuleList) {
            if ((u)Address >= (u)FoundDataTableEntry->DllBase &&
                (u)Address < (u)FoundDataTableEntry->DllBase +
                FoundDataTableEntry->SizeOfImage) {
                *DataTableEntry = FoundDataTableEntry;
                Status = STATUS_SUCCESS;
                break;
            }

            FoundDataTableEntry = CONTAINING_RECORD(
                FoundDataTableEntry->InLoadOrderLinks.Flink,
                KLDR_DATA_TABLE_ENTRY,
                InLoadOrderLinks);
        }
    }

    if (Status < 0) {
        if (FALSE == IsListEmpty(&RtBlock.LoadedModuleList)) {
            FoundDataTableEntry = CONTAINING_RECORD(
                RtBlock.LoadedModuleList.Flink,
                KLDR_DATA_TABLE_ENTRY,
                InLoadOrderLinks);

            while ((u)FoundDataTableEntry != (u)&RtBlock.LoadedModuleList) {
                if ((u)Address >= (u)FoundDataTableEntry->DllBase &&
                    (u)Address < (u)FoundDataTableEntry->DllBase +
                    FoundDataTableEntry->SizeOfImage) {
                    *DataTableEntry = FoundDataTableEntry;
                    Status = STATUS_SUCCESS;
                    break;
                }

                FoundDataTableEntry = CONTAINING_RECORD(
                    FoundDataTableEntry->InLoadOrderLinks.Flink,
                    KLDR_DATA_TABLE_ENTRY,
                    InLoadOrderLinks);
            }
        }
    }

    ExReleaseResourceLite(RtBlock.PsLoadedModuleResource);
    RtBlock.KeLeaveCriticalRegion();

    return Status;
}

ptr
NTAPI
LdrForward(
    __in cptr ForwarderData
)
{
    status Status = STATUS_SUCCESS;
    cptr Separator = NULL;
    cptr ImageName = NULL;
    cptr ProcedureName = NULL;
    u32 ProcedureNumber = 0;
    ptr ProcedureAddress = NULL;
    PKLDR_DATA_TABLE_ENTRY FoundDataTableEntry = NULL;
    PLDR_DATA_TABLE_ENTRY DataTableEntry = NULL;
    ANSI_STRING String = { 0 };
    UNICODE_STRING ImageFileName = { 0 };

    Separator = strchr(ForwarderData, '.');

    if (NULL != Separator) {
        ImageName = __malloc(Separator - ForwarderData);

        if (NULL != ImageName) {
            RtlCopyMemory(
                ImageName,
                ForwarderData,
                Separator - ForwarderData);

            String.Buffer = ImageName;
            String.Length = Separator - ForwarderData;
            String.MaximumLength = Separator - ForwarderData;

            Status = RtlAnsiStringToUnicodeString(
                &ImageFileName,
                &String,
                TRUE);

            if (TRACE(Status)) {
                RtBlock.KeEnterCriticalRegion();
                ExAcquireResourceExclusiveLite(RtBlock.PsLoadedModuleResource, TRUE);

                if (FALSE == IsListEmpty(RtBlock.PsLoadedModuleList)) {
                    FoundDataTableEntry = CONTAINING_RECORD(
                        RtBlock.PsLoadedModuleList->Flink,
                        KLDR_DATA_TABLE_ENTRY,
                        InLoadOrderLinks);

                    while ((u)FoundDataTableEntry !=
                        (u)RtBlock.PsLoadedModuleList) {
                        if (FALSE != RtlPrefixUnicodeString(
                            &ImageFileName,
                            &FoundDataTableEntry->BaseDllName,
                            TRUE)) {
                            DataTableEntry = FoundDataTableEntry;
                            Status = STATUS_SUCCESS;

                            break;
                        }

                        FoundDataTableEntry = CONTAINING_RECORD(
                            FoundDataTableEntry->InLoadOrderLinks.Flink,
                            KLDR_DATA_TABLE_ENTRY,
                            InLoadOrderLinks);
                    }
                }

                if (Status < 0) {
                    if (FALSE == IsListEmpty(&RtBlock.LoadedModuleList)) {
                        FoundDataTableEntry = CONTAINING_RECORD(
                            RtBlock.LoadedModuleList.Flink,
                            KLDR_DATA_TABLE_ENTRY,
                            InLoadOrderLinks);

                        while ((u)FoundDataTableEntry != (u)&RtBlock.LoadedModuleList) {
                            if (FALSE != RtlPrefixUnicodeString(
                                &ImageFileName,
                                &FoundDataTableEntry->BaseDllName,
                                TRUE)) {
                                DataTableEntry = FoundDataTableEntry;
                                Status = STATUS_SUCCESS;

                                break;
                            }

                            FoundDataTableEntry = CONTAINING_RECORD(
                                FoundDataTableEntry->InLoadOrderLinks.Flink,
                                KLDR_DATA_TABLE_ENTRY,
                                InLoadOrderLinks);
                        }
                    }
                }

                ExReleaseResourceLite(RtBlock.PsLoadedModuleResource);
                RtBlock.KeLeaveCriticalRegion();

                if (NT_SUCCESS(Status)) {
                    Separator += 1;
                    ProcedureName = Separator;

                    if (Separator[0] != '@') {
                        ProcedureAddress = LdrGetSymbol(
                            DataTableEntry->DllBase,
                            ProcedureName,
                            0);
                    }
                    else {
                        Separator += 1;

                        if (RtlCharToInteger(
                            Separator,
                            0,
                            &ProcedureNumber) >= 0) {
                            ProcedureAddress = LdrGetSymbol(
                                DataTableEntry->DllBase,
                                NULL,
                                ProcedureNumber);
                        }
                    }
                }

                RtlFreeUnicodeString(&ImageFileName);
            }

            __free(ImageName);
        }
    }

    return ProcedureAddress;
}

ptr
NTAPI
LdrGetSymbol(
    __in ptr ImageBase,
    __in_opt cptr ProcedureName,
    __in_opt u32 ProcedureNumber
)
{
    PIMAGE_EXPORT_DIRECTORY ExportDirectory = NULL;
    u32 Size = 0;
    u32ptr NameTable = NULL;
    u16ptr OrdinalTable = NULL;
    u32ptr AddressTable = NULL;
    cptr NameTableName = NULL;
    u16 HintIndex = 0;
    ptr ProcedureAddress = NULL;

    ExportDirectory = RtlImageDirectoryEntryToData(
        ImageBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_EXPORT,
        &Size);

    if (NULL != ExportDirectory) {
        NameTable = (u8ptr)ImageBase + ExportDirectory->AddressOfNames;
        OrdinalTable = (u8ptr)ImageBase + ExportDirectory->AddressOfNameOrdinals;
        AddressTable = (u8ptr)ImageBase + ExportDirectory->AddressOfFunctions;

        if (NULL != NameTable &&
            NULL != OrdinalTable &&
            NULL != AddressTable) {
            if (ProcedureNumber >= ExportDirectory->Base &&
                ProcedureNumber < MAXSHORT) {
                ProcedureAddress = (u8ptr)ImageBase +
                    AddressTable[ProcedureNumber - ExportDirectory->Base];
            }
            else {
                for (HintIndex = 0;
                    HintIndex < ExportDirectory->NumberOfNames;
                    HintIndex++) {
                    NameTableName = (u8ptr)ImageBase + NameTable[HintIndex];

                    if (0 == _stricmp(
                        ProcedureName,
                        NameTableName)) {
                        ProcedureAddress = (u8ptr)ImageBase +
                            AddressTable[OrdinalTable[HintIndex]];
                    }
                }
            }
        }

        if ((u)ProcedureAddress >= (u)ExportDirectory &&
            (u)ProcedureAddress < (u)ExportDirectory + Size) {
            ProcedureAddress = LdrForward(ProcedureAddress);
        }
    }

    return ProcedureAddress;
}

s32
NTAPI
LdrNameToNumber(
    __in cptr String
)
{
    status Status = STATUS_SUCCESS;
    ptr Handle = NULL;
    ptr Section = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    UNICODE_STRING ImageFileName = { 0 };
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    ptr ViewBase = NULL;
    u ViewSize = 0;
    u8ptr TargetPc = NULL;
    s32 Number = -1;

    RtlInitUnicodeString(
        &ImageFileName,
        L"\\SystemRoot\\System32\\ntdll.dll");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &ImageFileName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL);

    Status = ZwOpenFile(
        &Handle,
        FILE_EXECUTE,
        &ObjectAttributes,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_DELETE,
        0);

    if (TRACE(Status)) {
        InitializeObjectAttributes(
            &ObjectAttributes,
            NULL,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL);

        Status = ZwCreateSection(
            &Section,
            SECTION_MAP_READ | SECTION_MAP_EXECUTE,
            &ObjectAttributes,
            NULL,
            PAGE_EXECUTE,
            SEC_IMAGE,
            Handle);

        if (TRACE(Status)) {
            Status = ZwMapViewOfSection(
                Section,
                ZwCurrentProcess(),
                &ViewBase,
                0L,
                0L,
                NULL,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_EXECUTE);

            if (TRACE(Status)) {
                TargetPc = LdrGetSymbol(
                    ViewBase,
                    String,
                    0);

                if (NULL != TargetPc) {

#ifndef _WIN64
                    Number = __rds32(TargetPc + 1);
#else
                    Number = __rds32(TargetPc + 4);
#endif // !_WIN64
                }

                ZwUnmapViewOfSection(NtCurrentProcess(), ViewBase);
            }

            ZwClose(Section);
        }

        ZwClose(Handle);
    }

    return Number;
}

ptr
NTAPI
LdrNameToAddress(
    __in cptr String
)
{
    ptr RoutineAddress = NULL;
    UNICODE_STRING RoutineString = { 0 };
    s32 Number = -1;
    u8ptr ControlPc = NULL;
    u8ptr TargetPc = NULL;
    u32 FirstLength = 0;
    u32 Length = 0;

    if (0 == _cmpbyte(String[0], 'Z') &&
        0 == _cmpbyte(String[1], 'w')) {
        RtlInitUnicodeString(&RoutineString, L"ZwClose");

        ControlPc = MmGetSystemRoutineAddress(&RoutineString);

        if (NULL != ControlPc) {
            Number = LdrNameToNumber("NtClose");

            RoutineAddress = ControlPc +
                RtBlock.NameInterval * (s)(LdrNameToNumber(String) - Number);
        }
    }
    else if (0 == _cmpbyte(String[0], 'N') &&
        0 == _cmpbyte(String[1], 't')) {
        Number = LdrNameToNumber(String);

#ifndef _WIN64
        RoutineAddress = UlongToPtr(RtBlock.KeServiceDescriptorTable[0].Base[Number]);
#else
        RoutineAddress = (u8ptr)RtBlock.KeServiceDescriptorTable[0].Base +
            (((s32ptr)RtBlock.KeServiceDescriptorTable[0].Base)[Number] >> 4);
#endif // !_WIN64
    }

    return RoutineAddress;
}

ptr
NTAPI
LdrLoadImport(
    __in cptr ImageName
)
{
    status Status = STATUS_SUCCESS;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry = NULL;
    ANSI_STRING String = { 0 };
    UNICODE_STRING ImageFileName = { 0 };
    ptr ImageBase = NULL;

    RtlInitAnsiString(&String, ImageName);

    Status = RtlAnsiStringToUnicodeString(
        &ImageFileName,
        &String,
        TRUE);

    if (TRACE(Status)) {
        Status = FindEntryForImage(
            &ImageFileName,
            &DataTableEntry);

        if (NT_SUCCESS(Status)) {
            ImageBase = DataTableEntry->DllBase;
        }

        RtlFreeUnicodeString(&ImageFileName);
    }

    return ImageBase;
}

void
NTAPI
LdrSnapThunk(
    __in ptr ImageBase
)
{
    status Status = STATUS_SUCCESS;
    PIMAGE_IMPORT_DESCRIPTOR ImportDirectory = NULL;
    u32 Size = 0;
    PIMAGE_THUNK_DATA OriginalThunk = NULL;
    PIMAGE_THUNK_DATA Thunk = NULL;
    PIMAGE_IMPORT_BY_NAME ImportByName = NULL;
    cptr ImageName = NULL;
    ptr ImportBase = NULL;
    u16 Ordinal = 0;
    ptr FunctionAddress = NULL;

    ImportDirectory = RtlImageDirectoryEntryToData(
        ImageBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_IMPORT,
        &Size);

    if (0 != Size) {
        do {
            OriginalThunk = (u8ptr)ImageBase + ImportDirectory->OriginalFirstThunk;
            Thunk = (u8ptr)ImageBase + ImportDirectory->FirstThunk;
            ImageName = (u8ptr)ImageBase + ImportDirectory->Name;

            ImportBase = LdrLoadImport(ImageName);

            if (NULL != ImportBase) {
                do {
                    if (IMAGE_SNAP_BY_ORDINAL(OriginalThunk->u1.Ordinal)) {
                        Ordinal = (u16)IMAGE_ORDINAL(OriginalThunk->u1.Ordinal);

                        FunctionAddress = LdrGetSymbol(
                            ImportBase,
                            NULL,
                            Ordinal);

                        if (NULL != FunctionAddress) {
                            Thunk->u1.Function = (u)FunctionAddress;
                        }
                        else {
                            vDbgPrint(
                                "[SHARK] import procedure ordinal@%d not found\n",
                                Ordinal);
                        }
                    }
                    else {
                        ImportByName = (u8ptr)ImageBase + OriginalThunk->u1.AddressOfData;

                        if ((0 == _cmpbyte(ImportByName->Name[0], 'Z') &&
                            0 == _cmpbyte(ImportByName->Name[1], 'w')) ||
                            (0 == _cmpbyte(ImportByName->Name[0], 'N') &&
                                0 == _cmpbyte(ImportByName->Name[1], 't'))) {
                            FunctionAddress = LdrNameToAddress(ImportByName->Name);
                        }
                        else {
                            FunctionAddress = LdrGetSymbol(
                                ImportBase,
                                ImportByName->Name,
                                0);
                        }

                        if (NULL != FunctionAddress) {
                            Thunk->u1.Function = (u)FunctionAddress;
                        }
                        else {
                            vDbgPrint(
                                "[SHARK] import procedure %hs not found\n",
                                ImportByName->Name);
                        }
                    }

                    OriginalThunk++;
                    Thunk++;
                } while (OriginalThunk->u1.Function);
            }
            else {
                vDbgPrint(
                    "[SHARK] import %hs not found\n",
                    ImageName);
            }

            ImportDirectory++;
        } while (0 != ImportDirectory->Characteristics);
    }
}

void
NTAPI
LdrEnumerateThunk(
    __in ptr ImageBase
)
{
    PIMAGE_IMPORT_DESCRIPTOR ImportDirectory = NULL;
    u32 Size = 0;
    PIMAGE_THUNK_DATA OriginalThunk = NULL;
    PIMAGE_THUNK_DATA Thunk = NULL;
    PIMAGE_IMPORT_BY_NAME ImportByName = NULL;
    cptr ImportImageName = NULL;
    u16 Ordinal = 0;

    ImportDirectory = RtlImageDirectoryEntryToData(
        ImageBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_IMPORT,
        &Size);

    if (0 != Size) {
        do {
            OriginalThunk = (u8ptr)ImageBase + ImportDirectory->OriginalFirstThunk;
            Thunk = (u8ptr)ImageBase + ImportDirectory->FirstThunk;
            ImportImageName = (u8ptr)ImageBase + ImportDirectory->Name;

            do {
                if (IMAGE_SNAP_BY_ORDINAL(OriginalThunk->u1.Ordinal)) {
                    Ordinal = (u16)IMAGE_ORDINAL(OriginalThunk->u1.Ordinal);

                    vDbgPrint(
                        "[SHARK] < %p > %s @%d\n",
                        Thunk->u1.Function,
                        ImportImageName,
                        Ordinal);
                }
                else {
                    ImportByName = (u8ptr)ImageBase + OriginalThunk->u1.AddressOfData;

                    vDbgPrint(
                        "[SHARK] < %p > %s %s\n",
                        Thunk->u1.Function,
                        ImportImageName,
                        ImportByName->Name);
                }

                OriginalThunk++;
                Thunk++;
            } while (OriginalThunk->u1.Function);

            ImportDirectory++;
        } while (0 != ImportDirectory->Characteristics);
    }
}

void
NTAPI
LdrReplaceThunk(
    __in ptr ImageBase,
    __in_opt cptr ImageName,
    __in_opt cptr ProcedureName,
    __in_opt u32 ProcedureNumber,
    __in ptr ProcedureAddress
)
{
    PIMAGE_IMPORT_DESCRIPTOR ImportDirectory = NULL;
    u32 Size = 0;
    PIMAGE_THUNK_DATA OriginalThunk = NULL;
    PIMAGE_THUNK_DATA Thunk = NULL;
    PIMAGE_IMPORT_BY_NAME ImportByName = NULL;
    cptr ImportImageName = NULL;
    u16 Ordinal = 0;

    ImportDirectory = RtlImageDirectoryEntryToData(
        ImageBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_IMPORT,
        &Size);

    if (0 != Size) {
        do {
            OriginalThunk = (u8ptr)ImageBase + ImportDirectory->OriginalFirstThunk;
            Thunk = (u8ptr)ImageBase + ImportDirectory->FirstThunk;
            ImportImageName = (u8ptr)ImageBase + ImportDirectory->Name;

            if (NULL != ImageName) {
                if (0 != _stricmp(ImportImageName, ImageName)) {
                    ImportDirectory++;

                    continue;
                }
            }

            do {
                if (IMAGE_SNAP_BY_ORDINAL(OriginalThunk->u1.Ordinal)) {
                    Ordinal = (u16)IMAGE_ORDINAL(OriginalThunk->u1.Ordinal);

                    if (0 != ProcedureNumber &&
                        Ordinal == ProcedureNumber) {
                        MapLockedCopyInstruction(
                            &Thunk->u1.Function, &ProcedureAddress, sizeof(ptr));
                    }
                }
                else {
                    ImportByName = (u8ptr)ImageBase + OriginalThunk->u1.AddressOfData;

                    if (NULL != ProcedureName &&
                        0 == _stricmp(
                            ImportByName->Name,
                            ProcedureName)) {
                        MapLockedCopyInstruction(
                            &Thunk->u1.Function, &ProcedureAddress, sizeof(ptr));
                    }
                }

                OriginalThunk++;
                Thunk++;
            } while (OriginalThunk->u1.Function);

            ImportDirectory++;
        } while (0 != ImportDirectory->Characteristics);
    }
}

ptr
NTAPI
LdrAllocate(
    __in ptr ViewBase
)
{
    ptr ImageBase = NULL;
    u32 SizeOfEntry = 0;

    SizeOfEntry = LdrGetSize(ViewBase) + PAGE_SIZE;

    ImageBase = __malloc(SizeOfEntry);

    if (NULL != ImageBase) {
        ImageBase = (u8ptr)ImageBase + PAGE_SIZE;
    }

    return ImageBase;
}

u32
NTAPI
LdrMakeProtection(
    __in PIMAGE_SECTION_HEADER NtSection
)
{
    u8 Protection[] = {
        PAGE_NOACCESS,
        PAGE_EXECUTE,
        PAGE_READONLY,
        PAGE_EXECUTE_READ,
        PAGE_READWRITE,
        PAGE_EXECUTE_READWRITE,
        PAGE_READWRITE,
        PAGE_EXECUTE_READWRITE
    };

    return Protection[NtSection->Characteristics >> 29];
}

s
NTAPI
LdrSetImageBase(
    __in ptr ImageBase
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    s Diff = 0;

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        if (IMAGE_NT_OPTIONAL_HDR32_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Diff = (s)ImageBase
                - (s)((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase;

            ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase =
                (u)ImageBase;
        }

        if (IMAGE_NT_OPTIONAL_HDR64_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Diff = (s64)ImageBase
                - (s64)((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.ImageBase;

            ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.ImageBase =
                (u64)ImageBase;
        }
    }

    return Diff;
}

ptr
NTAPI
LdrMapSection(
    __in ptr ViewBase,
    __in u32 Flags
)
{
    ptr ImageBase = NULL;
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    PIMAGE_SECTION_HEADER NtSection = NULL;
    s Diff = 0;
    u Index = 0;
    u32 SizeToLock = 0;

    NtHeaders = RtlImageNtHeader(ViewBase);

    if (NULL != NtHeaders) {
        ImageBase = LdrAllocate(ViewBase);

        if (NULL != ImageBase) {
            RtlZeroMemory(
                ImageBase,
                NtHeaders->OptionalHeader.SizeOfImage);

            NtSection = IMAGE_FIRST_SECTION(NtHeaders);

            RtlCopyMemory(
                ImageBase,
                ViewBase,
                NtSection->VirtualAddress);

            for (Index = 0;
                Index < NtHeaders->FileHeader.NumberOfSections;
                Index++) {
                if (0 != NtSection[Index].VirtualAddress) {
                    SizeToLock = max(
                        NtSection[Index].SizeOfRawData,
                        NtSection[Index].Misc.VirtualSize);

                    RtlCopyMemory(
                        (u8ptr)ImageBase + NtSection[Index].VirtualAddress,
                        (u8ptr)ViewBase
                        + (LDRP_REDIRECTED == (Flags & LDRP_REDIRECTED) ?
                            NtSection[Index].VirtualAddress : NtSection[Index].PointerToRawData),
                        SizeToLock);
                }
            }

            Diff = LdrSetImageBase(ImageBase);

            if (0 != Diff) {
                LdrRelocImage(ImageBase, Diff);
            }

            LdrSnapThunk(ImageBase);
        }
    }

    return ImageBase;
}

PKLDR_DATA_TABLE_ENTRY
NTAPI
LdrLoad(
    __in ptr ViewBase,
    __in wcptr ImageName,
    __in u32 Flags
)
{
    status Status = STATUS_SUCCESS;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry = NULL;
    UNICODE_STRING ImageFileName = { 0 };
    ptr ImageBase = NULL;
    wcptr BaseName = NULL;

    BaseName = wcsrchr(ImageName, L'\\');

    if (NULL == BaseName) {
        BaseName = ImageName;
    }
    else {
        BaseName++;
    }

    RtlInitUnicodeString(&ImageFileName, BaseName);

    Status = FindEntryForImage(
        &ImageFileName,
        &DataTableEntry);

    if (NT_SUCCESS(Status)) {
        DataTableEntry->LoadCount++;
    }
    else {
        ImageBase = LdrMapSection(ViewBase, Flags);

        if (NULL != ImageBase) {
            DataTableEntry = (PKLDR_DATA_TABLE_ENTRY)
                ((u8ptr)ImageBase - PAGE_SIZE);

            RtlZeroMemory(
                DataTableEntry,
                sizeof(KLDR_DATA_TABLE_ENTRY) +
                MAXIMUM_FILENAME_LENGTH * sizeof(wc) * 2);

            DataTableEntry->DllBase = ImageBase;
            DataTableEntry->SizeOfImage = LdrGetSize(ImageBase);
            DataTableEntry->EntryPoint = LdrGetEntryPoint(ImageBase);
            DataTableEntry->Flags = Flags & ~LDRP_ENTRY_INSERTED;
            DataTableEntry->LoadCount = 0;

            DataTableEntry->FullDllName.Buffer = DataTableEntry + 1;

            DataTableEntry->FullDllName.MaximumLength =
                MAXIMUM_FILENAME_LENGTH * sizeof(wc);

            wcscpy(DataTableEntry->FullDllName.Buffer, SystemRootDirectory);
            wcscat(DataTableEntry->FullDllName.Buffer, BaseName);

            DataTableEntry->FullDllName.Length =
                wcslen(DataTableEntry->FullDllName.Buffer) * sizeof(wc);

            DataTableEntry->BaseDllName.Buffer =
                DataTableEntry->FullDllName.Buffer + MAXIMUM_FILENAME_LENGTH;

            DataTableEntry->BaseDllName.MaximumLength =
                MAXIMUM_FILENAME_LENGTH * sizeof(wc);

            wcscpy(DataTableEntry->BaseDllName.Buffer, BaseName);

            DataTableEntry->BaseDllName.Length =
                wcslen(DataTableEntry->BaseDllName.Buffer) * sizeof(wc);

            if (LDRP_ENTRY_INSERTED == (Flags & LDRP_ENTRY_INSERTED)) {
                if (CmdPgClear ==
                    (RtBlock.Operation & CmdPgClear)) {
                    CaptureImageExceptionValues(
                        DataTableEntry->DllBase,
                        &DataTableEntry->ExceptionTable,
                        &DataTableEntry->ExceptionTableSize);

#ifdef _WIN64
                    InsertInvertedFunctionTable(
                        DataTableEntry->DllBase,
                        DataTableEntry->SizeOfImage);
#endif // _WIN64
                }

                RtBlock.KeEnterCriticalRegion();
                ExAcquireResourceExclusiveLite(RtBlock.PsLoadedModuleResource, TRUE);

                InsertTailList(
                    &RtBlock.LoadedModuleList,
                    &DataTableEntry->InLoadOrderLinks);

                ExReleaseResourceLite(RtBlock.PsLoadedModuleResource);
                RtBlock.KeLeaveCriticalRegion();

                DataTableEntry->LoadCount++;
            }
        }
    }

    return DataTableEntry;
}

void
NTAPI
LdrUnload(
    __in PKLDR_DATA_TABLE_ENTRY DataTableEntry
)
{
    status Status = STATUS_SUCCESS;

    DataTableEntry->LoadCount--;

    if (0 == DataTableEntry->LoadCount) {
        RtBlock.KeEnterCriticalRegion();
        ExAcquireResourceExclusiveLite(RtBlock.PsLoadedModuleResource, TRUE);

        RemoveEntryList(&DataTableEntry->InLoadOrderLinks);

        ExReleaseResourceLite(RtBlock.PsLoadedModuleResource);
        RtBlock.KeLeaveCriticalRegion();

        if (CmdPgClear ==
            (RtBlock.Operation & CmdPgClear)) {
#ifdef _WIN64
            RemoveInvertedFunctionTable(DataTableEntry->DllBase);
#endif // _WIN64
        }

        __free(DataTableEntry);
    }
}

void
NTAPI
DumpImageWorker(
    __in ptr ImageBase,
    __in u32 SizeOfImage,
    __in PUNICODE_STRING ImageFIleName
)
{
    status Status = STATUS_SUCCESS;
    ptr FileHandle = NULL;
    UNICODE_STRING FilePath = { 0 };
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    PIMAGE_SECTION_HEADER NtSection = NULL;
    u Index = 0;
    u32 SizeToLock = 0;
    GUID Guid = { 0 };
    wc FilePathBuffer[MAXIMUM_FILENAME_LENGTH] = { 0 };
    wc FileBaseBuffer[MAXIMUM_FILENAME_LENGTH] = { 0 };
    u32 FileBaseNumberOfElements = 0;
    wc FileExtBuffer[MAXIMUM_FILENAME_LENGTH] = { 0 };
    u32 FileExtNumberOfElements = 0;
    LARGE_INTEGER ByteOffset = { 0 };
    PMMPTE PointerPde = NULL;
    PMMPTE PointerPte = NULL;

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        Status = ExUuidCreate(&Guid);

        if (TRACE(Status)) {
            Index = ImageFIleName->Length / sizeof(wc);

            do {
                Index--;

                if (L'.' == ImageFIleName->Buffer[Index]) {
                    FileExtNumberOfElements =
                        ImageFIleName->Length - Index * sizeof(wc);

                    RtlCopyMemory(
                        FileExtBuffer,
                        &ImageFIleName->Buffer[Index],
                        FileExtNumberOfElements);

                    break;
                }
            } while (Index > 0);

            Index = ImageFIleName->Length / sizeof(wc);

            do {
                Index--;

                if (L'\\' == ImageFIleName->Buffer[Index]) {
                    FileBaseNumberOfElements =
                        ImageFIleName->Length - Index * sizeof(wc);

                    RtlCopyMemory(
                        FileBaseBuffer,
                        &ImageFIleName->Buffer[Index],
                        FileBaseNumberOfElements);

                    break;
                }
            } while (Index > 0);

            swprintf(
                FilePathBuffer,
                L"\\??\\c:");

            RtlInitUnicodeString(&FilePath, FilePathBuffer);

            RtlCopyMemory(
                (u8ptr)FilePath.Buffer + FilePath.Length,
                FileBaseBuffer,
                FileBaseNumberOfElements - FileExtNumberOfElements);

            RtlInitUnicodeString(&FilePath, FilePathBuffer);

            swprintf(
                (u8ptr)FilePath.Buffer + FilePath.Length,
                L".{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                Guid.Data1,
                Guid.Data2,
                Guid.Data3,
                Guid.Data4[0],
                Guid.Data4[1],
                Guid.Data4[2],
                Guid.Data4[3],
                Guid.Data4[4],
                Guid.Data4[5],
                Guid.Data4[6],
                Guid.Data4[7]);

            RtlInitUnicodeString(&FilePath, FilePathBuffer);

            RtlCopyMemory(
                (u8ptr)FilePath.Buffer + FilePath.Length,
                FileExtBuffer,
                FileExtNumberOfElements);

            RtlInitUnicodeString(&FilePath, FilePathBuffer);

            for (Index = 0;
                Index < (FilePath.Length / sizeof(wc));
                Index++) {
                FilePath.Buffer[Index] = towlower(FilePath.Buffer[Index]);
            }

            InitializeObjectAttributes(
                &ObjectAttributes,
                &FilePath,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

            Status = ZwCreateFile(
                &FileHandle,
                FILE_ALL_ACCESS,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OVERWRITE_IF,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE,
                NULL,
                0);

            if (TRACE(Status)) {
                NtSection = IMAGE_FIRST_SECTION(NtHeaders);

                ByteOffset.QuadPart = 0;

                TRACE(ZwWriteFile(
                    FileHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    ImageBase,
                    NtSection->VirtualAddress,
                    &ByteOffset,
                    NULL));

                for (Index = 0;
                    Index < NtHeaders->FileHeader.NumberOfSections;
                    Index++) {
                    if (0 != NtSection[Index].VirtualAddress) {
                        ByteOffset.QuadPart = NtSection[Index].PointerToRawData;

                        SizeToLock = max(
                            NtSection[Index].SizeOfRawData,
                            NtSection[Index].Misc.VirtualSize);

                        PointerPte =
                            GetPteAddress((u8ptr)ImageBase +
                                NtSection[Index].VirtualAddress);

                        PointerPde =
                            GetPdeAddress((u8ptr)ImageBase +
                                NtSection[Index].VirtualAddress);

                        if (0 != PointerPde->u.Hard.Valid) {
                            if (0 != PointerPde->u.Hard.LargePage ||
                                (0 == PointerPde->u.Hard.LargePage && 0 != PointerPte->u.Hard.Valid)) {
                                TRACE(ZwWriteFile(
                                    FileHandle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    (u8ptr)ImageBase + NtSection[Index].VirtualAddress,
                                    SizeToLock,
                                    &ByteOffset,
                                    NULL));
                            }
                        }
                    }
                }

                TRACE(ZwClose(FileHandle));

#ifdef DEBUG
                vDbgPrint(
                    "[SHARK] dumped < %p - %08x > %wZ\n",
                    ImageBase,
                    SizeOfImage,
                    &FilePath);
#endif // DEBUG
            }
        }
    }
}

status
NTAPI
DumpFileWorker(
    __in PUNICODE_STRING ImageFIleName
)
{
    status Status = STATUS_SUCCESS;
    ptr SourceFileHandle = NULL;
    ptr DestinationFileHandle = NULL;
    UNICODE_STRING FilePath = { 0 };
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    FILE_STANDARD_INFORMATION StandardInformation = { 0 };
    LARGE_INTEGER ByteOffset = { 0 };
    ptr Buffer = NULL;
    GUID Guid = { 0 };
    wc FilePathBuffer[MAXIMUM_FILENAME_LENGTH] = { 0 };
    wc FileBaseBuffer[MAXIMUM_FILENAME_LENGTH] = { 0 };
    u32 FileBaseNumberOfElements = 0;
    wc FileExtBuffer[MAXIMUM_FILENAME_LENGTH] = { 0 };
    u32 FileExtNumberOfElements = 0;
    u32 Index = 0;

    InitializeObjectAttributes(
        &ObjectAttributes,
        ImageFIleName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL);

    Status = ZwOpenFile(
        &SourceFileHandle,
        FILE_EXECUTE | FILE_READ_DATA,
        &ObjectAttributes,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_DELETE,
        0);

    if (TRACE(Status)) {
        Status = ZwQueryInformationFile(
            SourceFileHandle,
            &IoStatusBlock,
            &StandardInformation,
            sizeof(FILE_STANDARD_INFORMATION),
            FileStandardInformation);

        if (TRACE(Status)) {
            Buffer =
                __malloc(StandardInformation.EndOfFile.LowPart);

            if (NULL != Buffer) {
                ByteOffset.QuadPart = 0;

                Status = ZwReadFile(
                    SourceFileHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    Buffer,
                    StandardInformation.EndOfFile.LowPart,
                    &ByteOffset,
                    NULL);

                if (TRACE(Status)) {
                    Status = ExUuidCreate(&Guid);

                    if (TRACE(Status)) {
                        Index = ImageFIleName->Length / sizeof(wc);

                        do {
                            Index--;

                            if (L'.' == ImageFIleName->Buffer[Index]) {
                                FileExtNumberOfElements =
                                    ImageFIleName->Length - Index * sizeof(wc);

                                RtlCopyMemory(
                                    FileExtBuffer,
                                    &ImageFIleName->Buffer[Index],
                                    FileExtNumberOfElements);

                                break;
                            }
                        } while (Index > 0);

                        Index = ImageFIleName->Length / sizeof(wc);

                        do {
                            Index--;

                            if (L'\\' == ImageFIleName->Buffer[Index]) {
                                FileBaseNumberOfElements =
                                    ImageFIleName->Length - Index * sizeof(wc);

                                RtlCopyMemory(
                                    FileBaseBuffer,
                                    &ImageFIleName->Buffer[Index],
                                    FileBaseNumberOfElements);

                                break;
                            }
                        } while (Index > 0);

                        swprintf(
                            FilePathBuffer,
                            L"\\??\\c:");

                        RtlInitUnicodeString(&FilePath, FilePathBuffer);

                        RtlCopyMemory(
                            (u8ptr)FilePath.Buffer + FilePath.Length,
                            FileBaseBuffer,
                            FileBaseNumberOfElements - FileExtNumberOfElements);

                        RtlInitUnicodeString(&FilePath, FilePathBuffer);

                        swprintf(
                            (u8ptr)FilePath.Buffer + FilePath.Length,
                            L".{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                            Guid.Data1,
                            Guid.Data2,
                            Guid.Data3,
                            Guid.Data4[0],
                            Guid.Data4[1],
                            Guid.Data4[2],
                            Guid.Data4[3],
                            Guid.Data4[4],
                            Guid.Data4[5],
                            Guid.Data4[6],
                            Guid.Data4[7]);

                        RtlInitUnicodeString(&FilePath, FilePathBuffer);

                        RtlCopyMemory(
                            (u8ptr)FilePath.Buffer + FilePath.Length,
                            FileExtBuffer,
                            FileExtNumberOfElements);

                        RtlInitUnicodeString(&FilePath, FilePathBuffer);

                        for (Index = 0;
                            Index < (FilePath.Length / sizeof(wc));
                            Index++) {
                            FilePath.Buffer[Index] = towlower(FilePath.Buffer[Index]);
                        }

                        InitializeObjectAttributes(
                            &ObjectAttributes,
                            &FilePath,
                            OBJ_CASE_INSENSITIVE,
                            NULL,
                            NULL);

                        Status = ZwCreateFile(
                            &DestinationFileHandle,
                            FILE_ALL_ACCESS,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ,
                            FILE_OVERWRITE_IF,
                            FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE,
                            NULL,
                            0);

                        if (TRACE(Status)) {
                            ByteOffset.QuadPart = 0;

                            TRACE(ZwWriteFile(
                                DestinationFileHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                Buffer,
                                StandardInformation.EndOfFile.LowPart,
                                &ByteOffset,
                                NULL));

                            TRACE(ZwFlushBuffersFile(DestinationFileHandle, &IoStatusBlock));
                            TRACE(ZwClose(DestinationFileHandle));

#ifdef DEBUG
                            vDbgPrint(
                                "[SHARK] dumped %wZ to %wZ\n",
                                ImageFIleName,
                                &FilePath);
#endif // DEBUG
                        }
                    }
                }

                __free(Buffer);
            }
        }

        ZwClose(SourceFileHandle);
    }

    return Status;
}

```

`Reload.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _RELOAD_H_
#define _RELOAD_H_

#include <devicedefs.h>
#include <guarddefs.h>
#include <dump.h>

#include "Space.h"

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

    typedef s32 EX_SPIN_LOCK, *PEX_SPIN_LOCK;

    typedef enum _OB_PREOP_CALLBACK_STATUS OB_PREOP_CALLBACK_STATUS;
    typedef struct _OB_PRE_OPERATION_INFORMATION *POB_PRE_OPERATION_INFORMATION;
    typedef struct _OB_POST_OPERATION_INFORMATION *POB_POST_OPERATION_INFORMATION;

    // runtime state block
    typedef struct _RTB {
        PLIST_ENTRY PsLoadedModuleList;
        PEPROCESS PsInitialSystemProcess;
        PERESOURCE PsLoadedModuleResource;
        struct _FUNCTION_TABLE * PsInvertedFunctionTable;
        KSERVICE_TABLE_DESCRIPTOR * KeServiceDescriptorTable;
        KSERVICE_TABLE_DESCRIPTOR * KeServiceDescriptorTableShadow;
        PKLDR_DATA_TABLE_ENTRY KernelDataTableEntry; // ntoskrnl.exe

        union {
            SUPDRVLDRIMAGE SupImage;

            struct {
                KLDR_DATA_TABLE_ENTRY DataTableEntry;
                wc FullDllName[MAXIMUM_FILENAME_LENGTH];
                wc BaseDllName[MAXIMUM_FILENAME_LENGTH];
            };
        }*Self;

        ptr CpuControlBlock; // hypervisor

        ptr NativeObject;

#ifdef _WIN64
        ptr Wx86NativeObject;
#endif // _WIN64

        LIST_ENTRY LoadedModuleList;

        LIST_ENTRY Object;
        KSPIN_LOCK Lock;

        s8 NumberProcessors;
        s8 Linkage[3];// { 0x33, 0xc0, 0xc3 };

        u32 BuildNumber;
        u32 Operation;
        u64 * PerfGlobalGroupMask;
        s8 KiSystemServiceCopyEnd[6];
        cptr PerfInfoLogSysCallEntry;
        ptr KeUserExceptionDispatcher;

#ifdef _WIN64
        PMMPTE PxeBase;
        PMMPTE PxeTop;

        PMMPTE PpeBase;
        PMMPTE PpeTop;
#endif // _WIN64

        PMMPTE PdeBase;
        PMMPTE PdeTop;

        PMMPTE PteBase;
        PMMPTE PteTop;

        void
        (NTAPI * KiDispatchException)(
            __in PEXCEPTION_RECORD ExceptionRecord,
            __in PKEXCEPTION_FRAME ExceptionFrame,
            __in PKTRAP_FRAME TrapFrame,
            __in KPROCESSOR_MODE PreviousMode,
            __in b FirstChance
            );

        void
        (NTAPI * KeContextFromKframes)(
            __in PKTRAP_FRAME TrapFrame,
#if defined(_X86_)
            __in_opt PKEXCEPTION_FRAME ExceptionFrame,
#else
            __in PKEXCEPTION_FRAME ExceptionFrame,
#endif
            __inout PCONTEXT ContextFrame
            );

        void
        (NTAPI * KeContextToKframes)(
            __inout PKTRAP_FRAME TrapFrame,

#if defined(_X86_)
            __inout_opt PKEXCEPTION_FRAME ExceptionFrame,
#else
            __inout PKEXCEPTION_FRAME ExceptionFrame,
#endif
            __in PCONTEXT ContextFrame,
            __in u32 ContextFlags,
            __in KPROCESSOR_MODE PreviousMode
            );

#ifndef _WIN64
        status
        (NTAPI * DbgkpSendApiMessageLpc)(
            __inout ptr ApiMsg,
            __in ptr Port,
            __in b SuspendProcess
            );

        status
        (FASTCALL * FastDbgkpSendApiMessageLpc)(
            __inout ptr ApiMsg,
            __in ptr Port,
            __in b SuspendProcess
            );
#else
        status
        (FASTCALL * DbgkpSendApiMessageLpc)(
            __inout ptr ApiMsg,
            __in ptr Port,
            __in b SuspendProcess
            );
#endif // !_WIN64

        status
        (NTAPI * ProcessOpen)(
            __in OB_OPEN_REASON OpenReason,
            __in KPROCESSOR_MODE PreviousMode,
            __in_opt PEPROCESS Process,
            __in ptr ProcessObject,
            __in ACCESS_MASK * GrantedAccess,
            __in u32 HandleCount
            );

        void
        (NTAPI * ProcessDelete)(
            __in ptr ProcessObject
            );

        status
        (NTAPI * ThreadOpen)(
            __in OB_OPEN_REASON OpenReason,
            __in KPROCESSOR_MODE PreviousMode,
            __in_opt PEPROCESS Process,
            __in ptr ThreadObject,
            __in ACCESS_MASK * GrantedAccess,
            __in u32 HandleCount
            );

        void
        (NTAPI * ThreadDelete)(
            __in ptr ThreadObject
            );

        status
        (NTAPI * FileOpen)(
            __in OB_OPEN_REASON OpenReason,
            __in KPROCESSOR_MODE PreviousMode,
            __in_opt PEPROCESS Process,
            __in ptr FileObject,
            __in ACCESS_MASK * GrantedAccess,
            __in u32 HandleCount
            );

        status
        (NTAPI * FileParse)(
            __in ptr ParseObject,
            __in ptr ObjectType,
            __in PACCESS_STATE AccessState,
            __in KPROCESSOR_MODE AccessMode,
            __in u32 Attributes,
            __inout PUNICODE_STRING CompleteName,
            __inout PUNICODE_STRING RemainingName,
            __inout_opt ptr Context,
            __in_opt PSECURITY_QUALITY_OF_SERVICE SecurityQos,
            __out ptr * FileObject
            );

        void
        (NTAPI * FileDelete)(
            __in ptr FileObject
            );

        status
        (NTAPI * DriverOpen)(
            __in OB_OPEN_REASON OpenReason,
            __in KPROCESSOR_MODE PreviousMode,
            __in_opt PEPROCESS Process,
            __in ptr DriverObject,
            __in ACCESS_MASK * GrantedAccess,
            __in u32 HandleCount
            );

        void
        (NTAPI * DriverDelete)(
            __in ptr DriverObject
            );

        OB_PREOP_CALLBACK_STATUS
        (NTAPI * GlobalObjectPreCallback)(
            __in ptr RegistrationContext,
            __in POB_PRE_OPERATION_INFORMATION OperationInformation
            );

        void
        (NTAPI * GlobalObjectPostCallback)(
            __in ptr RegistrationContext,
            __in POB_POST_OPERATION_INFORMATION OperationInformation
            );

        void
        (NTAPI * GlobalProcessNotify)(
            __in ptr ParentId,
            __in ptr ProcessId,
            __in b Create
            );

        void
        (NTAPI * GlobalThreadNotify)(
            __in ptr ProcessId,
            __in ptr ThreadId,
            __in b Create
            );

        void
        (NTAPI * GlobalImageNotify)(
            __in PUNICODE_STRING FullImageName,
            __in ptr ProcessId,
            __in PIMAGE_INFO ImageInfo
            );

        void
        (NTAPI * KeEnterCriticalRegion)(
            void
            );

        void
        (NTAPI * KeLeaveCriticalRegion)(
            void
            );

        status
        (NTAPI * PspCreateThread)(
            __out ptr * ThreadHandle,
            __in ACCESS_MASK DesiredAccess,
            __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
            __in ptr ProcessHandle,
            __in PEPROCESS ProcessPointer,
            __in_opt ptr Reserved,
            __in_opt PLARGE_INTEGER Cookie,
            __out_opt PCLIENT_ID ClientId,
            __in_opt PCONTEXT ThreadContext,
            __in_opt PINITIAL_TEB InitialTeb,
            __in b CreateSuspended,
            __in_opt PKSTART_ROUTINE StartRoutine,
            __in ptr StartContext
            );

        void
        (NTAPI * PspInitializeThunkContext)(
            void
            );

        b
        (FASTCALL * ExAcquireRundownProtection)(
            __inout PEX_RUNDOWN_REF RunRef
            );

        void
        (FASTCALL * ExReleaseRundownProtection)(
            __inout PEX_RUNDOWN_REF RunRef
            );

        void
        (FASTCALL * ExWaitForRundownProtectionRelease)(
            __inout PEX_RUNDOWN_REF RunRef
            );

        KIRQL
        (NTAPI * ExAcquireSpinLockShared)(
            __inout PEX_SPIN_LOCK SpinLock
            );

        void
        (NTAPI * ExReleaseSpinLockShared)(
            __inout PEX_SPIN_LOCK SpinLock,
            __in KIRQL OldIrql
            );

        u32
        (NTAPI * DbgPrint)(
            __in PCH Format,
            ...
            );

        NTSTATUS
        (NTAPI *  KeWaitForSingleObject)(
            __in PVOID Object,
            __in KWAIT_REASON WaitReason,
            __in KPROCESSOR_MODE WaitMode,
            __in BOOLEAN Alertable,
            __in_opt PLARGE_INTEGER Timeout
            );

        u
        (NTAPI * RtlCompareMemory)(
            const void * Destination,
            const void * Source,
            u Length
            );

        void
        (NTAPI * RtlRestoreContext)(
            __in PCONTEXT ContextRecord,
            __in_opt struct _EXCEPTION_RECORD *ExceptionRecord
            );

        void
        (NTAPI * ExQueueWorkItem)(
            __inout PWORK_QUEUE_ITEM WorkItem,
            __in WORK_QUEUE_TYPE QueueType
            );

        void
        (NTAPI * ExFreePoolWithTag)(
            __in ptr P,
            __in u32 Tag
            );

        PSAFEGUARD_OBJECT BugCheckHandle;

        void
        (NTAPI * KeBugCheckEx)(
            __in u32 BugCheckCode,
            __in u P1,
            __in u P2,
            __in u P3,
            __in u P4
            );

        PLIST_ENTRY
        (FASTCALL * ExInterlockedRemoveHeadList)(
            __inout PLIST_ENTRY ListHead,
            __inout PKSPIN_LOCK Lock
            );

        ptr ObjectCallback;

        KDDEBUGGER_DATA64 DebuggerDataBlock;
        KDDEBUGGER_DATA_ADDITION64 DebuggerDataAdditionBlock;

        u32 NameInterval;

        u16 OffsetKProcessThreadListHead;
        u16 OffsetKThreadThreadListEntry;
        u16 OffsetKThreadWin32StartAddress;
        u32 OffsetKThreadProcessId;
        u16 OffsetEProcessActiveProcessLinks;

        struct _PGBLOCK * PgBlock;
    } RTB, *PRTB;

    NTKERNELAPI
        status
        NTAPI
        PsAcquireProcessExitSynchronization(
            __in PEPROCESS Process
        );

    NTKERNELAPI
        void
        NTAPI
        PsReleaseProcessExitSynchronization(
            __in PEPROCESS Process
        );

#define FastAcquireRundownProtection(ref) \
            RtBlock.ExAcquireRundownProtection((ref))

#define FastReleaseRundownProtection(ref) \
            RtBlock.ExReleaseRundownProtection((ref))

#define FastWaitForRundownProtectionRelease(ref) \
            RtBlock.ExWaitForRundownProtectionRelease((ref))

#define FastAcquireObjectLock(irql) \
            *(irql) = RtBlock.ExAcquireSpinLockShared(&RtBlock.Lock)

#define FastReleaseObjectLock(irql) \
            RtBlock.ExReleaseSpinLockShared(&RtBlock.Lock, (irql))

    void
        NTAPI
        InitializeGpBlock(
            __in PRTB Block
        );

    u32
        NTAPI
        LdrMakeProtection(
            __in PIMAGE_SECTION_HEADER NtSection
        );

    u32
        NTAPI
        LdrGetPlatform(
            __in ptr ImageBase
        );

    u32
        NTAPI
        LdrGetTimeStamp(
            __in ptr ImageBase
        );

    u16
        NTAPI
        LdrGetSubsystem(
            __in ptr ImageBase
        );

    u32
        NTAPI
        LdrGetSize(
            __in ptr ImageBase
        );

    ptr
        NTAPI
        LdrGetEntryPoint(
            __in ptr ImageBase
        );

    PIMAGE_SECTION_HEADER
        NTAPI
        SectionTableFromVirtualAddress(
            __in ptr ImageBase,
            __in ptr Address
        );

    PIMAGE_SECTION_HEADER
        NTAPI
        LdrFindSection(
            __in ptr ImageBase,
            __in u8ptr SectionName
        );

    void
        NTAPI
        LdrRelocImage(
            __in ptr ImageBase,
            __in s Diff
        );

    status
        NTAPI
        FindEntryForImage(
            __in PUNICODE_STRING ImageFileName,
            __out PKLDR_DATA_TABLE_ENTRY * DataTableEntry
        );

    status
        NTAPI
        FindEntryForImageAddress(
            __in ptr Address,
            __out PKLDR_DATA_TABLE_ENTRY * DataTableEntry
        );

    ptr
        NTAPI
        LdrGetSymbol(
            __in ptr ImageBase,
            __in_opt cptr ProcedureName,
            __in_opt u32 ProcedureNumber
        );

    ptr
        NTAPI
        LdrNameToAddress(
            __in cptr String
        );

    void
        NTAPI
        LdrSnapThunk(
            __in ptr ImageBase
        );

    void
        NTAPI
        LdrEnumerateThunk(
            __in ptr ImageBase
        );

    void
        NTAPI
        LdrReplaceThunk(
            __in ptr ImageBase,
            __in_opt cptr ImageName,
            __in_opt cptr ProcedureName,
            __in_opt u32 ProcedureNumber,
            __in ptr ProcedureAddress
        );

    s
        NTAPI
        LdrSetImageBase(
            __in ptr ImageBase
        );

    PKLDR_DATA_TABLE_ENTRY
        NTAPI
        LdrLoad(
            __in ptr ViewBase,
            __in wcptr ImageName,
            __in u32 Flags
        );

    void
        NTAPI
        LdrUnload(
            __in PKLDR_DATA_TABLE_ENTRY DataTableEntry
        );

    void
        NTAPI
        DumpImageWorker(
            __in ptr ImageBase,
            __in u32 SizeOfImage,
            __in PUNICODE_STRING ImageFIleName
        );

    status
        NTAPI
        DumpFileWorker(
            __in PUNICODE_STRING ImageFIleName
        );

    extern RTB RtBlock;

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_RELOAD_H_

```

`Rtx.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Rtx.h"

#include "Ctx.h"
#include "Guard.h"
#include "Scan.h"

void
NTAPI
AsyncDispatcher(
    __in PKAPC Apc,
    __in PKNORMAL_ROUTINE * NormalRoutine,
    __in ptr * NormalContext,
    __in ptr * SystemArgument1,
    __in ptr * SystemArgument2
)
{
    PATX Atx = NULL;

    Atx = CONTAINING_RECORD(Apc, ATX, Apc);

    Atx->Rtx.Routines.Result = GuardCall(
        Atx->Rtx.Routines.KernelRoutine,
        Atx->Rtx.Routines.SystemRoutine,
        Atx->Rtx.Routines.RundownRoutine,
        Atx->Rtx.Routines.NormalRoutine);

    KeSetEvent(&Atx->Rtx.Notify, LOW_PRIORITY, FALSE);
}

status
NTAPI
AsyncCall(
    __in ptr UniqueThread,
    __in_opt PGKERNEL_ROUTINE KernelRoutine,
    __in_opt PGSYSTEM_ROUTINE SystemRoutine,
    __in_opt PGRUNDOWN_ROUTINE RundownRoutine,
    __in_opt PGNORMAL_ROUTINE NormalRoutine
)
{
    status Status = STATUS_SUCCESS;
    PETHREAD Thread = NULL;
    ATX Atx = { 0 };
    LARGE_INTEGER Timeout = { 0 };

    Status = PsLookupThreadByThreadId(
        UniqueThread,
        &Thread);

    if (TRACE(Status)) {
        Atx.Rtx.Routines.KernelRoutine = KernelRoutine;
        Atx.Rtx.Routines.SystemRoutine = SystemRoutine;
        Atx.Rtx.Routines.RundownRoutine = RundownRoutine;
        Atx.Rtx.Routines.NormalRoutine = NormalRoutine;

        KeInitializeEvent(
            &Atx.Rtx.Notify,
            SynchronizationEvent,
            FALSE);

        if ((u)KeGetCurrentThread() != (u)Thread) {
            KeInitializeApc(
                &Atx.Apc,
                Thread,
                OriginalApcEnvironment,
                AsyncDispatcher,
                NULL,
                NULL,
                KernelMode,
                NULL);

            Timeout.QuadPart = Int32x32To64(10, -10 * 1000 * 1000);

            if (FALSE != KeInsertQueueApc(
                &Atx.Apc,
                NULL,
                NULL,
                LOW_PRIORITY)) {
                Status = KeWaitForSingleObject(
                    &Atx.Rtx.Notify,
                    Executive,
                    KernelMode,
                    FALSE,
                    &Timeout);

                if (STATUS_SUCCESS == Status) {
                    Status = Atx.Rtx.Routines.Result;
                }
            }
            else {
                Status = STATUS_UNSUCCESSFUL;
            }
        }
        else {
            AsyncDispatcher(&Atx.Apc, NULL, NULL, NULL, NULL);

            Status = Atx.Rtx.Routines.Result;
        }

        ObDereferenceObject(Thread);
    }

    return Status;
}

void
NTAPI
IpiDispatcher(
    __in PRTX Rtx
)
{
    if (-1 == Rtx->Processor) {
        GuardCall(
            Rtx->Routines.KernelRoutine,
            Rtx->Routines.SystemRoutine,
            Rtx->Routines.RundownRoutine,
            Rtx->Routines.NormalRoutine);
    }
    else {
        if (KeGetCurrentProcessorNumber() == Rtx->Processor) {
            Rtx->Routines.Result = GuardCall(
                Rtx->Routines.KernelRoutine,
                Rtx->Routines.SystemRoutine,
                Rtx->Routines.RundownRoutine,
                Rtx->Routines.NormalRoutine);
        }
    }
}

u
NTAPI
IpiSingleCall(
    __in_opt PGKERNEL_ROUTINE KernelRoutine,
    __in_opt PGSYSTEM_ROUTINE SystemRoutine,
    __in_opt PGRUNDOWN_ROUTINE RundownRoutine,
    __in_opt PGNORMAL_ROUTINE NormalRoutine
)
{
    u Result = 0;
    RTX Rtx = { 0 };

    Rtx.Processor = KeGetCurrentProcessorNumber();

    Rtx.Routines.KernelRoutine = KernelRoutine;
    Rtx.Routines.SystemRoutine = SystemRoutine;
    Rtx.Routines.RundownRoutine = RundownRoutine;
    Rtx.Routines.NormalRoutine = NormalRoutine;

    KeIpiGenericCall(
        (PKIPI_BROADCAST_WORKER)IpiDispatcher,
        (u)&Rtx);

    Result = Rtx.Routines.Result;

    return Result;
}

void
NTAPI
IpiGenericCall(
    __in_opt PGKERNEL_ROUTINE KernelRoutine,
    __in_opt PGSYSTEM_ROUTINE SystemRoutine,
    __in_opt PGRUNDOWN_ROUTINE RundownRoutine,
    __in_opt PGNORMAL_ROUTINE NormalRoutine
)
{
    RTX Rtx = { 0 };

    Rtx.Processor = -1;

    Rtx.Routines.KernelRoutine = KernelRoutine;
    Rtx.Routines.SystemRoutine = SystemRoutine;
    Rtx.Routines.RundownRoutine = RundownRoutine;
    Rtx.Routines.NormalRoutine = NormalRoutine;

    KeIpiGenericCall(
        (PKIPI_BROADCAST_WORKER)IpiDispatcher,
        (u)&Rtx);
}

```

`Rtx.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _RTX_H_
#define _RTX_H_

#include <devicedefs.h>

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

    typedef struct _OBJECT *POBJECT;

    typedef struct _ROUTINES32 {
        u32 KernelRoutine;
        u32 SystemRoutine;
        u32 RundownRoutine;
        u32 NormalRoutine;
        u32 Result;
    }ROUTINES32, *PROUTINES32;

    typedef struct _ROUTINES64 {
        u64 KernelRoutine;
        u64 SystemRoutine;
        u64 RundownRoutine;
        u64 NormalRoutine;
        u64 Result;
    }ROUTINES64, *PROUTINES64;

    typedef struct _ROUTINES {
        PGKERNEL_ROUTINE KernelRoutine;
        PGSYSTEM_ROUTINE SystemRoutine;
        PGRUNDOWN_ROUTINE RundownRoutine;
        PGNORMAL_ROUTINE NormalRoutine;
        u Result;
    }ROUTINES, *PROUTINES;

    typedef struct _WORKER_OBJECT {
        SINGLE_LIST_ENTRY NextEntry;
        ROUTINES Routines;
    }WORKER_OBJECT, *PWORKER_OBJECT;

    typedef struct _RTX {
        POBJECT Object;
        POBJECT Target;
        ptr ApiMessage;
        KEVENT Notify;

        u16 Platform;
        u32 Processor;

        union {
            ROUTINES Routines;
            ROUTINES32 Routines32;
            ROUTINES64 Routines64;
        };

        KPROCESSOR_MODE Mode;
    } RTX, *PRTX;

    typedef struct _ATX {
        KAPC Apc;
        RTX Rtx;
    } ATX, *PATX;

#define MAXIMUM_COMPARE_INSTRUCTION_COUNT 8

    status
        NTAPI
        AsyncCall(
            __in ptr UniqueThread,
            __in_opt PGKERNEL_ROUTINE KernelRoutine,
            __in_opt PGSYSTEM_ROUTINE SystemRoutine,
            __in_opt PGRUNDOWN_ROUTINE RundownRoutine,
            __in_opt PGNORMAL_ROUTINE NormalRoutine
        );

    u
        NTAPI
        IpiSingleCall(
            __in_opt PGKERNEL_ROUTINE KernelRoutine,
            __in_opt PGSYSTEM_ROUTINE SystemRoutine,
            __in_opt PGRUNDOWN_ROUTINE RundownRoutine,
            __in_opt PGNORMAL_ROUTINE NormalRoutine
        );

    void
        NTAPI
        IpiGenericCall(
            __in_opt PGKERNEL_ROUTINE KernelRoutine,
            __in_opt PGSYSTEM_ROUTINE SystemRoutine,
            __in_opt PGRUNDOWN_ROUTINE RundownRoutine,
            __in_opt PGNORMAL_ROUTINE NormalRoutine
        );

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_RTX_H_

```

`Scan.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Scan.h"

u
NTAPI
TrimBytes(
    __in u8ptr Sig,
    __in_opt u8ptr Coll,
    __in_bcount(Coll) u CollSize,
    __out bptr Selector
)
{
    status Status = STATUS_SUCCESS;
    u Result = 0;
    u8ptr Buffer = NULL;
    u BufferSize = 0;
    u8 Single[3] = { 0 };
    u32 Digit = 0;
    u Index = 0;
    u32 Length = 0;

    Length = strlen(Sig);

    for (Index = 0;
        Index < Length;
        Index++) {
        if (0 != isxdigit(*(Sig + Index)) ||
            0 == _cmpbyte(*(Sig + Index), '?')) {
            BufferSize++;
        }
    }

    if (0 != BufferSize) {
        Buffer = __malloc(BufferSize);

        if (NULL != Buffer) {
            RtlZeroMemory(
                Buffer,
                BufferSize);

            for (Index = 0;
                Index < Length;
                Index++) {
                if (0 != isxdigit(*(Sig + Index)) ||
                    0 == _cmpbyte(*(Sig + Index), '?')) {
                    RtlCopyMemory(
                        Buffer + strlen(Buffer),
                        Sig + Index,
                        2);

                    Index++;
                }
            }

            if (0 != (BufferSize & 1)) {
                Result = -1;
            }
            else {
                if (NULL == Coll) {
                    Result = BufferSize / 2;
                }
                else {
                    Result = BufferSize / 2;

                    if (CollSize >= BufferSize / 2) {
                        for (Index = 0;
                            Index < BufferSize;
                            Index += 2) {
                            if (0 == _cmpbyte(*(Buffer + Index), '?') &&
                                0 == _cmpbyte(*(Buffer + Index + 1), '?')) {
                                *(Coll + Index / 2) = '?';

                                *Selector = TRUE;
                            }
                            else if (0 != isxdigit(*(Buffer + Index)) &&
                                0 != isxdigit(*(Buffer + Index + 1))) {
                                RtlCopyMemory(
                                    Single,
                                    Buffer + Index,
                                    sizeof(u8) * 2);

                                Status = RtlCharToInteger(
                                    Single,
                                    16,
                                    &Digit);

                                if (TRACE(Status)) {
                                    *(Coll + Index / 2) = (u8)Digit;

                                    *Selector =
                                        FALSE != *Selector ? TRUE : FALSE;
                                }
                                else {
                                    Result = -1;

                                    break;
                                }
                            }
                            else {
                                Result = -1;

                                break;
                            }
                        }
                    }
                    else {
                        Result = -1;
                    }
                }
            }

            __free(Buffer);
        }
    }

    return Result;
}

u
NTAPI
CompareBytes(
    __in u8ptr Destination,
    __in u8ptr Source,
    __in u Length,
    __in b Selector
)
{
    u Count = 0;

    if (FALSE == Selector) {
        Count = RtlCompareMemory(
            Destination,
            Source,
            Length);
    }
    else {
        for (Count = 0;
            Count < Length;
            Count++) {
            if (0 != _cmpbyte(*(Destination + Count), *(Source + Count)) &&
                0 != _cmpbyte(*(Source + Count), '?')) {
                break;
            }
        }
    }

    return Count;
}

ptr
NTAPI
ScanBytes(
    __in u8ptr Begin,
    __in u8ptr End,
    __in u8ptr Sig
)
{
    b Selector = FALSE;
    u8ptr Coll = NULL;
    u CollSize = 0;
    ptr Result = NULL;
    u Index = 0;

    CollSize = TrimBytes(
        Sig,
        NULL,
        CollSize,
        &Selector);

    if (-1 != CollSize) {
        if ((s)(End - Begin - CollSize) >= 0) {
            Coll = __malloc(CollSize);

            if (NULL != Coll) {
                CollSize = TrimBytes(
                    Sig,
                    Coll,
                    CollSize,
                    &Selector);

                if (-1 != CollSize) {
                    for (Index = 0;
                        Index < End - Begin - CollSize;
                        Index++) {
                        if (CollSize == CompareBytes(
                            Begin + Index,
                            Coll,
                            CollSize,
                            Selector)) {
                            Result = Begin + Index;
                            break;
                        }
                    }
                }

                __free(Coll);
            }
        }
    }

    return Result;
}

```

`Scan.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _SCAN_H_
#define _SCAN_H_

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

    b
        NTAPI
        _cmpbyte(
            __in s8 b1,
            __in s8 b2
        );

    b
        NTAPI
        _cmpword(
            __in s16 s1,
            __in s16 s2
        );

    b
        NTAPI
        _cmpdword(
            __in s32 l1,
            __in s32 l2
        );

    b
        NTAPI
        _cmpqword(
            __in s64 ll1,
            __in s64 ll2
        );

    ptr
        NTAPI
        ScanBytes(
            __in u8ptr Begin,
            __in u8ptr End,
            __in u8ptr Sig
        );

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_SCAN_H_

```

`Sea.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>
#include <devicedefs.h>

#include "Sea.h"

#include "Support.h"

NTSTATUS
NTAPI
NtProcessStartup(
    __in PPEB PebBase
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = SupInstall();

    if (ST_SUCCESS(Status)) {
        Status = SupInit();

        if (ST_SUCCESS(Status)) {
            Status = SupLdrLoad(KernelString, "Shark", CmdReload | CmdPgClear);

            SupTerm();
        }
        else {
            printf(
                TEXT("load driver error code < %08x >\n"),
                Status);

            _getwch();
        }

        SupUninstall();
    }
    else {
        printf(
            TEXT("load driver error code < %08x >\n"),
            Status);

        _getwch();
    }

    return  NtTerminateProcess(
        NtCurrentProcess(),
        STATUS_SUCCESS);
}

```

`Sea.def`:

```def
;
;
; Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
;
; The contents of this file are subject to the Mozilla Public License Version
; 2.0 (the "License"); you may not use this file except in compliance with
; the License. You may obtain a copy of the License at
; http://www.mozilla.org/MPL/
;
; Software distributed under the License is distributed on an "AS IS" basis,
; WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
; for the specific language governing rights and limitations under the
; License.
;
; The Initial Developer of the Original Code is blindtiger.
;
;

LIBRARY
    EXPORTS

```

`Sea.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _SEA_H_
#define _SEA_H_

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */



#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_SEA_H_

```

`Sea.rc`:

```rc
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <winver.h>
#include <ver.h>

#define VER_FILEDESCRIPTION_STR     "Sea"
#define VER_INTERNALNAME_STR        "Sea"
#define VER_ORIGINALFILENAME_STR    "Sea.exe"

ICON_SMALL ICON "Sea.ico"
ICON_BIG ICON "Sea.ico"

#include <common.ver>

```

`Sea.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Optimized|Win32">
      <Configuration>Optimized</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Optimized|x64">
      <Configuration>Optimized</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{CFDA5888-9D8D-4EFF-90E6-DA739486E10F}</ProjectGuid>
    <Keyword>MakeFileProj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'" Label="Configuration">
    <ConfigurationType>Makefile</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'" Label="Configuration">
    <ConfigurationType>Makefile</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">
    <NMakeBuildCommandLine>NMAKE /NOLOGO BUILD PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeBuildCommandLine>
    <NMakeCleanCommandLine>NMAKE /NOLOGO CLEAN PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeCleanCommandLine>
    <NMakeReBuildCommandLine>NMAKE /NOLOGO REBUILD PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeReBuildCommandLine>
    <NMakeOutput>$(SolutionDir)Build\Bins\I386\$(ProjectName).exe</NMakeOutput>
    <NMakePreprocessorDefinitions>UNICODE;_UNICODE;DOSWIN32;_X86_</NMakePreprocessorDefinitions>
    <NMakeIncludeSearchPath>..\..\..\MiniSDK\inc\ddk;..\..\..\MiniSDK\inc\halkit;..\..\..\MiniSDK\inc\internal\base;..\..\..\MiniSDK\inc\internal\ds;..\..\..\MiniSDK\inc\internal\sdktools;..\..\..\MiniSDK\inc\sdk;..\..\..\MiniSDK\inc\sdk\inc\crt;..\..\..\MiniSDK\inc\base;..\..\..\MiniSDK\inc\base\ntos;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt;..\..\..\MiniSDK\inc\sdk\crt\gl;..\..\..\MiniSDK\inc\sdk\crt\sys;..\..\..\MiniSDK\inc\debuggers;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt\gl;\$(SolutionDir)Include;$(ProjectDir)</NMakeIncludeSearchPath>
    <OutDir>$(SolutionDir)Build\Bins\I386\</OutDir>
    <IntDir>$(SolutionDir)Build\Objs\$(ProjectName)\I386\</IntDir>
    <IncludePath>..\..\..\MiniSDK\inc\ddk;..\..\..\MiniSDK\inc\halkit;..\..\..\MiniSDK\inc\internal\base;..\..\..\MiniSDK\inc\internal\ds;..\..\..\MiniSDK\inc\internal\sdktools;..\..\..\MiniSDK\inc\sdk;..\..\..\MiniSDK\inc\sdk\inc\crt;..\..\..\MiniSDK\inc\base;..\..\..\MiniSDK\inc\base\ntos;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt;..\..\..\MiniSDK\inc\sdk\crt\gl;..\..\..\MiniSDK\inc\sdk\crt\sys;..\..\..\MiniSDK\inc\debuggers;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt\gl;$(SolutionDir)Include;$(ProjectDir)</IncludePath>
    <ReferencePath />
    <LibraryPath>..\..\..\MiniSDK\lib\i386;..\..\..\MiniSDK\lib\crt\i386</LibraryPath>
    <LibraryWPath />
    <SourcePath />
    <ExcludePath />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">
    <NMakeBuildCommandLine>NMAKE /NOLOGO BUILD PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeBuildCommandLine>
    <NMakeCleanCommandLine>NMAKE /NOLOGO CLEAN PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeCleanCommandLine>
    <NMakeReBuildCommandLine>NMAKE /NOLOGO REBUILD PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeReBuildCommandLine>
    <NMakeOutput>$(SolutionDir)Build\Bins\AMD64\$(ProjectName).exe</NMakeOutput>
    <NMakePreprocessorDefinitions>UNICODE;_UNICODE;_AMD64_</NMakePreprocessorDefinitions>
    <NMakeIncludeSearchPath>..\..\..\MiniSDK\inc\ddk;..\..\..\MiniSDK\inc\halkit;..\..\..\MiniSDK\inc\internal\base;..\..\..\MiniSDK\inc\internal\ds;..\..\..\MiniSDK\inc\internal\sdktools;..\..\..\MiniSDK\inc\sdk;..\..\..\MiniSDK\inc\sdk\inc\crt;..\..\..\MiniSDK\inc\base;..\..\..\MiniSDK\inc\base\ntos;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt;..\..\..\MiniSDK\inc\sdk\crt\gl;..\..\..\MiniSDK\inc\sdk\crt\sys;..\..\..\MiniSDK\inc\debuggers;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt\gl;$(SolutionDir)Include;$(ProjectDir)</NMakeIncludeSearchPath>
    <OutDir>$(SolutionDir)Build\Bins\AMD64\</OutDir>
    <IntDir>$(SolutionDir)Build\Objs\$(ProjectName)\AMD64\</IntDir>
    <IncludePath>..\..\..\MiniSDK\inc\ddk;..\..\..\MiniSDK\inc\halkit;..\..\..\MiniSDK\inc\internal\base;..\..\..\MiniSDK\inc\internal\ds;..\..\..\MiniSDK\inc\internal\sdktools;..\..\..\MiniSDK\inc\sdk;..\..\..\MiniSDK\inc\sdk\inc\crt;..\..\..\MiniSDK\inc\base;..\..\..\MiniSDK\inc\base\ntos;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt;..\..\..\MiniSDK\inc\sdk\crt\gl;..\..\..\MiniSDK\inc\sdk\crt\sys;..\..\..\MiniSDK\inc\debuggers;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt\gl;$(SolutionDir)Include;$(ProjectDir)</IncludePath>
    <ReferencePath />
    <LibraryPath>..\..\..\MiniSDK\lib\amd64;..\..\..\MiniSDK\lib\crt\amd64</LibraryPath>
    <LibraryWPath />
    <SourcePath />
    <ExcludePath />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
  <ItemGroup>
    <ClCompile Include="Sea.c" />
    <ClCompile Include="Support.c" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="AMD64\AMD64.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">false</ExcludedFromBuild>
      <FileType>Document</FileType>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">false</UseSafeExceptionHandlers>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">true</ExcludedFromBuild>
    </MASM>
    <MASM Include="I386\I386.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">false</ExcludedFromBuild>
      <FileType>Document</FileType>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">true</UseSafeExceptionHandlers>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">true</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">true</UseSafeExceptionHandlers>
    </MASM>
    <None Include="Sea.def" />
    <None Include="Makefile" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Sea.rc" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Sea.h" />
    <ClInclude Include="Support.h" />
  </ItemGroup>
</Project>
```

`Sea.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Source Files\AMD64">
      <UniqueIdentifier>{6cc352ef-8d01-46ce-8869-0b5e9c731c9d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\I386">
      <UniqueIdentifier>{ef34afe2-89bf-4075-b93c-6850345cfe9a}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Sea.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Support.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Sea.def">
      <Filter>Source Files</Filter>
    </None>
    <None Include="Makefile" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Sea.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="AMD64\AMD64.asm">
      <Filter>Source Files\AMD64</Filter>
    </MASM>
    <MASM Include="I386\I386.asm">
      <Filter>Source Files\I386</Filter>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Sea.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Support.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Sea.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Shark.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>
#include <devicedefs.h>

#include "Shark.h"

#include "Except.h"
#include "Guard.h"
#include "Reload.h"
#include "PatchGuard.h"
#include "Space.h"

#pragma section( ".block", read, write, execute )

__declspec(allocate(".block")) RTB RtBlock = { 0 };
__declspec(allocate(".block")) PGBLOCK PgBlock = { 0 };

status
NTAPI
KernelFastCall(
    __in ptr Reserve,
    __in u32 Operation
)
{
    status Status = STATUS_SUCCESS;

#ifdef DEBUG
    vDbgPrint(
        "[Shark] KernelFastCall\n");
#endif // DEBUG

    switch (Operation) {
    case 0: {
        break;
    }

    case 1: {
        break;
    }

    case 2: {
        break;
    }

    default: {
        break;
    }
    }

    return Status;
}

status
NTAPI
ReloadSelf(
    __in PRTB RtBlock,
    __in u32 Operation
)
{
    status Status = STATUS_SUCCESS;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry = NULL;
    PGNORMAL_ROUTINE GsInitialize = NULL;
    PGSUPPORT_ROUTINE KernelEntry = NULL;

    DataTableEntry = LdrLoad(
        RtBlock->Self->SupImage.pvImage,
        KernelString,
        LDRP_SYSTEM_MAPPED | LDRP_REDIRECTED);

    if (NULL != DataTableEntry) {
#ifdef DEBUG
        vDbgPrint(
            ".reload /i %wZ=%p < %p - %08x >\n",
            &DataTableEntry->BaseDllName,
            DataTableEntry->DllBase,
            DataTableEntry->DllBase,
            DataTableEntry->SizeOfImage);
#endif // DEBUG

        GsInitialize = DataTableEntry->EntryPoint;

        if (NULL != GsInitialize) {
            GsInitialize();

            KernelEntry =
                LdrGetSymbol(
                    DataTableEntry->DllBase,
                    "KernelEntry",
                    0);

            if (NULL != KernelEntry) {
                Status = KernelEntry(
                    (ptr)DataTableEntry,
                    (ptr)(u)Operation,
                    NULL,
                    NULL);
            }
            else {
                __free(DataTableEntry);

                Status = STATUS_UNSUCCESSFUL;
            }
        }
        else {
            __free(DataTableEntry);

            Status = STATUS_UNSUCCESSFUL;
        }
    }
    else {
        Status = STATUS_UNSUCCESSFUL;

#ifdef DEBUG
        vDbgPrint(
            "[Shark] reload failed\n");
#endif // DEBUG
    }

    return Status;
}

status
NTAPI
KernelEntry(
    __in ptr Self,
    __in u32 Operation,
    __in ptr Reserve, // do not use
    __in ptr Nothing
)
{
    status Status = STATUS_SUCCESS;

    RtBlock.PgBlock = &PgBlock;
    PgBlock.RtBlock = &RtBlock;

    RtBlock.Self = Self;
    RtBlock.Operation = Operation;

    InitializeGpBlock(&RtBlock);

    if (CmdReload ==
        (RtBlock.Operation & CmdReload)) {
        ReloadSelf(&RtBlock, Operation & ~CmdReload);
    }
    else {
        InitializeSpace(&RtBlock);

        if (CmdPgClear ==
            (RtBlock.Operation & CmdPgClear)) {
            PgBlock.IsDebug = 1;

#ifndef _WIN64
            InitializeExcept(&RtBlock);
#else                             
            PgClear(&PgBlock);
            InitializeExcept(&RtBlock);
#endif // !_WIN64

            __try {
                *(volatile u8ptr)NULL;
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
#ifdef DEBUG
                vDbgPrint(
                    "[SHARK] < %p > test exception code\n",
                    GetExceptionCode());
#endif // DEBUG    
            }
        }

        if (CmdVmxOn ==
            (RtBlock.Operation & CmdVmxOn)) {
            // VmxStartAllProcessors(&RtBlock.CpuControlBlock);
        }

#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > shark load success\n",
            RtBlock.Self);
#endif // DEBUG
    }

    return Status;
}

```

`Shark.def`:

```def
;
;
; Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
;
; The contents of this file are subject to the Mozilla Public License Version
; 2.0 (the "License"); you may not use this file except in compliance with
; the License. You may obtain a copy of the License at
; http://www.mozilla.org/MPL/
;
; Software distributed under the License is distributed on an "AS IS" basis,
; WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
; for the specific language governing rights and limitations under the
; License.
;
; The Initial Developer of the Original Code is blindtiger.
;
;

LIBRARY
    EXPORTS
           
    KernelFastCall
    KernelEntry

```

`Shark.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _SHARK_H_
#define _SHARK_H_

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */



#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_SHARK_H_

```

`Shark.rc`:

```rc
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <winver.h>
#include <ver.h>

#define VER_FILEDESCRIPTION_STR     "Shark"
#define VER_INTERNALNAME_STR        "Shark"
#define VER_ORIGINALFILENAME_STR    "Shark.sys"

#include <common.ver>

```

`Shark.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Optimized|Win32">
      <Configuration>Optimized</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Optimized|x64">
      <Configuration>Optimized</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{389A3E87-9607-4515-9937-F2C5BAA1E268}</ProjectGuid>
    <Keyword>MakeFileProj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'" Label="Configuration">
    <ConfigurationType>Makefile</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'" Label="Configuration">
    <ConfigurationType>Makefile</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">
    <NMakeBuildCommandLine>NMAKE /NOLOGO BUILD PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeBuildCommandLine>
    <NMakeCleanCommandLine>NMAKE /NOLOGO CLEAN PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeCleanCommandLine>
    <NMakeReBuildCommandLine>NMAKE /NOLOGO REBUILD PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeReBuildCommandLine>
    <NMakeOutput>$(SolutionDir)Build\Bins\I386\$(ProjectName).sys</NMakeOutput>
    <NMakePreprocessorDefinitions>UNICODE;_UNICODE;DOSWIN32;_X86_;NTOS_KERNEL_RUNTIME;_NTDRIVER_;DETOURS_X86;DETOURS_32BIT</NMakePreprocessorDefinitions>
    <NMakeIncludeSearchPath>..\..\..\MiniSDK\inc\ddk;..\..\..\MiniSDK\inc\halkit;..\..\..\MiniSDK\inc\internal\base;..\..\..\MiniSDK\inc\internal\ds;..\..\..\MiniSDK\inc\internal\sdktools;..\..\..\MiniSDK\inc\sdk;..\..\..\MiniSDK\inc\sdk\inc\crt;..\..\..\MiniSDK\inc\base;..\..\..\MiniSDK\inc\base\ntos;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt;..\..\..\MiniSDK\inc\sdk\crt\gl;..\..\..\MiniSDK\inc\sdk\crt\sys;..\..\..\MiniSDK\inc\debuggers;$(SolutionDir)Include;$(ProjectDir)</NMakeIncludeSearchPath>
    <OutDir>$(SolutionDir)Build\Bins\I386\</OutDir>
    <IntDir>$(SolutionDir)Build\Objs\$(ProjectName)\I386\</IntDir>
    <IncludePath>..\..\..\MiniSDK\inc\ddk;..\..\..\MiniSDK\inc\halkit;..\..\..\MiniSDK\inc\internal\base;..\..\..\MiniSDK\inc\internal\ds;..\..\..\MiniSDK\inc\internal\sdktools;..\..\..\MiniSDK\inc\sdk;..\..\..\MiniSDK\inc\sdk\inc\crt;..\..\..\MiniSDK\inc\base;..\..\..\MiniSDK\inc\base\ntos;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt;..\..\..\MiniSDK\inc\sdk\crt\gl;..\..\..\MiniSDK\inc\sdk\crt\sys;..\..\..\MiniSDK\inc\debuggers;$(SolutionDir)Include;$(ProjectDir)</IncludePath>
    <ReferencePath />
    <LibraryPath>..\..\..\MiniSDK\lib\I386;..\..\..\MiniSDK\lib\Crt\I386</LibraryPath>
    <LibraryWPath />
    <SourcePath />
    <ExcludePath />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">
    <NMakeBuildCommandLine>NMAKE /NOLOGO BUILD PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeBuildCommandLine>
    <NMakeCleanCommandLine>NMAKE /NOLOGO CLEAN PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeCleanCommandLine>
    <NMakeReBuildCommandLine>NMAKE /NOLOGO REBUILD PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeReBuildCommandLine>
    <NMakeOutput>$(SolutionDir)Build\Bins\AMD64\$(ProjectName).sys</NMakeOutput>
    <NMakePreprocessorDefinitions>UNICODE;_UNICODE;_AMD64_;NTOS_KERNEL_RUNTIME;_NTDRIVER_;DETOURS_X64;DETOURS_64BIT</NMakePreprocessorDefinitions>
    <NMakeIncludeSearchPath>..\..\..\MiniSDK\inc\ddk;..\..\..\MiniSDK\inc\halkit;..\..\..\MiniSDK\inc\internal\base;..\..\..\MiniSDK\inc\internal\ds;..\..\..\MiniSDK\inc\internal\sdktools;..\..\..\MiniSDK\inc\sdk;..\..\..\MiniSDK\inc\sdk\inc\crt;..\..\..\MiniSDK\inc\base;..\..\..\MiniSDK\inc\base\ntos;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt;..\..\..\MiniSDK\inc\sdk\crt\gl;..\..\..\MiniSDK\inc\sdk\crt\sys;..\..\..\MiniSDK\inc\debuggers;$(SolutionDir)Include;$(ProjectDir)</NMakeIncludeSearchPath>
    <OutDir>$(SolutionDir)Build\Bins\AMD64\</OutDir>
    <IntDir>$(SolutionDir)Build\Objs\$(ProjectName)\AMD64\</IntDir>
    <IncludePath>..\..\..\MiniSDK\inc\ddk;..\..\..\MiniSDK\inc\halkit;..\..\..\MiniSDK\inc\internal\base;..\..\..\MiniSDK\inc\internal\ds;..\..\..\MiniSDK\inc\internal\sdktools;..\..\..\MiniSDK\inc\sdk;..\..\..\MiniSDK\inc\sdk\inc\crt;..\..\..\MiniSDK\inc\base;..\..\..\MiniSDK\inc\base\ntos;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt;..\..\..\MiniSDK\inc\sdk\crt\gl;..\..\..\MiniSDK\inc\sdk\crt\sys;..\..\..\MiniSDK\inc\debuggers;$(SolutionDir)Include;$(ProjectDir)</IncludePath>
    <ReferencePath />
    <LibraryPath>..\..\..\MiniSDK\lib\AMD64;..\..\..\MiniSDK\lib\Crt\AMD64</LibraryPath>
    <LibraryWPath />
    <SourcePath />
    <ExcludePath />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
  <ItemGroup>
    <MASM Include="AMD64\AMD64.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">true</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">false</UseSafeExceptionHandlers>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">false</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">true</UseSafeExceptionHandlers>
    </MASM>
    <MASM Include="AMD64\ContextAMD64.asm" />
    <MASM Include="I386\ContextI386.asm" />
    <MASM Include="I386\I386.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">false</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">true</UseSafeExceptionHandlers>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">true</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">false</UseSafeExceptionHandlers>
    </MASM>
    <MASM Include="AMD64\CmpAMD64.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">true</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">false</UseSafeExceptionHandlers>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">false</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">true</UseSafeExceptionHandlers>
    </MASM>
    <MASM Include="I386\CmpI386.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">false</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">true</UseSafeExceptionHandlers>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">true</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">false</UseSafeExceptionHandlers>
    </MASM>
    <ClCompile Include="AMD64\ExceptAMD64.c" />
    <ClCompile Include="AMD64\PatchGuardAMD64.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">true</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">false</UseSafeExceptionHandlers>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">false</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">true</UseSafeExceptionHandlers>
    </ClCompile>
    <ClCompile Include="AMD64\SpaceAMD64.c" />
    <ClCompile Include="AMD64\StackAMD64.c" />
    <ClCompile Include="Except.c" />
    <ClCompile Include="Guard.c" />
    <ClCompile Include="I386\ExceptI386.c" />
    <ClCompile Include="I386\PatchGuardI386.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">false</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">true</UseSafeExceptionHandlers>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">true</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">false</UseSafeExceptionHandlers>
    </ClCompile>
    <ClCompile Include="I386\SpaceI386.c" />
    <ClCompile Include="Ctx.c" />
    <ClCompile Include="I386\StackI386.c" />
    <ClCompile Include="Reload.c" />
    <ClCompile Include="Rtx.c" />
    <ClCompile Include="Shark.c" />
    <ClCompile Include="PatchGuard.c" />
    <ClCompile Include="Scan.c" />
    <ClCompile Include="Space.c" />
    <ClCompile Include="Stack.c" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Shark.def" />
    <None Include="Makefile" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Shark.rc" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Except.h" />
    <ClInclude Include="Guard.h" />
    <ClInclude Include="Reload.h" />
    <ClInclude Include="Rtx.h" />
    <ClInclude Include="Shark.h" />
    <ClInclude Include="PatchGuard.h" />
    <ClInclude Include="Ctx.h" />
    <ClInclude Include="Scan.h" />
    <ClInclude Include="Space.h" />
    <ClInclude Include="Stack.h" />
  </ItemGroup>
</Project>
```

`Shark.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Source Files\AMD64">
      <UniqueIdentifier>{6cc352ef-8d01-46ce-8869-0b5e9c731c9d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\I386">
      <UniqueIdentifier>{ef34afe2-89bf-4075-b93c-6850345cfe9a}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Shark.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PatchGuard.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AMD64\PatchGuardAMD64.c">
      <Filter>Source Files\AMD64</Filter>
    </ClCompile>
    <ClCompile Include="I386\PatchGuardI386.c">
      <Filter>Source Files\I386</Filter>
    </ClCompile>
    <ClCompile Include="Ctx.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Scan.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Stack.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Except.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Reload.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Space.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AMD64\SpaceAMD64.c">
      <Filter>Source Files\AMD64</Filter>
    </ClCompile>
    <ClCompile Include="I386\SpaceI386.c">
      <Filter>Source Files\I386</Filter>
    </ClCompile>
    <ClCompile Include="Rtx.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AMD64\StackAMD64.c">
      <Filter>Source Files\AMD64</Filter>
    </ClCompile>
    <ClCompile Include="I386\StackI386.c">
      <Filter>Source Files\I386</Filter>
    </ClCompile>
    <ClCompile Include="Guard.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AMD64\ExceptAMD64.c">
      <Filter>Source Files\AMD64</Filter>
    </ClCompile>
    <ClCompile Include="I386\ExceptI386.c">
      <Filter>Source Files\I386</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Shark.def">
      <Filter>Source Files</Filter>
    </None>
    <None Include="Makefile" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Shark.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="AMD64\AMD64.asm">
      <Filter>Source Files\AMD64</Filter>
    </MASM>
    <MASM Include="I386\I386.asm">
      <Filter>Source Files\I386</Filter>
    </MASM>
    <MASM Include="AMD64\CmpAMD64.asm">
      <Filter>Source Files\AMD64</Filter>
    </MASM>
    <MASM Include="I386\CmpI386.asm">
      <Filter>Source Files\I386</Filter>
    </MASM>
    <MASM Include="AMD64\ContextAMD64.asm">
      <Filter>Source Files\AMD64</Filter>
    </MASM>
    <MASM Include="I386\ContextI386.asm">
      <Filter>Source Files\I386</Filter>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Shark.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PatchGuard.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Ctx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Scan.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Stack.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Except.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Reload.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Space.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Rtx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Guard.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Shark.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Space.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Space.h"

#include "Reload.h"
#include "Rtx.h"

void
NTAPI
FlushSingleTb(
    __in ptr VirtualAddress
)
{
    IpiSingleCall(
        (PGKERNEL_ROUTINE)NULL,
        (PGSYSTEM_ROUTINE)NULL,
        (PGRUNDOWN_ROUTINE)_FlushSingleTb,
        (PGNORMAL_ROUTINE)VirtualAddress);
}

void
NTAPI
FlushMultipleTb(
    __in ptr VirtualAddress,
    __in u RegionSize,
    __in b AllProcesors
)
{
    if (FALSE != AllProcesors) {
        IpiGenericCall(
            (PGKERNEL_ROUTINE)NULL,
            (PGSYSTEM_ROUTINE)_FlushMultipleTb,
            (PGRUNDOWN_ROUTINE)VirtualAddress,
            (PGNORMAL_ROUTINE)RegionSize);
    }
    else {
        IpiSingleCall(
            (PGKERNEL_ROUTINE)NULL,
            (PGSYSTEM_ROUTINE)_FlushMultipleTb,
            (PGRUNDOWN_ROUTINE)VirtualAddress,
            (PGNORMAL_ROUTINE)RegionSize);
    }
}

```

`Space.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _SPACE_H_
#define _SPACE_H_

#include "..\..\WRK\base\ntos\mm\mi.h"

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

#ifndef _WIN64
#define GetPxeAddress(va) (NULL);
#define GetPpeAddress(va) (NULL);
#define GetVaMappedByPxe(Pxe) (NULL);
#define GetVaMappedByPpe(Ppe) (NULL);

    PMMPTE
        NTAPI
        _GetPdeAddress(
            __in ptr VirtualAddress,
            __in PMMPTE PdeBase
        );

    PMMPTE
        NTAPI
        _GetPdeAddressPae(
            __in ptr VirtualAddress,
            __in PMMPTE PdeBase
        );

    PMMPTE
        NTAPI
        _GetPteAddress(
            __in ptr VirtualAddress,
            __in PMMPTE PteBase
        );

    PMMPTE
        NTAPI
        _GetPteAddressPae(
            __in ptr VirtualAddress,
            __in PMMPTE PteBase
        );

    ptr
        NTAPI
        _GetVaMappedByPte(
            __in PMMPTE Pte
        );

    ptr
        NTAPI
        _GetVaMappedByPtePae(
            __in PMMPTE Pte
        );

    ptr
        NTAPI
        _GetVaMappedByPde(
            __in PMMPTE Pde
        );

    ptr
        NTAPI
        _GetVaMappedByPdePae(
            __in PMMPTE Pde
        );
#else
    PMMPTE
        NTAPI
        GetPxeAddress(
            __in ptr VirtualAddress
        );

    PMMPTE
        NTAPI
        GetPpeAddress(
            __in ptr VirtualAddress
        );

    ptr
        NTAPI
        GetVaMappedByPxe(
            __in PMMPTE Pxe
        );

    ptr
        NTAPI
        GetVaMappedByPpe(
            __in PMMPTE Ppe
        );
#endif // !_WIN64

    void
        NTAPI
        InitializeSpace(
            __inout ptr Block
        );

    PMMPTE
        NTAPI
        GetPdeAddress(
            __in ptr VirtualAddress
        );

    PMMPTE
        NTAPI
        GetPteAddress(
            __in ptr VirtualAddress
        );

    ptr
        NTAPI
        GetVaMappedByPde(
            __in PMMPTE Pde
        );

    ptr
        NTAPI
        GetVaMappedByPte(
            __in PMMPTE Pte
        );

    //
    //  Miscellaneous support macros.
    //
    //      u32
    //      FlagOn (
    //          IN u32 Flags,
    //          IN u32 SingleFlag
    //          );
    //
    //      b
    //      BooleanFlagOn (
    //          IN u32 Flags,
    //          IN u32 SingleFlag
    //          );
    //
    //      void
    //      SetFlag (
    //          IN u32 Flags,
    //          IN u32 SingleFlag
    //          );
    //
    //      void
    //      ClearFlag (
    //          IN u32 Flags,
    //          IN u32 SingleFlag
    //          );
    //
    //      u32
    //      QuadAlign (
    //          IN u32 Pointer
    //          );
    //

#define FlagOn(F,SF) ( \
    (((F) & (SF)))     \
)

#define BooleanFlagOn(F,SF) (    \
    (b)(((F) & (SF)) != 0) \
)

#define SetFlag(F,SF) { \
    (F) |= (SF);        \
}

#define ClearFlag(F,SF) { \
    (F) &= ~(SF);         \
}

#define QuadAlign(P) (             \
    ((((P)) + 7) & (-8)) \
)

#undef MM_PTE_WRITE_MASK
#define MM_PTE_WRITE_MASK 0x2

#ifndef _WIN64
#define MM_PTE_EXECUTE_MASK 0x8000000000000000UI64

#define PAE_ENABLE (FALSE != GpBlock.DebuggerDataBlock.PaeEnabled)

#define INSERT_EXECUTE_TO_VALID_PTE(PPTE) { \
            if(FALSE != PAE_ENABLE) \
                *(u64ptr)(PPTE) &= ~MM_PTE_EXECUTE_MASK; \
        }
#define REMOVE_EXECUTE_TO_VALID_PTE(PPTE) { \
            if(FALSE != PAE_ENABLE) \
                *(u64ptr)(PPTE) |= MM_PTE_EXECUTE_MASK; \
        }
#else
#define INSERT_EXECUTE_TO_VALID_PTE(PPTE) (PPTE)->u.Hard.NoExecute = 0;
#define REMOVE_EXECUTE_TO_VALID_PTE(PPTE) (PPTE)->u.Hard.NoExecute = 1;
#endif // !_WIN64

    void
        NTAPI
        _FlushSingleTb(
            __in ptr VirtualAddress
        );

    void
        NTAPI
        FlushSingleTb(
            __in ptr VirtualAddress
        );

    FORCEINLINE
        void
        NTAPI
        _FlushMultipleTb(
            __in ptr VirtualAddress,
            __in u RegionSize
        )
    {
        PFN_NUMBER NumberOfPages = 0;
        PFN_NUMBER PageFrameIndex = 0;

        NumberOfPages =
            BYTES_TO_PAGES(RegionSize +
            ((u8ptr)VirtualAddress - (u8ptr)PAGE_ALIGN(VirtualAddress)));

        for (PageFrameIndex = 0;
            PageFrameIndex < NumberOfPages;
            PageFrameIndex++) {
            _FlushSingleTb(
                (u8ptr)PAGE_ALIGN(VirtualAddress) + PAGE_SIZE * PageFrameIndex);
        }
    }

    void
        NTAPI
        FlushMultipleTb(
            __in ptr VirtualAddress,
            __in u RegionSize,
            __in b AllProcesors
        );

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_SPACE_H_

```

`Stack.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Stack.h"

#include "Reload.h"

void
NTAPI
PrintSymbol(
    __in u8ptr Prefix,
    __in PSYMBOL Symbol
)
{
    if (NULL != Symbol->String) {
        if (0 == Symbol->Offset) {
#ifdef DEBUG
            vDbgPrint(
                "%s < %p > %wZ!%hs\n",
                Prefix,
                Symbol->Address,
                &Symbol->DataTableEntry->BaseDllName,
                Symbol->String);
#endif // DEBUG
        }
        else {
#ifdef DEBUG
            vDbgPrint(
                "%s < %p > %wZ!%hs + %x\n",
                Prefix,
                Symbol->Address,
                &Symbol->DataTableEntry->BaseDllName,
                Symbol->String,
                Symbol->Offset);
#endif // DEBUG
        }
    }
    else if (0 != Symbol->Ordinal) {
        if (0 == Symbol->Offset) {
#ifdef DEBUG
            vDbgPrint(
                "%s < %p > %wZ!@%d\n",
                Prefix,
                Symbol->Address,
                &Symbol->DataTableEntry->BaseDllName,
                Symbol->Ordinal);
#endif // DEBUG
        }
        else {
#ifdef DEBUG
            vDbgPrint(
                "%s < %p > %wZ!@%d + %x\n",
                Prefix,
                Symbol->Address,
                &Symbol->DataTableEntry->BaseDllName,
                Symbol->Ordinal,
                Symbol->Offset);
#endif // DEBUG
        }
    }
    else if (NULL != Symbol->DataTableEntry) {
#ifdef DEBUG
        vDbgPrint(
            "%s < %p > %wZ + %x\n",
            Prefix,
            Symbol->Address,
            &Symbol->DataTableEntry->BaseDllName,
            Symbol->Offset);
#endif // DEBUG
    }
    else {
#ifdef DEBUG
        vDbgPrint(
            "%s < %p > symbol not found\n",
            Prefix,
            Symbol->Address);
#endif // DEBUG
    }
}

void
NTAPI
WalkImageSymbol(
    __in ptr Address,
    __inout PSYMBOL Symbol
)
{
    status Status = STATUS_SUCCESS;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory = NULL;
    u32 Size = 0;
    u32ptr NameTable = NULL;
    u16ptr OrdinalTable = NULL;
    u32ptr AddressTable = NULL;
    cptr NameTableName = NULL;
    u16 HintIndex = 0;
    u16 NameIndex = 0;
    ptr ProcedureAddress = NULL;
    ptr NearAddress = NULL;

    Symbol->Address = Address;

    Symbol->Offset =
        (u)Address - (u)Symbol->DataTableEntry->DllBase;

    ExportDirectory = RtlImageDirectoryEntryToData(
        Symbol->DataTableEntry->DllBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_EXPORT,
        &Size);

    if (NULL != ExportDirectory) {
        NameTable =
            (u8ptr)Symbol->DataTableEntry->DllBase + ExportDirectory->AddressOfNames;

        OrdinalTable =
            (u8ptr)Symbol->DataTableEntry->DllBase + ExportDirectory->AddressOfNameOrdinals;

        AddressTable =
            (u8ptr)Symbol->DataTableEntry->DllBase + ExportDirectory->AddressOfFunctions;

        if (NULL != NameTable &&
            NULL != OrdinalTable &&
            NULL != AddressTable) {
            for (HintIndex = 0;
                HintIndex < ExportDirectory->NumberOfFunctions;
                HintIndex++) {
                ProcedureAddress =
                    (u8ptr)Symbol->DataTableEntry->DllBase + AddressTable[HintIndex];

                if ((u)ProcedureAddress <= (u)Symbol->Address &&
                    (u)ProcedureAddress > (u)NearAddress) {
                    NearAddress = ProcedureAddress;

                    for (NameIndex = 0;
                        NameIndex < ExportDirectory->NumberOfNames;
                        NameIndex++) {
                        if (HintIndex == OrdinalTable[NameIndex]) {
                            Symbol->String =
                                (u8ptr)Symbol->DataTableEntry->DllBase + NameTable[HintIndex];
                        }
                    }

                    Symbol->Ordinal =
                        HintIndex + ExportDirectory->Base;

                    Symbol->Offset =
                        (u)Symbol->Address - (u)ProcedureAddress;
                }
            }
        }
    }
}

void
NTAPI
FindSymbol(
    __in ptr Address,
    __inout PSYMBOL Symbol
)
{
    status Status = STATUS_SUCCESS;

    Status = FindEntryForImageAddress(
        Address,
        &Symbol->DataTableEntry);

    if (NT_SUCCESS(Status)) {
        WalkImageSymbol(Address, Symbol);
    }
}

void
NTAPI
FindAndPrintSymbol(
    __in u8ptr Prefix,
    __in ptr Address
)
{
    SYMBOL Symbol = { 0 };

    FindSymbol(Address, &Symbol);
    PrintSymbol(Prefix, &Symbol);
}

void
NTAPI
PrintFrameChain(
    __in u8ptr Prefix,
    __in PCALLERS Callers,
    __in_opt u32 FramesToSkip,
    __in u32 Count
)
{
    u32 Index = 0;

    for (Index = FramesToSkip;
        Index < Count;
        Index++) {
        FindAndPrintSymbol(
            Prefix,
            Callers[Index].Establisher);
    }
}

```

`Stack.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _STACK_H_
#define _STACK_H_

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

    typedef struct _CALLERS {
        ptr * EstablisherFrame;
        ptr Establisher;
    }CALLERS, *PCALLERS;

    DECLSPEC_NOINLINE
        u32
        NTAPI
        WalkFrameChain(
            __out PCALLERS Callers,
            __in u32 Count
        );

    typedef struct _SYMBOL {
        PKLDR_DATA_TABLE_ENTRY DataTableEntry;
        ptr Address;
        cptr String;
        u16 Ordinal;
        s32 Offset;
    }SYMBOL, *PSYMBOL;

    void
        NTAPI
        PrintSymbol(
            __in u8ptr Prefix,
            __in PSYMBOL Symbol
        );

    void
        NTAPI
        WalkImageSymbol(
            __in ptr Address,
            __inout PSYMBOL Symbol
        );

    void
        NTAPI
        FindSymbol(
            __in ptr Address,
            __inout PSYMBOL Symbol
        );

    void
        NTAPI
        FindAndPrintSymbol(
            __in u8ptr Prefix,
            __in ptr Address
        );

    void
        NTAPI
        PrintFrameChain(
            __in u8ptr Prefix,
            __in PCALLERS Callers,
            __in_opt u32 FramesToSkip,
            __in u32 Count
        );

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_STACK_H_

```

`Support.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>
#include <devicedefs.h>

#include "Support.h"

u32 Cookie;
u32 SessionCookie;
ptr Session;
ptr SUPHandle;

static
u16
NTAPI
LdrGetOsPlatform(
    void
)
{
    status Status = STATUS_SUCCESS;
    SYSTEM_PROCESSOR_INFORMATION ProcessorInformation = { 0 };
    u ProcessInformation = 0;
    u32 ReturnLength = 0;
    u16 Platform = 0;

    Status = NtQuerySystemInformation(
        SystemProcessorInformation,
        &ProcessorInformation,
        sizeof(SYSTEM_PROCESSOR_INFORMATION),
        &ReturnLength);

    if (TRACE(Status)) {
        if (PROCESSOR_ARCHITECTURE_AMD64 ==
            ProcessorInformation.ProcessorArchitecture) {
            Platform = IMAGE_NT_OPTIONAL_HDR64_MAGIC;
        }
        else if (PROCESSOR_ARCHITECTURE_INTEL ==
            ProcessorInformation.ProcessorArchitecture) {
            Status = NtQueryInformationProcess(
                NtCurrentProcess(),
                ProcessWow64Information,
                &ProcessInformation,
                sizeof(ProcessInformation),
                &ReturnLength);

            if (TRACE(Status)) {
                if (ProcessInformation) {
                    Platform = IMAGE_NT_OPTIONAL_HDR64_MAGIC;
                }
                else {
                    Platform = IMAGE_NT_OPTIONAL_HDR32_MAGIC;
                }
            }
        }
    }

    return Platform;
}

status
NTAPI
RegistryCreateKey(
    __out ptr * KeyHandle,
    __in ACCESS_MASK DesiredAccess,
    __in wcptr KeyList,
    __in u32 CreateOptions
)
{
    status Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    UNICODE_STRING KeyPath = { 0 };

    RtlInitUnicodeString(&KeyPath, KeyList);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = NtCreateKey(
        KeyHandle,
        DesiredAccess,
        &ObjectAttributes,
        0,
        NULL,
        CreateOptions,
        NULL);

    return Status;
}

status
NTAPI
RegistryOpenKey(
    __out ptr * KeyHandle,
    __in ACCESS_MASK DesiredAccess,
    __in wcptr KeyList
)
{
    status Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    UNICODE_STRING KeyPath = { 0 };

    RtlInitUnicodeString(&KeyPath, KeyList);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = NtOpenKey(
        KeyHandle,
        DesiredAccess,
        &ObjectAttributes);

    return Status;
}

status
NTAPI
RegistrySetValueKey(
    __in ptr KeyHandle,
    __in wcptr ValueName,
    __in u32 Type,
    __in_bcount_opt(DataSize) ptr Data,
    __in u32 DataSize
)
{
    status Status = STATUS_SUCCESS;
    UNICODE_STRING KeyValueName = { 0 };

    RtlInitUnicodeString(&KeyValueName, ValueName);

    Status = NtSetValueKey(
        KeyHandle,
        &KeyValueName,
        0,
        Type,
        Data,
        DataSize);

    return Status;
}

void
NTAPI
RegistryDeleteKey(
    __in PUNICODE_STRING KeyPath
)
{
    status Status = STATUS_SUCCESS;
    ptr KeyHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    PKEY_BASIC_INFORMATION BasicInformation = NULL;
    PKEY_VALUE_BASIC_INFORMATION ValueBasicInformation = NULL;
    UNICODE_STRING KeyName = { 0 };
    UNICODE_STRING Separator = { 0 };
    UNICODE_STRING SubKeyName = { 0 };
    wcptr KeyNameBuffer = NULL;
    u32 Length = 0;
    u32 ResultLength = 0;

    InitializeObjectAttributes(
        &ObjectAttributes,
        KeyPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = NtOpenKey(
        &KeyHandle,
        KEY_ALL_ACCESS,
        &ObjectAttributes);

    if (NT_SUCCESS(Status)) {
        Length =
            MAXIMUM_FILENAME_LENGTH * sizeof(wc) +
            FIELD_OFFSET(KEY_BASIC_INFORMATION, Name);

        BasicInformation =
            __malloc(Length
                + MAXIMUM_FILENAME_LENGTH * sizeof(wc)
                + MAXIMUM_FILENAME_LENGTH * sizeof(wc)
                + FIELD_OFFSET(KEY_VALUE_BASIC_INFORMATION, Name));

        if (NULL != BasicInformation) {
            KeyNameBuffer = (PCHAR)BasicInformation + Length;
            ValueBasicInformation = KeyNameBuffer + MAXIMUM_FILENAME_LENGTH;

            do {
                Status = NtEnumerateKey(
                    KeyHandle,
                    0,
                    KeyBasicInformation,
                    BasicInformation,
                    Length,
                    &ResultLength);

                if (NT_SUCCESS(Status)) {
                    SubKeyName.Buffer = KeyNameBuffer;
                    SubKeyName.Length = 0;
                    SubKeyName.MaximumLength = (u16)MAXIMUM_FILENAME_LENGTH * sizeof(wc);

                    KeyName.Buffer = BasicInformation->Name;
                    KeyName.Length = (u16)BasicInformation->NameLength;
                    KeyName.MaximumLength = (u16)MAXIMUM_FILENAME_LENGTH * sizeof(wc);

                    RtlInitUnicodeString(&Separator, L"\\");

                    RtlAppendStringToString(&SubKeyName, KeyPath);
                    RtlAppendStringToString(&SubKeyName, &Separator);
                    RtlAppendStringToString(&SubKeyName, &KeyName);

                    RegistryDeleteKey(&SubKeyName);
                }
            } while (NT_SUCCESS(Status));

            do {
                Status = NtEnumerateValueKey(
                    KeyHandle,
                    0,
                    KeyValueBasicInformation,
                    ValueBasicInformation,
                    Length,
                    &ResultLength);

                if (NT_SUCCESS(Status)) {
                    KeyName.Buffer = ValueBasicInformation->Name;
                    KeyName.Length = (u16)ValueBasicInformation->NameLength;
                    KeyName.MaximumLength = (u16)MAXIMUM_FILENAME_LENGTH * sizeof(wc);

                    TRACE(NtDeleteValueKey(
                        KeyHandle,
                        &KeyName));
                }
            } while (NT_SUCCESS(Status));

            __free(BasicInformation);
        }

        TRACE(NtDeleteKey(KeyHandle));
        TRACE(NtClose(KeyHandle));
    }
}

status
NTAPI
RegistryCreateSevice(
    __in wcptr ImageFileName,
    __in wcptr ServiceName
)
{
    status Status = STATUS_SUCCESS;
    ptr KeyHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    UNICODE_STRING KeyPath = { 0 };
    wcptr KeyPathBuffer = NULL;
    UNICODE_STRING KeyName = { 0 };
    UNICODE_STRING ImagePath = { 0 };
    u32 Type = 1;
    u32 Start = 3;
    u32 ErrorControl = 1;
    b WasEnabled = FALSE;

    Status = RtlAdjustPrivilege(
        SE_LOAD_DRIVER_PRIVILEGE,
        TRUE,
        FALSE,
        &WasEnabled);

    if (TRACE(Status)) {
        KeyPathBuffer =
            __malloc(MAXIMUM_FILENAME_LENGTH * sizeof(wc));

        if (NULL != KeyPathBuffer) {
            KeyPath.Buffer = KeyPathBuffer;
            KeyPath.Length = 0;
            KeyPath.MaximumLength = MAXIMUM_FILENAME_LENGTH * sizeof(wc);

            RtlInitUnicodeString(&KeyName, ServicesDirectory);
            RtlAppendStringToString(&KeyPath, &KeyName);
            RtlInitUnicodeString(&KeyName, ServiceName);
            RtlAppendStringToString(&KeyPath, &KeyName);

            InitializeObjectAttributes(
                &ObjectAttributes,
                &KeyPath,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

            Status = NtCreateKey(
                &KeyHandle,
                KEY_ALL_ACCESS,
                &ObjectAttributes,
                0,
                NULL,
                REG_OPTION_VOLATILE,
                NULL);

            if (TRACE(Status)) {
                TRACE(RegistrySetValueKey(
                    KeyHandle,
                    L"Type",
                    REG_DWORD,
                    &Type,
                    sizeof(Type)));

                TRACE(RegistrySetValueKey(
                    KeyHandle,
                    L"ErrorControl",
                    REG_DWORD,
                    &ErrorControl,
                    sizeof(ErrorControl)));

                TRACE(RegistrySetValueKey(
                    KeyHandle,
                    L"Start",
                    REG_DWORD,
                    &Start,
                    sizeof(Start)));

                TRACE(RegistrySetValueKey(
                    KeyHandle,
                    L"DisplayName",
                    REG_SZ,
                    ServiceName,
                    wcslen(ServiceName) * sizeof(wc) + sizeof(UNICODE_NULL)));

                RtlInitUnicodeString(&ImagePath, ImageFileName);

                TRACE(RegistrySetValueKey(
                    KeyHandle,
                    L"ImagePath",
                    REG_EXPAND_SZ,
                    ImagePath.Buffer,
                    ImagePath.Length + sizeof(UNICODE_NULL)));

                Status = NtLoadDriver(&KeyPath);

                TRACE(NtClose(KeyHandle));
            }

            __free(KeyPathBuffer);
        }

        if (FALSE == WasEnabled) {
            TRACE(RtlAdjustPrivilege(
                SE_LOAD_DRIVER_PRIVILEGE,
                FALSE,
                FALSE,
                &WasEnabled));
        }
    }

    return Status;
}

status
NTAPI
RegistryDeleteSevice(
    __in wcptr ServiceName
)
{
    status Status = STATUS_SUCCESS;
    ptr KeyHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    UNICODE_STRING KeyPath = { 0 };
    wcptr KeyPathBuffer = NULL;
    UNICODE_STRING KeyName = { 0 };
    b WasEnabled = FALSE;

    Status = RtlAdjustPrivilege(
        SE_LOAD_DRIVER_PRIVILEGE,
        TRUE,
        FALSE,
        &WasEnabled);

    if (TRACE(Status)) {
        KeyPathBuffer =
            __malloc(MAXIMUM_FILENAME_LENGTH * sizeof(wc));

        if (NULL != KeyPathBuffer) {
            KeyPath.Buffer = KeyPathBuffer;
            KeyPath.Length = 0;
            KeyPath.MaximumLength = MAXIMUM_FILENAME_LENGTH * sizeof(wc);

            RtlInitUnicodeString(&KeyName, ServicesDirectory);
            RtlAppendStringToString(&KeyPath, &KeyName);
            RtlInitUnicodeString(&KeyName, ServiceName);
            RtlAppendStringToString(&KeyPath, &KeyName);

            InitializeObjectAttributes(
                &ObjectAttributes,
                &KeyPath,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

            Status = NtOpenKey(
                &KeyHandle,
                KEY_ALL_ACCESS,
                &ObjectAttributes);

            if (TRACE(Status)) {
                Status = NtUnloadDriver(&KeyPath);

                if (TRACE(Status)) {
                    RegistryDeleteKey(&KeyPath);
                }

                TRACE(NtClose(KeyHandle));
            }

            __free(KeyPathBuffer);
        }

        if (FALSE == WasEnabled) {
            TRACE(RtlAdjustPrivilege(
                SE_LOAD_DRIVER_PRIVILEGE,
                FALSE,
                FALSE,
                &WasEnabled));
        }
    }

    return Status;
}

FORCEINLINE
u32
NTAPI
LdrGetRelocCount(
    __in u32 SizeOfBlock
)
{
    u32 Count = 0;

    Count = (SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(u16);

    return Count;
}

PIMAGE_BASE_RELOCATION
NTAPI
LdrRelocBlock(
    __in ptr VA,
    __in u32 Count,
    __in u16ptr NextOffset,
    __in s Diff
)
{
    u16ptr FixupVA = NULL;
    u16 Offset = 0;
    u16 Type = 0;

    while (Count--) {
        Offset = *NextOffset & 0xfff;
        FixupVA = (u8ptr)VA + Offset;
        Type = (*NextOffset >> 12) & 0xf;

        switch (Type) {
        case IMAGE_REL_BASED_ABSOLUTE: {
            break;
        }

        case IMAGE_REL_BASED_HIGH: {
            FixupVA[1] += (u16)((Diff >> 16) & 0xffff);
            break;
        }

        case IMAGE_REL_BASED_LOW: {
            FixupVA[0] += (u16)(Diff & 0xffff);
            break;
        }

        case IMAGE_REL_BASED_HIGHLOW: {
            *(u32ptr)FixupVA += (u32)Diff;
            break;
        }

        case IMAGE_REL_BASED_HIGHADJ: {
            FixupVA[0] += NextOffset[1] & 0xffff;
            FixupVA[1] += (u16)((Diff >> 16) & 0xffff);

            ++NextOffset;
            --Count;
            break;
        }

        case IMAGE_REL_BASED_MIPS_JMPADDR:
        case IMAGE_REL_BASED_SECTION:
        case IMAGE_REL_BASED_REL32:
            // case IMAGE_REL_BASED_VXD_RELATIVE:
            // case IMAGE_REL_BASED_MIPS_JMPADDR16: 

        case IMAGE_REL_BASED_IA64_IMM64: {
            break;
        }

        case IMAGE_REL_BASED_DIR64: {
            *(uptr)FixupVA += Diff;
            break;
        }

        default: {
            return NULL;
        }
        }

        ++NextOffset;
    }

    return (PIMAGE_BASE_RELOCATION)NextOffset;
}

void
NTAPI
LdrRelocImage(
    __in ptr ImageBase,
    __in s Diff
)
{
    PIMAGE_BASE_RELOCATION RelocDirectory = NULL;
    u32 Size = 0;
    ptr VA = 0;

    RelocDirectory = RtlImageDirectoryEntryToData(
        ImageBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_BASERELOC,
        &Size);

    if (0 != Size) {
        if (0 != Diff) {
            while (0 != Size) {
                VA = (u8ptr)ImageBase + RelocDirectory->VirtualAddress;
                Size -= RelocDirectory->SizeOfBlock;

                RelocDirectory = LdrRelocBlock(
                    VA,
                    LdrGetRelocCount(RelocDirectory->SizeOfBlock),
                    (u16ptr)(RelocDirectory + 1),
                    Diff);
            }
        }
    }
}

status
NTAPI
LdrMapSectionOffline(
    __in cptr ImageFileName,
    __out ptr * ImageViewBase
)
{
    status Status = STATUS_SUCCESS;
    ptr Handle = NULL;
    ptr Section = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    ptr ViewBase = NULL;
    u ViewSize = 0;
    STRING String = { 0 };
    UNICODE_STRING FullPath = { 0 };

    RtlInitString(&String, ImageFileName);

    Status = RtlAnsiStringToUnicodeString(
        &FullPath,
        &String,
        TRUE);

    if (NT_SUCCESS(Status)) {
        InitializeObjectAttributes(
            &ObjectAttributes,
            &FullPath,
            (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE),
            NULL,
            NULL);

        Status = NtOpenFile(
            &Handle,
            FILE_EXECUTE,
            &ObjectAttributes,
            &IoStatusBlock,
            FILE_SHARE_READ | FILE_SHARE_DELETE,
            0);

        if (NT_SUCCESS(Status)) {
            InitializeObjectAttributes(
                &ObjectAttributes,
                NULL,
                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                NULL,
                NULL);

            Status = NtCreateSection(
                &Section,
                SECTION_MAP_READ | SECTION_MAP_EXECUTE,
                &ObjectAttributes,
                NULL,
                PAGE_EXECUTE,
                SEC_IMAGE,
                Handle);

            if (NT_SUCCESS(Status)) {
                Status = NtMapViewOfSection(
                    Section,
                    NtCurrentProcess(),
                    &ViewBase,
                    0L,
                    0L,
                    NULL,
                    &ViewSize,
                    ViewShare,
                    0L,
                    PAGE_EXECUTE);

                if (NT_SUCCESS(Status)) {
                    *ImageViewBase = ViewBase;
                }

                TRACE(NtClose(Section));
            }

            TRACE(NtClose(Handle));
        }

        RtlFreeUnicodeString(&FullPath);
    }

    return Status;
}

status
NTAPI
LdrLoadImportOffline(
    __in PSTRING ImageFileName,
    __out ptr * ImageBase,
    __out ptr * ImportViewBase
)
{
    status Status = STATUS_SUCCESS;
    PRTL_PROCESS_MODULES Modules = NULL;
    u32 BufferSize = PAGE_SIZE;
    u32 Index = 0;
    u32 ReturnLength = 0;
    STRING String = { 0 };
    c FullName[MAXIMUM_FILENAME_LENGTH] = { 0 };

retry:
    Modules = __malloc(BufferSize);

    if (NULL != Modules) {
        RtlZeroMemory(Modules, BufferSize);

        Status = NtQuerySystemInformation(
            SystemModuleInformation,
            Modules,
            BufferSize,
            &ReturnLength);

        if (NT_SUCCESS(Status)) {
            Status = STATUS_NOT_FOUND;

            for (Index = 0;
                Index < Modules->NumberOfModules;
                Index++) {
                _splitpath(
                    Modules->Modules[Index].FullPathName,
                    NULL,
                    NULL,
                    FullName,
                    NULL);

                _splitpath(
                    Modules->Modules[Index].FullPathName,
                    NULL,
                    NULL,
                    NULL,
                    FullName + strlen(FullName));

                RtlInitString(&String, FullName);

                if (FALSE != RtlPrefixString(
                    ImageFileName,
                    &String,
                    TRUE)) {
                    *ImageBase = Modules->Modules[Index].ImageBase;

                    Status = LdrMapSectionOffline(
                        Modules->Modules[Index].FullPathName,
                        ImportViewBase);

                    break;
                }
            }
        }

        __free(Modules);

        Modules = NULL;

        if (STATUS_INFO_LENGTH_MISMATCH == Status) {
            BufferSize = ReturnLength;

            goto retry;
        }
    }
    else {
        Status = STATUS_NO_MEMORY;
    }

    return Status;
}

ptr
NTAPI
LdrForwardOffline(
    __in cptr ForwarderData
)
{
    status Status = STATUS_SUCCESS;
    ptr ImageBase = NULL;
    ptr ImageViewBase = NULL;
    cptr Separator = NULL;
    cptr ImageName = NULL;
    cptr ProcedureName = NULL;
    u32 ProcedureNumber = 0;
    ptr ProcedureAddress = NULL;
    STRING String = { 0 };

    Separator = strchr(ForwarderData, '.');

    if (NULL != Separator) {
        ImageName = __malloc(Separator - ForwarderData);

        if (NULL != ImageName) {
            RtlCopyMemory(
                ImageName,
                ForwarderData,
                Separator - ForwarderData);

            String.Buffer = ImageName;
            String.Length = Separator - ForwarderData;
            String.MaximumLength = Separator - ForwarderData;

            Status = LdrLoadImportOffline(
                &String,
                &ImageBase,
                &ImageViewBase);

            if (TRACE(Status)) {
                Status = STATUS_NO_MORE_ENTRIES;

                Separator += 1;
                ProcedureName = Separator;

                if (Separator[0] != '@') {
                    ProcedureAddress = LdrGetSymbolOffline(
                        ImageBase,
                        ImageViewBase,
                        ProcedureName,
                        0);
                }
                else {
                    Separator += 1;

                    if (RtlCharToInteger(
                        Separator,
                        0,
                        &ProcedureNumber) >= 0) {
                        ProcedureAddress = LdrGetSymbolOffline(
                            ImageBase,
                            ImageViewBase,
                            NULL,
                            ProcedureNumber);
                    }
                }

                TRACE(NtUnmapViewOfSection(
                    NtCurrentProcess(),
                    ImageBase));
            }

            __free(ImageName);
        }
    }

    return ProcedureAddress;
}

ptr
NTAPI
LdrGetSymbolOffline(
    __in ptr ImageBase,
    __in ptr ImageViewBase,
    __in_opt cptr ProcedureName,
    __in_opt u32 ProcedureNumber
)
{
    PIMAGE_EXPORT_DIRECTORY ExportDirectory = NULL;
    u32 Size = 0;
    u32ptr NameTable = NULL;
    u16ptr OrdinalTable = NULL;
    u32ptr AddressTable = NULL;
    cptr NameTableName = NULL;
    u16 HintIndex = 0;
    ptr ProcedureAddress = NULL;

    ExportDirectory = RtlImageDirectoryEntryToData(
        ImageViewBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_EXPORT,
        &Size);

    if (NULL != ExportDirectory) {
        NameTable = (u8ptr)ImageViewBase + ExportDirectory->AddressOfNames;
        OrdinalTable = (u8ptr)ImageViewBase + ExportDirectory->AddressOfNameOrdinals;
        AddressTable = (u8ptr)ImageViewBase + ExportDirectory->AddressOfFunctions;

        if (NULL != NameTable &&
            NULL != OrdinalTable &&
            NULL != AddressTable) {
            if (ProcedureNumber >= ExportDirectory->Base &&
                ProcedureNumber < MAXSHORT) {
                ProcedureAddress = (u8ptr)ImageBase
                    + AddressTable[ProcedureNumber - ExportDirectory->Base];
            }
            else {
                for (HintIndex = 0;
                    HintIndex < ExportDirectory->NumberOfNames;
                    HintIndex++) {
                    NameTableName = (u8ptr)ImageViewBase + NameTable[HintIndex];

                    if (0 == _stricmp(
                        ProcedureName,
                        NameTableName)) {
                        ProcedureAddress = (u8ptr)ImageBase
                            + AddressTable[OrdinalTable[HintIndex]];
                    }
                }
            }
        }

        if ((u)ProcedureAddress >= (u)ExportDirectory &&
            (u)ProcedureAddress < (u)ExportDirectory + Size) {
            ProcedureAddress = LdrForwardOffline(ProcedureAddress);
        }
    }

    return ProcedureAddress;
}

void
NTAPI
LdrSnapThunkOffline(
    __in ptr ImageBase
)
{
    status Status = STATUS_SUCCESS;
    PIMAGE_IMPORT_DESCRIPTOR ImportDirectory = NULL;
    u32 Size = 0;
    PIMAGE_THUNK_DATA OriginalThunk = NULL;
    PIMAGE_THUNK_DATA Thunk = NULL;
    PIMAGE_IMPORT_BY_NAME ImportByName = NULL;
    u16 Ordinal = 0;
    cptr ImportName = NULL;
    ptr ImportBase = NULL;
    ptr ImportViewBase = NULL;
    ptr FunctionAddress = NULL;
    u32 Index = 0;
    STRING String = { 0 };

    ImportDirectory = RtlImageDirectoryEntryToData(
        ImageBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_IMPORT,
        &Size);

    if (0 != Size) {
        do {
            OriginalThunk = (u8ptr)ImageBase + ImportDirectory->OriginalFirstThunk;
            Thunk = (u8ptr)ImageBase + ImportDirectory->FirstThunk;
            ImportName = (u8ptr)ImageBase + ImportDirectory->Name;

            RtlInitString(&String, ImportName);

            Status = LdrLoadImportOffline(&String, &ImportBase, &ImportViewBase);

            if (TRACE(Status)) {
                do {
                    if (IMAGE_SNAP_BY_ORDINAL(OriginalThunk->u1.Ordinal)) {
                        Ordinal = (u16)IMAGE_ORDINAL(OriginalThunk->u1.Ordinal);

                        FunctionAddress = LdrGetSymbolOffline(
                            ImportBase,
                            ImportViewBase,
                            NULL,
                            Ordinal);

                        if (NULL != FunctionAddress) {
                            Thunk->u1.Function = (u)FunctionAddress;
                        }
                        else {
                            DbgPrint(
                                "[SHARK] import procedure ordinal@%d not found\n",
                                Ordinal);
                        }
                    }
                    else {
                        ImportByName = (u8ptr)ImageBase + OriginalThunk->u1.AddressOfData;

                        FunctionAddress = LdrGetSymbolOffline(
                            ImportBase,
                            ImportViewBase,
                            ImportByName->Name,
                            0);

                        if (NULL != FunctionAddress) {
                            Thunk->u1.Function = (u)FunctionAddress;
                        }
                        else {
                            DbgPrint(
                                "[SHARK] import procedure %hs not found\n",
                                ImportByName->Name);
                        }
                    }

                    OriginalThunk++;
                    Thunk++;
                } while (OriginalThunk->u1.Function);

                TRACE(NtUnmapViewOfSection(
                    NtCurrentProcess(),
                    ImportViewBase));
            }
            else {
                DbgPrint(
                    "[SHARK] import dll %hs not found\n",
                    ImportName);
            }

            ImportDirectory++;
        } while (0 != ImportDirectory->Characteristics);
    }
}

ptr64
NTAPI
LdrGetEntryPointOffline(
    __in ptr ImageBase,
    __in ptr ViewBase
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    u32 Offset = 0;
    ptr64 EntryPoint = NULL;

    NtHeaders = RtlImageNtHeader(ViewBase);

    if (NULL != NtHeaders) {
        if (IMAGE_NT_OPTIONAL_HDR32_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Offset = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.AddressOfEntryPoint;
        }

        if (IMAGE_NT_OPTIONAL_HDR64_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Offset = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.AddressOfEntryPoint;
        }

        if (0 != Offset) {
            EntryPoint = (u8ptr)ImageBase + Offset;
        }
    }

    return EntryPoint;
}

u32
NTAPI
LdrGetSize(
    __in ptr ImageBase
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    u32 SizeOfImage = 0;

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        if (IMAGE_NT_OPTIONAL_HDR32_MAGIC == NtHeaders->OptionalHeader.Magic) {
            SizeOfImage = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.SizeOfImage;
        }

        if (IMAGE_NT_OPTIONAL_HDR64_MAGIC == NtHeaders->OptionalHeader.Magic) {
            SizeOfImage = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.SizeOfImage;
        }
    }

    return SizeOfImage;
}

s
NTAPI
LdrSetImageBase(
    __in ptr ViewBase,
    __in ptr ImageBase
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    s Diff = 0;

    NtHeaders = RtlImageNtHeader(ViewBase);

    if (NULL != NtHeaders) {
        if (IMAGE_NT_OPTIONAL_HDR32_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Diff = (s)ImageBase
                - (s)((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase;

            ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase =
                (u)ImageBase;
        }

        if (IMAGE_NT_OPTIONAL_HDR64_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Diff = (s64)ImageBase
                - (s64)((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.ImageBase;

            ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.ImageBase =
                (u64)ImageBase;
        }
    }

    return Diff;
}

status
NTAPI
SupLdrMapSection(
    __in wcptr ImageFileName,
    __out ptr * ViewBase,
    __out u * ViewSize
)
{
    status Status = STATUS_SUCCESS;
    ptr Handle = NULL;
    ptr Section = NULL;
    UNICODE_STRING FilePath = { 0 };
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    FILE_STANDARD_INFORMATION StandardInformation = { 0 };
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    PIMAGE_SECTION_HEADER NtSection = NULL;
    LARGE_INTEGER ByteOffset = { 0 };
    ptr FileCache = NULL;
    u Index = 0;

    Status = RtlDosPathNameToNtPathName_U_WithStatus(
        ImageFileName,
        &FilePath,
        NULL,
        NULL);

    if (NT_SUCCESS(Status)) {
        InitializeObjectAttributes(
            &ObjectAttributes,
            &FilePath,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

        Status = NtOpenFile(
            &Handle,
            FILE_READ_DATA,
            &ObjectAttributes,
            &IoStatusBlock,
            FILE_SHARE_READ | FILE_SHARE_DELETE,
            0);

        if (NT_SUCCESS(Status)) {
            Status = NtQueryInformationFile(
                Handle,
                &IoStatusBlock,
                &StandardInformation,
                sizeof(FILE_STANDARD_INFORMATION),
                FileStandardInformation);

            if (TRACE(Status)) {
                FileCache = __malloc(StandardInformation.EndOfFile.LowPart);

                if (NULL != FileCache) {
                    Status = NtReadFile(
                        Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        FileCache,
                        StandardInformation.EndOfFile.LowPart,
                        &ByteOffset,
                        NULL);

                    if (NT_SUCCESS(Status)) {
                        *ViewSize = LdrGetSize(FileCache);

                        *ViewBase = __malloc(*ViewSize);

                        if (NULL != *ViewBase) {
                            NtHeaders = RtlImageNtHeader(FileCache);
                            NtSection = IMAGE_FIRST_SECTION(NtHeaders);

                            RtlCopyMemory(
                                *ViewBase,
                                FileCache,
                                NtSection->VirtualAddress);

                            for (Index = 0;
                                Index < NtHeaders->FileHeader.NumberOfSections;
                                Index++) {
                                if (0 != NtSection[Index].VirtualAddress) {
                                    RtlCopyMemory(
                                        (ptr)((u)*ViewBase + NtSection[Index].VirtualAddress),
                                        (ptr)((u)FileCache + NtSection[Index].PointerToRawData),
                                        NtSection[Index].SizeOfRawData);
                                }
                            }
                        }
                        else {
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    }

                    __free(FileCache);
                }
                else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            TRACE(NtClose(Handle));
        }

        RtlFreeUnicodeString(&FilePath);
    }

    return Status;
}

status
NTAPI
SupInstall(
    void
)
{
    status Status = STATUS_SUCCESS;
    ptr Handle = NULL;
    u DiskSize = 0;
    UNICODE_STRING ImagePath = { 0 };
    wc ImagePathBuffer[MAXIMUM_FILENAME_LENGTH] = { 0 };

    Status = RegistryOpenKey(
        &Handle,
        KEY_READ,
        RegistryString);

    if (Status < 0) {
        Status = RtlDosPathNameToNtPathName_U_WithStatus(
            SupportString,
            &ImagePath,
            NULL,
            NULL);

        if (TRACE(Status)) {
            RtlCopyMemory(
                ImagePathBuffer, ImagePath.Buffer, ImagePath.Length);

            Status = RegistryCreateSevice(
                ImagePathBuffer, ServiceString);

            RtlFreeUnicodeString(&ImagePath);
        }
    }
    else {
        Status = STATUS_NOT_SUPPORTED;
    }

    return Status;
}

void
NTAPI
SupUninstall(
    void
)
{
    TRACE(RegistryDeleteSevice(ServiceString));
}

status
NTAPI
SupInit(
    void
)
{
    status Status = STATUS_SUCCESS;
    ptr Handle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    UNICODE_STRING String = { 0 };
    SUPCOOKIE Req = { 0 };

    RtlInitUnicodeString(&String, DeviceString);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &String,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = NtOpenFile(
        &Handle,
        FILE_ALL_ACCESS,
        &ObjectAttributes,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    if (TRACE(Status)) {
        RtlFillMemory(&Req, sizeof(Req), 0xff);

        Req.Hdr.u32Cookie = SUPCOOKIE_INITIAL_COOKIE;
        Req.Hdr.u32SessionCookie = __rdtsc();
        Req.Hdr.cbIn = SUP_IOCTL_COOKIE_SIZE_IN;
        Req.Hdr.cbOut = SUP_IOCTL_COOKIE_SIZE_OUT;
        Req.Hdr.fFlags = SUPREQHDR_FLAGS_DEFAULT;
        Req.Hdr.rc = ERR_INTERNAL_ERROR;
        Req.u.In.u32MinVersion =
            (SUPDRVIOC_VERSION & 0xffff0000) == 0x00070000 ?
            0x00070002 :
            SUPDRVIOC_VERSION & 0xffff0000;

        strcpy(Req.u.In.szMagic, SUPCOOKIE_MAGIC);

        Status = NtDeviceIoControlFile(
            Handle,
            NULL,
            NULL,
            NULL,
            &IoStatusBlock,
            SUP_IOCTL_COOKIE,
            &Req,
            SUP_IOCTL_COOKIE_SIZE_IN,
            &Req,
            SUP_IOCTL_COOKIE_SIZE_OUT);

        if (TRACE(Status)) {
            Cookie = Req.u.Out.u32Cookie;
            SessionCookie = Req.u.Out.u32SessionCookie;
            Session = Req.u.Out.pSession;
            SUPHandle = Handle;
        }
    }

    return Status;
}

void
NTAPI
SupTerm(
    void
)
{
    TRACE(NtClose(SUPHandle));

    Cookie = 0;
    SessionCookie = 0;
    Session = SUPHandle;
    SUPHandle = NULL;
}

status
NTAPI
SupLdrUnload(
    __in ptr ImageBase
)
{
    status Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    SUPLDRFREE Req = { 0 };

    Req.Hdr.u32Cookie = Cookie;
    Req.Hdr.u32SessionCookie = SessionCookie;
    Req.Hdr.cbIn = SUP_IOCTL_LDR_FREE_SIZE_IN;
    Req.Hdr.cbOut = SUP_IOCTL_LDR_FREE_SIZE_OUT;
    Req.Hdr.fFlags = SUPREQHDR_FLAGS_DEFAULT;
    Req.Hdr.rc = ERR_INTERNAL_ERROR;
    Req.u.In.pvImageBase = ImageBase;

    Status = NtDeviceIoControlFile(
        SUPHandle,
        NULL,
        NULL,
        NULL,
        &IoStatusBlock,
        SUP_IOCTL_LDR_FREE,
        &Req,
        SUP_IOCTL_LDR_FREE_SIZE_IN,
        &Req,
        SUP_IOCTL_LDR_FREE_SIZE_OUT);

    return Status;
}

status
NTAPI
SupLdrLoad(
    __in wcptr ImageFileName,
    __in cptr BaseName,
    __in u32 Operation
)
{
    status Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    ptr ViewBase = NULL;
    u ViewSize = 0;
    PSUPLDRLOAD LoadReq = NULL;
    SUPLDROPEN OpenReq = { 0 };
    SUPCALLVMMR0 CallReq = { 0 };
    s Diff = 0;

    Status = SupLdrMapSection(
        ImageFileName,
        &ViewBase,
        &ViewSize);

    if (TRACE(Status)) {
        OpenReq.Hdr.u32Cookie = Cookie;
        OpenReq.Hdr.u32SessionCookie = SessionCookie;
        OpenReq.Hdr.cbIn = SUP_IOCTL_LDR_OPEN_SIZE_IN;
        OpenReq.Hdr.cbOut = SUP_IOCTL_LDR_OPEN_SIZE_OUT;
        OpenReq.Hdr.fFlags = SUPREQHDR_FLAGS_DEFAULT;
        OpenReq.Hdr.rc = ERR_INTERNAL_ERROR;
        OpenReq.u.In.cbImage = ViewSize;

        strcpy(OpenReq.u.In.szName, BaseName);

        Status = NtDeviceIoControlFile(
            SUPHandle,
            NULL,
            NULL,
            NULL,
            &IoStatusBlock,
            SUP_IOCTL_LDR_OPEN,
            &OpenReq,
            OpenReq.Hdr.cbIn,
            &OpenReq,
            OpenReq.Hdr.cbOut);

        if (TRACE(Status)) {
            LoadReq = __malloc(SUP_IOCTL_LDR_LOAD_SIZE(ViewSize));

            if (NULL != LoadReq) {
                RtlZeroMemory(LoadReq, SUP_IOCTL_LDR_LOAD_SIZE(ViewSize));

                LoadReq->Hdr.u32Cookie = Cookie;
                LoadReq->Hdr.u32SessionCookie = SessionCookie;
                LoadReq->Hdr.cbIn = SUP_IOCTL_LDR_LOAD_SIZE_IN(ViewSize);
                LoadReq->Hdr.cbOut = SUP_IOCTL_LDR_LOAD_SIZE_OUT;
                LoadReq->Hdr.fFlags = SUPREQHDR_FLAGS_MAGIC | SUPREQHDR_FLAGS_EXTRA_IN;
                LoadReq->Hdr.rc = ERR_INTERNAL_ERROR;
                LoadReq->u.In.eEPType = SUPLDRLOADEP_VMMR0;
                LoadReq->u.In.pvImageBase = OpenReq.u.Out.pvImageBase;
                LoadReq->u.In.cbImage = ViewSize;

                RtlCopyMemory(
                    LoadReq->u.In.achImage,
                    ViewBase,
                    ViewSize);

                Diff = LdrSetImageBase(
                    LoadReq->u.In.achImage,
                    LoadReq->u.In.pvImageBase);

                LdrRelocImage(LoadReq->u.In.achImage, Diff);
                LdrSnapThunkOffline(LoadReq->u.In.achImage);

                LoadReq->u.In.pfnModuleTerm =
                    LoadReq->u.In.pfnModuleInit = LdrGetEntryPointOffline(
                        LoadReq->u.In.pvImageBase,
                        LoadReq->u.In.achImage);

                // pass unset
                LoadReq->u.In.EP.VMMR0.pvVMMR0 = (ptr)((u)OpenReq.u.Out.pvImageBase + 1);

                LoadReq->u.In.EP.VMMR0.pvVMMR0EntryInt = LdrGetEntryPointOffline(
                    LoadReq->u.In.pvImageBase,
                    LoadReq->u.In.achImage);;

                LoadReq->u.In.EP.VMMR0.pvVMMR0EntryFast = LdrGetSymbolOffline(
                    LoadReq->u.In.pvImageBase,
                    LoadReq->u.In.achImage,
                    "KernelFastCall",
                    0);

                LoadReq->u.In.EP.VMMR0.pvVMMR0EntryEx = LdrGetSymbolOffline(
                    LoadReq->u.In.pvImageBase,
                    LoadReq->u.In.achImage,
                    "KernelEntry",
                    0);

                Status = NtDeviceIoControlFile(
                    SUPHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    SUP_IOCTL_LDR_LOAD,
                    LoadReq,
                    LoadReq->Hdr.cbIn,
                    LoadReq,
                    LoadReq->Hdr.cbOut);

                if (NT_SUCCESS(Status)) {
                    CallReq.Hdr.u32Cookie = Cookie;
                    CallReq.Hdr.u32SessionCookie = SessionCookie;
                    CallReq.Hdr.cbIn = SUP_IOCTL_CALL_VMMR0_SIZE_IN(0);
                    CallReq.Hdr.cbOut = SUP_IOCTL_CALL_VMMR0_SIZE_OUT(0);
                    CallReq.Hdr.fFlags = SUPREQHDR_FLAGS_DEFAULT;
                    CallReq.Hdr.rc = ERR_INTERNAL_ERROR;
                    CallReq.u.In.pVMR0 = (ptr)((u)OpenReq.u.Out.pvImageBase
                        - MEM_FENCE_EXTRA - sizeof(SUPDRVLDRIMAGE)/* - sizeof(MEMHDR) */);
                    CallReq.u.In.uOperation = Operation;
                    CallReq.u.In.u64Arg = 0;

                    DbgPrint(
                        ".reload /i %s=%p < %p - %08x >\n",
                        BaseName,
                        OpenReq.u.Out.pvImageBase,
                        OpenReq.u.Out.pvImageBase,
                        ViewSize);

                    Status = NtDeviceIoControlFile(
                        SUPHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        SUP_IOCTL_CALL_VMMR0(0),
                        &CallReq,
                        CallReq.Hdr.cbIn,
                        &CallReq,
                        CallReq.Hdr.cbOut);

                    SupLdrUnload(OpenReq.u.Out.pvImageBase);
                }

                __free(LoadReq);
            }
            else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        __free(ViewBase);
    }

    return Status;
}

```

`Support.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _SUPPORT_H_
#define _SUPPORT_H_

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

    status
        NTAPI
        RegistryOpenKey(
            __out ptr * KeyHandle,
            __in ACCESS_MASK DesiredAccess,
            __in wcptr KeyList
        );

    status
        NTAPI
        RegistryCreateSevice(
            __in wcptr ImageFileName,
            __in wcptr ServiceName
        );

    status
        NTAPI
        RegistryDeleteSevice(
            __in wcptr ServiceName
        );

    ptr
        NTAPI
        LdrGetSymbolOffline(
            __in ptr ImageBase,
            __in ptr ImageViewBase,
            __in_opt cptr ProcedureName,
            __in_opt u32 ProcedureNumber
        );

    status
        NTAPI
        SupInstall(
            void
        );

    void
        NTAPI
        SupUninstall(
            void
        );

    status
        NTAPI
        SupInit(
            void
        );

    void
        NTAPI
        SupTerm(
            void
        );

    status
        NTAPI
        SupLdrUnload(
            __in ptr ImageBase
        );

    status
        NTAPI
        SupSetVMForFastIoCtl(
            __in ptr Handler
        );

    status
        NTAPI
        SupLdrLoad(
            __in wcptr ImageFileName,
            __in cptr BaseName,
            __in u32 Operation
        );

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_SUPPORT_H_

```