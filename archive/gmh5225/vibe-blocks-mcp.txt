Project Path: arc_gmh5225_vibe-blocks-mcp_qowkrrqz

Source Tree:

```txt
arc_gmh5225_vibe-blocks-mcp_qowkrrqz
├── LICENSE
├── PLUGIN.md
├── README.md
├── aftman.toml
├── main.py
├── pyproject.toml
├── requirements.txt
├── roblox_mcp_plugin
│   ├── README.md
│   ├── VibeBlocksMCP_Companion.rbxm
│   ├── default.project.json
│   └── src
│       └── Plugin.server.lua
├── server.sh
├── src
│   └── roblox_mcp
│       ├── __init__.py
│       ├── config.py
│       ├── roblox_client.py
│       ├── server.py
│       └── sse.py
└── uv.lock

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 majidmanzarpour

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`PLUGIN.md`:

```md
# Plugin Refactoring Task List

This document lists the MCP tools that currently use the cloud execution API (`execute_luau`) but should be refactored to use the Studio plugin command queue for proper interaction with the live editor session.

The general process for refactoring each tool involves:

1.  **Server (`src/roblox_mcp/server.py`):**
    *   Modify the tool's Python function (`@mcp_server.tool()`).
    *   Replace calls to `client.call_luau(...)` with `await queue_command_and_wait(...)`.
    *   Construct the `command` dictionary with a unique `action` key (e.g., `"find_instances"`) and a `data` payload containing necessary parameters (e.g., `class_name`, `search_root`).
    *   Process the dictionary result returned by `queue_command_and_wait`, checking for `"error"` or the expected result key (e.g., `"instances"`).
    *   Format the result into a user-friendly string for the tool output.
2.  **Plugin (`roblox_mcp_plugin/src/Plugin.server.lua`):**
    *   Define a new Lua handler function (e.g., `local function handleFindInstances(data)`) *before* the `COMMAND_HANDLERS` table.
    *   Implement the core logic within the handler to perform the action in Studio (e.g., `root:GetDescendants()`, `target:Destroy()`, `target[propName] = value`, etc.).
    *   Extract the `request_id` from the `data` table passed to the handler.
    *   Prepare a `resultPayload` table containing either the successful result (e.g., `{ instances = ... }`) or an error (e.g., `{ error = "..." }`). Use the `serializeValue` helper if needed for complex data types.
    *   Call `sendResultToServer(requestId, resultPayload)` to send the outcome back to the server.
    *   Register the new handler in the `COMMAND_HANDLERS` table (e.g., `find_instances = handleFindInstances`).

---

## Tasks:

- [x] **`find_instances`**
    - **Server:** Queue command `{"action": "find_instances", "data": {"class_name": ..., "name_contains": ..., "search_root": ...}}`. Wait for result `{ "instances": [...] }` or `{ "error": "..." }`.
    - **Plugin:** Add `handleFindInstances`. Logic to find descendants matching criteria. Serialize results (name, className, path) in a list. Send back.

- [x] **`delete_instance`**
    - **Server:** Queue command `{"action": "delete_instance", "data": {"object_name": ...}}`. Wait for result `{ "success": true }` or `{ "error": "..." }`.
    - **Plugin:** Add `handleDeleteInstance`. Logic to find object by path and call `:Destroy()`. Send back success/error status.

- [x] **`set_property`**
    - **Server:** Queue command `{"action": "set_property", "data": {"object_name": ..., "property_name": ..., "value": ...}}`. Wait for result `{ "success": true }` or `{ "error": "..." }`. (*Note: Python `value` needs appropriate conversion before sending if it's not a basic type expected by the plugin's Lua type handling*).
    - **Plugin:** Add `handleSetProperty`. Logic to find object, find property, handle basic Lua type assignment (string, number, boolean, nil). Need robust type handling for common Roblox types (Vector3, Color3, BrickColor, Enum, Instance assignment) likely using `pcall` and checking `typeof(value)`. Send back success/error status.

- [x] **`move_instance`**
    - **Server:** Queue command `{"action": "move_instance", "data": {"object_name": ..., "position": '{"x": X, "y": Y, "z": Z}'}}` (ensure position is a JSON string representing the dictionary, e.g., `'{"x": X, "y": Y, "z": Z}'`). Wait for result `{ "success": true }` or `{ "error": "..." }`. (Alternatively, keep calling the refactored `set_property` tool).
    - **Plugin:** Add `handleMoveInstance`. Logic to find object, check if Model+PrimaryPart or BasePart, set Position/CFrame. Send back success/error status.

- [x] **`clone_instance`**
    - **Server:** Queue command `{"action": "clone_instance", "data": {"object_name": ..., "new_name": ..., "parent_name": ...}}`. Wait for result `{ "success": true, "clone_name": ..., "clone_path": ... }` or `{ "error": "..." }`.
    - **Plugin:** Add `handleCloneInstance`. Logic to find original, call `:Clone()`, find target parent (or use original's), set new parent, set new name. Send back success/error status and new details.

- [x] **`create_script`**
    - **Server:** Queue command `{"action": "create_script", "data": {"script_name": ..., "script_code": ..., "script_type": ..., "parent_name": ...}}`. Wait for result `{ "success": true, "name": ..., "path": ... }` or `{ "error": "..." }`.
    - **Plugin:** Add `handleCreateScript`. Logic to find parent, call `Instance.new()`, set Name, Source, Parent. Send back success/error status and details.

- [x] **`set_environment`**
    - **Server:** Queue command `{"action": "set_environment", "data": {"target": "Lighting" | "Terrain", "properties": {...}}}`. Wait for result `{ "success": true }` or `{ "error": "..." }`. (*Note: Value conversion needed as with `set_property`*).
    - **Plugin:** Add `handleSetEnvironment`. Logic to get Lighting service or Terrain object, iterate through properties, set values with type handling. Send back success/error status.

- [x] **`spawn_npc`**
    - **Server:** Queue command `{"action": "spawn_npc", "data": {"model_asset_id": ..., "template_model_name": ..., "position": {...}, "parent_name": ..., "new_name": ...}}`. Wait for result `{ "success": true, "name": ..., "path": ... }` or `{ "error": "..." }`.
    - **Plugin:** Add `handleSpawnNpc`. Logic to either call `InsertService:LoadAsset()` or find/clone template, parent the result, set name, attempt to set position. Send back success/error status and details.

- [x] **`play_animation`**
    - **Server:** Queue command `{"action": "play_animation", "data": {"target_name": ..., "animation_id": ...}}`. Wait for result `{ "success": true }` or `{ "error": "..." }`.
    - **Plugin:** Add `handlePlayAnimation`. Logic to find target, find Humanoid/AnimationController, create temp `Animation` instance, load it (`LoadAnimation`), call `:Play()` on the track. Send back success/error status. 

## New Script Management Tools:

- [x] **`edit_script`**
    - **Server:** Queue command `{"action": "edit_script", "data": {"script_path": ..., "script_code": ...}}`. Wait for result `{ "success": true }` or `{ "error": "..." }`.
    - **Plugin:** Add `handleEditScript`. Logic to find script by path, validate it's a Script/LocalScript, update its Source property. Send back success/error status.

- [x] **`delete_script`**
    - **Server:** Queue command `{"action": "delete_script", "data": {"script_path": ...}}`. Wait for result `{ "success": true }` or `{ "error": "..." }`.
    - **Plugin:** Add `handleDeleteScript`. Logic to find script by path, validate it's a Script/LocalScript, call `:Destroy()`. Send back success/error status.

## Proposed New Tools

- [ ] **`rotate_instance`**
    - **Server:** Queue command `{"action": "rotate_instance", "data": {"object_name": ..., "rotation_type": "euler"|"cframe_delta", "rotation_values": [... or CFrame components]}}`. Wait for result `{ "success": true }` or `{ "error": "..." }`.
    - **Plugin:** Add `handleRotateInstance`. Find object (Model or BasePart). If Model, use PrimaryPart. Apply rotation using `target:SetPrimaryPartCFrame(target.PrimaryPart.CFrame * CFrame.Angles(...))` or similar for CFrame delta. Send back success/error.

- [ ] **`group_instances`**
    - **Server:** Queue command `{"action": "group_instances", "data": {"instance_paths": [...], "new_group_name": ..., "parent_name": ...}}`. Wait for result `{ "success": true, "model_name": ..., "model_path": ... }` or `{ "error": "..." }`.
    - **Plugin:** Add `handleGroupInstances`. Find parent. Create new `Model`. Find each instance by path, validate, and set its Parent to the new Model. Set Model Name and Parent. Potentially call `model:MakeJoints()`? Send back success/error and model details.

- [ ] **`ungroup_model`**
    - **Server:** Queue command `{"action": "ungroup_model", "data": {"model_path": ...}}`. Wait for result `{ "success": true }` or `{ "error": "..." }`.
    - **Plugin:** Add `handleUngroupModel`. Find the Model. Get its Parent. Iterate through Model children (`model:GetChildren()`) and set their Parent to the Model's original parent. Call `model:Destroy()`. Send back success/error.

- [ ] **`fill_terrain_block`** (Example for `edit_terrain`)
    - **Server:** Queue command `{"action": "fill_terrain_block", "data": {"material": "Enum.Material...", "position": {...}, "size": {...}}}`. Wait for result `{ "success": true }` or `{ "error": "..." }`.
    - **Plugin:** Add `handleFillTerrainBlock`. Get Terrain service. Construct CFrame and Size from position/size data. Call `Terrain:FillBlock(cframe, size, materialEnum)`. Send back success/error.

- [ ] **`create_particle_emitter`**
    - **Server:** Queue command `{"action": "create_particle_emitter", "data": {"parent_path": ..., "properties": {...}}}`. Wait for result `{ "success": true, "emitter_name": ..., "emitter_path": ... }` or `{ "error": "..." }`. (Properties might include Texture, Color, Size, Rate, etc., requiring type conversion).
    - **Plugin:** Add `handleCreateParticleEmitter`. Find parent part. Create `Instance.new("ParticleEmitter")`. Apply properties (use `convertToRobloxType` helper, may need extensions for sequences). Set Parent. Send back success/error and emitter details.

- [ ] **`play_sound`**
    - **Server:** Queue command `{"action": "play_sound", "data": {"sound_id": "rbxassetid://...", "parent_path": ... | "position": {...}, "properties": {...}}}`. Wait for result `{ "success": true, "sound_instance_path": ... }` or `{ "error": "..." }`. (Properties: Volume, TimePosition, Looped, etc.).
    - **Plugin:** Add `handlePlaySound`. Create `Instance.new("Sound")`. Set SoundId and other properties. If `parent_path` provided, find parent and set Sound.Parent. If `position` provided, parent to Workspace or Terrain, set Position. Call `sound:Play()`. Return success/error and the path to the temporary Sound instance (e.g., `Workspace.Sound_xyz`). Consider how to manage/clean up these sounds.

- [ ] **`create_ui_element`** (Example: TextLabel)
    - **Server:** Queue command `{"action": "create_ui_element", "data": {"element_type": "TextLabel", "parent_path": "StarterGui.MyScreenGui", "properties": {"Text": "Hello", "Size": "UDim2.new(0, 100, 0, 50)", ...}}}`. Wait for result `{ "success": true, "element_name": ..., "element_path": ... }` or `{ "error": "..." }`. (Needs careful property formatting/conversion, especially UDim2).
    - **Plugin:** Add `handleCreateUIElement`. Find parent (might need to create ScreenGui first if it doesn't exist). Create `Instance.new(elementType)`. Apply properties (need robust conversion for UDim2, Color3, etc.). Set Parent. Send back success/error and element details.

- [ ] **`find_path`**
    - **Server:** Queue command `{"action": "find_path", "data": {"start_pos": {...}, "end_pos": {...}, "agent_params": {...}}}`. Wait for result `{ "success": true, "path_status": "Enum.PathStatus...", "waypoints": [{x,y,z}, ...] }` or `{ "error": "..." }`.
    - **Plugin:** Add `handleFindPath`. Get `PathfindingService`. Create path `p = service:CreatePath(agentParams)`. Compute `p:ComputeAsync(startVec3, endVec3)`. Check status. If success, iterate `p:GetWaypoints()`, convert Vector3s to tables `{x,y,z}`, return status and waypoint list. Send back result.

- [ ] **`create_remote_event`**
    - **Server:** Queue command `{"action": "create_remote_event", "data": {"event_name": ..., "parent_path": "ReplicatedStorage"}}`. Wait for result `{ "success": true, "event_name": ..., "event_path": ... }` or `{ "error": "..." }`.
    - **Plugin:** Add `handleCreateRemoteEvent`. Find parent (default ReplicatedStorage). Create `Instance.new("RemoteEvent")`. Set Name and Parent. Send back success/error and event details.

- [ ] **`set_primary_part`**
    - **Server:** Queue command `{"action": "set_primary_part", "data": {"model_path": ..., "part_path": ...}}`. Wait for result `{ "success": true }` or `{ "error": "..." }`.
    - **Plugin:** Add `handleSetPrimaryPart`. Find model by path, find part by path. Validate both are found, model is a Model, part is a BasePart, and part is descendant of model. Set `model.PrimaryPart = part`. Send back success/error status.

- [ ] **`execute_luau_in_studio`**
    - **Server:** Queue command `{"action": "execute_script_in_studio", "data": {"script_code": ...}}`. Wait for result `{ "output_lines": [...], "return_values": [...], "error_message": ... }`.
    - **Plugin:** Add `handleExecuteScriptInStudio`. Use `loadstring` to compile code. Override `print`. Use `pcall` to execute. Capture prints, return values (serialized), and errors. Restore `print`. Send results back.

- [ ] **`modify_children`**
    - **Server:** Queue command `{"action": "modify_children", "data": {"parent_path": ..., "property_name": ..., "property_value": ..., "child_name_filter": ..., "child_class_filter": ...}}`. `property_value` must be a JSON string like `set_property`. Wait for result `{ "affected_count": N, "errors": [...] }`.
    - **Plugin:** Add `handleModifyChildren`. Find parent. Loop `GetChildren()`. Apply name/class filters. For matching children, attempt to set `property_name` to `property_value` (using `pcall`, decoding JSON string value if needed, using `convertToRobloxType`). Report back affected count and list of errors. 
```

`README.md`:

```md
# Vibe Blocks MCP for Roblox Studio

Connects Roblox Studio to AI coding editors (like Cursor, Windsurf, Claude, etc) via the Model Context Protocol (MCP), enabling AI-assisted game development within your Roblox Studio environment.

## Overview

This project consists of two main parts:

1.  **Python MCP Server:** A FastAPI server that runs locally. It exposes Roblox Studio actions as tools over MCP (using Server-Sent Events - SSE). It can optionally interact with Roblox Open Cloud APIs if configured.
2.  **Lua Companion Plugin:** A Roblox Studio plugin (`roblox_mcp_plugin/src/Plugin.server.lua`) that runs inside Studio. It polls the local Python server for commands, executes them in the Studio context (manipulating instances, reading properties, executing Luau), and sends results and Studio logs back to the server.

This allows an AI agent connected via MCP to understand and interact with your live Roblox Studio session.

## Features

*   **Live Studio Interaction:**
    *   **Scene Manipulation:** Create, delete, clone, move, scale, and set properties (including PrimaryPart) of objects (Parts, Models, Scripts, etc.) directly in the Studio scene.
    *   **Scene Inspection:** Get object properties, list children, find instances by class or name within Studio.
    *   **Scripting:** Create, edit, and delete Scripts/LocalScripts. Execute arbitrary Luau code *directly within the Studio environment* and capture output/errors.
    *   **Environment:** Set properties on Lighting or Terrain services.
    *   **Animation:** Play animations on Humanoids/AnimationControllers.
    *   **NPCs:** Spawn NPCs by cloning existing templates or inserting from Asset IDs.
    *   **Modify Children:** Apply property changes to multiple children of an object based on filters.
    *   **Studio Logs:** Retrieve recent logs from the Studio Output window.
*   **Roblox Open Cloud Integration (Optional - Requires API Key):**
    *   **Luau Execution (Cloud):** Run Luau code in a separate cloud environment (useful for tasks not requiring live Studio access).
    *   **DataStores:** List stores, get, set, and delete key-value entries in standard DataStores.
    *   **Assets:** Upload new assets (Models, Images, Audio) from local files.
    *   **Publishing:** Publish the currently saved or published version of a place.
    *   **(Planned):** Get asset details, list user assets.

## Setup

**1. Prerequisites:**

*   Python >= 3.10
*   `uv` package manager ([Install uv](https://github.com/astral-sh/uv#installation)). This is highly recommended for faster dependency management.
*   Roblox Studio
*   **(Optional)** A Roblox API Key for Open Cloud features. Get one from [Roblox Creator Dashboard > Credentials](https://create.roblox.com/credentials). You'll need permissions for the APIs you intend to use (DataStore, Asset Upload, Publishing, Luau Execution etc.).
*   **(Optional)** Your Roblox Universe ID and the target Place ID (needed for Open Cloud features).

**2. Clone the Repository:**

```bash
git clone https://github.com/majidmanzarpour/vibe-blocks-mcp 
cd vibe-blocks-mcp
```

**3. Install Dependencies:**

Using `uv` (recommended):

```bash
uv pip sync pyproject.toml
```

Alternatively, using `pip`:

```bash
pip install -r requirements.lock # Or create requirements.txt from pyproject.toml if needed
```

**4. Configure Environment (Optional - For Cloud Features):**

*   If you plan to use the Open Cloud tools (DataStores, Asset Upload, Publishing, Cloud Luau), copy the example environment file:
    ```bash
    cp .env.example .env
    ```
*   **Edit the `.env` file:**
    *   Replace `"YOUR_API_KEY_HERE"` with your Roblox API Key.
    *   Replace `0` for `ROBLOX_UNIVERSE_ID` with your Universe ID.
    *   Replace `0` for `ROBLOX_PLACE_ID` with the target Place ID.
*   **If you don't need Cloud features, you can skip creating the `.env` file.** The server will still run, but Cloud-related tools will return an error.

**5. Install the Companion Plugin in Roblox Studio:**

*   **Install Rojo:** If you don't have Rojo installed, follow the instructions on the [Rojo website](https://rojo.space/docs/install/).
*   **Build the Plugin (optional):** Navigate to the `roblox_mcp_plugin` directory in your terminal and run:
    ```bash
    rojo build default.project.json --output VibeBlocksMCP_Companion.rbxm
    ```
    This will create a `VibeBlocksMCP_Companion.rbxm` file or you can use the one provided in the repository.
*   **Install in Studio:**
    *   Find your Roblox Studio plugins folder:
        *   **Windows:** `%LOCALAPPDATA%\Roblox\Plugins`
        *   **macOS:** `~/Documents/Roblox/Plugins` (You might need to use `Cmd+Shift+G` in Finder and paste the path to navigate there, or click Plugin Folder in Roblox Studio).
    *   Move or copy the generated `VibeBlocksMCP_Companion.rbxm` file into this plugins folder.
*   **Restart Roblox Studio:** The plugin should now be loaded automatically when you open Studio.
    *   **Note:** The plugin polls `http://localhost:8000/plugin_command`. If you change the server port, you'll need to update the `SERVER_URL` variable at the top of the Lua script (`roblox_mcp_plugin/src/Plugin.server.lua`) and rebuild the plugin.

**6. Run the Python Server:**

*   Open your terminal in the project's root directory.
*   Make the server script executable (if you haven't already):
    ```bash
    chmod +x server.sh 
    ```
*   Run the server:
    ```bash
    ./server.sh
    ```
*   The server will start, check/install `uvicorn` if needed, and log that it's running on `http://localhost:8000`.
*   Keep this terminal window open while you're using the service.

**7. Connect from MCP Client (e.g., Cursor):**

*   This service works with any AI client that supports the Model Context Protocol (MCP) via Server-Sent Events (SSE), such as Cursor, Windsurf, or potentially future versions of Claude Desktop.
*   **Example using Cursor:**
    *   Go to `File > Settings > MCP` (or `Code > Settings > MCP` on Mac).
    *   Click "Add New Global MCP Server".
    *   Enter the **SSE URL:** `http://localhost:8000/sse` (make sure to include the trailing `/sse`).
    *   You may need to edit the mcp.json file
    ```
    {
    "mcpServers": {
      "Vibe Blocks MCP": {
        "url": "http://localhost:8000/sse"
        }
      }
    }
    ```
*   The client should now detect the "Vibe Blocks MCP" tool source and its available tools.

## Usage

Once the server is running, the plugin is installed in Studio, and your MCP client is connected, you can interact with your Studio session through the AI.

Address the agent (@-mentioning the tools  if your client requires it, e.g., `list_children`) and ask it to perform actions.

**Example Prompts:**

*   "Create a bright red Part named 'Floor' in Workspace. Set its size to (100, 2, 100) and position to (0, -1, 0). Anchor it."
*   "Delete the object named 'Workspace.OldPlatform'"
*   "What is the Position property of 'Workspace.SpawnLocation'?"
*   "List the children of ServerScriptService."
*   "Find all instances with className 'Script' under ServerScriptService."
*   "Execute this script in Studio: `print(game:GetService('Lighting').ClockTime)`"
*   "Set the `ClockTime` property of Lighting to 14."
*   "Clone 'ReplicatedStorage.Templates.EnemyNPC' and name the clone 'Guard1'. Parent it to Workspace."
*   "Make the model named 'Workspace.Guard1' play animation asset 123456789."
*   "Modify all children of 'Workspace.DecorationFolder' with className 'Part' to have their Material set to 'Neon'."
*   **(Cloud Example)** "Upload './assets/MyCoolModel.fbx' as a Model named 'Cool Character Model'."
*   **(Cloud Example)** "Get the value for key 'player_123_score' from the 'PlayerData' datastore."
*   **(Cloud Example)** "Publish the current place."
*   "Show me the latest logs from the Studio output."

## Available Tools

*(Tools interact either directly with the Studio Plugin or with Roblox Open Cloud APIs)*

**Studio Plugin Tools (Live Interaction):**

*   `get_property`: Retrieves the value of a specific property from an object in Studio.
*   `list_children`: Retrieves direct children of an object in Studio.
*   `find_instances`: Finds instances within a specified root based on class name or name containing text in Studio.
*   `create_instance`: Creates a new instance (Part, Model, Script, etc.) in Studio.
*   `delete_instance`: Deletes an object from the Studio scene.
*   `set_property`: Sets a specific property on an object in Studio (uses JSON string for value).
*   `set_primary_part`: Sets the PrimaryPart property of a Model.
*   `move_instance`: Moves an object (Model or BasePart) to a new position in Studio.
*   `clone_instance`: Clones an existing object in Studio.
*   `create_script`: Creates a new Script or LocalScript instance with provided code in Studio.
*   `edit_script`: Edits the source code of an existing Script or LocalScript in Studio.
*   `delete_script`: Deletes an existing Script or LocalScript instance in Studio.
*   `set_environment`: Sets properties on environment services (Lighting or Terrain) in Studio.
*   `spawn_npc`: Spawns an NPC in Studio, either by inserting a model from asset ID or cloning an existing template model.
*   `play_animation`: Loads and plays an animation on a target object's Humanoid or AnimationController in Studio.
*   `execute_luau_in_studio`: Executes arbitrary Luau script in the LIVE Studio session via the plugin and captures output/return values/errors.
*   `modify_children`: Finds direct children under a parent matching optional filters (name/class) and sets a specified property on them.
*   `get_studio_logs`: Retrieves the most recent logs captured from the Roblox Studio Output window via the plugin.

**Open Cloud API Tools (Optional - Require `.env` setup):**

*   `execute_luau_in_cloud`: Executes arbitrary Luau script via the Roblox Cloud API (runs in a separate cloud environment, not live Studio).
*   `list_datastores_in_cloud`: Lists standard datastores via the Cloud API.
*   `get_datastore_value_in_cloud`: Gets the value of an entry from a standard datastore via the Cloud API.
*   `set_datastore_value_in_cloud`: Sets the value for an entry in a standard datastore via the Cloud API.
*   `delete_datastore_value_in_cloud`: Deletes an entry from a standard datastore via the Cloud API.
*   `upload_asset_via_cloud`: Uploads a file from the local system as a new Roblox asset via the Cloud API.
*   `publish_place_via_cloud`: Publishes the specified place via the Cloud API.
*   `get_asset_details_via_cloud`: (Not Implemented) Gets details about a specific asset via the Cloud API.
*   `list_user_assets_via_cloud`: (Not Implemented) Lists assets owned by the authenticated user via the Cloud API.
*   `send_chat_via_cloud`: Sends a message to the in-game chat via the Cloud API (execute_luau).
*   `teleport_player_via_cloud`: Teleports a player via the Cloud API (execute_luau).

**Internal/Queueing Tools:**

*   `queue_studio_command`: (Lower-level) Queues a single raw command dictionary for the Studio plugin.
*   `queue_studio_command_batch`: (Lower-level) Queues a batch of raw command dictionaries for the Studio plugin.

## Troubleshooting

*   **Server Not Starting:** Ensure Python and `uv` are installed correctly. Check terminal for error messages. Make sure dependencies are installed (`uv pip sync pyproject.toml`).
*   **Plugin Not Connecting:** Verify the Python server is running. Double-check the `SERVER_URL` in the Lua plugin script matches the server address and port (default `http://localhost:8000/plugin_command`). Check Studio's Output window for errors from the plugin script.
*   **MCP Client Not Connecting:** Ensure the server is running. Verify the SSE URL (`http://localhost:8000/sse`) is entered correctly in your MCP client settings.
*   **Cloud Tools Failing:** Make sure you have created a `.env` file with a valid API Key, Universe ID, and Place ID. Ensure your API key has the necessary permissions for the specific Cloud APIs you are trying to use.
*   **Permissions:** The companion plugin requires Script Injection permissions to function correctly if you load it from a local file instead of installing it properly.

```

`aftman.toml`:

```toml
# aftman.toml
 
[tools]
rojo = "rojo-rbx/rojo@7.1.0" # Using version from Aftman README example 
```

`main.py`:

```py
from roblox_mcp.server import main as server_main

def main():
    """Entry point for the roblox-mcp package"""
    server_main()
 
if __name__ == "__main__":
    main() 
```

`pyproject.toml`:

```toml
[project]
name = "roblox-mcp"
version = "0.1.0"
description = "Roblox Studio integration through the Model Context Protocol"
readme = "README.md"
requires-python = ">=3.10"
authors = [
    {name = "AI Assistant", email = "assistant@example.com"} # Replace with actual author info if desired
]
license = {text = "MIT"} # Or choose another appropriate license
classifiers = [
    "Programming Language :: Python :: 3",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
]
dependencies = [
    "mcp[cli]>=1.3.0",
    "python-dotenv>=1.0.0",
    "requests>=2.30.0",
]

[project.scripts]
roblox-mcp = "roblox_mcp.server:main"

[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[tool.setuptools]
package-dir = {"" = "src"}

```

`requirements.txt`:

```txt
# Base MCP requirements (assuming mcp-server is installed separately or via setup.py)

# Cloud API Client requirements
python-dotenv
aiohttp
pydantic

# FastAPI requirements for Plugin Communication
fastapi
uvicorn[standard] # Includes standard dependencies like websockets, httptools 
```

`roblox_mcp_plugin/README.md`:

```md
# Vibe Blocks MCP Companion Plugin

This is the companion Roblox Studio plugin for the Vibe Blocks MCP project. The plugin enables direct communication between the Python backend server and Roblox Studio, allowing for real-time interaction with the Studio environment.

## File Structure

- `default.project.json` - Rojo project configuration file (specifies the project name `VibeBlocksMCP_Companion`)
- `src/Plugin.server.lua` - Main plugin script containing all command handlers

## Building the Plugin

### Prerequisites

1. [Rojo](https://rojo.space/) - Install Rojo 7.0 or later
   - Rojo is a build system that bridges the gap between Roblox Studio and external code editors

### Build Instructions

1. **Using Command Line**:
   ```bash
   # Navigate to this plugin directory (roblox_mcp_plugin)
   cd roblox_mcp_plugin
   
   # Build the plugin (.rbxm file)
   rojo build default.project.json -o VibeBlocksMCP_Companion.rbxm
   ```

2. **Using Rojo VSCode Extension**:
   - Open this plugin folder in VSCode
   - Right-click on `default.project.json`
   - Select "Rojo: Build" from the context menu
   - Choose a location to save the output file (name it `VibeBlocksMCP_Companion.rbxm`)

### Installing the Plugin in Roblox Studio

1. In Roblox Studio, go to the "Plugins" tab
2. Click on "Plugins Folder" button
3. Copy the built `VibeBlocksMCP_Companion.rbxm` file to this folder
4. Restart Roblox Studio
5. The plugin should now appear in your Plugins tab

## Development and Modification

When developing or modifying the plugin:

1. Make your changes to the `Plugin.server.lua` file
2. Rebuild the plugin using the instructions above (outputting `VibeBlocksMCP_Companion.rbxm`)
3. If using Rojo's live sync feature for development:
   ```bash
   rojo serve default.project.json
   ```
   Then connect to the Rojo server from within Studio using the Rojo plugin.

## Output File Naming

For consistency, always name the output file `VibeBlocksMCP_Companion.rbxm` when building the plugin. This matches the project name defined in `default.project.json`.

## Plugin Functionality

This plugin enables communication with the Vibe Blocks MCP server and implements handlers for various commands including:

- Instance creation, deletion, and property manipulation
- Script management (create, edit, delete)
- Environment settings
- Animation playback
- NPC spawning
- Studio log forwarding
- Execution of Luau code within Studio

See the main project's `README.md` file for details on all supported commands. 
```

`roblox_mcp_plugin/default.project.json`:

```json
{
  "name": "VibeBlocksMCP_Companion",
  "tree": {
    "$path": "src"
  }
} 
```

`roblox_mcp_plugin/src/Plugin.server.lua`:

```lua
--[[ Plugin Main Script ]]

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local LogService = game:GetService("LogService") -- Added LogService

local SERVER_URL = "http://localhost:8000/plugin_command" -- TODO: Make configurable
local POLLING_INTERVAL = 2 -- Seconds

-- --- NEW: Result Reporting Configuration --- --
local SERVER_RESULT_ENDPOINT = "http://localhost:8000/plugin_report_result" -- Endpoint for sending results back
-- --- END: Result Reporting Configuration --- --

-- --- NEW: Logging Configuration --- --
local SERVER_LOG_ENDPOINT = "http://localhost:8000/receive_studio_logs" -- Endpoint for sending logs
local SEND_INTERVAL = 1.5 -- Minimum seconds between log sends to avoid spam
local MAX_LOG_BATCH_SIZE = 50 -- Max logs to send in one batch

local logsToSend = {} -- Buffer for logs waiting to be sent
local isSendingLogs = false -- Flag to prevent concurrent sends
local lastLogSendTime = 0
-- --- END: Logging Configuration --- --

local lastPollTime = 0

print("Vibe Blocks MCP Companion Plugin Loaded")

-- --- Helper: Send Result Back to Server --- --
local function sendResultToServer(requestId, resultData)
	if not requestId then
		print("Vibe Blocks MCP Plugin: Error - Cannot send result without a request ID.")
		return
	end
	
	local payload = {
		request_id = requestId,
		result = resultData -- This should be a table (will be JSON encoded)
	}
	
	local success, encodedPayload = pcall(function()
		return HttpService:JSONEncode(payload)
	end)
	
	if not success then
		print("Vibe Blocks MCP Plugin: Error - Failed to JSON encode result payload for request ID " .. requestId .. ": " .. tostring(encodedPayload)) -- encodedPayload is error message here
		return
	end
	
	print("Vibe Blocks MCP Plugin: Sending result for request ID " .. requestId .. " to " .. SERVER_RESULT_ENDPOINT)
	
	local postSuccess, postError = pcall(function()
		-- Use PostAsync for non-blocking request
		HttpService:PostAsync(SERVER_RESULT_ENDPOINT, encodedPayload, Enum.HttpContentType.ApplicationJson)
	end)
	
	if not postSuccess then
		print("Vibe Blocks MCP Plugin: Error - Failed to POST result to server for request ID " .. requestId .. ": " .. tostring(postError))
		-- Maybe implement retry logic later if needed
	else
		print("Vibe Blocks MCP Plugin: Successfully posted result for request ID " .. requestId)
	end
end
-- --- End Helper: Send Result --- --

local function findObjectFromPath(pathString)
	-- Simple path traversal (game, workspace, or starts with game/workspace)
	local parts = pathString:split(".")
	local currentObject
	local firstPartLower = string.lower(parts[1])

	-- Check if the path starts explicitly with game or workspace
	if firstPartLower == "game" then
		currentObject = game
		table.remove(parts, 1) -- Remove 'game' from parts to traverse
	elseif firstPartLower == "workspace" then
		currentObject = workspace
		table.remove(parts, 1) -- Remove 'workspace' from parts to traverse
	else
		-- Default to starting search from 'game' for other services (ServerStorage, etc.)
		currentObject = game
	end

	-- Traverse the remaining parts
	for _, partName in ipairs(parts) do
		if currentObject then
			currentObject = currentObject:FindFirstChild(partName)
		else
			return nil -- Path became invalid
		end
	end
	return currentObject
end

-- --- NEW: Helper to Convert Python/JSON values to Roblox Types ---
-- Returns: robloxValue, errorMessage (errorMessage is nil on success)
local function convertToRobloxType(propertyName, valueFromPython)
	local propNameLower = string.lower(propertyName or "") -- Safe lowercasing

	-- 1. Determine Expected Type based on Property Name
	local expectedType = "unknown"
	if propNameLower == "position" or propNameLower == "size" or propNameLower == "velocity" or propNameLower == "rotvelocity" or propNameLower == "orientation" then
		expectedType = "Vector3"
	elseif propNameLower == "color" then
		expectedType = "Color3"
	elseif propNameLower == "brickcolor" then
		expectedType = "BrickColor"
	elseif propNameLower == "cframe" then
		expectedType = "CFrame"
	elseif propNameLower == "material" then
		expectedType = "Enum.Material"
	elseif propNameLower == "shape" or propNameLower == "parttype" or propNameLower == "formfactor" then
		expectedType = "Enum.PartType" -- FormFactor maps to PartType Enum
	-- Add more specific property -> type mappings here (e.g., UDim2, NumberSequence)
	end

	-- 2. Handle Conversion based on Input Type and Expected Type
	local inputType = typeof(valueFromPython)

	if expectedType == "Vector3" then
		if inputType == "table" then
			if type(valueFromPython.x) == "number" and type(valueFromPython.y) == "number" and type(valueFromPython.z) == "number" then
				return Vector3.new(valueFromPython.x, valueFromPython.y, valueFromPython.z), nil
			elseif type(valueFromPython[1]) == "number" and type(valueFromPython[2]) == "number" and type(valueFromPython[3]) == "number" and #valueFromPython == 3 then
				return Vector3.new(valueFromPython[1], valueFromPython[2], valueFromPython[3]), nil
			else
				return nil, "Invalid table format for Vector3. Expected {x,y,z} or array [1,2,3]."
			end
		else
			return nil, "Incorrect input type for Vector3. Expected table, got " .. inputType
		end
	elseif expectedType == "Color3" then
		if inputType == "table" then
			-- Prefer {r,g,b} format (assume 0-1 range from JSON)
			if type(valueFromPython.r) == "number" and type(valueFromPython.g) == "number" and type(valueFromPython.b) == "number" then
				return Color3.new(valueFromPython.r, valueFromPython.g, valueFromPython.b), nil
			-- Accept array [r,g,b] format (assume 0-1 range from JSON)
			elseif type(valueFromPython[1]) == "number" and type(valueFromPython[2]) == "number" and type(valueFromPython[3]) == "number" and #valueFromPython == 3 then
				-- Check if values seem to be in 0-255 range (common mistake)
				if valueFromPython[1] > 1 or valueFromPython[2] > 1 or valueFromPython[3] > 1 then
					print("Vibe Blocks MCP Plugin: Warning - Color3 array values > 1 detected for '"..propertyName.."'. Assuming 0-255 range and using Color3.fromRGB.")
					return Color3.fromRGB(math.floor(valueFromPython[1]), math.floor(valueFromPython[2]), math.floor(valueFromPython[3])), nil
				else
					return Color3.new(valueFromPython[1], valueFromPython[2], valueFromPython[3]), nil
				end
			else
				return nil, "Invalid table format for Color3. Expected {r,g,b} or array [r,g,b] (0-1 range preferred)."
			end
		else
			return nil, "Incorrect input type for Color3. Expected table, got " .. inputType
		end
	elseif expectedType == "BrickColor" then
		if inputType == "string" or inputType == "number" then
			-- BrickColor.new handles invalid names/numbers gracefully by returning grey
			return BrickColor.new(valueFromPython), nil
		else
			return nil, "Incorrect input type for BrickColor. Expected string or number, got " .. inputType
		end
	elseif expectedType == "CFrame" then
		if inputType == "table" then
			-- Support 12-number array format: [x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22]
			local allNumbers = true
			if #valueFromPython == 12 then
				for i = 1, 12 do
					if type(valueFromPython[i]) ~= "number" then
						allNumbers = false
						break
					end
				end
				if allNumbers then
					return CFrame.new(
						valueFromPython[1], valueFromPython[2], valueFromPython[3],
						valueFromPython[4], valueFromPython[5], valueFromPython[6],
						valueFromPython[7], valueFromPython[8], valueFromPython[9],
						valueFromPython[10], valueFromPython[11], valueFromPython[12]
					), nil
				else
					return nil, "Invalid CFrame array. Expected 12 numbers."
				end
			-- Add support for other CFrame formats here if needed (e.g., Position+LookVector dict)
			else
				return nil, "Invalid table format for CFrame. Expected array of 12 numbers."
			end
		else
			return nil, "Incorrect input type for CFrame. Expected table, got " .. inputType
		end
	elseif string.sub(expectedType, 1, 5) == "Enum." then -- Handle Enums
		local enumTypeName = string.sub(expectedType, 6) -- Get "Material", "PartType", etc.
		local enumType = Enum[enumTypeName]
		if not enumType then
			return nil, "Internal Error: Unknown Enum type '" .. enumTypeName .. "'"
		end

		if inputType == "string" then
			-- If it already starts with "Enum.", try direct lookup
			if string.sub(valueFromPython, 1, 5) == "Enum." then
				local parts = valueFromPython:split(".")
				if #parts == 3 and parts[2] == enumTypeName then
					local enumItem = enumType[parts[3]]
					if enumItem then
						return enumItem, nil
					else
						return nil, "Invalid Enum item name '" .. parts[3] .. "' in full Enum path."
					end
				else
					return nil, "Invalid full Enum path format: " .. valueFromPython
				end
			else
				-- Try lookup by string name directly using index
				local enumItem = enumType[valueFromPython] -- Use direct indexing
				-- Alternative: iterate through enumType:GetEnumItems() and compare names (case-insensitive?)
				if enumItem then
					return enumItem, nil
				else
					return nil, "Could not find Enum item '" .. valueFromPython .. "' in Enum." .. enumTypeName
				end
			end
		elseif inputType == "number" then
			-- Try lookup by enum value/number
			for _, item in ipairs(enumType:GetEnumItems()) do
				if item.Value == valueFromPython then
					return item, nil
				end
			end
			return nil, "Could not find Enum item with value " .. tostring(valueFromPython) .. " in Enum." .. enumTypeName
		else
			return nil, "Incorrect input type for Enum." .. enumTypeName .. ". Expected string or number, got " .. inputType
		end
	end

	-- 3. If no specific type matched or conversion wasn't needed, return the original value
	-- This handles basic types: string, number, boolean, nil, and tables for non-special properties
	if inputType == "string" or inputType == "number" or inputType == "boolean" or inputType == "nil" or inputType == "table" then
		return valueFromPython, nil
	else
		-- Should not happen for standard JSON types, but catch anyway
		return nil, "Unsupported input value type: " .. inputType
	end
end
-- --- END Helper: Convert Roblox Value --- --

local function handleSetEnvironment(data)
	local targetName = data.target
	local properties = data.properties
    local requestId = data.request_id -- Extract request ID

	local resultPayload = {} -- Initialize result payload

	if not targetName or not properties or type(properties) ~= "table" then
		resultPayload.error = "Missing/invalid 'target' or 'properties' in set_environment data."
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	local targetService
	local serviceSuccess, serviceOrError = pcall(function()
		if string.lower(targetName) == "lighting" then
			return game:GetService("Lighting")
		elseif string.lower(targetName) == "terrain" then
			return workspace:FindFirstChildOfClass("Terrain")
		else
			error("Unsupported target for set_environment: " .. targetName)
		end
	end)

	if not serviceSuccess then
		resultPayload.error = "Error finding target service: " .. tostring(serviceOrError)
		print("Vibe Blocks MCP Plugin: " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end
	
	targetService = serviceOrError -- Assign the found service
	if not targetService then
		resultPayload.error = "Could not find target service instance: " .. targetName
		print("Vibe Blocks MCP Plugin: " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	print("Vibe Blocks MCP Plugin: Setting properties on " .. targetService.Name .. ":")
	local allPropertiesSuccess = true
	local propertyErrors = {}

	for propName, propValue in pairs(properties) do
		local success, err = pcall(function()
			-- Basic type handling - TODO: Expand this like handleSetProperty
			if type(propValue) == "number" then
				targetService[propName] = propValue
				print("  - Set " .. propName .. " to " .. tostring(propValue))
			elseif type(propValue) == "boolean" then
				targetService[propName] = propValue
				print("  - Set " .. propName .. " to " .. tostring(propValue))
			elseif type(propValue) == "string" then
				targetService[propName] = propValue
				print("  - Set " .. propName .. " to '" .. propValue .. "'")
			elseif type(propValue) == "table" then
				-- Placeholder for complex types
				error("Table values not fully supported yet in set_environment")
			else
				error("Unsupported value type: " .. type(propValue))
			end
		end)
		if not success then
			allPropertiesSuccess = false
			propertyErrors[propName] = tostring(err)
			print("  - Error setting property " .. propName .. ": " .. tostring(err))
		end
	end
	
	if allPropertiesSuccess then
		resultPayload.success = true
		print("Vibe Blocks MCP Plugin: Finished setting environment properties successfully.")
	else
		-- Still technically a success for the operation, but report errors
		resultPayload.success = false -- Mark as partial failure if any prop failed
		resultPayload.errors = propertyErrors
		resultPayload.error = "Failed to set one or more properties." -- General error message
		print("Vibe Blocks MCP Plugin: Finished setting environment properties with errors.")
	end

	-- Send final result
	if requestId then sendResultToServer(requestId, resultPayload) end
end

local function handleCreateInstance(data)
	local className = data.class_name
	local parentName = data.parent_name or "Workspace" -- Default to Workspace
	local properties = data.properties or {} -- Default to empty table
    local requestId = data.request_id -- Extract request ID

	local resultPayload = {} -- Initialize result payload

	if not className then
		resultPayload.error = "Missing 'class_name' in create_instance data."
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	-- Find the parent
	local parentObject = findObjectFromPath(parentName)
	if not parentObject then
		resultPayload.error = "Could not find parent object for create_instance: " .. parentName
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	print(string.format("Vibe Blocks MCP Plugin: Creating instance of '%s' under '%s'", className, parentObject:GetFullName()))

	local success, newInstanceOrError = pcall(function()
		local inst = Instance.new(className)
		inst.Parent = parentObject -- Parent first

		-- Apply properties using the new converter
		for propName, propValue in pairs(properties) do
			print(string.format("  - Applying property '%s' with value type: %s", propName, type(propValue)))
			local robloxValue, convertError = convertToRobloxType(propName, propValue)

			if convertError then
				-- If conversion fails, wrap the error (will be caught by outer pcall)
				error(string.format("Error converting value for property '%s': %s", propName, convertError))
			else
				-- Assign the converted value
				local setSuccess, setError = pcall(function()
					inst[propName] = robloxValue
				end)
				if not setSuccess then
					-- If setting the converted value fails, wrap the error
					error(string.format("Error setting property '%s' after conversion: %s", propName, tostring(setError)))
				end
			end
		end
		return inst -- Return the instance if all properties were set successfully
	end)

	if success then
		local newInstance = newInstanceOrError
		resultPayload.success = true
		resultPayload.name = newInstance.Name
		resultPayload.path = newInstance:GetFullName()
		print("Vibe Blocks MCP Plugin: Finished creating instance " .. resultPayload.path)
	else
		resultPayload.error = "Failed to create instance: " .. tostring(newInstanceOrError)
		print("Vibe Blocks MCP Plugin: " .. resultPayload.error)
	end

	-- Send final result
	if requestId then sendResultToServer(requestId, resultPayload) end
end

local function handleDeleteInstance(data)
	local objectName = data.object_name
	if not objectName then
		print("Vibe Blocks MCP Plugin: Error - Missing 'object_name' in delete_instance data.")
		return
	end

	local target = findObjectFromPath(objectName)
	if not target then
		print("Vibe Blocks MCP Plugin: Error - Could not find object to delete: " .. objectName)
		return
	end

	local fullName = target:GetFullName()
	print("Vibe Blocks MCP Plugin: Deleting instance " .. fullName)
	local success, err = pcall(function()
		target:Destroy()
	end)
	if success then
		print("Vibe Blocks MCP Plugin: Successfully deleted " .. fullName)
	else
		print("Vibe Blocks MCP Plugin: Error deleting " .. fullName .. ": " .. tostring(err))
	end
end

local function handleSetProperty(data)
	local objectName = data.object_name
	local propertyName = data.property_name
	local propertyValue = data.value
    local requestId = data.request_id -- Extract request ID

	local resultPayload = {} -- Initialize result payload

	if not objectName or not propertyName then
		resultPayload.error = "Missing 'object_name' or 'property_name' in set_property data."
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	local target = findObjectFromPath(objectName)
	if not target then
		resultPayload.error = "Could not find object to set property on: " .. objectName
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	local fullName = target:GetFullName()
	print(string.format("Vibe Blocks MCP Plugin: Setting property '%s' on '%s'", propertyName, fullName))

	local success, err = pcall(function()
		-- <<< Debug logging remains >>>
		print("  - Debug: typeof(propertyValue):", typeof(propertyValue))
		local debugSuccess, debugEncoded = pcall(function() return HttpService:JSONEncode(propertyValue) end)
		if debugSuccess then
			print("  - Debug: propertyValue JSON:", debugEncoded)
		else
			print("  - Debug: propertyValue raw:", tostring(propertyValue))
		end

		-- <<< NEW: Attempt to decode if value is string >>>
		local valueToConvert = propertyValue
		if typeof(valueToConvert) == "string" then
			-- Only attempt decode if it looks like an array or object string
			if string.sub(valueToConvert, 1, 1) == "[" or string.sub(valueToConvert, 1, 1) == "{" then
				local decodeSuccess, decodedTable = pcall(function()
					return HttpService:JSONDecode(valueToConvert)
				end)
				if decodeSuccess and typeof(decodedTable) == "table" then
					print("  - Info: Successfully JSONDecoded string value to table.")
					valueToConvert = decodedTable -- Use the decoded table instead
				else
					-- Log if decoding failed but maybe shouldn't have
					print("  - Warning: Value is string resembling table/array, but failed to decode or wasn't table type. Error:", tostring(decodedTable))
				end
			else
				print("  - Info: Value is string, but doesn't start with [ or {. Proceeding with raw string.")
			end
		end
		-- <<< END NEW >>>

		-- Convert the incoming value using the helper
		local robloxValue, convertError = convertToRobloxType(propertyName, valueToConvert)
		if convertError then
			-- Raise an error if conversion fails
			error("Value conversion failed: " .. convertError)
		end

		-- Assign the converted Roblox value
		target[propertyName] = robloxValue
		print(string.format("  - Successfully set '%s' to value of type %s", propertyName, typeof(robloxValue)))
	end)

	if success then
		resultPayload.success = true
		print("Vibe Blocks MCP Plugin: Finished setting property successfully.")
	else
		resultPayload.error = "Failed to set property: " .. tostring(err)
		print("  - Error setting property: " .. tostring(err))
	end

	-- Send final result
	if requestId then sendResultToServer(requestId, resultPayload) end
end

local function handleMoveInstance(data)
	local objectName = data.object_name
	local positionTable = data.position
    local requestId = data.request_id -- Extract request ID

	local resultPayload = {} -- Initialize result payload

	if not objectName or not positionTable or type(positionTable) ~= "table" then
		resultPayload.error = "Missing/invalid 'object_name' or 'position' in move_instance data."
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	if type(positionTable.x) ~= "number" or type(positionTable.y) ~= "number" or type(positionTable.z) ~= "number" then
		resultPayload.error = "Invalid 'position' table format (expected {x=num, y=num, z=num})."
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	local target = findObjectFromPath(objectName)
	if not target then
		resultPayload.error = "Could not find object to move: " .. objectName
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	local newPosition = Vector3.new(positionTable.x, positionTable.y, positionTable.z)
	local fullName = target:GetFullName()
	print(string.format("Vibe Blocks MCP Plugin: Moving '%s' to %s", fullName, tostring(newPosition)))

	local success, err = pcall(function()
		if target:IsA("Model") and target.PrimaryPart then
			local currentCFrame = target:GetPrimaryPartCFrame()
			target:SetPrimaryPartCFrame(CFrame.new(newPosition) * (currentCFrame - currentCFrame.Position))
		elseif target:IsA("BasePart") then
			target.Position = newPosition
		else
			error("Target is not a Model with PrimaryPart or a BasePart.")
		end
	end)

	if success then
		resultPayload.success = true
		print("Vibe Blocks MCP Plugin: Successfully moved " .. fullName)
	else
		resultPayload.error = "Failed to move object: " .. tostring(err)
		print("Vibe Blocks MCP Plugin: Error moving " .. fullName .. ": " .. tostring(err))
	end

	-- Send final result
	if requestId then sendResultToServer(requestId, resultPayload) end
end

local function handleCloneInstance(data)
	local objectName = data.object_name
	local newName = data.new_name -- Optional
	local parentName = data.parent_name -- Optional
    local requestId = data.request_id -- Extract request ID

	local resultPayload = {} -- Initialize result payload

	if not objectName then
		resultPayload.error = "Missing 'object_name' in clone_instance data."
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	local original = findObjectFromPath(objectName)
	if not original then
		resultPayload.error = "Could not find original object to clone: " .. objectName
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	local originalFullName = original:GetFullName()
	print("Vibe Blocks MCP Plugin: Cloning " .. originalFullName)

	local cloneSuccess, clone = pcall(function()
		return original:Clone()
	end)

	if not cloneSuccess then
		resultPayload.error = "Failed to clone object: " .. tostring(clone) -- clone is error message here
		print("Vibe Blocks MCP Plugin: Error cloning " .. originalFullName .. ": " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end
	
	print("  - Clone successful.")

	-- Handle parenting
	local parentObject = original.Parent -- Default
	local parentError = nil
	if parentName then
		local specifiedParent = findObjectFromPath(parentName)
		if specifiedParent then
			parentObject = specifiedParent
		else
			parentError = "Specified parent not found, using original parent."
			print("  - Warning: " .. parentError)
		end
	end
	
	local setParentSuccess, setParentErr = pcall(function() clone.Parent = parentObject end)
	if not setParentSuccess then
		resultPayload.error = "Failed to set parent on clone: " .. tostring(setParentErr)
		print("Vibe Blocks MCP Plugin: " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		pcall(function() clone:Destroy() end) -- Clean up clone
		return
	end
	print("  - Parent set to: " .. (parentObject and parentObject:GetFullName() or "nil"))

	-- Handle naming
	if newName then
		local setNameSuccess, setNameErr = pcall(function() clone.Name = newName end)
		if not setNameSuccess then
			resultPayload.error = "Failed to set name on clone: " .. tostring(setNameErr)
			print("Vibe Blocks MCP Plugin: " .. resultPayload.error)
			-- Don't destroy the clone here, parent was set successfully
		else
			print("  - Name set to: " .. newName)
		end
	else
		print("  - Using default clone name: " .. clone.Name)
	end
	
	-- If we reached here without a major error, report success
	if not resultPayload.error then
		resultPayload.success = true
		resultPayload.clone_name = clone.Name
		resultPayload.clone_path = clone:GetFullName()
		if parentError then resultPayload.parent_error = parentError end -- Include the parent warning
		print("Vibe Blocks MCP Plugin: Finished cloning. New instance at " .. resultPayload.clone_path)
	end
	
	-- Send final result (success or naming error)
	if requestId then sendResultToServer(requestId, resultPayload) end
end

local function handleCreateScript(data)
	local scriptName = data.script_name
	local scriptCode = data.script_code
	local scriptType = data.script_type or "Script" -- Default to Script
	local parentName = data.parent_name or "Workspace" -- Default to Workspace
    local requestId = data.request_id -- Extract request ID

	local resultPayload = {} -- Initialize result payload

	if not scriptName or not scriptCode then
		resultPayload.error = "Missing 'script_name' or 'script_code' in create_script data."
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	if scriptType ~= "Script" and scriptType ~= "LocalScript" then
		resultPayload.error = "Invalid 'script_type': " .. scriptType .. ". Must be 'Script' or 'LocalScript'."
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	local parentObject = findObjectFromPath(parentName)
	if not parentObject then
		resultPayload.error = "Could not find parent object for create_script: " .. parentName
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	print(string.format("Vibe Blocks MCP Plugin: Creating %s named '%s' under '%s'", scriptType, scriptName, parentObject:GetFullName()))

	local success, newScriptOrError = pcall(function()
		local newScript = Instance.new(scriptType)
		newScript.Name = scriptName
		newScript.Source = scriptCode
		newScript.Parent = parentObject -- Parent last after setting properties
		return newScript
	end)

	if success then
		local newScript = newScriptOrError
		resultPayload.success = true
		resultPayload.name = newScript.Name
		resultPayload.path = newScript:GetFullName()
		print("Vibe Blocks MCP Plugin: Successfully created script " .. resultPayload.path)
	else
		resultPayload.error = string.format("Failed creating %s '%s': %s", scriptType, scriptName, tostring(newScriptOrError))
		print("Vibe Blocks MCP Plugin: " .. resultPayload.error)
	end

	-- Send final result
	if requestId then sendResultToServer(requestId, resultPayload) end
end

local function handleSpawnNpc(data)
	local modelAssetId = data.model_asset_id
	local templateModelName = data.template_model_name
	local positionTable = data.position -- Optional, will be validated later
	local parentName = data.parent_name or "Workspace"
	local newName = data.new_name -- Optional
    local requestId = data.request_id -- Extract request ID

	local resultPayload = {} -- Initialize result payload

	if not modelAssetId and not templateModelName then
		resultPayload.error = "Missing 'model_asset_id' or 'template_model_name' in spawn_npc data."
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	local parentObject = findObjectFromPath(parentName)
	if not parentObject then
		resultPayload.error = "Could not find parent object for spawn_npc: " .. parentName
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	-- Validate position table if provided
	local newPosition = nil
	if positionTable then
		if type(positionTable) ~= "table" or type(positionTable.x) ~= "number" or type(positionTable.y) ~= "number" or type(positionTable.z) ~= "number" then
			resultPayload.error = "Invalid 'position' table format (expected {x=num, y=num, z=num})."
			print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
			if requestId then sendResultToServer(requestId, resultPayload) end
			return
		else
			newPosition = Vector3.new(positionTable.x, positionTable.y, positionTable.z)
		end
	end

	local npcModel = nil
	local loadSuccess, loadResultOrError

	-- Load or Clone NPC Model
	if modelAssetId then
		print("Vibe Blocks MCP Plugin: Spawning NPC from Asset ID: " .. tostring(modelAssetId))
		loadSuccess, loadResultOrError = pcall(function()
			local insertService = game:GetService("InsertService")
			local asset = insertService:LoadAsset(modelAssetId)
			if asset:IsA('Model') and #asset:GetChildren() == 1 then return asset:GetChildren()[1] else return asset end
		end)
		if not loadSuccess then
			resultPayload.error = "Error loading asset ID " .. tostring(modelAssetId) .. ": " .. tostring(loadResultOrError)
		end
	elseif templateModelName then
		print("Vibe Blocks MCP Plugin: Spawning NPC by cloning template: " .. templateModelName)
		local template = findObjectFromPath(templateModelName)
		if not template then
			resultPayload.error = "Template model not found: " .. templateModelName
		else
			loadSuccess, loadResultOrError = pcall(function() return template:Clone() end)
			if not loadSuccess then
				resultPayload.error = "Error cloning template " .. templateModelName .. ": " .. tostring(loadResultOrError)
			end
		end
	end

	-- Check if loading/cloning failed
	if not loadSuccess or not loadResultOrError or not loadResultOrError:IsA("Instance") then
		if not resultPayload.error then resultPayload.error = "Failed to obtain a valid instance for the NPC." end
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end
	npcModel = loadResultOrError

	-- Set Name, Parent, and Position
	local setupSuccess, setupError = pcall(function()
		if newName then npcModel.Name = newName end
		npcModel.Parent = parentObject
		print("  - NPC Parent set to: " .. parentObject:GetFullName())

		-- Attempt to position
		if newPosition then
			if npcModel:IsA("Model") and npcModel.PrimaryPart then
				local currentCFrame = npcModel:GetPrimaryPartCFrame()
				npcModel:SetPrimaryPartCFrame(CFrame.new(newPosition) * (currentCFrame - currentCFrame.Position))
				print("  - Positioned using SetPrimaryPartCFrame")
			elseif npcModel:IsA("BasePart") then
				npcModel.Position = newPosition
				print("  - Positioned using Position property")
			else
				resultPayload.warning = "Could not automatically set position - NPC is not a Model with PrimaryPart or a BasePart."
				print("  - Warning: " .. resultPayload.warning)
			end
		else
			print("  - No position specified, skipping positioning.")
		end
	end)

	if not setupSuccess then
		resultPayload.error = "Error setting up NPC (Name/Parent/Position): " .. tostring(setupError)
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		pcall(function() npcModel:Destroy() end) -- Clean up the partially set up NPC
	else
		resultPayload.success = true
		resultPayload.name = npcModel.Name
		resultPayload.path = npcModel:GetFullName()
		print("Vibe Blocks MCP Plugin: Finished spawning NPC " .. resultPayload.path)
		if resultPayload.warning then -- Include position warning if it exists
			print("Vibe Blocks MCP Plugin: Spawn finished with warnings.")
		end
	end

	-- Send final result
	if requestId then sendResultToServer(requestId, resultPayload) end
end

local function handleScaleModel(data)
	local objectName = data.object_name
	local scaleFactor = data.scale_factor
    local requestId = data.request_id -- Extract request ID

	local resultPayload = {} -- Initialize result payload

	if not objectName or type(scaleFactor) ~= "number" or scaleFactor <= 0 then
		resultPayload.error = "Missing/invalid 'object_name' or 'scale_factor' in scale_model data."
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	local targetModel = findObjectFromPath(objectName)
	if not targetModel or not targetModel:IsA("Model") then
		resultPayload.error = "Could not find Model to scale: " .. objectName
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	local fullName = targetModel:GetFullName()
	print(string.format("Vibe Blocks MCP Plugin: Scaling model '%s' by factor %.2f", fullName, scaleFactor))

	local success, err = pcall(function()
		local currentSize = targetModel:GetExtentsSize()
		local targetSize = currentSize * scaleFactor
		targetModel:ScaleTo(targetSize.X)
	end)

	if success then
		resultPayload.success = true
		print("Vibe Blocks MCP Plugin: Successfully scaled " .. fullName)
	else
		resultPayload.error = "Failed to scale model: " .. tostring(err)
		print("Vibe Blocks MCP Plugin: Error scaling " .. fullName .. ": " .. tostring(err))
	end
	
	-- Send final result
	if requestId then sendResultToServer(requestId, resultPayload) end
end

local function handlePlayAnimation(data)
	local targetName = data.target_name
	local animationId = data.animation_id
    local requestId = data.request_id -- Extract request ID

	local resultPayload = {} -- Initialize result payload

	if not targetName or not animationId or type(animationId) ~= "number" then
		resultPayload.error = "Missing/invalid 'target_name' or 'animation_id' in play_animation data."
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	local target = findObjectFromPath(targetName)
	if not target then
		resultPayload.error = "Could not find target object for play_animation: " .. targetName
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	local animator = target:FindFirstChildOfClass("Humanoid") or target:FindFirstChildOfClass("AnimationController")
	if not animator then
		resultPayload.error = "Target object " .. targetName .. " does not contain a Humanoid or AnimationController."
		print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error)
		if requestId then sendResultToServer(requestId, resultPayload) end
		return
	end

	local animationAssetId = "rbxassetid://" .. tostring(animationId)
	print(string.format("Vibe Blocks MCP Plugin: Playing animation %s on %s", animationAssetId, target:GetFullName()))

	local animInstance = Instance.new("Animation")
	animInstance.Name = "MCP_TempAnimation"
	animInstance.AnimationId = animationAssetId

	local loadSuccess, trackOrError = pcall(function() return animator:LoadAnimation(animInstance) end)
	pcall(function() animInstance:Destroy() end) -- Clean up temp instance

	if not loadSuccess then
		resultPayload.error = "Error loading animation " .. animationAssetId .. ": " .. tostring(trackOrError)
		print("Vibe Blocks MCP Plugin: " .. resultPayload.error)
	else
		local animationTrack = trackOrError
		local playSuccess, playError = pcall(function() animationTrack:Play() end)

		if playSuccess then
			resultPayload.success = true
			resultPayload.message = "Animation track loaded and played."
			print("Vibe Blocks MCP Plugin: Successfully started animation track.")
		else
			resultPayload.error = "Error playing animation track: " .. tostring(playError)
			print("Vibe Blocks MCP Plugin: " .. resultPayload.error)
		end
	end

	-- Send final result
	if requestId then sendResultToServer(requestId, resultPayload) end
end

local function handleSendChat(data)
	local message = data.message
	-- local senderName = data.sender_name -- Placeholder for future use if needed

	if not message or type(message) ~= "string" then
		print("Vibe Blocks MCP Plugin: Error - Missing/invalid 'message' in send_chat data.")
		return
	end

	local textChatService = game:GetService("TextChatService")
	if not textChatService then
		print("Vibe Blocks MCP Plugin: Error - TextChatService not found.")
		return
	end

	-- Use RBXSystem channel for system messages
	local systemChannel = textChatService:FindFirstChild("RBXSystem")
	if not systemChannel or not systemChannel:IsA("TextChannel") then
		print("Vibe Blocks MCP Plugin: Error - Could not find RBXSystem TextChannel.")
		return
	end

	print("Vibe Blocks MCP Plugin: Sending system chat message: " .. message)
	local success, err = pcall(function()
		-- Use SendAsync for more general message sending
		systemChannel:SendAsync(message)
		-- Alternative: systemChannel:DisplaySystemMessage(message)
	end)

	if success then
		print("Vibe Blocks MCP Plugin: Successfully sent chat message.")
	else
		print("Vibe Blocks MCP Plugin: Error sending chat message: " .. tostring(err))
	end
end

local function handleTeleportPlayer(data)
	local playerName = data.player_name
	local destinationPlaceId = data.destination_place_id
	local teleportOptions = data.teleport_options -- Optional table
	local customLoadingScriptName = data.custom_loading_script -- Optional string name

	if not playerName or not destinationPlaceId or type(destinationPlaceId) ~= "number" then
		print("Vibe Blocks MCP Plugin: Error - Missing/invalid 'player_name' or 'destination_place_id' in teleport_player data.")
		return
	end

	local teleportService = game:GetService("TeleportService")
	local playersService = game:GetService("Players")
	local replicatedFirst = game:GetService("ReplicatedFirst")

	if not teleportService then
		print("Vibe Blocks MCP Plugin: Error - TeleportService not found.")
		return
	end
	
	-- Player finding only works in a running game instance
	local playerToTeleport = playersService:FindFirstChild(playerName)
	if not playerToTeleport then
		print("Vibe Blocks MCP Plugin: Warning - Player \"" .. playerName .. "\" not found (or command run outside active game).")
		-- Don't return error, as this might be run in edit mode intentionally
		return 
	end

	-- Construct TeleportOptions if provided
	local finalTeleportOptions
	if teleportOptions and type(teleportOptions) == "table" then
		local success, optionsInstance = pcall(function() return Instance.new("TeleportOptions") end)
		if success and optionsInstance then
			finalTeleportOptions = optionsInstance
			for key, value in pairs(teleportOptions) do
				local setSuccess, setError = pcall(function()
					-- Basic assignment, might need type checks for complex option values
					finalTeleportOptions[key] = value
				end)
				if not setSuccess then
					print("  - Warning: Failed to set TeleportOption '" .. key .. "': " .. tostring(setError))
				end
			end
		else
			print("Vibe Blocks MCP Plugin: Warning - Could not create TeleportOptions instance.")
		end
	end

	-- Find custom loading screen if provided
	local loadingScreenGui
	if customLoadingScriptName and type(customLoadingScriptName) == "string" then
		loadingScreenGui = replicatedFirst:FindFirstChild(customLoadingScriptName)
		if not loadingScreenGui or not loadingScreenGui:IsA("LocalScript") then
			print("Vibe Blocks MCP Plugin: Warning - Custom loading script '" .. customLoadingScriptName .. "' not found or not a LocalScript in ReplicatedFirst.")
			loadingScreenGui = nil -- Reset if not valid
		end
	end

	print(string.format("Vibe Blocks MCP Plugin: Attempting to teleport player %s to place %d", playerName, destinationPlaceId))

	local success, err = pcall(function()
		teleportService:TeleportAsync(destinationPlaceId, {playerToTeleport}, finalTeleportOptions, loadingScreenGui)
	end)

	if success then
		print("Vibe Blocks MCP Plugin: Teleport initiated successfully for " .. playerName)
	else
		print("Vibe Blocks MCP Plugin: Error initiating teleport for " .. playerName .. ": " .. tostring(err))
	end
end

local function handleSetPlayerPosition(data)
	local playerName = data.player_name
	local positionTable = data.position

	if not playerName or not positionTable or type(positionTable) ~= "table" then
		print("Vibe Blocks MCP Plugin: Error - Missing/invalid 'player_name' or 'position' in set_player_position data.")
		return
	end

	-- Validate position table
	if type(positionTable.x) ~= "number" or type(positionTable.y) ~= "number" or type(positionTable.z) ~= "number" then
		print("Vibe Blocks MCP Plugin: Error - Invalid 'position' table format (expected {x=num, y=num, z=num}).")
		return
	end

	-- Find the player's character in the Workspace
	local character = workspace:FindFirstChild(playerName)
	if not character or not character:IsA("Model") then
		print("Vibe Blocks MCP Plugin: Error - Could not find character Model in Workspace named: " .. playerName)
		-- It might also be in game.Players[playerName].Character, but workspace is usually safer for positioning
		return
	end

	-- Find the HumanoidRootPart
	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp or not hrp:IsA("BasePart") then
		print("Vibe Blocks MCP Plugin: Error - Could not find HumanoidRootPart in character: " .. playerName)
		return
	end

	local newPosition = Vector3.new(positionTable.x, positionTable.y, positionTable.z)
	print(string.format("Vibe Blocks MCP Plugin: Setting position of %s's HumanoidRootPart to %s", playerName, tostring(newPosition)))

	local success, err = pcall(function()
		-- Set CFrame directly, preserves orientation if possible
		hrp.CFrame = CFrame.new(newPosition)
		-- Alternative if anchoring issues: hrp.Position = newPosition
	end)

	if success then
		print("Vibe Blocks MCP Plugin: Successfully set player position.")
	else
		print("Vibe Blocks MCP Plugin: Error setting player position: " .. tostring(err))
	end
end

-- --- NEW: Find Instances Handler --- --
local function handleFindInstances(data)
    local classNameFilter = data.class_name -- Can be nil
    local nameContainsFilter = data.name_contains -- Can be nil
    local searchRootName = data.search_root or "Workspace"
    local requestId = data.request_id

    local resultPayload = { instances = {} } -- Initialize with empty list
    local errorResult = nil

    local root = findObjectFromPath(searchRootName)

    if not root then
        errorResult = { error = "Search root not found: " .. searchRootName }
    else
        print(string.format("Vibe Blocks MCP Plugin: Finding instances under %s (%s) for request ID %s", root.Name, root.ClassName, requestId or "N/A"))
        print(string.format("  - Filters: ClassName='%s', NameContains='%s'", classNameFilter or "any", nameContainsFilter or "any"))
        
        local nameFilterLower = nameContainsFilter and nameContainsFilter:lower() or nil

        local findSuccess, findError = pcall(function()
            for _, descendant in ipairs(root:GetDescendants()) do
                -- ClassName check
                local classMatch = (classNameFilter == nil) or (descendant.ClassName == classNameFilter)

                -- Name check (case-insensitive)
                local nameMatch = (nameFilterLower == nil) or (string.find(descendant.Name:lower(), nameFilterLower) ~= nil)

                if classMatch and nameMatch then
                    -- No need to serialize here, just basic info
                    table.insert(resultPayload.instances, {
                        name = descendant.Name,
                        className = descendant.ClassName,
                        path = descendant:GetFullName()
                    })
                end
            end
        end)

        if not findSuccess then
            errorResult = { error = "Error during search: " .. tostring(findError) }
            print("  - Error during search: " .. tostring(findError))
        else
             print(string.format("  - Found %d matching instances.", #resultPayload.instances))
        end
    end

    -- Send results or error back
    if requestId then
        sendResultToServer(requestId, errorResult or resultPayload)
    else
        print("Vibe Blocks MCP Plugin: Warning - No request_id found in find_instances data. Cannot report result back.")
    end
end
-- --- END: Find Instances Handler --- --

-- --- NEW: List Children Handler --- --
local function handleListChildren(data)
    local parentName = data.parent_name or "Workspace" -- Use provided name or default
    local requestId = data.request_id -- Get the request ID sent by the server

    local parentObject = findObjectFromPath(parentName)
    local results = {}
    local errorResult = nil

    if not parentObject then
        local errMsg = "Error - Could not find parent object: " .. parentName
        print("Vibe Blocks MCP Plugin: " .. errMsg)
        errorResult = { error = errMsg }
    else
        print(string.format("Vibe Blocks MCP Plugin: Listing children of %s (%s) for request ID %s", parentObject.Name, parentObject.ClassName, requestId or "N/A"))
        local success, childrenOrError = pcall(function()
            return parentObject:GetChildren()
        end)

        if success then
            local children = childrenOrError
            for i, child in ipairs(children) do
                table.insert(results, {
                    name = child.Name,
                    className = child.ClassName,
                    path = child:GetFullName()
                })
                print(string.format("  - Found: %s (%s) Path: %s", child.Name, child.ClassName, child:GetFullName()))
            end
            print("Vibe Blocks MCP Plugin: Finished listing children for " .. parentName)
        else
            local errMsg = "Error getting children for " .. parentName .. ": " .. tostring(childrenOrError)
            print("Vibe Blocks MCP Plugin: " .. errMsg)
            errorResult = { error = errMsg }
        end
    end

    -- Send the result (or error) back to the server
    if requestId then
        sendResultToServer(requestId, errorResult or results) -- Use the previously added helper
    else
        print("Vibe Blocks MCP Plugin: Warning - No request_id found in list_children data. Cannot report result back.")
    end
end
-- --- END: List Children Handler --- --

-- --- Helper: Serialize Roblox Value to JSON-compatible Table/Primitive --- --
-- NOTE: Defined globally before handlers that might use it.
local function serializeValue(value)
	local valueType = typeof(value)

	if valueType == 'Vector3' then
		return {type='Vector3', x=value.X, y=value.Y, z=value.Z}
	elseif valueType == 'CFrame' then
		-- Simplified CFrame representation (Position + LookVector for basic orientation)
		-- Or return full components if needed
		local pos = value.Position
		local look = value.LookVector
		return {type='CFrame', position={x=pos.X, y=pos.Y, z=pos.Z}, lookVector={x=look.X, y=look.Y, z=look.Z}} 
	elseif valueType == 'Color3' then
		 return {type='Color3', r=value.R, g=value.G, b=value.B}
	elseif valueType == 'BrickColor' then
		return {type='BrickColor', name=value.Name, number=value.Number}
	elseif valueType == 'boolean' or valueType == 'number' or valueType == 'string' or valueType == 'nil' then
		return value -- These types are directly JSON compatible
	elseif string.find(valueType, "Enum.") then -- Check if it's an EnumItem
		return {type='EnumItem', fullValue=tostring(value), name=value.Name, value=value.Value}
	elseif valueType == 'Instance' then
		 return {type='Instance', name=value.Name, className=value.ClassName, path=value:GetFullName()}
	elseif valueType == 'RBXScriptConnection' then
		return {type='Connection', status=value.Connected and 'Connected' or 'Disconnected'} -- Basic info
	-- Add more types as needed: Vector2, UDim2, Rect, Ray, Region3, PhysicalProperties, etc.
	else
		-- Fallback: represent unknown types as a string
		return {type=valueType, value=tostring(value)}
	end
end
-- --- END Helper: Serialize Roblox Value --- --

-- --- NEW: Get Property Handler --- --
local function handleGetProperty(data)
    local objectName = data.object_name
    local propertyName = data.property_name
    local requestId = data.request_id

    local resultPayload = {}

    if not objectName or not propertyName then
        resultPayload.error = "Missing object_name or property_name in get_property data."
    else
        local target = findObjectFromPath(objectName)
        if not target then
            resultPayload.error = "Object not found: " .. objectName
        else
            print(string.format("Vibe Blocks MCP Plugin: Getting property '%s' on %s (%s) for request ID %s", propertyName, target.Name, target.ClassName, requestId or "N/A"))
            local success, value = pcall(function() 
                return target[propertyName] 
            end)

            if success then
                print(string.format("  - Raw value type: %s", typeof(value)))
                -- Serialize the value for JSON transport
                local serializeSuccess, serializedResult = pcall(serializeValue, value)
                if serializeSuccess then
                    resultPayload.value = serializedResult
                    print("  - Serialized value sent.")
                else
                    resultPayload.error = "Failed to serialize property value: " .. tostring(serializedResult) -- serializedResult is error message here
                    print("  - Error serializing: " .. tostring(serializedResult))
                end
            else
                resultPayload.error = "Error accessing property: " .. tostring(value) -- value is error message here
                print("  - Error accessing property: " .. tostring(value))
            end
        end
    end

    -- Send the result/error back to the server
    if requestId then
        sendResultToServer(requestId, resultPayload)
    else
        print("Vibe Blocks MCP Plugin: Warning - No request_id found in get_property data. Cannot report result back.")
    end
end
-- --- END: Get Property Handler --- --

-- --- NEW: Edit Script Handler --- --
local function handleEditScript(data)
    local scriptPath = data.script_path
    local newScriptCode = data.script_code
    local requestId = data.request_id

    local resultPayload = {}

    if not scriptPath or not newScriptCode then
        resultPayload.error = "Missing script_path or script_code in edit_script data."
    else
        local targetScript = findObjectFromPath(scriptPath)
        if not targetScript then
            resultPayload.error = "Script not found at path: " .. scriptPath
        elseif not (targetScript:IsA("Script") or targetScript:IsA("LocalScript")) then
             resultPayload.error = "Target object is not a Script or LocalScript: " .. targetScript.ClassName
        else
            print(string.format("Vibe Blocks MCP Plugin: Editing script '%s' for request ID %s", targetScript:GetFullName(), requestId or "N/A"))
            local success, err = pcall(function() 
                targetScript.Source = newScriptCode
            end)

            if success then
                resultPayload.success = true
                print("  - Script source updated successfully.")
            else
                resultPayload.error = "Error setting script source: " .. tostring(err)
                print("  - Error setting script source: " .. tostring(err))
            end
        end
    end

    -- Send the result/error back to the server
    if requestId then
        sendResultToServer(requestId, resultPayload)
    else
        print("Vibe Blocks MCP Plugin: Warning - No request_id found in edit_script data. Cannot report result back.")
    end
end
-- --- END: Edit Script Handler --- --

-- --- NEW: Delete Script Handler --- --
local function handleDeleteScript(data)
    local scriptPath = data.script_path
    local requestId = data.request_id

    local resultPayload = {}

    if not scriptPath then
        resultPayload.error = "Missing script_path in delete_script data."
    else
        local targetScript = findObjectFromPath(scriptPath)
        if not targetScript then
            resultPayload.error = "Script not found at path: " .. scriptPath
        elseif not (targetScript:IsA("Script") or targetScript:IsA("LocalScript")) then
             resultPayload.error = "Target object is not a Script or LocalScript: " .. targetScript.ClassName
        else
            local fullName = targetScript:GetFullName()
            print(string.format("Vibe Blocks MCP Plugin: Deleting script '%s' for request ID %s", fullName, requestId or "N/A"))
            local success, err = pcall(function() 
                targetScript:Destroy()
            end)

            if success then
                resultPayload.success = true
                print("  - Script deleted successfully.")
            else
                resultPayload.error = "Error deleting script: " .. tostring(err)
                print("  - Error deleting script: " .. tostring(err))
            end
        end
    end

    -- Send the result/error back to the server
    if requestId then
        sendResultToServer(requestId, resultPayload)
    else
        print("Vibe Blocks MCP Plugin: Warning - No request_id found in delete_script data. Cannot report result back.")
    end
end
-- --- END: Delete Script Handler --- --

-- --- NEW: Set Primary Part Handler --- --
local function handleSetPrimaryPart(data)
    local modelPath = data.model_path
    local partPath = data.part_path
    local requestId = data.request_id

    local resultPayload = {}

    if not modelPath or not partPath then
        resultPayload.error = "Missing model_path or part_path in set_primary_part data."
    else
        local model = findObjectFromPath(modelPath)
        local part = findObjectFromPath(partPath)

        if not model then
            resultPayload.error = "Model not found at path: " .. modelPath
        elseif not model:IsA("Model") then
            resultPayload.error = "Object at model_path is not a Model: " .. model.ClassName
        elseif not part then
            resultPayload.error = "Part not found at path: " .. partPath
        elseif not part:IsA("BasePart") then
            resultPayload.error = "Object at part_path is not a BasePart: " .. part.ClassName
        elseif not part:IsDescendantOf(model) then
            resultPayload.error = "Part at " .. partPath .. " is not a descendant of Model at " .. modelPath
        else
            print(string.format("Vibe Blocks MCP Plugin: Setting PrimaryPart of '%s' to '%s' for request ID %s", model:GetFullName(), part:GetFullName(), requestId or "N/A"))
            local success, err = pcall(function() 
                model.PrimaryPart = part
            end)

            if success then
                resultPayload.success = true
                print("  - PrimaryPart set successfully.")
            else
                resultPayload.error = "Error setting PrimaryPart property: " .. tostring(err)
                print("  - Error setting PrimaryPart: " .. tostring(err))
            end
        end
    end

    -- Send the result/error back to the server
    if requestId then
        sendResultToServer(requestId, resultPayload)
    else
        print("Vibe Blocks MCP Plugin: Warning - No request_id found in set_primary_part data. Cannot report result back.")
    end
end
-- --- END: Set Primary Part Handler --- --

-- --- NEW: Execute Script in Studio Handler --- --
local function handleExecuteScriptInStudio(data)
    local scriptCode = data.script_code
    local requestId = data.request_id

    local resultPayload = {
        output_lines = {},
        return_values = nil, -- Explicitly nil initially
        error_message = nil
    }

    if not scriptCode or type(scriptCode) ~= "string" then
        resultPayload.error_message = "Missing or invalid 'script_code' (must be a string)."
    else
        print(string.format("Vibe Blocks MCP Plugin: Executing script in Studio for request ID %s (Code: %s...)", requestId or "N/A", string.sub(scriptCode, 1, 50)))
        
        -- <<< NEW: Prepend standard globals to script code >>>
        local scriptToExecute = string.format("local game = game\nlocal Workspace = game:GetService(\"Workspace\")\n%s", scriptCode)
        print("  - Info: Prepended locals game/Workspace to script.")

        -- 1. Compile the MODIFIED script string
        local compiledFunc, compileError = loadstring(scriptToExecute)
        
        if not compiledFunc then
            resultPayload.error_message = "Compile Error: " .. tostring(compileError)
            print("  - Error during script compilation:", compileError)
        else
            -- 2. Prepare environment for execution (capture print)
            local capturedOutput = {}
            -- local originalPrint = print -- No longer need to save/restore global print
            
            -- <<< RE-INTRODUCE: Explicitly populate tempEnv with globals AND custom print >>>
            local tempEnv = {}
            -- Copy essential globals
            tempEnv.game = game
            tempEnv.workspace = workspace
            tempEnv.script = script 
            tempEnv.Instance = Instance
            tempEnv.Vector3 = Vector3
            tempEnv.Color3 = Color3
            tempEnv.BrickColor = BrickColor
            tempEnv.CFrame = CFrame
            tempEnv.Enum = Enum
            tempEnv.ipairs = ipairs
            tempEnv.pairs = pairs
            tempEnv.tostring = tostring
            tempEnv.tonumber = tonumber
            tempEnv.pcall = pcall -- Allow script to use pcall itself
            tempEnv.type = type
            tempEnv.select = select
            tempEnv.assert = assert
            tempEnv.warn = warn -- Capture warn?
            tempEnv.error = error -- Capture error?
            tempEnv.math = math
            tempEnv.table = table
            tempEnv.string = string
            tempEnv.os = os
            tempEnv.debug = debug
            
            -- Add our custom print DIRECTLY to the environment
            tempEnv.print = function(...)
                local args = {...}
                local lineParts = {}
                for i = 1, #args do
                    table.insert(lineParts, tostring(args[i]))
                end
                local line = table.concat(lineParts, "\t")
                table.insert(capturedOutput, line)
                -- Optional: print("  [Captured Print]:", line)
            end

            -- Set the environment for the function
            setfenv(compiledFunc, tempEnv)
            
            -- 3. Execute using pcall (should use print from tempEnv now)
            local executionSuccess, results = pcall(compiledFunc)

            -- 5. Process results
            resultPayload.output_lines = capturedOutput
            
            if not executionSuccess then
                resultPayload.error_message = "Runtime Error: " .. tostring(results) -- results is the error message here
                print("  - Error during script execution:", tostring(results))
            else 
                -- Execution succeeded, results contains return values
                print("  - Script execution successful.")
                local returnVals = {select("#", results), results} -- Get all return values
                if select("#", results) > 0 then
                    local serializedReturns = {}
                    for i = 1, select("#", results) do
                        local success, serialized = pcall(serializeValue, select(i, results))
                        if success then
                           table.insert(serializedReturns, serialized)
                        else
                           table.insert(serializedReturns, {type="SerializationError", error=tostring(serialized)})
                        end
                    end
                    resultPayload.return_values = serializedReturns
                    print("  - Captured", #serializedReturns, "return value(s).")
                else
                   print("  - Script returned no values.")
                end
            end
        end
    end

    -- Send the result/error back to the server
    if requestId then
        sendResultToServer(requestId, resultPayload)
    else
        print("Vibe Blocks MCP Plugin: Warning - No request_id found in execute_script_in_studio data. Cannot report result back.")
    end
end
-- --- END: Execute Script in Studio Handler --- --

-- --- NEW: Modify Children Handler --- --
local function handleModifyChildren(data)
    local parentPath = data.parent_path
    local propertyName = data.property_name
    local propertyValue = data.property_value -- This is already parsed Python object -> Lua table/primitive
    local nameFilter = data.child_name_filter
    local classFilter = data.child_class_filter
    local requestId = data.request_id

    local resultPayload = {
        affected_count = 0,
        errors = {},
        error_message = nil -- For fatal errors
    }

    -- 1. Find Parent
    local parentObject = findObjectFromPath(parentPath)
    if not parentObject then
        resultPayload.error_message = "Parent object not found at path: " .. parentPath
        print("Vibe Blocks MCP Plugin: Error - " .. resultPayload.error_message)
        if requestId then sendResultToServer(requestId, resultPayload) end
        return
    end

    print(string.format("Vibe Blocks MCP Plugin: Modifying children under '%s' for request ID %s", parentObject:GetFullName(), requestId or "N/A"))
    print(string.format("  - Filters: Name='%s', Class='%s'", nameFilter or "Any", classFilter or "Any"))
    print(string.format("  - Action: Set '%s'", propertyName))

    -- 2. Iterate and Modify Children
    local children = parentObject:GetChildren()
    for i, child in ipairs(children) do
        local childMatches = true

        -- Apply filters
        if nameFilter and child.Name ~= nameFilter then
            childMatches = false
        end
        if classFilter and child.ClassName ~= classFilter then
            childMatches = false
        end

        -- If filters pass, attempt modification
        if childMatches then
            local childFullName = child:GetFullName()
            print(string.format("  - Processing child: %s", childFullName))

            local success, err = pcall(function()
                 -- Reuse value processing logic from handleSetProperty
                local valueToConvert = propertyValue 
                if typeof(valueToConvert) == "string" then
                    if string.sub(valueToConvert, 1, 1) == "[" or string.sub(valueToConvert, 1, 1) == "{" then
                        local decodeSuccess, decodedTable = pcall(function() return HttpService:JSONDecode(valueToConvert) end)
                        if decodeSuccess and typeof(decodedTable) == "table" then
                            print("    - Info: Decoded string value for child.")
                            valueToConvert = decodedTable
                        else
                            print("    - Warning: String value for child looked like table/array but failed to decode.")
                        end
                    end
                end
                
                -- Convert value
                local robloxValue, convertError = convertToRobloxType(propertyName, valueToConvert)
                if convertError then
                    error("Value conversion failed: " .. convertError)
                end
                
                -- Assign value
                child[propertyName] = robloxValue
                print(string.format("    - Successfully set '%s' to type %s", propertyName, typeof(robloxValue)))
            end)

            if success then
                resultPayload.affected_count = resultPayload.affected_count + 1
            else
                local errorMsg = string.format("Failed on '%s': %s", childFullName, tostring(err))
                print("    - ERROR: " .. errorMsg)
                table.insert(resultPayload.errors, errorMsg)
            end
        end
    end

    print(string.format("Vibe Blocks MCP Plugin: Finished modifying children. Affected: %d, Errors: %d", resultPayload.affected_count, #resultPayload.errors))

    -- 3. Send Result
    if requestId then
        sendResultToServer(requestId, resultPayload)
    else
        print("Vibe Blocks MCP Plugin: Warning - No request_id found in modify_children data. Cannot report result back.")
    end
end
-- --- END: Modify Children Handler --- --

local function executeCommand(commandData)
	local action = commandData.action
	print("Vibe Blocks MCP Plugin: Executing action - " .. (action or "nil"))

	if action == "get_property_studio" then
		local objPath = commandData.object_path
		local propName = commandData.property_name

		if not objPath or not propName then
			print("Vibe Blocks MCP Plugin: Invalid get_property_studio command - missing object_path or property_name")
			return
		end

		local success, result = pcall(function()
			-- Attempt to find the object using the path
			-- NOTE: This simple FindFirstChild approach won't work for nested paths like game.Workspace.Part
			-- We need a helper to traverse the path.
			-- Let's add a simple path finder
			local target = findObjectFromPath(objPath)

			if target then
				local value = target[propName]
				print(string.format("Vibe Blocks MCP Plugin: Property [%s.%s] = %s", objPath, propName, tostring(value)))
			else
				print(string.format("Vibe Blocks MCP Plugin: Target object not found for path: %s", objPath))
			end
		end)

		if not success then
			print(string.format("Vibe Blocks MCP Plugin: Error executing get_property_studio [%s.%s]: %s", objPath, propName, tostring(result)))
		end

	elseif action == "print_message" then -- Add a simple test action
		local message = commandData.message or "No message provided."
		print("Vibe Blocks MCP Plugin: Message from server -> " .. message)

	elseif action == "set_environment" then
		handleSetEnvironment(commandData.data) -- Pass the 'data' part of the command

	elseif action == "create_instance" then
		handleCreateInstance(commandData.data) -- Pass the 'data' part

	elseif action == "delete_instance" then
		handleDeleteInstance(commandData.data)

	elseif action == "set_property" then
		handleSetProperty(commandData.data)

	elseif action == "move_instance" then
		handleMoveInstance(commandData.data)

	elseif action == "clone_instance" then
		handleCloneInstance(commandData.data)

	elseif action == "create_script" then
		handleCreateScript(commandData.data)

	elseif action == "spawn_npc" then
		handleSpawnNpc(commandData.data)

	elseif action == "scale_model" then
		handleScaleModel(commandData.data)

	elseif action == "play_animation" then
		handlePlayAnimation(commandData.data)

	elseif action == "send_chat" then
		handleSendChat(commandData.data)

	elseif action == "teleport_player" then
		handleTeleportPlayer(commandData.data)

	elseif action == "set_player_position" then
		handleSetPlayerPosition(commandData.data)

	elseif action == "list_children" then
		handleListChildren(commandData.data)

	elseif action == "get_property" then
		handleGetProperty(commandData.data)

	elseif action == "find_instances" then
		handleFindInstances(commandData.data)

	elseif action == "edit_script" then
		handleEditScript(commandData.data)

	elseif action == "delete_script" then
		handleDeleteScript(commandData.data)

	elseif action == "set_primary_part" then
		handleSetPrimaryPart(commandData.data)

	elseif action == "execute_script_in_studio" then
		handleExecuteScriptInStudio(commandData.data)

	-- <<< ADD: New action routing >>>
	elseif action == "modify_children" then
		handleModifyChildren(commandData.data)

	else
		print("Vibe Blocks MCP Plugin: Unknown command action received: " .. tostring(action))
	end
end

local COMMAND_HANDLERS = {
	set_environment = handleSetEnvironment,
	create_instance = handleCreateInstance,
	delete_instance = handleDeleteInstance,
	set_property = handleSetProperty,
	get_property = handleGetProperty,
	list_children = handleListChildren,
	move_instance = handleMoveInstance,
	clone_instance = handleCloneInstance,
	create_script = handleCreateScript,
	spawn_npc = handleSpawnNpc,
	scale_model = handleScaleModel,
	play_animation = handlePlayAnimation,
	send_chat = handleSendChat,
	teleport_player = handleTeleportPlayer,
	set_player_position = handleSetPlayerPosition,
	find_instances = handleFindInstances,
	edit_script = handleEditScript,
	delete_script = handleDeleteScript,
	set_primary_part = handleSetPrimaryPart,
	execute_script_in_studio = handleExecuteScriptInStudio,
	modify_children = handleModifyChildren, -- <<< REGISTER: New handler >>>
}

local function pollServer()
	-- Check if running in Studio environment before proceeding
	if not RunService:IsStudio() then
		-- print("Vibe Blocks MCP Companion Plugin: Not in Studio environment. Polling disabled.") -- Reduce noise
		return
	end

	local currentTime = os.clock()
	if currentTime - lastPollTime < POLLING_INTERVAL then
		return -- Don't poll too frequently
	end
	lastPollTime = currentTime

	local success, responseBody = pcall(function()
		-- Attempt HTTP GET request
        -- IMPORTANT: This will fail in Play Solo client, handled by pcall
        return HttpService:GetAsync(SERVER_URL)
	end)

    if not success then
        -- Ignore specific HTTP errors expected when running in Play Solo client
        local errStr = tostring(responseBody) -- responseBody contains error object/string
        if string.find(errStr, "Http requests can only be executed by game server") then
            -- Silently ignore, this is expected in Play Solo client
            -- print("Vibe Blocks MCP Plugin: Http GetAsync skipped (Play Solo Client context).")
        else
            -- Log other unexpected errors
            print("Vibe Blocks MCP Plugin: Error polling server - " .. errStr)
        end
        return -- Stop processing if the GET failed for any reason
    end

	-- Process successful response
	local decodedSuccess, commandData = pcall(function()
		return HttpService:JSONDecode(responseBody)
	end)

	if not decodedSuccess then
		print("Vibe Blocks MCP Plugin: Error decoding JSON response from server - " .. tostring(commandData)) -- commandData is error msg
		return
	end

	-- Check if the decoded data is a table and not empty
	if type(commandData) == "table" and next(commandData) ~= nil then
			-- Use the structure expected from the Python server:
            -- {"action": "action_name", "data": { ... }, "request_id": "..."}
            local action = commandData.action
            local data = commandData.data
            local requestId = commandData.request_id -- Extract request_id

            print("Vibe Blocks MCP Plugin: Received command from server.")
            print("  - Action: " .. tostring(action))
            print("  - Request ID: " .. tostring(requestId)) -- Log the ID
            -- print("  - Data: " .. HttpService:JSONEncode(data)) -- Optional: Log data if needed, can be verbose

            if action and COMMAND_HANDLERS[action] then
                print("Vibe Blocks MCP Plugin: Executing action - " .. action)
                
                -- Prepare data for the handler, ensuring request_id is included
                local handlerData = data
                if type(handlerData) ~= "table" then
                     -- If original data wasn't a table, create one
                    handlerData = {} 
                end
                -- Add/overwrite request_id in the data passed to the handler
                handlerData.request_id = requestId
                
                -- Execute the handler
                local handlerSuccess, handlerError = pcall(COMMAND_HANDLERS[action], handlerData)
                
                if not handlerSuccess then
                    print("Vibe Blocks MCP Plugin: Error executing action '" .. action .. "': " .. tostring(handlerError))
                    -- If the handler failed, send an error result back if there's a request ID
                    if requestId then
                        sendResultToServer(requestId, { error = "Plugin error during action '" .. action .. "' execution: " .. tostring(handlerError) })
                    end
                else
                    -- Success! The handler itself (like list_children) is responsible for sending back results if needed.
                    print("Vibe Blocks MCP Plugin: Action '" .. action .. "' execution finished.")
                end
            else
                print("Vibe Blocks MCP Plugin: Warning - Unknown or missing action in command: " .. tostring(action))
                -- Send an error result back for unknown actions if there's a request ID
                if requestId then
                    sendResultToServer(requestId, { error = "Unknown action requested by server: " .. tostring(action) })
                end
            end
        else
            -- Empty response or non-table data, likely just no command queued
            -- print("Vibe Blocks MCP Plugin: No command received from server.") -- Reduce noise
        end

end

-- --- NEW: Log Handling Functions --- --

-- Function to send buffered logs to the Python server
local function sendLogsToServer()
	if isSendingLogs or #logsToSend == 0 then
		return -- Already sending or nothing to send
	end

	local currentTime = os.clock()
	-- Enforce send interval
	if currentTime - lastLogSendTime < SEND_INTERVAL then
		-- Optional: Could schedule a deferred send here instead of just dropping
		return
	end

	isSendingLogs = true
	lastLogSendTime = currentTime -- Update time *before* sending

	-- Take a batch (up to MAX_LOG_BATCH_SIZE)
	local batch = {}
	local count = math.min(#logsToSend, MAX_LOG_BATCH_SIZE)
	for i = 1, count do
		table.insert(batch, table.remove(logsToSend, 1)) -- Move from buffer to batch
	end

	-- Print only if actually sending (avoids client spam)
	if RunService:IsServer() then
		print("Vibe Blocks MCP Plugin: Sending", #batch, "logs to server...")
	end

	local success, response = pcall(function()
		local jsonData = HttpService:JSONEncode(batch)
		return HttpService:PostAsync(SERVER_LOG_ENDPOINT, jsonData, Enum.HttpContentType.ApplicationJson)
	end)

	if success then
		-- Log successful send only on server
		-- if RunService:IsServer() then print("Log send success.") end 
	else
		local errorString = tostring(response)
		-- Check if it's the expected client-side error
		if string.find(errorString, "Http requests can only be executed by game server") then
			-- This error is expected on the client during Play mode, do nothing or minimal log
			-- print("MCP Debug: Client log send blocked as expected.")
		else
			-- Log other unexpected errors
			warn("Vibe Blocks MCP Plugin: Failed to send logs to server:", errorString)
			-- Retry logic (keep this part)
			for i = #batch, 1, -1 do
				table.insert(logsToSend, 1, batch[i])
			end
		end
	end

	isSendingLogs = false

	-- If there are still logs left, immediately try sending another batch
	-- This handles cases where logs accumulate faster than the send interval allows clearing
	if #logsToSend > 0 then
		task.defer(sendLogsToServer)
	end
end

-- Function called by LogService event
local function onMessageOut(message, messageType)
	-- Avoid logging our own log sending messages
	if string.find(message, "Vibe Blocks MCP Plugin: Sending") then
		return
	end

	local logEntry = {
		message = message,
		log_type = tostring(messageType), -- Convert Enum::MessageType to string
		timestamp = os.clock() -- Use os.clock() for high-resolution timestamp
	}
	table.insert(logsToSend, logEntry)

	-- Trigger send mechanism (non-blocking)
	-- Use task.defer to ensure it runs after the current event processing
	-- The IsServer check is inside sendLogsToServer, so it's safe to defer always
	task.defer(sendLogsToServer)
end

-- --- END: Log Handling Functions --- --

-- Only run polling loop and connect log service in Studio
if RunService:IsStudio() then
	-- TODO: Add plugin button/UI later if needed
	RunService.Heartbeat:Connect(function() pollServer() end)
	print("Vibe Blocks MCP Companion Plugin: Started polling loop.")

	-- --- NEW: Connect to Log Service --- --
	LogService.MessageOut:Connect(onMessageOut)
	print("Vibe Blocks MCP Companion Plugin: Connected to LogService for log forwarding.")
	-- --- END: Connect to Log Service --- --
else
	print("Vibe Blocks MCP Companion Plugin: Not running polling loop or log forwarding (not in Studio).")
end

-- --- NEW: List Children Handler --- --
-- <<< Function definition moved above COMMAND_HANDLERS >>>
-- --- END: List Children Handler --- -- 
```

`server.sh`:

```sh
#!/bin/bash
# Simple script to run the Vibe Blocks MCP server with uvicorn

# Check if uv is installed
if ! command -v uv &> /dev/null
then
    echo "Error: uv is not installed. Please install it first: https://github.com/astral-sh/uv#installation" 
    exit 1
fi

# Check if uvicorn is installed via uv, install if not
if ! uv pip freeze | grep -q "uvicorn=="
then
    echo "uvicorn not found via uv. Installing..."
    uv pip install uvicorn
    if [ $? -ne 0 ]; then
        echo "Failed to install uvicorn. Please install it manually." >&2
        exit 1
    fi
fi

# Navigate to the script's directory to ensure correct relative paths
cd "$(dirname "$0")"

# Run the server
echo "Starting Vibe Blocks MCP Server (http://localhost:8000)..."
uvicorn src.roblox_mcp.server:app --port 8000 --reload 
```

`src/roblox_mcp/__init__.py`:

```py
"""Roblox Studio integration through the Model Context Protocol."""

__version__ = "0.1.0"
 
# Expose key classes/functions if needed later
# from .server import ...
# from .roblox_client import RobloxClient 
```

`src/roblox_mcp/config.py`:

```py
import os
from pydantic_settings import BaseSettings, SettingsConfigDict
from dotenv import load_dotenv

class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8', extra='ignore')

    roblox_api_key: str
    roblox_universe_id: int
    roblox_place_id: int
    # Optional MCP server settings (if needed)
    mcp_host: str | None = None
    mcp_port: int | None = None

def load_config() -> Settings:
    """Loads configuration from environment variables or .env file."""
    load_dotenv()
    return Settings() 
```

`src/roblox_mcp/roblox_client.py`:

```py
import httpx # Replace requests
import asyncio # Import asyncio
import logging
# import time # Replaced by asyncio.sleep
import json
from typing import Dict, Any, Optional, List, AsyncIterator # Added AsyncIterator
import base64
import os
from pathlib import Path
import contextlib # For async context manager with files

from .config import Settings

logger = logging.getLogger(__name__)

API_BASE_URL = "https://apis.roblox.com/"
OPERATIONS_API_BASE_URL = "https://apis.roblox.com/operations/v1/"
DEVELOP_API_BASE_URL = "https://develop.roblox.com/" # Added for publish
POLLING_BASE_URL = "https://operations.roblox.com/" # Hypothetical base URL for polling

class RobloxApiError(Exception):
    """Custom exception for Roblox API errors."""
    def __init__(self, message, status_code=None, response_data=None):
        super().__init__(message)
        self.status_code = status_code
        self.response_data = response_data

class RobloxClient:
    def __init__(self, config: Settings):
        if not config:
            raise ValueError("Configuration is required to initialize RobloxClient")
        self.api_key = config.roblox_api_key
        self.universe_id = config.roblox_universe_id
        self.place_id = config.roblox_place_id # Default place ID
        
        # Initialize httpx.AsyncClient
        headers = {
            "x-api-key": self.api_key,
            "Content-Type": "application/json",
            "Accept": "application/json" # Generally expect JSON responses
        }
        self.client = httpx.AsyncClient(headers=headers, timeout=30.0) # Default timeout
        logger.info("RobloxClient initialized with httpx.AsyncClient.")

    async def _request(self, method: str, url: str,
                 params: Optional[Dict] = None, json_data: Optional[Dict] = None,
                 data: Optional[Any] = None, headers: Optional[Dict] = None,
                 files: Optional[Dict] = None, # httpx uses 'files', 'data' for form data, 'content' for raw bytes
                 content: Optional[bytes] = None, # For raw content like datastore set
                 timeout: Optional[float] = 30.0 # Allow per-request timeout override
                 ) -> Dict[str, Any]:
        """Async internal helper to make HTTP requests to Roblox API using httpx."""
        request_headers = self.client.headers.copy() # Start with client defaults
        if headers:
            request_headers.update(headers)

        # httpx handles Content-Type based on data/json/files/content, but let's remove if files specified
        if files:
            request_headers.pop("Content-Type", None)
        # If raw content or data (form) is provided, httpx might need explicit Content-Type if not default
        # If data is dict, httpx assumes form data, otherwise treats as bytes/string based on Content-Type
        # If content is bytes, Content-Type should be set appropriately in headers if needed

        max_retries = 3
        retry_delay = 1.0 # seconds, float for asyncio.sleep

        for attempt in range(max_retries):
            try:
                logger.debug(f"Sending {method} request to {url} (Attempt {attempt+1})")
                response = await self.client.request(
                    method=method,
                    url=url,
                    params=params,
                    json=json_data,
                    data=data, # For form data (dict)
                    files=files,
                    content=content, # For raw bytes/strings
                    headers=request_headers,
                    timeout=timeout
                )

                logger.debug(f"Received response: Status {response.status_code}, Headers: {response.headers}")

                # Handle Rate Limits (429)
                if response.status_code == 429:
                    retry_after_str = response.headers.get("Retry-After")
                    try:
                        delay = float(retry_after_str) if retry_after_str else retry_delay
                    except (ValueError, TypeError):
                        delay = retry_delay
                    # Ensure non-negative delay
                    delay = max(0, delay)
                    logger.warning(f"Rate limit hit (429) on attempt {attempt + 1}/{max_retries}. Retrying in {delay:.2f}s...")
                    await asyncio.sleep(delay)
                    # Exponential backoff, but ensure it respects Retry-After if larger
                    retry_delay = max(retry_delay * 2, delay) 
                    continue

                # Check for other errors
                response.raise_for_status() # Raises httpx.HTTPStatusError for 4xx/5xx

                # Try to parse JSON, handle cases with no content
                if response.status_code == 204: # No Content
                     return {}
                if response.content:
                    try:
                        # Use response.json() which handles decoding
                        return response.json()
                    except json.JSONDecodeError:
                        logger.warning(f"Non-JSON response received from {url}: {response.text[:100]}...")
                        # Return raw text if JSON parsing fails but request was successful
                        return {"raw_content": response.text} 
                else:
                    # Successful status code but no content (e.g., sometimes 200 OK with empty body)
                    return {}

            except httpx.HTTPStatusError as e:
                error_body = e.response.text
                try:
                    error_details = e.response.json()
                    message = f"HTTP Error {e.response.status_code}: {error_details.get('message', error_body)}"
                    response_data = error_details
                except json.JSONDecodeError:
                    message = f"HTTP Error {e.response.status_code}: {error_body}"
                    response_data = error_body
                
                # Handle 404 specifically for certain operations if needed (e.g., datastore get)
                # The caller method can decide how to handle specific status codes from RobloxApiError
                logger.error(f"HTTP Status Error from {url}: {message}")
                raise RobloxApiError(message, status_code=e.response.status_code, response_data=response_data) from e
            
            except httpx.RequestError as e: # Catches broader network issues, timeouts etc.
                logger.error(f"Request Error for {url} on attempt {attempt + 1}: {e}")
                if attempt == max_retries - 1:
                    raise RobloxApiError(f"Request Failed after {max_retries} attempts: {e}") from e
                await asyncio.sleep(retry_delay)
                retry_delay *= 2

        # Should not be reached if max_retries > 0
        raise RobloxApiError(f"Request failed after {max_retries} retries.")

    # --- Luau Execution --- 
    async def _poll_operation(self, operation_path: str, timeout: int = 90) -> Dict[str, Any]:
        """Async polls a long-running operation until completion or timeout."""
        loop = asyncio.get_event_loop()
        start_time = loop.time()
        poll_interval = 1.0 # Start polling after 1 second

        # Construct polling URL: BASE/cloud/v2/PATH
        operation_url = f"{API_BASE_URL.rstrip('/')}/cloud/v2/{operation_path.lstrip('/')}"
        logger.info(f"Constructed polling URL (with /cloud/v2/): {operation_url}")

        while loop.time() - start_time < timeout:
            try:
                logger.debug(f"Polling operation: {operation_url}")
                op_status = await self._request("GET", operation_url)

                # --- REVISED COMPLETION CHECK ---
                current_state = op_status.get('state')
                if current_state in ['COMPLETE', 'FAILED', 'CANCELLED'] or op_status.get("error"):
                    logger.info(f"Operation {operation_path} reached terminal state: {current_state}")
                    return op_status # Return the final status object
                else:
                    # Log current state if not done
                    logger.debug(f"Operation {operation_path} not complete yet. State: {current_state or 'Unknown'}")
                # --- END REVISED COMPLETION CHECK ---

            except RobloxApiError as e:
                logger.error(f"API Error polling operation {operation_path}: {e}")
                raise
            except Exception as e:
                 logger.error(f"Unexpected error polling operation {operation_path}: {e}", exc_info=True)
                 raise RobloxApiError(f"Unexpected polling error: {e}") from e

            await asyncio.sleep(poll_interval)
            poll_interval = min(poll_interval * 1.5, 5.0) # Increase delay up to 5 seconds

        raise RobloxApiError(f"Operation {operation_path} timed out after {timeout} seconds.", status_code=408)

    async def call_luau(self, script: str, target_place_id: Optional[int] = None, execution_timeout_secs: int = 30) -> Dict[str, Any]:
        """Async calls the Luau Execution API and waits for the result."""
        place_id = target_place_id or self.place_id
        if not place_id:
            raise ValueError("Target Place ID must be provided either in config or as argument.")

        endpoint = f"cloud/v2/universes/{self.universe_id}/places/{place_id}/luau-execution-session-tasks"
        url = f"{API_BASE_URL.rstrip('/')}/{endpoint.lstrip('/')}"
        payload = {
            "script": script,
            "timeout": f"{execution_timeout_secs}s"
        }

        logger.info(f"Initiating Luau execution for place {place_id}...")
        try:
            task_response = await self._request("POST", url, json_data=payload)
            logger.info(f"Received task response from /execute: {task_response}")
            operation_path = task_response.get("path")
            if not operation_path:
                 raise RobloxApiError("Luau execution task response did not contain 'path'.", response_data=task_response)

            logger.info(f"Luau task created, operation path: {operation_path}. Polling for result...")
            operation_result = await self._poll_operation(operation_path, timeout=execution_timeout_secs + 30)
            logger.debug(f"Full operation result from poll: {operation_result}")

            # --- REVISED RESULT PROCESSING (Fetch Logs) ---
            final_state = operation_result.get('state')
            if final_state == 'FAILED' or operation_result.get("error"):
                error_info = operation_result.get("error", {"message": f"Task failed with state {final_state} but no error details."}) 
                logger.error(f"Luau execution failed: {error_info}")
                error_response_data = error_info if isinstance(error_info, (dict, list, str, int, float, bool, type(None))) else str(error_info)
                raise RobloxApiError(f"Luau script execution error: {error_info.get('message', 'Unknown error')}", response_data=error_response_data)
            
            elif final_state != 'COMPLETE':
                # Handle unexpected states like CANCELLED or QUEUED (if polling timeout was too short?)
                raise RobloxApiError(f"Luau task ended in unexpected state: {final_state}", response_data=operation_result)

            # If state is COMPLETE, fetch logs
            logger.info(f"Task {operation_path} complete. Fetching logs...")
            logs_url = f"{API_BASE_URL.rstrip('/')}/cloud/v2/{operation_path.lstrip('/')}/logs" # Construct logs URL
            try:
                # --- ADD DEBUG LOGGING ---
                logger.debug(f"Fetching logs from: {logs_url}")
                logs_response = await self._request("GET", logs_url)
                logger.debug(f"Received raw logs_response (type {type(logs_response)}): {logs_response}")
                # --- END DEBUG LOGGING ---
                
                # Logs might be nested under "luauExecutionSessionTaskLogs"
                log_chunks = logs_response.get("luauExecutionSessionTaskLogs", [])
                # --- ADD DEBUG LOGGING ---
                logger.debug(f"Extracted log_chunks (type {type(log_chunks)}): {log_chunks}")
                # --- END DEBUG LOGGING ---
                messages = []
                if log_chunks and isinstance(log_chunks, list):
                    # --- ADD DEBUG LOGGING ---
                    for i, chunk in enumerate(log_chunks):
                        logger.debug(f"Processing chunk {i} (type {type(chunk)}): {chunk}")
                        # --- END DEBUG LOGGING ---
                        messages.extend(chunk.get("messages", []))
                
                # --- Modified Log Processing Logic --- 
                if not messages:
                    # Check if the raw response was just '[]' from _request's fallback
                    raw_output_from_logs = logs_response.get("raw_content") if isinstance(logs_response, dict) else None
                    if raw_output_from_logs == "[]":
                        logger.warning("Luau script completed but returned only '[]'. Returning empty dict.")
                        return {} # Return empty dict instead of the string "[]" or the "no messages" dict
                    else:
                        logger.warning(f"Luau script completed but no log messages found or parsed at {logs_url}. Raw response: {logs_response}")
                        return {"output": "", "parsed_json": None} # Indicate empty/unparsed output

                # --- Process all messages, prioritize last JSON --- 
                all_logs_str = "\n".join(map(str, messages))
                parsed_json_output = None
                last_message = messages[-1]

                # Attempt to parse the last message as JSON
                if isinstance(last_message, str) and last_message.strip().startswith('{') and last_message.strip().endswith('}'):
                    try:
                        parsed_json_output = json.loads(last_message)
                        logger.info(f"Successfully JSON-decoded final log message: {json.dumps(parsed_json_output)[:150]}...")
                    except json.JSONDecodeError:
                        logger.warning(f"Final log message looked like JSON but failed to parse: {last_message[:150]}...")
                        # Keep parsed_json_output as None
                
                # Return based on whether final JSON was parsed
                if parsed_json_output is not None:
                    # If last message was valid JSON, return the parsed object
                    return parsed_json_output 
                else:
                    # If last message wasn't JSON (or failed parse), return concatenated logs
                    logger.info(f"Script output appears to be plain text. Returning concatenated logs.")
                    # We return the raw string directly now, not nested in a dict
                    return all_logs_str 
                # --- End Modified Log Processing Logic --- 

            except RobloxApiError as log_err:
                logger.error(f"Failed to fetch logs for completed task {operation_path}: {log_err}")
                raise RobloxApiError(f"Task completed but failed to fetch logs: {log_err}", response_data=log_err.response_data) from log_err
            except Exception as e:
                logger.exception(f"Unexpected error processing logs for {operation_path}")
                raise RobloxApiError(f"Unexpected error processing logs: {e}") from e
            # --- END REVISED RESULT PROCESSING ---
            
        except RobloxApiError as e:
            logger.error(f"Failed to execute Luau script: {e}")
            raise # Re-raise the specific API error

    # --- Datastore --- 
    async def get_datastore_entry(self, datastore_name: str, entry_key: str, scope: str = "global") -> Any:
        """Async gets an entry from a standard datastore. Returns the decoded JSON value or raw text."""
        logger.info(f"Getting datastore entry '{entry_key}' from '{datastore_name}' (scope: {scope})")
        endpoint = f"datastores/v1/universes/{self.universe_id}/standard-datastores/datastore/entries/entry"
        url = f"{API_BASE_URL.rstrip('/')}/{endpoint.lstrip('/')}"
        params = {
            "datastoreName": datastore_name,
            "scope": scope,
            "entryKey": entry_key
        }
        try:
            # Use the _request method now which handles errors and retries
            # Expecting raw text or JSON directly from this endpoint
            response = await self._request("GET", url, params=params, timeout=15.0) 
            
            # _request now returns dict, check for raw_content if JSON failed
            if "raw_content" in response:
                logger.warning(f"Datastore value for {entry_key} is not valid JSON. Returning raw text.")
                return response["raw_content"]
            elif response == {}: # Should not happen for GET with content, but check
                 logger.warning(f"Datastore GET for {entry_key} returned empty response dict.")
                 return None
            else:
                 # If it's not raw_content and not empty, it should be parsed JSON
                 # The API returns the value directly, not nested in a dict
                 return response 

        except RobloxApiError as e:
            if e.status_code == 404:
                logger.info(f"Datastore entry '{entry_key}' not found (404).")
                return None # Return None if key doesn't exist
            else:
                # Re-raise other API errors
                raise
        except Exception as e:
             logger.error(f"Unexpected error getting datastore entry '{entry_key}': {e}", exc_info=True)
             raise RobloxApiError(f"Unexpected error: {e}") from e

    async def set_datastore_entry(self, datastore_name: str, entry_key: str, value: Any, 
                              scope: str = "global", 
                              match_version: Optional[str] = None, 
                              exclude_previous_value: bool = False,
                              user_ids: Optional[List[int]] = None, # For user attributes
                              attributes: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Async sets an entry in a standard datastore. Value should be JSON serializable."""
        logger.info(f"Setting datastore entry '{entry_key}' in '{datastore_name}' (scope: {scope})")
        endpoint = f"datastores/v1/universes/{self.universe_id}/standard-datastores/datastore/entries/entry"
        url = f"{API_BASE_URL.rstrip('/')}/{endpoint.lstrip('/')}"
        params = {
            "datastoreName": datastore_name,
            "scope": scope,
            "entryKey": entry_key
        }
        # Headers specific to this request
        request_headers = {
            "Content-Type": "application/json" # Roblox expects JSON string as data content
        }
        if match_version:
            params["matchVersion"] = match_version
        if exclude_previous_value:
            params["exclusiveCreate"] = "true"
        
        if user_ids or attributes:
             metadata = {}
             if user_ids: metadata["roblox-entry-userids"] = json.dumps(user_ids)
             if attributes: metadata["roblox-entry-attributes"] = json.dumps(attributes)
             encoded_metadata = base64.b64encode(json.dumps(metadata).encode()).decode()
             request_headers["roblox-entry-metadata"] = encoded_metadata

        try:
            json_string_value = json.dumps(value)
            # Send JSON string as raw content bytes
            content_bytes = json_string_value.encode('utf-8')
            # Use await for async _request
            result = await self._request(
                "POST", url, 
                params=params, 
                content=content_bytes, # Use content for raw bytes
                headers=request_headers
            )
            return result # Should contain version info on success
        except json.JSONDecodeError:
             raise ValueError("Value provided is not JSON serializable.")
        except Exception as e:
            logger.error(f"Error setting datastore entry '{entry_key}': {e}", exc_info=True)
            raise # Re-raise original or wrap in RobloxApiError if needed

    async def delete_datastore_entry(self, datastore_name: str, entry_key: str, scope: str = "global") -> None:
        """Async deletes an entry from a standard datastore."""
        logger.info(f"Deleting datastore entry '{entry_key}' from '{datastore_name}' (scope: {scope})")
        endpoint = f"datastores/v1/universes/{self.universe_id}/standard-datastores/datastore/entries/entry"
        url = f"{API_BASE_URL.rstrip('/')}/{endpoint.lstrip('/')}"
        params = {
            "datastoreName": datastore_name,
            "scope": scope,
            "entryKey": entry_key
        }
        try:
            # Use await. Expects 204 No Content on success, _request returns {}
            await self._request("DELETE", url, params=params)
            logger.info(f"Deletion request successful for entry '{entry_key}'.")
        except RobloxApiError as e:
             if e.status_code == 404:
                  # Log info but don't raise error if trying to delete non-existent key
                  logger.info(f"Entry '{entry_key}' not found during delete attempt (404).")
                  return # Treat as success (idempotent delete)
             else:
                  logger.error(f"API error deleting entry '{entry_key}': {e}")
                  raise # Re-raise other errors
        except Exception as e:
             logger.error(f"Unexpected error deleting entry '{entry_key}': {e}", exc_info=True)
             raise RobloxApiError(f"Unexpected error during delete: {e}") from e


    async def list_datastores(self, prefix: Optional[str] = None, limit: Optional[int] = None, cursor: Optional[str] = None) -> Dict[str, Any]:
        """Async lists standard datastores in the universe."""
        logger.info(f"Listing datastores (prefix: {prefix}, limit: {limit})")
        endpoint = f"datastores/v1/universes/{self.universe_id}/standard-datastores"
        url = f"{API_BASE_URL.rstrip('/')}/{endpoint.lstrip('/')}"
        params = {}
        if prefix: params["prefix"] = prefix
        if limit: params["limit"] = limit
        if cursor: params["cursor"] = cursor
        
        # Use await
        return await self._request("GET", url, params=params)
        
    # --- Assets --- 
    
    # Helper for async file opening
    @contextlib.asynccontextmanager
    async def _open_asset_file(self, file_path: str) -> AsyncIterator[tuple]:
        # This basic version just opens synchronously, but structure allows async later if needed
        # For true async file I/O, libraries like aiofiles would be needed.
        # httpx can handle sync file-like objects passed to 'files'.
        file_name = Path(file_path).name
        content_map = {
            ".fbx": "application/octet-stream", ".obj": "application/octet-stream",
            ".png": "image/png", ".jpg": "image/jpeg", ".jpeg": "image/jpeg",
            ".mp3": "audio/mpeg", ".ogg": "audio/ogg",
        }
        file_ext = Path(file_path).suffix.lower()
        content_type = content_map.get(file_ext, "application/octet-stream")
        
        try:
            # Open synchronously for now, httpx handles it
            f = open(file_path, 'rb') 
            yield (file_name, f, content_type)
        finally:
            if 'f' in locals() and f:
                 f.close()


    async def upload_asset(self, file_path: str, asset_type: str, display_name: str, description: str = "") -> Dict[str, Any]:
        """Async uploads a file as a new asset (e.g., Model, Image, Audio)."""
        if not os.path.exists(file_path): # Keep sync check for existence
            raise FileNotFoundError(f"File not found at path: {file_path}")

        logger.info(f"Uploading asset '{display_name}' ({asset_type}) from file '{Path(file_path).name}'")
        asset_api_url = "https://apis.roblox.com/assets/v1/assets" 

        asset_creation_request = {
            "assetType": asset_type,
            "displayName": display_name,
            "description": description,
            "creationContext": { "creator": { "userId": "me" } } # Placeholder, refine if needed
        }
        
        # Prepare headers, remove default Content-Type for multipart
        upload_headers = self.client.headers.copy()
        upload_headers.pop('Content-Type', None)
        # Accept header might already be set globally, but ensure it's correct
        upload_headers['Accept'] = 'application/json' 

        try:
            # Use the async context manager to handle the file
            async with self._open_asset_file(file_path) as file_info:
                # file_info is (file_name, file_object, content_type)
                file_name, file_obj, content_type = file_info
                
                files_payload = {
                    'request': (None, json.dumps(asset_creation_request), 'application/json'),
                    'fileContent': (file_name, file_obj, content_type)
                }

                # Make the request using the client directly (or adapt _request if preferred for retries)
                # Using client directly for simplicity with multipart files
                response = await self.client.post(
                    asset_api_url, 
                    files=files_payload, 
                    headers=upload_headers, 
                    timeout=120.0 # Longer timeout for uploads
                )
                response.raise_for_status() # Check for HTTP errors

                op_data = response.json()
                operation_path = op_data.get('path')
                if not operation_path:
                     raise RobloxApiError("Asset upload did not return an operation path.", response_data=op_data)

                logger.info(f"Asset upload initiated. Operation path: {operation_path}. Polling...")
                # Use await for async poll
                final_result = await self._poll_operation(operation_path, timeout=300)

                if final_result.get("error"):
                    error_info = final_result["error"]
                    logger.error(f"Asset processing failed: {error_info}")
                    raise RobloxApiError(f"Asset processing error: {error_info.get('message', 'Unknown error')}", response_data=error_info)

                asset_id = final_result.get("response", {}).get("assetId")
                if not asset_id: asset_id = final_result.get("metadata", {}).get("assetId") # Fallback check
                
                if asset_id:
                     logger.info(f"Asset upload successful. Asset ID: {asset_id}")
                     return {"assetId": asset_id, "operationResult": final_result}
                else:
                     raise RobloxApiError("Asset upload finished but failed to retrieve Asset ID.", response_data=final_result)

        except httpx.HTTPStatusError as e:
            raise RobloxApiError(f"HTTP Error uploading asset: {e.response.status_code}", status_code=e.response.status_code, response_data=e.response.text) from e
        except httpx.RequestError as e:
            logger.error(f"Request failed during asset upload: {e}", exc_info=True)
            raise RobloxApiError(f"Asset upload request failed: {e}") from e
        except FileNotFoundError as e: # Catch FileNotFoundError specifically
             raise # Re-raise it as it's a client-side error
        except Exception as e:
             logger.exception("Unexpected error during asset upload.")
             raise RobloxApiError(f"Unexpected upload error: {e}") from e

    async def get_asset_details(self, asset_id: int) -> Dict[str, Any]:
        """Async gets details for a specific asset ID."""
        logger.info(f"Getting details for asset ID: {asset_id}")
        # Placeholder - requires correct endpoint
        # endpoint = f"assets/v1/assets/{asset_id}"
        # url = f"{API_BASE_URL.rstrip('/')}/{endpoint.lstrip('/')}" 
        # return await self._request("GET", url)
        raise NotImplementedError("get_asset_details API call not fully implemented - requires correct endpoint.")

    async def list_assets(self, asset_types: Optional[List[str]] = None, 
                      filter_keyword: Optional[str] = None, 
                      limit: Optional[int] = None, 
                      cursor: Optional[str] = None) -> Dict[str, Any]:
        """Async lists assets owned by the user (or context), potentially filtered."""
        logger.info(f"Listing assets (types: {asset_types}, filter: {filter_keyword}, limit: {limit})")
        # Placeholder - requires correct endpoint
        # endpoint = "inventory/v1/..." 
        # url = f"{API_BASE_URL.rstrip('/')}/{endpoint.lstrip('/')}" 
        # params = {...}
        # return await self._request("GET", url, params=params)
        raise NotImplementedError("list_assets API call not fully implemented - requires correct endpoint.")

    # --- Publishing --- 
    async def publish_place(self, target_place_id: Optional[int] = None, version_type: str = "Saved") -> Dict[str, Any]:
        """Async publishes the specified place ID. Version type can be 'Saved' or 'Published'."""
        place_id = target_place_id or self.place_id
        if not place_id:
            raise ValueError("Target Place ID must be provided either in config or as argument.")
        if version_type not in ["Saved", "Published"]:
             raise ValueError("Invalid version_type. Must be 'Saved' or 'Published'.")

        logger.info(f"Publishing place {place_id} as version type '{version_type}'...")
        endpoint = f"v1/universes/{self.universe_id}/places/{place_id}/versions"
        url = f"{DEVELOP_API_BASE_URL.rstrip('/')}/{endpoint.lstrip('/')}" # Use Develop API base
        params = {"versionType": version_type}
        
        # Use await
        return await self._request("POST", url, params=params)

    async def close_session(self):
        """Async closes the underlying httpx client session."""
        await self.client.aclose()
        logger.info("Vibe Blocks MCP httpx session closed.") 
```

`src/roblox_mcp/server.py`:

```py
import asyncio
import logging
import json # Added for json formatting
from typing import Dict, Any, Optional, List, Union # Added Union
import re # For safe Lua string escaping
from collections import deque # Use deque for simple non-async queue
from datetime import datetime # For timestamping logs received from plugin
import uuid # For generating unique request IDs
import time # For timeouts
import threading # For locking access to shared results

# --- FastAPI Imports ---
from fastapi import FastAPI, HTTPException, Request # Added Request
from fastapi.responses import JSONResponse # For returning JSON
# --- End FastAPI Imports ---

from mcp.server.fastmcp import FastMCP, Context
from pydantic import Field, Json, BaseModel # Added BaseModel

from .config import load_config, Settings # Import config loading
from .roblox_client import RobloxClient, RobloxApiError # Import client and error
from .sse import create_sse_server # Import the SSE server creator

# --- Local Imports ---
from .config import load_config, Settings # Import config loading
from .roblox_client import RobloxClient, RobloxApiError # Import client and error
from .sse import create_sse_server # Import the SSE server creator
# --- End Local Imports ---

# --- Removed Uvicorn Import ---
# import uvicorn

# --- Define Known Services ---
KNOWN_ROBLOX_SERVICES = {
    "workspace", "lighting", "replicatedfirst", "replicatedstorage", 
    "serverstorage", "serverscriptservice", "startergui", "starterpack", 
    "starterplayer", "teams", "soundservice", "textchatservice", 
    "players", "chat", "localizationService", "testService"
    # Add more as needed
}

# Configure logging
logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger("VibeBlocksMCPServer") # <<< RENAME
# <<< Set main logger level to DEBUG >>>
logger.setLevel(logging.DEBUG)
logging.getLogger("roblox_mcp.roblox_client").setLevel(logging.DEBUG)
logging.getLogger("src.roblox_mcp.sse").setLevel(logging.INFO) # Add logger for SSE module

# --- Load Config Globally (Simpler than passing everywhere) ---
try:
    global_config = load_config()
    logger.info(f"Configuration loaded for Universe ID: {global_config.roblox_universe_id}")
except Exception as e:
    logger.error(f"Failed to load configuration: {e}. Ensure .env file exists.", exc_info=True)
    global_config = None
# --- End Load Config ---

# --- Removed Global Roblox Client (will be instantiated per tool call or managed differently) ---
# global_roblox_client: Optional[RobloxClient] = None

# --- Plugin Command Queue ---
plugin_command_queue: deque = deque()

# --- Last Script Logs ---
last_script_logs: Dict[str, Any] = {"output": None, "error": None}

# --- Studio Log Buffer ---
# Store tuples: (server_timestamp, log_entry_dict_from_plugin)
studio_log_buffer: deque = deque(maxlen=200) # Limit to last 200 entries

# --- Plugin Result Handling ---
# Dictionary to store results reported back by the plugin
# Key: request_id (str), Value: Result data or None if pending
pending_plugin_results: Dict[str, Any] = {}
# Lock to ensure thread-safe access to pending_plugin_results
plugin_results_lock = threading.Lock()
# --- End Plugin Result Handling ---

# --- Pydantic Model for Incoming Logs ---
class StudioLogEntry(BaseModel):
    message: str
    log_type: str # e.g., "Print", "Info", "Warning", "Error"
    timestamp: float # Plugin timestamp (os.clock() or similar)

# --- Main FastAPI App ---
app = FastAPI(
    title="Vibe Blocks MCP Server (SSE) with Plugin Endpoint", # <<< RENAME
    description="Combines MCP Tools (via SSE) with custom endpoints for Roblox Studio Plugin communication."
)
# --- End Main FastAPI App ---

# --- Add Endpoint for Studio Plugin (DEFINED BEFORE MOUNTING SSE) ---
@app.get("/plugin_command", response_class=JSONResponse)
async def get_plugin_command():
    """Endpoint for the Roblox Studio plugin to poll for commands."""
    global plugin_command_queue # Added global access
    try:
        # Get the next command from the left side of the queue
        command = plugin_command_queue.popleft()
        logger.info(f"Dequeued command for Studio plugin: {command}")
        return command # FastAPI automatically encodes dict to JSON
    except IndexError:
        # Queue is empty
        logger.debug("Plugin command queue empty.") # Add debug log
        return {} # Return empty JSON object
    except Exception as e:
        logger.exception("Error processing plugin command request")
        # Return an error response to the plugin
        raise HTTPException(status_code=500, detail="Internal server error processing command request")
# --- End Endpoint for Studio Plugin ---

# --- Add Endpoint for Reporting Plugin Results (NEW) ---
class PluginResultPayload(BaseModel):
    request_id: str
    result: Any # Can be any JSON-serializable type

@app.post("/plugin_report_result")
async def report_plugin_result(payload: PluginResultPayload, request: Request):
    """Endpoint for the Studio plugin to report the result of an executed command."""
    global pending_plugin_results, plugin_results_lock
    client_host = request.client.host if request.client else "unknown"
    request_id = payload.request_id
    result_data = payload.result
    logger.info(f"Received result for request_id {request_id} from plugin at {client_host}")
    
    with plugin_results_lock:
        if request_id in pending_plugin_results:
            pending_plugin_results[request_id] = result_data
            logger.debug(f"Stored result for {request_id}")
        else:
            # This might happen if the server restarted or the request timed out
            logger.warning(f"Received result for unknown or expired request_id: {request_id}")
            # Optionally, could still store it for a short time in case of race conditions

    return {"status": "success", "request_id": request_id}
# --- End Endpoint for Reporting Plugin Results ---

# --- Add Endpoint for Receiving Studio Logs (NEW) ---
@app.post("/receive_studio_logs")
async def receive_studio_logs(logs: List[StudioLogEntry], request: Request):
    """Endpoint for the Roblox Studio plugin to push captured logs."""
    global studio_log_buffer
    client_host = request.client.host if request.client else "unknown"
    try:
        server_received_time = datetime.now().timestamp()
        log_count = len(logs)
        logger.info(f"Received {log_count} log entries from plugin at {client_host}")
        # Store logs with server timestamp for potential sorting/filtering later
        # Convert Pydantic model back to dict for storage if needed, or store model directly
        # Storing dicts might be simpler for the tool later
        processed_logs = [
            (server_received_time, log.model_dump()) for log in logs
        ]
        studio_log_buffer.extend(processed_logs)
        return {"status": "success", "received": log_count}
    except Exception as e:
        logger.exception(f"Error processing logs from {client_host}")
        # Don't raise HTTPException usually, just log and return error status
        return JSONResponse(status_code=500, content={"status": "error", "detail": str(e)})
# --- End Endpoint for Receiving Studio Logs ---

# --- MCP Server Instance (Handles Tool Definitions) ---
# Note: We still need the FastMCP instance to register tools to.
mcp_server = FastMCP(
    "VibeBlocksMCP", # <<< RENAME
    description="Roblox Studio integration via MCP (SSE Transport)",
)
logger.info("FastMCP instance created for tool registration.")
# --- End MCP Server Instance ---

# --- Mount SSE Server onto Main App (at root, AFTER defining other routes) ---
# The SSE server internally uses the mcp_server instance to run the MCP protocol
if global_config: # Only mount if config loaded, otherwise client tools fail anyway
    app.mount("/", create_sse_server(mcp_server), name="mcp_sse") # Mount back at root
    logger.info("Mounted SSE MCP transport server at /") # Log correct path
else:
    logger.error("MCP SSE Server not mounted because configuration failed to load.")
# --- End Mount SSE Server ---


# --- Tool to Queue Command for Plugin (Remains registered with MCP) ---
# This tool is called via the SSE MCP connection now
@mcp_server.tool()
async def queue_studio_command(ctx: Context,
                               command: Dict[str, Any] = Field(..., description="The command dictionary to send to the Studio plugin.")) -> str:
    """Queues a command to be picked up by the companion Studio plugin via the /plugin_command endpoint."""
    global plugin_command_queue
    try:
        plugin_command_queue.append(command)
        logger.info(f"Queued command for Studio plugin via MCP: {command}") # Keep "MCP" generic here
        return f"Successfully queued command: {command}"
    except Exception as e:
        logger.exception("Error queuing command for plugin via MCP")
        return f"Error queuing command: {e}"
# --- End Tool to Queue Command for Plugin ---

# --- Tool to Queue MULTIPLE Commands for Plugin ---
@mcp_server.tool()
async def queue_studio_command_batch(ctx: Context,
                                   command_batch: List[Dict[str, Any]] = Field(..., description="A list of command dictionaries to send sequentially to the Studio plugin.")) -> str:
    """Queues a batch of commands to be picked up sequentially by the companion Studio plugin.
       Useful for sending multi-step instructions generated by the LLM.
    """
    global plugin_command_queue
    commands_queued = 0
    try:
        if not isinstance(command_batch, list):
            return "Error: Input must be a list of command dictionaries."
        
        for command in command_batch:
            if isinstance(command, dict):
                plugin_command_queue.append(command)
                commands_queued += 1
                logger.debug(f"Queued command from batch: {command}") # Debug level might be better
            else:
                logger.warning(f"Skipping non-dictionary item in command batch: {command}")
                
        logger.info(f"Queued {commands_queued} commands for Studio plugin via MCP batch tool.") # Keep "MCP" generic here
        return f"Successfully queued {commands_queued} commands."
    except Exception as e:
        logger.exception("Error queuing command batch for plugin via MCP")
        return f"Error queuing command batch: {e}"
# --- End Tool to Queue MULTIPLE Commands for Plugin ---

# --- Tool Helper Functions ---
def escape_lua_string(value: str) -> str:
    """Safely escapes a string for embedding in Lua code."""
    # Basic escaping for quotes, backslashes, and newlines
    escaped = value.replace('\\\\', '\\\\\\\\').replace('"', '\\\\"').replace("\\n", "\\\\n") # Double escape backslashes
    return f'"{escaped}"'

def value_to_lua_string(value: Any, property_name: Optional[str] = None) -> str:
    """Converts a Python value to its Lua string representation for scripting.
       Uses property_name hint for context-specific conversions (e.g., BrickColor, Enums).
    """
    if isinstance(value, str):
        # --- CONTEXT-AWARE STRING HANDLING --- --
        prop_lower = property_name.lower() if property_name else ""

        # 1. Check for specific property types first
        if prop_lower == "brickcolor":
            # Check if it looks like a standard BrickColor name (heuristic)
            if re.match(r"^(?:[A-Z][a-zA-Z0-9 ]+|[a-z0-9 ]+)$", value):
                logger.info(f"Treating string '{value}' as BrickColor name for property '{property_name}'.")
                return f'BrickColor.new({escape_lua_string(value)})'
            else:
                 logger.warning(f"Value '{value}' for BrickColor property '{property_name}' doesn't look like a standard name. Treating as escaped string.")
                 return escape_lua_string(value)

        elif prop_lower in ["material", "parttype", "formfactor", "style", "axis", "faces", "shape"]: # Add other Enum properties here
            if value.startswith("Enum."):
                logger.info(f"Passing Enum string '{value}' directly to Lua for property '{property_name}'.")
                return value # Assume it's already valid Lua code (e.g., "Enum.Material.Plastic")
            else:
                 logger.warning(f"Value '{value}' for Enum property '{property_name}' doesn't start with 'Enum.'. Treating as escaped string.")
                 return escape_lua_string(value)

        elif prop_lower in ["position", "size", "orientation"]:
             if value.lower().startswith("vector3.new("):
                 logger.info(f"Passing Vector3 string '{value}' directly to Lua for property '{property_name}'.")
                 return value # Assume it's already valid Lua code
             else:
                 # Fallback to default string handling if not explicitly Vector3.new()
                 return escape_lua_string(value)

        elif prop_lower == "color": # For Color3 properties
            if value.lower().startswith("color3.fromrgb(") or value.lower().startswith("color3.new("):
                 logger.info(f"Passing Color3 string '{value}' directly to Lua for property '{property_name}'.")
                 return value # Assume it's already valid Lua code
            else:
                 # Fallback to default string handling
                 return escape_lua_string(value)

        # 2. Check for general formats IF property type wasn't specific
        # (Less reliable, use specific property checks above first)
        # elif value.startswith("Enum."):
        #     logger.info(f"Passing Enum string '{value}' directly to Lua (generic check).")
        #     return value
        # elif value.lower().startswith("vector3.new("):
        #      logger.info(f"Passing Vector3 string '{value}' directly to Lua (generic check).")
        #      return value
        # elif value.lower().startswith("color3.fromrgb("):
        #      logger.info(f"Passing Color3 string '{value}' directly to Lua (generic check).")
        #      return value

        # --- DEFAULT: Treat as plain escaped string --- --
        else:
            # If none of the specific property types match, treat as a simple escaped string.
            # This is crucial for properties like 'Name', 'Value' (for StringValue), etc.
            logger.debug(f"Treating string '{value}' as plain escaped string for property '{property_name or 'None'}'.")
            return escape_lua_string(value)
        # --- END CONTEXT-AWARE STRING HANDLING --- --

    elif isinstance(value, bool):
        return str(value).lower()
    elif isinstance(value, (int, float)):
        return str(value)
    elif isinstance(value, list) and len(value) == 3 and all(isinstance(v, (int, float)) for v in value):
        # Assume lists of 3 numbers are Vector3, suitable for Position/Size etc.
        logger.info(f"Converting list {value} to Vector3 for property '{property_name or 'None'}'.")
        return f"Vector3.new({value[0]}, {value[1]}, {value[2]})"
    elif isinstance(value, list):
        # Basic table conversion for simple lists
        items = ", ".join(value_to_lua_string(item, None) for item in value) # No property hint for list items
        return f"{{{items}}}"
    elif isinstance(value, dict):
        # Basic table conversion for simple dicts (string keys only for now)
        items = ", ".join(f'["{k}"] = {value_to_lua_string(v, None)}' for k, v in value.items()) # No property hint for dict values
        return f"{{{items}}}"
    elif value is None:
        return "nil"
    else:
        logger.warning(f"Unsupported type {type(value)} for Lua conversion (property: {property_name}). Treating as string.")
        return escape_lua_string(str(value)) # Fallback to string

def safe_object_path(path: str) -> str:
    """Validates and formats an object path string for use in Lua."""
    # <<< ADD LOGGING: Show the exact input path >>>
    # logger.debug(f"[safe_object_path] Received path: {path!r}") # Original f-string log
    # <<< CHANGE: Use %-formatting for safer logging >>>
    logger.debug("[safe_object_path] Received path: %r", path)

    # <<< ADD try...except around validation >>>
    try:
        is_invalid = not re.match(r"^(game|workspace|[\w.]+)$", path, re.IGNORECASE) or ".." in path
    except Exception as validation_err:
        logger.error("[safe_object_path] Error during validation check for path %r: %r", path, validation_err, exc_info=True)
        # Re-raise the specific error to see if it's the one we're hunting
        raise validation_err

    if is_invalid:
    # if not re.match(r"^(game|workspace|[\w.]+)$", path, re.IGNORECASE) or ".." in path:
        # <<< Log before raising the explicit format error >>>
        logger.warning("[safe_object_path] Path failed validation: %r", path)
        raise ValueError(f"Invalid object path format: {path}")

    # lower_path = path.lower()

    # <<< ADD Explicit str conversion and logging >>>
    try:
        logger.debug("[safe_object_path] Type before str() conversion: %s", type(path))
        path_str = str(path)
        logger.debug("[safe_object_path] Path after str() conversion: %r", path_str)
        lower_path = path_str.lower()
        logger.debug("[safe_object_path] Lowercase path: %r", lower_path)
    except Exception as convert_err:
        logger.error("[safe_object_path] Error during str() or .lower() for path %r: %r", path, convert_err, exc_info=True)
        # Re-raise to be caught by list_children
        raise ValueError(f"Error during path conversion: {convert_err}") from convert_err

    if lower_path == 'workspace': # Line C
        return 'workspace'
    if lower_path == 'game':
        return 'game'
        
    # Handle paths starting with game. or workspace.
    if lower_path.startswith('game.'):
        return 'game' + path[len('game'):] 
    if lower_path.startswith('workspace.'):
         return 'workspace' + path[len('workspace'):] 

    # --- Check if it starts with a known service name --- 
    service_match = None
    service_name_original_case = None
    remaining_path = None
    for service in KNOWN_ROBLOX_SERVICES:
        if lower_path == service:
             service_match = service
             service_name_original_case = path # Use original case if it's just the service
             break
        elif lower_path.startswith(service + '.'):
            service_match = service
            # Find the original casing of the service part
            # This assumes the input path uses consistent casing for the service part
            service_name_original_case = path[:len(service)] 
            remaining_path = path[len(service):] # Includes the leading dot
            break

    # Handle known top-level services or paths starting with them
    if service_match:
        service_ref = f'game:GetService("{service_name_original_case}")'
        if remaining_path:
             logger.debug(f"Treating path '{path}' as service '{service_name_original_case}' + path.")
             return service_ref + remaining_path # Append the rest of the path (e.g., .StarterPlayerScripts)
        else:
             logger.debug(f"Treating path '{path}' as a known service.")
             return service_ref # Just the service itself

    # --- Fallback: Assume it's relative to workspace (last resort) ---
    # (Only reach here if it doesn't start with game/workspace/known service and doesn't contain dots)
    if '.' not in path:
        logger.debug(f"Assuming path '{path}' is relative to workspace (last resort).")
        if path in ["and", "or", "not", "local", "function", "if", "then", "else", "end", "while", "do", "for", "in", "return", "break", "true", "false", "nil"]:
                raise ValueError(f"Path '{path}' conflicts with Lua keyword.")
        return f"workspace:FindFirstChild({escape_lua_string(path)}, true)" 
    
    # --- If it contains dots but didn't match any service pattern ---
    # This case is less common now but could happen for things like game.Lighting.Something
    # if Lighting wasn't in KNOWN_ROBLOX_SERVICES initially.
    # Treat as full path, let Lua handle errors.
    logger.debug(f"Treating path '{path}' as a potential full path (not starting with known service).")
    return path


# --- Tool Definitions (Registered with mcp_server) ---

# --- Refactor Tool Handlers to Initialize Client ---
async def _get_roblox_client() -> Optional[RobloxClient]:
    """Helper to get or initialize the Roblox client based on global config."""
    if not global_config:
        logger.error("Cannot initialize RobloxClient: Configuration not loaded.")
        return None
    try:
        # Consider caching this client instance if performance becomes an issue,
        # but initializing per-call is safer for now.
        # We need to properly handle session closing if we cache.
        client = RobloxClient(global_config)
        # logger.debug(f"Initialized RobloxClient instance: {id(client)}")
        return client
    except Exception as e:
        logger.error(f"Failed to initialize RobloxClient: {e}", exc_info=True)
        return None

@mcp_server.tool()
async def execute_luau_in_cloud(ctx: Context, script_text: str = Field(..., description="The Luau code script to execute in the target place."), target_place_id: Optional[int] = Field(None, description="Optional Place ID to execute against, defaults to configured Place ID.")) -> str:
    """Executes arbitrary Luau script via the Roblox Cloud API and returns output or errors.
       Runs in a separate cloud environment, NOT the live Studio session.
    """
    global last_script_logs
    logger.info(f"Executing Luau script via Cloud API (first 100 chars): {script_text[:100]}...")
    last_script_logs = {"output": None, "error": None}
    client = await _get_roblox_client()
    if not client:
        return "Error: Roblox Client could not be initialized."

    try:
        # call_luau now returns parsed JSON (dict/list) or raw concatenated logs (str)
        result = await client.call_luau(script=script_text, target_place_id=target_place_id)
        last_script_logs["output"] = result # Store whatever was returned

        # --- Updated Result Handling --- 
        if isinstance(result, (dict, list)):
            # If we got a dict/list, assume it was parsed JSON
            try:
                # Pretty-print the JSON result
                output_str = json.dumps(result, indent=2)
                logger.info(f"Luau execution returned parsed JSON object.")
                # Check for an error key within the JSON itself
                if isinstance(result, dict) and result.get("error"):
                     error_msg = result["error"]
                     last_script_logs["error"] = error_msg
                     return f"Script reported error (JSON): {error_msg}"
                # Check for specific script_errors key
                elif isinstance(result, dict) and result.get("script_errors"):
                     script_errs = result["script_errors"]
                     last_script_logs["error"] = script_errs
                     return f"Script reported internal errors: {json.dumps(script_errs)}"
                else:
                     return f"""Script executed successfully (JSON Output):
{output_str}"""
            except (TypeError, ValueError) as json_err:
                # Should be rare if result is already dict/list, but handle just in case
                logger.error(f"Error formatting JSON result: {json_err}")
                last_script_logs["error"] = f"JSON formatting error: {json_err}"
                return f"Script executed, but failed to format JSON result: {result}"
        elif isinstance(result, str):
            # If we got a string, assume it's concatenated logs
            logger.info(f"Luau execution returned raw string output.")
            last_script_logs["output"] = result # Already stored, but re-assign for clarity
            # Return the raw string output directly
            # Truncate long outputs for display?
            max_len = 1000
            if len(result) > max_len:
                return f"""Script executed successfully (Raw Output Truncated):
{result[:max_len]}..."""
            else:
                return f"""Script executed successfully (Raw Output):
{result}"""
        else:
            # Handle unexpected return types from call_luau
            logger.error(f"call_luau returned unexpected type: {type(result)}")
            last_script_logs["error"] = f"Unexpected return type from client: {type(result)}"
            return f"Error: Script execution returned unexpected data type: {type(result).__name__}"
        # --- End Updated Result Handling ---

    except RobloxApiError as e:
        # Handle errors raised during the API call process (e.g., connection, permissions)
        logger.error(f"Roblox API Error during Luau execution call: {e}", exc_info=True) # Log traceback
        last_script_logs["error"] = str(e)
        # Provide more context if it's a script error returned via the API error
        if "Luau script execution error" in str(e) and e.response_data:
             error_detail = e.response_data.get('message', json.dumps(e.response_data)) if isinstance(e.response_data, dict) else str(e.response_data)
             return f"Error executing Luau script (API Response): {error_detail}"
        return f"Error executing Luau script (API Call): {e}"
    except NotImplementedError as e:
        logger.error("execute_luau tool called but RobloxClient.call_luau is not fully implemented.")
        last_script_logs["error"] = "NotImplementedError in client"
        return "Error: Luau execution feature is not yet implemented in the client."
    except Exception as e:
        logger.exception("Unexpected error during execute_luau tool execution.") # Log traceback
        last_script_logs["error"] = f"Unexpected server error: {e}"
        return f"Unexpected server error: {e}"
    finally:
        # Ensure client session is closed if initialized per-call
        if client:
            await client.close_session()

@mcp_server.tool()
async def get_property(ctx: Context, object_name: str = Field(..., description="Name or path of the object (e.g., 'MyPart' or 'Workspace.Model.Part')."), property_name: str = Field(..., description="Name of the property to retrieve (e.g., 'Position', 'Name', 'BrickColor').")) -> str:
    """Retrieves the value of a specific property from an object via the Studio Plugin."""
    # <<< CHANGE: Use plugin queue AND WAIT instead of Luau execution >>>
    logger.info(f"Requesting property '{property_name}' for object '{object_name}' via plugin")

    # Basic validation
    if not re.match(r"^[\w.]+$", object_name): # Allow dots in object name path
        return f"Tool: get_property, Error: Invalid object name format: {object_name}"
    if not re.match(r"^\w+$", property_name):
        return f"Tool: get_property, Error: Invalid property name format: {property_name}"

    command = {
        "action": "get_property",
        "data": {
            "object_name": object_name,
            "property_name": property_name
        }
        # request_id will be added by queue_command_and_wait
    }

    try:
        # Use the helper to queue and wait
        result_data = await queue_command_and_wait(command, timeout=10.0)

        logger.info(f"Received result for get_property({object_name}.{property_name}): {result_data}")

        # --- Result Processing ---
        if isinstance(result_data, dict):
            if "error" in result_data:
                error_msg = result_data["error"]
                logger.error(f"Plugin reported error for get_property: {error_msg}")
                return f"Tool: get_property, Error from plugin: {error_msg}"
            elif "value" in result_data:
                value = result_data["value"]
                # Format the output nicely
                # If the value itself is a dict (e.g., serialized Vector3), pretty print it
                if isinstance(value, (dict, list)):
                    value_str = json.dumps(value, indent=2)
                else:
                    value_str = str(value)
                return f"Tool: get_property, Result: Property '{property_name}' of '{object_name}' is: {value_str}"
            else:
                # Plugin returned a dictionary but without 'error' or 'value'
                logger.warning(f"Received unexpected dictionary format from plugin for get_property: {result_data}")
                return f"Tool: get_property, Error: Received unexpected result format from plugin: {result_data}"
        else:
            # Plugin returned something other than a dictionary
            logger.warning(f"Received non-dictionary result from plugin for get_property: {result_data}")
            return f"Tool: get_property, Error: Received unexpected result type from plugin: {type(result_data).__name__}"
        # --- End Result Processing ---

    except TimeoutError as e:
        logger.error(f"Timeout waiting for get_property result: {e}")
        return f"Tool: get_property, Error: Timeout waiting for response from Studio plugin for '{object_name}.{property_name}'."
    except Exception as e:
        logger.exception(f"Error executing get_property for {object_name}.{property_name}")
        return f"Tool: get_property, Error: An unexpected server error occurred: {e}"
    # <<< END CHANGE >>>

@mcp_server.tool()
async def list_children(ctx: Context, parent_name: str = Field("Workspace", description="Name or path of the parent object (e.g., 'Workspace', 'Workspace.Model').")) -> str:
    """Retrieves children of an object via the Studio Plugin and waits for the result."""
    # <<< CHANGE: Use plugin queue AND WAIT instead of just queueing >>>
    logger.info(f"Requesting list_children via plugin for parent: '{parent_name}'")

    # Define the command to be sent to the plugin
    command = {
        "action": "list_children",
        "data": {
            "parent_name": parent_name # Send the original name for the plugin to resolve
        }
        # request_id will be added by queue_command_and_wait
    }

    try:
        logger.info(f"Attempting to list children for parent: {parent_name}")
        
        # Use the new helper to queue and wait for the result
        result_data = await queue_command_and_wait(command, timeout=15.0) # Increased timeout slightly
        
        logger.info(f"Received result for list_children({parent_name}): {result_data}")

        # --- Result Processing ---
        if isinstance(result_data, dict) and "error" in result_data:
             # Plugin reported an error
             error_msg = result_data["error"]
             logger.error(f"Plugin reported error for list_children({parent_name}): {error_msg}")
             # Return error string suitable for MCP tool output
             return f"Tool: list_children, Error from plugin: {error_msg}"
        elif isinstance(result_data, list):
             # Assume success, result is the list of children dicts
             # Format the list into a user-friendly string output
             if not result_data:
                  return f"Tool: list_children, Result: No children found for '{parent_name}'."
             else:
                  output_str = f"Tool: list_children, Result: Children of '{parent_name}':\n"
                  # <<< CHANGE: Include path in output formatting >>>
                  output_str += "\n".join([f"- {child.get('name', '?')} ({child.get('className', '?')}) Path: {child.get('path', '?')}" for child in result_data])
                  return output_str
        else:
            # Unexpected result format from plugin
            logger.warning(f"Received unexpected result format for list_children({parent_name}): {result_data} (Type: {type(result_data)})")
            return f"Tool: list_children, Error: Received unexpected result format from plugin: {result_data}"
        # --- End Result Processing ---

    except TimeoutError as e:
        logger.error(f"Timeout waiting for list_children result for parent: {parent_name}: {e}")
        return f"Tool: list_children, Error: Timeout waiting for response from Studio plugin for parent '{parent_name}'."
    except Exception as e:
        # Catch potential errors from queue_command_and_wait or other issues
        logger.exception(f"Error executing list_children for parent {parent_name}")
        return f"Tool: list_children, Error: An unexpected server error occurred: {e}"
    # <<< END CHANGE >>>

@mcp_server.tool()
async def find_instances(ctx: Context,
                     class_name: str = Field(default=None, description="ClassName to filter by (e.g., 'Part', 'Model')."),
                     name_contains: str = Field(default=None, description="Text the instance name should contain (case-insensitive)."),
                     search_root: str = Field("Workspace", description="Name or path of the object to search under (e.g., 'Workspace', 'ReplicatedStorage.Models').")
                     ) -> str:
    """Finds instances within a specified root based on class name or name containing text via the Studio Plugin."""
    # <<< CHANGE: Use plugin queue AND WAIT instead of Luau execution >>>
    logger.info(f"Requesting find_instances via plugin under '{search_root}' (class: {class_name or 'Any'}, name contains: {name_contains or 'Any'})")

    # Basic validation (can add more for search_root if needed)
    # ... (validation skipped for brevity, assume safe inputs for now)

    command = {
        "action": "find_instances",
        "data": {
            "class_name": class_name,         # Pass None if not provided
            "name_contains": name_contains,   # Pass None if not provided
            "search_root": search_root
        }
        # request_id will be added by queue_command_and_wait
    }

    try:
        # Use the helper to queue and wait
        result_data = await queue_command_and_wait(command, timeout=20.0) # Allow slightly longer timeout for search

        logger.info(f"Received result for find_instances({search_root}, {class_name}, {name_contains}): {result_data}")

        # --- Result Processing ---
        if isinstance(result_data, dict):
            if "error" in result_data:
                error_msg = result_data["error"]
                logger.error(f"Plugin reported error for find_instances: {error_msg}")
                return f"Tool: find_instances, Error from plugin: {error_msg}"
            elif "instances" in result_data:
                instances = result_data["instances"]
                if not instances:
                    return f"Tool: find_instances, Result: No instances found matching criteria under '{search_root}'."
                else:
                    # Expecting list of dicts like {name, className, path}
                    output_str = f"Tool: find_instances, Result: Found {len(instances)} instance(s) under '{search_root}':\n"
                    output_str += "\n".join([f"- {inst.get('name', '?')} ({inst.get('className', '?')}) at path: {inst.get('path', '?')}" for inst in instances])
                    return output_str
            else:
                logger.warning(f"Received unexpected dictionary format from plugin for find_instances: {result_data}")
                return f"Tool: find_instances, Error: Received unexpected result format from plugin: {result_data}"
        else:
            logger.warning(f"Received non-dictionary result from plugin for find_instances: {result_data}")
            return f"Tool: find_instances, Error: Received unexpected result type from plugin: {type(result_data).__name__}"
        # --- End Result Processing ---

    except TimeoutError as e:
        logger.error(f"Timeout waiting for find_instances result: {e}")
        return f"Tool: find_instances, Error: Timeout waiting for response from Studio plugin under '{search_root}'."
    except Exception as e:
        logger.exception(f"Error executing find_instances under {search_root}")
        return f"Tool: find_instances, Error: An unexpected server error occurred: {e}"
    # <<< END CHANGE >>>

@mcp_server.tool()
async def create_instance(ctx: Context,
                      class_name: str = Field(..., description="The ClassName of the instance to create (e.g., 'Part', 'Model', 'Script')."),
                      properties: Dict[str, Any] = None,
                      parent_name: str = Field("Workspace", description="Name or path of the parent object to create the instance under (defaults to Workspace).")) -> str:
    """Creates a new instance via Studio Plugin command queue."""
    logger.info(f"Creating instance: Class='{class_name}', Parent='{parent_name}', Props={properties}")
    
    # Basic validation
    if not re.match(r"^\w+$", class_name):
        return f"Error: Invalid ClassName format: {class_name}"
    # TODO: Consider adding validation for parent_name and property keys/values

    command = {
        "action": "create_instance",
        "data": {
            "class_name": class_name,
            "parent_name": parent_name,
            "properties": properties if properties else {}
        }
    }

    try:
        # Ensure properties is always a dict
        if properties is None:
            properties = {}
        # Queue the command AND WAIT for the result
        result = await queue_command_and_wait(command)
        
        # Process the result from the plugin
        if "error" in result:
            error_msg = result["error"]
            # Truncate long errors if necessary
            if isinstance(error_msg, str) and len(error_msg) > 250:
                error_msg = error_msg[:250] + "..."
            logger.error(f"Plugin reported error for create_instance: {error_msg}")
            return f"Error creating instance: {error_msg}"
        elif "success" in result and result["success"]:
            instance_name = result.get('name', properties.get('Name', class_name))
            instance_path = result.get('path', 'unknown path')
            logger.info(f"Plugin successfully created instance '{instance_name}' at {instance_path}")
            return f"Successfully created {class_name} '{instance_name}' at '{instance_path}'."
        else:
            logger.warning(f"Received unexpected result format from plugin for create_instance: {result}")
            return f"Error: Unexpected result format from plugin while creating instance."

    except TimeoutError:
        logger.error(f"Timeout waiting for create_instance result for {class_name}")
        return f"Error: Timeout waiting for Studio plugin to create instance '{class_name}'."
    except Exception as e:
        logger.exception("Unexpected error in create_instance tool.")
        return f"Unexpected server error: {e}"

@mcp_server.tool()
async def delete_instance(ctx: Context, object_name: str = Field(..., description="Name or path of the object to delete (e.g., 'MyPart', 'Workspace.Model').")) -> str:
    """Deletes an object from the scene by calling its :Destroy() method via the Studio Plugin."""
    # <<< CHANGE: Use plugin queue AND WAIT instead of Luau execution >>>
    logger.info(f"Requesting delete_instance via plugin for object '{object_name}'")

    # Basic validation
    if not re.match(r"^[\w.]+$", object_name): # Allow dots in object name path
        return f"Tool: delete_instance, Error: Invalid object name format: {object_name}"

    command = {
        "action": "delete_instance",
        "data": {
            "object_name": object_name
        }
        # request_id will be added by queue_command_and_wait
    }

    try:
        # Use the helper to queue and wait
        result_data = await queue_command_and_wait(command, timeout=10.0)

        logger.info(f"Received result for delete_instance({object_name}): {result_data}")

        # --- Result Processing ---
        if isinstance(result_data, dict):
            if result_data.get("success"):
                 return f"Tool: delete_instance, Result: Successfully requested deletion of '{object_name}'."
            elif "error" in result_data:
                error_msg = result_data["error"]
                logger.error(f"Plugin reported error for delete_instance: {error_msg}")
                return f"Tool: delete_instance, Error from plugin: {error_msg}"
            else:
                logger.warning(f"Received unexpected dictionary format from plugin for delete_instance: {result_data}")
                return f"Tool: delete_instance, Error: Received unexpected result format from plugin: {result_data}"
        else:
            logger.warning(f"Received non-dictionary result from plugin for delete_instance: {result_data}")
            return f"Tool: delete_instance, Error: Received unexpected result type from plugin: {type(result_data).__name__}"
        # --- End Result Processing ---

    except TimeoutError as e:
        logger.error(f"Timeout waiting for delete_instance result: {e}")
        return f"Tool: delete_instance, Error: Timeout waiting for response from Studio plugin for '{object_name}'."
    except Exception as e:
        logger.exception(f"Error executing delete_instance for {object_name}")
        return f"Tool: delete_instance, Error: An unexpected server error occurred: {e}"
    # <<< END CHANGE >>>

@mcp_server.tool()
async def set_property(ctx: Context,
                     object_name: str = Field(..., description="Name or path of the object."),
                     property_name: str = Field(..., description="Name of the property to set."),
                     # <<< CHANGE: Added example of escaped JSON string >>>
                     value: str = Field(..., description='JSON string for the value (e.g., `"hello"`, `5`, `true`, `null`, `"[1,2,3]"`, `"{\\"key\\":\\"val\\"}"`). Primitives are passed directly. Complex types (like lists or dicts) must be valid JSON *within* the string.') 
                     ) -> str:
    """Sets a specific property on an object using a JSON string input. 
-       NOTE: Requires the value parameter to be a string containing valid JSON due to framework limitations. 
-       Crucially, when providing the JSON payload for the tool call, complex types must be represented as *escaped JSON strings*.
-       Tool Call Payload Examples for 'value':
-       - String:    `"\"hello\""`
-       - Number:    `"5"`
-       - Boolean:   `"true"`
-       - Nil:       `"null"`
-       - List/Vec3: `"[0, 10, 0]"`
-       - Dict:      `"{\"name\": \"MyPart\"}"`
-       The inner Python function then parses the string content (e.g., '[0, 10, 0]').
-       Use specific tools (e.g., move_instance, set_primary_part) or create_instance (with properties) for complex types where possible.
+       The 'value' parameter should be a string containing valid JSON representing the desired value.
+       - For primitive types (string, number, boolean, nil), provide them as standard JSON strings: `"\"hello\""`, `"5"`, `"true"`, `"null"`.
+       - For complex types (like Vector3, Color3, lists, dictionaries), provide the JSON representation as a string: `"[0, 10, 0]"`, `"{\"r\": 1, \"g\": 0, \"b\": 0}"`.
+       The plugin will attempt to convert the parsed JSON value to the appropriate Roblox type based on the property name.
+       Use specific tools (e.g., move_instance, set_primary_part, create_instance with properties) for complex types where possible, as they offer better type handling.
     """
    logger.info(f"Setting property '{property_name}' on '{object_name}' from JSON string: {value}")
    
    try:
        # Manually parse the JSON string value again
        try:
            parsed_value = json.loads(value)
            logger.debug(f"Parsed value type from JSON string: {type(parsed_value).__name__}")
        except json.JSONDecodeError as json_err:
            logger.error(f"Invalid JSON string provided for value: {value} - Error: {json_err}")
            return f"Error: Invalid JSON format for value parameter. Details: {json_err}"

        if not re.match(r"^\w+$", property_name):
            return f"Error: Invalid property name format: {property_name}"

        # Create command for the plugin with the PARSED value
        command = {
            "action": "set_property",
            "data": {
                "object_name": object_name,
                "property_name": property_name,
                "value": parsed_value 
            }
        }
        
        # Queue the command and wait for result
        result = await queue_command_and_wait(command)
        
        # Process the result
        if "error" in result:
            error_msg = result["error"]
            if isinstance(error_msg, str) and len(error_msg) > 200:
                error_msg = error_msg[:200] + "..."
            return f"Error setting property '{property_name}': {error_msg}"
        elif "success" in result and result["success"]:
            return f"Successfully set property '{property_name}' on '{object_name}'."
        else:
            return f"Error: Unexpected result format from plugin while setting property."

    except TimeoutError:
        return f"Error: Timeout waiting for Studio plugin to set property '{property_name}' on '{object_name}'."
    except ValueError as e: # Catch other potential errors like invalid property name format
        return f"Error: {e}"
    except Exception as e:
        logger.exception("Unexpected error in set_property tool.")
        return f"Unexpected server error: {e}"

@mcp_server.tool()
async def set_primary_part(ctx: Context,
                          model_path: str = Field(..., description="Path to the Model object."),
                          part_path: str = Field(..., description="Path to the BasePart object to set as the PrimaryPart.")) -> str:
    """Sets the PrimaryPart property of a Model to the specified BasePart."""
    logger.info(f"Setting PrimaryPart of '{model_path}' to '{part_path}'")

    # Basic path validation (could be stricter)
    if not re.match(r"^[\w.]+$", model_path):
        return f"Error: Invalid model path format: {model_path}"
    if not re.match(r"^[\w.]+$", part_path):
        return f"Error: Invalid part path format: {part_path}"

    try:
        # Create command for the plugin
        command = {
            "action": "set_primary_part",
            "data": {
                "model_path": model_path,
                "part_path": part_path
            }
        }

        # Queue the command and wait for result
        result = await queue_command_and_wait(command)

        # Process the result
        if "error" in result:
            return f"Error setting PrimaryPart for '{model_path}': {result['error']}"
        elif "success" in result and result["success"]:
            return f"Successfully set PrimaryPart of '{model_path}' to '{part_path}'."
        else:
            return f"Error: Unexpected result format from plugin while setting PrimaryPart."

    except TimeoutError:
        return f"Error: Timeout waiting for Studio plugin to set PrimaryPart for '{model_path}'."
    except ValueError as e: # Catch other potential errors like invalid path format
        return f"Error: {e}"
    except Exception as e:
        logger.exception("Unexpected error in set_primary_part tool.")
        return f"Unexpected server error: {e}"

@mcp_server.tool()
async def move_instance(ctx: Context, object_name: str = Field(..., description="Name or path of the object to move."),
                  # <<< CHANGE: Expect standard JSON string for dictionary >>>
                  position: str = Field(..., description='JSON string for the position dictionary, e.g., `"{\"x\": 0, \"y\": 10, \"z\": 0}"`.')
                  ) -> str:
    """Moves an object to a new position using a JSON string dictionary for the position."""
    logger.info(f"Moving '{object_name}' from position JSON string: {position}")
    
    try:
        # <<< ADD: Parse JSON string to dictionary >>>
        try:
            position_dict = json.loads(position)
            logger.debug(f"Parsed position dictionary: {position_dict}")
        except json.JSONDecodeError as json_err:
            logger.error(f"Invalid JSON string provided for position: {position} - Error: {json_err}")
            return f"Error: Invalid JSON format for position parameter. Expected a dictionary string like '{{\"x\":0, \"y\":0, \"z\":0}}'. Details: {json_err}"

        # <<< CHANGE: Validate parsed dictionary >>>
        if not isinstance(position_dict, dict) or not all(k in position_dict for k in ['x', 'y', 'z']) or not all(isinstance(position_dict[k], (int, float)) for k in ['x', 'y', 'z']):
            return "Error: Invalid position dictionary structure after parsing JSON. Expected keys 'x', 'y', 'z' with number values."
    
        # Create command for the plugin, using the PARSED position dict
        command = {
            "action": "move_instance",
            "data": {
                "object_name": object_name,
                "position": position_dict # Pass the parsed dictionary
            }
        }
        
        # Queue the command and wait for result
        result = await queue_command_and_wait(command)
        
        # Process the result
        if "error" in result:
            return f"Error moving '{object_name}': {result['error']}"
        elif "success" in result and result["success"]:
            # Format output using dict values from parsed dict
            return f"Successfully moved '{object_name}' to position (x={position_dict['x']}, y={position_dict['y']}, z={position_dict['z']})."
        else:
            return f"Error: Unexpected result format from plugin while moving instance."

    except TimeoutError:
        return f"Error: Timeout waiting for Studio plugin to move '{object_name}'."
    except ValueError as e: # Catch other potential errors
        return f"Error: {e}"
    except Exception as e:
        logger.exception("Unexpected error in move_instance tool.")
        return f"Unexpected server error: {e}"

@mcp_server.tool()
async def clone_instance(ctx: Context, object_name: str = Field(..., description="Name or path of the object to clone."),
                     new_name: Optional[str] = Field(None, description="Optional new name for the cloned object."),
                     parent_name: Optional[str] = Field(None, description="Optional name or path for the parent of the clone (defaults to original parent).")) -> str:
    """Clones an existing object, optionally giving it a new name and parent."""
    logger.info(f"Cloning instance '{object_name}' (new name: {new_name}, parent: {parent_name})")
    
    try:
        # Create command for the plugin
        command = {
            "action": "clone_instance",
            "data": {
                "object_name": object_name,
                "new_name": new_name,
                "parent_name": parent_name
            }
        }
        
        # Queue the command and wait for result
        result = await queue_command_and_wait(command)
        
        # Process the result
        if "error" in result:
            return f"Error cloning instance '{object_name}': {result['error']}"
        elif "success" in result and result["success"]:
            clone_name = result.get("clone_name", "Unknown")
            clone_path = result.get("clone_path", "Unknown path")
            parent_error = result.get("parent_error")
            
            msg = f"Successfully cloned '{object_name}' to '{clone_name}' at path '{clone_path}'."
            if parent_error:
                msg += f" Warning: {parent_error}"
            return msg
        else:
            return f"Error: Unexpected result format from plugin while cloning instance."

    except TimeoutError:
        return f"Error: Timeout waiting for Studio plugin to clone '{object_name}'."
    except ValueError as e:
        return f"Error: {e}"
    except Exception as e:
        logger.exception("Unexpected error in clone_instance tool.")
        return f"Unexpected server error: {e}"

@mcp_server.tool()
async def create_script(ctx: Context, script_name: str = Field(..., description="The name for the new Script instance."),
                  script_code: str = Field(..., description="The Luau code content for the script."),
                  script_type: str = Field("Script", description="Type of script: 'Script' or 'LocalScript'."),
                  parent_name: str = Field("Workspace", description="Name or path of the parent object (defaults to Workspace).")) -> str:
    """Creates a new Script or LocalScript instance with the provided code under the specified parent."""
    logger.info(f"Creating {script_type} named '{script_name}' under '{parent_name}'")
    
    if script_type not in ["Script", "LocalScript"]:
        return f"Error: Invalid script_type '{script_type}'. Must be 'Script' or 'LocalScript'."
    
    try:
        # Create command for the plugin
        command = {
            "action": "create_script",
            "data": {
                "script_name": script_name,
                "script_code": script_code,
                "script_type": script_type,
                "parent_name": parent_name
            }
        }
        
        # Queue the command and wait for result
        result = await queue_command_and_wait(command)
        
        # Process the result
        if "error" in result:
            return f"Error creating script: {result['error']}"
        elif "success" in result and result["success"]:
            return f"Successfully created {script_type} '{result.get('name', script_name)}' at '{result.get('path', 'unknown path')}'."
        else:
            return f"Error: Unexpected result format from plugin while creating script."

    except TimeoutError:
        return f"Error: Timeout waiting for Studio plugin to create script."
    except ValueError as e:
        return f"Error: {e}"
    except Exception as e:
        logger.exception("Unexpected error in create_script tool.")
        return f"Unexpected server error: {e}"

@mcp_server.tool()
async def edit_script(ctx: Context, script_path: str = Field(..., description="Name or path of the script to edit."),
                   script_code: str = Field(..., description="The new Luau code content for the script.")) -> str:
    """Edits the source code of an existing Script or LocalScript instance."""
    logger.info(f"Editing script at '{script_path}'")
    
    try:
        # Create command for the plugin
        command = {
            "action": "edit_script",
            "data": {
                "script_path": script_path,
                "script_code": script_code
            }
        }
        
        # Queue the command and wait for result
        result = await queue_command_and_wait(command)
        
        # Process the result
        if "error" in result:
            return f"Error editing script: {result['error']}"
        elif "success" in result and result["success"]:
            return f"Successfully updated script at '{script_path}'."
        else:
            return f"Error: Unexpected result format from plugin while editing script."

    except TimeoutError:
        return f"Error: Timeout waiting for Studio plugin to edit script."
    except ValueError as e:
        return f"Error: {e}"
    except Exception as e:
        logger.exception("Unexpected error in edit_script tool.")
        return f"Unexpected server error: {e}"

@mcp_server.tool()
async def delete_script(ctx: Context, script_path: str = Field(..., description="Name or path of the script to delete.")) -> str:
    """Deletes an existing Script or LocalScript instance."""
    logger.info(f"Deleting script at '{script_path}'")
    
    try:
        # Create command for the plugin
        command = {
            "action": "delete_script",
            "data": {
                "script_path": script_path
            }
        }
        
        # Queue the command and wait for result
        result = await queue_command_and_wait(command)
        
        # Process the result
        if "error" in result:
            return f"Error deleting script: {result['error']}"
        elif "success" in result and result["success"]:
            return f"Successfully deleted script at '{script_path}'."
        else:
            return f"Error: Unexpected result format from plugin while deleting script."

    except TimeoutError:
        return f"Error: Timeout waiting for Studio plugin to delete script."
    except ValueError as e:
        return f"Error: {e}"
    except Exception as e:
        logger.exception("Unexpected error in delete_script tool.")
        return f"Unexpected server error: {e}"

@mcp_server.tool()
async def list_datastores_in_cloud(ctx: Context, prefix: Optional[str] = Field(None, description="Filter datastores with names starting with this prefix."),
                    limit: Optional[int] = Field(None, description="Maximum number of datastores to return."),
                    cursor: Optional[str] = Field(None, description="Pagination cursor from a previous response.")) -> str:
    """Lists standard datastores via the Roblox Cloud API within the configured universe."""
    logger.info(f"Listing datastores via Cloud API (prefix: {prefix}, limit: {limit})")
    client = await _get_roblox_client()
    if not client:
        return "Error: Roblox Client could not be initialized."

    try:
        result = await client.list_datastores(prefix=prefix, limit=limit, cursor=cursor)
        stores = result.get("datastores", [])
        next_cursor = result.get("nextPageCursor")

        if not stores:
            return "No datastores found." + (f" (Prefix: {prefix})" if prefix else "")

        output = "Datastores found:\n" + "\n".join([f"- {store.get('name')}" for store in stores])
        if next_cursor:
            output += f"\n\n(Next page cursor: {next_cursor})"
        return output

    except RobloxApiError as e:
        logger.error(f"API Error listing datastores: {e}")
        return f"Error listing datastores: {e}"
    except Exception as e:
        logger.exception("Unexpected error in list_datastores tool.")
        return f"Unexpected server error: {e}"
    finally:
        if client:
            await client.close_session()

@mcp_server.tool()
async def get_datastore_value_in_cloud(ctx: Context, datastore_name: str = Field(..., description="The name of the datastore."),
                        entry_key: str = Field(..., description="The key of the entry to retrieve."),
                        scope: Optional[str] = Field("global", description="The scope of the datastore (defaults to 'global').")) -> str:
    """Gets the value of an entry from a standard datastore via the Roblox Cloud API."""
    logger.info(f"Getting datastore value via Cloud API for key '{entry_key}' from '{datastore_name}' (scope: {scope})")
    client = await _get_roblox_client()
    if not client:
        return "Error: Roblox Client could not be initialized."

    try:
        value = await client.get_datastore_entry(datastore_name=datastore_name, entry_key=entry_key, scope=scope)

        if value is None:
            return f"No entry found for key '{entry_key}' in datastore '{datastore_name}' (scope: {scope})."

        # Format the value nicely
        if isinstance(value, (dict, list)):
            return f"Value for key '{entry_key}':\n{json.dumps(value, indent=2)}"
        else:
            return f"Value for key '{entry_key}': {value}"

    except RobloxApiError as e:
        logger.error(f"API Error getting datastore value: {e}")
        return f"Error getting value for key '{entry_key}': {e}"
    except Exception as e:
        logger.exception("Unexpected error in get_datastore_value tool.")
        return f"Unexpected server error: {e}"
    finally:
        if client:
            await client.close_session()

@mcp_server.tool()
async def set_datastore_value_in_cloud(ctx: Context, datastore_name: str = Field(..., description="The name of the datastore."),
                        entry_key: str = Field(..., description="The key of the entry to set."),
                        value: Any = Field(..., description="The JSON-serializable value to store."),
                        scope: Optional[str] = Field("global", description="The scope (defaults to 'global')."),
                       ) -> str:
    """Sets the value for an entry in a standard datastore via the Roblox Cloud API."""
    logger.info(f"Setting datastore value via Cloud API for key '{entry_key}' in '{datastore_name}' (scope: {scope})")
    client = await _get_roblox_client()
    if not client:
        return "Error: Roblox Client could not be initialized."

    try:
        result = await client.set_datastore_entry(datastore_name=datastore_name, entry_key=entry_key, value=value, scope=scope)
        version = result.get("version")
        return f"Successfully set value for key '{entry_key}'. New version: {version}"

    except RobloxApiError as e:
        logger.error(f"API Error setting datastore value: {e}")
        return f"Error setting value for key '{entry_key}': {e}"
    except ValueError as e: # Handles non-JSON serializable value from client method
         return f"Error setting value: {e}"
    except Exception as e:
        logger.exception("Unexpected error in set_datastore_value tool.")
        return f"Unexpected server error: {e}"
    finally:
        if client:
            await client.close_session()

@mcp_server.tool()
async def delete_datastore_value_in_cloud(ctx: Context, datastore_name: str = Field(..., description="The name of the datastore."),
                           entry_key: str = Field(..., description="The key of the entry to delete."),
                           scope: Optional[str] = Field("global", description="The scope (defaults to 'global').")) -> str:
    """Deletes an entry from a standard datastore via the Roblox Cloud API."""
    logger.info(f"Deleting datastore key via Cloud API: '{entry_key}' from '{datastore_name}' (scope: {scope})")
    client = await _get_roblox_client()
    if not client:
        return "Error: Roblox Client could not be initialized."

    try:
        await client.delete_datastore_entry(datastore_name=datastore_name, entry_key=entry_key, scope=scope)
        return f"Successfully deleted entry '{entry_key}' from datastore '{datastore_name}'."
    except RobloxApiError as e:
        # Check if it was a 404 (key didn't exist anyway)
        if e.status_code == 404:
             logger.info(f"Attempted to delete non-existent key '{entry_key}'.")
             return f"Entry '{entry_key}' did not exist in datastore '{datastore_name}'."
        logger.error(f"API Error deleting datastore value: {e}")
        return f"Error deleting value for key '{entry_key}': {e}"
    except Exception as e:
        logger.exception("Unexpected error in delete_datastore_value tool.")
        return f"Unexpected server error: {e}"
    finally:
        if client:
            await client.close_session()

@mcp_server.tool()
async def upload_asset_via_cloud(ctx: Context, file_path: str = Field(..., description="Local path to the asset file (e.g., .fbx, .png, .mp3)."),
                   asset_type: str = Field(..., description="Type of asset (e.g., 'Model', 'Image', 'Audio'). Check Roblox docs for valid types."),
                   display_name: str = Field(..., description="Name for the asset in Roblox."),
                   description: Optional[str] = Field("", description="Optional description for the asset.")) -> str:
    """Uploads a file from the local system as a new Roblox asset via the Cloud API."""
    logger.info(f"Uploading asset '{display_name}' ({asset_type}) via Cloud API from '{file_path}'")
    client = await _get_roblox_client()
    if not client:
        return "Error: Roblox Client could not be initialized."

    # Basic validation for asset type (can be expanded based on Roblox API specifics)
    if not re.match(r"^\w+$", asset_type):
         return f"Error: Invalid asset type format: '{asset_type}'"

    try:
        result = await client.upload_asset(file_path=file_path, asset_type=asset_type, display_name=display_name, description=description)
        asset_id = result.get("assetId")
        if asset_id:
            return f"Successfully uploaded asset '{display_name}'. New Asset ID: {asset_id}"
        else:
            # This case should ideally be caught by exceptions in the client
            return f"Error: Asset upload completed but no Asset ID was returned. Result: {result.get('operationResult')}"

    except FileNotFoundError as e:
        return f"Error: File not found at path: {file_path}"
    except RobloxApiError as e:
        logger.error(f"API Error uploading asset: {e}")
        return f"Error uploading asset '{display_name}': {e}"
    except NotImplementedError as e:
        logger.error(f"Asset upload called but not fully implemented in client: {e}")
        return f"Error: Asset upload feature not implemented in client."
    except Exception as e:
        logger.exception("Unexpected error in upload_asset tool.")
        return f"Unexpected server error: {e}"
    finally:
        if client:
            await client.close_session()

@mcp_server.tool()
async def get_asset_details_via_cloud(ctx: Context, asset_id: int = Field(..., description="The ID of the asset to retrieve details for.")) -> str:
    """Gets details about a specific asset via the Roblox Cloud API using its ID."""
    logger.info(f"Getting details via Cloud API for asset ID {asset_id}")
    client = await _get_roblox_client()
    if not client:
        return "Error: Roblox Client could not be initialized."

    try:
        details = await client.get_asset_details(asset_id=asset_id)
        return f"Asset Details for {asset_id}:\n{json.dumps(details, indent=2)}"
    except NotImplementedError:
        return "Error: Get asset details feature is not yet implemented."
    except RobloxApiError as e:
        logger.error(f"API Error getting asset details: {e}")
        return f"Error getting details for asset {asset_id}: {e}"
    except Exception as e:
        logger.exception(f"Unexpected error in get_asset_details tool.")
        return f"Unexpected server error: {e}"
    finally:
        if client:
            await client.close_session()

@mcp_server.tool()
async def list_user_assets_via_cloud(ctx: Context, asset_types: Optional[List[str]] = Field(None, description="Optional list of asset types to filter by (e.g., ['Model', 'Image'])."),
                       limit: Optional[int] = Field(None, description="Maximum number of assets to return."),
                       cursor: Optional[str] = Field(None, description="Pagination cursor.")) -> str:
    """Lists assets owned by the authenticated user via the Roblox Cloud API."""
    logger.info(f"Listing user assets via Cloud API (types: {asset_types}, limit: {limit})")
    client = await _get_roblox_client()
    if not client:
        return "Error: Roblox Client could not be initialized."

    try:
        result = await client.list_assets(asset_types=asset_types, limit=limit, cursor=cursor)
        # Process and format the list result based on actual API response structure
        # Example assuming a structure like {"data": [...], "nextPageCursor": ...}
        assets = result.get("data", []) # Adjust key based on actual response
        next_cursor = result.get("nextPageCursor")

        if not assets:
            return "No assets found matching the criteria."

        # Adjust formatting based on details available in the list response
        output = "User Assets Found:\n" + "\n".join([f"- ID: {asset.get('assetId', 'N/A')}, Name: {asset.get('name', 'N/A')}, Type: {asset.get('type', 'N/A')}" for asset in assets])
        if next_cursor:
            output += f"\n\n(Next page cursor: {next_cursor})"
        return output

    except NotImplementedError:
        return "Error: List user assets feature is not yet implemented."
    except RobloxApiError as e:
        logger.error(f"API Error listing assets: {e}")
        return f"Error listing user assets: {e}"
    except Exception as e:
        logger.exception("Unexpected error in list_user_assets tool.")
        return f"Unexpected server error: {e}"
    finally:
        if client:
            await client.close_session()

@mcp_server.tool()
async def publish_place_via_cloud(ctx: Context, target_place_id: Optional[int] = Field(None, description="Optional Place ID to publish. Defaults to configured Place ID."),
                    version_type: str = Field("Saved", description="Version type to publish: 'Saved' or 'Published'.")) -> str:
    """Publishes the specified place via the Roblox Cloud API."""
    logger.info(f"Publishing place via Cloud API (ID: {target_place_id or 'default'}, Type: {version_type})")
    client = await _get_roblox_client()
    if not client:
        return "Error: Roblox Client could not be initialized."

    try:
        result = await client.publish_place(target_place_id=target_place_id, version_type=version_type)
        version_number = result.get("versionNumber")
        place_id_used = target_place_id or (client.place_id if client else 'N/A') # Added client check
        if version_number:
            return f"Successfully published place {place_id_used}. New version number: {version_number}"
        else:
            return f"Place {place_id_used} published, but version number not found in response: {result}"

    except RobloxApiError as e:
        logger.error(f"API Error publishing place: {e}")
        return f"Error publishing place: {e}"
    except ValueError as e: # Catches invalid version_type from client
         return f"Error: {e}"
    except Exception as e:
        logger.exception("Unexpected error in publish_place tool.")
        return f"Unexpected server error: {e}"
    finally:
        if client:
            await client.close_session()

@mcp_server.tool()
async def set_environment(ctx: Context,
                      properties: Dict[str, Any] = Field(..., description="Dictionary of properties to set on the Lighting service or Terrain.")) -> str:
    """Sets properties on environment services like Lighting or Terrain."""
    logger.info(f"Setting environment properties: {properties}")
    
    # Determine target service based on properties
    target = "Lighting"
    terrain_props = ["WaterColor", "WaterWaveSize", "WaterWaveSpeed", "WaterReflectance", "WaterTransparency"]
    if any(prop in properties for prop in terrain_props):
        target = "Terrain"
    
    try:
        # Check for invalid property names 
        for key in properties.keys():
            if not re.match(r"^\w+$", key):
                return f"Error: Invalid property name format: {key}"
        
        # Create command for the plugin
        command = {
            "action": "set_environment",
            "data": {
                "target": target,
                "properties": properties
            }
        }
        
        # Queue the command and wait for result
        result = await queue_command_and_wait(command)
        
        # Process the result
        if "error" in result:
            return f"Error setting environment properties on {target}: {result['error']}"
        elif "errors" in result and result["errors"]:
            error_str = json.dumps(result["errors"])
            logger.error(f"set_environment reported errors: {error_str}")
            return f"Error setting some environment properties on {target}: {error_str}"
        elif "success" in result and result["success"]:
            return f"Successfully set environment properties on {target}. (Note: Changes may not persist)"
        else:
            return f"Error: Unexpected result format from plugin while setting environment properties."

    except TimeoutError:
        return f"Error: Timeout waiting for Studio plugin to set environment properties."
    except ValueError as e:
        return f"Error: {e}"
    except Exception as e:
        logger.exception("Unexpected error in set_environment tool.")
        return f"Unexpected server error: {e}"

@mcp_server.tool()
async def spawn_npc(ctx: Context, model_asset_id: Optional[int] = Field(None, description="Asset ID of the NPC model to insert from Roblox library."),
                template_model_name: Optional[str] = Field(None, description="Name of an existing model in the place (e.g., in ServerStorage) to clone as the NPC."),
                position: Optional[List[float]] = Field([0,5,0], description="Position [X, Y, Z] where the NPC should be spawned."),
                parent_name: str = Field("Workspace", description="Parent object for the spawned NPC (defaults to Workspace)."),
                new_name: Optional[str] = Field(None, description="Optional name for the spawned NPC instance.")) -> str:
    """Spawns an NPC in the workspace, either by inserting a model from asset ID or cloning an existing template model."""
    logger.info(f"Spawning NPC (AssetID: {model_asset_id}, Template: {template_model_name}, Name: {new_name})")
    
    if not model_asset_id and not template_model_name:
        return "Error: Must provide either model_asset_id or template_model_name to spawn NPC."
    
    if model_asset_id and template_model_name:
        logger.warning("Both model_asset_id and template_model_name provided, using model_asset_id.")
        template_model_name = None  # Prioritize asset ID
    
    try:
        # Convert position to dictionary format expected by the plugin
        position_dict = None
        if position and len(position) == 3:
            position_dict = {
                "x": float(position[0]),
                "y": float(position[1]),
                "z": float(position[2])
            }
        
        # Create command for the plugin
        command = {
            "action": "spawn_npc",
            "data": {
                "model_asset_id": model_asset_id,
                "template_model_name": template_model_name,
                "position": position_dict,
                "parent_name": parent_name,
                "new_name": new_name
            }
        }
        
        # Queue the command and wait for result
        result = await queue_command_and_wait(command)
        
        # Process the result
        if "error" in result:
            return f"Error spawning NPC: {result['error']}"
        elif "success" in result and result["success"]:
            msg = f"Successfully spawned NPC '{result.get('name', 'unnamed')}' at '{result.get('path', 'unknown path')}'."
            if result.get('warning'):
                msg += f" Warning: {result['warning']}"
            if result.get('position_error'):
                msg += f" Position Error: {result['position_error']}"
            return msg
        else:
            return f"Error: Unexpected result format from plugin while spawning NPC."

    except TimeoutError:
        return f"Error: Timeout waiting for Studio plugin to spawn NPC."
    except ValueError as e:
        return f"Error: {e}"
    except Exception as e:
        logger.exception("Unexpected error in spawn_npc tool.")
        return f"Unexpected server error: {e}"

@mcp_server.tool()
async def play_animation(ctx: Context, target_name: str = Field(..., description="Name or path of the object with Humanoid or AnimationController (e.g., player character, NPC)."),
                     animation_id: int = Field(..., description="Asset ID of the Animation to play.")) -> str:
    """Loads and plays an animation on a target object's Humanoid or AnimationController."""
    logger.info(f"Playing animation {animation_id} on target '{target_name}'")
    
    try:
        # Create command for the plugin
        command = {
            "action": "play_animation",
            "data": {
                "target_name": target_name,
                "animation_id": animation_id
            }
        }
        
        # Queue the command and wait for result
        result = await queue_command_and_wait(command)
        
        # Process the result
        if "error" in result:
            return f"Error playing animation: {result['error']}"
        elif "success" in result and result["success"]:
            return f"Successfully played animation {animation_id} on '{target_name}'. {result.get('message', '')}"
        else:
            return f"Error: Unexpected result format from plugin while playing animation."

    except TimeoutError:
        return f"Error: Timeout waiting for Studio plugin to play animation on '{target_name}'."
    except ValueError as e:
        return f"Error: {e}"
    except Exception as e:
        logger.exception("Unexpected error in play_animation tool.")
        return f"Unexpected server error: {e}"

@mcp_server.tool()
async def send_chat_via_cloud(ctx: Context, message: str = Field(..., description="The chat message content."),
                sender_name: Optional[str] = Field(None, description="Optional name of the player or system sending the message (uses default if None).")) -> str:
    """Sends a message to the in-game chat via the Roblox Cloud API (execute_luau).
       Note: Functionality depends heavily on the game's chat setup and requires TextChatService.
    """
    logger.info(f"Sending chat message via Cloud API: '{message}' (from: {sender_name or 'System'})")
    client = await _get_roblox_client()
    if not client:
        return "Error: Roblox Client could not be initialized."

    try:
        lua_message = escape_lua_string(message)
        # Sender logic needs refinement based on desired behavior (system vs player)
        lua_sender_logic = "nil -- Use default sender"
        if sender_name:
            # Find player or create fake sender? This part is complex.
            # For simplicity, let's assume a basic system message for now.
            lua_sender_logic = f"{{ Name = {escape_lua_string(sender_name)}, UserId = 0 }} -- Placeholder sender"
            logger.warning("send_chat sender logic is simplified.")

        script = f"""
        local httpService = game:GetService("HttpService")
        local result = {{success=false}}
        local textChatService = game:GetService("TextChatService")
        if textChatService then
            local channel = textChatService:FindFirstChild("RBXSystem") -- Or find appropriate channel
            if channel and channel:IsA("TextChannel") then
                local success_send, err_send = pcall(function()
                    -- Send message (API might change)
                    channel:SendAsync({lua_message})
                    -- Older/Alternative: channel:DisplaySystemMessage(message)
                end)
                result.success = success_send
                if not success_send then result.error = "Failed to send message: " .. tostring(err_send) end
            else
                 result.error = "Could not find suitable TextChannel (e.g., RBXSystem)."
            end
        else
            result.error = "TextChatService not found."
        end
        print(httpService:JSONEncode(result))
        """

        exec_result = await execute_luau_in_cloud(ctx, script=script)

        # Parse result
        script_output_obj = exec_result.get("output", {})
        if isinstance(script_output_obj, dict):
            if script_output_obj.get("success"):
                 return f"Chat message sent successfully."
            else:
                  return f"Error sending chat: {script_output_obj.get('error', 'Script reported failure')}"
        else:
             if exec_result.get("error"):
                  error_info = exec_result["error"]
                  error_msg = error_info.get('message', json.dumps(error_info))
                  return f"Error executing send chat script: {error_msg}"
             else:
                 raw = script_output_obj.get("raw_output", str(script_output_obj))
                 return f"Error: Could not parse status from send chat script output: {raw}"

    except RobloxApiError as e:
        logger.error(f"API Error sending chat: {e}")
        if "Luau script execution error" in str(e) and e.response_data:
             return f"Error sending chat message: {e.response_data.get('message', json.dumps(e.response_data))}"
        return f"Error sending chat message: {e}"
    except ValueError as e:
         return f"Error: {e}"
    except Exception as e:
        logger.exception("Unexpected error in send_chat tool.")
        return f"Unexpected server error: {e}"
    finally:
        if client:
            await client.close_session()

@mcp_server.tool()
async def teleport_player_via_cloud(ctx: Context, player_name: str = Field(..., description="The exact name of the Player to teleport."),
                      destination_place_id: int = Field(..., description="The Place ID to teleport the player to."),
                      teleport_options: Optional[Dict[str, Any]] = Field(None, description="Optional TeleportOptions dictionary."),
                      custom_loading_script: Optional[str] = Field(None, description="Optional LocalScript name (in ReplicatedFirst) for custom loading screen.")) -> str:
    """Teleports a player via the Roblox Cloud API (execute_luau).
       Requires TeleportService.
    """
    logger.info(f"Teleporting player via Cloud API: '{player_name}' to place {destination_place_id}")
    client = await _get_roblox_client()
    if not client:
        return "Error: Roblox Client could not be initialized."

    try:
        lua_player_name = escape_lua_string(player_name)
        lua_options = value_to_lua_string(teleport_options) if teleport_options else "nil"
        lua_loading_script = f"game:GetService(\"ReplicatedFirst\"):FindFirstChild({escape_lua_string(custom_loading_script)})" if custom_loading_script else "nil"

        script = f"""
        local httpService = game:GetService("HttpService")
        local result = {{success=false}}
        local teleportService = game:GetService("TeleportService")
        local playersService = game:GetService("Players")
        local player = playersService:FindFirstChild({lua_player_name})

        if not teleportService then result.error = "TeleportService not found."
        elseif not player then result.error = "Player '{player_name}' not found."
        else
            local options = {lua_options}
            local loadingScript = {lua_loading_script}

            local success_tp, err_tp = pcall(function()
                teleportService:TeleportAsync({destination_place_id}, {{player}}, options, loadingScript)
            end)
            result.success = success_tp
            if not success_tp then result.error = "Teleport failed: " .. tostring(err_tp) end
        end
        print(httpService:JSONEncode(result))
        """

        exec_result = await execute_luau_in_cloud(ctx, script=script)

        # Parse result
        script_output_obj = exec_result.get("output", {})
        if isinstance(script_output_obj, dict):
            if script_output_obj.get("success"):
                 return f"Teleport initiated for player '{player_name}' to place {destination_place_id}."
            else:
                  return f"Error teleporting player: {script_output_obj.get('error', 'Script reported failure')}"
        else:
             if exec_result.get("error"):
                  error_info = exec_result["error"]
                  error_msg = error_info.get('message', json.dumps(error_info))
                  return f"Error executing teleport script: {error_msg}"
             else:
                 raw = script_output_obj.get("raw_output", str(script_output_obj))
                 return f"Error: Could not parse status from teleport script output: {raw}"

    except RobloxApiError as e:
        logger.error(f"API Error teleporting player: {e}")
        if "Luau script execution error" in str(e) and e.response_data:
             return f"Error teleporting player '{player_name}': {e.response_data.get('message', json.dumps(e.response_data))}"
        return f"Error teleporting player '{player_name}': {e}"
    except ValueError as e:
         return f"Error: {e}"
    except Exception as e:
        logger.exception("Unexpected error in teleport_player tool.")
        return f"Unexpected server error: {e}"
    finally:
        if client:
            await client.close_session()

@mcp_server.tool()
async def get_studio_logs(ctx: Context) -> List[Dict[str, Any]]: # REMOVED random_string parameter AGAIN
    """Retrieves the most recent logs captured from the Roblox Studio Output window."""
    # The random_string parameter caused issues, removed it again. Tool schema might be inconsistent.
    global studio_log_buffer
    
    safe_limit = 200 # Default to max buffer size now
    
    current_logs = list(studio_log_buffer) # Get a snapshot
    log_slice = current_logs[-safe_limit:]
    
    formatted_logs = [log_data for server_ts, log_data in log_slice]
    
    logger.info(f"Returning last {len(formatted_logs)} studio logs (limit: {safe_limit}).") 
    return formatted_logs

# --- Helper Function to Queue Command and Prepare for Result ---
async def queue_command_and_wait(command: Dict[str, Any], timeout: float = 20.0) -> Any: # <<< CHANGE: Increased default timeout >>>
    """
    Queues a command, adds a request_id, and waits for the result via /plugin_report_result.
    Returns the result or raises TimeoutError.
    """
    global plugin_command_queue, pending_plugin_results, plugin_results_lock
    
    request_id = str(uuid.uuid4())
    command_with_id = {**command, "request_id": request_id} # Add request_id to command
    
    try:
        # Initialize pending result entry
        with plugin_results_lock:
            pending_plugin_results[request_id] = None # Mark as pending

        # Queue the command
        plugin_command_queue.append(command_with_id)
        logger.info(f"Queued command with request_id {request_id}: {command_with_id}")

        # Wait for the result
        start_time = time.monotonic()
        while time.monotonic() < start_time + timeout:
            with plugin_results_lock:
                result = pending_plugin_results.get(request_id)
            
            if result is not None:
                logger.info(f"Result received for request_id {request_id}")
                # Clean up the entry
                with plugin_results_lock:
                    del pending_plugin_results[request_id]
                return result # Return the actual result data
            
            await asyncio.sleep(0.1) # Small sleep to prevent busy-waiting

        # Timeout occurred
        logger.warning(f"Timeout waiting for result for request_id {request_id}")
        # Clean up the pending entry on timeout
        with plugin_results_lock:
            if request_id in pending_plugin_results:
                del pending_plugin_results[request_id]
        raise TimeoutError(f"Timeout waiting for plugin result for request_id {request_id}")

    except Exception as e:
        logger.exception(f"Error in queue_command_and_wait for request_id {request_id}")
        # Ensure cleanup even if other errors occur
        with plugin_results_lock:
            if request_id in pending_plugin_results:
                del pending_plugin_results[request_id]
        raise # Re-raise the exception

# --- NEW: Execute Luau in Studio via Plugin --- 
@mcp_server.tool()
async def execute_luau_in_studio(ctx: Context, script_code: str = Field(..., description="The Luau code string to execute directly in the Studio session via the plugin.")) -> str:
    """Executes arbitrary Luau script in the LIVE Studio session via the plugin.
       WARNING: Use with caution. Captures print output, return values, and errors.
    """
    logger.info(f"Executing Luau script in Studio via Plugin (first 100 chars): {script_code[:100]}...")

    command = {
        "action": "execute_script_in_studio",
        "data": {
            "script_code": script_code
        }
    }

    try:
        # Use the helper to queue and wait (use a potentially longer timeout for scripts)
        result_data = await queue_command_and_wait(command, timeout=30.0) 

        logger.info(f"Received result for execute_luau_in_studio: {result_data}")

        # --- Result Processing --- 
        if isinstance(result_data, dict):
            output_lines = result_data.get("output_lines", [])
            return_values = result_data.get("return_values") # Could be None or a list
            error_msg = result_data.get("error_message")

            output_str = "-- Execute Luau in Studio Result --\n"
            
            # Add captured output
            if output_lines:
                output_str += "\n[Output]:\n"
                output_str += "\n".join(output_lines)
                output_str += "\n"
            else:
                 output_str += "\n[No Output Captured]"
                 
            # Add return values (nicely formatted)
            if return_values is not None:
                 try:
                     return_str = json.dumps(return_values, indent=2)
                     output_str += "\n[Return Values]:\n" + return_str + "\n"
                 except TypeError:
                      output_str += f"\n[Return Values (Raw)]:\n{return_values}\n"
            
            # Add error if present
            if error_msg:
                output_str += f"\n[Error]: {error_msg}\n"
            
            return output_str.strip()
            
        else:
            # Plugin returned something unexpected
            logger.warning(f"Received non-dictionary result from plugin for execute_luau_in_studio: {result_data}")
            return f"Tool: execute_luau_in_studio, Error: Received unexpected result type from plugin: {type(result_data).__name__}"
        # --- End Result Processing --- 

    except TimeoutError as e:
        logger.error(f"Timeout waiting for execute_luau_in_studio result: {e}")
        return f"Tool: execute_luau_in_studio, Error: Timeout waiting for response from Studio plugin."
    except Exception as e:
        logger.exception("Error executing execute_luau_in_studio tool")
        return f"Tool: execute_luau_in_studio, Error: An unexpected server error occurred: {e}"
# --- END: Execute Luau in Studio via Plugin --- 

# --- NEW: Modify Children Tool --- 
@mcp_server.tool()
async def modify_children(ctx: Context,
                        parent_path: str = Field(..., description="Path to the parent object whose children will be modified."),
                        property_name: str = Field(..., description="The name of the property to set on matching children."),
                        property_value: str = Field(..., description='JSON string for the value to set (same format as set_property: primitives or escaped JSON for complex types, e.g., \'"[1,2,3]"\').'),
                        child_name_filter: Optional[str] = Field(None, description="Optional: Only modify children with this exact name."),
                        child_class_filter: Optional[str] = Field(None, description="Optional: Only modify children of this exact ClassName.")) -> str:
    """Finds direct children under a parent matching optional filters (name/class) and sets a specified property on them."""
    logger.info(f"Modifying children under '{parent_path}' (Name: {child_name_filter or 'Any'}, Class: {child_class_filter or 'Any'}) - Set '{property_name}' from JSON: {property_value}")

    # Basic validation
    if not re.match(r"^[\w.]+$", parent_path):
        return f"Error: Invalid parent path format: {parent_path}"
    if not re.match(r"^\w+$", property_name):
        return f"Error: Invalid property name format: {property_name}"
    if child_name_filter is not None and not isinstance(child_name_filter, str):
         return f"Error: Invalid child_name_filter format (must be string or null)."
    if child_class_filter is not None and not re.match(r"^\w+$", child_class_filter):
         return f"Error: Invalid child_class_filter format: {child_class_filter}"

    try:
        # Parse the JSON string value
        try:
            parsed_value = json.loads(property_value)
            logger.debug(f"Parsed property value: {parsed_value} (Type: {type(parsed_value).__name__})")
        except json.JSONDecodeError as json_err:
            logger.error(f"Invalid JSON string provided for property_value: {property_value} - Error: {json_err}")
            return f"Error: Invalid JSON format for property_value parameter. Details: {json_err}"

        # Create command for the plugin
        command = {
            "action": "modify_children",
            "data": {
                "parent_path": parent_path,
                "property_name": property_name,
                "property_value": parsed_value, # Send parsed value
                "child_name_filter": child_name_filter,
                "child_class_filter": child_class_filter
            }
        }

        # Queue the command and wait for result
        result = await queue_command_and_wait(command, timeout=60.0) # Longer timeout for potentially many children

        # Process the result
        if "error_message" in result: # Check for fatal error first
            return f"Error modifying children under '{parent_path}': {result['error_message']}"
        elif "affected_count" in result:
            affected_count = result.get("affected_count", 0)
            errors = result.get("errors", [])
            msg = f"Successfully modified {affected_count} children under '{parent_path}' matching criteria."
            if errors:
                msg += f" Encountered {len(errors)} errors during modification: {errors[:5]}..." # Show first few errors
                logger.warning(f"modify_children reported errors: {errors}")
            return msg
        else:
            return f"Error: Unexpected result format from plugin while modifying children."

    except TimeoutError:
        return f"Error: Timeout waiting for Studio plugin to modify children under '{parent_path}'."
    except ValueError as e:
        return f"Error: {e}"
    except Exception as e:
        logger.exception("Unexpected error in modify_children tool.")
        return f"Unexpected server error: {e}"
# --- END: Modify Children Tool ---
```

`src/roblox_mcp/sse.py`:

```py
import logging
from mcp.server.fastmcp import FastMCP
from mcp.server.sse import SseServerTransport
from starlette.applications import Starlette
from starlette.routing import Mount, Route

logger = logging.getLogger(__name__)

def create_sse_server(mcp: FastMCP):
    """Create a Starlette app that handles SSE connections and message handling for MCP."""
    # Define the base path for message posting (relative to where this app is mounted)
    # If mounted at '/', messages go to /messages/
    # If mounted at '/mcp_sse', messages go to /mcp_sse/messages/
    message_post_path = "/messages/"
    transport = SseServerTransport(message_post_path)

    # Define handler function for the SSE connection endpoint
    async def handle_sse(request):
        logger.info(f"SSE connection established from {request.client}")
        try:
            async with transport.connect_sse(
                request.scope, request.receive, request._send
            ) as streams:
                # Run the core MCP server logic using the streams provided by the SSE transport
                await mcp._mcp_server.run(
                    streams[0], streams[1], mcp._mcp_server.create_initialization_options()
                )
        except Exception as e:
            logger.error(f"Error during SSE MCP session: {e}", exc_info=True)
        finally:
            logger.info(f"SSE connection closed for {request.client}")


    # Create Starlette routes
    # The '/sse/' endpoint handles the initial GET request to establish the SSE connection.
    # The '/messages/' endpoint handles the POST requests from the client to send MCP messages *after* the SSE connection is up.
    routes = [
        Route("/sse/", endpoint=handle_sse),
        Mount(message_post_path, app=transport.handle_post_message),
    ]

    # Create and return the Starlette app dedicated to handling SSE transport
    sse_app = Starlette(routes=routes)
    logger.info(f"Created Starlette SSE transport app with routes: /sse/ (GET), {message_post_path} (POST)")
    return sse_app 
```

`uv.lock`:

```lock
version = 1
revision = 1
requires-python = ">=3.10"

[[package]]
name = "annotated-types"
version = "0.7.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/ee/67/531ea369ba64dcff5ec9c3402f9f51bf748cec26dde048a2f973a4eea7f5/annotated_types-0.7.0.tar.gz", hash = "sha256:aff07c09a53a08bc8cfccb9c85b05f1aa9a2a6f23728d790723543408344ce89", size = 16081 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/78/b6/6307fbef88d9b5ee7421e68d78a9f162e0da4900bc5f5793f6d3d0e34fb8/annotated_types-0.7.0-py3-none-any.whl", hash = "sha256:1f02e8b43a8fbbc3f3e0d4f0f4bfc8131bcb4eebe8849b8e5c773f3a1c582a53", size = 13643 },
]

[[package]]
name = "anyio"
version = "4.9.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "exceptiongroup", marker = "python_full_version < '3.11'" },
    { name = "idna" },
    { name = "sniffio" },
    { name = "typing-extensions", marker = "python_full_version < '3.13'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/95/7d/4c1bd541d4dffa1b52bd83fb8527089e097a106fc90b467a7313b105f840/anyio-4.9.0.tar.gz", hash = "sha256:673c0c244e15788651a4ff38710fea9675823028a6f08a5eda409e0c9840a028", size = 190949 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/a1/ee/48ca1a7c89ffec8b6a0c5d02b89c305671d5ffd8d3c94acf8b8c408575bb/anyio-4.9.0-py3-none-any.whl", hash = "sha256:9f76d541cad6e36af7beb62e978876f3b41e3e04f2c1fbf0884604c0a9c4d93c", size = 100916 },
]

[[package]]
name = "certifi"
version = "2025.4.26"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/e8/9e/c05b3920a3b7d20d3d3310465f50348e5b3694f4f88c6daf736eef3024c4/certifi-2025.4.26.tar.gz", hash = "sha256:0a816057ea3cdefcef70270d2c515e4506bbc954f417fa5ade2021213bb8f0c6", size = 160705 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/4a/7e/3db2bd1b1f9e95f7cddca6d6e75e2f2bd9f51b1246e546d88addca0106bd/certifi-2025.4.26-py3-none-any.whl", hash = "sha256:30350364dfe371162649852c63336a15c70c6510c2ad5015b21c2345311805f3", size = 159618 },
]

[[package]]
name = "charset-normalizer"
version = "3.4.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/16/b0/572805e227f01586461c80e0fd25d65a2115599cc9dad142fee4b747c357/charset_normalizer-3.4.1.tar.gz", hash = "sha256:44251f18cd68a75b56585dd00dae26183e102cd5e0f9f1466e6df5da2ed64ea3", size = 123188 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/0d/58/5580c1716040bc89206c77d8f74418caf82ce519aae06450393ca73475d1/charset_normalizer-3.4.1-cp310-cp310-macosx_10_9_universal2.whl", hash = "sha256:91b36a978b5ae0ee86c394f5a54d6ef44db1de0815eb43de826d41d21e4af3de", size = 198013 },
    { url = "https://files.pythonhosted.org/packages/d0/11/00341177ae71c6f5159a08168bcb98c6e6d196d372c94511f9f6c9afe0c6/charset_normalizer-3.4.1-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:7461baadb4dc00fd9e0acbe254e3d7d2112e7f92ced2adc96e54ef6501c5f176", size = 141285 },
    { url = "https://files.pythonhosted.org/packages/01/09/11d684ea5819e5a8f5100fb0b38cf8d02b514746607934134d31233e02c8/charset_normalizer-3.4.1-cp310-cp310-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:e218488cd232553829be0664c2292d3af2eeeb94b32bea483cf79ac6a694e037", size = 151449 },
    { url = "https://files.pythonhosted.org/packages/08/06/9f5a12939db324d905dc1f70591ae7d7898d030d7662f0d426e2286f68c9/charset_normalizer-3.4.1-cp310-cp310-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:80ed5e856eb7f30115aaf94e4a08114ccc8813e6ed1b5efa74f9f82e8509858f", size = 143892 },
    { url = "https://files.pythonhosted.org/packages/93/62/5e89cdfe04584cb7f4d36003ffa2936681b03ecc0754f8e969c2becb7e24/charset_normalizer-3.4.1-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:b010a7a4fd316c3c484d482922d13044979e78d1861f0e0650423144c616a46a", size = 146123 },
    { url = "https://files.pythonhosted.org/packages/a9/ac/ab729a15c516da2ab70a05f8722ecfccc3f04ed7a18e45c75bbbaa347d61/charset_normalizer-3.4.1-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:4532bff1b8421fd0a320463030c7520f56a79c9024a4e88f01c537316019005a", size = 147943 },
    { url = "https://files.pythonhosted.org/packages/03/d2/3f392f23f042615689456e9a274640c1d2e5dd1d52de36ab8f7955f8f050/charset_normalizer-3.4.1-cp310-cp310-musllinux_1_2_aarch64.whl", hash = "sha256:d973f03c0cb71c5ed99037b870f2be986c3c05e63622c017ea9816881d2dd247", size = 142063 },
    { url = "https://files.pythonhosted.org/packages/f2/e3/e20aae5e1039a2cd9b08d9205f52142329f887f8cf70da3650326670bddf/charset_normalizer-3.4.1-cp310-cp310-musllinux_1_2_i686.whl", hash = "sha256:3a3bd0dcd373514dcec91c411ddb9632c0d7d92aed7093b8c3bbb6d69ca74408", size = 150578 },
    { url = "https://files.pythonhosted.org/packages/8d/af/779ad72a4da0aed925e1139d458adc486e61076d7ecdcc09e610ea8678db/charset_normalizer-3.4.1-cp310-cp310-musllinux_1_2_ppc64le.whl", hash = "sha256:d9c3cdf5390dcd29aa8056d13e8e99526cda0305acc038b96b30352aff5ff2bb", size = 153629 },
    { url = "https://files.pythonhosted.org/packages/c2/b6/7aa450b278e7aa92cf7732140bfd8be21f5f29d5bf334ae987c945276639/charset_normalizer-3.4.1-cp310-cp310-musllinux_1_2_s390x.whl", hash = "sha256:2bdfe3ac2e1bbe5b59a1a63721eb3b95fc9b6817ae4a46debbb4e11f6232428d", size = 150778 },
    { url = "https://files.pythonhosted.org/packages/39/f4/d9f4f712d0951dcbfd42920d3db81b00dd23b6ab520419626f4023334056/charset_normalizer-3.4.1-cp310-cp310-musllinux_1_2_x86_64.whl", hash = "sha256:eab677309cdb30d047996b36d34caeda1dc91149e4fdca0b1a039b3f79d9a807", size = 146453 },
    { url = "https://files.pythonhosted.org/packages/49/2b/999d0314e4ee0cff3cb83e6bc9aeddd397eeed693edb4facb901eb8fbb69/charset_normalizer-3.4.1-cp310-cp310-win32.whl", hash = "sha256:c0429126cf75e16c4f0ad00ee0eae4242dc652290f940152ca8c75c3a4b6ee8f", size = 95479 },
    { url = "https://files.pythonhosted.org/packages/2d/ce/3cbed41cff67e455a386fb5e5dd8906cdda2ed92fbc6297921f2e4419309/charset_normalizer-3.4.1-cp310-cp310-win_amd64.whl", hash = "sha256:9f0b8b1c6d84c8034a44893aba5e767bf9c7a211e313a9605d9c617d7083829f", size = 102790 },
    { url = "https://files.pythonhosted.org/packages/72/80/41ef5d5a7935d2d3a773e3eaebf0a9350542f2cab4eac59a7a4741fbbbbe/charset_normalizer-3.4.1-cp311-cp311-macosx_10_9_universal2.whl", hash = "sha256:8bfa33f4f2672964266e940dd22a195989ba31669bd84629f05fab3ef4e2d125", size = 194995 },
    { url = "https://files.pythonhosted.org/packages/7a/28/0b9fefa7b8b080ec492110af6d88aa3dea91c464b17d53474b6e9ba5d2c5/charset_normalizer-3.4.1-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:28bf57629c75e810b6ae989f03c0828d64d6b26a5e205535585f96093e405ed1", size = 139471 },
    { url = "https://files.pythonhosted.org/packages/71/64/d24ab1a997efb06402e3fc07317e94da358e2585165930d9d59ad45fcae2/charset_normalizer-3.4.1-cp311-cp311-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:f08ff5e948271dc7e18a35641d2f11a4cd8dfd5634f55228b691e62b37125eb3", size = 149831 },
    { url = "https://files.pythonhosted.org/packages/37/ed/be39e5258e198655240db5e19e0b11379163ad7070962d6b0c87ed2c4d39/charset_normalizer-3.4.1-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:234ac59ea147c59ee4da87a0c0f098e9c8d169f4dc2a159ef720f1a61bbe27cd", size = 142335 },
    { url = "https://files.pythonhosted.org/packages/88/83/489e9504711fa05d8dde1574996408026bdbdbd938f23be67deebb5eca92/charset_normalizer-3.4.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:fd4ec41f914fa74ad1b8304bbc634b3de73d2a0889bd32076342a573e0779e00", size = 143862 },
    { url = "https://files.pythonhosted.org/packages/c6/c7/32da20821cf387b759ad24627a9aca289d2822de929b8a41b6241767b461/charset_normalizer-3.4.1-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:eea6ee1db730b3483adf394ea72f808b6e18cf3cb6454b4d86e04fa8c4327a12", size = 145673 },
    { url = "https://files.pythonhosted.org/packages/68/85/f4288e96039abdd5aeb5c546fa20a37b50da71b5cf01e75e87f16cd43304/charset_normalizer-3.4.1-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:c96836c97b1238e9c9e3fe90844c947d5afbf4f4c92762679acfe19927d81d77", size = 140211 },
    { url = "https://files.pythonhosted.org/packages/28/a3/a42e70d03cbdabc18997baf4f0227c73591a08041c149e710045c281f97b/charset_normalizer-3.4.1-cp311-cp311-musllinux_1_2_i686.whl", hash = "sha256:4d86f7aff21ee58f26dcf5ae81a9addbd914115cdebcbb2217e4f0ed8982e146", size = 148039 },
    { url = "https://files.pythonhosted.org/packages/85/e4/65699e8ab3014ecbe6f5c71d1a55d810fb716bbfd74f6283d5c2aa87febf/charset_normalizer-3.4.1-cp311-cp311-musllinux_1_2_ppc64le.whl", hash = "sha256:09b5e6733cbd160dcc09589227187e242a30a49ca5cefa5a7edd3f9d19ed53fd", size = 151939 },
    { url = "https://files.pythonhosted.org/packages/b1/82/8e9fe624cc5374193de6860aba3ea8070f584c8565ee77c168ec13274bd2/charset_normalizer-3.4.1-cp311-cp311-musllinux_1_2_s390x.whl", hash = "sha256:5777ee0881f9499ed0f71cc82cf873d9a0ca8af166dfa0af8ec4e675b7df48e6", size = 149075 },
    { url = "https://files.pythonhosted.org/packages/3d/7b/82865ba54c765560c8433f65e8acb9217cb839a9e32b42af4aa8e945870f/charset_normalizer-3.4.1-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:237bdbe6159cff53b4f24f397d43c6336c6b0b42affbe857970cefbb620911c8", size = 144340 },
    { url = "https://files.pythonhosted.org/packages/b5/b6/9674a4b7d4d99a0d2df9b215da766ee682718f88055751e1e5e753c82db0/charset_normalizer-3.4.1-cp311-cp311-win32.whl", hash = "sha256:8417cb1f36cc0bc7eaba8ccb0e04d55f0ee52df06df3ad55259b9a323555fc8b", size = 95205 },
    { url = "https://files.pythonhosted.org/packages/1e/ab/45b180e175de4402dcf7547e4fb617283bae54ce35c27930a6f35b6bef15/charset_normalizer-3.4.1-cp311-cp311-win_amd64.whl", hash = "sha256:d7f50a1f8c450f3925cb367d011448c39239bb3eb4117c36a6d354794de4ce76", size = 102441 },
    { url = "https://files.pythonhosted.org/packages/0a/9a/dd1e1cdceb841925b7798369a09279bd1cf183cef0f9ddf15a3a6502ee45/charset_normalizer-3.4.1-cp312-cp312-macosx_10_13_universal2.whl", hash = "sha256:73d94b58ec7fecbc7366247d3b0b10a21681004153238750bb67bd9012414545", size = 196105 },
    { url = "https://files.pythonhosted.org/packages/d3/8c/90bfabf8c4809ecb648f39794cf2a84ff2e7d2a6cf159fe68d9a26160467/charset_normalizer-3.4.1-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:dad3e487649f498dd991eeb901125411559b22e8d7ab25d3aeb1af367df5efd7", size = 140404 },
    { url = "https://files.pythonhosted.org/packages/ad/8f/e410d57c721945ea3b4f1a04b74f70ce8fa800d393d72899f0a40526401f/charset_normalizer-3.4.1-cp312-cp312-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:c30197aa96e8eed02200a83fba2657b4c3acd0f0aa4bdc9f6c1af8e8962e0757", size = 150423 },
    { url = "https://files.pythonhosted.org/packages/f0/b8/e6825e25deb691ff98cf5c9072ee0605dc2acfca98af70c2d1b1bc75190d/charset_normalizer-3.4.1-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:2369eea1ee4a7610a860d88f268eb39b95cb588acd7235e02fd5a5601773d4fa", size = 143184 },
    { url = "https://files.pythonhosted.org/packages/3e/a2/513f6cbe752421f16d969e32f3583762bfd583848b763913ddab8d9bfd4f/charset_normalizer-3.4.1-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:bc2722592d8998c870fa4e290c2eec2c1569b87fe58618e67d38b4665dfa680d", size = 145268 },
    { url = "https://files.pythonhosted.org/packages/74/94/8a5277664f27c3c438546f3eb53b33f5b19568eb7424736bdc440a88a31f/charset_normalizer-3.4.1-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:ffc9202a29ab3920fa812879e95a9e78b2465fd10be7fcbd042899695d75e616", size = 147601 },
    { url = "https://files.pythonhosted.org/packages/7c/5f/6d352c51ee763623a98e31194823518e09bfa48be2a7e8383cf691bbb3d0/charset_normalizer-3.4.1-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:804a4d582ba6e5b747c625bf1255e6b1507465494a40a2130978bda7b932c90b", size = 141098 },
    { url = "https://files.pythonhosted.org/packages/78/d4/f5704cb629ba5ab16d1d3d741396aec6dc3ca2b67757c45b0599bb010478/charset_normalizer-3.4.1-cp312-cp312-musllinux_1_2_i686.whl", hash = "sha256:0f55e69f030f7163dffe9fd0752b32f070566451afe180f99dbeeb81f511ad8d", size = 149520 },
    { url = "https://files.pythonhosted.org/packages/c5/96/64120b1d02b81785f222b976c0fb79a35875457fa9bb40827678e54d1bc8/charset_normalizer-3.4.1-cp312-cp312-musllinux_1_2_ppc64le.whl", hash = "sha256:c4c3e6da02df6fa1410a7680bd3f63d4f710232d3139089536310d027950696a", size = 152852 },
    { url = "https://files.pythonhosted.org/packages/84/c9/98e3732278a99f47d487fd3468bc60b882920cef29d1fa6ca460a1fdf4e6/charset_normalizer-3.4.1-cp312-cp312-musllinux_1_2_s390x.whl", hash = "sha256:5df196eb874dae23dcfb968c83d4f8fdccb333330fe1fc278ac5ceeb101003a9", size = 150488 },
    { url = "https://files.pythonhosted.org/packages/13/0e/9c8d4cb99c98c1007cc11eda969ebfe837bbbd0acdb4736d228ccaabcd22/charset_normalizer-3.4.1-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:e358e64305fe12299a08e08978f51fc21fac060dcfcddd95453eabe5b93ed0e1", size = 146192 },
    { url = "https://files.pythonhosted.org/packages/b2/21/2b6b5b860781a0b49427309cb8670785aa543fb2178de875b87b9cc97746/charset_normalizer-3.4.1-cp312-cp312-win32.whl", hash = "sha256:9b23ca7ef998bc739bf6ffc077c2116917eabcc901f88da1b9856b210ef63f35", size = 95550 },
    { url = "https://files.pythonhosted.org/packages/21/5b/1b390b03b1d16c7e382b561c5329f83cc06623916aab983e8ab9239c7d5c/charset_normalizer-3.4.1-cp312-cp312-win_amd64.whl", hash = "sha256:6ff8a4a60c227ad87030d76e99cd1698345d4491638dfa6673027c48b3cd395f", size = 102785 },
    { url = "https://files.pythonhosted.org/packages/38/94/ce8e6f63d18049672c76d07d119304e1e2d7c6098f0841b51c666e9f44a0/charset_normalizer-3.4.1-cp313-cp313-macosx_10_13_universal2.whl", hash = "sha256:aabfa34badd18f1da5ec1bc2715cadc8dca465868a4e73a0173466b688f29dda", size = 195698 },
    { url = "https://files.pythonhosted.org/packages/24/2e/dfdd9770664aae179a96561cc6952ff08f9a8cd09a908f259a9dfa063568/charset_normalizer-3.4.1-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:22e14b5d70560b8dd51ec22863f370d1e595ac3d024cb8ad7d308b4cd95f8313", size = 140162 },
    { url = "https://files.pythonhosted.org/packages/24/4e/f646b9093cff8fc86f2d60af2de4dc17c759de9d554f130b140ea4738ca6/charset_normalizer-3.4.1-cp313-cp313-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:8436c508b408b82d87dc5f62496973a1805cd46727c34440b0d29d8a2f50a6c9", size = 150263 },
    { url = "https://files.pythonhosted.org/packages/5e/67/2937f8d548c3ef6e2f9aab0f6e21001056f692d43282b165e7c56023e6dd/charset_normalizer-3.4.1-cp313-cp313-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:2d074908e1aecee37a7635990b2c6d504cd4766c7bc9fc86d63f9c09af3fa11b", size = 142966 },
    { url = "https://files.pythonhosted.org/packages/52/ed/b7f4f07de100bdb95c1756d3a4d17b90c1a3c53715c1a476f8738058e0fa/charset_normalizer-3.4.1-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:955f8851919303c92343d2f66165294848d57e9bba6cf6e3625485a70a038d11", size = 144992 },
    { url = "https://files.pythonhosted.org/packages/96/2c/d49710a6dbcd3776265f4c923bb73ebe83933dfbaa841c5da850fe0fd20b/charset_normalizer-3.4.1-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:44ecbf16649486d4aebafeaa7ec4c9fed8b88101f4dd612dcaf65d5e815f837f", size = 147162 },
    { url = "https://files.pythonhosted.org/packages/b4/41/35ff1f9a6bd380303dea55e44c4933b4cc3c4850988927d4082ada230273/charset_normalizer-3.4.1-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:0924e81d3d5e70f8126529951dac65c1010cdf117bb75eb02dd12339b57749dd", size = 140972 },
    { url = "https://files.pythonhosted.org/packages/fb/43/c6a0b685fe6910d08ba971f62cd9c3e862a85770395ba5d9cad4fede33ab/charset_normalizer-3.4.1-cp313-cp313-musllinux_1_2_i686.whl", hash = "sha256:2967f74ad52c3b98de4c3b32e1a44e32975e008a9cd2a8cc8966d6a5218c5cb2", size = 149095 },
    { url = "https://files.pythonhosted.org/packages/4c/ff/a9a504662452e2d2878512115638966e75633519ec11f25fca3d2049a94a/charset_normalizer-3.4.1-cp313-cp313-musllinux_1_2_ppc64le.whl", hash = "sha256:c75cb2a3e389853835e84a2d8fb2b81a10645b503eca9bcb98df6b5a43eb8886", size = 152668 },
    { url = "https://files.pythonhosted.org/packages/6c/71/189996b6d9a4b932564701628af5cee6716733e9165af1d5e1b285c530ed/charset_normalizer-3.4.1-cp313-cp313-musllinux_1_2_s390x.whl", hash = "sha256:09b26ae6b1abf0d27570633b2b078a2a20419c99d66fb2823173d73f188ce601", size = 150073 },
    { url = "https://files.pythonhosted.org/packages/e4/93/946a86ce20790e11312c87c75ba68d5f6ad2208cfb52b2d6a2c32840d922/charset_normalizer-3.4.1-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:fa88b843d6e211393a37219e6a1c1df99d35e8fd90446f1118f4216e307e48cd", size = 145732 },
    { url = "https://files.pythonhosted.org/packages/cd/e5/131d2fb1b0dddafc37be4f3a2fa79aa4c037368be9423061dccadfd90091/charset_normalizer-3.4.1-cp313-cp313-win32.whl", hash = "sha256:eb8178fe3dba6450a3e024e95ac49ed3400e506fd4e9e5c32d30adda88cbd407", size = 95391 },
    { url = "https://files.pythonhosted.org/packages/27/f2/4f9a69cc7712b9b5ad8fdb87039fd89abba997ad5cbe690d1835d40405b0/charset_normalizer-3.4.1-cp313-cp313-win_amd64.whl", hash = "sha256:b1ac5992a838106edb89654e0aebfc24f5848ae2547d22c2c3f66454daa11971", size = 102702 },
    { url = "https://files.pythonhosted.org/packages/0e/f6/65ecc6878a89bb1c23a086ea335ad4bf21a588990c3f535a227b9eea9108/charset_normalizer-3.4.1-py3-none-any.whl", hash = "sha256:d98b1668f06378c6dbefec3b92299716b931cd4e6061f3c875a71ced1780ab85", size = 49767 },
]

[[package]]
name = "click"
version = "8.1.8"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "colorama", marker = "sys_platform == 'win32'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/b9/2e/0090cbf739cee7d23781ad4b89a9894a41538e4fcf4c31dcdd705b78eb8b/click-8.1.8.tar.gz", hash = "sha256:ed53c9d8990d83c2a27deae68e4ee337473f6330c040a31d4225c9574d16096a", size = 226593 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/7e/d4/7ebdbd03970677812aac39c869717059dbb71a4cfc033ca6e5221787892c/click-8.1.8-py3-none-any.whl", hash = "sha256:63c132bbbed01578a06712a2d1f497bb62d9c1c0d329b7903a866228027263b2", size = 98188 },
]

[[package]]
name = "colorama"
version = "0.4.6"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/d8/53/6f443c9a4a8358a93a6792e2acffb9d9d5cb0a5cfd8802644b7b1c9a02e4/colorama-0.4.6.tar.gz", hash = "sha256:08695f5cb7ed6e0531a20572697297273c47b8cae5a63ffc6d6ed5c201be6e44", size = 27697 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/d1/d6/3965ed04c63042e047cb6a3e6ed1a63a35087b6a609aa3a15ed8ac56c221/colorama-0.4.6-py2.py3-none-any.whl", hash = "sha256:4f1d9991f5acc0ca119f9d443620b77f9d6b33703e51011c16baf57afb285fc6", size = 25335 },
]

[[package]]
name = "exceptiongroup"
version = "1.2.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/09/35/2495c4ac46b980e4ca1f6ad6db102322ef3ad2410b79fdde159a4b0f3b92/exceptiongroup-1.2.2.tar.gz", hash = "sha256:47c2edf7c6738fafb49fd34290706d1a1a2f4d1c6df275526b62cbb4aa5393cc", size = 28883 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/02/cc/b7e31358aac6ed1ef2bb790a9746ac2c69bcb3c8588b41616914eb106eaf/exceptiongroup-1.2.2-py3-none-any.whl", hash = "sha256:3111b9d131c238bec2f8f516e123e14ba243563fb135d3fe885990585aa7795b", size = 16453 },
]

[[package]]
name = "h11"
version = "0.16.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/01/ee/02a2c011bdab74c6fb3c75474d40b3052059d95df7e73351460c8588d963/h11-0.16.0.tar.gz", hash = "sha256:4e35b956cf45792e4caa5885e69fba00bdbc6ffafbfa020300e549b208ee5ff1", size = 101250 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/04/4b/29cac41a4d98d144bf5f6d33995617b185d14b22401f75ca86f384e87ff1/h11-0.16.0-py3-none-any.whl", hash = "sha256:63cf8bbe7522de3bf65932fda1d9c2772064ffb3dae62d55932da54b31cb6c86", size = 37515 },
]

[[package]]
name = "httpcore"
version = "1.0.9"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "certifi" },
    { name = "h11" },
]
sdist = { url = "https://files.pythonhosted.org/packages/06/94/82699a10bca87a5556c9c59b5963f2d039dbd239f25bc2a63907a05a14cb/httpcore-1.0.9.tar.gz", hash = "sha256:6e34463af53fd2ab5d807f399a9b45ea31c3dfa2276f15a2c3f00afff6e176e8", size = 85484 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/7e/f5/f66802a942d491edb555dd61e3a9961140fd64c90bce1eafd741609d334d/httpcore-1.0.9-py3-none-any.whl", hash = "sha256:2d400746a40668fc9dec9810239072b40b4484b640a8c38fd654a024c7a1bf55", size = 78784 },
]

[[package]]
name = "httpx"
version = "0.28.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
    { name = "certifi" },
    { name = "httpcore" },
    { name = "idna" },
]
sdist = { url = "https://files.pythonhosted.org/packages/b1/df/48c586a5fe32a0f01324ee087459e112ebb7224f646c0b5023f5e79e9956/httpx-0.28.1.tar.gz", hash = "sha256:75e98c5f16b0f35b567856f597f06ff2270a374470a5c2392242528e3e3e42fc", size = 141406 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/2a/39/e50c7c3a983047577ee07d2a9e53faf5a69493943ec3f6a384bdc792deb2/httpx-0.28.1-py3-none-any.whl", hash = "sha256:d909fcccc110f8c7faf814ca82a9a4d816bc5a6dbfea25d6591d6985b8ba59ad", size = 73517 },
]

[[package]]
name = "httpx-sse"
version = "0.4.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/4c/60/8f4281fa9bbf3c8034fd54c0e7412e66edbab6bc74c4996bd616f8d0406e/httpx-sse-0.4.0.tar.gz", hash = "sha256:1e81a3a3070ce322add1d3529ed42eb5f70817f45ed6ec915ab753f961139721", size = 12624 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e1/9b/a181f281f65d776426002f330c31849b86b31fc9d848db62e16f03ff739f/httpx_sse-0.4.0-py3-none-any.whl", hash = "sha256:f329af6eae57eaa2bdfd962b42524764af68075ea87370a2de920af5341e318f", size = 7819 },
]

[[package]]
name = "idna"
version = "3.10"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/f1/70/7703c29685631f5a7590aa73f1f1d3fa9a380e654b86af429e0934a32f7d/idna-3.10.tar.gz", hash = "sha256:12f65c9b470abda6dc35cf8e63cc574b1c52b11df2c86030af0ac09b01b13ea9", size = 190490 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/76/c6/c88e154df9c4e1a2a66ccf0005a88dfb2650c1dffb6f5ce603dfbd452ce3/idna-3.10-py3-none-any.whl", hash = "sha256:946d195a0d259cbba61165e88e65941f16e9b36ea6ddb97f00452bae8b1287d3", size = 70442 },
]

[[package]]
name = "markdown-it-py"
version = "3.0.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "mdurl" },
]
sdist = { url = "https://files.pythonhosted.org/packages/38/71/3b932df36c1a044d397a1f92d1cf91ee0a503d91e470cbd670aa66b07ed0/markdown-it-py-3.0.0.tar.gz", hash = "sha256:e3f60a94fa066dc52ec76661e37c851cb232d92f9886b15cb560aaada2df8feb", size = 74596 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/42/d7/1ec15b46af6af88f19b8e5ffea08fa375d433c998b8a7639e76935c14f1f/markdown_it_py-3.0.0-py3-none-any.whl", hash = "sha256:355216845c60bd96232cd8d8c40e8f9765cc86f46880e43a8fd22dc1a1a8cab1", size = 87528 },
]

[[package]]
name = "mcp"
version = "1.6.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
    { name = "httpx" },
    { name = "httpx-sse" },
    { name = "pydantic" },
    { name = "pydantic-settings" },
    { name = "sse-starlette" },
    { name = "starlette" },
    { name = "uvicorn" },
]
sdist = { url = "https://files.pythonhosted.org/packages/95/d2/f587cb965a56e992634bebc8611c5b579af912b74e04eb9164bd49527d21/mcp-1.6.0.tar.gz", hash = "sha256:d9324876de2c5637369f43161cd71eebfd803df5a95e46225cab8d280e366723", size = 200031 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/10/30/20a7f33b0b884a9d14dd3aa94ff1ac9da1479fe2ad66dd9e2736075d2506/mcp-1.6.0-py3-none-any.whl", hash = "sha256:7bd24c6ea042dbec44c754f100984d186620d8b841ec30f1b19eda9b93a634d0", size = 76077 },
]

[package.optional-dependencies]
cli = [
    { name = "python-dotenv" },
    { name = "typer" },
]

[[package]]
name = "mdurl"
version = "0.1.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/d6/54/cfe61301667036ec958cb99bd3efefba235e65cdeb9c84d24a8293ba1d90/mdurl-0.1.2.tar.gz", hash = "sha256:bb413d29f5eea38f31dd4754dd7377d4465116fb207585f97bf925588687c1ba", size = 8729 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b3/38/89ba8ad64ae25be8de66a6d463314cf1eb366222074cfda9ee839c56a4b4/mdurl-0.1.2-py3-none-any.whl", hash = "sha256:84008a41e51615a49fc9966191ff91509e3c40b939176e643fd50a5c2196b8f8", size = 9979 },
]

[[package]]
name = "pydantic"
version = "2.11.3"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "annotated-types" },
    { name = "pydantic-core" },
    { name = "typing-extensions" },
    { name = "typing-inspection" },
]
sdist = { url = "https://files.pythonhosted.org/packages/10/2e/ca897f093ee6c5f3b0bee123ee4465c50e75431c3d5b6a3b44a47134e891/pydantic-2.11.3.tar.gz", hash = "sha256:7471657138c16adad9322fe3070c0116dd6c3ad8d649300e3cbdfe91f4db4ec3", size = 785513 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b0/1d/407b29780a289868ed696d1616f4aad49d6388e5a77f567dcd2629dcd7b8/pydantic-2.11.3-py3-none-any.whl", hash = "sha256:a082753436a07f9ba1289c6ffa01cd93db3548776088aa917cc43b63f68fa60f", size = 443591 },
]

[[package]]
name = "pydantic-core"
version = "2.33.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/17/19/ed6a078a5287aea7922de6841ef4c06157931622c89c2a47940837b5eecd/pydantic_core-2.33.1.tar.gz", hash = "sha256:bcc9c6fdb0ced789245b02b7d6603e17d1563064ddcfc36f046b61c0c05dd9df", size = 434395 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/38/ea/5f572806ab4d4223d11551af814d243b0e3e02cc6913def4d1fe4a5ca41c/pydantic_core-2.33.1-cp310-cp310-macosx_10_12_x86_64.whl", hash = "sha256:3077cfdb6125cc8dab61b155fdd714663e401f0e6883f9632118ec12cf42df26", size = 2044021 },
    { url = "https://files.pythonhosted.org/packages/8c/d1/f86cc96d2aa80e3881140d16d12ef2b491223f90b28b9a911346c04ac359/pydantic_core-2.33.1-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:8ffab8b2908d152e74862d276cf5017c81a2f3719f14e8e3e8d6b83fda863927", size = 1861742 },
    { url = "https://files.pythonhosted.org/packages/37/08/fbd2cd1e9fc735a0df0142fac41c114ad9602d1c004aea340169ae90973b/pydantic_core-2.33.1-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:5183e4f6a2d468787243ebcd70cf4098c247e60d73fb7d68d5bc1e1beaa0c4db", size = 1910414 },
    { url = "https://files.pythonhosted.org/packages/7f/73/3ac217751decbf8d6cb9443cec9b9eb0130eeada6ae56403e11b486e277e/pydantic_core-2.33.1-cp310-cp310-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:398a38d323f37714023be1e0285765f0a27243a8b1506b7b7de87b647b517e48", size = 1996848 },
    { url = "https://files.pythonhosted.org/packages/9a/f5/5c26b265cdcff2661e2520d2d1e9db72d117ea00eb41e00a76efe68cb009/pydantic_core-2.33.1-cp310-cp310-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:87d3776f0001b43acebfa86f8c64019c043b55cc5a6a2e313d728b5c95b46969", size = 2141055 },
    { url = "https://files.pythonhosted.org/packages/5d/14/a9c3cee817ef2f8347c5ce0713e91867a0dceceefcb2973942855c917379/pydantic_core-2.33.1-cp310-cp310-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:c566dd9c5f63d22226409553531f89de0cac55397f2ab8d97d6f06cfce6d947e", size = 2753806 },
    { url = "https://files.pythonhosted.org/packages/f2/68/866ce83a51dd37e7c604ce0050ff6ad26de65a7799df89f4db87dd93d1d6/pydantic_core-2.33.1-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:a0d5f3acc81452c56895e90643a625302bd6be351e7010664151cc55b7b97f89", size = 2007777 },
    { url = "https://files.pythonhosted.org/packages/b6/a8/36771f4404bb3e49bd6d4344da4dede0bf89cc1e01f3b723c47248a3761c/pydantic_core-2.33.1-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:d3a07fadec2a13274a8d861d3d37c61e97a816beae717efccaa4b36dfcaadcde", size = 2122803 },
    { url = "https://files.pythonhosted.org/packages/18/9c/730a09b2694aa89360d20756369822d98dc2f31b717c21df33b64ffd1f50/pydantic_core-2.33.1-cp310-cp310-musllinux_1_1_aarch64.whl", hash = "sha256:f99aeda58dce827f76963ee87a0ebe75e648c72ff9ba1174a253f6744f518f65", size = 2086755 },
    { url = "https://files.pythonhosted.org/packages/54/8e/2dccd89602b5ec31d1c58138d02340ecb2ebb8c2cac3cc66b65ce3edb6ce/pydantic_core-2.33.1-cp310-cp310-musllinux_1_1_armv7l.whl", hash = "sha256:902dbc832141aa0ec374f4310f1e4e7febeebc3256f00dc359a9ac3f264a45dc", size = 2257358 },
    { url = "https://files.pythonhosted.org/packages/d1/9c/126e4ac1bfad8a95a9837acdd0963695d69264179ba4ede8b8c40d741702/pydantic_core-2.33.1-cp310-cp310-musllinux_1_1_x86_64.whl", hash = "sha256:fe44d56aa0b00d66640aa84a3cbe80b7a3ccdc6f0b1ca71090696a6d4777c091", size = 2257916 },
    { url = "https://files.pythonhosted.org/packages/7d/ba/91eea2047e681a6853c81c20aeca9dcdaa5402ccb7404a2097c2adf9d038/pydantic_core-2.33.1-cp310-cp310-win32.whl", hash = "sha256:ed3eb16d51257c763539bde21e011092f127a2202692afaeaccb50db55a31383", size = 1923823 },
    { url = "https://files.pythonhosted.org/packages/94/c0/fcdf739bf60d836a38811476f6ecd50374880b01e3014318b6e809ddfd52/pydantic_core-2.33.1-cp310-cp310-win_amd64.whl", hash = "sha256:694ad99a7f6718c1a498dc170ca430687a39894a60327f548e02a9c7ee4b6504", size = 1952494 },
    { url = "https://files.pythonhosted.org/packages/d6/7f/c6298830cb780c46b4f46bb24298d01019ffa4d21769f39b908cd14bbd50/pydantic_core-2.33.1-cp311-cp311-macosx_10_12_x86_64.whl", hash = "sha256:6e966fc3caaf9f1d96b349b0341c70c8d6573bf1bac7261f7b0ba88f96c56c24", size = 2044224 },
    { url = "https://files.pythonhosted.org/packages/a8/65/6ab3a536776cad5343f625245bd38165d6663256ad43f3a200e5936afd6c/pydantic_core-2.33.1-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:bfd0adeee563d59c598ceabddf2c92eec77abcb3f4a391b19aa7366170bd9e30", size = 1858845 },
    { url = "https://files.pythonhosted.org/packages/e9/15/9a22fd26ba5ee8c669d4b8c9c244238e940cd5d818649603ca81d1c69861/pydantic_core-2.33.1-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:91815221101ad3c6b507804178a7bb5cb7b2ead9ecd600041669c8d805ebd595", size = 1910029 },
    { url = "https://files.pythonhosted.org/packages/d5/33/8cb1a62818974045086f55f604044bf35b9342900318f9a2a029a1bec460/pydantic_core-2.33.1-cp311-cp311-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:9fea9c1869bb4742d174a57b4700c6dadea951df8b06de40c2fedb4f02931c2e", size = 1997784 },
    { url = "https://files.pythonhosted.org/packages/c0/ca/49958e4df7715c71773e1ea5be1c74544923d10319173264e6db122543f9/pydantic_core-2.33.1-cp311-cp311-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:1d20eb4861329bb2484c021b9d9a977566ab16d84000a57e28061151c62b349a", size = 2141075 },
    { url = "https://files.pythonhosted.org/packages/7b/a6/0b3a167a9773c79ba834b959b4e18c3ae9216b8319bd8422792abc8a41b1/pydantic_core-2.33.1-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:0fb935c5591573ae3201640579f30128ccc10739b45663f93c06796854405505", size = 2745849 },
    { url = "https://files.pythonhosted.org/packages/0b/60/516484135173aa9e5861d7a0663dce82e4746d2e7f803627d8c25dfa5578/pydantic_core-2.33.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:c964fd24e6166420d18fb53996d8c9fd6eac9bf5ae3ec3d03015be4414ce497f", size = 2005794 },
    { url = "https://files.pythonhosted.org/packages/86/70/05b1eb77459ad47de00cf78ee003016da0cedf8b9170260488d7c21e9181/pydantic_core-2.33.1-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:681d65e9011f7392db5aa002b7423cc442d6a673c635668c227c6c8d0e5a4f77", size = 2123237 },
    { url = "https://files.pythonhosted.org/packages/c7/57/12667a1409c04ae7dc95d3b43158948eb0368e9c790be8b095cb60611459/pydantic_core-2.33.1-cp311-cp311-musllinux_1_1_aarch64.whl", hash = "sha256:e100c52f7355a48413e2999bfb4e139d2977a904495441b374f3d4fb4a170961", size = 2086351 },
    { url = "https://files.pythonhosted.org/packages/57/61/cc6d1d1c1664b58fdd6ecc64c84366c34ec9b606aeb66cafab6f4088974c/pydantic_core-2.33.1-cp311-cp311-musllinux_1_1_armv7l.whl", hash = "sha256:048831bd363490be79acdd3232f74a0e9951b11b2b4cc058aeb72b22fdc3abe1", size = 2258914 },
    { url = "https://files.pythonhosted.org/packages/d1/0a/edb137176a1f5419b2ddee8bde6a0a548cfa3c74f657f63e56232df8de88/pydantic_core-2.33.1-cp311-cp311-musllinux_1_1_x86_64.whl", hash = "sha256:bdc84017d28459c00db6f918a7272a5190bec3090058334e43a76afb279eac7c", size = 2257385 },
    { url = "https://files.pythonhosted.org/packages/26/3c/48ca982d50e4b0e1d9954919c887bdc1c2b462801bf408613ccc641b3daa/pydantic_core-2.33.1-cp311-cp311-win32.whl", hash = "sha256:32cd11c5914d1179df70406427097c7dcde19fddf1418c787540f4b730289896", size = 1923765 },
    { url = "https://files.pythonhosted.org/packages/33/cd/7ab70b99e5e21559f5de38a0928ea84e6f23fdef2b0d16a6feaf942b003c/pydantic_core-2.33.1-cp311-cp311-win_amd64.whl", hash = "sha256:2ea62419ba8c397e7da28a9170a16219d310d2cf4970dbc65c32faf20d828c83", size = 1950688 },
    { url = "https://files.pythonhosted.org/packages/4b/ae/db1fc237b82e2cacd379f63e3335748ab88b5adde98bf7544a1b1bd10a84/pydantic_core-2.33.1-cp311-cp311-win_arm64.whl", hash = "sha256:fc903512177361e868bc1f5b80ac8c8a6e05fcdd574a5fb5ffeac5a9982b9e89", size = 1908185 },
    { url = "https://files.pythonhosted.org/packages/c8/ce/3cb22b07c29938f97ff5f5bb27521f95e2ebec399b882392deb68d6c440e/pydantic_core-2.33.1-cp312-cp312-macosx_10_12_x86_64.whl", hash = "sha256:1293d7febb995e9d3ec3ea09caf1a26214eec45b0f29f6074abb004723fc1de8", size = 2026640 },
    { url = "https://files.pythonhosted.org/packages/19/78/f381d643b12378fee782a72126ec5d793081ef03791c28a0fd542a5bee64/pydantic_core-2.33.1-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:99b56acd433386c8f20be5c4000786d1e7ca0523c8eefc995d14d79c7a081498", size = 1852649 },
    { url = "https://files.pythonhosted.org/packages/9d/2b/98a37b80b15aac9eb2c6cfc6dbd35e5058a352891c5cce3a8472d77665a6/pydantic_core-2.33.1-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:35a5ec3fa8c2fe6c53e1b2ccc2454398f95d5393ab398478f53e1afbbeb4d939", size = 1892472 },
    { url = "https://files.pythonhosted.org/packages/4e/d4/3c59514e0f55a161004792b9ff3039da52448f43f5834f905abef9db6e4a/pydantic_core-2.33.1-cp312-cp312-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:b172f7b9d2f3abc0efd12e3386f7e48b576ef309544ac3a63e5e9cdd2e24585d", size = 1977509 },
    { url = "https://files.pythonhosted.org/packages/a9/b6/c2c7946ef70576f79a25db59a576bce088bdc5952d1b93c9789b091df716/pydantic_core-2.33.1-cp312-cp312-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:9097b9f17f91eea659b9ec58148c0747ec354a42f7389b9d50701610d86f812e", size = 2128702 },
    { url = "https://files.pythonhosted.org/packages/88/fe/65a880f81e3f2a974312b61f82a03d85528f89a010ce21ad92f109d94deb/pydantic_core-2.33.1-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:cc77ec5b7e2118b152b0d886c7514a4653bcb58c6b1d760134a9fab915f777b3", size = 2679428 },
    { url = "https://files.pythonhosted.org/packages/6f/ff/4459e4146afd0462fb483bb98aa2436d69c484737feaceba1341615fb0ac/pydantic_core-2.33.1-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:d5e3d15245b08fa4a84cefc6c9222e6f37c98111c8679fbd94aa145f9a0ae23d", size = 2008753 },
    { url = "https://files.pythonhosted.org/packages/7c/76/1c42e384e8d78452ededac8b583fe2550c84abfef83a0552e0e7478ccbc3/pydantic_core-2.33.1-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:ef99779001d7ac2e2461d8ab55d3373fe7315caefdbecd8ced75304ae5a6fc6b", size = 2114849 },
    { url = "https://files.pythonhosted.org/packages/00/72/7d0cf05095c15f7ffe0eb78914b166d591c0eed72f294da68378da205101/pydantic_core-2.33.1-cp312-cp312-musllinux_1_1_aarch64.whl", hash = "sha256:fc6bf8869e193855e8d91d91f6bf59699a5cdfaa47a404e278e776dd7f168b39", size = 2069541 },
    { url = "https://files.pythonhosted.org/packages/b3/69/94a514066bb7d8be499aa764926937409d2389c09be0b5107a970286ef81/pydantic_core-2.33.1-cp312-cp312-musllinux_1_1_armv7l.whl", hash = "sha256:b1caa0bc2741b043db7823843e1bde8aaa58a55a58fda06083b0569f8b45693a", size = 2239225 },
    { url = "https://files.pythonhosted.org/packages/84/b0/e390071eadb44b41f4f54c3cef64d8bf5f9612c92686c9299eaa09e267e2/pydantic_core-2.33.1-cp312-cp312-musllinux_1_1_x86_64.whl", hash = "sha256:ec259f62538e8bf364903a7d0d0239447059f9434b284f5536e8402b7dd198db", size = 2248373 },
    { url = "https://files.pythonhosted.org/packages/d6/b2/288b3579ffc07e92af66e2f1a11be3b056fe1214aab314748461f21a31c3/pydantic_core-2.33.1-cp312-cp312-win32.whl", hash = "sha256:e14f369c98a7c15772b9da98987f58e2b509a93235582838bd0d1d8c08b68fda", size = 1907034 },
    { url = "https://files.pythonhosted.org/packages/02/28/58442ad1c22b5b6742b992ba9518420235adced665513868f99a1c2638a5/pydantic_core-2.33.1-cp312-cp312-win_amd64.whl", hash = "sha256:1c607801d85e2e123357b3893f82c97a42856192997b95b4d8325deb1cd0c5f4", size = 1956848 },
    { url = "https://files.pythonhosted.org/packages/a1/eb/f54809b51c7e2a1d9f439f158b8dd94359321abcc98767e16fc48ae5a77e/pydantic_core-2.33.1-cp312-cp312-win_arm64.whl", hash = "sha256:8d13f0276806ee722e70a1c93da19748594f19ac4299c7e41237fc791d1861ea", size = 1903986 },
    { url = "https://files.pythonhosted.org/packages/7a/24/eed3466a4308d79155f1cdd5c7432c80ddcc4530ba8623b79d5ced021641/pydantic_core-2.33.1-cp313-cp313-macosx_10_12_x86_64.whl", hash = "sha256:70af6a21237b53d1fe7b9325b20e65cbf2f0a848cf77bed492b029139701e66a", size = 2033551 },
    { url = "https://files.pythonhosted.org/packages/ab/14/df54b1a0bc9b6ded9b758b73139d2c11b4e8eb43e8ab9c5847c0a2913ada/pydantic_core-2.33.1-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:282b3fe1bbbe5ae35224a0dbd05aed9ccabccd241e8e6b60370484234b456266", size = 1852785 },
    { url = "https://files.pythonhosted.org/packages/fa/96/e275f15ff3d34bb04b0125d9bc8848bf69f25d784d92a63676112451bfb9/pydantic_core-2.33.1-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:4b315e596282bbb5822d0c7ee9d255595bd7506d1cb20c2911a4da0b970187d3", size = 1897758 },
    { url = "https://files.pythonhosted.org/packages/b7/d8/96bc536e975b69e3a924b507d2a19aedbf50b24e08c80fb00e35f9baaed8/pydantic_core-2.33.1-cp313-cp313-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:1dfae24cf9921875ca0ca6a8ecb4bb2f13c855794ed0d468d6abbec6e6dcd44a", size = 1986109 },
    { url = "https://files.pythonhosted.org/packages/90/72/ab58e43ce7e900b88cb571ed057b2fcd0e95b708a2e0bed475b10130393e/pydantic_core-2.33.1-cp313-cp313-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:6dd8ecfde08d8bfadaea669e83c63939af76f4cf5538a72597016edfa3fad516", size = 2129159 },
    { url = "https://files.pythonhosted.org/packages/dc/3f/52d85781406886c6870ac995ec0ba7ccc028b530b0798c9080531b409fdb/pydantic_core-2.33.1-cp313-cp313-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:2f593494876eae852dc98c43c6f260f45abdbfeec9e4324e31a481d948214764", size = 2680222 },
    { url = "https://files.pythonhosted.org/packages/f4/56/6e2ef42f363a0eec0fd92f74a91e0ac48cd2e49b695aac1509ad81eee86a/pydantic_core-2.33.1-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:948b73114f47fd7016088e5186d13faf5e1b2fe83f5e320e371f035557fd264d", size = 2006980 },
    { url = "https://files.pythonhosted.org/packages/4c/c0/604536c4379cc78359f9ee0aa319f4aedf6b652ec2854953f5a14fc38c5a/pydantic_core-2.33.1-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:e11f3864eb516af21b01e25fac915a82e9ddad3bb0fb9e95a246067398b435a4", size = 2120840 },
    { url = "https://files.pythonhosted.org/packages/1f/46/9eb764814f508f0edfb291a0f75d10854d78113fa13900ce13729aaec3ae/pydantic_core-2.33.1-cp313-cp313-musllinux_1_1_aarch64.whl", hash = "sha256:549150be302428b56fdad0c23c2741dcdb5572413776826c965619a25d9c6bde", size = 2072518 },
    { url = "https://files.pythonhosted.org/packages/42/e3/fb6b2a732b82d1666fa6bf53e3627867ea3131c5f39f98ce92141e3e3dc1/pydantic_core-2.33.1-cp313-cp313-musllinux_1_1_armv7l.whl", hash = "sha256:495bc156026efafd9ef2d82372bd38afce78ddd82bf28ef5276c469e57c0c83e", size = 2248025 },
    { url = "https://files.pythonhosted.org/packages/5c/9d/fbe8fe9d1aa4dac88723f10a921bc7418bd3378a567cb5e21193a3c48b43/pydantic_core-2.33.1-cp313-cp313-musllinux_1_1_x86_64.whl", hash = "sha256:ec79de2a8680b1a67a07490bddf9636d5c2fab609ba8c57597e855fa5fa4dacd", size = 2254991 },
    { url = "https://files.pythonhosted.org/packages/aa/99/07e2237b8a66438d9b26482332cda99a9acccb58d284af7bc7c946a42fd3/pydantic_core-2.33.1-cp313-cp313-win32.whl", hash = "sha256:ee12a7be1742f81b8a65b36c6921022301d466b82d80315d215c4c691724986f", size = 1915262 },
    { url = "https://files.pythonhosted.org/packages/8a/f4/e457a7849beeed1e5defbcf5051c6f7b3c91a0624dd31543a64fc9adcf52/pydantic_core-2.33.1-cp313-cp313-win_amd64.whl", hash = "sha256:ede9b407e39949d2afc46385ce6bd6e11588660c26f80576c11c958e6647bc40", size = 1956626 },
    { url = "https://files.pythonhosted.org/packages/20/d0/e8d567a7cff7b04e017ae164d98011f1e1894269fe8e90ea187a3cbfb562/pydantic_core-2.33.1-cp313-cp313-win_arm64.whl", hash = "sha256:aa687a23d4b7871a00e03ca96a09cad0f28f443690d300500603bd0adba4b523", size = 1909590 },
    { url = "https://files.pythonhosted.org/packages/ef/fd/24ea4302d7a527d672c5be06e17df16aabfb4e9fdc6e0b345c21580f3d2a/pydantic_core-2.33.1-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:401d7b76e1000d0dd5538e6381d28febdcacb097c8d340dde7d7fc6e13e9f95d", size = 1812963 },
    { url = "https://files.pythonhosted.org/packages/5f/95/4fbc2ecdeb5c1c53f1175a32d870250194eb2fdf6291b795ab08c8646d5d/pydantic_core-2.33.1-cp313-cp313t-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:7aeb055a42d734c0255c9e489ac67e75397d59c6fbe60d155851e9782f276a9c", size = 1986896 },
    { url = "https://files.pythonhosted.org/packages/71/ae/fe31e7f4a62431222d8f65a3bd02e3fa7e6026d154a00818e6d30520ea77/pydantic_core-2.33.1-cp313-cp313t-win_amd64.whl", hash = "sha256:338ea9b73e6e109f15ab439e62cb3b78aa752c7fd9536794112e14bee02c8d18", size = 1931810 },
    { url = "https://files.pythonhosted.org/packages/9c/c7/8b311d5adb0fe00a93ee9b4e92a02b0ec08510e9838885ef781ccbb20604/pydantic_core-2.33.1-pp310-pypy310_pp73-macosx_10_12_x86_64.whl", hash = "sha256:5c834f54f8f4640fd7e4b193f80eb25a0602bba9e19b3cd2fc7ffe8199f5ae02", size = 2041659 },
    { url = "https://files.pythonhosted.org/packages/8a/d6/4f58d32066a9e26530daaf9adc6664b01875ae0691570094968aaa7b8fcc/pydantic_core-2.33.1-pp310-pypy310_pp73-macosx_11_0_arm64.whl", hash = "sha256:049e0de24cf23766f12cc5cc71d8abc07d4a9deb9061b334b62093dedc7cb068", size = 1873294 },
    { url = "https://files.pythonhosted.org/packages/f7/3f/53cc9c45d9229da427909c751f8ed2bf422414f7664ea4dde2d004f596ba/pydantic_core-2.33.1-pp310-pypy310_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:1a28239037b3d6f16916a4c831a5a0eadf856bdd6d2e92c10a0da3a59eadcf3e", size = 1903771 },
    { url = "https://files.pythonhosted.org/packages/f0/49/bf0783279ce674eb9903fb9ae43f6c614cb2f1c4951370258823f795368b/pydantic_core-2.33.1-pp310-pypy310_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:9d3da303ab5f378a268fa7d45f37d7d85c3ec19769f28d2cc0c61826a8de21fe", size = 2083558 },
    { url = "https://files.pythonhosted.org/packages/9c/5b/0d998367687f986c7d8484a2c476d30f07bf5b8b1477649a6092bd4c540e/pydantic_core-2.33.1-pp310-pypy310_pp73-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:25626fb37b3c543818c14821afe0fd3830bc327a43953bc88db924b68c5723f1", size = 2118038 },
    { url = "https://files.pythonhosted.org/packages/b3/33/039287d410230ee125daee57373ac01940d3030d18dba1c29cd3089dc3ca/pydantic_core-2.33.1-pp310-pypy310_pp73-musllinux_1_1_aarch64.whl", hash = "sha256:3ab2d36e20fbfcce8f02d73c33a8a7362980cff717926bbae030b93ae46b56c7", size = 2079315 },
    { url = "https://files.pythonhosted.org/packages/1f/85/6d8b2646d99c062d7da2d0ab2faeb0d6ca9cca4c02da6076376042a20da3/pydantic_core-2.33.1-pp310-pypy310_pp73-musllinux_1_1_armv7l.whl", hash = "sha256:2f9284e11c751b003fd4215ad92d325d92c9cb19ee6729ebd87e3250072cdcde", size = 2249063 },
    { url = "https://files.pythonhosted.org/packages/17/d7/c37d208d5738f7b9ad8f22ae8a727d88ebf9c16c04ed2475122cc3f7224a/pydantic_core-2.33.1-pp310-pypy310_pp73-musllinux_1_1_x86_64.whl", hash = "sha256:048c01eee07d37cbd066fc512b9d8b5ea88ceeb4e629ab94b3e56965ad655add", size = 2254631 },
    { url = "https://files.pythonhosted.org/packages/13/e0/bafa46476d328e4553b85ab9b2f7409e7aaef0ce4c937c894821c542d347/pydantic_core-2.33.1-pp310-pypy310_pp73-win_amd64.whl", hash = "sha256:5ccd429694cf26af7997595d627dd2637e7932214486f55b8a357edaac9dae8c", size = 2080877 },
    { url = "https://files.pythonhosted.org/packages/0b/76/1794e440c1801ed35415238d2c728f26cd12695df9057154ad768b7b991c/pydantic_core-2.33.1-pp311-pypy311_pp73-macosx_10_12_x86_64.whl", hash = "sha256:3a371dc00282c4b84246509a5ddc808e61b9864aa1eae9ecc92bb1268b82db4a", size = 2042858 },
    { url = "https://files.pythonhosted.org/packages/73/b4/9cd7b081fb0b1b4f8150507cd59d27b275c3e22ad60b35cb19ea0977d9b9/pydantic_core-2.33.1-pp311-pypy311_pp73-macosx_11_0_arm64.whl", hash = "sha256:f59295ecc75a1788af8ba92f2e8c6eeaa5a94c22fc4d151e8d9638814f85c8fc", size = 1873745 },
    { url = "https://files.pythonhosted.org/packages/e1/d7/9ddb7575d4321e40d0363903c2576c8c0c3280ebea137777e5ab58d723e3/pydantic_core-2.33.1-pp311-pypy311_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:08530b8ac922003033f399128505f513e30ca770527cc8bbacf75a84fcc2c74b", size = 1904188 },
    { url = "https://files.pythonhosted.org/packages/d1/a8/3194ccfe461bb08da19377ebec8cb4f13c9bd82e13baebc53c5c7c39a029/pydantic_core-2.33.1-pp311-pypy311_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:bae370459da6a5466978c0eacf90690cb57ec9d533f8e63e564ef3822bfa04fe", size = 2083479 },
    { url = "https://files.pythonhosted.org/packages/42/c7/84cb569555d7179ca0b3f838cef08f66f7089b54432f5b8599aac6e9533e/pydantic_core-2.33.1-pp311-pypy311_pp73-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:e3de2777e3b9f4d603112f78006f4ae0acb936e95f06da6cb1a45fbad6bdb4b5", size = 2118415 },
    { url = "https://files.pythonhosted.org/packages/3b/67/72abb8c73e0837716afbb58a59cc9e3ae43d1aa8677f3b4bc72c16142716/pydantic_core-2.33.1-pp311-pypy311_pp73-musllinux_1_1_aarch64.whl", hash = "sha256:3a64e81e8cba118e108d7126362ea30e021291b7805d47e4896e52c791be2761", size = 2079623 },
    { url = "https://files.pythonhosted.org/packages/0b/cd/c59707e35a47ba4cbbf153c3f7c56420c58653b5801b055dc52cccc8e2dc/pydantic_core-2.33.1-pp311-pypy311_pp73-musllinux_1_1_armv7l.whl", hash = "sha256:52928d8c1b6bda03cc6d811e8923dffc87a2d3c8b3bfd2ce16471c7147a24850", size = 2250175 },
    { url = "https://files.pythonhosted.org/packages/84/32/e4325a6676b0bed32d5b084566ec86ed7fd1e9bcbfc49c578b1755bde920/pydantic_core-2.33.1-pp311-pypy311_pp73-musllinux_1_1_x86_64.whl", hash = "sha256:1b30d92c9412beb5ac6b10a3eb7ef92ccb14e3f2a8d7732e2d739f58b3aa7544", size = 2254674 },
    { url = "https://files.pythonhosted.org/packages/12/6f/5596dc418f2e292ffc661d21931ab34591952e2843e7168ea5a52591f6ff/pydantic_core-2.33.1-pp311-pypy311_pp73-win_amd64.whl", hash = "sha256:f995719707e0e29f0f41a8aa3bcea6e761a36c9136104d3189eafb83f5cec5e5", size = 2080951 },
]

[[package]]
name = "pydantic-settings"
version = "2.9.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "pydantic" },
    { name = "python-dotenv" },
    { name = "typing-inspection" },
]
sdist = { url = "https://files.pythonhosted.org/packages/67/1d/42628a2c33e93f8e9acbde0d5d735fa0850f3e6a2f8cb1eb6c40b9a732ac/pydantic_settings-2.9.1.tar.gz", hash = "sha256:c509bf79d27563add44e8446233359004ed85066cd096d8b510f715e6ef5d268", size = 163234 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b6/5f/d6d641b490fd3ec2c4c13b4244d68deea3a1b970a97be64f34fb5504ff72/pydantic_settings-2.9.1-py3-none-any.whl", hash = "sha256:59b4f431b1defb26fe620c71a7d3968a710d719f5f4cdbbdb7926edeb770f6ef", size = 44356 },
]

[[package]]
name = "pygments"
version = "2.19.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/7c/2d/c3338d48ea6cc0feb8446d8e6937e1408088a72a39937982cc6111d17f84/pygments-2.19.1.tar.gz", hash = "sha256:61c16d2a8576dc0649d9f39e089b5f02bcd27fba10d8fb4dcc28173f7a45151f", size = 4968581 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/8a/0b/9fcc47d19c48b59121088dd6da2488a49d5f72dacf8262e2790a1d2c7d15/pygments-2.19.1-py3-none-any.whl", hash = "sha256:9ea1544ad55cecf4b8242fab6dd35a93bbce657034b0611ee383099054ab6d8c", size = 1225293 },
]

[[package]]
name = "python-dotenv"
version = "1.1.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/88/2c/7bb1416c5620485aa793f2de31d3df393d3686aa8a8506d11e10e13c5baf/python_dotenv-1.1.0.tar.gz", hash = "sha256:41f90bc6f5f177fb41f53e87666db362025010eb28f60a01c9143bfa33a2b2d5", size = 39920 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/1e/18/98a99ad95133c6a6e2005fe89faedf294a748bd5dc803008059409ac9b1e/python_dotenv-1.1.0-py3-none-any.whl", hash = "sha256:d7c01d9e2293916c18baf562d95698754b0dbbb5e74d457c45d4f6561fb9d55d", size = 20256 },
]

[[package]]
name = "requests"
version = "2.32.3"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "certifi" },
    { name = "charset-normalizer" },
    { name = "idna" },
    { name = "urllib3" },
]
sdist = { url = "https://files.pythonhosted.org/packages/63/70/2bf7780ad2d390a8d301ad0b550f1581eadbd9a20f896afe06353c2a2913/requests-2.32.3.tar.gz", hash = "sha256:55365417734eb18255590a9ff9eb97e9e1da868d4ccd6402399eaf68af20a760", size = 131218 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/f9/9b/335f9764261e915ed497fcdeb11df5dfd6f7bf257d4a6a2a686d80da4d54/requests-2.32.3-py3-none-any.whl", hash = "sha256:70761cfe03c773ceb22aa2f671b4757976145175cdfca038c02654d061d6dcc6", size = 64928 },
]

[[package]]
name = "rich"
version = "14.0.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "markdown-it-py" },
    { name = "pygments" },
    { name = "typing-extensions", marker = "python_full_version < '3.11'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/a1/53/830aa4c3066a8ab0ae9a9955976fb770fe9c6102117c8ec4ab3ea62d89e8/rich-14.0.0.tar.gz", hash = "sha256:82f1bc23a6a21ebca4ae0c45af9bdbc492ed20231dcb63f297d6d1021a9d5725", size = 224078 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/0d/9b/63f4c7ebc259242c89b3acafdb37b41d1185c07ff0011164674e9076b491/rich-14.0.0-py3-none-any.whl", hash = "sha256:1c9491e1951aac09caffd42f448ee3d04e58923ffe14993f6e83068dc395d7e0", size = 243229 },
]

[[package]]
name = "roblox-mcp"
version = "0.1.0"
source = { editable = "." }
dependencies = [
    { name = "mcp", extra = ["cli"] },
    { name = "python-dotenv" },
    { name = "requests" },
]

[package.metadata]
requires-dist = [
    { name = "mcp", extras = ["cli"], specifier = ">=1.3.0" },
    { name = "python-dotenv", specifier = ">=1.0.0" },
    { name = "requests", specifier = ">=2.30.0" },
]

[[package]]
name = "shellingham"
version = "1.5.4"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/58/15/8b3609fd3830ef7b27b655beb4b4e9c62313a4e8da8c676e142cc210d58e/shellingham-1.5.4.tar.gz", hash = "sha256:8dbca0739d487e5bd35ab3ca4b36e11c4078f3a234bfce294b0a0291363404de", size = 10310 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e0/f9/0595336914c5619e5f28a1fb793285925a8cd4b432c9da0a987836c7f822/shellingham-1.5.4-py2.py3-none-any.whl", hash = "sha256:7ecfff8f2fd72616f7481040475a65b2bf8af90a56c89140852d1120324e8686", size = 9755 },
]

[[package]]
name = "sniffio"
version = "1.3.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/a2/87/a6771e1546d97e7e041b6ae58d80074f81b7d5121207425c964ddf5cfdbd/sniffio-1.3.1.tar.gz", hash = "sha256:f4324edc670a0f49750a81b895f35c3adb843cca46f0530f79fc1babb23789dc", size = 20372 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e9/44/75a9c9421471a6c4805dbf2356f7c181a29c1879239abab1ea2cc8f38b40/sniffio-1.3.1-py3-none-any.whl", hash = "sha256:2f6da418d1f1e0fddd844478f41680e794e6051915791a034ff65e5f100525a2", size = 10235 },
]

[[package]]
name = "sse-starlette"
version = "2.3.3"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
    { name = "starlette" },
]
sdist = { url = "https://files.pythonhosted.org/packages/86/35/7d8d94eb0474352d55f60f80ebc30f7e59441a29e18886a6425f0bccd0d3/sse_starlette-2.3.3.tar.gz", hash = "sha256:fdd47c254aad42907cfd5c5b83e2282be15be6c51197bf1a9b70b8e990522072", size = 17499 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/5d/20/52fdb5ebb158294b0adb5662235dd396fc7e47aa31c293978d8d8942095a/sse_starlette-2.3.3-py3-none-any.whl", hash = "sha256:8b0a0ced04a329ff7341b01007580dd8cf71331cc21c0ccea677d500618da1e0", size = 10235 },
]

[[package]]
name = "starlette"
version = "0.46.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
]
sdist = { url = "https://files.pythonhosted.org/packages/ce/20/08dfcd9c983f6a6f4a1000d934b9e6d626cff8d2eeb77a89a68eef20a2b7/starlette-0.46.2.tar.gz", hash = "sha256:7f7361f34eed179294600af672f565727419830b54b7b084efe44bb82d2fccd5", size = 2580846 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/8b/0c/9d30a4ebeb6db2b25a841afbb80f6ef9a854fc3b41be131d249a977b4959/starlette-0.46.2-py3-none-any.whl", hash = "sha256:595633ce89f8ffa71a015caed34a5b2dc1c0cdb3f0f1fbd1e69339cf2abeec35", size = 72037 },
]

[[package]]
name = "typer"
version = "0.15.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "click" },
    { name = "rich" },
    { name = "shellingham" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/8b/6f/3991f0f1c7fcb2df31aef28e0594d8d54b05393a0e4e34c65e475c2a5d41/typer-0.15.2.tar.gz", hash = "sha256:ab2fab47533a813c49fe1f16b1a370fd5819099c00b119e0633df65f22144ba5", size = 100711 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/7f/fc/5b29fea8cee020515ca82cc68e3b8e1e34bb19a3535ad854cac9257b414c/typer-0.15.2-py3-none-any.whl", hash = "sha256:46a499c6107d645a9c13f7ee46c5d5096cae6f5fc57dd11eccbbb9ae3e44ddfc", size = 45061 },
]

[[package]]
name = "typing-extensions"
version = "4.13.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/f6/37/23083fcd6e35492953e8d2aaaa68b860eb422b34627b13f2ce3eb6106061/typing_extensions-4.13.2.tar.gz", hash = "sha256:e6c81219bd689f51865d9e372991c540bda33a0379d5573cddb9a3a23f7caaef", size = 106967 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/8b/54/b1ae86c0973cc6f0210b53d508ca3641fb6d0c56823f288d108bc7ab3cc8/typing_extensions-4.13.2-py3-none-any.whl", hash = "sha256:a439e7c04b49fec3e5d3e2beaa21755cadbbdc391694e28ccdd36ca4a1408f8c", size = 45806 },
]

[[package]]
name = "typing-inspection"
version = "0.4.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/82/5c/e6082df02e215b846b4b8c0b887a64d7d08ffaba30605502639d44c06b82/typing_inspection-0.4.0.tar.gz", hash = "sha256:9765c87de36671694a67904bf2c96e395be9c6439bb6c87b5142569dcdd65122", size = 76222 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/31/08/aa4fdfb71f7de5176385bd9e90852eaf6b5d622735020ad600f2bab54385/typing_inspection-0.4.0-py3-none-any.whl", hash = "sha256:50e72559fcd2a6367a19f7a7e610e6afcb9fac940c650290eed893d61386832f", size = 14125 },
]

[[package]]
name = "urllib3"
version = "2.4.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/8a/78/16493d9c386d8e60e442a35feac5e00f0913c0f4b7c217c11e8ec2ff53e0/urllib3-2.4.0.tar.gz", hash = "sha256:414bc6535b787febd7567804cc015fee39daab8ad86268f1310a9250697de466", size = 390672 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/6b/11/cc635220681e93a0183390e26485430ca2c7b5f9d33b15c74c2861cb8091/urllib3-2.4.0-py3-none-any.whl", hash = "sha256:4e16665048960a0900c702d4a66415956a584919c03361cac9f1df5c5dd7e813", size = 128680 },
]

[[package]]
name = "uvicorn"
version = "0.34.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "click" },
    { name = "h11" },
    { name = "typing-extensions", marker = "python_full_version < '3.11'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/a6/ae/9bbb19b9e1c450cf9ecaef06463e40234d98d95bf572fab11b4f19ae5ded/uvicorn-0.34.2.tar.gz", hash = "sha256:0e929828f6186353a80b58ea719861d2629d766293b6d19baf086ba31d4f3328", size = 76815 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b1/4b/4cef6ce21a2aaca9d852a6e84ef4f135d99fcd74fa75105e2fc0c8308acd/uvicorn-0.34.2-py3-none-any.whl", hash = "sha256:deb49af569084536d269fe0a6d67e3754f104cf03aba7c11c40f01aadf33c403", size = 62483 },
]

```