Project Path: arc_gmh5225_ttddbg_tndgb2on

Source Tree:

```txt
arc_gmh5225_ttddbg_tndgb2on
├── CMakeLists.txt
├── HOWTO_TIME_TRAVEL.md
├── LICENSE.txt
├── README.md
├── cmake
│   ├── FindIdaSdk.cmake
│   └── FindTTDReplay.cmake
├── continue_backwards.png
├── install
│   ├── CERT-blue-short.bmp
│   ├── CERT-blue-short.ico
│   └── patch.xml
├── screenshots
│   ├── ida_backward_icon.png
│   ├── ida_single_step_icon.png
│   ├── ida_timeline_icon.png
│   ├── ida_ttddbg_dropdown.png
│   ├── ida_ttddbg_run.png
│   ├── main_window.png
│   ├── windbg.png
│   ├── windbg_ttd.png
│   └── windbg_ttd_configure.png
├── single_step_backwards.png
├── tests
│   ├── CMakeLists.txt
│   ├── samples
│   │   ├── x64
│   │   │   ├── ttddbg_test_dll.dll
│   │   │   ├── ttddbg_test_dll.run
│   │   │   ├── ttddbg_test_exceptions.exe
│   │   │   ├── ttddbg_test_exceptions01.run
│   │   │   ├── ttddbg_test_multithread.exe
│   │   │   └── ttddbg_test_multithread01.run
│   │   └── x86
│   │       ├── ttddbg_test_dll.dll
│   │       ├── ttddbg_test_dll.run
│   │       ├── ttddbg_test_exceptions.exe
│   │       ├── ttddbg_test_exceptions01.run
│   │       ├── ttddbg_test_multithread.exe
│   │       └── ttddbg_test_multithread01.run
│   ├── test_dll.cc
│   ├── test_exceptions.cc
│   └── test_multithread.cc
├── ttd-bindings
└── ttddbg
    ├── CMakeLists.txt
    ├── include
    │   ├── resume_backwards_icon.hh
    │   ├── single_step_icon.hh
    │   ├── ttddbg_action.hh
    │   ├── ttddbg_debugger.hh
    │   ├── ttddbg_debugger_manager.hh
    │   ├── ttddbg_debugger_manager_interface.hh
    │   ├── ttddbg_debugger_x86.hh
    │   ├── ttddbg_debugger_x86_64.hh
    │   ├── ttddbg_event_deque.hh
    │   ├── ttddbg_logger.hh
    │   ├── ttddbg_logger_ida.hh
    │   ├── ttddbg_plugin.hh
    │   ├── ttddbg_position_chooser.hh
    │   ├── ttddbg_strings.hh
    │   └── ttddbg_x86_registers.hh
    └── src
        ├── ttddbg_action.cc
        ├── ttddbg_debugger.cc
        ├── ttddbg_debugger_manager.cc
        ├── ttddbg_debugger_x86.cc
        ├── ttddbg_debugger_x86_64.cc
        ├── ttddbg_event_deque.cc
        ├── ttddbg_logger_ida.cc
        ├── ttddbg_plugin.cc
        ├── ttddbg_position_chooser.cc
        └── ttddbg_strings.cc

```

`CMakeLists.txt`:

```txt
# Minimum CMake required
cmake_minimum_required(VERSION 3.11)

# Project
project(ttddbg LANGUAGES CXX VERSION 1.0.0)

# Opions
option(BUILD_TESTS "Build test programs" OFF)
option(INSTALL_TTDDLL "Try to find and install ttd dll from Windbg Preview install folder" OFF)

# Config
set_property(GLOBAL PROPERTY USE_FOLDERS ON)

set(CMAKE_POSITION_INDEPENDENT_CODE ON)

SET(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR}/bin)
SET(LIBRARY_OUTPUT_PATH ${CMAKE_BINARY_DIR}/bin)

if (MSVC)
	set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /MT /WX")
	set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /MTd /WX")
endif(MSVC)

# Add cmake folder for 
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")

# Install ttd dlls if it's requested
# Use when generate installer
if (INSTALL_TTDDLL)
	find_package(TTDReplay)
	INSTALL_TTDREPLAY(".")
endif (INSTALL_TTDDLL)

# The IDA plugin
add_subdirectory(ttddbg)

# Tests
if(BUILD_TESTS)
    add_subdirectory(tests)
endif(BUILD_TESTS)

# Summary
message(STATUS "Configuration summary")
message(STATUS "Project name                 : ${PROJECT_NAME}")
message(STATUS "Project version              : ${PROJECT_VERSION}")
message(STATUS "Build Tests                  : ${BUILD_TESTS}")
message(STATUS "Install TTD Dlls             : ${INSTALL_TTDDLL}")

# CPack part
if(WIN32)
set(CPACK_GENERATOR "WIX")
set(CPACK_WIX_UPGRADE_GUID "01fe726f-0a68-4913-8193-020d6911ce42")
set(CPACK_WIX_UNINSTALL "1")
set(CPACK_WIX_PATCH_FILE "${CMAKE_CURRENT_SOURCE_DIR}/install/patch.xml")
set(CPACK_PACKAGE_ICON "${CMAKE_CURRENT_SOURCE_DIR}/install\\\\CERT-blue-short.bmp")
set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/LICENSE.txt")
endif()
include(CPack)

```

`HOWTO_TIME_TRAVEL.md`:

```md
# Things to know before time traveling

There are two main points to consider, especially if you plan using time travel debugging to analyze malware.

## TTD relies on DLL injection

WinDBG will inject a DLL into the selected process, which may trigger anti-tampering features possibly implemented into the targeted program.

## Targeted program is freely executed

In order to record a trace, WinDBG allows the targeted program to run freely. Isolate the environment as appropriate!

# How to record a TTD trace using WinDBG

This short tutorial will guide you through using WinDBG to record a Time Travel Debugging trace to be used with this plugin.

You will need the following prerequisites:
- A copy of WinDBG Preview [[Microsoft Store link](https://apps.microsoft.com/store/detail/windbg-preview/9PGJGD53TN86)]
- A copy of the executable you are trying to debug

Then, open up WinDBG Preview and go to "File -> Launch executable (advanced)". Select your executable and make sure to enable "Record with Time Travel Debugging".

![windbg main window](screenshots/windbg.png)

![windbg launch executable](screenshots/windbg_ttd.png)

WinDBG will then ask you for a path to store the recording. You can store them wherever you want, but be aware that the recording is made up of three different files, and can quickly become significant in size.

Once this is done, click "Record".

![windbg ttd configure window](screenshots/windbg_ttd_configure.png)

WinDBG will then record the executable's actions and give you back control after some time. Once this is done, you can safely close WinDBG! Your recording will be in a `*.run` file in the folder you chose.

```

`LICENSE.txt`:

```txt
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

```

`README.md`:

```md
# ttddbg - Time Travel Debugging IDA plugin

This plugin adds a new debugger to IDA which supports loading [Time Travel Debugging](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/time-travel-debugging-overview) traces generated using WinDBG Preview.

![ttddbg main window](screenshots/main_window.png)

This plugin supports both x86 and x64 traces, and by extension IDA and IDA64.

## Installation

Installing the plugin can be done using the installer from the [releases page](https://github.com/airbus-cert/ttddbg/releases). The installer will automatically install the required dependencies, provided you have a copy of [WinDBG Preview](https://apps.microsoft.com/store/detail/windbg-preview/9PGJGD53TN86) installed.

## Usage

Once installed, you can use the plugin by selecting the `ttddbg` debugger in the IDA interface, and specifying your `*.run` file as the "Application". For help on generating a `.run` file, see [`HOWTO_TIME_TRAVEL.md`](HOWTO_TIME_TRAVEL.md).

![ttddbg debugger](screenshots/ida_ttddbg_dropdown.png)

![ttdbg debugger setup](screenshots/ida_ttddbg_run.png)

| Icon | Action |
|------|--------|
|![backward_icon](screenshots/ida_backward_icon.png) | Go to previous breakpoint |
|![single_step_icon](screenshots/ida_single_step_icon.png) | Single step backward (RIP - one instruction) |
|![timeline_icon](screenshots/ida_timeline_icon.png) | Manage the timeline of interesting events (Threads Created/Terminated, Module Loaded/Unloaded, Exceptions, Custom) |

## Building the project

Prerequisites:

- A copy of the IDA SDK (available from the [download center](https://hex-rays.com/download-center/) using your IDA Pro credentials)
- A copy of `TTDReplay.dll` (usually in `C:\Program Files\WindowsApps\[WinDBG folder]\amd64\ttd\`)
- A copy of `TTDReplayCPU.dll` (usually in `C:\Program Files\WindowsApps\[WinDBG folder]\amd64\ttd\`)

And let CMAKE do its magic!

```console
$ git clone git@github.com:airbus-cert/ttddbg.git --recursive
$ mkdir build
$ cd build
$ cmake ..\ttddbg -DIDA_SDK_SOURCE_DIR=[PATH_TO_IDA_SDK_ROOT_FOLDER] -DCPACK_PACKAGE_INSTALL_DIRECTORY="IDA Pro 7.7"
$ cmake --build . --target package --config release
```

## Developer corner

To create a dev solution:

```console
$ git clone git@github.com:airbus-cert/ttddbg.git --recursive
$ mkdir build
$ cd build
$ cmake ..\ttddbg -DIDA_SDK_SOURCE_DIR=[PATH_TO_IDA_SDK_ROOT_FOLDER] -DBUILD_TESTS=ON
```

# Credits and references

Greetz to [commial](https://github.com/commial) for his work on [ttd-bindings](https://github.com/commial/ttd-bindings)!

```

`cmake/FindIdaSdk.cmake`:

```cmake


if(IDA_SDK_SOURCE_DIR)
	find_path(IDA_SDK_SOURCE_ROOT
	NAMES include/ida.hpp
	PATHS "${IDA_SDK_SOURCE_DIR}"
	NO_DEFAULT_PATH)
else()
	set(IDA_SDK_SOURCE_ROOT IDA_SDK_SOURCE_ROOT-NOTFOUND)
endif()

include(FindPackageHandleStandardArgs)
FIND_PACKAGE_HANDLE_STANDARD_ARGS(
    IDA_SDK
	REQUIRED_VARS IDA_SDK_SOURCE_ROOT
    FAIL_MESSAGE "
#######################################################
Could not find IDA SDK headers. Make sure IDA_SDK_SOURCE_DIR is set to the root of the IDA SDK source repository.
#######################################################
")

mark_as_advanced(IDA_SDK_MAIN_HEADER)

if(IDA_SDK_FOUND)
	set(IDA_SDK_INCLUDE_DIRS "${IDA_SDK_SOURCE_ROOT}/include")
	if(WIN32)
		set(IDA_SDK_LIBS_IDA64 "${IDA_SDK_SOURCE_ROOT}/lib/x64_win_vc_64/ida.lib")
		set(IDA_SDK_LIBS_IDA32 "${IDA_SDK_SOURCE_ROOT}/lib/x64_win_vc_32/ida.lib")
	else()
		set(IDA_SDK_LIBS_IDA64 "${IDA_SDK_SOURCE_ROOT}/lib/x64_linux_gcc_64/libida64.so")
		set(IDA_SDK_LIBS_IDA32 "${IDA_SDK_SOURCE_ROOT}/lib/x64_linux_gcc_32/libida.so")
	endif()
endif()

```

`cmake/FindTTDReplay.cmake`:

```cmake
############################################
# Use to find dll of Time Travel Debugging #
############################################
# OUTPUT is ${TTDReplay_INSTALL_PATH} set with the correct path
# INSTALL_TTDREPLAY macro use to copy ttd dll files

set(WindbgPreview_INSTALL_PATH "$ENV{ProgramFiles}/WindowsApps/Microsoft.WinDbg_1.2202.7001.0_neutral__8wekyb3d8bbwe/amd64/ttd")

find_path(
	TTDReplay_INSTALL_PATH
	NAMES TTDReplay.dll
	PATHS "${WindbgPreview_INSTALL_PATH}"
	NO_DEFAULT_PATH
)

include(FindPackageHandleStandardArgs)
FIND_PACKAGE_HANDLE_STANDARD_ARGS(
    TTDReplay
	REQUIRED_VARS TTDReplay_INSTALL_PATH
    FAIL_MESSAGE "
#######################################################
Could not find Time Travel Debugging dll. Make sure you installed windbg preview edition or disable using -DINSTALL_TTDDLL=OFF
#######################################################
")

macro(INSTALL_TTDREPLAY DESTINATION)

install(FILES "${TTDReplay_INSTALL_PATH}/TTDReplay.dll" DESTINATION ${DESTINATION})
install(FILES "${TTDReplay_INSTALL_PATH}/TTDReplayCPU.dll" DESTINATION ${DESTINATION})

endmacro(INSTALL_TTDREPLAY)

```

`install/patch.xml`:

```xml
<CPackWiXPatch>
	<CPackWiXFragment Id="#PRODUCT">
		<Property Id="TTDPACKAGENAME">
			<RegistrySearch Id='TTDPACKAGENAME' Type='raw' Root='HKCR' Key='Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\SystemAppData\Microsoft.WinDbg_8wekyb3d8bbwe\Schemas' Name='PackageFullName' />
		</Property>
 
		<Condition Message="Windbg Preview Not Found. Please Install It Before.">
		  <![CDATA[Installed OR TTDPACKAGENAME]]>
		</Condition>
		
		<SetProperty Id="TTD" Value='[ProgramFiles64Folder]WindowsApps\[TTDPACKAGENAME]\amd64\ttd' Before="AppSearch"/>

		<Component Id="InstallTDD" Guid="4d084a02-bbbb-4e86-a1ba-b950afc930e8" Directory="INSTALL_ROOT" Feature="ProductFeature">
			<CopyFile Id="CopyTTDReplay" SourceProperty="TTD" SourceName="TTDReplay.dll" DestinationProperty="INSTALL_ROOT" DestinationName="TTDReplay.dll"/>
			<CopyFile Id="CopyTTDReplayCPU" SourceProperty="TTD" SourceName="TTDReplayCPU.dll" DestinationProperty="INSTALL_ROOT" DestinationName="TTDReplayCPU.dll"/>
		</Component>
	</CPackWiXFragment>
</CPackWiXPatch> 
```

`tests/CMakeLists.txt`:

```txt
add_library(ttddbg_test_dll SHARED test_dll.cc)
target_compile_features(ttddbg_test_dll PRIVATE cxx_std_17)

add_executable(ttddbg_test_multithread test_multithread.cc)
target_compile_features(ttddbg_test_multithread PRIVATE cxx_std_17)

add_executable(ttddbg_test_exceptions test_exceptions.cc)
target_compile_features(ttddbg_test_exceptions PRIVATE cxx_std_17)

```

`tests/test_dll.cc`:

```cc
#include <Windows.h>
#include <thread>
#include <mutex>
#include <iostream>

void display(int start, int nb)
{
    auto heap = (char*)malloc(0x10);
    memset(heap, 0, 0x10);
    heap[5] = 0x77;
    // put a breakpoint here in the trace!
    std::cout << "hello from thread " << std::endl;
    for (int i = start; i < start + nb; ++i)
        std::cout << i << ",";
}

BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,  // handle to DLL module
    DWORD fdwReason,     // reason for calling function
    LPVOID lpReserved)  // reserved
{
    // Perform actions based on the reason for calling.
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        // Initialize once for each new process.
        // Return FALSE to fail DLL load.
        break;

    case DLL_THREAD_ATTACH:
        // Do thread-specific initialization.
        break;

    case DLL_THREAD_DETACH:
        // Do thread-specific cleanup.
        break;

    case DLL_PROCESS_DETACH:
        // Perform any necessary cleanup.
        break;
    }
    return TRUE;  // Successful DLL_PROCESS_ATTACH.
}


extern "C" __declspec(dllexport) void __cdecl Run(void)
{
    std::thread t1(display, 0, 5);
    std::thread t2([]() { display(5, 5); });
    t1.join();
    t2.join();
    Sleep(60000);
}
```

`tests/test_exceptions.cc`:

```cc


#include <thread>
#include <mutex>
#include <iostream>
void test_cpp_exception()
{
	try
	{
		throw "My c++ exception";
	}
	catch (...)
	{
		std::cout << "Exception c++" << std::endl;
	}
}

void test_structured_exception()
{
	__try
	{
		// Test write access violation
		auto myArray = new uint8_t[5];
		myArray = nullptr;

		myArray[500] = 5;
	}
	__finally
	{
		std::cout << "Exception write acess" << std::endl;
	}
}



int main() {

	test_cpp_exception();
	test_structured_exception();
	return 0;
}
```

`tests/test_multithread.cc`:

```cc


#include <thread>
#include <mutex>
#include <iostream>
void display(int start, int nb)
{
	auto heap = (char*)malloc(0x10);
	memset(heap, 0, 0x10);
	heap[5] = 0x77;
	// put a breakpoint here in the trace!
	std::cout << "hello from thread " << std::endl;
	for (int i = start; i < start + nb; ++i)
		std::cout << i << ",";
}
int main() {
	std::thread t1(display, 0, 5);
	std::thread t2([]() { display(5, 5); });
	t1.join();
	t2.join();

	return 0;
}
```

`ttddbg/CMakeLists.txt`:

```txt
#####################################################
########### Static library use for test #############
#####################################################
# needs IDA SDK for backend
find_package(IdaSdk)

set(ttddbg_STATIC_SRC
	../ttd-bindings/TTD/TTD.cpp
	../ttd-bindings/TTD/sha256.cpp
	../ttd-bindings/TTD/utils.cpp
	src/ttddbg_plugin.cc
	src/ttddbg_debugger.cc
	src/ttddbg_debugger_x86.cc
	src/ttddbg_debugger_x86_64.cc
	src/ttddbg_debugger_manager.cc
	src/ttddbg_logger_ida.cc
	src/ttddbg_event_deque.cc
	src/ttddbg_strings.cc
	src/ttddbg_action.cc
	src/ttddbg_position_chooser.cc
)

set(ttddbg_STATIC_INCLUDE
	../ttd-bindings/TTD/TTD.hpp
	../ttd-bindings/TTD/sha256.h
	../ttd-bindings/TTD/utils.h
	include/ttddbg_debugger.hh
	include/ttddbg_debugger_x86.hh
	include/ttddbg_debugger_x86_64.hh
	include/ttddbg_debugger_manager_interface.hh
	include/ttddbg_debugger_manager.hh
	include/ttddbg_plugin.hh
	include/ttddbg_logger.hh
	include/ttddbg_logger_ida.hh
	include/ttddbg_event_deque.hh
	include/ttddbg_strings.hh
	include/ttddbg_action.hh
	include/ttddbg_position_chooser.hh
	include/ttddbg_x86_registers.hh
	include/single_step_icon.hh
	include/resume_backwards_icon.hh
)

add_library(ttddbg_static STATIC ${ttddbg_STATIC_INCLUDE} ${ttddbg_STATIC_SRC})
target_compile_features(ttddbg_static PRIVATE cxx_std_17)

target_include_directories(
	ttddbg_static
	INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
	PRIVATE ${CMAKE_CURRENT_SOURCE_DIR} ${IDA_SDK_INCLUDE_DIRS} include
)

target_link_libraries(ttddbg_static)

# ttddbg sources
set(ttddbg_SRC
	${ttddbg_STATIC_SRC}
)

set(ttddbg_INCLUDE
	${ttddbg_STATIC_INCLUDE}
)

if(MSVC)
	add_definitions(
		/wd4267
		/wd4244
		/wd4099
	)
endif()

##########################################################
############# build target ttddbg64 ##################
##########################################################
add_library(ttddbg64 SHARED ${ttddbg_INCLUDE} ${ttddbg_SRC})
target_compile_features(ttddbg64 PRIVATE cxx_std_17)

target_include_directories(
	ttddbg64
	INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
	PRIVATE ${CMAKE_CURRENT_SOURCE_DIR} ${IDA_SDK_INCLUDE_DIRS} include
)

install(TARGETS ttddbg64
       RUNTIME DESTINATION plugins
       LIBRARY DESTINATION plugins
)

target_compile_definitions(ttddbg64 PRIVATE __EA64__)

set_target_properties(ttddbg64 PROPERTIES 
	OUTPUT_NAME "ttddbg64"
	PREFIX ""
)

if(MSVC)
	target_compile_definitions(ttddbg64 PRIVATE __NT__)
endif()

target_link_libraries(ttddbg64 ${IDA_SDK_LIBS_IDA64})

#####################################################
# Target for Ida 32, but need to be built in 64 bits#
#####################################################

add_library(ttddbg SHARED ${ttddbg_INCLUDE} ${ttddbg_SRC})

target_compile_features(ttddbg PRIVATE cxx_std_17)

target_include_directories(
	ttddbg
	INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
	PRIVATE ${CMAKE_CURRENT_SOURCE_DIR} ${IDA_SDK_INCLUDE_DIRS} include
)

install(TARGETS ttddbg
	RUNTIME DESTINATION plugins
	LIBRARY DESTINATION plugins
)

set_target_properties(ttddbg PROPERTIES 
	OUTPUT_NAME "ttddbg"
	PREFIX ""
)

if(MSVC)	
	target_compile_definitions(ttddbg PRIVATE __NT__)
endif()

target_link_libraries(ttddbg ${IDA_SDK_LIBS_IDA32})

```

`ttddbg/include/resume_backwards_icon.hh`:

```hh
#ifndef HEADER_BIN2H_resumebackwards_png
#define HEADER_BIN2H_resumebackwards_png

const unsigned char resumebackwards_png[] = {0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a, 0xa, 0x0, 0x0, 0x0, 0xd, 0x49, 0x48, 0x44, 0x52, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x10, 0x8, 0x6, 0x0, 0x0, 0x0, 0x1f, 0xf3, 0xff, 0x61, 0x0, 0x0, 0x0, 0x1, 0x73, 0x52, 0x47, 0x42, 0x0, 0xae, 0xce, 0x1c, 0xe9, 0x0, 0x0, 0x0, 0x4, 0x67, 0x41, 0x4d, 0x41, 0x0, 0x0, 0xb1, 0x8f, 0xb, 0xfc, 0x61, 0x5, 0x0, 0x0, 0x0, 0x9, 0x70, 0x48, 0x59, 0x73, 0x0, 0x0, 0xe, 0xc3, 0x0, 0x0, 0xe, 0xc3, 0x1, 0xc7, 0x6f, 0xa8, 0x64, 0x0, 0x0, 0x1, 0x37, 0x49, 0x44, 0x41, 0x54, 0x38, 0x4f, 0x63, 0x18, 0x5a, 0x60, 0xe9, 0xd6, 0xa5, 0xff, 0x6d, 0x92, 0x6c, 0xfe, 0x43, 0xb9, 0xc4, 0x83, 0x4b, 0x37, 0x2e, 0x81, 0x35, 0xf2, 0xfa, 0x8, 0xff, 0x67, 0x30, 0x66, 0x20, 0xcd, 0x80, 0x8a, 0x49, 0x15, 0xff, 0x59, 0xed, 0xd8, 0xff, 0x1b, 0xcc, 0xf1, 0xf8, 0x1f, 0xf7, 0xbd, 0x17, 0xc3, 0x0, 0x26, 0x28, 0x8d, 0x1, 0xa6, 0xad, 0x9c, 0xf6, 0x5f, 0xce, 0x5b, 0xee, 0xff, 0xfc, 0x7b, 0xab, 0x18, 0x6c, 0xa7, 0x45, 0x33, 0x30, 0x3a, 0x6a, 0x30, 0xfc, 0xf8, 0xf1, 0x5, 0x2a, 0x8b, 0x0, 0x18, 0x6, 0x1c, 0x3e, 0x7b, 0x18, 0xec, 0xdc, 0xc2, 0x25, 0xa5, 0xc, 0x2c, 0xe1, 0xa2, 0xc, 0x42, 0x91, 0xfa, 0xc, 0xa7, 0xde, 0x7f, 0x67, 0x38, 0xff, 0xf2, 0x3, 0x61, 0x3, 0x32, 0xdb, 0x32, 0xff, 0xdb, 0xe5, 0xda, 0x31, 0x5c, 0x94, 0xbb, 0xc1, 0x20, 0x9a, 0xa9, 0xcc, 0xf0, 0x96, 0x8f, 0x9b, 0xe1, 0xfa, 0xb3, 0x1f, 0xc, 0x5f, 0x3e, 0x7f, 0x67, 0x0, 0xea, 0xc6, 0x6f, 0x0, 0xc8, 0xaf, 0xd3, 0x77, 0x4d, 0x67, 0x60, 0x8d, 0xe0, 0x60, 0xf8, 0xaf, 0xca, 0xca, 0xf0, 0xec, 0x19, 0x33, 0xc3, 0xc7, 0xf7, 0xbf, 0xc1, 0x1a, 0x19, 0x7e, 0xfe, 0x24, 0x6c, 0x40, 0x47, 0x5e, 0x7, 0x63, 0xa6, 0x5b, 0x26, 0xc3, 0xaf, 0x15, 0xdf, 0x19, 0x7e, 0x5e, 0x7e, 0xcf, 0xc0, 0xcd, 0xf5, 0x8c, 0x81, 0x9d, 0xe9, 0x13, 0xc4, 0x0, 0xa8, 0x21, 0x4, 0xbd, 0x30, 0xbd, 0x6a, 0x3a, 0xe3, 0xe1, 0xc9, 0x87, 0x19, 0xcc, 0x5f, 0x99, 0x30, 0x7c, 0x5d, 0xf4, 0x86, 0x81, 0xf5, 0xd5, 0x73, 0x6, 0x1, 0x2e, 0x20, 0xfd, 0xf7, 0x1b, 0x61, 0x17, 0xc0, 0x80, 0xad, 0xb1, 0x2d, 0xe3, 0x91, 0x79, 0x47, 0x18, 0xa7, 0x24, 0x4e, 0x66, 0x60, 0xde, 0xf2, 0x97, 0xe1, 0xdb, 0xf6, 0xa7, 0xc, 0x2, 0x2c, 0x2f, 0x19, 0x84, 0xd8, 0x3f, 0x62, 0x35, 0x80, 0x20, 0x0, 0x85, 0xd, 0xa3, 0x35, 0xd3, 0x7f, 0xbe, 0x2a, 0xd1, 0xff, 0x72, 0xdb, 0xf5, 0x48, 0x4f, 0x48, 0x20, 0x0, 0x4b, 0x89, 0xcc, 0xce, 0xac, 0xe4, 0x19, 0x0, 0x3, 0x64, 0xe7, 0x5, 0xdc, 0x80, 0x81, 0x1, 0x0, 0x8b, 0x4d, 0x9c, 0xc7, 0xb9, 0xce, 0x81, 0x7f, 0x0, 0x0, 0x0, 0x0, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82};
size_t resumebackwards_png_length = 418;

#endif

```

`ttddbg/include/single_step_icon.hh`:

```hh
#ifndef HEADER_BIN2H_singlestep_png
#define HEADER_BIN2H_singlestep_png

const unsigned char singlestep_png[] = {0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a, 0xa, 0x0, 0x0, 0x0, 0xd, 0x49, 0x48, 0x44, 0x52, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x10, 0x8, 0x3, 0x0, 0x0, 0x0, 0x28, 0x2d, 0xf, 0x53, 0x0, 0x0, 0x0, 0x1, 0x73, 0x52, 0x47, 0x42, 0x0, 0xae, 0xce, 0x1c, 0xe9, 0x0, 0x0, 0x0, 0x4, 0x67, 0x41, 0x4d, 0x41, 0x0, 0x0, 0xb1, 0x8f, 0xb, 0xfc, 0x61, 0x5, 0x0, 0x0, 0x0, 0x39, 0x50, 0x4c, 0x54, 0x45, 0x96, 0xa9, 0xd0, 0x3c, 0x62, 0xaf, 0x5a, 0x7a, 0xb9, 0x0, 0x33, 0x99, 0x4f, 0x7c, 0xd7, 0x7f, 0xa8, 0xfc, 0xa9, 0xc3, 0xf7, 0x1e, 0x4b, 0xa4, 0xe1, 0xe4, 0xeb, 0xb4, 0xc1, 0xda, 0x87, 0x9d, 0xca, 0x78, 0x92, 0xc5, 0xf, 0x3f, 0x9e, 0x40, 0x6e, 0xcb, 0xc6, 0xd5, 0xf5, 0x8d, 0xb1, 0xfa, 0x5f, 0x8b, 0xe3, 0x30, 0x5f, 0xbe, 0x0, 0x0, 0x0, 0xde, 0xf1, 0x6a, 0x5f, 0x0, 0x0, 0x0, 0x13, 0x74, 0x52, 0x4e, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xb2, 0x7d, 0xdc, 0x8, 0x0, 0x0, 0x0, 0x9, 0x70, 0x48, 0x59, 0x73, 0x0, 0x0, 0xe, 0xc3, 0x0, 0x0, 0xe, 0xc3, 0x1, 0xc7, 0x6f, 0xa8, 0x64, 0x0, 0x0, 0x0, 0x5c, 0x49, 0x44, 0x41, 0x54, 0x28, 0x53, 0x9d, 0x8d, 0x4b, 0x12, 0x80, 0x20, 0xc, 0x43, 0x2b, 0xb5, 0x22, 0xfe, 0xed, 0xfd, 0xf, 0x2b, 0xfd, 0x9, 0x33, 0xee, 0x7c, 0xb, 0x8, 0xa1, 0x4d, 0x80, 0x5, 0x18, 0xf4, 0x12, 0xd4, 0x48, 0x38, 0x12, 0x4d, 0xfa, 0x56, 0x3, 0x8d, 0xac, 0x9f, 0x3e, 0x1, 0x3c, 0x97, 0x84, 0x4b, 0x18, 0x9e, 0xb1, 0x6e, 0x22, 0x45, 0x39, 0x5, 0xeb, 0xd1, 0x4f, 0x34, 0x43, 0x5b, 0x88, 0xf6, 0x58, 0x89, 0x96, 0x16, 0xfa, 0xa7, 0xc5, 0xf8, 0x18, 0xdd, 0xca, 0x71, 0x12, 0x5d, 0xf7, 0x1b, 0xa, 0xd9, 0x6a, 0xab, 0x66, 0x7e, 0x0, 0x17, 0x4c, 0xd, 0x88, 0x17, 0xa8, 0xbe, 0x1b, 0x0, 0x0, 0x0, 0x0, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82};
size_t singlestep_png_length = 299;

#endif

```

`ttddbg/include/ttddbg_action.hh`:

```hh
#ifndef __TTDDBG_ACTION__
#define __TTDDBG_ACTION__

#include <ida.hpp>
#include <idp.hpp>

namespace ttddbg 
{
	/*!
	 * \brief	Describe the new action introduce by the time travel debugging
	 *			The backward action will back in time until the debugger saw a debugger 
	 *			breakpoint or reach the starting point
	 */
	struct BackwardStateRequest : public action_handler_t
	{
		inline static const char* actionName = "ttddbg:Backward";
		inline static const char* actionLabel = "ttddbg Backward";
		inline static const char* actionHotkey = "F3";

		virtual int idaapi activate(action_activation_ctx_t*) override;
		virtual action_state_t idaapi update(action_update_ctx_t*) override;
	};

	/*!
	 * \brief	Describe the new action introduce by the time travel debugging
	 *			Single step will just use backward debugger with a singe step
	 *			Be carefull it will not understand jump (like in the function calling case)
	 *			It will just decrement the EIP correctly
	 */
	struct BackwardSingleStepRequest : public action_handler_t
	{
		inline static const char* actionName = "ttddbg:BackwardSingle";
		inline static const char* actionLabel = "Single-step backwards";
		inline static const char* actionHotkey = "Ctrl+F8";

		virtual int idaapi activate(action_activation_ctx_t*) override;
		virtual action_state_t idaapi update(action_update_ctx_t*) override;
	};

	/*!
	 * \brief	Action use to manage the position chooser (aka the timeline)
	 */
	struct OpenPositionChooserAction : public action_handler_t 
	{
		inline static const char* actionName = "ttddbg:ChoosePosition";
		inline static const char* actionLabel = "Timeline";

		virtual int idaapi activate(action_activation_ctx_t*) override;
		virtual action_state_t idaapi update(action_update_ctx_t*) override;
	};
}

#endif
```

`ttddbg/include/ttddbg_debugger.hh`:

```hh
#ifndef __TTDDBG_DEBUGGER__
#define __TTDDBG_DEBUGGER__

#include <ida.hpp>
#include <idd.hpp>
#include <Windows.h>
#include "ttddbg_logger.hh"
#include "ttddbg_debugger_manager_interface.hh"

namespace ttddbg 
{
	/*!
	 * \brief	Main debugger object 
	 */
	class Debugger : public debugger_t
	{
	protected:
		/*!
		 * \brief	logger interface 
		 */
		std::shared_ptr<Logger> m_logger;

		/*!
		 * \brief	Debugger manager
		 *			Use to manage debugger autoata
		 */
		std::unique_ptr<IDebuggerManager> m_manager;

		/*!
		 *	\brief	main callback use by IDA to check debugger internal state 
		 */
		static ssize_t idaapi debugger_callback(void*, int notification_code, va_list va);
		
	public:
		/*!
		 * \brief	ctor
		 * \param	logger	logger interface to print informations messages
		 * \param	manager	debugger automata
		 */
		explicit Debugger(std::shared_ptr<ttddbg::Logger> logger, std::unique_ptr<IDebuggerManager>&& manager);

		/*!
		 * \brief	Retrieve the manager for 
		 */
		IDebuggerManager& getManager();
	};
}

#endif
```

`ttddbg/include/ttddbg_debugger_manager.hh`:

```hh
#ifndef __TTDDBG_DEBUGGER_MANGER__
#define __TTDDBG_DEBUGGER_MANGER__

#include "ttddbg_debugger_manager_interface.hh"
#include "ttddbg_logger.hh"
#include "ttddbg_event_deque.hh"
#include "ttddbg_position_chooser.hh"
#include <deque>
#include <memory>
#include <Windows.h>
#include <filesystem>
#include "../../ttd-bindings/TTD/TTD.hpp"

namespace ttddbg 
{
	/*!
	 * \brief	Main implementation of the Time Travel debugger
	 *			Automata for IDA
	 */
	class DebuggerManager : public IDebuggerManager
	{
		friend PositionChooser;

	public:
		/*!
		 *	\brief size of architecture
		 */
		enum Arch
		{
			ARCH_32_BITS = 4,
			ARCH_64_BITS = 8
		};

	protected:

		/*!
		 * \brief	Current debugger architecture
		 */
		Arch	m_arch;

		/*!
		 * \brief	Time travel debugger interface
		 */
		TTD::ReplayEngine m_engine;

		/*!
		 * \brief	current state of the time travel debugger
		 */
		std::shared_ptr<TTD::Cursor> m_cursor;

		/*!
		 * \brief	main logger use to print informationals messages
		 */
		std::shared_ptr<ttddbg::Logger> m_logger;

		/*!
		 * \brief	main event queue use to send message to IDA debugger thread
		 */
		EventDeque m_events;

		/*!
		 * \brief	I'm forward or backward state
		 *			Time travel debugging baby!
		 */
		bool m_isForward;

		/*!
		 * \brief	State resume mode when process is resume
		 */
		resume_mode_t m_resumeMode;

		/*!
		 * \brief	State chooser window
		 */
		PositionChooser *m_positionChooser;

		/*!
		* \brief	The next position to which the cursor should go. If it is {0, 0}, continue as normal.
		*			If it is *not* {0, 0}, divert the control flow to set the position to this one, and set 
		*			it to {0, 0} afterwards.
		*/
		TTD::Position m_nextPosition;

		/*!
		* \brief	Flag holding whether the "next action" should be a Backwards Single Step. If "true",
		*			instead of doing the normal action, force the TTD engine to go back in time for a single
		*			instruction. Then, set to "false".
		*/
		bool m_backwardsSingleStep;	

		/*!
		 * \brief	Fake process id
		 */
		pid_t m_processId;

		/*!
		 * \brief	the module of interest (the main module loaded by IDA)
		 */
		std::filesystem::path m_targetImagePath;

		/*!
		 * \brief	use to known if the current module is the one currently reversed
		 * \param	module	module to process
		 * \return	true if the TTD module is the one loaded into IDA
		 */
		bool isTargetModule(const TTD::TTD_Replay_Module& module);

		/*!
		* \brief	Automatically adds notable events to the Timeline (position_chooser). Notable events include:
		*			thread creation, thread exit, module load, module unload
		*/
		void populatePositionChooser();

	public:

		/*!
		 * \brief	ctor
		 * \param	logger	logger use to print message
		 */
		explicit DebuggerManager(std::shared_ptr< ttddbg::Logger> logger, Arch arch);

		/*!
		 * \brief	First state of the automata
		 * \param	hostname	use in case of remote debugging
		 * \param	portNumber	host port in case of remote debugging
		 * \param	password	remote password
		 * \param	errbuf		use to signal error
		 */
		ssize_t onInit(std::string& hostname, int portNumber, std::string& password, qstring* errBuf) override;

		/*!
		 * \brief	When terminate a debugger
		 */
		ssize_t OnTermDebugger() override;

		/*!
		 * \brief	Event use to get information about the current debugging process
		 * \param	infos	list of processes started by debugger (name and pid)
		 */
		ssize_t onGetProcess(procinfo_vec_t* infos, qstring* errBuf) override;

		/*!
		 * \brief	Debugger ask to start a process
		 * \param	path	path to the executable, we will use this parameter for input run files
		 * \param	args	arguments path to the executable
		 * \param	startdir	working directory
		 * \param	flags	startup flags
		 * \param	image input files
		 * \param	inputFileCRC32	use to check if image is aligned with debugging process
		 */
		ssize_t onStartProcess(const char* path, const char* args, const char* startdir, uint32 flags, const char* inputPath, uint32 inputFileCRC32, qstring* errbuf = nullptr) override;
		
		/*!
		 * \brief	use to get debug attributes
		 * \param	attrs	debug attributes
		 */
		ssize_t onGetDebappAttrs(debapp_attrs_t* attrs) override;

		/*!
		 * \brief	Main event to get current debug event
		 *			Will be used to pop from the event queue
		 * \param	code	use to to set if pending events exist in the queue
		 * \param	event	output event
		 * \param	timeout_ms
		 */
		ssize_t onGetDebugEvent(gdecode_t* code, debug_event_t* event, int timeout_ms) override;

		/*!
		 * \brief	Get memory information, like segment with module named
		 *			We can know wich address is used by which module
		 * \param	infos	list of memory infos
		 */
		ssize_t onGetMemoryInfo(meminfo_vec_t* infos, qstring* errbuf = nullptr) override;

		/*!
		 * \brief	Set exception configuration of the debugger
		 * \param	info	exception informations
		 */
		ssize_t onSetExceptionInfo(exception_info_t* info, int qty) override;

		/*!
		 * \brief	Read memory at a special process address
		 * \param	nbytes	number of bytes read (out)
		 * \param	ea		memory address to read
		 * \param	buffer	output buffer
		 * \param	size	buffer size
		 */
		ssize_t onReadMemory(size_t* nbytes, ea_t ea, void* buffer, size_t size, qstring* errbuf = nullptr) override;

		/*!
		 * \brief	If a rebase is required, we have to rebase the image
		 * \param	newBase	new base address of the IDA database	
		 */
		ssize_t onRebaseIfRequiredTo(ea_t newBase) override;

		/*!
		 * \brief	use to inform the plugin to the resume state
		 * \param	event	the event before the resume
		 */
		ssize_t onResume(debug_event_t* event) override;

		/*!
		 * \brief	Inform the backend that the debugger is in the suspended state
		 * \param	dllsAdded	boolean inform that new dll has been added
		 * \param	thrNames	current thread 
		 */
		ssize_t onSuspended(bool dllsAdded, thread_name_vec_t* thrNames) override;

		/*!
		 * \brief	Ask debugger to exit the debugging process
		 * \param	errbuf	error buffer
		 */
		ssize_t onExitProcess(qstring* errbuf = nullptr) override;

		/*!
		 * \brief	use to retrieve compiler source files
		 */
		ssize_t onGetSrcinfoPath(qstring* path, ea_t base) override;

		/*!
		 * \brief	use to inform new and deleted breakpoint
		 */
		ssize_t onUpdateBpts(int* nbpts, update_bpt_info_t* bpts, int nadd, int ndel, qstring* errbuf) override;

		/*!
		 * \brief	When debugger is resumed
		 */
		ssize_t onSetResumeMode(thid_t tid, resume_mode_t resmod) override;

		/*!
		 * \brief	When call stack is updated
		 */
		ssize_t onUpdateCallStack(thid_t tid, call_stack_t* trace) override;

		/*!
		 * \brief	Run steps and emit code for loaded and unloaded module
		 * \param	steps	Number of steps to run -1 to run until next breakpoint
		 */
		void applyCursor(int steps);

		/*!
		 * \brief run the cursor directly at a special positon
		 * \param	newPos	target position
		 */
		void applyCursor(TTD::Position newPos);

		/*!
		 * \brief	change the way you debug : Welcome time travel debugger !
		 */
		void switchWay() override;

		/*!
		 * \brief	Request a single step debugging but in backward way ! 
		 */
		void requestBackwardsSingleStep() override;

		/*!
		 * \brief	Open the timeline
		 */
		void openPositionChooser() override;

		void setNextPosition(TTD::Position newPos) override;

	private:

		std::set<uint32_t> getCursorThreads();
		std::set<TTD::TTD_Replay_Module*> getCursorModules();

		/*!
		 * \brief	Compute the diff between two position (forward and backward)
		 *			And emit the appropriate debug event
		 * \param	threadsBefore	List of thread id before the change of position
		 * \param	threadsAfter	List of thread id after the change of position
		 * \param	modulesBefore	List of modules loaded before the change of position
		 * \param	modulesAfter	List of modules loaded after the change of position
		 */
		void applyDifferences(std::set<uint32_t> threadsBefore, std::set<uint32_t> threadsAfter, std::set<TTD::TTD_Replay_Module*> modulesBefore, std::set<TTD::TTD_Replay_Module*> modulesAfter);
	};
}

#endif
```

`ttddbg/include/ttddbg_debugger_manager_interface.hh`:

```hh
#ifndef __TTDDBG_DEBUGGER_MANAGER_INTERFACE__
#define __TTDDBG_DEBUGGER_MANAGER_INTERFACE__

#include <ida.hpp>
#include <idd.hpp>

#include <Windows.h>
#include "../../ttd-bindings/TTD/TTD.hpp"

namespace ttddbg 
{
	/*!
	 * \brief	IDA debugger interface
	 */
	class IDebuggerManager
	{
	public:
		/*!
		 * \brief	First state of the automata
		 * \param	hostname	use in case of remote debugging
		 * \param	portNumber	host port in case of remote debugging
		 * \param	password	remote password
		 * \param	errbuf		use to signal error
		 */
		virtual ssize_t onInit(std::string& hostname, int portNumber, std::string& password, qstring* errBuf) = 0;

		/*!
		 * \brief	When terminate a debugger
		 */
		virtual ssize_t OnTermDebugger() = 0;

		/*!
		 * \brief	Event use to get information about the current debugging process
		 * \param	infos	list of processes started by debugger (name and pid)
		 */
		virtual ssize_t onGetProcess(procinfo_vec_t* infos, qstring* errBuf) = 0;

		/*!
		 * \brief	Debugger ask to start a process
		 * \param	path	path to the executable
		 * \param	args	arguments path to the executable
		 * \param	startdir	working directory
		 * \param	flags	startup flags
		 * \param	image input files
		 * \param	inputFileCRC32	use to check if image is aligned with debugging process
		 */
		virtual ssize_t onStartProcess(const char* path, const char* args, const char* startdir, uint32 dbg_proc_flags, const char* input_path, uint32 input_file_crc32, qstring* errbuf = nullptr) = 0;

		/*!
		 * \brief	use to get debug attributes
		 * \param	attrs	debug attributes
		 */
		virtual ssize_t onGetDebappAttrs(debapp_attrs_t* out_pattrs) = 0;

		/*!
		 * \brief	Main event to get current debug event
		 *			Will be used to pop from the event queue
		 * \param	code	use to to set if pending events exist in the queue
		 * \param	event	output event
		 * \param	timeout_ms
		 */
		virtual ssize_t onGetDebugEvent(gdecode_t* code, debug_event_t* event, int timeout_ms) = 0;

		/*!
		 * \brief	Get memory information, like segment with module named
		 *			We can know wich address is used by which module
		 * \param	infos	list of memory infos
		 */
		virtual ssize_t onGetMemoryInfo(meminfo_vec_t* infos, qstring* errbuf = nullptr) = 0;

		/*!
		 * \brief	Set exception configuration of the debugger
		 * \param	info	exception informations
		 */
		virtual ssize_t onSetExceptionInfo(exception_info_t* info, int qty) = 0;

		/*!
		 * \brief	Read memory at a special process address
		 * \param	nbytes	number of bytes read (out)
		 * \param	ea		memory address to read
		 * \param	buffer	output buffer
		 * \param	size	buffer size
		 */
		virtual ssize_t onReadMemory(size_t* nbytes, ea_t ea, void* buffer, size_t size, qstring* errbuf = nullptr) = 0;

		/*!
		 * \brief	If a rebase is required, we have to rebase the image
		 * \param	newBase	new base address of the IDA database
		 */
		virtual ssize_t onRebaseIfRequiredTo(ea_t newBase) = 0;

		/*!
		 * \brief	use to inform the plugin to the resume state
		 * \param	event	the event before the resume
		 */
		virtual ssize_t onResume(debug_event_t* event) = 0;

		/*!
		 * \brief	use to inform the debugger to read register state
		 * \param	tid	thread id
		 * \param	clsmask	class mask (for xample x86 class mask)
		 * \param	values	output register state, follow declaration of the debugger
		 * \param	errbuf	buffer error to inform state
		 */
		virtual ssize_t onReadRegisters(thid_t tid, int clsmask, regval_t* values, qstring* errbuf) = 0;

		/*!
		 * \brief	Inform the backend that the debugger is in the suspended state
		 * \param	dllsAdded	boolean inform that new dll has been added
		 * \param	thrNames	current thread
		 */
		virtual ssize_t onSuspended(bool dllsAdded, thread_name_vec_t* thrNames) = 0;

		/*!
		 * \brief	Ask debugger to exit the debugging process
		 * \param	errbuf	error buffer
		 */
		virtual ssize_t onExitProcess(qstring* errbuf = nullptr) = 0;

		/*!
		 * \brief	use to retrieve compiler source files
		 */
		virtual ssize_t onGetSrcinfoPath(qstring* path, ea_t base) = 0;

		/*!
		 * \brief	use to inform new and deleted breakpoint
		 */
		virtual ssize_t onUpdateBpts(int* nbpts, update_bpt_info_t* bpts, int nadd, int ndel, qstring* errbuf) = 0;

		/*!
		 * \brief	use to know if the resume is due to step of play
		 */
		virtual ssize_t onSetResumeMode(thid_t tid, resume_mode_t resmod) = 0;

		/*!
		* \brief	Sets the m_nextPosition attribute to the parameter.
		* \param	The next position which should be assumed by the cursor.
		*/
		virtual void setNextPosition(TTD::Position) = 0;

		virtual ssize_t onUpdateCallStack(thid_t tid, call_stack_t* trace) = 0;
		
		virtual void switchWay() = 0;
		virtual void requestBackwardsSingleStep() = 0;
		virtual void openPositionChooser() = 0;
	};
}

#endif
```

`ttddbg/include/ttddbg_debugger_x86.hh`:

```hh
#ifndef __TTDDBG_DEBUGGERX86__
#define __TTDDBG_DEBUGGERX86__

#include <ida.hpp>
#include <idd.hpp>
#include <Windows.h>
#include "ttddbg_debugger.hh"
#include "ttddbg_debugger_manager.hh"

namespace ttddbg 
{
	/*!
	 * \brief	x86 debugger object
	 */
	class DebuggerX86 : public Debugger
	{
	public:
		/*!
		 * \brief	ctor
		 * \param	logger	logger interface to print informations messages
		 */
		explicit DebuggerX86(std::shared_ptr<ttddbg::Logger> logger);
	};

	/*!
	 * \brief	specialized debugger manager for x86
	 */
	class DebuggerManagerX86 : public DebuggerManager
	{
	public:
		/*!
		 * \brief	ctor
		 */
		explicit DebuggerManagerX86(std::shared_ptr< ttddbg::Logger> logger);

		/*!
		 * \brief	use to inform the debugger to read register state
		 * \param	tid	thread id
		 * \param	clsmask	class mask (for xample x86 class mask)
		 * \param	values	output register state, follow declaration of the debugger
		 * \param	errbuf	buffer error to inform state
		 */
		ssize_t onReadRegisters(thid_t tid, int clsmask, regval_t* values, qstring* errbuf) override;
	};
}

#endif
```

`ttddbg/include/ttddbg_debugger_x86_64.hh`:

```hh
#ifndef __TTDDBG_DEBUGGERX86_64__
#define __TTDDBG_DEBUGGERX86_64__

#include <ida.hpp>
#include <idd.hpp>
#include <Windows.h>

#include "ttddbg_debugger.hh"
#include "ttddbg_debugger_manager.hh"

namespace ttddbg
{
	/*!
	 * \brief	x86 debugger object
	 */
	class DebuggerX86_64 : public Debugger
	{
	public:
		/*!
		 * \brief	ctor
		 * \param	logger	logger interface to print informations messages
		 */
		explicit DebuggerX86_64(std::shared_ptr<ttddbg::Logger> logger);
	};

	/*!
	 * \brief	specialized debugger manager for x86_64
	 */
	class DebuggerManagerX86_64 : public DebuggerManager
	{
	public:
		/*!
		 * \brief	ctor
		 */
		explicit DebuggerManagerX86_64(std::shared_ptr<ttddbg::Logger> logger);

		/*!
		 * \brief	use to inform the debugger to read register state
		 * \param	tid	thread id
		 * \param	clsmask	class mask (for example x86 class mask)
		 * \param	values	output register state, follow declaration of the debugger
		 * \param	errbuf	buffer error to inform state
		 */
		ssize_t onReadRegisters(thid_t tid, int clsmask, regval_t* values, qstring* errbuf) override;
	};
}

#endif
```

`ttddbg/include/ttddbg_event_deque.hh`:

```hh
#ifndef __TTDDBG_EVENT_DEQUE__
#define __TTDDBG_EVENT_DEQUE__

#include <mutex>
#include <deque>
#include <ida.hpp>
#include <idd.hpp>

namespace ttddbg 
{
	/*!
	 * \brief	A thread safe queue use to manage Debugger events
	 */
	class EventDeque
	{
	protected:
		/*!
		 * \brief	Current event list queue
		 */
		std::deque<debug_event_t> m_events;

		/*!
		 * \brief	Insert and remove mutex
		 *			The thread safe part
		 */
		std::mutex m_safeQueue;

	public:

		/*!
		 * \brief	Push a new event into the queue
		 * \param	newEvent	new event to push
		 */
		void pushEvent(debug_event_t& newEvent);

		/*!
		 * \brief	Pop a pending event
		 *			Be sure you checked with the isEmpty function
		 */
		debug_event_t popEvent();

		/*!
		 * \brief	Check if the event queue is empty
		 * \return	true if empty
		 */
		bool isEmpty();

		/*!
		 * \brief	Create a Process start event and must be the first in the queue
		 * \param	processId	process Id
		 * \param	threadId	Thread id is the first thread created by the process
		 * \param	moduleName	name of the exe module (the main one)
		 * \param	base		base of the main module
		 * \param	rebase_to	if the main module is one loaded into IDA we need to ask for rebase
		 * \param	moduleSize	Size of the main module
		 */
		void addProcessStartEvent(pid_t processId, tid_t threadId, std::string& moduleName, ea_t base, ea_t rebase_to, asize_t moduleSize);
		
		/*!
		 * \brief	New thread star
		 * \param	processId	Process ID
		 * \param	threadId	Id of the new thread
		 */
		void addThreadStartEvent(pid_t processId, tid_t threadId);

		/*!
		 * \brief	Enfd of a particular thread
		 * \param	processId Process ID
		 * \param	threadId	Id of the exited one
		 */
		void addThreadExitEvent(pid_t processId, tid_t threadId);

		/*!
		 * \brief	Inform the debugger that a debugger breakpoint was reached
		 * \param	processID	process ID Id of the current debug process
		 * \param	threadId	thread id where breakpoint is reached
		 * \param	bpk			breakpoint infos
		 */
		void addBreakPointEvent(pid_t processId, tid_t threadId, ea_t bpk);

		/*!
		 * \brief	Inform debuger that a newly module was loaded
		 * \param	base	base of the newly module
		 * \param	rebase_to	if the module is the one loaded into IDA, you must rebase the database
		 * \param	moduleSize	size of the newly module
		 */
		void addLibLoadEvent(std::string& moduleName, ea_t base, ea_t rebase_to, asize_t moduleSize);

		/*!
		 * \brief	Inform the debugger of the unload of a particular moduler
		 * \param	moduleName	name of the unloaded module
		 * \param	base		base of the unloaded module
		 */
		void addLibUnloadEvent(std::string& moduleName, ea_t base);

		/*!
		 * \brief	Inform the debugger of the end of the current debugged process
		 * \param	processID	process ID
		 */
		void addProcessExitEvent(pid_t processId);

		/*!
		 * \brief	Inform debugger of the single step debug event
		 * \param	processId	id of the process
		 * \param	threadId	Id of the main thread
		 */
		void addStepEvent(pid_t processId, tid_t threadId);
	};
}

#endif
```

`ttddbg/include/ttddbg_logger.hh`:

```hh
#ifndef __TTDDBG_ILOGGER__
#define __TTDDBG_ILOGGER__

#include <string>
#include <sstream>
#include <ostream>

namespace ttddbg
{
	/*!
	 * \brief	SFINAE override to manage multiple type
	 *			Use to convert integer type into string
	 */
	template<typename T, typename std::enable_if<std::is_integral<T>::value, T>::type = 0>
	std::string to_string(T p)
	{
		std::stringstream ss;
		ss << p;
		return ss.str();
	}

	/*!
	 * \brief	SFINAE override to manage multiple type
	 *			Use to convert c++ std::string (of it's easy)
	 */
	template<typename T, typename std::enable_if<std::is_same_v<T, std::string>, T>::type = 0>
	std::string to_string(T p)
	{
		return p;
	}

	/*!
	 * \brief	SFINAE override to manage multiple type
	 *			Use to convert C char* string
	 */
	template<typename T, typename std::enable_if<std::is_same_v<T, const char*>, T>::type = 0>
	std::string to_string(T p)
	{
		return std::string(p);
	}

	/*!
	 * \brief	A base class for every logger 
	 */
	class Logger
	{
	private:
		/*!
		 * \brief	Format any message from logger implementation 
		 */
		template<typename... Params>
		void format(const std::string& level, const std::string message, Params... parameters)
		{
			std::stringstream ss;

			ss << "[ttddbg] " << level << " : ";
			for (auto& val : { message, to_string(parameters) ... })
			{
				ss << " " << val;
			}

			ss << std::endl;
			print(ss.str());
		}

		/*!
		 * \brief	Core implementation of the logger
		 *			Must be reimplemented by any subclasses
		 */
		virtual void print(const std::string& message) = 0;

	public:
		
		/*!
		 *	\brief	An error message
		 *			This will be prefixed with the ERROR keyword
		 *  \param	message main message
		 *  \param	parameters	convenient format parameters
		 */
		template<typename... Params>
		void error(const std::string& message, Params... parameters) {
			this->format("ERROR", message, parameters...);
		}

		/*!
		 * \brief	Write an informations log
		 *			This will prefix all message with the INFI prefix
		 */
		template<typename... Params>
		void info(const std::string message, Params... parameters) {
			this->format("INFO", message, parameters...);
		}
	};
}
#endif

```

`ttddbg/include/ttddbg_logger_ida.hh`:

```hh
#ifndef __TTDDBG_IDALOG__
#define __TTDDBG_IDALOG__

#include "ttddbg_logger.hh"

namespace ttddbg
{
	/*!
	 * \brief	The IDA implementation of the ttddbg logger
	 */
	class IdaLogger : public Logger
	{
	public:
		/*!
		 * \brief	Core print for IDA
		 * \param	message	message to print on console
		 */
		void print(const std::string& message) override;
	};
}

#endif
```

`ttddbg/include/ttddbg_plugin.hh`:

```hh
#ifndef __TTDDBG_PLUGIN__
#define __TTDDBG_PLUGIN__

#include <ida.hpp>
#include <idp.hpp>
#include "ttddbg_action.hh"
#include "ttddbg_position_chooser.hh"
#include "single_step_icon.hh"
#include "resume_backwards_icon.hh"

namespace ttddbg 
{
	

	class Plugin : public plugmod_t
	{
	protected:
		/*!
		 * \brief	Backward action declaration
		 *			It's the continue in reverse way
		 *			Use by IDA to know how to print button
		 */
		BackwardStateRequest m_backwardAction;
		const action_desc_t m_backwardActionDesc = ACTION_DESC_LITERAL_PLUGMOD(
			BackwardStateRequest::actionName,
			BackwardStateRequest::actionLabel,
			&m_backwardAction,
			this,
			nullptr,
			nullptr,
			load_custom_icon(resumebackwards_png, resumebackwards_png_length, "PNG")
		);


		/*!
		 * \brief	Show the timeline GUI
		 */
		OpenPositionChooserAction m_positionChooserAction;
		const action_desc_t m_positionChooserActionDesc = ACTION_DESC_LITERAL_PLUGMOD(
			OpenPositionChooserAction::actionName,
			OpenPositionChooserAction::actionLabel,
			&m_positionChooserAction,
			this,
			nullptr,
			nullptr,
			185			// timeline Icon
		);

		/*!
		 * \brief	single instruction pointer decrement
		 */
		BackwardSingleStepRequest m_backwardSingleAction;
		const action_desc_t m_backwardSingleActionDesc = ACTION_DESC_LITERAL_PLUGMOD(
			BackwardSingleStepRequest::actionName,
			BackwardSingleStepRequest::actionLabel,
			&m_backwardSingleAction,
			this,
			nullptr,
			nullptr,
			load_custom_icon(singlestep_png, singlestep_png_length, "PNG")
		);

	public:
		/*!
		 * \brief	Constructoe
		 */
		explicit Plugin();

		/*!
		 * \brief	virtual destructor
		 */
		virtual ~Plugin();

		/*!
		 * \brief main plugin function
		 */
		virtual bool idaapi run(size_t) override;
	};
}

#endif
```

`ttddbg/include/ttddbg_position_chooser.hh`:

```hh
#pragma once

#include <vector>
#include <functional>

#include <pro.h>
#include <kernwin.hpp>

#include <Windows.h>
#include "ttddbg_logger.hh"
#include "../../ttd-bindings/TTD/TTD.hpp"

namespace ttddbg {
	class PositionChooser : public chooser_t {
	public:
		PositionChooser(std::shared_ptr<Logger> logger);
		PositionChooser(std::shared_ptr<TTD::Cursor>, std::shared_ptr<Logger> logger);

		void setCursor(std::shared_ptr<TTD::Cursor>);
		void addNewPosition(std::string name, TTD::Position pos);

		bool isClosed();
		
		// Overrides
		bool init() override;
		size_t get_count() const override;
		void get_row(qstrvec_t* out, int* out_icon, chooser_item_attrs_t* out_attrs, size_t n) const override;
		ea_t get_ea(size_t) const override;
		void closed() override;
		cbret_t ins(ssize_t) override;
		cbret_t del(size_t) override;
		ssize_t choose(ssize_t = 0);

	private:
		void savePositions() const;
		void loadPositions();
		void sortPositions();

		/* List of all positions saved by the user. The pair is <position name, TTD position struct> */
		std::vector<std::pair<std::string, TTD::Position>> m_positions;

		/* A pointer to the current TTD::Cursor used by the debugger. Used when adding a new position to get the current position. */
		std::shared_ptr<TTD::Cursor> m_cursor;

		/* A pointer to the shared logger object. */
		std::shared_ptr<Logger> m_logger;

		/* This boolean holds the internal state of the Chooser: is it visible or not. Used to prevent calling choose() twice. */
		bool m_isClosed;
	};
}
```

`ttddbg/include/ttddbg_strings.hh`:

```hh
#ifndef __TTDDBG_STRINGS__
#define __TTDDBG_STRINGS__

#include <string>

namespace ttddbg 
{
	/*!
	 * \brief	Sring toolbox
	 */
	class Strings
	{
	public:
		/*!
		 * \brief	Convert string from utf8 standard c++ into utf16 windows styme string
		 */
		static std::wstring to_wstring(const char* cStr);

		/*!
		 * \brief	Convert string from utf16 windows styme string into utf8 standard c++
		 */
		static std::string to_string(const wchar_t* cStr);

		/*!
		 * \brief	Extract the filename to isolate the module name
		 */
		static std::string find_module_name(const wchar_t* path);

		/*!
		 * \brief	Print facility for exception code
		 */
		static std::string exception_name(uint32_t exceptionCode);
	};
}

#endif
```

`ttddbg/include/ttddbg_x86_registers.hh`:

```hh
#ifndef __TTDDBG_X86_REGISTERS__
#define __TTDDBG_X86_REGISTERS__

namespace ttddbg 
{
	/*!
	 * \brief	Declare x86 arch class register
	 *			This code is inspired from https://github.com/cseagle/sk3wldbg
	 */
	static const char* x86_register_classes[] = {
		"General registers",
		"Segment registers",
		"FPU registers",
		"MMX registers",
		"XMM registers",
		NULL
	};

	/*!
	 * \brief	Declare x86 arch class register enum
	 *			This code is inspired from https://github.com/cseagle/sk3wldbg
	 */
	enum X86RegClass {
		X86_GENERAL = 1,
		X86_SEGMENT = 2,
		X86_FPU = 4,
		X86_MMX = 8,
		X86_XMM = 16
	};

	/*!
	 * \brief	Bit flags
	 *			This code is inspired from https://github.com/cseagle/sk3wldbg
	 */
	static const char* flag_bits[32] = {
		"CF", NULL, "PF", NULL, "AF", NULL, "ZF", "SF", "TF", "IF", "DF", "OF",
		"IOPL", "IOPL", "NT", NULL, "RF", "VM", "AC", "VIF", "VIP", "ID"
	};
}

#endif
```

`ttddbg/src/ttddbg_action.cc`:

```cc
#include "ttddbg_action.hh"
#include "ttddbg_debugger.hh"
#include <dbg.hpp>

namespace ttddbg
{
	/**********************************************************************/
	int idaapi ttddbg::BackwardStateRequest::activate(action_activation_ctx_t*)
	{
		if (dbg != nullptr)
		{
			static_cast<ttddbg::Debugger*>(dbg)->getManager().switchWay();
			continue_process();
			static_cast<ttddbg::Debugger*>(dbg)->getManager().switchWay();
		}
		return false;
	}

	/**********************************************************************/
	action_state_t idaapi ttddbg::BackwardStateRequest::update(action_update_ctx_t*)
	{
		return AST_ENABLE_ALWAYS;
	}

	/**********************************************************************/
	int idaapi ttddbg::BackwardSingleStepRequest::activate(action_activation_ctx_t*)
	{
		if (dbg != nullptr)
		{
			static_cast<ttddbg::Debugger*>(dbg)->getManager().requestBackwardsSingleStep();
			continue_process();
		}
		return false;
	}

	/**********************************************************************/
	action_state_t idaapi ttddbg::BackwardSingleStepRequest::update(action_update_ctx_t*)
	{
		return AST_ENABLE_ALWAYS;
	}

	/**********************************************************************/
	int idaapi ttddbg::OpenPositionChooserAction::activate(action_activation_ctx_t*) {
		if (dbg != nullptr)
		{
			static_cast<ttddbg::Debugger*>(dbg)->getManager().openPositionChooser();
		}
		return false;
	}

	/**********************************************************************/
	action_state_t idaapi ttddbg::OpenPositionChooserAction::update(action_update_ctx_t*) {
		return AST_ENABLE_ALWAYS;
	}
}
```

`ttddbg/src/ttddbg_debugger.cc`:

```cc
#include "ttddbg_debugger.hh"
#include "ttddbg_x86_registers.hh"
#include <dbg.hpp>
#include <winternl.h>
#include <codecvt>
#include <string>

namespace ttddbg
{
	/**********************************************************************/
	static const char* idaapi debugger_set_dbg_options(const char* keyword, int /*pri*/,
		int value_type, const void* value) {
		return IDPOPT_OK;
	}
	
	/**********************************************************************/
	ssize_t idaapi Debugger::debugger_callback(void*, int notification_code, va_list va)
	{
		Debugger* ttddbg = static_cast<Debugger*>(::dbg);

		switch (notification_code) {
			case debugger_t::ev_init_debugger: {
				const char* hostname = va_arg(va, const char*);
				int portnum = va_arg(va, int);
				const char* password = va_arg(va, const char*);
				auto errbuf = va_arg(va, qstring*);
				return ttddbg->m_manager->onInit(std::string(hostname), portnum, std::string(password), errbuf);
			}

			case debugger_t::ev_term_debugger: {
				return ttddbg->m_manager->OnTermDebugger();
			}

			case debugger_t::ev_get_processes: {
				procinfo_vec_t* procs = va_arg(va, procinfo_vec_t*);
				auto errbuf = va_arg(va, qstring*);
				return ttddbg->m_manager->onGetProcess(procs, errbuf);
			}

			case debugger_t::ev_get_debapp_attrs: {
				debapp_attrs_t* attrib = va_arg(va, debapp_attrs_t*);
				return ttddbg->m_manager->onGetDebappAttrs(attrib);
			}

			case debugger_t::ev_start_process: {
				const char* path = va_arg(va, const char*);
				const char* args = va_arg(va, const char*);
				const char* startdir = va_arg(va, const char*);
				uint32 dbg_proc_flags = va_arg(va, uint32);
				const char* input_path = va_arg(va, const char*);
				uint32 input_file_crc32 = va_arg(va, uint32);
				auto errbuf = va_arg(va, qstring*);
				return ttddbg->m_manager->onStartProcess(path, args, startdir, dbg_proc_flags, input_path, input_file_crc32, errbuf);
			}

			case debugger_t::ev_set_exception_info: {
				exception_info_t* info = va_arg(va, exception_info_t*);
				int qty = va_arg(va, int);
				return ttddbg->m_manager->onSetExceptionInfo(info, qty);
			}

			case debugger_t::ev_get_debug_event: {
				gdecode_t* code = va_arg(va, gdecode_t*);
				debug_event_t* event = va_arg(va, debug_event_t*);
				int timeout_ms = va_arg(va, int);
				return ttddbg->m_manager->onGetDebugEvent(code, event, timeout_ms);
			}

			case debugger_t::ev_get_memory_info: {
				meminfo_vec_t* ranges = va_arg(va, meminfo_vec_t*);
				auto errbuf = va_arg(va, qstring*);
				return ttddbg->m_manager->onGetMemoryInfo(ranges, errbuf);
			}

			case debugger_t::ev_read_memory: {
				size_t* nbytes = va_arg(va, size_t*);
				ea_t ea = va_arg(va, ea_t);
				void* buffer = va_arg(va, void*);
				size_t size = va_arg(va, size_t);
				auto errbuf = va_arg(va, qstring*);
				return ttddbg->m_manager->onReadMemory(nbytes, ea, buffer, size, errbuf);
			}

			case debugger_t::ev_rebase_if_required_to: {
				ea_t new_base = va_arg(va, ea_t);
				return ttddbg->m_manager->onRebaseIfRequiredTo(new_base);
			}

			case debugger_t::ev_resume: {
				debug_event_t* event = va_arg(va, debug_event_t*);
				return ttddbg->m_manager->onResume(event);
			}

			case debugger_t::ev_read_registers: {
				thid_t tid = va_argi(va, thid_t);
				int clsmask = va_arg(va, int);
				regval_t* values = va_arg(va, regval_t*);
				auto errbuf = va_arg(va, qstring*);
				return ttddbg->m_manager->onReadRegisters(tid, clsmask, values, errbuf);
			}

			case debugger_t::ev_suspended: {
				bool dlls_added = va_argi(va, bool);
				thread_name_vec_t* thr_names = va_arg(va, thread_name_vec_t*);
				return ttddbg->m_manager->onSuspended(dlls_added, thr_names);
			}
			case debugger_t::ev_exit_process:
			{
				auto errbuf = va_arg(va, qstring*);
				return ttddbg->m_manager->onExitProcess(errbuf);
			}

			case debugger_t::ev_get_srcinfo_path: {
				qstring* path = va_arg(va, qstring*);
				ea_t base = va_arg(va, ea_t);
				return ttddbg->m_manager->onGetSrcinfoPath(path, base);
			}

			case debugger_t::ev_update_bpts: {
				int* nbpts = va_arg(va, int*);
				update_bpt_info_t* bpts = va_arg(va, update_bpt_info_t*);
				int nadd = va_arg(va, int);
				int ndel = va_arg(va, int);
				auto errbuf = va_arg(va, qstring*);
				return ttddbg->m_manager->onUpdateBpts(nbpts, bpts, nadd, ndel, errbuf);
			}
			
			case debugger_t::ev_set_resume_mode: {
				thid_t tid = va_argi(va, thid_t);
				resume_mode_t resmod = va_argi(va, resume_mode_t);
				return ttddbg->m_manager->onSetResumeMode(tid, resmod);
			}

			case debugger_t::ev_update_call_stack: {
				thid_t tid = va_argi(va, thid_t);
				call_stack_t* trace = va_arg(va, call_stack_t*);
				return ttddbg->m_manager->onUpdateCallStack(tid, trace);
			}

			default:
				ttddbg->m_logger->info("unhandled code ", notification_code);
				break;
		}

		return true;
	}

	/**********************************************************************/
	Debugger::Debugger(std::shared_ptr< ttddbg::Logger> logger, std::unique_ptr<IDebuggerManager>&& manager)
		: m_logger { logger }, m_manager { std::move(manager) }
	{
		version = IDD_INTERFACE_VERSION;
		id = 0x100;

		flags =		DBG_FLAG_CAN_CONT_BPT | 
					DBG_FLAG_SAFE | 
					DBG_FLAG_DEBTHREAD | 
					DBG_FLAG_DEBUG_DLL;

		flags2 =	DBG_HAS_GET_PROCESSES |
					DBG_HAS_SET_RESUME_MODE;

		resume_modes = DBG_RESMOD_STEP_INTO;
		processor = "metapc";

		bpt_bytes = (const uchar*)"\xcc";
		bpt_size = 1;

		memory_page_size = 0x1000;

		set_dbg_options = debugger_set_dbg_options;
		callback = debugger_callback;

		filetype = inf_get_filetype();
	}

	/**********************************************************************/
	IDebuggerManager& Debugger::getManager()
	{
		return *m_manager;
	}
}
```

`ttddbg/src/ttddbg_debugger_manager.cc`:

```cc
#include <filesystem>
#include <fstream>
#include <iostream>
#include "ttddbg_debugger_manager.hh"
#include "ttddbg_strings.hh"
#include <idp.hpp>
#include <ida.hpp>
#include <segment.hpp>

namespace ttddbg
{
	/**********************************************************************/
	static int from_idabptype(bpttype_t bp_type)
	{
		switch (bp_type)
		{
		case BPT_WRITE:
			return TTD::BP_FLAGS::WRITE;
		case BPT_READ:
			return TTD::BP_FLAGS::READ;
		case BPT_RDWR:
			return TTD::BP_FLAGS::READ | TTD::BP_FLAGS::WRITE;
		case BPT_EXEC:
			return TTD::BP_FLAGS::EXEC;
		case BPT_DEFAULT:
			return TTD::BP_FLAGS::EXEC;
		default:
			return TTD::BP_FLAGS::EXEC;
		} 
	}

	/**********************************************************************/
	bool DebuggerManager::isTargetModule(const TTD::TTD_Replay_Module& module)
	{
		if (m_targetImagePath.string() == Strings::to_string(module.path))
		{
			return true;
		}
		else if (m_targetImagePath.filename() == Strings::find_module_name(module.path))
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	/**********************************************************************/
	DebuggerManager::DebuggerManager(std::shared_ptr<ttddbg::Logger> logger, Arch arch)
		: m_logger(logger), m_arch{ arch }, m_isForward{ true }, m_resumeMode{ resume_mode_t::RESMOD_NONE }, m_positionChooser(new PositionChooser(m_logger)), m_nextPosition{ 0 }, m_processId(1234), m_backwardsSingleStep(false)
	{
	}

	/**********************************************************************/
	ssize_t DebuggerManager::onInit(std::string& hostname, int portNumber, std::string& password, qstring* errBuf)
	{
		return DRC_OK;
	}

	/**********************************************************************/
	ssize_t DebuggerManager::OnTermDebugger()
	{
		return DRC_OK;
	}

	/**********************************************************************/
	ssize_t DebuggerManager::onGetProcess(procinfo_vec_t* infos, qstring* errBuf)
	{
		process_info_t info;
		info.name = "test";
		info.pid = m_processId;
		infos->push_back(info);
		return DRC_OK;
	}

	/**********************************************************************/
	ssize_t DebuggerManager::onStartProcess(const char* path, const char* args, const char* startdir, uint32 dbg_proc_flags, const char* input_path, uint32 input_file_crc32, qstring* errbuf)
	{	
		m_isForward = true;
		m_targetImagePath = input_path;

		// check if the file exist
		if (!std::filesystem::exists(path))
		{
			m_logger->error("unable to find trace file : ", path);
			m_logger->error("Please fill the Application field with the TTD trace file");
			return DRC_NOFILE;
		}

		std::ifstream traceFile(path, std::ios::out | std::ios::binary);
		if (!traceFile.is_open())
		{
			m_logger->error("unable to open the trace : ", path);
			m_logger->error("Please fill the Application field with the TTD trace file");
			return DRC_NOFILE;
		}

		std::vector<char> magic(6);
		traceFile.read(magic.data(), magic.size());
		traceFile.close();

		if (magic != std::vector<char>({ 'T', 'T', 'D', 'L', 'o', 'g'}))
		{
			m_logger->error("invalid trace file (wrong magic) : ", path);
			m_logger->error("Please fill the Application field with the TTD trace file");
			return DRC_NOFILE;
		}

		// Initialize engine
		if (!m_engine.Initialize(Strings::to_wstring(path).c_str()))
		{
			m_logger->error("unable to load the trace : ", path);
			return DRC_FAILED;
		}

		// init step mode
		m_resumeMode = resume_mode_t::RESMOD_NONE;

		m_cursor = std::make_shared<TTD::Cursor>(m_engine.NewCursor());
		m_positionChooser->setCursor(m_cursor);

		// Populate position chooser (timeline)
		populatePositionChooser();
		
		// Init cursor at the first position
		m_cursor->SetPosition(m_engine.GetFirstPosition());

		m_events.addProcessStartEvent(
			m_processId,
			m_cursor->GetThreadInfo()->threadid, 
			Strings::to_string(m_engine.GetModuleList()[0].path), 
			m_engine.GetModuleList()[0].base_addr,
			isTargetModule(m_engine.GetModuleList()[0]) ? m_engine.GetModuleList()[0].base_addr : BADADDR,
			m_engine.GetModuleList()[0].imageSize
		);

		// if the target module is not the main one
		// we will simulate load program to force rebase
		// PDB load and unload symbol
		// The main symbol must not be unload !!!
		if (!isTargetModule(m_engine.GetModuleList()[0]))
		{
			for (int i = 1; i < m_engine.GetModuleCount(); i++)
			{
				auto moduleInfo = m_engine.GetModuleList()[i];
				if (isTargetModule(moduleInfo))
				{
					m_events.addLibLoadEvent(
						Strings::to_string(moduleInfo.path),
						moduleInfo.base_addr,
						moduleInfo.base_addr,
						moduleInfo.imageSize
					);
				}
			}
		}
		
		for (int i = 1; i < m_cursor->GetThreadCount(); i++)
		{
			auto threadId = m_cursor->GetThreadList()[i].info->threadid;
			m_events.addThreadStartEvent(m_processId, threadId);
		}

		for (int i = 1; i < m_cursor->GetModuleCount(); i++)
		{
			auto moduleInfo = m_cursor->GetModuleList()[i];
			m_events.addLibLoadEvent(
				Strings::to_string(moduleInfo.module->path), 
				moduleInfo.module->base_addr,
				isTargetModule(*moduleInfo.module) ? moduleInfo.module->base_addr : BADADDR,
				moduleInfo.module->imageSize
			);
		}

		m_events.addBreakPointEvent(
			m_processId,
			m_cursor->GetThreadInfo()->threadid,
			m_cursor->GetProgramCounter()
		);
		
		return DRC_OK;
	}

	/**********************************************************************/
	ssize_t DebuggerManager::onGetDebappAttrs(debapp_attrs_t* attrs)
	{
		return DRC_OK;
	}

	/**********************************************************************/
	ssize_t DebuggerManager::onGetDebugEvent(gdecode_t* code, debug_event_t* event, int timeout_ms)
	{
		if (!m_events.isEmpty())
		{
			*code = GDE_ONE_EVENT;
			*event = m_events.popEvent();
		}
		else
		{
			*code = GDE_NO_EVENT;
		}
		return DRC_OK;
	}

	/**********************************************************************/
	ssize_t DebuggerManager::onGetMemoryInfo(meminfo_vec_t* infos, qstring* errbuf)
	{
		memory_info_t other;
		other.start_ea = 0;
		other.end_ea = (ea_t)0x7FFFFFFFFFFF; // Userland process on windows
		other.bitness = (m_arch == ARCH_64_BITS)?2:1;
		infos->push_back(other);
		return DRC_OK;
	}

	/**********************************************************************/
	ssize_t DebuggerManager::onSetExceptionInfo(exception_info_t* info, int qty)
	{
		return DRC_OK;
	}

	/**********************************************************************/
	ssize_t DebuggerManager::onReadMemory(size_t* nbytes, ea_t ea, void* buffer, size_t size, qstring* errbuf)
	{
		auto memory = m_cursor->QueryMemoryBuffer(ea, size);
		*nbytes = memory->size;
		if (memory->size > 0)
		{
			memcpy(buffer, memory->data, size);
		}
		free(memory->data);
		return DRC_OK;
	}

	/**********************************************************************/
	ssize_t DebuggerManager::onRebaseIfRequiredTo(ea_t newBase)
	{
		rebase_program(newBase - get_imagebase(), MSF_FIXONCE);
		return DRC_OK;
	}

	/**********************************************************************/
	ssize_t DebuggerManager::onResume(debug_event_t* event)
	{
		if (event->eid() == event_id_t::BREAKPOINT || event->eid() == event_id_t::STEP)
		{
			if (m_nextPosition.Major != 0 || m_nextPosition.Minor != 0) {
				// Special case: instead of stepping or resuming, if there is a "next position" saved,
				// go to this position instead
				m_logger->info("special case: next position: ", m_nextPosition.Major, " ", m_nextPosition.Minor);
				this->applyCursor(m_nextPosition);
				m_events.addBreakPointEvent(m_processId, m_cursor->GetThreadInfo()[0].threadid, m_cursor->GetProgramCounter());
				m_nextPosition = { 0 };
				return DRC_OK;
			}

			if (m_backwardsSingleStep) {
				// Special case: if "m_backwardsSingleStep" is true, simulate a "single-step"
				// back in time: we force m_isForward to false and "applyCursor(1)", which effectively
				// moves back in time of 1 unit
				bool old_isForward = m_isForward;
				m_isForward = false;
				applyCursor(1);
				m_isForward = old_isForward;

				m_events.addBreakPointEvent(m_processId, m_cursor->GetThreadInfo()[0].threadid, m_cursor->GetProgramCounter());

				m_backwardsSingleStep = false;

				return DRC_OK;
			}

			switch (m_resumeMode)
			{
			case resume_mode_t::RESMOD_NONE:
			{
				this->applyCursor(-1);
				m_events.addBreakPointEvent(m_processId, m_cursor->GetThreadInfo()[0].threadid, m_cursor->GetProgramCounter());
				break;
			}
			case resume_mode_t::RESMOD_INTO:
			{
				this->applyCursor(1);
				m_events.addStepEvent(m_processId, m_cursor->GetThreadInfo()[0].threadid);
				break;
			}
			default:
				m_logger->info("unsupported resume mode ", (int)m_resumeMode);
				break;
			}
			m_resumeMode = resume_mode_t::RESMOD_NONE;
		}
		return DRC_OK;
	}

	/**********************************************************************/
	ssize_t DebuggerManager::onSuspended(bool dllsAdded, thread_name_vec_t* thrNames)
	{
		return DRC_OK;
	}

	/**********************************************************************/
	ssize_t DebuggerManager::onExitProcess(qstring* errbuf)
	{
		m_events.addProcessExitEvent(m_processId);
		return DRC_OK;
	}

	/**********************************************************************/
	ssize_t DebuggerManager::onGetSrcinfoPath(qstring* path, ea_t base)
	{
		for (int i = 0; i < m_cursor->GetModuleCount(); i++)
		{
			auto module = m_cursor->GetModuleList()[i].module;
			if (module->base_addr == base)
			{
				*path = Strings::to_string(module->path).c_str();
				break;
			}
		}
		return DRC_OK;
	}

	/**********************************************************************/
	ssize_t DebuggerManager::onUpdateBpts(int* nbpts, update_bpt_info_t* bpts, int nadd, int ndel, qstring* errbuf)
	{
		int i = 0;
		*nbpts = 0;
		for (; i < nadd; i++)
		{
			TTD::TTD_Replay_MemoryWatchpointData data;
			data.addr = bpts[i].ea;
			data.size = m_arch;
			data.flags = from_idabptype(bpts->type);
			m_cursor->AddMemoryWatchpoint(&data);
			(*nbpts)++;
		}

		for (; i < ndel; i++)
		{
			TTD::TTD_Replay_MemoryWatchpointData data;
			data.addr = bpts[i].ea;
			data.size = m_arch;
			data.flags = from_idabptype(bpts->type);
			m_cursor->RemoveMemoryWatchpoint(&data);
			(*nbpts)++;
		}
		return DRC_OK;
	}

	/**********************************************************************/
	ssize_t DebuggerManager::onSetResumeMode(thid_t tid, resume_mode_t resmod)
	{
		m_resumeMode = resmod;
		return DRC_OK;
	}

	/**********************************************************************/
	ssize_t DebuggerManager::onUpdateCallStack(thid_t tid, call_stack_t* trace)
	{
		return DRC_NONE;
	}

	/**********************************************************************/
	void DebuggerManager::applyCursor(int steps)
	{
		// compute current list of thread
		std::set<uint32_t> threadBefore = getCursorThreads();
		std::set<TTD::TTD_Replay_Module*> moduleBefore = getCursorModules();

		TTD::TTD_Replay_ICursorView_ReplayResult replayrez;
		
		if (m_isForward)
		{
			m_cursor->ReplayForward(&replayrez, m_engine.GetLastPosition(), steps);
		}
		else
		{
			m_cursor->ReplayBackward(&replayrez, m_engine.GetFirstPosition(), steps);
		}

		std::set<uint32_t> threadAfter = getCursorThreads();
		std::set<TTD::TTD_Replay_Module*> moduleAfter = getCursorModules();

		applyDifferences(threadBefore, threadAfter, moduleBefore, moduleAfter);

		m_logger->info("Now at position ", m_cursor->GetPosition()->Major, " ", m_cursor->GetPosition()->Minor);
	}

	/**********************************************************************/
	void DebuggerManager::applyCursor(TTD::Position newPos) {
		std::set<uint32_t> threadBefore = getCursorThreads();
		std::set<TTD::TTD_Replay_Module*> moduleBefore = getCursorModules();

		m_cursor->SetPosition(&newPos);

		std::set<uint32_t> threadAfter = getCursorThreads();
		std::set<TTD::TTD_Replay_Module*> moduleAfter = getCursorModules();

		applyDifferences(threadBefore, threadAfter, moduleBefore, moduleAfter);

		m_logger->info("Now at position ", m_cursor->GetPosition()->Major, " ", m_cursor->GetPosition()->Minor);
	}

	/**********************************************************************/
	std::set<uint32_t> DebuggerManager::getCursorThreads() {
		std::set<uint32_t> threads;
		for (int i = 0; i < m_cursor->GetThreadCount(); i++)
		{
			threads.insert(m_cursor->GetThreadList()[i].info->threadid);
		}
		return threads;
	}

	/**********************************************************************/
	std::set<TTD::TTD_Replay_Module*> DebuggerManager::getCursorModules() {
		std::set<TTD::TTD_Replay_Module*> modules;
		for (int i = 0; i < m_cursor->GetModuleCount(); i++)
		{
			modules.insert(m_cursor->GetModuleList()[i].module);
		}
		return modules;
	}

	/**********************************************************************/
	void DebuggerManager::applyDifferences(std::set<uint32_t> threadBefore, std::set<uint32_t> threadAfter, std::set<TTD::TTD_Replay_Module*> moduleBefore, std::set<TTD::TTD_Replay_Module*> moduleAfter) {
		// Check created and exited thread between two states
		std::vector<uint32_t> threadExited, threadStarted;

		std::set_difference(threadBefore.begin(), threadBefore.end(), threadAfter.begin(), threadAfter.end(), std::inserter(threadExited, threadExited.begin()));
		std::set_difference(threadAfter.begin(), threadAfter.end(), threadBefore.begin(), threadBefore.end(), std::inserter(threadStarted, threadStarted.begin()));

		std::for_each(threadExited.begin(), threadExited.end(),
			[this](uint32_t threadId) {
				m_events.addThreadExitEvent(m_processId, threadId);
			}
		);
		std::for_each(threadStarted.begin(), threadStarted.end(),
			[this](uint32_t threadId) {
				m_events.addThreadStartEvent(m_processId, threadId);
			}
		);

		// Check loaded and unloaded modules
		std::vector<TTD::TTD_Replay_Module*> moduleUnloaded, moduleLoaded;

		std::set_difference(moduleBefore.begin(), moduleBefore.end(), moduleAfter.begin(), moduleAfter.end(), std::inserter(moduleUnloaded, moduleUnloaded.begin()));
		std::set_difference(moduleAfter.begin(), moduleAfter.end(), moduleBefore.begin(), moduleBefore.end(), std::inserter(moduleLoaded, moduleLoaded.begin()));

		std::for_each(moduleUnloaded.begin(), moduleUnloaded.end(),
			[this](TTD::TTD_Replay_Module* module) {
				if (!isTargetModule(*module))
				{
					m_events.addLibUnloadEvent(
						Strings::to_string(module->path),
						module->base_addr
					);
				}
			}
		);

		std::for_each(moduleLoaded.begin(), moduleLoaded.end(),
			[this](TTD::TTD_Replay_Module* module) {
				m_events.addLibLoadEvent(
					Strings::to_string(module->path),
					module->base_addr,
					isTargetModule(*module) ? module->base_addr : BADADDR,
					module->imageSize
				);
			}
		);
	}

	/**********************************************************************/
	void DebuggerManager::switchWay()
	{
		m_isForward = !m_isForward;
	}

	/**********************************************************************/
	void DebuggerManager::requestBackwardsSingleStep()
	{
		m_backwardsSingleStep = true;
	}

	/**********************************************************************/
	void DebuggerManager::openPositionChooser() {
		if (m_positionChooser != nullptr) {
			m_positionChooser->choose();
		}
	}

	/**********************************************************************/
	void DebuggerManager::setNextPosition(TTD::Position newPos) {
		m_nextPosition = newPos;
	}

	/**********************************************************************/
	void DebuggerManager::populatePositionChooser() {
		// TODO: use m_engine methods to add timeline positions for each:
		// - Thread creation / exit
		// - Module load / unload

		if (m_positionChooser->get_count() > 0) {
			// If the position count is > 0 even before populating, it means that
			// a list of positions was already loaded. In this case, we do not populate it further.
			return;
		}

		auto threadCreatedEvents = m_engine.GetThreadCreatedEvents();
		auto threadExitedEvents = m_engine.GetThreadTerminatedEvents();
		auto moduleLoadedEvents = m_engine.GetModuleLoadedEvents();
		auto moduleUnloadedEvents = m_engine.GetModuleUnloadedEvents();
		auto exceptionEvents = m_engine.GetExceptionEvents();

		std::for_each(threadCreatedEvents.begin(), threadCreatedEvents.end(), [this](TTD::TTD_Replay_ThreadCreatedEvent& e) {
			std::ostringstream oss;
			oss << "Thread created: " << e.info->threadid;
			m_positionChooser->addNewPosition(oss.str(), e.pos);
		});

		std::for_each(threadExitedEvents.begin(), threadExitedEvents.end(), [this](TTD::TTD_Replay_ThreadTerminatedEvent& e) {
			std::ostringstream oss;
			oss << "Thread exited: " << e.info->threadid;
			m_positionChooser->addNewPosition(oss.str(), e.pos);
		});

		std::for_each(moduleLoadedEvents.begin(), moduleLoadedEvents.end(), [this](TTD::TTD_Replay_ModuleLoadedEvent& e) {
			std::ostringstream oss;
			oss << "Module loaded: " << Strings::to_string(e.info->path);
			m_positionChooser->addNewPosition(oss.str(), e.pos);
		});

		std::for_each(moduleUnloadedEvents.begin(), moduleUnloadedEvents.end(), [this](TTD::TTD_Replay_ModuleUnloadedEvent& e) {
			std::ostringstream oss;
			oss << "Module unloaded: " << Strings::to_string(e.info->path);
			m_positionChooser->addNewPosition(oss.str(), e.pos);
		});

		std::for_each(exceptionEvents.begin(), exceptionEvents.end(), [this](TTD::TTD_Replay_ExceptionEvent& e) {
			std::ostringstream oss;
			oss << "Exception at 0x" << std::hex << e.info.ExceptionAddress << " of type " << Strings::exception_name(e.info.ExceptionCode) << " (0x" << std::hex << e.info.ExceptionCode << ")";
			m_positionChooser->addNewPosition(oss.str(), e.pos);
		});
	}
}
```

`ttddbg/src/ttddbg_debugger_x86.cc`:

```cc
#include "ttddbg_debugger_x86.hh"
#include "ttddbg_x86_registers.hh"

namespace ttddbg
{
	/**********************************************************************/
	// x86 registers declaration
	static struct register_info_t x86_regs[] = {
		{"EAX", REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
		{"ECX", REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
		{"EDX", REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
		{"EBX", REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
		{"ESP", REGISTER_SP | REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
		{"EBP", REGISTER_FP | REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
		{"ESI", REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
		{"EDI", REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
		{"EIP", REGISTER_IP | REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
		{"EFL", 0, X86_GENERAL, dt_dword, flag_bits, 0xdd5},
		{"CS", REGISTER_CS, X86_SEGMENT, dt_word, NULL, 0},
		{"DS", 0, X86_SEGMENT, dt_word, NULL, 0},
		{"SS", REGISTER_SS, X86_SEGMENT, dt_word, NULL, 0},
		{"ES", 0, X86_SEGMENT, dt_word, NULL, 0},
		{"FS", 0, X86_SEGMENT, dt_word, NULL, 0},
		{"GS", 0, X86_SEGMENT, dt_word, NULL, 0}
	};

	/**********************************************************************/
	DebuggerManagerX86::DebuggerManagerX86(std::shared_ptr<ttddbg::Logger> logger)
		: DebuggerManager(logger, Arch::ARCH_32_BITS)
	{

	}

	/**********************************************************************/
	ssize_t DebuggerManagerX86::onReadRegisters(thid_t tid, int clsmask, regval_t* values, qstring* errbuf)
	{
		auto threadInfo = m_cursor->GetContextx86(tid);

		values[0].ival = threadInfo->Eax;
		values[1].ival = threadInfo->Ecx;
		values[2].ival = threadInfo->Edx;
		values[3].ival = threadInfo->Ebx;
		values[4].ival = threadInfo->Esp;
		values[5].ival = threadInfo->Ebp;
		values[6].ival = threadInfo->Esi;
		values[7].ival = threadInfo->Edi;
		values[8].ival = threadInfo->Eip;
		values[9].ival = threadInfo->EFlags;
		values[10].ival = threadInfo->SegCs;
		values[11].ival = threadInfo->SegDs;
		values[12].ival = threadInfo->SegSs;
		values[13].ival = threadInfo->SegEs;
		values[14].ival = threadInfo->SegFs;
		values[15].ival = threadInfo->SegGs;

		return DRC_OK;
	}

	/**********************************************************************/
	DebuggerX86::DebuggerX86(std::shared_ptr< ttddbg::Logger> logger)
		: Debugger(logger, std::make_unique<DebuggerManagerX86>(logger))
	{
		name = "ttddbg_x86";
		
		regclasses = x86_register_classes;
		default_regclasses = X86_GENERAL;
		registers = x86_regs;

		nregs = 16;
	}
}
```

`ttddbg/src/ttddbg_debugger_x86_64.cc`:

```cc
#include "ttddbg_debugger_x86_64.hh"
#include "ttddbg_x86_registers.hh"

namespace ttddbg
{
	/**********************************************************************/
	// Register information for x86_64 arch
	static struct register_info_t x64_regs[] = {
		{"RAX", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
		{"RCX", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
		{"RDX", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
		{"RBX", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
		{"RSP", REGISTER_SP | REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
		{"RBP", REGISTER_FP | REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
		{"RSI", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
		{"RDI", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
		{"R8", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
		{"R9", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
		{"R10", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
		{"R11", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
		{"R12", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
		{"R13", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
		{"R14", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
		{"R15", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
		{"RIP", REGISTER_IP | REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
		{"EFL", 0, X86_GENERAL, dt_dword, flag_bits, 0xdd5},
		{"CS", REGISTER_CS, X86_SEGMENT, dt_word, NULL, 0},
		{"DS", 0, X86_SEGMENT, dt_word, NULL, 0},
		{"SS", REGISTER_SS, X86_SEGMENT, dt_word, NULL, 0},
		{"ES", 0, X86_SEGMENT, dt_word, NULL, 0},
		{"FS", 0, X86_SEGMENT, dt_word, NULL, 0},
		{"GS", 0, X86_SEGMENT, dt_word, NULL, 0},
	};

	/**********************************************************************/
	DebuggerManagerX86_64::DebuggerManagerX86_64(std::shared_ptr<ttddbg::Logger> logger)
		: DebuggerManager(logger, Arch::ARCH_64_BITS)
	{

	}

	/**********************************************************************/
	ssize_t DebuggerManagerX86_64::onReadRegisters(thid_t tid, int clsmask, regval_t* values, qstring* errbuf)
	{
		auto threadInfo = m_cursor->GetContextx86_64(tid);

		values[0].ival = threadInfo->Rax;
		values[1].ival = threadInfo->Rcx;
		values[2].ival = threadInfo->Rdx;
		values[3].ival = threadInfo->Rbx;
		values[4].ival = threadInfo->Rsp;
		values[5].ival = threadInfo->Rbp;
		values[6].ival = threadInfo->Rsi;
		values[7].ival = threadInfo->Rdi;
		values[8].ival = threadInfo->R8;
		values[9].ival = threadInfo->R9;
		values[10].ival = threadInfo->R10;
		values[11].ival = threadInfo->R11;
		values[12].ival = threadInfo->R12;
		values[13].ival = threadInfo->R13;
		values[14].ival = threadInfo->R14;
		values[15].ival = threadInfo->R15;
		values[16].ival = threadInfo->Rip;
		values[17].ival = threadInfo->EFlags;
		values[18].ival = threadInfo->SegCs;
		values[19].ival = threadInfo->SegDs;
		values[20].ival = threadInfo->SegSs;
		values[21].ival = threadInfo->SegEs;
		values[22].ival = threadInfo->SegFs;
		values[23].ival = threadInfo->SegGs;

		return DRC_OK;
	}


	/**********************************************************************/
	DebuggerX86_64::DebuggerX86_64(std::shared_ptr< ttddbg::Logger> logger)
		: Debugger(logger, std::make_unique<DebuggerManagerX86_64>(logger))
	{
		name = "ttddbg_x86_64";

		regclasses = x86_register_classes;
		default_regclasses = X86_GENERAL;
		registers = x64_regs;

		nregs = 24;
		bpt_bytes = (const uchar*)"\xcc";
	}

}
```

`ttddbg/src/ttddbg_event_deque.cc`:

```cc
#include "ttddbg_event_deque.hh"
namespace ttddbg
{
	/**********************************************************************/
	void EventDeque::pushEvent(debug_event_t& newEvent)
	{
		std::lock_guard<std::mutex> guard(m_safeQueue);
		m_events.push_back(newEvent);
	}

	/**********************************************************************/
	debug_event_t EventDeque::popEvent()
	{
		std::lock_guard<std::mutex> guard(m_safeQueue);
		auto result = m_events.front();
		m_events.pop_front();
		return result;
	}

	/**********************************************************************/
	bool EventDeque::isEmpty()
	{
		std::lock_guard<std::mutex> guard(m_safeQueue);
		return m_events.empty();
	}

	/**********************************************************************/
	void EventDeque::addProcessStartEvent(pid_t processId, tid_t threadId, std::string& moduleName, ea_t base, ea_t rebase_to, asize_t moduleSize)
	{
		debug_event_t event;
		event.set_eid(event_id_t::PROCESS_STARTED);
		event.pid = processId;
		event.tid = threadId;
		event.ea = base;
		event.modinfo().base = base;
		event.modinfo().rebase_to = rebase_to;
		event.modinfo().name = moduleName.c_str();
		event.modinfo().size = moduleSize;
		event.handled = false;
		this->pushEvent(event);
	}

	/**********************************************************************/
	void EventDeque::addThreadStartEvent(pid_t processId, tid_t threadId)
	{
		debug_event_t event;
		event.set_eid(event_id_t::THREAD_STARTED);
		event.pid = processId;
		event.tid = threadId;
		event.ea = BADADDR;
		event.handled = false;
		this->pushEvent(event);
	}

	/**********************************************************************/
	void EventDeque::addThreadExitEvent(pid_t processId, tid_t threadId)
	{
		debug_event_t event;
		event.set_eid(event_id_t::THREAD_EXITED);
		event.pid = processId;
		event.tid = threadId;
		event.ea = BADADDR;
		event.handled = false;
		this->pushEvent(event);
	}

	/**********************************************************************/
	void EventDeque::addBreakPointEvent(pid_t processId, tid_t threadId, ea_t bpk)
	{
		debug_event_t event;
		event.set_eid(event_id_t::BREAKPOINT);
		event.pid = processId;
		event.tid = threadId;
		event.ea = bpk;
		event.handled = true;
		this->pushEvent(event);
	}

	/**********************************************************************/
	void EventDeque::addLibLoadEvent(std::string& moduleName, ea_t base, ea_t rebase_to, asize_t moduleSize)
	{
		debug_event_t event;
		event.set_eid(event_id_t::LIB_LOADED);
		event.ea = base;
		event.handled = false;
		event.modinfo().base = base;
		event.modinfo().rebase_to = rebase_to;
		event.modinfo().name = moduleName.c_str();
		event.modinfo().size = moduleSize;
		this->pushEvent(event);
	}

	/**********************************************************************/
	void EventDeque::addLibUnloadEvent(std::string& moduleName, ea_t base)
	{
		debug_event_t event;
		event.set_eid(event_id_t::LIB_UNLOADED);
		event.ea = BADADDR;
		event.handled = false;
		event.info() = moduleName.c_str();
		this->pushEvent(event);
	}

	/**********************************************************************/
	void EventDeque::addProcessExitEvent(pid_t processId)
	{
		debug_event_t event;
		event.set_eid(event_id_t::PROCESS_EXITED);
		event.pid = processId;
		event.ea = BADADDR;
		event.handled = false;
		this->pushEvent(event);
	}

	/**********************************************************************/
	void EventDeque::addStepEvent(pid_t processId, tid_t threadId)
	{
		debug_event_t event;
		event.set_eid(event_id_t::STEP);
		event.pid = processId;
		event.tid = threadId;
		event.ea = BADADDR;
		event.handled = true;
		this->pushEvent(event);
	}
}
```

`ttddbg/src/ttddbg_logger_ida.cc`:

```cc
#include "ttddbg_logger_ida.hh"
#include <idp.hpp>
#include <kernwin.hpp>

namespace ttddbg
{
	/**********************************************************************/
	void IdaLogger::print(const std::string& message)
	{
		msg(message.c_str());
	}
}
```

`ttddbg/src/ttddbg_plugin.cc`:

```cc
#ifndef USE_DANGEROUS_FUNCTIONS
#define USE_DANGEROUS_FUNCTIONS 1
#endif  // USE_DANGEROUS_FUNCTIONS

#ifndef USE_STANDARD_FILE_FUNCTIONS
#define USE_STANDARD_FILE_FUNCTIONS
#endif

#ifndef NO_OBSOLETE_FUNCS
#define NO_OBSOLETE_FUNCS
#endif

#include <ida.hpp>
#include <idp.hpp>
#include <loader.hpp>
#include <dbg.hpp>

#include "ttddbg_debugger.hh"
#include "ttddbg_plugin.hh"
#include "ttddbg_logger_ida.hh"
#include "ttddbg_debugger_x86.hh"
#include "ttddbg_debugger_x86_64.hh"

/**********************************************************************/
ttddbg::Plugin::Plugin()
{
	register_action(m_backwardActionDesc);
	register_action(m_positionChooserActionDesc);
	register_action(m_backwardSingleActionDesc);
	attach_action_to_toolbar("DebugToolBar", m_backwardActionDesc.name);
	attach_action_to_toolbar("DebugToolBar", m_backwardSingleActionDesc.name);
	attach_action_to_toolbar("DebugToolBar", m_positionChooserActionDesc.name);
}

/**********************************************************************/
ttddbg::Plugin::~Plugin()
{
	unregister_action(m_backwardAction.actionName);
	unregister_action(m_positionChooserAction.actionName);
}

/**********************************************************************/
bool idaapi ttddbg::Plugin::run(size_t)
{
	return true;
}

/**********************************************************************/
static plugmod_t* idaapi ttddbg_init(void)
{
	auto logger = std::make_shared<ttddbg::IdaLogger>();
	try
	{
		if (inf_is_64bit())
		{
			dbg = new ttddbg::DebuggerX86_64(logger);
		}
		else
		{
			dbg = new ttddbg::DebuggerX86(logger);
		}
		return new ttddbg::Plugin();
	}
	catch (std::exception& e)
	{
		logger->error(e.what());
		return nullptr;
	}
}

/**********************************************************************/
/*!
 * \brief	This is an export present into loader.hpp of IDA SDK
 */
plugin_t PLUGIN =
{
	IDP_INTERFACE_VERSION,
	PLUGIN_DBG | PLUGIN_HIDE | PLUGIN_MULTI,
	ttddbg_init,
	nullptr,
	nullptr,
	"Time Travel Debugger",
	"Airbus CERT\n",
	"ttddbg",
	"F3"
};

```

`ttddbg/src/ttddbg_position_chooser.cc`:

```cc
#include "ttddbg_position_chooser.hh"
#include "ttddbg_debugger.hh"

#include <dbg.hpp>

namespace ttddbg {

	/**********************************************************************/
	PositionChooser::PositionChooser(std::shared_ptr<Logger> logger)
		: chooser_t(CH_CAN_INS | CH_CAN_DEL | CH_KEEP, 2, nullptr, new char* [2]{"Name", "Position"}, "Timeline"), m_cursor(nullptr), m_logger{ logger },m_isClosed(true)
	{
		loadPositions();
	}

	/**********************************************************************/
	PositionChooser::PositionChooser(std::shared_ptr<TTD::Cursor> cursor, std::shared_ptr<Logger> logger) : PositionChooser(logger) {
		setCursor(cursor);
	}

	/**********************************************************************/
	void PositionChooser::setCursor(std::shared_ptr<TTD::Cursor> cursor) {
		m_cursor = cursor;
	}

	/**********************************************************************/
	void PositionChooser::addNewPosition(std::string name, TTD::Position pos) {
		std::pair<std::string, TTD::Position> new_pair;
		new_pair.first = name;
		new_pair.second = pos;
		m_positions.push_back(new_pair);

		sortPositions();
		savePositions();
	}

	/**********************************************************************/
	bool PositionChooser::isClosed() {
		return m_isClosed;
	}

	/**********************************************************************/
	ssize_t PositionChooser::choose(ssize_t d) {
		if (isClosed()) {
			m_isClosed = false;
			return chooser_t::choose(d);
		}
		return 0;
	}

	/**********************************************************************/
	bool PositionChooser::init() {
		return true;
	}

	/**********************************************************************/
	size_t PositionChooser::get_count() const {
		return m_positions.size();
	}

	/**********************************************************************/
	void PositionChooser::get_row(qstrvec_t* out, int* out_icon, chooser_item_attrs_t* out_attrs, size_t n) const {
		auto &entry = m_positions.at(n);

		out->at(0).sprnt(entry.first.c_str());
		out->at(1).sprnt("%d %d", entry.second.Major, entry.second.Minor);
	}

	/**********************************************************************/
	ea_t PositionChooser::get_ea(size_t n) const {
		if (n >= m_positions.size()) {
			m_logger->info("out-of-bounds for PositionChooser.get_ea(): asked for ", n, ", max", m_positions.size());
			return BADADDR;
		}

		auto pos = m_positions.at(n);
		m_logger->info("Moving to position ", pos.first.c_str(), " at ", pos.second.Major, " ", pos.second.Minor);
		static_cast<ttddbg::Debugger*>(dbg)->getManager().setNextPosition(pos.second);
		continue_process();
		return BADADDR;
	}

	/**********************************************************************/
	void PositionChooser::closed() {
		m_isClosed = true;
	}

	/**********************************************************************/
	chooser_t::cbret_t PositionChooser::ins(ssize_t n) {
		qstring res;
		bool ok = ask_str(&res, 0, "Name of the new position");

		if (!ok) {
			return NOTHING_CHANGED;
		}
		
		std::pair<std::string, TTD::Position> new_pair;
		addNewPosition(std::string(res.c_str()), *m_cursor.get()->GetPosition());

		return ALL_CHANGED;
	}

	/**********************************************************************/
	chooser_t::cbret_t PositionChooser::del(size_t n) {
		if (n >= m_positions.size()) {
			m_logger->info("out-of-bounds when del()eting pos: ", n, "max ", m_positions.size());
			return NOTHING_CHANGED;
		}

		std::ostringstream nodename;
		nodename << "$ttddbg." << m_positions.at(n).first;
		netnode node(nodename.str().c_str() , 0, false);
		node.kill();

		m_positions.erase(m_positions.begin() + n);
		return ALL_CHANGED;
	}

	/**********************************************************************/
	void PositionChooser::savePositions() const {
		std::for_each(m_positions.begin(), m_positions.end(),
			[](std::pair<std::string, TTD::Position> pair) {
				std::string name = pair.first;
				TTD::Position pos = pair.second;

				std::ostringstream node_name;
				node_name << "$ttddbg." << name;

				netnode node(node_name.str().c_str(), 0, true);
				node.set(&pos, sizeof(TTD::Position));
			}
		);
	}

	/**********************************************************************/
	void PositionChooser::loadPositions() {
		netnode n;
		qstring nodename;
		qstring posname;
		TTD::Position pos;
		
		for (bool ok = n.start(); ok; ok = n.next()) {
			ssize_t sz = n.get_name(&nodename);
			if (sz == -1 || sz <= 8) {
				continue;
			}

			if (nodename.substr(0, 8) != "$ttddbg.") {
				continue;
			}

			posname = nodename.substr(8, sz);
			if (n.valobj(&pos, sizeof(TTD::Position)) == -1) {
				continue;
			}

			m_logger->info("loaded position ", posname.c_str());

			m_positions.push_back(std::pair<std::string, TTD::Position>(std::string(posname.c_str()), pos));
		}

		sortPositions();
	}

	/**********************************************************************/
	void PositionChooser::sortPositions() {
		sort(m_positions.begin(), m_positions.end(), [](auto p1, auto p2) -> bool {
			return (p1.second < p2.second);
		});
	}
}
```

`ttddbg/src/ttddbg_strings.cc`:

```cc
#include "ttddbg_strings.hh"
#include <Windows.h>
#include <iostream>
#include <filesystem>

namespace ttddbg
{
	/**********************************************************************/
	std::wstring Strings::to_wstring(const char* cStr)
	{
		auto stringSize = strnlen_s(cStr, MAX_PATH);
		std::wstring ws(L"", stringSize + 1);
		size_t tmp;
		mbstowcs_s(&tmp, &ws[0], stringSize + 1, cStr, stringSize);
		return ws;
	}

	/**********************************************************************/
	std::string Strings::to_string(const wchar_t* cStr)
	{
		auto stringSize = wcsnlen_s(cStr, MAX_PATH);
		std::string tmpString("", stringSize + 1);
		size_t tmp;
		wcstombs_s(&tmp, &tmpString[0], stringSize + 1, cStr, stringSize);
		// remove las \0 char
		tmpString.resize(stringSize);
		return tmpString;
	}

	/**********************************************************************/
	std::string Strings::find_module_name(const wchar_t* path)
	{
		std::filesystem::path modulePath(to_string(path));
		auto fileName = modulePath.filename();
		return fileName.string();
	}

	/**********************************************************************/
	std::string Strings::exception_name(uint32_t exceptionCode)
	{
		switch (exceptionCode)
		{
		case ('msc' | 0xE0000000): // c++ exception
			return "c++";
		case EXCEPTION_ACCESS_VIOLATION:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_DATATYPE_MISALIGNMENT:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_BREAKPOINT:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_SINGLE_STEP:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_FLT_DENORMAL_OPERAND:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_FLT_DIVIDE_BY_ZERO:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_FLT_INEXACT_RESULT:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_FLT_INVALID_OPERATION:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_FLT_OVERFLOW:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_FLT_STACK_CHECK:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_FLT_UNDERFLOW:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_INT_DIVIDE_BY_ZERO:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_INT_OVERFLOW:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_PRIV_INSTRUCTION:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_IN_PAGE_ERROR:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_ILLEGAL_INSTRUCTION:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_NONCONTINUABLE_EXCEPTION:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_STACK_OVERFLOW:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_INVALID_DISPOSITION:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_GUARD_PAGE:
			return "EXCEPTION_ACCESS_VIOLATION";
		case EXCEPTION_INVALID_HANDLE:
			return "EXCEPTION_ACCESS_VIOLATION";
		default:
			return "unknown exception code";
		}
	}
}
```