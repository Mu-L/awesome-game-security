Project Path: arc_gmh5225_IDA-Pro-SigMaker_htsbyo1v

Source Tree:

```txt
arc_gmh5225_IDA-Pro-SigMaker_htsbyo1v
├── IDA Pro SigMaker
│   ├── IDA Pro SigMaker.vcxproj
│   ├── IDA Pro SigMaker.vcxproj.filters
│   ├── Main.cpp
│   ├── Main.h
│   ├── MainProperties.props
│   ├── Plugin.cpp
│   └── Plugin.h
├── IDA Pro SigMaker.sln
├── README.md
└── SDK
    └── IDA_PLUGIN_SDK_GOES_HERE

```

`IDA Pro SigMaker.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32929.385
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "IDA Pro SigMaker", "IDA Pro SigMaker\IDA Pro SigMaker.vcxproj", "{592D07EA-CC3B-4F3E-904C-E21D8F299E8F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		IDA Plugin (32-Bit)|x64 = IDA Plugin (32-Bit)|x64
		IDA Plugin (32-Bit)|x86 = IDA Plugin (32-Bit)|x86
		IDA Plugin (64-Bit)|x64 = IDA Plugin (64-Bit)|x64
		IDA Plugin (64-Bit)|x86 = IDA Plugin (64-Bit)|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{592D07EA-CC3B-4F3E-904C-E21D8F299E8F}.IDA Plugin (32-Bit)|x64.ActiveCfg = IDA Plugin (32-Bit)|x64
		{592D07EA-CC3B-4F3E-904C-E21D8F299E8F}.IDA Plugin (32-Bit)|x64.Build.0 = IDA Plugin (32-Bit)|x64
		{592D07EA-CC3B-4F3E-904C-E21D8F299E8F}.IDA Plugin (32-Bit)|x86.ActiveCfg = IDA Plugin (32-Bit)|Win32
		{592D07EA-CC3B-4F3E-904C-E21D8F299E8F}.IDA Plugin (32-Bit)|x86.Build.0 = IDA Plugin (32-Bit)|Win32
		{592D07EA-CC3B-4F3E-904C-E21D8F299E8F}.IDA Plugin (64-Bit)|x64.ActiveCfg = IDA Plugin (64-Bit)|x64
		{592D07EA-CC3B-4F3E-904C-E21D8F299E8F}.IDA Plugin (64-Bit)|x64.Build.0 = IDA Plugin (64-Bit)|x64
		{592D07EA-CC3B-4F3E-904C-E21D8F299E8F}.IDA Plugin (64-Bit)|x86.ActiveCfg = IDA Plugin (64-Bit)|Win32
		{592D07EA-CC3B-4F3E-904C-E21D8F299E8F}.IDA Plugin (64-Bit)|x86.Build.0 = IDA Plugin (64-Bit)|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {EE4EC937-F784-4044-A8E9-7A6EFEBB8AB0}
	EndGlobalSection
EndGlobal

```

`IDA Pro SigMaker/IDA Pro SigMaker.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="IDA Plugin (32-Bit)|Win32">
      <Configuration>IDA Plugin (32-Bit)</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="IDA Plugin (32-Bit)|x64">
      <Configuration>IDA Plugin (32-Bit)</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="IDA Plugin (64-Bit)|Win32">
      <Configuration>IDA Plugin (64-Bit)</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="IDA Plugin (64-Bit)|x64">
      <Configuration>IDA Plugin (64-Bit)</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{592D07EA-CC3B-4F3E-904C-E21D8F299E8F}</ProjectGuid>
    <RootNamespace>IDAProSigMaker</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='IDA Plugin (64-Bit)|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='IDA Plugin (32-Bit)|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='IDA Plugin (64-Bit)|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='IDA Plugin (32-Bit)|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='IDA Plugin (64-Bit)|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="MainProperties.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='IDA Plugin (32-Bit)|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="MainProperties.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='IDA Plugin (64-Bit)|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="MainProperties.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='IDA Plugin (32-Bit)|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="MainProperties.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='IDA Plugin (64-Bit)|x64'">
    <TargetName>SigMaker64</TargetName>
    <OutDir>$(SolutionDir)$(Platform)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='IDA Plugin (32-Bit)|x64'">
    <TargetName>SigMaker</TargetName>
    <OutDir>$(SolutionDir)$(Platform)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='IDA Plugin (64-Bit)|Win32'">
    <IncludePath>$(IDAPRO_SDK_PATH)\include;$(IncludePath)</IncludePath>
    <LibraryPath>$(IDAPRO_SDK_PATH)\lib\x64_win_vc_32;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='IDA Plugin (32-Bit)|Win32'">
    <IncludePath>$(IDAPRO_SDK_PATH)\include;$(IncludePath)</IncludePath>
    <LibraryPath>$(IDAPRO_SDK_PATH)\lib\x64_win_vc_32;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='IDA Plugin (64-Bit)|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='IDA Plugin (32-Bit)|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='IDA Plugin (64-Bit)|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <PreprocessorDefinitions>__NT__;__EA64__;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <AdditionalIncludeDirectories>..\SDK\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <DisableSpecificWarnings>4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalLibraryDirectories>..\SDK\lib\x64_win_vc_64_pro;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>ida.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalOptions>/EXPORT:PLUGIN %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='IDA Plugin (32-Bit)|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <AdditionalIncludeDirectories>..\SDK\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>__NT__;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalLibraryDirectories>..\SDK\lib\x64_win_vc_32_pro;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>ida.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalOptions>/EXPORT:PLUGIN %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="Plugin.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Main.h" />
    <ClInclude Include="Plugin.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`IDA Pro SigMaker/IDA Pro SigMaker.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Quelldateien">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Headerdateien">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Ressourcendateien">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Plugin">
      <UniqueIdentifier>{c6ed3fe7-0d2a-4c59-9663-428e1081b99e}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
    <ClCompile Include="Plugin.cpp">
      <Filter>Plugin</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Plugin.h">
      <Filter>Plugin</Filter>
    </ClInclude>
    <ClInclude Include="Main.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`IDA Pro SigMaker/Main.cpp`:

```cpp
#include "Main.h"

bool IS_ARM = false;

static bool IsARM() {
    return std::string_view( "ARM" ) == inf.procname;
}

static void AddByteToSignature( Signature& signature, ea_t address, bool wildcard ) {
    SignatureByte byte{};
    byte.isWildcard = wildcard;
    byte.value = get_byte( address );
    signature.push_back( byte );
}

static void AddBytesToSignature( Signature& signature, ea_t address, size_t count, bool wildcard ) {
    // signature.reserve( signature.size() + count ); // Not sure if this is overhead for average signature creation
    for( size_t i = 0; i < count; i++ ) {
        AddByteToSignature( signature, address + i, wildcard );
    }
}

static bool GetOperandOffsetARM( const insn_t& instruction, uint8_t* operandOffset, uint8_t* operandLength ) {

    // Iterate all operands
    for( const auto& op : instruction.ops ) {
        // For ARM, we have to filter a bit though, only wildcard those operand types
        switch( op.type ) {
        case o_mem:
        case o_far:
        case o_near:
        case o_phrase:
        case o_displ:
        case o_imm:
            break;
        default:
            continue;
        }

        *operandOffset = op.offb;

        // This is somewhat of a hack because IDA api does not provide more info 
        // I always assume the operand is 3 bytes long with 1 byte operator
        if( instruction.size == 4 ) {
            *operandLength = 3;
        }
        // I saw some ADRL instruction having 8 bytes
        if( instruction.size == 8 ) {
            *operandLength = 7;
        }
        return true;
    }
    return false;
}

static bool GetOperand( const insn_t& instruction, uint8_t* operandOffset, uint8_t* operandLength ) {

    // Handle ARM
    if( IS_ARM ) {
        return GetOperandOffsetARM( instruction, operandOffset, operandLength );
    }

    // Handle metapc x86/64

    // Iterate all operands
    for( const auto& op : instruction.ops ) {
        // Skip if we have no operand
        if( op.type == o_void ) {
            continue;
        }
        // offb = 0 means unknown
        if( op.offb == 0 ) {
            continue;
        }
        *operandOffset = op.offb;
        *operandLength = instruction.size - op.offb;
        return true;
    }
    return false;
}

static std::vector<ea_t> FindSignatureOccurences( std::string_view idaSignature ) {
    // Convert signature string to searchable struct
    compiled_binpat_vec_t binaryPattern;
    parse_binpat_str( &binaryPattern, inf.min_ea, idaSignature.data(), 16 );

    // Search for occurences
    std::vector<ea_t> results;
    auto ea = inf.min_ea;
    while( true ) {
        auto occurence = bin_search2( ea, inf.max_ea, binaryPattern, BIN_SEARCH_NOCASE | BIN_SEARCH_FORWARD );
        // Signature not found anymore
        if( occurence == BADADDR ) {
            return results;
        }

        results.push_back( occurence );

        ea = occurence + 1;
    }
    return results;
}

static bool IsSignatureUnique( std::string_view idaSignature ) {
    return FindSignatureOccurences( idaSignature ).size() == 1;
}

// Signature to string 
static std::string BuildIDASignatureString( const Signature& signature, bool doubleQM = false ) {
    std::ostringstream result;
    // Build hex pattern
    for( const auto& byte : signature ) {
        if( byte.isWildcard ) {
            result << ( doubleQM ? "??" : "?" );
        }
        else {
            result << std::format( "{:02X}", byte.value );
        }
        result << " ";
    }
    auto str = result.str();
    // Remove whitespace at end
    if( !str.empty() ) {
        str.pop_back();
    }
    return str;
}

static std::string BuildByteArrayWithMaskSignatureString( const Signature& signature ) {
    std::ostringstream pattern;
    std::ostringstream mask;
    // Build hex pattern
    for( const auto& byte : signature ) {
        pattern << "\\x" << std::format( "{:02X}", ( byte.isWildcard ? 0 : byte.value ) );
        mask << ( byte.isWildcard ? "?" : "x" );
    }
    auto str = pattern.str() + " " + mask.str();
    return str;
}

static std::string BuildBytesWithBitmaskSignatureString( const Signature& signature ) {
    std::ostringstream pattern;
    std::ostringstream mask;
    // Build hex pattern
    for( const auto& byte : signature ) {
        pattern << "0x" << std::format( "{:02X}", ( byte.isWildcard ? 0 : byte.value ) ) << ", ";
        mask << ( byte.isWildcard ? "0" : "1" );
    }
    auto patternStr = pattern.str();
    auto maskStr = mask.str();

    // Reverse bitmask
    std::ranges::reverse( maskStr );

    // Remove separators
    if( !patternStr.empty() ) {
        patternStr.pop_back();
        patternStr.pop_back();
    }

    auto str = patternStr + " " + " 0b" + maskStr;
    return str;
}

static bool SetClipboardText( std::string_view text ) {
    if( text.empty() ) {
        msg( "[Error] Text empty" );
        return false;
    }

    if( OpenClipboard( NULL ) == false ) {
        msg( "[Error] Failed to open clipboard" );
        return false;
    }
    if( EmptyClipboard() == false ) {
        msg( "[Error] Failed to empty clipboard" );
    }

    auto memoryHandle = GlobalAlloc( GMEM_MOVEABLE | GMEM_ZEROINIT, text.size() + 1 );
    if( memoryHandle == nullptr ) {
        msg( "[Error] Failed to allocate clipboard memory" );
        CloseClipboard();
        return false;
    }

    auto textMem = reinterpret_cast< char* >( GlobalLock( memoryHandle ) );
    if( textMem == nullptr ) {
        msg( "[Error] Failed to lock clipboard memory" );
        GlobalFree( memoryHandle );
        CloseClipboard();
        return false;
    }

    memcpy( textMem, text.data(), text.size() );
    GlobalUnlock( memoryHandle );
    auto handle = SetClipboardData( CF_TEXT, memoryHandle );
    GlobalFree( memoryHandle );
    CloseClipboard();

    if( handle == nullptr ) {
        msg( "[Error] SetClipboardData failed" );
        return false;
    }
    return true;
}

// Trim wildcards at end
static void TrimSignature( Signature& signature ) {
    auto it = std::find_if( signature.rbegin(), signature.rend(), []( const auto& sb ) { return !sb.isWildcard; } );
    signature.erase( it.base(), signature.end() );
}

static std::expected<Signature, std::string> GenerateUniqueSignatureForEA( const ea_t ea, bool wildcardOperands, size_t maxSignatureLength = 1000, bool askLongerSignature = true ) {
    if( ea == BADADDR ) {
        return std::unexpected( "Invalid address" );
    }

    if( !is_code( get_flags( ea ) ) ) {
        return std::unexpected( "Can not create code signature for data" );
    }

    Signature signature;
    size_t sigPartLength = 0;

    auto currentAddress = ea;
    while( true ) {
        insn_t instruction;
        auto currentInstructionLength = decode_insn( &instruction, currentAddress );
        if( currentInstructionLength <= 0 ) {
            if( signature.empty() ) {
                return std::unexpected( "Failed to decode first instruction" );
            }

            msg( "Signature reached end of executable code @ %I64X\n", currentAddress );
            auto signatureString = BuildIDASignatureString( signature );
            msg( "NOT UNIQUE Signature for %I64X: %s\n", ea, signatureString.c_str() );
            return std::unexpected( "Signature not unique" );
        }

        // Length check in case the signature becomes too long
        if( sigPartLength > maxSignatureLength ) {
            if( askLongerSignature ) {
                auto result = ask_yn( 1, "Signature is already at %llu bytes. Continue?", signature.size() );
                if( result == 1 ) { // Yes 
                    sigPartLength = 0;
                }
                else if( result == 0 ) { // No
                    // Print the signature we have so far, even though its not unique
                    auto signatureString = BuildIDASignatureString( signature );
                    msg( "NOT UNIQUE Signature for %I64X: %s\n", ea, signatureString.c_str() );
                    return std::unexpected( "Signature not unique" );
                }
                else { // Cancel
                    return std::unexpected( "Aborted" );
                }
            }
            else {
                return std::unexpected( "Signature exceeded maximum length" );
            }
        }
        sigPartLength += currentInstructionLength;

        uint8_t operandOffset = 0, operandLength = 0;
        if( wildcardOperands && GetOperand( instruction, &operandOffset, &operandLength ) && operandLength > 0 ) {
            // Add opcodes
            AddBytesToSignature( signature, currentAddress, operandOffset, false );
            // Wildcards for operands
            AddBytesToSignature( signature, currentAddress + operandOffset, operandLength, true );
            // If the operand is on the "left side", add the operator from the "right side"
            if( operandOffset == 0 ) {
                AddBytesToSignature( signature, currentAddress + operandLength, currentInstructionLength - operandLength, false );
            }
        }
        else {
            // No operand, add all bytes
            AddBytesToSignature( signature, currentAddress, currentInstructionLength, false );
        }

        auto currentSig = BuildIDASignatureString( signature );
        if( IsSignatureUnique( currentSig ) ) {
            // Remove wildcards at end for output
            TrimSignature( signature );

            // Return the signature we generated
            return signature;
        }
        currentAddress += currentInstructionLength;
    }
    return std::unexpected( "Unknown" );
}

// Function for code selection
static std::expected<Signature, std::string> GenerateSignatureForEARange( ea_t eaStart, ea_t eaEnd, bool wildcardOperands ) {
    if( eaStart == BADADDR || eaEnd == BADADDR ) {
        return std::unexpected( "Invalid address" );
    }

    Signature signature;
    size_t sigPartLength = 0;

    // Copy data section, no wildcards
    if( !is_code( get_flags( eaStart ) ) ) {
        AddBytesToSignature( signature, eaStart, eaEnd - eaStart, false );
        return signature;
    }

    auto currentAddress = eaStart;
    while( true ) {
        insn_t instruction;
        auto currentInstructionLength = decode_insn( &instruction, currentAddress );
        if( currentInstructionLength <= 0 ) {
            if( signature.empty() ) {
                return std::unexpected( "Failed to decode first instruction" );
            }

            msg( "Signature reached end of executable code @ %I64X\n", currentAddress );
            // If we have some bytes left, add them
            if( currentAddress < eaEnd ) {
                AddBytesToSignature( signature, currentAddress, eaEnd - currentAddress, false );
            }
            TrimSignature( signature );
            return signature;
        }

        sigPartLength += currentInstructionLength;

        uint8_t operandOffset = 0, operandLength = 0;
        if( wildcardOperands && GetOperand( instruction, &operandOffset, &operandLength ) && operandLength > 0 ) {
            // Add opcodes
            AddBytesToSignature( signature, currentAddress, operandOffset, false );
            // Wildcards for operands
            AddBytesToSignature( signature, currentAddress + operandOffset, operandLength, true );
            // If the operand is on the "left side", add the operator from the "right side"
            if( operandOffset == 0 ) {
                AddBytesToSignature( signature, currentAddress + operandLength, currentInstructionLength - operandLength, false );
            }
        }
        else {
            // No operand, add all bytes
            AddBytesToSignature( signature, currentAddress, currentInstructionLength, false );
        }
        currentAddress += currentInstructionLength;

        if( currentAddress >= eaEnd ) {

            TrimSignature( signature );
            return signature;
        }
    }
    return std::unexpected( "Unknown" );
}

static std::string FormatSignature( const Signature& signature, SignatureType type ) {
    using enum SignatureType;
    switch( type ) {
    case IDA:
        return BuildIDASignatureString( signature );
    case x64Dbg:
        return BuildIDASignatureString( signature, true );
    case Signature_Mask:
        return BuildByteArrayWithMaskSignatureString( signature );
    case SignatureByteArray_Bitmask:
        return BuildBytesWithBitmaskSignatureString( signature );
    }
    return {};
}

void PrintSignatureForEA( const std::expected<Signature, std::string>& signature, ea_t ea, SignatureType sigType ) {
    if( !signature.has_value() ) {
        msg( "Error: %s\n", signature.error().c_str() );
        return;
    }
    const auto signatureStr = FormatSignature( signature.value(), sigType );
    msg( "Signature for %I64X: %s\n", ea, signatureStr.c_str() );
    SetClipboardText( signatureStr );
}

static void FindXRefs( ea_t ea, bool wildcardOperands, std::vector<std::tuple<ea_t, Signature>>& xrefSignatures, size_t maxSignatureLength ) {
    xrefblk_t xref{};
    for( auto xref_ok = xref.first_to( ea, XREF_FAR ); xref_ok; xref_ok = xref.next_to() ) {

        // Skip data refs, xref.iscode is not what we want though
        if( !is_code( get_flags( xref.from ) ) ) {
            continue;
        }

        // Genreate signature for xref
        auto signature = GenerateUniqueSignatureForEA( xref.from, wildcardOperands, maxSignatureLength, false );
        if( !signature.has_value() ) {
            continue;
        }

        xrefSignatures.push_back( std::make_pair( xref.from, signature.value() ) );
    }

    // Sort signatures by length
    std::ranges::sort( xrefSignatures, []( const auto& a, const auto& b ) -> bool { return std::get<1>( a ).size() < std::get<1>( b ).size(); } );
}

static void PrintXRefSignaturesForEA( ea_t ea, const std::vector<std::tuple<ea_t, Signature>>& xrefSignatures, SignatureType sigType, size_t topCount ) {
    if( xrefSignatures.empty() ) {
        msg( "No XREFs have been found for your address\n" );
        return;
    }

    auto topLength = std::min( topCount, xrefSignatures.size() );
    msg( "Top %llu Signatures out of %llu xrefs for %I64X:\n", topLength, xrefSignatures.size(), ea );
    for( size_t i = 0; i < topLength; i++ ) {
        const auto& [originAddress, signature] = xrefSignatures[i];
        const auto signatureStr = FormatSignature( signature, sigType );
        msg( "XREF Signature #%i @ %I64X: %s\n", i + 1, originAddress, signatureStr.c_str() );

        // Copy first signature only
        if( i == 0 ) {
            SetClipboardText( signatureStr );
        }
    }
}

static void PrintSelectedCode( ea_t start, ea_t end, SignatureType sigType, bool wildcardOperands ) {
    const auto selectionSize = end - start;
    __assume( selectionSize > 0 );
    // Create signature of fixed size from selection

    auto signature = GenerateSignatureForEARange( start, end, wildcardOperands );
    if( !signature.has_value() ) {
        msg( "Error: %s\n", signature.error().c_str() );
        return;
    }

    const auto signatureStr = FormatSignature( signature.value(), sigType );
    msg( "Code for %I64X-%I64X: %s\n", start, end, signatureStr.c_str() );
    SetClipboardText( signatureStr );
}

static bool GetRegexMatches( std::string string, std::regex regex, std::vector<std::string>& matches ) {
    std::sregex_iterator iter( string.begin(), string.end(), regex );
    std::sregex_iterator end;

    matches.clear();

    size_t i = 0;
    while( iter != end ) {
        matches.push_back( iter->str() );
        ++iter;
    }
    return !matches.empty();
}

static void SearchSignatureString( std::string input ) {
    // Try to figure out what signature type is used
    // We will convert it to IDA style
    std::string convertedSignatureString;

    std::string stringMask;

    // Try to detect a string mask like "xx????xx?xx"
    // Assume string mask always starts with x, and we don't just have one byte
    std::smatch match;
    if( std::regex_search( input, match, std::regex( R"(x(?:x|\?)+)" ) ) ) {
        stringMask = match[0].str();
    }
    // Try to find binary style bitmask like "0b101110" and convert it to a string mask
    else if( std::regex_search( input, match, std::regex( R"(0b(?:[0,1])+)" ) ) ) {
        auto bits = match[0].str().substr( 2 );
        std::string reversedBits( bits.rbegin(), bits.rend() );
        for( const auto& b : reversedBits ) {
            stringMask += ( b == '1' ? 'x' : '?' );
        }
    }

    if( !stringMask.empty() ) {
        // Since we have a mask, search for the bytes

        std::vector<std::string> rawByteStrings;
        // Search for \x00\x11\x22 type arrays
        if( GetRegexMatches( input, std::regex( R"(\\x(?:[0-9A-F]{2}))" ), rawByteStrings ) && rawByteStrings.size() == stringMask.length() ) {
            Signature convertedSignature;
            for( size_t i = 0; const auto & m : rawByteStrings ) {
                SignatureByte b{ std::stoi( m.substr( 2 ), nullptr, 16 ), stringMask[i++] == '?' };
                convertedSignature.push_back( b );
            }
            convertedSignatureString = BuildIDASignatureString( convertedSignature );
        }
        // Search for 0x00, 0x11, 0x22 type arrays
        else if( GetRegexMatches( input, std::regex( R"((?:0x(?:[0-9A-F]{2}))+)" ), rawByteStrings ) && rawByteStrings.size() == stringMask.length() ) {
            Signature convertedSignature;
            for( size_t i = 0; const auto & m : rawByteStrings ) {
                SignatureByte b{ std::stoi( m.substr( 2 ), nullptr, 16 ), stringMask[i++] == '?' };
                convertedSignature.push_back( b );
            }
            convertedSignatureString = BuildIDASignatureString( convertedSignature );
        }
        else {
            msg( "Detected mask \"%s\" but failed to match corresponding bytes\n", stringMask.c_str() );
        }
    }
    else {
        // We did not find a specific mask, so try formats with included wildcards 

        // Remove braces in case you have makers in your IDA style signature 
        input = std::regex_replace( input, std::regex( R"([\)\(\[\]]+)" ), "" );

        // Remove whitespace at beginning, questionmarks and spaces at the end, and add one space for the following step
        input = std::regex_replace( input, std::regex( "^\\s+" ), "" );
        input = std::regex_replace( input, std::regex( "[? ]+$" ), "" ) + " ";

        // Replace double question marks with single ones to convert x64Dbg style to IDA style
        // We need spaces between signature bytes, because we can not recognize if a signature uses one or two question marks per wildcard
        input = std::regex_replace( input, std::regex( R"(\?\? )" ), "? " );

        // Direct match for IDA type signature
        if( std::regex_match( input, std::regex( R"((?:(?:[A-F0-9]{2}\s+)|(?:\?\s+))+)" ) ) ) {
            // Just use it
            convertedSignatureString = input;
        }
        else {
            // Just try the other formats without wildcards

            std::vector<std::string> rawByteStrings;
            // Search for \x00\x11\x22 type arrays

            if( GetRegexMatches( input, std::regex( R"(\\x(?:[0-9A-F]{2}))" ), rawByteStrings ) && rawByteStrings.size() > 1 ) {
                Signature convertedSignature;
                for( size_t i = 0; const auto & m : rawByteStrings ) {
                    SignatureByte b{ std::stoi( m.substr( 2 ), nullptr, 16 ), false };
                    convertedSignature.push_back( b );
                }
                convertedSignatureString = BuildIDASignatureString( convertedSignature );
            }
            // Search for 0x00, 0x11, 0x22 type arrays
            else if( GetRegexMatches( input, std::regex( R"((?:0x(?:[0-9A-F]{2}))+)" ), rawByteStrings ) && rawByteStrings.size() > 1 ) {
                Signature convertedSignature;
                for( size_t i = 0; const auto & m : rawByteStrings ) {
                    SignatureByte b{ std::stoi( m.substr( 2 ), nullptr, 16 ), false };
                    convertedSignature.push_back( b );
                }
                convertedSignatureString = BuildIDASignatureString( convertedSignature );
            }
            else {
                msg( "Failed to match signature format\n" );
            }
        }
    }

    if( convertedSignatureString.empty() ) {
        msg( "Unrecognized signature type\n" );
        return;
    }

    // Print results
    msg( "Signature: %s\n", convertedSignatureString.c_str() );
    auto signatureMatches = FindSignatureOccurences( convertedSignatureString );
    if( signatureMatches.empty() ) {
        msg( "Signature does not match!\n" );
        return;
    }
    for( const auto& ea : signatureMatches ) {
        msg( "Match @ %I64X\n", ea );
    }
}

bool idaapi plugin_ctx_t::run( size_t ) {

    // Check what processor we have
    if( IsARM() ) {
        IS_ARM = true;
    }

    // Show dialog
    const char format[] =
        "STARTITEM 0\n"                                                         // TabStop
        "Signature Maker\n"                                                     // Title

        "Select action:\n"                                                      // Title
        "<Create unique Signature for current code address:R>\n"                       // Radio Button 0
        "<Find shortest XREF Signature for current data or code address:R>\n"	// Radio Button 1
        "<Copy selected code:R>\n"                                              // Radio Button 2
        "<Search for a signature:R>>\n"                                         // Radio Button 3

        "Output format:\n"                                                      // Title
        "<IDA Signature:R>\n"				                                    // Radio Button 0
        "<x64Dbg Signature:R>\n"			                                    // Radio Button 1
        "<C Byte Array Signature + String mask:R>\n"			                // Radio Button 2
        "<C Raw Bytes Signature + Bitmask:R>>\n"			                    // Radio Button 3

        "Options:\n"                                                            // Title
        "<Wildcards for operands:C>>\n\n";                                      // Checkbox Button

    static short action = 0;
    static short outputFormat = 0;
    static short wildcardOperands = 1;
    if( ask_form( format, &action, &outputFormat, &wildcardOperands ) ) {
        const auto sigType = static_cast< SignatureType >( outputFormat );
        switch( action ) {
        case 0:
        {
            // Find unique signature for current address
            const auto ea = get_screen_ea();
            auto signature = GenerateUniqueSignatureForEA( ea, wildcardOperands );
            PrintSignatureForEA( signature, ea, sigType );
            break;
        }
        case 1:
        {
            // Find XREFs for current selection, generate signatures up to 250 bytes length
            const auto ea = get_screen_ea();
            std::vector<std::tuple<ea_t, Signature>> xrefSignatures;
            FindXRefs( ea, wildcardOperands, xrefSignatures, 250 );

            // Print top 5 shortest signatures
            PrintXRefSignaturesForEA( ea, xrefSignatures, sigType, 5 );
            break;
        }
        case 2:
        {
            // Print selected code as signature
            ea_t start, end;
            if( read_range_selection( get_current_viewer(), &start, &end ) ) {
                PrintSelectedCode( start, end, sigType, wildcardOperands );
            }
            else {
                msg( "Select a range to copy the code\n" );
            }
            break;
        }
        case 3:
        {
            // Search for a signature
            qstring inputSignatureQstring;
            if( ask_str( &inputSignatureQstring, HIST_SRCH, "Enter a signature" ) ) {
                SearchSignatureString( inputSignatureQstring.c_str() );
            }
            break;
        }
        default:
            break;
        }
    }
    return true;
}

```

`IDA Pro SigMaker/Main.h`:

```h
#pragma once
#define NOMINMAX
#include <Windows.h>
#include <expected>
#include <string>
#include <sstream>
#include <format>
#include <vector>
#include <regex>

#include "Plugin.h"

// Signature types and structures
enum class SignatureType : uint32_t {
    IDA = 0,
    x64Dbg,
    Signature_Mask,
    SignatureByteArray_Bitmask
};

typedef struct {
    uint8_t value;
    bool isWildcard;
} SignatureByte;

using Signature = std::vector<SignatureByte>;
```

`IDA Pro SigMaker/MainProperties.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup Label="UserMacros">
    <IDAPRO_PATH>C:\Program Files\IDA 7.0</IDAPRO_PATH>
    <IDAPRO_SDK_PATH>$(IDAPRO_PATH)\idasdk70</IDAPRO_SDK_PATH>
  </PropertyGroup>
  <PropertyGroup />
  <ItemDefinitionGroup />
  <ItemGroup>
    <BuildMacro Include="IDAPRO_PATH">
      <Value>$(IDAPRO_PATH)</Value>
    </BuildMacro>
    <BuildMacro Include="IDAPRO_SDK_PATH">
      <Value>$(IDAPRO_SDK_PATH)</Value>
    </BuildMacro>
  </ItemGroup>
</Project>
```

`IDA Pro SigMaker/Plugin.cpp`:

```cpp
#include "Plugin.h"

plugin_t PLUGIN = {
    IDP_INTERFACE_VERSION,
    PLUGIN_MULTI,
    init,
    nullptr,
    nullptr,
    "Signature Maker for IDA Pro by A200K",
    "Select location in disassembly and press CTRL+ALT+S to open menu",
    "Signature Maker",
    "Ctrl-Alt-S"
};

```

`IDA Pro SigMaker/Plugin.h`:

```h
#pragma once
#include <ida.hpp>
#include <idp.hpp>

#include <loader.hpp>
#include <search.hpp>

// Plugin specific definitions

struct plugin_ctx_t : public plugmod_t {
    ~plugin_ctx_t( ) {
    }
    virtual bool idaapi run( size_t ) override;
};

static plugmod_t *idaapi init( ) {
    return new plugin_ctx_t;
}
```

`README.md`:

```md
# IDA Pro SigMaker
Signature Maker Plugin for IDA Pro 8.3

## Requirements
- IDA Pro Plugin SDK 8.3. Previous versions >= 8.0 might work as well though.

## Installation
Drop into plugins folder of your IDA installation.

`%AppData%\Roaming\Hex-Rays\IDA Pro\plugins`

## Usage
In disassembly view, select a line you want to generate a signature for, and press 
**CTRL+ALT+S**
![](https://i.imgur.com/b4MKkca.png)

The generated signature will be printed to the output console, as well as copied to the clipboard:
![](https://i.imgur.com/mTFbKce.png)

___

| Signature type | Example preview |
| --- | ----------- |
| IDA Signature | E8 ? ? ? ? 45 33 F6 66 44 89 34 33 |
| x64Dbg Signature | E8 ?? ?? ?? ?? 45 33 F6 66 44 89 34 33 |
| C Byte Array Signature + String mask | \xE8\x00\x00\x00\x00\x45\x33\xF6\x66\x44\x89\x34\x33 x????xxxxxxxx |
| C Raw Bytes Signature + Bitmask | 0xE8, 0x00, 0x00, 0x00, 0x00, 0x45, 0x33, 0xF6, 0x66, 0x44, 0x89, 0x34, 0x33  0b1111111100001 |

___
### Finding XREFs
Generating code Signatures by data or code xrefs and finding the shortest ones is also supported:
![](https://i.imgur.com/P0VRIFQ.png)

___
### Signature searching
Searching for Signatures works for supported formats:

![](https://i.imgur.com/lD4Zfwb.png)

Just enter any string containing your Signature, it will automatically try to figure out what kind of Signature format is being used:

![](https://i.imgur.com/oWMs7LN.png)

Currently, all output formats you can generate are supported.

Match(es) of your signature will be printed to console:

![](https://i.imgur.com/Pe4REkX.png)

```