Project Path: arc_gmh5225_the-finals-interior-cheat_yriwbmro

Source Tree:

```txt
arc_gmh5225_the-finals-interior-cheat_yriwbmro
├── NtUserSendInput.asm
├── README.md
├── ZeroGUI.h
├── dllmain.cpp
├── game_data.h
├── game_miscs.h
├── hooking.h
├── importer.hpp
├── includes.h
├── main.h
├── memory.h
├── menu.h
├── novacane.clinic.sln
├── novacane.clinic.vcxproj
├── novacane.clinic.vcxproj.filters
├── novacane.clinic.vcxproj.user
├── pch.cpp
├── pch.h
├── render.h
├── sdk.h
├── settings.h
└── vmthook.h

```

`NtUserSendInput.asm`:

```asm
.code

_NtUserSendInput PROC

	mov r10, rcx
	mov eax, 3735928559
	syscall
	ret

_NtUserSendInput ENDP

END
```

`README.md`:

```md
# the-finals-interior
the finals interior cheat 

Current features: 1：Characters glow 2：The item glows 3：The loot glows 4：Simulates smooth self-aiming 5：No back seat
Dedicated to learning and communication

```

`ZeroGUI.h`:

```h
#pragma once

namespace ZeroGUI
{
	namespace Input
	{
		bool mouseDown[5];
		bool mouseDownAlready[256];

		bool keysDown[256];
		bool keysDownAlready[256];

		bool IsAnyMouseDown()
		{
			if (mouseDown[0]) return true;
			if (mouseDown[1]) return true;
			if (mouseDown[2]) return true;
			if (mouseDown[3]) return true;
			if (mouseDown[4]) return true;

			return false;
		}

		bool IsMouseClicked(int button, int element_id, bool repeat)
		{
			if (mouseDown[button])
			{
				if (!mouseDownAlready[element_id])
				{
					mouseDownAlready[element_id] = true;
					return true;
				}
				if (repeat)
					return true;
			}
			else
			{
				mouseDownAlready[element_id] = false;
			}
			return false;
		}
		bool IsKeyPressed(int key, bool repeat)
		{
			if (keysDown[key])
			{
				if (!keysDownAlready[key])
				{
					keysDownAlready[key] = true;
					return true;
				}
				if (repeat)
					return true;
			}
			else
			{
				keysDownAlready[key] = false;
			}
			return false;
		}

		void Handle()
		{
			if (IFH(GetAsyncKeyState)(0x01))
				mouseDown[0] = true;
			else
				mouseDown[0] = false;
		}
	}
}

namespace ZeroGUI
{
	namespace Colors
	{
		flinearcolor Text = { 1.0f, 1.0f, 1.0f, 1.0f };
		flinearcolor Text_Shadow = { 0.0f, 0.0f, 0.0f, 0.0f };
		flinearcolor Text_Outline = { 0.0f, 0.0f, 0.0f, 0.30f };

		flinearcolor Window_Background = { 0.15f, 0.15f, 0.15f, 1.0f };
		flinearcolor Window_Header = { 0.22f, 0.45f, 0.78f, 1.0f };

		flinearcolor Button_Idle = { 0.22f, 0.45f, 0.78f, 1.0f };
		flinearcolor Button_Hovered = { 0.28f, 0.55f, 0.92f, 1.0f };
		flinearcolor Button_Active = { 0.35f, 0.65f, 0.98f, 1.0f };

		flinearcolor Checkbox_Idle = { 0.10f, 0.10f, 0.10f, 1.0f };
		flinearcolor Checkbox_Hovered = { 0.15f, 0.15f, 0.15f, 1.0f };
		flinearcolor Checkbox_Enabled = { 0.22f, 0.45f, 0.78f, 1.0f };

		flinearcolor Combobox_Idle = { 0.10f, 0.10f, 0.10f, 1.0f };
		flinearcolor Combobox_Hovered = { 0.15f, 0.15f, 0.15f, 1.0f };
		flinearcolor Combobox_Elements = { 0.42f, 0.80f, 0.98f, 1.0f };

		flinearcolor Slider_Idle = { 0.10f, 0.10f, 0.10f, 1.0f };
		flinearcolor Slider_Hovered = { 0.15f, 0.15f, 0.15f, 1.0f };
		flinearcolor Slider_Progress = { 0.22f, 0.45f, 0.78f, 1.0f };
		flinearcolor Slider_Button = { 0.28f, 0.55f, 0.92f, 1.0f };

		flinearcolor ColorPicker_Background = { 0.05f, 0.05f, 0.05f, 1.0f };

		// Light purple colors
		flinearcolor LightPurple = { 0.80f, 0.60f, 0.90f, 1.0f };
		flinearcolor LightPurple_Hovered = { 0.85f, 0.70f, 0.95f, 1.0f };
	}

	namespace PostRenderer
	{
		struct DrawList
		{
			int type = -1; //1 = FilledRect, 2 = TextLeft, 3 = TextCenter, 4 = Draw_Line
			fvector2d pos;
			fvector2d size;
			flinearcolor color;
			const char* name;
			bool outline;

			fvector2d from;
			fvector2d to;
			int thickness;
		};
		DrawList drawlist[128];

		void drawFilledRect(fvector2d pos, float w, float h, flinearcolor color)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 1;
					drawlist[i].pos = pos;
					drawlist[i].size = fvector2d{ w, h };
					drawlist[i].color = color;
					return;
				}
			}
		}
		void TextLeft(const char* name, fvector2d pos, flinearcolor color, bool outline)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 2;
					drawlist[i].name = name;
					drawlist[i].pos = pos;
					drawlist[i].outline = outline;
					drawlist[i].color = color;
					return;
				}
			}
		}
		void TextCenter(const char* name, fvector2d pos, flinearcolor color, bool outline)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 3;
					drawlist[i].name = name;
					drawlist[i].pos = pos;
					drawlist[i].outline = outline;
					drawlist[i].color = color;
					return;
				}
			}
		}
		void Draw_Line(fvector2d from, fvector2d to, int thickness, flinearcolor color)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 4;
					drawlist[i].from = from;
					drawlist[i].to = to;
					drawlist[i].thickness = thickness;
					drawlist[i].color = color;
					return;
				}
			}
		}
	}

	ucanvas* canvas;
	wchar_t* s2wc(const char* c)
	{
		const size_t cSize = IFH(strlen)(c) + 1;
		wchar_t* wc = new wchar_t[cSize];
		IFH(mbstowcs)(wc, c, cSize);

		return wc;
	}

	bool hover_element = false;
	fvector2d menu_pos = fvector2d{ 0, 0 };
	float offset_x = 0.0f;
	float offset_y = 0.0f;

	fvector2d first_element_pos = fvector2d{ 0, 0 };

	fvector2d last_element_pos = fvector2d{ 0, 0 };
	fvector2d last_element_size = fvector2d{ 0, 0 };

	int current_element = -1;
	fvector2d current_element_pos = fvector2d{ 0, 0 };
	fvector2d current_element_size = fvector2d{ 0, 0 };
	int elements_count = 0;

	bool sameLine = false;

	bool pushY = false;
	float pushYvalue = 0.0f;

	void SetupCanvas(ucanvas* _canvas)
	{
		canvas = _canvas;
	}

	fvector2d CursorPos()
	{
		POINT cursorPos;
		IFH(GetCursorPos)(&cursorPos);
		return fvector2d{ (float)cursorPos.x, (float)cursorPos.y };
	}
	bool MouseInZone(fvector2d pos, fvector2d size)
	{
		fvector2d cursor_pos = CursorPos();

		if (cursor_pos.x > pos.x && cursor_pos.y > pos.y)
			if (cursor_pos.x < pos.x + size.x && cursor_pos.y < pos.y + size.y)
				return true;

		return false;
	}

	void Draw_Cursor(bool toggle)
	{
		if (toggle)
		{
			fvector2d cursorPos = CursorPos();
			flinearcolor cursorColor{ 0.22f, 0.45f, 0.78f, 1.0f };
			int cursorSize = 20;

			canvas->k2_draw_line(cursorPos, cursorPos + fvector2d{ 35.0f, 10.0f }, 1, cursorColor);

			for (int i = 1; i <= cursorSize; i++)
			{
				float progress = static_cast<float>(i) / cursorSize;
				fvector2d lineEnd = cursorPos + fvector2d{ 35.0f * progress, 10.0f * progress };

				canvas->k2_draw_line(cursorPos, lineEnd, 1, cursorColor);
			}

			canvas->k2_draw_line(cursorPos, cursorPos + fvector2d{ 15.0f, 30.0f }, 1, cursorColor);
			canvas->k2_draw_line(cursorPos + fvector2d{ 35.0f, 10.0f }, cursorPos + fvector2d{ 15.0f, 30.0f }, 1, cursorColor);
		}
	}

	void SameLine()
	{
		sameLine = true;
	}
	void PushNextElementY(float y, bool from_last_element = true)
	{
		pushY = true;
		if (from_last_element)
			pushYvalue = last_element_pos.y + last_element_size.y + y;
		else
			pushYvalue = y;
	}
	void NextColumn(float x)
	{
		offset_x = x;
		PushNextElementY(first_element_pos.y, false);
	}
	void ClearFirstPos()
	{
		first_element_pos = fvector2d{ 0, 0 };
	}

	void TextLeft(const char* name, fvector2d pos, flinearcolor color, bool outline)
	{
		int length = IFH(strlen)(name) + 1;
		canvas->k2_draw_text(render::font, fstring{ s2wc(name) }, pos, fvector2d{ 0.97f, 0.97f }, color, false, Colors::Text_Shadow, fvector2d{ pos.x + 1, pos.y + 1 }, false, true, true, Colors::Text_Outline);
	}
	void TextCenter(const char* name, fvector2d pos, flinearcolor color, bool outline)
	{
		int length = IFH(strlen)(name) + 1;
		canvas->k2_draw_text(render::font, fstring{ s2wc(name) }, pos, fvector2d{ 0.97f, 0.97f }, color, false, Colors::Text_Shadow, fvector2d{ pos.x + 1, pos.y + 1 }, true, true, true, Colors::Text_Outline);
	}



	void Draw_Line(fvector2d from, fvector2d to, int thickness, flinearcolor color)
	{
		canvas->k2_draw_line(fvector2d{ from.x, from.y }, fvector2d{ to.x, to.y }, thickness, color);
	}
	void drawFilledRect(fvector2d initial_pos, float w, float h, flinearcolor color)
	{
		for (float i = 0.0f; i < h; i += 1.0f)
			canvas->k2_draw_line(fvector2d{ initial_pos.x, initial_pos.y + i }, fvector2d{ initial_pos.x + w, initial_pos.y + i }, 1.0f, color);
	}
	void drawFilledRect_trans(fvector2d initial_pos, float w, float h, flinearcolor color)
	{
		for (float i = 0.0f; i < h; i += 1.0f)
			canvas->k2_draw_line(fvector2d{ initial_pos.x, initial_pos.y + i }, fvector2d{ initial_pos.x + w, initial_pos.y + i }, 0.4f, color);
	}
	void DrawFilledCircle(fvector2d pos, float r, flinearcolor color)
	{
		float smooth = 0.07f;

		double PI = 3.14159265359;
		int size = (int)(2.0f * PI / smooth) + 1;

		float angle = 0.0f;
		int i = 0;

		for (; angle < 2 * PI; angle += smooth, i++)
		{
			Draw_Line(fvector2d{ pos.x, pos.y }, fvector2d{ pos.x + cosf(angle) * r, pos.y + sinf(angle) * r }, 1.0f, color);
		}
	}
	void DrawCircle(fvector2d pos, int radius, int numSides, flinearcolor Color)
	{
		float PI = 3.1415927f;

		float Step = PI * 2.0 / numSides;
		int Count = 0;
		fvector2d V[128];
		for (float a = 0; a < PI * 2.0; a += Step) {
			float X1 = radius * defines::math->cos(a) + pos.x;
			float Y1 = radius * defines::math->sin(a) + pos.y;
			float X2 = radius * defines::math->cos(a + Step) + pos.x;
			float Y2 = radius * defines::math->sin(a + Step) + pos.y;
			V[Count].x = X1;
			V[Count].y = Y1;
			V[Count + 1].x = X2;
			V[Count + 1].y = Y2;
			//Draw_Line(fvector2d{ pos.x, pos.y }, fvector2d{ X2, Y2 }, 1.0f, Color); // Points from Centre to ends of circle
			Draw_Line(fvector2d{ V[Count].x, V[Count].y }, fvector2d{ X2, Y2 }, 1.0f, Color);// Circle Around
		}
	}

	fvector2d dragPos;
	bool Window(const char* name, fvector2d* pos, fvector2d size, bool isOpen, float width, float height)
	{
		elements_count = 0;

		if (!isOpen)
			return false;

		bool isHovered = MouseInZone(fvector2d{ pos->x, pos->y }, size);

		//Drop last element
		if (current_element != -1 && !IFH(GetAsyncKeyState)(0x1))
		{
			current_element = -1;
		}

		//Drag
		if (hover_element && IFH(GetAsyncKeyState)(0x1))
		{

		}
		else if ((isHovered || dragPos.x != 0) && !hover_element)
		{
			if (Input::IsMouseClicked(0, elements_count, true))
			{
				fvector2d cursorPos = CursorPos();

				cursorPos.x -= size.x;
				cursorPos.y -= size.y;

				if (dragPos.x == 0)
				{
					dragPos.x = (cursorPos.x - pos->x);
					dragPos.y = (cursorPos.y - pos->y);
				}
				pos->x = cursorPos.x - dragPos.x;
				pos->y = cursorPos.y - dragPos.y;
			}
			else
			{
				dragPos = fvector2d{ 0, 0 };
			}
		}
		else
		{
			hover_element = false;
		}


		offset_x = 0.0f; offset_y = 0.0f;
		menu_pos = fvector2d{ pos->x, pos->y };
		first_element_pos = fvector2d{ 0, 0 };
		current_element_pos = fvector2d{ 0, 0 };
		current_element_size = fvector2d{ 0, 0 };

		// Dark transparent background
		//drawFilledRect_trans(fvector2d{ 0, 0 }, width, height, flinearcolor{ 0.0f, 0.0f, 0.0f, 0.4f });


		// Bg
		drawFilledRect(fvector2d{ pos->x, pos->y }, size.x, size.y, Colors::Window_Background);
		//drawFilledRect(fvector2d{ pos->x, pos->y }, 122, size.y, flinearcolor{ 0.006f, 0.006f, 0.006f, 1.0f });//My tabs bg

		// Header
		drawFilledRect(fvector2d{ pos->x, pos->y }, size.x, 25.0f, Colors::Window_Header);

		offset_y += 25.0f;

		// Title
		fvector2d titlePos = fvector2d{ pos->x + size.x / 2, pos->y + 25 / 2 };
		TextCenter(name, titlePos, flinearcolor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

		return true;
	}

	void Text(const char* text, bool center = false, bool outline = false)
	{
		elements_count++;

		float size = 25;
		fvector2d padding = fvector2d{ 10, 10 };
		fvector2d pos = fvector2d{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if (sameLine)
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}
		if (pushY)
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}

		if (!sameLine)
			offset_y += size + padding.y;

		//Text
		fvector2d textPos = fvector2d{ pos.x + 5.0f, pos.y + size / 2 };
		if (center)
			TextCenter(text, textPos, flinearcolor{ 1.0f, 1.0f, 1.0f, 1.0f }, outline);
		else
			TextLeft(text, textPos, flinearcolor{ 1.0f, 1.0f, 1.0f, 1.0f }, outline);

		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if (first_element_pos.x == 0.0f)
			first_element_pos = pos;
	}



	bool ButtonTab(const char* name, fvector2d size, bool active)
	{
		elements_count++;

		fvector2d padding = { 5, 10 };
		fvector2d pos = { menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };

		if (sameLine)
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}

		if (pushY)
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}

		bool isHovered = MouseInZone(pos, size);

		// Background
		flinearcolor buttonColor = active ? Colors::Button_Active : (isHovered ? Colors::Button_Hovered : Colors::Button_Idle);
		drawFilledRect(pos, size.x, size.y, buttonColor);

		if (!sameLine)
			offset_y += size.y + padding.y;

		// Text
		fvector2d textPos = { pos.x + size.x / 2, pos.y + size.y / 2 };
		TextCenter(name, textPos, { 1.0f, 1.0f, 1.0f, 1.0f }, false);

		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.x == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			return true;

		return false;
	}

	bool Button(const char* name, fvector2d size)
	{
		elements_count++;

		fvector2d padding = fvector2d{ 5, 10 };
		fvector2d pos = fvector2d{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if (sameLine)
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}
		if (pushY)
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}
		bool isHovered = MouseInZone(fvector2d{ pos.x, pos.y }, size);

		//Bg
		if (isHovered)
		{
			drawFilledRect(fvector2d{ pos.x, pos.y }, size.x, size.y, Colors::Button_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(fvector2d{ pos.x, pos.y }, size.x, size.y, Colors::Button_Idle);
		}

		if (!sameLine)
			offset_y += size.y + padding.y;

		//Text
		fvector2d textPos = fvector2d{ pos.x + size.x / 2, pos.y + size.y / 2 };
		//if (!TextOverlapedFromActiveElement(textPos))
		TextCenter(name, textPos, flinearcolor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.x == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			return true;

		return false;
	}
	void Checkbox(const char* name, bool* value)
	{
		elements_count++;

		float size = 18;
		fvector2d padding = fvector2d{ 10, 10 };
		fvector2d pos = fvector2d{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if (sameLine)
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}
		if (pushY)
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}
		bool isHovered = MouseInZone(fvector2d{ pos.x, pos.y }, fvector2d{ size, size });

		//Bg
		if (isHovered)
		{
			drawFilledRect(fvector2d{ pos.x, pos.y }, size, size, Colors::Checkbox_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(fvector2d{ pos.x, pos.y }, size, size, Colors::Checkbox_Idle);
		}

		if (!sameLine)
			offset_y += size + padding.y;

		if (*value)
		{
			drawFilledRect(fvector2d{ pos.x + 3, pos.y + 3 }, size - 6, size - 6, Colors::Checkbox_Enabled);
			//drawFilledRect(fvector2d{ pos.x + 9, pos.y + 9 }, size - 18, size - 18, Colors::Checkbox_Hovered);
		}



		//Text
		fvector2d textPos = fvector2d{ pos.x + size + 5.0f, pos.y + size / 2 };
		//if (!TextOverlapedFromActiveElement(textPos))
		TextLeft(name, textPos, flinearcolor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);


		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if (first_element_pos.x == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			*value = !*value;
	}
	//void SliderInt( const char* name, int* value, int min, int max )
	//{
	//	elements_count++;

	//	fvector2d size = fvector2d { 240, 50 };
	//	fvector2d slider_size = fvector2d { 200, 10 };
	//	fvector2d padding = fvector2d { 10, 15 };
	//	fvector2d pos = fvector2d { menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
	//	if ( sameLine )
	//	{
	//		pos.x = last_element_pos.x + last_element_size.x + padding.x;
	//		pos.y = last_element_pos.y;
	//	}
	//	if ( pushY )
	//	{
	//		pos.y = pushYvalue;
	//		pushY = false;
	//		pushYvalue = 0.0f;
	//		offset_y = pos.y - menu_pos.y;
	//	}
	//	bool isHovered = MouseInZone( fvector2d { pos.x, pos.y + slider_size.y + padding.y }, slider_size );

	//	if ( !sameLine )
	//		offset_y += size.y + padding.y;

	//	//Bg
	//	if ( isHovered || current_element == elements_count )
	//	{
	//		//Drag
	//		if ( Input::IsMouseClicked( 0, elements_count, true ) )
	//		{
	//			current_element = elements_count;

	//			fvector2d cursorPos = CursorPos( );
	//			*value = ((cursorPos.x - pos.x) * ((max - min) / slider_size.x)) + min;
	//			if ( *value < min ) *value = min;
	//			if ( *value > max ) *value = max;
	//		}

	//		drawFilledRect( fvector2d { pos.x, pos.y + slider_size.y + padding.y }, slider_size.x, slider_size.y, Colors::Slider_Hovered );
	//		drawFilledRect( fvector2d { pos.x, pos.y + slider_size.y + padding.y + 5.0f }, 5.0f, 5.0f, Colors::Slider_Progress );

	//		hover_element = true;
	//	}
	//	else
	//	{
	//		drawFilledRect( fvector2d { pos.x, pos.y + slider_size.y + padding.y }, slider_size.x, slider_size.y, Colors::Slider_Idle );
	//		drawFilledRect( fvector2d { pos.x, pos.y + slider_size.y + padding.y + 5.0f }, 5.0f, 5.0f, Colors::Slider_Progress );
	//	}


	//	//Value
	//	float oneP = slider_size.x / (max - min);
	//	drawFilledRect( fvector2d { pos.x, pos.y + slider_size.y + padding.y }, oneP * (*value - min), slider_size.y, Colors::Slider_Progress );
	//	//drawFilledRect(fvector2d{ pos.x + oneP * (*value - min) - 10.0f, pos.y + slider_size.y - 5.0f + padding.y }, 20.0f, 20.0f, Colors::Slider_Button);
	//	DrawFilledCircle( fvector2d { pos.x + oneP * (*value - min), pos.y + slider_size.y + 3.3f + padding.y }, 10.0f, Colors::Slider_Button );
	//	DrawFilledCircle( fvector2d { pos.x + oneP * (*value - min), pos.y + slider_size.y + 3.3f + padding.y }, 5.0f, Colors::Slider_Progress );

	//	char buffer [ 32 ];
	//	sprintf_s( buffer, "%i", *value );
	//	fvector2d valuePos = fvector2d { pos.x + oneP * (*value - min), pos.y + slider_size.y + 25 + padding.y };
	//	TextCenter( buffer, valuePos, flinearcolor { 1.0f, 1.0f, 1.0f, 1.0f }, false );

	//	//Text
	//	fvector2d textPos = fvector2d { pos.x + 5, pos.y + 10 };
	//	TextLeft( name, textPos, flinearcolor { 1.0f, 1.0f, 1.0f, 1.0f }, false );


	//	sameLine = false;
	//	last_element_pos = pos;
	//	last_element_size = size;
	//	if ( first_element_pos.x == 0.0f )
	//		first_element_pos = pos;
	//}
	void SliderFloat(const char* name, float* value, float min, float max, const char* format = "%.0f")
	{
		elements_count++;

		fvector2d size = { 210, 40 };
		fvector2d slider_size = { 170, 7 };
		fvector2d adjust_zone = { 0, 20 };
		fvector2d padding = { 10, 15 };
		fvector2d pos = { menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };

		if (sameLine)
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}

		if (pushY)
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}

		bool isHovered = MouseInZone(pos, { slider_size.x, slider_size.y + adjust_zone.y * 1.5f });

		if (!sameLine)
			offset_y += size.y + padding.y;

		// Background
		flinearcolor sliderIdleColor = isHovered || current_element == elements_count ? Colors::Slider_Hovered : Colors::Slider_Idle;
		drawFilledRect({ pos.x, pos.y + slider_size.y + padding.y }, slider_size.x, slider_size.y, sliderIdleColor);
		DrawFilledCircle({ pos.x, pos.y + padding.y + 9.3f }, 3.1f, Colors::Slider_Progress);
		DrawFilledCircle({ pos.x + slider_size.x, pos.y + padding.y + 9.3f }, 3.1f, sliderIdleColor);

		if (isHovered || current_element == elements_count)
		{
			// Drag
			if (Input::IsMouseClicked(0, elements_count, true))
			{
				current_element = elements_count;

				fvector2d cursorPos = CursorPos();
				*value = ((cursorPos.x - pos.x) * ((max - min) / slider_size.x)) + min;
				if (*value < min)
					*value = min;
				if (*value > max)
					*value = max;
			}

			hover_element = true;
		}

		// Text
		fvector2d textPos = { pos.x, pos.y + 5 };
		TextLeft(name, textPos, Colors::Text, false);

		// Value
		float oneP = slider_size.x / (max - min);
		drawFilledRect({ pos.x, pos.y + slider_size.y + padding.y }, oneP * (*value - min), slider_size.y, Colors::Slider_Progress);
		DrawFilledCircle({ pos.x + oneP * (*value - min), pos.y + slider_size.y + 2.66f + padding.y }, 8.0f, Colors::Slider_Button);
		DrawFilledCircle({ pos.x + oneP * (*value - min), pos.y + slider_size.y + 2.66f + padding.y }, 4.0f, Colors::Slider_Progress);

		char buffer[32];
		sprintf_s(buffer, format, *value);
		fvector2d valuePos = { pos.x + oneP * (*value - min), pos.y + slider_size.y + 20 + padding.y };
		TextCenter(buffer, valuePos, Colors::Text, false);

		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.x == 0.0f)
			first_element_pos = pos;
	}



	bool checkbox_enabled[256];
	void Combobox(const char* name, fvector2d size, int* value, const char* arg, ...)
	{
		elements_count++;

		fvector2d padding = fvector2d{ 5, 10 };
		fvector2d pos = fvector2d{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if (sameLine)
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}
		if (pushY)
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}
		bool isHovered = MouseInZone(fvector2d{ pos.x, pos.y }, size);

		//Bg
		if (isHovered || checkbox_enabled[elements_count])
		{
			drawFilledRect(fvector2d{ pos.x, pos.y }, size.x, size.y, Colors::Combobox_Hovered);

			hover_element = true;
		}
		else
		{
			drawFilledRect(fvector2d{ pos.x, pos.y }, size.x, size.y, Colors::Combobox_Idle);
		}

		if (!sameLine)
			offset_y += size.y + padding.y;

		//Text
		fvector2d textPos = fvector2d{ pos.x + size.x + 5.0f, pos.y + size.y / 2 };
		TextLeft(name, textPos, flinearcolor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

		//Elements
		bool isHovered2 = false;
		fvector2d element_pos = pos;
		int num = 0;

		if (checkbox_enabled[elements_count])
		{
			current_element_size.x = element_pos.x - 5.0f;
			current_element_size.y = element_pos.y - 5.0f;
		}
		va_list arguments;
		for (va_start(arguments, arg); arg != NULL; arg = va_arg(arguments, const char*))
		{
			//Selected Element
			if (num == *value)
			{
				fvector2d _textPos = fvector2d{ pos.x + size.x / 2, pos.y + size.y / 2 };
				TextCenter((char*)arg, _textPos, flinearcolor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
			}

			if (checkbox_enabled[elements_count])
			{
				element_pos.y += 25.0f;

				isHovered2 = MouseInZone(fvector2d{ element_pos.x, element_pos.y }, fvector2d{ size.x, 25.0f });
				if (isHovered2)
				{
					hover_element = true;
					PostRenderer::drawFilledRect(fvector2d{ element_pos.x, element_pos.y }, size.x, 25.0f, Colors::Combobox_Hovered);

					//Click
					if (Input::IsMouseClicked(0, elements_count, false))
					{
						*value = num;
						checkbox_enabled[elements_count] = false;
					}
				}
				else
				{
					PostRenderer::drawFilledRect(fvector2d{ element_pos.x, element_pos.y }, size.x, 25.0f, Colors::Combobox_Idle);
				}

				PostRenderer::TextLeft((char*)arg, fvector2d{ element_pos.x + 5.0f, element_pos.y + 15.0f }, flinearcolor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
			}
			num++;
		}
		va_end(arguments);
		if (checkbox_enabled[elements_count])
		{
			current_element_size.x = element_pos.x + 5.0f;
			current_element_size.y = element_pos.y + 5.0f;
		}


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.x == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
		{
			checkbox_enabled[elements_count] = !checkbox_enabled[elements_count];
		}
		if (!isHovered && !isHovered2 && Input::IsMouseClicked(0, elements_count, false))
		{
			checkbox_enabled[elements_count] = false;
		}
	}

	int active_hotkey = -1;
	bool already_pressed = false;
	std::string VirtualKeyCodeToString(UCHAR virtualKey)
	{
		UINT scanCode = MapVirtualKey(virtualKey, MAPVK_VK_TO_VSC);

		if (virtualKey == VK_LBUTTON)
		{
			return ("MOUSE0");
		}
		if (virtualKey == VK_RBUTTON)
		{
			return ("MOUSE1");
		}
		if (virtualKey == VK_MBUTTON)
		{
			return ("MBUTTON");
		}
		if (virtualKey == VK_XBUTTON1)
		{
			return ("XBUTTON1");
		}
		if (virtualKey == VK_XBUTTON2)
		{
			return ("XBUTTON2");
		}

		CHAR szName[128];
		int result = 0;
		switch (virtualKey)
		{
		case VK_LEFT: case VK_UP: case VK_RIGHT: case VK_DOWN:
		case VK_RCONTROL: case VK_RMENU:
		case VK_LWIN: case VK_RWIN: case VK_APPS:
		case VK_PRIOR: case VK_NEXT:
		case VK_END: case VK_HOME:
		case VK_INSERT: case VK_DELETE:
		case VK_DIVIDE:
		case VK_NUMLOCK:
			scanCode |= KF_EXTENDED;
		default:
			result = IFH(GetKeyNameTextA)(scanCode << 16, szName, 128);
		}

		return szName;
	}
	void Hotkey(const char* name, fvector2d size, int* key)
	{
		elements_count++;

		fvector2d padding = fvector2d{ 5, 10 };
		fvector2d pos = fvector2d{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if (sameLine)
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y + (last_element_size.y / 2) - size.y / 2;
		}
		if (pushY)
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}
		bool isHovered = MouseInZone(fvector2d{ pos.x, pos.y }, size);

		//Bg
		if (isHovered)
		{
			drawFilledRect(fvector2d{ pos.x, pos.y }, size.x, size.y, Colors::Button_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(fvector2d{ pos.x, pos.y }, size.x, size.y, Colors::Button_Idle);
		}

		if (!sameLine)
			offset_y += size.y + padding.y;

		if (active_hotkey == elements_count)
		{
			//Text
			fvector2d textPos = fvector2d{ pos.x + size.x / 2, pos.y + size.y / 2 };
			TextCenter("[Press Key]", textPos, flinearcolor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

			if (!ZeroGUI::Input::IsAnyMouseDown())
			{
				already_pressed = false;
			}

			if (!already_pressed)
			{
				for (int code = 0; code < 255; code++)
				{
					if (IFH(GetAsyncKeyState)(code))
					{
						*key = code;
						active_hotkey = -1;
					}
				}
			}
		}
		else
		{
			//Text
			fvector2d textPos = fvector2d{ pos.x + size.x / 2, pos.y + size.y / 2 };
			TextCenter((char*)VirtualKeyCodeToString(*key).c_str(), textPos, flinearcolor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

			if (isHovered)
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{
					already_pressed = true;
					active_hotkey = elements_count;

					//Queue Fix
					for (int code = 0; code < 255; code++)
						if (IFH(GetAsyncKeyState)(code)) {}
				}
			}
			else
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{
					active_hotkey = -1;
				}
			}
		}


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.x == 0.0f)
			first_element_pos = pos;
	}

	int active_picker = -1;
	flinearcolor saved_color;
	


	void Render()
	{
		for (int i = 0; i < 128; i++)
		{
			if (PostRenderer::drawlist[i].type != -1)
			{
				//Filled Rect
				if (PostRenderer::drawlist[i].type == 1)
				{
					ZeroGUI::drawFilledRect(PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].size.x, PostRenderer::drawlist[i].size.y, PostRenderer::drawlist[i].color);
				}
				//TextLeft
				else if (PostRenderer::drawlist[i].type == 2)
				{
					ZeroGUI::TextLeft(PostRenderer::drawlist[i].name, PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].color, PostRenderer::drawlist[i].outline);
				}
				//TextCenter
				else if (PostRenderer::drawlist[i].type == 3)
				{
					ZeroGUI::TextCenter(PostRenderer::drawlist[i].name, PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].color, PostRenderer::drawlist[i].outline);
				}
				//Draw_Line
				else if (PostRenderer::drawlist[i].type == 4)
				{
					Draw_Line(PostRenderer::drawlist[i].from, PostRenderer::drawlist[i].to, PostRenderer::drawlist[i].thickness, PostRenderer::drawlist[i].color);
				}

				PostRenderer::drawlist[i].type = -1;
			}
		}
	}
}



```

`dllmain.cpp`:

```cpp
#include "includes.h"
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
BOOL APIENTRY DllMain(HMODULE module, DWORD reason, LPVOID reserved) {
	if (reason == DLL_PROCESS_ATTACH) {
		novacane::init();
	}

	return TRUE;
}
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
// GO TO sdk.h TO UPDATE THE OFFSETS
```

`game_data.h`:

```h
#pragma once

```

`game_miscs.h`:

```h
#pragma once
#include <vector>

#define contains_record( address, type, field ) ( ( type* )( ( char* )( address ) - ( std::uintptr_t )( & ( (type* ) 0 ) -> field ) ) )
#define loword(l) ((std::uint16_t)(((std::uintptr_t)(l)) & 0xffff))


namespace string {
	int wcslen(wchar_t* str) {
		int counter = 0;
		if (!str)
			return 0;
		for (; *str != '\0'; ++str)
			++counter;
		return counter;
	}

	int wcsicmp_insensitive(wchar_t* cs, wchar_t* ct) {
		auto len = wcslen(cs);
		if (len != wcslen(ct))
			return false;

		for (size_t i = 0; i < len; i++)
			if ((cs[i] | L' ') != (ct[i] | L' '))
				return false;

		return true;
	}
}

namespace ntos {
	struct list_entry {
		struct list_entry* Flink;
		struct list_entry* Blink;
	};

	struct unicode_string {
		unsigned short Length;
		unsigned short MaximumLength;
		wchar_t* Buffer;
	};

	struct peb_ldr_data {
		unsigned long Length;
		unsigned long Initialized;
		const char* SsHandle;
		list_entry InLoadOrderModuleList;
		list_entry InMemoryOrderModuleList;
		list_entry InInitializationOrderModuleList;
	};

	struct peb {
		unsigned char   Reserved1[2];
		unsigned char   BeingDebugged;
		unsigned char   Reserved2[1];
		const char* Reserved3[2];
		peb_ldr_data* Ldr;
	};

	struct ldr_data_table_entry {
		list_entry InLoadOrderModuleList;
		list_entry InMemoryOrderLinks;
		list_entry InInitializationOrderModuleList;
		void* DllBase;
		void* EntryPoint;
		union {
			unsigned long SizeOfImage;
			const char* _dummy;
		};
		unicode_string FullDllName;
		unicode_string BaseDllName;
	};

	struct image_dos_header {
		unsigned short e_magic;
		unsigned short e_cblp;
		unsigned short e_cp;
		unsigned short e_crlc;
		unsigned short e_cparhdr;
		unsigned short e_minalloc;
		unsigned short e_maxalloc;
		unsigned short e_ss;
		unsigned short e_sp;
		unsigned short e_csum;
		unsigned short e_ip;
		unsigned short e_cs;
		unsigned short e_lfarlc;
		unsigned short e_ovno;
		unsigned short e_res[4];
		unsigned short e_oemid;
		unsigned short e_oeminfo;
		unsigned short e_res2[10];
		long e_lfanew;
	};

	struct image_file_header {
		unsigned short Machine;
		unsigned short NumberOfSections;
		unsigned long TimeDateStamp;
		unsigned long PointerToSymbolTable;
		unsigned long NumberOfSymbols;
		unsigned short SizeOfOptionalHeader;
		unsigned short Characteristics;
	};

	struct image_export_directory {
		unsigned long Characteristics;
		unsigned long TimeDateStamp;
		unsigned short MajorVersion;
		unsigned short MinorVersion;
		unsigned long Name;
		unsigned long Base;
		unsigned long NumberOfFunctions;
		unsigned long NumberOfNames;
		unsigned long AddressOfFunctions;
		unsigned long AddressOfNames;
		unsigned long AddressOfNameOrdinals;
	};

	struct image_data_directory {
		unsigned long VirtualAddress;
		unsigned long Size;
	};

	struct image_optional_header {
		unsigned short Magic;
		unsigned char MajorLinkerVersion;
		unsigned char MinorLinkerVersion;
		unsigned long SizeOfCode;
		unsigned long SizeOfInitializedData;
		unsigned long SizeOfUninitializedData;
		unsigned long AddressOfEntryPoint;
		unsigned long BaseOfCode;
		unsigned long long ImageBase;
		unsigned long SectionAlignment;
		unsigned long FileAlignment;
		unsigned short MajorOperatingSystemVersion;
		unsigned short MinorOperatingSystemVersion;
		unsigned short MajorImageVersion;
		unsigned short MinorImageVersion;
		unsigned short MajorSubsystemVersion;
		unsigned short MinorSubsystemVersion;
		unsigned long Win32VersionValue;
		unsigned long SizeOfImage;
		unsigned long SizeOfHeaders;
		unsigned long CheckSum;
		unsigned short Subsystem;
		unsigned short DllCharacteristics;
		unsigned long long SizeOfStackReserve;
		unsigned long long SizeOfStackCommit;
		unsigned long long SizeOfHeapReserve;
		unsigned long long SizeOfHeapCommit;
		unsigned long LoaderFlags;
		unsigned long NumberOfRvaAndSizes;
		image_data_directory DataDirectory[16];
	};

	struct image_nt_headers {
		unsigned long Signature;
		image_file_header FileHeader;
		image_optional_header OptionalHeader;
	};
}

std::uintptr_t get_module(wchar_t* name) {
	const ntos::peb* peb = reinterpret_cast<ntos::peb*>(__readgsqword(0x60));
	if (!peb) return std::uintptr_t(0);

	const ntos::list_entry head = peb->Ldr->InMemoryOrderModuleList;

	for (auto curr = head; curr.Flink != &peb->Ldr->InMemoryOrderModuleList; curr = *curr.Flink) {
		ntos::ldr_data_table_entry* mod = reinterpret_cast<ntos::ldr_data_table_entry*>(contains_record(curr.Flink, ntos::ldr_data_table_entry, InMemoryOrderLinks));

		if (mod->BaseDllName.Buffer)
			if (string::wcsicmp_insensitive(mod->BaseDllName.Buffer, name))
				return std::uintptr_t(mod->DllBase);
	}

	return std::uintptr_t(0);
}



```

`hooking.h`:

```h
#pragma once


bool in_area(fvector2d target, fvector2d pos, fvector2d size)
{
	if (target.x > pos.x && target.y > pos.y)
		if (target.x < pos.x + size.x && target.y < pos.y + size.y)
			return true;

	return false;
}

namespace menu {
	fvector2d pos = { 25, 25 };

	static void run(ucanvas* canvas) {
		if (render::show_menu) {

			ZeroGUI::SetupCanvas(canvas);
			ZeroGUI::Input::Handle();

			float width = ((double)canvas->clip_x());
			float height = ((double)canvas->clip_y());
			if (ZeroGUI::Window("novopaste.shit", &pos, fvector2d{ 650.0f, 500.0f }, render::show_menu, width, height)) {
					ZeroGUI::Draw_Cursor(render::draw_cursor);

					const char* tabNames[] = { "Aim", "Bones", "Player", "Containers", "Pickups", "Weakspots", "Radar", "Exploits", "World", "Misc" };
					static int tab = 0;

					for (int i = 0; i < sizeof(tabNames) / sizeof(tabNames[0]); i++) {
						if (ZeroGUI::ButtonTab(tabNames[i], fvector2d{ 100, 25 }, tab == i)) {
							tab = i;
						}
					}

					if (tab == 0)
					{
						ZeroGUI::NextColumn(130.0f);
						ZeroGUI::Checkbox("Enable", &settings::aimbot::enable);

						ZeroGUI::Checkbox("Enable Mouse (safer)", &settings::aimbot::mouse);
						ZeroGUI::Checkbox("Enable Memory", &settings::aimbot::memory); // TO BE FIXED
						if (settings::aimbot::mouse)
						{

							ZeroGUI::SliderFloat("Mouse Smoothing", &settings::aimbot::mouse_speed, 1, 25);
						}
						if (settings::aimbot::memory)
						{
							if (settings::exploits::enable_hooks) {
								ZeroGUI::Checkbox("pSilent", &settings::aimbot::silent);
								ZeroGUI::Checkbox("Sticky Silent", &settings::aimbot::sticky_silent);
							}
							ZeroGUI::Checkbox("Interpolate", &settings::aimbot::interpolate);
							ZeroGUI::Checkbox("Constant", &settings::aimbot::constant);
							ZeroGUI::SliderFloat("Interp Speed", &settings::aimbot::interpolate_speed, 1, 25);
		
						}
						if (settings::aimbot::enable)
						{
							ZeroGUI::Checkbox("Visible Only", &settings::aimbot::visible_only);
							ZeroGUI::Checkbox("Target Line", &settings::aimbot::target_line);
							ZeroGUI::Checkbox("Show FOV", &settings::aimbot::show_fov);
							ZeroGUI::SliderFloat("FOV", &settings::aimbot::field_of_view, 1, 360);
						}
					}


					else if (tab == 1)
					{
						ZeroGUI::NextColumn(130.0f);
						ZeroGUI::Checkbox("Head", &settings::bones::head);
						ZeroGUI::Checkbox("Neck", &settings::bones::neck);
						ZeroGUI::Checkbox("Torso", &settings::bones::torso);
						ZeroGUI::Checkbox("Pelvis", &settings::bones::pelvis);
					}

					else if (tab == 2)
					{
						ZeroGUI::NextColumn(130.0f);
						ZeroGUI::Checkbox("Enable", &settings::player::enable);

						if (settings::player::enable)
						{
							ZeroGUI::Checkbox("Box", &settings::player::normal_box);
							ZeroGUI::Checkbox("Cornered Box", &settings::player::cornered_box);
							if (!settings::style::performance) {
							ZeroGUI::Checkbox("Skeleton", &settings::player::skeleton);
							}
							ZeroGUI::Checkbox("Distance", &settings::player::display_distance);
							ZeroGUI::Checkbox("Snapline", &settings::player::snapline);
							ZeroGUI::Checkbox("Current Weapon", &settings::player::active_weapon);
							ZeroGUI::Checkbox("Username", &settings::player::player_name);
							ZeroGUI::Checkbox("Eyes", &settings::player::eyes);
							ZeroGUI::SliderFloat("Render Distance", &settings::player::max_distance, 5, 900);


						}
					}




					else if (tab == 3)
					{
						ZeroGUI::NextColumn(130.0f);
						ZeroGUI::Checkbox("Enable", &settings::containers::enable);

						if (settings::containers::enable)
						{
							ZeroGUI::Checkbox("Ignore Opened", &settings::containers::ignore_opened);
							ZeroGUI::Checkbox("Display Distance", &settings::containers::display_distance);
							ZeroGUI::Checkbox("Lines", &settings::containers::lines);
							ZeroGUI::Checkbox("Chest", &settings::containers::chest);
							ZeroGUI::Checkbox("Ammo Box", &settings::containers::ammo_box);
							ZeroGUI::Checkbox("Coolers, Food", &settings::containers::cooler_and_food);
							ZeroGUI::Checkbox("Safe", &settings::containers::safe);
							ZeroGUI::Checkbox("Others", &settings::containers::others);
							ZeroGUI::SliderFloat("Render Distance", &settings::containers::max_distance, 5, 450);
							ZeroGUI::SliderFloat("Line Offset", &settings::containers::line_offset, 5, 450);

						}
					}




					else if (tab == 4)
					{
						ZeroGUI::NextColumn(130.0f);
						ZeroGUI::Checkbox("Enable", &settings::pickups::enable);

						if (settings::pickups::enable)
						{
							ZeroGUI::Checkbox("Display Distance", &settings::pickups::display_distance);
							ZeroGUI::Checkbox("Common", &settings::pickups::common);
							ZeroGUI::Checkbox("Uncommon", &settings::pickups::uncommon);
							ZeroGUI::Checkbox("Rare", &settings::pickups::rare);
							ZeroGUI::Checkbox("Epic", &settings::pickups::epic);
							ZeroGUI::Checkbox("Legendary", &settings::pickups::legendary);
							ZeroGUI::Checkbox("Mythic", &settings::pickups::mythic);
							ZeroGUI::SliderFloat("Render Distance", &settings::pickups::max_distance, 5, 450);
							ZeroGUI::SliderFloat("Line Offset", &settings::pickups::line_offset, 5, 450);

						}
					}



					else if (tab == 5)
					{
						ZeroGUI::NextColumn(130.0f);
						ZeroGUI::Checkbox("Enable", &settings::weakspot::enable);

						if (settings::weakspot::enable)
						{
							ZeroGUI::Checkbox("Weakspot Aimbot", &settings::weakspot::weakspot_aimbot);
							if (settings::exploits::enable_hooks) {
								ZeroGUI::Checkbox("pSilent", &settings::weakspot::silent);
							}
							ZeroGUI::Checkbox("Interpolate", &settings::weakspot::interpolate);
							ZeroGUI::Checkbox("Constant", &settings::weakspot::constant);
							ZeroGUI::Checkbox("Target Line", &settings::weakspot::target_line);
							ZeroGUI::SliderFloat("Speed", &settings::weakspot::interpolate_speed, 1, 25);

						}
					}



					else if (tab == 6)
					{
						ZeroGUI::NextColumn(130.0f);
						ZeroGUI::Checkbox("Enable", &settings::radar::enable);

						if (settings::radar::enable)
						{
							ZeroGUI::Checkbox("Show Line Of Sight", &settings::radar::show_line_of_sight);
							ZeroGUI::Checkbox("Circle", &settings::radar::useless_circle);
							ZeroGUI::Checkbox("Players", &settings::radar::players);
							ZeroGUI::Checkbox("Containers", &settings::radar::containers);
							ZeroGUI::Checkbox("Pickups", &settings::radar::pickups);
							ZeroGUI::Checkbox("Vehicles", &settings::radar::vehicles);
							ZeroGUI::SliderFloat("Range Distance", &settings::radar::range, 5, 450);
							ZeroGUI::SliderFloat("Position X", &settings::radar::positionx, 0, 500);
							ZeroGUI::SliderFloat("Position Y", &settings::radar::positiony, 0, 500);
							ZeroGUI::SliderFloat("Size", &settings::radar::size, 0, 300);

						}
					}




					else if (tab == 7)
					{
						ZeroGUI::NextColumn(130.0f);
						ZeroGUI::Checkbox("Enable Hooks", &settings::exploits::enable_hooks);
						if (settings::exploits::enable_hooks) {
							ZeroGUI::Checkbox("Fov Changer", &settings::exploits::fov_changer);
							ZeroGUI::SliderFloat("Fov Value", &settings::exploits::fov_value, 0, 180);
						}
						
						ZeroGUI::Checkbox("Bullet TP", &settings::aimbot::bulletp);
					    ZeroGUI::Checkbox("Fov Changer", &settings::miscellaneous::fovchanger);
						ZeroGUI::SliderFloat("Fov Value", &settings::miscellaneous::fovslider, 0, 180);
						ZeroGUI::Checkbox("Vehicle Fly [W]", &settings::miscellaneous::vehiclefly);
						ZeroGUI::SliderFloat("Vehicle Flight Speed", &settings::miscellaneous::vehicle_flight_speed, 0, 600);
					}


					else if (tab == 8)
					{
						ZeroGUI::NextColumn(130.0f);
						ZeroGUI::Checkbox("Enable", &settings::miscactors::enable);

						if (settings::miscactors::enable)
						{

							ZeroGUI::Checkbox("Display Distance", &settings::miscactors::display_distance);
							ZeroGUI::Checkbox("Vehicles", &settings::miscactors::vehicles);
							ZeroGUI::Checkbox("Rifts", &settings::miscactors::rifts);
							ZeroGUI::Checkbox("Flags", &settings::miscactors::flags);
							ZeroGUI::Checkbox("Traps", &settings::miscactors::traps);
							ZeroGUI::SliderFloat("Render Distance", &settings::miscactors::max_distance, 0, 450);
						}

					}

					else if (tab == 9)
					{
						ZeroGUI::NextColumn(130.0f);
						ZeroGUI::Checkbox("Outlined Text", &settings::style::text_outlined);
						ZeroGUI::Checkbox("Outlined Lines", &render::outline);
						if (render::outline) {
							ZeroGUI::SliderFloat("Outlined Thickness", &render::outlinethickness, 0, 10);
						}
						ZeroGUI::SliderFloat("Line Thickness", &render::linethickness, 0, 10);
						ZeroGUI::Checkbox("Draw Cursor", &render::draw_cursor);
						ZeroGUI::Checkbox("Performance mode", &settings::style::performance);
					}
				}
		}
	}
}



#define M_PI   3.14159265358979323846264338327950288

float degree_to_radian(float degree) {
	return degree * (M_PI / 180);
}

void angle_rotation(const frotator& angles, fvector* forward)
{
	float	sp, sy, cp, cy;

	sy = sin(degree_to_radian(angles.yaw));
	cy = cos(degree_to_radian(angles.yaw));

	sp = sin(degree_to_radian(angles.pitch));
	cp = cos(degree_to_radian(angles.pitch));

	forward->x = cp * cy;
	forward->y = cp * sy;
	forward->z = -sp;
}

namespace fortnite {
	namespace temp {
		bool silent_active = false;
		frotator silent_rotation = frotator();
		bool sticky_silent_active = false;
		frotator sticky_silent_rotation = frotator();
	}
	bool visible;
	namespace radar {
		fvector2d position, size;
		fvector camera_location;
		frotator camera_rotation;

		void range(double* x, double* y, double range) {
			if (defines::math->abs((*x)) > range || defines::math->abs((*y)) > range) {
				if ((*y) > (*x)) {
					if ((*y) > -(*x)) {
						(*x) = range * (*x) / (*y);
						(*y) = range;
					}
					else {
						(*y) = -range * (*y) / (*x);
						(*x) = -range;
					}
				}
				else {
					if ((*y) > -(*x)) {
						(*y) = range * (*y) / (*x);
						(*x) = range;
					}
					else {
						(*x) = -range * (*x) / (*y);
						(*y) = -range;
					}
				}
			}
		}

		void rotate_point(fvector2d* screen, fvector origin, fvector camera_location, frotator camera_rotation) {
			auto yaw = camera_rotation.yaw * 3.1415927 / 180;

			double dx = origin.x - camera_location.x;
			double dy = origin.y - camera_location.y;

			double fsin_yaw = defines::math->sin(yaw);
			double fminus_cos_yaw = -defines::math->cos(yaw);

			double x = -(dy * fminus_cos_yaw + dx * fsin_yaw);
			double y = dx * fminus_cos_yaw - dy * fsin_yaw;

			double range_value = settings::radar::range * 1000;
			range(&x, &y, range_value);

			auto DrawPos = radar::position;
			auto DrawSize = radar::size;

			int rad_x = (int)DrawPos.x;
			int rad_y = (int)DrawPos.y;

			double r_siz_x = DrawSize.x;
			double r_siz_y = DrawSize.y;

			int x_max = (int)r_siz_x + rad_x - 5;
			int y_max = (int)r_siz_y + rad_y - 5;

			double out_screen_x = rad_x + ((int)r_siz_x / 2 + int(x / range_value * r_siz_x));
			double out_screen_y = rad_y + ((int)r_siz_y / 2 + int(y / range_value * r_siz_y));

			if (out_screen_x > x_max)
				out_screen_x = x_max;

			if (out_screen_x < rad_x)
				out_screen_x = rad_x;

			if (out_screen_y > y_max)
				out_screen_y = y_max;

			if (out_screen_y < rad_y)
				out_screen_y = rad_y;

			*screen = fvector2d(out_screen_x, out_screen_y);
		}

		void add_to_radar(fvector world_location, flinearcolor color) {
			fvector2d screen;
			rotate_point(&screen, world_location, radar::camera_location, radar::camera_rotation);

			render::filled_box(screen, fvector2d(4, 4), color);
		}

		void radar_initialize(fvector2d position, fvector2d size, fvector camera_location, frotator camera_rotation) {
			radar::position = position;
			radar::size = size;
			radar::camera_location = camera_location;
			radar::camera_rotation = camera_rotation;

			render::filled_box(position, size, flinearcolor(0.025f, 0.025f, 0.025f, 1.f));

			if (settings::radar::useless_circle) {
				render::circle(fvector2d(position.x + size.x / 2, position.y + size.y / 2), size.x / 2, 100, flinearcolor(1.f, 1.f, 1.f, 1.f));
			}

			if (settings::radar::show_line_of_sight) {
				render::line(fvector2d(position.x + size.x / 2, position.y + size.y), fvector2d(position.x + size.x / 2, position.y + size.y / 2), flinearcolor(1.f, 1.f, 1.f, 1.f), 1.f);
				render::line(fvector2d(position.x + size.x / 2, position.y + size.y / 2), fvector2d(position.x, position.y), flinearcolor(1.f, 1.f, 1.f, 1.f), 1.f);
				render::line(fvector2d(position.x + size.x / 2, position.y + size.y / 2), fvector2d(position.x + size.x, position.y), flinearcolor(1.f, 1.f, 1.f, 1.f), 1.f);
			}
		}
	}

	void set_aim_mouse(aplayercontroller* controller,fvector aim_location,float width, float height, float smooth) {
		float ScreenCenterX = (width / 2);
		float ScreenCenterY = (height / 2);
		float TargetX = 0;
		float TargetY = 0;
		auto aim_screen = fvector2d();
		if (controller->w2s(aim_location, &aim_screen) && aim_screen) {
			if (aim_screen.x != 0)
			{
				if (aim_screen.x > ScreenCenterX)
				{
					TargetX = -(ScreenCenterX - aim_screen.x);
					TargetX /= smooth;
					if (TargetX + ScreenCenterX > ScreenCenterX * 2) TargetX = -0;
				}

				if (aim_screen.x < ScreenCenterX)
				{
					TargetX = aim_screen.x - ScreenCenterX;
					TargetX /= smooth;
					if (TargetX + ScreenCenterX < 0) TargetX = -0;
				}
			}

			if (aim_screen.y != 0)
			{
				if (aim_screen.y > ScreenCenterY)
				{
					TargetY = -(ScreenCenterY - aim_screen.y);
					TargetY /= smooth;
					if (TargetY + ScreenCenterY > ScreenCenterY * 2) TargetY = -0;
				}

				if (aim_screen.y < ScreenCenterY)
				{
					TargetY = aim_screen.y - ScreenCenterY;
					TargetY /= smooth;
					if (TargetY + ScreenCenterY < 0) TargetY = -0;
				}
			}

			IFH(mouse_event)(MOUSEEVENTF_MOVE, static_cast<DWORD>(TargetX), static_cast<DWORD>(TargetY), NULL, NULL);
		}
		
	}

	void set_aim(uworld* world, aplayercontroller* controller, fvector camera_location, frotator camera_rotation, fvector aim_location, bool interpolate, bool constant, double speed) {
		auto aim_rotation = defines::math->find_look_at_rotation(camera_location, aim_location);
		auto world_delta_seconds = defines::game_statics->get_world_delta_seconds(world);

		auto result = aim_rotation;
		if (interpolate) {
			if (constant)
				result = defines::math->interp_to_constant(camera_rotation, aim_rotation, world_delta_seconds, speed);
			else
				result = defines::math->interp_to(camera_rotation, aim_rotation, world_delta_seconds, speed);
		}

		result.pitch = (result.pitch - camera_rotation.pitch) / controller->input_pitch_scale();
		result.yaw = (result.yaw - camera_rotation.yaw) / controller->input_yaw_scale();

		controller->add_pitch_input((float)result.pitch);
		controller->add_yaw_input((float)result.yaw);
	}

	fvector bottom, bottom_2, head, head_2, neck, chest, pelvis, rshoulder, relbow, rhand, rthigh, rknee, rfoot, rfootout, lshoulder, lelbow, lhand, lthigh, lknee, lfoot, lfootout;
	fvector2d s_bottom, s_bottom_2, s_head, s_head_2, s_neck, s_chest, s_pelvis, s_rshoulder, s_relbow, s_rhand, s_rthigh, s_rknee, s_rfoot, s_rfootout, s_lshoulder, s_lelbow, s_lhand, s_lthigh, s_lknee, s_lfoot, s_lfootout;

	bool get_performance_bones(aplayercontroller* controller, mesh* mesh) {
		bool success = true;

		bottom = mesh->get_bone_location(0);
		if (success && !controller->w2s(bottom, &s_bottom)) success = false;

	
		head = mesh->get_bone_location(68);
		if (success && !controller->w2s(head, &s_head)) success = false;

		if (!s_bottom || !s_head) 
			return false;


		return success;
	}

	bool get_all_bones(aplayercontroller* controller, mesh* mesh) {
		bool success = true;

		bottom = mesh->get_bone_location(0);
		if (success && !controller->w2s(bottom, &s_bottom)) success = false;

		bottom_2 = bottom; bottom_2.z -= 10;
		if (success && !controller->w2s(bottom_2, &s_bottom_2)) success = false;

		head = mesh->get_bone_location(68);
		if (success && !controller->w2s(head, &s_head)) success = false;

		head_2 = head; head_2.z += 13;
		if (success && !controller->w2s(head_2, &s_head_2)) success = false;

		neck = mesh->get_bone_location(67);
		if (success && !controller->w2s(neck, &s_neck)) success = false;

		chest = mesh->get_bone_location(7); chest.z += 7;
		if (success && !controller->w2s(chest, &s_chest)) success = false;

		pelvis = mesh->get_bone_location(2);
		if (success && !controller->w2s(pelvis, &s_pelvis)) success = false;

		rshoulder = mesh->get_bone_location(38);
		if (success && !controller->w2s(rshoulder, &s_rshoulder)) success = false;

		relbow = mesh->get_bone_location(39);
		if (success && !controller->w2s(relbow, &s_relbow)) success = false;

		rhand = mesh->get_bone_location(40);
		if (success && !controller->w2s(rhand, &s_rhand)) success = false;

		rthigh = mesh->get_bone_location(78);
		if (success && !controller->w2s(rthigh, &s_rthigh)) success = false;

		rknee = mesh->get_bone_location(79);
		if (success && !controller->w2s(rknee, &s_rknee)) success = false;

		rfoot = mesh->get_bone_location(82);
		if (success && !controller->w2s(rfoot, &s_rfoot)) success = false;

		rfootout = mesh->get_bone_location(83);
		if (success && !controller->w2s(rfootout, &s_rfootout)) success = false;

		lshoulder = mesh->get_bone_location(9);
		if (success && !controller->w2s(lshoulder, &s_lshoulder)) success = false;

		lelbow = mesh->get_bone_location(10);
		if (success && !controller->w2s(lelbow, &s_lelbow)) success = false;

		lhand = mesh->get_bone_location(11);
		if (success && !controller->w2s(lhand, &s_lhand)) success = false;

		lthigh = mesh->get_bone_location(71);
		if (success && !controller->w2s(lthigh, &s_lthigh)) success = false;

		lknee = mesh->get_bone_location(72);
		if (success && !controller->w2s(lknee, &s_lknee)) success = false;

		lfoot = mesh->get_bone_location(75);
		if (success && !controller->w2s(lfoot, &s_lfoot)) success = false;

		lfootout = mesh->get_bone_location(76);
		if (success && !controller->w2s(lfootout, &s_lfootout)) success = false;

		if (!s_bottom || !s_head || !s_neck || !s_chest || !s_rshoulder || !s_relbow || !s_rhand || !s_lshoulder || !s_lelbow || !s_lhand || !s_rthigh || !s_rknee || !s_rfoot || !s_rfootout || !s_lthigh || !s_lknee || !s_lfoot || !s_lfootout)
			return false;

		return success;
	}
}

namespace essential_hooks {
	fvector location_o = fvector();
	frotator rotation_o = frotator();

	ulocalplayer* local_player_old = 0;
	aplayercontroller* player_controller_old = 0;

	using get_view_point_sim = void(*)(ulocalplayer* local_player, fminimalviewinfo* out_viewinfo, BYTE stereo_pass);
	get_view_point_sim get_view_point_o = 0;

	void get_view_point(ulocalplayer* local_player, fminimalviewinfo* out_viewinfo, BYTE stereo_pass) {
		get_view_point_o(local_player, out_viewinfo, stereo_pass);

		if (fortnite::temp::silent_active) {
			out_viewinfo->location = location_o;
			out_viewinfo->rotation = rotation_o;
		}

		if (fortnite::temp::sticky_silent_active) {
			out_viewinfo->location = location_o;
			out_viewinfo->location.z += 40;
			out_viewinfo->rotation = fortnite::temp::sticky_silent_rotation;
		}

		if (settings::exploits::fov_changer)
			out_viewinfo->fov = settings::exploits::fov_value;
	}

	using get_player_view_point_sim = void(*)(aplayercontroller* controller, fvector* location, frotator* rotation);
	get_player_view_point_sim get_player_view_point_o = 0;

	void get_player_view_point(aplayercontroller* controller, fvector* location, frotator* rotation) {
		get_player_view_point_o(controller, location, rotation);

		location_o = *location;
		rotation_o = *rotation;

		if (fortnite::temp::silent_active) {
			*rotation = fortnite::temp::silent_rotation;
		}

		if (fortnite::temp::sticky_silent_active) {
			*rotation = fortnite::temp::sticky_silent_rotation;
		}
	}

	void run(aplayercontroller* controller, ulocalplayer* local_player) {
		if (local_player != essential_hooks::local_player_old) {
			//essential_hooks::get_view_point_o = vmt<decltype(essential_hooks::get_view_point_o)>(std::uintptr_t(local_player), std::uintptr_t(essential_hooks::get_view_point), 0x58);
			void** LocalPlayer_VTable = *(void***)(local_player);
			DWORD OldProtection;
			(VirtualProtect)(&LocalPlayer_VTable[88], 8, PAGE_EXECUTE_READWRITE, &OldProtection);
			essential_hooks::get_view_point_o = decltype(essential_hooks::get_view_point_o)(LocalPlayer_VTable[88]);
			LocalPlayer_VTable[88] = &essential_hooks::get_view_point;
			(VirtualProtect)(&LocalPlayer_VTable[88], 8, OldProtection, &OldProtection);

			essential_hooks::local_player_old = local_player;
		}

		if (controller != essential_hooks::player_controller_old) {
			//essential_hooks::get_player_view_point_o = vmt<decltype(essential_hooks::get_player_view_point_o)>(std::uintptr_t(controller), std::uintptr_t(essential_hooks::get_player_view_point), 0x7E8);
			void** PlayerController_VTable = *(void***)(controller);
			DWORD OldProtection;
			(VirtualProtect)(&PlayerController_VTable[245], 8, PAGE_EXECUTE_READWRITE, &OldProtection);
			essential_hooks::get_player_view_point_o = decltype(essential_hooks::get_player_view_point_o)(PlayerController_VTable[245]);
			PlayerController_VTable[245] = &essential_hooks::get_player_view_point;
			(VirtualProtect)(&PlayerController_VTable[245], 8, OldProtection, &OldProtection);
			essential_hooks::player_controller_old = controller;
		}
	}
}



void novacane_main(ugameviewportclient* viewport, ucanvas* canvas) {
	auto screen_size = fvector2d((double)canvas->clip_x(), (double)canvas->clip_y());
	auto center = fvector2d((double)screen_size.x / 2, (double)screen_size.y / 2);
	bool player_silent = false;

	auto world = viewport->get_world();
	if (!world) return;

	auto game_instance = defines::game_statics->get_game_instance(world);
	if (!game_instance) return;

	auto local_player = game_instance->get_local_players()[0];
	if (!game_instance) return;

	auto controller = defines::game_statics->get_player_controller(world, std::int32_t(0));
	if (!controller) return;

	auto camera_manager = defines::game_statics->get_player_camera_manager(world, std::int32_t(0));
	if (!camera_manager) return;

	if (settings::exploits::enable_hooks) {
		essential_hooks::run(controller, local_player);
	}

	render::world = world;
	render::canvas = canvas;
	render::controller = controller;
	render::screen_center = center;
	render::screen_size = screen_size;


	if (render::is_insert_clicked()) render::show_menu = !render::show_menu;
	menu::run(canvas);

	render::text(L"novopaste.shit", fvector2d(75, 15), flinearcolor(1.f, 1.f, 1.f, 1.f), true, true, true);


	auto camera_location = camera_manager->get_camera_location();
	auto camera_rotation = camera_manager->get_camera_rotation();
	auto camera_fov = camera_manager->get_fov_angle();


	auto radius = (settings::aimbot::field_of_view * center.x / (double)camera_fov) / 2; 

	auto local_pawn_holding_pickaxe = false;
	auto local_pawn = controller->get_pawn();
	auto local_team = (char)6969;

	if (settings::miscellaneous::fovchanger) {
		if (local_pawn) {
			controller->fov(settings::miscellaneous::fovslider);
		}
	}

	if (settings::radar::enable) {
		fortnite::radar::radar_initialize(fvector2d(settings::radar::positionx, settings::radar::positiony), fvector2d(settings::radar::size, settings::radar::size), camera_location, camera_rotation);
	}

	if (settings::miscellaneous::vehiclefly) {
		auto current_vehicle = *(afortvehicle**)(local_pawn + 0x2578);
		if (current_vehicle && local_pawn) {
			auto current_location = current_vehicle->get_actor_location();
			auto current_rotation = camera_rotation;
			if (controller->is_key_down(defines::W)) {
			current_location.x = current_location.x + settings::miscellaneous::vehicle_flight_speed;
			current_vehicle->k2_teleport_to(current_location, current_rotation);
			}
			if (controller->is_key_down(defines::A)) {
				current_location.y = current_location.y + settings::miscellaneous::vehicle_flight_speed;
				current_vehicle->k2_teleport_to(current_location, current_rotation);
			}
			if (controller->is_key_down(defines::S)) {
				current_location.x = current_location.x - settings::miscellaneous::vehicle_flight_speed;
				current_vehicle->k2_teleport_to(current_location, current_rotation);
			}
			if (controller->is_key_down(defines::D)) {
				current_location.y = current_location.y - settings::miscellaneous::vehicle_flight_speed;
				current_vehicle->k2_teleport_to(current_location, current_rotation);
			}
			if (controller->is_key_down(defines::space)) {
				current_location.z = current_location.z + settings::miscellaneous::vehicle_flight_speed;
				current_vehicle->k2_teleport_to(current_location, current_rotation);
			}
		}
	}


	if (settings::player::enable) {
		double closest_distance = DBL_MAX;
		player_pawn* target_player = 0;

		tarray<uobject*> player_array = defines::game_statics->get_all_actors_of_class(world, defines::actor_player_class);
		for (int i = 0; i < player_array.size(); i++) {
			if (!player_array.valid(i)) continue;

			auto player = (player_pawn*)player_array[i];
			if (player == local_pawn) continue;
			if (!player) continue;

			if (player->is_dead()) continue;

			auto object_name = defines::system->get_object_name(player);
	
			if (!defines::string->contains(object_name.c_str(), L"PlayerPawn", false, false)) continue;

			bool teammate = player->get_team() == local_team;

			auto esp_color = flinearcolor(1.f, 1.f, 1.f, 1.f);
			auto black_color = flinearcolor(0.f, 0.f, 0.f, 1.f);
			if (teammate)
				esp_color = flinearcolor(0.4f, 0.7f, 0.5f, 1.f);

			auto world_location = player->get_actor_location();
			
			if (settings::radar::enable && settings::radar::players) {
				fortnite::radar::add_to_radar(world_location, esp_color);
			}

			auto max_distance = settings::player::max_distance;
			double distance = defines::math->vector_distance(world_location, camera_location) * 0.01;
		    if (distance > max_distance) continue;

			bool visible = player->was_recently_rendered(0.f);
			if (visible) {
				fortnite::visible = true;
				esp_color = flinearcolor(0.5f, 1.f, 0.5f, 1.f);
			}
			else {
				fortnite::visible = false;
				esp_color = flinearcolor(1.0f, 0.5f, 0.5f, 1.f);
			}


			auto mesh = player->get_pawn_mesh();
			if (!mesh) continue;

			if (!settings::style::performance) {
				if (!fortnite::get_all_bones(controller, mesh)) continue;
			}
			else {
				if (!fortnite::get_performance_bones(controller, mesh)) continue;
			}
			if (settings::style::performance) {
			if (!in_area(fortnite::s_bottom, fvector2d(50, 50), fvector2d(screen_size.x - (50 * 2), screen_size.y - (50 * 2)))) continue;
			}

			if (settings::player::skeleton) {
				render::line_with_outline(fortnite::s_head, fortnite::s_neck, esp_color, 1.f);
				render::line_with_outline(fortnite::s_neck, fortnite::s_chest, esp_color, 1.f);
				render::line_with_outline(fortnite::s_chest, fortnite::s_pelvis, esp_color, 1.f);

				render::line_with_outline(fortnite::s_chest, fortnite::s_rshoulder, esp_color, 1.f);
				render::line_with_outline(fortnite::s_rshoulder, fortnite::s_relbow, esp_color, 1.f);
				render::line_with_outline(fortnite::s_relbow, fortnite::s_rhand, esp_color, 1.f);
				render::line_with_outline(fortnite::s_pelvis, fortnite::s_rthigh, esp_color, 1.f);
				render::line_with_outline(fortnite::s_rthigh, fortnite::s_rknee, esp_color, 1.f);
				render::line_with_outline(fortnite::s_rknee, fortnite::s_rfoot, esp_color, 1.f);
				render::line_with_outline(fortnite::s_rfoot, fortnite::s_rfootout, esp_color, 1.f);

				render::line_with_outline(fortnite::s_chest, fortnite::s_lshoulder, esp_color, 1.f);
				render::line_with_outline(fortnite::s_lshoulder, fortnite::s_lelbow, esp_color, 1.f);
				render::line_with_outline(fortnite::s_lelbow, fortnite::s_lhand, esp_color, 1.f);
				render::line_with_outline(fortnite::s_pelvis, fortnite::s_lthigh, esp_color, 1.f);
				render::line_with_outline(fortnite::s_lthigh, fortnite::s_lknee, esp_color, 1.f);
				render::line_with_outline(fortnite::s_lknee, fortnite::s_lfoot, esp_color, 1.f);
				render::line_with_outline(fortnite::s_lfoot, fortnite::s_lfootout, esp_color, 1.f);
			}
			auto most_left = DBL_MAX;
			auto most_right = DBL_MIN;
			auto most_top = DBL_MAX;
			auto most_bottom = DBL_MIN;


			if (!settings::style::performance) {
				fvector2d bones_to_check[] = { fortnite::s_bottom, fortnite::s_head, fortnite::s_head_2, fortnite::s_neck, fortnite::s_chest, fortnite::s_pelvis, fortnite::s_rshoulder, fortnite::s_relbow, fortnite::s_rhand, fortnite::s_rthigh, fortnite::s_rknee, fortnite::s_rfoot, fortnite::s_rfootout, fortnite::s_lshoulder, fortnite::s_lelbow,fortnite::s_lhand, fortnite::s_lthigh, fortnite::s_lknee, fortnite::s_lfoot, fortnite::s_lfootout };

				for (int i = 0; i < 20; i++) {
					auto bone = bones_to_check[i];

					if (bone.x < most_left)
						most_left = bone.x;

					if (bone.x > most_right)
						most_right = bone.x;

					if (bone.y < most_top)
						most_top = bone.y;

					if (bone.y > most_bottom)
						most_bottom = bone.y;
				}
			}
			else {
				fvector2d bones_to_check[] = { fortnite::s_bottom, fortnite::s_head };

				for (int i = 0; i < 2; i++) {
					auto bone = bones_to_check[i];

					if (bone.x < most_left)
						most_left = bone.x;

					if (bone.x > most_right)
						most_right = bone.x;

					if (bone.y < most_top)
						most_top = bone.y;

					if (bone.y > most_bottom)
						most_bottom = bone.y;
				}
			}
			auto actor_height = most_bottom - most_top;
			auto actor_width = most_right - most_left;

			auto calculated_distance = max_distance - distance;
			auto offset = calculated_distance * 0.035;
			auto corner_wide = actor_width / 3;
			auto corner_heit = actor_height / 3;

			auto text_offset = double(0);
			fvector2d bottom_middle;
			if (!settings::style::performance) {
				bottom_middle = fvector2d(most_left + actor_width / 2, fortnite::s_bottom_2.y);
			}
			else {
				bottom_middle = fvector2d(most_left + actor_width / 2, fortnite::s_bottom.y);
			}

			if (settings::player::cornered_box) {
				//top left
				render::line_with_outline(fvector2d(most_left - offset, most_top - offset), fvector2d(most_left - offset + corner_wide, most_top - offset), esp_color, 1.f);
				render::line_with_outline(fvector2d(most_left - offset, most_top - offset), fvector2d(most_left - offset, most_top - offset + corner_heit), esp_color, 1.f);

				//top right
				render::line_with_outline(fvector2d(most_right + offset, most_top - offset), fvector2d(most_right + offset - corner_wide, most_top - offset), esp_color, 1.f);
				render::line_with_outline(fvector2d(most_right + offset, most_top - offset), fvector2d(most_right + offset, most_top - offset + corner_heit), esp_color, 1.f);

				//bottom left
				render::line_with_outline(fvector2d(most_left - offset, most_bottom + offset), fvector2d(most_left - offset + corner_wide, most_bottom + offset), esp_color, 1.f);
				render::line_with_outline(fvector2d(most_left - offset, most_bottom + offset), fvector2d(most_left - offset, most_bottom + offset - corner_heit), esp_color, 1.f);

				//bottom right
				render::line_with_outline(fvector2d(most_right + offset, most_bottom + offset), fvector2d(most_right + offset - corner_wide, most_bottom + offset), esp_color, 1.f);
				render::line_with_outline(fvector2d(most_right + offset, most_bottom + offset), fvector2d(most_right + offset, most_bottom + offset - corner_heit), esp_color, 1.f);

				// Outline on the other side

			}
				if (settings::player::normal_box) {
					render::line_with_outline(fvector2d(most_left - offset, most_top - offset), fvector2d(most_left - offset, most_bottom + offset), esp_color, 1.f);
				

					// right line
					render::line_with_outline(fvector2d(most_right + offset, most_top - offset), fvector2d(most_right + offset, most_bottom + offset), esp_color, 1.f);

					// top line
					render::line_with_outline(fvector2d(most_left - offset, most_top - offset), fvector2d(most_right + offset, most_top - offset), esp_color, 1.f);

					// bottom line
					render::line_with_outline(fvector2d(most_left - offset, most_bottom + offset), fvector2d(most_right + offset, most_bottom + offset), esp_color, 1.f);
				}

			if (settings::player::player_name) {
				if (player) {
				auto playername = defines::lib->get_player_name_safe(player, defines::actor_player_nameprivate);
			    render::text(playername.c_str(), fvector2d(bottom_middle.x, bottom_middle.y + text_offset), flinearcolor(1.f, 1.f, 0.f, 1.f), true, false, settings::style::text_outlined);
			    text_offset += 15;
				}
			}

			if (settings::player::display_distance) {
				auto final = defines::string->build_string_double(L"", L"[", defines::math->round(distance), L"m]");
				render::text(final.c_str(), fvector2d(bottom_middle.x, bottom_middle.y + text_offset), flinearcolor(1.f, 1.f, 1.f, 1.f), true, false, settings::style::text_outlined);
				text_offset += 15;
			}

			if (settings::player::active_weapon) {
				if (auto current_weapon = player->get_current_weapon()) {
					if (auto weapon_data = current_weapon->get_weapon_data()) {
						auto display_name = weapon_data->display_name();
						if (display_name.data && display_name.c_str()) {
							auto tier = weapon_data->get_tier();

							auto render_color = flinearcolor();
							if (tier == fort_item_tier::I) render_color = flinearcolor(0.4f, 0.4f, 0.4f, 1.f);
							else if (tier == fort_item_tier::II) render_color = flinearcolor(0.2f, 0.8f, 0.4f, 1.f);
							else if (tier == fort_item_tier::III) render_color = flinearcolor(0.f, 0.4f, 0.8f, 1.f);
							else if (tier == fort_item_tier::IV) render_color = flinearcolor(1.f, 0.f, 1.f, 1.f);
							else if (tier == fort_item_tier::V) render_color = flinearcolor(0.7f, 0.7f, 0.f, 1.f);
							else if (tier == fort_item_tier::VI) render_color = flinearcolor(1.f, 1.f, 0.f, 1.f);

							if (render_color) {
								auto a = defines::string->build_string_int(display_name.c_str(), L" [", current_weapon->get_magazine_ammo_count(), L"");
								auto b = defines::string->build_string_int(L"", L"/", current_weapon->get_bullets_per_clip(), L"]");
								auto c = defines::string->concat_str_str(a, b);
								render::text(c.c_str(), fvector2d(bottom_middle.x, bottom_middle.y + text_offset), render_color, true, false, settings::style::text_outlined);
								text_offset += 15;
							}
						}
					}
				}
			}

			if (settings::player::snapline) {
				render::line_with_outline(fvector2d(center.x, screen_size.y - 15), fvector2d(bottom_middle.x, bottom_middle.y + text_offset), esp_color, 1.f);
			}

			if (settings::player::eyes)
			{
				frotator _Angle = player->get_actor_rotation();

				fvector test2, headpos;

				headpos = fortnite::head;

				angle_rotation(_Angle, &test2);
				test2.x *= 50;
				test2.y *= 50;
				test2.z *= 50;

				fvector end = headpos + test2;
				fvector2d test1, test3;

				if (controller->w2s(headpos, &test1))
				{
					if (controller->w2s(end, &test3))
					{
						render::line_with_outline(fvector2d(test1.x, test1.y), fvector2d(test3.x, test3.y), { 1.0f, 0.0f, 0.0f, 1.0f }, 1.f);
					}
				}
			}

			if (!teammate && !local_pawn_holding_pickaxe && ((settings::aimbot::visible_only && visible) || (!settings::aimbot::visible_only)) && local_pawn && render::in_circle(center.x, center.y, radius, fortnite::s_head.x, fortnite::s_head.y)) {
				double distance = defines::math->distance2d(fortnite::s_head, center);
				if (distance < closest_distance) {
					target_player = player;
					closest_distance = distance;
				}
			}
		}

		if (settings::aimbot::enable) {
			auto temp_silent_active = false;
			auto temp_silent_rotation = frotator();

			auto temp_sticky_silent_active = false;
			auto temp_sticky_silent_rotation = frotator();

			if (settings::aimbot::show_fov) {
				render::circle(center, radius, 100, flinearcolor(0.9f, 0.9f, 0.9f, 1.f));
			}



			if (target_player && local_pawn) {
				if (auto mesh = target_player->get_pawn_mesh()) {

					int32_t bone = 68;

					if (settings::bones::head)
						bone = 68;
					else if (settings::bones::neck)
						bone = 67;
					else if (settings::bones::torso)
						bone = 7;
					else if (settings::bones::pelvis)
						bone = 2;


					auto aim_location = mesh->get_bone_location(bone);
					auto esp_color = flinearcolor(1.f, 1.f, 1.f, 1.f);
					auto visible = target_player->was_recently_rendered(0.f);
					if (visible) {
						esp_color = flinearcolor(0.5f, 1.f, 0.5f, 1.f);
					}
					else {
						esp_color = flinearcolor(1.0f, 0.5f, 0.5f, 1.f);
					}

					if (settings::aimbot::target_line) {
						auto aim_screen = fvector2d();
						if (controller->w2s(aim_location, &aim_screen) && aim_screen) {
							render::line_with_outline(center, aim_screen, esp_color, 1.f);
						}
					}

					if (settings::aimbot::bulletp)
					{
						tarray<uobject*> projectile_array = defines::game_statics->get_all_actors_of_class(world, defines::actor_projectile_class);
						for (int i = 0; i < projectile_array.size(); i++) {
							if (!projectile_array.valid(i)) continue;

							auto projectile = (actor*)projectile_array[i];
							if (!projectile) continue;

							auto object_name = defines::system->get_object_name(projectile);

							if (!defines::string->contains(object_name.c_str(), L"Bullet", false, false))
								continue;

							projectile->set_actor_location(aim_location, false, 0, false);
						}
					}


					if (controller->is_key_down(defines::right_mouse_button)) {
						if (settings::aimbot::silent) {
							player_silent = true;
							temp_silent_active = true;
							temp_silent_rotation = defines::math->find_look_at_rotation(camera_location, aim_location);
						}
						else if (settings::aimbot::sticky_silent) {
							temp_sticky_silent_active = true;
							temp_sticky_silent_rotation = defines::math->find_look_at_rotation(camera_location, aim_location);
						}
						else if (settings::aimbot::memory) {
							fortnite::set_aim(world, controller, camera_location, camera_rotation, aim_location, settings::aimbot::interpolate, settings::aimbot::constant, settings::aimbot::interpolate_speed);
						}
						else if (settings::aimbot::mouse) {
							float width = ((double)canvas->clip_x());
							float height = ((double)canvas->clip_y());

						    fortnite::set_aim_mouse(controller, aim_location, width, height, settings::aimbot::mouse_speed);
						}
					}
				}
			}

			fortnite::temp::silent_active = temp_silent_active;
			fortnite::temp::silent_rotation = temp_silent_rotation;

			fortnite::temp::sticky_silent_active = temp_sticky_silent_active;
			fortnite::temp::sticky_silent_rotation = temp_sticky_silent_rotation;
		}
	}



	if (settings::miscactors::vehicles)
	{
		tarray<uobject*> vehicle_array = defines::game_statics->get_all_actors_of_class(world, defines::actor_vehicle_class);
		for (int i = 0; i < vehicle_array.size(); i++) {
			if (!vehicle_array.valid(i)) continue;

			auto vehicle = (vehicle_actor*)vehicle_array[i];
			if (!vehicle) continue;

			auto screen_location = fvector2d();
			auto world_location = vehicle->get_actor_location();

			auto distance = defines::math->vector_distance(camera_location, world_location) * 0.01;

			if (distance > settings::miscactors::max_distance) continue;

			if (controller->w2s(world_location, &screen_location)) {

				if (settings::miscactors::display_distance) {
					auto final = defines::string->build_string_double(vehicle->get_display_name().c_str(), L"[", defines::math->round(distance), L"m]");
					render::text(final.c_str(), screen_location, flinearcolor(1.f, 0.f, 1.f, 1.f), true, true, settings::style::text_outlined);
				}
				else {
					render::text(vehicle->get_display_name().c_str(), screen_location, flinearcolor(1.f, 0.f, 1.f, 1.f), true, true, settings::style::text_outlined);
				}
			
			}
		}
	}

	if (settings::miscactors::flags)
	{
		tarray<uobject*> flag_array = defines::game_statics->get_all_actors_of_class(world, defines::actor_flag_class);
		for (int i = 0; i < flag_array.size(); i++) {
			if (!flag_array.valid(i)) continue;

			auto flag = (flag_actor*)flag_array[i];
			if (!flag) continue;

			auto screen_location = fvector2d();
			auto world_location = flag->get_actor_location();

			auto distance = defines::math->vector_distance(camera_location, world_location) * 0.01;

			if (distance > settings::miscactors::max_distance) continue;

			if (controller->w2s(world_location, &screen_location)) {

				if (settings::miscactors::display_distance) {
					auto final = defines::string->build_string_double(L"Flag", L"[", defines::math->round(distance), L"m]");
					render::text(final.c_str(), screen_location, flinearcolor(0.f, 1.f, 0.f, 1.f), true, true, settings::style::text_outlined);
				}
				else {
					render::text(L"Flag", screen_location, flinearcolor(0.f, 1.f, 0.f, 1.f), true, true, settings::style::text_outlined);
				}

			}
		}
	}

	if (settings::miscactors::traps)
	{
		tarray<uobject*> trap_array = defines::game_statics->get_all_actors_of_class(world, defines::actor_trap_class);
		for (int i = 0; i < trap_array.size(); i++) {
			if (!trap_array.valid(i)) continue;

			auto trap = (trap_actor*)trap_array[i];
			if (!trap) continue;

			auto screen_location = fvector2d();
			auto world_location = trap->get_actor_location();

			auto distance = defines::math->vector_distance(camera_location, world_location) * 0.01;

			if (distance > settings::miscactors::max_distance) continue;

			if (controller->w2s(world_location, &screen_location)) {

				if (settings::miscactors::display_distance) {
					auto final = defines::string->build_string_double(L"Trap", L"[", defines::math->round(distance), L"m]");
					render::text(final.c_str(), screen_location, flinearcolor(0.f, 1.f, 0.f, 1.f), true, true, settings::style::text_outlined);
				}
				else {
					render::text(L"Trap", screen_location, flinearcolor(0.f, 1.f, 0.f, 1.f), true, true, settings::style::text_outlined);
				}

			}
		}
	}

	if (settings::miscactors::rifts) {
		tarray<uobject*> rift_array = defines::game_statics->get_all_actors_of_class(world, defines::actor_rift_class);
		for (int i = 0; i < rift_array.size(); i++) {
			if (!rift_array.valid(i)) continue;

			auto rift = (rift_actor*)rift_array[i];
			if (!rift) continue;


			auto screen_location = fvector2d();
			auto world_location = rift->get_actor_location();

			auto distance = defines::math->vector_distance(camera_location, world_location) * 0.01;

			if (distance > settings::miscactors::max_distance) continue;

			if (controller->w2s(world_location, &screen_location)) {
				if (settings::miscactors::display_distance) {
					auto final = defines::string->build_string_double(L"Rift", L"[", defines::math->round(distance), L"m]");
					render::text(final.c_str(), screen_location, flinearcolor(1.f, 1.f, 0.f, 1.f), true, true, settings::style::text_outlined);
				}
				else {
					render::text(L"Rift", screen_location, flinearcolor(1.f, 1.f, 0.f, 1.f), true, true, settings::style::text_outlined);
				}
			}
		}
	}

	if (settings::weakspot::enable) {
		weakspot_actor* target_weakspot = 0;
		tarray<uobject*> weakspot_array = defines::game_statics->get_all_actors_of_class(world, defines::actor_weakspot_class);
		for (int i = 0; i < weakspot_array.size(); i++) {
			if (!weakspot_array.valid(i)) continue;

			auto weakspot = (weakspot_actor*)weakspot_array[i];
			if (!weakspot) continue;

			if (!weakspot->is_active()) continue;

			target_weakspot = weakspot;
		}

		auto temp_silent_active = false;
		auto temp_silent_rotation = frotator();

		if (target_weakspot) {
			auto aim_location = target_weakspot->get_actor_location();
			auto aim_screen = fvector2d();
			if (controller->w2s(aim_location, &aim_screen) && aim_screen) {

				render::text(L"[X]", aim_screen, flinearcolor(1.f, 0.f, 0.f, 1.f), true, true, settings::style::text_outlined);

				if (settings::weakspot::weakspot_aimbot && local_pawn) {
					if (settings::weakspot::target_line) {
						render::line_with_outline(center, aim_screen, flinearcolor(1.f, 0.f, 0.f, 1.f), 1.f);
					}

					if (controller->is_key_down(defines::left_mouse_button)) {
						if (settings::weakspot::silent) {
							temp_silent_active = true;
							temp_silent_rotation = defines::math->find_look_at_rotation(camera_location, aim_location);
						}
						else {
							fortnite::set_aim(world, controller, camera_location, camera_rotation, aim_location, settings::weakspot::interpolate, settings::weakspot::constant, settings::weakspot::interpolate_speed);
						}
					}
				}
			}
		}

		if (!player_silent) {
			fortnite::temp::silent_active = temp_silent_active;
			fortnite::temp::silent_rotation = temp_silent_rotation;
		}
	}

	if (settings::pickups::enable) {
		tarray<uobject*> pickup_array = defines::game_statics->get_all_actors_of_class(world, defines::actor_pickup_class);
		for (int i = 0; i < pickup_array.size(); i++) {
			if (!pickup_array.valid(i)) continue;

			auto pickup = (pickup_actor*)pickup_array[i];
			if (!pickup) continue;

			auto screen_location = fvector2d();
			auto world_location = pickup->get_actor_location();
			auto distance = defines::math->vector_distance(camera_location, world_location) * 0.01;

			if (distance > settings::pickups::max_distance) continue;

			if (auto definition = pickup->get_item_definition()) {
				auto display_name = definition->display_name();
				if (display_name.data && display_name.c_str()) {
					auto render_color = flinearcolor();
					auto tier = definition->get_tier();

					if (settings::pickups::common && tier == fort_item_tier::I) render_color = flinearcolor(0.4f, 0.4f, 0.4f, 1.f);
					else if (settings::pickups::uncommon && tier == fort_item_tier::II) render_color = flinearcolor(0.2f, 0.8f, 0.4f, 1.f);
					else if (settings::pickups::rare && tier == fort_item_tier::III) render_color = flinearcolor(0.f, 0.4f, 0.8f, 1.f);
					else if (settings::pickups::epic && tier == fort_item_tier::IV) render_color = flinearcolor(1.f, 0.f, 1.f, 1.f);
					else if (settings::pickups::legendary && tier == fort_item_tier::V) render_color = flinearcolor(0.7f, 0.7f, 0.f, 1.f);
					else if (settings::pickups::mythic && tier == fort_item_tier::VI) render_color = flinearcolor(1.f, 1.f, 0.f, 1.f);

					if (settings::radar::enable && settings::radar::pickups && render_color) {
						fortnite::radar::add_to_radar(world_location, render_color);
					}

					if (controller->w2s(world_location, &screen_location) && screen_location) {
						if (render_color) {
							if (settings::pickups::lines && !render::in_circle(center.x, center.y, settings::pickups::line_offset, screen_location.x, screen_location.y)) {
								double angle = defines::math->atan2(screen_location.y - center.y, screen_location.x - center.x);

								double x = settings::pickups::line_offset * defines::math->cos(angle) + center.x;
								double y = settings::pickups::line_offset * defines::math->sin(angle) + center.y;

								fvector2d end_pos = fvector2d(x, y);
								render::line_with_outline(end_pos, fvector2d(screen_location.x, screen_location.y + 8), render_color, 1.f);
							}

							if (settings::pickups::display_distance) {
								auto final = defines::string->build_string_double(display_name.c_str(), L"[", defines::math->round(distance), L"m]");
								render::text(final.c_str(), screen_location, render_color, true, true, settings::style::text_outlined);
							}
							else render::text(display_name.c_str(), screen_location, render_color, true, true, settings::style::text_outlined);
						}
					}
				}
			}
		}
	}

	if (settings::containers::enable) {
		tarray<uobject*> container_array = defines::game_statics->get_all_actors_of_class(world, defines::actor_container_class);
		for (int i = 0; i < container_array.size(); i++) {
			if (!container_array.valid(i)) continue;

			auto container = (container_actor*)container_array[i];
			if (!container) continue;

			if (settings::containers::ignore_opened && container->already_searched()) continue;

			auto object_name = defines::system->get_object_name(container);

			auto screen_location = fvector2d();
			auto world_location = container->get_actor_location();
			auto distance = defines::math->vector_distance(camera_location, world_location) * 0.01;

			if (distance > settings::containers::max_distance) continue;

			auto render_color = flinearcolor(1.f, 1.f, 1.f, 1.f);
			if (controller->w2s(world_location, &screen_location) && screen_location) {
				if (settings::containers::chest && defines::string->contains(object_name.c_str(), L"Tiered_Chest", false, false)) {
					render_color = flinearcolor(1.f, 1.f, 0.f, 1.f);
					if (settings::containers::display_distance) {
						auto final = defines::string->build_string_double(L"Chest ", L"[", defines::math->round(distance), L"m]");
						render::text(final.c_str(), screen_location, render_color, true, true, settings::style::text_outlined);
					}
					else render::text(L"Chest", screen_location, render_color, true, true, settings::style::text_outlined);
				}
				else if (settings::containers::ammo_box && defines::string->contains(object_name.c_str(), L"Tiered_Ammo", false, false)) {
					render_color = flinearcolor(0.4f, 0.4f, 0.4f, 1.f);
					if (settings::containers::display_distance) {
						auto final = defines::string->build_string_double(L"Ammo box ", L"[", defines::math->round(distance), L"m]");
						render::text(final.c_str(), screen_location, render_color, true, true, settings::style::text_outlined);
					}
					else render::text(L"Ammo box", screen_location, render_color, true, true, settings::style::text_outlined);
				}
				else if (settings::containers::chest && defines::string->contains(object_name.c_str(), L"AlwaysSpawn_NormalChest", false, false)) {
					render_color = flinearcolor(1.f, 1.f, 0.f, 1.f);
					if (settings::containers::display_distance) {
						auto final = defines::string->build_string_double(L"Basic chest ", L"[", defines::math->round(distance), L"m]");
						render::text(final.c_str(), screen_location, render_color, true, true, settings::style::text_outlined);
					}
					else render::text(L"Basic chest", screen_location, render_color, true, true, settings::style::text_outlined);
				}
				else if (settings::containers::cooler_and_food && defines::string->contains(object_name.c_str(), L"Cooler_Container", false, false)) {
					render_color = flinearcolor(0.f, 1.f, 1.f, 1.f);
					if (settings::containers::display_distance) {
						auto final = defines::string->build_string_double(L"Cooler ", L"[", defines::math->round(distance), L"m]");
						render::text(final.c_str(), screen_location, render_color, true, true, settings::style::text_outlined);
					}
					else render::text(L"Cooler", screen_location, render_color, true, true, settings::style::text_outlined);
				}
				else if (settings::containers::cooler_and_food && defines::string->contains(object_name.c_str(), L"FoodBox_Produce", false, false)) {
					render_color = flinearcolor(0.f, 1.f, 0.4f, 1.f);
					if (settings::containers::display_distance) {
						auto final = defines::string->build_string_double(L"Food box ", L"[", defines::math->round(distance), L"m]");
						render::text(final.c_str(), screen_location, render_color, true, true, settings::style::text_outlined);
					}
					else render::text(L"Food box", screen_location, render_color, true, true, settings::style::text_outlined);
				}
				else if (settings::containers::safe && defines::string->contains(object_name.c_str(), L"Tiered_Safe", false, false)) {
					render_color = flinearcolor(1.f, 0.f, 0.f, 1.f);
					if (settings::containers::display_distance) {
						auto final = defines::string->build_string_double(L"Safe ", L"[", defines::math->round(distance), L"m]");
						render::text(final.c_str(), screen_location, render_color, true, true, settings::style::text_outlined);
					}
					else render::text(L"Safe", screen_location, render_color, true, true, settings::style::text_outlined);
				}
				else if (settings::containers::others && defines::string->contains(object_name.c_str(), L"Barrel_FishingRod", false, false)) {
					render_color = flinearcolor(0.4f, 0.4f, 0.4f, 1.f);
					if (settings::containers::display_distance) {
						auto final = defines::string->build_string_double(L"Fishing rod ", L"[", defines::math->round(distance), L"m]");
						render::text(final.c_str(), screen_location, render_color, true, true, settings::style::text_outlined);
					}
					else render::text(L"Fishing rod", screen_location, render_color, true, true, settings::style::text_outlined);
				}
				else if (settings::containers::others && defines::string->contains(object_name.c_str(), L"CashRegister", false, false)) {
					render_color = flinearcolor(0.4f, 0.4f, 0.4f, 1.f);
					if (settings::containers::display_distance) {
						auto final = defines::string->build_string_double(L"Cash register ", L"[", defines::math->round(distance), L"m]");
						render::text(final.c_str(), screen_location, render_color, true, true, settings::style::text_outlined);
					}
					else render::text(L"Cash register", screen_location, render_color, true, true, settings::style::text_outlined);
				}
				else if (settings::containers::chest && defines::string->contains(object_name.c_str(), L"BuriedChest", false, false)) {
					render_color = flinearcolor(1.f, 1.f, 0.f, 1.f);
					if (settings::containers::display_distance) {
						auto final = defines::string->build_string_double(L"Buried chest ", L"[", defines::math->round(distance), L"m]");
						render::text(final.c_str(), screen_location, render_color, true, true, settings::style::text_outlined);
					}
					else render::text(L"Buried chest", screen_location, render_color, true, true, settings::style::text_outlined);
				}
				if (settings::containers::lines && render_color && !render::in_circle(center.x, center.y, settings::containers::line_offset, screen_location.x, screen_location.y)) {
					double angle = defines::math->atan2(screen_location.y - center.y, screen_location.x - center.x);

					double x = settings::containers::line_offset * defines::math->cos(angle) + center.x;
					double y = settings::containers::line_offset * defines::math->sin(angle) + center.y;

					fvector2d end_pos = fvector2d(x, y);
					render::line_with_outline(end_pos, fvector2d(screen_location.x, screen_location.y + 8), render_color, 1.f);
				}
			}

			if (settings::radar::enable && settings::radar::containers && render_color) {
				fortnite::radar::add_to_radar(world_location, render_color);
			}
		}
	}





}

namespace novacane {
	using draw_transition_sim = void(*)(ugameviewportclient* viewport, ucanvas* canvas);
	draw_transition_sim draw_transition_o = 0;


	void draw_transition(ugameviewportclient* viewport, ucanvas* canvas) {
		novacane_main(viewport, canvas);
		return draw_transition_o(viewport, canvas);
	}


	static void init() {
		game = get_module(L"FortniteClient-Win64-Shipping.exe");

		if (!game)
			return;

		defines::init();


		if (auto world = uobject::find_object(L"Frontend", reinterpret_cast<uobject*>(-1))) {
			auto game_instance = defines::game_statics->get_game_instance(world);
			auto local_player = game_instance->get_local_players()[0];


			auto controller = defines::game_statics->get_player_controller(world, std::int32_t(0));
			auto viewport = local_player->get_viewport();

			auto engine = (uengine*)defines::system->get_outer_object(game_instance);
			render::font = engine->get_font(); 



			draw_transition_o = vmt<decltype(draw_transition_o)>(std::uintptr_t(viewport), std::uintptr_t(draw_transition), offsets::drawtransition);
		}

	}
}

```

`importer.hpp`:

```hpp
#ifndef LAZY_IMPORTER_HPP
#define LAZY_IMPORTER_HPP


#define IFH(name) ::li::detail::lazy_function<LAZY_IMPORTER_KHASH(#name), decltype(&name)>()

#define IFH_DEF(name) ::li::detail::lazy_function<LAZY_IMPORTER_KHASH(#name), name>()

#define IFH_MODULE(name) ::li::detail::lazy_module<LAZY_IMPORTER_KHASH(name)>()

#ifndef LAZY_IMPORTER_CPP_FORWARD
#ifdef LAZY_IMPORTER_NO_CPP_FORWARD
#define LAZY_IMPORTER_CPP_FORWARD(t, v) v
#else
#include <utility>
#define LAZY_IMPORTER_CPP_FORWARD(t, v) std::forward<t>( v )
#endif
#endif

#include <intrin.h>

#ifndef LAZY_IMPORTER_NO_FORCEINLINE
#if defined(_MSC_VER)
#define LAZY_IMPORTER_FORCEINLINE __forceinline
#elif defined(__GNUC__) && __GNUC__ > 3
#define LAZY_IMPORTER_FORCEINLINE inline __attribute__((__always_inline__))
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif


#ifdef LAZY_IMPORTER_CASE_INSENSITIVE
#define LAZY_IMPORTER_CASE_SENSITIVITY false
#else
#define LAZY_IMPORTER_CASE_SENSITIVITY true
#endif

#define LAZY_IMPORTER_STRINGIZE(x) #x
#define LAZY_IMPORTER_STRINGIZE_EXPAND(x) LAZY_IMPORTER_STRINGIZE(x)

#define LAZY_IMPORTER_KHASH(str) ::li::detail::khash(str, \
    ::li::detail::khash_impl( __TIME__ __DATE__ LAZY_IMPORTER_STRINGIZE_EXPAND(__LINE__) LAZY_IMPORTER_STRINGIZE_EXPAND(__COUNTER__), 2166136261 ))

namespace li {
    namespace detail {

        namespace win {

            struct LIST_ENTRY_T {
                const char* Flink;
                const char* Blink;
            };

            struct UNICODE_STRING_T {
                unsigned short Length;
                unsigned short MaximumLength;
                wchar_t* Buffer;
            };

            struct PEB_LDR_DATA_T {
                unsigned long Length;
                unsigned long Initialized;
                const char* SsHandle;
                LIST_ENTRY_T  InLoadOrderModuleList;
            };

            struct PEB_T {
                unsigned char   Reserved1[2];
                unsigned char   BeingDebugged;
                unsigned char   Reserved2[1];
                const char* Reserved3[2];
                PEB_LDR_DATA_T* Ldr;
            };

            struct LDR_DATA_TABLE_ENTRY_T {
                LIST_ENTRY_T InLoadOrderLinks;
                LIST_ENTRY_T InMemoryOrderLinks;
                LIST_ENTRY_T InInitializationOrderLinks;
                const char* DllBase;
                const char* EntryPoint;
                union {
                    unsigned long SizeOfImage;
                    const char* _dummy;
                };
                UNICODE_STRING_T FullDllName;
                UNICODE_STRING_T BaseDllName;

                LAZY_IMPORTER_FORCEINLINE const LDR_DATA_TABLE_ENTRY_T*
                    load_order_next() const noexcept
                {
                    return reinterpret_cast<const LDR_DATA_TABLE_ENTRY_T*>(
                        InLoadOrderLinks.Flink);
                }
            };

            struct IMAGE_DOS_HEADER { // DOS .EXE header
                unsigned short e_magic; // Magic number
                unsigned short e_cblp; // Bytes on last page of file
                unsigned short e_cp; // Pages in file
                unsigned short e_crlc; // Relocations
                unsigned short e_cparhdr; // Size of header in paragraphs
                unsigned short e_minalloc; // Minimum extra paragraphs needed
                unsigned short e_maxalloc; // Maximum extra paragraphs needed
                unsigned short e_ss; // Initial (relative) SS value
                unsigned short e_sp; // Initial SP value
                unsigned short e_csum; // Checksum
                unsigned short e_ip; // Initial IP value
                unsigned short e_cs; // Initial (relative) CS value
                unsigned short e_lfarlc; // File address of relocation table
                unsigned short e_ovno; // Overlay number
                unsigned short e_res[4]; // Reserved words
                unsigned short e_oemid; // OEM identifier (for e_oeminfo)
                unsigned short e_oeminfo; // OEM information; e_oemid specific
                unsigned short e_res2[10]; // Reserved words
                long           e_lfanew; // File address of new exe header
            };

            struct IMAGE_FILE_HEADER {
                unsigned short Machine;
                unsigned short NumberOfSections;
                unsigned long  TimeDateStamp;
                unsigned long  PointerToSymbolTable;
                unsigned long  NumberOfSymbols;
                unsigned short SizeOfOptionalHeader;
                unsigned short Characteristics;
            };

            struct IMAGE_EXPORT_DIRECTORY {
                unsigned long  Characteristics;
                unsigned long  TimeDateStamp;
                unsigned short MajorVersion;
                unsigned short MinorVersion;
                unsigned long  Name;
                unsigned long  Base;
                unsigned long  NumberOfFunctions;
                unsigned long  NumberOfNames;
                unsigned long  AddressOfFunctions; // RVA from base of image
                unsigned long  AddressOfNames; // RVA from base of image
                unsigned long  AddressOfNameOrdinals; // RVA from base of image
            };

            struct IMAGE_DATA_DIRECTORY {
                unsigned long VirtualAddress;
                unsigned long Size;
            };

            struct IMAGE_OPTIONAL_HEADER64 {
                unsigned short       Magic;
                unsigned char        MajorLinkerVersion;
                unsigned char        MinorLinkerVersion;
                unsigned long        SizeOfCode;
                unsigned long        SizeOfInitializedData;
                unsigned long        SizeOfUninitializedData;
                unsigned long        AddressOfEntryPoint;
                unsigned long        BaseOfCode;
                unsigned long long   ImageBase;
                unsigned long        SectionAlignment;
                unsigned long        FileAlignment;
                unsigned short       MajorOperatingSystemVersion;
                unsigned short       MinorOperatingSystemVersion;
                unsigned short       MajorImageVersion;
                unsigned short       MinorImageVersion;
                unsigned short       MajorSubsystemVersion;
                unsigned short       MinorSubsystemVersion;
                unsigned long        Win32VersionValue;
                unsigned long        SizeOfImage;
                unsigned long        SizeOfHeaders;
                unsigned long        CheckSum;
                unsigned short       Subsystem;
                unsigned short       DllCharacteristics;
                unsigned long long   SizeOfStackReserve;
                unsigned long long   SizeOfStackCommit;
                unsigned long long   SizeOfHeapReserve;
                unsigned long long   SizeOfHeapCommit;
                unsigned long        LoaderFlags;
                unsigned long        NumberOfRvaAndSizes;
                IMAGE_DATA_DIRECTORY DataDirectory[16];
            };

            struct IMAGE_OPTIONAL_HEADER32 {
                unsigned short       Magic;
                unsigned char        MajorLinkerVersion;
                unsigned char        MinorLinkerVersion;
                unsigned long        SizeOfCode;
                unsigned long        SizeOfInitializedData;
                unsigned long        SizeOfUninitializedData;
                unsigned long        AddressOfEntryPoint;
                unsigned long        BaseOfCode;
                unsigned long        BaseOfData;
                unsigned long        ImageBase;
                unsigned long        SectionAlignment;
                unsigned long        FileAlignment;
                unsigned short       MajorOperatingSystemVersion;
                unsigned short       MinorOperatingSystemVersion;
                unsigned short       MajorImageVersion;
                unsigned short       MinorImageVersion;
                unsigned short       MajorSubsystemVersion;
                unsigned short       MinorSubsystemVersion;
                unsigned long        Win32VersionValue;
                unsigned long        SizeOfImage;
                unsigned long        SizeOfHeaders;
                unsigned long        CheckSum;
                unsigned short       Subsystem;
                unsigned short       DllCharacteristics;
                unsigned long        SizeOfStackReserve;
                unsigned long        SizeOfStackCommit;
                unsigned long        SizeOfHeapReserve;
                unsigned long        SizeOfHeapCommit;
                unsigned long        LoaderFlags;
                unsigned long        NumberOfRvaAndSizes;
                IMAGE_DATA_DIRECTORY DataDirectory[16];
            };

            struct IMAGE_NT_HEADERS {
                unsigned long     Signature;
                IMAGE_FILE_HEADER FileHeader;
#ifdef _WIN64
                IMAGE_OPTIONAL_HEADER64 OptionalHeader;
#else
                IMAGE_OPTIONAL_HEADER32 OptionalHeader;
#endif
            };

        } // namespace win

        struct forwarded_hashes {
            unsigned module_hash;
            unsigned function_hash;
        };

        // 64 bit integer where 32 bits are used for the hash offset
        // and remaining 32 bits are used for the hash computed using it
        using offset_hash_pair = unsigned long long;

        LAZY_IMPORTER_FORCEINLINE constexpr unsigned get_hash(offset_hash_pair pair) noexcept { return (pair & 0xFFFFFFFF); }

        LAZY_IMPORTER_FORCEINLINE constexpr unsigned get_offset(offset_hash_pair pair) noexcept { return (pair >> 32); }

        template<bool CaseSensitive = LAZY_IMPORTER_CASE_SENSITIVITY>
        LAZY_IMPORTER_FORCEINLINE constexpr unsigned hash_single(unsigned value, char c) noexcept
        {
            return static_cast<unsigned int>(
                (value ^ ((!CaseSensitive && c >= 'A' && c <= 'Z') ? (c | (1 << 5)) : c)) *
                static_cast<unsigned long long>(16777619));
        }

        LAZY_IMPORTER_FORCEINLINE constexpr unsigned
            khash_impl(const char* str, unsigned value) noexcept
        {
            return (*str ? khash_impl(str + 1, hash_single(value, *str)) : value);
        }

        LAZY_IMPORTER_FORCEINLINE constexpr offset_hash_pair khash(
            const char* str, unsigned offset) noexcept
        {
            return ((offset_hash_pair{ offset } << 32) | khash_impl(str, offset));
        }

        template<class CharT = char>
        LAZY_IMPORTER_FORCEINLINE unsigned hash(const CharT* str, unsigned offset) noexcept
        {
            unsigned value = offset;

            for (;;) {
                char c = *str++;
                if (!c)
                    return value;
                value = hash_single(value, c);
            }
        }

        LAZY_IMPORTER_FORCEINLINE unsigned hash(
            const win::UNICODE_STRING_T& str, unsigned offset) noexcept
        {
            auto       first = str.Buffer;
            const auto last = first + (str.Length / sizeof(wchar_t));
            auto       value = offset;
            for (; first != last; ++first)
                value = hash_single(value, static_cast<char>(*first));

            return value;
        }

        LAZY_IMPORTER_FORCEINLINE forwarded_hashes hash_forwarded(
            const char* str, unsigned offset) noexcept
        {
            forwarded_hashes res{ offset, offset };

            for (; *str != '.'; ++str)
                res.module_hash = hash_single<true>(res.module_hash, *str);

            ++str;

            for (; *str; ++str)
                res.function_hash = hash_single(res.function_hash, *str);

            return res;
        }

        // some helper functions
        LAZY_IMPORTER_FORCEINLINE const win::PEB_T* peb() noexcept
        {
#if defined(_M_X64) || defined(__amd64__)
            return reinterpret_cast<const win::PEB_T*>(__readgsqword(0x60));
#elif defined(_M_IX86) || defined(__i386__)
            return reinterpret_cast<const win::PEB_T*>(__readfsdword(0x30));
#elif defined(_M_ARM) || defined(__arm__)
            return *reinterpret_cast<const win::PEB_T**>(_MoveFromCoprocessor(15, 0, 13, 0, 2) + 0x30);
#elif defined(_M_ARM64) || defined(__aarch64__)
            return *reinterpret_cast<const win::PEB_T**>(__getReg(18) + 0x60);
#elif defined(_M_IA64) || defined(__ia64__)
            return *reinterpret_cast<const win::PEB_T**>(static_cast<char*>(_rdteb()) + 0x60);
#else
#error Unsupported platform. Open an issue and I'll probably add support.
#endif
        }

        LAZY_IMPORTER_FORCEINLINE const win::PEB_LDR_DATA_T* ldr()
        {
            return reinterpret_cast<const win::PEB_LDR_DATA_T*>(peb()->Ldr);
        }

        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_NT_HEADERS* nt_headers(
            const char* base) noexcept
        {
            return reinterpret_cast<const win::IMAGE_NT_HEADERS*>(
                base + reinterpret_cast<const win::IMAGE_DOS_HEADER*>(base)->e_lfanew);
        }

        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* image_export_dir(
            const char* base) noexcept
        {
            return reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
                base + nt_headers(base)->OptionalHeader.DataDirectory->VirtualAddress);
        }

        LAZY_IMPORTER_FORCEINLINE const win::LDR_DATA_TABLE_ENTRY_T* ldr_data_entry() noexcept
        {
            return reinterpret_cast<const win::LDR_DATA_TABLE_ENTRY_T*>(
                ldr()->InLoadOrderModuleList.Flink);
        }

        struct exports_directory {
            const char* _base;
            const win::IMAGE_EXPORT_DIRECTORY* _ied;
            unsigned long                      _ied_size;

        public:
            using size_type = unsigned long;

            LAZY_IMPORTER_FORCEINLINE
                exports_directory(const char* base) noexcept : _base(base)
            {
                const auto ied_data_dir = nt_headers(base)->OptionalHeader.DataDirectory[0];
                _ied = reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
                    base + ied_data_dir.VirtualAddress);
                _ied_size = ied_data_dir.Size;
            }

            LAZY_IMPORTER_FORCEINLINE explicit operator bool() const noexcept
            {
                return reinterpret_cast<const char*>(_ied) != _base;
            }

            LAZY_IMPORTER_FORCEINLINE size_type size() const noexcept
            {
                return _ied->NumberOfNames;
            }

            LAZY_IMPORTER_FORCEINLINE const char* base() const noexcept { return _base; }
            LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* ied() const noexcept
            {
                return _ied;
            }

            LAZY_IMPORTER_FORCEINLINE const char* name(size_type index) const noexcept
            {
                return reinterpret_cast<const char*>(
                    _base + reinterpret_cast<const unsigned long*>(
                        _base + _ied->AddressOfNames)[index]);
            }

            LAZY_IMPORTER_FORCEINLINE const char* address(size_type index) const noexcept
            {
                const auto* const rva_table =
                    reinterpret_cast<const unsigned long*>(_base + _ied->AddressOfFunctions);

                const auto* const ord_table = reinterpret_cast<const unsigned short*>(
                    _base + _ied->AddressOfNameOrdinals);

                return _base + rva_table[ord_table[index]];
            }

            LAZY_IMPORTER_FORCEINLINE bool is_forwarded(
                const char* export_address) const noexcept
            {
                const auto ui_ied = reinterpret_cast<const char*>(_ied);
                return (export_address > ui_ied && export_address < ui_ied + _ied_size);
            }
        };

        struct safe_module_enumerator {
            using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T;
            value_type* value;
            value_type* head;

            LAZY_IMPORTER_FORCEINLINE safe_module_enumerator() noexcept
                : safe_module_enumerator(ldr_data_entry())
            {}

            LAZY_IMPORTER_FORCEINLINE
                safe_module_enumerator(const detail::win::LDR_DATA_TABLE_ENTRY_T* ldr) noexcept
                : value(ldr->load_order_next()), head(value)
            {}

            LAZY_IMPORTER_FORCEINLINE void reset() noexcept
            {
                value = head->load_order_next();
            }

            LAZY_IMPORTER_FORCEINLINE bool next() noexcept
            {
                value = value->load_order_next();

                return value != head && value->DllBase;
            }
        };

        struct unsafe_module_enumerator {
            using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T*;
            value_type value;

            LAZY_IMPORTER_FORCEINLINE unsafe_module_enumerator() noexcept
                : value(ldr_data_entry())
            {}

            LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = ldr_data_entry(); }

            LAZY_IMPORTER_FORCEINLINE bool next() noexcept
            {
                value = value->load_order_next();
                return true;
            }
        };

        // provides the cached functions which use Derive classes methods
        template<class Derived, class DefaultType = void*>
        class lazy_base {
        protected:
            // This function is needed because every templated function
            // with different args has its own static buffer
            LAZY_IMPORTER_FORCEINLINE static void*& _cache() noexcept
            {
                static void* value = nullptr;
                return value;
            }

        public:
            template<class T = DefaultType>
            LAZY_IMPORTER_FORCEINLINE static T safe() noexcept
            {
                return Derived::template get<T, safe_module_enumerator>();
            }

            template<class T = DefaultType, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static T cached() noexcept
            {
                auto& cached = _cache();
                if (!cached)
                    cached = Derived::template get<void*, Enum>();

                return (T)(cached);
            }

            template<class T = DefaultType>
            LAZY_IMPORTER_FORCEINLINE static T safe_cached() noexcept
            {
                return cached<T, safe_module_enumerator>();
            }
        };

        template<offset_hash_pair OHP>
        struct lazy_module : lazy_base<lazy_module<OHP>> {
            template<class T = void*, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static T get() noexcept
            {
                Enum e;
                do {
                    if (hash(e.value->BaseDllName, get_offset(OHP)) == get_hash(OHP))
                        return (T)(e.value->DllBase);
                } while (e.next());
                return {};
            }

            template<class T = void*, class Ldr>
            LAZY_IMPORTER_FORCEINLINE static T in(Ldr ldr) noexcept
            {
                safe_module_enumerator e((const detail::win::LDR_DATA_TABLE_ENTRY_T*)(ldr));
                do {
                    if (hash(e.value->BaseDllName, get_offset(OHP)) == get_hash(OHP))
                        return (T)(e.value->DllBase);
                } while (e.next());
                return {};
            }

            template<class T = void*, class Ldr>
            LAZY_IMPORTER_FORCEINLINE static T in_cached(Ldr ldr) noexcept
            {
                auto& cached = lazy_base<lazy_module<OHP>>::_cache();
                if (!cached)
                    cached = in(ldr);

                return (T)(cached);
            }
        };

        template<offset_hash_pair OHP, class T>
        struct lazy_function : lazy_base<lazy_function<OHP, T>, T> {
            using base_type = lazy_base<lazy_function<OHP, T>, T>;

            template<class... Args>
            LAZY_IMPORTER_FORCEINLINE decltype(auto) operator()(Args&&... args) const
            {
#ifndef LAZY_IMPORTER_CACHE_OPERATOR_PARENS
                return get()(LAZY_IMPORTER_CPP_FORWARD(Args, args)...);
#else
                return this->cached()(LAZY_IMPORTER_CPP_FORWARD(Args, args)...);
#endif
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F get() noexcept
            {
                // for backwards compatability.
                // Before 2.0 it was only possible to resolve forwarded exports when
                // this macro was enabled
#ifdef LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
                return forwarded<F, Enum>();
#else

                Enum e;

                do {
#ifdef LAZY_IMPORTER_HARDENED_MODULE_CHECKS
                    if (!e.value->DllBase || !e.value->FullDllName.Length)
                        continue;
#endif

                    const exports_directory exports(e.value->DllBase);

                    if (exports) {
                        auto export_index = exports.size();
                        while (export_index--)
                            if (hash(exports.name(export_index), get_offset(OHP)) == get_hash(OHP))
                                return (F)(exports.address(export_index));
                    }
                } while (e.next());
                return {};
#endif
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F forwarded() noexcept
            {
                detail::win::UNICODE_STRING_T name;
                forwarded_hashes              hashes{ 0, get_hash(OHP) };

                Enum e;
                do {
                    name = e.value->BaseDllName;
                    name.Length -= 8; // get rid of .dll extension

                    if (!hashes.module_hash || hash(name, get_offset(OHP)) == hashes.module_hash) {
                        const exports_directory exports(e.value->DllBase);

                        if (exports) {
                            auto export_index = exports.size();
                            while (export_index--)
                                if (hash(exports.name(export_index), get_offset(OHP)) == hashes.function_hash) {
                                    const auto addr = exports.address(export_index);

                                    if (exports.is_forwarded(addr)) {
                                        hashes = hash_forwarded(
                                            reinterpret_cast<const char*>(addr),
                                            get_offset(OHP));

                                        e.reset();
                                        break;
                                    }
                                    return (F)(addr);
                                }
                        }
                    }
                } while (e.next());
                return {};
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_safe() noexcept
            {
                return forwarded<F, safe_module_enumerator>();
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_cached() noexcept
            {
                auto& value = base_type::_cache();
                if (!value)
                    value = forwarded<void*, Enum>();
                return (F)(value);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_safe_cached() noexcept
            {
                return forwarded_cached<F, safe_module_enumerator>();
            }

            template<class F = T, bool IsSafe = false, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in(Module m) noexcept
            {
                if (IsSafe && !m)
                    return {};

                const exports_directory exports((const char*)(m));
                if (IsSafe && !exports)
                    return {};

                for (unsigned long i{};; ++i) {
                    if (IsSafe && i == exports.size())
                        break;

                    if (hash(exports.name(i), get_offset(OHP)) == get_hash(OHP))
                        return (F)(exports.address(i));
                }
                return {};
            }

            template<class F = T, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_safe(Module m) noexcept
            {
                return in<F, true>(m);
            }

            template<class F = T, bool IsSafe = false, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_cached(Module m) noexcept
            {
                auto& value = base_type::_cache();
                if (!value)
                    value = in<void*, IsSafe>(m);
                return (F)(value);
            }

            template<class F = T, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_safe_cached(Module m) noexcept
            {
                return in_cached<F, true>(m);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt() noexcept
            {
                return in<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_safe() noexcept
            {
                return in_safe<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_cached() noexcept
            {
                return in_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_safe_cached() noexcept
            {
                return in_safe_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
            }
        };

    }
} // namespace li::detail

#endif // include guard


```

`includes.h`:

```h
#pragma once

//windows includes
#include <iostream>
#include <windows.h>
#include <cstdint>


// 

/*
*
*  Novacane : Fortnite Internal 
*  Last Modified : 6/13/23
*
*
*
*/

// game funcs
std::uintptr_t game = std::uintptr_t(0);



// includes
#include "memory.h"
#include "importer.hpp"
#include "game_miscs.h"
#include "vmthook.h"
// settings

#include "settings.h"
#include "sdk.h"
#include "render.h"
#include "ZeroGUI.h"
#include "hooking.h"

```

`main.h`:

```h
#pragma once



```

`memory.h`:

```h
#pragma once

bool is_bad_write_ptr(LPVOID ptr, UINT_PTR size)
{
    return ptr ? false : true;
}

bool valid_pointer(uintptr_t address)
{
	if (!is_bad_write_ptr((LPVOID)address, (UINT_PTR)8)) return TRUE;
	else return FALSE;
}

template<typename ReadT>
ReadT read(DWORD_PTR address, const ReadT& def = ReadT())
{
    if (valid_pointer(address)) {
        return *(ReadT*)(address);
    }
}

```

`menu.h`:

```h
#pragma once

```

`novacane.clinic.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.6.33723.286
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "novacane.clinic", "novacane.clinic\novacane.clinic.vcxproj", "{0039C3AF-303E-475B-A427-481B600DFB35}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{0039C3AF-303E-475B-A427-481B600DFB35}.Debug|x64.ActiveCfg = Debug|x64
		{0039C3AF-303E-475B-A427-481B600DFB35}.Debug|x64.Build.0 = Debug|x64
		{0039C3AF-303E-475B-A427-481B600DFB35}.Debug|x86.ActiveCfg = Debug|Win32
		{0039C3AF-303E-475B-A427-481B600DFB35}.Debug|x86.Build.0 = Debug|Win32
		{0039C3AF-303E-475B-A427-481B600DFB35}.Release|x64.ActiveCfg = Release|x64
		{0039C3AF-303E-475B-A427-481B600DFB35}.Release|x64.Build.0 = Release|x64
		{0039C3AF-303E-475B-A427-481B600DFB35}.Release|x86.ActiveCfg = Release|Win32
		{0039C3AF-303E-475B-A427-481B600DFB35}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {715CBF43-6770-4128-A09F-9D010244EF4C}
	EndGlobalSection
EndGlobal

```

`novacane.clinic.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{0039c3af-303e-475b-a427-481b600dfb35}</ProjectGuid>
    <RootNamespace>novacaneclinic</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;NOVACANECLINIC_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;NOVACANECLINIC_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;NOVACANECLINIC_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>
      </SDLCheck>
      <PreprocessorDefinitions>_WINDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>
      </ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <LanguageStandard>Default</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="game_data.h" />
    <ClInclude Include="game_miscs.h" />
    <ClInclude Include="importer.hpp" />
    <ClInclude Include="includes.h" />
    <ClInclude Include="hooking.h" />
    <ClInclude Include="memory.h" />
    <ClInclude Include="render.h" />
    <ClInclude Include="sdk.h" />
    <ClInclude Include="settings.h" />
    <ClInclude Include="vmthook.h" />
    <ClInclude Include="ZeroGUI.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
  </ItemGroup>
  <ItemGroup>
    <CustomBuild Include="NtUserSendInput.asm">
      <FileType>Document</FileType>
    </CustomBuild>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`novacane.clinic.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="main">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="main_headers">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="includes.h">
      <Filter>main_headers</Filter>
    </ClInclude>
    <ClInclude Include="hooking.h">
      <Filter>main</Filter>
    </ClInclude>
    <ClInclude Include="game_miscs.h">
      <Filter>main_headers</Filter>
    </ClInclude>
    <ClInclude Include="game_data.h">
      <Filter>main_headers</Filter>
    </ClInclude>
    <ClInclude Include="sdk.h">
      <Filter>main_headers</Filter>
    </ClInclude>
    <ClInclude Include="memory.h">
      <Filter>main_headers</Filter>
    </ClInclude>
    <ClInclude Include="vmthook.h">
      <Filter>main_headers</Filter>
    </ClInclude>
    <ClInclude Include="ZeroGUI.h">
      <Filter>main_headers</Filter>
    </ClInclude>
    <ClInclude Include="importer.hpp">
      <Filter>main_headers</Filter>
    </ClInclude>
    <ClInclude Include="render.h">
      <Filter>main_headers</Filter>
    </ClInclude>
    <ClInclude Include="settings.h">
      <Filter>main_headers</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>main</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <CustomBuild Include="NtUserSendInput.asm">
      <Filter>main</Filter>
    </CustomBuild>
  </ItemGroup>
</Project>
```

`novacane.clinic.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`pch.cpp`:

```cpp
// pch.cpp: source file corresponding to the pre-compiled header

#include "pch.h"

// When you are using pre-compiled headers, this source file is necessary for compilation to succeed.

```

`pch.h`:

```h
// pch.h: This is a precompiled header file.
// Files listed below are compiled only once, improving build performance for future builds.
// This also affects IntelliSense performance, including code completion and many code browsing features.
// However, files listed here are ALL re-compiled if any one of them is updated between builds.
// Do not add files here that you will be updating frequently as this negates the performance advantage.

#ifndef PCH_H
#define PCH_H

// add headers that you want to pre-compile here
#include "framework.h"

#endif //PCH_H

```

`render.h`:

```h
#pragma once

namespace render {
	bool show_menu = true;
	bool draw_cursor = true;
	bool show_menu_old = false;
	bool outline = true;
	float outlinethickness = 1.5f;
	float linethickness = 1.f;
	int hovered_headers = 0;
	uworld* world;
	aplayercontroller* controller;
	ucanvas* canvas;
	uobject* font;
	fvector2d screen_center, screen_size;

	bool is_insert_clicked() {
		static bool insert_clicked = false;
		static bool insert_down_already = false;

		bool insert_down = render::controller->is_key_down(defines::insert);
		if (insert_down) {
			if (insert_down_already)
				insert_clicked = false;
			else {
				insert_clicked = true;
				insert_down_already = true;
			}
		}
		else {
			insert_clicked = false;
			insert_down_already = false;
		}

		return insert_clicked;
	}

	bool in_circle(int cx, int cy, int r, int x, int y) {
		int dist = (x - cx) * (x - cx) + (y - cy) * (y - cy);
		if (dist <= r * r)
			return true;
		else
			return false;
	}

	void text(fstring content, fvector2d position, flinearcolor render_color, bool center_x, bool center_y, bool outlined) {
		canvas->k2_draw_text(font, content, position, fvector2d(1.0, 1.0), render_color, 1.0f, flinearcolor(), fvector2d(), center_x, center_y, outlined, flinearcolor(0, 0, 0, 1));
	}

	fvector2d text_size(fstring content) {
		return canvas->k2_text_size(font, content, fvector2d(1.0, 1.0));
	}

	void line(fvector2d a, fvector2d b, flinearcolor render_color, float thickness) {
		canvas->k2_draw_line(a, b, thickness, render_color);
	}

	void line_with_outline(fvector2d a, fvector2d b, flinearcolor render_color, float thickness)
	{
		if (outline) {
			canvas->k2_draw_line(a, b, outlinethickness, flinearcolor(0.f, 0.f, 0.f, 1.f));
		}
		canvas->k2_draw_line(a, b, linethickness, render_color);
	}

	void circle(fvector2d position, int radius, int segments, flinearcolor color) {
		float PI = 3.1415927f;

		float Step = PI * 2.0 / segments;
		int Count = 0;
		fvector2d V[128];
		for (float a = 0; a < PI * 2.0; a += Step) {
			float X1 = radius * defines::math->cos(a) + position.x;
			float Y1 = radius * defines::math->sin(a) + position.y;
			float X2 = radius * defines::math->cos(a + Step) + position.x;
			float Y2 = radius * defines::math->sin(a + Step) + position.y;
			V[Count].x = X1;
			V[Count].y = Y1;
			V[Count + 1].x = X2;
			V[Count + 1].y = Y2;
			line(fvector2d{ V[Count].x, V[Count].y }, fvector2d{ X2, Y2 }, color, 1.f);
		}
	}

	void filled_box(fvector2d position, fvector2d size, flinearcolor render_color) {
		for (int i = 0; i < size.y; i++) {
			canvas->k2_draw_line(fvector2d(position.x, position.y + i), fvector2d(position.x + size.x, position.y + i), 1.f, render_color);
		}
	}

	void mouse_cursor() {
		auto cursor = render::controller->get_mouse_position();
		filled_box(fvector2d(cursor.x - 2.5, cursor.y - 2.5), fvector2d(5, 5), flinearcolor(0.f, 0.f, 0.f, 1.f));
	}
}





```

`sdk.h`:

```h
#pragma once


//UPDATE THESE IF CHEAT DOESNT WORK AFTER UPDATE!!

enum offsets : std::int32_t {
	bonematrix = 0xFEC898, // needs to be found in IDA 
	staticfindobject = 0x100FCE8, // needs to be found in IDA
	drawtransition = 113, // needs to be found in IDA
	processevent = 77, // needs to be found in IDA
	offset_get_name = 0x18, // can be found in SDK
	offset_displayname = 0x98, // can be found in SDK
	offset_tier = 0x73, // can be found in SDK
	offset_viewportclient = 0x78, // can be found in SDK
	offset_get_font = 0x70, // can be found in SDK
	offset_get_world = 0x78, // can be found in SDK
	offset_balreadysearched = 0xeea, // can be found in SDK
	offset_clip_x = 0x30, // can be found in SDK
	offset_clip_y = 0x34, // can be found in SDK
	offset_get_item_definition = 0x350 + 0x18, // can be found in SDK
	offset_is_active = 0x2b8, // can be found in SDK
    offset_get_pawn_mesh = 0x318, // can be found in SDK
    offset_input_pitch_scale = 0x534, // can be found in SDK
    offset_input_yaw_scale = 0x530, // can be found in SDK
    offset_get_viewport = 0x78, // can be found in SDK
    offset_get_local_players = 0x38, // can be found in SDK
};


enum fort_item_tier : std::uint8_t {
	No_Tier = 0,
	I = 1,
	II = 2,
	III = 3,
	IV = 4,
	V = 5,
	VI = 6,
	VII = 7,
	VIII = 8,
	IX = 9,
	X = 10,
	NumItemTierValues = 11,
	EFortItemTier_MAX = 12
};

struct ftextdata {
	char pad_0[0x38];
	wchar_t* name;
	__int32 length;
};

struct ftext {
	ftextdata* data;
	char pad_0[0x10];

	wchar_t* c_str() const {
		if (this->data) {
			return data->name;
		}

		return nullptr;
	}
};

template <class type>
struct tarray {
public:
	tarray() { this->data = nullptr; this->count = this->max = 0; };

	type* data;
	std::int32_t count, max;

	type& operator[](int i) {
		return this->data[i];
	};

	int size() {
		return this->count;
	}

	bool valid(int i) {
		return bool(i < this->count);
	}
};

struct fstring : private tarray<wchar_t> {
	fstring() { };
	fstring(const wchar_t* other) {
		this->max = this->count = *other ? static_cast<int>(std::wcslen(other)) + 1 : 0;

		if (this->count)
			this->data = const_cast<wchar_t*>(other);
	};

	wchar_t* c_str() {
		return this->data;
	}

	bool valid() {
		return this->data != nullptr;
	}
};

struct fmatrix {
	double m[4][4];
};

struct fvector {
	fvector() : x(), y(), z() { }
	fvector(double _x, double _y, double _z) : x(_x), y(_y), z(_z) { }

	double x, y, z;

	operator bool() { return bool(this->x && this->y && this->z); }
	bool operator==(fvector in) { return bool(this->x == in.x && this->y == in.y && this->z == in.z); }
	fvector operator+(fvector in) { return fvector(this->x + in.x, this->y + in.y, this->z + in.z); }
	fvector operator-(fvector in) { return fvector(this->x - in.x, this->y - in.y, this->z - in.z); }
};

struct fvector2d {
	fvector2d() : x(), y() { }
	fvector2d(double _x, double _y) : x(_x), y(_y) { }

	double x, y;

	operator bool() { return bool(this->x && this->y); }
	bool operator==(fvector2d in) { return bool(this->x == in.x && this->y == in.y); }
	fvector2d operator+(fvector2d in) { return fvector2d(this->x + in.x, this->y + in.y); }
	fvector2d operator-(fvector2d in) { return fvector2d(this->x - in.x, this->y - in.y); }
};

struct frotator {
	frotator() : pitch(), yaw(), roll() { }
	frotator(double _pitch, double _yaw, double _roll) : pitch(_pitch), yaw(_yaw), roll(_roll) { }

	double pitch, yaw, roll;

	operator bool() { return bool(this->pitch && this->yaw); }
	bool operator==(frotator in) { return bool(this->pitch == in.pitch && this->yaw == in.yaw && this->roll == in.roll); }
	frotator operator+(frotator in) { return frotator(this->pitch + in.pitch, this->yaw + in.yaw, this->roll + in.roll); }
	frotator operator-(frotator in) { return frotator(this->pitch - in.pitch, this->yaw - in.yaw, this->roll - in.roll); }
};

struct flinearcolor {
	flinearcolor() : r(), g(), b(), a() { }
	flinearcolor(float _r, float _g, float _b, float _a) : r(_r), g(_g), b(_b), a(_a) { }

	float r, g, b, a;

	operator bool() { return bool(this->r || this->g || this->b || this->a); }
	bool operator==(flinearcolor in) { return bool(this->r == in.r && this->g == in.g && this->b == in.b && this->a == in.a); }
};

struct fminimalviewinfo {
	fvector location;
	frotator rotation;
	float fov;
};

struct fname {
	fname() : index() { }
	fname(std::uint32_t _index) : index(_index) { }

	std::uint32_t index;
};

struct fkey {
	fname name;
	std::uint8_t details[20];
};



class uobject {
public:
	fname get_name() {
		return read<fname>(std::uintptr_t(this) + offset_get_name);
	}
	static uobject* find_object(const wchar_t* name, uobject* outer = nullptr) {
		return reinterpret_cast<uobject*>(uobject::static_find_objecttwo(nullptr, outer, name));
	}

	static uobject* static_find_objecttwo(uobject* klass, uobject* outer, const wchar_t* name) {
		return reinterpret_cast<uobject * (*)(uobject*, uobject*, const wchar_t*)>(game + offsets::staticfindobject)(klass, outer, name);
	}

	static uobject* static_find_object(uobject* klass, uobject* outer, const wchar_t* name, bool exact) {
		return reinterpret_cast<uobject * (*)(uobject*, uobject*, const wchar_t*, bool)>(game + offsets::staticfindobject)(klass, outer, name, exact);
	}
	void process_event(uobject* function, void* args) {
		auto vtable = *reinterpret_cast<void***>(this);
		reinterpret_cast<void(*)(void*, void*, void*)>(vtable[offsets::processevent])(this, function, args);
	}
};


class ucanvas : public uobject {
public:
	float clip_x() {
		return read<float>(std::uintptr_t(this) + offset_clip_x); //OK
	}

	float clip_y() {
		return read<float>(std::uintptr_t(this) + offset_clip_y); //OK
	}

	fvector2d k2_text_size(uobject* render_font, fstring render_text, fvector2d scale) {
		struct {
			uobject* render_font;
			fstring render_text;
			fvector2d scale;
			fvector2d return_value;
		} params = { render_font, render_text, scale };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"Canvas.K2_TextSize", false);
		this->process_event(function, &params);
		return params.return_value;
	}

	void k2_draw_text(uobject* render_font, fstring render_text, fvector2d screen_position, fvector2d scale, flinearcolor render_color, float kerning, flinearcolor shadow_color, fvector2d shadow_offset, bool center_x, bool center_y, bool outlined, flinearcolor outline_color) {
		struct {
			uobject* render_font;
			fstring render_text;
			fvector2d screen_position;
			fvector2d scale;
			flinearcolor render_color;
			float kerning;
			flinearcolor shadow_color;
			fvector2d shadow_offset;
			bool center_x;
			bool center_y;
			bool outlined;
			flinearcolor outline_color;
		} params = { render_font, render_text, screen_position, scale, render_color, kerning, shadow_color, shadow_offset, center_x, center_y, outlined, outline_color };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"Canvas.K2_DrawText", false);
		this->process_event(function, &params);
	}

	void k2_draw_line(fvector2d screen_position_a, fvector2d screen_position_b, float thickness, flinearcolor render_color) {
		struct {
			fvector2d screen_position_a;
			fvector2d screen_position_b;
			float thickness;
			flinearcolor render_color;
		} params = { screen_position_a, screen_position_b, thickness, render_color };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"Canvas.K2_DrawLine", false);
		this->process_event(function, &params);
	}
};

class uworld : public uobject {
public:

};

class uengine : public uobject {
public:
	uobject* get_font() {
		return read<uobject*>(std::uintptr_t(this) + offset_get_font);
	}
};

class ugameviewportclient : public uobject {
public:
	uworld* get_world() {
		return read<uworld*>(std::uintptr_t(this) + offset_get_world);
	}
};

class item_definition : public uobject {
public:
	//enum class EFortItemTier Tier; // 0x74(0x01)
	fort_item_tier get_tier() {
		return read<fort_item_tier>(std::uintptr_t(this) + offset_tier);
	}

	ftext display_name() {
		return read<ftext>(std::uintptr_t(this) + offset_displayname);
	}
};

struct fortitementry { //0x1a0
	char pad_0[0x18];
	item_definition* item_def;
	char pad_1[0x180];
};

class weapon : public uobject {
public:

	std::int32_t get_magazine_ammo_count() {
		struct {
			std::int32_t return_value;
		} params = { };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"FortWeapon.GetMagazineAmmoCount", false);
		this->process_event(function, &params);
		return params.return_value;
	}

	std::int32_t get_bullets_per_clip() {
		struct {
			std::int32_t return_value;
		} params = { };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"FortWeapon.GetBulletsPerClip", false);
		this->process_event(function, &params);
		return params.return_value;
	}


	item_definition* get_weapon_data() {
		struct {
			item_definition* return_value;
		} params = { };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"FortWeapon.GetWeaponData", false);
		this->process_event(function, &params);
		return params.return_value;
	}
};

class mesh : public uobject {
public:
	std::int32_t get_num_bones() {
		struct {
			std::int32_t return_value;
		} params = { };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"SkinnedMeshComponent.GetNumBones", false);
		this->process_event(function, &params);
		return params.return_value;
	}

	fvector get_bone_location(std::int32_t index) {
		fmatrix out_matrix = { };
		reinterpret_cast<fmatrix* (*)(mesh*, fmatrix*, std::int32_t)>(game + offsets::bonematrix)(this, &out_matrix, index);

		return fvector(out_matrix.m[3][0], out_matrix.m[3][1], out_matrix.m[3][2]);
	}
};

class actor : public uobject {
public:
	void enable_input(uobject* playercontroller) {
		struct {
			uobject* playercontroller;
		} params = { playercontroller };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"Actor.EnableInput", false);
		this->process_event(function, &params);
	}

	bool set_actor_location(fvector new_location, bool sweep, uint8_t sweep_hit_result, bool teleport) {
		static uobject* function;
		if (!function)
			function = uobject::static_find_object(0, 0, L"Actor.K2_SetActorLocation", false);

		struct { fvector a1; bool a2; uint8_t a3; bool a4; bool ret; } params;
		params.a1 = new_location;
		params.a2 = sweep;
		params.a3 = sweep_hit_result;
		params.a4 = teleport;

		this->process_event(function, &params);
		return params.ret;
	}
	
	bool k2_teleport_to(const fvector& DestLocation, const frotator& DestRotation) {
		static uobject* function;
		if (!function)
			function = uobject::static_find_object(0, 0, L"Actor.K2_TeleportTo", false);


		struct
		{
			fvector										DestLocation;                                             // (Parm, ZeroConstructor, IsPlainOldData)
			frotator										DestRotation;                                             // (Parm, ZeroConstructor, IsPlainOldData)
			bool										ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;
		params.DestLocation = DestLocation;
		params.DestRotation = DestRotation;

		this->process_event(function, &params);
		return params.ReturnValue;
	}

	void disable_input(uobject* playercontroller) {
		struct {
			uobject* playercontroller;
		} params = { playercontroller };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"Actor.DisableInput", false);
		this->process_event(function, &params);
	}

	bool was_recently_rendered(float tolerance) {
		struct {
			float tolerance;
			bool return_value;
		} params = { tolerance };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"Actor.WasRecentlyRendered", false);
		this->process_event(function, &params);
		return params.return_value;
	}

	bool set_actor_rotation(frotator new_rotation, bool teleport_physics) {
		struct {
			frotator new_rotation;
			bool teleport_physics;
			bool return_value;
		} params = { new_rotation, teleport_physics };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"Actor.K2_SetActorRotation", false);
		this->process_event(function, &params);
		return params.return_value;
	}

	bool k2_set_actor_location_and_rotation(const fvector& new_location, const frotator& new_rotation, bool b_sweep, bool b_teleport) {
		static uobject* function;
		if (!function)
			function = uobject::static_find_object(0, 0, L"Actor.K2_SetActorLocationAndRotation", false);

		struct aactor_k2_set_actor_location_and_rotation_params
		{
			fvector new_location; // (Parm, ZeroConstructor, IsPlainOldData)
			frotator new_rotation; // (Parm, ZeroConstructor, IsPlainOldData)
			bool b_sweep; // (Parm, ZeroConstructor, IsPlainOldData)
			int sweep_hit_result; // (Parm, OutParm, IsPlainOldData)
			bool b_teleport; // (Parm, ZeroConstructor, IsPlainOldData)
			bool return_value; // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		};

		aactor_k2_set_actor_location_and_rotation_params params{};
		params.new_location = new_location;
		params.new_rotation = new_rotation;
		params.b_sweep = b_sweep;
		params.b_teleport = b_teleport;

		this->process_event(function, &params);
		return params.return_value;
	}

	frotator get_actor_rotation() {
		struct {
			frotator return_value;
		} params = { };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"Actor.K2_GetActorRotation", false);
		this->process_event(function, &params);
		return params.return_value;
	}

	fvector get_actor_location() {
		struct {
			fvector return_value;
		} params = { };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"Actor.K2_GetActorLocation", false);
		this->process_event(function, &params);
		return params.return_value;
	}
};

struct container_struct_0x102a {
	char bForceSpawnLootOnDestruction : 1; // 0x102a(0x01)
	char bForceTossLootOnSpawn : 1; // 0x102a(0x01)
	char bAlreadySearched : 1; // 0x102a(0x01)
	char bGivePickupsDirectlyToPlayer : 1; // 0x102a(0x01)
	char bDoNotDropLootOnDestruction : 1; // 0x102a(0x01)
	char bSkipRollForDestruction : 1; // 0x102a(0x01)
	char pad_102A_6 : 2; // 0x102a(0x01)
};

class container_actor : public actor {
public:
	bool already_searched() {
		return read<container_struct_0x102a>(std::uintptr_t(this) + offset_balreadysearched).bAlreadySearched;
	}
};

class afortvehicle : public actor {
public:


};

class flag_actor : public actor {
public:


};

class trap_actor : public actor {
public:


};

class rift_actor : public actor {
public:


};

class vehicle_actor : public actor {
public:
	fstring get_display_name() {
		struct {
			fstring return_value;
		} params = { };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"FortAthenaVehicle.GetDisplayName", false);
		this->process_event(function, &params);
		return params.return_value;
	}
};
class pickup_actor : public actor {
public:
	item_definition* get_item_definition() {
		return read<item_definition*>(std::uintptr_t(this) + offset_get_item_definition);
	}
};

struct weakspot_struft_0x2b8 {
	char bHit : 1; // 0x2b8(0x01)
	char bFadeOut : 1; // 0x2b8(0x01)
	char bActive : 1; // 0x2b8(0x01)
	char pad_2B8_3 : 5; // 0x2b8(0x01)
};

class weakspot_actor : public actor {
public:
	bool is_active() {
		weakspot_struft_0x2b8 weakspot_struct = read<weakspot_struft_0x2b8>(std::uintptr_t(this) + offset_is_active);
		return weakspot_struct.bActive;
	}
};


class player_pawn : public actor {
public:

	mesh* get_pawn_mesh() {
		return read<mesh*>(std::uintptr_t(this) + offset_get_pawn_mesh);
	}

	bool is_in_vehicle() {
		//IsInVehicle
		static uobject* function;
		if (!function)
			function = uobject::static_find_object(0, 0, L"FortPlayerPawn.IsInVehicle", false);

		struct { bool ret; } params;

		this->process_event(function, &params);
		return params.ret;
	}

	bool is_dead() {
		struct {
			bool return_value;
		} params = { };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"FortPawn.IsDead", false);
		this->process_event(function, &params);
		return params.return_value;
	}

	bool is_dbno() {
		struct {
			bool return_value;
		} params = { };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"FortPawn.IsDBNO", false);
		this->process_event(function, &params);
		return params.return_value;
	}

	char get_team() {
		struct {
			char return_value;
		} params = { };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"FortPawn.GetTeam", false);
		this->process_event(function, &params);
		return params.return_value;
	}


	weapon* get_current_weapon() {
		struct {
			weapon* return_value;
		} params = { };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"FortPawn.GetCurrentWeapon", false);
		this->process_event(function, &params);
		return params.return_value;
	}

	afortvehicle* get_current_vehicle() {
		struct {
			afortvehicle* return_value;
		} params = { };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"FortniteGame.FortPlayerPawn.GetVehicle", false);
		this->process_event(function, &params);
		return params.return_value;
	}

};

class aplayercontroller : public uobject {
public:
	float input_pitch_scale() {
		return read<float>(std::uintptr_t(this) + offset_input_pitch_scale);
	}

	float input_yaw_scale() {
		return read<float>(std::uintptr_t(this) + offset_input_yaw_scale);
	}

	bool is_key_down(fkey key) {
		struct {
			fkey key;
			bool return_value;
		} params = { key };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"PlayerController.IsInputKeyDown", false);
		this->process_event(function, &params);
		return params.return_value;
	}

	static bool is_visible(aplayercontroller* PlayerController, player_pawn* Pawn, fvector* ViewPoint)
	{

		auto subIsVisible = reinterpret_cast<bool(__fastcall*)(aplayercontroller * PlayerController, player_pawn * Pawn, fvector * ViewPoint)>(0x7857C3C); 
		return subIsVisible(PlayerController, Pawn, ViewPoint);

	}


	bool LineOfSightTo(class actor* Other, const struct fvector& ViewPoint)
	{
		struct
		{
			class actor* Other;                                                    // (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
			struct fvector                                    ViewPoint;                                                // (Parm, ZeroConstructor, IsPlainOldData)
			bool                                               bAlternateChecks;                                         // (Parm, ZeroConstructor, IsPlainOldData)
			bool                                               ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;

		params.Other = Other;
		params.ViewPoint = ViewPoint;
		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"Function Engine.Controller.LineOfSightTo", false);
		this->process_event(function, &params);
		return params.ReturnValue;
	}



	bool w2s(fvector world_location, fvector2d* screen_location) {
		struct {
			fvector world_location;
			fvector2d screen_location;
			bool return_value;
		} params = { world_location, fvector2d(), true };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"PlayerController.ProjectWorldLocationToScreen", false);
		this->process_event(function, &params);
		*screen_location = params.screen_location;
		return params.return_value;
	}

	player_pawn* get_pawn() {
		struct {
			player_pawn* return_value;
		} params = { };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"Controller.K2_GetPawn", false);
		this->process_event(function, &params);
		return params.return_value;
	}



	fvector2d get_mouse_position() {
		struct {
			float x;
			float y;
		} params = { };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"PlayerController.GetMousePosition", false);
		this->process_event(function, &params);
		return fvector2d((double)params.x, (double)params.y);
	}

	void add_pitch_input(float val) {
		struct {
			float val;
		} params = { val };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"PlayerController.AddPitchInput", false);
		this->process_event(function, &params);
	}

	void add_yaw_input(float val) {
		struct {
			float val;
		} params = { val };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"PlayerController.AddYawInput", false);
		this->process_event(function, &params);
	}


	void fov(float NewFOV) {
		struct {
			float NewFOV; 
		} params = { NewFOV };
		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"PlayerController.FOV", false);
		params.NewFOV = NewFOV;
		this->process_event(function, &params);
	}

};

class ulocalplayer : public uobject {
public:
	ugameviewportclient* get_viewport() {
		return read<ugameviewportclient*>(std::uintptr_t(this) + offset_get_viewport);
	}
};

class ugameinstance : public uobject {
public:
	tarray<ulocalplayer*> get_local_players() {
		return read<tarray<ulocalplayer*>>(std::uintptr_t(this) + offset_get_local_players);
	}
};

class camera_manager : public uobject {
public:
	//struct FRotator GetCameraRotation(); // Function Engine.PlayerCameraManager.GetCameraRotation

	//struct FVector GetCameraLocation(); // Function Engine.PlayerCameraManager.GetCameraLocation

	frotator get_camera_rotation() {
		struct {
			frotator return_value;
		} params = { };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"PlayerCameraManager.GetCameraRotation", false);
		this->process_event(function, &params);
		return params.return_value;
	}

	fvector get_camera_location() {
		struct {
			fvector return_value;
		} params = { };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"PlayerCameraManager.GetCameraLocation", false);
		this->process_event(function, &params);
		return params.return_value;
	}

	float get_fov_angle() {
		struct {
			float return_value;
		} params = { };

		static uobject* function;
		if (!function) function = uobject::static_find_object(nullptr, nullptr, L"PlayerCameraManager.GetFOVAngle", false);
		this->process_event(function, &params);
		return params.return_value;
	}
};

namespace library {
	class lib_game_statics : public uobject {
	public:
		tarray<uobject*> get_all_actors_of_class(uobject* world_context_object, uobject* actor_class) {
			struct {
				uobject* world_context_object;
				uobject* actor_class;
				tarray<uobject*> out_actors;
			} params = { world_context_object, actor_class };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"GameplayStatics.GetAllActorsOfClass", false);
			this->process_event(function, &params);
			return params.out_actors;
		}

		ugameinstance* get_game_instance(uobject* world_context_object) {
			struct {
				uobject* world_context_object;
				ugameinstance* return_value;
			} params = { world_context_object };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"GameplayStatics.GetGameInstance", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		aplayercontroller* get_player_controller(uobject* world_context_object, std::int32_t player_index) {
			struct {
				uobject* world_context_object;
				std::int32_t player_index;
				aplayercontroller* return_value;
			} params = { world_context_object, player_index };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"GameplayStatics.GetPlayerController", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		double get_world_delta_seconds(uobject* world_context_object) {
			struct {
				uobject* world_context_object;
				double return_value;
			} params = { world_context_object };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"GameplayStatics.GetWorldDeltaSeconds", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		camera_manager* get_player_camera_manager(uobject* world_context_object, std::int32_t player_index) {
			struct {
				uobject* world_context_object;
				std::int32_t player_index;
				camera_manager* return_value;
			} params = { world_context_object, player_index };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"GameplayStatics.GetPlayerCameraManager", false);
			this->process_event(function, &params);
			return params.return_value;
		}
	};

	class lib_system : public uobject {
	public:
		fstring get_object_name(uobject* object) {
			struct {
				uobject* object;
				fstring return_value;
			} params = { object };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetSystemLibrary.GetObjectName", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		const char* get_object_name_char(uobject* object) {
			struct {
				uobject* object;
				const char* return_value;
			} params = { object };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetSystemLibrary.GetObjectName", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		uobject* get_outer_object(uobject* object) {
			struct {
				uobject* object;
				uobject* return_value;
			} params = { object };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetSystemLibrary.GetOuterObject", false);
			this->process_event(function, &params);
			return params.return_value;
		}
	};

	class lib_lib : public uobject {
	public:
		fstring get_player_name_safe(actor* actor, uobject* playernameprivate) {
			struct {
				uobject* actor;
				fstring return_value;
			} params = { actor };

			static uobject* function;
			if (!function) function = playernameprivate;
			this->process_event(function, &params);
			return params.return_value;
		}
	};

	class lib_string : public uobject {
	public:
		fname string_to_name(fstring in_string) {
			struct {
				fstring in_string;
				fname return_value;
			} params = { in_string };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetStringLibrary.Conv_StringToName", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		fstring build_string_double(fstring append_to, fstring prefix, double in_double, fstring suffix) {
			struct {
				fstring append_to;
				fstring prefix;
				double in_double;
				fstring suffix;
				fstring return_value;
			} params = { append_to, prefix, in_double, suffix };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetStringLibrary.BuildString_Double", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		fstring build_string_int(fstring append_to, fstring prefix, std::int32_t in_int, fstring suffix) {
			struct {
				fstring append_to;
				fstring prefix;
				std::int32_t in_int;
				fstring suffix;
				fstring return_value;
			} params = { append_to, prefix, in_int, suffix };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetStringLibrary.BuildString_Int", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		fstring concat_str_str(fstring a, fstring b) {
			struct {
				fstring a;
				fstring b;
				fstring return_value;
			} params = { a, b };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetStringLibrary.Concat_StrStr", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		bool contains(fstring search_in, fstring sub_string, bool use_case, bool search_from_end) {
			struct {
				fstring search_in;
				fstring sub_string;
				bool use_case;
				bool search_from_end;
				bool return_value;
			} params = { search_in, sub_string, use_case, search_from_end };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetStringLibrary.Contains", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		fstring to_upper(fstring source_string) {
			struct {
				fstring search_in;
				fstring return_value;
			} params = { source_string };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetStringLibrary.ToUpper", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		fstring to_lower(fstring source_string) {
			struct {
				fstring search_in;
				fstring return_value;
			} params = { source_string };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetStringLibrary.ToLower", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		bool equal(fstring a, fstring b) {
			struct {
				fstring a;
				fstring b;
				bool return_value;
			} params = { a, b };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetStringLibrary.EqualEqual_StrStr", false);
			this->process_event(function, &params);
			return params.return_value;
		}
	};

	class lib_text : public uobject {
	public:
		//struct FString Conv_TextToString(struct FText& InText); // Function Engine.KismetTextLibrary.Conv_TextToString
	};

	class lib_math : public uobject {
	public:
		double round(double value) {
			return std::round(value);
		}

		double distance2d(fvector2d v1, fvector2d v2) {
			struct {
				fvector2d v1;
				fvector2d v2;
				double return_value;
			} params = { v1, v2 };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetMathLibrary.Distance2D", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		double abs(double a) {
			struct {
				double a;
				double return_value;
			} params = { a };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetMathLibrary.abs", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		double sin(double a) {
			struct {
				double a;
				double return_value;
			} params = { a };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetMathLibrary.sin", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		double cos(double a) {
			struct {
				double a;
				double return_value;
			} params = { a };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetMathLibrary.cos", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		double tan(double a) {
			struct {
				double a;
				double return_value;
			} params = { a };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetMathLibrary.tan", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		double asin(double a) {
			struct {
				double a;
				double return_value;
			} params = { a };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetMathLibrary.asin", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		double acos(double a) {
			struct {
				double a;
				double return_value;
			} params = { a };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetMathLibrary.acos", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		double atan(double a) {
			struct {
				double a;
				double return_value;
			} params = { a };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetMathLibrary.atan", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		double atan2(double y, double x) {
			struct {
				double y;
				double x;
				double return_value;
			} params = { y, x };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetMathLibrary.Atan2", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		double vector_distance(fvector v1, fvector v2) {
			struct {
				fvector v1;
				fvector v2;
				double return_value;
			} params = { v1, v2 };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetMathLibrary.Vector_Distance", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		frotator find_look_at_rotation(fvector start, fvector target) {
			struct {
				fvector start;
				fvector target;
				frotator return_value;
			} params = { start, target };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetMathLibrary.FindLookAtRotation", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		double f_interp_to(double current, double target, double delta_time, double interp_speed) {
			struct {
				double current;
				double target;
				float delta_time;
				float interp_speed;
				frotator return_value;
			} params = { current, target, delta_time, interp_speed };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetMathLibrary.FInterpTo", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		frotator interp_to(frotator current, frotator target, float delta_time, float interp_speed) {
			struct {
				frotator current;
				frotator target;
				float delta_time;
				float interp_speed;
				frotator return_value;
			} params = { current, target, delta_time, interp_speed };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetMathLibrary.RInterpTo", false);
			this->process_event(function, &params);
			return params.return_value;
		}

		frotator interp_to_constant(frotator current, frotator target, float delta_time, float interp_speed) {
			struct {
				frotator current;
				frotator target;
				float delta_time;
				float interp_speed;
				frotator return_value;
			} params = { current, target, delta_time, interp_speed };

			static uobject* function;
			if (!function) function = uobject::static_find_object(nullptr, nullptr, L"KismetMathLibrary.RInterpTo_Constant", false);
			this->process_event(function, &params);
			return params.return_value;
		}
	};
}



namespace defines {
	static library::lib_game_statics* game_statics = nullptr;
	static library::lib_system* system = nullptr;
	static library::lib_string* string = nullptr;
	static library::lib_text* text = nullptr;
	static library::lib_math* math = nullptr;
	static library::lib_lib* lib = nullptr;

	static uobject* actor_player_class = nullptr;
	static uobject* actor_vehicle_class = nullptr;
	static uobject* actor_container_class = nullptr;
	static uobject* actor_pickup_class = nullptr;
	static uobject* actor_weakspot_class = nullptr;
	static uobject* actor_projectile_class = nullptr;
	static uobject* actor_rift_class = nullptr;
	static uobject* actor_marker_class = nullptr;
	static uobject* actor_flag_class = nullptr;
	static uobject* actor_trap_class = nullptr;
	static uobject* actor_player_nameprivate = nullptr;
	static uobject* actor_get_vehicle = nullptr;
	static fkey insert = fkey();
	static fkey space = fkey();
	static fkey enter = fkey();
	static fkey W = fkey();
	static fkey A = fkey();
	static fkey S = fkey();
	static fkey D = fkey();
	static fkey left_mouse_button = fkey();
	static fkey right_mouse_button = fkey();


	static bool init() {
		defines::game_statics = (library::lib_game_statics*)uobject::static_find_object(nullptr, nullptr, L"Engine.Default__GameplayStatics", false);
		defines::system = (library::lib_system*)uobject::static_find_object(nullptr, nullptr, L"Engine.Default__KismetSystemLibrary", false);
		defines::string = (library::lib_string*)uobject::static_find_object(nullptr, nullptr, L"Engine.Default__KismetStringLibrary", false);
		defines::text = (library::lib_text*)uobject::static_find_object(nullptr, nullptr, L"Engine.Default__KismetTextLibrary", false);
		defines::math = (library::lib_math*)uobject::static_find_object(nullptr, nullptr, L"Engine.Default__KismetMathLibrary", false);
		defines::lib = (library::lib_lib*)uobject::static_find_object(nullptr, nullptr, L"FortniteGame.Default__FortKismetLibrary", false);

		defines::actor_player_class = uobject::static_find_object(nullptr, nullptr, L"FortniteGame.FortPlayerPawn", false);
		defines::actor_vehicle_class = uobject::static_find_object(nullptr, nullptr, L"FortniteGame.FortAthenaVehicle", false);
		defines::actor_container_class = uobject::static_find_object(nullptr, nullptr, L"FortniteGame.BuildingContainer", false);
		defines::actor_pickup_class = uobject::static_find_object(nullptr, nullptr, L"FortniteGame.FortPickup", false);
		defines::actor_weakspot_class = uobject::static_find_object(nullptr, nullptr, L"FortniteGame.BuildingWeakSpot", false);
		defines::actor_projectile_class = uobject::static_find_object(nullptr, nullptr, L"FortniteGame.FortProjectileBase", false);
		defines::actor_rift_class = uobject::static_find_object(nullptr, nullptr, L"FortniteGame.FortAthenaRiftPortal", false);
		defines::actor_marker_class = uobject::static_find_object(nullptr, nullptr, L"FortniteGame.FortWorldMarker", false);
		defines::actor_flag_class = uobject::static_find_object(nullptr, nullptr, L"FortniteGame.FortFlag", false);
		defines::actor_trap_class = uobject::static_find_object(nullptr, nullptr, L"FortniteGame.BuildingTrap", false);
		defines::actor_player_nameprivate = uobject::static_find_object(nullptr, nullptr, L"FortKismetLibrary.GetPlayerNameSafe", false);
		defines::actor_get_vehicle = uobject::static_find_object(nullptr, nullptr, L"FortniteGame.FortPlayerPawn.GetVehicle", false);


		defines::insert = fkey{ defines::string->string_to_name(L"Insert"), 0 };
		defines::space = fkey{ defines::string->string_to_name(L"SpaceBar"), 0 };
		defines::enter = fkey{ defines::string->string_to_name(L"Enter"), 0 };
		defines::W = fkey{ defines::string->string_to_name(L"W"), 0 };
		defines::A = fkey{ defines::string->string_to_name(L"A"), 0 };
		defines::S = fkey{ defines::string->string_to_name(L"S"), 0 };
		defines::D = fkey{ defines::string->string_to_name(L"D"), 0 };
		defines::left_mouse_button = fkey{ defines::string->string_to_name(L"LeftMouseButton"), 0 };
		defines::right_mouse_button = fkey{ defines::string->string_to_name(L"RightMouseButton"), 0 };

		return true;
	}
}
```

`settings.h`:

```h
#pragma once

namespace settings {
	namespace bones
	{
		bool head = true;
		bool neck = false;
		bool torso = false;
		bool pelvis = false;
	}

	namespace aimbot {

		bool enable = false;
		bool bulletp = false;
		bool memory = false;
		bool mouse = false;
		bool silent = false;
		bool sticky_silent = false;
		bool interpolate = false;
		bool constant = false;
		bool show_fov = false;
		bool visible_only = false;
		bool target_line = false;
		float mouse_speed = 5;
		float interpolate_speed = 5;
		float field_of_view = 20;
	}

	namespace player {
		bool enable = false;
		bool skeleton = false;
		bool box = true;
		bool normal_box = false;
		bool cornered_box = false;
		bool snapline = false;
		bool eyes = false;
		bool player_name = false;
		bool active_weapon = false;
		bool display_distance = false;
		float max_distance = 350;
	}

	namespace containers {
		bool enable = false;
		bool ignore_opened = false;
		bool display_distance = false;
		bool lines = false;
		bool chest = false;
		bool ammo_box = false;
		bool cooler_and_food = false;
		bool safe = false;
		bool others = false;
		float max_distance = 450;
		float line_offset = 20;
	}

	namespace pickups {
		bool enable = false;
		bool display_distance = false;
		bool lines = false;
		bool common = false;
		bool uncommon = false;
		bool rare = false;
		bool epic = false;
		bool legendary = false;
		bool mythic = false;
		float max_distance = 450;
		float line_offset = 20;
	}

	namespace weakspot {
		bool enable = false;
		bool weakspot_aimbot = false;
		bool silent = false;
		bool interpolate = false;
		bool constant = false;
		bool target_line = false;
		float interpolate_speed = 1;
	}

	namespace radar {
		bool enable = false;
		bool show_line_of_sight = false;
		bool useless_circle = false;
		bool players = false;
		bool containers = false;
		bool pickups = false;
		bool vehicles = false;
		float range = 10;
		float positionx = 50;
		float positiony = 50;
		float size = 200;
	}

	namespace exploits {
		bool enable_hooks = false;
		bool enable_patches = false;
		bool spinbot = false;
		bool fov_changer = false;
		float fov_value = 110;
	}

	namespace miscellaneous {
		bool vehiclefly = false;
		float vehicle_flight_speed = 50;
		bool fovchanger = false;
		float fovslider = 105;
	}
	
	namespace rifts {
		bool enable = false;
		bool display_distance = false;
		float max_distance = 150;
	}

	namespace miscactors {
		bool enable = false;
		bool display_distance = false;
		float max_distance = 150;
		bool vehicles = false;
		bool rifts = false;
		bool flags = false;
		bool traps = false;

	}
	namespace vehicles {
		bool enable = false;
		bool display_distance = false;
		float max_distance = 150;
	}

	namespace style {
		bool text_outlined = false;
		bool performance = false;
	}
}
```

`vmthook.h`:

```h
#pragma once
template <typename hook_type>
_declspec(noinline) hook_type vmt(std::uintptr_t address, std::uintptr_t hook_function, int index) {
	auto vtable = *(std::uintptr_t**)address;

	int vtable_size = 0;
	do vtable_size += 1;
	while (*(std::uintptr_t*)(std::uintptr_t(vtable) + (vtable_size * 8)));

	auto original_virtual_function = (void*)vtable[index];

	std::uintptr_t* fake_vtable = new std::uintptr_t[vtable_size * 8];

	for (int i = 0; i < vtable_size; i++) {
		if (i == index) continue;
		fake_vtable[i] = *(std::uintptr_t*)(std::uintptr_t(vtable) + (i * 8));
	} fake_vtable[index] = hook_function;

	*(std::uintptr_t**)address = fake_vtable;

	return hook_type(original_virtual_function);
}
```