Project Path: arc_gmh5225_Fenrir__60btb1h

Source Tree:

```txt
arc_gmh5225_Fenrir__60btb1h
├── LICENSE
├── README.md
├── ansible
│   └── fenrir-ansible-playbook.yml
├── c2-iocs.txt
├── demo
│   ├── evil.jsp
│   └── mal-content.asp
├── fenrir.sh
├── filename-iocs.txt
├── hash-iocs.txt
├── requirements.txt
├── screens
│   ├── fenrir1.png
│   ├── fenrir2.png
│   ├── fenrir3.png
│   ├── fenrir4.png
│   ├── fenrir5.png
│   └── stat1.png
└── string-iocs.txt

```

`LICENSE`:

```
The MIT License (MIT)

Copyright (c) 2015 Florian Roth

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


```

`README.md`:

```md
[![Active Development](https://img.shields.io/badge/Maintenance%20Level-Actively%20Developed-brightgreen.svg)](https://gist.github.com/cheerfulstoic/d107229326a01ff0f333a1d3476e068d)

# Fenrir
Simple Bash IOC Scanner

Fenrir is a simple IOC scanner bash script. It allows scanning Linux/Unix/OSX systems for the following Indicators of Compromise (IOCs):

- Hashes

   MD5, SHA1 and SHA256 (using md5sum, sha1sum, sha -a 256)

- File Names 

   string - checked for substring of the full path, e.g. "temp/p.exe" in "/var/temp/p.exe"

- Strings

   grep in files
   
- C2 Server
   
   checking for C2 server strings in 'lsof -i' and 'lsof -i -n' output  

- Hot Time Frame

   using stat in different modes - define min and max epoch time stamp and get all files that have been created in between
   
Basic characteristics:
- Bash Script
- No installation or agent needed
- Uses common tools to extract attributes (e.g. md5sum, grep, stat in different modes)
- Intended to run on any Linux / Unix / OS X with Bash
- Low footprint - Ansible playbook with RAM drive solution
- Smart exclusions (file size, extension, certain directories) speeds up the scan process

# Why Fenrir?
FENRIR is the 3rd tool after THOR and LOKI. [THOR](http://www.bsk-consulting.de/apt-scanner-thor/) is our full featured APT Scanner with many modules and export types for corporate customers. [LOKI](https://github.com/Neo23x0/Loki) is a free and open IOC scanner that uses [YARA](https://plusvic.github.io/yara/) as signature format. 

The problem with both predecessors is that both have certain requirements on the Linux platform. We build THOR for a certain Linux version in order to match the correct libc that is required by the YARA module. LOKI requires Python and YARA installed on Linux to run.

We faced the problem of checking more than 100 different Linux systems for certain Indicators of Compromise (IOCs) without installing an agent or software packages. We already had an [Ansible](http://www.ansible.com/) playbook for the distribution of THOR on a defined set of Linux remote systems. This playbook creates a RAM drive on the remote system, copies the local program binary to the remote system, runs it and retrieves the logs afterwards. This ensures that the program's footprint on the remote system is minimal. I adapted the Ansible playbook for Fenrir. (it is still untested)

Fenrir is still 'testing'. Please report back errors (and solutions) via the "Issues" section here on github. 

If you find a better / more solid / less error-prone solution to the evaluations in the script, please report them back. I am not a full-time bash programmer so I'd expect some room for improvement. 

# Usage

```
Usage: ./fenrir.sh DIRECTORY
 
DIRECTORY - Start point of the recursive scan
```

All settings can be configured in the header of the script.

![Settings](./screens/fenrir2.png)

# Step by Step

What Fenrir does is:
- Reads the IOC files
- Takes a parameter as starting directory for the recursive walk
- Checks C2 servers in lsof output
- Checks for directory exclusions (configurable in the script header)
- Checks for certain file extensions to check (configurable in the script header)
- Checks the file name (full path) for matches in IOC files
- Checks for file size exclusions (configurable in the script header)
- Checks for certain strings in the file (via grep)
- Checks for certain hash values 
- Checks for change/creation time stamp 

# Screenshots

Scan Run showing the different match types on a demo directory. 

![Scan Run](./screens/fenrir1.png)

Detect C2 connections

![Ansible Playbook](./screens/fenrir4.png)

Detect strings in GZIP packed log files

![Strings in GZP Logs](./screens/fenrir5.png)

Configuration

![Configuration](./screens/fenrir2.png)

Ansible Playbook

![Ansible Playbook](./screens/fenrir3.png)

Stat issue (regarding the CREATED file stamp on Linux file systems)

![Stat issue](./screens/stat1.png)

# Known Issues

# Contact 

via Twitter @Cyb3rOps

```

`ansible/fenrir-ansible-playbook.yml`:

```yml
---
- hosts: all

  tasks:
    - name: Fenrir
      block:
        - name: Create folder for temporary RAM drive
          ansible.builtin.file:
            path: /mnt/temp_ram
            state: directory
            owner: root
            group: root
            mode: "u=rwx,g=,o="

        - name: Create Fenrir RAM drive on target
          ansible.posix.mount:
            path: /mnt/temp_ram/
            src: ramfs
            fstype: ramfs
            opts: size=30M
            state: mounted

        # copy is slow, but synchronize doesn't work with `become: yes`
        # I suppose using `become: no` is an option, if /mnt/temp_ram was owned
        # by {{ ansible_user }}
        - name: Copy Fenrir to RAM drive
          ansible.builtin.copy:
            src: "{{ playbook_dir }}/.."
            dest: /mnt/temp_ram/
            owner: root
            group: root

        - name: Make Fenrir Executeable
          ansible.builtin.file:
            path: /mnt/temp_ram/fenrir.sh
            state: touch
            mode: "u=rx,g=rx,o=rx"

        - name: Execute Fenrir
          shell:
            cmd: /mnt/temp_ram/fenrir.sh / > /mnt/temp_ram/fenrir.log

        - name: Fetch Log file
          ansible.builtin.fetch:
            src: /mnt/temp_ram/fenrir.log
            dest: ./

        - name: Unmount temporary RAM drive
          ansible.posix.mount:
            path: /mnt/temp_ram/
            state: unmounted

        - name: Delete folder for temporary RAM drive
          ansible.builtin.file:
            path: /mnt/temp_ram/
            state: absent
      become: yes
      when: ansible_system == "Linux"

```

`c2-iocs.txt`:

```txt
bingsearchlib.com
34.198.182.201
canarytokens.com
52.18.63.80
log4j.binaryedge.io
134.209.163.248
leakix.net
167.71.13.196
dnslog.cn
47.244.138.18
kryptoslogic-cve-2021-44228.com
167.99.86.185
interact.sh
46.101.25.250
# END
```

`demo/evil.jsp`:

```jsp
# This is not en evil file - just for demonstration purposes

```

`demo/mal-content.asp`:

```asp
# THIS
<%eval request("ice")%>
# END

```

`fenrir.sh`:

```sh
#!/bin/bash
#
# FENRIR
# Simple Bash IOC Checker
# Florian Roth

VERSION="0.9.0-log4shell"

# Settings ------------------------------------------------------------
SYSTEM_NAME=$(uname -n | tr -d "\n")
TS_CONDENSED=$(date +%Y%m%d)

# IOCs
HASH_IOC_FILE="./hash-iocs.txt"
STRING_IOCS="./string-iocs.txt"
FILENAME_IOCS="./filename-iocs.txt"
C2_IOCS="./c2-iocs.txt"

# Log
LOGFILE="./FENRIR_${SYSTEM_NAME}_${TS_CONDENSED}.log"
LOG_TO_FILE=1
LOG_TO_SYSLOG=0 # Log to syslog is set to 'off' by default > false positives
LOG_TO_CMDLINE=1
SYSLOG_FACILITY=local4

# Enable / Disable Checks
ENABLE_C2_CHECK=1
ENABLE_TYPE_CHECK=1
ENABLE_HASH_CHECK=1

# Exclusions
MAX_FILE_SIZE=8000 # max file size to check in kilobyte, default 2 MB
CHECK_ONLY_RELEVANT_EXTENSIONS=1 # ELF binaries get always checked
declare -a RELEVANT_EXTENSIONS=('jsp' 'jspx' 'txt' 'tmp' 'pl' 'war' 'sh' 'log' 'jar'); # use lower-case
# files in these directories will be checked with string grep
# regradless of their size and extension
declare -a EXCLUDED_DIRS=('/proc/' '/initctl/' '/dev/' '/media/');
# Force Checks
declare -a FORCED_STRING_MATCH_DIRS=('/var/log/' '/etc/hosts' '/etc/crontab');
# Exclude all output lines that contain these strings
declare -a EXCLUDE_STRINGS=('iocs.txt' 'fenrir');

# global var for passing pseudo hash
declare -i pseudo_h

# Hot Time Frame Check
MIN_HOT_EPOCH=1444163570 # minimum Unix epoch for hot time frame e.g. 1444160522
MAX_HOT_EPOCH=1444163590 # maximum Unix epoch for hot time frame e.g. 1444160619
CHECK_FOR_HOT_TIMEFRAME=0

# Debug
DEBUG=0

# Code ----------------------------------------------------------------

# Global vars
declare -a hash_iocs
declare -a pseudo_hash_iocs
declare -a hash_ioc_description
declare -a string_iocs
declare -a check_strings
declare -a filename_iocs
declare -a c2_iocs
# declare grep_strings

function scan_dirs
{
    # Scan Dir
    scandir=$1

    # Debug Output --------------------------------------------
    log debug "Scanning $scandir ..."

    # Cleanup trailing "/" in the most compatible way
    if [ "${scandir: -1}" == "/" ] && [ "${#scandir}" -gt 1 ]; then
        scandir="${scandir:0:${#scandir}-1}"
    fi

    # Loop through files
    find "$scandir" -type f 2> /dev/null | while read -r file_path
    do
        if [ -f "${file_path}" ]; then

            # Debug Output --------------------------------------------
            log debug "Scanning $file_path ..."

            # Marker --------------------------------------------------
            DO_STRING_CHECK=1
            DO_HASH_CHECK=1
            DO_DATE_CHECK=1
            DO_FILENAME_CHECK=1

            # Evaluations ---------------------------------------------
            file_name=$(basename "$file_path")
            extension="${file_name##*.}"

            # Checks to disable modules -------------------------------

            # Excluded Directories
            result=$(check_dir "$file_path")
            if [ "${result}" -eq 1 ]; then
                log debug "Skipping $file_path due to exclusion ..."
                DO_STRING_CHECK=0
                DO_HASH_CHECK=0
                DO_DATE_CHECK=0
                DO_FILENAME_CHECK=0
            fi
            
            # Check if relevant type
            if [ $ENABLE_TYPE_CHECK -eq 1 ]; then
                relevant_type=$(file "$file_path" | grep -F "ELF")
            fi

            # Exclude Extensions
            if [ $CHECK_ONLY_RELEVANT_EXTENSIONS -eq 1 ] && [ "$relevant_type" == "" ]; then
                result=$(check_extension "$extension")
                if [ "${result}" -ne 1 ]; then
                    log debug "Deactivating some checks on $file_path due to irrelevant extension ..."
                    DO_STRING_CHECK=0
                    DO_HASH_CHECK=0
                fi
            fi

            # Check Size
            filesize=$(du -k "$file_path" | cut -f1)
            if [ "${filesize}" -gt $MAX_FILE_SIZE ]; then
                log debug "Deactivating some checks on $file_path due to size"
                DO_STRING_CHECK=0
                DO_HASH_CHECK=0
            fi

            # Checks to include modules -------------------------------

            # Forced string check directory
            for fsm_dir in "${FORCED_STRING_MATCH_DIRS[@]}";
            do
                # echo "Checking if $ex_dir is in $dir"
                # The following check matches when $fsm_dir is ANYWHERE in the
                # $file_path, not only at the beginning. As we're just doing
                # more checks in that case, we don't care
                if [ "${file_path/$fsm_dir}" != "$file_path" ]; then
                    DO_STRING_CHECK=1
                    log debug "Activating string check on $file_name"
                fi
            done

            # Checks --------------------------------------------------

            # File Name Check
            if [ $DO_FILENAME_CHECK -eq 1 ]; then
                check_filename "$file_path"
            fi

            # String Check
            if [ $DO_STRING_CHECK -eq 1 ]; then
                check_string "$file_path" "$extension"
            fi

            # Hash Check
            if [ $DO_HASH_CHECK -eq 1 ] && [ $ENABLE_HASH_CHECK -eq 1 ]; then
                md5=$(md5sum "$file_path" 2> /dev/null | cut -f1 -d' ')
                #md5tmp=$(md5sum "$file_path" 2> /dev/null)
                #md5=${md5tmp%% *}
                sha1=$(sha1sum "$file_path" 2> /dev/null | cut -f1 -d' ')
                sha256=$(sha256sum "$file_path" 2> /dev/null | cut -f1 -d' ')
                log debug "Checking hashes of file $file_path : $md5"
                check_pseudo_hashes "$md5" "$sha1" "$sha256" "$file_path"
            fi

            # Date Check
            if [ $CHECK_FOR_HOT_TIMEFRAME -eq 1 ] && [ $DO_DATE_CHECK -eq 1 ]; then
                check_date "$file_path"
            fi
        fi


    done
    IFS=$oldIFS
}

# Check Functions -----------------------------------------------------

function check_pseudo_hashes
{
    local md5=$1
    local sha1=$2
    local sha256=$3
    local filepath=$4

    hashes=(${md5} ${sha1} ${sha256})
    for hash in "${hashes[@]}";
        do
        pseudo_hash "$hash"
        if [ -n "${pseudo_hash_iocs[$pseudo_h]}" ]; then
            # TODO change to "log debug"
            log debug "[+] Pseudo hash match on $file_path pseudo hash: $pseudo_h real hash will be checked now: $hash"

            check_hashes "$hash" "$file_path"
        fi
    done
}

function check_hashes
{
    local index=0
	local check_hash=$1
    #local md5=$1
    #local sha1=$2
    #local sha256=$3
    local filepath=$2

    for hash in "${hash_iocs[@]}";
    do
        #echo "Comparing $hash with $md5"
        if [ "$check_hash" == "$hash" ]; then
            description=${hash_ioc_description[$index]}
            log warning "[!] Hash match found FILE: $filepath HASH: $hash DESCRIPTION: $description"
        fi
        #if [ "$sha1" == "$hash" ]; then
            #description=${hash_ioc_description[$index]}
            #log warning "[!] Hash match found FILE: $filepath HASH: $hash DESCRIPTION: $description"
        #fi
        #if [ "$sha256" == "$hash" ]; then
            #description=${hash_ioc_description[$index]}
            #log warning "[!] Hash match found FILE: $filepath HASH: $hash DESCRIPTION: $description"
        #fi
        index=$((index+1))
    done
}

function check_string
{
    local filepath=$1
    local extension=$2
    local varlog="/var/log"

    # echo "Greping $string in $1"
    match=$(grep -F "$check_strings" "$filepath" 2> /dev/null)
    # Cut big matches (fixes buges in super long web shell lines without line breaks)
    match=$(echo "$match" |cut -c1-100)

    # if [[ ! -z "${match// }" ]] ; then
    if [ "$match" != "" ]; then
        string=$(determine_stringmatch "$match")
        log warning "[!] String match found FILE: $filepath STRING: $string TYPE: plain MATCH: $match"
    fi
    # Try zgrep on gz files below /var/log
    if [ "$extension" == "gz" ] || [ "$extension" == "Z" ] || [ "$extension" == "zip" ]; then
        if [ "${filepath/$varlog}" != "$filepath" ]; then
            match=$(zgrep -F "$check_strings" "$filepath" 2> /dev/null)
            if [ "$match" != "" ]; then
                string=$(determine_stringmatch "$match")
                match_extract=$(echo "$match" |cut -c1-100)
                size_of_match=${#match}
                if [ "$size_of_match" -gt 100 ]; then
                    match_extract="$match_extract ... (truncated)"
                fi
                log warning "[!] String match found FILE: $filepath STRING: $string TYPE: gzip MATCH: $match_extract"
            fi
        fi
    fi
    # Try bzgrep on bz files below /var/log
    if [ "$extension" == "bz" ] || [ "$extension" == "bz2" ]; then
        if [ "${filepath/$varlog}" != "$filepath" ]; then
            match=$(bzgrep -F "$check_strings" "$filepath" 2> /dev/null)
            if [ "$match" != "" ]; then
                string=$(determine_stringmatch "$match")
                match_extract=$(echo "$match" |cut -c1-100)
                size_of_match=${#match}
                if [ "$size_of_match" -gt 100 ]; then
                    match_extract="$match_extract ... (truncated)"
                fi
                log warning "[!] String match found FILE: $filepath STRING: $string TYPE: bzip2 MATCH: $match_extract"
            fi
        fi
    fi
}

function determine_stringmatch
{
    for string in "${string_iocs[@]}";
    do
        if [ "${1/$string}" != "$1" ]; then
            echo "$string"
            return 0
        fi
    done
    for string in "${c2_iocs[@]}";
    do
        if [ "${1/$string}" != "$1" ]; then
            echo "$string"
            return 0
        fi
    done
    echo "(binary match)"
}

function check_filename
{
    for filename in "${filename_iocs[@]}";
    do
        if [ "${1/$filename}" != "$1" ]; then
            log warning "[!] Filename match found FILE: $1 INDICATOR: $filename"
        fi
    done
}

function check_extension
{
    extension=$(echo "$1" | tr '[:upper:]' '[:lower:]')
    result=0
    for ext in "${RELEVANT_EXTENSIONS[@]}";
    do
        # echo "Comparing $extension with $ext"
        if [ "$extension" == "$ext" ]; then
            result=1
        fi
    done
    echo "$result"
}

function check_date
{
    local filepath="$1"
    local file_epoch=123 # dummy value
    if [ "$stat_mode" -eq 1 ]; then
        file_epoch=$(stat -c '%Z' "$filepath")
    else
        local st_ctime="$file_epoch"
        eval "$(stat -s "$filepath")"
        file_epoch="$st_ctime"
    fi
    # echo "$file_epoch"
    if [ "$file_epoch" -gt "$MIN_HOT_EPOCH" ] && [ "$file_epoch" -lt "$MAX_HOT_EPOCH" ]; then
        log warning "[!] File changed/created in hot time frame FILE: $filepath EPOCH: $file_epoch"
    fi
}

function check_dir
{
    dir=$1
    result=0
    for ex_dir in "${EXCLUDED_DIRS[@]}";
    do
        # echo "Checking if $ex_dir is in $dir"
        if [ "${dir/$ex_dir}" != "$dir" ]; then
            if [ "${dir/#$ex_dir}" = "$dir" ];then
                log debug "Skipping $dir due to WRONG exclusion bc/ $ex_dir in the middle of the path..."
            fi
            result=1
        fi
    done
    echo $result
}

# Analysis --------------------------------------------------------------------
function scan_c2
{
    oldIFS=$IFS
    IFS=$'\n'
    # Don't resolve names
    lsof_output=$(lsof -i -n)
    for lsof_line in ${lsof_output}; do
        for c2 in "${c2_iocs[@]}"; do
            # C2 check
            if [ "${lsof_line/$c2}" != "$lsof_line" ]; then
                log warning "[!] C2 server found in lsof output SERVER: $c2 LSOF_LINE: $lsof_line"
            fi
        done
        # Shell Check 
        if [ "${lsof_line:0:5}" == "bash " ] || [ "${lsof_line:0:3}" == "sh " ]; then
            if [ "${lsof_line/127.0.0.1}" == "$lsof_line" ]; then
                log notice "[!] Shell found in lsof output - could be a back connect shell LSOF_LINE: $lsof_line"
            fi
        fi
    done
    # Resolve names
    lsof_output=$(lsof -i)
    for lsof_line in ${lsof_output}; do
        for c2 in "${c2_iocs[@]}"; do
            # echo "$lsof_line - $c2"
            if [ "${lsof_line/$c2}" != "$lsof_line" ]; then
                log warning "[!] C2 server found in lsof output SERVER: $c2 LSOF_LINE: $lsof_line"
            fi
        done
    done
    IFS=$oldIFS
}

# Helpers -------------------------------------------------------------

function evaluate_stat_mode
{
    # Check if Linux mode works
    local result
    result=$(stat -c '%Z' "$0" 2>&1)
    local marker="illegal option"
    if [ "${result/$marker}" != "$result" ]; then
        log info "[+] Setting stat mode to Unix / OS X"
        stat_mode=2
    else
        log info "[+] Setting stat mode to Linux"
        stat_mode=1
    fi
}

function timestamp {
  date +%F_%T
}

function log {
    local type="$1"
    local message="$2"
    local ts
    ts=$(timestamp)

    # Only report debug messages if mode is enabled
    if [ "$type" == "debug" ] && [ $DEBUG -ne 1 ]; then
        return 0
    fi

    # Exclude certain strings (false positives)
    for ex_string in "${EXCLUDE_STRINGS[@]}";
    do
        # echo "Checking if $ex_string is in $message"
        if [ "${message/$ex_string}" != "$message" ]; then
            return 0
        fi
    done

    # Remove line breaks
    message=$(echo "$message" | tr -d '\r' | tr '\n' ' ') 

    # Remove prefix (e.g. [+])
    if [[ "${message:0:1}" == "[" ]]; then
        message_cleaned="${message:4:${#message}}"
    else
        message_cleaned="$message"
    fi

    # Log to file
    if [[ $LOG_TO_FILE -eq 1 ]]; then
        echo "$ts $type $message_cleaned" >> "$LOGFILE"
    fi
    # Log to syslog
    if [[ $LOG_TO_SYSLOG -eq 1 ]]; then
        logger -p "$SYSLOG_FACILITY.$type" "$(basename "$0"): $message_cleaned"
    fi
    # Log to command line
    if [[ $LOG_TO_CMDLINE -eq 1 ]]; then
        echo "$message" >&2
    fi
}

# READ IOCS -----------------------------------------------------------

function pseudo_hash {
    local hash=$1
    #echo hash: $hash

    short_hash="0x${hash:0:8}"
    let pseudo_h=$(($short_hash))

    # use global var to save the fork of /bin/echo
    #echo $pseudo_h
}		


function read_hashes_iocs
{
    # Save field separator
    oldIFS="$IFS"
    IFS=$'\n'
    local index=0
    while read -r line ; do
        #hash=$(echo "$line" | cut -f1 -d';')
        #description=$(echo "$line" | cut -f2 -d';')
        hash=${line%;*}
        if [[ -z "${hash// }" ]] ; then
            continue
        fi

        # Skip comments
        if [[ $line == \#* ]] ; then
            continue
        fi
        description=${line#*;}

        hash_iocs[$index]="$hash"
        hash_ioc_description[$index]="$description"

        # changes global var $pseudo_h
        pseudo_hash "$hash"
        # assigning the real hash value to the pseudo hash array. beware: there might be collisions so only the last one is in there!
        #echo $pseudo_h
        pseudo_hash_iocs[$pseudo_h]=$hash

        # echo "$hash $description"
        index=$((index+1))
    done < $HASH_IOC_FILE
    IFS=$oldIFS
}

function read_string_iocs
{
    # Save field separator
    oldIFS="$IFS"
    IFS=$'\n'
    local index=0
    while read -r line ; do
        # Skip empty values
        if [[ -z "${line// }" ]] ; then
            continue
        fi
        # Skip comments
        if [[ $line == \#* ]] ; then
            continue
        fi
        string_iocs[$index]="$line"
        # echo "$line"
        index=$((index+1))
    done < $STRING_IOCS
    # Prepare grep strings - tried to concatenate a complete string, failed - todo
    # grep_strings=$(prepare_grep_strings)
    # echo $grep_strings
    IFS=$oldIFS
}

function read_filename_iocs
{
    # Save field separator
    oldIFS="$IFS"
    IFS=$'\n'
    local index=0
    while read -r line ; do
        if [[ -z "${line// }" ]] ; then
            continue
        fi
        filename_iocs[$index]="$line"
        # echo "$line"
        index=$((index+1))
    done < $FILENAME_IOCS
    IFS=$oldIFS
}

function read_c2_iocs
{
    # Save field separator
    oldIFS="$IFS"
    IFS=$'\n'
    local index=0
    while read -r line ; do
        if [[ -z "${line// }" ]] ; then
            continue
        fi
        c2_iocs[$index]="$line"
        # echo "$line"
        index=$((index+1))
    done < $C2_IOCS
    IFS=$oldIFS
}

function prepare_check_stings
{
    # New method - create a string with values divided by new line for use in 'grep -F' 
    check_strings=$(
        for string in "${string_iocs[@]}";
        do
            echo "$string"
        done

        # Add C2 iocs if directory is log directory
        for string in "${c2_iocs[@]}";
        do
            echo "$string"
        done
    )
}

function check_req 
{
    log info "Checking the required utilities ..."
    file_avail=$(command -v file)
    if [[ -z $file_avail ]]; then 
        log error "The 'file' command can't be found (disabling file type checks)"
        ENABLE_TYPE_CHECK=0
    fi
    lsof_avail=$(command -v lsof)
    if [[ -z $lsof_avail ]]; then 
        log error "The 'lsof' command can't be found (disabling C2 checks)"
        ENABLE_C2_CHECK=0
    fi
    md5sum_avail=$(command -v md5sum)
    if [[ -z $md5sum_avail ]]; then 
        log error "The 'md5sum' command can't be found (disabling hash checks)"
        ENABLE_HASH_CHECK=0
    fi
}


# Program -------------------------------------------------------------

echo "##############################################################"
echo "    ____             _     "
echo "   / __/__ ___  ____(_)___ "
echo "  / _// -_) _ \/ __/ / __/ "
echo " /_/  \__/_//_/_/ /_/_/    "
echo " v$VERSION"
echo " "
echo " Simple Bash IOC Checker"
echo " Florian Roth, Dec 2021"
echo "##############################################################"

if [ "$#" -ne 1 ]; then
    echo " "
    echo "[E] Error - not enough parameters"
    echo "    Usage: $0 DIRECTORY" >&2
    echo " "
    echo "    DIRECTORY - Start point of the recursive scan"
    echo " "
    exit 1
fi

# Non-static global variables
declare stat_mode=1

log info "Started FENRIR Scan - version $VERSION"
log info "Writing logfile to ${LOGFILE}"
log info "HOSTNAME: ${SYSTEM_NAME}"

IP_ADDRESS=$(ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1' | tr '\n' ' ')
OS_RELEASE=$(cat /etc/*release | sort -u | tr "\n" ";")
OS_ISSUE=$(cat /etc/issue)
OS_KERNEL=$(uname -a)

log info "IP: $IP_ADDRESS"
log info "OS: $OS_RELEASE"
log info "ISSUE: $OS_ISSUE"
log info "KERNEL: $OS_KERNEL"

# Evaluate which stat mode to use
evaluate_stat_mode

# Check requirements
check_req

# Read all IOCs
log info "[+] Reading Hash IOCs ..."
read_hashes_iocs
log info "[+] Reading String IOCs ..."
read_string_iocs
prepare_check_stings
log info "[+] Reading Filename IOCs ..."
read_filename_iocs
log info "[+] Reading C2 IOCs ..."
read_c2_iocs

# Now scan the given first parameter
if [ $ENABLE_C2_CHECK -eq 1 ]; then
    log info "[+] Scanning for C2 servers in 'lsof' output ..."
    scan_c2
fi
log info "[+] Scanning path $1 ..."
scan_dirs "$1"
log info "Finished FENRIR Scan"

```

`filename-iocs.txt`:

```txt
log4j-core
# END - DO NOT REMOVE
```

`hash-iocs.txt`:

```txt
2addabe2ceca2145955c02a6182f7fc5;Vulnerable Log4j version ./apache-log4j-2.0-alpha2-bin/log4j-core-2.0-alpha2.jar
5b1d4e4eea828a724c8b0237326829b3;Vulnerable Log4j version ./apache-log4j-2.0-beta1-bin/log4j-core-2.0-beta1.jar
ce9e9a27c2a5caa47754999eb9c549b8;Vulnerable Log4j version ./apache-log4j-2.0-beta2-bin/log4j-core-2.0-beta2.jar
1538d8c342e3e2a31cd16e01e3865276;Vulnerable Log4j version ./apache-log4j-2.0-beta3-bin/log4j-core-2.0-beta3.jar
9cb138881a317a7f49c74c3e462f35f4;Vulnerable Log4j version ./apache-log4j-2.0-beta4-bin/log4j-core-2.0-beta4.jar
578ffc5bcccb29f6be2d23176c0425e0;Vulnerable Log4j version ./apache-log4j-2.0-beta5-bin/log4j-core-2.0-beta5.jar
5b73a0ad257c57e7441778edee4620a7;Vulnerable Log4j version ./apache-log4j-2.0-beta6-bin/log4j-core-2.0-beta6.jar
e32489039dab38637557882cca0653d7;Vulnerable Log4j version ./apache-log4j-2.0-beta7-bin/log4j-core-2.0-beta7.jar
db025370dbe801ac623382edb2336ede;Vulnerable Log4j version ./apache-log4j-2.0-beta8-bin/log4j-core-2.0-beta8.jar
152ecb3ce094ac5bc9ea39d6122e2814;Vulnerable Log4j version ./apache-log4j-2.0-beta9-bin/log4j-core-2.0-beta9.jar
cd70a1888ecdd311c1990e784867ce1e;Vulnerable Log4j version ./apache-log4j-2.0-bin/log4j-core-2.0.jar
088df113ad249ab72bf19b7f00b863d5;Vulnerable Log4j version ./apache-log4j-2.0-rc1-bin/log4j-core-2.0-rc1.jar
de8d01cc15fd0c74fea8bbb668e289f5;Vulnerable Log4j version ./apache-log4j-2.0-rc2-bin/log4j-core-2.0-rc2.jar
fbfa5f33ab4b29a6fdd52473ee7b834d;Vulnerable Log4j version ./apache-log4j-2.0.1-bin/log4j-core-2.0.1.jar
8c0cf3eb047154a4f8e16daf5a209319;Vulnerable Log4j version ./apache-log4j-2.0.2-bin/log4j-core-2.0.2.jar
8d331544b2e7b20ad166debca2550d73;Vulnerable Log4j version ./apache-log4j-2.1-bin/log4j-core-2.1.jar
5e4bca5ed20b94ab19bb65836da93f96;Vulnerable Log4j version ./apache-log4j-2.2-bin/log4j-core-2.2.jar
110ab3e3e4f3780921e8ee5dde3373ad;Vulnerable Log4j version ./apache-log4j-2.3-bin/log4j-core-2.3.jar
0079c907230659968f0fc0e41a6abcf9;Vulnerable Log4j version ./apache-log4j-2.4-bin/log4j-core-2.4.jar
f0c43adaca2afc71c6cc80f851b38818;Vulnerable Log4j version ./apache-log4j-2.4.1-bin/log4j-core-2.4.1.jar
dd0e3e0b404083ec69618aabb50b8ac0;Vulnerable Log4j version ./apache-log4j-2.5-bin/log4j-core-2.5.jar
5523f144faef2bfca08a3ca8b2becd6a;Vulnerable Log4j version ./apache-log4j-2.6-bin/log4j-core-2.6.jar
48f7f3cda53030a87e8c387d8d1e4265;Vulnerable Log4j version ./apache-log4j-2.6.1-bin/log4j-core-2.6.1.jar
472c8e1fbaa0e61520e025c255b5d168;Vulnerable Log4j version ./apache-log4j-2.6.2-bin/log4j-core-2.6.2.jar
2b63e0e5063fdaccf669a1e26384f3fd;Vulnerable Log4j version ./apache-log4j-2.7-bin/log4j-core-2.7.jar
c6d233bc8e9cfe5da690059d27d9f88f;Vulnerable Log4j version ./apache-log4j-2.8-bin/log4j-core-2.8.jar
547bb3ed2deb856d0e3bbd77c27b9625;Vulnerable Log4j version ./apache-log4j-2.8.1-bin/log4j-core-2.8.1.jar
4a5177a172764bda6f4472b94ba17ccb;Vulnerable Log4j version ./apache-log4j-2.8.2-bin/log4j-core-2.8.2.jar
a27e67868b69b7223576d6e8511659dd;Vulnerable Log4j version ./apache-log4j-2.9.0-bin/log4j-core-2.9.0.jar
a3a6bc23ffc5615efcb637e9fd8be7ec;Vulnerable Log4j version ./apache-log4j-2.9.1-bin/log4j-core-2.9.1.jar
0042e7de635dc1c6c0c5a1ebd2c1c416;Vulnerable Log4j version ./apache-log4j-2.10.0-bin/log4j-core-2.10.0.jar
90c12763ac2a49966dbb9a6d98be361d;Vulnerable Log4j version ./apache-log4j-2.11.0-bin/log4j-core-2.11.0.jar
71d3394226547d81d1bf6373a5b0e53a;Vulnerable Log4j version ./apache-log4j-2.11.1-bin/log4j-core-2.11.1.jar
8da9b75725fb3357cb9872adf7711f9f;Vulnerable Log4j version ./apache-log4j-2.11.2-bin/log4j-core-2.11.2.jar
7943c49b634b404144557181f550a59c;Vulnerable Log4j version ./apache-log4j-2.12.0-bin/log4j-core-2.12.0.jar
df949e7d73479ab717e5770814de0ae9;Vulnerable Log4j version ./apache-log4j-2.12.1-bin/log4j-core-2.12.1.jar
2803991d51c98421be35d2db4ed3c2ac;Vulnerable Log4j version ./apache-log4j-2.13.0-bin/log4j-core-2.13.0.jar
5ff1dab00c278ab8c7d46aadc60b4074;Vulnerable Log4j version ./apache-log4j-2.13.1-bin/log4j-core-2.13.1.jar
b8e0d2779abbf38586b869f8b8e2eb46;Vulnerable Log4j version ./apache-log4j-2.13.2-bin/log4j-core-2.13.2.jar
46e660d79456e6f751c22b94976f6ad5;Vulnerable Log4j version ./apache-log4j-2.13.3-bin/log4j-core-2.13.3.jar
62ad26fbfb783183663ba5bfdbfb5ace;Vulnerable Log4j version ./apache-log4j-2.14.0-bin/log4j-core-2.14.0.jar
3570d00d9ceb3ca645d6927f15c03a62;Vulnerable Log4j version ./apache-log4j-2.14.1-bin/log4j-core-2.14.1.jar
f5e2d2a9543ee3c4339b6f90b6cb01fc;Vulnerable Log4j version ./log4j-2.0-alpha1/log4j-core-2.0-alpha1.jar
```

`string-iocs.txt`:

```txt
${jndi:ldap:/
${jndi:rmi:/
${jndi:ldaps:/
${jndi:dns:/
/$%7bjndi:
%24%7bjndi:
$%7Bjndi:
%2524%257Bjndi
%2F%252524%25257Bjndi%3A
${jndi:${lower:
${::-j}${
${jndi:nis
${jndi:nds
${jndi:corba
${jndi:iiop
${${env:BARFOO:-j}
${::-l}${::-d}${::-a}${::-p}
${base64:JHtqbmRp
/Basic/Command/Base64/
* * * wget
* * * curl
bingsearchlib.com
34.198.182.201
canarytokens.com
52.18.63.80
log4j.binaryedge.io
134.209.163.248
leakix.net
167.71.13.196
dnslog.cn
47.244.138.18
kryptoslogic-cve-2021-44228.com
167.99.86.185
interact.sh
46.101.25.250
# END - DO NOT REMOVE - contents passed to grep - double escape square brackets
```