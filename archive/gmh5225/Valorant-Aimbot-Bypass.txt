Project Path: arc_gmh5225_Valorant-Aimbot-Bypass_3kma3ifn

Source Tree:

```txt
arc_gmh5225_Valorant-Aimbot-Bypass_3kma3ifn
├── AItest.cpp
├── README.md
├── _config.yml
├── aibox.cpp
├── aibox.h
├── build.cfg
├── calcangle.h
├── main.cpp
├── player.h
└── valorant-aimbot
    ├── GAME.cfg
    ├── GAME.names
    ├── GAME.screenshots
    ├── GAME.weights
    └── GAME_last.weights

```

`AItest.cpp`:

```cpp
DWORD pLocalPlayer = { 0x509B74 };
DWORD playerObjectAddress = 0;

// Base address of "client.dll" (int or DWORD)
int ClientDLL = (int)GetModuleHandleA("client.dll");

// Find actual EntityBase address
EntityBase = *(int*)(ClientDLL + 0x9D3C6C); 

// Read the memory address of the EntityBase+0x23C4 to find the ID of the entity in the crosshair
int in_cross = *(int*)(EntityBase + 0x23C4); 
 
// ReadProcessMemory reads memory from a given process
ReadProcessMemory(handleToGame, (LPCVOID)addressToRead, &variableToStoreReadInformation, sizeof(variableToStoreReadInformation), NULL);

// WriteProcessMemory writes memory to a given process
WriteProcessMemory(handleToGame, (LPVOID)addressToWriteTo, &variableContainingValueToWrite, sizeof(variableContainingValueToWrite), NULL);


```

`README.md`:

```md
# Valorant Aimbot Bypass - AI Weights

This is my aimbot that I coded for the game Valorant. It has aimbot functionality with human aim.
# Requirements

Win 10 64 and NVIDIA graphics card

CUDA Installation
http://developer.download.nvidia.com/compute/cuda/10.2/Prod/network_installers/cuda_10.2.89_win10_network.exe

## Debug mode
![This is what debug mode looks like.](https://i.imgur.com/KExBtq5.png)
When you compile the valorant hack you should see this when you press F9 ingame. 
## Proof of success

![Aimbot is great.](https://i.imgur.com/zUzFo3S.png)
This is the cheats performance after training it for 100 hours against real players.
## Credits

Big thanks to secret club and LChamber for helping me in discord.


```

`_config.yml`:

```yml
theme: jekyll-theme-hacker
```

`aibox.cpp`:

```cpp
#include "Drawing.h"


void Drawing::DrawBorderBox( int x, int y, int w, int h, int thickness, D3DCOLOR Colour, IDirect3DDevice9 *pDevice)
{
	//Top horiz line
	DrawFilledRect( x, y, w, thickness,  Colour, pDevice );
	//Left vertical line
	DrawFilledRect( x, y, thickness, h, Colour, pDevice );
	//right vertical line
	DrawFilledRect( (x + w), y, thickness, h, Colour, pDevice );
	//bottom horiz line
	DrawFilledRect( x, y + h, w+thickness, thickness, Colour, pDevice );
}


//We receive the 2-D Coordinates the color and the device we want to use to draw those colors with
void Drawing::DrawFilledRect(int x, int y, int w, int h, D3DCOLOR color, IDirect3DDevice9* dev)
{
	//We create our rectangle to draw on screen
	D3DRECT BarRect = { x, y, x + w, y + h }; 
	//We clear that portion of the screen and display our rectangle
	dev->Clear(1, &BarRect, D3DCLEAR_TARGET | D3DCLEAR_TARGET, color, 0, 0);
}


void Drawing::Draw_Text(LPCSTR TextToDraw, int x, int y, D3DCOLOR Colour, LPD3DXFONT m_font)
{
	// Create a rectangle to indicate where on the screen it should be drawn
	RECT rct = {x- 120, y, x+ 120, y + 15};

	// Draw some text 
	m_font->DrawText(NULL, TextToDraw, -1, &rct, DT_NOCLIP, Colour );
}



```

`aibox.h`:

```h
#pragma once

#include "d3d9.h"

static class Drawing
{
public:
	static void Draw_Text(LPCSTR TextToDraw, int x, int y, D3DCOLOR Colour, LPD3DXFONT m_font);
	static void DrawFilledRect(int x, int y, int w, int h, D3DCOLOR color, IDirect3DDevice9* d3dDevice);
	static void DrawBorderBox( int x, int y, int w, int h, int thickness, D3DCOLOR Colour, IDirect3DDevice9 *d3dDevice);
};


```

`build.cfg`:

```cfg
// b00m-h3adsh0t.cfg Config File								     
// Web: https://github.com/lucylow/b00m-h3adsh0t						     


// Autoassign # bots (defaults to 0)
set b00m-h3adsh0t "0"

// Add # bots to allies (defaults to 0)
set b00m-h3adsh0t_allies "0"

// Add # bots to axis (defaults to 0)
set b00m-h3adsh0t_axis "0"

// Bot skill level, value from 0.1 to 1.0 (defaults to 1.0)
set b00m-h3adsh0t_skill "1.0"

// Set to 0 - Original (slower speed and more walking) or 1 - Faster (Run & Gun) or 2 - Both (defaults to 2)
set b00m-h3adsh0t_playstyle "2"

// Set to 0 to disable bots choosing a random perk upon spawn. 
set b00m-h3adsh0t_useperks "1"

// Set to 1 to enable bots to use the additional character models such as Capt. Price. (defaults to 0)
b00m-h3adsh0t_modelchoice "0"

// Set to 0 to stop bots using battlechatter (talking during game) (defaults to 1)
set b00m-h3adsh0t_chatter "1"

// Set to 1 to disable bots using UAV, Airstrike and Helicopter (defaults to 0)
set b00m-h3adsh0t_dewards "0"

// Set to 1 and bots will drop grenades/RPGs for the player to pick up and restock their grenade/RPG ammunition (defaults to 0)
set b00m-h3adsh0t_grenadepickup "0"

// Set to 1 to be instant level 55 and have all weapons unlocked (defaults to 0)
set b00m-h3adsh0t_XPcheat "0"

// Restarts the listen server after (defaults to 2)
set b00m-h3adsh0t_roundCount "2"


// Required to fix bug with UAV, Airstrike and Helicopter. Leave this here.
set b00m-h3adsh0t_mode "normal"

```

`calcangle.h`:

```h
Vector CAimbot::CalcAngle( Vector& src, Vector& dst )
{
Vector vAngle;
Vector delta( (src.X-dst.X), (src.Y-dst.Y), (src.Z-dst.Z) );
double hyp = sqrt( delta.X*delta.X + delta.Y*delta.Y );
 
vAngle.X = (float)(asinf( (delta.Z + 64.06f) / hyp ) * 57.295779513082f);
vAngle.Y = (float)(atanf( delta.Y / delta.X ) * 57.295779513082f);
vAngle.Z = 0.0f;
 
if(delta.X >= 0.0)
vAngle.Y += 180.0f;
 
return vAngle;
}


```

`main.cpp`:

```cpp
#include <Windows.h>
#include <iostream>
#include "main.h"
#include <vector>
#include <algorithm>
using namespace std;


CHackProcess fProcess;
using namespace std;

#define F6_Key 0x75
#define RIGHT_MOUSE 0x02

int NumOfPlayers = 32;

//Relative offsets:
const DWORD dw_PlayerCountOffs = 0x5EF6BC;//Engine.dll
const DWORD Player_Base = 0x4C6708;
const DWORD dw_m_angRotation = 0x47F1B4; //ViewAngles - find by moving our mouse around, look for changed/unchanged value, or use cl_pdump 1

// Entity offsets
const DWORD dw_mTeamOffset = 0x9C;
const DWORD dw_Health = 0x94;
const DWORD dw_Pos = 0x260;

const DWORD EntityPlayer_Base = 0x4D3904;//Entitylist relative offset
const DWORD EntityLoopDistance = 0x10; //Distance in bytes between each ent

struct MyPlayer_t
{
	DWORD CLocalPlayer; //Address of our ent
	int Team;
	int Health;
	float Position[3];
	void ReadInformation()
	{
		//Get address of entity
		ReadProcessMemory(fProcess.__HandleProcess, (BYTE*)(fProcess.__dwordClient + Player_Base), &CLocalPlayer, sizeof(CLocalPlayer), 0);
		ReadProcessMemory(fProcess.__HandleProcess, (BYTE*)(CLocalPlayer + dw_mTeamOffset), &Team, sizeof(Team), 0);
		ReadProcessMemory(fProcess.__HandleProcess, (BYTE*)(CLocalPlayer + dw_Health), &Health, sizeof(Health), 0);
		ReadProcessMemory(fProcess.__HandleProcess, (BYTE*)(CLocalPlayer + dw_Pos), &Position, sizeof(float[3]), 0);
		//Get Number of players
		ReadProcessMemory(fProcess.__HandleProcess, (BYTE*)(fProcess.__dwordEngine + dw_PlayerCountOffs), &NumOfPlayers, sizeof(int), 0);
	}
}MyPlayer;

//struct for targets
struct TargetList_t
{
	float Distance;
	float AimbotAngle[3];

	TargetList_t() {} //default contructor

	TargetList_t(float aimbotAngle[], float myCoords[], float enemyCoords[])
	{
		Distance = Get3dDistance(myCoords[0], myCoords[1], myCoords[2],
			enemyCoords[0], enemyCoords[1], enemyCoords[2]);

		//set aimbot angles for the ent
		AimbotAngle[0] = aimbotAngle[0];
		AimbotAngle[1] = aimbotAngle[1];
		AimbotAngle[2] = aimbotAngle[2];
	}

	float Get3dDistance(float myCoordsX, float myCoordsZ, float myCoordsY,
		float eNx, float eNz, float eNy)
	{
		return (float)sqrt(
			pow(double(eNx - myCoordsX), 2.0) +
			pow(double(eNy - myCoordsY), 2.0) +
			pow(double(eNz - myCoordsZ), 2.0));
	}
};

//Struct for other players
struct PlayerList_t
{
	DWORD CBaseEntity;
	int Team;
	int Health;
	float Position[3];
	float AimbotAngle[3];
	char Name[39];

	void ReadInformation(int Player)
	{
		//Get Address of Entity
		ReadProcessMemory(fProcess.__HandleProcess, (BYTE*)(fProcess.__dwordClient + EntityPlayer_Base + (Player * EntityLoopDistance)), &CBaseEntity, sizeof(DWORD), 0);
		ReadProcessMemory(fProcess.__HandleProcess, (BYTE*)(CBaseEntity + dw_mTeamOffset), &Team, sizeof(int), 0);
		ReadProcessMemory(fProcess.__HandleProcess, (BYTE*)(CBaseEntity + dw_Health), &Health, sizeof(int), 0);
		ReadProcessMemory(fProcess.__HandleProcess, (BYTE*)(CBaseEntity + dw_Pos), &Position, sizeof(float[3]), 0);
	}
}PlayerList[32];

// Compare distance when sorting the array of Target Enemies "sort predicate"
struct CompareTargetEnArray
{
	bool operator() (TargetList_t & lhs, TargetList_t & rhs)
	{
		return lhs.Distance < rhs.Distance;
	}
};

void CalcAngle(float *src, float *dst, float *angles)
{
	double delta[3] = { (src[0] - dst[0]), (src[1] - dst[1]), (src[2] - dst[2]) };
	double hyp = sqrt(delta[0] * delta[0] + delta[1] * delta[1]);
	angles[0] = (float)(asinf(delta[2] / hyp) * 57.295779513082f);
	angles[1] = (float)(atanf(delta[1] / delta[0]) * 57.295779513082f);
	angles[2] = 0.0f;

	// Normalize angle
	if (delta[0] >= 0.0)
	{
		angles[1] += 180.0f;
	}
}

void Aimbot()
{
	// Declare our target list to define our victims through a dynamic array
	TargetList_t* TargetList = new TargetList_t[NumOfPlayers];

	// Loop through all our players and retrieve their information
	int targetLoop = 0;
	for (int i = 0; i < NumOfPlayers; i++)
	{
		PlayerList[i].ReadInformation(i);

		// Skip if they're my teammates.
		if (PlayerList[i].Team == MyPlayer.Team) continue;

		// Skip players without health such as bad ents
		if (PlayerList[i].Health < 2) continue;

		// PlayerList[i].Position[2] -= 10;
		CalcAngle(MyPlayer.Position, PlayerList[i].Position, PlayerList[i].AimbotAngle);

		// Populate array of targets with only good targets
		TargetList[targetLoop] = TargetList_t(PlayerList[i].AimbotAngle, MyPlayer.Position, PlayerList[i].Position);

		// Increment to advance the array for the next iteration
		targetLoop++;
	}

	//Aim only if we have any enemies
	if (targetLoop > 0)
	{
		//SORT ENEMIES ARRAY BY DISTANCE by using our sort predicate
		std::sort(TargetList, TargetList + targetLoop, CompareTargetEnArray());

		//AIM at the closest ent, by default aim at ALL times, if you right click hold it switches it off
		if (!GetAsyncKeyState(0x2))
		{
			WriteProcessMemory(fProcess.__HandleProcess, (BYTE*)(fProcess.__dwordEngine + dw_m_angRotation), TargetList[0].AimbotAngle, 12, 0);
		}

	}
	// Reset the loop counter
	targetLoop = 0;

	delete[] TargetList; //DELETE OUR ARRAY and clear memory
}

int main()
{
	fProcess.RunProcess(); // Waiting for CSS......
	cout << "Game found! Running b00m h3adsh0t aimbot." << endl;

	//Exit if the F6 key is pressed
	while (!GetAsyncKeyState(F6_Key))
	{
		MyPlayer.ReadInformation();
		Aimbot();
	}
}

```

`player.h`:

```h
#pragma once
#include <math.h>

// 3D data for each player
// Memory addresses within "PlayerData" 

    class Vect3d
    {
	public:
        float x;
        float y;
        float z;

        Vect3d(float _x, float _y, float _z)
        {
            x = _x;
            y = _y;
            z = _z;
        }

        Vect3d()
        {
        }

        float length()
        {
			return (float)sqrt(x * x + y * y + z * z);
        }

        float dotproduct(Vect3d dot)
        {
            return (x * dot.x + y * dot.y + z * dot.z);
        }

    };

		struct Color
	{
		public:
		short R;
		short G;
		short B;

		Color()
		{

		}
		Color(short r, short g, short b)
		{
			R = r;
			G = g;
			B = b;
		}

	};

    class PlayerDataVec
    {
		public:
        float xMouse;
        float yMouse;
        int isValid;
        float xPos;
        float yPos;
        float zPos;
        int isAlive;
        int clientNum;
        Color color;
        char name[16];
        int pose;
        int team;
        bool visible;
        int isInGame;
		int health;

        Vect3d VecCoords()
        {
			Vect3d vec(xPos, zPos, yPos);
            return vec;
        }
    };

```

`valorant-aimbot/GAME.cfg`:

```cfg
GAME.cfg

Output - program writes in cfg file

    Batch = 1
    Subdivision = 1 for testing

```

`valorant-aimbot/GAME.names`:

```names
GAME.names

```

`valorant-aimbot/GAME.screenshots`:

```screenshots
void GetScreenShot(void)
{
    int x1, y1, x2, y2, w, h;

    // get screen dimensions
    x1  = GetSystemMetrics(SM_XVIRTUALSCREEN);
    y1  = GetSystemMetrics(SM_YVIRTUALSCREEN);
    x2  = GetSystemMetrics(SM_CXVIRTUALSCREEN);
    y2  = GetSystemMetrics(SM_CYVIRTUALSCREEN);
    w   = x2 - x1;
    h   = y2 - y1;

    // copy screen to bitmap
    HDC     hScreen = GetDC(NULL);
    HDC     hDC     = CreateCompatibleDC(hScreen);
    HBITMAP hBitmap = CreateCompatibleBitmap(hScreen, w, h);
    HGDIOBJ old_obj = SelectObject(hDC, hBitmap);
    BOOL    bRet    = BitBlt(hDC, 0, 0, w, h, hScreen, x1, y1, SRCCOPY);

    // save bitmap to clipboard
    OpenClipboard(NULL);
    EmptyClipboard();
    SetClipboardData(CF_BITMAP, hBitmap);
    CloseClipboard();   

    // clean up
    SelectObject(hDC, old_obj);
    DeleteDC(hDC);
    ReleaseDC(NULL, hScreen);
    DeleteObject(hBitmap);
    
    // screenshot to jpg and save to stream
    image.Attach(hBitmap);
    image.Save(stream, Gdiplus::ImageFormatJPEG);
    IStream_Size(stream, &liSize);
    DWORD len = liSize.LowPart;
    IStream_Reset(stream);
    buf.resize(len);
    IStream_Read(stream, &buf[0], len);
    stream->Release();

    // put image in the file
    std::fstream fi;
    fi.open(path, std::fstream::binary | std::fstream::out);
    fi.write(reinterpret_cast<const char*>(&buf[0]), buf.size() * sizeof(BYTE));
    fi.close();
}

```

`valorant-aimbot/GAME.weights`:

```weights
GAME.weights

```

`valorant-aimbot/GAME_last.weights`:

```weights
GAME_last.weights

```