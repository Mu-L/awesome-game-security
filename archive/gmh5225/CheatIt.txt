Project Path: arc_gmh5225_CheatIt_559_s_av

Source Tree:

```txt
arc_gmh5225_CheatIt_559_s_av
├── CheatIt
│   ├── CheatIt.vcxproj
│   ├── CheatIt.vcxproj.filters
│   ├── CheatIt.vcxproj.user
│   ├── cheat.cpp
│   ├── cheat.h
│   ├── engine.cpp
│   ├── engine.h
│   ├── main.cpp
│   ├── utils.cpp
│   └── utils.h
├── CheatIt.sln
└── README.md

```

`CheatIt.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30717.126
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CheatIt", "CheatIt\CheatIt.vcxproj", "{2F097290-656B-47B0-9287-4707333AB0BB}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{2F097290-656B-47B0-9287-4707333AB0BB}.Debug|x64.ActiveCfg = Debug|x64
		{2F097290-656B-47B0-9287-4707333AB0BB}.Debug|x64.Build.0 = Debug|x64
		{2F097290-656B-47B0-9287-4707333AB0BB}.Release|x64.ActiveCfg = Release|x64
		{2F097290-656B-47B0-9287-4707333AB0BB}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {99394375-443E-4301-871A-1E3A361F888B}
	EndGlobalSection
EndGlobal

```

`CheatIt/CheatIt.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="cheat.cpp" />
    <ClCompile Include="engine.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="cheat.h" />
    <ClInclude Include="engine.h" />
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{2f097290-656b-47b0-9287-4707333ab0bb}</ProjectGuid>
    <RootNamespace>CheatIt</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir>intermediate\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir>intermediate\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CheatIt/CheatIt.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="engine.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="utils.cpp" />
    <ClCompile Include="cheat.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="engine.h" />
    <ClInclude Include="utils.h" />
    <ClInclude Include="cheat.h" />
  </ItemGroup>
</Project>
```

`CheatIt/CheatIt.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerCommand>D:\SteamLibrary\steamapps\common\WitchIt\WitchIt\Binaries\Win64\PropWitchHuntModule-Win64-Shipping.exe</LocalDebuggerCommand>
    <LocalDebuggerAttach>true</LocalDebuggerAttach>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LocalDebuggerCommand>D:\SteamLibrary\steamapps\common\WitchIt\WitchIt\Binaries\Win64\PropWitchHuntModule-Win64-Shipping.exe</LocalDebuggerCommand>
    <LocalDebuggerAttach>true</LocalDebuggerAttach>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`CheatIt/cheat.cpp`:

```cpp
#include "cheat.h"
#include "engine.h"
#include "utils.h"

void** Address;
void(__thiscall* PostRenderOriginal)(UGameViewportClient*, UCanvas*);

void* Font = nullptr;

void PostRenderHook(UGameViewportClient* viewport, UCanvas* canvas)
{
    do
    {
        auto world = viewport->World;
        auto game = world->OwningGameInstance;
        auto state = world->GameState;
        if (!state) break;
        auto localPlayer = game->LocalPlayers.Data[0];
        auto localController = localPlayer->PlayerController;
        auto localCamera = localController->PlayerCameraManager;
        if (!localCamera) break;
        auto cameraLocation = localCamera->K2_GetActorLocation();
        auto localPawn = localController->K2_GetPawn();
        auto players = state->PlayerArray;
        for (auto i = 0; i < players.Count; i++)
        {
            auto player = players.Data[i];
            auto pawn = player->PawnPrivate;
            if (!pawn || pawn == localPawn) continue;
            auto location = pawn->K2_GetActorLocation();
            FVector2D screen;
            if (localController->ProjectWorldLocationToScreen(location, screen, true))
            {
                auto name = player->PlayerNamePrivate;
                FVector2D scale{ 1.f, 1.f };
                FLinearColor color{ 1.f, 0.43f, 0.f, 1.f };
                FLinearColor shadow{ 0.f, 0.f, 0.f, 0.f };
                FLinearColor outline{ 0.f, 0.f, 0.f, 1.f };
                canvas->K2_DrawText(Font, name, screen, scale, color, false, shadow, scale, true, true, true, outline);
            };
        }
    } while (false);

    PostRenderOriginal(viewport, canvas);
}

bool CheatInit()
{
    auto engine = *Engine;
    if (!engine) return false;

    Font = engine->SubtitleFont;
    if (!Font) return false;

    auto viewport = engine->GameViewport;
    if (!viewport) return false; 

    auto vtable = viewport->VFTable;
    if (!vtable) return false;

    Address = vtable + 0x61;
    PostRenderOriginal = reinterpret_cast<decltype(PostRenderOriginal)>(Address[0]);

    auto hook = &PostRenderHook;
    return PatchMem(Address, &hook, 8);
}

void CheatRemove()
{
   PatchMem(Address, &PostRenderOriginal, 8);
}
```

`CheatIt/cheat.h`:

```h
#pragma once

bool CheatInit();
void CheatRemove();
```

`CheatIt/engine.cpp`:

```cpp
#include "engine.h"
#include "utils.h"

std::string FNameEntry::String()
{
	if (bIsWide) { return std::string(); }
	return { AnsiName, Len };
}

FNameEntry* FNamePool::GetEntry(FNameEntryHandle handle) const
{
	return reinterpret_cast<FNameEntry*>(Blocks[handle.Block] + 2 * static_cast<uint64_t>(handle.Offset));
}

std::string FName::GetName()
{
	auto entry = NamePoolData->GetEntry(Index);
	auto name = entry->String();
	if (Number > 0)
	{
		name += '_' + std::to_string(Number);
	}
	auto pos = name.rfind('/');
	if (pos != std::string::npos)
	{
		name = name.substr(pos + 1);
	}
	return name;
}

std::string UObject::GetName()
{
	return NamePrivate.GetName();
}

std::string UObject::GetFullName()
{
	std::string name;
	for (auto outer = OuterPrivate; outer; outer = outer->OuterPrivate) { name = outer->GetName() + "." + name; }
	name = ClassPrivate->GetName() + " " + name + this->GetName();
	return name;
}

bool UObject::IsA(void* cmp)
{
	for (auto super = ClassPrivate; super; super = static_cast<UClass*>(super->SuperStruct)) { if (super == cmp) { return true; } }
	return false;
}

void UObject::ProcessEvent(void* fn, void* parms)
{
	auto vtable = *reinterpret_cast<void***>(this);
	reinterpret_cast<void(*)(void*, void*, void*)>(vtable[0x42])(this, fn, parms);
}

UObject* TUObjectArray::GetObjectPtr(uint32_t id) const
{
	if (id >= NumElements) return nullptr;
	uint64_t chunkIndex = id / 65536;
	if (chunkIndex >= NumChunks) return nullptr;
	auto chunk = Objects[chunkIndex];
	if (!chunk) return nullptr;
	uint32_t withinChunkIndex = id % 65536 * 24;
	auto item = *reinterpret_cast<UObject**>(chunk + withinChunkIndex);
	return item;
}

UObject* TUObjectArray::FindObject(const char* name) const
{
	for (auto i = 0u; i < NumElements; i++)
	{
		auto object = GetObjectPtr(i);
		if (object && object->GetFullName() == name) { return object; }
	}
	return nullptr;
}

UEngine** Engine = nullptr;
TUObjectArray* ObjObjects = nullptr;
FNamePool* NamePoolData = nullptr;

void UCanvas::K2_DrawText(void* RenderFont, FString& RenderText, FVector2D& ScreenPosition, FVector2D& Scale, FLinearColor& RenderColor, float Kerning, FLinearColor& ShadowColor, FVector2D& ShadowOffset, bool bCentreX, bool bCentreY, bool bOutlined, FLinearColor& OutlineColor)
{
	static auto fn = ObjObjects->FindObject("Function Engine.Canvas.K2_DrawText");
	struct {
		void* RenderFont;
		FString RenderText;
		FVector2D ScreenPosition;
		FVector2D Scale;
		FLinearColor RenderColor;
		float Kerning;
		FLinearColor ShadowColor;
		FVector2D ShadowOffset;
		bool bCentreX;
		bool bCentreY;
		bool bOutlined;
		FLinearColor OutlineColor;
	} parms;
	parms = { RenderFont , RenderText, ScreenPosition, Scale, RenderColor, Kerning, ShadowColor, ShadowOffset, bCentreX, bCentreY, bOutlined, OutlineColor};
	ProcessEvent(fn, &parms);
}

FVector AActor::K2_GetActorLocation()
{
	static auto fn = ObjObjects->FindObject("Function Engine.Actor.K2_GetActorLocation");
	struct {
		FVector ReturnValue;
	} parms;
	ProcessEvent(fn, &parms);
	return parms.ReturnValue;
}

APawn* AController::K2_GetPawn()
{
	static auto fn = ObjObjects->FindObject("Function Engine.Controller.K2_GetPawn");
	struct {
		APawn* ReturnValue;
	} parms;
	ProcessEvent(fn, &parms);
	return parms.ReturnValue;
}

bool APlayerController::ProjectWorldLocationToScreen(FVector& WorldLocation, FVector2D& ScreenLocation, bool bPlayerViewportRelative)
{
	static auto fn = ObjObjects->FindObject("Function Engine.PlayerController.ProjectWorldLocationToScreen");
	struct {
		FVector WorldLocation;
		FVector2D ScreenLocation;
		bool bPlayerViewportRelative;
		bool ReturnValue;
	} parms;
	parms = { WorldLocation, ScreenLocation, bPlayerViewportRelative };
	ProcessEvent(fn, &parms);
	ScreenLocation = parms.ScreenLocation;
	return parms.ReturnValue;
}

bool EngineInit()
{
	auto main = GetModuleHandleA(nullptr);

	static byte engineSig[] = { 0x48, 0x8b, 0x05, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x88, 0x08, 0x0b, 0x00, 0x00 };
	Engine = reinterpret_cast<decltype(Engine)>(FindPointer(main, engineSig, sizeof(engineSig), 0));
	if (!Engine) return false;

	static byte objSig[] = { 0x48, 0x8B, 0x05, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x0C, 0xC8, 0x48, 0x8D, 0x04, 0xD1, 0xEB };
	ObjObjects = reinterpret_cast<decltype(ObjObjects)>(FindPointer(main, objSig, sizeof(objSig), 0));
	if (!ObjObjects) return false;

	static byte poolSig[] = { 0x48, 0x8d, 0x35, 0x00, 0x00, 0x00, 0x00, 0xeb, 0x16 };
	NamePoolData = reinterpret_cast<decltype(NamePoolData)>(FindPointer(main, poolSig, sizeof(poolSig), 0));
	if (!NamePoolData) return false;

	return true;
}
```

`CheatIt/engine.h`:

```h
#pragma once
#include <cstdint>
#include <windows.h>
#include <string>
#undef DrawText

struct FVector {
	float X, Y, Z;

	FVector() : X(0.f), Y(0.f), Z(0.f) {}
	FVector(float X, float Y, float Z) : X(X), Y(Y), Z(Z) {}
	FVector(float InF) : X(InF), Y(InF), Z(InF) { }
	float Size() const { return sqrtf(X * X + Y * Y + Z * Z); }
	float DistTo(const FVector& V) const { return (*this - V).Size(); }
	FVector operator-(const FVector& other) const { return FVector(X - other.X, Y - other.Y, Z - other.Z); }
};

struct FVector2D {
	float X, Y;
};

struct FRotator {
	float Pitch, Yaw, Roll;
};

struct FLinearColor {
	float R, G, B, A;
	FLinearColor() : R(0.f), G(0.f), B(0.f), A(0.f) {};
	FLinearColor(float R, float G, float B, float A) : R(R), G(G), B(B), A(A) {};
};

template<typename T>
struct TArray {
	T* Data;
	int Count;
	int Size;
};

struct FString : TArray<wchar_t> {};

struct FNameEntryHandle {
	uint32_t Block = 0;
	uint32_t Offset = 0;

	FNameEntryHandle(uint32_t block, uint32_t offset) : Block(block), Offset(offset) {};
	FNameEntryHandle(uint32_t id) : Block(id >> 16), Offset(id & 65535) {};
	operator uint32_t() const { return (Block << 16 | Offset); }
};

struct FNameEntry {
	uint16_t bIsWide : 1;
	uint16_t LowercaseProbeHash : 5;
	uint16_t Len : 10;
	union
	{
		char AnsiName[1024];
		wchar_t	WideName[1024];
	};

	std::string String();
};

struct FNamePool 
{
	byte Lock[8];
	uint32_t CurrentBlock;
	uint32_t CurrentByteCursor;
	byte* Blocks[8192];

	FNameEntry* GetEntry(FNameEntryHandle handle) const;
};

struct FName {
	uint32_t Index;
	uint32_t Number;

	std::string GetName();
};

struct UObject {
	void** VFTable;
	uint32_t ObjectFlags;
	uint32_t InternalIndex;
	struct UClass* ClassPrivate;
	FName NamePrivate;
	UObject* OuterPrivate;

	std::string GetName();
	std::string GetFullName();
	bool IsA(void* cmp);
	void ProcessEvent(void* fn, void* parms);
};


// Class CoreUObject.Field
// Size: 0x30 (Inherited: 0x28)
struct UField : UObject {
	char UnknownData_28[0x8]; // 0x28(0x08)
};

// Class CoreUObject.Struct
// Size: 0xb0 (Inherited: 0x30)
struct UStruct : UField {
	char UnknownData_30[0x10]; // 0x30(0x10)
	UStruct* SuperStruct; // 0x40(0x8)
	char UnknownData_48[0x68]; // 0x48(0x80)
};

// Class CoreUObject.Class
// Size: 0x230 (Inherited: 0xb0)
struct UClass : UStruct {
	char UnknownData_B0[0x180]; // 0xb0(0x180)
};

struct TUObjectArray {
	byte** Objects;
	byte* PreAllocatedObjects;
	uint32_t MaxElements;
	uint32_t NumElements;
	uint32_t MaxChunks;
	uint32_t NumChunks;

	UObject* GetObjectPtr(uint32_t id) const;
	UObject* FindObject(const char* name) const;
};

// Class Engine.Canvas
// Size: 0x2c0 (Inherited: 0x28)
struct UCanvas : UObject {
	void K2_DrawText(void* RenderFont, FString& RenderText, FVector2D& ScreenPosition, FVector2D& Scale, FLinearColor& RenderColor, float Kerning, FLinearColor& ShadowColor, FVector2D& ShadowOffset, bool bCentreX, bool bCentreY, bool bOutlined, FLinearColor& OutlineColor); // Function Engine.Canvas.K2_DrawText
};

// Class Engine.Actor
// Size: 0x220 (Inherited: 0x28)
struct AActor : UObject {
	char pad_28[0x1F8]; // 0x28(0x1F8)

	FVector K2_GetActorLocation();
};

// Class Engine.Pawn
// Size: 0x280 (Inherited: 0x220)
struct APawn : AActor {
	char pad_220[0x60];
};

// Class Engine.PlayerCameraManager
// Size: 0x2740 (Inherited: 0x220)
struct APlayerCameraManager : AActor {
	char pad_220[0x2520]; // 0x220
};

// Class Engine.Controller
// Size: 0x298 (Inherited: 0x220)
struct AController : AActor {
	char pad_220[0x78];

	struct APawn* K2_GetPawn();
};

// Class Engine.PlayerController
// Size: 0x570 (Inherited: 0x298)
struct APlayerController : AController {
	char pad_298[0x20]; // 0x298(0x08)
	struct APlayerCameraManager* PlayerCameraManager; // 0x2b8(0x08)

	bool ProjectWorldLocationToScreen(struct FVector& WorldLocation, struct FVector2D& ScreenLocation, bool bPlayerViewportRelative); // Function Engine.PlayerController.ProjectWorldLocationToScreen
};

// Class Engine.Player
// Size: 0x48 (Inherited: 0x28)
struct UPlayer : UObject {
	char UnknownData_28[0x8]; // 0x28(0x08)
	struct APlayerController* PlayerController; // 0x30(0x08)
};

// Class Engine.PlayerState
// Size: 0x320 (Inherited: 0x220)
struct APlayerState : AActor {
	char pad_220[0x60]; // 0x220(0x04)
	struct APawn* PawnPrivate; // 0x280(0x08)
	char pad_288[0x78]; // 0x288
	struct FString PlayerNamePrivate; // 0x300(0x10)
};

// Class Engine.GameStateBase
// Size: 0x270 (Inherited: 0x220)
struct AGameStateBase : AActor {
	char pad_220[0x18]; // 0x220
	struct TArray<struct APlayerState*> PlayerArray; // 0x238(0x10)
};

// Class Engine.GameInstance
// Size: 0x198 (Inherited: 0x28)
struct UGameInstance : UObject {
	char UnknownData_28[0x10]; // 0x28(0x10)
	struct TArray<struct UPlayer*> LocalPlayers; // 0x38(0x10)
};

// Class Engine.World
// Size: 0x710 (Inherited: 0x28)
struct UWorld : UObject {
	char pad_28[0x108]; // 0x28(0x108)
	struct AGameStateBase* GameState; // 0x130(0x08)
	char pad_0x138[0x50]; // 0x138(0x50)
	struct UGameInstance* OwningGameInstance; // 0x188(0x08)
};

// Class Engine.ScriptViewportClient
// Size: 0x38 (Inherited: 0x28)
struct UScriptViewportClient : UObject {
	char UnknownData_28[0x10]; // 0x28(0x10)
};

// Class Engine.GameViewportClient
// Size: 0x330 (Inherited: 0x38)
struct UGameViewportClient : UScriptViewportClient {
	char UnknownData_38[0x40]; // 0x38(0x08)
	struct UWorld* World; // 0x78(0x08)
	struct UGameInstance* GameInstance; // 0x80(0x08)
	char UnknownData_88[0x2a8]; // 0x88(0x2a8)
};

// Class Engine.Engine
// Size: 0xde0 (Inherited: 0x28)
struct UEngine : UObject {
	char UnknownData_28[0x88]; // 0x28(0x08)
	struct UFont* SubtitleFont; // 0xb0(0x08)
	char pad_b8[0x6D0]; // 0xb8
	struct UGameViewportClient* GameViewport; // 0x788(0x08)
};

extern UEngine** Engine;
extern FNamePool* NamePoolData;
extern TUObjectArray* ObjObjects;

bool EngineInit();
```

`CheatIt/main.cpp`:

```cpp
#include <Windows.h>
#include "engine.h"
#include "cheat.h"

void* Dll = nullptr;
bool err = false;

void ClearingThread()
{
	while (1)
	{
		if (GetAsyncKeyState(VK_END) & 1) { FreeLibraryAndExitThread(reinterpret_cast<HMODULE>(Dll), 0); }
		Sleep(20);
	}
}

BOOL WINAPI DllMain(HINSTANCE dll, DWORD reason, LPVOID reserved)
{
	switch (reason)
	{
	case DLL_PROCESS_ATTACH:
	{
		DisableThreadLibraryCalls(dll);

		err = EngineInit() && CheatInit();

		if (err)
		{
			Dll = dll;
			auto t = CreateThread(nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(ClearingThread), nullptr, 0, nullptr);
			if (t) { CloseHandle(t); }
		}

		return err;
	}
	case DLL_PROCESS_DETACH:
	{
		if (err) { CheatRemove(); };
		return true;
	}
	}
	return TRUE;
}
```

`CheatIt/utils.cpp`:

```cpp
#include "utils.h"
#include <Psapi.h>

bool Compare(byte* data, byte* sig, uint64_t size)
{
    for (auto i = 0ull; i < size; i++) { if (data[i] != sig[i] && sig[i] != 0x00) { return false; } }
    return true;
}

byte* FindSignature(byte* start, byte* end, byte* sig, uint64_t size)
{
    for (auto it = start; it < end - size; it++) { if (Compare(it, sig, size)) { return it; }; }
    return nullptr;
}

void* FindPointer(HMODULE mod, byte* sig, uint64_t size, int addition)
{
    MODULEINFO info;
    if (!K32GetModuleInformation(GetCurrentProcess(), mod, &info, sizeof(MODULEINFO))) { return nullptr; };
    auto base = static_cast<byte*>(info.lpBaseOfDll);
    auto address = FindSignature(base, base + info.SizeOfImage - 1, sig, size);
    if (!address) { return nullptr; }
    auto k = 0;
    for (; sig[k]; k++);
    auto offset = *reinterpret_cast<int*>(address + k);
    return address + k + 4 + offset + addition;
}

bool PatchMem(void* address, void* bytes, uint64_t size)
{
    DWORD oldProtection;
    if (!VirtualProtect(address, size, PAGE_EXECUTE_READWRITE, &oldProtection)) { return false; }
    memcpy(address, bytes, size);
    return VirtualProtect(address, size, oldProtection, &oldProtection);
}
```

`CheatIt/utils.h`:

```h
#pragma once
#include <cstdint>
#include <Windows.h>

bool Compare(byte* data, byte* sig, uint64_t size);
byte* FindSignature(byte* start, byte* end, byte* sig, uint64_t size);
void* FindPointer(HMODULE mod, byte* sig, uint64_t size, int addition);
bool PatchMem(void* address, void* bytes, uint64_t size);
```

`README.md`:

```md
# CheatIt
Cheat for the game 'Witch It' and 'POLYGON'
https://youtu.be/a_0UrwHd4Pk
https://youtu.be/2-gtF3kCEAU

To make it work with the POLYGON change the ObjObjects sig to '{ 0x48, 0x8d, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x39, 0x44, 0x24, 0x68 }'

```