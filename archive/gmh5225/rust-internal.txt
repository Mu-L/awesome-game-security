Project Path: arc_gmh5225_rust-internal_ubmevq2y

Source Tree:

```txt
arc_gmh5225_rust-internal_ubmevq2y
├── holzed.sln
├── horizon
│   ├── constant
│   │   ├── character.hpp
│   │   ├── hash.hpp
│   │   ├── secure_string.hpp
│   │   └── string.hpp
│   ├── core
│   │   ├── map_data.cpp
│   │   ├── map_data.hpp
│   │   ├── mutex.cpp
│   │   ├── mutex.hpp
│   │   ├── no_copy.hpp
│   │   ├── no_move.hpp
│   │   ├── singleton.hpp
│   │   ├── timer.cpp
│   │   └── timer.hpp
│   ├── graphics
│   │   ├── color.cpp
│   │   ├── color.hpp
│   │   ├── renderer.cpp
│   │   └── renderer.hpp
│   ├── hde
│   │   ├── hde64.cpp
│   │   ├── hde64.hpp
│   │   ├── table32.hpp
│   │   └── table64.hpp
│   ├── horizon.txt
│   ├── horizon.vcxproj
│   ├── horizon.vcxproj.filters
│   ├── horizon.vcxproj.user
│   ├── imgui
│   │   ├── imconfig.hpp
│   │   ├── imgui.cpp
│   │   ├── imgui.hpp
│   │   ├── imgui_draw.cpp
│   │   ├── imgui_impl_dx11.cpp
│   │   ├── imgui_impl_dx11.hpp
│   │   ├── imgui_impl_win32.cpp
│   │   ├── imgui_impl_win32.hpp
│   │   ├── imgui_internal.hpp
│   │   ├── imgui_shader_dx11.cpp
│   │   ├── imgui_shader_dx11.hpp
│   │   ├── imgui_widgets.cpp
│   │   ├── imstb_rectpack.hpp
│   │   ├── imstb_textedit.hpp
│   │   └── imstb_truetype.hpp
│   ├── include
│   │   ├── auto.hpp
│   │   ├── base.hpp
│   │   └── win32.hpp
│   ├── memory
│   │   ├── arg_stack.hpp
│   │   ├── detour_hook.cpp
│   │   ├── detour_hook.hpp
│   │   ├── macro.hpp
│   │   ├── operation.cpp
│   │   ├── operation.hpp
│   │   ├── scan.cpp
│   │   ├── scan.hpp
│   │   ├── secure_call.hpp
│   │   ├── system_call.hpp
│   │   ├── vftable_hook.cpp
│   │   ├── vftable_hook.hpp
│   │   └── x64
│   │       ├── code_secure_call.asm
│   │       └── code_system_call.asm
│   ├── vcruntime
│   │   ├── dll_dllmain.cpp
│   │   ├── dll_dllmain.hpp
│   │   ├── initializers.cpp
│   │   ├── initializers.hpp
│   │   ├── internal_shared.hpp
│   │   ├── memory.cpp
│   │   ├── memory.hpp
│   │   ├── operator.cpp
│   │   ├── security_cookie.cpp
│   │   ├── security_cookie.hpp
│   │   ├── thread_local_storage.cpp
│   │   ├── thread_local_storage.hpp
│   │   ├── thread_safe_statics.cpp
│   │   └── thread_safe_statics.hpp
│   └── win32
│       ├── basic.cpp
│       ├── basic.hpp
│       ├── core_types.hpp
│       ├── file.cpp
│       ├── file.hpp
│       ├── image.cpp
│       ├── image.hpp
│       ├── input_manager.cpp
│       ├── input_manager.hpp
│       ├── math.cpp
│       ├── math.hpp
│       ├── process.cpp
│       ├── process.hpp
│       └── sdk
│           ├── access_mask.hpp
│           ├── activation_context_stack.hpp
│           ├── alternative_architecture_type.hpp
│           ├── client_id.hpp
│           ├── constant_page.hpp
│           ├── constant_region.hpp
│           ├── constant_section.hpp
│           ├── event_basic_information.hpp
│           ├── event_information_class.hpp
│           ├── event_type.hpp
│           ├── exception_registration_record.hpp
│           ├── file_basic_information.hpp
│           ├── file_directory_information.hpp
│           ├── file_id_both_dir_information.hpp
│           ├── file_information_class.hpp
│           ├── file_standard_information.hpp
│           ├── gdi_teb_batch.hpp
│           ├── guid.hpp
│           ├── handle.hpp
│           ├── image_base_relocation.hpp
│           ├── image_data_directory.hpp
│           ├── image_dos_header.hpp
│           ├── image_export_directory.hpp
│           ├── image_file_header.hpp
│           ├── image_import_by_name.hpp
│           ├── image_import_descriptor.hpp
│           ├── image_nt_headers.hpp
│           ├── image_optional_header.hpp
│           ├── image_relocation.hpp
│           ├── image_runtime_function_entry.hpp
│           ├── image_section_header.hpp
│           ├── image_thunk_data.hpp
│           ├── io_apc_routine.hpp
│           ├── io_status_block.hpp
│           ├── ksystem_time.hpp
│           ├── kuser_shared_data.hpp
│           ├── large_integer.hpp
│           ├── ldr_data_table_entry.hpp
│           ├── list_entry.hpp
│           ├── memory_basic_information.hpp
│           ├── memory_enclave_image_information.hpp
│           ├── memory_frame_information.hpp
│           ├── memory_image_information.hpp
│           ├── memory_information_class.hpp
│           ├── memory_region_information.hpp
│           ├── memory_shared_commit_information.hpp
│           ├── memory_working_set_block.hpp
│           ├── memory_working_set_ex_block.hpp
│           ├── memory_working_set_ex_information.hpp
│           ├── memory_working_set_ex_location.hpp
│           ├── memory_working_set_information.hpp
│           ├── mutant_basic_information.hpp
│           ├── mutant_information_class.hpp
│           ├── nt_product_type.hpp
│           ├── nt_tib.hpp
│           ├── object_attributes.hpp
│           ├── object_basic_information.hpp
│           ├── object_information_class.hpp
│           ├── object_name_information.hpp
│           ├── object_wait_type.hpp
│           ├── peb.hpp
│           ├── peb_ldr_data.hpp
│           ├── rtl_activation_context_stack_frame.hpp
│           ├── rtl_balanced_node.hpp
│           ├── rtl_condition_variable.hpp
│           ├── rtl_critical_section.hpp
│           ├── rtl_critical_section_debug.hpp
│           ├── rtl_heap_parameters.hpp
│           ├── section_basic_information.hpp
│           ├── section_information_class.hpp
│           ├── section_inherit.hpp
│           ├── string.hpp
│           ├── teb.hpp
│           ├── ularge_integer.hpp
│           ├── unicode_string.hpp
│           ├── xstate_configuration.hpp
│           └── xstate_feature.hpp
└── rust
    ├── main
    │   ├── entry.cpp
    │   └── vcruntime.cpp
    ├── options
    │   ├── storage.cpp
    │   └── storage.hpp
    ├── rust
    │   ├── core.cpp
    │   ├── core.hpp
    │   ├── features
    │   │   ├── aimbot.cpp
    │   │   ├── aimbot.hpp
    │   │   ├── user_interface.cpp
    │   │   ├── user_interface.hpp
    │   │   ├── visuals.cpp
    │   │   └── visuals.hpp
    │   └── hooks
    │       ├── dispatch_message.cpp
    │       └── dispatch_message.hpp
    ├── rust.vcxproj
    ├── rust.vcxproj.filters
    ├── rust.vcxproj.user
    └── unity
        ├── engine
        │   ├── math.cpp
        │   ├── math.hpp
        │   ├── matrix4x4.cpp
        │   ├── matrix4x4.hpp
        │   ├── vector2.cpp
        │   ├── vector2.hpp
        │   ├── vector3.cpp
        │   └── vector3.hpp
        ├── il2cpp
        │   ├── il2cpp-api-functions.hpp
        │   ├── il2cpp-api-types.hpp
        │   ├── il2cpp-api.cpp
        │   ├── il2cpp-api.hpp
        │   ├── il2cpp-blob.hpp
        │   ├── il2cpp-class-internals.hpp
        │   ├── il2cpp-config-api.hpp
        │   ├── il2cpp-config.hpp
        │   ├── il2cpp-metadata.hpp
        │   ├── il2cpp-object-internals.hpp
        │   └── il2cpp-runtime-metadata.hpp
        ├── object
        │   ├── rust.hpp
        │   ├── system.hpp
        │   ├── unity_engine.cpp
        │   └── unity_engine.hpp
        ├── sdk.cpp
        └── sdk.hpp

```

`holzed.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29418.71
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "horizon", "horizon\horizon.vcxproj", "{96858F12-06FC-41DC-98FB-1593B502F373}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pubg", "pubg\pubg.vcxproj", "{4EE45439-8A88-484E-B8DC-1F270905F053}"
	ProjectSection(ProjectDependencies) = postProject
		{96858F12-06FC-41DC-98FB-1593B502F373} = {96858F12-06FC-41DC-98FB-1593B502F373}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pubg-lite", "pubg-lite\pubg-lite.vcxproj", "{537C3F36-3175-41FB-9DFC-D38516055BB8}"
	ProjectSection(ProjectDependencies) = postProject
		{96858F12-06FC-41DC-98FB-1593B502F373} = {96858F12-06FC-41DC-98FB-1593B502F373}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "rust", "rust\rust.vcxproj", "{946F1633-F2E3-41A6-B7DB-70890015E1ED}"
	ProjectSection(ProjectDependencies) = postProject
		{96858F12-06FC-41DC-98FB-1593B502F373} = {96858F12-06FC-41DC-98FB-1593B502F373}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{96858F12-06FC-41DC-98FB-1593B502F373}.Debug|x64.ActiveCfg = Debug|x64
		{96858F12-06FC-41DC-98FB-1593B502F373}.Debug|x64.Build.0 = Debug|x64
		{96858F12-06FC-41DC-98FB-1593B502F373}.Debug|x86.ActiveCfg = Debug|x64
		{96858F12-06FC-41DC-98FB-1593B502F373}.Release|x64.ActiveCfg = Release|x64
		{96858F12-06FC-41DC-98FB-1593B502F373}.Release|x64.Build.0 = Release|x64
		{96858F12-06FC-41DC-98FB-1593B502F373}.Release|x86.ActiveCfg = Release|x64
		{4EE45439-8A88-484E-B8DC-1F270905F053}.Debug|x64.ActiveCfg = Debug|x64
		{4EE45439-8A88-484E-B8DC-1F270905F053}.Debug|x64.Build.0 = Debug|x64
		{4EE45439-8A88-484E-B8DC-1F270905F053}.Debug|x86.ActiveCfg = Debug|x64
		{4EE45439-8A88-484E-B8DC-1F270905F053}.Release|x64.ActiveCfg = Release|x64
		{4EE45439-8A88-484E-B8DC-1F270905F053}.Release|x64.Build.0 = Release|x64
		{4EE45439-8A88-484E-B8DC-1F270905F053}.Release|x86.ActiveCfg = Release|x64
		{537C3F36-3175-41FB-9DFC-D38516055BB8}.Debug|x64.ActiveCfg = Debug|x64
		{537C3F36-3175-41FB-9DFC-D38516055BB8}.Debug|x64.Build.0 = Debug|x64
		{537C3F36-3175-41FB-9DFC-D38516055BB8}.Debug|x86.ActiveCfg = Debug|Win32
		{537C3F36-3175-41FB-9DFC-D38516055BB8}.Debug|x86.Build.0 = Debug|Win32
		{537C3F36-3175-41FB-9DFC-D38516055BB8}.Release|x64.ActiveCfg = Release|x64
		{537C3F36-3175-41FB-9DFC-D38516055BB8}.Release|x64.Build.0 = Release|x64
		{537C3F36-3175-41FB-9DFC-D38516055BB8}.Release|x86.ActiveCfg = Release|Win32
		{537C3F36-3175-41FB-9DFC-D38516055BB8}.Release|x86.Build.0 = Release|Win32
		{946F1633-F2E3-41A6-B7DB-70890015E1ED}.Debug|x64.ActiveCfg = Debug|x64
		{946F1633-F2E3-41A6-B7DB-70890015E1ED}.Debug|x64.Build.0 = Debug|x64
		{946F1633-F2E3-41A6-B7DB-70890015E1ED}.Debug|x86.ActiveCfg = Debug|Win32
		{946F1633-F2E3-41A6-B7DB-70890015E1ED}.Debug|x86.Build.0 = Debug|Win32
		{946F1633-F2E3-41A6-B7DB-70890015E1ED}.Release|x64.ActiveCfg = Release|x64
		{946F1633-F2E3-41A6-B7DB-70890015E1ED}.Release|x64.Build.0 = Release|x64
		{946F1633-F2E3-41A6-B7DB-70890015E1ED}.Release|x86.ActiveCfg = Release|Win32
		{946F1633-F2E3-41A6-B7DB-70890015E1ED}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {234193C4-59DA-4073-8D0B-23811C88F225}
	EndGlobalSection
EndGlobal

```

`horizon/constant/character.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

namespace horizon::constant
{

template< typename Type >
constexpr bool IsTerminator( const Type character )
{
	return ( character == static_cast< const Type >( 0 ) );
}

template< typename Type >
constexpr bool IsSpace( const Type character )
{
	return ( character == static_cast< const Type >( 32 ) );
}

template< typename Type >
constexpr bool IsQuestion( const Type character )
{
	return ( character == static_cast< const Type >( 63 ) );
}

template< typename Type >
constexpr bool IsDecimal( const Type character )
{
	return ( character >= static_cast< const Type >( 48 ) &&
					 character <= static_cast< const Type >( 57 ) );
}

template< typename Type >
constexpr bool IsLower( const Type character )
{
	return ( character >= static_cast< const Type >( 97 ) &&
					 character <= static_cast< const Type >( 122 ) );
}

template< typename Type >
constexpr bool IsUpper( const Type character )
{
	return ( character >= static_cast< const Type >( 65 ) &&
					 character <= static_cast< const Type >( 90 ) );
}

template< typename Type >
constexpr Type ToLower( const Type character )
{
	if( IsUpper( character ) )
	{
		return ( character + static_cast< const Type >( 32 ) );
	}

	return character;
}

template< typename Type >
constexpr Type ToUpper( const Type character )
{
	if( IsLower( character ) )
	{
		return ( character - static_cast< const Type >( 32 ) );
	}

	return character;
}

} // namespace horizon::constant
```

`horizon/constant/hash.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "string.hpp"

namespace horizon::constant
{

constexpr std::uint64_t HashPrime = 1099511628211;
constexpr std::uint64_t HashBasis = 14695981039346656037;

template< typename Type >
constexpr std::uint64_t HashCompute( std::uint64_t hash, const Type* const data, std::size_t size, bool ignore_case )
{
	const auto element = static_cast< std::uint64_t >( ignore_case ? ToLower( data[ 0 ] ) : data[ 0 ] );
	return ( size == 0 ) ? hash : HashCompute( ( hash * HashPrime ) ^ element, data + 1, size - 1, ignore_case );
}

template< typename Type >
constexpr std::uint64_t Hash( const Type* const data, std::size_t size, bool ignore_case )
{
	return HashCompute( HashBasis, data, size, ignore_case );
}

constexpr std::uint64_t Hash( const char* const data, bool ignore_case )
{
	const auto length = GetLength( data );
	return Hash( data, length, ignore_case );
}

constexpr std::uint64_t Hash( const wchar_t* const data, bool ignore_case )
{
	const auto length = GetLength( data );
	return Hash( data, length, ignore_case );
}

constexpr std::uint64_t Hash( const win32::ANSI_STRING& data, bool ignore_case )
{
	const auto length = data.Length / sizeof( char );
	return Hash( data.Buffer, length, ignore_case );
}

constexpr std::uint64_t Hash( const win32::UNICODE_STRING& data, bool ignore_case )
{
	const auto length = data.Length / sizeof( wchar_t );
	return Hash( data.Buffer, length, ignore_case );
}

template< typename Type >
constexpr std::uint64_t Hash( const std::basic_string< Type >& data, bool ignore_case )
{
	return Hash( data.c_str(), data.size(), ignore_case );
}

} // namespace horizon::constant

#define HASH( Data )																							\
	[ & ]()																													\
	{																																\
		constexpr auto hash = horizon::constant::Hash( Data, true );	\
		return hash;																									\
	}()
```

`horizon/constant/secure_string.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "character.hpp"
#include "hash.hpp"
#include "string.hpp"

namespace horizon::constant
{

template< typename Type >
using WrapType = typename std::remove_const_t< std::remove_reference_t< Type > >;

template< std::size_t Size, char Key1, char Key2, typename Type >
class SecureString
{
public:
	FORCEINLINE constexpr SecureString( Type* data )
	{
		compute( data );
	}

	FORCEINLINE Type* get()
	{
		return m_storage;
	}

	FORCEINLINE std::size_t size() const
	{
		return Size;
	}

	FORCEINLINE std::size_t size_in_bytes() const
	{
		return ( Size * sizeof( Type ) );
	}

	FORCEINLINE std::size_t length() const
	{
		return ( Size - 1 );
	}

	FORCEINLINE char get_key() const
	{
		return Key1;
	}

	FORCEINLINE bool is_decrypted() const
	{
		const auto index = length();
		return IsTerminator( m_storage[ index ] );
	}

	FORCEINLINE bool is_encrypted() const
	{
		return !( is_decrypted() );
	}

	FORCEINLINE Type* encrypt()
	{
		if( is_decrypted() )
		{
			compute( m_storage );
		}

		return m_storage;
	}

	FORCEINLINE Type* decrypt()
	{
		if( is_encrypted() )
		{
			compute( m_storage );
		}

		return m_storage;
	}

	FORCEINLINE void clear()
	{
		for( std::size_t index = 0; index < Size; index++ )
		{
			m_storage[ index ] = static_cast< Type >( 0 );
		}
	}

protected:
	FORCEINLINE constexpr void compute( Type* data )
	{
		for( std::size_t index = 0; index < Size; index++ )
		{
			m_storage[ index ] = static_cast< Type >( data[ index ] ^ ( Key1 + index % ( 1 + Key2 ) ) );
		}
	}

protected:
	Type m_storage[ Size ] = { };
};

} // namespace horizon::constant

#define SECURE_STRING_IMPL( name, data )	\
	static constexpr auto name = horizon::constant::SecureString				\
		< sizeof( data ) / sizeof( data[ 0 ] ),														\
			__TIME__[ 4 ],																									\
			__TIME__[ 7 ],																									\
			horizon::constant::WrapType< decltype( data[ 0 ] ) > >					\
		( ( horizon::constant::WrapType< decltype( data[ 0 ] ) >* )data )

#define SECURE_STRING( data )						\
	[]()																	\
	{																			\
		SECURE_STRING_IMPL( result, data );	\
		return result;											\
	}()

#define SECURE( data )									\
	[]()																	\
	{																			\
		SECURE_STRING_IMPL( result, data );	\
		return result;											\
	}().decrypt()
```

`horizon/constant/string.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "../win32/sdk/string.hpp"
#include "../win32/sdk/unicode_string.hpp"

#include "character.hpp"

namespace horizon::constant
{

template< typename Type >
constexpr std::size_t GetLength( const Type* const data )
{
	std::size_t length = 0;

	while( true )
	{
		if( IsTerminator( data[ length ] ) )
		{
			break;
		}

		length++;
	}

	return length;
}

template< typename Type >
constexpr bool AreEqual( const Type* const source, const Type* const destination, std::size_t length, bool ignore_case )
{
	for( std::size_t index = 0; index < length; index++ )
	{
		if( ignore_case )
		{
			if( ToLower( source[ index ] ) != ToLower( destination[ index ] ) )
			{
				return false;
			}
		}
		else
		{
			if( source[ index ] != destination[ index ] )
			{
				return false;
			}
		}
	}

	return true;
}

template< typename Type >
constexpr bool AreEqual( const Type* const source, const Type* const destination, bool ignore_case )
{
	const auto source_length = GetLength( source );
	const auto destination_length = GetLength( destination );

	if( source_length != destination_length )
	{
		return false;
	}

	return AreEqual( source, destination, source_length, ignore_case );
}

constexpr bool AreEqual( const win32::ANSI_STRING& source, const char* const destination, bool ignore_case )
{
	const auto source_length = source.Length / sizeof( char );
	const auto destination_length = GetLength( destination );

	if( source_length != destination_length )
	{
		return false;
	}

	return AreEqual( source.Buffer, destination, source_length, ignore_case );
}

constexpr bool AreEqual( const win32::UNICODE_STRING& source, const wchar_t* const destination, bool ignore_case )
{
	const auto source_length = source.Length / sizeof( wchar_t );
	const auto destination_length = GetLength( destination );

	if( source_length != destination_length )
	{
		return false;
	}

	return AreEqual( source.Buffer, destination, source_length, ignore_case );
}

template< typename Type >
constexpr Type* Copy( Type* const destination, const Type* const source, std::size_t length )
{
	for( std::size_t index = 0; index < length; index++ )
	{
		destination[ index ] = source[ index ];
	}

	return destination;
}

template< typename Type >
constexpr Type* Copy( Type* const destination, const Type* const source )
{
	const auto source_length = GetLength( source );
	return Copy( destination, source, source_length );
}

} // namespace horizon::constant
```

`horizon/core/map_data.cpp`:

```cpp
#include "map_data.hpp"

#include "../win32/basic.hpp"
#include "../win32/time.hpp"

namespace horizon::core
{

bool MapData::Create()
{
	const auto image_native = win32::GetImage( HASH( L"ntdll.dll" ) );

	if( memory::IsUserAddress( image_native ) )
	{
		RtlAddFunctionTable.Set( image_native );
		RtlDeleteFunctionTable.Set( image_native );
		RtlAllocateHeap.Set( image_native );
		RtlReAllocateHeap.Set( image_native );
		RtlFreeHeap.Set( image_native );
		RtlQueryPerformanceCounter.Set( image_native );
		RtlQueryPerformanceFrequency.Set( image_native );
		RtlInitializeCriticalSection.Set( image_native );
		RtlInitializeCriticalSectionEx.Set( image_native );
		RtlEnterCriticalSection.Set( image_native );
		RtlTryEnterCriticalSection.Set( image_native );
		RtlLeaveCriticalSection.Set( image_native );
		RtlDeleteCriticalSection.Set( image_native );

		if( IsValidConditionVariable() )
		{
			RtlInitializeConditionVariable.Set( image_native );
			RtlSleepConditionVariableCS.Set( image_native );
			RtlWakeConditionVariable.Set( image_native );
			RtlWakeAllConditionVariable.Set( image_native );
		}

		const auto exception_procedure = *reinterpret_cast< std::uintptr_t* >( &__C_specific_handler );
		const auto exception_procedure_pointer = reinterpret_cast< std::uintptr_t* >( &__C_specific_handler );

		if( exception_procedure )
		{
			( *exception_procedure_pointer ) = ( image_native + exception_procedure );
		}
		else
		{
			return false;
		}
	}
	else
	{
		return false;
	}

	const auto image_kernel32 = win32::GetImage( HASH( L"kernel32.dll" ) );

	if( memory::IsUserAddress( image_kernel32 ) )
	{
		OutputDebugStringA.Set( image_kernel32 );
		OutputDebugStringW.Set( image_kernel32 );
	}
	else
	{
		return false;
	}

	const auto image_msvcrt = win32::GetImage( HASH( L"msvcrt.dll" ) );

	if( memory::IsUserAddress( image_msvcrt ) )
	{
		malloc.Set( image_msvcrt );
		free.Set( image_msvcrt );
		memchr.Set( image_msvcrt );
		memcmp.Set( image_msvcrt );
		memcpy.Set( image_msvcrt );
		memmove.Set( image_msvcrt );
		memset.Set( image_msvcrt );
		qsort.Set( image_msvcrt );
		strstr.Set( image_msvcrt );
		_vsnprintf_l.Set( image_msvcrt );
		_vsnwprintf_l.Set( image_msvcrt );
		fabs.Set( image_msvcrt );
		fmod.Set( image_msvcrt );
		pow.Set( image_msvcrt );
		atan2.Set( image_msvcrt );
		ceil.Set( image_msvcrt );
		floor.Set( image_msvcrt );
		atol.Set( image_msvcrt );
		atof.Set( image_msvcrt );

		const auto sscanf_procedure = *reinterpret_cast< std::uintptr_t* >( &sscanf );
		const auto sscanf_procedure_pointer = reinterpret_cast< std::uintptr_t* >( &sscanf );

		if( sscanf_procedure )
		{
			( *sscanf_procedure_pointer ) = ( image_msvcrt + sscanf_procedure );
		}
		else
		{
			return false;
		}
	}
	else
	{
		return false;
	}

	return true;
}

void MapData::Destroy()
{
	// 
	// reset instance fields
	// 
	std::memset( this, 0, sizeof( MapData ) );
}

bool MapData::IsValid() const
{
	return ( m_signature == HASH( "MapData" ) );
}

bool MapData::IsValidSubscription()
{
	LARGE_INTEGER time = { };
	RtlQueryPerformanceCounter( &time );
	return ( time.QuadPart < m_time.QuadPart );
}

bool MapData::IsValidConditionVariable() const
{
	return ( RtlInitializeConditionVariable.IsValid() &&
					 RtlSleepConditionVariableCS.IsValid() &&
					 RtlWakeConditionVariable.IsValid() &&
					 RtlWakeAllConditionVariable.IsValid() );
}

} // namespace horizon::core

horizon::core::MapData g_map_data = { };
```

`horizon/core/map_data.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "../memory/operation.hpp"
#include "../memory/secure_call.hpp"
#include "../memory/system_call.hpp"

#include "../win32/sdk/handle.hpp"
#include "../win32/sdk/access_mask.hpp"
#include "../win32/sdk/io_apc_routine.hpp"
#include "../win32/sdk/io_status_block.hpp"
#include "../win32/sdk/object_attributes.hpp"
#include "../win32/sdk/object_information_class.hpp"
#include "../win32/sdk/object_wait_type.hpp"
#include "../win32/sdk/event_type.hpp"
#include "../win32/sdk/image_runtime_function_entry.hpp"
#include "../win32/sdk/file_information_class.hpp"
#include "../win32/sdk/memory_information_class.hpp"
#include "../win32/sdk/rtl_critical_section.hpp"
#include "../win32/sdk/rtl_condition_variable.hpp"
#include "../win32/sdk/unicode_string.hpp"
#include "../win32/sdk/large_integer.hpp"

#include "../win32/basic.hpp"
#include "../win32/file.hpp"
#include "../win32/image.hpp"
#include "../win32/process.hpp"
#include "../win32/string.hpp"
#include "../win32/time.hpp"
#include "../win32/trace.hpp"

namespace horizon::core
{

#define SECURE_IMPORT( Type, Name, ... )									\
	memory::WrapSecureCall< Type, __VA_ARGS__ > Name = { }

#define SYSTEM_IMPORT( Type, Name, ... )									\
	memory::WrapSystemCall< Type, __VA_ARGS__ > Name = { }

using namespace win32;

struct MapData
{
	bool Create();
	void Destroy();

	bool IsValid() const;
	bool IsValidSubscription();
	bool IsValidConditionVariable() const;

	// 
	// shared data
	// 

	std::uint64_t m_signature = 0;																																										// 0x0000

	std::uintptr_t m_base = 0;																																												// 0x0008
	std::size_t m_size = 0;																																														// 0x0010

	win32::LARGE_INTEGER m_time = { };

	// 
	// native imports
	// 

	SECURE_IMPORT( bool, RtlAddFunctionTable, IMAGE_RUNTIME_FUNCTION_ENTRY*, std::uint32_t, std::uintptr_t );								// 0x0018
	SECURE_IMPORT( bool, RtlDeleteFunctionTable, IMAGE_RUNTIME_FUNCTION_ENTRY* );																						// 0x0020

	SECURE_IMPORT( void*, RtlAllocateHeap, void*, std::uint32_t, std::size_t );																							// 0x0028
	SECURE_IMPORT( void*, RtlReAllocateHeap, void*, std::uint32_t, void*, std::size_t );
	SECURE_IMPORT( bool, RtlFreeHeap, void*, std::uint32_t, void* );																												// 0x0030

	SECURE_IMPORT( bool, RtlQueryPerformanceCounter, LARGE_INTEGER* );																								// 0x0038
	SECURE_IMPORT( bool, RtlQueryPerformanceFrequency, LARGE_INTEGER* );																							// 0x0040

	SECURE_IMPORT( NTSTATUS, RtlInitializeCriticalSection, RTL_CRITICAL_SECTION* );																					// 0x0048
	SECURE_IMPORT( NTSTATUS, RtlInitializeCriticalSectionEx, RTL_CRITICAL_SECTION*, std::int32_t, std::uint32_t );					// 0x0050
	SECURE_IMPORT( NTSTATUS, RtlEnterCriticalSection, RTL_CRITICAL_SECTION* );																							// 0x0058
	SECURE_IMPORT( bool, RtlTryEnterCriticalSection, RTL_CRITICAL_SECTION* );																								// 0x0060
	SECURE_IMPORT( NTSTATUS, RtlLeaveCriticalSection, RTL_CRITICAL_SECTION* );																							// 0x0068
	SECURE_IMPORT( NTSTATUS, RtlDeleteCriticalSection, RTL_CRITICAL_SECTION* );																							// 0x0070

	SECURE_IMPORT( void, RtlInitializeConditionVariable, RTL_CONDITION_VARIABLE* );																					// 0x0078
	SECURE_IMPORT( NTSTATUS, RtlSleepConditionVariableCS, RTL_CONDITION_VARIABLE*, RTL_CRITICAL_SECTION*, LARGE_INTEGER* );	// 0x0080
	SECURE_IMPORT( void, RtlWakeConditionVariable, RTL_CONDITION_VARIABLE* );																								// 0x0088
	SECURE_IMPORT( void, RtlWakeAllConditionVariable, RTL_CONDITION_VARIABLE* );																						// 0x0090

	EXCEPTION_DISPOSITION( API_STDCALL*__C_specific_handler )( EXCEPTION_RECORD*, void*, CONTEXT*, DISPATCHER_CONTEXT* );		// 0x0098

	// 
	// kernel32 imports
	// 

	SECURE_IMPORT( void, OutputDebugStringA, const char* const );																														// 0x00A0
	SECURE_IMPORT( void, OutputDebugStringW, const wchar_t* const );																												// 0x00A8

	// 
	// msvcrt imports
	// 

	SECURE_IMPORT( void*, malloc, std::size_t );																																						// 0x00B0
	SECURE_IMPORT( void, free, void* );																																											// 0x00B8

	SECURE_IMPORT( void*, memchr, void*, int, std::size_t );																																// 0x00C0
	SECURE_IMPORT( int, memcmp, const void*, const void*, std::size_t );																										// 0x00C8
	SECURE_IMPORT( void*, memcpy, void*, const void*, std::size_t );																												// 0x00D0
	SECURE_IMPORT( void*, memmove, void*, void*, std::size_t );																															// 0x00D8
	SECURE_IMPORT( void*, memset, void*, int, std::size_t );																																// 0x00E0

	SECURE_IMPORT( void, qsort, void*, std::size_t, std::size_t, int( * )( const void*, const void* ) );										// 0x00E8
	SECURE_IMPORT( char*, strstr, const char* const, const char* const );																										// 0x00F0

	SECURE_IMPORT( int, _vsnprintf_l, char* const, std::size_t, const char* const, _locale_t, va_list );										// 0x00F8
	SECURE_IMPORT( int, _vsnwprintf_l, wchar_t* const, std::size_t, const wchar_t* const, _locale_t, va_list );							// 0x0100

	SECURE_IMPORT( double, fabs, double );																																									// 0x0108
	SECURE_IMPORT( double, fmod, double, double );																																					// 0x0110
	SECURE_IMPORT( double, pow, double, double );																																						// 0x0118
	SECURE_IMPORT( double, atan2, double, double );																																					// 0x0120
	SECURE_IMPORT( double, ceil, double );																																									// 0x0128
	SECURE_IMPORT( double, floor, double );																																									// 0x0130
	SECURE_IMPORT( long, atol, const char* const );																																					// 0x0138
	SECURE_IMPORT( double, atof, const char* const );																																				// 0x0140

	int( API_CDECL* sscanf )( const char* const, const char* const, ... ) = nullptr;																				// 0x0148

	// 
	// object system api
	// 

	SYSTEM_IMPORT( NTSTATUS, NtClose, HANDLE );																																							// 0x0150
	SYSTEM_IMPORT( NTSTATUS, NtDuplicateObject, HANDLE, HANDLE*, HANDLE, HANDLE*, ACCESS_MASK, bool, std::uint32_t );				// 0x0154
	SYSTEM_IMPORT( NTSTATUS, NtMakeTemporaryObject, HANDLE );																																// 0x0158
	SYSTEM_IMPORT( NTSTATUS, NtQueryObject, HANDLE, OBJECT_INFORMATION_CLASS, void*, std::uint32_t, std::uint32_t* );				// 0x015C
	SYSTEM_IMPORT( NTSTATUS, NtSetInformationObject, HANDLE, OBJECT_INFORMATION_CLASS, void*, std::uint32_t );							// 0x0160
	SYSTEM_IMPORT( NTSTATUS, NtSignalAndWaitForSingleObject, HANDLE, HANDLE, bool, LARGE_INTEGER* );												// 0x0164
	SYSTEM_IMPORT( NTSTATUS, NtWaitForMultipleObjects, std::uint32_t, HANDLE*, OBJECT_WAIT_TYPE, bool, LARGE_INTEGER* );		// 0x0168
	SYSTEM_IMPORT( NTSTATUS, NtWaitForSingleObject, HANDLE, bool, LARGE_INTEGER* );																					// 0x016C

	// 
	// event system api
	// 

	SYSTEM_IMPORT( NTSTATUS, NtClearEvent, HANDLE );																																				// 0x0170
	SYSTEM_IMPORT( NTSTATUS, NtCreateEvent, HANDLE*, ACCESS_MASK, OBJECT_ATTRIBUTES*, EVENT_TYPE, bool );										// 0x0174
	SYSTEM_IMPORT( NTSTATUS, NtOpenEvent, HANDLE*, ACCESS_MASK, OBJECT_ATTRIBUTES* );																				// 0x0178
	SYSTEM_IMPORT( NTSTATUS, NtPulseEvent, HANDLE, std::int32_t* );																													// 0x017C
	SYSTEM_IMPORT( NTSTATUS, NtResetEvent, HANDLE, std::int32_t* );																													// 0x0180
	SYSTEM_IMPORT( NTSTATUS, NtSetEvent, HANDLE, std::int32_t* );																														// 0x0184

	// 
	// file system api
	// 

	SYSTEM_IMPORT( NTSTATUS, NtCreateFile, HANDLE*, ACCESS_MASK, OBJECT_ATTRIBUTES*, IO_STATUS_BLOCK*, LARGE_INTEGER*, std::uint32_t, std::uint32_t, std::uint32_t, std::uint32_t, void*, std::uint32_t );	// 0x0188
	SYSTEM_IMPORT( NTSTATUS, NtReadFile, HANDLE, HANDLE, IO_APC_ROUTINE*, void*, IO_STATUS_BLOCK*, void*, std::uint32_t, LARGE_INTEGER*, std::uint32_t* );																									// 0x018C
	SYSTEM_IMPORT( NTSTATUS, NtWriteFile, HANDLE, HANDLE, IO_APC_ROUTINE*, void*, IO_STATUS_BLOCK*, void*, std::uint32_t, LARGE_INTEGER*, std::uint32_t* );																									// 0x0190
	SYSTEM_IMPORT( NTSTATUS, NtLockFile, HANDLE, HANDLE, IO_APC_ROUTINE*, void*, IO_STATUS_BLOCK*, LARGE_INTEGER*, LARGE_INTEGER*, std::uint32_t*, bool, bool );																						// 0x0194
	SYSTEM_IMPORT( NTSTATUS, NtUnlockFile, HANDLE, IO_STATUS_BLOCK*, LARGE_INTEGER*, LARGE_INTEGER*, std::uint32_t* );																																											// 0x0198
	SYSTEM_IMPORT( NTSTATUS, NtDeleteFile, OBJECT_ATTRIBUTES* );																																																																						// 0x019C
	SYSTEM_IMPORT( NTSTATUS, NtQueryInformationFile, HANDLE, IO_STATUS_BLOCK*, void*, std::uint32_t, FILE_INFORMATION_CLASS );
	SYSTEM_IMPORT( NTSTATUS, NtQueryDirectoryFile, HANDLE, HANDLE, IO_APC_ROUTINE*, void*, IO_STATUS_BLOCK*, void*, std::uint32_t, FILE_INFORMATION_CLASS, std::uint8_t, UNICODE_STRING*, std::uint8_t );

	// 
	// memory system api
	// 

	SYSTEM_IMPORT( NTSTATUS, NtAllocateVirtualMemory, HANDLE, void**, std::uintptr_t, std::size_t*, std::uint32_t, std::uint32_t );	// 0x01A0
	SYSTEM_IMPORT( NTSTATUS, NtFreeVirtualMemory, HANDLE, void**, std::size_t*, std::uint32_t );																		// 0x01A4
	SYSTEM_IMPORT( NTSTATUS, NtLockVirtualMemory, HANDLE, void**, std::size_t*, std::uint32_t );																		// 0x01A8
	SYSTEM_IMPORT( NTSTATUS, NtUnlockVirtualMemory, HANDLE, void**, std::size_t*, std::uint32_t );																	// 0x01AC
	SYSTEM_IMPORT( NTSTATUS, NtQueryVirtualMemory, HANDLE, void*, MEMORY_INFORMATION_CLASS, void*, std::size_t, std::size_t* );			// 0x01B0
	SYSTEM_IMPORT( NTSTATUS, NtProtectVirtualMemory, HANDLE, void**, std::size_t*, std::uint32_t, std::uint32_t* );									// 0x01B4
	SYSTEM_IMPORT( NTSTATUS, NtReadVirtualMemory, HANDLE, void*, void*, std::size_t, std::size_t* );																// 0x01B8
	SYSTEM_IMPORT( NTSTATUS, NtWriteVirtualMemory, HANDLE, void*, void*, std::size_t, std::size_t* );																// 0x01BC

	// 
	// win32 user api
	// 

	SYSTEM_IMPORT( std::int32_t, NtUserGetKeyNameText, std::int32_t, const wchar_t* const, std::int32_t );													// 0x01C0
	SYSTEM_IMPORT( std::int16_t, NtUserGetKeyState, std::int32_t );																																	// 0x01C4
	SYSTEM_IMPORT( std::int16_t, NtUserGetAsyncKeyState, std::int32_t );																														// 0x01C8
	SYSTEM_IMPORT( std::uint32_t, NtUserMapVirtualKeyEx, std::int32_t, std::uint32_t, std::uintptr_t, std::uint32_t );							// 0x01CC
};

} // namespace horizon::core

extern horizon::core::MapData g_map_data;
```

`horizon/core/mutex.cpp`:

```cpp
#include "mutex.hpp"

#include "../core/map_data.hpp"

#include "../memory/operation.hpp"
#include "../memory/secure_call.hpp"
#include "../memory/system_call.hpp"

#include "../win32/basic.hpp"
#include "../win32/image.hpp"
#include "../win32/process.hpp"
#include "../win32/trace.hpp"

namespace horizon::core
{

Mutex::Mutex( std::int32_t spin_count /*= 0*/ )
	: m_section()
{
	if( !win32::RtlInitializeCriticalSectionEx( &m_section, spin_count, 0 ) )
	{
		TRACE( "%s: RtlInitializeCriticalSectionEx( ... ) error!", ATOM_FUNCTION );
	}
}

Mutex::~Mutex()
{
	if( !win32::RtlDeleteCriticalSection( &m_section ) )
	{
		TRACE( "%s: RtlDeleteCriticalSection( ... ) error!", ATOM_FUNCTION );
	}
}

void Mutex::lock()
{
	if( !win32::RtlEnterCriticalSection( &m_section ) )
	{
		TRACE( "%s: RtlEnterCriticalSection( ... ) error!", ATOM_FUNCTION );
	}
}

bool Mutex::try_lock()
{
	return win32::RtlTryEnterCriticalSection( &m_section );
}

void Mutex::unlock()
{
	if( !win32::RtlLeaveCriticalSection( &m_section ) )
	{
		TRACE( "%s: RtlLeaveCriticalSection( ... ) error!", ATOM_FUNCTION );
	}
}

ScopedLock::ScopedLock( Mutex& mutex )
	: m_mutex( mutex )
{
	m_mutex.lock();
}

ScopedLock::~ScopedLock()
{
	m_mutex.unlock();
}

ConditionVariable::ConditionVariable()
	: m_cv()
	, m_event( nullptr )
{
	if( g_map_data.IsValidConditionVariable() )
	{
		win32::RtlInitializeConditionVariable( &m_cv );
	}
	else
	{
		win32::OBJECT_ATTRIBUTES object_attributes = { };
		win32::InitializeObjectAttributes( &object_attributes );

		const auto status = g_map_data.NtCreateEvent( &m_event, EVENT_ALL_ACCESS, &object_attributes, win32::NotificationEvent, true );

		if( !NT_SUCCESS( status ) )
		{
			TRACE( "%s: NtCreateEvent( ... ) error! (0x%08X)", ATOM_FUNCTION, status );
		}
	}
}

ConditionVariable::~ConditionVariable()
{
	if( g_map_data.IsValidConditionVariable() )
	{
		return;
	}

	if( m_event && m_event != INVALID_HANDLE_VALUE )
	{
		const auto status = g_map_data.NtClose( m_event );

		if( !NT_SUCCESS( status ) )
		{
			TRACE( "%s: NtClose( ... ) error! (0x%08X)", ATOM_FUNCTION, status );
		}
	}
}

void ConditionVariable::notify()
{
	if( g_map_data.IsValidConditionVariable() )
	{
		win32::RtlWakeAllConditionVariable( &m_cv );
	}
	else
	{
		if( !m_event || m_event == INVALID_HANDLE_VALUE )
		{
			TRACE( "%s: m_event is not valid!", ATOM_FUNCTION );
			return;
		}

		auto status = g_map_data.NtSetEvent( m_event, nullptr );

		if( !NT_SUCCESS( status ) )
		{
			TRACE( "%s: NtSetEvent( ... ) error! (0x%08X)", ATOM_FUNCTION, status );
			return;
		}

		status = g_map_data.NtResetEvent( m_event, nullptr );

		if( !NT_SUCCESS( status ) )
		{
			TRACE( "%s: NtResetEvent( ... ) error! (0x%08X)", ATOM_FUNCTION, status );
		}
	}
}

bool ConditionVariable::wait_for( Mutex& mutex, std::uint32_t time )
{
	win32::LARGE_INTEGER time_out = { };
	time_out.QuadPart = static_cast< std::int64_t >( time ) * -( 10000 );

	if( g_map_data.IsValidConditionVariable() )
	{
		if( !win32::RtlSleepConditionVariableCS( &m_cv, &mutex.m_section, &time_out ) )
		{
			TRACE( "%s: RtlSleepConditionVariableCS( ... ) error!", ATOM_FUNCTION );
			return false;
		}
	}
	else
	{
		mutex.unlock();

		const auto status = g_map_data.NtWaitForSingleObject( m_event, false, &time_out );

		if( !NT_SUCCESS( status ) )
		{
			mutex.unlock();
			TRACE( "%s: NtWaitForSingleObject( ... ) error! (0x%08X)", ATOM_FUNCTION, status );
			return false;
		}

		mutex.lock();
	}

	return true;
}

} // namespace horizon::win32
```

`horizon/core/mutex.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "../win32/sdk/handle.hpp"

#include "../win32/sdk/rtl_critical_section.hpp"
#include "../win32/sdk/rtl_condition_variable.hpp"

#include "no_copy.hpp"
#include "no_move.hpp"

namespace horizon::core
{

class Mutex : public NoCopy
{
protected:
	friend class ConditionVariable;

public:
	Mutex( std::int32_t spin_count = 0 );

public:
	~Mutex();

public:
	void lock();
	bool try_lock();
	void unlock();

protected:
	win32::RTL_CRITICAL_SECTION m_section = { };
};

class ScopedLock : public NoCopy
{
public:
	explicit ScopedLock( Mutex& mutex );

public:
	~ScopedLock();

protected:
	Mutex& m_mutex;
};

class ConditionVariable : public NoCopy
{
public:
	ConditionVariable();

public:
	~ConditionVariable();

public:
	void notify();
	bool wait_for( Mutex& mutex, std::uint32_t time );

protected:
	win32::RTL_CONDITION_VARIABLE m_cv = { };
	win32::HANDLE m_event = nullptr;
};

} // namespace horizon::core
```

`horizon/core/no_copy.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

namespace horizon::core
{

class NoCopy
{
public:
	NoCopy() = default;
	NoCopy( const NoCopy& ) = delete;

protected:
	NoCopy& operator=( const NoCopy& ) = delete;
};

}
```

`horizon/core/no_move.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

namespace horizon::core
{

class NoMove
{
public:
	NoMove() = default;
	NoMove( NoMove&& ) = delete;

protected:
	NoMove& operator=( NoMove&& ) = delete;
};

}
```

`horizon/core/singleton.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "no_copy.hpp"
#include "no_move.hpp"

namespace horizon::core
{

template< class Type >
class Singleton : public NoCopy, public NoMove
{
public:
	static Type& Instance();
};

template< class Type >
Type& Singleton< Type >::Instance()
{
	static Type instance = { };
	return instance;
}

}
```

`horizon/core/timer.cpp`:

```cpp
#include "timer.hpp"

#include "../core/map_data.hpp"

#include "../win32/time.hpp"
#include "../win32/trace.hpp"

namespace horizon::core
{

Timer::Timer( bool begin /*= false*/ )
	: m_frequency{ }
	, m_begin{ }
	, m_end{ }
{
	g_map_data.RtlQueryPerformanceFrequency( &m_frequency );
	
	if( begin )
	{
		reset();
	}
}

void Timer::reset()
{
	g_map_data.RtlQueryPerformanceCounter( &m_begin );
}

std::int64_t Timer::elapsed()
{
	if( !m_frequency.QuadPart )
	{
		g_map_data.RtlQueryPerformanceFrequency( &m_frequency );
	}

	g_map_data.RtlQueryPerformanceCounter( &m_end );

	const auto count = ( m_end.QuadPart - m_begin.QuadPart );
	return ( count > 0 ? ( ( count * 1000 ) / m_frequency.QuadPart ) : 0 );
}

} // namespace horizon::core
```

`horizon/core/timer.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "../win32/sdk/large_integer.hpp"

#include "no_copy.hpp"

namespace horizon::core
{

class Timer : public NoCopy
{
public:
	Timer( bool begin = false );

public:
	void reset();

	std::int64_t elapsed();

protected:
	win32::LARGE_INTEGER m_frequency = { };
	win32::LARGE_INTEGER m_begin = { };
	win32::LARGE_INTEGER m_end = { };
};

} // namespace horizon::core
```

`horizon/graphics/color.cpp`:

```cpp
#include "color.hpp"

namespace horizon::graphics
{

Color::Color()
	: m_red( 0.f )
	, m_green( 0.f )
	, m_blue( 0.f )
	, m_alpha( 0.f )
{ }

Color::Color( std::uint8_t red, std::uint8_t green, std::uint8_t blue, std::uint8_t alpha /*= 255*/ )
	: m_red( ToValue( red ) )
	, m_green( ToValue( green ) )
	, m_blue( ToValue( blue ) )
	, m_alpha( ToValue( alpha ) )
{ }

Color::Color( float red, float green, float blue, float alpha /*= 1.f*/ )
	: m_red( red )
	, m_green( green )
	, m_blue( blue )
	, m_alpha( alpha )
{ }

Color::Color( const Color& color )
	: m_red( color.m_red )
	, m_green( color.m_green )
	, m_blue( color.m_blue )
	, m_alpha( color.m_alpha )
{ }

float* Color::ToArray()
{
	return reinterpret_cast< float* >( this );
}

const float* Color::ToArray() const
{
	return reinterpret_cast< const float* >( this );
}

std::uint32_t Color::ToUInt32() const
{
	return 0;
}

Color& Color::operator=( const Color& color )
{
	m_red = color.m_red;
	m_green = color.m_green;
	m_blue = color.m_blue;
	m_alpha = color.m_alpha;
	return *this;
}

float& Color::operator[]( std::size_t index )
{
	const auto data = ToArray();
	return data[ index ];
}

float Color::operator[]( std::size_t index ) const
{
	const auto data = ToArray();
	return data[ index ];
}

Color Color::Transparent()
{
	return { 0.f, 0.f, 0.f, 0.f };
}

Color Color::Black( float alpha /*= 1.f*/ )
{
	return { 0.f, 0.f, 0.f, alpha };
}

Color Color::White( float alpha /*= 1.f*/ )
{
	return { 1.f, 1.f, 1.f, alpha };
}

Color Color::Red( float alpha /*= 1.f*/ )
{
	return { 1.f, 0.f, 0.f, alpha };
}

Color Color::Green( float alpha /*= 1.f*/ )
{
	return { 0.f, 1.f, 0.f, alpha };
}

Color Color::Blue( float alpha /*= 1.f*/ )
{
	return { 0.f, 0.f, 1.f, alpha };
}

Color Color::Yellow( float alpha /*= 1.f*/ )
{
	return { 1.f, 1.f, 0.f, alpha };
}

Color Color::Orange( float alpha /*= 1.f*/ )
{
	return { 1.f, 0.5f, 0.f, alpha };
}

Color Color::Cyan( float alpha /*= 1.f*/ )
{
	return { 0.f, 0.5f, 1.f, alpha };
}

} // namespace horizon::graphics
```

`horizon/graphics/color.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

namespace horizon::graphics
{

class Color
{
protected:
	constexpr float ToValue( std::uint8_t value )
	{
		return ( static_cast< float >( value ) / 255.f );
	}

	constexpr std::uint8_t ToValue( float value )
	{
		return static_cast< std::uint8_t >( value * 255.f );
	}

public:
	Color();
	Color( std::uint8_t red, std::uint8_t green, std::uint8_t blue, std::uint8_t alpha = 255 );
	Color( float red, float green, float blue, float alpha = 1.f );
	Color( const Color& color );

public:
	float* ToArray();
	const float* ToArray() const;

	std::uint32_t ToUInt32() const;

public:
	Color& operator=( const Color& color );

public:
	float& operator[]( std::size_t index );
	float operator[]( std::size_t index ) const;

public:
	static Color Transparent();
	static Color Black( float alpha = 1.f );
	static Color White( float alpha = 1.f );
	static Color Red( float alpha = 1.f );
	static Color Green( float alpha = 1.f );
	static Color Blue( float alpha = 1.f );
	static Color Yellow( float alpha = 1.f );
	static Color Orange( float alpha = 1.f );
	static Color Cyan( float alpha = 1.f );

public:
	float m_red = 0.f;
	float m_green = 0.f;
	float m_blue = 0.f;
	float m_alpha = 0.f;
};

} // namespace horizon::graphics
```

`horizon/graphics/renderer.cpp`:

```cpp
#include "renderer.hpp"

#include "../memory/operation.hpp"

#include "../win32/trace.hpp"

namespace horizon::graphics
{

Renderer::~Renderer()
{
	Destroy();
}

bool Renderer::Create( IDXGISwapChain* swap_chain )
{
	m_swap_chain = swap_chain;

	if( !memory::IsAddressValid( m_swap_chain ) )
	{
		TRACE( "%s: m_swap_chain is not valid!", ATOM_FUNCTION );
		return false;
	}

	auto result = m_swap_chain->GetDevice( IID_PPV_ARGS( &m_device ) );

	if( FAILED( result ) )
	{
		TRACE( "%s: IDXGISwapChain::GetDevice( ... ) error! (0x%08X)", ATOM_FUNCTION, result );
		return false;
	}

	m_device->GetImmediateContext( &m_device_context );

	if( !memory::IsAddressValid( m_device_context ) )
	{
		TRACE( "%s: ID3D11Device::GetImmediateContext( ... ) error!", ATOM_FUNCTION );
		return false;
	}

	DXGI_SWAP_CHAIN_DESC swap_chain_desc = { };
	result = m_swap_chain->GetDesc( &swap_chain_desc );

	if( FAILED( result ) )
	{
		TRACE( "%s: IDXGISwapChain::GetDesc( ... ) error! (0x%08X)", ATOM_FUNCTION, result );
		return false;
	}

	m_window = swap_chain_desc.OutputWindow;

	if( !m_window )
	{
		TRACE( "%s: m_window is not valid!", ATOM_FUNCTION );
		return false;
	}

	m_context = ImGui::CreateContext();

	if( !memory::IsAddressValid( m_context ) )
	{
		TRACE( "%s: ImGui::CreateContext() error!", ATOM_FUNCTION );
		return false;
	}

	if( !ImGui_ImplWin32_Init( m_window ) )
	{
		TRACE( "%s: ImGui_ImplWin32_Init( ... ) error!", ATOM_FUNCTION );
		return false;
	}

	if( !ImGui_ImplDX11_Init( m_device, m_device_context ) )
	{
		TRACE( "%s: ImGui_ImplDX11_Init( ... ) error!", ATOM_FUNCTION );
		return false;
	}

	return CreateRenderTarget();
}

void Renderer::Destroy()
{
	// release device objects
	Lost();

	// release imgui objects
	ImGui_ImplDX11_Shutdown();
	ImGui_ImplWin32_Shutdown();

	if( memory::IsAddressValid( m_context ) )
	{
		// destroy imgui
		ImGui::DestroyContext( m_context );
	}

	m_swap_chain = nullptr;
	m_device = nullptr;
	m_device_context = nullptr;

	m_window = nullptr;
	m_context = nullptr;
	m_draw_list = nullptr;

	m_render_target_view = nullptr;
}

bool Renderer::Begin()
{
	// sanity checks
	if( !memory::IsAddressValid( m_render_target_view ) )
	{
		return false;
	}

	// update viewport
	m_device_context->RSGetViewports( &m_viewport_count, &m_viewport );

	ImGui_ImplDX11_NewFrame();
	ImGui_ImplWin32_NewFrame();

	ImGui::NewFrame();

	m_draw_list = ImGui::GetBackgroundDrawList();
	return memory::IsAddressValid( m_draw_list );
}

void Renderer::End()
{
	ImGui::Render();

	// set render target
	m_device_context->OMSetRenderTargets( 1, &m_render_target_view, nullptr );

	// render imgui draw data
	ImGui_ImplDX11_RenderDrawData( ImGui::GetDrawData() );
}

void Renderer::Lost()
{
	// destroy imgui objects
	ImGui_ImplDX11_InvalidateDeviceObjects();

	// destroy render target
	DestroyRenderTarget();
}

bool Renderer::Reset()
{
	// reset render target
	if( !CreateRenderTarget() )
	{
		TRACE( "%s: CreateRenderTarget() error!", ATOM_FUNCTION );
		return false;
	}

	// reset imgui objects
	if( !ImGui_ImplDX11_CreateDeviceObjects() )
	{
		TRACE( "%s: ImGui_ImplDX11_CreateDeviceObjects() error!", ATOM_FUNCTION );
		return false;
	}

	return true;
}

bool Renderer::Intersect( const ImVec2& position )
{
	return ( position[ 0 ] >= 0.f &&
					 position[ 1 ] >= 0.f &&
					 position[ 0 ] <= m_viewport.Width &&
					 position[ 1 ] <= m_viewport.Height );
}

IDXGISwapChain* Renderer::GetSwapChain() const
{
	return m_swap_chain;
}

ID3D11Device* Renderer::GetDevice() const
{
	return m_device;
}

ID3D11DeviceContext* Renderer::GetDeviceContext() const
{
	return m_device_context;
}

const D3D11_VIEWPORT& Renderer::GetViewport() const
{
	return m_viewport;
}

void Renderer::DrawCircle( const ImVec2& center_screen, float radius, const Color& color, int segments /*= 12*/ )
{
	m_draw_list->AddCircle( { center_screen[ 0 ], center_screen[ 1 ] }, radius, ImColor( color.m_red, color.m_green, color.m_blue, color.m_alpha ), segments );
}

void Renderer::DrawLine( const ImVec2& begin, const ImVec2& end, const Color& color )
{
	m_draw_list->AddLine( { begin[ 0 ], begin[ 1 ] }, { end[ 0 ], end[ 1 ] }, ImColor( color.m_red, color.m_green, color.m_blue, color.m_alpha ) );
}

void Renderer::DrawRect( const ImVec2& position, const ImVec2& size, const Color& color )
{
	m_draw_list->AddRectFilled( { position[ 0 ], position[ 1 ] }, { position[ 0 ] + size[ 0 ], position[ 1 ] + size[ 1 ] }, ImColor( color.m_red, color.m_green, color.m_blue, color.m_alpha ), 0.f, ImDrawCornerFlags_None );
}

void Renderer::DrawBox( const ImVec2& position, const ImVec2& size, float thickness, const Color& color )
{
	DrawRect( position, { size[ 0 ], thickness }, color );
	DrawRect( position, { thickness, size[ 1 ] }, color );

	DrawRect( { position[ 0 ] + size[ 0 ], position[ 1 ] }, { thickness, size[ 1 ] }, color );
	DrawRect( { position[ 0 ], position[ 1 ] + size[ 1 ] }, { size[ 0 ] + thickness, thickness }, color );
}

void Renderer::DrawBoxBorder( const ImVec2& position, const ImVec2& size, float thickness, const Color& color, const Color& border /*= Color::Black()*/ )
{
	DrawBox( position, size, thickness, color );
	DrawBox( position - ImVec2( thickness, thickness ), size + ImVec2( thickness * 2.f, thickness * 2.f ), 1.f, border );
	DrawBox( position + ImVec2( thickness, thickness ), size - ImVec2( thickness * 2.f, thickness * 2.f ), 1.f, border );
}

void Renderer::DrawCornerBox( const ImVec2& position, const ImVec2& size, float thickness, const Color& color )
{
	const auto line_size = size * 0.25f;

	DrawRect( position, { line_size[ 0 ], thickness }, color ); // top left -> right
	DrawRect( position, { thickness, line_size[ 1 ] }, color ); // top left -> bottom

	DrawRect( { position[ 0 ], position[ 1 ] + size[ 1 ] - line_size[ 1 ] + thickness }, { thickness, line_size[ 1 ] }, color ); // bottom left -> top
	DrawRect( { position[ 0 ], position[ 1 ] + size[ 1 ] }, { line_size[ 0 ], thickness }, color ); // bottom left -> right

	DrawRect( { position[ 0 ] + size[ 0 ] - line_size[ 0 ] + thickness, position[ 1 ] }, { line_size[ 0 ], thickness }, color ); // top right -> left
	DrawRect( { position[ 0 ] + size[ 0 ], position[ 1 ] }, { thickness, line_size[ 1 ] }, color ); // top right -> bottom

	DrawRect( { position[ 0 ] + size[ 0 ] - line_size[ 0 ] + thickness, position[ 1 ] + size[ 1 ] }, { line_size[ 0 ], thickness }, color ); // bottom right -> left
	DrawRect( { position[ 0 ] + size[ 0 ], position[ 1 ] + size[ 1 ] - line_size[ 1 ] + thickness }, { thickness, line_size[ 1 ] }, color ); // bottom right -> top
}

void Renderer::DrawCornerBoxBorder( const ImVec2& position, const ImVec2& size, float thickness, const Color& color, const Color& border /*= Color::Black()*/ )
{
	const auto line_size = size * 0.25f;

	DrawRect( { position[ 0 ] - thickness, position[ 1 ] - thickness }, { line_size[ 0 ] + thickness * 2.f, 1.f + thickness * 2.f }, border ); // top left -> right
	DrawRect( { position[ 0 ] - thickness, position[ 1 ] - thickness }, { 1.f + thickness * 2.f, line_size[ 1 ] + thickness * 2.f }, border ); // top left -> bottom
	DrawRect( { position[ 0 ] - thickness, position[ 1 ] + size[ 1 ] - line_size[ 1 ] }, { 1.f + thickness * 2.f, line_size[ 1 ] + thickness * 2.f }, border ); // bottom left -> top
	DrawRect( { position[ 0 ] - thickness, position[ 1 ] + size[ 1 ] - thickness }, { line_size[ 0 ] + thickness * 2.f, 1.f + thickness * 2.f }, border ); // bottom left -> right
	DrawRect( { position[ 0 ] + size[ 0 ] - line_size[ 0 ], position[ 1 ] - thickness }, { line_size[ 0 ] + thickness * 2.f, 1.f + thickness * 2.f }, border ); // top right -> left
	DrawRect( { position[ 0 ] + size[ 0 ] - thickness, position[ 1 ] - thickness }, { 1.f + thickness * 2.f, line_size[ 1 ] + thickness * 2.f }, border ); // top right -> bottom
	DrawRect( { position[ 0 ] + size[ 0 ] - line_size[ 0 ], position[ 1 ] + size[ 1 ] - thickness }, { line_size[ 0 ] + thickness * 2.f, 1.f + thickness * 2.f }, border ); // bottom right -> left
	DrawRect( { position[ 0 ] + size[ 0 ] - thickness, position[ 1 ] + size[ 1 ] - line_size[ 1 ] }, { 1.f + thickness * 2.f, line_size[ 1 ] + thickness * 2.f }, border ); // bottom right -> top

	DrawCornerBox( position, size, thickness, color );
}

void Renderer::DrawText( const ImVec2& position, std::uint32_t layout, const Color& color, const char* const format, ... )
{
	va_list arg_pack = { };
	va_start( arg_pack, format );
	DrawTextFormat( position, layout, color, Color::Transparent(), format, arg_pack );
	va_end( arg_pack );
}

void Renderer::DrawTextShadow( const ImVec2& position, std::uint32_t layout, const Color& color, const char* const format, ... )
{
	const auto shadow = Color::Black( color.m_alpha );

	va_list arg_pack = { };
	va_start( arg_pack, format );
	DrawTextFormat( position + ImVec2( 1.f, 1.f ), layout, shadow, Color::Transparent(), format, arg_pack );
	DrawTextFormat( position, layout, color, Color::Transparent(), format, arg_pack );
	va_end( arg_pack );
}

void Renderer::DrawTextBorder( const ImVec2& position, std::uint32_t layout, const Color& color, const Color& border, const char* const format, ... )
{
	va_list arg_pack = { };
	va_start( arg_pack, format );
	DrawTextFormat( position, layout, color, border, format, arg_pack );
	va_end( arg_pack );
}

void Renderer::DrawTexture( ImTextureID texture_id, const ImVec2& position, const ImVec2& size, const Color& color /*= Color::White()*/ )
{
	m_draw_list->AddImage( texture_id, { position[ 0 ], position[ 1 ] }, { position[ 0 ] + size[ 0 ], position[ 1 ] + size[ 1 ] }, { 0.f, 0.f }, { 1.f, 1.f }, ImColor( color.m_red, color.m_green, color.m_blue, color.m_alpha ) );
}

void Renderer::DrawTextFormat( ImVec2 position, std::uint32_t layout, const Color& color, const Color& border, const char* const format, va_list arg_pack )
{
	const auto output_length = static_cast< std::size_t >( win32::vsprintf_s( nullptr, 0, format, arg_pack ) );

	if( !output_length )
	{
		return;
	}

	const auto output = std::make_unique< char[] >( output_length + 1 );
	win32::vsprintf_s( output.get(), output_length, format, arg_pack );

	const auto size = ImGui::CalcTextSize( output.get() );

	if( layout & TextRight )
	{
		position[ 0 ] -= size[ 0 ];
	}
	else if( layout & TextCenterH )
	{
		position[ 0 ] -= size[ 0 ] * 0.5f;
	}

	if( layout & TextCenterV )
	{
		position[ 1 ] -= size[ 1 ] * 0.5f;
	}

	if( border.m_alpha > 0.f )
	{
		DrawRect( position, { size[ 0 ], size[ 1 ] }, border );
	}

	m_draw_list->AddText( { position[ 0 ], position[ 1 ] }, ImColor( color.m_red, color.m_green, color.m_blue, color.m_alpha ), output.get() );
}

bool Renderer::CreateRenderTarget()
{
	ID3D11Texture2D* texture2d = nullptr;

	// try to acquire render target texture
	auto result = m_swap_chain->GetBuffer( 0, IID_PPV_ARGS( &texture2d ) );

	if( FAILED( result ) )
	{
		TRACE( "%s: IDXGISwapChain::GetBuffer( ... ) error! (0x%08X)", FN, result );
		return false;
	}

	// try to create render target
	result = m_device->CreateRenderTargetView( texture2d, nullptr, &m_render_target_view );

	// release texture
	memory::SafeRelease( texture2d );

	if( FAILED( result ) )
	{
		TRACE( "%s: ID3D11Device::CreateRenderTargetView( ... ) error! (0x%08X)", FN, result );
		return false;
	}

	return true;
}

void Renderer::DestroyRenderTarget()
{
	memory::SafeRelease( m_render_target_view );
}

} // namespace horizon::graphics
```

`horizon/graphics/renderer.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "../core/singleton.hpp"

#include "../win32/basic.hpp"
#include "../win32/image.hpp"
#include "../win32/math.hpp"
#include "../win32/process.hpp"
#include "../win32/string.hpp"
#include "../win32/time.hpp"
#include "../win32/trace.hpp"

#define IMGUI_DEFINE_MATH_OPERATORS

#include "../imgui/imgui.hpp"
#include "../imgui/imgui_internal.hpp"

#include "../imgui/imgui_impl_win32.hpp"
#include "../imgui/imgui_impl_dx11.hpp"

#include "color.hpp"

namespace horizon::graphics
{

enum TextLayout : std::uint32_t
{
	TextLeft = 0x0000,
	TextRight = 0x0001,
	TextCenterV = 0x0002,
	TextCenterH = 0x0004,
	TextCenter = ( TextCenterV | TextCenterH ),
};

class Renderer : public core::Singleton< Renderer >
{
public:
	~Renderer();

public:
	bool Create( IDXGISwapChain* swap_chain );
	void Destroy();

	bool Begin();
	void End();

	void Lost();
	bool Reset();

	bool Intersect( const ImVec2& position );

	IDXGISwapChain* GetSwapChain() const;
	ID3D11Device* GetDevice() const;
	ID3D11DeviceContext* GetDeviceContext() const;

	const D3D11_VIEWPORT& GetViewport() const;

public:
	void DrawCircle( const ImVec2& center_screen, float radius, const Color& color, int segments = 12 );
	void DrawLine( const ImVec2& begin, const ImVec2& end, const Color& color );
	void DrawRect( const ImVec2& position, const ImVec2& size, const Color& color );

	void DrawBox( const ImVec2& position, const ImVec2& size, float thickness, const Color& color );
	void DrawBoxBorder( const ImVec2& position, const ImVec2& size, float thickness, const Color& color, const Color& border = Color::Black() );

	void DrawCornerBox( const ImVec2& position, const ImVec2& size, float thickness, const Color& color );
	void DrawCornerBoxBorder( const ImVec2& position, const ImVec2& size, float thickness, const Color& color, const Color& border = Color::Black() );

	void DrawText( const ImVec2& position, std::uint32_t layout, const Color& color, const char* const format, ... );
	void DrawTextShadow( const ImVec2& position, std::uint32_t layout, const Color& color, const char* const format, ... );
	void DrawTextBorder( const ImVec2& position, std::uint32_t layout, const Color& color, const Color& border, const char* const format, ... );

	void DrawTexture( ImTextureID texture_id, const ImVec2& position, const ImVec2& size, const Color& color = Color::White() );

protected:
	void DrawTextFormat( ImVec2 position, std::uint32_t layout, const Color& color, const Color& border, const char* const format, va_list arg_pack );

protected:
	bool CreateRenderTarget();
	void DestroyRenderTarget();

protected:
	// 
	// d3d11 data
	// 
	IDXGISwapChain* m_swap_chain = nullptr;
	ID3D11Device* m_device = nullptr;
	ID3D11DeviceContext* m_device_context = nullptr;

	// 
	// win32 object
	// 
	void* m_window = nullptr;

	// 
	// imgui data
	// 
	ImGuiContext* m_context = nullptr;
	ImDrawList* m_draw_list = nullptr;

	// 
	// render target view
	// 
	ID3D11RenderTargetView* m_render_target_view = nullptr;

	// 
	// viewport
	// 
	std::uint32_t m_viewport_count = 1;
	D3D11_VIEWPORT m_viewport = { };
};

} // namespace horizon::graphics
```

`horizon/hde/hde64.cpp`:

```cpp
/*
 * Hacker Disassembler Engine 64 C++
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 */

#include "../include/base.hpp"

#if defined( HORIZON_X64 )

#include "hde64.hpp"
#include "table64.hpp"

#include <intrin.h>

unsigned int hde64_disasm( const void* code, hde64s* hs )
{
  uint8_t x, c, * p = ( uint8_t* )code, cflags, opcode, pref = 0;
  uint8_t* ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
  uint8_t op64 = 0;

  // Avoid using memset to reduce the footprint.
#ifndef _MSC_VER
  memset( ( LPBYTE )hs, 0, sizeof( hde64s ) );
#else
  __stosb( ( unsigned char* )hs, 0, sizeof( hde64s ) );
#endif

  for( x = 16; x; x-- )
    switch( c = *p++ )
    {
      case 0xf3:
        hs->p_rep = c;
        pref |= PRE_F3;
        break;
      case 0xf2:
        hs->p_rep = c;
        pref |= PRE_F2;
        break;
      case 0xf0:
        hs->p_lock = c;
        pref |= PRE_LOCK;
        break;
      case 0x26: case 0x2e: case 0x36:
      case 0x3e: case 0x64: case 0x65:
        hs->p_seg = c;
        pref |= PRE_SEG;
        break;
      case 0x66:
        hs->p_66 = c;
        pref |= PRE_66;
        break;
      case 0x67:
        hs->p_67 = c;
        pref |= PRE_67;
        break;
      default:
        goto pref_done;
    }
pref_done:

  hs->flags = ( uint32_t )pref << 23;

  if( !pref )
    pref |= PRE_NONE;

  if( ( c & 0xf0 ) == 0x40 )
  {
    hs->flags |= F_PREFIX_REX;
    if( ( hs->rex_w = ( c & 0xf ) >> 3 ) && ( *p & 0xf8 ) == 0xb8 )
      op64++;
    hs->rex_r = ( c & 7 ) >> 2;
    hs->rex_x = ( c & 3 ) >> 1;
    hs->rex_b = c & 1;
    if( ( ( c = *p++ ) & 0xf0 ) == 0x40 )
    {
      opcode = c;
      goto error_opcode;
    }
  }

  if( ( hs->opcode = c ) == 0x0f )
  {
    hs->opcode2 = c = *p++;
    ht += DELTA_OPCODES;
  }
  else if( c >= 0xa0 && c <= 0xa3 )
  {
    op64++;
    if( pref & PRE_67 )
      pref |= PRE_66;
    else
      pref &= ~PRE_66;
  }

  opcode = c;
  cflags = ht[ ht[ opcode / 4 ] + ( opcode % 4 ) ];

  if( cflags == C_ERROR )
  {
  error_opcode:
    hs->flags |= F_ERROR | F_ERROR_OPCODE;
    cflags = 0;
    if( ( opcode & -3 ) == 0x24 )
      cflags++;
  }

  x = 0;
  if( cflags & C_GROUP )
  {
    uint16_t t;
    t = *( uint16_t* )( ht + ( cflags & 0x7f ) );
    cflags = ( uint8_t )t;
    x = ( uint8_t )( t >> 8 );
  }

  if( hs->opcode2 )
  {
    ht = hde64_table + DELTA_PREFIXES;
    if( ht[ ht[ opcode / 4 ] + ( opcode % 4 ) ] & pref )
      hs->flags |= F_ERROR | F_ERROR_OPCODE;
  }

  if( cflags & C_MODRM )
  {
    hs->flags |= F_MODRM;
    hs->modrm = c = *p++;
    hs->modrm_mod = m_mod = c >> 6;
    hs->modrm_rm = m_rm = c & 7;
    hs->modrm_reg = m_reg = ( c & 0x3f ) >> 3;

    if( x && ( ( x << m_reg ) & 0x80 ) )
      hs->flags |= F_ERROR | F_ERROR_OPCODE;

    if( !hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf )
    {
      uint8_t t = opcode - 0xd9;
      if( m_mod == 3 )
      {
        ht = hde64_table + DELTA_FPU_MODRM + t * 8;
        t = ht[ m_reg ] << m_rm;
      }
      else
      {
        ht = hde64_table + DELTA_FPU_REG;
        t = ht[ t ] << m_reg;
      }
      if( t & 0x80 )
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if( pref & PRE_LOCK )
    {
      if( m_mod == 3 )
      {
        hs->flags |= F_ERROR | F_ERROR_LOCK;
      }
      else
      {
        uint8_t* table_end, op = opcode;
        if( hs->opcode2 )
        {
          ht = hde64_table + DELTA_OP2_LOCK_OK;
          table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
        }
        else
        {
          ht = hde64_table + DELTA_OP_LOCK_OK;
          table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
          op &= -2;
        }
        for( ; ht != table_end; ht++ )
          if( *ht++ == op )
          {
            if( !( ( *ht << m_reg ) & 0x80 ) )
              goto no_lock_error;
            else
              break;
          }
        hs->flags |= F_ERROR | F_ERROR_LOCK;
      no_lock_error:
        ;
      }
    }

    if( hs->opcode2 )
    {
      switch( opcode )
      {
        case 0x20: case 0x22:
          m_mod = 3;
          if( m_reg > 4 || m_reg == 1 )
            goto error_operand;
          else
            goto no_error_operand;
        case 0x21: case 0x23:
          m_mod = 3;
          if( m_reg == 4 || m_reg == 5 )
            goto error_operand;
          else
            goto no_error_operand;
      }
    }
    else
    {
      switch( opcode )
      {
        case 0x8c:
          if( m_reg > 5 )
            goto error_operand;
          else
            goto no_error_operand;
        case 0x8e:
          if( m_reg == 1 || m_reg > 5 )
            goto error_operand;
          else
            goto no_error_operand;
      }
    }

    if( m_mod == 3 )
    {
      uint8_t* table_end;
      if( hs->opcode2 )
      {
        ht = hde64_table + DELTA_OP2_ONLY_MEM;
        table_end = ht + sizeof( hde64_table ) - DELTA_OP2_ONLY_MEM;
      }
      else
      {
        ht = hde64_table + DELTA_OP_ONLY_MEM;
        table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
      }
      for( ; ht != table_end; ht += 2 )
        if( *ht++ == opcode )
        {
          if( *ht++ & pref && !( ( *ht << m_reg ) & 0x80 ) )
            goto error_operand;
          else
            break;
        }
      goto no_error_operand;
    }
    else if( hs->opcode2 )
    {
      switch( opcode )
      {
        case 0x50: case 0xd7: case 0xf7:
          if( pref & ( PRE_NONE | PRE_66 ) )
            goto error_operand;
          break;
        case 0xd6:
          if( pref & ( PRE_F2 | PRE_F3 ) )
            goto error_operand;
          break;
        case 0xc5:
          goto error_operand;
      }
      goto no_error_operand;
    }
    else
      goto no_error_operand;

  error_operand:
    hs->flags |= F_ERROR | F_ERROR_OPERAND;
  no_error_operand:

    c = *p++;
    if( m_reg <= 1 )
    {
      if( opcode == 0xf6 )
        cflags |= C_IMM8;
      else if( opcode == 0xf7 )
        cflags |= C_IMM_P66;
    }

    switch( m_mod )
    {
      case 0:
        if( pref & PRE_67 )
        {
          if( m_rm == 6 )
            disp_size = 2;
        }
        else
          if( m_rm == 5 )
            disp_size = 4;
        break;
      case 1:
        disp_size = 1;
        break;
      case 2:
        disp_size = 2;
        if( !( pref & PRE_67 ) )
          disp_size <<= 1;
    }

    if( m_mod != 3 && m_rm == 4 )
    {
      hs->flags |= F_SIB;
      p++;
      hs->sib = c;
      hs->sib_scale = c >> 6;
      hs->sib_index = ( c & 0x3f ) >> 3;
      if( ( hs->sib_base = c & 7 ) == 5 && !( m_mod & 1 ) )
        disp_size = 4;
    }

    p--;
    switch( disp_size )
    {
      case 1:
        hs->flags |= F_DISP8;
        hs->disp.disp8 = *p;
        break;
      case 2:
        hs->flags |= F_DISP16;
        hs->disp.disp16 = *( uint16_t* )p;
        break;
      case 4:
        hs->flags |= F_DISP32;
        hs->disp.disp32 = *( uint32_t* )p;
    }
    p += disp_size;
  }
  else if( pref & PRE_LOCK )
    hs->flags |= F_ERROR | F_ERROR_LOCK;

  if( cflags & C_IMM_P66 )
  {
    if( cflags & C_REL32 )
    {
      if( pref & PRE_66 )
      {
        hs->flags |= F_IMM16 | F_RELATIVE;
        hs->imm.imm16 = *( uint16_t* )p;
        p += 2;
        goto disasm_done;
      }
      goto rel32_ok;
    }
    if( op64 )
    {
      hs->flags |= F_IMM64;
      hs->imm.imm64 = *( uint64_t* )p;
      p += 8;
    }
    else if( !( pref & PRE_66 ) )
    {
      hs->flags |= F_IMM32;
      hs->imm.imm32 = *( uint32_t* )p;
      p += 4;
    }
    else
      goto imm16_ok;
  }


  if( cflags & C_IMM16 )
  {
  imm16_ok:
    hs->flags |= F_IMM16;
    hs->imm.imm16 = *( uint16_t* )p;
    p += 2;
  }
  if( cflags & C_IMM8 )
  {
    hs->flags |= F_IMM8;
    hs->imm.imm8 = *p++;
  }

  if( cflags & C_REL32 )
  {
  rel32_ok:
    hs->flags |= F_IMM32 | F_RELATIVE;
    hs->imm.imm32 = *( uint32_t* )p;
    p += 4;
  }
  else if( cflags & C_REL8 )
  {
    hs->flags |= F_IMM8 | F_RELATIVE;
    hs->imm.imm8 = *p++;
  }

disasm_done:

  if( ( hs->len = ( uint8_t )( p - ( uint8_t* )code ) ) > 15 )
  {
    hs->flags |= F_ERROR | F_ERROR_LENGTH;
    hs->len = 15;
  }

  return ( unsigned int )hs->len;
}

#endif // defined(_M_X64) || defined(__x86_64__)
```

`horizon/hde/hde64.hpp`:

```hpp
#pragma once

/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.hpp: C++ header file
 */

#include <cstdint>

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack( push, 1 )

typedef struct
{
  std::uint8_t len;
  std::uint8_t p_rep;
  std::uint8_t p_lock;
  std::uint8_t p_seg;
  std::uint8_t p_66;
  std::uint8_t p_67;
  std::uint8_t rex;
  std::uint8_t rex_w;
  std::uint8_t rex_r;
  std::uint8_t rex_x;
  std::uint8_t rex_b;
  std::uint8_t opcode;
  std::uint8_t opcode2;
  std::uint8_t modrm;
  std::uint8_t modrm_mod;
  std::uint8_t modrm_reg;
  std::uint8_t modrm_rm;
  std::uint8_t sib;
  std::uint8_t sib_scale;
  std::uint8_t sib_index;
  std::uint8_t sib_base;
  union
  {
    std::uint8_t imm8;
    std::uint16_t imm16;
    std::uint32_t imm32;
    std::uint64_t imm64;
  } imm;
  union
  {
    std::uint8_t disp8;
    std::uint16_t disp16;
    std::uint32_t disp32;
  } disp;
  std::uint32_t flags;
} hde64s;

#pragma pack( pop )

unsigned int hde64_disasm( const void* code, hde64s* hs );
```

`horizon/hde/table32.hpp`:

```hpp
#pragma once

/*
 * Hacker Disassembler Engine 32 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 */

#include <cstdint>

#define C_NONE              0x00
#define C_MODRM             0x01
#define C_IMM8              0x02
#define C_IMM16             0x04
#define C_IMM_P66           0x10
#define C_REL8              0x20
#define C_REL32             0x40
#define C_GROUP             0x80
#define C_ERROR             0xff

#define PRE_ANY             0x00
#define PRE_NONE            0x01
#define PRE_F2              0x02
#define PRE_F3              0x04
#define PRE_66              0x08
#define PRE_67              0x10
#define PRE_LOCK            0x20
#define PRE_SEG             0x40
#define PRE_ALL             0xff

#define DELTA_OPCODES       0x4a
#define DELTA_FPU_REG       0xf1
#define DELTA_FPU_MODRM     0xf8
#define DELTA_PREFIXES      0x130
#define DELTA_OP_LOCK_OK    0x1a1
#define DELTA_OP2_LOCK_OK   0x1b9
#define DELTA_OP_ONLY_MEM   0x1cb
#define DELTA_OP2_ONLY_MEM  0x1da

std::uint8_t hde32_table[] =
{
	0xa3, 0xa8, 0xa3, 0xa8, 0xa3, 0xa8, 0xa3, 0xa8, 0xa3, 0xa8, 0xa3, 0xa8, 0xa3, 0xa8, 0xa3,
	0xa8, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xac, 0xaa, 0xb2, 0xaa, 0x9f, 0x9f,
	0x9f, 0x9f, 0xb5, 0xa3, 0xa3, 0xa4, 0xaa, 0xaa, 0xba, 0xaa, 0x96, 0xaa, 0xa8, 0xaa, 0xc3,
	0xc3, 0x96, 0x96, 0xb7, 0xae, 0xd6, 0xbd, 0xa3, 0xc5, 0xa3, 0xa3, 0x9f, 0xc3, 0x9c, 0xaa,
	0xaa, 0xac, 0xaa, 0xbf, 0x03, 0x7f, 0x11, 0x7f, 0x01, 0x7f, 0x01, 0x3f, 0x01, 0x01, 0x90,
	0x82, 0x7d, 0x97, 0x59, 0x59, 0x59, 0x59, 0x59, 0x7f, 0x59, 0x59, 0x60, 0x7d, 0x7f, 0x7f,
	0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x9a, 0x88, 0x7d,
	0x59, 0x50, 0x50, 0x50, 0x50, 0x59, 0x59, 0x59, 0x59, 0x61, 0x94, 0x61, 0x9e, 0x59, 0x59,
	0x85, 0x59, 0x92, 0xa3, 0x60, 0x60, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59,
	0x59, 0x59, 0x9f, 0x01, 0x03, 0x01, 0x04, 0x03, 0xd5, 0x03, 0xcc, 0x01, 0xbc, 0x03, 0xf0,
	0x10, 0x10, 0x10, 0x10, 0x50, 0x50, 0x50, 0x50, 0x14, 0x20, 0x20, 0x20, 0x20, 0x01, 0x01,
	0x01, 0x01, 0xc4, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0xc0, 0xc2, 0x10, 0x11,
	0x02, 0x03, 0x11, 0x03, 0x03, 0x04, 0x00, 0x00, 0x14, 0x00, 0x02, 0x00, 0x00, 0xc6, 0xc8,
	0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xca,
	0x01, 0x01, 0x01, 0x00, 0x06, 0x00, 0x04, 0x00, 0xc0, 0xc2, 0x01, 0x01, 0x03, 0x01, 0xff,
	0xff, 0x01, 0x00, 0x03, 0xc4, 0xc4, 0xc6, 0x03, 0x01, 0x01, 0x01, 0xff, 0x03, 0x03, 0x03,
	0xc8, 0x40, 0x00, 0x0a, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x33, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xbf, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
	0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7f, 0x00, 0x00, 0xff, 0x4a, 0x4a, 0x4a, 0x4a, 0x4b, 0x52, 0x4a, 0x4a, 0x4a, 0x4a, 0x4f,
	0x4c, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x55, 0x45, 0x40, 0x4a, 0x4a, 0x4a,
	0x45, 0x59, 0x4d, 0x46, 0x4a, 0x5d, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a,
	0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x61, 0x63, 0x67, 0x4e, 0x4a, 0x4a, 0x6b, 0x6d, 0x4a, 0x4a,
	0x45, 0x6d, 0x4a, 0x4a, 0x44, 0x45, 0x4a, 0x4a, 0x00, 0x00, 0x00, 0x02, 0x0d, 0x06, 0x06,
	0x06, 0x06, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x06, 0x06, 0x06, 0x00, 0x06, 0x06, 0x02, 0x06,
	0x00, 0x0a, 0x0a, 0x07, 0x07, 0x06, 0x02, 0x05, 0x05, 0x02, 0x02, 0x00, 0x00, 0x04, 0x04,
	0x04, 0x04, 0x00, 0x00, 0x00, 0x0e, 0x05, 0x06, 0x06, 0x06, 0x01, 0x06, 0x00, 0x00, 0x08,
	0x00, 0x10, 0x00, 0x18, 0x00, 0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x80, 0x01, 0x82, 0x01,
	0x86, 0x00, 0xf6, 0xcf, 0xfe, 0x3f, 0xab, 0x00, 0xb0, 0x00, 0xb1, 0x00, 0xb3, 0x00, 0xba,
	0xf8, 0xbb, 0x00, 0xc0, 0x00, 0xc1, 0x00, 0xc7, 0xbf, 0x62, 0xff, 0x00, 0x8d, 0xff, 0x00,
	0xc4, 0xff, 0x00, 0xc5, 0xff, 0x00, 0xff, 0xff, 0xeb, 0x01, 0xff, 0x0e, 0x12, 0x08, 0x00,
	0x13, 0x09, 0x00, 0x16, 0x08, 0x00, 0x17, 0x09, 0x00, 0x2b, 0x09, 0x00, 0xae, 0xff, 0x07,
	0xb2, 0xff, 0x00, 0xb4, 0xff, 0x00, 0xb5, 0xff, 0x00, 0xc3, 0x01, 0x00, 0xc7, 0xff, 0xbf,
	0xe7, 0x08, 0x00, 0xf0, 0x02, 0x00,
};
```

`horizon/hde/table64.hpp`:

```hpp
#pragma once

/*
 * Hacker Disassembler Engine 64 C++
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 */

#include <cstdint>

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xfd
#define DELTA_FPU_MODRM    0x104
#define DELTA_PREFIXES     0x13c
#define DELTA_OP_LOCK_OK   0x1ae
#define DELTA_OP2_LOCK_OK  0x1c6
#define DELTA_OP_ONLY_MEM  0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

std::uint8_t hde64_table[] =
{
  0xa5, 0xaa, 0xa5, 0xb8, 0xa5, 0xaa, 0xa5, 0xaa, 0xa5, 0xb8, 0xa5, 0xb8, 0xa5, 0xb8, 0xa5,
  0xb8, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xac, 0xc0, 0xcc, 0xc0, 0xa1, 0xa1,
  0xa1, 0xa1, 0xb1, 0xa5, 0xa5, 0xa6, 0xc0, 0xc0, 0xd7, 0xda, 0xe0, 0xc0, 0xe4, 0xc0, 0xea,
  0xea, 0xe0, 0xe0, 0x98, 0xc8, 0xee, 0xf1, 0xa5, 0xd3, 0xa5, 0xa5, 0xa1, 0xea, 0x9e, 0xc0,
  0xc0, 0xc2, 0xc0, 0xe6, 0x03, 0x7f, 0x11, 0x7f, 0x01, 0x7f, 0x01, 0x3f, 0x01, 0x01, 0xab,
  0x8b, 0x90, 0x64, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x92, 0x5b, 0x5b, 0x76, 0x90, 0x92, 0x92,
  0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x6a, 0x73, 0x90,
  0x5b, 0x52, 0x52, 0x52, 0x52, 0x5b, 0x5b, 0x5b, 0x5b, 0x77, 0x7c, 0x77, 0x85, 0x5b, 0x5b,
  0x70, 0x5b, 0x7a, 0xaf, 0x76, 0x76, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b,
  0x5b, 0x5b, 0x86, 0x01, 0x03, 0x01, 0x04, 0x03, 0xd5, 0x03, 0xd5, 0x03, 0xcc, 0x01, 0xbc,
  0x03, 0xf0, 0x03, 0x03, 0x04, 0x00, 0x50, 0x50, 0x50, 0x50, 0xff, 0x20, 0x20, 0x20, 0x20,
  0x01, 0x01, 0x01, 0x01, 0xc4, 0x02, 0x10, 0xff, 0xff, 0xff, 0x01, 0x00, 0x03, 0x11, 0xff,
  0x03, 0xc4, 0xc6, 0xc8, 0x02, 0x10, 0x00, 0xff, 0xcc, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x01, 0x01, 0x03, 0x01, 0xff, 0xff, 0xc0, 0xc2, 0x10, 0x11, 0x02, 0x03, 0x01, 0x01,
  0x01, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x10,
  0x10, 0x10, 0x10, 0x02, 0x10, 0x00, 0x00, 0xc6, 0xc8, 0x02, 0x02, 0x02, 0x02, 0x06, 0x00,
  0x04, 0x00, 0x02, 0xff, 0x00, 0xc0, 0xc2, 0x01, 0x01, 0x03, 0x03, 0x03, 0xca, 0x40, 0x00,
  0x0a, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x33, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xff, 0xbf, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0xff, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
  0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00,
  0xff, 0x40, 0x40, 0x40, 0x40, 0x41, 0x49, 0x40, 0x40, 0x40, 0x40, 0x4c, 0x42, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x4f, 0x44, 0x53, 0x40, 0x40, 0x40, 0x44, 0x57, 0x43,
  0x5c, 0x40, 0x60, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x64, 0x66, 0x6e, 0x6b, 0x40, 0x40, 0x6a, 0x46, 0x40, 0x40, 0x44, 0x46, 0x40,
  0x40, 0x5b, 0x44, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x06, 0x06, 0x06, 0x06, 0x01, 0x06,
  0x06, 0x02, 0x06, 0x06, 0x00, 0x06, 0x00, 0x0a, 0x0a, 0x00, 0x00, 0x00, 0x02, 0x07, 0x07,
  0x06, 0x02, 0x0d, 0x06, 0x06, 0x06, 0x0e, 0x05, 0x05, 0x02, 0x02, 0x00, 0x00, 0x04, 0x04,
  0x04, 0x04, 0x05, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x08, 0x00, 0x10,
  0x00, 0x18, 0x00, 0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x80, 0x01, 0x82, 0x01, 0x86, 0x00,
  0xf6, 0xcf, 0xfe, 0x3f, 0xab, 0x00, 0xb0, 0x00, 0xb1, 0x00, 0xb3, 0x00, 0xba, 0xf8, 0xbb,
  0x00, 0xc0, 0x00, 0xc1, 0x00, 0xc7, 0xbf, 0x62, 0xff, 0x00, 0x8d, 0xff, 0x00, 0xc4, 0xff,
  0x00, 0xc5, 0xff, 0x00, 0xff, 0xff, 0xeb, 0x01, 0xff, 0x0e, 0x12, 0x08, 0x00, 0x13, 0x09,
  0x00, 0x16, 0x08, 0x00, 0x17, 0x09, 0x00, 0x2b, 0x09, 0x00, 0xae, 0xff, 0x07, 0xb2, 0xff,
  0x00, 0xb4, 0xff, 0x00, 0xb5, 0xff, 0x00, 0xc3, 0x01, 0x00, 0xc7, 0xff, 0xbf, 0xe7, 0x08,
  0x00, 0xf0, 0x02, 0x00,
};
```

`horizon/horizon.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{96858F12-06FC-41DC-98FB-1593B502F373}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>horizon</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <TargetName>$(ProjectName)_debug</TargetName>
    <IntDir>$(SolutionDir)obj\$(ProjectName)\x64\debug\</IntDir>
    <OutDir>$(SolutionDir)bin\x64\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\x64\</OutDir>
    <IntDir>$(SolutionDir)obj\$(ProjectName)\x64\release\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <ExceptionHandling>false</ExceptionHandling>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <AdditionalIncludeDirectories>$(DXSDK_DIR)Include\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>
      </SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ExceptionHandling>false</ExceptionHandling>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <DebugInformationFormat>None</DebugInformationFormat>
      <AdditionalIncludeDirectories>$(DXSDK_DIR)Include\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <OmitDefaultLibName>false</OmitDefaultLibName>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <FloatingPointExceptions>
      </FloatingPointExceptions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>
      </AdditionalDependencies>
    </Lib>
    <MASM>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </MASM>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="constant\character.hpp" />
    <ClInclude Include="constant\secure_string.hpp" />
    <ClInclude Include="core\map_data.hpp" />
    <ClInclude Include="core\mutex.hpp" />
    <ClInclude Include="core\no_copy.hpp" />
    <ClInclude Include="core\no_move.hpp" />
    <ClInclude Include="core\singleton.hpp" />
    <ClInclude Include="core\timer.hpp" />
    <ClInclude Include="constant\hash.hpp" />
    <ClInclude Include="constant\string.hpp" />
    <ClInclude Include="graphics\color.hpp" />
    <ClInclude Include="graphics\renderer.hpp" />
    <ClInclude Include="hde\hde64.hpp" />
    <ClInclude Include="hde\table32.hpp" />
    <ClInclude Include="hde\table64.hpp" />
    <ClInclude Include="imgui\imconfig.hpp" />
    <ClInclude Include="imgui\imgui.hpp" />
    <ClInclude Include="imgui\imgui_impl_dx11.hpp" />
    <ClInclude Include="imgui\imgui_impl_win32.hpp" />
    <ClInclude Include="imgui\imgui_internal.hpp" />
    <ClInclude Include="imgui\imgui_shader_dx11.hpp" />
    <ClInclude Include="imgui\imstb_rectpack.hpp" />
    <ClInclude Include="imgui\imstb_textedit.hpp" />
    <ClInclude Include="imgui\imstb_truetype.hpp" />
    <ClInclude Include="include\auto.hpp" />
    <ClInclude Include="include\base.hpp" />
    <ClInclude Include="include\win32.hpp" />
    <ClInclude Include="memory\arg_stack.hpp" />
    <ClInclude Include="memory\detour_hook.hpp" />
    <ClInclude Include="memory\macro.hpp" />
    <ClInclude Include="memory\operation.hpp" />
    <ClInclude Include="memory\scan.hpp" />
    <ClInclude Include="memory\secure_call.hpp" />
    <ClInclude Include="memory\system_call.hpp" />
    <ClInclude Include="memory\vftable_hook.hpp" />
    <ClInclude Include="vcruntime\dll_dllmain.hpp" />
    <ClInclude Include="vcruntime\initializers.hpp" />
    <ClInclude Include="vcruntime\internal_shared.hpp" />
    <ClInclude Include="vcruntime\memory.hpp" />
    <ClInclude Include="vcruntime\security_cookie.hpp" />
    <ClInclude Include="vcruntime\thread_local_storage.hpp" />
    <ClInclude Include="vcruntime\thread_safe_statics.hpp" />
    <ClInclude Include="win32\basic.hpp" />
    <ClInclude Include="win32\core_types.hpp" />
    <ClInclude Include="win32\file.hpp" />
    <ClInclude Include="win32\input_manager.hpp" />
    <ClInclude Include="win32\math.hpp" />
    <ClInclude Include="win32\sdk\access_mask.hpp" />
    <ClInclude Include="win32\sdk\activation_context_stack.hpp" />
    <ClInclude Include="win32\sdk\alternative_architecture_type.hpp" />
    <ClInclude Include="win32\sdk\constant_section.hpp" />
    <ClInclude Include="win32\sdk\event_basic_information.hpp" />
    <ClInclude Include="win32\sdk\event_information_class.hpp" />
    <ClInclude Include="win32\sdk\event_type.hpp" />
    <ClInclude Include="win32\sdk\file_basic_information.hpp" />
    <ClInclude Include="win32\sdk\file_directory_information.hpp" />
    <ClInclude Include="win32\sdk\file_id_both_dir_information.hpp" />
    <ClInclude Include="win32\sdk\file_information_class.hpp" />
    <ClInclude Include="win32\sdk\file_standard_information.hpp" />
    <ClInclude Include="win32\sdk\gdi_teb_batch.hpp" />
    <ClInclude Include="win32\sdk\guid.hpp" />
    <ClInclude Include="win32\sdk\handle.hpp" />
    <ClInclude Include="win32\sdk\image_base_relocation.hpp" />
    <ClInclude Include="win32\sdk\image_data_directory.hpp" />
    <ClInclude Include="win32\sdk\image_dos_header.hpp" />
    <ClInclude Include="win32\sdk\image_export_directory.hpp" />
    <ClInclude Include="win32\sdk\image_file_header.hpp" />
    <ClInclude Include="win32\sdk\image_import_by_name.hpp" />
    <ClInclude Include="win32\sdk\image_import_descriptor.hpp" />
    <ClInclude Include="win32\sdk\image_nt_headers.hpp" />
    <ClInclude Include="win32\sdk\image_optional_header.hpp" />
    <ClInclude Include="win32\sdk\image_relocation.hpp" />
    <ClInclude Include="win32\sdk\image_runtime_function_entry.hpp" />
    <ClInclude Include="win32\sdk\image_section_header.hpp" />
    <ClInclude Include="win32\sdk\image_thunk_data.hpp" />
    <ClInclude Include="win32\sdk\io_apc_routine.hpp" />
    <ClInclude Include="win32\sdk\io_status_block.hpp" />
    <ClInclude Include="win32\sdk\ksystem_time.hpp" />
    <ClInclude Include="win32\sdk\kuser_shared_data.hpp" />
    <ClInclude Include="win32\sdk\memory_basic_information.hpp" />
    <ClInclude Include="win32\sdk\memory_enclave_image_information.hpp" />
    <ClInclude Include="win32\sdk\memory_frame_information.hpp" />
    <ClInclude Include="win32\sdk\memory_image_information.hpp" />
    <ClInclude Include="win32\sdk\memory_information_class.hpp" />
    <ClInclude Include="win32\sdk\memory_region_information.hpp" />
    <ClInclude Include="win32\sdk\memory_shared_commit_information.hpp" />
    <ClInclude Include="win32\sdk\memory_working_set_block.hpp" />
    <ClInclude Include="win32\sdk\memory_working_set_ex_block.hpp" />
    <ClInclude Include="win32\sdk\memory_working_set_ex_information.hpp" />
    <ClInclude Include="win32\sdk\memory_working_set_ex_location.hpp" />
    <ClInclude Include="win32\sdk\memory_working_set_information.hpp" />
    <ClInclude Include="win32\sdk\mutant_basic_information.hpp" />
    <ClInclude Include="win32\sdk\mutant_information_class.hpp" />
    <ClInclude Include="win32\sdk\nt_product_type.hpp" />
    <ClInclude Include="win32\sdk\object_attributes.hpp" />
    <ClInclude Include="win32\sdk\object_basic_information.hpp" />
    <ClInclude Include="win32\sdk\object_information_class.hpp" />
    <ClInclude Include="win32\sdk\object_name_information.hpp" />
    <ClInclude Include="win32\sdk\object_wait_type.hpp" />
    <ClInclude Include="win32\sdk\constant_page.hpp" />
    <ClInclude Include="win32\sdk\peb.hpp" />
    <ClInclude Include="win32\sdk\peb_ldr_data.hpp" />
    <ClInclude Include="win32\sdk\constant_region.hpp" />
    <ClInclude Include="win32\sdk\rtl_activation_context_stack_frame.hpp" />
    <ClInclude Include="win32\sdk\rtl_balanced_node.hpp" />
    <ClInclude Include="win32\sdk\client_id.hpp" />
    <ClInclude Include="win32\sdk\exception_registration_record.hpp" />
    <ClInclude Include="win32\sdk\large_integer.hpp" />
    <ClInclude Include="win32\sdk\ldr_data_table_entry.hpp" />
    <ClInclude Include="win32\sdk\list_entry.hpp" />
    <ClInclude Include="win32\sdk\nt_tib.hpp" />
    <ClInclude Include="win32\sdk\rtl_condition_variable.hpp" />
    <ClInclude Include="win32\sdk\rtl_critical_section.hpp" />
    <ClInclude Include="win32\sdk\rtl_critical_section_debug.hpp" />
    <ClInclude Include="win32\sdk\rtl_heap_parameters.hpp" />
    <ClInclude Include="win32\sdk\section_basic_information.hpp" />
    <ClInclude Include="win32\sdk\section_information_class.hpp" />
    <ClInclude Include="win32\sdk\section_inherit.hpp" />
    <ClInclude Include="win32\sdk\string.hpp" />
    <ClInclude Include="win32\sdk\teb.hpp" />
    <ClInclude Include="win32\sdk\ularge_integer.hpp" />
    <ClInclude Include="win32\sdk\unicode_string.hpp" />
    <ClInclude Include="win32\sdk\xstate_configuration.hpp" />
    <ClInclude Include="win32\sdk\xstate_feature.hpp" />
    <ClInclude Include="win32\trace.hpp" />
    <ClInclude Include="win32\image.hpp" />
    <ClInclude Include="win32\process.hpp" />
    <ClInclude Include="win32\string.hpp" />
    <ClInclude Include="win32\time.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="core\map_data.cpp" />
    <ClCompile Include="core\mutex.cpp" />
    <ClCompile Include="core\timer.cpp" />
    <ClCompile Include="graphics\color.cpp" />
    <ClCompile Include="graphics\renderer.cpp" />
    <ClCompile Include="hde\hde64.cpp" />
    <ClCompile Include="imgui\imgui.cpp" />
    <ClCompile Include="imgui\imgui_draw.cpp" />
    <ClCompile Include="imgui\imgui_impl_dx11.cpp" />
    <ClCompile Include="imgui\imgui_impl_win32.cpp" />
    <ClCompile Include="imgui\imgui_shader_dx11.cpp" />
    <ClCompile Include="imgui\imgui_widgets.cpp" />
    <ClCompile Include="memory\detour_hook.cpp" />
    <ClCompile Include="memory\operation.cpp" />
    <ClCompile Include="memory\scan.cpp" />
    <ClCompile Include="memory\vftable_hook.cpp" />
    <ClCompile Include="vcruntime\dll_dllmain.cpp" />
    <ClCompile Include="vcruntime\initializers.cpp" />
    <ClCompile Include="vcruntime\memory.cpp" />
    <ClCompile Include="vcruntime\operator.cpp" />
    <ClCompile Include="vcruntime\security_cookie.cpp" />
    <ClCompile Include="vcruntime\thread_safe_statics.cpp" />
    <ClCompile Include="vcruntime\thread_local_storage.cpp" />
    <ClCompile Include="win32\basic.cpp" />
    <ClCompile Include="win32\file.cpp" />
    <ClCompile Include="win32\input_manager.cpp" />
    <ClCompile Include="win32\math.cpp" />
    <ClCompile Include="win32\trace.cpp" />
    <ClCompile Include="win32\image.cpp" />
    <ClCompile Include="win32\process.cpp" />
    <ClCompile Include="win32\string.cpp" />
    <ClCompile Include="win32\time.cpp" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="memory\x64\code_secure_call.asm" />
    <MASM Include="memory\x64\code_system_call.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`horizon/horizon.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClInclude Include="include\auto.hpp" />
    <ClInclude Include="include\base.hpp" />
    <ClInclude Include="include\win32.hpp" />
    <ClInclude Include="win32\string.hpp" />
    <ClInclude Include="win32\process.hpp" />
    <ClInclude Include="win32\image.hpp" />
    <ClInclude Include="core\no_copy.hpp" />
    <ClInclude Include="core\no_move.hpp" />
    <ClInclude Include="core\singleton.hpp" />
    <ClInclude Include="vcruntime\thread_safe_statics.hpp" />
    <ClInclude Include="vcruntime\security_cookie.hpp" />
    <ClInclude Include="win32\time.hpp" />
    <ClInclude Include="core\mutex.hpp" />
    <ClInclude Include="core\timer.hpp" />
    <ClInclude Include="vcruntime\dll_dllmain.hpp" />
    <ClInclude Include="vcruntime\thread_local_storage.hpp" />
    <ClInclude Include="memory\operation.hpp" />
    <ClInclude Include="memory\scan.hpp" />
    <ClInclude Include="memory\vftable_hook.hpp" />
    <ClInclude Include="win32\trace.hpp" />
    <ClInclude Include="win32\sdk\large_integer.hpp" />
    <ClInclude Include="win32\sdk\ularge_integer.hpp" />
    <ClInclude Include="win32\sdk\list_entry.hpp" />
    <ClInclude Include="win32\sdk\string.hpp" />
    <ClInclude Include="win32\sdk\unicode_string.hpp" />
    <ClInclude Include="win32\sdk\client_id.hpp" />
    <ClInclude Include="win32\sdk\nt_tib.hpp" />
    <ClInclude Include="win32\sdk\exception_registration_record.hpp" />
    <ClInclude Include="win32\sdk\ldr_data_table_entry.hpp" />
    <ClInclude Include="win32\sdk\rtl_balanced_node.hpp" />
    <ClInclude Include="win32\sdk\teb.hpp" />
    <ClInclude Include="win32\sdk\peb.hpp" />
    <ClInclude Include="win32\sdk\peb_ldr_data.hpp" />
    <ClInclude Include="win32\sdk\rtl_critical_section_debug.hpp" />
    <ClInclude Include="win32\sdk\rtl_critical_section.hpp" />
    <ClInclude Include="win32\math.hpp" />
    <ClInclude Include="memory\detour_hook.hpp" />
    <ClInclude Include="win32\input_manager.hpp" />
    <ClInclude Include="hde\table32.hpp" />
    <ClInclude Include="hde\table64.hpp" />
    <ClInclude Include="hde\hde64.hpp" />
    <ClInclude Include="constant\hash.hpp" />
    <ClInclude Include="constant\string.hpp" />
    <ClInclude Include="constant\character.hpp" />
    <ClInclude Include="constant\secure_string.hpp" />
    <ClInclude Include="win32\sdk\event_type.hpp" />
    <ClInclude Include="win32\sdk\access_mask.hpp" />
    <ClInclude Include="win32\sdk\object_attributes.hpp" />
    <ClInclude Include="win32\sdk\event_information_class.hpp" />
    <ClInclude Include="win32\sdk\event_basic_information.hpp" />
    <ClInclude Include="win32\sdk\object_information_class.hpp" />
    <ClInclude Include="win32\sdk\object_wait_type.hpp" />
    <ClInclude Include="win32\sdk\object_basic_information.hpp" />
    <ClInclude Include="win32\sdk\object_name_information.hpp" />
    <ClInclude Include="win32\sdk\io_status_block.hpp" />
    <ClInclude Include="win32\sdk\io_apc_routine.hpp" />
    <ClInclude Include="win32\sdk\file_basic_information.hpp" />
    <ClInclude Include="win32\sdk\mutant_information_class.hpp" />
    <ClInclude Include="win32\sdk\mutant_basic_information.hpp" />
    <ClInclude Include="win32\sdk\section_inherit.hpp" />
    <ClInclude Include="win32\sdk\section_information_class.hpp" />
    <ClInclude Include="win32\sdk\section_basic_information.hpp" />
    <ClInclude Include="win32\sdk\constant_page.hpp" />
    <ClInclude Include="win32\sdk\constant_region.hpp" />
    <ClInclude Include="win32\sdk\constant_section.hpp" />
    <ClInclude Include="win32\sdk\memory_working_set_block.hpp" />
    <ClInclude Include="win32\sdk\memory_working_set_information.hpp" />
    <ClInclude Include="win32\sdk\memory_region_information.hpp" />
    <ClInclude Include="win32\sdk\memory_working_set_ex_location.hpp" />
    <ClInclude Include="win32\sdk\memory_working_set_ex_block.hpp" />
    <ClInclude Include="win32\sdk\memory_working_set_ex_information.hpp" />
    <ClInclude Include="win32\sdk\memory_shared_commit_information.hpp" />
    <ClInclude Include="win32\sdk\memory_image_information.hpp" />
    <ClInclude Include="win32\sdk\memory_enclave_image_information.hpp" />
    <ClInclude Include="win32\sdk\memory_frame_information.hpp" />
    <ClInclude Include="win32\sdk\memory_information_class.hpp" />
    <ClInclude Include="win32\sdk\memory_basic_information.hpp" />
    <ClInclude Include="win32\sdk\rtl_heap_parameters.hpp" />
    <ClInclude Include="win32\sdk\rtl_condition_variable.hpp" />
    <ClInclude Include="core\map_data.hpp" />
    <ClInclude Include="win32\sdk\image_runtime_function_entry.hpp" />
    <ClInclude Include="win32\core_types.hpp" />
    <ClInclude Include="win32\sdk\image_dos_header.hpp" />
    <ClInclude Include="win32\sdk\image_file_header.hpp" />
    <ClInclude Include="win32\sdk\image_data_directory.hpp" />
    <ClInclude Include="win32\sdk\image_optional_header.hpp" />
    <ClInclude Include="win32\sdk\image_nt_headers.hpp" />
    <ClInclude Include="win32\sdk\image_section_header.hpp" />
    <ClInclude Include="win32\sdk\image_relocation.hpp" />
    <ClInclude Include="win32\sdk\image_base_relocation.hpp" />
    <ClInclude Include="win32\sdk\image_export_directory.hpp" />
    <ClInclude Include="win32\sdk\image_import_by_name.hpp" />
    <ClInclude Include="win32\sdk\image_thunk_data.hpp" />
    <ClInclude Include="win32\sdk\image_import_descriptor.hpp" />
    <ClInclude Include="win32\sdk\handle.hpp" />
    <ClInclude Include="win32\sdk\rtl_activation_context_stack_frame.hpp" />
    <ClInclude Include="win32\sdk\activation_context_stack.hpp" />
    <ClInclude Include="win32\sdk\gdi_teb_batch.hpp" />
    <ClInclude Include="win32\sdk\guid.hpp" />
    <ClInclude Include="memory\secure_call.hpp" />
    <ClInclude Include="memory\system_call.hpp" />
    <ClInclude Include="imgui\imconfig.hpp" />
    <ClInclude Include="imgui\imgui.hpp" />
    <ClInclude Include="imgui\imgui_internal.hpp" />
    <ClInclude Include="imgui\imstb_rectpack.hpp" />
    <ClInclude Include="imgui\imstb_textedit.hpp" />
    <ClInclude Include="imgui\imstb_truetype.hpp" />
    <ClInclude Include="imgui\imgui_impl_dx11.hpp" />
    <ClInclude Include="imgui\imgui_impl_win32.hpp" />
    <ClInclude Include="imgui\imgui_shader_dx11.hpp" />
    <ClInclude Include="win32\sdk\kuser_shared_data.hpp" />
    <ClInclude Include="win32\sdk\ksystem_time.hpp" />
    <ClInclude Include="win32\sdk\nt_product_type.hpp" />
    <ClInclude Include="win32\sdk\alternative_architecture_type.hpp" />
    <ClInclude Include="win32\sdk\xstate_feature.hpp" />
    <ClInclude Include="win32\sdk\xstate_configuration.hpp" />
    <ClInclude Include="win32\basic.hpp" />
    <ClInclude Include="graphics\color.hpp" />
    <ClInclude Include="graphics\renderer.hpp" />
    <ClInclude Include="vcruntime\memory.hpp" />
    <ClInclude Include="win32\sdk\file_information_class.hpp" />
    <ClInclude Include="win32\sdk\file_standard_information.hpp" />
    <ClInclude Include="win32\sdk\file_id_both_dir_information.hpp" />
    <ClInclude Include="vcruntime\initializers.hpp" />
    <ClInclude Include="vcruntime\internal_shared.hpp" />
    <ClInclude Include="win32\file.hpp" />
    <ClInclude Include="win32\sdk\file_directory_information.hpp" />
    <ClInclude Include="memory\macro.hpp" />
    <ClInclude Include="memory\arg_stack.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="win32\string.cpp" />
    <ClCompile Include="win32\process.cpp" />
    <ClCompile Include="win32\image.cpp" />
    <ClCompile Include="vcruntime\thread_safe_statics.cpp" />
    <ClCompile Include="vcruntime\security_cookie.cpp" />
    <ClCompile Include="vcruntime\initializers.cpp" />
    <ClCompile Include="vcruntime\operator.cpp" />
    <ClCompile Include="win32\time.cpp" />
    <ClCompile Include="core\mutex.cpp" />
    <ClCompile Include="core\timer.cpp" />
    <ClCompile Include="vcruntime\dll_dllmain.cpp" />
    <ClCompile Include="vcruntime\thread_local_storage.cpp" />
    <ClCompile Include="memory\scan.cpp" />
    <ClCompile Include="memory\vftable_hook.cpp" />
    <ClCompile Include="memory\operation.cpp" />
    <ClCompile Include="win32\trace.cpp" />
    <ClCompile Include="win32\math.cpp" />
    <ClCompile Include="memory\detour_hook.cpp" />
    <ClCompile Include="win32\input_manager.cpp" />
    <ClCompile Include="hde\hde64.cpp" />
    <ClCompile Include="core\map_data.cpp" />
    <ClCompile Include="imgui\imgui.cpp" />
    <ClCompile Include="imgui\imgui_draw.cpp" />
    <ClCompile Include="imgui\imgui_widgets.cpp" />
    <ClCompile Include="imgui\imgui_impl_dx11.cpp" />
    <ClCompile Include="imgui\imgui_impl_win32.cpp" />
    <ClCompile Include="imgui\imgui_shader_dx11.cpp" />
    <ClCompile Include="win32\basic.cpp" />
    <ClCompile Include="graphics\color.cpp" />
    <ClCompile Include="graphics\renderer.cpp" />
    <ClCompile Include="win32\file.cpp" />
    <ClCompile Include="vcruntime\memory.cpp" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="memory\x64\code_secure_call.asm" />
    <MASM Include="memory\x64\code_system_call.asm" />
  </ItemGroup>
</Project>
```

`horizon/horizon.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`horizon/imgui/imconfig.hpp`:

```hpp
//-----------------------------------------------------------------------------
// COMPILE-TIME OPTIONS FOR DEAR IMGUI
// Runtime options (clipboard callbacks, enabling various features, etc.) can generally be set via the ImGuiIO structure.
// You can use ImGui::SetAllocatorFunctions() before calling ImGui::CreateContext() to rewire memory allocation functions.
//-----------------------------------------------------------------------------
// A) You may edit imconfig.h (and not overwrite it when updating Dear ImGui, or maintain a patch/branch with your modifications to imconfig.h)
// B) or add configuration directives in your own file and compile with #define IMGUI_USER_CONFIG "myfilename.h"
// If you do so you need to make sure that configuration settings are defined consistently _everywhere_ Dear ImGui is used, which include
// the imgui*.cpp files but also _any_ of your code that uses Dear ImGui. This is because some compile-time options have an affect on data structures.
// Defining those options in imconfig.h will ensure every compilation unit gets to see the same data structure layouts.
// Call IMGUI_CHECKVERSION() from your .cpp files to verify that the data structures your files are using are matching the ones imgui.cpp is using.
//-----------------------------------------------------------------------------

#pragma once

//---- Define assertion handler. Defaults to calling assert().
// If your macro uses multiple statements, make sure is enclosed in a 'do { .. } while (0)' block so it can be used as a single statement.
//#define IM_ASSERT(_EXPR)  MyAssert(_EXPR)
//#define IM_ASSERT(_EXPR)  ((void)(_EXPR))     // Disable asserts

//---- Define attributes of all API symbols declarations, e.g. for DLL under Windows
// Using dear imgui via a shared library is not recommended, because of function call overhead and because we don't guarantee backward nor forward ABI compatibility.
//#define IMGUI_API __declspec( dllexport )
//#define IMGUI_API __declspec( dllimport )

//---- Don't define obsolete functions/enums/behaviors. Consider enabling from time to time after updating to avoid using soon-to-be obsolete function/names.
//#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS

//---- Disable all of Dear ImGui or don't implement standard windows.
// It is very strongly recommended to NOT disable the demo windows during development. Please read comments in imgui_demo.cpp.
//#define IMGUI_DISABLE                                     // Disable everything: all headers and source files will be empty.
#define IMGUI_DISABLE_DEMO_WINDOWS                        // Disable demo windows: ShowDemoWindow()/ShowStyleEditor() will be empty. Not recommended.
#define IMGUI_DISABLE_METRICS_WINDOW                      // Disable debug/metrics window: ShowMetricsWindow() will be empty.

//---- Don't implement some functions to reduce linkage requirements.
//#define IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS   // [Win32] Don't implement default clipboard handler. Won't use and link with OpenClipboard/GetClipboardData/CloseClipboard etc.
//#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS         // [Win32] Don't implement default IME handler. Won't use and link with ImmGetContext/ImmSetCompositionWindow.
#define IMGUI_DISABLE_WIN32_FUNCTIONS                     // [Win32] Won't use and link with any Win32 function (clipboard, ime).
//#define IMGUI_ENABLE_OSX_DEFAULT_CLIPBOARD_FUNCTIONS      // [OSX] Implement default OSX clipboard handler (need to link with '-framework ApplicationServices', this is why this is not the default).
//#define IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS            // Don't implement ImFormatString/ImFormatStringV so you can implement them yourself (e.g. if you don't want to link with vsnprintf)
//#define IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS              // Don't implement ImFabs/ImSqrt/ImPow/ImFmod/ImCos/ImSin/ImAcos/ImAtan2 so you can implement them yourself.
//#define IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS              // Don't implement ImFileOpen/ImFileClose/ImFileRead/ImFileWrite so you can implement them yourself if you don't want to link with fopen/fclose/fread/fwrite. This will also disable the LogToTTY() function.
//#define IMGUI_DISABLE_DEFAULT_ALLOCATORS                  // Don't implement default allocators calling malloc()/free() to avoid linking with them. You will need to call ImGui::SetAllocatorFunctions().
#define IMGUI_DISABLE_FILE_FUNCTIONS

//---- Include imgui_user.h at the end of imgui.h as a convenience
//#define IMGUI_INCLUDE_IMGUI_USER_H

//---- Pack colors to BGRA8 instead of RGBA8 (to avoid converting from one to another)
//#define IMGUI_USE_BGRA_PACKED_COLOR

//---- Use 32-bit for ImWchar (default is 16-bit) to support full unicode code points.
//#define IMGUI_USE_WCHAR32

//---- Avoid multiple STB libraries implementations, or redefine path/filenames to prioritize another version
// By default the embedded implementations are declared static and not available outside of imgui cpp files.
//#define IMGUI_STB_TRUETYPE_FILENAME   "my_folder/stb_truetype.h"
//#define IMGUI_STB_RECT_PACK_FILENAME  "my_folder/stb_rect_pack.h"
//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION

//---- Unless IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS is defined, use the much faster STB sprintf library implementation of vsnprintf instead of the one from the default C library.
// Note that stb_sprintf.h is meant to be provided by the user and available in the include path at compile time. Also, the compatibility checks of the arguments and formats done by clang and GCC will be disabled in order to support the extra formats provided by STB sprintf.
// #define IMGUI_USE_STB_SPRINTF

//---- Define constructor and implicit cast operators to convert back<>forth between your math types and ImVec2/ImVec4.
// This will be inlined as part of ImVec2 and ImVec4 class declarations.
/*
#define IM_VEC2_CLASS_EXTRA                                                 \
        ImVec2(const MyVec2& f) { x = f.x; y = f.y; }                       \
        operator MyVec2() const { return MyVec2(x,y); }

#define IM_VEC4_CLASS_EXTRA                                                 \
        ImVec4(const MyVec4& f) { x = f.x; y = f.y; z = f.z; w = f.w; }     \
        operator MyVec4() const { return MyVec4(x,y,z,w); }
*/

//---- Use 32-bit vertex indices (default is 16-bit) is one way to allow large meshes with more than 64K vertices.
// Your renderer back-end will need to support it (most example renderer back-ends support both 16/32-bit indices).
// Another way to allow large meshes while keeping 16-bit indices is to handle ImDrawCmd::VtxOffset in your renderer.
// Read about ImGuiBackendFlags_RendererHasVtxOffset for details.
//#define ImDrawIdx unsigned int

//---- Override ImDrawCallback signature (will need to modify renderer back-ends accordingly)
//struct ImDrawList;
//struct ImDrawCmd;
//typedef void (*MyImDrawCallback)(const ImDrawList* draw_list, const ImDrawCmd* cmd, void* my_renderer_user_data);
//#define ImDrawCallback MyImDrawCallback

//---- Debug Tools: Macro to break in Debugger
// (use 'Metrics->Tools->Item Picker' to pick widgets with the mouse and break into them for easy debugging.)
//#define IM_DEBUG_BREAK  IM_ASSERT(0)
//#define IM_DEBUG_BREAK  __debugbreak()

//---- Debug Tools: Have the Item Picker break in the ItemAdd() function instead of ItemHoverable(),
// (which comes earlier in the code, will catch a few extra items, allow picking items other than Hovered one.)
// This adds a small runtime cost which is why it is not enabled by default.
//#define IMGUI_DEBUG_TOOL_ITEM_PICKER_EX

//---- Debug Tools: Enable slower asserts
//#define IMGUI_DEBUG_PARANOID

//---- Tip: You can add extra functions within the ImGui:: namespace, here or in your own headers files.
/*
namespace ImGui
{
    void MyFunction(const char* name, const MyMatrix44& v);
}
*/
```

`horizon/imgui/imgui.cpp`:

```cpp
// dear imgui, v1.77 WIP
// (main code and documentation)

// Help:
// - Read FAQ at http://dearimgui.org/faq
// - Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.
// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code. All applications in examples/ are doing that.
// Read imgui.cpp for details, links and comments.

// Resources:
// - FAQ                   http://dearimgui.org/faq
// - Homepage & latest     https://github.com/ocornut/imgui
// - Releases & changelog  https://github.com/ocornut/imgui/releases
// - Gallery               https://github.com/ocornut/imgui/issues/3075 (please post your screenshots/video there!)
// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary
// - Wiki                  https://github.com/ocornut/imgui/wiki
// - Issues & support      https://github.com/ocornut/imgui/issues

// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.
// See LICENSE.txt for copyright and licensing details (standard MIT License).
// This library is free but I need your support to sustain development and maintenance.
// Businesses: you can support continued development via invoiced technical support, maintenance and sponsoring contracts. Please reach out to "contact AT dearimgui.org".
// Individuals: you can support continued development via donations. See docs/README or web page.

// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.
// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without
// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't
// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you
// to a better solution or official support for them.

/*

Index of this file:

DOCUMENTATION

- MISSION STATEMENT
- END-USER GUIDE
- PROGRAMMER GUIDE
  - READ FIRST
  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI
  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE
  - HOW A SIMPLE APPLICATION MAY LOOK LIKE
  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE
  - USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS
- API BREAKING CHANGES (read me when you update!)
- FREQUENTLY ASKED QUESTIONS (FAQ)
  - Read all answers online: https://www.dearimgui.org/faq, or in docs/FAQ.md (with a Markdown viewer)

CODE
(search for "[SECTION]" in the code to find them)

// [SECTION] INCLUDES
// [SECTION] FORWARD DECLARATIONS
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)
// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)
// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)
// [SECTION] MISC HELPERS/UTILITIES (File functions)
// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
// [SECTION] MISC HELPERS/UTILITIES (Color functions)
// [SECTION] ImGuiStorage
// [SECTION] ImGuiTextFilter
// [SECTION] ImGuiTextBuffer
// [SECTION] ImGuiListClipper
// [SECTION] STYLING
// [SECTION] RENDER HELPERS
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
// [SECTION] ERROR CHECKING
// [SECTION] LAYOUT
// [SECTION] SCROLLING
// [SECTION] TOOLTIPS
// [SECTION] POPUPS
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
// [SECTION] DRAG AND DROP
// [SECTION] LOGGING/CAPTURING
// [SECTION] SETTINGS
// [SECTION] PLATFORM DEPENDENT HELPERS
// [SECTION] METRICS/DEBUG WINDOW

*/

//-----------------------------------------------------------------------------
// DOCUMENTATION
//-----------------------------------------------------------------------------

/*

 MISSION STATEMENT
 =================

 - Easy to use to create code-driven and data-driven tools.
 - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.
 - Easy to hack and improve.
 - Minimize screen real-estate usage.
 - Minimize setup and maintenance.
 - Minimize state storage on user side.
 - Portable, minimize dependencies, run on target (consoles, phones, etc.).
 - Efficient runtime and memory consumption (NB- we do allocate when "growing" content e.g. creating a window,.
   opening a tree node for the first time, etc. but a typical frame should not allocate anything).

 Designed for developers and content-creators, not the typical end-user! Some of the weaknesses includes:
 - Doesn't look fancy, doesn't animate.
 - Limited layout features, intricate layouts are typically crafted in code.


 END-USER GUIDE
 ==============

 - Double-click on title bar to collapse window.
 - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().
 - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).
 - Click and drag on any empty space to move window.
 - TAB/SHIFT+TAB to cycle through keyboard editable fields.
 - CTRL+Click on a slider or drag box to input value as text.
 - Use mouse wheel to scroll.
 - Text editor:
   - Hold SHIFT or use mouse to select text.
   - CTRL+Left/Right to word jump.
   - CTRL+Shift+Left/Right to select words.
   - CTRL+A our Double-Click to select all.
   - CTRL+X,CTRL+C,CTRL+V to use OS clipboard/
   - CTRL+Z,CTRL+Y to undo/redo.
   - ESCAPE to revert text to its original value.
   - You can apply arithmetic operators +,*,/ on numerical values. Use +- to subtract (because - would set a negative value!)
   - Controls are automatically adjusted for OSX to match standard OSX text editing operations.
 - General Keyboard controls: enable with ImGuiConfigFlags_NavEnableKeyboard.
 - General Gamepad controls: enable with ImGuiConfigFlags_NavEnableGamepad. See suggested mappings in imgui.h ImGuiNavInput_ + download PNG/PSD at http://goo.gl/9LgVZW


 PROGRAMMER GUIDE
 ================

 READ FIRST
 ----------
 - Remember to read the FAQ (https://www.dearimgui.org/faq)
 - Your code creates the UI, if your code doesn't run the UI is gone! The UI can be highly dynamic, there are no construction
   or destruction steps, less superfluous data retention on your side, less state duplication, less state synchronization, less bugs.
 - Call and read ImGui::ShowDemoWindow() for demo code demonstrating most features.
 - The library is designed to be built from sources. Avoid pre-compiled binaries and packaged versions. See imconfig.h to configure your build.
 - Dear ImGui is an implementation of the IMGUI paradigm (immediate-mode graphical user interface, a term coined by Casey Muratori).
   You can learn about IMGUI principles at http://www.johno.se/book/imgui.html, http://mollyrocket.com/861 & more links in the FAQ.
 - Dear ImGui is a "single pass" rasterizing implementation of the IMGUI paradigm, aimed at ease of use and high-performances.
   For every application frame your UI code will be called only once. This is in contrast to e.g. Unity's own implementation of an IMGUI,
   where the UI code is called multiple times ("multiple passes") from a single entry point. There are pros and cons to both approaches.
 - Our origin are on the top-left. In axis aligned bounding boxes, Min = top-left, Max = bottom-right.
 - This codebase is also optimized to yield decent performances with typical "Debug" builds settings.
 - Please make sure you have asserts enabled (IM_ASSERT redirects to assert() by default, but can be redirected).
   If you get an assert, read the messages and comments around the assert.
 - C++: this is a very C-ish codebase: we don't rely on C++11, we don't include any C++ headers, and ImGui:: is a namespace.
 - C++: ImVec2/ImVec4 do not expose math operators by default, because it is expected that you use your own math types.
   See FAQ "How can I use my own math types instead of ImVec2/ImVec4?" for details about setting up imconfig.h for that.
   However, imgui_internal.h can optionally export math operators for ImVec2/ImVec4, which we use in this codebase.
 - C++: pay attention that ImVector<> manipulates plain-old-data and does not honor construction/destruction (avoid using it in your code!).


 HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI
 ----------------------------------------------
 - Overwrite all the sources files except for imconfig.h (if you have made modification to your copy of imconfig.h)
 - Or maintain your own branch where you have imconfig.h modified.
 - Read the "API BREAKING CHANGES" section (below). This is where we list occasional API breaking changes.
   If a function/type has been renamed / or marked obsolete, try to fix the name in your code before it is permanently removed
   from the public API. If you have a problem with a missing function/symbols, search for its name in the code, there will
   likely be a comment about it. Please report any issue to the GitHub page!
 - Try to keep your copy of dear imgui reasonably up to date.


 GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE
 ---------------------------------------------------------------
 - Run and study the examples and demo in imgui_demo.cpp to get acquainted with the library.
 - In the majority of cases you should be able to use unmodified back-ends files available in the examples/ folder.
 - Add the Dear ImGui source files to your projects or using your preferred build system.
   It is recommended you build and statically link the .cpp files as part of your project and NOT as shared library (DLL).
 - You can later customize the imconfig.h file to tweak some compile-time behavior, such as integrating Dear ImGui types with your own maths types.
 - When using Dear ImGui, your programming IDE is your friend: follow the declaration of variables, functions and types to find comments about them.
 - Dear ImGui never touches or knows about your GPU state. The only function that knows about GPU is the draw function that you provide.
   Effectively it means you can create widgets at any time in your code, regardless of considerations of being in "update" vs "render"
   phases of your own application. All rendering information are stored into command-lists that you will retrieve after calling ImGui::Render().
 - Refer to the bindings and demo applications in the examples/ folder for instruction on how to setup your code.
 - If you are running over a standard OS with a common graphics API, you should be able to use unmodified imgui_impl_*** files from the examples/ folder.


 HOW A SIMPLE APPLICATION MAY LOOK LIKE
 --------------------------------------
 EXHIBIT 1: USING THE EXAMPLE BINDINGS (= imgui_impl_XXX.cpp files from the examples/ folder).
 The sub-folders in examples/ contains examples applications following this structure.

     // Application init: create a dear imgui context, setup some options, load fonts
     ImGui::CreateContext();
     ImGuiIO& io = ImGui::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Initialize helper Platform and Renderer bindings (here we are using imgui_impl_win32.cpp and imgui_impl_dx11.cpp)
     ImGui_ImplWin32_Init(hwnd);
     ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);

     // Application main loop
     while (true)
     {
         // Feed inputs to dear imgui, start new frame
         ImGui_ImplDX11_NewFrame();
         ImGui_ImplWin32_NewFrame();
         ImGui::NewFrame();

         // Any application code here
         ImGui::Text("Hello, world!");

         // Render dear imgui into screen
         ImGui::Render();
         ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());
         g_pSwapChain->Present(1, 0);
     }

     // Shutdown
     ImGui_ImplDX11_Shutdown();
     ImGui_ImplWin32_Shutdown();
     ImGui::DestroyContext();

 EXHIBIT 2: IMPLEMENTING CUSTOM BINDING / CUSTOM ENGINE

     // Application init: create a dear imgui context, setup some options, load fonts
     ImGui::CreateContext();
     ImGuiIO& io = ImGui::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Build and load the texture atlas into a texture
     // (In the examples/ app this is usually done within the ImGui_ImplXXX_Init() function from one of the demo Renderer)
     int width, height;
     unsigned char* pixels = NULL;
     io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);

     // At this point you've got the texture data and you need to upload that your your graphic system:
     // After we have created the texture, store its pointer/identifier (_in whichever format your engine uses_) in 'io.Fonts->TexID'.
     // This will be passed back to your via the renderer. Basically ImTextureID == void*. Read FAQ for details about ImTextureID.
     MyTexture* texture = MyEngine::CreateTextureFromMemoryPixels(pixels, width, height, TEXTURE_TYPE_RGBA32)
     io.Fonts->TexID = (void*)texture;

     // Application main loop
     while (true)
     {
        // Setup low-level inputs, e.g. on Win32: calling GetKeyboardState(), or write to those fields from your Windows message handlers, etc.
        // (In the examples/ app this is usually done within the ImGui_ImplXXX_NewFrame() function from one of the demo Platform bindings)
        io.DeltaTime = 1.0f/60.0f;              // set the time elapsed since the previous frame (in seconds)
        io.DisplaySize.x = 1920.0f;             // set the current display width
        io.DisplaySize.y = 1280.0f;             // set the current display height here
        io.MousePos = my_mouse_pos;             // set the mouse position
        io.MouseDown[0] = my_mouse_buttons[0];  // set the mouse button states
        io.MouseDown[1] = my_mouse_buttons[1];

        // Call NewFrame(), after this point you can use ImGui::* functions anytime
        // (So you want to try calling NewFrame() as early as you can in your mainloop to be able to use Dear ImGui everywhere)
        ImGui::NewFrame();

        // Most of your application code here
        ImGui::Text("Hello, world!");
        MyGameUpdate(); // may use any Dear ImGui functions, e.g. ImGui::Begin("My window"); ImGui::Text("Hello, world!"); ImGui::End();
        MyGameRender(); // may use any Dear ImGui functions as well!

        // Render dear imgui, swap buffers
        // (You want to try calling EndFrame/Render as late as you can, to be able to use Dear ImGui in your own game rendering code)
        ImGui::EndFrame();
        ImGui::Render();
        ImDrawData* draw_data = ImGui::GetDrawData();
        MyImGuiRenderFunction(draw_data);
        SwapBuffers();
     }

     // Shutdown
     ImGui::DestroyContext();

 To decide whether to dispatch mouse/keyboard inputs to Dear ImGui to the rest your application,
 you should read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags!
 Please read the FAQ and example applications for details about this!


 HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE
 ---------------------------------------------
 The bindings in impl_impl_XXX.cpp files contains many working implementations of a rendering function.

    void void MyImGuiRenderFunction(ImDrawData* draw_data)
    {
       // TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
       // TODO: Setup viewport covering draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup orthographic projection matrix cover draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.
       for (int n = 0; n < draw_data->CmdListsCount; n++)
       {
          const ImDrawList* cmd_list = draw_data->CmdLists[n];
          const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by Dear ImGui
          const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by Dear ImGui
          for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
          {
             const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
             if (pcmd->UserCallback)
             {
                 pcmd->UserCallback(cmd_list, pcmd);
             }
             else
             {
                 // The texture for the draw call is specified by pcmd->TextureId.
                 // The vast majority of draw calls will use the Dear ImGui texture atlas, which value you have set yourself during initialization.
                 MyEngineBindTexture((MyTexture*)pcmd->TextureId);

                 // We are using scissoring to clip some objects. All low-level graphics API should supports it.
                 // - If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches
                 //   (some elements visible outside their bounds) but you can fix that once everything else works!
                 // - Clipping coordinates are provided in imgui coordinates space (from draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize)
                 //   In a single viewport application, draw_data->DisplayPos will always be (0,0) and draw_data->DisplaySize will always be == io.DisplaySize.
                 //   However, in the interest of supporting multi-viewport applications in the future (see 'viewport' branch on github),
                 //   always subtract draw_data->DisplayPos from clipping bounds to convert them to your viewport space.
                 // - Note that pcmd->ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)
                 ImVec2 pos = draw_data->DisplayPos;
                 MyEngineScissor((int)(pcmd->ClipRect.x - pos.x), (int)(pcmd->ClipRect.y - pos.y), (int)(pcmd->ClipRect.z - pos.x), (int)(pcmd->ClipRect.w - pos.y));

                 // Render 'pcmd->ElemCount/3' indexed triangles.
                 // By default the indices ImDrawIdx are 16-bit, you can change them to 32-bit in imconfig.h if your engine doesn't support 16-bit indices.
                 MyEngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer, vtx_buffer);
             }
             idx_buffer += pcmd->ElemCount;
          }
       }
    }


 USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS
 ------------------------------------------
 - The gamepad/keyboard navigation is fairly functional and keeps being improved.
 - Gamepad support is particularly useful to use Dear ImGui on a console system (e.g. PS4, Switch, XB1) without a mouse!
 - You can ask questions and report issues at https://github.com/ocornut/imgui/issues/787
 - The initial focus was to support game controllers, but keyboard is becoming increasingly and decently usable.
 - Keyboard:
    - Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable.
      NewFrame() will automatically fill io.NavInputs[] based on your io.KeysDown[] + io.KeyMap[] arrays.
    - When keyboard navigation is active (io.NavActive + ImGuiConfigFlags_NavEnableKeyboard), the io.WantCaptureKeyboard flag
      will be set. For more advanced uses, you may want to read from:
       - io.NavActive: true when a window is focused and it doesn't have the ImGuiWindowFlags_NoNavInputs flag set.
       - io.NavVisible: true when the navigation cursor is visible (and usually goes false when mouse is used).
       - or query focus information with e.g. IsWindowFocused(ImGuiFocusedFlags_AnyWindow), IsItemFocused() etc. functions.
      Please reach out if you think the game vs navigation input sharing could be improved.
 - Gamepad:
    - Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable.
    - Backend: Set io.BackendFlags |= ImGuiBackendFlags_HasGamepad + fill the io.NavInputs[] fields before calling NewFrame().
      Note that io.NavInputs[] is cleared by EndFrame().
    - See 'enum ImGuiNavInput_' in imgui.h for a description of inputs. For each entry of io.NavInputs[], set the following values:
         0.0f= not held. 1.0f= fully held. Pass intermediate 0.0f..1.0f values for analog triggers/sticks.
    - We uses a simple >0.0f test for activation testing, and won't attempt to test for a dead-zone.
      Your code will probably need to transform your raw inputs (such as e.g. remapping your 0.2..0.9 raw input range to 0.0..1.0 imgui range, etc.).
    - You can download PNG/PSD files depicting the gamepad controls for common controllers at: http://goo.gl/9LgVZW.
    - If you need to share inputs between your game and the imgui parts, the easiest approach is to go all-or-nothing, with a buttons combo
      to toggle the target. Please reach out if you think the game vs navigation input sharing could be improved.
 - Mouse:
    - PS4 users: Consider emulating a mouse cursor with DualShock4 touch pad or a spare analog stick as a mouse-emulation fallback.
    - Consoles/Tablet/Phone users: Consider using a Synergy 1.x server (on your PC) + uSynergy.c (on your console/tablet/phone app) to share your PC mouse/keyboard.
    - On a TV/console system where readability may be lower or mouse inputs may be awkward, you may want to set the ImGuiConfigFlags_NavEnableSetMousePos flag.
      Enabling ImGuiConfigFlags_NavEnableSetMousePos + ImGuiBackendFlags_HasSetMousePos instructs dear imgui to move your mouse cursor along with navigation movements.
      When enabled, the NewFrame() function may alter 'io.MousePos' and set 'io.WantSetMousePos' to notify you that it wants the mouse cursor to be moved.
      When that happens your back-end NEEDS to move the OS or underlying mouse cursor on the next frame. Some of the binding in examples/ do that.
      (If you set the NavEnableSetMousePos flag but don't honor 'io.WantSetMousePos' properly, imgui will misbehave as it will see your mouse as moving back and forth!)
      (In a setup when you may not have easy control over the mouse cursor, e.g. uSynergy.c doesn't expose moving remote mouse cursor, you may want
       to set a boolean to ignore your other external mouse positions until the external source is moved again.)


 API BREAKING CHANGES
 ====================

 Occasionally introducing changes that are breaking the API. We try to make the breakage minor and easy to fix.
 Below is a change-log of API breaking changes only. If you are using one of the functions listed, expect to have to fix some code.
 When you are not sure about a old symbol or function name, try using the Search/Find function of your IDE to look for comments or references in all imgui files.
 You can read releases logs https://github.com/ocornut/imgui/releases for more details.

 - 2020/04/23 (1.77) - Removed unnecessary ID (first arg) of ImFontAtlas::AddCustomRectRegular().
 - 2020/01/22 (1.75) - ImDrawList::AddCircle()/AddCircleFilled() functions don't accept negative radius any more.
 - 2019/12/17 (1.75) - [undid this change in 1.76] made Columns() limited to 64 columns by asserting above that limit. While the current code technically supports it, future code may not so we're putting the restriction ahead.
 - 2019/12/13 (1.75) - [imgui_internal.h] changed ImRect() default constructor initializes all fields to 0.0f instead of (FLT_MAX,FLT_MAX,-FLT_MAX,-FLT_MAX). If you used ImRect::Add() to create bounding boxes by adding multiple points into it, you may need to fix your initial value.
 - 2019/12/08 (1.75) - removed redirecting functions/enums that were marked obsolete in 1.53 (December 2017):
                       - ShowTestWindow()                    -> use ShowDemoWindow()
                       - IsRootWindowFocused()               -> use IsWindowFocused(ImGuiFocusedFlags_RootWindow)
                       - IsRootWindowOrAnyChildFocused()     -> use IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows)
                       - SetNextWindowContentWidth(w)        -> use SetNextWindowContentSize(ImVec2(w, 0.0f)
                       - GetItemsLineHeightWithSpacing()     -> use GetFrameHeightWithSpacing()
                       - ImGuiCol_ChildWindowBg              -> use ImGuiCol_ChildBg
                       - ImGuiStyleVar_ChildWindowRounding   -> use ImGuiStyleVar_ChildRounding
                       - ImGuiTreeNodeFlags_AllowOverlapMode -> use ImGuiTreeNodeFlags_AllowItemOverlap
                       - IMGUI_DISABLE_TEST_WINDOWS          -> use IMGUI_DISABLE_DEMO_WINDOWS
 - 2019/12/08 (1.75) - obsoleted calling ImDrawList::PrimReserve() with a negative count (which was the vaguely documented and rarely if ever used). Instead we added an explicit PrimUnreserve() API.
 - 2019/12/06 (1.75) - removed implicit default parameter to IsMouseDragging(int button = 0) to be consistent with other mouse functions (none of the other functions have it).
 - 2019/11/21 (1.74) - ImFontAtlas::AddCustomRectRegular() now requires an ID larger than 0x110000 (instead of 0x10000) to conform with supporting Unicode planes 1-16 in a future update. ID below 0x110000 will now assert.
 - 2019/11/19 (1.74) - renamed IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS to IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS for consistency.
 - 2019/11/19 (1.74) - renamed IMGUI_DISABLE_MATH_FUNCTIONS to IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS for consistency.
 - 2019/10/22 (1.74) - removed redirecting functions/enums that were marked obsolete in 1.52 (October 2017):
                       - Begin() [old 5 args version]        -> use Begin() [3 args], use SetNextWindowSize() SetNextWindowBgAlpha() if needed
                       - IsRootWindowOrAnyChildHovered()     -> use IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows)
                       - AlignFirstTextHeightToWidgets()     -> use AlignTextToFramePadding()
                       - SetNextWindowPosCenter()            -> use SetNextWindowPos() with a pivot of (0.5f, 0.5f)
                       - ImFont::Glyph                       -> use ImFontGlyph
 - 2019/10/14 (1.74) - inputs: Fixed a miscalculation in the keyboard/mouse "typematic" repeat delay/rate calculation, used by keys and e.g. repeating mouse buttons as well as the GetKeyPressedAmount() function.
                       if you were using a non-default value for io.KeyRepeatRate (previous default was 0.250), you can add +io.KeyRepeatDelay to it to compensate for the fix.
                       The function was triggering on: 0.0 and (delay+rate*N) where (N>=1). Fixed formula responds to (N>=0). Effectively it made io.KeyRepeatRate behave like it was set to (io.KeyRepeatRate + io.KeyRepeatDelay).
                       If you never altered io.KeyRepeatRate nor used GetKeyPressedAmount() this won't affect you.
 - 2019/07/15 (1.72) - removed TreeAdvanceToLabelPos() which is rarely used and only does SetCursorPosX(GetCursorPosX() + GetTreeNodeToLabelSpacing()). Kept redirection function (will obsolete).
 - 2019/07/12 (1.72) - renamed ImFontAtlas::CustomRect to ImFontAtlasCustomRect. Kept redirection typedef (will obsolete).
 - 2019/06/14 (1.72) - removed redirecting functions/enums names that were marked obsolete in 1.51 (June 2017): ImGuiCol_Column*, ImGuiSetCond_*, IsItemHoveredRect(), IsPosHoveringAnyWindow(), IsMouseHoveringAnyWindow(), IsMouseHoveringWindow(), IMGUI_ONCE_UPON_A_FRAME. Grep this log for details and new names, or see how they were implemented until 1.71.
 - 2019/06/07 (1.71) - rendering of child window outer decorations (bg color, border, scrollbars) is now performed as part of the parent window. If you have
                       overlapping child windows in a same parent, and relied on their relative z-order to be mapped to their submission order, this will affect your rendering.
                       This optimization is disabled if the parent window has no visual output, because it appears to be the most common situation leading to the creation of overlapping child windows.
                       Please reach out if you are affected.
 - 2019/05/13 (1.71) - renamed SetNextTreeNodeOpen() to SetNextItemOpen(). Kept inline redirection function (will obsolete).
 - 2019/05/11 (1.71) - changed io.AddInputCharacter(unsigned short c) signature to io.AddInputCharacter(unsigned int c).
 - 2019/04/29 (1.70) - improved ImDrawList thick strokes (>1.0f) preserving correct thickness up to 90 degrees angles (e.g. rectangles). If you have custom rendering using thick lines, they will appear thicker now.
 - 2019/04/29 (1.70) - removed GetContentRegionAvailWidth(), use GetContentRegionAvail().x instead. Kept inline redirection function (will obsolete).
 - 2019/03/04 (1.69) - renamed GetOverlayDrawList() to GetForegroundDrawList(). Kept redirection function (will obsolete).
 - 2019/02/26 (1.69) - renamed ImGuiColorEditFlags_RGB/ImGuiColorEditFlags_HSV/ImGuiColorEditFlags_HEX to ImGuiColorEditFlags_DisplayRGB/ImGuiColorEditFlags_DisplayHSV/ImGuiColorEditFlags_DisplayHex. Kept redirection enums (will obsolete).
 - 2019/02/14 (1.68) - made it illegal/assert when io.DisplayTime == 0.0f (with an exception for the first frame). If for some reason your time step calculation gives you a zero value, replace it with a dummy small value!
 - 2019/02/01 (1.68) - removed io.DisplayVisibleMin/DisplayVisibleMax (which were marked obsolete and removed from viewport/docking branch already).
 - 2019/01/06 (1.67) - renamed io.InputCharacters[], marked internal as was always intended. Please don't access directly, and use AddInputCharacter() instead!
 - 2019/01/06 (1.67) - renamed ImFontAtlas::GlyphRangesBuilder to ImFontGlyphRangesBuilder. Kept redirection typedef (will obsolete).
 - 2018/12/20 (1.67) - made it illegal to call Begin("") with an empty string. This somehow half-worked before but had various undesirable side-effects.
 - 2018/12/10 (1.67) - renamed io.ConfigResizeWindowsFromEdges to io.ConfigWindowsResizeFromEdges as we are doing a large pass on configuration flags.
 - 2018/10/12 (1.66) - renamed misc/stl/imgui_stl.* to misc/cpp/imgui_stdlib.* in prevision for other C++ helper files.
 - 2018/09/28 (1.66) - renamed SetScrollHere() to SetScrollHereY(). Kept redirection function (will obsolete).
 - 2018/09/06 (1.65) - renamed stb_truetype.h to imstb_truetype.h, stb_textedit.h to imstb_textedit.h, and stb_rect_pack.h to imstb_rectpack.h.
                       If you were conveniently using the imgui copy of those STB headers in your project you will have to update your include paths.
 - 2018/09/05 (1.65) - renamed io.OptCursorBlink/io.ConfigCursorBlink to io.ConfigInputTextCursorBlink. (#1427)
 - 2018/08/31 (1.64) - added imgui_widgets.cpp file, extracted and moved widgets code out of imgui.cpp into imgui_widgets.cpp. Re-ordered some of the code remaining in imgui.cpp.
                       NONE OF THE FUNCTIONS HAVE CHANGED. THE CODE IS SEMANTICALLY 100% IDENTICAL, BUT _EVERY_ FUNCTION HAS BEEN MOVED.
                       Because of this, any local modifications to imgui.cpp will likely conflict when you update. Read docs/CHANGELOG.txt for suggestions.
 - 2018/08/22 (1.63) - renamed IsItemDeactivatedAfterChange() to IsItemDeactivatedAfterEdit() for consistency with new IsItemEdited() API. Kept redirection function (will obsolete soonish as IsItemDeactivatedAfterChange() is very recent).
 - 2018/08/21 (1.63) - renamed ImGuiTextEditCallback to ImGuiInputTextCallback, ImGuiTextEditCallbackData to ImGuiInputTextCallbackData for consistency. Kept redirection types (will obsolete).
 - 2018/08/21 (1.63) - removed ImGuiInputTextCallbackData::ReadOnly since it is a duplication of (ImGuiInputTextCallbackData::Flags & ImGuiInputTextFlags_ReadOnly).
 - 2018/08/01 (1.63) - removed per-window ImGuiWindowFlags_ResizeFromAnySide beta flag in favor of a global io.ConfigResizeWindowsFromEdges [update 1.67 renamed to ConfigWindowsResizeFromEdges] to enable the feature.
 - 2018/08/01 (1.63) - renamed io.OptCursorBlink to io.ConfigCursorBlink [-> io.ConfigInputTextCursorBlink in 1.65], io.OptMacOSXBehaviors to ConfigMacOSXBehaviors for consistency.
 - 2018/07/22 (1.63) - changed ImGui::GetTime() return value from float to double to avoid accumulating floating point imprecisions over time.
 - 2018/07/08 (1.63) - style: renamed ImGuiCol_ModalWindowDarkening to ImGuiCol_ModalWindowDimBg for consistency with other features. Kept redirection enum (will obsolete).
 - 2018/06/08 (1.62) - examples: the imgui_impl_xxx files have been split to separate platform (Win32, Glfw, SDL2, etc.) from renderer (DX11, OpenGL, Vulkan,  etc.).
                       old bindings will still work as is, however prefer using the separated bindings as they will be updated to support multi-viewports.
                       when adopting new bindings follow the main.cpp code of your preferred examples/ folder to know which functions to call.
                       in particular, note that old bindings called ImGui::NewFrame() at the end of their ImGui_ImplXXXX_NewFrame() function.
 - 2018/06/06 (1.62) - renamed GetGlyphRangesChinese() to GetGlyphRangesChineseFull() to distinguish other variants and discourage using the full set.
 - 2018/06/06 (1.62) - TreeNodeEx()/TreeNodeBehavior(): the ImGuiTreeNodeFlags_CollapsingHeader helper now include the ImGuiTreeNodeFlags_NoTreePushOnOpen flag. See Changelog for details.
 - 2018/05/03 (1.61) - DragInt(): the default compile-time format string has been changed from "%.0f" to "%d", as we are not using integers internally any more.
                       If you used DragInt() with custom format strings, make sure you change them to use %d or an integer-compatible format.
                       To honor backward-compatibility, the DragInt() code will currently parse and modify format strings to replace %*f with %d, giving time to users to upgrade their code.
                       If you have IMGUI_DISABLE_OBSOLETE_FUNCTIONS enabled, the code will instead assert! You may run a reg-exp search on your codebase for e.g. "DragInt.*%f" to help you find them.
 - 2018/04/28 (1.61) - obsoleted InputFloat() functions taking an optional "int decimal_precision" in favor of an equivalent and more flexible "const char* format",
                       consistent with other functions. Kept redirection functions (will obsolete).
 - 2018/04/09 (1.61) - IM_DELETE() helper function added in 1.60 doesn't clear the input _pointer_ reference, more consistent with expectation and allows passing r-value.
 - 2018/03/20 (1.60) - renamed io.WantMoveMouse to io.WantSetMousePos for consistency and ease of understanding (was added in 1.52, _not_ used by core and only honored by some binding ahead of merging the Nav branch).
 - 2018/03/12 (1.60) - removed ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered as the closing cross uses regular button colors now.
 - 2018/03/08 (1.60) - changed ImFont::DisplayOffset.y to default to 0 instead of +1. Fixed rounding of Ascent/Descent to match TrueType renderer. If you were adding or subtracting to ImFont::DisplayOffset check if your fonts are correctly aligned vertically.
 - 2018/03/03 (1.60) - renamed ImGuiStyleVar_Count_ to ImGuiStyleVar_COUNT and ImGuiMouseCursor_Count_ to ImGuiMouseCursor_COUNT for consistency with other public enums.
 - 2018/02/18 (1.60) - BeginDragDropSource(): temporarily removed the optional mouse_button=0 parameter because it is not really usable in many situations at the moment.
 - 2018/02/16 (1.60) - obsoleted the io.RenderDrawListsFn callback, you can call your graphics engine render function after ImGui::Render(). Use ImGui::GetDrawData() to retrieve the ImDrawData* to display.
 - 2018/02/07 (1.60) - reorganized context handling to be more explicit,
                       - YOU NOW NEED TO CALL ImGui::CreateContext() AT THE BEGINNING OF YOUR APP, AND CALL ImGui::DestroyContext() AT THE END.
                       - removed Shutdown() function, as DestroyContext() serve this purpose.
                       - you may pass a ImFontAtlas* pointer to CreateContext() to share a font atlas between contexts. Otherwise CreateContext() will create its own font atlas instance.
                       - removed allocator parameters from CreateContext(), they are now setup with SetAllocatorFunctions(), and shared by all contexts.
                       - removed the default global context and font atlas instance, which were confusing for users of DLL reloading and users of multiple contexts.
 - 2018/01/31 (1.60) - moved sample TTF files from extra_fonts/ to misc/fonts/. If you loaded files directly from the imgui repo you may need to update your paths.
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowHovered() in favor of IsWindowHovered(ImGuiHoveredFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowFocused() in favor of IsWindowFocused(ImGuiFocusedFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/03 (1.60) - renamed ImGuiSizeConstraintCallback to ImGuiSizeCallback, ImGuiSizeConstraintCallbackData to ImGuiSizeCallbackData.
 - 2017/12/29 (1.60) - removed CalcItemRectClosestPoint() which was weird and not really used by anyone except demo code. If you need it it's easy to replicate on your side.
 - 2017/12/24 (1.53) - renamed the emblematic ShowTestWindow() function to ShowDemoWindow(). Kept redirection function (will obsolete).
 - 2017/12/21 (1.53) - ImDrawList: renamed style.AntiAliasedShapes to style.AntiAliasedFill for consistency and as a way to explicitly break code that manipulate those flag at runtime. You can now manipulate ImDrawList::Flags
 - 2017/12/21 (1.53) - ImDrawList: removed 'bool anti_aliased = true' final parameter of ImDrawList::AddPolyline() and ImDrawList::AddConvexPolyFilled(). Prefer manipulating ImDrawList::Flags if you need to toggle them during the frame.
 - 2017/12/14 (1.53) - using the ImGuiWindowFlags_NoScrollWithMouse flag on a child window forwards the mouse wheel event to the parent window, unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set.
 - 2017/12/13 (1.53) - renamed GetItemsLineHeightWithSpacing() to GetFrameHeightWithSpacing(). Kept redirection function (will obsolete).
 - 2017/12/13 (1.53) - obsoleted IsRootWindowFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootWindow). Kept redirection function (will obsolete).
                     - obsoleted IsRootWindowOrAnyChildFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows). Kept redirection function (will obsolete).
 - 2017/12/12 (1.53) - renamed ImGuiTreeNodeFlags_AllowOverlapMode to ImGuiTreeNodeFlags_AllowItemOverlap. Kept redirection enum (will obsolete).
 - 2017/12/10 (1.53) - removed SetNextWindowContentWidth(), prefer using SetNextWindowContentSize(). Kept redirection function (will obsolete).
 - 2017/11/27 (1.53) - renamed ImGuiTextBuffer::append() helper to appendf(), appendv() to appendfv(). If you copied the 'Log' demo in your code, it uses appendv() so that needs to be renamed.
 - 2017/11/18 (1.53) - Style, Begin: removed ImGuiWindowFlags_ShowBorders window flag. Borders are now fully set up in the ImGuiStyle structure (see e.g. style.FrameBorderSize, style.WindowBorderSize). Use ImGui::ShowStyleEditor() to look them up.
                       Please note that the style system will keep evolving (hopefully stabilizing in Q1 2018), and so custom styles will probably subtly break over time. It is recommended you use the StyleColorsClassic(), StyleColorsDark(), StyleColorsLight() functions.
 - 2017/11/18 (1.53) - Style: removed ImGuiCol_ComboBg in favor of combo boxes using ImGuiCol_PopupBg for consistency.
 - 2017/11/18 (1.53) - Style: renamed ImGuiCol_ChildWindowBg to ImGuiCol_ChildBg.
 - 2017/11/18 (1.53) - Style: renamed style.ChildWindowRounding to style.ChildRounding, ImGuiStyleVar_ChildWindowRounding to ImGuiStyleVar_ChildRounding.
 - 2017/11/02 (1.53) - obsoleted IsRootWindowOrAnyChildHovered() in favor of using IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows);
 - 2017/10/24 (1.52) - renamed IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCS to IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS for consistency.
 - 2017/10/20 (1.52) - changed IsWindowHovered() default parameters behavior to return false if an item is active in another window (e.g. click-dragging item from another window to this window). You can use the newly introduced IsWindowHovered() flags to requests this specific behavior if you need it.
 - 2017/10/20 (1.52) - marked IsItemHoveredRect()/IsMouseHoveringWindow() as obsolete, in favor of using the newly introduced flags for IsItemHovered() and IsWindowHovered(). See https://github.com/ocornut/imgui/issues/1382 for details.
                       removed the IsItemRectHovered()/IsWindowRectHovered() names introduced in 1.51 since they were merely more consistent names for the two functions we are now obsoleting.
                         IsItemHoveredRect()        --> IsItemHovered(ImGuiHoveredFlags_RectOnly)
                         IsMouseHoveringAnyWindow() --> IsWindowHovered(ImGuiHoveredFlags_AnyWindow)
                         IsMouseHoveringWindow()    --> IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) [weird, old behavior]
 - 2017/10/17 (1.52) - marked the old 5-parameters version of Begin() as obsolete (still available). Use SetNextWindowSize()+Begin() instead!
 - 2017/10/11 (1.52) - renamed AlignFirstTextHeightToWidgets() to AlignTextToFramePadding(). Kept inline redirection function (will obsolete).
 - 2017/09/26 (1.52) - renamed ImFont::Glyph to ImFontGlyph. Kept redirection typedef (will obsolete).
 - 2017/09/25 (1.52) - removed SetNextWindowPosCenter() because SetNextWindowPos() now has the optional pivot information to do the same and more. Kept redirection function (will obsolete).
 - 2017/08/25 (1.52) - io.MousePos needs to be set to ImVec2(-FLT_MAX,-FLT_MAX) when mouse is unavailable/missing. Previously ImVec2(-1,-1) was enough but we now accept negative mouse coordinates. In your binding if you need to support unavailable mouse, make sure to replace "io.MousePos = ImVec2(-1,-1)" with "io.MousePos = ImVec2(-FLT_MAX,-FLT_MAX)".
 - 2017/08/22 (1.51) - renamed IsItemHoveredRect() to IsItemRectHovered(). Kept inline redirection function (will obsolete). -> (1.52) use IsItemHovered(ImGuiHoveredFlags_RectOnly)!
                     - renamed IsMouseHoveringAnyWindow() to IsAnyWindowHovered() for consistency. Kept inline redirection function (will obsolete).
                     - renamed IsMouseHoveringWindow() to IsWindowRectHovered() for consistency. Kept inline redirection function (will obsolete).
 - 2017/08/20 (1.51) - renamed GetStyleColName() to GetStyleColorName() for consistency.
 - 2017/08/20 (1.51) - added PushStyleColor(ImGuiCol idx, ImU32 col) overload, which _might_ cause an "ambiguous call" compilation error if you are using ImColor() with implicit cast. Cast to ImU32 or ImVec4 explicily to fix.
 - 2017/08/15 (1.51) - marked the weird IMGUI_ONCE_UPON_A_FRAME helper macro as obsolete. prefer using the more explicit ImGuiOnceUponAFrame type.
 - 2017/08/15 (1.51) - changed parameter order for BeginPopupContextWindow() from (const char*,int buttons,bool also_over_items) to (const char*,int buttons,bool also_over_items). Note that most calls relied on default parameters completely.
 - 2017/08/13 (1.51) - renamed ImGuiCol_Column to ImGuiCol_Separator, ImGuiCol_ColumnHovered to ImGuiCol_SeparatorHovered, ImGuiCol_ColumnActive to ImGuiCol_SeparatorActive. Kept redirection enums (will obsolete).
 - 2017/08/11 (1.51) - renamed ImGuiSetCond_Always to ImGuiCond_Always, ImGuiSetCond_Once to ImGuiCond_Once, ImGuiSetCond_FirstUseEver to ImGuiCond_FirstUseEver, ImGuiSetCond_Appearing to ImGuiCond_Appearing. Kept redirection enums (will obsolete).
 - 2017/08/09 (1.51) - removed ValueColor() helpers, they are equivalent to calling Text(label) + SameLine() + ColorButton().
 - 2017/08/08 (1.51) - removed ColorEditMode() and ImGuiColorEditMode in favor of ImGuiColorEditFlags and parameters to the various Color*() functions. The SetColorEditOptions() allows to initialize default but the user can still change them with right-click context menu.
                     - changed prototype of 'ColorEdit4(const char* label, float col[4], bool show_alpha = true)' to 'ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0)', where passing flags = 0x01 is a safe no-op (hello dodgy backward compatibility!). - check and run the demo window, under "Color/Picker Widgets", to understand the various new options.
                     - changed prototype of rarely used 'ColorButton(ImVec4 col, bool small_height = false, bool outline_border = true)' to 'ColorButton(const char* desc_id, ImVec4 col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0,0))'
 - 2017/07/20 (1.51) - removed IsPosHoveringAnyWindow(ImVec2), which was partly broken and misleading. ASSERT + redirect user to io.WantCaptureMouse
 - 2017/05/26 (1.50) - removed ImFontConfig::MergeGlyphCenterV in favor of a more multipurpose ImFontConfig::GlyphOffset.
 - 2017/05/01 (1.50) - renamed ImDrawList::PathFill() (rarely used directly) to ImDrawList::PathFillConvex() for clarity.
 - 2016/11/06 (1.50) - BeginChild(const char*) now applies the stack id to the provided label, consistently with other functions as it should always have been. It shouldn't affect you unless (extremely unlikely) you were appending multiple times to a same child from different locations of the stack id. If that's the case, generate an id with GetId() and use it instead of passing string to BeginChild().
 - 2016/10/15 (1.50) - avoid 'void* user_data' parameter to io.SetClipboardTextFn/io.GetClipboardTextFn pointers. We pass io.ClipboardUserData to it.
 - 2016/09/25 (1.50) - style.WindowTitleAlign is now a ImVec2 (ImGuiAlign enum was removed). set to (0.5f,0.5f) for horizontal+vertical centering, (0.0f,0.0f) for upper-left, etc.
 - 2016/07/30 (1.50) - SameLine(x) with x>0.0f is now relative to left of column/group if any, and not always to left of window. This was sort of always the intent and hopefully breakage should be minimal.
 - 2016/05/12 (1.49) - title bar (using ImGuiCol_TitleBg/ImGuiCol_TitleBgActive colors) isn't rendered over a window background (ImGuiCol_WindowBg color) anymore.
                       If your TitleBg/TitleBgActive alpha was 1.0f or you are using the default theme it will not affect you, otherwise if <1.0f you need tweak your custom theme to readjust for the fact that we don't draw a WindowBg background behind the title bar.
                       This helper function will convert an old TitleBg/TitleBgActive color into a new one with the same visual output, given the OLD color and the OLD WindowBg color:
                       ImVec4 ConvertTitleBgCol(const ImVec4& win_bg_col, const ImVec4& title_bg_col) { float new_a = 1.0f - ((1.0f - win_bg_col.w) * (1.0f - title_bg_col.w)), k = title_bg_col.w / new_a; return ImVec4((win_bg_col.x * win_bg_col.w + title_bg_col.x) * k, (win_bg_col.y * win_bg_col.w + title_bg_col.y) * k, (win_bg_col.z * win_bg_col.w + title_bg_col.z) * k, new_a); }
                       If this is confusing, pick the RGB value from title bar from an old screenshot and apply this as TitleBg/TitleBgActive. Or you may just create TitleBgActive from a tweaked TitleBg color.
 - 2016/05/07 (1.49) - removed confusing set of GetInternalState(), GetInternalStateSize(), SetInternalState() functions. Now using CreateContext(), DestroyContext(), GetCurrentContext(), SetCurrentContext().
 - 2016/05/02 (1.49) - renamed SetNextTreeNodeOpened() to SetNextTreeNodeOpen(), no redirection.
 - 2016/05/01 (1.49) - obsoleted old signature of CollapsingHeader(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false) as extra parameters were badly designed and rarely used. You can replace the "default_open = true" flag in new API with CollapsingHeader(label, ImGuiTreeNodeFlags_DefaultOpen).
 - 2016/04/26 (1.49) - changed ImDrawList::PushClipRect(ImVec4 rect) to ImDrawList::PushClipRect(Imvec2 min,ImVec2 max,bool intersect_with_current_clip_rect=false). Note that higher-level ImGui::PushClipRect() is preferable because it will clip at logic/widget level, whereas ImDrawList::PushClipRect() only affect your renderer.
 - 2016/04/03 (1.48) - removed style.WindowFillAlphaDefault setting which was redundant. Bake default BG alpha inside style.Colors[ImGuiCol_WindowBg] and all other Bg color values. (ref github issue #337).
 - 2016/04/03 (1.48) - renamed ImGuiCol_TooltipBg to ImGuiCol_PopupBg, used by popups/menus and tooltips. popups/menus were previously using ImGuiCol_WindowBg. (ref github issue #337)
 - 2016/03/21 (1.48) - renamed GetWindowFont() to GetFont(), GetWindowFontSize() to GetFontSize(). Kept inline redirection function (will obsolete).
 - 2016/03/02 (1.48) - InputText() completion/history/always callbacks: if you modify the text buffer manually (without using DeleteChars()/InsertChars() helper) you need to maintain the BufTextLen field. added an assert.
 - 2016/01/23 (1.48) - fixed not honoring exact width passed to PushItemWidth(), previously it would add extra FramePadding.x*2 over that width. if you had manual pixel-perfect alignment in place it might affect you.
 - 2015/12/27 (1.48) - fixed ImDrawList::AddRect() which used to render a rectangle 1 px too large on each axis.
 - 2015/12/04 (1.47) - renamed Color() helpers to ValueColor() - dangerously named, rarely used and probably to be made obsolete.
 - 2015/08/29 (1.45) - with the addition of horizontal scrollbar we made various fixes to inconsistencies with dealing with cursor position.
                       GetCursorPos()/SetCursorPos() functions now include the scrolled amount. It shouldn't affect the majority of users, but take note that SetCursorPosX(100.0f) puts you at +100 from the starting x position which may include scrolling, not at +100 from the window left side.
                       GetContentRegionMax()/GetWindowContentRegionMin()/GetWindowContentRegionMax() functions allow include the scrolled amount. Typically those were used in cases where no scrolling would happen so it may not be a problem, but watch out!
 - 2015/08/29 (1.45) - renamed style.ScrollbarWidth to style.ScrollbarSize
 - 2015/08/05 (1.44) - split imgui.cpp into extra files: imgui_demo.cpp imgui_draw.cpp imgui_internal.h that you need to add to your project.
 - 2015/07/18 (1.44) - fixed angles in ImDrawList::PathArcTo(), PathArcToFast() (introduced in 1.43) being off by an extra PI for no justifiable reason
 - 2015/07/14 (1.43) - add new ImFontAtlas::AddFont() API. For the old AddFont***, moved the 'font_no' parameter of ImFontAtlas::AddFont** functions to the ImFontConfig structure.
                       you need to render your textured triangles with bilinear filtering to benefit from sub-pixel positioning of text.
 - 2015/07/08 (1.43) - switched rendering data to use indexed rendering. this is saving a fair amount of CPU/GPU and enables us to get anti-aliasing for a marginal cost.
                       this necessary change will break your rendering function! the fix should be very easy. sorry for that :(
                     - if you are using a vanilla copy of one of the imgui_impl_XXXX.cpp provided in the example, you just need to update your copy and you can ignore the rest.
                     - the signature of the io.RenderDrawListsFn handler has changed!
                       old: ImGui_XXXX_RenderDrawLists(ImDrawList** const cmd_lists, int cmd_lists_count)
                       new: ImGui_XXXX_RenderDrawLists(ImDrawData* draw_data).
                         parameters: 'cmd_lists' becomes 'draw_data->CmdLists', 'cmd_lists_count' becomes 'draw_data->CmdListsCount'
                         ImDrawList: 'commands' becomes 'CmdBuffer', 'vtx_buffer' becomes 'VtxBuffer', 'IdxBuffer' is new.
                         ImDrawCmd:  'vtx_count' becomes 'ElemCount', 'clip_rect' becomes 'ClipRect', 'user_callback' becomes 'UserCallback', 'texture_id' becomes 'TextureId'.
                     - each ImDrawList now contains both a vertex buffer and an index buffer. For each command, render ElemCount/3 triangles using indices from the index buffer.
                     - if you REALLY cannot render indexed primitives, you can call the draw_data->DeIndexAllBuffers() method to de-index the buffers. This is slow and a waste of CPU/GPU. Prefer using indexed rendering!
                     - refer to code in the examples/ folder or ask on the GitHub if you are unsure of how to upgrade. please upgrade!
 - 2015/07/10 (1.43) - changed SameLine() parameters from int to float.
 - 2015/07/02 (1.42) - renamed SetScrollPosHere() to SetScrollFromCursorPos(). Kept inline redirection function (will obsolete).
 - 2015/07/02 (1.42) - renamed GetScrollPosY() to GetScrollY(). Necessary to reduce confusion along with other scrolling functions, because positions (e.g. cursor position) are not equivalent to scrolling amount.
 - 2015/06/14 (1.41) - changed ImageButton() default bg_col parameter from (0,0,0,1) (black) to (0,0,0,0) (transparent) - makes a difference when texture have transparence
 - 2015/06/14 (1.41) - changed Selectable() API from (label, selected, size) to (label, selected, flags, size). Size override should have been rarely be used. Sorry!
 - 2015/05/31 (1.40) - renamed GetWindowCollapsed() to IsWindowCollapsed() for consistency. Kept inline redirection function (will obsolete).
 - 2015/05/31 (1.40) - renamed IsRectClipped() to IsRectVisible() for consistency. Note that return value is opposite! Kept inline redirection function (will obsolete).
 - 2015/05/27 (1.40) - removed the third 'repeat_if_held' parameter from Button() - sorry! it was rarely used and inconsistent. Use PushButtonRepeat(true) / PopButtonRepeat() to enable repeat on desired buttons.
 - 2015/05/11 (1.40) - changed BeginPopup() API, takes a string identifier instead of a bool. ImGui needs to manage the open/closed state of popups. Call OpenPopup() to actually set the "open" state of a popup. BeginPopup() returns true if the popup is opened.
 - 2015/05/03 (1.40) - removed style.AutoFitPadding, using style.WindowPadding makes more sense (the default values were already the same).
 - 2015/04/13 (1.38) - renamed IsClipped() to IsRectClipped(). Kept inline redirection function until 1.50.
 - 2015/04/09 (1.38) - renamed ImDrawList::AddArc() to ImDrawList::AddArcFast() for compatibility with future API
 - 2015/04/03 (1.38) - removed ImGuiCol_CheckHovered, ImGuiCol_CheckActive, replaced with the more general ImGuiCol_FrameBgHovered, ImGuiCol_FrameBgActive.
 - 2014/04/03 (1.38) - removed support for passing -FLT_MAX..+FLT_MAX as the range for a SliderFloat(). Use DragFloat() or Inputfloat() instead.
 - 2015/03/17 (1.36) - renamed GetItemBoxMin()/GetItemBoxMax()/IsMouseHoveringBox() to GetItemRectMin()/GetItemRectMax()/IsMouseHoveringRect(). Kept inline redirection function until 1.50.
 - 2015/03/15 (1.36) - renamed style.TreeNodeSpacing to style.IndentSpacing, ImGuiStyleVar_TreeNodeSpacing to ImGuiStyleVar_IndentSpacing
 - 2015/03/13 (1.36) - renamed GetWindowIsFocused() to IsWindowFocused(). Kept inline redirection function until 1.50.
 - 2015/03/08 (1.35) - renamed style.ScrollBarWidth to style.ScrollbarWidth (casing)
 - 2015/02/27 (1.34) - renamed OpenNextNode(bool) to SetNextTreeNodeOpened(bool, ImGuiSetCond). Kept inline redirection function until 1.50.
 - 2015/02/27 (1.34) - renamed ImGuiSetCondition_*** to ImGuiSetCond_***, and _FirstUseThisSession becomes _Once.
 - 2015/02/11 (1.32) - changed text input callback ImGuiTextEditCallback return type from void-->int. reserved for future use, return 0 for now.
 - 2015/02/10 (1.32) - renamed GetItemWidth() to CalcItemWidth() to clarify its evolving behavior
 - 2015/02/08 (1.31) - renamed GetTextLineSpacing() to GetTextLineHeightWithSpacing()
 - 2015/02/01 (1.31) - removed IO.MemReallocFn (unused)
 - 2015/01/19 (1.30) - renamed ImGuiStorage::GetIntPtr()/GetFloatPtr() to GetIntRef()/GetIntRef() because Ptr was conflicting with actual pointer storage functions.
 - 2015/01/11 (1.30) - big font/image API change! now loads TTF file. allow for multiple fonts. no need for a PNG loader.
 - 2015/01/11 (1.30) - removed GetDefaultFontData(). uses io.Fonts->GetTextureData*() API to retrieve uncompressed pixels.
                       - old:  const void* png_data; unsigned int png_size; ImGui::GetDefaultFontData(NULL, NULL, &png_data, &png_size); [..Upload texture to GPU..];
                       - new:  unsigned char* pixels; int width, height; io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); [..Upload texture to GPU..]; io.Fonts->TexId = YourTexIdentifier;
                       you now have more flexibility to load multiple TTF fonts and manage the texture buffer for internal needs. It is now recommended that you sample the font texture with bilinear interpolation.
 - 2015/01/11 (1.30) - added texture identifier in ImDrawCmd passed to your render function (we can now render images). make sure to set io.Fonts->TexID.
 - 2015/01/11 (1.30) - removed IO.PixelCenterOffset (unnecessary, can be handled in user projection matrix)
 - 2015/01/11 (1.30) - removed ImGui::IsItemFocused() in favor of ImGui::IsItemActive() which handles all widgets
 - 2014/12/10 (1.18) - removed SetNewWindowDefaultPos() in favor of new generic API SetNextWindowPos(pos, ImGuiSetCondition_FirstUseEver)
 - 2014/11/28 (1.17) - moved IO.Font*** options to inside the IO.Font-> structure (FontYOffset, FontTexUvForWhite, FontBaseScale, FontFallbackGlyph)
 - 2014/11/26 (1.17) - reworked syntax of IMGUI_ONCE_UPON_A_FRAME helper macro to increase compiler compatibility
 - 2014/11/07 (1.15) - renamed IsHovered() to IsItemHovered()
 - 2014/10/02 (1.14) - renamed IMGUI_INCLUDE_IMGUI_USER_CPP to IMGUI_INCLUDE_IMGUI_USER_INL and imgui_user.cpp to imgui_user.inl (more IDE friendly)
 - 2014/09/25 (1.13) - removed 'text_end' parameter from IO.SetClipboardTextFn (the string is now always zero-terminated for simplicity)
 - 2014/09/24 (1.12) - renamed SetFontScale() to SetWindowFontScale()
 - 2014/09/24 (1.12) - moved IM_MALLOC/IM_REALLOC/IM_FREE preprocessor defines to IO.MemAllocFn/IO.MemReallocFn/IO.MemFreeFn
 - 2014/08/30 (1.09) - removed IO.FontHeight (now computed automatically)
 - 2014/08/30 (1.09) - moved IMGUI_FONT_TEX_UV_FOR_WHITE preprocessor define to IO.FontTexUvForWhite
 - 2014/08/28 (1.09) - changed the behavior of IO.PixelCenterOffset following various rendering fixes


 FREQUENTLY ASKED QUESTIONS (FAQ)
 ================================

 Read all answers online: https://www.dearimgui.org/faq, or in docs/FAQ.md (with a Markdown viewer)
 Some answers are copied down here to facilitate searching in code.

 Q&A: Basics
 ===========

 Q: Where is the documentation?
 A: This library is poorly documented at the moment and expects of the user to be acquainted with C/C++.
    - Run the examples/ and explore them.
    - See demo code in imgui_demo.cpp and particularly the ImGui::ShowDemoWindow() function.
    - The demo covers most features of Dear ImGui, so you can read the code and see its output.
    - See documentation and comments at the top of imgui.cpp + effectively imgui.h.
    - Dozens of standalone example applications using e.g. OpenGL/DirectX are provided in the
      examples/ folder to explain how to integrate Dear ImGui with your own engine/application.
    - The Wiki (https://github.com/ocornut/imgui/wiki) has many resources and links.
    - The Glossary (https://github.com/ocornut/imgui/wiki/Glossary) page also may be useful.
    - Your programming IDE is your friend, find the type or function declaration to find comments
      associated to it.

 Q: What is this library called?
 Q: Which version should I get?
 >> This library is called "Dear ImGui", please don't call it "ImGui" :)
 >> See https://www.dearimgui.org/faq

 Q&A: Integration
 ================

 Q: How can I tell whether to dispatch mouse/keyboard to Dear ImGui or to my application?
 A: You should read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags!
 >> See https://www.dearimgui.org/faq for fully detailed answer. You really want to read this.

 Q. How can I enable keyboard controls?
 Q: How can I use this without a mouse, without a keyboard or without a screen? (gamepad, input share, remote display)
 Q: I integrated Dear ImGui in my engine and the text or lines are blurry..
 Q: I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around..
 >> See https://www.dearimgui.org/faq

 Q&A: Usage
 ----------

 Q: Why are multiple widgets reacting when I interact with a single one?
 Q: How can I have multiple widgets with the same label or with an empty label?
 A: A primer on labels and the ID Stack...

    Dear ImGui internally need to uniquely identify UI elements.
    Elements that are typically not clickable (such as calls to the Text functions) don't need an ID.
    Interactive widgets (such as calls to Button buttons) need a unique ID.
    Unique ID are used internally to track active widgets and occasionally associate state to widgets.
    Unique ID are implicitly built from the hash of multiple elements that identify the "path" to the UI element.

   - Unique ID are often derived from a string label:

       Button("OK");          // Label = "OK",     ID = hash of (..., "OK")
       Button("Cancel");      // Label = "Cancel", ID = hash of (..., "Cancel")

   - ID are uniquely scoped within windows, tree nodes, etc. which all pushes to the ID stack. Having
     two buttons labeled "OK" in different windows or different tree locations is fine.
     We used "..." above to signify whatever was already pushed to the ID stack previously:

       Begin("MyWindow");
       Button("OK");          // Label = "OK",     ID = hash of ("MyWindow", "OK")
       End();
       Begin("MyOtherWindow");
       Button("OK");          // Label = "OK",     ID = hash of ("MyOtherWindow", "OK")
       End();

   - If you have a same ID twice in the same location, you'll have a conflict:

       Button("OK");
       Button("OK");          // ID collision! Interacting with either button will trigger the first one.

     Fear not! this is easy to solve and there are many ways to solve it!

   - Solving ID conflict in a simple/local context:
     When passing a label you can optionally specify extra ID information within string itself.
     Use "##" to pass a complement to the ID that won't be visible to the end-user.
     This helps solving the simple collision cases when you know e.g. at compilation time which items
     are going to be created:

       Begin("MyWindow");
       Button("Play");        // Label = "Play",   ID = hash of ("MyWindow", "Play")
       Button("Play##foo1");  // Label = "Play",   ID = hash of ("MyWindow", "Play##foo1")  // Different from above
       Button("Play##foo2");  // Label = "Play",   ID = hash of ("MyWindow", "Play##foo2")  // Different from above
       End();

   - If you want to completely hide the label, but still need an ID:

       Checkbox("##On", &b);  // Label = "",       ID = hash of (..., "##On")   // No visible label, just a checkbox!

   - Occasionally/rarely you might want change a label while preserving a constant ID. This allows
     you to animate labels. For example you may want to include varying information in a window title bar,
     but windows are uniquely identified by their ID. Use "###" to pass a label that isn't part of ID:

       Button("Hello###ID");  // Label = "Hello",  ID = hash of (..., "###ID")
       Button("World###ID");  // Label = "World",  ID = hash of (..., "###ID")  // Same as above, even though the label looks different

       sprintf(buf, "My game (%f FPS)###MyGame", fps);
       Begin(buf);            // Variable title,   ID = hash of "MyGame"

   - Solving ID conflict in a more general manner:
     Use PushID() / PopID() to create scopes and manipulate the ID stack, as to avoid ID conflicts
     within the same window. This is the most convenient way of distinguishing ID when iterating and
     creating many UI elements programmatically.
     You can push a pointer, a string or an integer value into the ID stack.
     Remember that ID are formed from the concatenation of _everything_ pushed into the ID stack.
     At each level of the stack we store the seed used for items at this level of the ID stack.

     Begin("Window");
       for (int i = 0; i < 100; i++)
       {
         PushID(i);           // Push i to the id tack
         Button("Click");     // Label = "Click",  ID = hash of ("Window", i, "Click")
         PopID();
       }
       for (int i = 0; i < 100; i++)
       {
         MyObject* obj = Objects[i];
         PushID(obj);
         Button("Click");     // Label = "Click",  ID = hash of ("Window", obj pointer, "Click")
         PopID();
       }
       for (int i = 0; i < 100; i++)
       {
         MyObject* obj = Objects[i];
         PushID(obj->Name);
         Button("Click");     // Label = "Click",  ID = hash of ("Window", obj->Name, "Click")
         PopID();
       }
       End();

   - You can stack multiple prefixes into the ID stack:

       Button("Click");       // Label = "Click",  ID = hash of (..., "Click")
       PushID("node");
       Button("Click");       // Label = "Click",  ID = hash of (..., "node", "Click")
         PushID(my_ptr);
           Button("Click");   // Label = "Click",  ID = hash of (..., "node", my_ptr, "Click")
         PopID();
       PopID();

   - Tree nodes implicitly creates a scope for you by calling PushID().

       Button("Click");       // Label = "Click",  ID = hash of (..., "Click")
       if (TreeNode("node"))  // <-- this function call will do a PushID() for you (unless instructed not to, with a special flag)
       {
         Button("Click");     // Label = "Click",  ID = hash of (..., "node", "Click")
         TreePop();
       }

   - When working with trees, ID are used to preserve the open/close state of each tree node.
     Depending on your use cases you may want to use strings, indices or pointers as ID.
      e.g. when following a single pointer that may change over time, using a static string as ID
       will preserve your node open/closed state when the targeted object change.
      e.g. when displaying a list of objects, using indices or pointers as ID will preserve the
       node open/closed state differently. See what makes more sense in your situation!

 Q: How can I display an image? What is ImTextureID, how does it works?
 >> See https://www.dearimgui.org/faq and https://github.com/ocornut/imgui/wiki/Image-Loading-and-Displaying-Examples

 Q: How can I use my own math types instead of ImVec2/ImVec4?
 Q: How can I interact with standard C++ types (such as std::string and std::vector)?
 Q: How can I display custom shapes? (using low-level ImDrawList API)
 >> See https://www.dearimgui.org/faq

 Q&A: Fonts, Text
 ================

 Q: How can I load a different font than the default?
 Q: How can I easily use icons in my application?
 Q: How can I load multiple fonts?
 Q: How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic?
 >> See https://www.dearimgui.org/faq and docs/FONTS.txt

 Q&A: Concerns
 =============

 Q: Who uses Dear ImGui?
 Q: Can you create elaborate/serious tools with Dear ImGui?
 Q: Can you reskin the look of Dear ImGui?
 Q: Why using C++ (as opposed to C)?
 >> See https://www.dearimgui.org/faq

 Q&A: Community
 ==============

 Q: How can I help?
 A: - Businesses: please reach out to "contact AT dearimgui.org" if you work in a place using Dear ImGui!
      We can discuss ways for your company to fund development via invoiced technical support, maintenance or sponsoring contacts.
      This is among the most useful thing you can do for Dear ImGui. With increased funding we can hire more people working on this project.
    - Individuals: you can support continued development via PayPal donations. See README.
    - If you are experienced with Dear ImGui and C++, look at the github issues, look at the Wiki, read docs/TODO.txt
      and see how you want to help and can help!
    - Disclose your usage of Dear ImGui via a dev blog post, a tweet, a screenshot, a mention somewhere etc.
      You may post screenshot or links in the gallery threads (github.com/ocornut/imgui/issues/3075). Visuals are ideal as they inspire other programmers.
      But even without visuals, disclosing your use of dear imgui help the library grow credibility, and help other teams and programmers with taking decisions.
    - If you have issues or if you need to hack into the library, even if you don't expect any support it is useful that you share your issues (on github or privately).

*/

//-------------------------------------------------------------------------
// [SECTION] INCLUDES
//-------------------------------------------------------------------------

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.hpp"

// Atom includes
#include "../constant/character.hpp"
#include "../constant/hash.hpp"
#include "../constant/secure_string.hpp"
#include "../constant/string.hpp"

#include "../core/map_data.hpp"

#include "../win32/image.hpp"
#include "../win32/math.hpp"
#include "../win32/process.hpp"
#include "../win32/string.hpp"
#include "../win32/time.hpp"
#include "../win32/trace.hpp"

using namespace horizon;

#ifndef IMGUI_DISABLE

#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif
#include "imgui_internal.hpp"

// System includes
#include <ctype.h>      // toupper
#include <stdio.h>      // vsnprintf, sscanf, printf
#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
#include <stddef.h>     // intptr_t
#else
#include <stdint.h>     // intptr_t
#endif

// [Windows] OS specific includes (optional)
#if defined(_WIN32) && defined(IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS) && defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS) && defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS)
#define IMGUI_DISABLE_WIN32_FUNCTIONS
#endif
#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS)
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif
#ifndef __MINGW32__
#include <Windows.h>        // _wfopen, OpenClipboard
#else
#include <windows.h>
#endif
#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP) // UWP doesn't have all Win32 functions
#define IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS
#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS
#endif
#endif

// [Apple] OS specific includes
#if defined(__APPLE__)
#include <TargetConditionals.h>
#endif

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4127)             // condition expression is constant
#pragma warning (disable: 4996)             // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#if defined(_MSC_VER) && _MSC_VER >= 1922   // MSVC 2019 16.2 or later
#pragma warning (disable: 5054)             // operator '|': deprecated between enumerations of different types
#endif
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#pragma clang diagnostic ignored "-Wunknown-pragmas"        // warning : unknown warning group '-Wformat-pedantic *'        // not all warnings are known by all clang versions.. so ignoring warnings triggers new warnings on some configuration. great!
#pragma clang diagnostic ignored "-Wold-style-cast"         // warning : use of old-style cast                              // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants (typically 0.0f) is ok.
#pragma clang diagnostic ignored "-Wformat-nonliteral"      // warning : format string is not a string literal              // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
#pragma clang diagnostic ignored "-Wexit-time-destructors"  // warning : declaration requires an exit-time destructor       // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.
#pragma clang diagnostic ignored "-Wglobal-constructors"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference is.
#pragma clang diagnostic ignored "-Wsign-conversion"        // warning : implicit conversion changes signedness             //
#pragma clang diagnostic ignored "-Wformat-pedantic"        // warning : format specifies type 'void *' but the argument has type 'xxxx *' // unreasonable, would lead to casting every %p arg to void*. probably enabled by -pedantic.
#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast"       // warning : cast to 'void *' from smaller integer type 'int'
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning : zero as null pointer constant              // some standard header variations use #define NULL 0
#endif
#if __has_warning("-Wdouble-promotion")
#pragma clang diagnostic ignored "-Wdouble-promotion"       // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#endif
#elif defined(__GNUC__)
// We disable -Wpragmas because GCC doesn't provide an has_warning equivalent and some forks/patches may not following the warning/version association.
#pragma GCC diagnostic ignored "-Wpragmas"                  // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wunused-function"          // warning: 'xxxx' defined but not used
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"      // warning: cast to pointer from integer of different size
#pragma GCC diagnostic ignored "-Wformat"                   // warning: format '%p' expects argument of type 'void*', but argument 6 has type 'ImGuiWindow*'
#pragma GCC diagnostic ignored "-Wdouble-promotion"         // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored "-Wconversion"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value
#pragma GCC diagnostic ignored "-Wformat-nonliteral"        // warning: format not a string literal, format string not checked
#pragma GCC diagnostic ignored "-Wstrict-overflow"          // warning: assuming signed overflow does not occur when assuming that (X - c) > X is always false
#pragma GCC diagnostic ignored "-Wclass-memaccess"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif

// Debug options
#define IMGUI_DEBUG_NAV_SCORING     0   // Display navigation scoring preview when hovering items. Display last moving direction matches when holding CTRL
#define IMGUI_DEBUG_NAV_RECTS       0   // Display the reference navigation rectangle for each window
#define IMGUI_DEBUG_INI_SETTINGS    0   // Save additional comments in .ini file (particularly helps for Docking, but makes saving slower)

// When using CTRL+TAB (or Gamepad Square+L/R) we delay the visual a little in order to reduce visual noise doing a fast switch.
static const float NAV_WINDOWING_HIGHLIGHT_DELAY = 0.20f;    // Time before the highlight and screen dimming starts fading in
static const float NAV_WINDOWING_LIST_APPEAR_DELAY = 0.15f;    // Time before the window list starts to appear

// Window resizing from edges (when io.ConfigWindowsResizeFromEdges = true and ImGuiBackendFlags_HasMouseCursors is set in io.BackendFlags by back-end)
static const float WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS = 4.0f;     // Extend outside and inside windows. Affect FindHoveredWindow().
static const float WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER = 0.04f;    // Reduce visual noise by only highlighting the border after a certain time.
static const float WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER = 2.00f;    // Lock scrolled window (so it doesn't pick child windows that are scrolling through) for a certain time, unless mouse moved.

//-------------------------------------------------------------------------
// [SECTION] FORWARD DECLARATIONS
//-------------------------------------------------------------------------

static void             SetCurrentWindow( ImGuiWindow* window );
static void             FindHoveredWindow();
static ImGuiWindow* CreateNewWindow( const char* name, ImVec2 size, ImGuiWindowFlags flags );
static ImVec2           CalcNextScrollFromScrollTargetAndClamp( ImGuiWindow* window, bool snap_on_edges );

static void             AddDrawListToDrawData( ImVector<ImDrawList*>* out_list, ImDrawList* draw_list );
static void             AddWindowToSortBuffer( ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window );

static ImRect           GetViewportRect();

// Settings
static void* WindowSettingsHandler_ReadOpen( ImGuiContext*, ImGuiSettingsHandler*, const char* name );
static void             WindowSettingsHandler_ReadLine( ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line );
static void             WindowSettingsHandler_WriteAll( ImGuiContext*, ImGuiSettingsHandler*, ImGuiTextBuffer* buf );

// Platform Dependents default implementation for IO functions
static const char* GetClipboardTextFn_DefaultImpl( void* user_data );
static void             SetClipboardTextFn_DefaultImpl( void* user_data, const char* text );
static void             ImeSetInputScreenPosFn_DefaultImpl( int x, int y );

namespace ImGui
{
// Navigation
static void             NavUpdate();
static void             NavUpdateWindowing();
static void             NavUpdateWindowingOverlay();
static void             NavUpdateMoveResult();
static float            NavUpdatePageUpPageDown();
static inline void      NavUpdateAnyRequestFlag();
static bool             NavScoreItem( ImGuiNavMoveResult* result, ImRect cand );
static void             NavProcessItem( ImGuiWindow* window, const ImRect& nav_bb, ImGuiID id );
static ImVec2           NavCalcPreferredRefPos();
static void             NavSaveLastChildNavWindowIntoParent( ImGuiWindow* nav_window );
static ImGuiWindow* NavRestoreLastChildNavWindow( ImGuiWindow* window );
static int              FindWindowFocusIndex( ImGuiWindow* window );

// Error Checking
static void             ErrorCheckNewFrameSanityChecks();
static void             ErrorCheckEndFrameSanityChecks();
static void             ErrorCheckBeginEndCompareStacksSize( ImGuiWindow* window, bool write );

// Misc
static void             UpdateSettings();
static void             UpdateMouseInputs();
static void             UpdateMouseWheel();
static void             UpdateTabFocus();
static void             UpdateDebugToolItemPicker();
static bool             UpdateWindowManualResize( ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[ 4 ] );
static void             RenderWindowOuterBorders( ImGuiWindow* window );
static void             RenderWindowDecorations( ImGuiWindow* window, const ImRect& title_bar_rect, bool title_bar_is_highlight, int resize_grip_count, const ImU32 resize_grip_col[ 4 ], float resize_grip_draw_size );
static void             RenderWindowTitleBarContents( ImGuiWindow* window, const ImRect& title_bar_rect, const char* name, bool* p_open );

}

//-----------------------------------------------------------------------------
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
//-----------------------------------------------------------------------------

// Current context pointer. Implicitly used by all Dear ImGui functions. Always assumed to be != NULL.
// ImGui::CreateContext() will automatically set this pointer if it is NULL. Change to a different context by calling ImGui::SetCurrentContext().
// 1) Important: globals are not shared across DLL boundaries! If you use DLLs or any form of hot-reloading: you will need to call
//    SetCurrentContext() (with the pointer you got from CreateContext) from each unique static/DLL boundary, and after each hot-reloading.
//    In your debugger, add GImGui to your watch window and notice how its value changes depending on which location you are currently stepping into.
// 2) Important: Dear ImGui functions are not thread-safe because of this pointer.
//    If you want thread-safety to allow N threads to access N different contexts, you can:
//    - Change this variable to use thread local storage so each thread can refer to a different context, in imconfig.h:
//          struct ImGuiContext;
//          extern thread_local ImGuiContext* MyImGuiTLS;
//          #define GImGui MyImGuiTLS
//      And then define MyImGuiTLS in one of your cpp file. Note that thread_local is a C++11 keyword, earlier C++ uses compiler-specific keyword.
//    - Future development aim to make this context pointer explicit to all calls. Also read https://github.com/ocornut/imgui/issues/586
//    - If you need a finite number of contexts, you may compile and use multiple instances of the ImGui code from different namespace.
#ifndef GImGui
ImGuiContext* GImGui = NULL;
#endif

// Memory Allocator functions. Use SetAllocatorFunctions() to change them.
// If you use DLL hotreloading you might need to call SetAllocatorFunctions() after reloading code from this file.
// Otherwise, you probably don't want to modify them mid-program, and if you use global/static e.g. ImVector<> instances you may need to keep them accessible during program destruction.
#ifndef IMGUI_DISABLE_DEFAULT_ALLOCATORS
static void* MallocWrapper( size_t size, void* user_data )
{
  // IM_UNUSED( user_data ); return malloc( size );
  IM_UNUSED( user_data );
  auto heap = win32::GetProcessHeap();
  return win32::RtlAllocateHeap( heap, 0, size );
}
static void    FreeWrapper( void* ptr, void* user_data )
{
  // IM_UNUSED( user_data ); free( ptr );
  IM_UNUSED( user_data );
  auto heap = win32::GetProcessHeap();
  win32::RtlFreeHeap( heap, 0, ptr );
}
#else
static void* MallocWrapper( size_t size, void* user_data )
{
  IM_UNUSED( user_data ); IM_UNUSED( size ); IM_ASSERT( 0 ); return NULL;
}
static void    FreeWrapper( void* ptr, void* user_data )
{
  IM_UNUSED( user_data ); IM_UNUSED( ptr ); IM_ASSERT( 0 );
}
#endif

static void* ( *GImAllocatorAllocFunc )( size_t size, void* user_data ) = MallocWrapper;
static void   ( *GImAllocatorFreeFunc )( void* ptr, void* user_data ) = FreeWrapper;
static void* GImAllocatorUserData = NULL;

//-----------------------------------------------------------------------------
// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)
//-----------------------------------------------------------------------------

ImGuiStyle::ImGuiStyle()
{
  Alpha = 1.0f;             // Global alpha applies to everything in ImGui
  WindowPadding = ImVec2( 8, 8 );      // Padding within a window
  WindowRounding = 7.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows
  WindowBorderSize = 1.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.
  WindowMinSize = ImVec2( 32, 32 );    // Minimum window size
  WindowTitleAlign = ImVec2( 0.0f, 0.5f );// Alignment for title bar text
  WindowMenuButtonPosition = ImGuiDir_Left;    // Position of the collapsing/docking button in the title bar (left/right). Defaults to ImGuiDir_Left.
  ChildRounding = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows
  ChildBorderSize = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
  PopupRounding = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows
  PopupBorderSize = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
  FramePadding = ImVec2( 4, 3 );      // Padding within a framed rectangle (used by most widgets)
  FrameRounding = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).
  FrameBorderSize = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.
  ItemSpacing = ImVec2( 8, 4 );      // Horizontal and vertical spacing between widgets/lines
  ItemInnerSpacing = ImVec2( 4, 4 );      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
  TouchExtraPadding = ImVec2( 0, 0 );      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
  IndentSpacing = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
  ColumnsMinSpacing = 6.0f;             // Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).
  ScrollbarSize = 14.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar
  ScrollbarRounding = 9.0f;             // Radius of grab corners rounding for scrollbar
  GrabMinSize = 10.0f;            // Minimum width/height of a grab box for slider/scrollbar
  GrabRounding = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
  TabRounding = 4.0f;             // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
  TabBorderSize = 0.0f;             // Thickness of border around tabs.
  ColorButtonPosition = ImGuiDir_Right;   // Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.
  ButtonTextAlign = ImVec2( 0.5f, 0.5f );// Alignment of button text when button is larger than text.
  SelectableTextAlign = ImVec2( 0.0f, 0.0f );// Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.
  DisplayWindowPadding = ImVec2( 19, 19 );    // Window position are clamped to be visible within the display area or monitors by at least this amount. Only applies to regular windows.
  DisplaySafeAreaPadding = ImVec2( 3, 3 );      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
  MouseCursorScale = 1.0f;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
  AntiAliasedLines = true;             // Enable anti-aliasing on lines/borders. Disable if you are really short on CPU/GPU.
  AntiAliasedFill = true;             // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)
  CurveTessellationTol = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
  CircleSegmentMaxError = 1.60f;            // Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.

  // Default theme
  ImGui::StyleColorsDark( this );
}

// To scale your entire UI (e.g. if you want your app to use High DPI or generally be DPI aware) you may use this helper function. Scaling the fonts is done separately and is up to you.
// Important: This operation is lossy because we round all sizes to integer. If you need to change your scale multiples, call this over a freshly initialized ImGuiStyle structure rather than scaling multiple times.
void ImGuiStyle::ScaleAllSizes( float scale_factor )
{
  WindowPadding = ImFloor( WindowPadding * scale_factor );
  WindowRounding = ImFloor( WindowRounding * scale_factor );
  WindowMinSize = ImFloor( WindowMinSize * scale_factor );
  ChildRounding = ImFloor( ChildRounding * scale_factor );
  PopupRounding = ImFloor( PopupRounding * scale_factor );
  FramePadding = ImFloor( FramePadding * scale_factor );
  FrameRounding = ImFloor( FrameRounding * scale_factor );
  ItemSpacing = ImFloor( ItemSpacing * scale_factor );
  ItemInnerSpacing = ImFloor( ItemInnerSpacing * scale_factor );
  TouchExtraPadding = ImFloor( TouchExtraPadding * scale_factor );
  IndentSpacing = ImFloor( IndentSpacing * scale_factor );
  ColumnsMinSpacing = ImFloor( ColumnsMinSpacing * scale_factor );
  ScrollbarSize = ImFloor( ScrollbarSize * scale_factor );
  ScrollbarRounding = ImFloor( ScrollbarRounding * scale_factor );
  GrabMinSize = ImFloor( GrabMinSize * scale_factor );
  GrabRounding = ImFloor( GrabRounding * scale_factor );
  TabRounding = ImFloor( TabRounding * scale_factor );
  DisplayWindowPadding = ImFloor( DisplayWindowPadding * scale_factor );
  DisplaySafeAreaPadding = ImFloor( DisplaySafeAreaPadding * scale_factor );
  MouseCursorScale = ImFloor( MouseCursorScale * scale_factor );
}

ImGuiIO::ImGuiIO()
{
  // Most fields are initialized with zero
  memset( this, 0, sizeof( *this ) );
  IM_ASSERT( IM_ARRAYSIZE( ImGuiIO::MouseDown ) == ImGuiMouseButton_COUNT && IM_ARRAYSIZE( ImGuiIO::MouseClicked ) == ImGuiMouseButton_COUNT ); // Our pre-C++11 IM_STATIC_ASSERT() macros triggers warning on modern compilers so we don't use it here.

  // Settings
  ConfigFlags = ImGuiConfigFlags_None;
  BackendFlags = ImGuiBackendFlags_None;
  DisplaySize = ImVec2( -1.0f, -1.0f );
  DeltaTime = 1.0f / 60.0f;
  IniSavingRate = 5.0f;
  IniFilename = SECURE( "imgui.ini" );
  LogFilename = SECURE( "imgui_log.txt" );
  MouseDoubleClickTime = 0.30f;
  MouseDoubleClickMaxDist = 6.0f;
  for( int i = 0; i < ImGuiKey_COUNT; i++ )
    KeyMap[ i ] = -1;
  KeyRepeatDelay = 0.275f;
  KeyRepeatRate = 0.050f;
  UserData = NULL;

  Fonts = NULL;
  FontGlobalScale = 1.0f;
  FontDefault = NULL;
  FontAllowUserScaling = false;
  DisplayFramebufferScale = ImVec2( 1.0f, 1.0f );

  // Miscellaneous options
  MouseDrawCursor = false;
#ifdef __APPLE__
  ConfigMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag
#else
  ConfigMacOSXBehaviors = false;
#endif
  ConfigInputTextCursorBlink = true;
  ConfigWindowsResizeFromEdges = true;
  ConfigWindowsMoveFromTitleBarOnly = false;
  ConfigWindowsMemoryCompactTimer = 60.0f;

  // Platform Functions
  BackendPlatformName = BackendRendererName = NULL;
  BackendPlatformUserData = BackendRendererUserData = BackendLanguageUserData = NULL;
  GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;   // Platform dependent default implementations
  SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;
  ClipboardUserData = NULL;
  ImeSetInputScreenPosFn = ImeSetInputScreenPosFn_DefaultImpl;
  ImeWindowHandle = NULL;

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
  RenderDrawListsFn = NULL;
#endif

  // Input (NB: we already have memset zero the entire structure!)
  MousePos = ImVec2( -FLT_MAX, -FLT_MAX );
  MousePosPrev = ImVec2( -FLT_MAX, -FLT_MAX );
  MouseDragThreshold = 6.0f;
  for( int i = 0; i < IM_ARRAYSIZE( MouseDownDuration ); i++ ) MouseDownDuration[ i ] = MouseDownDurationPrev[ i ] = -1.0f;
  for( int i = 0; i < IM_ARRAYSIZE( KeysDownDuration ); i++ ) KeysDownDuration[ i ] = KeysDownDurationPrev[ i ] = -1.0f;
  for( int i = 0; i < IM_ARRAYSIZE( NavInputsDownDuration ); i++ ) NavInputsDownDuration[ i ] = -1.0f;
}

// Pass in translated ASCII characters for text input.
// - with glfw you can get those from the callback set in glfwSetCharCallback()
// - on Windows you can get those using ToAscii+keyboard state, or via the WM_CHAR message
void ImGuiIO::AddInputCharacter( unsigned int c )
{
  InputQueueCharacters.push_back( c > 0 && c <= IM_UNICODE_CODEPOINT_MAX ? ( ImWchar )c : IM_UNICODE_CODEPOINT_INVALID );
}

// UTF16 strings use surrogate pairs to encode codepoints >= 0x10000, so
// we should save the high surrogate.
void ImGuiIO::AddInputCharacterUTF16( ImWchar16 c )
{
  if( ( c & 0xFC00 ) == 0xD800 ) // High surrogate, must save
  {
    if( InputQueueSurrogate != 0 )
      InputQueueCharacters.push_back( 0xFFFD );
    InputQueueSurrogate = c;
    return;
  }

  ImWchar cp = c;
  if( InputQueueSurrogate != 0 )
  {
    if( ( c & 0xFC00 ) != 0xDC00 ) // Invalid low surrogate
      InputQueueCharacters.push_back( IM_UNICODE_CODEPOINT_INVALID );
    else if( IM_UNICODE_CODEPOINT_MAX == ( 0xFFFF ) ) // Codepoint will not fit in ImWchar (extra parenthesis around 0xFFFF somehow fixes -Wunreachable-code with Clang)
      cp = IM_UNICODE_CODEPOINT_INVALID;
    else
      cp = ( ImWchar )( ( ( InputQueueSurrogate - 0xD800 ) << 10 ) + ( c - 0xDC00 ) + 0x10000 );
    InputQueueSurrogate = 0;
  }
  InputQueueCharacters.push_back( cp );
}

void ImGuiIO::AddInputCharactersUTF8( const char* utf8_chars )
{
  while( *utf8_chars != 0 )
  {
    unsigned int c = 0;
    utf8_chars += ImTextCharFromUtf8( &c, utf8_chars, NULL );
    if( c > 0 )
      InputQueueCharacters.push_back( ( ImWchar )c );
  }
}

void ImGuiIO::ClearInputCharacters()
{
  InputQueueCharacters.resize( 0 );
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)
//-----------------------------------------------------------------------------

ImVec2 ImBezierClosestPoint( const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, int num_segments )
{
  IM_ASSERT( num_segments > 0 ); // Use ImBezierClosestPointCasteljau()
  ImVec2 p_last = p1;
  ImVec2 p_closest;
  float p_closest_dist2 = FLT_MAX;
  float t_step = 1.0f / ( float )num_segments;
  for( int i_step = 1; i_step <= num_segments; i_step++ )
  {
    ImVec2 p_current = ImBezierCalc( p1, p2, p3, p4, t_step * i_step );
    ImVec2 p_line = ImLineClosestPoint( p_last, p_current, p );
    float dist2 = ImLengthSqr( p - p_line );
    if( dist2 < p_closest_dist2 )
    {
      p_closest = p_line;
      p_closest_dist2 = dist2;
    }
    p_last = p_current;
  }
  return p_closest;
}

// Closely mimics PathBezierToCasteljau() in imgui_draw.cpp
static void BezierClosestPointCasteljauStep( const ImVec2& p, ImVec2& p_closest, ImVec2& p_last, float& p_closest_dist2, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level )
{
  float dx = x4 - x1;
  float dy = y4 - y1;
  float d2 = ( ( x2 - x4 ) * dy - ( y2 - y4 ) * dx );
  float d3 = ( ( x3 - x4 ) * dy - ( y3 - y4 ) * dx );
  d2 = ( d2 >= 0 ) ? d2 : -d2;
  d3 = ( d3 >= 0 ) ? d3 : -d3;
  if( ( d2 + d3 ) * ( d2 + d3 ) < tess_tol * ( dx * dx + dy * dy ) )
  {
    ImVec2 p_current( x4, y4 );
    ImVec2 p_line = ImLineClosestPoint( p_last, p_current, p );
    float dist2 = ImLengthSqr( p - p_line );
    if( dist2 < p_closest_dist2 )
    {
      p_closest = p_line;
      p_closest_dist2 = dist2;
    }
    p_last = p_current;
  }
  else if( level < 10 )
  {
    float x12 = ( x1 + x2 ) * 0.5f, y12 = ( y1 + y2 ) * 0.5f;
    float x23 = ( x2 + x3 ) * 0.5f, y23 = ( y2 + y3 ) * 0.5f;
    float x34 = ( x3 + x4 ) * 0.5f, y34 = ( y3 + y4 ) * 0.5f;
    float x123 = ( x12 + x23 ) * 0.5f, y123 = ( y12 + y23 ) * 0.5f;
    float x234 = ( x23 + x34 ) * 0.5f, y234 = ( y23 + y34 ) * 0.5f;
    float x1234 = ( x123 + x234 ) * 0.5f, y1234 = ( y123 + y234 ) * 0.5f;
    BezierClosestPointCasteljauStep( p, p_closest, p_last, p_closest_dist2, x1, y1, x12, y12, x123, y123, x1234, y1234, tess_tol, level + 1 );
    BezierClosestPointCasteljauStep( p, p_closest, p_last, p_closest_dist2, x1234, y1234, x234, y234, x34, y34, x4, y4, tess_tol, level + 1 );
  }
}

// tess_tol is generally the same value you would find in ImGui::GetStyle().CurveTessellationTol
// Because those ImXXX functions are lower-level than ImGui:: we cannot access this value automatically.
ImVec2 ImBezierClosestPointCasteljau( const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, float tess_tol )
{
  IM_ASSERT( tess_tol > 0.0f );
  ImVec2 p_last = p1;
  ImVec2 p_closest;
  float p_closest_dist2 = FLT_MAX;
  BezierClosestPointCasteljauStep( p, p_closest, p_last, p_closest_dist2, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, tess_tol, 0 );
  return p_closest;
}

ImVec2 ImLineClosestPoint( const ImVec2& a, const ImVec2& b, const ImVec2& p )
{
  ImVec2 ap = p - a;
  ImVec2 ab_dir = b - a;
  float dot = ap.x * ab_dir.x + ap.y * ab_dir.y;
  if( dot < 0.0f )
    return a;
  float ab_len_sqr = ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y;
  if( dot > ab_len_sqr )
    return b;
  return a + ab_dir * dot / ab_len_sqr;
}

bool ImTriangleContainsPoint( const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p )
{
  bool b1 = ( ( p.x - b.x ) * ( a.y - b.y ) - ( p.y - b.y ) * ( a.x - b.x ) ) < 0.0f;
  bool b2 = ( ( p.x - c.x ) * ( b.y - c.y ) - ( p.y - c.y ) * ( b.x - c.x ) ) < 0.0f;
  bool b3 = ( ( p.x - a.x ) * ( c.y - a.y ) - ( p.y - a.y ) * ( c.x - a.x ) ) < 0.0f;
  return ( ( b1 == b2 ) && ( b2 == b3 ) );
}

void ImTriangleBarycentricCoords( const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w )
{
  ImVec2 v0 = b - a;
  ImVec2 v1 = c - a;
  ImVec2 v2 = p - a;
  const float denom = v0.x * v1.y - v1.x * v0.y;
  out_v = ( v2.x * v1.y - v1.x * v2.y ) / denom;
  out_w = ( v0.x * v2.y - v2.x * v0.y ) / denom;
  out_u = 1.0f - out_v - out_w;
}

ImVec2 ImTriangleClosestPoint( const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p )
{
  ImVec2 proj_ab = ImLineClosestPoint( a, b, p );
  ImVec2 proj_bc = ImLineClosestPoint( b, c, p );
  ImVec2 proj_ca = ImLineClosestPoint( c, a, p );
  float dist2_ab = ImLengthSqr( p - proj_ab );
  float dist2_bc = ImLengthSqr( p - proj_bc );
  float dist2_ca = ImLengthSqr( p - proj_ca );
  float m = ImMin( dist2_ab, ImMin( dist2_bc, dist2_ca ) );
  if( m == dist2_ab )
    return proj_ab;
  if( m == dist2_bc )
    return proj_bc;
  return proj_ca;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)
//-----------------------------------------------------------------------------

// Consider using _stricmp/_strnicmp under Windows or strcasecmp/strncasecmp. We don't actually use either ImStricmp/ImStrnicmp in the codebase any more.
int ImStricmp( const char* str1, const char* str2 )
{
  int d;
  while( ( d = win32::toupper( *str2 ) - win32::toupper( *str1 ) ) == 0 && *str1 )
  {
    str1++; str2++;
  }
  return d;
}

int ImStrnicmp( const char* str1, const char* str2, size_t count )
{
  int d = 0;
  while( count > 0 && ( d = win32::toupper( *str2 ) - win32::toupper( *str1 ) ) == 0 && *str1 )
  {
    str1++; str2++; count--;
  }
  return d;
}

void ImStrncpy( char* dst, const char* src, size_t count )
{
  if( count < 1 )
    return;
  if( count > 1 )
    win32::strncpy( dst, src, count - 1 );
  dst[ count - 1 ] = 0;
}

char* ImStrdup( const char* str )
{
  size_t len = win32::strlen( str );
  void* buf = IM_ALLOC( len + 1 );
  return ( char* )memcpy( buf, ( const void* )str, len + 1 );
}

char* ImStrdupcpy( char* dst, size_t* p_dst_size, const char* src )
{
  size_t dst_buf_size = p_dst_size ? *p_dst_size : win32::strlen( dst ) + 1;
  size_t src_size = win32::strlen( src ) + 1;
  if( dst_buf_size < src_size )
  {
    IM_FREE( dst );
    dst = ( char* )IM_ALLOC( src_size );
    if( p_dst_size )
      *p_dst_size = src_size;
  }
  return ( char* )memcpy( dst, ( const void* )src, src_size );
}

const char* ImStrchrRange( const char* str, const char* str_end, char c )
{
  const char* p = ( const char* )memchr( str, ( int )c, str_end - str );
  return p;
}

int ImStrlenW( const ImWchar* str )
{
  //return (int)wcslen((const wchar_t*)str);  // FIXME-OPT: Could use this when wchar_t are 16-bit
  int n = 0;
  while( *str++ ) n++;
  return n;
}

// Find end-of-line. Return pointer will point to either first \n, either str_end.
const char* ImStreolRange( const char* str, const char* str_end )
{
  const char* p = ( const char* )memchr( str, '\n', str_end - str );
  return p ? p : str_end;
}

const ImWchar* ImStrbolW( const ImWchar* buf_mid_line, const ImWchar* buf_begin ) // find beginning-of-line
{
  while( buf_mid_line > buf_begin && buf_mid_line[ -1 ] != '\n' )
    buf_mid_line--;
  return buf_mid_line;
}

const char* ImStristr( const char* haystack, const char* haystack_end, const char* needle, const char* needle_end )
{
  if( !needle_end )
    needle_end = needle + win32::strlen( needle );

  const char un0 = ( char )win32::toupper( *needle );
  while( ( !haystack_end && *haystack ) || ( haystack_end && haystack < haystack_end ) )
  {
    if( win32::toupper( *haystack ) == un0 )
    {
      const char* b = needle + 1;
      for( const char* a = haystack + 1; b < needle_end; a++, b++ )
        if( win32::toupper( *a ) != win32::toupper( *b ) )
          break;
      if( b == needle_end )
        return haystack;
    }
    haystack++;
  }
  return NULL;
}

// Trim str by offsetting contents when there's leading data + writing a \0 at the trailing position. We use this in situation where the cost is negligible.
void ImStrTrimBlanks( char* buf )
{
  char* p = buf;
  while( p[ 0 ] == ' ' || p[ 0 ] == '\t' )     // Leading blanks
    p++;
  char* p_start = p;
  while( *p != 0 )                         // Find end of string
    p++;
  while( p > p_start && ( p[ -1 ] == ' ' || p[ -1 ] == '\t' ) )  // Trailing blanks
    p--;
  if( p_start != buf )                     // Copy memory if we had leading blanks
    memmove( buf, p_start, p - p_start );
  buf[ p - p_start ] = 0;                   // Zero terminate
}

const char* ImStrSkipBlank( const char* str )
{
  while( str[ 0 ] == ' ' || str[ 0 ] == '\t' )
    str++;
  return str;
}

// A) MSVC version appears to return -1 on overflow, whereas glibc appears to return total count (which may be >= buf_size).
// Ideally we would test for only one of those limits at runtime depending on the behavior the vsnprintf(), but trying to deduct it at compile time sounds like a pandora can of worm.
// B) When buf==NULL vsnprintf() will return the output size.
#ifndef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS

// We support stb_sprintf which is much faster (see: https://github.com/nothings/stb/blob/master/stb_sprintf.h)
// You may set IMGUI_USE_STB_SPRINTF to use our default wrapper, or set IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
// and setup the wrapper yourself. (FIXME-OPT: Some of our high-level operations such as ImGuiTextBuffer::appendfv() are
// designed using two-passes worst case, which probably could be improved using the stbsp_vsprintfcb() function.)
#ifdef IMGUI_USE_STB_SPRINTF
#define STB_SPRINTF_IMPLEMENTATION
#include "stb_sprintf.h"
#endif

#if defined(_MSC_VER) && !defined(vsnprintf)
#define vsnprintf _vsnprintf
#endif

int ImFormatString( char* buf, size_t buf_size, const char* fmt, ... )
{
  va_list args;
  va_start( args, fmt );
#ifdef IMGUI_USE_STB_SPRINTF
  int w = stbsp_vsnprintf( buf, ( int )buf_size, fmt, args );
#else
  int w = win32::vsnprintf_s( buf, buf_size, fmt, args );
#endif
  va_end( args );
  if( buf == NULL )
    return w;
  if( w == -1 || w >= ( int )buf_size )
    w = ( int )buf_size - 1;
  buf[ w ] = 0;
  return w;
}

int ImFormatStringV( char* buf, size_t buf_size, const char* fmt, va_list args )
{
#ifdef IMGUI_USE_STB_SPRINTF
  int w = stbsp_vsnprintf( buf, ( int )buf_size, fmt, args );
#else
  int w = win32::vsnprintf_s( buf, buf_size, fmt, args );
#endif
  if( buf == NULL )
    return w;
  if( w == -1 || w >= ( int )buf_size )
    w = ( int )buf_size - 1;
  buf[ w ] = 0;
  return w;
}
#endif // #ifdef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS

// CRC32 needs a 1KB lookup table (not cache friendly)
// Although the code to generate the table is simple and shorter than the table itself, using a const table allows us to easily:
// - avoid an unnecessary branch/memory tap, - keep the ImHashXXX functions usable by static constructors, - make it thread-safe.
static const ImU32 GCrc32LookupTable[ 256 ] =
{
    0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535,0x9E6495A3,0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD,0xE7B82D07,0x90BF1D91,
    0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D,0x6DDDE4EB,0xF4D4B551,0x83D385C7,0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC,0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,
    0x3B6E20C8,0x4C69105E,0xD56041E4,0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,0x35B5A8FA,0x42B2986C,0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,
    0x26D930AC,0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F,0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB,0xB6662D3D,
    0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F,0x9FBFE4A5,0xE8B8D433,0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB,0x086D3D2D,0x91646C97,0xE6635C01,
    0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E,0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,0x65B0D9C6,0x12B7E950,0x8BBEB8EA,0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,
    0x4DB26158,0x3AB551CE,0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,0x4369E96A,0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9,
    0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409,0xCE61E49F,0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81,0xB7BD5C3B,0xC0BA6CAD,
    0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739,0x9DD277AF,0x04DB2615,0x73DC1683,0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8,0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,
    0xF00F9344,0x8708A3D2,0x1E01F268,0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,0xFED41B76,0x89D32BE0,0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,
    0xD6D6A3E8,0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B,0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF,0x4669BE79,
    0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703,0x220216B9,0x5505262F,0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7,0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,
    0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A,0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,0x95BF4A82,0xE2B87A14,0x7BB12BAE,0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,
    0x86D3D2D4,0xF1D4E242,0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,0x88085AE6,0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45,
    0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D,0x3E6E77DB,0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5,0x47B2CF7F,0x30B5FFE9,
    0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605,0xCDD70693,0x54DE5729,0x23D967BF,0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94,0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D,
};

// Known size hash
// It is ok to call ImHashData on a string with known length but the ### operator won't be supported.
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
ImU32 ImHashData( const void* data_p, size_t data_size, ImU32 seed )
{
  ImU32 crc = ~seed;
  const unsigned char* data = ( const unsigned char* )data_p;
  const ImU32* crc32_lut = GCrc32LookupTable;
  while( data_size-- != 0 )
    crc = ( crc >> 8 ) ^ crc32_lut[ ( crc & 0xFF ) ^ *data++ ];
  return ~crc;
}

// Zero-terminated string hash, with support for ### to reset back to seed value
// We support a syntax of "label###id" where only "###id" is included in the hash, and only "label" gets displayed.
// Because this syntax is rarely used we are optimizing for the common case.
// - If we reach ### in the string we discard the hash so far and reset to the seed.
// - We don't do 'current += 2; continue;' after handling ### to keep the code smaller/faster (measured ~10% diff in Debug build)
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
ImU32 ImHashStr( const char* data_p, size_t data_size, ImU32 seed )
{
  seed = ~seed;
  ImU32 crc = seed;
  const unsigned char* data = ( const unsigned char* )data_p;
  const ImU32* crc32_lut = GCrc32LookupTable;
  if( data_size != 0 )
  {
    while( data_size-- != 0 )
    {
      unsigned char c = *data++;
      if( c == '#' && data_size >= 2 && data[ 0 ] == '#' && data[ 1 ] == '#' )
        crc = seed;
      crc = ( crc >> 8 ) ^ crc32_lut[ ( crc & 0xFF ) ^ c ];
    }
  }
  else
  {
    while( unsigned char c = *data++ )
    {
      if( c == '#' && data[ 0 ] == '#' && data[ 1 ] == '#' )
        crc = seed;
      crc = ( crc >> 8 ) ^ crc32_lut[ ( crc & 0xFF ) ^ c ];
    }
  }
  return ~crc;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (File functions)
//-----------------------------------------------------------------------------

// Default file functions
#ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS

ImFileHandle ImFileOpen( const char* filename, const char* mode )
{
#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && !defined(__CYGWIN__) && !defined(__GNUC__)
  // We need a fopen() wrapper because MSVC/Windows fopen doesn't handle UTF-8 filenames.
  // Previously we used ImTextCountCharsFromUtf8/ImTextStrFromUtf8 here but we now need to support ImWchar16 and ImWchar32!
  const int filename_wsize = ::MultiByteToWideChar( CP_UTF8, 0, filename, -1, NULL, 0 );
  const int mode_wsize = ::MultiByteToWideChar( CP_UTF8, 0, mode, -1, NULL, 0 );
  ImVector<ImWchar> buf;
  buf.resize( filename_wsize + mode_wsize );
  ::MultiByteToWideChar( CP_UTF8, 0, filename, -1, ( wchar_t* )&buf[ 0 ], filename_wsize );
  ::MultiByteToWideChar( CP_UTF8, 0, mode, -1, ( wchar_t* )&buf[ filename_wsize ], mode_wsize );
  return ::_wfopen( ( const wchar_t* )&buf[ 0 ], ( const wchar_t* )&buf[ filename_wsize ] );
#else
  return fopen( filename, mode );
#endif
}

// We should in theory be using fseeko()/ftello() with off_t and _fseeki64()/_ftelli64() with __int64, waiting for the PR that does that in a very portable pre-C++11 zero-warnings way.
bool    ImFileClose( ImFileHandle f )
{
  return fclose( f ) == 0;
}
ImU64   ImFileGetSize( ImFileHandle f )
{
  long off = 0, sz = 0; return ( ( off = ftell( f ) ) != -1 && !fseek( f, 0, SEEK_END ) && ( sz = ftell( f ) ) != -1 && !fseek( f, off, SEEK_SET ) ) ? ( ImU64 )sz : ( ImU64 )-1;
}
ImU64   ImFileRead( void* data, ImU64 sz, ImU64 count, ImFileHandle f )
{
  return fread( data, ( size_t )sz, ( size_t )count, f );
}
ImU64   ImFileWrite( const void* data, ImU64 sz, ImU64 count, ImFileHandle f )
{
  return fwrite( data, ( size_t )sz, ( size_t )count, f );
}
#endif // #ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS

// Helper: Load file content into memory
// Memory allocated with IM_ALLOC(), must be freed by user using IM_FREE() == ImGui::MemFree()
// This can't really be used with "rt" because fseek size won't match read size.
void* ImFileLoadToMemory( const char* filename, const char* mode, size_t* out_file_size, int padding_bytes )
{
  IM_ASSERT( filename && mode );
  if( out_file_size )
    *out_file_size = 0;

  ImFileHandle f;
  if( ( f = ImFileOpen( filename, mode ) ) == NULL )
    return NULL;

  size_t file_size = ( size_t )ImFileGetSize( f );
  if( file_size == ( size_t )-1 )
  {
    ImFileClose( f );
    return NULL;
  }

  void* file_data = IM_ALLOC( file_size + padding_bytes );
  if( file_data == NULL )
  {
    ImFileClose( f );
    return NULL;
  }
  if( ImFileRead( file_data, 1, file_size, f ) != file_size )
  {
    ImFileClose( f );
    IM_FREE( file_data );
    return NULL;
  }
  if( padding_bytes > 0 )
    memset( ( void* )( ( ( char* )file_data ) + file_size ), 0, ( size_t )padding_bytes );

  ImFileClose( f );
  if( out_file_size )
    *out_file_size = file_size;

  return file_data;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
//-----------------------------------------------------------------------------

// Convert UTF-8 to 32-bit character, process single character input.
// Based on stb_from_utf8() from github.com/nothings/stb/
// We handle UTF-8 decoding error by skipping forward.
int ImTextCharFromUtf8( unsigned int* out_char, const char* in_text, const char* in_text_end )
{
  unsigned int c = ( unsigned int )-1;
  const unsigned char* str = ( const unsigned char* )in_text;
  if( !( *str & 0x80 ) )
  {
    c = ( unsigned int )( *str++ );
    *out_char = c;
    return 1;
  }
  if( ( *str & 0xe0 ) == 0xc0 )
  {
    *out_char = IM_UNICODE_CODEPOINT_INVALID; // will be invalid but not end of string
    if( in_text_end && in_text_end - ( const char* )str < 2 ) return 1;
    if( *str < 0xc2 ) return 2;
    c = ( unsigned int )( ( *str++ & 0x1f ) << 6 );
    if( ( *str & 0xc0 ) != 0x80 ) return 2;
    c += ( *str++ & 0x3f );
    *out_char = c;
    return 2;
  }
  if( ( *str & 0xf0 ) == 0xe0 )
  {
    *out_char = IM_UNICODE_CODEPOINT_INVALID; // will be invalid but not end of string
    if( in_text_end && in_text_end - ( const char* )str < 3 ) return 1;
    if( *str == 0xe0 && ( str[ 1 ] < 0xa0 || str[ 1 ] > 0xbf ) ) return 3;
    if( *str == 0xed && str[ 1 ] > 0x9f ) return 3; // str[1] < 0x80 is checked below
    c = ( unsigned int )( ( *str++ & 0x0f ) << 12 );
    if( ( *str & 0xc0 ) != 0x80 ) return 3;
    c += ( unsigned int )( ( *str++ & 0x3f ) << 6 );
    if( ( *str & 0xc0 ) != 0x80 ) return 3;
    c += ( *str++ & 0x3f );
    *out_char = c;
    return 3;
  }
  if( ( *str & 0xf8 ) == 0xf0 )
  {
    *out_char = IM_UNICODE_CODEPOINT_INVALID; // will be invalid but not end of string
    if( in_text_end && in_text_end - ( const char* )str < 4 ) return 1;
    if( *str > 0xf4 ) return 4;
    if( *str == 0xf0 && ( str[ 1 ] < 0x90 || str[ 1 ] > 0xbf ) ) return 4;
    if( *str == 0xf4 && str[ 1 ] > 0x8f ) return 4; // str[1] < 0x80 is checked below
    c = ( unsigned int )( ( *str++ & 0x07 ) << 18 );
    if( ( *str & 0xc0 ) != 0x80 ) return 4;
    c += ( unsigned int )( ( *str++ & 0x3f ) << 12 );
    if( ( *str & 0xc0 ) != 0x80 ) return 4;
    c += ( unsigned int )( ( *str++ & 0x3f ) << 6 );
    if( ( *str & 0xc0 ) != 0x80 ) return 4;
    c += ( *str++ & 0x3f );
    // utf-8 encodings of values used in surrogate pairs are invalid
    if( ( c & 0xFFFFF800 ) == 0xD800 ) return 4;
    // If codepoint does not fit in ImWchar, use replacement character U+FFFD instead
    if( c > IM_UNICODE_CODEPOINT_MAX ) c = IM_UNICODE_CODEPOINT_INVALID;
    *out_char = c;
    return 4;
  }
  *out_char = 0;
  return 0;
}

int ImTextStrFromUtf8( ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining )
{
  ImWchar* buf_out = buf;
  ImWchar* buf_end = buf + buf_size;
  while( buf_out < buf_end - 1 && ( !in_text_end || in_text < in_text_end ) && *in_text )
  {
    unsigned int c;
    in_text += ImTextCharFromUtf8( &c, in_text, in_text_end );
    if( c == 0 )
      break;
    *buf_out++ = ( ImWchar )c;
  }
  *buf_out = 0;
  if( in_text_remaining )
    *in_text_remaining = in_text;
  return ( int )( buf_out - buf );
}

int ImTextCountCharsFromUtf8( const char* in_text, const char* in_text_end )
{
  int char_count = 0;
  while( ( !in_text_end || in_text < in_text_end ) && *in_text )
  {
    unsigned int c;
    in_text += ImTextCharFromUtf8( &c, in_text, in_text_end );
    if( c == 0 )
      break;
    char_count++;
  }
  return char_count;
}

// Based on stb_to_utf8() from github.com/nothings/stb/
static inline int ImTextCharToUtf8( char* buf, int buf_size, unsigned int c )
{
  if( c < 0x80 )
  {
    buf[ 0 ] = ( char )c;
    return 1;
  }
  if( c < 0x800 )
  {
    if( buf_size < 2 ) return 0;
    buf[ 0 ] = ( char )( 0xc0 + ( c >> 6 ) );
    buf[ 1 ] = ( char )( 0x80 + ( c & 0x3f ) );
    return 2;
  }
  if( c < 0x10000 )
  {
    if( buf_size < 3 ) return 0;
    buf[ 0 ] = ( char )( 0xe0 + ( c >> 12 ) );
    buf[ 1 ] = ( char )( 0x80 + ( ( c >> 6 ) & 0x3f ) );
    buf[ 2 ] = ( char )( 0x80 + ( ( c ) & 0x3f ) );
    return 3;
  }
  if( c <= 0x10FFFF )
  {
    if( buf_size < 4 ) return 0;
    buf[ 0 ] = ( char )( 0xf0 + ( c >> 18 ) );
    buf[ 1 ] = ( char )( 0x80 + ( ( c >> 12 ) & 0x3f ) );
    buf[ 2 ] = ( char )( 0x80 + ( ( c >> 6 ) & 0x3f ) );
    buf[ 3 ] = ( char )( 0x80 + ( ( c ) & 0x3f ) );
    return 4;
  }
  // Invalid code point, the max unicode is 0x10FFFF
  return 0;
}

// Not optimal but we very rarely use this function.
int ImTextCountUtf8BytesFromChar( const char* in_text, const char* in_text_end )
{
  unsigned int dummy = 0;
  return ImTextCharFromUtf8( &dummy, in_text, in_text_end );
}

static inline int ImTextCountUtf8BytesFromChar( unsigned int c )
{
  if( c < 0x80 ) return 1;
  if( c < 0x800 ) return 2;
  if( c < 0x10000 ) return 3;
  if( c <= 0x10FFFF ) return 4;
  return 3;
}

int ImTextStrToUtf8( char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end )
{
  char* buf_out = buf;
  const char* buf_end = buf + buf_size;
  while( buf_out < buf_end - 1 && ( !in_text_end || in_text < in_text_end ) && *in_text )
  {
    unsigned int c = ( unsigned int )( *in_text++ );
    if( c < 0x80 )
      *buf_out++ = ( char )c;
    else
      buf_out += ImTextCharToUtf8( buf_out, ( int )( buf_end - buf_out - 1 ), c );
  }
  *buf_out = 0;
  return ( int )( buf_out - buf );
}

int ImTextCountUtf8BytesFromStr( const ImWchar* in_text, const ImWchar* in_text_end )
{
  int bytes_count = 0;
  while( ( !in_text_end || in_text < in_text_end ) && *in_text )
  {
    unsigned int c = ( unsigned int )( *in_text++ );
    if( c < 0x80 )
      bytes_count++;
    else
      bytes_count += ImTextCountUtf8BytesFromChar( c );
  }
  return bytes_count;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (Color functions)
// Note: The Convert functions are early design which are not consistent with other API.
//-----------------------------------------------------------------------------

IMGUI_API ImU32 ImAlphaBlendColors( ImU32 col_a, ImU32 col_b )
{
  float t = ( ( col_b >> IM_COL32_A_SHIFT ) & 0xFF ) / 255.f;
  int r = ImLerp( ( int )( col_a >> IM_COL32_R_SHIFT ) & 0xFF, ( int )( col_b >> IM_COL32_R_SHIFT ) & 0xFF, t );
  int g = ImLerp( ( int )( col_a >> IM_COL32_G_SHIFT ) & 0xFF, ( int )( col_b >> IM_COL32_G_SHIFT ) & 0xFF, t );
  int b = ImLerp( ( int )( col_a >> IM_COL32_B_SHIFT ) & 0xFF, ( int )( col_b >> IM_COL32_B_SHIFT ) & 0xFF, t );
  return IM_COL32( r, g, b, 0xFF );
}

ImVec4 ImGui::ColorConvertU32ToFloat4( ImU32 in )
{
  float s = 1.0f / 255.0f;
  return ImVec4(
    ( ( in >> IM_COL32_R_SHIFT ) & 0xFF ) * s,
    ( ( in >> IM_COL32_G_SHIFT ) & 0xFF ) * s,
    ( ( in >> IM_COL32_B_SHIFT ) & 0xFF ) * s,
    ( ( in >> IM_COL32_A_SHIFT ) & 0xFF ) * s );
}

ImU32 ImGui::ColorConvertFloat4ToU32( const ImVec4& in )
{
  ImU32 out;
  out = ( ( ImU32 )IM_F32_TO_INT8_SAT( in.x ) ) << IM_COL32_R_SHIFT;
  out |= ( ( ImU32 )IM_F32_TO_INT8_SAT( in.y ) ) << IM_COL32_G_SHIFT;
  out |= ( ( ImU32 )IM_F32_TO_INT8_SAT( in.z ) ) << IM_COL32_B_SHIFT;
  out |= ( ( ImU32 )IM_F32_TO_INT8_SAT( in.w ) ) << IM_COL32_A_SHIFT;
  return out;
}

// Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p592
// Optimized http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
void ImGui::ColorConvertRGBtoHSV( float r, float g, float b, float& out_h, float& out_s, float& out_v )
{
  float K = 0.f;
  if( g < b )
  {
    ImSwap( g, b );
    K = -1.f;
  }
  if( r < g )
  {
    ImSwap( r, g );
    K = -2.f / 6.f - K;
  }

  const float chroma = r - ( g < b ? g : b );
  out_h = ImFabs( K + ( g - b ) / ( 6.f * chroma + 1e-20f ) );
  out_s = chroma / ( r + 1e-20f );
  out_v = r;
}

// Convert hsv floats ([0-1],[0-1],[0-1]) to rgb floats ([0-1],[0-1],[0-1]), from Foley & van Dam p593
// also http://en.wikipedia.org/wiki/HSL_and_HSV
void ImGui::ColorConvertHSVtoRGB( float h, float s, float v, float& out_r, float& out_g, float& out_b )
{
  if( s == 0.0f )
  {
    // gray
    out_r = out_g = out_b = v;
    return;
  }

  h = ImFmod( h, 1.0f ) / ( 60.0f / 360.0f );
  int   i = ( int )h;
  float f = h - ( float )i;
  float p = v * ( 1.0f - s );
  float q = v * ( 1.0f - s * f );
  float t = v * ( 1.0f - s * ( 1.0f - f ) );

  switch( i )
  {
    case 0: out_r = v; out_g = t; out_b = p; break;
    case 1: out_r = q; out_g = v; out_b = p; break;
    case 2: out_r = p; out_g = v; out_b = t; break;
    case 3: out_r = p; out_g = q; out_b = v; break;
    case 4: out_r = t; out_g = p; out_b = v; break;
    case 5: default: out_r = v; out_g = p; out_b = q; break;
  }
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiStorage
// Helper: Key->value storage
//-----------------------------------------------------------------------------

// std::lower_bound but without the bullshit
static ImGuiStorage::ImGuiStoragePair* LowerBound( ImVector<ImGuiStorage::ImGuiStoragePair>& data, ImGuiID key )
{
  ImGuiStorage::ImGuiStoragePair* first = data.Data;
  ImGuiStorage::ImGuiStoragePair* last = data.Data + data.Size;
  size_t count = ( size_t )( last - first );
  while( count > 0 )
  {
    size_t count2 = count >> 1;
    ImGuiStorage::ImGuiStoragePair* mid = first + count2;
    if( mid->key < key )
    {
      first = ++mid;
      count -= count2 + 1;
    }
    else
    {
      count = count2;
    }
  }
  return first;
}

// For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
void ImGuiStorage::BuildSortByKey()
{
  struct StaticFunc
  {
    static int IMGUI_CDECL PairCompareByID( const void* lhs, const void* rhs )
    {
      // We can't just do a subtraction because qsort uses signed integers and subtracting our ID doesn't play well with that.
      if( ( ( const ImGuiStoragePair* )lhs )->key > ( ( const ImGuiStoragePair* )rhs )->key ) return +1;
      if( ( ( const ImGuiStoragePair* )lhs )->key < ( ( const ImGuiStoragePair* )rhs )->key ) return -1;
      return 0;
    }
  };
  if( Data.Size > 1 )
    ImQsort( Data.Data, ( size_t )Data.Size, sizeof( ImGuiStoragePair ), StaticFunc::PairCompareByID );
}

int ImGuiStorage::GetInt( ImGuiID key, int default_val ) const
{
  ImGuiStoragePair* it = LowerBound( const_cast< ImVector<ImGuiStoragePair>& >( Data ), key );
  if( it == Data.end() || it->key != key )
    return default_val;
  return it->val_i;
}

bool ImGuiStorage::GetBool( ImGuiID key, bool default_val ) const
{
  return GetInt( key, default_val ? 1 : 0 ) != 0;
}

float ImGuiStorage::GetFloat( ImGuiID key, float default_val ) const
{
  ImGuiStoragePair* it = LowerBound( const_cast< ImVector<ImGuiStoragePair>& >( Data ), key );
  if( it == Data.end() || it->key != key )
    return default_val;
  return it->val_f;
}

void* ImGuiStorage::GetVoidPtr( ImGuiID key ) const
{
  ImGuiStoragePair* it = LowerBound( const_cast< ImVector<ImGuiStoragePair>& >( Data ), key );
  if( it == Data.end() || it->key != key )
    return NULL;
  return it->val_p;
}

// References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
int* ImGuiStorage::GetIntRef( ImGuiID key, int default_val )
{
  ImGuiStoragePair* it = LowerBound( Data, key );
  if( it == Data.end() || it->key != key )
    it = Data.insert( it, ImGuiStoragePair( key, default_val ) );
  return &it->val_i;
}

bool* ImGuiStorage::GetBoolRef( ImGuiID key, bool default_val )
{
  return ( bool* )GetIntRef( key, default_val ? 1 : 0 );
}

float* ImGuiStorage::GetFloatRef( ImGuiID key, float default_val )
{
  ImGuiStoragePair* it = LowerBound( Data, key );
  if( it == Data.end() || it->key != key )
    it = Data.insert( it, ImGuiStoragePair( key, default_val ) );
  return &it->val_f;
}

void** ImGuiStorage::GetVoidPtrRef( ImGuiID key, void* default_val )
{
  ImGuiStoragePair* it = LowerBound( Data, key );
  if( it == Data.end() || it->key != key )
    it = Data.insert( it, ImGuiStoragePair( key, default_val ) );
  return &it->val_p;
}

// FIXME-OPT: Need a way to reuse the result of lower_bound when doing GetInt()/SetInt() - not too bad because it only happens on explicit interaction (maximum one a frame)
void ImGuiStorage::SetInt( ImGuiID key, int val )
{
  ImGuiStoragePair* it = LowerBound( Data, key );
  if( it == Data.end() || it->key != key )
  {
    Data.insert( it, ImGuiStoragePair( key, val ) );
    return;
  }
  it->val_i = val;
}

void ImGuiStorage::SetBool( ImGuiID key, bool val )
{
  SetInt( key, val ? 1 : 0 );
}

void ImGuiStorage::SetFloat( ImGuiID key, float val )
{
  ImGuiStoragePair* it = LowerBound( Data, key );
  if( it == Data.end() || it->key != key )
  {
    Data.insert( it, ImGuiStoragePair( key, val ) );
    return;
  }
  it->val_f = val;
}

void ImGuiStorage::SetVoidPtr( ImGuiID key, void* val )
{
  ImGuiStoragePair* it = LowerBound( Data, key );
  if( it == Data.end() || it->key != key )
  {
    Data.insert( it, ImGuiStoragePair( key, val ) );
    return;
  }
  it->val_p = val;
}

void ImGuiStorage::SetAllInt( int v )
{
  for( int i = 0; i < Data.Size; i++ )
    Data[ i ].val_i = v;
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiTextFilter
//-----------------------------------------------------------------------------

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
ImGuiTextFilter::ImGuiTextFilter( const char* default_filter )
{
  if( default_filter )
  {
    ImStrncpy( InputBuf, default_filter, IM_ARRAYSIZE( InputBuf ) );
    Build();
  }
  else
  {
    InputBuf[ 0 ] = 0;
    CountGrep = 0;
  }
}

bool ImGuiTextFilter::Draw( const char* label, float width )
{
  if( width != 0.0f )
    ImGui::SetNextItemWidth( width );
  bool value_changed = ImGui::InputText( label, InputBuf, IM_ARRAYSIZE( InputBuf ) );
  if( value_changed )
    Build();
  return value_changed;
}

void ImGuiTextFilter::ImGuiTextRange::split( char separator, ImVector<ImGuiTextRange>* out ) const
{
  out->resize( 0 );
  const char* wb = b;
  const char* we = wb;
  while( we < e )
  {
    if( *we == separator )
    {
      out->push_back( ImGuiTextRange( wb, we ) );
      wb = we + 1;
    }
    we++;
  }
  if( wb != we )
    out->push_back( ImGuiTextRange( wb, we ) );
}

void ImGuiTextFilter::Build()
{
  Filters.resize( 0 );
  ImGuiTextRange input_range( InputBuf, InputBuf + strlen( InputBuf ) );
  input_range.split( ',', &Filters );

  CountGrep = 0;
  for( int i = 0; i != Filters.Size; i++ )
  {
    ImGuiTextRange& f = Filters[ i ];
    while( f.b < f.e && ImCharIsBlankA( f.b[ 0 ] ) )
      f.b++;
    while( f.e > f.b && ImCharIsBlankA( f.e[ -1 ] ) )
      f.e--;
    if( f.empty() )
      continue;
    if( Filters[ i ].b[ 0 ] != '-' )
      CountGrep += 1;
  }
}

bool ImGuiTextFilter::PassFilter( const char* text, const char* text_end ) const
{
  if( Filters.empty() )
    return true;

  if( text == NULL )
    text = "";

  for( int i = 0; i != Filters.Size; i++ )
  {
    const ImGuiTextRange& f = Filters[ i ];
    if( f.empty() )
      continue;
    if( f.b[ 0 ] == '-' )
    {
      // Subtract
      if( ImStristr( text, text_end, f.b + 1, f.e ) != NULL )
        return false;
    }
    else
    {
      // Grep
      if( ImStristr( text, text_end, f.b, f.e ) != NULL )
        return true;
    }
  }

  // Implicit * grep
  if( CountGrep == 0 )
    return true;

  return false;
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiTextBuffer
//-----------------------------------------------------------------------------

// On some platform vsnprintf() takes va_list by reference and modifies it.
// va_copy is the 'correct' way to copy a va_list but Visual Studio prior to 2013 doesn't have it.
#ifndef va_copy
#if defined(__GNUC__) || defined(__clang__)
#define va_copy(dest, src) __builtin_va_copy(dest, src)
#else
#define va_copy(dest, src) (dest = src)
#endif
#endif

char ImGuiTextBuffer::EmptyString[ 1 ] = { 0 };

void ImGuiTextBuffer::append( const char* str, const char* str_end )
{
  int len = str_end ? ( int )( str_end - str ) : ( int )strlen( str );

  // Add zero-terminator the first time
  const int write_off = ( Buf.Size != 0 ) ? Buf.Size : 1;
  const int needed_sz = write_off + len;
  if( write_off + len >= Buf.Capacity )
  {
    int new_capacity = Buf.Capacity * 2;
    Buf.reserve( needed_sz > new_capacity ? needed_sz : new_capacity );
  }

  Buf.resize( needed_sz );
  memcpy( &Buf[ write_off - 1 ], str, ( size_t )len );
  Buf[ write_off - 1 + len ] = 0;
}

void ImGuiTextBuffer::appendf( const char* fmt, ... )
{
  va_list args;
  va_start( args, fmt );
  appendfv( fmt, args );
  va_end( args );
}

// Helper: Text buffer for logging/accumulating text
void ImGuiTextBuffer::appendfv( const char* fmt, va_list args )
{
  va_list args_copy;
  va_copy( args_copy, args );

  int len = ImFormatStringV( NULL, 0, fmt, args );         // FIXME-OPT: could do a first pass write attempt, likely successful on first pass.
  if( len <= 0 )
  {
    va_end( args_copy );
    return;
  }

  // Add zero-terminator the first time
  const int write_off = ( Buf.Size != 0 ) ? Buf.Size : 1;
  const int needed_sz = write_off + len;
  if( write_off + len >= Buf.Capacity )
  {
    int new_capacity = Buf.Capacity * 2;
    Buf.reserve( needed_sz > new_capacity ? needed_sz : new_capacity );
  }

  Buf.resize( needed_sz );
  ImFormatStringV( &Buf[ write_off - 1 ], ( size_t )len + 1, fmt, args_copy );
  va_end( args_copy );
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiListClipper
// This is currently not as flexible/powerful as it should be and really confusing/spaghetti, mostly because we changed
// the API mid-way through development and support two ways to using the clipper, needs some rework (see TODO)
//-----------------------------------------------------------------------------

// Helper to calculate coarse clipping of large list of evenly sized items.
// NB: Prefer using the ImGuiListClipper higher-level helper if you can! Read comments and instructions there on how those use this sort of pattern.
// NB: 'items_count' is only used to clamp the result, if you don't know your count you can use INT_MAX
void ImGui::CalcListClipping( int items_count, float items_height, int* out_items_display_start, int* out_items_display_end )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  if( g.LogEnabled )
  {
    // If logging is active, do not perform any clipping
    *out_items_display_start = 0;
    *out_items_display_end = items_count;
    return;
  }
  if( window->SkipItems )
  {
    *out_items_display_start = *out_items_display_end = 0;
    return;
  }

  // We create the union of the ClipRect and the NavScoringRect which at worst should be 1 page away from ClipRect
  ImRect unclipped_rect = window->ClipRect;
  if( g.NavMoveRequest )
    unclipped_rect.Add( g.NavScoringRect );
  if( g.NavJustMovedToId && window->NavLastIds[ 0 ] == g.NavJustMovedToId )
    unclipped_rect.Add( ImRect( window->Pos + window->NavRectRel[ 0 ].Min, window->Pos + window->NavRectRel[ 0 ].Max ) );

  const ImVec2 pos = window->DC.CursorPos;
  int start = ( int )( ( unclipped_rect.Min.y - pos.y ) / items_height );
  int end = ( int )( ( unclipped_rect.Max.y - pos.y ) / items_height );

  // When performing a navigation request, ensure we have one item extra in the direction we are moving to
  if( g.NavMoveRequest && g.NavMoveClipDir == ImGuiDir_Up )
    start--;
  if( g.NavMoveRequest && g.NavMoveClipDir == ImGuiDir_Down )
    end++;

  start = ImClamp( start, 0, items_count );
  end = ImClamp( end + 1, start, items_count );
  *out_items_display_start = start;
  *out_items_display_end = end;
}

static void SetCursorPosYAndSetupDummyPrevLine( float pos_y, float line_height )
{
  // Set cursor position and a few other things so that SetScrollHereY() and Columns() can work when seeking cursor.
  // FIXME: It is problematic that we have to do that here, because custom/equivalent end-user code would stumble on the same issue.
  // The clipper should probably have a 4th step to display the last item in a regular manner.
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  window->DC.CursorPos.y = pos_y;
  window->DC.CursorMaxPos.y = ImMax( window->DC.CursorMaxPos.y, pos_y );
  window->DC.CursorPosPrevLine.y = window->DC.CursorPos.y - line_height;  // Setting those fields so that SetScrollHereY() can properly function after the end of our clipper usage.
  window->DC.PrevLineSize.y = ( line_height - g.Style.ItemSpacing.y );      // If we end up needing more accurate data (to e.g. use SameLine) we may as well make the clipper have a fourth step to let user process and display the last item in their list.
  if( ImGuiColumns* columns = window->DC.CurrentColumns )
    columns->LineMinY = window->DC.CursorPos.y;                         // Setting this so that cell Y position are set properly
}

// Use case A: Begin() called from constructor with items_height<0, then called again from Sync() in StepNo 1
// Use case B: Begin() called from constructor with items_height>0
// FIXME-LEGACY: Ideally we should remove the Begin/End functions but they are part of the legacy API we still support. This is why some of the code in Step() calling Begin() and reassign some fields, spaghetti style.
void ImGuiListClipper::Begin( int count, float items_height )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;

  StartPosY = window->DC.CursorPos.y;
  ItemsHeight = items_height;
  ItemsCount = count;
  StepNo = 0;
  DisplayEnd = DisplayStart = -1;
  if( ItemsHeight > 0.0f )
  {
    ImGui::CalcListClipping( ItemsCount, ItemsHeight, &DisplayStart, &DisplayEnd ); // calculate how many to clip/display
    if( DisplayStart > 0 )
      SetCursorPosYAndSetupDummyPrevLine( StartPosY + DisplayStart * ItemsHeight, ItemsHeight ); // advance cursor
    StepNo = 2;
  }
}

void ImGuiListClipper::End()
{
  if( ItemsCount < 0 )
    return;
  // In theory here we should assert that ImGui::GetCursorPosY() == StartPosY + DisplayEnd * ItemsHeight, but it feels saner to just seek at the end and not assert/crash the user.
  if( ItemsCount < INT_MAX )
    SetCursorPosYAndSetupDummyPrevLine( StartPosY + ItemsCount * ItemsHeight, ItemsHeight ); // advance cursor
  ItemsCount = -1;
  StepNo = 3;
}

bool ImGuiListClipper::Step()
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;

  if( ItemsCount == 0 || window->SkipItems )
  {
    ItemsCount = -1;
    return false;
  }
  if( StepNo == 0 ) // Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height.
  {
    DisplayStart = 0;
    DisplayEnd = 1;
    StartPosY = window->DC.CursorPos.y;
    StepNo = 1;
    return true;
  }
  if( StepNo == 1 ) // Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.
  {
    if( ItemsCount == 1 )
    {
      ItemsCount = -1; return false;
    }
    float items_height = window->DC.CursorPos.y - StartPosY;
    IM_ASSERT( items_height > 0.0f );   // If this triggers, it means Item 0 hasn't moved the cursor vertically
    Begin( ItemsCount - 1, items_height );
    DisplayStart++;
    DisplayEnd++;
    StepNo = 3;
    return true;
  }
  if( StepNo == 2 ) // Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user still call Step(). Does nothing and switch to Step 3.
  {
    IM_ASSERT( DisplayStart >= 0 && DisplayEnd >= 0 );
    StepNo = 3;
    return true;
  }
  if( StepNo == 3 ) // Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.
    End();
  return false;
}

//-----------------------------------------------------------------------------
// [SECTION] STYLING
//-----------------------------------------------------------------------------

ImGuiStyle& ImGui::GetStyle()
{
  IM_ASSERT( GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?" );
  return GImGui->Style;
}

ImU32 ImGui::GetColorU32( ImGuiCol idx, float alpha_mul )
{
  ImGuiStyle& style = GImGui->Style;
  ImVec4 c = style.Colors[ idx ];
  c.w *= style.Alpha * alpha_mul;
  return ColorConvertFloat4ToU32( c );
}

ImU32 ImGui::GetColorU32( const ImVec4& col )
{
  ImGuiStyle& style = GImGui->Style;
  ImVec4 c = col;
  c.w *= style.Alpha;
  return ColorConvertFloat4ToU32( c );
}

const ImVec4& ImGui::GetStyleColorVec4( ImGuiCol idx )
{
  ImGuiStyle& style = GImGui->Style;
  return style.Colors[ idx ];
}

ImU32 ImGui::GetColorU32( ImU32 col )
{
  ImGuiStyle& style = GImGui->Style;
  if( style.Alpha >= 1.0f )
    return col;
  ImU32 a = ( col & IM_COL32_A_MASK ) >> IM_COL32_A_SHIFT;
  a = ( ImU32 )( a * style.Alpha ); // We don't need to clamp 0..255 because Style.Alpha is in 0..1 range.
  return ( col & ~IM_COL32_A_MASK ) | ( a << IM_COL32_A_SHIFT );
}

// FIXME: This may incur a round-trip (if the end user got their data from a float4) but eventually we aim to store the in-flight colors as ImU32
void ImGui::PushStyleColor( ImGuiCol idx, ImU32 col )
{
  ImGuiContext& g = *GImGui;
  ImGuiColorMod backup;
  backup.Col = idx;
  backup.BackupValue = g.Style.Colors[ idx ];
  g.ColorModifiers.push_back( backup );
  g.Style.Colors[ idx ] = ColorConvertU32ToFloat4( col );
}

void ImGui::PushStyleColor( ImGuiCol idx, const ImVec4& col )
{
  ImGuiContext& g = *GImGui;
  ImGuiColorMod backup;
  backup.Col = idx;
  backup.BackupValue = g.Style.Colors[ idx ];
  g.ColorModifiers.push_back( backup );
  g.Style.Colors[ idx ] = col;
}

void ImGui::PopStyleColor( int count )
{
  ImGuiContext& g = *GImGui;
  while( count > 0 )
  {
    ImGuiColorMod& backup = g.ColorModifiers.back();
    g.Style.Colors[ backup.Col ] = backup.BackupValue;
    g.ColorModifiers.pop_back();
    count--;
  }
}

struct ImGuiStyleVarInfo
{
  ImGuiDataType   Type;
  ImU32           Count;
  ImU32           Offset;
  void* GetVarPtr( ImGuiStyle* style ) const
  {
    return ( void* )( ( unsigned char* )style + Offset );
  }
};

static const ImGuiStyleVarInfo GStyleVarInfo[] =
{
    { ImGuiDataType_Float, 1, ( ImU32 )IM_OFFSETOF( ImGuiStyle, Alpha ) },               // ImGuiStyleVar_Alpha
    { ImGuiDataType_Float, 2, ( ImU32 )IM_OFFSETOF( ImGuiStyle, WindowPadding ) },       // ImGuiStyleVar_WindowPadding
    { ImGuiDataType_Float, 1, ( ImU32 )IM_OFFSETOF( ImGuiStyle, WindowRounding ) },      // ImGuiStyleVar_WindowRounding
    { ImGuiDataType_Float, 1, ( ImU32 )IM_OFFSETOF( ImGuiStyle, WindowBorderSize ) },    // ImGuiStyleVar_WindowBorderSize
    { ImGuiDataType_Float, 2, ( ImU32 )IM_OFFSETOF( ImGuiStyle, WindowMinSize ) },       // ImGuiStyleVar_WindowMinSize
    { ImGuiDataType_Float, 2, ( ImU32 )IM_OFFSETOF( ImGuiStyle, WindowTitleAlign ) },    // ImGuiStyleVar_WindowTitleAlign
    { ImGuiDataType_Float, 1, ( ImU32 )IM_OFFSETOF( ImGuiStyle, ChildRounding ) },       // ImGuiStyleVar_ChildRounding
    { ImGuiDataType_Float, 1, ( ImU32 )IM_OFFSETOF( ImGuiStyle, ChildBorderSize ) },     // ImGuiStyleVar_ChildBorderSize
    { ImGuiDataType_Float, 1, ( ImU32 )IM_OFFSETOF( ImGuiStyle, PopupRounding ) },       // ImGuiStyleVar_PopupRounding
    { ImGuiDataType_Float, 1, ( ImU32 )IM_OFFSETOF( ImGuiStyle, PopupBorderSize ) },     // ImGuiStyleVar_PopupBorderSize
    { ImGuiDataType_Float, 2, ( ImU32 )IM_OFFSETOF( ImGuiStyle, FramePadding ) },        // ImGuiStyleVar_FramePadding
    { ImGuiDataType_Float, 1, ( ImU32 )IM_OFFSETOF( ImGuiStyle, FrameRounding ) },       // ImGuiStyleVar_FrameRounding
    { ImGuiDataType_Float, 1, ( ImU32 )IM_OFFSETOF( ImGuiStyle, FrameBorderSize ) },     // ImGuiStyleVar_FrameBorderSize
    { ImGuiDataType_Float, 2, ( ImU32 )IM_OFFSETOF( ImGuiStyle, ItemSpacing ) },         // ImGuiStyleVar_ItemSpacing
    { ImGuiDataType_Float, 2, ( ImU32 )IM_OFFSETOF( ImGuiStyle, ItemInnerSpacing ) },    // ImGuiStyleVar_ItemInnerSpacing
    { ImGuiDataType_Float, 1, ( ImU32 )IM_OFFSETOF( ImGuiStyle, IndentSpacing ) },       // ImGuiStyleVar_IndentSpacing
    { ImGuiDataType_Float, 1, ( ImU32 )IM_OFFSETOF( ImGuiStyle, ScrollbarSize ) },       // ImGuiStyleVar_ScrollbarSize
    { ImGuiDataType_Float, 1, ( ImU32 )IM_OFFSETOF( ImGuiStyle, ScrollbarRounding ) },   // ImGuiStyleVar_ScrollbarRounding
    { ImGuiDataType_Float, 1, ( ImU32 )IM_OFFSETOF( ImGuiStyle, GrabMinSize ) },         // ImGuiStyleVar_GrabMinSize
    { ImGuiDataType_Float, 1, ( ImU32 )IM_OFFSETOF( ImGuiStyle, GrabRounding ) },        // ImGuiStyleVar_GrabRounding
    { ImGuiDataType_Float, 1, ( ImU32 )IM_OFFSETOF( ImGuiStyle, TabRounding ) },         // ImGuiStyleVar_TabRounding
    { ImGuiDataType_Float, 2, ( ImU32 )IM_OFFSETOF( ImGuiStyle, ButtonTextAlign ) },     // ImGuiStyleVar_ButtonTextAlign
    { ImGuiDataType_Float, 2, ( ImU32 )IM_OFFSETOF( ImGuiStyle, SelectableTextAlign ) }, // ImGuiStyleVar_SelectableTextAlign
};

static const ImGuiStyleVarInfo* GetStyleVarInfo( ImGuiStyleVar idx )
{
  IM_ASSERT( idx >= 0 && idx < ImGuiStyleVar_COUNT );
  IM_ASSERT( IM_ARRAYSIZE( GStyleVarInfo ) == ImGuiStyleVar_COUNT );
  return &GStyleVarInfo[ idx ];
}

void ImGui::PushStyleVar( ImGuiStyleVar idx, float val )
{
  const ImGuiStyleVarInfo* var_info = GetStyleVarInfo( idx );
  if( var_info->Type == ImGuiDataType_Float && var_info->Count == 1 )
  {
    ImGuiContext& g = *GImGui;
    float* pvar = ( float* )var_info->GetVarPtr( &g.Style );
    g.StyleModifiers.push_back( ImGuiStyleMod( idx, *pvar ) );
    *pvar = val;
    return;
  }
  IM_ASSERT( 0 && "Called PushStyleVar() float variant but variable is not a float!" );
}

void ImGui::PushStyleVar( ImGuiStyleVar idx, const ImVec2& val )
{
  const ImGuiStyleVarInfo* var_info = GetStyleVarInfo( idx );
  if( var_info->Type == ImGuiDataType_Float && var_info->Count == 2 )
  {
    ImGuiContext& g = *GImGui;
    ImVec2* pvar = ( ImVec2* )var_info->GetVarPtr( &g.Style );
    g.StyleModifiers.push_back( ImGuiStyleMod( idx, *pvar ) );
    *pvar = val;
    return;
  }
  IM_ASSERT( 0 && "Called PushStyleVar() ImVec2 variant but variable is not a ImVec2!" );
}

void ImGui::PopStyleVar( int count )
{
  ImGuiContext& g = *GImGui;
  while( count > 0 )
  {
    // We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.
    ImGuiStyleMod& backup = g.StyleModifiers.back();
    const ImGuiStyleVarInfo* info = GetStyleVarInfo( backup.VarIdx );
    void* data = info->GetVarPtr( &g.Style );
    if( info->Type == ImGuiDataType_Float && info->Count == 1 )
    {
      ( ( float* )data )[ 0 ] = backup.BackupFloat[ 0 ];
    }
    else if( info->Type == ImGuiDataType_Float && info->Count == 2 )
    {
      ( ( float* )data )[ 0 ] = backup.BackupFloat[ 0 ]; ( ( float* )data )[ 1 ] = backup.BackupFloat[ 1 ];
    }
    g.StyleModifiers.pop_back();
    count--;
  }
}

const char* ImGui::GetStyleColorName( ImGuiCol idx )
{
  // Create switch-case from enum with regexp: ImGuiCol_{.*}, --> case ImGuiCol_\1: return "\1";
  switch( idx )
  {
    case ImGuiCol_Text: return SECURE( "Text" );
    case ImGuiCol_TextDisabled: return SECURE( "TextDisabled" );
    case ImGuiCol_WindowBg: return SECURE( "WindowBg" );
    case ImGuiCol_ChildBg: return SECURE( "ChildBg" );
    case ImGuiCol_PopupBg: return SECURE( "PopupBg" );
    case ImGuiCol_Border: return SECURE( "Border" );
    case ImGuiCol_BorderShadow: return SECURE( "BorderShadow" );
    case ImGuiCol_FrameBg: return SECURE( "FrameBg" );
    case ImGuiCol_FrameBgHovered: return SECURE( "FrameBgHovered" );
    case ImGuiCol_FrameBgActive: return SECURE( "FrameBgActive" );
    case ImGuiCol_TitleBg: return SECURE( "TitleBg" );
    case ImGuiCol_TitleBgActive: return SECURE( "TitleBgActive" );
    case ImGuiCol_TitleBgCollapsed: return SECURE( "TitleBgCollapsed" );
    case ImGuiCol_MenuBarBg: return SECURE( "MenuBarBg" );
    case ImGuiCol_ScrollbarBg: return SECURE( "ScrollbarBg" );
    case ImGuiCol_ScrollbarGrab: return SECURE( "ScrollbarGrab" );
    case ImGuiCol_ScrollbarGrabHovered: return SECURE( "ScrollbarGrabHovered" );
    case ImGuiCol_ScrollbarGrabActive: return SECURE( "ScrollbarGrabActive" );
    case ImGuiCol_CheckMark: return SECURE( "CheckMark" );
    case ImGuiCol_SliderGrab: return SECURE( "SliderGrab" );
    case ImGuiCol_SliderGrabActive: return SECURE( "SliderGrabActive" );
    case ImGuiCol_Button: return SECURE( "Button" );
    case ImGuiCol_ButtonHovered: return SECURE( "ButtonHovered" );
    case ImGuiCol_ButtonActive: return SECURE( "ButtonActive" );
    case ImGuiCol_Header: return SECURE( "Header" );
    case ImGuiCol_HeaderHovered: return SECURE( "HeaderHovered" );
    case ImGuiCol_HeaderActive: return SECURE( "HeaderActive" );
    case ImGuiCol_Separator: return SECURE( "Separator" );
    case ImGuiCol_SeparatorHovered: return SECURE( "SeparatorHovered" );
    case ImGuiCol_SeparatorActive: return SECURE( "SeparatorActive" );
    case ImGuiCol_ResizeGrip: return SECURE( "ResizeGrip" );
    case ImGuiCol_ResizeGripHovered: return SECURE( "ResizeGripHovered" );
    case ImGuiCol_ResizeGripActive: return SECURE( "ResizeGripActive" );
    case ImGuiCol_Tab: return SECURE( "Tab" );
    case ImGuiCol_TabHovered: return SECURE( "TabHovered" );
    case ImGuiCol_TabActive: return SECURE( "TabActive" );
    case ImGuiCol_TabUnfocused: return SECURE( "TabUnfocused" );
    case ImGuiCol_TabUnfocusedActive: return SECURE( "TabUnfocusedActive" );
    case ImGuiCol_PlotLines: return SECURE( "PlotLines" );
    case ImGuiCol_PlotLinesHovered: return SECURE( "PlotLinesHovered" );
    case ImGuiCol_PlotHistogram: return SECURE( "PlotHistogram" );
    case ImGuiCol_PlotHistogramHovered: return SECURE( "PlotHistogramHovered" );
    case ImGuiCol_TextSelectedBg: return SECURE( "TextSelectedBg" );
    case ImGuiCol_DragDropTarget: return SECURE( "DragDropTarget" );
    case ImGuiCol_NavHighlight: return SECURE( "NavHighlight" );
    case ImGuiCol_NavWindowingHighlight: return SECURE( "NavWindowingHighlight" );
    case ImGuiCol_NavWindowingDimBg: return SECURE( "NavWindowingDimBg" );
    case ImGuiCol_ModalWindowDimBg: return SECURE( "ModalWindowDimBg" );
  }
  IM_ASSERT( 0 );
  return SECURE( "Unknown" );
}

//-----------------------------------------------------------------------------
// [SECTION] RENDER HELPERS
// Some of those (internal) functions are currently quite a legacy mess - their signature and behavior will change,
// we need a nicer separation between low-level functions and high-level functions relying on the ImGui context.
// Also see imgui_draw.cpp for some more which have been reworked to not rely on ImGui:: context.
//-----------------------------------------------------------------------------

const char* ImGui::FindRenderedTextEnd( const char* text, const char* text_end )
{
  const char* text_display_end = text;
  if( !text_end )
    text_end = ( const char* )-1;

  while( text_display_end < text_end && *text_display_end != '\0' && ( text_display_end[ 0 ] != '#' || text_display_end[ 1 ] != '#' ) )
    text_display_end++;
  return text_display_end;
}

// Internal ImGui functions to render text
// RenderText***() functions calls ImDrawList::AddText() calls ImBitmapFont::RenderText()
void ImGui::RenderText( ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;

  // Hide anything after a '##' string
  const char* text_display_end;
  if( hide_text_after_hash )
  {
    text_display_end = FindRenderedTextEnd( text, text_end );
  }
  else
  {
    if( !text_end )
      text_end = text + strlen( text ); // FIXME-OPT
    text_display_end = text_end;
  }

  if( text != text_display_end )
  {
    window->DrawList->AddText( g.Font, g.FontSize, pos, GetColorU32( ImGuiCol_Text ), text, text_display_end );
    if( g.LogEnabled )
      LogRenderedText( &pos, text, text_display_end );
  }
}

void ImGui::RenderTextWrapped( ImVec2 pos, const char* text, const char* text_end, float wrap_width )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;

  if( !text_end )
    text_end = text + strlen( text ); // FIXME-OPT

  if( text != text_end )
  {
    window->DrawList->AddText( g.Font, g.FontSize, pos, GetColorU32( ImGuiCol_Text ), text, text_end, wrap_width );
    if( g.LogEnabled )
      LogRenderedText( &pos, text, text_end );
  }
}

// Default clip_rect uses (pos_min,pos_max)
// Handle clipping on CPU immediately (vs typically let the GPU clip the triangles that are overlapping the clipping rectangle edges)
void ImGui::RenderTextClippedEx( ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_display_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect )
{
  // Perform CPU side clipping for single clipped element to avoid using scissor state
  ImVec2 pos = pos_min;
  const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize( text, text_display_end, false, 0.0f );

  const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;
  const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;
  bool need_clipping = ( pos.x + text_size.x >= clip_max->x ) || ( pos.y + text_size.y >= clip_max->y );
  if( clip_rect ) // If we had no explicit clipping rectangle then pos==clip_min
    need_clipping |= ( pos.x < clip_min->x ) || ( pos.y < clip_min->y );

  // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
  if( align.x > 0.0f ) pos.x = ImMax( pos.x, pos.x + ( pos_max.x - pos.x - text_size.x ) * align.x );
  if( align.y > 0.0f ) pos.y = ImMax( pos.y, pos.y + ( pos_max.y - pos.y - text_size.y ) * align.y );

  // Render
  if( need_clipping )
  {
    ImVec4 fine_clip_rect( clip_min->x, clip_min->y, clip_max->x, clip_max->y );
    draw_list->AddText( NULL, 0.0f, pos, GetColorU32( ImGuiCol_Text ), text, text_display_end, 0.0f, &fine_clip_rect );
  }
  else
  {
    draw_list->AddText( NULL, 0.0f, pos, GetColorU32( ImGuiCol_Text ), text, text_display_end, 0.0f, NULL );
  }
}

void ImGui::RenderTextClipped( const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect )
{
  // Hide anything after a '##' string
  const char* text_display_end = FindRenderedTextEnd( text, text_end );
  const int text_len = ( int )( text_display_end - text );
  if( text_len == 0 )
    return;

  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  RenderTextClippedEx( window->DrawList, pos_min, pos_max, text, text_display_end, text_size_if_known, align, clip_rect );
  if( g.LogEnabled )
    LogRenderedText( &pos_min, text, text_display_end );
}


// Another overly complex function until we reorganize everything into a nice all-in-one helper.
// This is made more complex because we have dissociated the layout rectangle (pos_min..pos_max) which define _where_ the ellipsis is, from actual clipping of text and limit of the ellipsis display.
// This is because in the context of tabs we selectively hide part of the text when the Close Button appears, but we don't want the ellipsis to move.
void ImGui::RenderTextEllipsis( ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, float clip_max_x, float ellipsis_max_x, const char* text, const char* text_end_full, const ImVec2* text_size_if_known )
{
  ImGuiContext& g = *GImGui;
  if( text_end_full == NULL )
    text_end_full = FindRenderedTextEnd( text );
  const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize( text, text_end_full, false, 0.0f );

  //draw_list->AddLine(ImVec2(pos_max.x, pos_min.y - 4), ImVec2(pos_max.x, pos_max.y + 4), IM_COL32(0, 0, 255, 255));
  //draw_list->AddLine(ImVec2(ellipsis_max_x, pos_min.y-2), ImVec2(ellipsis_max_x, pos_max.y+2), IM_COL32(0, 255, 0, 255));
  //draw_list->AddLine(ImVec2(clip_max_x, pos_min.y), ImVec2(clip_max_x, pos_max.y), IM_COL32(255, 0, 0, 255));
  // FIXME: We could technically remove (last_glyph->AdvanceX - last_glyph->X1) from text_size.x here and save a few pixels.
  if( text_size.x > pos_max.x - pos_min.x )
  {
    // Hello wo...
    // |       |   |
    // min   max   ellipsis_max
    //          <-> this is generally some padding value

    const ImFont* font = draw_list->_Data->Font;
    const float font_size = draw_list->_Data->FontSize;
    const char* text_end_ellipsis = NULL;

    ImWchar ellipsis_char = font->EllipsisChar;
    int ellipsis_char_count = 1;
    if( ellipsis_char == ( ImWchar )-1 )
    {
      ellipsis_char = ( ImWchar )'.';
      ellipsis_char_count = 3;
    }
    const ImFontGlyph* glyph = font->FindGlyph( ellipsis_char );

    float ellipsis_glyph_width = glyph->X1;                 // Width of the glyph with no padding on either side
    float ellipsis_total_width = ellipsis_glyph_width;      // Full width of entire ellipsis

    if( ellipsis_char_count > 1 )
    {
      // Full ellipsis size without free spacing after it.
      const float spacing_between_dots = 1.0f * ( draw_list->_Data->FontSize / font->FontSize );
      ellipsis_glyph_width = glyph->X1 - glyph->X0 + spacing_between_dots;
      ellipsis_total_width = ellipsis_glyph_width * ( float )ellipsis_char_count - spacing_between_dots;
    }

    // We can now claim the space between pos_max.x and ellipsis_max.x
    const float text_avail_width = ImMax( ( ImMax( pos_max.x, ellipsis_max_x ) - ellipsis_total_width ) - pos_min.x, 1.0f );
    float text_size_clipped_x = font->CalcTextSizeA( font_size, text_avail_width, 0.0f, text, text_end_full, &text_end_ellipsis ).x;
    if( text == text_end_ellipsis && text_end_ellipsis < text_end_full )
    {
      // Always display at least 1 character if there's no room for character + ellipsis
      text_end_ellipsis = text + ImTextCountUtf8BytesFromChar( text, text_end_full );
      text_size_clipped_x = font->CalcTextSizeA( font_size, FLT_MAX, 0.0f, text, text_end_ellipsis ).x;
    }
    while( text_end_ellipsis > text && ImCharIsBlankA( text_end_ellipsis[ -1 ] ) )
    {
      // Trim trailing space before ellipsis (FIXME: Supporting non-ascii blanks would be nice, for this we need a function to backtrack in UTF-8 text)
      text_end_ellipsis--;
      text_size_clipped_x -= font->CalcTextSizeA( font_size, FLT_MAX, 0.0f, text_end_ellipsis, text_end_ellipsis + 1 ).x; // Ascii blanks are always 1 byte
    }

    // Render text, render ellipsis
    RenderTextClippedEx( draw_list, pos_min, ImVec2( clip_max_x, pos_max.y ), text, text_end_ellipsis, &text_size, ImVec2( 0.0f, 0.0f ) );
    float ellipsis_x = pos_min.x + text_size_clipped_x;
    if( ellipsis_x + ellipsis_total_width <= ellipsis_max_x )
      for( int i = 0; i < ellipsis_char_count; i++ )
      {
        font->RenderChar( draw_list, font_size, ImVec2( ellipsis_x, pos_min.y ), GetColorU32( ImGuiCol_Text ), ellipsis_char );
        ellipsis_x += ellipsis_glyph_width;
      }
  }
  else
  {
    RenderTextClippedEx( draw_list, pos_min, ImVec2( clip_max_x, pos_max.y ), text, text_end_full, &text_size, ImVec2( 0.0f, 0.0f ) );
  }

  if( g.LogEnabled )
    LogRenderedText( &pos_min, text, text_end_full );
}

// Render a rectangle shaped with optional rounding and borders
void ImGui::RenderFrame( ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  window->DrawList->AddRectFilled( p_min, p_max, fill_col, rounding );
  const float border_size = g.Style.FrameBorderSize;
  if( border && border_size > 0.0f )
  {
    window->DrawList->AddRect( p_min + ImVec2( 1, 1 ), p_max + ImVec2( 1, 1 ), GetColorU32( ImGuiCol_BorderShadow ), rounding, ImDrawCornerFlags_All, border_size );
    window->DrawList->AddRect( p_min, p_max, GetColorU32( ImGuiCol_Border ), rounding, ImDrawCornerFlags_All, border_size );
  }
}

void ImGui::RenderFrameBorder( ImVec2 p_min, ImVec2 p_max, float rounding )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  const float border_size = g.Style.FrameBorderSize;
  if( border_size > 0.0f )
  {
    window->DrawList->AddRect( p_min + ImVec2( 1, 1 ), p_max + ImVec2( 1, 1 ), GetColorU32( ImGuiCol_BorderShadow ), rounding, ImDrawCornerFlags_All, border_size );
    window->DrawList->AddRect( p_min, p_max, GetColorU32( ImGuiCol_Border ), rounding, ImDrawCornerFlags_All, border_size );
  }
}

void ImGui::RenderNavHighlight( const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags )
{
  ImGuiContext& g = *GImGui;
  if( id != g.NavId )
    return;
  if( g.NavDisableHighlight && !( flags & ImGuiNavHighlightFlags_AlwaysDraw ) )
    return;
  ImGuiWindow* window = g.CurrentWindow;
  if( window->DC.NavHideHighlightOneFrame )
    return;

  float rounding = ( flags & ImGuiNavHighlightFlags_NoRounding ) ? 0.0f : g.Style.FrameRounding;
  ImRect display_rect = bb;
  display_rect.ClipWith( window->ClipRect );
  if( flags & ImGuiNavHighlightFlags_TypeDefault )
  {
    const float THICKNESS = 2.0f;
    const float DISTANCE = 3.0f + THICKNESS * 0.5f;
    display_rect.Expand( ImVec2( DISTANCE, DISTANCE ) );
    bool fully_visible = window->ClipRect.Contains( display_rect );
    if( !fully_visible )
      window->DrawList->PushClipRect( display_rect.Min, display_rect.Max );
    window->DrawList->AddRect( display_rect.Min + ImVec2( THICKNESS * 0.5f, THICKNESS * 0.5f ), display_rect.Max - ImVec2( THICKNESS * 0.5f, THICKNESS * 0.5f ), GetColorU32( ImGuiCol_NavHighlight ), rounding, ImDrawCornerFlags_All, THICKNESS );
    if( !fully_visible )
      window->DrawList->PopClipRect();
  }
  if( flags & ImGuiNavHighlightFlags_TypeThin )
  {
    window->DrawList->AddRect( display_rect.Min, display_rect.Max, GetColorU32( ImGuiCol_NavHighlight ), rounding, ~0, 1.0f );
  }
}

//-----------------------------------------------------------------------------
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
//-----------------------------------------------------------------------------

// ImGuiWindow is mostly a dumb struct. It merely has a constructor and a few helper methods
ImGuiWindow::ImGuiWindow( ImGuiContext* context, const char* name )
  : DrawListInst( &context->DrawListSharedData )
{
  Name = ImStrdup( name );
  ID = ImHashStr( name );
  IDStack.push_back( ID );
  Flags = ImGuiWindowFlags_None;
  Pos = ImVec2( 0.0f, 0.0f );
  Size = SizeFull = ImVec2( 0.0f, 0.0f );
  ContentSize = ContentSizeExplicit = ImVec2( 0.0f, 0.0f );
  WindowPadding = ImVec2( 0.0f, 0.0f );
  WindowRounding = 0.0f;
  WindowBorderSize = 0.0f;
  NameBufLen = ( int )win32::strlen( name ) + 1;
  MoveId = GetID( SECURE( "#MOVE" ) );
  ChildId = 0;
  Scroll = ImVec2( 0.0f, 0.0f );
  ScrollTarget = ImVec2( FLT_MAX, FLT_MAX );
  ScrollTargetCenterRatio = ImVec2( 0.5f, 0.5f );
  ScrollbarSizes = ImVec2( 0.0f, 0.0f );
  ScrollbarX = ScrollbarY = false;
  Active = WasActive = false;
  WriteAccessed = false;
  Collapsed = false;
  WantCollapseToggle = false;
  SkipItems = false;
  Appearing = false;
  Hidden = false;
  IsFallbackWindow = false;
  HasCloseButton = false;
  ResizeBorderHeld = -1;
  BeginCount = 0;
  BeginOrderWithinParent = -1;
  BeginOrderWithinContext = -1;
  PopupId = 0;
  AutoFitFramesX = AutoFitFramesY = -1;
  AutoFitChildAxises = 0x00;
  AutoFitOnlyGrows = false;
  AutoPosLastDirection = ImGuiDir_None;
  HiddenFramesCanSkipItems = HiddenFramesCannotSkipItems = 0;
  SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;
  SetWindowPosVal = SetWindowPosPivot = ImVec2( FLT_MAX, FLT_MAX );

  InnerRect = ImRect( 0.0f, 0.0f, 0.0f, 0.0f ); // Clear so the InnerRect.GetSize() code in Begin() doesn't lead to overflow even if the result isn't used.

  LastFrameActive = -1;
  LastTimeActive = -1.0f;
  ItemWidthDefault = 0.0f;
  FontWindowScale = 1.0f;
  SettingsOffset = -1;

  DrawList = &DrawListInst;
  DrawList->_OwnerName = Name;
  ParentWindow = NULL;
  RootWindow = NULL;
  RootWindowForTitleBarHighlight = NULL;
  RootWindowForNav = NULL;

  NavLastIds[ 0 ] = NavLastIds[ 1 ] = 0;
  NavRectRel[ 0 ] = NavRectRel[ 1 ] = ImRect();
  NavLastChildNavWindow = NULL;

  MemoryCompacted = false;
  MemoryDrawListIdxCapacity = MemoryDrawListVtxCapacity = 0;
}

ImGuiWindow::~ImGuiWindow()
{
  IM_ASSERT( DrawList == &DrawListInst );
  IM_DELETE( Name );
  for( int i = 0; i != ColumnsStorage.Size; i++ )
    ColumnsStorage[ i ].~ImGuiColumns();
}

ImGuiID ImGuiWindow::GetID( const char* str, const char* str_end )
{
  ImGuiID seed = IDStack.back();
  ImGuiID id = ImHashStr( str, str_end ? ( str_end - str ) : 0, seed );
  ImGui::KeepAliveID( id );
#ifdef IMGUI_ENABLE_TEST_ENGINE
  ImGuiContext& g = *GImGui;
  IMGUI_TEST_ENGINE_ID_INFO2( id, ImGuiDataType_String, str, str_end );
#endif
  return id;
}

ImGuiID ImGuiWindow::GetID( const void* ptr )
{
  ImGuiID seed = IDStack.back();
  ImGuiID id = ImHashData( &ptr, sizeof( void* ), seed );
  ImGui::KeepAliveID( id );
#ifdef IMGUI_ENABLE_TEST_ENGINE
  ImGuiContext& g = *GImGui;
  IMGUI_TEST_ENGINE_ID_INFO( id, ImGuiDataType_Pointer, ptr );
#endif
  return id;
}

ImGuiID ImGuiWindow::GetID( int n )
{
  ImGuiID seed = IDStack.back();
  ImGuiID id = ImHashData( &n, sizeof( n ), seed );
  ImGui::KeepAliveID( id );
#ifdef IMGUI_ENABLE_TEST_ENGINE
  ImGuiContext& g = *GImGui;
  IMGUI_TEST_ENGINE_ID_INFO( id, ImGuiDataType_S32, ( intptr_t )n );
#endif
  return id;
}

ImGuiID ImGuiWindow::GetIDNoKeepAlive( const char* str, const char* str_end )
{
  ImGuiID seed = IDStack.back();
  ImGuiID id = ImHashStr( str, str_end ? ( str_end - str ) : 0, seed );
#ifdef IMGUI_ENABLE_TEST_ENGINE
  ImGuiContext& g = *GImGui;
  IMGUI_TEST_ENGINE_ID_INFO2( id, ImGuiDataType_String, str, str_end );
#endif
  return id;
}

ImGuiID ImGuiWindow::GetIDNoKeepAlive( const void* ptr )
{
  ImGuiID seed = IDStack.back();
  ImGuiID id = ImHashData( &ptr, sizeof( void* ), seed );
#ifdef IMGUI_ENABLE_TEST_ENGINE
  ImGuiContext& g = *GImGui;
  IMGUI_TEST_ENGINE_ID_INFO( id, ImGuiDataType_Pointer, ptr );
#endif
  return id;
}

ImGuiID ImGuiWindow::GetIDNoKeepAlive( int n )
{
  ImGuiID seed = IDStack.back();
  ImGuiID id = ImHashData( &n, sizeof( n ), seed );
#ifdef IMGUI_ENABLE_TEST_ENGINE
  ImGuiContext& g = *GImGui;
  IMGUI_TEST_ENGINE_ID_INFO( id, ImGuiDataType_S32, ( intptr_t )n );
#endif
  return id;
}

// This is only used in rare/specific situations to manufacture an ID out of nowhere.
ImGuiID ImGuiWindow::GetIDFromRectangle( const ImRect& r_abs )
{
  ImGuiID seed = IDStack.back();
  const int r_rel[ 4 ] = { ( int )( r_abs.Min.x - Pos.x ), ( int )( r_abs.Min.y - Pos.y ), ( int )( r_abs.Max.x - Pos.x ), ( int )( r_abs.Max.y - Pos.y ) };
  ImGuiID id = ImHashData( &r_rel, sizeof( r_rel ), seed );
  ImGui::KeepAliveID( id );
  return id;
}

static void SetCurrentWindow( ImGuiWindow* window )
{
  ImGuiContext& g = *GImGui;
  g.CurrentWindow = window;
  if( window )
    g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
}

// Free up/compact internal window buffers, we can use this when a window becomes unused.
// This is currently unused by the library, but you may call this yourself for easy GC.
// Not freed:
// - ImGuiWindow, ImGuiWindowSettings, Name
// - StateStorage, ColumnsStorage (may hold useful data)
// This should have no noticeable visual effect. When the window reappear however, expect new allocation/buffer growth/copy cost.
void ImGui::GcCompactTransientWindowBuffers( ImGuiWindow* window )
{
  window->MemoryCompacted = true;
  window->MemoryDrawListIdxCapacity = window->DrawList->IdxBuffer.Capacity;
  window->MemoryDrawListVtxCapacity = window->DrawList->VtxBuffer.Capacity;
  window->IDStack.clear();
  window->DrawList->ClearFreeMemory();
  window->DC.ChildWindows.clear();
  window->DC.ItemFlagsStack.clear();
  window->DC.ItemWidthStack.clear();
  window->DC.TextWrapPosStack.clear();
  window->DC.GroupStack.clear();
}

void ImGui::GcAwakeTransientWindowBuffers( ImGuiWindow* window )
{
  // We stored capacity of the ImDrawList buffer to reduce growth-caused allocation/copy when awakening.
  // The other buffers tends to amortize much faster.
  window->MemoryCompacted = false;
  window->DrawList->IdxBuffer.reserve( window->MemoryDrawListIdxCapacity );
  window->DrawList->VtxBuffer.reserve( window->MemoryDrawListVtxCapacity );
  window->MemoryDrawListIdxCapacity = window->MemoryDrawListVtxCapacity = 0;
}

void ImGui::SetActiveID( ImGuiID id, ImGuiWindow* window )
{
  ImGuiContext& g = *GImGui;
  g.ActiveIdIsJustActivated = ( g.ActiveId != id );
  if( g.ActiveIdIsJustActivated )
  {
    g.ActiveIdTimer = 0.0f;
    g.ActiveIdHasBeenPressedBefore = false;
    g.ActiveIdHasBeenEditedBefore = false;
    if( id != 0 )
    {
      g.LastActiveId = id;
      g.LastActiveIdTimer = 0.0f;
    }
  }
  g.ActiveId = id;
  g.ActiveIdAllowOverlap = false;
  g.ActiveIdWindow = window;
  g.ActiveIdHasBeenEditedThisFrame = false;
  if( id )
  {
    g.ActiveIdIsAlive = id;
    g.ActiveIdSource = ( g.NavActivateId == id || g.NavInputId == id || g.NavJustTabbedId == id || g.NavJustMovedToId == id ) ? ImGuiInputSource_Nav : ImGuiInputSource_Mouse;
  }

  // Clear declaration of inputs claimed by the widget
  // (Please note that this is WIP and not all keys/inputs are thoroughly declared by all widgets yet)
  g.ActiveIdUsingNavDirMask = 0x00;
  g.ActiveIdUsingNavInputMask = 0x00;
  g.ActiveIdUsingKeyInputMask = 0x00;
}

void ImGui::ClearActiveID()
{
  SetActiveID( 0, NULL );
}

void ImGui::SetHoveredID( ImGuiID id )
{
  ImGuiContext& g = *GImGui;
  g.HoveredId = id;
  g.HoveredIdAllowOverlap = false;
  if( id != 0 && g.HoveredIdPreviousFrame != id )
    g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;
}

ImGuiID ImGui::GetHoveredID()
{
  ImGuiContext& g = *GImGui;
  return g.HoveredId ? g.HoveredId : g.HoveredIdPreviousFrame;
}

void ImGui::KeepAliveID( ImGuiID id )
{
  ImGuiContext& g = *GImGui;
  if( g.ActiveId == id )
    g.ActiveIdIsAlive = id;
  if( g.ActiveIdPreviousFrame == id )
    g.ActiveIdPreviousFrameIsAlive = true;
}

void ImGui::MarkItemEdited( ImGuiID id )
{
  // This marking is solely to be able to provide info for IsItemDeactivatedAfterEdit().
  // ActiveId might have been released by the time we call this (as in the typical press/release button behavior) but still need need to fill the data.
  ImGuiContext& g = *GImGui;
  IM_ASSERT( g.ActiveId == id || g.ActiveId == 0 || g.DragDropActive );
  IM_UNUSED( id ); // Avoid unused variable warnings when asserts are compiled out.
  //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
  g.ActiveIdHasBeenEditedThisFrame = true;
  g.ActiveIdHasBeenEditedBefore = true;
  g.CurrentWindow->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_Edited;
}

static inline bool IsWindowContentHoverable( ImGuiWindow* window, ImGuiHoveredFlags flags )
{
  // An active popup disable hovering on other windows (apart from its own children)
  // FIXME-OPT: This could be cached/stored within the window.
  ImGuiContext& g = *GImGui;
  if( g.NavWindow )
    if( ImGuiWindow* focused_root_window = g.NavWindow->RootWindow )
      if( focused_root_window->WasActive && focused_root_window != window->RootWindow )
      {
        // For the purpose of those flags we differentiate "standard popup" from "modal popup"
        // NB: The order of those two tests is important because Modal windows are also Popups.
        if( focused_root_window->Flags & ImGuiWindowFlags_Modal )
          return false;
        if( ( focused_root_window->Flags & ImGuiWindowFlags_Popup ) && !( flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup ) )
          return false;
      }
  return true;
}

// This is roughly matching the behavior of internal-facing ItemHoverable()
// - we allow hovering to be true when ActiveId==window->MoveID, so that clicking on non-interactive items such as a Text() item still returns true with IsItemHovered()
// - this should work even for non-interactive items that have no ID, so we cannot use LastItemId
bool ImGui::IsItemHovered( ImGuiHoveredFlags flags )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  if( g.NavDisableMouseHover && !g.NavDisableHighlight )
    return IsItemFocused();

  // Test for bounding box overlap, as updated as ItemAdd()
  if( !( window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect ) )
    return false;
  IM_ASSERT( ( flags & ( ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows ) ) == 0 );   // Flags not supported by this function

  // Test if we are hovering the right window (our window could be behind another window)
  // [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I believe it is correct to NOT test for RootWindow but this leaves us unable to use IsItemHovered() after EndChild() itself.
  // Until a solution is found I believe reverting to the test from 2017/09/27 is safe since this was the test that has been running for a long while.
  //if (g.HoveredWindow != window)
  //    return false;
  if( g.HoveredRootWindow != window->RootWindow && !( flags & ImGuiHoveredFlags_AllowWhenOverlapped ) )
    return false;

  // Test if another item is active (e.g. being dragged)
  if( !( flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem ) )
    if( g.ActiveId != 0 && g.ActiveId != window->DC.LastItemId && !g.ActiveIdAllowOverlap && g.ActiveId != window->MoveId )
      return false;

  // Test if interactions on this window are blocked by an active popup or modal.
  // The ImGuiHoveredFlags_AllowWhenBlockedByPopup flag will be tested here.
  if( !IsWindowContentHoverable( window, flags ) )
    return false;

  // Test if the item is disabled
  if( ( window->DC.ItemFlags & ImGuiItemFlags_Disabled ) && !( flags & ImGuiHoveredFlags_AllowWhenDisabled ) )
    return false;

  // Special handling for the dummy item after Begin() which represent the title bar or tab.
  // When the window is collapsed (SkipItems==true) that last item will never be overwritten so we need to detect the case.
  if( window->DC.LastItemId == window->MoveId && window->WriteAccessed )
    return false;
  return true;
}

// Internal facing ItemHoverable() used when submitting widgets. Differs slightly from IsItemHovered().
bool ImGui::ItemHoverable( const ImRect& bb, ImGuiID id )
{
  ImGuiContext& g = *GImGui;
  if( g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap )
    return false;

  ImGuiWindow* window = g.CurrentWindow;
  if( g.HoveredWindow != window )
    return false;
  if( g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap )
    return false;
  if( !IsMouseHoveringRect( bb.Min, bb.Max ) )
    return false;
  if( g.NavDisableMouseHover || !IsWindowContentHoverable( window, ImGuiHoveredFlags_None ) )
    return false;
  if( window->DC.ItemFlags & ImGuiItemFlags_Disabled )
    return false;

  SetHoveredID( id );

  // [DEBUG] Item Picker tool!
  // We perform the check here because SetHoveredID() is not frequently called (1~ time a frame), making
  // the cost of this tool near-zero. We can get slightly better call-stack and support picking non-hovered
  // items if we perform the test in ItemAdd(), but that would incur a small runtime cost.
  // #define IMGUI_DEBUG_TOOL_ITEM_PICKER_EX in imconfig.h if you want this check to also be performed in ItemAdd().
  if( g.DebugItemPickerActive && g.HoveredIdPreviousFrame == id )
    GetForegroundDrawList()->AddRect( bb.Min, bb.Max, IM_COL32( 255, 255, 0, 255 ) );
  if( g.DebugItemPickerBreakId == id )
    IM_DEBUG_BREAK();

  return true;
}

bool ImGui::IsClippedEx( const ImRect& bb, ImGuiID id, bool clip_even_when_logged )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  if( !bb.Overlaps( window->ClipRect ) )
    if( id == 0 || ( id != g.ActiveId && id != g.NavId ) )
      if( clip_even_when_logged || !g.LogEnabled )
        return true;
  return false;
}

// Process TAB/Shift+TAB. Be mindful that this function may _clear_ the ActiveID when tabbing out.
bool ImGui::FocusableItemRegister( ImGuiWindow* window, ImGuiID id )
{
  ImGuiContext& g = *GImGui;

  // Increment counters
  const bool is_tab_stop = ( window->DC.ItemFlags & ( ImGuiItemFlags_NoTabStop | ImGuiItemFlags_Disabled ) ) == 0;
  window->DC.FocusCounterRegular++;
  if( is_tab_stop )
    window->DC.FocusCounterTabStop++;

  // Process TAB/Shift-TAB to tab *OUT* of the currently focused item.
  // (Note that we can always TAB out of a widget that doesn't allow tabbing in)
  if( g.ActiveId == id && g.FocusTabPressed && !IsActiveIdUsingKey( ImGuiKey_Tab ) && g.FocusRequestNextWindow == NULL )
  {
    g.FocusRequestNextWindow = window;
    g.FocusRequestNextCounterTabStop = window->DC.FocusCounterTabStop + ( g.IO.KeyShift ? ( is_tab_stop ? -1 : 0 ) : +1 ); // Modulo on index will be applied at the end of frame once we've got the total counter of items.
  }

  // Handle focus requests
  if( g.FocusRequestCurrWindow == window )
  {
    if( window->DC.FocusCounterRegular == g.FocusRequestCurrCounterRegular )
      return true;
    if( is_tab_stop && window->DC.FocusCounterTabStop == g.FocusRequestCurrCounterTabStop )
    {
      g.NavJustTabbedId = id;
      return true;
    }

    // If another item is about to be focused, we clear our own active id
    if( g.ActiveId == id )
      ClearActiveID();
  }

  return false;
}

void ImGui::FocusableItemUnregister( ImGuiWindow* window )
{
  window->DC.FocusCounterRegular--;
  window->DC.FocusCounterTabStop--;
}

float ImGui::CalcWrapWidthForPos( const ImVec2& pos, float wrap_pos_x )
{
  if( wrap_pos_x < 0.0f )
    return 0.0f;

  ImGuiWindow* window = GImGui->CurrentWindow;
  if( wrap_pos_x == 0.0f )
    wrap_pos_x = window->WorkRect.Max.x;
  else if( wrap_pos_x > 0.0f )
    wrap_pos_x += window->Pos.x - window->Scroll.x; // wrap_pos_x is provided is window local space

  return ImMax( wrap_pos_x - pos.x, 1.0f );
}

// IM_ALLOC() == ImGui::MemAlloc()
void* ImGui::MemAlloc( size_t size )
{
  if( ImGuiContext* ctx = GImGui )
    ctx->IO.MetricsActiveAllocations++;
  return GImAllocatorAllocFunc( size, GImAllocatorUserData );
}

// IM_FREE() == ImGui::MemFree()
void ImGui::MemFree( void* ptr )
{
  if( ptr )
    if( ImGuiContext* ctx = GImGui )
      ctx->IO.MetricsActiveAllocations--;
  return GImAllocatorFreeFunc( ptr, GImAllocatorUserData );
}

const char* ImGui::GetClipboardText()
{
  ImGuiContext& g = *GImGui;
  return g.IO.GetClipboardTextFn ? g.IO.GetClipboardTextFn( g.IO.ClipboardUserData ) : "";
}

void ImGui::SetClipboardText( const char* text )
{
  ImGuiContext& g = *GImGui;
  if( g.IO.SetClipboardTextFn )
    g.IO.SetClipboardTextFn( g.IO.ClipboardUserData, text );
}

const char* ImGui::GetVersion()
{
  return IMGUI_VERSION;
}

// Internal state access - if you want to share Dear ImGui state between modules (e.g. DLL) or allocate it yourself
// Note that we still point to some static data and members (such as GFontAtlas), so the state instance you end up using will point to the static data within its module
ImGuiContext* ImGui::GetCurrentContext()
{
  return GImGui;
}

void ImGui::SetCurrentContext( ImGuiContext* ctx )
{
#ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC
  IMGUI_SET_CURRENT_CONTEXT_FUNC( ctx ); // For custom thread-based hackery you may want to have control over this.
#else
  GImGui = ctx;
#endif
}

void ImGui::SetAllocatorFunctions( void* ( *alloc_func )( size_t sz, void* user_data ), void ( *free_func )( void* ptr, void* user_data ), void* user_data )
{
  GImAllocatorAllocFunc = alloc_func;
  GImAllocatorFreeFunc = free_func;
  GImAllocatorUserData = user_data;
}

ImGuiContext* ImGui::CreateContext( ImFontAtlas* shared_font_atlas )
{
  ImGuiContext* ctx = IM_NEW( ImGuiContext )( shared_font_atlas );
  if( GImGui == NULL )
    SetCurrentContext( ctx );
  Initialize( ctx );
  return ctx;
}

void ImGui::DestroyContext( ImGuiContext* ctx )
{
  if( ctx == NULL )
    ctx = GImGui;
  Shutdown( ctx );
  if( GImGui == ctx )
    SetCurrentContext( NULL );
  IM_DELETE( ctx );
}

ImGuiIO& ImGui::GetIO()
{
  IM_ASSERT( GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?" );
  return GImGui->IO;
}

// Same value as passed to the old io.RenderDrawListsFn function. Valid after Render() and until the next call to NewFrame()
ImDrawData* ImGui::GetDrawData()
{
  ImGuiContext& g = *GImGui;
  return g.DrawData.Valid ? &g.DrawData : NULL;
}

double ImGui::GetTime()
{
  return GImGui->Time;
}

int ImGui::GetFrameCount()
{
  return GImGui->FrameCount;
}

ImDrawList* ImGui::GetBackgroundDrawList()
{
  return &GImGui->BackgroundDrawList;
}

ImDrawList* ImGui::GetForegroundDrawList()
{
  return &GImGui->ForegroundDrawList;
}

ImDrawListSharedData* ImGui::GetDrawListSharedData()
{
  return &GImGui->DrawListSharedData;
}

void ImGui::StartMouseMovingWindow( ImGuiWindow* window )
{
  // Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.
  // We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.
  // This is because we want ActiveId to be set even when the window is not permitted to move.
  ImGuiContext& g = *GImGui;
  FocusWindow( window );
  SetActiveID( window->MoveId, window );
  g.NavDisableHighlight = true;
  g.ActiveIdClickOffset = g.IO.MousePos - window->RootWindow->Pos;

  bool can_move_window = true;
  if( ( window->Flags & ImGuiWindowFlags_NoMove ) || ( window->RootWindow->Flags & ImGuiWindowFlags_NoMove ) )
    can_move_window = false;
  if( can_move_window )
    g.MovingWindow = window;
}

// Handle mouse moving window
// Note: moving window with the navigation keys (Square + d-pad / CTRL+TAB + Arrows) are processed in NavUpdateWindowing()
// FIXME: We don't have strong guarantee that g.MovingWindow stay synched with g.ActiveId == g.MovingWindow->MoveId.
// This is currently enforced by the fact that BeginDragDropSource() is setting all g.ActiveIdUsingXXXX flags to inhibit navigation inputs,
// but if we should more thoroughly test cases where g.ActiveId or g.MovingWindow gets changed and not the other.
void ImGui::UpdateMouseMovingWindowNewFrame()
{
  ImGuiContext& g = *GImGui;
  if( g.MovingWindow != NULL )
  {
    // We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
    // We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.
    KeepAliveID( g.ActiveId );
    IM_ASSERT( g.MovingWindow && g.MovingWindow->RootWindow );
    ImGuiWindow* moving_window = g.MovingWindow->RootWindow;
    if( g.IO.MouseDown[ 0 ] && IsMousePosValid( &g.IO.MousePos ) )
    {
      ImVec2 pos = g.IO.MousePos - g.ActiveIdClickOffset;
      if( moving_window->Pos.x != pos.x || moving_window->Pos.y != pos.y )
      {
        MarkIniSettingsDirty( moving_window );
        SetWindowPos( moving_window, pos, ImGuiCond_Always );
      }
      FocusWindow( g.MovingWindow );
    }
    else
    {
      ClearActiveID();
      g.MovingWindow = NULL;
    }
  }
  else
  {
    // When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
    if( g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId )
    {
      KeepAliveID( g.ActiveId );
      if( !g.IO.MouseDown[ 0 ] )
        ClearActiveID();
    }
  }
}

// Initiate moving window when clicking on empty space or title bar.
// Handle left-click and right-click focus.
void ImGui::UpdateMouseMovingWindowEndFrame()
{
  ImGuiContext& g = *GImGui;
  if( g.ActiveId != 0 || g.HoveredId != 0 )
    return;

  // Unless we just made a window/popup appear
  if( g.NavWindow && g.NavWindow->Appearing )
    return;

  // Click to focus window and start moving (after we're done with all our widgets)
  if( g.IO.MouseClicked[ 0 ] )
  {
    if( g.HoveredRootWindow != NULL )
    {
      StartMouseMovingWindow( g.HoveredWindow );
      if( g.IO.ConfigWindowsMoveFromTitleBarOnly && !( g.HoveredRootWindow->Flags & ImGuiWindowFlags_NoTitleBar ) )
        if( !g.HoveredRootWindow->TitleBarRect().Contains( g.IO.MouseClickedPos[ 0 ] ) )
          g.MovingWindow = NULL;
    }
    else if( g.NavWindow != NULL && GetTopMostPopupModal() == NULL )
    {
      // Clicking on void disable focus
      FocusWindow( NULL );
    }
  }

  // With right mouse button we close popups without changing focus based on where the mouse is aimed
  // Instead, focus will be restored to the window under the bottom-most closed popup.
  // (The left mouse button path calls FocusWindow on the hovered window, which will lead NewFrame->ClosePopupsOverWindow to trigger)
  if( g.IO.MouseClicked[ 1 ] )
  {
    // Find the top-most window between HoveredWindow and the top-most Modal Window.
    // This is where we can trim the popup stack.
    ImGuiWindow* modal = GetTopMostPopupModal();
    bool hovered_window_above_modal = false;
    if( modal == NULL )
      hovered_window_above_modal = true;
    for( int i = g.Windows.Size - 1; i >= 0 && hovered_window_above_modal == false; i-- )
    {
      ImGuiWindow* window = g.Windows[ i ];
      if( window == modal )
        break;
      if( window == g.HoveredWindow )
        hovered_window_above_modal = true;
    }
    ClosePopupsOverWindow( hovered_window_above_modal ? g.HoveredWindow : modal, true );
  }
}

static bool IsWindowActiveAndVisible( ImGuiWindow* window )
{
  return ( window->Active ) && ( !window->Hidden );
}

static void ImGui::UpdateMouseInputs()
{
  ImGuiContext& g = *GImGui;

  // Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)
  if( IsMousePosValid( &g.IO.MousePos ) )
    g.IO.MousePos = g.LastValidMousePos = ImFloor( g.IO.MousePos );

  // If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta
  if( IsMousePosValid( &g.IO.MousePos ) && IsMousePosValid( &g.IO.MousePosPrev ) )
    g.IO.MouseDelta = g.IO.MousePos - g.IO.MousePosPrev;
  else
    g.IO.MouseDelta = ImVec2( 0.0f, 0.0f );
  if( g.IO.MouseDelta.x != 0.0f || g.IO.MouseDelta.y != 0.0f )
    g.NavDisableMouseHover = false;

  g.IO.MousePosPrev = g.IO.MousePos;
  for( int i = 0; i < IM_ARRAYSIZE( g.IO.MouseDown ); i++ )
  {
    g.IO.MouseClicked[ i ] = g.IO.MouseDown[ i ] && g.IO.MouseDownDuration[ i ] < 0.0f;
    g.IO.MouseReleased[ i ] = !g.IO.MouseDown[ i ] && g.IO.MouseDownDuration[ i ] >= 0.0f;
    g.IO.MouseDownDurationPrev[ i ] = g.IO.MouseDownDuration[ i ];
    g.IO.MouseDownDuration[ i ] = g.IO.MouseDown[ i ] ? ( g.IO.MouseDownDuration[ i ] < 0.0f ? 0.0f : g.IO.MouseDownDuration[ i ] + g.IO.DeltaTime ) : -1.0f;
    g.IO.MouseDoubleClicked[ i ] = false;
    if( g.IO.MouseClicked[ i ] )
    {
      if( ( float )( g.Time - g.IO.MouseClickedTime[ i ] ) < g.IO.MouseDoubleClickTime )
      {
        ImVec2 delta_from_click_pos = IsMousePosValid( &g.IO.MousePos ) ? ( g.IO.MousePos - g.IO.MouseClickedPos[ i ] ) : ImVec2( 0.0f, 0.0f );
        if( ImLengthSqr( delta_from_click_pos ) < g.IO.MouseDoubleClickMaxDist * g.IO.MouseDoubleClickMaxDist )
          g.IO.MouseDoubleClicked[ i ] = true;
        g.IO.MouseClickedTime[ i ] = -DBL_MAX;    // so the third click isn't turned into a double-click
      }
      else
      {
        g.IO.MouseClickedTime[ i ] = g.Time;
      }
      g.IO.MouseClickedPos[ i ] = g.IO.MousePos;
      g.IO.MouseDownWasDoubleClick[ i ] = g.IO.MouseDoubleClicked[ i ];
      g.IO.MouseDragMaxDistanceAbs[ i ] = ImVec2( 0.0f, 0.0f );
      g.IO.MouseDragMaxDistanceSqr[ i ] = 0.0f;
    }
    else if( g.IO.MouseDown[ i ] )
    {
      // Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
      ImVec2 delta_from_click_pos = IsMousePosValid( &g.IO.MousePos ) ? ( g.IO.MousePos - g.IO.MouseClickedPos[ i ] ) : ImVec2( 0.0f, 0.0f );
      g.IO.MouseDragMaxDistanceSqr[ i ] = ImMax( g.IO.MouseDragMaxDistanceSqr[ i ], ImLengthSqr( delta_from_click_pos ) );
      g.IO.MouseDragMaxDistanceAbs[ i ].x = ImMax( g.IO.MouseDragMaxDistanceAbs[ i ].x, delta_from_click_pos.x < 0.0f ? -delta_from_click_pos.x : delta_from_click_pos.x );
      g.IO.MouseDragMaxDistanceAbs[ i ].y = ImMax( g.IO.MouseDragMaxDistanceAbs[ i ].y, delta_from_click_pos.y < 0.0f ? -delta_from_click_pos.y : delta_from_click_pos.y );
    }
    if( !g.IO.MouseDown[ i ] && !g.IO.MouseReleased[ i ] )
      g.IO.MouseDownWasDoubleClick[ i ] = false;
    if( g.IO.MouseClicked[ i ] ) // Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation
      g.NavDisableMouseHover = false;
  }
}

static void StartLockWheelingWindow( ImGuiWindow* window )
{
  ImGuiContext& g = *GImGui;
  if( g.WheelingWindow == window )
    return;
  g.WheelingWindow = window;
  g.WheelingWindowRefMousePos = g.IO.MousePos;
  g.WheelingWindowTimer = WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER;
}

void ImGui::UpdateMouseWheel()
{
  ImGuiContext& g = *GImGui;

  // Reset the locked window if we move the mouse or after the timer elapses
  if( g.WheelingWindow != NULL )
  {
    g.WheelingWindowTimer -= g.IO.DeltaTime;
    if( IsMousePosValid() && ImLengthSqr( g.IO.MousePos - g.WheelingWindowRefMousePos ) > g.IO.MouseDragThreshold * g.IO.MouseDragThreshold )
      g.WheelingWindowTimer = 0.0f;
    if( g.WheelingWindowTimer <= 0.0f )
    {
      g.WheelingWindow = NULL;
      g.WheelingWindowTimer = 0.0f;
    }
  }

  if( g.IO.MouseWheel == 0.0f && g.IO.MouseWheelH == 0.0f )
    return;

  ImGuiWindow* window = g.WheelingWindow ? g.WheelingWindow : g.HoveredWindow;
  if( !window || window->Collapsed )
    return;

  // Zoom / Scale window
  // FIXME-OBSOLETE: This is an old feature, it still works but pretty much nobody is using it and may be best redesigned.
  if( g.IO.MouseWheel != 0.0f && g.IO.KeyCtrl && g.IO.FontAllowUserScaling )
  {
    StartLockWheelingWindow( window );
    const float new_font_scale = ImClamp( window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f );
    const float scale = new_font_scale / window->FontWindowScale;
    window->FontWindowScale = new_font_scale;
    if( !( window->Flags & ImGuiWindowFlags_ChildWindow ) )
    {
      const ImVec2 offset = window->Size * ( 1.0f - scale ) * ( g.IO.MousePos - window->Pos ) / window->Size;
      SetWindowPos( window, window->Pos + offset, 0 );
      window->Size = ImFloor( window->Size * scale );
      window->SizeFull = ImFloor( window->SizeFull * scale );
    }
    return;
  }

  // Mouse wheel scrolling
  // If a child window has the ImGuiWindowFlags_NoScrollWithMouse flag, we give a chance to scroll its parent

  // Vertical Mouse Wheel scrolling
  const float wheel_y = ( g.IO.MouseWheel != 0.0f && !g.IO.KeyShift ) ? g.IO.MouseWheel : 0.0f;
  if( wheel_y != 0.0f && !g.IO.KeyCtrl )
  {
    StartLockWheelingWindow( window );
    while( ( window->Flags & ImGuiWindowFlags_ChildWindow ) && ( ( window->ScrollMax.y == 0.0f ) || ( ( window->Flags & ImGuiWindowFlags_NoScrollWithMouse ) && !( window->Flags & ImGuiWindowFlags_NoMouseInputs ) ) ) )
      window = window->ParentWindow;
    if( !( window->Flags & ImGuiWindowFlags_NoScrollWithMouse ) && !( window->Flags & ImGuiWindowFlags_NoMouseInputs ) )
    {
      float max_step = window->InnerRect.GetHeight() * 0.67f;
      float scroll_step = ImFloor( ImMin( 5 * window->CalcFontSize(), max_step ) );
      SetScrollY( window, window->Scroll.y - wheel_y * scroll_step );
    }
  }

  // Horizontal Mouse Wheel scrolling, or Vertical Mouse Wheel w/ Shift held
  const float wheel_x = ( g.IO.MouseWheelH != 0.0f && !g.IO.KeyShift ) ? g.IO.MouseWheelH : ( g.IO.MouseWheel != 0.0f && g.IO.KeyShift ) ? g.IO.MouseWheel : 0.0f;
  if( wheel_x != 0.0f && !g.IO.KeyCtrl )
  {
    StartLockWheelingWindow( window );
    while( ( window->Flags & ImGuiWindowFlags_ChildWindow ) && ( ( window->ScrollMax.x == 0.0f ) || ( ( window->Flags & ImGuiWindowFlags_NoScrollWithMouse ) && !( window->Flags & ImGuiWindowFlags_NoMouseInputs ) ) ) )
      window = window->ParentWindow;
    if( !( window->Flags & ImGuiWindowFlags_NoScrollWithMouse ) && !( window->Flags & ImGuiWindowFlags_NoMouseInputs ) )
    {
      float max_step = window->InnerRect.GetWidth() * 0.67f;
      float scroll_step = ImFloor( ImMin( 2 * window->CalcFontSize(), max_step ) );
      SetScrollX( window, window->Scroll.x - wheel_x * scroll_step );
    }
  }
}

void ImGui::UpdateTabFocus()
{
  ImGuiContext& g = *GImGui;

  // Pressing TAB activate widget focus
  g.FocusTabPressed = ( g.NavWindow && g.NavWindow->Active && !( g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs ) && !g.IO.KeyCtrl && IsKeyPressedMap( ImGuiKey_Tab ) );
  if( g.ActiveId == 0 && g.FocusTabPressed )
  {
    // Note that SetKeyboardFocusHere() sets the Next fields mid-frame. To be consistent we also
    // manipulate the Next fields even, even though they will be turned into Curr fields by the code below.
    g.FocusRequestNextWindow = g.NavWindow;
    g.FocusRequestNextCounterRegular = INT_MAX;
    if( g.NavId != 0 && g.NavIdTabCounter != INT_MAX )
      g.FocusRequestNextCounterTabStop = g.NavIdTabCounter + 1 + ( g.IO.KeyShift ? -1 : 1 );
    else
      g.FocusRequestNextCounterTabStop = g.IO.KeyShift ? -1 : 0;
  }

  // Turn queued focus request into current one
  g.FocusRequestCurrWindow = NULL;
  g.FocusRequestCurrCounterRegular = g.FocusRequestCurrCounterTabStop = INT_MAX;
  if( g.FocusRequestNextWindow != NULL )
  {
    ImGuiWindow* window = g.FocusRequestNextWindow;
    g.FocusRequestCurrWindow = window;
    if( g.FocusRequestNextCounterRegular != INT_MAX && window->DC.FocusCounterRegular != -1 )
      g.FocusRequestCurrCounterRegular = ImModPositive( g.FocusRequestNextCounterRegular, window->DC.FocusCounterRegular + 1 );
    if( g.FocusRequestNextCounterTabStop != INT_MAX && window->DC.FocusCounterTabStop != -1 )
      g.FocusRequestCurrCounterTabStop = ImModPositive( g.FocusRequestNextCounterTabStop, window->DC.FocusCounterTabStop + 1 );
    g.FocusRequestNextWindow = NULL;
    g.FocusRequestNextCounterRegular = g.FocusRequestNextCounterTabStop = INT_MAX;
  }

  g.NavIdTabCounter = INT_MAX;
}

// The reason this is exposed in imgui_internal.h is: on touch-based system that don't have hovering, we want to dispatch inputs to the right target (imgui vs imgui+app)
void ImGui::UpdateHoveredWindowAndCaptureFlags()
{
  ImGuiContext& g = *GImGui;

  // Find the window hovered by mouse:
  // - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
  // - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.
  // - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
  FindHoveredWindow();

  // Modal windows prevents cursor from hovering behind them.
  ImGuiWindow* modal_window = GetTopMostPopupModal();
  if( modal_window )
    if( g.HoveredRootWindow && !IsWindowChildOf( g.HoveredRootWindow, modal_window ) )
      g.HoveredRootWindow = g.HoveredWindow = NULL;

  // Disabled mouse?
  if( g.IO.ConfigFlags & ImGuiConfigFlags_NoMouse )
    g.HoveredWindow = g.HoveredRootWindow = NULL;

  // We track click ownership. When clicked outside of a window the click is owned by the application and won't report hovering nor request capture even while dragging over our windows afterward.
  int mouse_earliest_button_down = -1;
  bool mouse_any_down = false;
  for( int i = 0; i < IM_ARRAYSIZE( g.IO.MouseDown ); i++ )
  {
    if( g.IO.MouseClicked[ i ] )
      g.IO.MouseDownOwned[ i ] = ( g.HoveredWindow != NULL ) || ( !g.OpenPopupStack.empty() );
    mouse_any_down |= g.IO.MouseDown[ i ];
    if( g.IO.MouseDown[ i ] )
      if( mouse_earliest_button_down == -1 || g.IO.MouseClickedTime[ i ] < g.IO.MouseClickedTime[ mouse_earliest_button_down ] )
        mouse_earliest_button_down = i;
  }
  const bool mouse_avail_to_imgui = ( mouse_earliest_button_down == -1 ) || g.IO.MouseDownOwned[ mouse_earliest_button_down ];

  // If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
  // FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
  const bool mouse_dragging_extern_payload = g.DragDropActive && ( g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern ) != 0;
  if( !mouse_avail_to_imgui && !mouse_dragging_extern_payload )
    g.HoveredWindow = g.HoveredRootWindow = NULL;

  // Update io.WantCaptureMouse for the user application (true = dispatch mouse info to imgui, false = dispatch mouse info to Dear ImGui + app)
  if( g.WantCaptureMouseNextFrame != -1 )
    g.IO.WantCaptureMouse = ( g.WantCaptureMouseNextFrame != 0 );
  else
    g.IO.WantCaptureMouse = ( mouse_avail_to_imgui && ( g.HoveredWindow != NULL || mouse_any_down ) ) || ( !g.OpenPopupStack.empty() );

  // Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to imgui, false = dispatch keyboard info to Dear ImGui + app)
  if( g.WantCaptureKeyboardNextFrame != -1 )
    g.IO.WantCaptureKeyboard = ( g.WantCaptureKeyboardNextFrame != 0 );
  else
    g.IO.WantCaptureKeyboard = ( g.ActiveId != 0 ) || ( modal_window != NULL );
  if( g.IO.NavActive && ( g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard ) && !( g.IO.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard ) )
    g.IO.WantCaptureKeyboard = true;

  // Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
  g.IO.WantTextInput = ( g.WantTextInputNextFrame != -1 ) ? ( g.WantTextInputNextFrame != 0 ) : false;
}

ImGuiKeyModFlags ImGui::GetMergedKeyModFlags()
{
  ImGuiContext& g = *GImGui;
  ImGuiKeyModFlags key_mod_flags = ImGuiKeyModFlags_None;
  if( g.IO.KeyCtrl )
  {
    key_mod_flags |= ImGuiKeyModFlags_Ctrl;
  }
  if( g.IO.KeyShift )
  {
    key_mod_flags |= ImGuiKeyModFlags_Shift;
  }
  if( g.IO.KeyAlt )
  {
    key_mod_flags |= ImGuiKeyModFlags_Alt;
  }
  if( g.IO.KeySuper )
  {
    key_mod_flags |= ImGuiKeyModFlags_Super;
  }
  return key_mod_flags;
}

void ImGui::NewFrame()
{
  IM_ASSERT( GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?" );
  ImGuiContext& g = *GImGui;

#ifdef IMGUI_ENABLE_TEST_ENGINE
  ImGuiTestEngineHook_PreNewFrame( &g );
#endif

  // Check and assert for various common IO and Configuration mistakes
  ErrorCheckNewFrameSanityChecks();

  // Load settings on first frame, save settings when modified (after a delay)
  UpdateSettings();

  g.Time += g.IO.DeltaTime;
  g.WithinFrameScope = true;
  g.FrameCount += 1;
  g.TooltipOverrideCount = 0;
  g.WindowsActiveCount = 0;
  g.MenusIdSubmittedThisFrame.resize( 0 );

  // Calculate frame-rate for the user, as a purely luxurious feature
  g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[ g.FramerateSecPerFrameIdx ];
  g.FramerateSecPerFrame[ g.FramerateSecPerFrameIdx ] = g.IO.DeltaTime;
  g.FramerateSecPerFrameIdx = ( g.FramerateSecPerFrameIdx + 1 ) % IM_ARRAYSIZE( g.FramerateSecPerFrame );
  g.IO.Framerate = ( g.FramerateSecPerFrameAccum > 0.0f ) ? ( 1.0f / ( g.FramerateSecPerFrameAccum / ( float )IM_ARRAYSIZE( g.FramerateSecPerFrame ) ) ) : FLT_MAX;

  // Setup current font and draw list shared data
  g.IO.Fonts->Locked = true;
  SetCurrentFont( GetDefaultFont() );
  IM_ASSERT( g.Font->IsLoaded() );
  g.DrawListSharedData.ClipRectFullscreen = ImVec4( 0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y );
  g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;
  g.DrawListSharedData.SetCircleSegmentMaxError( g.Style.CircleSegmentMaxError );
  g.DrawListSharedData.InitialFlags = ImDrawListFlags_None;
  if( g.Style.AntiAliasedLines )
    g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLines;
  if( g.Style.AntiAliasedFill )
    g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedFill;
  if( g.IO.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset )
    g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AllowVtxOffset;

  g.BackgroundDrawList.Clear();
  g.BackgroundDrawList.PushTextureID( g.IO.Fonts->TexID );
  g.BackgroundDrawList.PushClipRectFullScreen();

  g.ForegroundDrawList.Clear();
  g.ForegroundDrawList.PushTextureID( g.IO.Fonts->TexID );
  g.ForegroundDrawList.PushClipRectFullScreen();

  // Mark rendering data as invalid to prevent user who may have a handle on it to use it.
  g.DrawData.Clear();

  // Drag and drop keep the source ID alive so even if the source disappear our state is consistent
  if( g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId )
    KeepAliveID( g.DragDropPayload.SourceId );

  // Update HoveredId data
  if( !g.HoveredIdPreviousFrame )
    g.HoveredIdTimer = 0.0f;
  if( !g.HoveredIdPreviousFrame || ( g.HoveredId && g.ActiveId == g.HoveredId ) )
    g.HoveredIdNotActiveTimer = 0.0f;
  if( g.HoveredId )
    g.HoveredIdTimer += g.IO.DeltaTime;
  if( g.HoveredId && g.ActiveId != g.HoveredId )
    g.HoveredIdNotActiveTimer += g.IO.DeltaTime;
  g.HoveredIdPreviousFrame = g.HoveredId;
  g.HoveredId = 0;
  g.HoveredIdAllowOverlap = false;

  // Update ActiveId data (clear reference to active widget if the widget isn't alive anymore)
  if( g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId && g.ActiveId != 0 )
    ClearActiveID();
  if( g.ActiveId )
    g.ActiveIdTimer += g.IO.DeltaTime;
  g.LastActiveIdTimer += g.IO.DeltaTime;
  g.ActiveIdPreviousFrame = g.ActiveId;
  g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;
  g.ActiveIdPreviousFrameHasBeenEditedBefore = g.ActiveIdHasBeenEditedBefore;
  g.ActiveIdIsAlive = 0;
  g.ActiveIdHasBeenEditedThisFrame = false;
  g.ActiveIdPreviousFrameIsAlive = false;
  g.ActiveIdIsJustActivated = false;
  if( g.TempInputId != 0 && g.ActiveId != g.TempInputId )
    g.TempInputId = 0;
  if( g.ActiveId == 0 )
  {
    g.ActiveIdUsingNavDirMask = 0x00;
    g.ActiveIdUsingNavInputMask = 0x00;
    g.ActiveIdUsingKeyInputMask = 0x00;
  }

  // Drag and drop
  g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
  g.DragDropAcceptIdCurr = 0;
  g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
  g.DragDropWithinSource = false;
  g.DragDropWithinTarget = false;
  g.DragDropHoldJustPressedId = 0;

  // Update keyboard input state
  // Synchronize io.KeyMods with individual modifiers io.KeyXXX bools
  g.IO.KeyMods = GetMergedKeyModFlags();
  memcpy( g.IO.KeysDownDurationPrev, g.IO.KeysDownDuration, sizeof( g.IO.KeysDownDuration ) );
  for( int i = 0; i < IM_ARRAYSIZE( g.IO.KeysDown ); i++ )
    g.IO.KeysDownDuration[ i ] = g.IO.KeysDown[ i ] ? ( g.IO.KeysDownDuration[ i ] < 0.0f ? 0.0f : g.IO.KeysDownDuration[ i ] + g.IO.DeltaTime ) : -1.0f;

  // Update gamepad/keyboard navigation
  NavUpdate();

  // Update mouse input state
  UpdateMouseInputs();

  // Find hovered window
  // (needs to be before UpdateMouseMovingWindowNewFrame so we fill g.HoveredWindowUnderMovingWindow on the mouse release frame)
  UpdateHoveredWindowAndCaptureFlags();

  // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
  UpdateMouseMovingWindowNewFrame();

  // Background darkening/whitening
  if( GetTopMostPopupModal() != NULL || ( g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f ) )
    g.DimBgRatio = ImMin( g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f );
  else
    g.DimBgRatio = ImMax( g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f );

  g.MouseCursor = ImGuiMouseCursor_Arrow;
  g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;
  g.PlatformImePos = ImVec2( 1.0f, 1.0f ); // OS Input Method Editor showing on top-left of our window by default

  // Mouse wheel scrolling, scale
  UpdateMouseWheel();

  // Update legacy TAB focus
  UpdateTabFocus();

  // Mark all windows as not visible and compact unused memory.
  IM_ASSERT( g.WindowsFocusOrder.Size == g.Windows.Size );
  const float memory_compact_start_time = ( g.IO.ConfigWindowsMemoryCompactTimer >= 0.0f ) ? ( float )g.Time - g.IO.ConfigWindowsMemoryCompactTimer : FLT_MAX;
  for( int i = 0; i != g.Windows.Size; i++ )
  {
    ImGuiWindow* window = g.Windows[ i ];
    window->WasActive = window->Active;
    window->BeginCount = 0;
    window->Active = false;
    window->WriteAccessed = false;

    // Garbage collect transient buffers of recently unused windows
    if( !window->WasActive && !window->MemoryCompacted && window->LastTimeActive < memory_compact_start_time )
      GcCompactTransientWindowBuffers( window );
  }

  // Closing the focused window restore focus to the first active root window in descending z-order
  if( g.NavWindow && !g.NavWindow->WasActive )
    FocusTopMostWindowUnderOne( NULL, NULL );

  // No window should be open at the beginning of the frame.
  // But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
  g.CurrentWindowStack.resize( 0 );
  g.BeginPopupStack.resize( 0 );
  ClosePopupsOverWindow( g.NavWindow, false );

  // [DEBUG] Item picker tool - start with DebugStartItemPicker() - useful to visually select an item and break into its call-stack.
  UpdateDebugToolItemPicker();

  // Create implicit/fallback window - which we will only render it if the user has added something to it.
  // We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
  // This fallback is particularly important as it avoid ImGui:: calls from crashing.
  g.WithinFrameScopeWithImplicitWindow = true;
  SetNextWindowSize( ImVec2( 400, 400 ), ImGuiCond_FirstUseEver );
  Begin( SECURE( "Debug##Default" ) );
  IM_ASSERT( g.CurrentWindow->IsFallbackWindow == true );

#ifdef IMGUI_ENABLE_TEST_ENGINE
  ImGuiTestEngineHook_PostNewFrame( &g );
#endif
}

// [DEBUG] Item picker tool - start with DebugStartItemPicker() - useful to visually select an item and break into its call-stack.
void ImGui::UpdateDebugToolItemPicker()
{
  ImGuiContext& g = *GImGui;
  g.DebugItemPickerBreakId = 0;
  if( g.DebugItemPickerActive )
  {
    const ImGuiID hovered_id = g.HoveredIdPreviousFrame;
    ImGui::SetMouseCursor( ImGuiMouseCursor_Hand );
    if( ImGui::IsKeyPressedMap( ImGuiKey_Escape ) )
      g.DebugItemPickerActive = false;
    if( ImGui::IsMouseClicked( 0 ) && hovered_id )
    {
      g.DebugItemPickerBreakId = hovered_id;
      g.DebugItemPickerActive = false;
    }
    ImGui::SetNextWindowBgAlpha( 0.60f );
    ImGui::BeginTooltip();
    ImGui::Text( SECURE( "HoveredId: 0x%08X" ), hovered_id );
    ImGui::Text( SECURE( "Press ESC to abort picking." ) );
    ImGui::TextColored( GetStyleColorVec4( hovered_id ? ImGuiCol_Text : ImGuiCol_TextDisabled ), SECURE( "Click to break in debugger!" ) );
    ImGui::EndTooltip();
  }
}

void ImGui::Initialize( ImGuiContext* context )
{
  ImGuiContext& g = *context;
  IM_ASSERT( !g.Initialized && !g.SettingsLoaded );

  // Add .ini handle for ImGuiWindow type
  {
    ImGuiSettingsHandler ini_handler;
    ini_handler.TypeName = SECURE( "Window" );
    ini_handler.TypeHash = ImHashStr( SECURE( "Window" ) );
    ini_handler.ReadOpenFn = WindowSettingsHandler_ReadOpen;
    ini_handler.ReadLineFn = WindowSettingsHandler_ReadLine;
    ini_handler.WriteAllFn = WindowSettingsHandler_WriteAll;
    g.SettingsHandlers.push_back( ini_handler );
  }

#ifdef IMGUI_HAS_TABLE
  // Add .ini handle for ImGuiTable type
  {
    ImGuiSettingsHandler ini_handler;
    ini_handler.TypeName = "Table";
    ini_handler.TypeHash = ImHashStr( "Table" );
    ini_handler.ReadOpenFn = TableSettingsHandler_ReadOpen;
    ini_handler.ReadLineFn = TableSettingsHandler_ReadLine;
    ini_handler.WriteAllFn = TableSettingsHandler_WriteAll;
    g.SettingsHandlers.push_back( ini_handler );
  }
#endif // #ifdef IMGUI_HAS_TABLE

#ifdef IMGUI_HAS_DOCK
#endif // #ifdef IMGUI_HAS_DOCK

  g.Initialized = true;
}

// This function is merely here to free heap allocations.
void ImGui::Shutdown( ImGuiContext* context )
{
  // The fonts atlas can be used prior to calling NewFrame(), so we clear it even if g.Initialized is FALSE (which would happen if we never called NewFrame)
  ImGuiContext& g = *context;
  if( g.IO.Fonts && g.FontAtlasOwnedByContext )
  {
    g.IO.Fonts->Locked = false;
    IM_DELETE( g.IO.Fonts );
  }
  g.IO.Fonts = NULL;

  // Cleanup of other data are conditional on actually having initialized Dear ImGui.
  if( !g.Initialized )
    return;

  // Save settings (unless we haven't attempted to load them: CreateContext/DestroyContext without a call to NewFrame shouldn't save an empty file)
  if( g.SettingsLoaded && g.IO.IniFilename != NULL )
  {
    ImGuiContext* backup_context = GImGui;
    SetCurrentContext( context );
    SaveIniSettingsToDisk( g.IO.IniFilename );
    SetCurrentContext( backup_context );
  }

  // Clear everything else
  for( int i = 0; i < g.Windows.Size; i++ )
    IM_DELETE( g.Windows[ i ] );
  g.Windows.clear();
  g.WindowsFocusOrder.clear();
  g.WindowsTempSortBuffer.clear();
  g.CurrentWindow = NULL;
  g.CurrentWindowStack.clear();
  g.WindowsById.Clear();
  g.NavWindow = NULL;
  g.HoveredWindow = g.HoveredRootWindow = NULL;
  g.ActiveIdWindow = g.ActiveIdPreviousFrameWindow = NULL;
  g.MovingWindow = NULL;
  g.ColorModifiers.clear();
  g.StyleModifiers.clear();
  g.FontStack.clear();
  g.OpenPopupStack.clear();
  g.BeginPopupStack.clear();
  g.DrawDataBuilder.ClearFreeMemory();
  g.BackgroundDrawList.ClearFreeMemory();
  g.ForegroundDrawList.ClearFreeMemory();

  g.TabBars.Clear();
  g.CurrentTabBarStack.clear();
  g.ShrinkWidthBuffer.clear();

  g.ClipboardHandlerData.clear();
  g.MenusIdSubmittedThisFrame.clear();
  g.InputTextState.ClearFreeMemory();

  g.SettingsWindows.clear();
  g.SettingsHandlers.clear();

  if( g.LogFile )
  {
#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
    if( g.LogFile != stdout )
#endif
      ImFileClose( g.LogFile );
    g.LogFile = NULL;
  }
  g.LogBuffer.clear();

  g.Initialized = false;
}

// FIXME: Add a more explicit sort order in the window structure.
static int IMGUI_CDECL ChildWindowComparer( const void* lhs, const void* rhs )
{
  const ImGuiWindow* const a = *( const ImGuiWindow* const* )lhs;
  const ImGuiWindow* const b = *( const ImGuiWindow* const* )rhs;
  if( int d = ( a->Flags & ImGuiWindowFlags_Popup ) - ( b->Flags & ImGuiWindowFlags_Popup ) )
    return d;
  if( int d = ( a->Flags & ImGuiWindowFlags_Tooltip ) - ( b->Flags & ImGuiWindowFlags_Tooltip ) )
    return d;
  return ( a->BeginOrderWithinParent - b->BeginOrderWithinParent );
}

static void AddWindowToSortBuffer( ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window )
{
  out_sorted_windows->push_back( window );
  if( window->Active )
  {
    int count = window->DC.ChildWindows.Size;
    if( count > 1 )
      ImQsort( window->DC.ChildWindows.Data, ( size_t )count, sizeof( ImGuiWindow* ), ChildWindowComparer );
    for( int i = 0; i < count; i++ )
    {
      ImGuiWindow* child = window->DC.ChildWindows[ i ];
      if( child->Active )
        AddWindowToSortBuffer( out_sorted_windows, child );
    }
  }
}

static void AddDrawListToDrawData( ImVector<ImDrawList*>* out_list, ImDrawList* draw_list )
{
  if( draw_list->CmdBuffer.empty() )
    return;

  // Remove trailing command if unused
  ImDrawCmd& last_cmd = draw_list->CmdBuffer.back();
  if( last_cmd.ElemCount == 0 && last_cmd.UserCallback == NULL )
  {
    draw_list->CmdBuffer.pop_back();
    if( draw_list->CmdBuffer.empty() )
      return;
  }

  // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc.
  // May trigger for you if you are using PrimXXX functions incorrectly.
  IM_ASSERT( draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size );
  IM_ASSERT( draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size );
  if( !( draw_list->Flags & ImDrawListFlags_AllowVtxOffset ) )
    IM_ASSERT( ( int )draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size );

  // Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)
  // If this assert triggers because you are drawing lots of stuff manually:
  // - First, make sure you are coarse clipping yourself and not trying to draw many things outside visible bounds.
  //   Be mindful that the ImDrawList API doesn't filter vertices. Use the Metrics window to inspect draw list contents.
  // - If you want large meshes with more than 64K vertices, you can either:
  //   (A) Handle the ImDrawCmd::VtxOffset value in your renderer back-end, and set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset'.
  //       Most example back-ends already support this from 1.71. Pre-1.71 back-ends won't.
  //       Some graphics API such as GL ES 1/2 don't have a way to offset the starting vertex so it is not supported for them.
  //   (B) Or handle 32-bit indices in your renderer back-end, and uncomment '#define ImDrawIdx unsigned int' line in imconfig.h.
  //       Most example back-ends already support this. For example, the OpenGL example code detect index size at compile-time:
  //         glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
  //       Your own engine or render API may use different parameters or function calls to specify index sizes.
  //       2 and 4 bytes indices are generally supported by most graphics API.
  // - If for some reason neither of those solutions works for you, a workaround is to call BeginChild()/EndChild() before reaching
  //   the 64K limit to split your draw commands in multiple draw lists.
  if( sizeof( ImDrawIdx ) == 2 )
    IM_ASSERT( draw_list->_VtxCurrentIdx < ( 1 << 16 ) && "Too many vertices in ImDrawList using 16-bit indices. Read comment above" );

  out_list->push_back( draw_list );
}

static void AddWindowToDrawData( ImVector<ImDrawList*>* out_render_list, ImGuiWindow* window )
{
  ImGuiContext& g = *GImGui;
  g.IO.MetricsRenderWindows++;
  AddDrawListToDrawData( out_render_list, window->DrawList );
  for( int i = 0; i < window->DC.ChildWindows.Size; i++ )
  {
    ImGuiWindow* child = window->DC.ChildWindows[ i ];
    if( IsWindowActiveAndVisible( child ) ) // clipped children may have been marked not active
      AddWindowToDrawData( out_render_list, child );
  }
}

// Layer is locked for the root window, however child windows may use a different viewport (e.g. extruding menu)
static void AddRootWindowToDrawData( ImGuiWindow* window )
{
  ImGuiContext& g = *GImGui;
  int layer = ( window->Flags & ImGuiWindowFlags_Tooltip ) ? 1 : 0;
  AddWindowToDrawData( &g.DrawDataBuilder.Layers[ layer ], window );
}

void ImDrawDataBuilder::FlattenIntoSingleLayer()
{
  int n = Layers[ 0 ].Size;
  int size = n;
  for( int i = 1; i < IM_ARRAYSIZE( Layers ); i++ )
    size += Layers[ i ].Size;
  Layers[ 0 ].resize( size );
  for( int layer_n = 1; layer_n < IM_ARRAYSIZE( Layers ); layer_n++ )
  {
    ImVector<ImDrawList*>& layer = Layers[ layer_n ];
    if( layer.empty() )
      continue;
    memcpy( &Layers[ 0 ][ n ], &layer[ 0 ], layer.Size * sizeof( ImDrawList* ) );
    n += layer.Size;
    layer.resize( 0 );
  }
}

static void SetupDrawData( ImVector<ImDrawList*>* draw_lists, ImDrawData* draw_data )
{
  ImGuiIO& io = ImGui::GetIO();
  draw_data->Valid = true;
  draw_data->CmdLists = ( draw_lists->Size > 0 ) ? draw_lists->Data : NULL;
  draw_data->CmdListsCount = draw_lists->Size;
  draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;
  draw_data->DisplayPos = ImVec2( 0.0f, 0.0f );
  draw_data->DisplaySize = io.DisplaySize;
  draw_data->FramebufferScale = io.DisplayFramebufferScale;
  for( int n = 0; n < draw_lists->Size; n++ )
  {
    draw_data->TotalVtxCount += draw_lists->Data[ n ]->VtxBuffer.Size;
    draw_data->TotalIdxCount += draw_lists->Data[ n ]->IdxBuffer.Size;
  }
}

// When using this function it is sane to ensure that float are perfectly rounded to integer values, to that e.g. (int)(max.x-min.x) in user's render produce correct result.
void ImGui::PushClipRect( const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect )
{
  ImGuiWindow* window = GetCurrentWindow();
  window->DrawList->PushClipRect( clip_rect_min, clip_rect_max, intersect_with_current_clip_rect );
  window->ClipRect = window->DrawList->_ClipRectStack.back();
}

void ImGui::PopClipRect()
{
  ImGuiWindow* window = GetCurrentWindow();
  window->DrawList->PopClipRect();
  window->ClipRect = window->DrawList->_ClipRectStack.back();
}

// This is normally called by Render(). You may want to call it directly if you want to avoid calling Render() but the gain will be very minimal.
void ImGui::EndFrame()
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( g.Initialized );

  // Don't process EndFrame() multiple times.
  if( g.FrameCountEnded == g.FrameCount )
    return;
  IM_ASSERT( g.WithinFrameScope && "Forgot to call ImGui::NewFrame()?" );

  ErrorCheckEndFrameSanityChecks();

  // Notify OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
  if( g.IO.ImeSetInputScreenPosFn && ( g.PlatformImeLastPos.x == FLT_MAX || ImLengthSqr( g.PlatformImeLastPos - g.PlatformImePos ) > 0.0001f ) )
  {
    g.IO.ImeSetInputScreenPosFn( ( int )g.PlatformImePos.x, ( int )g.PlatformImePos.y );
    g.PlatformImeLastPos = g.PlatformImePos;
  }

  // Hide implicit/fallback "Debug" window if it hasn't been used
  g.WithinFrameScopeWithImplicitWindow = false;
  if( g.CurrentWindow && !g.CurrentWindow->WriteAccessed )
    g.CurrentWindow->Active = false;
  End();

  // Show CTRL+TAB list window
  if( g.NavWindowingTarget != NULL )
    NavUpdateWindowingOverlay();

  // Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)
  if( g.DragDropActive )
  {
    bool is_delivered = g.DragDropPayload.Delivery;
    bool is_elapsed = ( g.DragDropPayload.DataFrameCount + 1 < g.FrameCount ) && ( ( g.DragDropSourceFlags & ImGuiDragDropFlags_SourceAutoExpirePayload ) || !IsMouseDown( g.DragDropMouseButton ) );
    if( is_delivered || is_elapsed )
      ClearDragDrop();
  }

  // Drag and Drop: Fallback for source tooltip. This is not ideal but better than nothing.
  if( g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount && !( g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip ) )
  {
    g.DragDropWithinSource = true;
    SetTooltip( SECURE( "..." ) );
    g.DragDropWithinSource = false;
  }

  // End frame
  g.WithinFrameScope = false;
  g.FrameCountEnded = g.FrameCount;

  // Initiate moving window + handle left-click and right-click focus
  UpdateMouseMovingWindowEndFrame();

  // Sort the window list so that all child windows are after their parent
  // We cannot do that on FocusWindow() because children may not exist yet
  g.WindowsTempSortBuffer.resize( 0 );
  g.WindowsTempSortBuffer.reserve( g.Windows.Size );
  for( int i = 0; i != g.Windows.Size; i++ )
  {
    ImGuiWindow* window = g.Windows[ i ];
    if( window->Active && ( window->Flags & ImGuiWindowFlags_ChildWindow ) )       // if a child is active its parent will add it
      continue;
    AddWindowToSortBuffer( &g.WindowsTempSortBuffer, window );
  }

  // This usually assert if there is a mismatch between the ImGuiWindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows[] in parents, aka we've done something wrong.
  IM_ASSERT( g.Windows.Size == g.WindowsTempSortBuffer.Size );
  g.Windows.swap( g.WindowsTempSortBuffer );
  g.IO.MetricsActiveWindows = g.WindowsActiveCount;

  // Unlock font atlas
  g.IO.Fonts->Locked = false;

  // Clear Input data for next frame
  g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;
  g.IO.InputQueueCharacters.resize( 0 );
  memset( g.IO.NavInputs, 0, sizeof( g.IO.NavInputs ) );
}

void ImGui::Render()
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( g.Initialized );

  if( g.FrameCountEnded != g.FrameCount )
    EndFrame();
  g.FrameCountRendered = g.FrameCount;
  g.IO.MetricsRenderWindows = 0;
  g.DrawDataBuilder.Clear();

  // Add background ImDrawList
  if( !g.BackgroundDrawList.VtxBuffer.empty() )
    AddDrawListToDrawData( &g.DrawDataBuilder.Layers[ 0 ], &g.BackgroundDrawList );

  // Add ImDrawList to render
  ImGuiWindow* windows_to_render_top_most[ 2 ];
  windows_to_render_top_most[ 0 ] = ( g.NavWindowingTarget && !( g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus ) ) ? g.NavWindowingTarget->RootWindow : NULL;
  windows_to_render_top_most[ 1 ] = ( g.NavWindowingTarget ? g.NavWindowingList : NULL );
  for( int n = 0; n != g.Windows.Size; n++ )
  {
    ImGuiWindow* window = g.Windows[ n ];
    if( IsWindowActiveAndVisible( window ) && ( window->Flags & ImGuiWindowFlags_ChildWindow ) == 0 && window != windows_to_render_top_most[ 0 ] && window != windows_to_render_top_most[ 1 ] )
      AddRootWindowToDrawData( window );
  }
  for( int n = 0; n < IM_ARRAYSIZE( windows_to_render_top_most ); n++ )
    if( windows_to_render_top_most[ n ] && IsWindowActiveAndVisible( windows_to_render_top_most[ n ] ) ) // NavWindowingTarget is always temporarily displayed as the top-most window
      AddRootWindowToDrawData( windows_to_render_top_most[ n ] );
  g.DrawDataBuilder.FlattenIntoSingleLayer();

  // Draw software mouse cursor if requested
  if( g.IO.MouseDrawCursor )
    RenderMouseCursor( &g.ForegroundDrawList, g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32( 0, 0, 0, 48 ) );

  // Add foreground ImDrawList
  if( !g.ForegroundDrawList.VtxBuffer.empty() )
    AddDrawListToDrawData( &g.DrawDataBuilder.Layers[ 0 ], &g.ForegroundDrawList );

  // Setup ImDrawData structure for end-user
  SetupDrawData( &g.DrawDataBuilder.Layers[ 0 ], &g.DrawData );
  g.IO.MetricsRenderVertices = g.DrawData.TotalVtxCount;
  g.IO.MetricsRenderIndices = g.DrawData.TotalIdxCount;

  // (Legacy) Call the Render callback function. The current prefer way is to let the user retrieve GetDrawData() and call the render function themselves.
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
  if( g.DrawData.CmdListsCount > 0 && g.IO.RenderDrawListsFn != NULL )
    g.IO.RenderDrawListsFn( &g.DrawData );
#endif
}

// Calculate text size. Text can be multi-line. Optionally ignore text after a ## marker.
// CalcTextSize("") should return ImVec2(0.0f, g.FontSize)
ImVec2 ImGui::CalcTextSize( const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width )
{
  ImGuiContext& g = *GImGui;

  const char* text_display_end;
  if( hide_text_after_double_hash )
    text_display_end = FindRenderedTextEnd( text, text_end );      // Hide anything after a '##' string
  else
    text_display_end = text_end;

  ImFont* font = g.Font;
  const float font_size = g.FontSize;
  if( text == text_display_end )
    return ImVec2( 0.0f, font_size );
  ImVec2 text_size = font->CalcTextSizeA( font_size, FLT_MAX, wrap_width, text, text_display_end, NULL );

  // Round
  text_size.x = IM_FLOOR( text_size.x + 0.95f );

  return text_size;
}

// Find window given position, search front-to-back
// FIXME: Note that we have an inconsequential lag here: OuterRectClipped is updated in Begin(), so windows moved programmatically
// with SetWindowPos() and not SetNextWindowPos() will have that rectangle lagging by a frame at the time FindHoveredWindow() is
// called, aka before the next Begin(). Moving window isn't affected.
static void FindHoveredWindow()
{
  ImGuiContext& g = *GImGui;

  ImGuiWindow* hovered_window = NULL;
  if( g.MovingWindow && !( g.MovingWindow->Flags & ImGuiWindowFlags_NoMouseInputs ) )
    hovered_window = g.MovingWindow;

  ImVec2 padding_regular = g.Style.TouchExtraPadding;
  ImVec2 padding_for_resize_from_edges = g.IO.ConfigWindowsResizeFromEdges ? ImMax( g.Style.TouchExtraPadding, ImVec2( WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS, WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS ) ) : padding_regular;
  for( int i = g.Windows.Size - 1; i >= 0; i-- )
  {
    ImGuiWindow* window = g.Windows[ i ];
    if( !window->Active || window->Hidden )
      continue;
    if( window->Flags & ImGuiWindowFlags_NoMouseInputs )
      continue;

    // Using the clipped AABB, a child window will typically be clipped by its parent (not always)
    ImRect bb( window->OuterRectClipped );
    if( window->Flags & ( ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize ) )
      bb.Expand( padding_regular );
    else
      bb.Expand( padding_for_resize_from_edges );
    if( !bb.Contains( g.IO.MousePos ) )
      continue;

    // Those seemingly unnecessary extra tests are because the code here is a little different in viewport/docking branches.
    if( hovered_window == NULL )
      hovered_window = window;
    if( hovered_window )
      break;
  }

  g.HoveredWindow = hovered_window;
  g.HoveredRootWindow = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;

}

// Test if mouse cursor is hovering given rectangle
// NB- Rectangle is clipped by our current clip setting
// NB- Expand the rectangle to be generous on imprecise inputs systems (g.Style.TouchExtraPadding)
bool ImGui::IsMouseHoveringRect( const ImVec2& r_min, const ImVec2& r_max, bool clip )
{
  ImGuiContext& g = *GImGui;

  // Clip
  ImRect rect_clipped( r_min, r_max );
  if( clip )
    rect_clipped.ClipWith( g.CurrentWindow->ClipRect );

  // Expand for touch input
  const ImRect rect_for_touch( rect_clipped.Min - g.Style.TouchExtraPadding, rect_clipped.Max + g.Style.TouchExtraPadding );
  if( !rect_for_touch.Contains( g.IO.MousePos ) )
    return false;
  return true;
}

int ImGui::GetKeyIndex( ImGuiKey imgui_key )
{
  IM_ASSERT( imgui_key >= 0 && imgui_key < ImGuiKey_COUNT );
  ImGuiContext& g = *GImGui;
  return g.IO.KeyMap[ imgui_key ];
}

// Note that dear imgui doesn't know the semantic of each entry of io.KeysDown[]!
// Use your own indices/enums according to how your back-end/engine stored them into io.KeysDown[]!
bool ImGui::IsKeyDown( int user_key_index )
{
  if( user_key_index < 0 )
    return false;
  ImGuiContext& g = *GImGui;
  IM_ASSERT( user_key_index >= 0 && user_key_index < IM_ARRAYSIZE( g.IO.KeysDown ) );
  return g.IO.KeysDown[ user_key_index ];
}

// t0 = previous time (e.g.: g.Time - g.IO.DeltaTime)
// t1 = current time (e.g.: g.Time)
// An event is triggered at:
//  t = 0.0f     t = repeat_delay,    t = repeat_delay + repeat_rate*N
int ImGui::CalcTypematicRepeatAmount( float t0, float t1, float repeat_delay, float repeat_rate )
{
  if( t1 == 0.0f )
    return 1;
  if( t0 >= t1 )
    return 0;
  if( repeat_rate <= 0.0f )
    return ( t0 < repeat_delay ) && ( t1 >= repeat_delay );
  const int count_t0 = ( t0 < repeat_delay ) ? -1 : ( int )( ( t0 - repeat_delay ) / repeat_rate );
  const int count_t1 = ( t1 < repeat_delay ) ? -1 : ( int )( ( t1 - repeat_delay ) / repeat_rate );
  const int count = count_t1 - count_t0;
  return count;
}

int ImGui::GetKeyPressedAmount( int key_index, float repeat_delay, float repeat_rate )
{
  ImGuiContext& g = *GImGui;
  if( key_index < 0 )
    return 0;
  IM_ASSERT( key_index >= 0 && key_index < IM_ARRAYSIZE( g.IO.KeysDown ) );
  const float t = g.IO.KeysDownDuration[ key_index ];
  return CalcTypematicRepeatAmount( t - g.IO.DeltaTime, t, repeat_delay, repeat_rate );
}

bool ImGui::IsKeyPressed( int user_key_index, bool repeat )
{
  ImGuiContext& g = *GImGui;
  if( user_key_index < 0 )
    return false;
  IM_ASSERT( user_key_index >= 0 && user_key_index < IM_ARRAYSIZE( g.IO.KeysDown ) );
  const float t = g.IO.KeysDownDuration[ user_key_index ];
  if( t == 0.0f )
    return true;
  if( repeat && t > g.IO.KeyRepeatDelay )
    return GetKeyPressedAmount( user_key_index, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate ) > 0;
  return false;
}

bool ImGui::IsKeyReleased( int user_key_index )
{
  ImGuiContext& g = *GImGui;
  if( user_key_index < 0 ) return false;
  IM_ASSERT( user_key_index >= 0 && user_key_index < IM_ARRAYSIZE( g.IO.KeysDown ) );
  return g.IO.KeysDownDurationPrev[ user_key_index ] >= 0.0f && !g.IO.KeysDown[ user_key_index ];
}

bool ImGui::IsMouseDown( ImGuiMouseButton button )
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( button >= 0 && button < IM_ARRAYSIZE( g.IO.MouseDown ) );
  return g.IO.MouseDown[ button ];
}

bool ImGui::IsMouseClicked( ImGuiMouseButton button, bool repeat )
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( button >= 0 && button < IM_ARRAYSIZE( g.IO.MouseDown ) );
  const float t = g.IO.MouseDownDuration[ button ];
  if( t == 0.0f )
    return true;

  if( repeat && t > g.IO.KeyRepeatDelay )
  {
    // FIXME: 2019/05/03: Our old repeat code was wrong here and led to doubling the repeat rate, which made it an ok rate for repeat on mouse hold.
    int amount = CalcTypematicRepeatAmount( t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate * 0.50f );
    if( amount > 0 )
      return true;
  }
  return false;
}

bool ImGui::IsMouseReleased( ImGuiMouseButton button )
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( button >= 0 && button < IM_ARRAYSIZE( g.IO.MouseDown ) );
  return g.IO.MouseReleased[ button ];
}

bool ImGui::IsMouseDoubleClicked( ImGuiMouseButton button )
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( button >= 0 && button < IM_ARRAYSIZE( g.IO.MouseDown ) );
  return g.IO.MouseDoubleClicked[ button ];
}

// [Internal] This doesn't test if the button is pressed
bool ImGui::IsMouseDragPastThreshold( ImGuiMouseButton button, float lock_threshold )
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( button >= 0 && button < IM_ARRAYSIZE( g.IO.MouseDown ) );
  if( lock_threshold < 0.0f )
    lock_threshold = g.IO.MouseDragThreshold;
  return g.IO.MouseDragMaxDistanceSqr[ button ] >= lock_threshold * lock_threshold;
}

bool ImGui::IsMouseDragging( ImGuiMouseButton button, float lock_threshold )
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( button >= 0 && button < IM_ARRAYSIZE( g.IO.MouseDown ) );
  if( !g.IO.MouseDown[ button ] )
    return false;
  return IsMouseDragPastThreshold( button, lock_threshold );
}

ImVec2 ImGui::GetMousePos()
{
  ImGuiContext& g = *GImGui;
  return g.IO.MousePos;
}

// NB: prefer to call right after BeginPopup(). At the time Selectable/MenuItem is activated, the popup is already closed!
ImVec2 ImGui::GetMousePosOnOpeningCurrentPopup()
{
  ImGuiContext& g = *GImGui;
  if( g.BeginPopupStack.Size > 0 )
    return g.OpenPopupStack[ g.BeginPopupStack.Size - 1 ].OpenMousePos;
  return g.IO.MousePos;
}

// We typically use ImVec2(-FLT_MAX,-FLT_MAX) to denote an invalid mouse position.
bool ImGui::IsMousePosValid( const ImVec2* mouse_pos )
{
  // The assert is only to silence a false-positive in XCode Static Analysis.
  // Because GImGui is not dereferenced in every code path, the static analyzer assume that it may be NULL (which it doesn't for other functions).
  IM_ASSERT( GImGui != NULL );
  const float MOUSE_INVALID = -256000.0f;
  ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;
  return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;
}

bool ImGui::IsAnyMouseDown()
{
  ImGuiContext& g = *GImGui;
  for( int n = 0; n < IM_ARRAYSIZE( g.IO.MouseDown ); n++ )
    if( g.IO.MouseDown[ n ] )
      return true;
  return false;
}

// Return the delta from the initial clicking position while the mouse button is clicked or was just released.
// This is locked and return 0.0f until the mouse moves past a distance threshold at least once.
// NB: This is only valid if IsMousePosValid(). Back-ends in theory should always keep mouse position valid when dragging even outside the client window.
ImVec2 ImGui::GetMouseDragDelta( ImGuiMouseButton button, float lock_threshold )
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( button >= 0 && button < IM_ARRAYSIZE( g.IO.MouseDown ) );
  if( lock_threshold < 0.0f )
    lock_threshold = g.IO.MouseDragThreshold;
  if( g.IO.MouseDown[ button ] || g.IO.MouseReleased[ button ] )
    if( g.IO.MouseDragMaxDistanceSqr[ button ] >= lock_threshold * lock_threshold )
      if( IsMousePosValid( &g.IO.MousePos ) && IsMousePosValid( &g.IO.MouseClickedPos[ button ] ) )
        return g.IO.MousePos - g.IO.MouseClickedPos[ button ];
  return ImVec2( 0.0f, 0.0f );
}

void ImGui::ResetMouseDragDelta( ImGuiMouseButton button )
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( button >= 0 && button < IM_ARRAYSIZE( g.IO.MouseDown ) );
  // NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr
  g.IO.MouseClickedPos[ button ] = g.IO.MousePos;
}

ImGuiMouseCursor ImGui::GetMouseCursor()
{
  return GImGui->MouseCursor;
}

void ImGui::SetMouseCursor( ImGuiMouseCursor cursor_type )
{
  GImGui->MouseCursor = cursor_type;
}

void ImGui::CaptureKeyboardFromApp( bool capture )
{
  GImGui->WantCaptureKeyboardNextFrame = capture ? 1 : 0;
}

void ImGui::CaptureMouseFromApp( bool capture )
{
  GImGui->WantCaptureMouseNextFrame = capture ? 1 : 0;
}

bool ImGui::IsItemActive()
{
  ImGuiContext& g = *GImGui;
  if( g.ActiveId )
  {
    ImGuiWindow* window = g.CurrentWindow;
    return g.ActiveId == window->DC.LastItemId;
  }
  return false;
}

bool ImGui::IsItemActivated()
{
  ImGuiContext& g = *GImGui;
  if( g.ActiveId )
  {
    ImGuiWindow* window = g.CurrentWindow;
    if( g.ActiveId == window->DC.LastItemId && g.ActiveIdPreviousFrame != window->DC.LastItemId )
      return true;
  }
  return false;
}

bool ImGui::IsItemDeactivated()
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  if( window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HasDeactivated )
    return ( window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_Deactivated ) != 0;
  return ( g.ActiveIdPreviousFrame == window->DC.LastItemId && g.ActiveIdPreviousFrame != 0 && g.ActiveId != window->DC.LastItemId );
}

bool ImGui::IsItemDeactivatedAfterEdit()
{
  ImGuiContext& g = *GImGui;
  return IsItemDeactivated() && ( g.ActiveIdPreviousFrameHasBeenEditedBefore || ( g.ActiveId == 0 && g.ActiveIdHasBeenEditedBefore ) );
}

bool ImGui::IsItemFocused()
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;

  if( g.NavId == 0 || g.NavDisableHighlight || g.NavId != window->DC.LastItemId )
    return false;
  return true;
}

bool ImGui::IsItemClicked( ImGuiMouseButton mouse_button )
{
  return IsMouseClicked( mouse_button ) && IsItemHovered( ImGuiHoveredFlags_None );
}

bool ImGui::IsItemToggledOpen()
{
  ImGuiContext& g = *GImGui;
  return ( g.CurrentWindow->DC.LastItemStatusFlags & ImGuiItemStatusFlags_ToggledOpen ) ? true : false;
}

bool ImGui::IsItemToggledSelection()
{
  ImGuiContext& g = *GImGui;
  return ( g.CurrentWindow->DC.LastItemStatusFlags & ImGuiItemStatusFlags_ToggledSelection ) ? true : false;
}

bool ImGui::IsAnyItemHovered()
{
  ImGuiContext& g = *GImGui;
  return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;
}

bool ImGui::IsAnyItemActive()
{
  ImGuiContext& g = *GImGui;
  return g.ActiveId != 0;
}

bool ImGui::IsAnyItemFocused()
{
  ImGuiContext& g = *GImGui;
  return g.NavId != 0 && !g.NavDisableHighlight;
}

bool ImGui::IsItemVisible()
{
  ImGuiWindow* window = GetCurrentWindowRead();
  return window->ClipRect.Overlaps( window->DC.LastItemRect );
}

bool ImGui::IsItemEdited()
{
  ImGuiWindow* window = GetCurrentWindowRead();
  return ( window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_Edited ) != 0;
}

// Allow last item to be overlapped by a subsequent item. Both may be activated during the same frame before the later one takes priority.
void ImGui::SetItemAllowOverlap()
{
  ImGuiContext& g = *GImGui;
  if( g.HoveredId == g.CurrentWindow->DC.LastItemId )
    g.HoveredIdAllowOverlap = true;
  if( g.ActiveId == g.CurrentWindow->DC.LastItemId )
    g.ActiveIdAllowOverlap = true;
}

ImVec2 ImGui::GetItemRectMin()
{
  ImGuiWindow* window = GetCurrentWindowRead();
  return window->DC.LastItemRect.Min;
}

ImVec2 ImGui::GetItemRectMax()
{
  ImGuiWindow* window = GetCurrentWindowRead();
  return window->DC.LastItemRect.Max;
}

ImVec2 ImGui::GetItemRectSize()
{
  ImGuiWindow* window = GetCurrentWindowRead();
  return window->DC.LastItemRect.GetSize();
}

static ImRect GetViewportRect()
{
  ImGuiContext& g = *GImGui;
  return ImRect( 0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y );
}

bool ImGui::BeginChildEx( const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* parent_window = g.CurrentWindow;

  flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_ChildWindow;
  flags |= ( parent_window->Flags & ImGuiWindowFlags_NoMove );  // Inherit the NoMove flag

  // Size
  const ImVec2 content_avail = GetContentRegionAvail();
  ImVec2 size = ImFloor( size_arg );
  const int auto_fit_axises = ( ( size.x == 0.0f ) ? ( 1 << ImGuiAxis_X ) : 0x00 ) | ( ( size.y == 0.0f ) ? ( 1 << ImGuiAxis_Y ) : 0x00 );
  if( size.x <= 0.0f )
    size.x = ImMax( content_avail.x + size.x, 4.0f ); // Arbitrary minimum child size (0.0f causing too much issues)
  if( size.y <= 0.0f )
    size.y = ImMax( content_avail.y + size.y, 4.0f );
  SetNextWindowSize( size );

  // Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(ImGuiID id) with a stable value.
  char title[ 256 ];
  if( name )
    ImFormatString( title, IM_ARRAYSIZE( title ), SECURE( "%s/%s_%08X" ), parent_window->Name, name, id );
  else
    ImFormatString( title, IM_ARRAYSIZE( title ), SECURE( "%s/%08X" ), parent_window->Name, id );

  const float backup_border_size = g.Style.ChildBorderSize;
  if( !border )
    g.Style.ChildBorderSize = 0.0f;
  bool ret = Begin( title, NULL, flags );
  g.Style.ChildBorderSize = backup_border_size;

  ImGuiWindow* child_window = g.CurrentWindow;
  child_window->ChildId = id;
  child_window->AutoFitChildAxises = ( ImS8 )auto_fit_axises;

  // Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.
  // While this is not really documented/defined, it seems that the expected thing to do.
  if( child_window->BeginCount == 1 )
    parent_window->DC.CursorPos = child_window->Pos;

  // Process navigation-in immediately so NavInit can run on first frame
  if( g.NavActivateId == id && !( flags & ImGuiWindowFlags_NavFlattened ) && ( child_window->DC.NavLayerActiveMask != 0 || child_window->DC.NavHasScroll ) )
  {
    FocusWindow( child_window );
    NavInitWindow( child_window, false );
    SetActiveID( id + 1, child_window ); // Steal ActiveId with a dummy id so that key-press won't activate child item
    g.ActiveIdSource = ImGuiInputSource_Nav;
  }
  return ret;
}

bool ImGui::BeginChild( const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags )
{
  ImGuiWindow* window = GetCurrentWindow();
  return BeginChildEx( str_id, window->GetID( str_id ), size_arg, border, extra_flags );
}

bool ImGui::BeginChild( ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags )
{
  IM_ASSERT( id != 0 );
  return BeginChildEx( NULL, id, size_arg, border, extra_flags );
}

void ImGui::EndChild()
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;

  IM_ASSERT( g.WithinEndChild == false );
  IM_ASSERT( window->Flags & ImGuiWindowFlags_ChildWindow );   // Mismatched BeginChild()/EndChild() calls

  g.WithinEndChild = true;
  if( window->BeginCount > 1 )
  {
    End();
  }
  else
  {
    ImVec2 sz = window->Size;
    if( window->AutoFitChildAxises & ( 1 << ImGuiAxis_X ) ) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f
      sz.x = ImMax( 4.0f, sz.x );
    if( window->AutoFitChildAxises & ( 1 << ImGuiAxis_Y ) )
      sz.y = ImMax( 4.0f, sz.y );
    End();

    ImGuiWindow* parent_window = g.CurrentWindow;
    ImRect bb( parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz );
    ItemSize( sz );
    if( ( window->DC.NavLayerActiveMask != 0 || window->DC.NavHasScroll ) && !( window->Flags & ImGuiWindowFlags_NavFlattened ) )
    {
      ItemAdd( bb, window->ChildId );
      RenderNavHighlight( bb, window->ChildId );

      // When browsing a window that has no activable items (scroll only) we keep a highlight on the child
      if( window->DC.NavLayerActiveMask == 0 && window == g.NavWindow )
        RenderNavHighlight( ImRect( bb.Min - ImVec2( 2, 2 ), bb.Max + ImVec2( 2, 2 ) ), g.NavId, ImGuiNavHighlightFlags_TypeThin );
    }
    else
    {
      // Not navigable into
      ItemAdd( bb, 0 );
    }
  }
  g.WithinEndChild = false;
}

// Helper to create a child window / scrolling region that looks like a normal widget frame.
bool ImGui::BeginChildFrame( ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags )
{
  ImGuiContext& g = *GImGui;
  const ImGuiStyle& style = g.Style;
  PushStyleColor( ImGuiCol_ChildBg, style.Colors[ ImGuiCol_FrameBg ] );
  PushStyleVar( ImGuiStyleVar_ChildRounding, style.FrameRounding );
  PushStyleVar( ImGuiStyleVar_ChildBorderSize, style.FrameBorderSize );
  PushStyleVar( ImGuiStyleVar_WindowPadding, style.FramePadding );
  bool ret = BeginChild( id, size, true, ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysUseWindowPadding | extra_flags );
  PopStyleVar( 3 );
  PopStyleColor();
  return ret;
}

void ImGui::EndChildFrame()
{
  EndChild();
}

static void SetWindowConditionAllowFlags( ImGuiWindow* window, ImGuiCond flags, bool enabled )
{
  window->SetWindowPosAllowFlags = enabled ? ( window->SetWindowPosAllowFlags | flags ) : ( window->SetWindowPosAllowFlags & ~flags );
  window->SetWindowSizeAllowFlags = enabled ? ( window->SetWindowSizeAllowFlags | flags ) : ( window->SetWindowSizeAllowFlags & ~flags );
  window->SetWindowCollapsedAllowFlags = enabled ? ( window->SetWindowCollapsedAllowFlags | flags ) : ( window->SetWindowCollapsedAllowFlags & ~flags );
}

ImGuiWindow* ImGui::FindWindowByID( ImGuiID id )
{
  ImGuiContext& g = *GImGui;
  return ( ImGuiWindow* )g.WindowsById.GetVoidPtr( id );
}

ImGuiWindow* ImGui::FindWindowByName( const char* name )
{
  ImGuiID id = ImHashStr( name );
  return FindWindowByID( id );
}

static ImGuiWindow* CreateNewWindow( const char* name, ImVec2 size, ImGuiWindowFlags flags )
{
  ImGuiContext& g = *GImGui;
  //IMGUI_DEBUG_LOG("CreateNewWindow '%s', flags = 0x%08X\n", name, flags);

  // Create window the first time
  ImGuiWindow* window = IM_NEW( ImGuiWindow )( &g, name );
  window->Flags = flags;
  g.WindowsById.SetVoidPtr( window->ID, window );

  // Default/arbitrary window position. Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
  window->Pos = ImVec2( 60, 60 );

  // User can disable loading and saving of settings. Tooltip and child windows also don't store settings.
  if( !( flags & ImGuiWindowFlags_NoSavedSettings ) )
    if( ImGuiWindowSettings* settings = ImGui::FindWindowSettings( window->ID ) )
    {
      // Retrieve settings from .ini file
      window->SettingsOffset = g.SettingsWindows.offset_from_ptr( settings );
      SetWindowConditionAllowFlags( window, ImGuiCond_FirstUseEver, false );
      window->Pos = ImVec2( settings->Pos.x, settings->Pos.y );
      window->Collapsed = settings->Collapsed;
      if( settings->Size.x > 0 && settings->Size.y > 0 )
        size = ImVec2( settings->Size.x, settings->Size.y );
    }
  window->Size = window->SizeFull = ImFloor( size );
  window->DC.CursorStartPos = window->DC.CursorMaxPos = window->Pos; // So first call to CalcContentSize() doesn't return crazy values

  if( ( flags & ImGuiWindowFlags_AlwaysAutoResize ) != 0 )
  {
    window->AutoFitFramesX = window->AutoFitFramesY = 2;
    window->AutoFitOnlyGrows = false;
  }
  else
  {
    if( window->Size.x <= 0.0f )
      window->AutoFitFramesX = 2;
    if( window->Size.y <= 0.0f )
      window->AutoFitFramesY = 2;
    window->AutoFitOnlyGrows = ( window->AutoFitFramesX > 0 ) || ( window->AutoFitFramesY > 0 );
  }

  g.WindowsFocusOrder.push_back( window );
  if( flags & ImGuiWindowFlags_NoBringToFrontOnFocus )
    g.Windows.push_front( window ); // Quite slow but rare and only once
  else
    g.Windows.push_back( window );
  return window;
}

static ImVec2 CalcWindowSizeAfterConstraint( ImGuiWindow* window, ImVec2 new_size )
{
  ImGuiContext& g = *GImGui;
  if( g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint )
  {
    // Using -1,-1 on either X/Y axis to preserve the current size.
    ImRect cr = g.NextWindowData.SizeConstraintRect;
    new_size.x = ( cr.Min.x >= 0 && cr.Max.x >= 0 ) ? ImClamp( new_size.x, cr.Min.x, cr.Max.x ) : window->SizeFull.x;
    new_size.y = ( cr.Min.y >= 0 && cr.Max.y >= 0 ) ? ImClamp( new_size.y, cr.Min.y, cr.Max.y ) : window->SizeFull.y;
    if( g.NextWindowData.SizeCallback )
    {
      ImGuiSizeCallbackData data;
      data.UserData = g.NextWindowData.SizeCallbackUserData;
      data.Pos = window->Pos;
      data.CurrentSize = window->SizeFull;
      data.DesiredSize = new_size;
      g.NextWindowData.SizeCallback( &data );
      new_size = data.DesiredSize;
    }
    new_size.x = IM_FLOOR( new_size.x );
    new_size.y = IM_FLOOR( new_size.y );
  }

  // Minimum size
  if( !( window->Flags & ( ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_AlwaysAutoResize ) ) )
  {
    ImGuiWindow* window_for_height = window;
    new_size = ImMax( new_size, g.Style.WindowMinSize );
    new_size.y = ImMax( new_size.y, window_for_height->TitleBarHeight() + window_for_height->MenuBarHeight() + ImMax( 0.0f, g.Style.WindowRounding - 1.0f ) ); // Reduce artifacts with very small windows
  }
  return new_size;
}

static ImVec2 CalcWindowContentSize( ImGuiWindow* window )
{
  if( window->Collapsed )
    if( window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 )
      return window->ContentSize;
  if( window->Hidden && window->HiddenFramesCannotSkipItems == 0 && window->HiddenFramesCanSkipItems > 0 )
    return window->ContentSize;

  ImVec2 sz;
  sz.x = IM_FLOOR( ( window->ContentSizeExplicit.x != 0.0f ) ? window->ContentSizeExplicit.x : window->DC.CursorMaxPos.x - window->DC.CursorStartPos.x );
  sz.y = IM_FLOOR( ( window->ContentSizeExplicit.y != 0.0f ) ? window->ContentSizeExplicit.y : window->DC.CursorMaxPos.y - window->DC.CursorStartPos.y );
  return sz;
}

static ImVec2 CalcWindowAutoFitSize( ImGuiWindow* window, const ImVec2& size_contents )
{
  ImGuiContext& g = *GImGui;
  ImGuiStyle& style = g.Style;
  ImVec2 size_decorations = ImVec2( 0.0f, window->TitleBarHeight() + window->MenuBarHeight() );
  ImVec2 size_pad = window->WindowPadding * 2.0f;
  ImVec2 size_desired = size_contents + size_pad + size_decorations;
  if( window->Flags & ImGuiWindowFlags_Tooltip )
  {
    // Tooltip always resize
    return size_desired;
  }
  else
  {
    // Maximum window size is determined by the viewport size or monitor size
    const bool is_popup = ( window->Flags & ImGuiWindowFlags_Popup ) != 0;
    const bool is_menu = ( window->Flags & ImGuiWindowFlags_ChildMenu ) != 0;
    ImVec2 size_min = style.WindowMinSize;
    if( is_popup || is_menu ) // Popups and menus bypass style.WindowMinSize by default, but we give then a non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)
      size_min = ImMin( size_min, ImVec2( 4.0f, 4.0f ) );
    ImVec2 size_auto_fit = ImClamp( size_desired, size_min, ImMax( size_min, g.IO.DisplaySize - style.DisplaySafeAreaPadding * 2.0f ) );

    // When the window cannot fit all contents (either because of constraints, either because screen is too small),
    // we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than ViewportSize-WindowPadding.
    ImVec2 size_auto_fit_after_constraint = CalcWindowSizeAfterConstraint( window, size_auto_fit );
    bool will_have_scrollbar_x = ( size_auto_fit_after_constraint.x - size_pad.x - size_decorations.x < size_contents.x && !( window->Flags& ImGuiWindowFlags_NoScrollbar ) && ( window->Flags& ImGuiWindowFlags_HorizontalScrollbar ) ) || ( window->Flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar );
    bool will_have_scrollbar_y = ( size_auto_fit_after_constraint.y - size_pad.y - size_decorations.y < size_contents.y && !( window->Flags& ImGuiWindowFlags_NoScrollbar ) ) || ( window->Flags & ImGuiWindowFlags_AlwaysVerticalScrollbar );
    if( will_have_scrollbar_x )
      size_auto_fit.y += style.ScrollbarSize;
    if( will_have_scrollbar_y )
      size_auto_fit.x += style.ScrollbarSize;
    return size_auto_fit;
  }
}

ImVec2 ImGui::CalcWindowExpectedSize( ImGuiWindow* window )
{
  ImVec2 size_contents = CalcWindowContentSize( window );
  ImVec2 size_auto_fit = CalcWindowAutoFitSize( window, size_contents );
  ImVec2 size_final = CalcWindowSizeAfterConstraint( window, size_auto_fit );
  return size_final;
}

static ImGuiCol GetWindowBgColorIdxFromFlags( ImGuiWindowFlags flags )
{
  if( flags & ( ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup ) )
    return ImGuiCol_PopupBg;
  if( flags & ImGuiWindowFlags_ChildWindow )
    return ImGuiCol_ChildBg;
  return ImGuiCol_WindowBg;
}

static void CalcResizePosSizeFromAnyCorner( ImGuiWindow* window, const ImVec2& corner_target, const ImVec2& corner_norm, ImVec2* out_pos, ImVec2* out_size )
{
  ImVec2 pos_min = ImLerp( corner_target, window->Pos, corner_norm );                // Expected window upper-left
  ImVec2 pos_max = ImLerp( window->Pos + window->Size, corner_target, corner_norm ); // Expected window lower-right
  ImVec2 size_expected = pos_max - pos_min;
  ImVec2 size_constrained = CalcWindowSizeAfterConstraint( window, size_expected );
  *out_pos = pos_min;
  if( corner_norm.x == 0.0f )
    out_pos->x -= ( size_constrained.x - size_expected.x );
  if( corner_norm.y == 0.0f )
    out_pos->y -= ( size_constrained.y - size_expected.y );
  *out_size = size_constrained;
}

struct ImGuiResizeGripDef
{
  ImVec2  CornerPosN;
  ImVec2  InnerDir;
  int     AngleMin12, AngleMax12;
};

static const ImGuiResizeGripDef resize_grip_def[ 4 ] =
{
    { ImVec2( 1,1 ), ImVec2( -1,-1 ), 0, 3 }, // Lower-right
    { ImVec2( 0,1 ), ImVec2( +1,-1 ), 3, 6 }, // Lower-left
    { ImVec2( 0,0 ), ImVec2( +1,+1 ), 6, 9 }, // Upper-left (Unused)
    { ImVec2( 1,0 ), ImVec2( -1,+1 ), 9,12 }, // Upper-right (Unused)
};

static ImRect GetResizeBorderRect( ImGuiWindow* window, int border_n, float perp_padding, float thickness )
{
  ImRect rect = window->Rect();
  if( thickness == 0.0f ) rect.Max -= ImVec2( 1, 1 );
  if( border_n == 0 ) return ImRect( rect.Min.x + perp_padding, rect.Min.y - thickness, rect.Max.x - perp_padding, rect.Min.y + thickness );      // Top
  if( border_n == 1 ) return ImRect( rect.Max.x - thickness, rect.Min.y + perp_padding, rect.Max.x + thickness, rect.Max.y - perp_padding );   // Right
  if( border_n == 2 ) return ImRect( rect.Min.x + perp_padding, rect.Max.y - thickness, rect.Max.x - perp_padding, rect.Max.y + thickness );      // Bottom
  if( border_n == 3 ) return ImRect( rect.Min.x - thickness, rect.Min.y + perp_padding, rect.Min.x + thickness, rect.Max.y - perp_padding );   // Left
  IM_ASSERT( 0 );
  return ImRect();
}

// 0..3: corners (Lower-right, Lower-left, Unused, Unused)
// 4..7: borders (Top, Right, Bottom, Left)
ImGuiID ImGui::GetWindowResizeID( ImGuiWindow* window, int n )
{
  IM_ASSERT( n >= 0 && n <= 7 );
  ImGuiID id = window->ID;
  id = ImHashStr( SECURE( "#RESIZE" ), 0, id );
  id = ImHashData( &n, sizeof( int ), id );
  return id;
}

// Handle resize for: Resize Grips, Borders, Gamepad
// Return true when using auto-fit (double click on resize grip)
static bool ImGui::UpdateWindowManualResize( ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[ 4 ] )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindowFlags flags = window->Flags;

  if( ( flags & ImGuiWindowFlags_NoResize ) || ( flags & ImGuiWindowFlags_AlwaysAutoResize ) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0 )
    return false;
  if( window->WasActive == false ) // Early out to avoid running this code for e.g. an hidden implicit/fallback Debug window.
    return false;

  bool ret_auto_fit = false;
  const int resize_border_count = g.IO.ConfigWindowsResizeFromEdges ? 4 : 0;
  const float grip_draw_size = IM_FLOOR( ImMax( g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f ) );
  const float grip_hover_inner_size = IM_FLOOR( grip_draw_size * 0.75f );
  const float grip_hover_outer_size = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS : 0.0f;

  ImVec2 pos_target( FLT_MAX, FLT_MAX );
  ImVec2 size_target( FLT_MAX, FLT_MAX );

  // Resize grips and borders are on layer 1
  window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
  window->DC.NavLayerCurrentMask = ( 1 << ImGuiNavLayer_Menu );

  // Manual resize grips
  PushID( SECURE( "#RESIZE" ) );
  for( int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++ )
  {
    const ImGuiResizeGripDef& grip = resize_grip_def[ resize_grip_n ];
    const ImVec2 corner = ImLerp( window->Pos, window->Pos + window->Size, grip.CornerPosN );

    // Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window
    ImRect resize_rect( corner - grip.InnerDir * grip_hover_outer_size, corner + grip.InnerDir * grip_hover_inner_size );
    if( resize_rect.Min.x > resize_rect.Max.x ) ImSwap( resize_rect.Min.x, resize_rect.Max.x );
    if( resize_rect.Min.y > resize_rect.Max.y ) ImSwap( resize_rect.Min.y, resize_rect.Max.y );
    bool hovered, held;
    ButtonBehavior( resize_rect, window->GetID( resize_grip_n ), &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus );
    //GetForegroundDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max, IM_COL32(255, 255, 0, 255));
    if( hovered || held )
      g.MouseCursor = ( resize_grip_n & 1 ) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;

    if( held && g.IO.MouseDoubleClicked[ 0 ] && resize_grip_n == 0 )
    {
      // Manual auto-fit when double-clicking
      size_target = CalcWindowSizeAfterConstraint( window, size_auto_fit );
      ret_auto_fit = true;
      ClearActiveID();
    }
    else if( held )
    {
      // Resize from any of the four corners
      // We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position
      ImVec2 corner_target = g.IO.MousePos - g.ActiveIdClickOffset + ImLerp( grip.InnerDir * grip_hover_outer_size, grip.InnerDir * -grip_hover_inner_size, grip.CornerPosN ); // Corner of the window corresponding to our corner grip
      CalcResizePosSizeFromAnyCorner( window, corner_target, grip.CornerPosN, &pos_target, &size_target );
    }
    if( resize_grip_n == 0 || held || hovered )
      resize_grip_col[ resize_grip_n ] = GetColorU32( held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip );
  }
  for( int border_n = 0; border_n < resize_border_count; border_n++ )
  {
    bool hovered, held;
    ImRect border_rect = GetResizeBorderRect( window, border_n, grip_hover_inner_size, WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS );
    ButtonBehavior( border_rect, window->GetID( border_n + 4 ), &hovered, &held, ImGuiButtonFlags_FlattenChildren );
    //GetForegroundDrawLists(window)->AddRect(border_rect.Min, border_rect.Max, IM_COL32(255, 255, 0, 255));
    if( ( hovered && g.HoveredIdTimer > WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER ) || held )
    {
      g.MouseCursor = ( border_n & 1 ) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS;
      if( held )
        *border_held = border_n;
    }
    if( held )
    {
      ImVec2 border_target = window->Pos;
      ImVec2 border_posn;
      if( border_n == 0 )
      {
        border_posn = ImVec2( 0, 0 ); border_target.y = ( g.IO.MousePos.y - g.ActiveIdClickOffset.y + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS );
      } // Top
      if( border_n == 1 )
      {
        border_posn = ImVec2( 1, 0 ); border_target.x = ( g.IO.MousePos.x - g.ActiveIdClickOffset.x + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS );
      } // Right
      if( border_n == 2 )
      {
        border_posn = ImVec2( 0, 1 ); border_target.y = ( g.IO.MousePos.y - g.ActiveIdClickOffset.y + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS );
      } // Bottom
      if( border_n == 3 )
      {
        border_posn = ImVec2( 0, 0 ); border_target.x = ( g.IO.MousePos.x - g.ActiveIdClickOffset.x + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS );
      } // Left
      CalcResizePosSizeFromAnyCorner( window, border_target, border_posn, &pos_target, &size_target );
    }
  }
  PopID();

  // Restore nav layer
  window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
  window->DC.NavLayerCurrentMask = ( 1 << ImGuiNavLayer_Main );

  // Navigation resize (keyboard/gamepad)
  if( g.NavWindowingTarget && g.NavWindowingTarget->RootWindow == window )
  {
    ImVec2 nav_resize_delta;
    if( g.NavInputSource == ImGuiInputSource_NavKeyboard && g.IO.KeyShift )
      nav_resize_delta = GetNavInputAmount2d( ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down );
    if( g.NavInputSource == ImGuiInputSource_NavGamepad )
      nav_resize_delta = GetNavInputAmount2d( ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_Down );
    if( nav_resize_delta.x != 0.0f || nav_resize_delta.y != 0.0f )
    {
      const float NAV_RESIZE_SPEED = 600.0f;
      nav_resize_delta *= ImFloor( NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin( g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y ) );
      g.NavWindowingToggleLayer = false;
      g.NavDisableMouseHover = true;
      resize_grip_col[ 0 ] = GetColorU32( ImGuiCol_ResizeGripActive );
      // FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.
      size_target = CalcWindowSizeAfterConstraint( window, window->SizeFull + nav_resize_delta );
    }
  }

  // Apply back modified position/size to window
  if( size_target.x != FLT_MAX )
  {
    window->SizeFull = size_target;
    MarkIniSettingsDirty( window );
  }
  if( pos_target.x != FLT_MAX )
  {
    window->Pos = ImFloor( pos_target );
    MarkIniSettingsDirty( window );
  }

  window->Size = window->SizeFull;
  return ret_auto_fit;
}

static inline void ClampWindowRect( ImGuiWindow* window, const ImRect& rect, const ImVec2& padding )
{
  ImGuiContext& g = *GImGui;
  ImVec2 size_for_clamping = ( g.IO.ConfigWindowsMoveFromTitleBarOnly && !( window->Flags & ImGuiWindowFlags_NoTitleBar ) ) ? ImVec2( window->Size.x, window->TitleBarHeight() ) : window->Size;
  window->Pos = ImMin( rect.Max - padding, ImMax( window->Pos + size_for_clamping, rect.Min + padding ) - size_for_clamping );
}

static void ImGui::RenderWindowOuterBorders( ImGuiWindow* window )
{
  ImGuiContext& g = *GImGui;
  float rounding = window->WindowRounding;
  float border_size = window->WindowBorderSize;
  if( border_size > 0.0f && !( window->Flags & ImGuiWindowFlags_NoBackground ) )
    window->DrawList->AddRect( window->Pos, window->Pos + window->Size, GetColorU32( ImGuiCol_Border ), rounding, ImDrawCornerFlags_All, border_size );

  int border_held = window->ResizeBorderHeld;
  if( border_held != -1 )
  {
    struct ImGuiResizeBorderDef
    {
      ImVec2 InnerDir;
      ImVec2 CornerPosN1, CornerPosN2;
      float  OuterAngle;
    };
    static const ImGuiResizeBorderDef resize_border_def[ 4 ] =
    {
        { ImVec2( 0,+1 ), ImVec2( 0,0 ), ImVec2( 1,0 ), IM_PI * 1.50f }, // Top
        { ImVec2( -1,0 ), ImVec2( 1,0 ), ImVec2( 1,1 ), IM_PI * 0.00f }, // Right
        { ImVec2( 0,-1 ), ImVec2( 1,1 ), ImVec2( 0,1 ), IM_PI * 0.50f }, // Bottom
        { ImVec2( +1,0 ), ImVec2( 0,1 ), ImVec2( 0,0 ), IM_PI * 1.00f }  // Left
    };
    const ImGuiResizeBorderDef& def = resize_border_def[ border_held ];
    ImRect border_r = GetResizeBorderRect( window, border_held, rounding, 0.0f );
    window->DrawList->PathArcTo( ImLerp( border_r.Min, border_r.Max, def.CornerPosN1 ) + ImVec2( 0.5f, 0.5f ) + def.InnerDir * rounding, rounding, def.OuterAngle - IM_PI * 0.25f, def.OuterAngle );
    window->DrawList->PathArcTo( ImLerp( border_r.Min, border_r.Max, def.CornerPosN2 ) + ImVec2( 0.5f, 0.5f ) + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + IM_PI * 0.25f );
    window->DrawList->PathStroke( GetColorU32( ImGuiCol_SeparatorActive ), false, ImMax( 2.0f, border_size ) ); // Thicker than usual
  }
  if( g.Style.FrameBorderSize > 0 && !( window->Flags & ImGuiWindowFlags_NoTitleBar ) )
  {
    float y = window->Pos.y + window->TitleBarHeight() - 1;
    window->DrawList->AddLine( ImVec2( window->Pos.x + border_size, y ), ImVec2( window->Pos.x + window->Size.x - border_size, y ), GetColorU32( ImGuiCol_Border ), g.Style.FrameBorderSize );
  }
}

// Draw background and borders
// Draw and handle scrollbars
void ImGui::RenderWindowDecorations( ImGuiWindow* window, const ImRect& title_bar_rect, bool title_bar_is_highlight, int resize_grip_count, const ImU32 resize_grip_col[ 4 ], float resize_grip_draw_size )
{
  ImGuiContext& g = *GImGui;
  ImGuiStyle& style = g.Style;
  ImGuiWindowFlags flags = window->Flags;

  // Ensure that ScrollBar doesn't read last frame's SkipItems
  window->SkipItems = false;

  // Draw window + handle manual resize
  // As we highlight the title bar when want_focus is set, multiple reappearing windows will have have their title bar highlighted on their reappearing frame.
  const float window_rounding = window->WindowRounding;
  const float window_border_size = window->WindowBorderSize;
  if( window->Collapsed )
  {
    // Title bar only
    float backup_border_size = style.FrameBorderSize;
    g.Style.FrameBorderSize = window->WindowBorderSize;
    ImU32 title_bar_col = GetColorU32( ( title_bar_is_highlight && !g.NavDisableHighlight ) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed );
    RenderFrame( title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding );
    g.Style.FrameBorderSize = backup_border_size;
  }
  else
  {
    // Window background
    if( !( flags & ImGuiWindowFlags_NoBackground ) )
    {
      ImU32 bg_col = GetColorU32( GetWindowBgColorIdxFromFlags( flags ) );
      bool override_alpha = false;
      float alpha = 1.0f;
      if( g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasBgAlpha )
      {
        alpha = g.NextWindowData.BgAlphaVal;
        override_alpha = true;
      }
      if( override_alpha )
        bg_col = ( bg_col & ~IM_COL32_A_MASK ) | ( IM_F32_TO_INT8_SAT( alpha ) << IM_COL32_A_SHIFT );
      window->DrawList->AddRectFilled( window->Pos + ImVec2( 0, window->TitleBarHeight() ), window->Pos + window->Size, bg_col, window_rounding, ( flags & ImGuiWindowFlags_NoTitleBar ) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Bot );
    }

    // Title bar
    if( !( flags & ImGuiWindowFlags_NoTitleBar ) )
    {
      ImU32 title_bar_col = GetColorU32( title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg );
      window->DrawList->AddRectFilled( title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawCornerFlags_Top );
    }

    // Menu bar
    if( flags & ImGuiWindowFlags_MenuBar )
    {
      ImRect menu_bar_rect = window->MenuBarRect();
      menu_bar_rect.ClipWith( window->Rect() );  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
      window->DrawList->AddRectFilled( menu_bar_rect.Min + ImVec2( window_border_size, 0 ), menu_bar_rect.Max - ImVec2( window_border_size, 0 ), GetColorU32( ImGuiCol_MenuBarBg ), ( flags & ImGuiWindowFlags_NoTitleBar ) ? window_rounding : 0.0f, ImDrawCornerFlags_Top );
      if( style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y )
        window->DrawList->AddLine( menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32( ImGuiCol_Border ), style.FrameBorderSize );
    }

    // Scrollbars
    if( window->ScrollbarX )
      Scrollbar( ImGuiAxis_X );
    if( window->ScrollbarY )
      Scrollbar( ImGuiAxis_Y );

    // Render resize grips (after their input handling so we don't have a frame of latency)
    if( !( flags & ImGuiWindowFlags_NoResize ) )
    {
      for( int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++ )
      {
        const ImGuiResizeGripDef& grip = resize_grip_def[ resize_grip_n ];
        const ImVec2 corner = ImLerp( window->Pos, window->Pos + window->Size, grip.CornerPosN );
        window->DrawList->PathLineTo( corner + grip.InnerDir * ( ( resize_grip_n & 1 ) ? ImVec2( window_border_size, resize_grip_draw_size ) : ImVec2( resize_grip_draw_size, window_border_size ) ) );
        window->DrawList->PathLineTo( corner + grip.InnerDir * ( ( resize_grip_n & 1 ) ? ImVec2( resize_grip_draw_size, window_border_size ) : ImVec2( window_border_size, resize_grip_draw_size ) ) );
        window->DrawList->PathArcToFast( ImVec2( corner.x + grip.InnerDir.x * ( window_rounding + window_border_size ), corner.y + grip.InnerDir.y * ( window_rounding + window_border_size ) ), window_rounding, grip.AngleMin12, grip.AngleMax12 );
        window->DrawList->PathFillConvex( resize_grip_col[ resize_grip_n ] );
      }
    }

    // Borders
    RenderWindowOuterBorders( window );
  }
}

// Render title text, collapse button, close button
void ImGui::RenderWindowTitleBarContents( ImGuiWindow* window, const ImRect& title_bar_rect, const char* name, bool* p_open )
{
  ImGuiContext& g = *GImGui;
  ImGuiStyle& style = g.Style;
  ImGuiWindowFlags flags = window->Flags;

  const bool has_close_button = ( p_open != NULL );
  const bool has_collapse_button = !( flags & ImGuiWindowFlags_NoCollapse ) && ( style.WindowMenuButtonPosition != ImGuiDir_None );

  // Close & Collapse button are on the Menu NavLayer and don't default focus (unless there's nothing else on that layer)
  const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;
  window->DC.ItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;
  window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
  window->DC.NavLayerCurrentMask = ( 1 << ImGuiNavLayer_Menu );

  // Layout buttons
  // FIXME: Would be nice to generalize the subtleties expressed here into reusable code.
  float pad_l = style.FramePadding.x;
  float pad_r = style.FramePadding.x;
  float button_sz = g.FontSize;
  ImVec2 close_button_pos;
  ImVec2 collapse_button_pos;
  if( has_close_button )
  {
    pad_r += button_sz;
    close_button_pos = ImVec2( title_bar_rect.Max.x - pad_r - style.FramePadding.x, title_bar_rect.Min.y );
  }
  if( has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Right )
  {
    pad_r += button_sz;
    collapse_button_pos = ImVec2( title_bar_rect.Max.x - pad_r - style.FramePadding.x, title_bar_rect.Min.y );
  }
  if( has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Left )
  {
    collapse_button_pos = ImVec2( title_bar_rect.Min.x + pad_l - style.FramePadding.x, title_bar_rect.Min.y );
    pad_l += button_sz;
  }

  // Collapse button (submitting first so it gets priority when choosing a navigation init fallback)
  if( has_collapse_button )
    if( CollapseButton( window->GetID( SECURE( "#COLLAPSE" ) ), collapse_button_pos ) )
      window->WantCollapseToggle = true; // Defer actual collapsing to next frame as we are too far in the Begin() function

// Close button
  if( has_close_button )
    if( CloseButton( window->GetID( SECURE( "#CLOSE" ) ), close_button_pos ) )
      *p_open = false;

  window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
  window->DC.NavLayerCurrentMask = ( 1 << ImGuiNavLayer_Main );
  window->DC.ItemFlags = item_flags_backup;

  // Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
  // FIXME: Refactor text alignment facilities along with RenderText helpers, this is WAY too much messy code..
  const char* UNSAVED_DOCUMENT_MARKER = SECURE( "*" );
  const float marker_size_x = ( flags & ImGuiWindowFlags_UnsavedDocument ) ? CalcTextSize( UNSAVED_DOCUMENT_MARKER, NULL, false ).x : 0.0f;
  const ImVec2 text_size = CalcTextSize( name, NULL, true ) + ImVec2( marker_size_x, 0.0f );

  // As a nice touch we try to ensure that centered title text doesn't get affected by visibility of Close/Collapse button,
  // while uncentered title text will still reach edges correct.
  if( pad_l > style.FramePadding.x )
    pad_l += g.Style.ItemInnerSpacing.x;
  if( pad_r > style.FramePadding.x )
    pad_r += g.Style.ItemInnerSpacing.x;
  if( style.WindowTitleAlign.x > 0.0f && style.WindowTitleAlign.x < 1.0f )
  {
    float centerness = ImSaturate( 1.0f - ImFabs( style.WindowTitleAlign.x - 0.5f ) * 2.0f ); // 0.0f on either edges, 1.0f on center
    float pad_extend = ImMin( ImMax( pad_l, pad_r ), title_bar_rect.GetWidth() - pad_l - pad_r - text_size.x );
    pad_l = ImMax( pad_l, pad_extend * centerness );
    pad_r = ImMax( pad_r, pad_extend * centerness );
  }

  ImRect layout_r( title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y, title_bar_rect.Max.x - pad_r, title_bar_rect.Max.y );
  ImRect clip_r( layout_r.Min.x, layout_r.Min.y, layout_r.Max.x + g.Style.ItemInnerSpacing.x, layout_r.Max.y );
  //if (g.IO.KeyCtrl) window->DrawList->AddRect(layout_r.Min, layout_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
  RenderTextClipped( layout_r.Min, layout_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_r );
  if( flags & ImGuiWindowFlags_UnsavedDocument )
  {
    ImVec2 marker_pos = ImVec2( ImMax( layout_r.Min.x, layout_r.Min.x + ( layout_r.GetWidth() - text_size.x ) * style.WindowTitleAlign.x ) + text_size.x, layout_r.Min.y ) + ImVec2( 2 - marker_size_x, 0.0f );
    ImVec2 off = ImVec2( 0.0f, IM_FLOOR( -g.FontSize * 0.25f ) );
    RenderTextClipped( marker_pos + off, layout_r.Max + off, UNSAVED_DOCUMENT_MARKER, NULL, NULL, ImVec2( 0, style.WindowTitleAlign.y ), &clip_r );
  }
}

void ImGui::UpdateWindowParentAndRootLinks( ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window )
{
  window->ParentWindow = parent_window;
  window->RootWindow = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;
  if( parent_window && ( flags & ImGuiWindowFlags_ChildWindow ) && !( flags & ImGuiWindowFlags_Tooltip ) )
    window->RootWindow = parent_window->RootWindow;
  if( parent_window && !( flags & ImGuiWindowFlags_Modal ) && ( flags & ( ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup ) ) )
    window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;
  while( window->RootWindowForNav->Flags & ImGuiWindowFlags_NavFlattened )
  {
    IM_ASSERT( window->RootWindowForNav->ParentWindow != NULL );
    window->RootWindowForNav = window->RootWindowForNav->ParentWindow;
  }
}

// Push a new Dear ImGui window to add widgets to.
// - A default window called "Debug" is automatically stacked at the beginning of every frame so you can use widgets without explicitly calling a Begin/End pair.
// - Begin/End can be called multiple times during the frame with the same window name to append content.
// - The window name is used as a unique identifier to preserve window information across frames (and save rudimentary information to the .ini file).
//   You can use the "##" or "###" markers to use the same label with different id, or same id with different label. See documentation at the top of this file.
// - Return false when window is collapsed, so you can early out in your code. You always need to call ImGui::End() even if false is returned.
// - Passing 'bool* p_open' displays a Close button on the upper-right corner of the window, the pointed value will be set to false when the button is pressed.
bool ImGui::Begin( const char* name, bool* p_open, ImGuiWindowFlags flags )
{
  ImGuiContext& g = *GImGui;
  const ImGuiStyle& style = g.Style;
  IM_ASSERT( name != NULL && name[ 0 ] != '\0' );     // Window name required
  IM_ASSERT( g.WithinFrameScope );                  // Forgot to call ImGui::NewFrame()
  IM_ASSERT( g.FrameCountEnded != g.FrameCount );   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet

  // Find or create
  ImGuiWindow* window = FindWindowByName( name );
  const bool window_just_created = ( window == NULL );
  if( window_just_created )
  {
    ImVec2 size_on_first_use = ( g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize ) ? g.NextWindowData.SizeVal : ImVec2( 0.0f, 0.0f ); // Any condition flag will do since we are creating a new window here.
    window = CreateNewWindow( name, size_on_first_use, flags );
  }

  // Automatically disable manual moving/resizing when NoInputs is set
  if( ( flags & ImGuiWindowFlags_NoInputs ) == ImGuiWindowFlags_NoInputs )
    flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;

  if( flags & ImGuiWindowFlags_NavFlattened )
    IM_ASSERT( flags & ImGuiWindowFlags_ChildWindow );

  const int current_frame = g.FrameCount;
  const bool first_begin_of_the_frame = ( window->LastFrameActive != current_frame );
  window->IsFallbackWindow = ( g.CurrentWindowStack.Size == 0 && g.WithinFrameScopeWithImplicitWindow );

  // Update the Appearing flag
  bool window_just_activated_by_user = ( window->LastFrameActive < current_frame - 1 );   // Not using !WasActive because the implicit "Debug" window would always toggle off->on
  const bool window_just_appearing_after_hidden_for_resize = ( window->HiddenFramesCannotSkipItems > 0 );
  if( flags & ImGuiWindowFlags_Popup )
  {
    ImGuiPopupData& popup_ref = g.OpenPopupStack[ g.BeginPopupStack.Size ];
    window_just_activated_by_user |= ( window->PopupId != popup_ref.PopupId ); // We recycle popups so treat window as activated if popup id changed
    window_just_activated_by_user |= ( window != popup_ref.Window );
  }
  window->Appearing = ( window_just_activated_by_user || window_just_appearing_after_hidden_for_resize );
  if( window->Appearing )
    SetWindowConditionAllowFlags( window, ImGuiCond_Appearing, true );

  // Update Flags, LastFrameActive, BeginOrderXXX fields
  if( first_begin_of_the_frame )
  {
    window->Flags = ( ImGuiWindowFlags )flags;
    window->LastFrameActive = current_frame;
    window->LastTimeActive = ( float )g.Time;
    window->BeginOrderWithinParent = 0;
    window->BeginOrderWithinContext = ( short )( g.WindowsActiveCount++ );
  }
  else
  {
    flags = window->Flags;
  }

  // Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
  ImGuiWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();
  ImGuiWindow* parent_window = first_begin_of_the_frame ? ( ( flags & ( ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup ) ) ? parent_window_in_stack : NULL ) : window->ParentWindow;
  IM_ASSERT( parent_window != NULL || !( flags & ImGuiWindowFlags_ChildWindow ) );

  // We allow window memory to be compacted so recreate the base stack when needed.
  if( window->IDStack.Size == 0 )
    window->IDStack.push_back( window->ID );

  // Add to stack
  // We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
  g.CurrentWindowStack.push_back( window );
  g.CurrentWindow = NULL;
  ErrorCheckBeginEndCompareStacksSize( window, true );
  if( flags & ImGuiWindowFlags_Popup )
  {
    ImGuiPopupData& popup_ref = g.OpenPopupStack[ g.BeginPopupStack.Size ];
    popup_ref.Window = window;
    g.BeginPopupStack.push_back( popup_ref );
    window->PopupId = popup_ref.PopupId;
  }

  if( window_just_appearing_after_hidden_for_resize && !( flags & ImGuiWindowFlags_ChildWindow ) )
    window->NavLastIds[ 0 ] = 0;

  // Update ->RootWindow and others pointers (before any possible call to FocusWindow)
  if( first_begin_of_the_frame )
    UpdateWindowParentAndRootLinks( window, flags, parent_window );

  // Process SetNextWindow***() calls
  // (FIXME: Consider splitting the HasXXX flags into X/Y components
  bool window_pos_set_by_api = false;
  bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
  if( g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos )
  {
    window_pos_set_by_api = ( window->SetWindowPosAllowFlags & g.NextWindowData.PosCond ) != 0;
    if( window_pos_set_by_api && ImLengthSqr( g.NextWindowData.PosPivotVal ) > 0.00001f )
    {
      // May be processed on the next frame if this is our first frame and we are measuring size
      // FIXME: Look into removing the branch so everything can go through this same code path for consistency.
      window->SetWindowPosVal = g.NextWindowData.PosVal;
      window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
      window->SetWindowPosAllowFlags &= ~( ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing );
    }
    else
    {
      SetWindowPos( window, g.NextWindowData.PosVal, g.NextWindowData.PosCond );
    }
  }
  if( g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize )
  {
    window_size_x_set_by_api = ( window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond ) != 0 && ( g.NextWindowData.SizeVal.x > 0.0f );
    window_size_y_set_by_api = ( window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond ) != 0 && ( g.NextWindowData.SizeVal.y > 0.0f );
    SetWindowSize( window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond );
  }
  if( g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasScroll )
  {
    if( g.NextWindowData.ScrollVal.x >= 0.0f )
    {
      window->ScrollTarget.x = g.NextWindowData.ScrollVal.x;
      window->ScrollTargetCenterRatio.x = 0.0f;
    }
    if( g.NextWindowData.ScrollVal.y >= 0.0f )
    {
      window->ScrollTarget.y = g.NextWindowData.ScrollVal.y;
      window->ScrollTargetCenterRatio.y = 0.0f;
    }
  }
  if( g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasContentSize )
    window->ContentSizeExplicit = g.NextWindowData.ContentSizeVal;
  else if( first_begin_of_the_frame )
    window->ContentSizeExplicit = ImVec2( 0.0f, 0.0f );
  if( g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasCollapsed )
    SetWindowCollapsed( window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond );
  if( g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasFocus )
    FocusWindow( window );
  if( window->Appearing )
    SetWindowConditionAllowFlags( window, ImGuiCond_Appearing, false );

  // When reusing window again multiple times a frame, just append content (don't need to setup again)
  if( first_begin_of_the_frame )
  {
    // Initialize
    const bool window_is_child_tooltip = ( flags & ImGuiWindowFlags_ChildWindow ) && ( flags & ImGuiWindowFlags_Tooltip ); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
    window->Active = true;
    window->HasCloseButton = ( p_open != NULL );
    window->ClipRect = ImVec4( -FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX );
    window->IDStack.resize( 1 );

    // Restore buffer capacity when woken from a compacted state, to avoid
    if( window->MemoryCompacted )
      GcAwakeTransientWindowBuffers( window );

    // Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
    // The title bar always display the 'name' parameter, so we only update the string storage if it needs to be visible to the end-user elsewhere.
    bool window_title_visible_elsewhere = false;
    if( g.NavWindowingList != NULL && ( window->Flags & ImGuiWindowFlags_NoNavFocus ) == 0 )   // Window titles visible when using CTRL+TAB
      window_title_visible_elsewhere = true;
    if( window_title_visible_elsewhere && !window_just_created && strcmp( name, window->Name ) != 0 )
    {
      size_t buf_len = ( size_t )window->NameBufLen;
      window->Name = ImStrdupcpy( window->Name, &buf_len, name );
      window->NameBufLen = ( int )buf_len;
    }

    // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

    // Update contents size from last frame for auto-fitting (or use explicit size)
    window->ContentSize = CalcWindowContentSize( window );
    if( window->HiddenFramesCanSkipItems > 0 )
      window->HiddenFramesCanSkipItems--;
    if( window->HiddenFramesCannotSkipItems > 0 )
      window->HiddenFramesCannotSkipItems--;

    // Hide new windows for one frame until they calculate their size
    if( window_just_created && ( !window_size_x_set_by_api || !window_size_y_set_by_api ) )
      window->HiddenFramesCannotSkipItems = 1;

    // Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
    // We reset Size/ContentSize for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
    if( window_just_activated_by_user && ( flags & ( ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip ) ) != 0 )
    {
      window->HiddenFramesCannotSkipItems = 1;
      if( flags & ImGuiWindowFlags_AlwaysAutoResize )
      {
        if( !window_size_x_set_by_api )
          window->Size.x = window->SizeFull.x = 0.f;
        if( !window_size_y_set_by_api )
          window->Size.y = window->SizeFull.y = 0.f;
        window->ContentSize = ImVec2( 0.f, 0.f );
      }
    }

    // SELECT VIEWPORT
    // FIXME-VIEWPORT: In the docking/viewport branch, this is the point where we select the current viewport (which may affect the style)
    SetCurrentWindow( window );

    // LOCK BORDER SIZE AND PADDING FOR THE FRAME (so that altering them doesn't cause inconsistencies)

    if( flags & ImGuiWindowFlags_ChildWindow )
      window->WindowBorderSize = style.ChildBorderSize;
    else
      window->WindowBorderSize = ( ( flags & ( ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip ) ) && !( flags & ImGuiWindowFlags_Modal ) ) ? style.PopupBorderSize : style.WindowBorderSize;
    window->WindowPadding = style.WindowPadding;
    if( ( flags & ImGuiWindowFlags_ChildWindow ) && !( flags & ( ImGuiWindowFlags_AlwaysUseWindowPadding | ImGuiWindowFlags_Popup ) ) && window->WindowBorderSize == 0.0f )
      window->WindowPadding = ImVec2( 0.0f, ( flags & ImGuiWindowFlags_MenuBar ) ? style.WindowPadding.y : 0.0f );

    // Collapse window by double-clicking on title bar
    // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
    if( !( flags & ImGuiWindowFlags_NoTitleBar ) && !( flags & ImGuiWindowFlags_NoCollapse ) )
    {
      // We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
      ImRect title_bar_rect = window->TitleBarRect();
      if( g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect( title_bar_rect.Min, title_bar_rect.Max ) && g.IO.MouseDoubleClicked[ 0 ] )
        window->WantCollapseToggle = true;
      if( window->WantCollapseToggle )
      {
        window->Collapsed = !window->Collapsed;
        MarkIniSettingsDirty( window );
        FocusWindow( window );
      }
    }
    else
    {
      window->Collapsed = false;
    }
    window->WantCollapseToggle = false;

    // SIZE

    // Calculate auto-fit size, handle automatic resize
    const ImVec2 size_auto_fit = CalcWindowAutoFitSize( window, window->ContentSize );
    bool use_current_size_for_scrollbar_x = window_just_created;
    bool use_current_size_for_scrollbar_y = window_just_created;
    if( ( flags & ImGuiWindowFlags_AlwaysAutoResize ) && !window->Collapsed )
    {
      // Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
      if( !window_size_x_set_by_api )
      {
        window->SizeFull.x = size_auto_fit.x;
        use_current_size_for_scrollbar_x = true;
      }
      if( !window_size_y_set_by_api )
      {
        window->SizeFull.y = size_auto_fit.y;
        use_current_size_for_scrollbar_y = true;
      }
    }
    else if( window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0 )
    {
      // Auto-fit may only grow window during the first few frames
      // We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
      if( !window_size_x_set_by_api && window->AutoFitFramesX > 0 )
      {
        window->SizeFull.x = window->AutoFitOnlyGrows ? ImMax( window->SizeFull.x, size_auto_fit.x ) : size_auto_fit.x;
        use_current_size_for_scrollbar_x = true;
      }
      if( !window_size_y_set_by_api && window->AutoFitFramesY > 0 )
      {
        window->SizeFull.y = window->AutoFitOnlyGrows ? ImMax( window->SizeFull.y, size_auto_fit.y ) : size_auto_fit.y;
        use_current_size_for_scrollbar_y = true;
      }
      if( !window->Collapsed )
        MarkIniSettingsDirty( window );
    }

    // Apply minimum/maximum window size constraints and final size
    window->SizeFull = CalcWindowSizeAfterConstraint( window, window->SizeFull );
    window->Size = window->Collapsed && !( flags & ImGuiWindowFlags_ChildWindow ) ? window->TitleBarRect().GetSize() : window->SizeFull;

    // Decoration size
    const float decoration_up_height = window->TitleBarHeight() + window->MenuBarHeight();

    // POSITION

    // Popup latch its initial position, will position itself when it appears next frame
    if( window_just_activated_by_user )
    {
      window->AutoPosLastDirection = ImGuiDir_None;
      if( ( flags & ImGuiWindowFlags_Popup ) != 0 && !window_pos_set_by_api )
        window->Pos = g.BeginPopupStack.back().OpenPopupPos;
    }

    // Position child window
    if( flags & ImGuiWindowFlags_ChildWindow )
    {
      IM_ASSERT( parent_window && parent_window->Active );
      window->BeginOrderWithinParent = ( short )parent_window->DC.ChildWindows.Size;
      parent_window->DC.ChildWindows.push_back( window );
      if( !( flags & ImGuiWindowFlags_Popup ) && !window_pos_set_by_api && !window_is_child_tooltip )
        window->Pos = parent_window->DC.CursorPos;
    }

    const bool window_pos_with_pivot = ( window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0 );
    if( window_pos_with_pivot )
      SetWindowPos( window, window->SetWindowPosVal - window->SizeFull * window->SetWindowPosPivot, 0 ); // Position given a pivot (e.g. for centering)
    else if( ( flags & ImGuiWindowFlags_ChildMenu ) != 0 )
      window->Pos = FindBestWindowPosForPopup( window );
    else if( ( flags & ImGuiWindowFlags_Popup ) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize )
      window->Pos = FindBestWindowPosForPopup( window );
    else if( ( flags & ImGuiWindowFlags_Tooltip ) != 0 && !window_pos_set_by_api && !window_is_child_tooltip )
      window->Pos = FindBestWindowPosForPopup( window );

    // Clamp position/size so window stays visible within its viewport or monitor
    // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
    ImRect viewport_rect( GetViewportRect() );
    if( !window_pos_set_by_api && !( flags & ImGuiWindowFlags_ChildWindow ) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 )
    {
      ImVec2 clamp_padding = ImMax( style.DisplayWindowPadding, style.DisplaySafeAreaPadding );
      if( viewport_rect.GetWidth() > 0 && viewport_rect.GetHeight() > 0.0f )
      {
        ClampWindowRect( window, viewport_rect, clamp_padding );
      }
    }
    window->Pos = ImFloor( window->Pos );

    // Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
    window->WindowRounding = ( flags & ImGuiWindowFlags_ChildWindow ) ? style.ChildRounding : ( ( flags & ImGuiWindowFlags_Popup ) && !( flags & ImGuiWindowFlags_Modal ) ) ? style.PopupRounding : style.WindowRounding;

    // Apply window focus (new and reactivated windows are moved to front)
    bool want_focus = false;
    if( window_just_activated_by_user && !( flags & ImGuiWindowFlags_NoFocusOnAppearing ) )
    {
      if( flags & ImGuiWindowFlags_Popup )
        want_focus = true;
      else if( ( flags & ( ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Tooltip ) ) == 0 )
        want_focus = true;
    }

    // Handle manual resize: Resize Grips, Borders, Gamepad
    int border_held = -1;
    ImU32 resize_grip_col[ 4 ] = {};
    const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // Allow resize from lower-left if we have the mouse cursor feedback for it.
    const float resize_grip_draw_size = IM_FLOOR( ImMax( g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f ) );
    if( !window->Collapsed )
      if( UpdateWindowManualResize( window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[ 0 ] ) )
        use_current_size_for_scrollbar_x = use_current_size_for_scrollbar_y = true;
    window->ResizeBorderHeld = ( signed char )border_held;

    // SCROLLBAR VISIBILITY

    // Update scrollbar visibility (based on the Size that was effective during last frame or the auto-resized Size).
    if( !window->Collapsed )
    {
      // When reading the current size we need to read it after size constraints have been applied.
      // When we use InnerRect here we are intentionally reading last frame size, same for ScrollbarSizes values before we set them again.
      ImVec2 avail_size_from_current_frame = ImVec2( window->SizeFull.x, window->SizeFull.y - decoration_up_height );
      ImVec2 avail_size_from_last_frame = window->InnerRect.GetSize() + window->ScrollbarSizes;
      ImVec2 needed_size_from_last_frame = window_just_created ? ImVec2( 0, 0 ) : window->ContentSize + window->WindowPadding * 2.0f;
      float size_x_for_scrollbars = use_current_size_for_scrollbar_x ? avail_size_from_current_frame.x : avail_size_from_last_frame.x;
      float size_y_for_scrollbars = use_current_size_for_scrollbar_y ? avail_size_from_current_frame.y : avail_size_from_last_frame.y;
      //bool scrollbar_y_from_last_frame = window->ScrollbarY; // FIXME: May want to use that in the ScrollbarX expression? How many pros vs cons?
      window->ScrollbarY = ( flags & ImGuiWindowFlags_AlwaysVerticalScrollbar ) || ( ( needed_size_from_last_frame.y > size_y_for_scrollbars ) && !( flags & ImGuiWindowFlags_NoScrollbar ) );
      window->ScrollbarX = ( flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar ) || ( ( needed_size_from_last_frame.x > size_x_for_scrollbars - ( window->ScrollbarY ? style.ScrollbarSize : 0.0f ) ) && !( flags & ImGuiWindowFlags_NoScrollbar ) && ( flags & ImGuiWindowFlags_HorizontalScrollbar ) );
      if( window->ScrollbarX && !window->ScrollbarY )
        window->ScrollbarY = ( needed_size_from_last_frame.y > size_y_for_scrollbars ) && !( flags & ImGuiWindowFlags_NoScrollbar );
      window->ScrollbarSizes = ImVec2( window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f );
    }

    // UPDATE RECTANGLES (1- THOSE NOT AFFECTED BY SCROLLING)
    // Update various regions. Variables they depends on should be set above in this function.
    // We set this up after processing the resize grip so that our rectangles doesn't lag by a frame.

    // Outer rectangle
    // Not affected by window border size. Used by:
    // - FindHoveredWindow() (w/ extra padding when border resize is enabled)
    // - Begin() initial clipping rect for drawing window background and borders.
    // - Begin() clipping whole child
    const ImRect host_rect = ( ( flags & ImGuiWindowFlags_ChildWindow ) && !( flags & ImGuiWindowFlags_Popup ) && !window_is_child_tooltip ) ? parent_window->ClipRect : viewport_rect;
    const ImRect outer_rect = window->Rect();
    const ImRect title_bar_rect = window->TitleBarRect();
    window->OuterRectClipped = outer_rect;
    window->OuterRectClipped.ClipWith( host_rect );

    // Inner rectangle
    // Not affected by window border size. Used by:
    // - InnerClipRect
    // - ScrollToBringRectIntoView()
    // - NavUpdatePageUpPageDown()
    // - Scrollbar()
    window->InnerRect.Min.x = window->Pos.x;
    window->InnerRect.Min.y = window->Pos.y + decoration_up_height;
    window->InnerRect.Max.x = window->Pos.x + window->Size.x - window->ScrollbarSizes.x;
    window->InnerRect.Max.y = window->Pos.y + window->Size.y - window->ScrollbarSizes.y;

    // Inner clipping rectangle.
    // Will extend a little bit outside the normal work region.
    // This is to allow e.g. Selectable or CollapsingHeader or some separators to cover that space.
    // Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
    // Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
    // Affected by window/frame border size. Used by:
    // - Begin() initial clip rect
    float top_border_size = ( ( ( flags & ImGuiWindowFlags_MenuBar ) || !( flags & ImGuiWindowFlags_NoTitleBar ) ) ? style.FrameBorderSize : window->WindowBorderSize );
    window->InnerClipRect.Min.x = ImFloor( 0.5f + window->InnerRect.Min.x + ImMax( ImFloor( window->WindowPadding.x * 0.5f ), window->WindowBorderSize ) );
    window->InnerClipRect.Min.y = ImFloor( 0.5f + window->InnerRect.Min.y + top_border_size );
    window->InnerClipRect.Max.x = ImFloor( 0.5f + window->InnerRect.Max.x - ImMax( ImFloor( window->WindowPadding.x * 0.5f ), window->WindowBorderSize ) );
    window->InnerClipRect.Max.y = ImFloor( 0.5f + window->InnerRect.Max.y - window->WindowBorderSize );
    window->InnerClipRect.ClipWithFull( host_rect );

    // Default item width. Make it proportional to window size if window manually resizes
    if( window->Size.x > 0.0f && !( flags & ImGuiWindowFlags_Tooltip ) && !( flags & ImGuiWindowFlags_AlwaysAutoResize ) )
      window->ItemWidthDefault = ImFloor( window->Size.x * 0.65f );
    else
      window->ItemWidthDefault = ImFloor( g.FontSize * 16.0f );

    // SCROLLING

    // Lock down maximum scrolling
    // The value of ScrollMax are ahead from ScrollbarX/ScrollbarY which is intentionally using InnerRect from previous rect in order to accommodate
    // for right/bottom aligned items without creating a scrollbar.
    window->ScrollMax.x = ImMax( 0.0f, window->ContentSize.x + window->WindowPadding.x * 2.0f - window->InnerRect.GetWidth() );
    window->ScrollMax.y = ImMax( 0.0f, window->ContentSize.y + window->WindowPadding.y * 2.0f - window->InnerRect.GetHeight() );

    // Apply scrolling
    window->Scroll = CalcNextScrollFromScrollTargetAndClamp( window, true );
    window->ScrollTarget = ImVec2( FLT_MAX, FLT_MAX );

    // DRAWING

    // Setup draw list and outer clipping rectangle
    window->DrawList->Clear();
    window->DrawList->PushTextureID( g.Font->ContainerAtlas->TexID );
    PushClipRect( host_rect.Min, host_rect.Max, false );

    // Draw modal window background (darkens what is behind them, all viewports)
    const bool dim_bg_for_modal = ( flags & ImGuiWindowFlags_Modal ) && window == GetTopMostPopupModal() && window->HiddenFramesCannotSkipItems <= 0;
    const bool dim_bg_for_window_list = g.NavWindowingTargetAnim && ( window == g.NavWindowingTargetAnim->RootWindow );
    if( dim_bg_for_modal || dim_bg_for_window_list )
    {
      const ImU32 dim_bg_col = GetColorU32( dim_bg_for_modal ? ImGuiCol_ModalWindowDimBg : ImGuiCol_NavWindowingDimBg, g.DimBgRatio );
      window->DrawList->AddRectFilled( viewport_rect.Min, viewport_rect.Max, dim_bg_col );
    }

    // Draw navigation selection/windowing rectangle background
    if( dim_bg_for_window_list && window == g.NavWindowingTargetAnim )
    {
      ImRect bb = window->Rect();
      bb.Expand( g.FontSize );
      if( !bb.Contains( viewport_rect ) ) // Avoid drawing if the window covers all the viewport anyway
        window->DrawList->AddRectFilled( bb.Min, bb.Max, GetColorU32( ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha * 0.25f ), g.Style.WindowRounding );
    }

    // Since 1.71, child window can render their decoration (bg color, border, scrollbars, etc.) within their parent to save a draw call.
    // When using overlapping child windows, this will break the assumption that child z-order is mapped to submission order.
    // We disable this when the parent window has zero vertices, which is a common pattern leading to laying out multiple overlapping child.
    // We also disabled this when we have dimming overlay behind this specific one child.
    // FIXME: More code may rely on explicit sorting of overlapping child window and would need to disable this somehow. Please get in contact if you are affected.
    {
      bool render_decorations_in_parent = false;
      if( ( flags & ImGuiWindowFlags_ChildWindow ) && !( flags & ImGuiWindowFlags_Popup ) && !window_is_child_tooltip )
        if( window->DrawList->CmdBuffer.back().ElemCount == 0 && parent_window->DrawList->VtxBuffer.Size > 0 )
          render_decorations_in_parent = true;
      if( render_decorations_in_parent )
        window->DrawList = parent_window->DrawList;

      // Handle title bar, scrollbar, resize grips and resize borders
      const ImGuiWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
      const bool title_bar_is_highlight = want_focus || ( window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight );
      RenderWindowDecorations( window, title_bar_rect, title_bar_is_highlight, resize_grip_count, resize_grip_col, resize_grip_draw_size );

      if( render_decorations_in_parent )
        window->DrawList = &window->DrawListInst;
    }

    // Draw navigation selection/windowing rectangle border
    if( g.NavWindowingTargetAnim == window )
    {
      float rounding = ImMax( window->WindowRounding, g.Style.WindowRounding );
      ImRect bb = window->Rect();
      bb.Expand( g.FontSize );
      if( bb.Contains( viewport_rect ) ) // If a window fits the entire viewport, adjust its highlight inward
      {
        bb.Expand( -g.FontSize - 1.0f );
        rounding = window->WindowRounding;
      }
      window->DrawList->AddRect( bb.Min, bb.Max, GetColorU32( ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha ), rounding, ~0, 3.0f );
    }

    // UPDATE RECTANGLES (2- THOSE AFFECTED BY SCROLLING)

    // Work rectangle.
    // Affected by window padding and border size. Used by:
    // - Columns() for right-most edge
    // - TreeNode(), CollapsingHeader() for right-most edge
    // - BeginTabBar() for right-most edge
    const bool allow_scrollbar_x = !( flags & ImGuiWindowFlags_NoScrollbar ) && ( flags & ImGuiWindowFlags_HorizontalScrollbar );
    const bool allow_scrollbar_y = !( flags & ImGuiWindowFlags_NoScrollbar );
    const float work_rect_size_x = ( window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : ImMax( allow_scrollbar_x ? window->ContentSize.x : 0.0f, window->Size.x - window->WindowPadding.x * 2.0f - window->ScrollbarSizes.x ) );
    const float work_rect_size_y = ( window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : ImMax( allow_scrollbar_y ? window->ContentSize.y : 0.0f, window->Size.y - window->WindowPadding.y * 2.0f - decoration_up_height - window->ScrollbarSizes.y ) );
    window->WorkRect.Min.x = ImFloor( window->InnerRect.Min.x - window->Scroll.x + ImMax( window->WindowPadding.x, window->WindowBorderSize ) );
    window->WorkRect.Min.y = ImFloor( window->InnerRect.Min.y - window->Scroll.y + ImMax( window->WindowPadding.y, window->WindowBorderSize ) );
    window->WorkRect.Max.x = window->WorkRect.Min.x + work_rect_size_x;
    window->WorkRect.Max.y = window->WorkRect.Min.y + work_rect_size_y;

    // [LEGACY] Content Region
    // FIXME-OBSOLETE: window->ContentRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
    // Used by:
    // - Mouse wheel scrolling + many other things
    window->ContentRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x;
    window->ContentRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + decoration_up_height;
    window->ContentRegionRect.Max.x = window->ContentRegionRect.Min.x + ( window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : ( window->Size.x - window->WindowPadding.x * 2.0f - window->ScrollbarSizes.x ) );
    window->ContentRegionRect.Max.y = window->ContentRegionRect.Min.y + ( window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : ( window->Size.y - window->WindowPadding.y * 2.0f - decoration_up_height - window->ScrollbarSizes.y ) );

    // Setup drawing context
    // (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
    window->DC.Indent.x = 0.0f + window->WindowPadding.x - window->Scroll.x;
    window->DC.GroupOffset.x = 0.0f;
    window->DC.ColumnsOffset.x = 0.0f;
    window->DC.CursorStartPos = window->Pos + ImVec2( window->DC.Indent.x + window->DC.ColumnsOffset.x, decoration_up_height + window->WindowPadding.y - window->Scroll.y );
    window->DC.CursorPos = window->DC.CursorStartPos;
    window->DC.CursorPosPrevLine = window->DC.CursorPos;
    window->DC.CursorMaxPos = window->DC.CursorStartPos;
    window->DC.CurrLineSize = window->DC.PrevLineSize = ImVec2( 0.0f, 0.0f );
    window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;

    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
    window->DC.NavLayerCurrentMask = ( 1 << ImGuiNavLayer_Main );
    window->DC.NavLayerActiveMask = window->DC.NavLayerActiveMaskNext;
    window->DC.NavLayerActiveMaskNext = 0x00;
    window->DC.NavFocusScopeIdCurrent = ( flags & ImGuiWindowFlags_ChildWindow ) ? parent_window->DC.NavFocusScopeIdCurrent : 0; // -V595
    window->DC.NavHideHighlightOneFrame = false;
    window->DC.NavHasScroll = ( window->ScrollMax.y > 0.0f );

    window->DC.MenuBarAppending = false;
    window->DC.MenuBarOffset.x = ImMax( ImMax( window->WindowPadding.x, style.ItemSpacing.x ), g.NextWindowData.MenuBarOffsetMinVal.x );
    window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;
    window->DC.MenuColumns.Update( 3, style.ItemSpacing.x, window_just_activated_by_user );
    window->DC.TreeDepth = 0;
    window->DC.TreeJumpToParentOnPopMask = 0x00;
    window->DC.ChildWindows.resize( 0 );
    window->DC.StateStorage = &window->StateStorage;
    window->DC.CurrentColumns = NULL;
    window->DC.LayoutType = ImGuiLayoutType_Vertical;
    window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;
    window->DC.FocusCounterRegular = window->DC.FocusCounterTabStop = -1;

    window->DC.ItemWidth = window->ItemWidthDefault;
    window->DC.TextWrapPos = -1.0f; // disabled
    window->DC.ItemFlagsStack.resize( 0 );
    window->DC.ItemWidthStack.resize( 0 );
    window->DC.TextWrapPosStack.resize( 0 );
    window->DC.GroupStack.resize( 0 );
    window->DC.ItemFlags = parent_window ? parent_window->DC.ItemFlags : ImGuiItemFlags_Default_;
    if( parent_window )
      window->DC.ItemFlagsStack.push_back( window->DC.ItemFlags );

    if( window->AutoFitFramesX > 0 )
      window->AutoFitFramesX--;
    if( window->AutoFitFramesY > 0 )
      window->AutoFitFramesY--;

    // Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
    if( want_focus )
    {
      FocusWindow( window );
      NavInitWindow( window, false );
    }

    // Title bar
    if( !( flags & ImGuiWindowFlags_NoTitleBar ) )
      RenderWindowTitleBarContents( window, title_bar_rect, name, p_open );

    // Pressing CTRL+C while holding on a window copy its content to the clipboard
    // This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
    // Maybe we can support CTRL+C on every element?
    /*
    if (g.ActiveId == move_id)
        if (g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_C))
            LogToClipboard();
    */

    // We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
    // This is useful to allow creating context menus on title bar only, etc.
    window->DC.LastItemId = window->MoveId;
    window->DC.LastItemStatusFlags = IsMouseHoveringRect( title_bar_rect.Min, title_bar_rect.Max, false ) ? ImGuiItemStatusFlags_HoveredRect : 0;
    window->DC.LastItemRect = title_bar_rect;
#ifdef IMGUI_ENABLE_TEST_ENGINE
    if( !( window->Flags & ImGuiWindowFlags_NoTitleBar ) )
      IMGUI_TEST_ENGINE_ITEM_ADD( window->DC.LastItemRect, window->DC.LastItemId );
#endif
  }
  else
  {
    // Append
    SetCurrentWindow( window );
  }

  PushClipRect( window->InnerClipRect.Min, window->InnerClipRect.Max, true );

  // Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
  if( first_begin_of_the_frame )
    window->WriteAccessed = false;

  window->BeginCount++;
  g.NextWindowData.ClearFlags();

  if( flags & ImGuiWindowFlags_ChildWindow )
  {
    // Child window can be out of sight and have "negative" clip windows.
    // Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
    IM_ASSERT( ( flags & ImGuiWindowFlags_NoTitleBar ) != 0 );
    if( !( flags & ImGuiWindowFlags_AlwaysAutoResize ) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 )
      if( window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y )
        window->HiddenFramesCanSkipItems = 1;

    // Hide along with parent or if parent is collapsed
    if( parent_window && ( parent_window->Collapsed || parent_window->HiddenFramesCanSkipItems > 0 ) )
      window->HiddenFramesCanSkipItems = 1;
    if( parent_window && ( parent_window->Collapsed || parent_window->HiddenFramesCannotSkipItems > 0 ) )
      window->HiddenFramesCannotSkipItems = 1;
  }

  // Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
  if( style.Alpha <= 0.0f )
    window->HiddenFramesCanSkipItems = 1;

  // Update the Hidden flag
  window->Hidden = ( window->HiddenFramesCanSkipItems > 0 ) || ( window->HiddenFramesCannotSkipItems > 0 );

  // Update the SkipItems flag, used to early out of all items functions (no layout required)
  bool skip_items = false;
  if( window->Collapsed || !window->Active || window->Hidden )
    if( window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0 )
      skip_items = true;
  window->SkipItems = skip_items;

  return !skip_items;
}

void ImGui::End()
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;

  // Error checking: verify that user hasn't called End() too many times!
  if( g.CurrentWindowStack.Size <= 1 && g.WithinFrameScopeWithImplicitWindow )
  {
    IM_ASSERT_USER_ERROR( g.CurrentWindowStack.Size > 1, "Calling End() too many times!" );
    return;
  }
  IM_ASSERT( g.CurrentWindowStack.Size > 0 );

  // Error checking: verify that user doesn't directly call End() on a child window.
  if( window->Flags & ImGuiWindowFlags_ChildWindow )
    IM_ASSERT_USER_ERROR( g.WithinEndChild, "Must call EndChild() and not End()!" );

  // Close anything that is open
  if( window->DC.CurrentColumns )
    EndColumns();
  PopClipRect();   // Inner window clip rectangle

  // Stop logging
  if( !( window->Flags & ImGuiWindowFlags_ChildWindow ) )    // FIXME: add more options for scope of logging
    LogFinish();

  // Pop from window stack
  g.CurrentWindowStack.pop_back();
  if( window->Flags & ImGuiWindowFlags_Popup )
    g.BeginPopupStack.pop_back();
  ErrorCheckBeginEndCompareStacksSize( window, false );
  SetCurrentWindow( g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back() );
}

void ImGui::BringWindowToFocusFront( ImGuiWindow* window )
{
  ImGuiContext& g = *GImGui;
  if( g.WindowsFocusOrder.back() == window )
    return;
  for( int i = g.WindowsFocusOrder.Size - 2; i >= 0; i-- ) // We can ignore the top-most window
    if( g.WindowsFocusOrder[ i ] == window )
    {
      memmove( &g.WindowsFocusOrder[ i ], &g.WindowsFocusOrder[ i + 1 ], ( size_t )( g.WindowsFocusOrder.Size - i - 1 ) * sizeof( ImGuiWindow* ) );
      g.WindowsFocusOrder[ g.WindowsFocusOrder.Size - 1 ] = window;
      break;
    }
}

void ImGui::BringWindowToDisplayFront( ImGuiWindow* window )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* current_front_window = g.Windows.back();
  if( current_front_window == window || current_front_window->RootWindow == window )
    return;
  for( int i = g.Windows.Size - 2; i >= 0; i-- ) // We can ignore the top-most window
    if( g.Windows[ i ] == window )
    {
      memmove( &g.Windows[ i ], &g.Windows[ i + 1 ], ( size_t )( g.Windows.Size - i - 1 ) * sizeof( ImGuiWindow* ) );
      g.Windows[ g.Windows.Size - 1 ] = window;
      break;
    }
}

void ImGui::BringWindowToDisplayBack( ImGuiWindow* window )
{
  ImGuiContext& g = *GImGui;
  if( g.Windows[ 0 ] == window )
    return;
  for( int i = 0; i < g.Windows.Size; i++ )
    if( g.Windows[ i ] == window )
    {
      memmove( &g.Windows[ 1 ], &g.Windows[ 0 ], ( size_t )i * sizeof( ImGuiWindow* ) );
      g.Windows[ 0 ] = window;
      break;
    }
}

// Moving window to front of display and set focus (which happens to be back of our sorted list)
void ImGui::FocusWindow( ImGuiWindow* window )
{
  ImGuiContext& g = *GImGui;

  if( g.NavWindow != window )
  {
    g.NavWindow = window;
    if( window && g.NavDisableMouseHover )
      g.NavMousePosDirty = true;
    g.NavInitRequest = false;
    g.NavId = window ? window->NavLastIds[ 0 ] : 0; // Restore NavId
    g.NavFocusScopeId = 0;
    g.NavIdIsAlive = false;
    g.NavLayer = ImGuiNavLayer_Main;
    //IMGUI_DEBUG_LOG("FocusWindow(\"%s\")\n", window ? window->Name : NULL);
  }

  // Close popups if any
  ClosePopupsOverWindow( window, false );

  // Passing NULL allow to disable keyboard focus
  if( !window )
    return;

  // Move the root window to the top of the pile
  IM_ASSERT( window->RootWindow != NULL );
  ImGuiWindow* focus_front_window = window->RootWindow; // NB: In docking branch this is window->RootWindowDockStop
  ImGuiWindow* display_front_window = window->RootWindow;

  // Steal focus on active widgets
  if( focus_front_window->Flags & ImGuiWindowFlags_Popup ) // FIXME: This statement may be unnecessary? Need further testing before removing it..
    if( g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != focus_front_window )
      ClearActiveID();

  // Bring to front
  BringWindowToFocusFront( focus_front_window );
  if( ( ( window->Flags | display_front_window->Flags ) & ImGuiWindowFlags_NoBringToFrontOnFocus ) == 0 )
    BringWindowToDisplayFront( display_front_window );
}

void ImGui::FocusTopMostWindowUnderOne( ImGuiWindow* under_this_window, ImGuiWindow* ignore_window )
{
  ImGuiContext& g = *GImGui;

  int start_idx = g.WindowsFocusOrder.Size - 1;
  if( under_this_window != NULL )
  {
    int under_this_window_idx = FindWindowFocusIndex( under_this_window );
    if( under_this_window_idx != -1 )
      start_idx = under_this_window_idx - 1;
  }
  for( int i = start_idx; i >= 0; i-- )
  {
    // We may later decide to test for different NoXXXInputs based on the active navigation input (mouse vs nav) but that may feel more confusing to the user.
    ImGuiWindow* window = g.WindowsFocusOrder[ i ];
    if( window != ignore_window && window->WasActive && !( window->Flags & ImGuiWindowFlags_ChildWindow ) )
      if( ( window->Flags & ( ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs ) ) != ( ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs ) )
      {
        ImGuiWindow* focus_window = NavRestoreLastChildNavWindow( window );
        FocusWindow( focus_window );
        return;
      }
  }
  FocusWindow( NULL );
}

void ImGui::SetCurrentFont( ImFont* font )
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( font && font->IsLoaded() );    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
  IM_ASSERT( font->Scale > 0.0f );
  g.Font = font;
  g.FontBaseSize = ImMax( 1.0f, g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale );
  g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;

  ImFontAtlas* atlas = g.Font->ContainerAtlas;
  g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;
  g.DrawListSharedData.Font = g.Font;
  g.DrawListSharedData.FontSize = g.FontSize;
}

void ImGui::PushFont( ImFont* font )
{
  ImGuiContext& g = *GImGui;
  if( !font )
    font = GetDefaultFont();
  SetCurrentFont( font );
  g.FontStack.push_back( font );
  g.CurrentWindow->DrawList->PushTextureID( font->ContainerAtlas->TexID );
}

void  ImGui::PopFont()
{
  ImGuiContext& g = *GImGui;
  g.CurrentWindow->DrawList->PopTextureID();
  g.FontStack.pop_back();
  SetCurrentFont( g.FontStack.empty() ? GetDefaultFont() : g.FontStack.back() );
}

void ImGui::PushItemFlag( ImGuiItemFlags option, bool enabled )
{
  ImGuiWindow* window = GetCurrentWindow();
  if( enabled )
    window->DC.ItemFlags |= option;
  else
    window->DC.ItemFlags &= ~option;
  window->DC.ItemFlagsStack.push_back( window->DC.ItemFlags );
}

void ImGui::PopItemFlag()
{
  ImGuiWindow* window = GetCurrentWindow();
  window->DC.ItemFlagsStack.pop_back();
  window->DC.ItemFlags = window->DC.ItemFlagsStack.empty() ? ImGuiItemFlags_Default_ : window->DC.ItemFlagsStack.back();
}

// FIXME: Look into renaming this once we have settled the new Focus/Activation/TabStop system.
void ImGui::PushAllowKeyboardFocus( bool allow_keyboard_focus )
{
  PushItemFlag( ImGuiItemFlags_NoTabStop, !allow_keyboard_focus );
}

void ImGui::PopAllowKeyboardFocus()
{
  PopItemFlag();
}

void ImGui::PushButtonRepeat( bool repeat )
{
  PushItemFlag( ImGuiItemFlags_ButtonRepeat, repeat );
}

void ImGui::PopButtonRepeat()
{
  PopItemFlag();
}

void ImGui::PushTextWrapPos( float wrap_pos_x )
{
  ImGuiWindow* window = GetCurrentWindow();
  window->DC.TextWrapPos = wrap_pos_x;
  window->DC.TextWrapPosStack.push_back( wrap_pos_x );
}

void ImGui::PopTextWrapPos()
{
  ImGuiWindow* window = GetCurrentWindow();
  window->DC.TextWrapPosStack.pop_back();
  window->DC.TextWrapPos = window->DC.TextWrapPosStack.empty() ? -1.0f : window->DC.TextWrapPosStack.back();
}

bool ImGui::IsWindowChildOf( ImGuiWindow* window, ImGuiWindow* potential_parent )
{
  if( window->RootWindow == potential_parent )
    return true;
  while( window != NULL )
  {
    if( window == potential_parent )
      return true;
    window = window->ParentWindow;
  }
  return false;
}

bool ImGui::IsWindowHovered( ImGuiHoveredFlags flags )
{
  IM_ASSERT( ( flags & ImGuiHoveredFlags_AllowWhenOverlapped ) == 0 );   // Flags not supported by this function
  ImGuiContext& g = *GImGui;

  if( flags & ImGuiHoveredFlags_AnyWindow )
  {
    if( g.HoveredWindow == NULL )
      return false;
  }
  else
  {
    switch( flags & ( ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows ) )
    {
      case ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows:
        if( g.HoveredRootWindow != g.CurrentWindow->RootWindow )
          return false;
        break;
      case ImGuiHoveredFlags_RootWindow:
        if( g.HoveredWindow != g.CurrentWindow->RootWindow )
          return false;
        break;
      case ImGuiHoveredFlags_ChildWindows:
        if( g.HoveredWindow == NULL || !IsWindowChildOf( g.HoveredWindow, g.CurrentWindow ) )
          return false;
        break;
      default:
        if( g.HoveredWindow != g.CurrentWindow )
          return false;
        break;
    }
  }

  if( !IsWindowContentHoverable( g.HoveredWindow, flags ) )
    return false;
  if( !( flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem ) )
    if( g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != g.HoveredWindow->MoveId )
      return false;
  return true;
}

bool ImGui::IsWindowFocused( ImGuiFocusedFlags flags )
{
  ImGuiContext& g = *GImGui;

  if( flags & ImGuiFocusedFlags_AnyWindow )
    return g.NavWindow != NULL;

  IM_ASSERT( g.CurrentWindow );     // Not inside a Begin()/End()
  switch( flags & ( ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows ) )
  {
    case ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows:
      return g.NavWindow && g.NavWindow->RootWindow == g.CurrentWindow->RootWindow;
    case ImGuiFocusedFlags_RootWindow:
      return g.NavWindow == g.CurrentWindow->RootWindow;
    case ImGuiFocusedFlags_ChildWindows:
      return g.NavWindow && IsWindowChildOf( g.NavWindow, g.CurrentWindow );
    default:
      return g.NavWindow == g.CurrentWindow;
  }
}

// Can we focus this window with CTRL+TAB (or PadMenu + PadFocusPrev/PadFocusNext)
// Note that NoNavFocus makes the window not reachable with CTRL+TAB but it can still be focused with mouse or programmatically.
// If you want a window to never be focused, you may use the e.g. NoInputs flag.
bool ImGui::IsWindowNavFocusable( ImGuiWindow* window )
{
  return window->Active && window == window->RootWindow && !( window->Flags & ImGuiWindowFlags_NoNavFocus );
}

float ImGui::GetWindowWidth()
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  return window->Size.x;
}

float ImGui::GetWindowHeight()
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  return window->Size.y;
}

ImVec2 ImGui::GetWindowPos()
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  return window->Pos;
}

void ImGui::SetWindowPos( ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond )
{
  // Test condition (NB: bit 0 is always true) and clear flags for next time
  if( cond && ( window->SetWindowPosAllowFlags & cond ) == 0 )
    return;

  IM_ASSERT( cond == 0 || ImIsPowerOfTwo( cond ) ); // Make sure the user doesn't attempt to combine multiple condition flags.
  window->SetWindowPosAllowFlags &= ~( ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing );
  window->SetWindowPosVal = ImVec2( FLT_MAX, FLT_MAX );

  // Set
  const ImVec2 old_pos = window->Pos;
  window->Pos = ImFloor( pos );
  ImVec2 offset = window->Pos - old_pos;
  window->DC.CursorPos += offset;         // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor
  window->DC.CursorMaxPos += offset;      // And more importantly we need to offset CursorMaxPos/CursorStartPos this so ContentSize calculation doesn't get affected.
  window->DC.CursorStartPos += offset;
}

void ImGui::SetWindowPos( const ImVec2& pos, ImGuiCond cond )
{
  ImGuiWindow* window = GetCurrentWindowRead();
  SetWindowPos( window, pos, cond );
}

void ImGui::SetWindowPos( const char* name, const ImVec2& pos, ImGuiCond cond )
{
  if( ImGuiWindow* window = FindWindowByName( name ) )
    SetWindowPos( window, pos, cond );
}

ImVec2 ImGui::GetWindowSize()
{
  ImGuiWindow* window = GetCurrentWindowRead();
  return window->Size;
}

void ImGui::SetWindowSize( ImGuiWindow* window, const ImVec2& size, ImGuiCond cond )
{
  // Test condition (NB: bit 0 is always true) and clear flags for next time
  if( cond && ( window->SetWindowSizeAllowFlags & cond ) == 0 )
    return;

  IM_ASSERT( cond == 0 || ImIsPowerOfTwo( cond ) ); // Make sure the user doesn't attempt to combine multiple condition flags.
  window->SetWindowSizeAllowFlags &= ~( ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing );

  // Set
  if( size.x > 0.0f )
  {
    window->AutoFitFramesX = 0;
    window->SizeFull.x = IM_FLOOR( size.x );
  }
  else
  {
    window->AutoFitFramesX = 2;
    window->AutoFitOnlyGrows = false;
  }
  if( size.y > 0.0f )
  {
    window->AutoFitFramesY = 0;
    window->SizeFull.y = IM_FLOOR( size.y );
  }
  else
  {
    window->AutoFitFramesY = 2;
    window->AutoFitOnlyGrows = false;
  }
}

void ImGui::SetWindowSize( const ImVec2& size, ImGuiCond cond )
{
  SetWindowSize( GImGui->CurrentWindow, size, cond );
}

void ImGui::SetWindowSize( const char* name, const ImVec2& size, ImGuiCond cond )
{
  if( ImGuiWindow* window = FindWindowByName( name ) )
    SetWindowSize( window, size, cond );
}

void ImGui::SetWindowCollapsed( ImGuiWindow* window, bool collapsed, ImGuiCond cond )
{
  // Test condition (NB: bit 0 is always true) and clear flags for next time
  if( cond && ( window->SetWindowCollapsedAllowFlags & cond ) == 0 )
    return;
  window->SetWindowCollapsedAllowFlags &= ~( ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing );

  // Set
  window->Collapsed = collapsed;
}

void ImGui::SetWindowCollapsed( bool collapsed, ImGuiCond cond )
{
  SetWindowCollapsed( GImGui->CurrentWindow, collapsed, cond );
}

bool ImGui::IsWindowCollapsed()
{
  ImGuiWindow* window = GetCurrentWindowRead();
  return window->Collapsed;
}

bool ImGui::IsWindowAppearing()
{
  ImGuiWindow* window = GetCurrentWindowRead();
  return window->Appearing;
}

void ImGui::SetWindowCollapsed( const char* name, bool collapsed, ImGuiCond cond )
{
  if( ImGuiWindow* window = FindWindowByName( name ) )
    SetWindowCollapsed( window, collapsed, cond );
}

void ImGui::SetWindowFocus()
{
  FocusWindow( GImGui->CurrentWindow );
}

void ImGui::SetWindowFocus( const char* name )
{
  if( name )
  {
    if( ImGuiWindow* window = FindWindowByName( name ) )
      FocusWindow( window );
  }
  else
  {
    FocusWindow( NULL );
  }
}

void ImGui::SetNextWindowPos( const ImVec2& pos, ImGuiCond cond, const ImVec2& pivot )
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( cond == 0 || ImIsPowerOfTwo( cond ) ); // Make sure the user doesn't attempt to combine multiple condition flags.
  g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasPos;
  g.NextWindowData.PosVal = pos;
  g.NextWindowData.PosPivotVal = pivot;
  g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowSize( const ImVec2& size, ImGuiCond cond )
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( cond == 0 || ImIsPowerOfTwo( cond ) ); // Make sure the user doesn't attempt to combine multiple condition flags.
  g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSize;
  g.NextWindowData.SizeVal = size;
  g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowSizeConstraints( const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback, void* custom_callback_user_data )
{
  ImGuiContext& g = *GImGui;
  g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSizeConstraint;
  g.NextWindowData.SizeConstraintRect = ImRect( size_min, size_max );
  g.NextWindowData.SizeCallback = custom_callback;
  g.NextWindowData.SizeCallbackUserData = custom_callback_user_data;
}

// Content size = inner scrollable rectangle, padded with WindowPadding.
// SetNextWindowContentSize(ImVec2(100,100) + ImGuiWindowFlags_AlwaysAutoResize will always allow submitting a 100x100 item.
void ImGui::SetNextWindowContentSize( const ImVec2& size )
{
  ImGuiContext& g = *GImGui;
  g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasContentSize;
  g.NextWindowData.ContentSizeVal = size;
}

void ImGui::SetNextWindowScroll( const ImVec2& scroll )
{
  ImGuiContext& g = *GImGui;
  g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasScroll;
  g.NextWindowData.ScrollVal = scroll;
}

void ImGui::SetNextWindowCollapsed( bool collapsed, ImGuiCond cond )
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( cond == 0 || ImIsPowerOfTwo( cond ) ); // Make sure the user doesn't attempt to combine multiple condition flags.
  g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasCollapsed;
  g.NextWindowData.CollapsedVal = collapsed;
  g.NextWindowData.CollapsedCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowFocus()
{
  ImGuiContext& g = *GImGui;
  g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasFocus;
}

void ImGui::SetNextWindowBgAlpha( float alpha )
{
  ImGuiContext& g = *GImGui;
  g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasBgAlpha;
  g.NextWindowData.BgAlphaVal = alpha;
}

ImDrawList* ImGui::GetWindowDrawList()
{
  ImGuiWindow* window = GetCurrentWindow();
  return window->DrawList;
}

ImFont* ImGui::GetFont()
{
  return GImGui->Font;
}

float ImGui::GetFontSize()
{
  return GImGui->FontSize;
}

ImVec2 ImGui::GetFontTexUvWhitePixel()
{
  return GImGui->DrawListSharedData.TexUvWhitePixel;
}

void ImGui::SetWindowFontScale( float scale )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = GetCurrentWindow();
  window->FontWindowScale = scale;
  g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
}

void ImGui::ActivateItem( ImGuiID id )
{
  ImGuiContext& g = *GImGui;
  g.NavNextActivateId = id;
}

void ImGui::PushFocusScope( ImGuiID id )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  window->IDStack.push_back( window->DC.NavFocusScopeIdCurrent );
  window->DC.NavFocusScopeIdCurrent = id;
}

void ImGui::PopFocusScope()
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  window->DC.NavFocusScopeIdCurrent = window->IDStack.back();
  window->IDStack.pop_back();
}

void ImGui::SetKeyboardFocusHere( int offset )
{
  IM_ASSERT( offset >= -1 );    // -1 is allowed but not below
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  g.FocusRequestNextWindow = window;
  g.FocusRequestNextCounterRegular = window->DC.FocusCounterRegular + 1 + offset;
  g.FocusRequestNextCounterTabStop = INT_MAX;
}

void ImGui::SetItemDefaultFocus()
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  if( !window->Appearing )
    return;
  if( g.NavWindow == window->RootWindowForNav && ( g.NavInitRequest || g.NavInitResultId != 0 ) && g.NavLayer == g.NavWindow->DC.NavLayerCurrent )
  {
    g.NavInitRequest = false;
    g.NavInitResultId = g.NavWindow->DC.LastItemId;
    g.NavInitResultRectRel = ImRect( g.NavWindow->DC.LastItemRect.Min - g.NavWindow->Pos, g.NavWindow->DC.LastItemRect.Max - g.NavWindow->Pos );
    NavUpdateAnyRequestFlag();
    if( !IsItemVisible() )
      SetScrollHereY();
  }
}

void ImGui::SetStateStorage( ImGuiStorage* tree )
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  window->DC.StateStorage = tree ? tree : &window->StateStorage;
}

ImGuiStorage* ImGui::GetStateStorage()
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  return window->DC.StateStorage;
}

void ImGui::PushID( const char* str_id )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  ImGuiID id = window->GetIDNoKeepAlive( str_id );
  window->IDStack.push_back( id );
}

void ImGui::PushID( const char* str_id_begin, const char* str_id_end )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  ImGuiID id = window->GetIDNoKeepAlive( str_id_begin, str_id_end );
  window->IDStack.push_back( id );
}

void ImGui::PushID( const void* ptr_id )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  ImGuiID id = window->GetIDNoKeepAlive( ptr_id );
  window->IDStack.push_back( id );
}

void ImGui::PushID( int int_id )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  ImGuiID id = window->GetIDNoKeepAlive( int_id );
  window->IDStack.push_back( id );
}

// Push a given id value ignoring the ID stack as a seed.
void ImGui::PushOverrideID( ImGuiID id )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  window->IDStack.push_back( id );
}

void ImGui::PopID()
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  window->IDStack.pop_back();
}

ImGuiID ImGui::GetID( const char* str_id )
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  return window->GetID( str_id );
}

ImGuiID ImGui::GetID( const char* str_id_begin, const char* str_id_end )
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  return window->GetID( str_id_begin, str_id_end );
}

ImGuiID ImGui::GetID( const void* ptr_id )
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  return window->GetID( ptr_id );
}

bool ImGui::IsRectVisible( const ImVec2& size )
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  return window->ClipRect.Overlaps( ImRect( window->DC.CursorPos, window->DC.CursorPos + size ) );
}

bool ImGui::IsRectVisible( const ImVec2& rect_min, const ImVec2& rect_max )
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  return window->ClipRect.Overlaps( ImRect( rect_min, rect_max ) );
}


//-----------------------------------------------------------------------------
// [SECTION] ERROR CHECKING
//-----------------------------------------------------------------------------

// Helper function to verify ABI compatibility between caller code and compiled version of Dear ImGui.
// Verify that the type sizes are matching between the calling file's compilation unit and imgui.cpp's compilation unit
// If the user has inconsistent compilation settings, imgui configuration #define, packing pragma, etc. your user code
// may see different structures than what imgui.cpp sees, which is problematic.
// We usually require settings to be in imconfig.h to make sure that they are accessible to all compilation units involved with Dear ImGui.
bool ImGui::DebugCheckVersionAndDataLayout( const char* version, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_vert, size_t sz_idx )
{
  bool error = false;
  if( win32::strcmp( version, IMGUI_VERSION ) != 0 )
  {
    error = true; IM_ASSERT( win32::strcmp( version, IMGUI_VERSION ) == 0 && "Mismatched version string!" );
  }
  if( sz_io != sizeof( ImGuiIO ) )
  {
    error = true; IM_ASSERT( sz_io == sizeof( ImGuiIO ) && "Mismatched struct layout!" );
  }
  if( sz_style != sizeof( ImGuiStyle ) )
  {
    error = true; IM_ASSERT( sz_style == sizeof( ImGuiStyle ) && "Mismatched struct layout!" );
  }
  if( sz_vec2 != sizeof( ImVec2 ) )
  {
    error = true; IM_ASSERT( sz_vec2 == sizeof( ImVec2 ) && "Mismatched struct layout!" );
  }
  if( sz_vec4 != sizeof( ImVec4 ) )
  {
    error = true; IM_ASSERT( sz_vec4 == sizeof( ImVec4 ) && "Mismatched struct layout!" );
  }
  if( sz_vert != sizeof( ImDrawVert ) )
  {
    error = true; IM_ASSERT( sz_vert == sizeof( ImDrawVert ) && "Mismatched struct layout!" );
  }
  if( sz_idx != sizeof( ImDrawIdx ) )
  {
    error = true; IM_ASSERT( sz_idx == sizeof( ImDrawIdx ) && "Mismatched struct layout!" );
  }
  return !error;
}

static void ImGui::ErrorCheckNewFrameSanityChecks()
{
  ImGuiContext& g = *GImGui;

  // Check user IM_ASSERT macro
  // (IF YOU GET A WARNING OR COMPILE ERROR HERE: it means you assert macro is incorrectly defined!
  //  If your macro uses multiple statements, it NEEDS to be surrounded by a 'do { ... } while (0)' block.
  //  This is a common C/C++ idiom to allow multiple statements macros to be used in control flow blocks.)
  // #define IM_ASSERT(EXPR)   SomeCode(EXPR); SomeMoreCode();                    // Wrong!
  // #define IM_ASSERT(EXPR)   do { SomeCode(EXPR); SomeMoreCode(); } while (0)   // Correct!
  if( true ) IM_ASSERT( 1 ); else IM_ASSERT( 0 );

  // Check user data
  // (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)
  IM_ASSERT( g.Initialized );
  IM_ASSERT( ( g.IO.DeltaTime > 0.0f || g.FrameCount == 0 ) && "Need a positive DeltaTime!" );
  IM_ASSERT( ( g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount ) && "Forgot to call Render() or EndFrame() at the end of the previous frame?" );
  IM_ASSERT( g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f && "Invalid DisplaySize value!" );
  IM_ASSERT( g.IO.Fonts->Fonts.Size > 0 && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?" );
  IM_ASSERT( g.IO.Fonts->Fonts[ 0 ]->IsLoaded() && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?" );
  IM_ASSERT( g.Style.CurveTessellationTol > 0.0f && "Invalid style setting!" );
  IM_ASSERT( g.Style.CircleSegmentMaxError > 0.0f && "Invalid style setting!" );
  IM_ASSERT( g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f && "Invalid style setting. Alpha cannot be negative (allows us to avoid a few clamps in color computations)!" );
  IM_ASSERT( g.Style.WindowMinSize.x >= 1.0f && g.Style.WindowMinSize.y >= 1.0f && "Invalid style setting." );
  IM_ASSERT( g.Style.WindowMenuButtonPosition == ImGuiDir_None || g.Style.WindowMenuButtonPosition == ImGuiDir_Left || g.Style.WindowMenuButtonPosition == ImGuiDir_Right );
  for( int n = 0; n < ImGuiKey_COUNT; n++ )
    IM_ASSERT( g.IO.KeyMap[ n ] >= -1 && g.IO.KeyMap[ n ] < IM_ARRAYSIZE( g.IO.KeysDown ) && "io.KeyMap[] contains an out of bound value (need to be 0..512, or -1 for unmapped key)" );

  // Perform simple check: required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was only recently added in 1.60 WIP)
  if( g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard )
    IM_ASSERT( g.IO.KeyMap[ ImGuiKey_Space ] != -1 && "ImGuiKey_Space is not mapped, required for keyboard navigation." );

  // Perform simple check: the beta io.ConfigWindowsResizeFromEdges option requires back-end to honor mouse cursor changes and set the ImGuiBackendFlags_HasMouseCursors flag accordingly.
  if( g.IO.ConfigWindowsResizeFromEdges && !( g.IO.BackendFlags & ImGuiBackendFlags_HasMouseCursors ) )
    g.IO.ConfigWindowsResizeFromEdges = false;
}

static void ImGui::ErrorCheckEndFrameSanityChecks()
{
  ImGuiContext& g = *GImGui;

  // Verify that io.KeyXXX fields haven't been tampered with. Key mods should not be modified between NewFrame() and EndFrame()
  const ImGuiKeyModFlags expected_key_mod_flags = GetMergedKeyModFlags();
  IM_ASSERT( g.IO.KeyMods == expected_key_mod_flags && "Mismatching io.KeyCtrl/io.KeyShift/io.KeyAlt/io.KeySuper vs io.KeyMods" );
  IM_UNUSED( expected_key_mod_flags );

  // Report when there is a mismatch of Begin/BeginChild vs End/EndChild calls. Important: Remember that the Begin/BeginChild API requires you
  // to always call End/EndChild even if Begin/BeginChild returns false! (this is unfortunately inconsistent with most other Begin* API).
  if( g.CurrentWindowStack.Size != 1 )
  {
    if( g.CurrentWindowStack.Size > 1 )
    {
      IM_ASSERT_USER_ERROR( g.CurrentWindowStack.Size == 1, "Mismatched Begin/BeginChild vs End/EndChild calls: did you forget to call End/EndChild?" );
      while( g.CurrentWindowStack.Size > 1 )
        End();
    }
    else
    {
      IM_ASSERT_USER_ERROR( g.CurrentWindowStack.Size == 1, "Mismatched Begin/BeginChild vs End/EndChild calls: did you call End/EndChild too much?" );
    }
  }
}

// Save and compare stack sizes on Begin()/End() to detect usage errors
// Begin() calls this with write=true
// End() calls this with write=false
static void ImGui::ErrorCheckBeginEndCompareStacksSize( ImGuiWindow* window, bool write )
{
  ImGuiContext& g = *GImGui;
  short* p = &window->DC.StackSizesBackup[ 0 ];

  // Window stacks
  // NOT checking: DC.ItemWidth, DC.AllowKeyboardFocus, DC.ButtonRepeat, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)
  {
    int n = window->IDStack.Size;       if( write ) *p = ( short )n; else IM_ASSERT( *p == n && "PushID/PopID or TreeNode/TreePop Mismatch!" );   p++;
  }    // Too few or too many PopID()/TreePop()
  {
    int n = window->DC.GroupStack.Size; if( write ) *p = ( short )n; else IM_ASSERT( *p == n && "BeginGroup/EndGroup Mismatch!" );                p++;
  }    // Too few or too many EndGroup()

// Global stacks
// For color, style and font stacks there is an incentive to use Push/Begin/Pop/.../End patterns, so we relax our checks a little to allow them.
  {
    int n = g.BeginPopupStack.Size;     if( write ) *p = ( short )n; else IM_ASSERT( *p == n && "BeginMenu/EndMenu or BeginPopup/EndPopup Mismatch!" ); p++;
  }// Too few or too many EndMenu()/EndPopup()
  {
    int n = g.ColorModifiers.Size;      if( write ) *p = ( short )n; else IM_ASSERT( *p >= n && "PushStyleColor/PopStyleColor Mismatch!" );       p++;
  }    // Too few or too many PopStyleColor()
  {
    int n = g.StyleModifiers.Size;      if( write ) *p = ( short )n; else IM_ASSERT( *p >= n && "PushStyleVar/PopStyleVar Mismatch!" );           p++;
  }    // Too few or too many PopStyleVar()
  {
    int n = g.FontStack.Size;           if( write ) *p = ( short )n; else IM_ASSERT( *p >= n && "PushFont/PopFont Mismatch!" );                   p++;
  }    // Too few or too many PopFont()
  IM_ASSERT( p == window->DC.StackSizesBackup + IM_ARRAYSIZE( window->DC.StackSizesBackup ) );
}


//-----------------------------------------------------------------------------
// [SECTION] LAYOUT
//-----------------------------------------------------------------------------
// - ItemSize()
// - ItemAdd()
// - SameLine()
// - GetCursorScreenPos()
// - SetCursorScreenPos()
// - GetCursorPos(), GetCursorPosX(), GetCursorPosY()
// - SetCursorPos(), SetCursorPosX(), SetCursorPosY()
// - GetCursorStartPos()
// - Indent()
// - Unindent()
// - SetNextItemWidth()
// - PushItemWidth()
// - PushMultiItemsWidths()
// - PopItemWidth()
// - CalcItemWidth()
// - CalcItemSize()
// - GetTextLineHeight()
// - GetTextLineHeightWithSpacing()
// - GetFrameHeight()
// - GetFrameHeightWithSpacing()
// - GetContentRegionMax()
// - GetContentRegionMaxAbs() [Internal]
// - GetContentRegionAvail(),
// - GetWindowContentRegionMin(), GetWindowContentRegionMax()
// - GetWindowContentRegionWidth()
// - BeginGroup()
// - EndGroup()
// Also see in imgui_widgets: tab bars, columns.
//-----------------------------------------------------------------------------

// Advance cursor given item size for layout.
// Register minimum needed size so it can extend the bounding box used for auto-fit calculation.
// See comments in ItemAdd() about how/why the size provided to ItemSize() vs ItemAdd() may often different.
void ImGui::ItemSize( const ImVec2& size, float text_baseline_y )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  if( window->SkipItems )
    return;

  // We increase the height in this function to accommodate for baseline offset.
  // In theory we should be offsetting the starting position (window->DC.CursorPos), that will be the topic of a larger refactor,
  // but since ItemSize() is not yet an API that moves the cursor (to handle e.g. wrapping) enlarging the height has the same effect.
  const float offset_to_match_baseline_y = ( text_baseline_y >= 0 ) ? ImMax( 0.0f, window->DC.CurrLineTextBaseOffset - text_baseline_y ) : 0.0f;
  const float line_height = ImMax( window->DC.CurrLineSize.y, size.y + offset_to_match_baseline_y );

  // Always align ourselves on pixel boundaries
  //if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]
  window->DC.CursorPosPrevLine.x = window->DC.CursorPos.x + size.x;
  window->DC.CursorPosPrevLine.y = window->DC.CursorPos.y;
  window->DC.CursorPos.x = IM_FLOOR( window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x );    // Next line
  window->DC.CursorPos.y = IM_FLOOR( window->DC.CursorPos.y + line_height + g.Style.ItemSpacing.y );        // Next line
  window->DC.CursorMaxPos.x = ImMax( window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x );
  window->DC.CursorMaxPos.y = ImMax( window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y );
  //if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]

  window->DC.PrevLineSize.y = line_height;
  window->DC.CurrLineSize.y = 0.0f;
  window->DC.PrevLineTextBaseOffset = ImMax( window->DC.CurrLineTextBaseOffset, text_baseline_y );
  window->DC.CurrLineTextBaseOffset = 0.0f;

  // Horizontal layout mode
  if( window->DC.LayoutType == ImGuiLayoutType_Horizontal )
    SameLine();
}

void ImGui::ItemSize( const ImRect& bb, float text_baseline_y )
{
  ItemSize( bb.GetSize(), text_baseline_y );
}

// Declare item bounding box for clipping and interaction.
// Note that the size can be different than the one provided to ItemSize(). Typically, widgets that spread over available surface
// declare their minimum size requirement to ItemSize() and provide a larger region to ItemAdd() which is used drawing/interaction.
bool ImGui::ItemAdd( const ImRect& bb, ImGuiID id, const ImRect* nav_bb_arg )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;

  if( id != 0 )
  {
    // Navigation processing runs prior to clipping early-out
    //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
    //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
    //      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
    //      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
    //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
    //      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
    // We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
    // If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
    window->DC.NavLayerActiveMaskNext |= window->DC.NavLayerCurrentMask;
    if( g.NavId == id || g.NavAnyRequest )
      if( g.NavWindow->RootWindowForNav == window->RootWindowForNav )
        if( window == g.NavWindow || ( ( window->Flags | g.NavWindow->Flags ) & ImGuiWindowFlags_NavFlattened ) )
          NavProcessItem( window, nav_bb_arg ? *nav_bb_arg : bb, id );

    // [DEBUG] Item Picker tool, when enabling the "extended" version we perform the check in ItemAdd()
#ifdef IMGUI_DEBUG_TOOL_ITEM_PICKER_EX
    if( id == g.DebugItemPickerBreakId )
    {
      IM_DEBUG_BREAK();
      g.DebugItemPickerBreakId = 0;
    }
#endif
  }

  window->DC.LastItemId = id;
  window->DC.LastItemRect = bb;
  window->DC.LastItemStatusFlags = ImGuiItemStatusFlags_None;
  g.NextItemData.Flags = ImGuiNextItemDataFlags_None;

#ifdef IMGUI_ENABLE_TEST_ENGINE
  if( id != 0 )
    IMGUI_TEST_ENGINE_ITEM_ADD( nav_bb_arg ? *nav_bb_arg : bb, id );
#endif

  // Clipping test
  const bool is_clipped = IsClippedEx( bb, id, false );
  if( is_clipped )
    return false;
  //if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]

  // We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
  if( IsMouseHoveringRect( bb.Min, bb.Max ) )
    window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HoveredRect;
  return true;
}

// Gets back to previous line and continue with horizontal layout
//      offset_from_start_x == 0 : follow right after previous item
//      offset_from_start_x != 0 : align to specified x position (relative to window/group left)
//      spacing_w < 0            : use default spacing if pos_x == 0, no spacing if pos_x != 0
//      spacing_w >= 0           : enforce spacing amount
void ImGui::SameLine( float offset_from_start_x, float spacing_w )
{
  ImGuiWindow* window = GetCurrentWindow();
  if( window->SkipItems )
    return;

  ImGuiContext& g = *GImGui;
  if( offset_from_start_x != 0.0f )
  {
    if( spacing_w < 0.0f ) spacing_w = 0.0f;
    window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + offset_from_start_x + spacing_w + window->DC.GroupOffset.x + window->DC.ColumnsOffset.x;
    window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
  }
  else
  {
    if( spacing_w < 0.0f ) spacing_w = g.Style.ItemSpacing.x;
    window->DC.CursorPos.x = window->DC.CursorPosPrevLine.x + spacing_w;
    window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
  }
  window->DC.CurrLineSize = window->DC.PrevLineSize;
  window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;
}

ImVec2 ImGui::GetCursorScreenPos()
{
  ImGuiWindow* window = GetCurrentWindowRead();
  return window->DC.CursorPos;
}

void ImGui::SetCursorScreenPos( const ImVec2& pos )
{
  ImGuiWindow* window = GetCurrentWindow();
  window->DC.CursorPos = pos;
  window->DC.CursorMaxPos = ImMax( window->DC.CursorMaxPos, window->DC.CursorPos );
}

// User generally sees positions in window coordinates. Internally we store CursorPos in absolute screen coordinates because it is more convenient.
// Conversion happens as we pass the value to user, but it makes our naming convention confusing because GetCursorPos() == (DC.CursorPos - window.Pos). May want to rename 'DC.CursorPos'.
ImVec2 ImGui::GetCursorPos()
{
  ImGuiWindow* window = GetCurrentWindowRead();
  return window->DC.CursorPos - window->Pos + window->Scroll;
}

float ImGui::GetCursorPosX()
{
  ImGuiWindow* window = GetCurrentWindowRead();
  return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;
}

float ImGui::GetCursorPosY()
{
  ImGuiWindow* window = GetCurrentWindowRead();
  return window->DC.CursorPos.y - window->Pos.y + window->Scroll.y;
}

void ImGui::SetCursorPos( const ImVec2& local_pos )
{
  ImGuiWindow* window = GetCurrentWindow();
  window->DC.CursorPos = window->Pos - window->Scroll + local_pos;
  window->DC.CursorMaxPos = ImMax( window->DC.CursorMaxPos, window->DC.CursorPos );
}

void ImGui::SetCursorPosX( float x )
{
  ImGuiWindow* window = GetCurrentWindow();
  window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;
  window->DC.CursorMaxPos.x = ImMax( window->DC.CursorMaxPos.x, window->DC.CursorPos.x );
}

void ImGui::SetCursorPosY( float y )
{
  ImGuiWindow* window = GetCurrentWindow();
  window->DC.CursorPos.y = window->Pos.y - window->Scroll.y + y;
  window->DC.CursorMaxPos.y = ImMax( window->DC.CursorMaxPos.y, window->DC.CursorPos.y );
}

ImVec2 ImGui::GetCursorStartPos()
{
  ImGuiWindow* window = GetCurrentWindowRead();
  return window->DC.CursorStartPos - window->Pos;
}

void ImGui::Indent( float indent_w )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = GetCurrentWindow();
  window->DC.Indent.x += ( indent_w != 0.0f ) ? indent_w : g.Style.IndentSpacing;
  window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}

void ImGui::Unindent( float indent_w )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = GetCurrentWindow();
  window->DC.Indent.x -= ( indent_w != 0.0f ) ? indent_w : g.Style.IndentSpacing;
  window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}

// Affect large frame+labels widgets only.
void ImGui::SetNextItemWidth( float item_width )
{
  ImGuiContext& g = *GImGui;
  g.NextItemData.Flags |= ImGuiNextItemDataFlags_HasWidth;
  g.NextItemData.Width = item_width;
}

void ImGui::PushItemWidth( float item_width )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  window->DC.ItemWidth = ( item_width == 0.0f ? window->ItemWidthDefault : item_width );
  window->DC.ItemWidthStack.push_back( window->DC.ItemWidth );
  g.NextItemData.Flags &= ~ImGuiNextItemDataFlags_HasWidth;
}

void ImGui::PushMultiItemsWidths( int components, float w_full )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  const ImGuiStyle& style = g.Style;
  const float w_item_one = ImMax( 1.0f, IM_FLOOR( ( w_full - ( style.ItemInnerSpacing.x ) * ( components - 1 ) ) / ( float )components ) );
  const float w_item_last = ImMax( 1.0f, IM_FLOOR( w_full - ( w_item_one + style.ItemInnerSpacing.x ) * ( components - 1 ) ) );
  window->DC.ItemWidthStack.push_back( w_item_last );
  for( int i = 0; i < components - 1; i++ )
    window->DC.ItemWidthStack.push_back( w_item_one );
  window->DC.ItemWidth = window->DC.ItemWidthStack.back();
  g.NextItemData.Flags &= ~ImGuiNextItemDataFlags_HasWidth;
}

void ImGui::PopItemWidth()
{
  ImGuiWindow* window = GetCurrentWindow();
  window->DC.ItemWidthStack.pop_back();
  window->DC.ItemWidth = window->DC.ItemWidthStack.empty() ? window->ItemWidthDefault : window->DC.ItemWidthStack.back();
}

// Calculate default item width given value passed to PushItemWidth() or SetNextItemWidth().
// The SetNextItemWidth() data is generally cleared/consumed by ItemAdd() or NextItemData.ClearFlags()
float ImGui::CalcItemWidth()
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  float w;
  if( g.NextItemData.Flags & ImGuiNextItemDataFlags_HasWidth )
    w = g.NextItemData.Width;
  else
    w = window->DC.ItemWidth;
  if( w < 0.0f )
  {
    float region_max_x = GetContentRegionMaxAbs().x;
    w = ImMax( 1.0f, region_max_x - window->DC.CursorPos.x + w );
  }
  w = IM_FLOOR( w );
  return w;
}

// [Internal] Calculate full item size given user provided 'size' parameter and default width/height. Default width is often == CalcItemWidth().
// Those two functions CalcItemWidth vs CalcItemSize are awkwardly named because they are not fully symmetrical.
// Note that only CalcItemWidth() is publicly exposed.
// The 4.0f here may be changed to match CalcItemWidth() and/or BeginChild() (right now we have a mismatch which is harmless but undesirable)
ImVec2 ImGui::CalcItemSize( ImVec2 size, float default_w, float default_h )
{
  ImGuiWindow* window = GImGui->CurrentWindow;

  ImVec2 region_max;
  if( size.x < 0.0f || size.y < 0.0f )
    region_max = GetContentRegionMaxAbs();

  if( size.x == 0.0f )
    size.x = default_w;
  else if( size.x < 0.0f )
    size.x = ImMax( 4.0f, region_max.x - window->DC.CursorPos.x + size.x );

  if( size.y == 0.0f )
    size.y = default_h;
  else if( size.y < 0.0f )
    size.y = ImMax( 4.0f, region_max.y - window->DC.CursorPos.y + size.y );

  return size;
}

float ImGui::GetTextLineHeight()
{
  ImGuiContext& g = *GImGui;
  return g.FontSize;
}

float ImGui::GetTextLineHeightWithSpacing()
{
  ImGuiContext& g = *GImGui;
  return g.FontSize + g.Style.ItemSpacing.y;
}

float ImGui::GetFrameHeight()
{
  ImGuiContext& g = *GImGui;
  return g.FontSize + g.Style.FramePadding.y * 2.0f;
}

float ImGui::GetFrameHeightWithSpacing()
{
  ImGuiContext& g = *GImGui;
  return g.FontSize + g.Style.FramePadding.y * 2.0f + g.Style.ItemSpacing.y;
}

// FIXME: All the Contents Region function are messy or misleading. WE WILL AIM TO OBSOLETE ALL OF THEM WITH A NEW "WORK RECT" API. Thanks for your patience!

// FIXME: This is in window space (not screen space!).
ImVec2 ImGui::GetContentRegionMax()
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  ImVec2 mx = window->ContentRegionRect.Max - window->Pos;
  if( window->DC.CurrentColumns )
    mx.x = window->WorkRect.Max.x - window->Pos.x;
  return mx;
}

// [Internal] Absolute coordinate. Saner. This is not exposed until we finishing refactoring work rect features.
ImVec2 ImGui::GetContentRegionMaxAbs()
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  ImVec2 mx = window->ContentRegionRect.Max;
  if( window->DC.CurrentColumns )
    mx.x = window->WorkRect.Max.x;
  return mx;
}

ImVec2 ImGui::GetContentRegionAvail()
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  return GetContentRegionMaxAbs() - window->DC.CursorPos;
}

// In window space (not screen space!)
ImVec2 ImGui::GetWindowContentRegionMin()
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  return window->ContentRegionRect.Min - window->Pos;
}

ImVec2 ImGui::GetWindowContentRegionMax()
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  return window->ContentRegionRect.Max - window->Pos;
}

float ImGui::GetWindowContentRegionWidth()
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  return window->ContentRegionRect.GetWidth();
}

// Lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
void ImGui::BeginGroup()
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = GetCurrentWindow();

  window->DC.GroupStack.resize( window->DC.GroupStack.Size + 1 );
  ImGuiGroupData& group_data = window->DC.GroupStack.back();
  group_data.BackupCursorPos = window->DC.CursorPos;
  group_data.BackupCursorMaxPos = window->DC.CursorMaxPos;
  group_data.BackupIndent = window->DC.Indent;
  group_data.BackupGroupOffset = window->DC.GroupOffset;
  group_data.BackupCurrLineSize = window->DC.CurrLineSize;
  group_data.BackupCurrLineTextBaseOffset = window->DC.CurrLineTextBaseOffset;
  group_data.BackupActiveIdIsAlive = g.ActiveIdIsAlive;
  group_data.BackupActiveIdPreviousFrameIsAlive = g.ActiveIdPreviousFrameIsAlive;
  group_data.EmitItem = true;

  window->DC.GroupOffset.x = window->DC.CursorPos.x - window->Pos.x - window->DC.ColumnsOffset.x;
  window->DC.Indent = window->DC.GroupOffset;
  window->DC.CursorMaxPos = window->DC.CursorPos;
  window->DC.CurrLineSize = ImVec2( 0.0f, 0.0f );
  if( g.LogEnabled )
    g.LogLinePosY = -FLT_MAX; // To enforce Log carriage return
}

void ImGui::EndGroup()
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = GetCurrentWindow();
  IM_ASSERT( !window->DC.GroupStack.empty() );  // Mismatched BeginGroup()/EndGroup() calls

  ImGuiGroupData& group_data = window->DC.GroupStack.back();

  ImRect group_bb( group_data.BackupCursorPos, ImMax( window->DC.CursorMaxPos, group_data.BackupCursorPos ) );

  window->DC.CursorPos = group_data.BackupCursorPos;
  window->DC.CursorMaxPos = ImMax( group_data.BackupCursorMaxPos, window->DC.CursorMaxPos );
  window->DC.Indent = group_data.BackupIndent;
  window->DC.GroupOffset = group_data.BackupGroupOffset;
  window->DC.CurrLineSize = group_data.BackupCurrLineSize;
  window->DC.CurrLineTextBaseOffset = group_data.BackupCurrLineTextBaseOffset;
  if( g.LogEnabled )
    g.LogLinePosY = -FLT_MAX; // To enforce Log carriage return

  if( !group_data.EmitItem )
  {
    window->DC.GroupStack.pop_back();
    return;
  }

  window->DC.CurrLineTextBaseOffset = ImMax( window->DC.PrevLineTextBaseOffset, group_data.BackupCurrLineTextBaseOffset );      // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.
  ItemSize( group_bb.GetSize() );
  ItemAdd( group_bb, 0 );

  // If the current ActiveId was declared within the boundary of our group, we copy it to LastItemId so IsItemActive(), IsItemDeactivated() etc. will be functional on the entire group.
  // It would be be neater if we replaced window.DC.LastItemId by e.g. 'bool LastItemIsActive', but would put a little more burden on individual widgets.
  // Also if you grep for LastItemId you'll notice it is only used in that context.
  // (The tests not symmetrical because ActiveIdIsAlive is an ID itself, in order to be able to handle ActiveId being overwritten during the frame.)
  const bool group_contains_curr_active_id = ( group_data.BackupActiveIdIsAlive != g.ActiveId ) && ( g.ActiveIdIsAlive == g.ActiveId ) && g.ActiveId;
  const bool group_contains_prev_active_id = !group_data.BackupActiveIdPreviousFrameIsAlive && g.ActiveIdPreviousFrameIsAlive;
  if( group_contains_curr_active_id )
    window->DC.LastItemId = g.ActiveId;
  else if( group_contains_prev_active_id )
    window->DC.LastItemId = g.ActiveIdPreviousFrame;
  window->DC.LastItemRect = group_bb;

  // Forward Edited flag
  if( group_contains_curr_active_id && g.ActiveIdHasBeenEditedThisFrame )
    window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_Edited;

  // Forward Deactivated flag
  window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HasDeactivated;
  if( group_contains_prev_active_id && g.ActiveId != g.ActiveIdPreviousFrame )
    window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_Deactivated;

  window->DC.GroupStack.pop_back();
  //window->DrawList->AddRect(group_bb.Min, group_bb.Max, IM_COL32(255,0,255,255));   // [Debug]
}


//-----------------------------------------------------------------------------
// [SECTION] SCROLLING
//-----------------------------------------------------------------------------

static ImVec2 CalcNextScrollFromScrollTargetAndClamp( ImGuiWindow* window, bool snap_on_edges )
{
  ImGuiContext& g = *GImGui;
  ImVec2 scroll = window->Scroll;
  if( window->ScrollTarget.x < FLT_MAX )
  {
    float cr_x = window->ScrollTargetCenterRatio.x;
    float target_x = window->ScrollTarget.x;
    if( snap_on_edges && cr_x <= 0.0f && target_x <= window->WindowPadding.x )
      target_x = 0.0f;
    else if( snap_on_edges && cr_x >= 1.0f && target_x >= window->ContentSize.x + window->WindowPadding.x + g.Style.ItemSpacing.x )
      target_x = window->ContentSize.x + window->WindowPadding.x * 2.0f;
    scroll.x = target_x - cr_x * ( window->SizeFull.x - window->ScrollbarSizes.x );
  }
  if( window->ScrollTarget.y < FLT_MAX )
  {
    // 'snap_on_edges' allows for a discontinuity at the edge of scrolling limits to take account of WindowPadding so that scrolling to make the last item visible scroll far enough to see the padding.
    float decoration_up_height = window->TitleBarHeight() + window->MenuBarHeight();
    float cr_y = window->ScrollTargetCenterRatio.y;
    float target_y = window->ScrollTarget.y;
    if( snap_on_edges && cr_y <= 0.0f && target_y <= window->WindowPadding.y )
      target_y = 0.0f;
    if( snap_on_edges && cr_y >= 1.0f && target_y >= window->ContentSize.y + window->WindowPadding.y + g.Style.ItemSpacing.y )
      target_y = window->ContentSize.y + window->WindowPadding.y * 2.0f;
    scroll.y = target_y - cr_y * ( window->SizeFull.y - window->ScrollbarSizes.y - decoration_up_height );
  }
  scroll.x = IM_FLOOR( ImMax( scroll.x, 0.0f ) );
  scroll.y = IM_FLOOR( ImMax( scroll.y, 0.0f ) );
  if( !window->Collapsed && !window->SkipItems )
  {
    scroll.x = ImMin( scroll.x, window->ScrollMax.x );
    scroll.y = ImMin( scroll.y, window->ScrollMax.y );
  }
  return scroll;
}

// Scroll to keep newly navigated item fully into view
ImVec2 ImGui::ScrollToBringRectIntoView( ImGuiWindow* window, const ImRect& item_rect )
{
  ImGuiContext& g = *GImGui;
  ImRect window_rect( window->InnerRect.Min - ImVec2( 1, 1 ), window->InnerRect.Max + ImVec2( 1, 1 ) );
  //GetForegroundDrawList(window)->AddRect(window_rect.Min, window_rect.Max, IM_COL32_WHITE); // [DEBUG]

  ImVec2 delta_scroll;
  if( !window_rect.Contains( item_rect ) )
  {
    if( window->ScrollbarX && item_rect.Min.x < window_rect.Min.x )
      SetScrollFromPosX( window, item_rect.Min.x - window->Pos.x + g.Style.ItemSpacing.x, 0.0f );
    else if( window->ScrollbarX && item_rect.Max.x >= window_rect.Max.x )
      SetScrollFromPosX( window, item_rect.Max.x - window->Pos.x + g.Style.ItemSpacing.x, 1.0f );
    if( item_rect.Min.y < window_rect.Min.y )
      SetScrollFromPosY( window, item_rect.Min.y - window->Pos.y - g.Style.ItemSpacing.y, 0.0f );
    else if( item_rect.Max.y >= window_rect.Max.y )
      SetScrollFromPosY( window, item_rect.Max.y - window->Pos.y + g.Style.ItemSpacing.y, 1.0f );

    ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp( window, false );
    delta_scroll = next_scroll - window->Scroll;
  }

  // Also scroll parent window to keep us into view if necessary
  if( window->Flags & ImGuiWindowFlags_ChildWindow )
    delta_scroll += ScrollToBringRectIntoView( window->ParentWindow, ImRect( item_rect.Min - delta_scroll, item_rect.Max - delta_scroll ) );

  return delta_scroll;
}

float ImGui::GetScrollX()
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  return window->Scroll.x;
}

float ImGui::GetScrollY()
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  return window->Scroll.y;
}

float ImGui::GetScrollMaxX()
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  return window->ScrollMax.x;
}

float ImGui::GetScrollMaxY()
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  return window->ScrollMax.y;
}

void ImGui::SetScrollX( float scroll_x )
{
  ImGuiWindow* window = GetCurrentWindow();
  window->ScrollTarget.x = scroll_x;
  window->ScrollTargetCenterRatio.x = 0.0f;
}

void ImGui::SetScrollY( float scroll_y )
{
  ImGuiWindow* window = GetCurrentWindow();
  window->ScrollTarget.y = scroll_y;
  window->ScrollTargetCenterRatio.y = 0.0f;
}

void ImGui::SetScrollX( ImGuiWindow* window, float new_scroll_x )
{
  window->ScrollTarget.x = new_scroll_x;
  window->ScrollTargetCenterRatio.x = 0.0f;
}

void ImGui::SetScrollY( ImGuiWindow* window, float new_scroll_y )
{
  window->ScrollTarget.y = new_scroll_y;
  window->ScrollTargetCenterRatio.y = 0.0f;
}


void ImGui::SetScrollFromPosX( ImGuiWindow* window, float local_x, float center_x_ratio )
{
  // We store a target position so centering can occur on the next frame when we are guaranteed to have a known window size
  IM_ASSERT( center_x_ratio >= 0.0f && center_x_ratio <= 1.0f );
  window->ScrollTarget.x = IM_FLOOR( local_x + window->Scroll.x );
  window->ScrollTargetCenterRatio.x = center_x_ratio;
}

void ImGui::SetScrollFromPosY( ImGuiWindow* window, float local_y, float center_y_ratio )
{
  // We store a target position so centering can occur on the next frame when we are guaranteed to have a known window size
  IM_ASSERT( center_y_ratio >= 0.0f && center_y_ratio <= 1.0f );
  const float decoration_up_height = window->TitleBarHeight() + window->MenuBarHeight();
  local_y -= decoration_up_height;
  window->ScrollTarget.y = IM_FLOOR( local_y + window->Scroll.y );
  window->ScrollTargetCenterRatio.y = center_y_ratio;
}

void ImGui::SetScrollFromPosX( float local_x, float center_x_ratio )
{
  ImGuiContext& g = *GImGui;
  SetScrollFromPosX( g.CurrentWindow, local_x, center_x_ratio );
}

void ImGui::SetScrollFromPosY( float local_y, float center_y_ratio )
{
  ImGuiContext& g = *GImGui;
  SetScrollFromPosY( g.CurrentWindow, local_y, center_y_ratio );
}

// center_x_ratio: 0.0f left of last item, 0.5f horizontal center of last item, 1.0f right of last item.
void ImGui::SetScrollHereX( float center_x_ratio )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  float target_x = window->DC.LastItemRect.Min.x - window->Pos.x; // Left of last item, in window space
  float last_item_width = window->DC.LastItemRect.GetWidth();
  target_x += ( last_item_width * center_x_ratio ) + ( g.Style.ItemSpacing.x * ( center_x_ratio - 0.5f ) * 2.0f ); // Precisely aim before, in the middle or after the last item.
  SetScrollFromPosX( target_x, center_x_ratio );
}

// center_y_ratio: 0.0f top of last item, 0.5f vertical center of last item, 1.0f bottom of last item.
void ImGui::SetScrollHereY( float center_y_ratio )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  float target_y = window->DC.CursorPosPrevLine.y - window->Pos.y; // Top of last item, in window space
  target_y += ( window->DC.PrevLineSize.y * center_y_ratio ) + ( g.Style.ItemSpacing.y * ( center_y_ratio - 0.5f ) * 2.0f ); // Precisely aim above, in the middle or below the last line.
  SetScrollFromPosY( target_y, center_y_ratio );
}

//-----------------------------------------------------------------------------
// [SECTION] TOOLTIPS
//-----------------------------------------------------------------------------

void ImGui::BeginTooltip()
{
  BeginTooltipEx( ImGuiWindowFlags_None, ImGuiTooltipFlags_None );
}

void ImGui::BeginTooltipEx( ImGuiWindowFlags extra_flags, ImGuiTooltipFlags tooltip_flags )
{
  ImGuiContext& g = *GImGui;

  if( g.DragDropWithinSource || g.DragDropWithinTarget )
  {
    // The default tooltip position is a little offset to give space to see the context menu (it's also clamped within the current viewport/monitor)
    // In the context of a dragging tooltip we try to reduce that offset and we enforce following the cursor.
    // Whatever we do we want to call SetNextWindowPos() to enforce a tooltip position and disable clipping the tooltip without our display area, like regular tooltip do.
    //ImVec2 tooltip_pos = g.IO.MousePos - g.ActiveIdClickOffset - g.Style.WindowPadding;
    ImVec2 tooltip_pos = g.IO.MousePos + ImVec2( 16 * g.Style.MouseCursorScale, 8 * g.Style.MouseCursorScale );
    SetNextWindowPos( tooltip_pos );
    SetNextWindowBgAlpha( g.Style.Colors[ ImGuiCol_PopupBg ].w * 0.60f );
    //PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * 0.60f); // This would be nice but e.g ColorButton with checkboard has issue with transparent colors :(
    tooltip_flags |= ImGuiTooltipFlags_OverridePreviousTooltip;
  }

  char window_name[ 16 ];
  ImFormatString( window_name, IM_ARRAYSIZE( window_name ), SECURE( "##Tooltip_%02d" ), g.TooltipOverrideCount );
  if( tooltip_flags & ImGuiTooltipFlags_OverridePreviousTooltip )
    if( ImGuiWindow* window = FindWindowByName( window_name ) )
      if( window->Active )
      {
        // Hide previous tooltip from being displayed. We can't easily "reset" the content of a window so we create a new one.
        window->Hidden = true;
        window->HiddenFramesCanSkipItems = 1;
        ImFormatString( window_name, IM_ARRAYSIZE( window_name ), SECURE( "##Tooltip_%02d" ), ++g.TooltipOverrideCount );
      }
  ImGuiWindowFlags flags = ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_AlwaysAutoResize;
  Begin( window_name, NULL, flags | extra_flags );
}

void ImGui::EndTooltip()
{
  IM_ASSERT( GetCurrentWindowRead()->Flags & ImGuiWindowFlags_Tooltip );   // Mismatched BeginTooltip()/EndTooltip() calls
  End();
}

void ImGui::SetTooltipV( const char* fmt, va_list args )
{
  BeginTooltipEx( 0, ImGuiTooltipFlags_OverridePreviousTooltip );
  TextV( fmt, args );
  EndTooltip();
}

void ImGui::SetTooltip( const char* fmt, ... )
{
  va_list args;
  va_start( args, fmt );
  SetTooltipV( fmt, args );
  va_end( args );
}

//-----------------------------------------------------------------------------
// [SECTION] POPUPS
//-----------------------------------------------------------------------------

bool ImGui::IsPopupOpen( ImGuiID id )
{
  ImGuiContext& g = *GImGui;
  return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[ g.BeginPopupStack.Size ].PopupId == id;
}

bool ImGui::IsPopupOpen( const char* str_id )
{
  ImGuiContext& g = *GImGui;
  return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[ g.BeginPopupStack.Size ].PopupId == g.CurrentWindow->GetID( str_id );
}

ImGuiWindow* ImGui::GetTopMostPopupModal()
{
  ImGuiContext& g = *GImGui;
  for( int n = g.OpenPopupStack.Size - 1; n >= 0; n-- )
    if( ImGuiWindow* popup = g.OpenPopupStack.Data[ n ].Window )
      if( popup->Flags & ImGuiWindowFlags_Modal )
        return popup;
  return NULL;
}

void ImGui::OpenPopup( const char* str_id )
{
  ImGuiContext& g = *GImGui;
  OpenPopupEx( g.CurrentWindow->GetID( str_id ) );
}

// Mark popup as open (toggle toward open state).
// Popups are closed when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block.
// Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
// One open popup per level of the popup hierarchy (NB: when assigning we reset the Window member of ImGuiPopupRef to NULL)
void ImGui::OpenPopupEx( ImGuiID id )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* parent_window = g.CurrentWindow;
  int current_stack_size = g.BeginPopupStack.Size;
  ImGuiPopupData popup_ref; // Tagged as new ref as Window will be set back to NULL if we write this into OpenPopupStack.
  popup_ref.PopupId = id;
  popup_ref.Window = NULL;
  popup_ref.SourceWindow = g.NavWindow;
  popup_ref.OpenFrameCount = g.FrameCount;
  popup_ref.OpenParentId = parent_window->IDStack.back();
  popup_ref.OpenPopupPos = NavCalcPreferredRefPos();
  popup_ref.OpenMousePos = IsMousePosValid( &g.IO.MousePos ) ? g.IO.MousePos : popup_ref.OpenPopupPos;

  //IMGUI_DEBUG_LOG("OpenPopupEx(0x%08X)\n", g.FrameCount, id);
  if( g.OpenPopupStack.Size < current_stack_size + 1 )
  {
    g.OpenPopupStack.push_back( popup_ref );
  }
  else
  {
    // Gently handle the user mistakenly calling OpenPopup() every frame. It is a programming mistake! However, if we were to run the regular code path, the ui
    // would become completely unusable because the popup will always be in hidden-while-calculating-size state _while_ claiming focus. Which would be a very confusing
    // situation for the programmer. Instead, we silently allow the popup to proceed, it will keep reappearing and the programming error will be more obvious to understand.
    if( g.OpenPopupStack[ current_stack_size ].PopupId == id && g.OpenPopupStack[ current_stack_size ].OpenFrameCount == g.FrameCount - 1 )
    {
      g.OpenPopupStack[ current_stack_size ].OpenFrameCount = popup_ref.OpenFrameCount;
    }
    else
    {
      // Close child popups if any, then flag popup for open/reopen
      g.OpenPopupStack.resize( current_stack_size + 1 );
      g.OpenPopupStack[ current_stack_size ] = popup_ref;
    }

    // When reopening a popup we first refocus its parent, otherwise if its parent is itself a popup it would get closed by ClosePopupsOverWindow().
    // This is equivalent to what ClosePopupToLevel() does.
    //if (g.OpenPopupStack[current_stack_size].PopupId == id)
    //    FocusWindow(parent_window);
  }
}

void ImGui::ClosePopupsOverWindow( ImGuiWindow* ref_window, bool restore_focus_to_window_under_popup )
{
  ImGuiContext& g = *GImGui;
  if( g.OpenPopupStack.empty() )
    return;

  // When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.
  // Don't close our own child popup windows.
  int popup_count_to_keep = 0;
  if( ref_window )
  {
    // Find the highest popup which is a descendant of the reference window (generally reference window = NavWindow)
    for( ; popup_count_to_keep < g.OpenPopupStack.Size; popup_count_to_keep++ )
    {
      ImGuiPopupData& popup = g.OpenPopupStack[ popup_count_to_keep ];
      if( !popup.Window )
        continue;
      IM_ASSERT( ( popup.Window->Flags & ImGuiWindowFlags_Popup ) != 0 );
      if( popup.Window->Flags & ImGuiWindowFlags_ChildWindow )
        continue;

      // Trim the stack when popups are not direct descendant of the reference window (the reference window is often the NavWindow)
      bool popup_or_descendent_is_ref_window = false;
      for( int m = popup_count_to_keep; m < g.OpenPopupStack.Size && !popup_or_descendent_is_ref_window; m++ )
        if( ImGuiWindow* popup_window = g.OpenPopupStack[ m ].Window )
          if( popup_window->RootWindow == ref_window->RootWindow )
            popup_or_descendent_is_ref_window = true;
      if( !popup_or_descendent_is_ref_window )
        break;
    }
  }
  if( popup_count_to_keep < g.OpenPopupStack.Size ) // This test is not required but it allows to set a convenient breakpoint on the statement below
  {
    //IMGUI_DEBUG_LOG("ClosePopupsOverWindow(%s) -> ClosePopupToLevel(%d)\n", ref_window->Name, popup_count_to_keep);
    ClosePopupToLevel( popup_count_to_keep, restore_focus_to_window_under_popup );
  }
}

void ImGui::ClosePopupToLevel( int remaining, bool restore_focus_to_window_under_popup )
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( remaining >= 0 && remaining < g.OpenPopupStack.Size );
  ImGuiWindow* focus_window = g.OpenPopupStack[ remaining ].SourceWindow;
  ImGuiWindow* popup_window = g.OpenPopupStack[ remaining ].Window;
  g.OpenPopupStack.resize( remaining );

  if( restore_focus_to_window_under_popup )
  {
    if( focus_window && !focus_window->WasActive && popup_window )
    {
      // Fallback
      FocusTopMostWindowUnderOne( popup_window, NULL );
    }
    else
    {
      if( g.NavLayer == ImGuiNavLayer_Main && focus_window )
        focus_window = NavRestoreLastChildNavWindow( focus_window );
      FocusWindow( focus_window );
    }
  }
}

// Close the popup we have begin-ed into.
void ImGui::CloseCurrentPopup()
{
  ImGuiContext& g = *GImGui;
  int popup_idx = g.BeginPopupStack.Size - 1;
  if( popup_idx < 0 || popup_idx >= g.OpenPopupStack.Size || g.BeginPopupStack[ popup_idx ].PopupId != g.OpenPopupStack[ popup_idx ].PopupId )
    return;

  // Closing a menu closes its top-most parent popup (unless a modal)
  while( popup_idx > 0 )
  {
    ImGuiWindow* popup_window = g.OpenPopupStack[ popup_idx ].Window;
    ImGuiWindow* parent_popup_window = g.OpenPopupStack[ popup_idx - 1 ].Window;
    bool close_parent = false;
    if( popup_window && ( popup_window->Flags & ImGuiWindowFlags_ChildMenu ) )
      if( parent_popup_window == NULL || !( parent_popup_window->Flags & ImGuiWindowFlags_Modal ) )
        close_parent = true;
    if( !close_parent )
      break;
    popup_idx--;
  }
  //IMGUI_DEBUG_LOG("CloseCurrentPopup %d -> %d\n", g.BeginPopupStack.Size - 1, popup_idx);
  ClosePopupToLevel( popup_idx, true );

  // A common pattern is to close a popup when selecting a menu item/selectable that will open another window.
  // To improve this usage pattern, we avoid nav highlight for a single frame in the parent window.
  // Similarly, we could avoid mouse hover highlight in this window but it is less visually problematic.
  if( ImGuiWindow* window = g.NavWindow )
    window->DC.NavHideHighlightOneFrame = true;
}

bool ImGui::BeginPopupEx( ImGuiID id, ImGuiWindowFlags flags )
{
  ImGuiContext& g = *GImGui;
  if( !IsPopupOpen( id ) )
  {
    g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
    return false;
  }

  char name[ 20 ];
  if( flags & ImGuiWindowFlags_ChildMenu )
    ImFormatString( name, IM_ARRAYSIZE( name ), SECURE( "##Menu_%02d" ), g.BeginPopupStack.Size ); // Recycle windows based on depth
  else
    ImFormatString( name, IM_ARRAYSIZE( name ), SECURE( "##Popup_%08x" ), id ); // Not recycling, so we can close/open during the same frame

  flags |= ImGuiWindowFlags_Popup;
  bool is_open = Begin( name, NULL, flags );
  if( !is_open ) // NB: Begin can return false when the popup is completely clipped (e.g. zero size display)
    EndPopup();

  return is_open;
}

bool ImGui::BeginPopup( const char* str_id, ImGuiWindowFlags flags )
{
  ImGuiContext& g = *GImGui;
  if( g.OpenPopupStack.Size <= g.BeginPopupStack.Size ) // Early out for performance
  {
    g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
    return false;
  }
  flags |= ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings;
  return BeginPopupEx( g.CurrentWindow->GetID( str_id ), flags );
}

// If 'p_open' is specified for a modal popup window, the popup will have a regular close button which will close the popup.
// Note that popup visibility status is owned by Dear ImGui (and manipulated with e.g. OpenPopup) so the actual value of *p_open is meaningless here.
bool ImGui::BeginPopupModal( const char* name, bool* p_open, ImGuiWindowFlags flags )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  const ImGuiID id = window->GetID( name );
  if( !IsPopupOpen( id ) )
  {
    g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
    return false;
  }

  // Center modal windows by default
  // FIXME: Should test for (PosCond & window->SetWindowPosAllowFlags) with the upcoming window.
  if( ( g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos ) == 0 )
    SetNextWindowPos( g.IO.DisplaySize * 0.5f, ImGuiCond_Appearing, ImVec2( 0.5f, 0.5f ) );

  flags |= ImGuiWindowFlags_Popup | ImGuiWindowFlags_Modal | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings;
  const bool is_open = Begin( name, p_open, flags );
  if( !is_open || ( p_open && !*p_open ) ) // NB: is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
  {
    EndPopup();
    if( is_open )
      ClosePopupToLevel( g.BeginPopupStack.Size, true );
    return false;
  }
  return is_open;
}

void ImGui::EndPopup()
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  IM_ASSERT( window->Flags & ImGuiWindowFlags_Popup );  // Mismatched BeginPopup()/EndPopup() calls
  IM_ASSERT( g.BeginPopupStack.Size > 0 );

  // Make all menus and popups wrap around for now, may need to expose that policy.
  NavMoveRequestTryWrapping( window, ImGuiNavMoveFlags_LoopY );

  // Child-popups don't need to be laid out
  IM_ASSERT( g.WithinEndChild == false );
  if( window->Flags & ImGuiWindowFlags_ChildWindow )
    g.WithinEndChild = true;
  End();
  g.WithinEndChild = false;
}

bool ImGui::OpenPopupOnItemClick( const char* str_id, ImGuiMouseButton mouse_button )
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  if( IsMouseReleased( mouse_button ) && IsItemHovered( ImGuiHoveredFlags_AllowWhenBlockedByPopup ) )
  {
    ImGuiID id = str_id ? window->GetID( str_id ) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
    IM_ASSERT( id != 0 );                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
    OpenPopupEx( id );
    return true;
  }
  return false;
}

// This is a helper to handle the simplest case of associating one named popup to one given widget.
// You may want to handle this on user side if you have specific needs (e.g. tweaking IsItemHovered() parameters).
// You can pass a NULL str_id to use the identifier of the last item.
bool ImGui::BeginPopupContextItem( const char* str_id, ImGuiMouseButton mouse_button )
{
  ImGuiWindow* window = GImGui->CurrentWindow;
  if( window->SkipItems )
    return false;
  ImGuiID id = str_id ? window->GetID( str_id ) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
  IM_ASSERT( id != 0 );                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
  if( IsMouseReleased( mouse_button ) && IsItemHovered( ImGuiHoveredFlags_AllowWhenBlockedByPopup ) )
    OpenPopupEx( id );
  return BeginPopupEx( id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings );
}

bool ImGui::BeginPopupContextWindow( const char* str_id, ImGuiMouseButton mouse_button, bool also_over_items )
{
  if( !str_id )
    str_id = SECURE( "window_context" );
  ImGuiID id = GImGui->CurrentWindow->GetID( str_id );
  if( IsMouseReleased( mouse_button ) && IsWindowHovered( ImGuiHoveredFlags_AllowWhenBlockedByPopup ) )
    if( also_over_items || !IsAnyItemHovered() )
      OpenPopupEx( id );
  return BeginPopupEx( id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings );
}

bool ImGui::BeginPopupContextVoid( const char* str_id, ImGuiMouseButton mouse_button )
{
  if( !str_id )
    str_id = SECURE( "void_context" );
  ImGuiID id = GImGui->CurrentWindow->GetID( str_id );
  if( IsMouseReleased( mouse_button ) && !IsWindowHovered( ImGuiHoveredFlags_AnyWindow ) )
    OpenPopupEx( id );
  return BeginPopupEx( id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings );
}

// r_avoid = the rectangle to avoid (e.g. for tooltip it is a rectangle around the mouse cursor which we want to avoid. for popups it's a small point around the cursor.)
// r_outer = the visible area rectangle, minus safe area padding. If our popup size won't fit because of safe area padding we ignore it.
ImVec2 ImGui::FindBestWindowPosForPopupEx( const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy )
{
  ImVec2 base_pos_clamped = ImClamp( ref_pos, r_outer.Min, r_outer.Max - size );
  //GetForegroundDrawList()->AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255,0,0,255));
  //GetForegroundDrawList()->AddRect(r_outer.Min, r_outer.Max, IM_COL32(0,255,0,255));

  // Combo Box policy (we want a connecting edge)
  if( policy == ImGuiPopupPositionPolicy_ComboBox )
  {
    const ImGuiDir dir_prefered_order[ ImGuiDir_COUNT ] = { ImGuiDir_Down, ImGuiDir_Right, ImGuiDir_Left, ImGuiDir_Up };
    for( int n = ( *last_dir != ImGuiDir_None ) ? -1 : 0; n < ImGuiDir_COUNT; n++ )
    {
      const ImGuiDir dir = ( n == -1 ) ? *last_dir : dir_prefered_order[ n ];
      if( n != -1 && dir == *last_dir ) // Already tried this direction?
        continue;
      ImVec2 pos;
      if( dir == ImGuiDir_Down )  pos = ImVec2( r_avoid.Min.x, r_avoid.Max.y );          // Below, Toward Right (default)
      if( dir == ImGuiDir_Right ) pos = ImVec2( r_avoid.Min.x, r_avoid.Min.y - size.y ); // Above, Toward Right
      if( dir == ImGuiDir_Left )  pos = ImVec2( r_avoid.Max.x - size.x, r_avoid.Max.y ); // Below, Toward Left
      if( dir == ImGuiDir_Up )    pos = ImVec2( r_avoid.Max.x - size.x, r_avoid.Min.y - size.y ); // Above, Toward Left
      if( !r_outer.Contains( ImRect( pos, pos + size ) ) )
        continue;
      *last_dir = dir;
      return pos;
    }
  }

  // Default popup policy
  const ImGuiDir dir_prefered_order[ ImGuiDir_COUNT ] = { ImGuiDir_Right, ImGuiDir_Down, ImGuiDir_Up, ImGuiDir_Left };
  for( int n = ( *last_dir != ImGuiDir_None ) ? -1 : 0; n < ImGuiDir_COUNT; n++ )
  {
    const ImGuiDir dir = ( n == -1 ) ? *last_dir : dir_prefered_order[ n ];
    if( n != -1 && dir == *last_dir ) // Already tried this direction?
      continue;
    float avail_w = ( dir == ImGuiDir_Left ? r_avoid.Min.x : r_outer.Max.x ) - ( dir == ImGuiDir_Right ? r_avoid.Max.x : r_outer.Min.x );
    float avail_h = ( dir == ImGuiDir_Up ? r_avoid.Min.y : r_outer.Max.y ) - ( dir == ImGuiDir_Down ? r_avoid.Max.y : r_outer.Min.y );
    if( avail_w < size.x || avail_h < size.y )
      continue;
    ImVec2 pos;
    pos.x = ( dir == ImGuiDir_Left ) ? r_avoid.Min.x - size.x : ( dir == ImGuiDir_Right ) ? r_avoid.Max.x : base_pos_clamped.x;
    pos.y = ( dir == ImGuiDir_Up ) ? r_avoid.Min.y - size.y : ( dir == ImGuiDir_Down ) ? r_avoid.Max.y : base_pos_clamped.y;
    *last_dir = dir;
    return pos;
  }

  // Fallback, try to keep within display
  *last_dir = ImGuiDir_None;
  ImVec2 pos = ref_pos;
  pos.x = ImMax( ImMin( pos.x + size.x, r_outer.Max.x ) - size.x, r_outer.Min.x );
  pos.y = ImMax( ImMin( pos.y + size.y, r_outer.Max.y ) - size.y, r_outer.Min.y );
  return pos;
}

ImRect ImGui::GetWindowAllowedExtentRect( ImGuiWindow* window )
{
  IM_UNUSED( window );
  ImVec2 padding = GImGui->Style.DisplaySafeAreaPadding;
  ImRect r_screen = GetViewportRect();
  r_screen.Expand( ImVec2( ( r_screen.GetWidth() > padding.x * 2 ) ? -padding.x : 0.0f, ( r_screen.GetHeight() > padding.y * 2 ) ? -padding.y : 0.0f ) );
  return r_screen;
}

ImVec2 ImGui::FindBestWindowPosForPopup( ImGuiWindow* window )
{
  ImGuiContext& g = *GImGui;

  ImRect r_outer = GetWindowAllowedExtentRect( window );
  if( window->Flags & ImGuiWindowFlags_ChildMenu )
  {
    // Child menus typically request _any_ position within the parent menu item, and then we move the new menu outside the parent bounds.
    // This is how we end up with child menus appearing (most-commonly) on the right of the parent menu.
    IM_ASSERT( g.CurrentWindow == window );
    ImGuiWindow* parent_window = g.CurrentWindowStack[ g.CurrentWindowStack.Size - 2 ];
    float horizontal_overlap = g.Style.ItemInnerSpacing.x; // We want some overlap to convey the relative depth of each menu (currently the amount of overlap is hard-coded to style.ItemSpacing.x).
    ImRect r_avoid;
    if( parent_window->DC.MenuBarAppending )
      r_avoid = ImRect( -FLT_MAX, parent_window->ClipRect.Min.y, FLT_MAX, parent_window->ClipRect.Max.y ); // Avoid parent menu-bar. If we wanted multi-line menu-bar, we may instead want to have the calling window setup e.g. a NextWindowData.PosConstraintAvoidRect field
    else
      r_avoid = ImRect( parent_window->Pos.x + horizontal_overlap, -FLT_MAX, parent_window->Pos.x + parent_window->Size.x - horizontal_overlap - parent_window->ScrollbarSizes.x, FLT_MAX );
    return FindBestWindowPosForPopupEx( window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid );
  }
  if( window->Flags & ImGuiWindowFlags_Popup )
  {
    ImRect r_avoid = ImRect( window->Pos.x - 1, window->Pos.y - 1, window->Pos.x + 1, window->Pos.y + 1 );
    return FindBestWindowPosForPopupEx( window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid );
  }
  if( window->Flags & ImGuiWindowFlags_Tooltip )
  {
    // Position tooltip (always follows mouse)
    float sc = g.Style.MouseCursorScale;
    ImVec2 ref_pos = NavCalcPreferredRefPos();
    ImRect r_avoid;
    if( !g.NavDisableHighlight && g.NavDisableMouseHover && !( g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos ) )
      r_avoid = ImRect( ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 16, ref_pos.y + 8 );
    else
      r_avoid = ImRect( ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24 * sc, ref_pos.y + 24 * sc ); // FIXME: Hard-coded based on mouse cursor shape expectation. Exact dimension not very important.
    ImVec2 pos = FindBestWindowPosForPopupEx( ref_pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid );
    if( window->AutoPosLastDirection == ImGuiDir_None )
      pos = ref_pos + ImVec2( 2, 2 ); // If there's not enough room, for tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.
    return pos;
  }
  IM_ASSERT( 0 );
  return window->Pos;
}

//-----------------------------------------------------------------------------
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
//-----------------------------------------------------------------------------

// FIXME-NAV: The existence of SetNavID vs SetNavIDWithRectRel vs SetFocusID is incredibly messy and confusing,
// and needs some explanation or serious refactoring.
void ImGui::SetNavID( ImGuiID id, int nav_layer, ImGuiID focus_scope_id )
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( g.NavWindow );
  IM_ASSERT( nav_layer == 0 || nav_layer == 1 );
  g.NavId = id;
  g.NavFocusScopeId = focus_scope_id;
  g.NavWindow->NavLastIds[ nav_layer ] = id;
}

void ImGui::SetNavIDWithRectRel( ImGuiID id, int nav_layer, ImGuiID focus_scope_id, const ImRect& rect_rel )
{
  ImGuiContext& g = *GImGui;
  SetNavID( id, nav_layer, focus_scope_id );
  g.NavWindow->NavRectRel[ nav_layer ] = rect_rel;
  g.NavMousePosDirty = true;
  g.NavDisableHighlight = false;
  g.NavDisableMouseHover = true;
}

void ImGui::SetFocusID( ImGuiID id, ImGuiWindow* window )
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( id != 0 );

  // Assume that SetFocusID() is called in the context where its window->DC.NavLayerCurrent and window->DC.NavFocusScopeIdCurrent are valid.
  // Note that window may be != g.CurrentWindow (e.g. SetFocusID call in InputTextEx for multi-line text)
  const ImGuiNavLayer nav_layer = window->DC.NavLayerCurrent;
  if( g.NavWindow != window )
    g.NavInitRequest = false;
  g.NavWindow = window;
  g.NavId = id;
  g.NavLayer = nav_layer;
  g.NavFocusScopeId = window->DC.NavFocusScopeIdCurrent;
  window->NavLastIds[ nav_layer ] = id;
  if( window->DC.LastItemId == id )
    window->NavRectRel[ nav_layer ] = ImRect( window->DC.LastItemRect.Min - window->Pos, window->DC.LastItemRect.Max - window->Pos );

  if( g.ActiveIdSource == ImGuiInputSource_Nav )
    g.NavDisableMouseHover = true;
  else
    g.NavDisableHighlight = true;
}

ImGuiDir ImGetDirQuadrantFromDelta( float dx, float dy )
{
  if( ImFabs( dx ) > ImFabs( dy ) )
    return ( dx > 0.0f ) ? ImGuiDir_Right : ImGuiDir_Left;
  return ( dy > 0.0f ) ? ImGuiDir_Down : ImGuiDir_Up;
}

static float inline NavScoreItemDistInterval( float a0, float a1, float b0, float b1 )
{
  if( a1 < b0 )
    return a1 - b0;
  if( b1 < a0 )
    return a0 - b1;
  return 0.0f;
}

static void inline NavClampRectToVisibleAreaForMoveDir( ImGuiDir move_dir, ImRect& r, const ImRect& clip_rect )
{
  if( move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right )
  {
    r.Min.y = ImClamp( r.Min.y, clip_rect.Min.y, clip_rect.Max.y );
    r.Max.y = ImClamp( r.Max.y, clip_rect.Min.y, clip_rect.Max.y );
  }
  else
  {
    r.Min.x = ImClamp( r.Min.x, clip_rect.Min.x, clip_rect.Max.x );
    r.Max.x = ImClamp( r.Max.x, clip_rect.Min.x, clip_rect.Max.x );
  }
}

// Scoring function for gamepad/keyboard directional navigation. Based on https://gist.github.com/rygorous/6981057
static bool ImGui::NavScoreItem( ImGuiNavMoveResult* result, ImRect cand )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  if( g.NavLayer != window->DC.NavLayerCurrent )
    return false;

  const ImRect& curr = g.NavScoringRect; // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)
  g.NavScoringCount++;

  // When entering through a NavFlattened border, we consider child window items as fully clipped for scoring
  if( window->ParentWindow == g.NavWindow )
  {
    IM_ASSERT( ( window->Flags | g.NavWindow->Flags ) & ImGuiWindowFlags_NavFlattened );
    if( !window->ClipRect.Overlaps( cand ) )
      return false;
    cand.ClipWithFull( window->ClipRect ); // This allows the scored item to not overlap other candidates in the parent window
  }

  // We perform scoring on items bounding box clipped by the current clipping rectangle on the other axis (clipping on our movement axis would give us equal scores for all clipped items)
  // For example, this ensure that items in one column are not reached when moving vertically from items in another column.
  NavClampRectToVisibleAreaForMoveDir( g.NavMoveClipDir, cand, window->ClipRect );

  // Compute distance between boxes
  // FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
  float dbx = NavScoreItemDistInterval( cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x );
  float dby = NavScoreItemDistInterval( ImLerp( cand.Min.y, cand.Max.y, 0.2f ), ImLerp( cand.Min.y, cand.Max.y, 0.8f ), ImLerp( curr.Min.y, curr.Max.y, 0.2f ), ImLerp( curr.Min.y, curr.Max.y, 0.8f ) ); // Scale down on Y to keep using box-distance for vertically touching items
  if( dby != 0.0f && dbx != 0.0f )
    dbx = ( dbx / 1000.0f ) + ( ( dbx > 0.0f ) ? +1.0f : -1.0f );
  float dist_box = ImFabs( dbx ) + ImFabs( dby );

  // Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)
  float dcx = ( cand.Min.x + cand.Max.x ) - ( curr.Min.x + curr.Max.x );
  float dcy = ( cand.Min.y + cand.Max.y ) - ( curr.Min.y + curr.Max.y );
  float dist_center = ImFabs( dcx ) + ImFabs( dcy ); // L1 metric (need this for our connectedness guarantee)

  // Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance
  ImGuiDir quadrant;
  float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;
  if( dbx != 0.0f || dby != 0.0f )
  {
    // For non-overlapping boxes, use distance between boxes
    dax = dbx;
    day = dby;
    dist_axial = dist_box;
    quadrant = ImGetDirQuadrantFromDelta( dbx, dby );
  }
  else if( dcx != 0.0f || dcy != 0.0f )
  {
    // For overlapping boxes with different centers, use distance between centers
    dax = dcx;
    day = dcy;
    dist_axial = dist_center;
    quadrant = ImGetDirQuadrantFromDelta( dcx, dcy );
  }
  else
  {
    // Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)
    quadrant = ( window->DC.LastItemId < g.NavId ) ? ImGuiDir_Left : ImGuiDir_Right;
  }

#if IMGUI_DEBUG_NAV_SCORING
  char buf[ 128 ];
  if( IsMouseHoveringRect( cand.Min, cand.Max ) )
  {
    ImFormatString( buf, IM_ARRAYSIZE( buf ), "dbox (%.2f,%.2f->%.4f)\ndcen (%.2f,%.2f->%.4f)\nd (%.2f,%.2f->%.4f)\nnav %c, quadrant %c", dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "WENS"[ g.NavMoveDir ], "WENS"[ quadrant ] );
    ImDrawList* draw_list = GetForegroundDrawList( window );
    draw_list->AddRect( curr.Min, curr.Max, IM_COL32( 255, 200, 0, 100 ) );
    draw_list->AddRect( cand.Min, cand.Max, IM_COL32( 255, 255, 0, 200 ) );
    draw_list->AddRectFilled( cand.Max - ImVec2( 4, 4 ), cand.Max + CalcTextSize( buf ) + ImVec2( 4, 4 ), IM_COL32( 40, 0, 0, 150 ) );
    draw_list->AddText( g.IO.FontDefault, 13.0f, cand.Max, ~0U, buf );
  }
  else if( g.IO.KeyCtrl ) // Hold to preview score in matching quadrant. Press C to rotate.
  {
    if( IsKeyPressedMap( ImGuiKey_C ) )
    {
      g.NavMoveDirLast = ( ImGuiDir )( ( g.NavMoveDirLast + 1 ) & 3 ); g.IO.KeysDownDuration[ g.IO.KeyMap[ ImGuiKey_C ] ] = 0.01f;
    }
    if( quadrant == g.NavMoveDir )
    {
      ImFormatString( buf, IM_ARRAYSIZE( buf ), "%.0f/%.0f", dist_box, dist_center );
      ImDrawList* draw_list = GetForegroundDrawList( window );
      draw_list->AddRectFilled( cand.Min, cand.Max, IM_COL32( 255, 0, 0, 200 ) );
      draw_list->AddText( g.IO.FontDefault, 13.0f, cand.Min, IM_COL32( 255, 255, 255, 255 ), buf );
    }
  }
#endif

  // Is it in the quadrant we're interesting in moving to?
  bool new_best = false;
  if( quadrant == g.NavMoveDir )
  {
    // Does it beat the current best candidate?
    if( dist_box < result->DistBox )
    {
      result->DistBox = dist_box;
      result->DistCenter = dist_center;
      return true;
    }
    if( dist_box == result->DistBox )
    {
      // Try using distance between center points to break ties
      if( dist_center < result->DistCenter )
      {
        result->DistCenter = dist_center;
        new_best = true;
      }
      else if( dist_center == result->DistCenter )
      {
        // Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" items
        // (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index),
        // this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.
        if( ( ( g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down ) ? dby : dbx ) < 0.0f ) // moving bj to the right/down decreases distance
          new_best = true;
      }
    }
  }

  // Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches
  // are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)
  // This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.
  // 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.
  // Disabling it may lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?
  if( result->DistBox == FLT_MAX && dist_axial < result->DistAxial )  // Check axial match
    if( g.NavLayer == ImGuiNavLayer_Menu && !( g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu ) )
      if( ( g.NavMoveDir == ImGuiDir_Left && dax < 0.0f ) || ( g.NavMoveDir == ImGuiDir_Right && dax > 0.0f ) || ( g.NavMoveDir == ImGuiDir_Up && day < 0.0f ) || ( g.NavMoveDir == ImGuiDir_Down && day > 0.0f ) )
      {
        result->DistAxial = dist_axial;
        new_best = true;
      }

  return new_best;
}

// We get there when either NavId == id, or when g.NavAnyRequest is set (which is updated by NavUpdateAnyRequestFlag above)
static void ImGui::NavProcessItem( ImGuiWindow* window, const ImRect& nav_bb, const ImGuiID id )
{
  ImGuiContext& g = *GImGui;
  //if (!g.IO.NavActive)  // [2017/10/06] Removed this possibly redundant test but I am not sure of all the side-effects yet. Some of the feature here will need to work regardless of using a _NoNavInputs flag.
  //    return;

  const ImGuiItemFlags item_flags = window->DC.ItemFlags;
  const ImRect nav_bb_rel( nav_bb.Min - window->Pos, nav_bb.Max - window->Pos );

  // Process Init Request
  if( g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent )
  {
    // Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
    if( !( item_flags & ImGuiItemFlags_NoNavDefaultFocus ) || g.NavInitResultId == 0 )
    {
      g.NavInitResultId = id;
      g.NavInitResultRectRel = nav_bb_rel;
    }
    if( !( item_flags & ImGuiItemFlags_NoNavDefaultFocus ) )
    {
      g.NavInitRequest = false; // Found a match, clear request
      NavUpdateAnyRequestFlag();
    }
  }

  // Process Move Request (scoring for navigation)
  // FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRectScreen + scoring from a rect wrapped according to current wrapping policy)
  if( ( g.NavId != id || ( g.NavMoveRequestFlags & ImGuiNavMoveFlags_AllowCurrentNavId ) ) && !( item_flags & ( ImGuiItemFlags_Disabled | ImGuiItemFlags_NoNav ) ) )
  {
    ImGuiNavMoveResult* result = ( window == g.NavWindow ) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;
#if IMGUI_DEBUG_NAV_SCORING
    // [DEBUG] Score all items in NavWindow at all times
    if( !g.NavMoveRequest )
      g.NavMoveDir = g.NavMoveDirLast;
    bool new_best = NavScoreItem( result, nav_bb ) && g.NavMoveRequest;
#else
    bool new_best = g.NavMoveRequest && NavScoreItem( result, nav_bb );
#endif
    if( new_best )
    {
      result->Window = window;
      result->ID = id;
      result->FocusScopeId = window->DC.NavFocusScopeIdCurrent;
      result->RectRel = nav_bb_rel;
    }

    // Features like PageUp/PageDown need to maintain a separate score for the visible set of items.
    const float VISIBLE_RATIO = 0.70f;
    if( ( g.NavMoveRequestFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet ) && window->ClipRect.Overlaps( nav_bb ) )
      if( ImClamp( nav_bb.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y ) - ImClamp( nav_bb.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y ) >= ( nav_bb.Max.y - nav_bb.Min.y ) * VISIBLE_RATIO )
        if( NavScoreItem( &g.NavMoveResultLocalVisibleSet, nav_bb ) )
        {
          result = &g.NavMoveResultLocalVisibleSet;
          result->Window = window;
          result->ID = id;
          result->FocusScopeId = window->DC.NavFocusScopeIdCurrent;
          result->RectRel = nav_bb_rel;
        }
  }

  // Update window-relative bounding box of navigated item
  if( g.NavId == id )
  {
    g.NavWindow = window;                                           // Always refresh g.NavWindow, because some operations such as FocusItem() don't have a window.
    g.NavLayer = window->DC.NavLayerCurrent;
    g.NavFocusScopeId = window->DC.NavFocusScopeIdCurrent;
    g.NavIdIsAlive = true;
    g.NavIdTabCounter = window->DC.FocusCounterTabStop;
    window->NavRectRel[ window->DC.NavLayerCurrent ] = nav_bb_rel;    // Store item bounding box (relative to window position)
  }
}

bool ImGui::NavMoveRequestButNoResultYet()
{
  ImGuiContext& g = *GImGui;
  return g.NavMoveRequest && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;
}

void ImGui::NavMoveRequestCancel()
{
  ImGuiContext& g = *GImGui;
  g.NavMoveRequest = false;
  NavUpdateAnyRequestFlag();
}

void ImGui::NavMoveRequestForward( ImGuiDir move_dir, ImGuiDir clip_dir, const ImRect& bb_rel, ImGuiNavMoveFlags move_flags )
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( g.NavMoveRequestForward == ImGuiNavForward_None );
  NavMoveRequestCancel();
  g.NavMoveDir = move_dir;
  g.NavMoveClipDir = clip_dir;
  g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;
  g.NavMoveRequestFlags = move_flags;
  g.NavWindow->NavRectRel[ g.NavLayer ] = bb_rel;
}

void ImGui::NavMoveRequestTryWrapping( ImGuiWindow* window, ImGuiNavMoveFlags move_flags )
{
  ImGuiContext& g = *GImGui;
  if( g.NavWindow != window || !NavMoveRequestButNoResultYet() || g.NavMoveRequestForward != ImGuiNavForward_None || g.NavLayer != ImGuiNavLayer_Main )
    return;
  IM_ASSERT( move_flags != 0 ); // No points calling this with no wrapping
  ImRect bb_rel = window->NavRectRel[ 0 ];

  ImGuiDir clip_dir = g.NavMoveDir;
  if( g.NavMoveDir == ImGuiDir_Left && ( move_flags & ( ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX ) ) )
  {
    bb_rel.Min.x = bb_rel.Max.x = ImMax( window->SizeFull.x, window->ContentSize.x + window->WindowPadding.x * 2.0f ) - window->Scroll.x;
    if( move_flags & ImGuiNavMoveFlags_WrapX )
    {
      bb_rel.TranslateY( -bb_rel.GetHeight() ); clip_dir = ImGuiDir_Up;
    }
    NavMoveRequestForward( g.NavMoveDir, clip_dir, bb_rel, move_flags );
  }
  if( g.NavMoveDir == ImGuiDir_Right && ( move_flags & ( ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX ) ) )
  {
    bb_rel.Min.x = bb_rel.Max.x = -window->Scroll.x;
    if( move_flags & ImGuiNavMoveFlags_WrapX )
    {
      bb_rel.TranslateY( +bb_rel.GetHeight() ); clip_dir = ImGuiDir_Down;
    }
    NavMoveRequestForward( g.NavMoveDir, clip_dir, bb_rel, move_flags );
  }
  if( g.NavMoveDir == ImGuiDir_Up && ( move_flags & ( ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY ) ) )
  {
    bb_rel.Min.y = bb_rel.Max.y = ImMax( window->SizeFull.y, window->ContentSize.y + window->WindowPadding.y * 2.0f ) - window->Scroll.y;
    if( move_flags & ImGuiNavMoveFlags_WrapY )
    {
      bb_rel.TranslateX( -bb_rel.GetWidth() ); clip_dir = ImGuiDir_Left;
    }
    NavMoveRequestForward( g.NavMoveDir, clip_dir, bb_rel, move_flags );
  }
  if( g.NavMoveDir == ImGuiDir_Down && ( move_flags & ( ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY ) ) )
  {
    bb_rel.Min.y = bb_rel.Max.y = -window->Scroll.y;
    if( move_flags & ImGuiNavMoveFlags_WrapY )
    {
      bb_rel.TranslateX( +bb_rel.GetWidth() ); clip_dir = ImGuiDir_Right;
    }
    NavMoveRequestForward( g.NavMoveDir, clip_dir, bb_rel, move_flags );
  }
}

// FIXME: This could be replaced by updating a frame number in each window when (window == NavWindow) and (NavLayer == 0).
// This way we could find the last focused window among our children. It would be much less confusing this way?
static void ImGui::NavSaveLastChildNavWindowIntoParent( ImGuiWindow* nav_window )
{
  ImGuiWindow* parent_window = nav_window;
  while( parent_window && ( parent_window->Flags & ImGuiWindowFlags_ChildWindow ) != 0 && ( parent_window->Flags & ( ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu ) ) == 0 )
    parent_window = parent_window->ParentWindow;
  if( parent_window && parent_window != nav_window )
    parent_window->NavLastChildNavWindow = nav_window;
}

// Restore the last focused child.
// Call when we are expected to land on the Main Layer (0) after FocusWindow()
static ImGuiWindow* ImGui::NavRestoreLastChildNavWindow( ImGuiWindow* window )
{
  return window->NavLastChildNavWindow ? window->NavLastChildNavWindow : window;
}

static void NavRestoreLayer( ImGuiNavLayer layer )
{
  ImGuiContext& g = *GImGui;
  g.NavLayer = layer;
  if( layer == 0 )
    g.NavWindow = ImGui::NavRestoreLastChildNavWindow( g.NavWindow );
  ImGuiWindow* window = g.NavWindow;
  if( layer == 0 && window->NavLastIds[ 0 ] != 0 )
    ImGui::SetNavIDWithRectRel( window->NavLastIds[ 0 ], layer, 0, window->NavRectRel[ 0 ] );
  else
    ImGui::NavInitWindow( window, true );
}

static inline void ImGui::NavUpdateAnyRequestFlag()
{
  ImGuiContext& g = *GImGui;
  g.NavAnyRequest = g.NavMoveRequest || g.NavInitRequest || ( IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL );
  if( g.NavAnyRequest )
    IM_ASSERT( g.NavWindow != NULL );
}

// This needs to be called before we submit any widget (aka in or before Begin)
void ImGui::NavInitWindow( ImGuiWindow* window, bool force_reinit )
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( window == g.NavWindow );
  bool init_for_nav = false;
  if( !( window->Flags & ImGuiWindowFlags_NoNavInputs ) )
    if( !( window->Flags & ImGuiWindowFlags_ChildWindow ) || ( window->Flags & ImGuiWindowFlags_Popup ) || ( window->NavLastIds[ 0 ] == 0 ) || force_reinit )
      init_for_nav = true;
  //IMGUI_DEBUG_LOG("[Nav] NavInitWindow() init_for_nav=%d, window=\"%s\", layer=%d\n", init_for_nav, window->Name, g.NavLayer);
  if( init_for_nav )
  {
    SetNavID( 0, g.NavLayer, 0 );
    g.NavInitRequest = true;
    g.NavInitRequestFromMove = false;
    g.NavInitResultId = 0;
    g.NavInitResultRectRel = ImRect();
    NavUpdateAnyRequestFlag();
  }
  else
  {
    g.NavId = window->NavLastIds[ 0 ];
    g.NavFocusScopeId = 0;
  }
}

static ImVec2 ImGui::NavCalcPreferredRefPos()
{
  ImGuiContext& g = *GImGui;
  if( g.NavDisableHighlight || !g.NavDisableMouseHover || !g.NavWindow )
  {
    // Mouse (we need a fallback in case the mouse becomes invalid after being used)
    if( IsMousePosValid( &g.IO.MousePos ) )
      return g.IO.MousePos;
    return g.LastValidMousePos;
  }
  else
  {
    // When navigation is active and mouse is disabled, decide on an arbitrary position around the bottom left of the currently navigated item.
    const ImRect& rect_rel = g.NavWindow->NavRectRel[ g.NavLayer ];
    ImVec2 pos = g.NavWindow->Pos + ImVec2( rect_rel.Min.x + ImMin( g.Style.FramePadding.x * 4, rect_rel.GetWidth() ), rect_rel.Max.y - ImMin( g.Style.FramePadding.y, rect_rel.GetHeight() ) );
    ImRect visible_rect = GetViewportRect();
    return ImFloor( ImClamp( pos, visible_rect.Min, visible_rect.Max ) );   // ImFloor() is important because non-integer mouse position application in back-end might be lossy and result in undesirable non-zero delta.
  }
}

float ImGui::GetNavInputAmount( ImGuiNavInput n, ImGuiInputReadMode mode )
{
  ImGuiContext& g = *GImGui;
  if( mode == ImGuiInputReadMode_Down )
    return g.IO.NavInputs[ n ];                         // Instant, read analog input (0.0f..1.0f, as provided by user)

  const float t = g.IO.NavInputsDownDuration[ n ];
  if( t < 0.0f && mode == ImGuiInputReadMode_Released )  // Return 1.0f when just released, no repeat, ignore analog input.
    return ( g.IO.NavInputsDownDurationPrev[ n ] >= 0.0f ? 1.0f : 0.0f );
  if( t < 0.0f )
    return 0.0f;
  if( mode == ImGuiInputReadMode_Pressed )               // Return 1.0f when just pressed, no repeat, ignore analog input.
    return ( t == 0.0f ) ? 1.0f : 0.0f;
  if( mode == ImGuiInputReadMode_Repeat )
    return ( float )CalcTypematicRepeatAmount( t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay * 0.72f, g.IO.KeyRepeatRate * 0.80f );
  if( mode == ImGuiInputReadMode_RepeatSlow )
    return ( float )CalcTypematicRepeatAmount( t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay * 1.25f, g.IO.KeyRepeatRate * 2.00f );
  if( mode == ImGuiInputReadMode_RepeatFast )
    return ( float )CalcTypematicRepeatAmount( t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay * 0.72f, g.IO.KeyRepeatRate * 0.30f );
  return 0.0f;
}

ImVec2 ImGui::GetNavInputAmount2d( ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor, float fast_factor )
{
  ImVec2 delta( 0.0f, 0.0f );
  if( dir_sources & ImGuiNavDirSourceFlags_Keyboard )
    delta += ImVec2( GetNavInputAmount( ImGuiNavInput_KeyRight_, mode ) - GetNavInputAmount( ImGuiNavInput_KeyLeft_, mode ), GetNavInputAmount( ImGuiNavInput_KeyDown_, mode ) - GetNavInputAmount( ImGuiNavInput_KeyUp_, mode ) );
  if( dir_sources & ImGuiNavDirSourceFlags_PadDPad )
    delta += ImVec2( GetNavInputAmount( ImGuiNavInput_DpadRight, mode ) - GetNavInputAmount( ImGuiNavInput_DpadLeft, mode ), GetNavInputAmount( ImGuiNavInput_DpadDown, mode ) - GetNavInputAmount( ImGuiNavInput_DpadUp, mode ) );
  if( dir_sources & ImGuiNavDirSourceFlags_PadLStick )
    delta += ImVec2( GetNavInputAmount( ImGuiNavInput_LStickRight, mode ) - GetNavInputAmount( ImGuiNavInput_LStickLeft, mode ), GetNavInputAmount( ImGuiNavInput_LStickDown, mode ) - GetNavInputAmount( ImGuiNavInput_LStickUp, mode ) );
  if( slow_factor != 0.0f && IsNavInputDown( ImGuiNavInput_TweakSlow ) )
    delta *= slow_factor;
  if( fast_factor != 0.0f && IsNavInputDown( ImGuiNavInput_TweakFast ) )
    delta *= fast_factor;
  return delta;
}

static void ImGui::NavUpdate()
{
  ImGuiContext& g = *GImGui;
  g.IO.WantSetMousePos = false;
#if 0
  if( g.NavScoringCount > 0 ) IMGUI_DEBUG_LOG( "NavScoringCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.FrameCount, g.NavScoringCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest );
#endif

  // Set input source as Gamepad when buttons are pressed (as some features differs when used with Gamepad vs Keyboard)
  // (do it before we map Keyboard input!)
  bool nav_keyboard_active = ( g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard ) != 0;
  bool nav_gamepad_active = ( g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad ) != 0 && ( g.IO.BackendFlags & ImGuiBackendFlags_HasGamepad ) != 0;
  if( nav_gamepad_active )
    if( g.IO.NavInputs[ ImGuiNavInput_Activate ] > 0.0f || g.IO.NavInputs[ ImGuiNavInput_Input ] > 0.0f || g.IO.NavInputs[ ImGuiNavInput_Cancel ] > 0.0f || g.IO.NavInputs[ ImGuiNavInput_Menu ] > 0.0f )
      g.NavInputSource = ImGuiInputSource_NavGamepad;

  // Update Keyboard->Nav inputs mapping
  if( nav_keyboard_active )
  {
#define NAV_MAP_KEY(_KEY, _NAV_INPUT)  do { if (IsKeyDown(g.IO.KeyMap[_KEY])) { g.IO.NavInputs[_NAV_INPUT] = 1.0f; g.NavInputSource = ImGuiInputSource_NavKeyboard; } } while (0)
    NAV_MAP_KEY( ImGuiKey_Space, ImGuiNavInput_Activate );
    NAV_MAP_KEY( ImGuiKey_Enter, ImGuiNavInput_Input );
    NAV_MAP_KEY( ImGuiKey_Escape, ImGuiNavInput_Cancel );
    NAV_MAP_KEY( ImGuiKey_LeftArrow, ImGuiNavInput_KeyLeft_ );
    NAV_MAP_KEY( ImGuiKey_RightArrow, ImGuiNavInput_KeyRight_ );
    NAV_MAP_KEY( ImGuiKey_UpArrow, ImGuiNavInput_KeyUp_ );
    NAV_MAP_KEY( ImGuiKey_DownArrow, ImGuiNavInput_KeyDown_ );
    if( g.IO.KeyCtrl )
      g.IO.NavInputs[ ImGuiNavInput_TweakSlow ] = 1.0f;
    if( g.IO.KeyShift )
      g.IO.NavInputs[ ImGuiNavInput_TweakFast ] = 1.0f;
    if( g.IO.KeyAlt && !g.IO.KeyCtrl ) // AltGR is Alt+Ctrl, also even on keyboards without AltGR we don't want Alt+Ctrl to open menu.
      g.IO.NavInputs[ ImGuiNavInput_KeyMenu_ ] = 1.0f;
#undef NAV_MAP_KEY
  }
  memcpy( g.IO.NavInputsDownDurationPrev, g.IO.NavInputsDownDuration, sizeof( g.IO.NavInputsDownDuration ) );
  for( int i = 0; i < IM_ARRAYSIZE( g.IO.NavInputs ); i++ )
    g.IO.NavInputsDownDuration[ i ] = ( g.IO.NavInputs[ i ] > 0.0f ) ? ( g.IO.NavInputsDownDuration[ i ] < 0.0f ? 0.0f : g.IO.NavInputsDownDuration[ i ] + g.IO.DeltaTime ) : -1.0f;

  // Process navigation init request (select first/default focus)
  // In very rare cases g.NavWindow may be null (e.g. clearing focus after requesting an init request, which does happen when releasing Alt while clicking on void)
  if( g.NavInitResultId != 0 && ( !g.NavDisableHighlight || g.NavInitRequestFromMove ) && g.NavWindow )
  {
    // Apply result from previous navigation init request (will typically select the first item, unless SetItemDefaultFocus() has been called)
    //IMGUI_DEBUG_LOG("[Nav] Apply NavInitRequest result: 0x%08X Layer %d in \"%s\"\n", g.NavInitResultId, g.NavLayer, g.NavWindow->Name);
    if( g.NavInitRequestFromMove )
      SetNavIDWithRectRel( g.NavInitResultId, g.NavLayer, 0, g.NavInitResultRectRel );
    else
      SetNavID( g.NavInitResultId, g.NavLayer, 0 );
    g.NavWindow->NavRectRel[ g.NavLayer ] = g.NavInitResultRectRel;
  }
  g.NavInitRequest = false;
  g.NavInitRequestFromMove = false;
  g.NavInitResultId = 0;
  g.NavJustMovedToId = 0;

  // Process navigation move request
  if( g.NavMoveRequest )
    NavUpdateMoveResult();

  // When a forwarded move request failed, we restore the highlight that we disabled during the forward frame
  if( g.NavMoveRequestForward == ImGuiNavForward_ForwardActive )
  {
    IM_ASSERT( g.NavMoveRequest );
    if( g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0 )
      g.NavDisableHighlight = false;
    g.NavMoveRequestForward = ImGuiNavForward_None;
  }

  // Apply application mouse position movement, after we had a chance to process move request result.
  if( g.NavMousePosDirty && g.NavIdIsAlive )
  {
    // Set mouse position given our knowledge of the navigated item position from last frame
    if( ( g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos ) && ( g.IO.BackendFlags & ImGuiBackendFlags_HasSetMousePos ) )
    {
      if( !g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow )
      {
        g.IO.MousePos = g.IO.MousePosPrev = NavCalcPreferredRefPos();
        g.IO.WantSetMousePos = true;
      }
    }
    g.NavMousePosDirty = false;
  }
  g.NavIdIsAlive = false;
  g.NavJustTabbedId = 0;
  IM_ASSERT( g.NavLayer == 0 || g.NavLayer == 1 );

  // Store our return window (for returning from Layer 1 to Layer 0) and clear it as soon as we step back in our own Layer 0
  if( g.NavWindow )
    NavSaveLastChildNavWindowIntoParent( g.NavWindow );
  if( g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL && g.NavLayer == ImGuiNavLayer_Main )
    g.NavWindow->NavLastChildNavWindow = NULL;

  // Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
  NavUpdateWindowing();

  // Set output flags for user application
  g.IO.NavActive = ( nav_keyboard_active || nav_gamepad_active ) && g.NavWindow && !( g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs );
  g.IO.NavVisible = ( g.IO.NavActive && g.NavId != 0 && !g.NavDisableHighlight ) || ( g.NavWindowingTarget != NULL );

  // Process NavCancel input (to close a popup, get back to parent, clear focus)
  if( IsNavInputTest( ImGuiNavInput_Cancel, ImGuiInputReadMode_Pressed ) )
  {
    if( g.ActiveId != 0 )
    {
      if( !IsActiveIdUsingNavInput( ImGuiNavInput_Cancel ) )
        ClearActiveID();
    }
    else if( g.NavWindow && ( g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow ) && !( g.NavWindow->Flags & ImGuiWindowFlags_Popup ) && g.NavWindow->ParentWindow )
    {
      // Exit child window
      ImGuiWindow* child_window = g.NavWindow;
      ImGuiWindow* parent_window = g.NavWindow->ParentWindow;
      IM_ASSERT( child_window->ChildId != 0 );
      FocusWindow( parent_window );
      SetNavID( child_window->ChildId, 0, 0 );
      // Reassigning with same value, we're being explicit here.
      g.NavIdIsAlive = false;     // -V1048
      if( g.NavDisableMouseHover )
        g.NavMousePosDirty = true;
    }
    else if( g.OpenPopupStack.Size > 0 )
    {
      // Close open popup/menu
      if( !( g.OpenPopupStack.back().Window->Flags & ImGuiWindowFlags_Modal ) )
        ClosePopupToLevel( g.OpenPopupStack.Size - 1, true );
    }
    else if( g.NavLayer != ImGuiNavLayer_Main )
    {
      // Leave the "menu" layer
      NavRestoreLayer( ImGuiNavLayer_Main );
    }
    else
    {
      // Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
      if( g.NavWindow && ( ( g.NavWindow->Flags & ImGuiWindowFlags_Popup ) || !( g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow ) ) )
        g.NavWindow->NavLastIds[ 0 ] = 0;
      g.NavId = g.NavFocusScopeId = 0;
    }
  }

  // Process manual activation request
  g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = 0;
  if( g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget && g.NavWindow && !( g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs ) )
  {
    bool activate_down = IsNavInputDown( ImGuiNavInput_Activate );
    bool activate_pressed = activate_down && IsNavInputTest( ImGuiNavInput_Activate, ImGuiInputReadMode_Pressed );
    if( g.ActiveId == 0 && activate_pressed )
      g.NavActivateId = g.NavId;
    if( ( g.ActiveId == 0 || g.ActiveId == g.NavId ) && activate_down )
      g.NavActivateDownId = g.NavId;
    if( ( g.ActiveId == 0 || g.ActiveId == g.NavId ) && activate_pressed )
      g.NavActivatePressedId = g.NavId;
    if( ( g.ActiveId == 0 || g.ActiveId == g.NavId ) && IsNavInputTest( ImGuiNavInput_Input, ImGuiInputReadMode_Pressed ) )
      g.NavInputId = g.NavId;
  }
  if( g.NavWindow && ( g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs ) )
    g.NavDisableHighlight = true;
  if( g.NavActivateId != 0 )
    IM_ASSERT( g.NavActivateDownId == g.NavActivateId );
  g.NavMoveRequest = false;

  // Process programmatic activation request
  if( g.NavNextActivateId != 0 )
    g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = g.NavNextActivateId;
  g.NavNextActivateId = 0;

  // Initiate directional inputs request
  if( g.NavMoveRequestForward == ImGuiNavForward_None )
  {
    g.NavMoveDir = ImGuiDir_None;
    g.NavMoveRequestFlags = ImGuiNavMoveFlags_None;
    if( g.NavWindow && !g.NavWindowingTarget && !( g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs ) )
    {
      const ImGuiInputReadMode read_mode = ImGuiInputReadMode_Repeat;
      if( !IsActiveIdUsingNavDir( ImGuiDir_Left ) && ( IsNavInputTest( ImGuiNavInput_DpadLeft, read_mode ) || IsNavInputTest( ImGuiNavInput_KeyLeft_, read_mode ) ) )
      {
        g.NavMoveDir = ImGuiDir_Left;
      }
      if( !IsActiveIdUsingNavDir( ImGuiDir_Right ) && ( IsNavInputTest( ImGuiNavInput_DpadRight, read_mode ) || IsNavInputTest( ImGuiNavInput_KeyRight_, read_mode ) ) )
      {
        g.NavMoveDir = ImGuiDir_Right;
      }
      if( !IsActiveIdUsingNavDir( ImGuiDir_Up ) && ( IsNavInputTest( ImGuiNavInput_DpadUp, read_mode ) || IsNavInputTest( ImGuiNavInput_KeyUp_, read_mode ) ) )
      {
        g.NavMoveDir = ImGuiDir_Up;
      }
      if( !IsActiveIdUsingNavDir( ImGuiDir_Down ) && ( IsNavInputTest( ImGuiNavInput_DpadDown, read_mode ) || IsNavInputTest( ImGuiNavInput_KeyDown_, read_mode ) ) )
      {
        g.NavMoveDir = ImGuiDir_Down;
      }
    }
    g.NavMoveClipDir = g.NavMoveDir;
  }
  else
  {
    // Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
    // (Preserve g.NavMoveRequestFlags, g.NavMoveClipDir which were set by the NavMoveRequestForward() function)
    IM_ASSERT( g.NavMoveDir != ImGuiDir_None && g.NavMoveClipDir != ImGuiDir_None );
    IM_ASSERT( g.NavMoveRequestForward == ImGuiNavForward_ForwardQueued );
    g.NavMoveRequestForward = ImGuiNavForward_ForwardActive;
  }

  // Update PageUp/PageDown/Home/End scroll
  // FIXME-NAV: Consider enabling those keys even without the master ImGuiConfigFlags_NavEnableKeyboard flag?
  float nav_scoring_rect_offset_y = 0.0f;
  if( nav_keyboard_active )
    nav_scoring_rect_offset_y = NavUpdatePageUpPageDown();

  // If we initiate a movement request and have no current NavId, we initiate a InitDefautRequest that will be used as a fallback if the direction fails to find a match
  if( g.NavMoveDir != ImGuiDir_None )
  {
    g.NavMoveRequest = true;
    g.NavMoveRequestKeyMods = g.IO.KeyMods;
    g.NavMoveDirLast = g.NavMoveDir;
  }
  if( g.NavMoveRequest && g.NavId == 0 )
  {
    //IMGUI_DEBUG_LOG("[Nav] NavInitRequest from move, window \"%s\", layer=%d\n", g.NavWindow->Name, g.NavLayer);
    g.NavInitRequest = g.NavInitRequestFromMove = true;
    // Reassigning with same value, we're being explicit here.
    g.NavInitResultId = 0;     // -V1048
    g.NavDisableHighlight = false;
  }
  NavUpdateAnyRequestFlag();

  // Scrolling
  if( g.NavWindow && !( g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs ) && !g.NavWindowingTarget )
  {
    // *Fallback* manual-scroll with Nav directional keys when window has no navigable item
    ImGuiWindow* window = g.NavWindow;
    const float scroll_speed = IM_ROUND( window->CalcFontSize() * 100 * g.IO.DeltaTime ); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.
    if( window->DC.NavLayerActiveMask == 0x00 && window->DC.NavHasScroll && g.NavMoveRequest )
    {
      if( g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right )
        SetScrollX( window, ImFloor( window->Scroll.x + ( ( g.NavMoveDir == ImGuiDir_Left ) ? -1.0f : +1.0f ) * scroll_speed ) );
      if( g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down )
        SetScrollY( window, ImFloor( window->Scroll.y + ( ( g.NavMoveDir == ImGuiDir_Up ) ? -1.0f : +1.0f ) * scroll_speed ) );
    }

    // *Normal* Manual scroll with NavScrollXXX keys
    // Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
    ImVec2 scroll_dir = GetNavInputAmount2d( ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down, 1.0f / 10.0f, 10.0f );
    if( scroll_dir.x != 0.0f && window->ScrollbarX )
    {
      SetScrollX( window, ImFloor( window->Scroll.x + scroll_dir.x * scroll_speed ) );
      g.NavMoveFromClampedRefRect = true;
    }
    if( scroll_dir.y != 0.0f )
    {
      SetScrollY( window, ImFloor( window->Scroll.y + scroll_dir.y * scroll_speed ) );
      g.NavMoveFromClampedRefRect = true;
    }
  }

  // Reset search results
  g.NavMoveResultLocal.Clear();
  g.NavMoveResultLocalVisibleSet.Clear();
  g.NavMoveResultOther.Clear();

  // When we have manually scrolled (without using navigation) and NavId becomes out of bounds, we project its bounding box to the visible area to restart navigation within visible items
  if( g.NavMoveRequest && g.NavMoveFromClampedRefRect && g.NavLayer == ImGuiNavLayer_Main )
  {
    ImGuiWindow* window = g.NavWindow;
    ImRect window_rect_rel( window->InnerRect.Min - window->Pos - ImVec2( 1, 1 ), window->InnerRect.Max - window->Pos + ImVec2( 1, 1 ) );
    if( !window_rect_rel.Contains( window->NavRectRel[ g.NavLayer ] ) )
    {
      float pad = window->CalcFontSize() * 0.5f;
      window_rect_rel.Expand( ImVec2( -ImMin( window_rect_rel.GetWidth(), pad ), -ImMin( window_rect_rel.GetHeight(), pad ) ) ); // Terrible approximation for the intent of starting navigation from first fully visible item
      window->NavRectRel[ g.NavLayer ].ClipWith( window_rect_rel );
      g.NavId = g.NavFocusScopeId = 0;
    }
    g.NavMoveFromClampedRefRect = false;
  }

  // For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
  ImRect nav_rect_rel = ( g.NavWindow && !g.NavWindow->NavRectRel[ g.NavLayer ].IsInverted() ) ? g.NavWindow->NavRectRel[ g.NavLayer ] : ImRect( 0, 0, 0, 0 );
  g.NavScoringRect = g.NavWindow ? ImRect( g.NavWindow->Pos + nav_rect_rel.Min, g.NavWindow->Pos + nav_rect_rel.Max ) : GetViewportRect();
  g.NavScoringRect.TranslateY( nav_scoring_rect_offset_y );
  g.NavScoringRect.Min.x = ImMin( g.NavScoringRect.Min.x + 1.0f, g.NavScoringRect.Max.x );
  g.NavScoringRect.Max.x = g.NavScoringRect.Min.x;
  IM_ASSERT( !g.NavScoringRect.IsInverted() ); // Ensure if we have a finite, non-inverted bounding box here will allows us to remove extraneous ImFabs() calls in NavScoreItem().
  //GetForegroundDrawList()->AddRect(g.NavScoringRectScreen.Min, g.NavScoringRectScreen.Max, IM_COL32(255,200,0,255)); // [DEBUG]
  g.NavScoringCount = 0;
#if IMGUI_DEBUG_NAV_RECTS
  if( g.NavWindow )
  {
    ImDrawList* draw_list = GetForegroundDrawList( g.NavWindow );
    if( 1 )
    {
      for( int layer = 0; layer < 2; layer++ ) draw_list->AddRect( g.NavWindow->Pos + g.NavWindow->NavRectRel[ layer ].Min, g.NavWindow->Pos + g.NavWindow->NavRectRel[ layer ].Max, IM_COL32( 255, 200, 0, 255 ) );
    } // [DEBUG]
    if( 1 )
    {
      ImU32 col = ( !g.NavWindow->Hidden ) ? IM_COL32( 255, 0, 255, 255 ) : IM_COL32( 255, 0, 0, 255 ); ImVec2 p = NavCalcPreferredRefPos(); char buf[ 32 ]; ImFormatString( buf, 32, "%d", g.NavLayer ); draw_list->AddCircleFilled( p, 3.0f, col ); draw_list->AddText( NULL, 13.0f, p + ImVec2( 8, -4 ), col, buf );
    }
  }
#endif
}

// Apply result from previous frame navigation directional move request
static void ImGui::NavUpdateMoveResult()
{
  ImGuiContext& g = *GImGui;
  if( g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0 )
  {
    // In a situation when there is no results but NavId != 0, re-enable the Navigation highlight (because g.NavId is not considered as a possible result)
    if( g.NavId != 0 )
    {
      g.NavDisableHighlight = false;
      g.NavDisableMouseHover = true;
    }
    return;
  }

  // Select which result to use
  ImGuiNavMoveResult* result = ( g.NavMoveResultLocal.ID != 0 ) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;

  // PageUp/PageDown behavior first jumps to the bottom/top mostly visible item, _otherwise_ use the result from the previous/next page.
  if( g.NavMoveRequestFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet )
    if( g.NavMoveResultLocalVisibleSet.ID != 0 && g.NavMoveResultLocalVisibleSet.ID != g.NavId )
      result = &g.NavMoveResultLocalVisibleSet;

  // Maybe entering a flattened child from the outside? In this case solve the tie using the regular scoring rules.
  if( result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window->ParentWindow == g.NavWindow )
    if( ( g.NavMoveResultOther.DistBox < result->DistBox ) || ( g.NavMoveResultOther.DistBox == result->DistBox && g.NavMoveResultOther.DistCenter < result->DistCenter ) )
      result = &g.NavMoveResultOther;
  IM_ASSERT( g.NavWindow && result->Window );

  // Scroll to keep newly navigated item fully into view.
  if( g.NavLayer == ImGuiNavLayer_Main )
  {
    ImVec2 delta_scroll;
    if( g.NavMoveRequestFlags & ImGuiNavMoveFlags_ScrollToEdge )
    {
      float scroll_target = ( g.NavMoveDir == ImGuiDir_Up ) ? result->Window->ScrollMax.y : 0.0f;
      delta_scroll.y = result->Window->Scroll.y - scroll_target;
      SetScrollY( result->Window, scroll_target );
    }
    else
    {
      ImRect rect_abs = ImRect( result->RectRel.Min + result->Window->Pos, result->RectRel.Max + result->Window->Pos );
      delta_scroll = ScrollToBringRectIntoView( result->Window, rect_abs );
    }

    // Offset our result position so mouse position can be applied immediately after in NavUpdate()
    result->RectRel.TranslateX( -delta_scroll.x );
    result->RectRel.TranslateY( -delta_scroll.y );
  }

  ClearActiveID();
  g.NavWindow = result->Window;
  if( g.NavId != result->ID )
  {
    // Don't set NavJustMovedToId if just landed on the same spot (which may happen with ImGuiNavMoveFlags_AllowCurrentNavId)
    g.NavJustMovedToId = result->ID;
    g.NavJustMovedToFocusScopeId = result->FocusScopeId;
    g.NavJustMovedToKeyMods = g.NavMoveRequestKeyMods;
  }
  SetNavIDWithRectRel( result->ID, g.NavLayer, result->FocusScopeId, result->RectRel );
  g.NavMoveFromClampedRefRect = false;
}

// Handle PageUp/PageDown/Home/End keys
static float ImGui::NavUpdatePageUpPageDown()
{
  ImGuiContext& g = *GImGui;
  if( g.NavMoveDir != ImGuiDir_None || g.NavWindow == NULL )
    return 0.0f;
  if( ( g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs ) || g.NavWindowingTarget != NULL || g.NavLayer != ImGuiNavLayer_Main )
    return 0.0f;

  ImGuiWindow* window = g.NavWindow;
  const bool page_up_held = IsKeyDown( g.IO.KeyMap[ ImGuiKey_PageUp ] ) && !IsActiveIdUsingKey( ImGuiKey_PageUp );
  const bool page_down_held = IsKeyDown( g.IO.KeyMap[ ImGuiKey_PageDown ] ) && !IsActiveIdUsingKey( ImGuiKey_PageDown );
  const bool home_pressed = IsKeyPressed( g.IO.KeyMap[ ImGuiKey_Home ] ) && !IsActiveIdUsingKey( ImGuiKey_Home );
  const bool end_pressed = IsKeyPressed( g.IO.KeyMap[ ImGuiKey_End ] ) && !IsActiveIdUsingKey( ImGuiKey_End );
  if( page_up_held != page_down_held || home_pressed != end_pressed ) // If either (not both) are pressed
  {
    if( window->DC.NavLayerActiveMask == 0x00 && window->DC.NavHasScroll )
    {
      // Fallback manual-scroll when window has no navigable item
      if( IsKeyPressed( g.IO.KeyMap[ ImGuiKey_PageUp ], true ) )
        SetScrollY( window, window->Scroll.y - window->InnerRect.GetHeight() );
      else if( IsKeyPressed( g.IO.KeyMap[ ImGuiKey_PageDown ], true ) )
        SetScrollY( window, window->Scroll.y + window->InnerRect.GetHeight() );
      else if( home_pressed )
        SetScrollY( window, 0.0f );
      else if( end_pressed )
        SetScrollY( window, window->ScrollMax.y );
    }
    else
    {
      ImRect& nav_rect_rel = window->NavRectRel[ g.NavLayer ];
      const float page_offset_y = ImMax( 0.0f, window->InnerRect.GetHeight() - window->CalcFontSize() * 1.0f + nav_rect_rel.GetHeight() );
      float nav_scoring_rect_offset_y = 0.0f;
      if( IsKeyPressed( g.IO.KeyMap[ ImGuiKey_PageUp ], true ) )
      {
        nav_scoring_rect_offset_y = -page_offset_y;
        g.NavMoveDir = ImGuiDir_Down; // Because our scoring rect is offset up, we request the down direction (so we can always land on the last item)
        g.NavMoveClipDir = ImGuiDir_Up;
        g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;
      }
      else if( IsKeyPressed( g.IO.KeyMap[ ImGuiKey_PageDown ], true ) )
      {
        nav_scoring_rect_offset_y = +page_offset_y;
        g.NavMoveDir = ImGuiDir_Up; // Because our scoring rect is offset down, we request the up direction (so we can always land on the last item)
        g.NavMoveClipDir = ImGuiDir_Down;
        g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;
      }
      else if( home_pressed )
      {
        // FIXME-NAV: handling of Home/End is assuming that the top/bottom most item will be visible with Scroll.y == 0/ScrollMax.y
        // Scrolling will be handled via the ImGuiNavMoveFlags_ScrollToEdge flag, we don't scroll immediately to avoid scrolling happening before nav result.
        // Preserve current horizontal position if we have any.
        nav_rect_rel.Min.y = nav_rect_rel.Max.y = -window->Scroll.y;
        if( nav_rect_rel.IsInverted() )
          nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
        g.NavMoveDir = ImGuiDir_Down;
        g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdge;
      }
      else if( end_pressed )
      {
        nav_rect_rel.Min.y = nav_rect_rel.Max.y = window->ScrollMax.y + window->SizeFull.y - window->Scroll.y;
        if( nav_rect_rel.IsInverted() )
          nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
        g.NavMoveDir = ImGuiDir_Up;
        g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdge;
      }
      return nav_scoring_rect_offset_y;
    }
  }
  return 0.0f;
}

static int ImGui::FindWindowFocusIndex( ImGuiWindow* window ) // FIXME-OPT O(N)
{
  ImGuiContext& g = *GImGui;
  for( int i = g.WindowsFocusOrder.Size - 1; i >= 0; i-- )
    if( g.WindowsFocusOrder[ i ] == window )
      return i;
  return -1;
}

static ImGuiWindow* FindWindowNavFocusable( int i_start, int i_stop, int dir ) // FIXME-OPT O(N)
{
  ImGuiContext& g = *GImGui;
  for( int i = i_start; i >= 0 && i < g.WindowsFocusOrder.Size && i != i_stop; i += dir )
    if( ImGui::IsWindowNavFocusable( g.WindowsFocusOrder[ i ] ) )
      return g.WindowsFocusOrder[ i ];
  return NULL;
}

static void NavUpdateWindowingHighlightWindow( int focus_change_dir )
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( g.NavWindowingTarget );
  if( g.NavWindowingTarget->Flags & ImGuiWindowFlags_Modal )
    return;

  const int i_current = ImGui::FindWindowFocusIndex( g.NavWindowingTarget );
  ImGuiWindow* window_target = FindWindowNavFocusable( i_current + focus_change_dir, -INT_MAX, focus_change_dir );
  if( !window_target )
    window_target = FindWindowNavFocusable( ( focus_change_dir < 0 ) ? ( g.WindowsFocusOrder.Size - 1 ) : 0, i_current, focus_change_dir );
  if( window_target ) // Don't reset windowing target if there's a single window in the list
    g.NavWindowingTarget = g.NavWindowingTargetAnim = window_target;
  g.NavWindowingToggleLayer = false;
}

// Windowing management mode
// Keyboard: CTRL+Tab (change focus/move/resize), Alt (toggle menu layer)
// Gamepad:  Hold Menu/Square (change focus/move/resize), Tap Menu/Square (toggle menu layer)
static void ImGui::NavUpdateWindowing()
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* apply_focus_window = NULL;
  bool apply_toggle_layer = false;

  ImGuiWindow* modal_window = GetTopMostPopupModal();
  if( modal_window != NULL )
  {
    g.NavWindowingTarget = NULL;
    return;
  }

  // Fade out
  if( g.NavWindowingTargetAnim && g.NavWindowingTarget == NULL )
  {
    g.NavWindowingHighlightAlpha = ImMax( g.NavWindowingHighlightAlpha - g.IO.DeltaTime * 10.0f, 0.0f );
    if( g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f )
      g.NavWindowingTargetAnim = NULL;
  }

  // Start CTRL-TAB or Square+L/R window selection
  bool start_windowing_with_gamepad = !g.NavWindowingTarget && IsNavInputTest( ImGuiNavInput_Menu, ImGuiInputReadMode_Pressed );
  bool start_windowing_with_keyboard = !g.NavWindowingTarget && g.IO.KeyCtrl && IsKeyPressedMap( ImGuiKey_Tab ) && ( g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard );
  if( start_windowing_with_gamepad || start_windowing_with_keyboard )
    if( ImGuiWindow* window = g.NavWindow ? g.NavWindow : FindWindowNavFocusable( g.WindowsFocusOrder.Size - 1, -INT_MAX, -1 ) )
    {
      g.NavWindowingTarget = g.NavWindowingTargetAnim = window->RootWindow; // FIXME-DOCK: Will need to use RootWindowDockStop
      g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;
      g.NavWindowingToggleLayer = start_windowing_with_keyboard ? false : true;
      g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource_NavKeyboard : ImGuiInputSource_NavGamepad;
    }

  // Gamepad update
  g.NavWindowingTimer += g.IO.DeltaTime;
  if( g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_NavGamepad )
  {
    // Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
    g.NavWindowingHighlightAlpha = ImMax( g.NavWindowingHighlightAlpha, ImSaturate( ( g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY ) / 0.05f ) );

    // Select window to focus
    const int focus_change_dir = ( int )IsNavInputTest( ImGuiNavInput_FocusPrev, ImGuiInputReadMode_RepeatSlow ) - ( int )IsNavInputTest( ImGuiNavInput_FocusNext, ImGuiInputReadMode_RepeatSlow );
    if( focus_change_dir != 0 )
    {
      NavUpdateWindowingHighlightWindow( focus_change_dir );
      g.NavWindowingHighlightAlpha = 1.0f;
    }

    // Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered top-most)
    if( !IsNavInputDown( ImGuiNavInput_Menu ) )
    {
      g.NavWindowingToggleLayer &= ( g.NavWindowingHighlightAlpha < 1.0f ); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.
      if( g.NavWindowingToggleLayer && g.NavWindow )
        apply_toggle_layer = true;
      else if( !g.NavWindowingToggleLayer )
        apply_focus_window = g.NavWindowingTarget;
      g.NavWindowingTarget = NULL;
    }
  }

  // Keyboard: Focus
  if( g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_NavKeyboard )
  {
    // Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise
    g.NavWindowingHighlightAlpha = ImMax( g.NavWindowingHighlightAlpha, ImSaturate( ( g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY ) / 0.05f ) ); // 1.0f
    if( IsKeyPressedMap( ImGuiKey_Tab, true ) )
      NavUpdateWindowingHighlightWindow( g.IO.KeyShift ? +1 : -1 );
    if( !g.IO.KeyCtrl )
      apply_focus_window = g.NavWindowingTarget;
  }

  // Keyboard: Press and Release ALT to toggle menu layer
  // FIXME: We lack an explicit IO variable for "is the imgui window focused", so compare mouse validity to detect the common case of back-end clearing releases all keys on ALT-TAB
  if( IsNavInputTest( ImGuiNavInput_KeyMenu_, ImGuiInputReadMode_Pressed ) )
    g.NavWindowingToggleLayer = true;
  if( ( g.ActiveId == 0 || g.ActiveIdAllowOverlap ) && g.NavWindowingToggleLayer && IsNavInputTest( ImGuiNavInput_KeyMenu_, ImGuiInputReadMode_Released ) )
    if( IsMousePosValid( &g.IO.MousePos ) == IsMousePosValid( &g.IO.MousePosPrev ) )
      apply_toggle_layer = true;

  // Move window
  if( g.NavWindowingTarget && !( g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove ) )
  {
    ImVec2 move_delta;
    if( g.NavInputSource == ImGuiInputSource_NavKeyboard && !g.IO.KeyShift )
      move_delta = GetNavInputAmount2d( ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down );
    if( g.NavInputSource == ImGuiInputSource_NavGamepad )
      move_delta = GetNavInputAmount2d( ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down );
    if( move_delta.x != 0.0f || move_delta.y != 0.0f )
    {
      const float NAV_MOVE_SPEED = 800.0f;
      const float move_speed = ImFloor( NAV_MOVE_SPEED * g.IO.DeltaTime * ImMin( g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y ) ); // FIXME: Doesn't code variable framerate very well
      SetWindowPos( g.NavWindowingTarget->RootWindow, g.NavWindowingTarget->RootWindow->Pos + move_delta * move_speed, ImGuiCond_Always );
      g.NavDisableMouseHover = true;
      MarkIniSettingsDirty( g.NavWindowingTarget );
    }
  }

  // Apply final focus
  if( apply_focus_window && ( g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindow ) )
  {
    ClearActiveID();
    g.NavDisableHighlight = false;
    g.NavDisableMouseHover = true;
    apply_focus_window = NavRestoreLastChildNavWindow( apply_focus_window );
    ClosePopupsOverWindow( apply_focus_window, false );
    FocusWindow( apply_focus_window );
    if( apply_focus_window->NavLastIds[ 0 ] == 0 )
      NavInitWindow( apply_focus_window, false );

    // If the window only has a menu layer, select it directly
    if( apply_focus_window->DC.NavLayerActiveMask == ( 1 << ImGuiNavLayer_Menu ) )
      g.NavLayer = ImGuiNavLayer_Menu;
  }
  if( apply_focus_window )
    g.NavWindowingTarget = NULL;

  // Apply menu/layer toggle
  if( apply_toggle_layer && g.NavWindow )
  {
    // Move to parent menu if necessary
    ImGuiWindow* new_nav_window = g.NavWindow;
    while( new_nav_window->ParentWindow
           && ( new_nav_window->DC.NavLayerActiveMask & ( 1 << ImGuiNavLayer_Menu ) ) == 0
           && ( new_nav_window->Flags & ImGuiWindowFlags_ChildWindow ) != 0
           && ( new_nav_window->Flags & ( ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu ) ) == 0 )
      new_nav_window = new_nav_window->ParentWindow;
    if( new_nav_window != g.NavWindow )
    {
      ImGuiWindow* old_nav_window = g.NavWindow;
      FocusWindow( new_nav_window );
      new_nav_window->NavLastChildNavWindow = old_nav_window;
    }
    g.NavDisableHighlight = false;
    g.NavDisableMouseHover = true;

    // When entering a regular menu bar with the Alt key, we always reinitialize the navigation ID.
    const ImGuiNavLayer new_nav_layer = ( g.NavWindow->DC.NavLayerActiveMask & ( 1 << ImGuiNavLayer_Menu ) ) ? ( ImGuiNavLayer )( ( int )g.NavLayer ^ 1 ) : ImGuiNavLayer_Main;
    NavRestoreLayer( new_nav_layer );
  }
}

// Window has already passed the IsWindowNavFocusable()
static const char* GetFallbackWindowNameForWindowingList( ImGuiWindow* window )
{
  if( window->Flags & ImGuiWindowFlags_Popup )
    return SECURE( "(Popup)" );
  if( ( window->Flags & ImGuiWindowFlags_MenuBar ) && win32::strcmp( window->Name, SECURE("##MainMenuBar") ) == 0 )
    return SECURE( "(Main menu bar)" );
  return SECURE( "(Untitled)" );
}

// Overlay displayed when using CTRL+TAB. Called by EndFrame().
void ImGui::NavUpdateWindowingOverlay()
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( g.NavWindowingTarget != NULL );

  if( g.NavWindowingTimer < NAV_WINDOWING_LIST_APPEAR_DELAY )
    return;

  if( g.NavWindowingList == NULL )
    g.NavWindowingList = FindWindowByName( SECURE( "###NavWindowingList" ) );
  SetNextWindowSizeConstraints( ImVec2( g.IO.DisplaySize.x * 0.20f, g.IO.DisplaySize.y * 0.20f ), ImVec2( FLT_MAX, FLT_MAX ) );
  SetNextWindowPos( g.IO.DisplaySize * 0.5f, ImGuiCond_Always, ImVec2( 0.5f, 0.5f ) );
  PushStyleVar( ImGuiStyleVar_WindowPadding, g.Style.WindowPadding * 2.0f );
  Begin( SECURE( "###NavWindowingList" ), NULL, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings );
  for( int n = g.WindowsFocusOrder.Size - 1; n >= 0; n-- )
  {
    ImGuiWindow* window = g.WindowsFocusOrder[ n ];
    if( !IsWindowNavFocusable( window ) )
      continue;
    const char* label = window->Name;
    if( label == FindRenderedTextEnd( label ) )
      label = GetFallbackWindowNameForWindowingList( window );
    Selectable( label, g.NavWindowingTarget == window );
  }
  End();
  PopStyleVar();
}

//-----------------------------------------------------------------------------
// [SECTION] DRAG AND DROP
//-----------------------------------------------------------------------------

void ImGui::ClearDragDrop()
{
  ImGuiContext& g = *GImGui;
  g.DragDropActive = false;
  g.DragDropPayload.Clear();
  g.DragDropAcceptFlags = ImGuiDragDropFlags_None;
  g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;
  g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
  g.DragDropAcceptFrameCount = -1;

  g.DragDropPayloadBufHeap.clear();
  memset( &g.DragDropPayloadBufLocal, 0, sizeof( g.DragDropPayloadBufLocal ) );
}

// Call when current ID is active.
// When this returns true you need to: a) call SetDragDropPayload() exactly once, b) you may render the payload visual/description, c) call EndDragDropSource()
bool ImGui::BeginDragDropSource( ImGuiDragDropFlags flags )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;

  bool source_drag_active = false;
  ImGuiID source_id = 0;
  ImGuiID source_parent_id = 0;
  ImGuiMouseButton mouse_button = ImGuiMouseButton_Left;
  if( !( flags & ImGuiDragDropFlags_SourceExtern ) )
  {
    source_id = window->DC.LastItemId;
    if( source_id != 0 && g.ActiveId != source_id ) // Early out for most common case
      return false;
    if( g.IO.MouseDown[ mouse_button ] == false )
      return false;

    if( source_id == 0 )
    {
      // If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:
      // A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag, C) Swallow your programmer pride.
      if( !( flags & ImGuiDragDropFlags_SourceAllowNullID ) )
      {
        IM_ASSERT( 0 );
        return false;
      }

      // Early out
      if( ( window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect ) == 0 && ( g.ActiveId == 0 || g.ActiveIdWindow != window ) )
        return false;

      // Magic fallback (=somehow reprehensible) to handle items with no assigned ID, e.g. Text(), Image()
      // We build a throwaway ID based on current ID stack + relative AABB of items in window.
      // THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING OF THE WIDGET, so if your widget moves your dragging operation will be canceled.
      // We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.
      source_id = window->DC.LastItemId = window->GetIDFromRectangle( window->DC.LastItemRect );
      bool is_hovered = ItemHoverable( window->DC.LastItemRect, source_id );
      if( is_hovered && g.IO.MouseClicked[ mouse_button ] )
      {
        SetActiveID( source_id, window );
        FocusWindow( window );
      }
      if( g.ActiveId == source_id ) // Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.
        g.ActiveIdAllowOverlap = is_hovered;
    }
    else
    {
      g.ActiveIdAllowOverlap = false;
    }
    if( g.ActiveId != source_id )
      return false;
    source_parent_id = window->IDStack.back();
    source_drag_active = IsMouseDragging( mouse_button );

    // Disable navigation and key inputs while dragging
    g.ActiveIdUsingNavDirMask = ~( ImU32 )0;
    g.ActiveIdUsingNavInputMask = ~( ImU32 )0;
    g.ActiveIdUsingKeyInputMask = ~( ImU64 )0;
  }
  else
  {
    window = NULL;
    source_id = ImHashStr( SECURE( "#SourceExtern" ) );
    source_drag_active = true;
  }

  if( source_drag_active )
  {
    if( !g.DragDropActive )
    {
      IM_ASSERT( source_id != 0 );
      ClearDragDrop();
      ImGuiPayload& payload = g.DragDropPayload;
      payload.SourceId = source_id;
      payload.SourceParentId = source_parent_id;
      g.DragDropActive = true;
      g.DragDropSourceFlags = flags;
      g.DragDropMouseButton = mouse_button;
    }
    g.DragDropSourceFrameCount = g.FrameCount;
    g.DragDropWithinSource = true;

    if( !( flags & ImGuiDragDropFlags_SourceNoPreviewTooltip ) )
    {
      // Target can request the Source to not display its tooltip (we use a dedicated flag to make this request explicit)
      // We unfortunately can't just modify the source flags and skip the call to BeginTooltip, as caller may be emitting contents.
      BeginTooltip();
      if( g.DragDropAcceptIdPrev && ( g.DragDropAcceptFlags & ImGuiDragDropFlags_AcceptNoPreviewTooltip ) )
      {
        ImGuiWindow* tooltip_window = g.CurrentWindow;
        tooltip_window->SkipItems = true;
        tooltip_window->HiddenFramesCanSkipItems = 1;
      }
    }

    if( !( flags & ImGuiDragDropFlags_SourceNoDisableHover ) && !( flags & ImGuiDragDropFlags_SourceExtern ) )
      window->DC.LastItemStatusFlags &= ~ImGuiItemStatusFlags_HoveredRect;

    return true;
  }
  return false;
}

void ImGui::EndDragDropSource()
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( g.DragDropActive );
  IM_ASSERT( g.DragDropWithinSource && "Not after a BeginDragDropSource()?" );

  if( !( g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip ) )
    EndTooltip();

  // Discard the drag if have not called SetDragDropPayload()
  if( g.DragDropPayload.DataFrameCount == -1 )
    ClearDragDrop();
  g.DragDropWithinSource = false;
}

// Use 'cond' to choose to submit payload on drag start or every frame
bool ImGui::SetDragDropPayload( const char* type, const void* data, size_t data_size, ImGuiCond cond )
{
  ImGuiContext& g = *GImGui;
  ImGuiPayload& payload = g.DragDropPayload;
  if( cond == 0 )
    cond = ImGuiCond_Always;

  IM_ASSERT( type != NULL );
  IM_ASSERT( strlen( type ) < IM_ARRAYSIZE( payload.DataType ) && "Payload type can be at most 32 characters long" );
  IM_ASSERT( ( data != NULL && data_size > 0 ) || ( data == NULL && data_size == 0 ) );
  IM_ASSERT( cond == ImGuiCond_Always || cond == ImGuiCond_Once );
  IM_ASSERT( payload.SourceId != 0 );                               // Not called between BeginDragDropSource() and EndDragDropSource()

  if( cond == ImGuiCond_Always || payload.DataFrameCount == -1 )
  {
    // Copy payload
    ImStrncpy( payload.DataType, type, IM_ARRAYSIZE( payload.DataType ) );
    g.DragDropPayloadBufHeap.resize( 0 );
    if( data_size > sizeof( g.DragDropPayloadBufLocal ) )
    {
      // Store in heap
      g.DragDropPayloadBufHeap.resize( ( int )data_size );
      payload.Data = g.DragDropPayloadBufHeap.Data;
      memcpy( payload.Data, data, data_size );
    }
    else if( data_size > 0 )
    {
      // Store locally
      memset( &g.DragDropPayloadBufLocal, 0, sizeof( g.DragDropPayloadBufLocal ) );
      payload.Data = g.DragDropPayloadBufLocal;
      memcpy( payload.Data, data, data_size );
    }
    else
    {
      payload.Data = NULL;
    }
    payload.DataSize = ( int )data_size;
  }
  payload.DataFrameCount = g.FrameCount;

  return ( g.DragDropAcceptFrameCount == g.FrameCount ) || ( g.DragDropAcceptFrameCount == g.FrameCount - 1 );
}

bool ImGui::BeginDragDropTargetCustom( const ImRect& bb, ImGuiID id )
{
  ImGuiContext& g = *GImGui;
  if( !g.DragDropActive )
    return false;

  ImGuiWindow* window = g.CurrentWindow;
  if( g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow )
    return false;
  IM_ASSERT( id != 0 );
  if( !IsMouseHoveringRect( bb.Min, bb.Max ) || ( id == g.DragDropPayload.SourceId ) )
    return false;
  if( window->SkipItems )
    return false;

  IM_ASSERT( g.DragDropWithinTarget == false );
  g.DragDropTargetRect = bb;
  g.DragDropTargetId = id;
  g.DragDropWithinTarget = true;
  return true;
}

// We don't use BeginDragDropTargetCustom() and duplicate its code because:
// 1) we use LastItemRectHoveredRect which handles items that pushes a temporarily clip rectangle in their code. Calling BeginDragDropTargetCustom(LastItemRect) would not handle them.
// 2) and it's faster. as this code may be very frequently called, we want to early out as fast as we can.
// Also note how the HoveredWindow test is positioned differently in both functions (in both functions we optimize for the cheapest early out case)
bool ImGui::BeginDragDropTarget()
{
  ImGuiContext& g = *GImGui;
  if( !g.DragDropActive )
    return false;

  ImGuiWindow* window = g.CurrentWindow;
  if( !( window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect ) )
    return false;
  if( g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow )
    return false;

  const ImRect& display_rect = ( window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect ) ? window->DC.LastItemDisplayRect : window->DC.LastItemRect;
  ImGuiID id = window->DC.LastItemId;
  if( id == 0 )
    id = window->GetIDFromRectangle( display_rect );
  if( g.DragDropPayload.SourceId == id )
    return false;

  IM_ASSERT( g.DragDropWithinTarget == false );
  g.DragDropTargetRect = display_rect;
  g.DragDropTargetId = id;
  g.DragDropWithinTarget = true;
  return true;
}

bool ImGui::IsDragDropPayloadBeingAccepted()
{
  ImGuiContext& g = *GImGui;
  return g.DragDropActive && g.DragDropAcceptIdPrev != 0;
}

const ImGuiPayload* ImGui::AcceptDragDropPayload( const char* type, ImGuiDragDropFlags flags )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  ImGuiPayload& payload = g.DragDropPayload;
  IM_ASSERT( g.DragDropActive );                        // Not called between BeginDragDropTarget() and EndDragDropTarget() ?
  IM_ASSERT( payload.DataFrameCount != -1 );            // Forgot to call EndDragDropTarget() ?
  if( type != NULL && !payload.IsDataType( type ) )
    return NULL;

  // Accept smallest drag target bounding box, this allows us to nest drag targets conveniently without ordering constraints.
  // NB: We currently accept NULL id as target. However, overlapping targets requires a unique ID to function!
  const bool was_accepted_previously = ( g.DragDropAcceptIdPrev == g.DragDropTargetId );
  ImRect r = g.DragDropTargetRect;
  float r_surface = r.GetWidth() * r.GetHeight();
  if( r_surface < g.DragDropAcceptIdCurrRectSurface )
  {
    g.DragDropAcceptFlags = flags;
    g.DragDropAcceptIdCurr = g.DragDropTargetId;
    g.DragDropAcceptIdCurrRectSurface = r_surface;
  }

  // Render default drop visuals
  payload.Preview = was_accepted_previously;
  flags |= ( g.DragDropSourceFlags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect ); // Source can also inhibit the preview (useful for external sources that lives for 1 frame)
  if( !( flags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect ) && payload.Preview )
  {
    // FIXME-DRAG: Settle on a proper default visuals for drop target.
    r.Expand( 3.5f );
    bool push_clip_rect = !window->ClipRect.Contains( r );
    if( push_clip_rect ) window->DrawList->PushClipRect( r.Min - ImVec2( 1, 1 ), r.Max + ImVec2( 1, 1 ) );
    window->DrawList->AddRect( r.Min, r.Max, GetColorU32( ImGuiCol_DragDropTarget ), 0.0f, ~0, 2.0f );
    if( push_clip_rect ) window->DrawList->PopClipRect();
  }

  g.DragDropAcceptFrameCount = g.FrameCount;
  payload.Delivery = was_accepted_previously && !IsMouseDown( g.DragDropMouseButton ); // For extern drag sources affecting os window focus, it's easier to just test !IsMouseDown() instead of IsMouseReleased()
  if( !payload.Delivery && !( flags & ImGuiDragDropFlags_AcceptBeforeDelivery ) )
    return NULL;

  return &payload;
}

const ImGuiPayload* ImGui::GetDragDropPayload()
{
  ImGuiContext& g = *GImGui;
  return g.DragDropActive ? &g.DragDropPayload : NULL;
}

// We don't really use/need this now, but added it for the sake of consistency and because we might need it later.
void ImGui::EndDragDropTarget()
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( g.DragDropActive );
  IM_ASSERT( g.DragDropWithinTarget );
  g.DragDropWithinTarget = false;
}

//-----------------------------------------------------------------------------
// [SECTION] LOGGING/CAPTURING
//-----------------------------------------------------------------------------
// All text output from the interface can be captured into tty/file/clipboard.
// By default, tree nodes are automatically opened during logging.
//-----------------------------------------------------------------------------

// Pass text data straight to log (without being displayed)
void ImGui::LogText( const char* fmt, ... )
{
  ImGuiContext& g = *GImGui;
  if( !g.LogEnabled )
    return;

  va_list args;
  va_start( args, fmt );
  if( g.LogFile )
  {
    g.LogBuffer.Buf.resize( 0 );
    g.LogBuffer.appendfv( fmt, args );
    ImFileWrite( g.LogBuffer.c_str(), sizeof( char ), ( ImU64 )g.LogBuffer.size(), g.LogFile );
  }
  else
  {
    g.LogBuffer.appendfv( fmt, args );
  }
  va_end( args );
}

// Internal version that takes a position to decide on newline placement and pad items according to their depth.
// We split text into individual lines to add current tree level padding
void ImGui::LogRenderedText( const ImVec2* ref_pos, const char* text, const char* text_end )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;

  if( !text_end )
    text_end = FindRenderedTextEnd( text, text_end );

  const bool log_new_line = ref_pos && ( ref_pos->y > g.LogLinePosY + 1 );
  if( ref_pos )
    g.LogLinePosY = ref_pos->y;
  if( log_new_line )
    g.LogLineFirstItem = true;

  const char* text_remaining = text;
  if( g.LogDepthRef > window->DC.TreeDepth )  // Re-adjust padding if we have popped out of our starting depth
    g.LogDepthRef = window->DC.TreeDepth;
  const int tree_depth = ( window->DC.TreeDepth - g.LogDepthRef );
  for( ;;)
  {
    // Split the string. Each new line (after a '\n') is followed by spacing corresponding to the current depth of our log entry.
    // We don't add a trailing \n to allow a subsequent item on the same line to be captured.
    const char* line_start = text_remaining;
    const char* line_end = ImStreolRange( line_start, text_end );
    const bool is_first_line = ( line_start == text );
    const bool is_last_line = ( line_end == text_end );
    if( !is_last_line || ( line_start != line_end ) )
    {
      const int char_count = ( int )( line_end - line_start );
      if( log_new_line || !is_first_line )
        LogText( SECURE( IM_NEWLINE "%*s%.*s" ), tree_depth * 4, "", char_count, line_start );
      else if( g.LogLineFirstItem )
        LogText( SECURE( "%*s%.*s" ), tree_depth * 4, "", char_count, line_start );
      else
        LogText( SECURE( " %.*s" ), char_count, line_start );
      g.LogLineFirstItem = false;
    }
    else if( log_new_line )
    {
      // An empty "" string at a different Y position should output a carriage return.
      LogText( SECURE( IM_NEWLINE ) );
      break;
    }

    if( is_last_line )
      break;
    text_remaining = line_end + 1;
  }
}

// Start logging/capturing text output
void ImGui::LogBegin( ImGuiLogType type, int auto_open_depth )
{
  ImGuiContext& g = *GImGui;
  ImGuiWindow* window = g.CurrentWindow;
  IM_ASSERT( g.LogEnabled == false );
  IM_ASSERT( g.LogFile == NULL );
  IM_ASSERT( g.LogBuffer.empty() );
  g.LogEnabled = true;
  g.LogType = type;
  g.LogDepthRef = window->DC.TreeDepth;
  g.LogDepthToExpand = ( ( auto_open_depth >= 0 ) ? auto_open_depth : g.LogDepthToExpandDefault );
  g.LogLinePosY = FLT_MAX;
  g.LogLineFirstItem = true;
}

void ImGui::LogToTTY( int auto_open_depth )
{
  ImGuiContext& g = *GImGui;
  if( g.LogEnabled )
    return;
  IM_UNUSED( auto_open_depth );
#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
  LogBegin( ImGuiLogType_TTY, auto_open_depth );
  g.LogFile = stdout;
#endif
}

// Start logging/capturing text output to given file
void ImGui::LogToFile( int auto_open_depth, const char* filename )
{
  ImGuiContext& g = *GImGui;
  if( g.LogEnabled )
    return;

  // FIXME: We could probably open the file in text mode "at", however note that clipboard/buffer logging will still
  // be subject to outputting OS-incompatible carriage return if within strings the user doesn't use IM_NEWLINE.
  // By opening the file in binary mode "ab" we have consistent output everywhere.
  if( !filename )
    filename = g.IO.LogFilename;
  if( !filename || !filename[ 0 ] )
    return;
  ImFileHandle f = ImFileOpen( filename, SECURE( "ab" ) );
  if( !f )
  {
    IM_ASSERT( 0 );
    return;
  }

  LogBegin( ImGuiLogType_File, auto_open_depth );
  g.LogFile = f;
}

// Start logging/capturing text output to clipboard
void ImGui::LogToClipboard( int auto_open_depth )
{
  ImGuiContext& g = *GImGui;
  if( g.LogEnabled )
    return;
  LogBegin( ImGuiLogType_Clipboard, auto_open_depth );
}

void ImGui::LogToBuffer( int auto_open_depth )
{
  ImGuiContext& g = *GImGui;
  if( g.LogEnabled )
    return;
  LogBegin( ImGuiLogType_Buffer, auto_open_depth );
}

void ImGui::LogFinish()
{
  ImGuiContext& g = *GImGui;
  if( !g.LogEnabled )
    return;

  LogText( IM_NEWLINE );
  switch( g.LogType )
  {
    case ImGuiLogType_TTY:
#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
      fflush( g.LogFile );
#endif
      break;
    case ImGuiLogType_File:
      ImFileClose( g.LogFile );
      break;
    case ImGuiLogType_Buffer:
      break;
    case ImGuiLogType_Clipboard:
      if( !g.LogBuffer.empty() )
        SetClipboardText( g.LogBuffer.begin() );
      break;
    case ImGuiLogType_None:
      IM_ASSERT( 0 );
      break;
  }

  g.LogEnabled = false;
  g.LogType = ImGuiLogType_None;
  g.LogFile = NULL;
  g.LogBuffer.clear();
}

// Helper to display logging buttons
// FIXME-OBSOLETE: We should probably obsolete this and let the user have their own helper (this is one of the oldest function alive!)
void ImGui::LogButtons()
{
  ImGuiContext& g = *GImGui;

  PushID( SECURE( "LogButtons" ) );
#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
  const bool log_to_tty = Button( "Log To TTY" ); SameLine();
#else
  const bool log_to_tty = false;
#endif
  const bool log_to_file = Button( SECURE( "Log To File" ) ); SameLine();
  const bool log_to_clipboard = Button( SECURE( "Log To Clipboard" ) ); SameLine();
  PushAllowKeyboardFocus( false );
  SetNextItemWidth( 80.0f );
  SliderInt( SECURE( "Default Depth" ), &g.LogDepthToExpandDefault, 0, 9, NULL );
  PopAllowKeyboardFocus();
  PopID();

  // Start logging at the end of the function so that the buttons don't appear in the log
  if( log_to_tty )
    LogToTTY();
  if( log_to_file )
    LogToFile();
  if( log_to_clipboard )
    LogToClipboard();
}

//-----------------------------------------------------------------------------
// [SECTION] SETTINGS
//-----------------------------------------------------------------------------

// Called by NewFrame()
void ImGui::UpdateSettings()
{
  // Load settings on first frame (if not explicitly loaded manually before)
  ImGuiContext& g = *GImGui;
  if( !g.SettingsLoaded )
  {
    IM_ASSERT( g.SettingsWindows.empty() );
    if( g.IO.IniFilename )
      LoadIniSettingsFromDisk( g.IO.IniFilename );
    g.SettingsLoaded = true;
  }

  // Save settings (with a delay after the last modification, so we don't spam disk too much)
  if( g.SettingsDirtyTimer > 0.0f )
  {
    g.SettingsDirtyTimer -= g.IO.DeltaTime;
    if( g.SettingsDirtyTimer <= 0.0f )
    {
      if( g.IO.IniFilename != NULL )
        SaveIniSettingsToDisk( g.IO.IniFilename );
      else
        g.IO.WantSaveIniSettings = true;  // Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.
      g.SettingsDirtyTimer = 0.0f;
    }
  }
}

void ImGui::MarkIniSettingsDirty()
{
  ImGuiContext& g = *GImGui;
  if( g.SettingsDirtyTimer <= 0.0f )
    g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

void ImGui::MarkIniSettingsDirty( ImGuiWindow* window )
{
  ImGuiContext& g = *GImGui;
  if( !( window->Flags & ImGuiWindowFlags_NoSavedSettings ) )
    if( g.SettingsDirtyTimer <= 0.0f )
      g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

ImGuiWindowSettings* ImGui::CreateNewWindowSettings( const char* name )
{
  ImGuiContext& g = *GImGui;

#if !IMGUI_DEBUG_INI_SETTINGS
  // Skip to the "###" marker if any. We don't skip past to match the behavior of GetID()
  // Preserve the full string when IMGUI_DEBUG_INI_SETTINGS is set to make .ini inspection easier.
  if( const char* p = win32::strstr( name, SECURE( "###" ) ) )
    name = p;
#endif
  const size_t name_len = win32::strlen( name );

  // Allocate chunk
  const size_t chunk_size = sizeof( ImGuiWindowSettings ) + name_len + 1;
  ImGuiWindowSettings* settings = g.SettingsWindows.alloc_chunk( chunk_size );
  IM_PLACEMENT_NEW( settings ) ImGuiWindowSettings();
  settings->ID = ImHashStr( name, name_len );
  memcpy( settings->GetName(), name, name_len + 1 );   // Store with zero terminator

  return settings;
}

ImGuiWindowSettings* ImGui::FindWindowSettings( ImGuiID id )
{
  ImGuiContext& g = *GImGui;
  for( ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk( settings ) )
    if( settings->ID == id )
      return settings;
  return NULL;
}

ImGuiWindowSettings* ImGui::FindOrCreateWindowSettings( const char* name )
{
  if( ImGuiWindowSettings* settings = FindWindowSettings( ImHashStr( name ) ) )
    return settings;
  return CreateNewWindowSettings( name );
}

void ImGui::LoadIniSettingsFromDisk( const char* ini_filename )
{
  size_t file_data_size = 0;
  char* file_data = ( char* )ImFileLoadToMemory( ini_filename, SECURE( "rb" ), &file_data_size );
  if( !file_data )
    return;
  LoadIniSettingsFromMemory( file_data, ( size_t )file_data_size );
  IM_FREE( file_data );
}

ImGuiSettingsHandler* ImGui::FindSettingsHandler( const char* type_name )
{
  ImGuiContext& g = *GImGui;
  const ImGuiID type_hash = ImHashStr( type_name );
  for( int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++ )
    if( g.SettingsHandlers[ handler_n ].TypeHash == type_hash )
      return &g.SettingsHandlers[ handler_n ];
  return NULL;
}

// Zero-tolerance, no error reporting, cheap .ini parsing
void ImGui::LoadIniSettingsFromMemory( const char* ini_data, size_t ini_size )
{
  ImGuiContext& g = *GImGui;
  IM_ASSERT( g.Initialized );
  IM_ASSERT( g.SettingsLoaded == false && g.FrameCount == 0 );

  // For user convenience, we allow passing a non zero-terminated string (hence the ini_size parameter).
  // For our convenience and to make the code simpler, we'll also write zero-terminators within the buffer. So let's create a writable copy..
  if( ini_size == 0 )
    ini_size = strlen( ini_data );
  char* buf = ( char* )IM_ALLOC( ini_size + 1 );
  char* buf_end = buf + ini_size;
  memcpy( buf, ini_data, ini_size );
  buf[ ini_size ] = 0;

  void* entry_data = NULL;
  ImGuiSettingsHandler* entry_handler = NULL;

  char* line_end = NULL;
  for( char* line = buf; line < buf_end; line = line_end + 1 )
  {
    // Skip new lines markers, then find end of the line
    while( *line == '\n' || *line == '\r' )
      line++;
    line_end = line;
    while( line_end < buf_end && *line_end != '\n' && *line_end != '\r' )
      line_end++;
    line_end[ 0 ] = 0;
    if( line[ 0 ] == ';' )
      continue;
    if( line[ 0 ] == '[' && line_end > line && line_end[ -1 ] == ']' )
    {
      // Parse "[Type][Name]". Note that 'Name' can itself contains [] characters, which is acceptable with the current format and parsing code.
      line_end[ -1 ] = 0;
      const char* name_end = line_end - 1;
      const char* type_start = line + 1;
      char* type_end = ( char* )( void* )ImStrchrRange( type_start, name_end, ']' );
      const char* name_start = type_end ? ImStrchrRange( type_end + 1, name_end, '[' ) : NULL;
      if( !type_end || !name_start )
        continue;
      *type_end = 0; // Overwrite first ']'
      name_start++;  // Skip second '['
      entry_handler = FindSettingsHandler( type_start );
      entry_data = entry_handler ? entry_handler->ReadOpenFn( &g, entry_handler, name_start ) : NULL;
    }
    else if( entry_handler != NULL && entry_data != NULL )
    {
      // Let type handler parse the line
      entry_handler->ReadLineFn( &g, entry_handler, entry_data, line );
    }
  }
  IM_FREE( buf );
  g.SettingsLoaded = true;
}

void ImGui::SaveIniSettingsToDisk( const char* ini_filename )
{
  ImGuiContext& g = *GImGui;
  g.SettingsDirtyTimer = 0.0f;
  if( !ini_filename )
    return;

  size_t ini_data_size = 0;
  const char* ini_data = SaveIniSettingsToMemory( &ini_data_size );
  ImFileHandle f = ImFileOpen( ini_filename, SECURE( "wt" ) );
  if( !f )
    return;
  ImFileWrite( ini_data, sizeof( char ), ini_data_size, f );
  ImFileClose( f );
}

// Call registered handlers (e.g. SettingsHandlerWindow_WriteAll() + custom handlers) to write their stuff into a text buffer
const char* ImGui::SaveIniSettingsToMemory( size_t* out_size )
{
  ImGuiContext& g = *GImGui;
  g.SettingsDirtyTimer = 0.0f;
  g.SettingsIniData.Buf.resize( 0 );
  g.SettingsIniData.Buf.push_back( 0 );
  for( int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++ )
  {
    ImGuiSettingsHandler* handler = &g.SettingsHandlers[ handler_n ];
    handler->WriteAllFn( &g, handler, &g.SettingsIniData );
  }
  if( out_size )
    *out_size = ( size_t )g.SettingsIniData.size();
  return g.SettingsIniData.c_str();
}

static void* WindowSettingsHandler_ReadOpen( ImGuiContext*, ImGuiSettingsHandler*, const char* name )
{
  ImGuiWindowSettings* settings = ImGui::FindWindowSettings( ImHashStr( name ) );
  if( !settings )
    settings = ImGui::CreateNewWindowSettings( name );
  return ( void* )settings;
}

static void WindowSettingsHandler_ReadLine( ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line )
{
  ImGuiWindowSettings* settings = ( ImGuiWindowSettings* )entry;
  int x, y;
  int i;
  if( g_map_data.sscanf( line, SECURE( "Pos=%i,%i" ), &x, &y ) == 2 )         settings->Pos = ImVec2ih( ( short )x, ( short )y );
  else if( g_map_data.sscanf( line, SECURE( "Size=%i,%i" ), &x, &y ) == 2 )   settings->Size = ImVec2ih( ( short )x, ( short )y );
  else if( g_map_data.sscanf( line, SECURE( "Collapsed=%d" ), &i ) == 1 )     settings->Collapsed = ( i != 0 );
}

static void WindowSettingsHandler_WriteAll( ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf )
{
  // Gather data from windows that were active during this session
  // (if a window wasn't opened in this session we preserve its settings)
  ImGuiContext& g = *ctx;
  for( int i = 0; i != g.Windows.Size; i++ )
  {
    ImGuiWindow* window = g.Windows[ i ];
    if( window->Flags & ImGuiWindowFlags_NoSavedSettings )
      continue;

    ImGuiWindowSettings* settings = ( window->SettingsOffset != -1 ) ? g.SettingsWindows.ptr_from_offset( window->SettingsOffset ) : ImGui::FindWindowSettings( window->ID );
    if( !settings )
    {
      settings = ImGui::CreateNewWindowSettings( window->Name );
      window->SettingsOffset = g.SettingsWindows.offset_from_ptr( settings );
    }
    IM_ASSERT( settings->ID == window->ID );
    settings->Pos = ImVec2ih( ( short )window->Pos.x, ( short )window->Pos.y );
    settings->Size = ImVec2ih( ( short )window->SizeFull.x, ( short )window->SizeFull.y );
    settings->Collapsed = window->Collapsed;
  }

  // Write to text buffer
  buf->reserve( buf->size() + g.SettingsWindows.size() * 6 ); // ballpark reserve
  for( ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk( settings ) )
  {
    const char* settings_name = settings->GetName();
    buf->appendf( SECURE( "[%s][%s]\n" ), handler->TypeName, settings_name );
    buf->appendf( SECURE( "Pos=%d,%d\n" ), settings->Pos.x, settings->Pos.y );
    buf->appendf( SECURE( "Size=%d,%d\n" ), settings->Size.x, settings->Size.y );
    buf->appendf( SECURE( "Collapsed=%d\n" ), settings->Collapsed );
    buf->append( SECURE( "\n" ) );
  }
}


//-----------------------------------------------------------------------------
// [SECTION] VIEWPORTS, PLATFORM WINDOWS
//-----------------------------------------------------------------------------

// (this section is filled in the 'docking' branch)


//-----------------------------------------------------------------------------
// [SECTION] DOCKING
//-----------------------------------------------------------------------------

// (this section is filled in the 'docking' branch)


//-----------------------------------------------------------------------------
// [SECTION] PLATFORM DEPENDENT HELPERS
//-----------------------------------------------------------------------------

#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS)

#ifdef _MSC_VER
#pragma comment(lib, "user32")
#pragma comment(lib, "kernel32")
#endif

// Win32 clipboard implementation
// We use g.ClipboardHandlerData for temporary storage to ensure it is freed on Shutdown()
static const char* GetClipboardTextFn_DefaultImpl( void* )
{
  ImGuiContext& g = *GImGui;
  g.ClipboardHandlerData.clear();
  if( !::OpenClipboard( NULL ) )
    return NULL;
  HANDLE wbuf_handle = ::GetClipboardData( CF_UNICODETEXT );
  if( wbuf_handle == NULL )
  {
    ::CloseClipboard();
    return NULL;
  }
  if( const WCHAR* wbuf_global = ( const WCHAR* )::GlobalLock( wbuf_handle ) )
  {
    int buf_len = ::WideCharToMultiByte( CP_UTF8, 0, wbuf_global, -1, NULL, 0, NULL, NULL );
    g.ClipboardHandlerData.resize( buf_len );
    ::WideCharToMultiByte( CP_UTF8, 0, wbuf_global, -1, g.ClipboardHandlerData.Data, buf_len, NULL, NULL );
  }
  ::GlobalUnlock( wbuf_handle );
  ::CloseClipboard();
  return g.ClipboardHandlerData.Data;
}

static void SetClipboardTextFn_DefaultImpl( void*, const char* text )
{
  if( !::OpenClipboard( NULL ) )
    return;
  const int wbuf_length = ::MultiByteToWideChar( CP_UTF8, 0, text, -1, NULL, 0 );
  HGLOBAL wbuf_handle = ::GlobalAlloc( GMEM_MOVEABLE, ( SIZE_T )wbuf_length * sizeof( WCHAR ) );
  if( wbuf_handle == NULL )
  {
    ::CloseClipboard();
    return;
  }
  WCHAR* wbuf_global = ( WCHAR* )::GlobalLock( wbuf_handle );
  ::MultiByteToWideChar( CP_UTF8, 0, text, -1, wbuf_global, wbuf_length );
  ::GlobalUnlock( wbuf_handle );
  ::EmptyClipboard();
  if( ::SetClipboardData( CF_UNICODETEXT, wbuf_handle ) == NULL )
    ::GlobalFree( wbuf_handle );
  ::CloseClipboard();
}

#elif defined(__APPLE__) && TARGET_OS_OSX && defined(IMGUI_ENABLE_OSX_DEFAULT_CLIPBOARD_FUNCTIONS)

#include <Carbon/Carbon.h>  // Use old API to avoid need for separate .mm file
static PasteboardRef main_clipboard = 0;

// OSX clipboard implementation
// If you enable this you will need to add '-framework ApplicationServices' to your linker command-line!
static void SetClipboardTextFn_DefaultImpl( void*, const char* text )
{
  if( !main_clipboard )
    PasteboardCreate( kPasteboardClipboard, &main_clipboard );
  PasteboardClear( main_clipboard );
  CFDataRef cf_data = CFDataCreate( kCFAllocatorDefault, ( const UInt8* )text, strlen( text ) );
  if( cf_data )
  {
    PasteboardPutItemFlavor( main_clipboard, ( PasteboardItemID )1, CFSTR( "public.utf8-plain-text" ), cf_data, 0 );
    CFRelease( cf_data );
  }
}

static const char* GetClipboardTextFn_DefaultImpl( void* )
{
  if( !main_clipboard )
    PasteboardCreate( kPasteboardClipboard, &main_clipboard );
  PasteboardSynchronize( main_clipboard );

  ItemCount item_count = 0;
  PasteboardGetItemCount( main_clipboard, &item_count );
  for( ItemCount i = 0; i < item_count; i++ )
  {
    PasteboardItemID item_id = 0;
    PasteboardGetItemIdentifier( main_clipboard, i + 1, &item_id );
    CFArrayRef flavor_type_array = 0;
    PasteboardCopyItemFlavors( main_clipboard, item_id, &flavor_type_array );
    for( CFIndex j = 0, nj = CFArrayGetCount( flavor_type_array ); j < nj; j++ )
    {
      CFDataRef cf_data;
      if( PasteboardCopyItemFlavorData( main_clipboard, item_id, CFSTR( "public.utf8-plain-text" ), &cf_data ) == noErr )
      {
        ImGuiContext& g = *GImGui;
        g.ClipboardHandlerData.clear();
        int length = ( int )CFDataGetLength( cf_data );
        g.ClipboardHandlerData.resize( length + 1 );
        CFDataGetBytes( cf_data, CFRangeMake( 0, length ), ( UInt8* )g.ClipboardHandlerData.Data );
        g.ClipboardHandlerData[ length ] = 0;
        CFRelease( cf_data );
        return g.ClipboardHandlerData.Data;
      }
    }
  }
  return NULL;
}

#else

// Local Dear ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers.
static const char* GetClipboardTextFn_DefaultImpl( void* )
{
  ImGuiContext& g = *GImGui;
  return g.ClipboardHandlerData.empty() ? NULL : g.ClipboardHandlerData.begin();
}

static void SetClipboardTextFn_DefaultImpl( void*, const char* text )
{
  ImGuiContext& g = *GImGui;
  g.ClipboardHandlerData.clear();
  const char* text_end = text + strlen( text );
  g.ClipboardHandlerData.resize( ( int )( text_end - text ) + 1 );
  memcpy( &g.ClipboardHandlerData[ 0 ], text, ( size_t )( text_end - text ) );
  g.ClipboardHandlerData[ ( int )( text_end - text ) ] = 0;
}

#endif

// Win32 API IME support (for Asian languages, etc.)
#if defined(_WIN32) && !defined(__GNUC__) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS)

#include <imm.h>
#ifdef _MSC_VER
#pragma comment(lib, "imm32")
#endif

static void ImeSetInputScreenPosFn_DefaultImpl( int x, int y )
{
  // Notify OS Input Method Editor of text input position
  ImGuiIO& io = ImGui::GetIO();
  if( HWND hwnd = ( HWND )io.ImeWindowHandle )
    if( HIMC himc = ::ImmGetContext( hwnd ) )
    {
      COMPOSITIONFORM cf;
      cf.ptCurrentPos.x = x;
      cf.ptCurrentPos.y = y;
      cf.dwStyle = CFS_FORCE_POSITION;
      ::ImmSetCompositionWindow( himc, &cf );
      ::ImmReleaseContext( hwnd, himc );
    }
}

#else

static void ImeSetInputScreenPosFn_DefaultImpl( int, int )
{ }

#endif

//-----------------------------------------------------------------------------
// [SECTION] METRICS/DEBUG WINDOW
//-----------------------------------------------------------------------------

#ifndef IMGUI_DISABLE_METRICS_WINDOW
// Avoid naming collision with imgui_demo.cpp's HelpMarker() for unity builds.
static void MetricsHelpMarker( const char* desc )
{
  ImGui::TextDisabled( SECURE( "(?)" ) );
  if( ImGui::IsItemHovered() )
  {
    ImGui::BeginTooltip();
    ImGui::PushTextWrapPos( ImGui::GetFontSize() * 35.0f );
    ImGui::TextUnformatted( desc );
    ImGui::PopTextWrapPos();
    ImGui::EndTooltip();
  }
}

void ImGui::ShowMetricsWindow( bool* p_open )
{
  if( !ImGui::Begin( SECURE( "Dear ImGui Metrics" ), p_open ) )
  {
    ImGui::End();
    return;
  }

  // Debugging enums
  enum
  {
    WRT_OuterRect, WRT_OuterRectClipped, WRT_InnerRect, WRT_InnerClipRect, WRT_WorkRect, WRT_Content, WRT_ContentRegionRect, WRT_Count
  }; // Windows Rect Type
  const char* wrt_rects_names[ WRT_Count ] = { "OuterRect", "OuterRectClipped", "InnerRect", "InnerClipRect", "WorkRect", "Content", "ContentRegionRect" };
  enum
  {
    TRT_OuterRect, TRT_WorkRect, TRT_HostClipRect, TRT_InnerClipRect, TRT_BackgroundClipRect, TRT_ColumnsRect, TRT_ColumnsClipRect, TRT_ColumnsContentHeadersUsed, TRT_ColumnsContentHeadersDesired, TRT_ColumnsContentRowsFrozen, TRT_ColumnsContentRowsUnfrozen, TRT_Count
  }; // Tables Rect Type
  const char* trt_rects_names[ TRT_Count ] = { "OuterRect", "WorkRect", "HostClipRect", "InnerClipRect", "BackgroundClipRect", "ColumnsRect", "ColumnsClipRect", "ColumnsContentHeadersUsed", "ColumnsContentHeadersDesired", "ColumnsContentRowsFrozen", "ColumnsContentRowsUnfrozen" };

  // State
  static bool show_windows_rects = false;
  static int  show_windows_rect_type = WRT_WorkRect;
  static bool show_windows_begin_order = false;
  static bool show_tables_rects = false;
  static int  show_tables_rect_type = TRT_WorkRect;
  static bool show_drawcmd_mesh = true;
  static bool show_drawcmd_aabb = true;

  // Basic info
  ImGuiContext& g = *GImGui;
  ImGuiIO& io = ImGui::GetIO();
  ImGui::Text( SECURE( "Dear ImGui %s" ), ImGui::GetVersion() );
  ImGui::Text( SECURE( "Application average %.3f ms/frame (%.1f FPS)" ), 1000.0f / io.Framerate, io.Framerate );
  ImGui::Text( SECURE( "%d vertices, %d indices (%d triangles)" ), io.MetricsRenderVertices, io.MetricsRenderIndices, io.MetricsRenderIndices / 3 );
  ImGui::Text( SECURE( "%d active windows (%d visible)" ), io.MetricsActiveWindows, io.MetricsRenderWindows );
  ImGui::Text( SECURE( "%d active allocations" ), io.MetricsActiveAllocations );
  ImGui::Separator();

  // Helper functions to display common structures:
  // - NodeDrawList()
  // - NodeColumns()
  // - NodeWindow()
  // - NodeWindows()
  // - NodeTabBar()
  // - NodeStorage()
  struct Funcs
  {
    static ImRect GetWindowRect( ImGuiWindow* window, int rect_type )
    {
      if( rect_type == WRT_OuterRect )
      {
        return window->Rect();
      }
      else if( rect_type == WRT_OuterRectClipped )
      {
        return window->OuterRectClipped;
      }
      else if( rect_type == WRT_InnerRect )
      {
        return window->InnerRect;
      }
      else if( rect_type == WRT_InnerClipRect )
      {
        return window->InnerClipRect;
      }
      else if( rect_type == WRT_WorkRect )
      {
        return window->WorkRect;
      }
      else if( rect_type == WRT_Content )
      {
        ImVec2 min = window->InnerRect.Min - window->Scroll + window->WindowPadding; return ImRect( min, min + window->ContentSize );
      }
      else if( rect_type == WRT_ContentRegionRect )
      {
        return window->ContentRegionRect;
      }
      IM_ASSERT( 0 );
      return ImRect();
    }

    static void NodeDrawCmdShowMeshAndBoundingBox( ImGuiWindow* window, const ImDrawList* draw_list, const ImDrawCmd* draw_cmd, int elem_offset, bool show_mesh, bool show_aabb )
    {
      IM_ASSERT( show_mesh || show_aabb );
      ImDrawList* fg_draw_list = GetForegroundDrawList( window ); // Render additional visuals into the top-most draw list
      ImDrawIdx* idx_buffer = ( draw_list->IdxBuffer.Size > 0 ) ? draw_list->IdxBuffer.Data : NULL;

      // Draw wire-frame version of all triangles
      ImRect clip_rect = draw_cmd->ClipRect;
      ImRect vtxs_rect( FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX );
      ImDrawListFlags backup_flags = fg_draw_list->Flags;
      fg_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines is more readable for very large and thin triangles.
      for( unsigned int base_idx = elem_offset; base_idx < ( elem_offset + draw_cmd->ElemCount ); base_idx += 3 )
      {
        ImVec2 triangle[ 3 ];
        for( int n = 0; n < 3; n++ )
        {
          ImVec2 p = draw_list->VtxBuffer[ idx_buffer ? idx_buffer[ base_idx + n ] : ( base_idx + n ) ].pos;
          triangle[ n ] = p;
          vtxs_rect.Add( p );
        }
        if( show_mesh )
          fg_draw_list->AddPolyline( triangle, 3, IM_COL32( 255, 255, 0, 255 ), true, 1.0f ); // In yellow: mesh triangles
      }
      // Draw bounding boxes
      if( show_aabb )
      {
        fg_draw_list->AddRect( ImFloor( clip_rect.Min ), ImFloor( clip_rect.Max ), IM_COL32( 255, 0, 255, 255 ) ); // In pink: clipping rectangle submitted to GPU
        fg_draw_list->AddRect( ImFloor( vtxs_rect.Min ), ImFloor( vtxs_rect.Max ), IM_COL32( 0, 255, 255, 255 ) ); // In cyan: bounding box of triangles
      }
      fg_draw_list->Flags = backup_flags;
    }

    static void NodeDrawList( ImGuiWindow* window, ImDrawList* draw_list, const char* label )
    {
      bool node_open = ImGui::TreeNode( draw_list, SECURE( "%s: '%s' %d vtx, %d indices, %d cmds" ), label, draw_list->_OwnerName ? draw_list->_OwnerName : "", draw_list->VtxBuffer.Size, draw_list->IdxBuffer.Size, draw_list->CmdBuffer.Size );
      if( draw_list == ImGui::GetWindowDrawList() )
      {
        ImGui::SameLine();
        ImGui::TextColored( ImVec4( 1.0f, 0.4f, 0.4f, 1.0f ), SECURE( "CURRENTLY APPENDING" ) ); // Can't display stats for active draw list! (we don't have the data double-buffered)
        if( node_open ) ImGui::TreePop();
        return;
      }

      ImDrawList* fg_draw_list = GetForegroundDrawList( window ); // Render additional visuals into the top-most draw list
      if( window && IsItemHovered() )
        fg_draw_list->AddRect( window->Pos, window->Pos + window->Size, IM_COL32( 255, 255, 0, 255 ) );
      if( !node_open )
        return;

      if( window && !window->WasActive )
        ImGui::TextDisabled( SECURE( "Warning: owning Window is inactive. This DrawList is not being rendered!" ) );

      unsigned int elem_offset = 0;
      for( const ImDrawCmd* pcmd = draw_list->CmdBuffer.begin(); pcmd < draw_list->CmdBuffer.end(); elem_offset += pcmd->ElemCount, pcmd++ )
      {
        if( pcmd->UserCallback == NULL && pcmd->ElemCount == 0 )
          continue;
        if( pcmd->UserCallback )
        {
          ImGui::BulletText( SECURE( "Callback %p, user_data %p" ), pcmd->UserCallback, pcmd->UserCallbackData );
          continue;
        }

        ImDrawIdx* idx_buffer = ( draw_list->IdxBuffer.Size > 0 ) ? draw_list->IdxBuffer.Data : NULL;
        char buf[ 300 ];
        ImFormatString( buf, IM_ARRAYSIZE( buf ), SECURE( "DrawCmd: %4d triangles, Tex 0x%p, ClipRect (%4.0f,%4.0f)-(%4.0f,%4.0f)" ),
                        pcmd->ElemCount / 3, ( void* )( intptr_t )pcmd->TextureId,
                        pcmd->ClipRect.x, pcmd->ClipRect.y, pcmd->ClipRect.z, pcmd->ClipRect.w );
        bool pcmd_node_open = ImGui::TreeNode( ( void* )( pcmd - draw_list->CmdBuffer.begin() ), SECURE( "%s" ), buf );
        if( ImGui::IsItemHovered() && ( show_drawcmd_mesh || show_drawcmd_aabb ) && fg_draw_list )
          NodeDrawCmdShowMeshAndBoundingBox( window, draw_list, pcmd, elem_offset, show_drawcmd_mesh, show_drawcmd_aabb );
        if( !pcmd_node_open )
          continue;

        // Calculate approximate coverage area (touched pixel count)
        // This will be in pixels squared as long there's no post-scaling happening to the renderer output.
        float total_area = 0.0f;
        for( unsigned int base_idx = elem_offset; base_idx < ( elem_offset + pcmd->ElemCount ); base_idx += 3 )
        {
          ImVec2 triangle[ 3 ];
          for( int n = 0; n < 3; n++ )
            triangle[ n ] = draw_list->VtxBuffer[ idx_buffer ? idx_buffer[ base_idx + n ] : ( base_idx + n ) ].pos;
          total_area += ImTriangleArea( triangle[ 0 ], triangle[ 1 ], triangle[ 2 ] );
        }

        // Display vertex information summary. Hover to get all triangles drawn in wire-frame
        ImFormatString( buf, IM_ARRAYSIZE( buf ), SECURE( "Mesh: ElemCount: %d, VtxOffset: +%d, IdxOffset: +%d, Area: ~%0.f px" ), pcmd->ElemCount, pcmd->VtxOffset, pcmd->IdxOffset, total_area );
        ImGui::Selectable( buf );
        if( ImGui::IsItemHovered() && fg_draw_list )
          NodeDrawCmdShowMeshAndBoundingBox( window, draw_list, pcmd, elem_offset, true, false );

        // Display individual triangles/vertices. Hover on to get the corresponding triangle highlighted.
        ImGuiListClipper clipper( pcmd->ElemCount / 3 ); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.
        while( clipper.Step() )
          for( int prim = clipper.DisplayStart, idx_i = elem_offset + clipper.DisplayStart * 3; prim < clipper.DisplayEnd; prim++ )
          {
            char* buf_p = buf, * buf_end = buf + IM_ARRAYSIZE( buf );
            ImVec2 triangle[ 3 ];
            for( int n = 0; n < 3; n++, idx_i++ )
            {
              ImDrawVert& v = draw_list->VtxBuffer[ idx_buffer ? idx_buffer[ idx_i ] : idx_i ];
              triangle[ n ] = v.pos;
              buf_p += ImFormatString( buf_p, buf_end - buf_p, SECURE( "%s %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X\n" ),
                                       ( n == 0 ) ? SECURE( "Vert:" ) : SECURE( "     " ), idx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col );
            }

            ImGui::Selectable( buf, false );
            if( fg_draw_list && ImGui::IsItemHovered() )
            {
              ImDrawListFlags backup_flags = fg_draw_list->Flags;
              fg_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines is more readable for very large and thin triangles.
              fg_draw_list->AddPolyline( triangle, 3, IM_COL32( 255, 255, 0, 255 ), true, 1.0f );
              fg_draw_list->Flags = backup_flags;
            }
          }
        ImGui::TreePop();
      }
      ImGui::TreePop();
    }

    static void NodeColumns( const ImGuiColumns* columns )
    {
      if( !ImGui::TreeNode( ( void* )( uintptr_t )columns->ID, "Columns Id: 0x%08X, Count: %d, Flags: 0x%04X", columns->ID, columns->Count, columns->Flags ) )
        return;
      ImGui::BulletText( SECURE("Width: %.1f (MinX: %.1f, MaxX: %.1f)"), columns->OffMaxX - columns->OffMinX, columns->OffMinX, columns->OffMaxX );
      for( int column_n = 0; column_n < columns->Columns.Size; column_n++ )
        ImGui::BulletText( SECURE("Column %02d: OffsetNorm %.3f (= %.1f px)"), column_n, columns->Columns[ column_n ].OffsetNorm, GetColumnOffsetFromNorm( columns, columns->Columns[ column_n ].OffsetNorm ) );
      ImGui::TreePop();
    }

    static void NodeWindows( ImVector<ImGuiWindow*>& windows, const char* label )
    {
      if( !ImGui::TreeNode( label, SECURE("%s (%d)"), label, windows.Size ) )
        return;
      for( int i = 0; i < windows.Size; i++ )
      {
        ImGui::PushID( windows[ i ] );
        Funcs::NodeWindow( windows[ i ], SECURE("Window") );
        ImGui::PopID();
      }
      ImGui::TreePop();
    }

    static void NodeWindow( ImGuiWindow* window, const char* label )
    {
      if( window == NULL )
      {
        ImGui::BulletText( SECURE("%s: NULL"), label );
        return;
      }
      bool open = ImGui::TreeNode( label, SECURE("%s '%s', %d @ 0x%p"), label, window->Name, ( window->Active || window->WasActive ), window );
      if( ImGui::IsItemHovered() && window->WasActive )
        ImGui::GetForegroundDrawList()->AddRect( window->Pos, window->Pos + window->Size, IM_COL32( 255, 255, 0, 255 ) );
      if( !open )
        return;

      if( !window->WasActive )
        ImGui::TextDisabled( SECURE("Note: window is not currently visible.") );
      if( window->MemoryCompacted )
        ImGui::TextDisabled( SECURE("Note: some memory buffers have been compacted/freed.") );

      ImGuiWindowFlags flags = window->Flags;
      NodeDrawList( window, window->DrawList, "DrawList" );
      ImGui::BulletText( SECURE("Pos: (%.1f,%.1f), Size: (%.1f,%.1f), ContentSize (%.1f,%.1f)"), window->Pos.x, window->Pos.y, window->Size.x, window->Size.y, window->ContentSize.x, window->ContentSize.y );
      ImGui::BulletText( SECURE("Flags: 0x%08X (%s%s%s%s%s%s%s%s%s..)"), flags,
                         ( flags & ImGuiWindowFlags_ChildWindow ) ? SECURE("Child ") : "", ( flags & ImGuiWindowFlags_Tooltip ) ? SECURE("Tooltip ") : "", ( flags & ImGuiWindowFlags_Popup ) ? SECURE("Popup ") : "",
                         ( flags & ImGuiWindowFlags_Modal ) ? SECURE("Modal ") : "", ( flags & ImGuiWindowFlags_ChildMenu ) ? SECURE("ChildMenu ") : "", ( flags & ImGuiWindowFlags_NoSavedSettings ) ? SECURE("NoSavedSettings ") : "",
                         ( flags & ImGuiWindowFlags_NoMouseInputs ) ? SECURE("NoMouseInputs") : "", ( flags & ImGuiWindowFlags_NoNavInputs ) ? SECURE("NoNavInputs") : "", ( flags & ImGuiWindowFlags_AlwaysAutoResize ) ? SECURE("AlwaysAutoResize") : "" );
      ImGui::BulletText( SECURE("Scroll: (%.2f/%.2f,%.2f/%.2f) Scrollbar:%s%s"), window->Scroll.x, window->ScrollMax.x, window->Scroll.y, window->ScrollMax.y, window->ScrollbarX ? SECURE("X") : "", window->ScrollbarY ? SECURE("Y") : "" );
      ImGui::BulletText( SECURE("Active: %d/%d, WriteAccessed: %d, BeginOrderWithinContext: %d"), window->Active, window->WasActive, window->WriteAccessed, ( window->Active || window->WasActive ) ? window->BeginOrderWithinContext : -1 );
      ImGui::BulletText( SECURE("Appearing: %d, Hidden: %d (CanSkip %d Cannot %d), SkipItems: %d"), window->Appearing, window->Hidden, window->HiddenFramesCanSkipItems, window->HiddenFramesCannotSkipItems, window->SkipItems );
      ImGui::BulletText( SECURE("NavLastIds: 0x%08X,0x%08X, NavLayerActiveMask: %X"), window->NavLastIds[ 0 ], window->NavLastIds[ 1 ], window->DC.NavLayerActiveMask );
      ImGui::BulletText( SECURE("NavLastChildNavWindow: %s"), window->NavLastChildNavWindow ? window->NavLastChildNavWindow->Name : "NULL" );
      if( !window->NavRectRel[ 0 ].IsInverted() )
        ImGui::BulletText( SECURE("NavRectRel[0]: (%.1f,%.1f)(%.1f,%.1f)"), window->NavRectRel[ 0 ].Min.x, window->NavRectRel[ 0 ].Min.y, window->NavRectRel[ 0 ].Max.x, window->NavRectRel[ 0 ].Max.y );
      else
        ImGui::BulletText( SECURE("NavRectRel[0]: <None>") );
      if( window->RootWindow != window ) NodeWindow( window->RootWindow, SECURE("RootWindow") );
      if( window->ParentWindow != NULL ) NodeWindow( window->ParentWindow, SECURE("ParentWindow") );
      if( window->DC.ChildWindows.Size > 0 ) NodeWindows( window->DC.ChildWindows, SECURE("ChildWindows") );
      if( window->ColumnsStorage.Size > 0 && ImGui::TreeNode( SECURE("Columns"), SECURE("Columns sets (%d)"), window->ColumnsStorage.Size ) )
      {
        for( int n = 0; n < window->ColumnsStorage.Size; n++ )
          NodeColumns( &window->ColumnsStorage[ n ] );
        ImGui::TreePop();
      }
      NodeStorage( &window->StateStorage, SECURE("Storage") );
      ImGui::TreePop();
    }

    static void NodeTabBar( ImGuiTabBar* tab_bar )
    {
      // Standalone tab bars (not associated to docking/windows functionality) currently hold no discernible strings.
      char buf[ 256 ];
      char* p = buf;
      const char* buf_end = buf + IM_ARRAYSIZE( buf );
      p += ImFormatString( p, buf_end - p, SECURE("TabBar (%d tabs)%s"), tab_bar->Tabs.Size, ( tab_bar->PrevFrameVisible < ImGui::GetFrameCount() - 2 ) ? " *Inactive*" : "" );
      if( ImGui::TreeNode( tab_bar, SECURE("%s"), buf ) )
      {
        for( int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++ )
        {
          const ImGuiTabItem* tab = &tab_bar->Tabs[ tab_n ];
          ImGui::PushID( tab );
          if( ImGui::SmallButton( SECURE("<") ) )
          {
            TabBarQueueChangeTabOrder( tab_bar, tab, -1 );
          } ImGui::SameLine( 0, 2 );
          if( ImGui::SmallButton( SECURE(">") ) )
          {
            TabBarQueueChangeTabOrder( tab_bar, tab, +1 );
          } ImGui::SameLine();
          ImGui::Text( SECURE("%02d%c Tab 0x%08X '%s'"), tab_n, ( tab->ID == tab_bar->SelectedTabId ) ? '*' : ' ', tab->ID, ( tab->NameOffset != -1 ) ? tab_bar->GetTabName( tab ) : "" );
          ImGui::PopID();
        }
        ImGui::TreePop();
      }
    }

    static void NodeStorage( ImGuiStorage* storage, const char* label )
    {
      if( !ImGui::TreeNode( label, SECURE("%s: %d entries, %d bytes"), label, storage->Data.Size, storage->Data.size_in_bytes() ) )
        return;
      for( int n = 0; n < storage->Data.Size; n++ )
      {
        const ImGuiStorage::ImGuiStoragePair& p = storage->Data[ n ];
        ImGui::BulletText( SECURE("Key 0x%08X Value { i: %d }"), p.key, p.val_i ); // Important: we currently don't store a type, real value may not be integer.
      }
      ImGui::TreePop();
    }
  };


  // Tools
  if( ImGui::TreeNode( SECURE("Tools") ) )
  {
    // The Item Picker tool is super useful to visually select an item and break into the call-stack of where it was submitted.
    if( ImGui::Button( SECURE("Item Picker..") ) )
      ImGui::DebugStartItemPicker();
    ImGui::SameLine();
    MetricsHelpMarker( SECURE("Will call the IM_DEBUG_BREAK() macro to break in debugger.\nWarning: If you don't have a debugger attached, this will probably crash.") );

    ImGui::Checkbox( SECURE("Show windows begin order"), &show_windows_begin_order );
    ImGui::Checkbox( SECURE("Show windows rectangles"), &show_windows_rects );
    ImGui::SameLine();
    ImGui::SetNextItemWidth( ImGui::GetFontSize() * 12 );
    show_windows_rects |= ImGui::Combo( SECURE("##show_windows_rect_type"), &show_windows_rect_type, wrt_rects_names, WRT_Count, WRT_Count );
    if( show_windows_rects && g.NavWindow )
    {
      ImGui::BulletText( SECURE("'%s':"), g.NavWindow->Name );
      ImGui::Indent();
      for( int rect_n = 0; rect_n < WRT_Count; rect_n++ )
      {
        ImRect r = Funcs::GetWindowRect( g.NavWindow, rect_n );
        ImGui::Text( SECURE("(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) %s"), r.Min.x, r.Min.y, r.Max.x, r.Max.y, r.GetWidth(), r.GetHeight(), wrt_rects_names[ rect_n ] );
      }
      ImGui::Unindent();
    }
    ImGui::Checkbox( SECURE("Show mesh when hovering ImDrawCmd"), &show_drawcmd_mesh );
    ImGui::Checkbox( SECURE("Show bounding boxes when hovering ImDrawCmd"), &show_drawcmd_aabb );
    ImGui::TreePop();
  }

  // Contents
  Funcs::NodeWindows( g.Windows, SECURE("Windows") );
  //Funcs::NodeWindows(g.WindowsFocusOrder, "WindowsFocusOrder");
  if( ImGui::TreeNode( SECURE("DrawLists"), SECURE("Active DrawLists (%d)"), g.DrawDataBuilder.Layers[ 0 ].Size ) )
  {
    for( int i = 0; i < g.DrawDataBuilder.Layers[ 0 ].Size; i++ )
      Funcs::NodeDrawList( NULL, g.DrawDataBuilder.Layers[ 0 ][ i ], SECURE("DrawList") );
    ImGui::TreePop();
  }

  // Details for Popups
  if( ImGui::TreeNode( SECURE("Popups"), SECURE("Popups (%d)"), g.OpenPopupStack.Size ) )
  {
    for( int i = 0; i < g.OpenPopupStack.Size; i++ )
    {
      ImGuiWindow* window = g.OpenPopupStack[ i ].Window;
      ImGui::BulletText( SECURE("PopupID: %08x, Window: '%s'%s%s"), g.OpenPopupStack[ i ].PopupId, window ? window->Name : SECURE("NULL"), window && ( window->Flags & ImGuiWindowFlags_ChildWindow ) ? SECURE(" ChildWindow") : "", window && ( window->Flags & ImGuiWindowFlags_ChildMenu ) ? SECURE(" ChildMenu") : "" );
    }
    ImGui::TreePop();
  }

  // Details for TabBars
  if( ImGui::TreeNode( SECURE("TabBars"), SECURE("Tab Bars (%d)"), g.TabBars.GetSize() ) )
  {
    for( int n = 0; n < g.TabBars.GetSize(); n++ )
      Funcs::NodeTabBar( g.TabBars.GetByIndex( n ) );
    ImGui::TreePop();
  }

  // Details for Tables
  IM_UNUSED( trt_rects_names );
  IM_UNUSED( show_tables_rects );
  IM_UNUSED( show_tables_rect_type );
#ifdef IMGUI_HAS_TABLE
  if( ImGui::TreeNode( "Tables", "Tables (%d)", g.Tables.GetSize() ) )
  {
    for( int n = 0; n < g.Tables.GetSize(); n++ )
      Funcs::NodeTable( g.Tables.GetByIndex( n ) );
    ImGui::TreePop();
  }
#endif // #define IMGUI_HAS_TABLE

  // Details for Docking
#ifdef IMGUI_HAS_DOCK
  if( ImGui::TreeNode( "Docking" ) )
  {
    ImGui::TreePop();
  }
#endif // #define IMGUI_HAS_DOCK

  // Misc Details
  if( ImGui::TreeNode( "Internal state" ) )
  {
    const char* input_source_names[] = { "None", "Mouse", "Nav", "NavKeyboard", "NavGamepad" }; IM_ASSERT( IM_ARRAYSIZE( input_source_names ) == ImGuiInputSource_COUNT );
    ImGui::Text( "HoveredWindow: '%s'", g.HoveredWindow ? g.HoveredWindow->Name : "NULL" );
    ImGui::Text( "HoveredRootWindow: '%s'", g.HoveredRootWindow ? g.HoveredRootWindow->Name : "NULL" );
    ImGui::Text( "HoveredId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d", g.HoveredId, g.HoveredIdPreviousFrame, g.HoveredIdTimer, g.HoveredIdAllowOverlap ); // Data is "in-flight" so depending on when the Metrics window is called we may see current frame information or not
    ImGui::Text( "ActiveId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d, Source: %s", g.ActiveId, g.ActiveIdPreviousFrame, g.ActiveIdTimer, g.ActiveIdAllowOverlap, input_source_names[ g.ActiveIdSource ] );
    ImGui::Text( "ActiveIdWindow: '%s'", g.ActiveIdWindow ? g.ActiveIdWindow->Name : "NULL" );
    ImGui::Text( "MovingWindow: '%s'", g.MovingWindow ? g.MovingWindow->Name : "NULL" );
    ImGui::Text( "NavWindow: '%s'", g.NavWindow ? g.NavWindow->Name : "NULL" );
    ImGui::Text( "NavId: 0x%08X, NavLayer: %d", g.NavId, g.NavLayer );
    ImGui::Text( "NavInputSource: %s", input_source_names[ g.NavInputSource ] );
    ImGui::Text( "NavActive: %d, NavVisible: %d", g.IO.NavActive, g.IO.NavVisible );
    ImGui::Text( "NavActivateId: 0x%08X, NavInputId: 0x%08X", g.NavActivateId, g.NavInputId );
    ImGui::Text( "NavDisableHighlight: %d, NavDisableMouseHover: %d", g.NavDisableHighlight, g.NavDisableMouseHover );
    ImGui::Text( "NavWindowingTarget: '%s'", g.NavWindowingTarget ? g.NavWindowingTarget->Name : "NULL" );
    ImGui::Text( "DragDrop: %d, SourceId = 0x%08X, Payload \"%s\" (%d bytes)", g.DragDropActive, g.DragDropPayload.SourceId, g.DragDropPayload.DataType, g.DragDropPayload.DataSize );
    ImGui::TreePop();
  }

  // Overlay: Display windows Rectangles and Begin Order
  if( show_windows_rects || show_windows_begin_order )
  {
    for( int n = 0; n < g.Windows.Size; n++ )
    {
      ImGuiWindow* window = g.Windows[ n ];
      if( !window->WasActive )
        continue;
      ImDrawList* draw_list = GetForegroundDrawList( window );
      if( show_windows_rects )
      {
        ImRect r = Funcs::GetWindowRect( window, show_windows_rect_type );
        draw_list->AddRect( r.Min, r.Max, IM_COL32( 255, 0, 128, 255 ) );
      }
      if( show_windows_begin_order && !( window->Flags & ImGuiWindowFlags_ChildWindow ) )
      {
        char buf[ 32 ];
        ImFormatString( buf, IM_ARRAYSIZE( buf ), "%d", window->BeginOrderWithinContext );
        float font_size = ImGui::GetFontSize();
        draw_list->AddRectFilled( window->Pos, window->Pos + ImVec2( font_size, font_size ), IM_COL32( 200, 100, 100, 255 ) );
        draw_list->AddText( window->Pos, IM_COL32( 255, 255, 255, 255 ), buf );
      }
    }
  }

#ifdef IMGUI_HAS_TABLE
  // Overlay: Display Tables Rectangles
  if( show_tables_rects )
  {
    for( int table_n = 0; table_n < g.Tables.GetSize(); table_n++ )
    {
      ImGuiTable* table = g.Tables.GetByIndex( table_n );
    }
  }
#endif // #define IMGUI_HAS_TABLE

#ifdef IMGUI_HAS_DOCK
  // Overlay: Display Docking info
  if( show_docking_nodes && g.IO.KeyCtrl )
  {
  }
#endif // #define IMGUI_HAS_DOCK

  ImGui::End();
}

#else

void ImGui::ShowMetricsWindow( bool* )
{ }

#endif

//-----------------------------------------------------------------------------

// Include imgui_user.inl at the end of imgui.cpp to access private data/functions that aren't exposed.
// Prefer just including imgui_internal.h from your code rather than using this define. If a declaration is missing from imgui_internal.h add it or request it on the github.
#ifdef IMGUI_INCLUDE_IMGUI_USER_INL
#include "imgui_user.inl"
#endif

//-----------------------------------------------------------------------------

#endif // #ifndef IMGUI_DISABLE
```

`horizon/imgui/imgui.hpp`:

```hpp
// dear imgui, v1.77 WIP
// (headers)

// Help:
// - Read FAQ at http://dearimgui.org/faq
// - Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.
// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code. All applications in examples/ are doing that.
// Read imgui.cpp for details, links and comments.

// Resources:
// - FAQ                   http://dearimgui.org/faq
// - Homepage & latest     https://github.com/ocornut/imgui
// - Releases & changelog  https://github.com/ocornut/imgui/releases
// - Gallery               https://github.com/ocornut/imgui/issues/3075 (please post your screenshots/video there!)
// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary
// - Wiki                  https://github.com/ocornut/imgui/wiki
// - Issues & support      https://github.com/ocornut/imgui/issues

/*

Index of this file:
// Header mess
// Forward declarations and basic types
// ImGui API (Dear ImGui end-user API)
// Flags & Enumerations
// Memory allocations macros
// ImVector<>
// ImGuiStyle
// ImGuiIO
// Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiPayload)
// Obsolete functions
// Helpers (ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, ImColor)
// Draw List API (ImDrawCallback, ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListSplitter, ImDrawListFlags, ImDrawList, ImDrawData)
// Font API (ImFontConfig, ImFontGlyph, ImFontGlyphRangesBuilder, ImFontAtlasFlags, ImFontAtlas, ImFont)

*/

#pragma once

// Configuration file with compile-time options (edit imconfig.h or #define IMGUI_USER_CONFIG to your own filename)
#ifdef IMGUI_USER_CONFIG
#include IMGUI_USER_CONFIG
#endif
#if !defined(IMGUI_DISABLE_INCLUDE_IMCONFIG_H) || defined(IMGUI_INCLUDE_IMCONFIG_H)
#include "imconfig.hpp"
#endif

#ifndef IMGUI_DISABLE

//-----------------------------------------------------------------------------
// Header mess
//-----------------------------------------------------------------------------

// Includes
#include <float.h>                  // FLT_MIN, FLT_MAX
#include <stdarg.h>                 // va_list, va_start, va_end
#include <stddef.h>                 // ptrdiff_t, NULL
#include <string.h>                 // memset, memmove, memcpy, strlen, strchr, strcpy, strcmp

// Atom includes
#include "../constant/character.hpp"
#include "../constant/hash.hpp"
#include "../constant/secure_string.hpp"
#include "../constant/string.hpp"

// Version
// (Integer encoded as XYYZZ for use in #if preprocessor conditionals. Work in progress versions typically starts at XYY99 then bounce up to XYY00, XYY01 etc. when release tagging happens)
#define IMGUI_VERSION               "1.77 WIP"
#define IMGUI_VERSION_NUM           17601
#define IMGUI_CHECKVERSION()        ImGui::DebugCheckVersionAndDataLayout(IMGUI_VERSION, sizeof(ImGuiIO), sizeof(ImGuiStyle), sizeof(ImVec2), sizeof(ImVec4), sizeof(ImDrawVert), sizeof(ImDrawIdx))

// Define attributes of all API symbols declarations (e.g. for DLL under Windows)
// IMGUI_API is used for core imgui functions, IMGUI_IMPL_API is used for the default bindings files (imgui_impl_xxx.h)
// Using dear imgui via a shared library is not recommended, because we don't guarantee backward nor forward ABI compatibility (also function call overhead, as dear imgui is a call-heavy API)
#ifndef IMGUI_API
#define IMGUI_API
#endif
#ifndef IMGUI_IMPL_API
#define IMGUI_IMPL_API              IMGUI_API
#endif

// Helper Macros
#ifndef IM_ASSERT
#include <assert.h>
#define IM_ASSERT(_EXPR)            assert(_EXPR)                               // You can override the default assert handler by editing imconfig.h
#endif
#if !defined(IMGUI_USE_STB_SPRINTF) && (defined(__clang__) || defined(__GNUC__))
#define IM_FMTARGS(FMT)             __attribute__((format(printf, FMT, FMT+1))) // To apply printf-style warnings to our functions.
#define IM_FMTLIST(FMT)             __attribute__((format(printf, FMT, 0)))
#else
#define IM_FMTARGS(FMT)
#define IM_FMTLIST(FMT)
#endif
#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*_ARR)))       // Size of a static C-style array. Don't use on pointers!
#define IM_UNUSED(_VAR)             ((void)_VAR)                                // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
#if (__cplusplus >= 201100)
#define IM_OFFSETOF(_TYPE,_MEMBER)  offsetof(_TYPE, _MEMBER)                    // Offset of _MEMBER within _TYPE. Standardized as offsetof() in C++11
#else
#define IM_OFFSETOF(_TYPE,_MEMBER)  ((size_t)&(((_TYPE*)0)->_MEMBER))           // Offset of _MEMBER within _TYPE. Old style macro.
#endif

// Warnings
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wold-style-cast"
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
#endif
#elif defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpragmas"                  // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wclass-memaccess"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif

//-----------------------------------------------------------------------------
// Forward declarations and basic types
//-----------------------------------------------------------------------------

// Forward declarations
struct ImDrawChannel;               // Temporary storage to output draw commands out of order, used by ImDrawListSplitter and ImDrawList::ChannelsSplit()
struct ImDrawCmd;                   // A single draw command within a parent ImDrawList (generally maps to 1 GPU draw call, unless it is a callback)
struct ImDrawData;                  // All draw command lists required to render the frame + pos/size coordinates to use for the projection matrix.
struct ImDrawList;                  // A single draw command list (generally one per window, conceptually you may see this as a dynamic "mesh" builder)
struct ImDrawListSharedData;        // Data shared among multiple draw lists (typically owned by parent ImGui context, but you may create one yourself)
struct ImDrawListSplitter;          // Helper to split a draw list into different layers which can be drawn into out of order, then flattened back.
struct ImDrawVert;                  // A single vertex (pos + uv + col = 20 bytes by default. Override layout with IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT)
struct ImFont;                      // Runtime data for a single font within a parent ImFontAtlas
struct ImFontAtlas;                 // Runtime data for multiple fonts, bake multiple fonts into a single texture, TTF/OTF font loader
struct ImFontConfig;                // Configuration data when adding a font or merging fonts
struct ImFontGlyph;                 // A single font glyph (code point + coordinates within in ImFontAtlas + offset)
struct ImFontGlyphRangesBuilder;    // Helper to build glyph ranges from text/string data
struct ImColor;                     // Helper functions to create a color that can be converted to either u32 or float4 (*OBSOLETE* please avoid using)
struct ImGuiContext;                // Dear ImGui context (opaque structure, unless including imgui_internal.h)
struct ImGuiIO;                     // Main configuration and I/O between your application and ImGui
struct ImGuiInputTextCallbackData;  // Shared state of InputText() when using custom ImGuiInputTextCallback (rare/advanced use)
struct ImGuiListClipper;            // Helper to manually clip large list of items
struct ImGuiOnceUponAFrame;         // Helper for running a block of code not more than once a frame, used by IMGUI_ONCE_UPON_A_FRAME macro
struct ImGuiPayload;                // User data payload for drag and drop operations
struct ImGuiSizeCallbackData;       // Callback data when using SetNextWindowSizeConstraints() (rare/advanced use)
struct ImGuiStorage;                // Helper for key->value storage
struct ImGuiStyle;                  // Runtime data for styling/colors
struct ImGuiTextBuffer;             // Helper to hold and append into a text buffer (~string builder)
struct ImGuiTextFilter;             // Helper to parse and apply text filters (e.g. "aaaaa[,bbbbb][,ccccc]")

// Enums/Flags (declared as int for compatibility with old C++, to allow using as flags and to not pollute the top of this file)
// - Tip: Use your programming IDE navigation facilities on the names in the _central column_ below to find the actual flags/enum lists!
//   In Visual Studio IDE: CTRL+comma ("Edit.NavigateTo") can follow symbols in comments, whereas CTRL+F12 ("Edit.GoToImplementation") cannot.
//   With Visual Assist installed: ALT+G ("VAssistX.GoToImplementation") can also follow symbols in comments.
typedef int ImGuiCol;               // -> enum ImGuiCol_             // Enum: A color identifier for styling
typedef int ImGuiCond;              // -> enum ImGuiCond_            // Enum: A condition for many Set*() functions
typedef int ImGuiDataType;          // -> enum ImGuiDataType_        // Enum: A primary data type
typedef int ImGuiDir;               // -> enum ImGuiDir_             // Enum: A cardinal direction
typedef int ImGuiKey;               // -> enum ImGuiKey_             // Enum: A key identifier (ImGui-side enum)
typedef int ImGuiNavInput;          // -> enum ImGuiNavInput_        // Enum: An input identifier for navigation
typedef int ImGuiMouseButton;       // -> enum ImGuiMouseButton_     // Enum: A mouse button identifier (0=left, 1=right, 2=middle)
typedef int ImGuiMouseCursor;       // -> enum ImGuiMouseCursor_     // Enum: A mouse cursor identifier
typedef int ImGuiStyleVar;          // -> enum ImGuiStyleVar_        // Enum: A variable identifier for styling
typedef int ImDrawCornerFlags;      // -> enum ImDrawCornerFlags_    // Flags: for ImDrawList::AddRect(), AddRectFilled() etc.
typedef int ImDrawListFlags;        // -> enum ImDrawListFlags_      // Flags: for ImDrawList
typedef int ImFontAtlasFlags;       // -> enum ImFontAtlasFlags_     // Flags: for ImFontAtlas
typedef int ImGuiBackendFlags;      // -> enum ImGuiBackendFlags_    // Flags: for io.BackendFlags
typedef int ImGuiColorEditFlags;    // -> enum ImGuiColorEditFlags_  // Flags: for ColorEdit4(), ColorPicker4() etc.
typedef int ImGuiConfigFlags;       // -> enum ImGuiConfigFlags_     // Flags: for io.ConfigFlags
typedef int ImGuiComboFlags;        // -> enum ImGuiComboFlags_      // Flags: for BeginCombo()
typedef int ImGuiDragDropFlags;     // -> enum ImGuiDragDropFlags_   // Flags: for BeginDragDropSource(), AcceptDragDropPayload()
typedef int ImGuiFocusedFlags;      // -> enum ImGuiFocusedFlags_    // Flags: for IsWindowFocused()
typedef int ImGuiHoveredFlags;      // -> enum ImGuiHoveredFlags_    // Flags: for IsItemHovered(), IsWindowHovered() etc.
typedef int ImGuiInputTextFlags;    // -> enum ImGuiInputTextFlags_  // Flags: for InputText(), InputTextMultiline()
typedef int ImGuiKeyModFlags;       // -> enum ImGuiKeyModFlags_     // Flags: for io.KeyMods (Ctrl/Shift/Alt/Super)
typedef int ImGuiSelectableFlags;   // -> enum ImGuiSelectableFlags_ // Flags: for Selectable()
typedef int ImGuiTabBarFlags;       // -> enum ImGuiTabBarFlags_     // Flags: for BeginTabBar()
typedef int ImGuiTabItemFlags;      // -> enum ImGuiTabItemFlags_    // Flags: for BeginTabItem()
typedef int ImGuiTreeNodeFlags;     // -> enum ImGuiTreeNodeFlags_   // Flags: for TreeNode(), TreeNodeEx(), CollapsingHeader()
typedef int ImGuiWindowFlags;       // -> enum ImGuiWindowFlags_     // Flags: for Begin(), BeginChild()

// Other types
#ifndef ImTextureID                 // ImTextureID [configurable type: override in imconfig.h with '#define ImTextureID xxx']
typedef void* ImTextureID;          // User data for rendering back-end to identify a texture. This is whatever to you want it to be! read the FAQ about ImTextureID for details.
#endif
typedef unsigned int ImGuiID;       // A unique ID used by widgets, typically hashed from a stack of string.
typedef int ( *ImGuiInputTextCallback )( ImGuiInputTextCallbackData* data );
typedef void ( *ImGuiSizeCallback )( ImGuiSizeCallbackData* data );

// Decoded character types
// (we generally use UTF-8 encoded string in the API. This is storage specifically for a decoded character used for keyboard input and display)
typedef unsigned short ImWchar16;   // A single decoded U16 character/code point. We encode them as multi bytes UTF-8 when used in strings.
typedef unsigned int ImWchar32;     // A single decoded U32 character/code point. We encode them as multi bytes UTF-8 when used in strings.
#ifdef IMGUI_USE_WCHAR32            // ImWchar [configurable type: override in imconfig.h with '#define IMGUI_USE_WCHAR32' to support Unicode planes 1-16]
typedef ImWchar32 ImWchar;
#else
typedef ImWchar16 ImWchar;
#endif

// Basic scalar data types
typedef signed char         ImS8;   // 8-bit signed integer
typedef unsigned char       ImU8;   // 8-bit unsigned integer
typedef signed short        ImS16;  // 16-bit signed integer
typedef unsigned short      ImU16;  // 16-bit unsigned integer
typedef signed int          ImS32;  // 32-bit signed integer == int
typedef unsigned int        ImU32;  // 32-bit unsigned integer (often used to store packed colors)
#if defined(_MSC_VER) && !defined(__clang__)
typedef signed   __int64    ImS64;  // 64-bit signed integer (pre and post C++11 with Visual Studio)
typedef unsigned __int64    ImU64;  // 64-bit unsigned integer (pre and post C++11 with Visual Studio)
#elif (defined(__clang__) || defined(__GNUC__)) && (__cplusplus < 201100)
#include <stdint.h>
typedef int64_t             ImS64;  // 64-bit signed integer (pre C++11)
typedef uint64_t            ImU64;  // 64-bit unsigned integer (pre C++11)
#else
typedef signed   long long  ImS64;  // 64-bit signed integer (post C++11)
typedef unsigned long long  ImU64;  // 64-bit unsigned integer (post C++11)
#endif

// 2D vector (often used to store positions or sizes)
struct ImVec2
{
	float                                   x, y;
	ImVec2()
	{
		x = y = 0.0f;
	}
	ImVec2( float _x, float _y )
	{
		x = _x; y = _y;
	}
	float  operator[] ( size_t idx ) const
	{
		IM_ASSERT( idx <= 1 ); return ( &x )[ idx ];
	}    // We very rarely use this [] operator, the assert overhead is fine.
	float& operator[] ( size_t idx )
	{
		IM_ASSERT( idx <= 1 ); return ( &x )[ idx ];
	}    // We very rarely use this [] operator, the assert overhead is fine.
#ifdef IM_VEC2_CLASS_EXTRA
	IM_VEC2_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec2.
#endif
};

// 4D vector (often used to store floating-point colors)
struct ImVec4
{
	float                                   x, y, z, w;
	ImVec4()
	{
		x = y = z = w = 0.0f;
	}
	ImVec4( float _x, float _y, float _z, float _w )
	{
		x = _x; y = _y; z = _z; w = _w;
	}
#ifdef IM_VEC4_CLASS_EXTRA
	IM_VEC4_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec4.
#endif
};

//-----------------------------------------------------------------------------
// ImGui: Dear ImGui end-user API
// (This is a namespace. You can add extra ImGui:: functions in your own separate file. Please don't modify imgui source files!)
//-----------------------------------------------------------------------------

namespace ImGui
{
// Context creation and access
// Each context create its own ImFontAtlas by default. You may instance one yourself and pass it to CreateContext() to share a font atlas between imgui contexts.
// None of those functions is reliant on the current context.
IMGUI_API ImGuiContext* CreateContext( ImFontAtlas* shared_font_atlas = NULL );
IMGUI_API void          DestroyContext( ImGuiContext* ctx = NULL );   // NULL = destroy current context
IMGUI_API ImGuiContext* GetCurrentContext();
IMGUI_API void          SetCurrentContext( ImGuiContext* ctx );

// Main
IMGUI_API ImGuiIO& GetIO();                                    // access the IO structure (mouse/keyboard/gamepad inputs, time, various configuration options/flags)
IMGUI_API ImGuiStyle& GetStyle();                                 // access the Style structure (colors, sizes). Always use PushStyleCol(), PushStyleVar() to modify style mid-frame!
IMGUI_API void          NewFrame();                                 // start a new Dear ImGui frame, you can submit any command from this point until Render()/EndFrame().
IMGUI_API void          EndFrame();                                 // ends the Dear ImGui frame. automatically called by Render(). If you don't need to render data (skipping rendering) you may call EndFrame() without Render()... but you'll have wasted CPU already! If you don't need to render, better to not create any windows and not call NewFrame() at all!
IMGUI_API void          Render();                                   // ends the Dear ImGui frame, finalize the draw data. You can get call GetDrawData() to obtain it and run your rendering function (up to v1.60, this used to call io.RenderDrawListsFn(). Nowadays, we allow and prefer calling your render function yourself.)
IMGUI_API ImDrawData* GetDrawData();                              // valid after Render() and until the next call to NewFrame(). this is what you have to render.

// Demo, Debug, Information
IMGUI_API void          ShowDemoWindow( bool* p_open = NULL );        // create Demo window (previously called ShowTestWindow). demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application!
IMGUI_API void          ShowAboutWindow( bool* p_open = NULL );       // create About window. display Dear ImGui version, credits and build/system information.
IMGUI_API void          ShowMetricsWindow( bool* p_open = NULL );     // create Debug/Metrics window. display Dear ImGui internals: draw commands (with individual draw calls and vertices), window list, basic internal state, etc.
IMGUI_API void          ShowStyleEditor( ImGuiStyle* ref = NULL );    // add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)
IMGUI_API bool          ShowStyleSelector( const char* label );       // add style selector block (not a window), essentially a combo listing the default styles.
IMGUI_API void          ShowFontSelector( const char* label );        // add font selector block (not a window), essentially a combo listing the loaded fonts.
IMGUI_API void          ShowUserGuide();                            // add basic help/info block (not a window): how to manipulate ImGui as a end-user (mouse/keyboard controls).
IMGUI_API const char* GetVersion();                               // get the compiled version string e.g. "1.23" (essentially the compiled value for IMGUI_VERSION)

// Styles
IMGUI_API void          StyleColorsDark( ImGuiStyle* dst = NULL );    // new, recommended style (default)
IMGUI_API void          StyleColorsClassic( ImGuiStyle* dst = NULL ); // classic imgui style
IMGUI_API void          StyleColorsLight( ImGuiStyle* dst = NULL );   // best used with borders and a custom, thicker font

// Windows
// - Begin() = push window to the stack and start appending to it. End() = pop window from the stack.
// - You may append multiple times to the same window during the same frame.
// - Passing 'bool* p_open != NULL' shows a window-closing widget in the upper-right corner of the window,
//   which clicking will set the boolean to false when clicked.
// - Begin() return false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting
//   anything to the window. Always call a matching End() for each Begin() call, regardless of its return value!
//   [Important: due to legacy reason, this is inconsistent with most other functions such as BeginMenu/EndMenu,
//    BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding BeginXXX function
//    returned true. Begin and BeginChild are the only odd ones out. Will be fixed in a future update.]
// - Note that the bottom of window stack always contains a window called "Debug".
IMGUI_API bool          Begin( const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0 );
IMGUI_API void          End();

// Child Windows
// - Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window. Child windows can embed their own child.
// - For each independent axis of 'size': ==0.0f: use remaining host window size / >0.0f: fixed size / <0.0f: use remaining window size minus abs(size) / Each axis can use a different mode, e.g. ImVec2(0,400).
// - BeginChild() returns false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting anything to the window.
//   Always call a matching EndChild() for each BeginChild() call, regardless of its return value [as with Begin: this is due to legacy reason and inconsistent with most BeginXXX functions apart from the regular Begin() which behaves like BeginChild().]
IMGUI_API bool          BeginChild( const char* str_id, const ImVec2& size = ImVec2( 0, 0 ), bool border = false, ImGuiWindowFlags flags = 0 );
IMGUI_API bool          BeginChild( ImGuiID id, const ImVec2& size = ImVec2( 0, 0 ), bool border = false, ImGuiWindowFlags flags = 0 );
IMGUI_API void          EndChild();

// Windows Utilities
// - 'current window' = the window we are appending into while inside a Begin()/End() block. 'next window' = next window we will Begin() into.
IMGUI_API bool          IsWindowAppearing();
IMGUI_API bool          IsWindowCollapsed();
IMGUI_API bool          IsWindowFocused( ImGuiFocusedFlags flags = 0 ); // is current window focused? or its root/child, depending on flags. see flags for options.
IMGUI_API bool          IsWindowHovered( ImGuiHoveredFlags flags = 0 ); // is current window hovered (and typically: not blocked by a popup/modal)? see flags for options. NB: If you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that! Please read the FAQ!
IMGUI_API ImDrawList* GetWindowDrawList();                        // get draw list associated to the current window, to append your own drawing primitives
IMGUI_API ImVec2        GetWindowPos();                             // get current window position in screen space (useful if you want to do your own drawing via the DrawList API)
IMGUI_API ImVec2        GetWindowSize();                            // get current window size
IMGUI_API float         GetWindowWidth();                           // get current window width (shortcut for GetWindowSize().x)
IMGUI_API float         GetWindowHeight();                          // get current window height (shortcut for GetWindowSize().y)

// Prefer using SetNextXXX functions (before Begin) rather that SetXXX functions (after Begin).
IMGUI_API void          SetNextWindowPos( const ImVec2& pos, ImGuiCond cond = 0, const ImVec2& pivot = ImVec2( 0, 0 ) ); // set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.
IMGUI_API void          SetNextWindowSize( const ImVec2& size, ImGuiCond cond = 0 );                  // set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()
IMGUI_API void          SetNextWindowSizeConstraints( const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback = NULL, void* custom_callback_data = NULL ); // set next window size limits. use -1,-1 on either X/Y axis to preserve the current size. Sizes will be rounded down. Use callback to apply non-trivial programmatic constraints.
IMGUI_API void          SetNextWindowContentSize( const ImVec2& size );                               // set next window content size (~ scrollable client area, which enforce the range of scrollbars). Not including window decorations (title bar, menu bar, etc.) nor WindowPadding. set an axis to 0.0f to leave it automatic. call before Begin()
IMGUI_API void          SetNextWindowCollapsed( bool collapsed, ImGuiCond cond = 0 );                 // set next window collapsed state. call before Begin()
IMGUI_API void          SetNextWindowFocus();                                                       // set next window to be focused / top-most. call before Begin()
IMGUI_API void          SetNextWindowBgAlpha( float alpha );                                          // set next window background color alpha. helper to easily override the Alpha component of ImGuiCol_WindowBg/ChildBg/PopupBg. you may also use ImGuiWindowFlags_NoBackground.
IMGUI_API void          SetWindowPos( const ImVec2& pos, ImGuiCond cond = 0 );                        // (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.
IMGUI_API void          SetWindowSize( const ImVec2& size, ImGuiCond cond = 0 );                      // (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0,0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.
IMGUI_API void          SetWindowCollapsed( bool collapsed, ImGuiCond cond = 0 );                     // (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().
IMGUI_API void          SetWindowFocus();                                                           // (not recommended) set current window to be focused / top-most. prefer using SetNextWindowFocus().
IMGUI_API void          SetWindowFontScale( float scale );                                            // set font scale. Adjust IO.FontGlobalScale if you want to scale all windows. This is an old API! For correct scaling, prefer to reload font + rebuild ImFontAtlas + call style.ScaleAllSizes().
IMGUI_API void          SetWindowPos( const char* name, const ImVec2& pos, ImGuiCond cond = 0 );      // set named window position.
IMGUI_API void          SetWindowSize( const char* name, const ImVec2& size, ImGuiCond cond = 0 );    // set named window size. set axis to 0.0f to force an auto-fit on this axis.
IMGUI_API void          SetWindowCollapsed( const char* name, bool collapsed, ImGuiCond cond = 0 );   // set named window collapsed state
IMGUI_API void          SetWindowFocus( const char* name );                                           // set named window to be focused / top-most. use NULL to remove focus.

// Content region
// - Those functions are bound to be redesigned soon (they are confusing, incomplete and return values in local window coordinates which increases confusion)
IMGUI_API ImVec2        GetContentRegionMax();                                          // current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates
IMGUI_API ImVec2        GetContentRegionAvail();                                        // == GetContentRegionMax() - GetCursorPos()
IMGUI_API ImVec2        GetWindowContentRegionMin();                                    // content boundaries min (roughly (0,0)-Scroll), in window coordinates
IMGUI_API ImVec2        GetWindowContentRegionMax();                                    // content boundaries max (roughly (0,0)+Size-Scroll) where Size can be override with SetNextWindowContentSize(), in window coordinates
IMGUI_API float         GetWindowContentRegionWidth();                                  //

// Windows Scrolling
IMGUI_API float         GetScrollX();                                                   // get scrolling amount [0..GetScrollMaxX()]
IMGUI_API float         GetScrollY();                                                   // get scrolling amount [0..GetScrollMaxY()]
IMGUI_API float         GetScrollMaxX();                                                // get maximum scrolling amount ~~ ContentSize.X - WindowSize.X
IMGUI_API float         GetScrollMaxY();                                                // get maximum scrolling amount ~~ ContentSize.Y - WindowSize.Y
IMGUI_API void          SetScrollX( float scroll_x );                                     // set scrolling amount [0..GetScrollMaxX()]
IMGUI_API void          SetScrollY( float scroll_y );                                     // set scrolling amount [0..GetScrollMaxY()]
IMGUI_API void          SetScrollHereX( float center_x_ratio = 0.5f );                    // adjust scrolling amount to make current cursor position visible. center_x_ratio=0.0: left, 0.5: center, 1.0: right. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
IMGUI_API void          SetScrollHereY( float center_y_ratio = 0.5f );                    // adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
IMGUI_API void          SetScrollFromPosX( float local_x, float center_x_ratio = 0.5f );  // adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.
IMGUI_API void          SetScrollFromPosY( float local_y, float center_y_ratio = 0.5f );  // adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.

// Parameters stacks (shared)
IMGUI_API void          PushFont( ImFont* font );                                         // use NULL as a shortcut to push default font
IMGUI_API void          PopFont();
IMGUI_API void          PushStyleColor( ImGuiCol idx, ImU32 col );
IMGUI_API void          PushStyleColor( ImGuiCol idx, const ImVec4& col );
IMGUI_API void          PopStyleColor( int count = 1 );
IMGUI_API void          PushStyleVar( ImGuiStyleVar idx, float val );
IMGUI_API void          PushStyleVar( ImGuiStyleVar idx, const ImVec2& val );
IMGUI_API void          PopStyleVar( int count = 1 );
IMGUI_API const ImVec4& GetStyleColorVec4( ImGuiCol idx );                                // retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(), otherwise use GetColorU32() to get style color with style alpha baked in.
IMGUI_API ImFont* GetFont();                                                      // get current font
IMGUI_API float         GetFontSize();                                                  // get current font size (= height in pixels) of current font with current scale applied
IMGUI_API ImVec2        GetFontTexUvWhitePixel();                                       // get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API
IMGUI_API ImU32         GetColorU32( ImGuiCol idx, float alpha_mul = 1.0f );              // retrieve given style color with style alpha applied and optional extra alpha multiplier
IMGUI_API ImU32         GetColorU32( const ImVec4& col );                                 // retrieve given color with style alpha applied
IMGUI_API ImU32         GetColorU32( ImU32 col );                                         // retrieve given color with style alpha applied

// Parameters stacks (current window)
IMGUI_API void          PushItemWidth( float item_width );                                // push width of items for common large "item+label" widgets. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side). 0.0f = default to ~2/3 of windows width,
IMGUI_API void          PopItemWidth();
IMGUI_API void          SetNextItemWidth( float item_width );                             // set width of the _next_ common large "item+label" widget. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side)
IMGUI_API float         CalcItemWidth();                                                // width of item given pushed settings and current cursor position. NOT necessarily the width of last item unlike most 'Item' functions.
IMGUI_API void          PushTextWrapPos( float wrap_local_pos_x = 0.0f );                 // push word-wrapping position for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space
IMGUI_API void          PopTextWrapPos();
IMGUI_API void          PushAllowKeyboardFocus( bool allow_keyboard_focus );              // allow focusing using TAB/Shift-TAB, enabled by default but you can disable it for certain widgets
IMGUI_API void          PopAllowKeyboardFocus();
IMGUI_API void          PushButtonRepeat( bool repeat );                                  // in 'repeat' mode, Button*() functions return repeated true in a typematic manner (using io.KeyRepeatDelay/io.KeyRepeatRate setting). Note that you can call IsItemActive() after any Button() to tell if the button is held in the current frame.
IMGUI_API void          PopButtonRepeat();

// Cursor / Layout
// - By "cursor" we mean the current output position.
// - The typical widget behavior is to output themselves at the current cursor position, then move the cursor one line down.
// - You can call SameLine() between widgets to undo the last carriage return and output at the right of the preceding widget.
// - Attention! We currently have inconsistencies between window-local and absolute positions we will aim to fix with future API:
//    Window-local coordinates:   SameLine(), GetCursorPos(), SetCursorPos(), GetCursorStartPos(), GetContentRegionMax(), GetWindowContentRegion*(), PushTextWrapPos()
//    Absolute coordinate:        GetCursorScreenPos(), SetCursorScreenPos(), all ImDrawList:: functions.
IMGUI_API void          Separator();                                                    // separator, generally horizontal. inside a menu bar or in horizontal layout mode, this becomes a vertical separator.
IMGUI_API void          SameLine( float offset_from_start_x = 0.0f, float spacing = -1.0f );  // call between widgets or groups to layout them horizontally. X position given in window coordinates.
IMGUI_API void          NewLine();                                                      // undo a SameLine() or force a new line when in an horizontal-layout context.
IMGUI_API void          Spacing();                                                      // add vertical spacing.
IMGUI_API void          Dummy( const ImVec2& size );                                      // add a dummy item of given size. unlike InvisibleButton(), Dummy() won't take the mouse click or be navigable into.
IMGUI_API void          Indent( float indent_w = 0.0f );                                  // move content position toward the right, by style.IndentSpacing or indent_w if != 0
IMGUI_API void          Unindent( float indent_w = 0.0f );                                // move content position back to the left, by style.IndentSpacing or indent_w if != 0
IMGUI_API void          BeginGroup();                                                   // lock horizontal starting position
IMGUI_API void          EndGroup();                                                     // unlock horizontal starting position + capture the whole group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
IMGUI_API ImVec2        GetCursorPos();                                                 // cursor position in window coordinates (relative to window position)
IMGUI_API float         GetCursorPosX();                                                //   (some functions are using window-relative coordinates, such as: GetCursorPos, GetCursorStartPos, GetContentRegionMax, GetWindowContentRegion* etc.
IMGUI_API float         GetCursorPosY();                                                //    other functions such as GetCursorScreenPos or everything in ImDrawList::
IMGUI_API void          SetCursorPos( const ImVec2& local_pos );                          //    are using the main, absolute coordinate system.
IMGUI_API void          SetCursorPosX( float local_x );                                   //    GetWindowPos() + GetCursorPos() == GetCursorScreenPos() etc.)
IMGUI_API void          SetCursorPosY( float local_y );                                   //
IMGUI_API ImVec2        GetCursorStartPos();                                            // initial cursor position in window coordinates
IMGUI_API ImVec2        GetCursorScreenPos();                                           // cursor position in absolute screen coordinates [0..io.DisplaySize] (useful to work with ImDrawList API)
IMGUI_API void          SetCursorScreenPos( const ImVec2& pos );                          // cursor position in absolute screen coordinates [0..io.DisplaySize]
IMGUI_API void          AlignTextToFramePadding();                                      // vertically align upcoming text baseline to FramePadding.y so that it will align properly to regularly framed items (call if you have text on a line before a framed item)
IMGUI_API float         GetTextLineHeight();                                            // ~ FontSize
IMGUI_API float         GetTextLineHeightWithSpacing();                                 // ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)
IMGUI_API float         GetFrameHeight();                                               // ~ FontSize + style.FramePadding.y * 2
IMGUI_API float         GetFrameHeightWithSpacing();                                    // ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)

// ID stack/scopes
// - Read the FAQ for more details about how ID are handled in dear imgui. If you are creating widgets in a loop you most
//   likely want to push a unique identifier (e.g. object pointer, loop index) to uniquely differentiate them.
// - The resulting ID are hashes of the entire stack.
// - You can also use the "Label##foobar" syntax within widget label to distinguish them from each others.
// - In this header file we use the "label"/"name" terminology to denote a string that will be displayed and used as an ID,
//   whereas "str_id" denote a string that is only used as an ID and not normally displayed.
IMGUI_API void          PushID( const char* str_id );                                     // push string into the ID stack (will hash string).
IMGUI_API void          PushID( const char* str_id_begin, const char* str_id_end );       // push string into the ID stack (will hash string).
IMGUI_API void          PushID( const void* ptr_id );                                     // push pointer into the ID stack (will hash pointer).
IMGUI_API void          PushID( int int_id );                                             // push integer into the ID stack (will hash integer).
IMGUI_API void          PopID();                                                        // pop from the ID stack.
IMGUI_API ImGuiID       GetID( const char* str_id );                                      // calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself
IMGUI_API ImGuiID       GetID( const char* str_id_begin, const char* str_id_end );
IMGUI_API ImGuiID       GetID( const void* ptr_id );

// Widgets: Text
IMGUI_API void          TextUnformatted( const char* text, const char* text_end = NULL ); // raw text without formatting. Roughly equivalent to Text("%s", text) but: A) doesn't require null terminated string if 'text_end' is specified, B) it's faster, no memory copy is done, no buffer size limits, recommended for long chunks of text.
IMGUI_API void          Text( const char* fmt, ... )                                      IM_FMTARGS( 1 ); // formatted text
IMGUI_API void          TextV( const char* fmt, va_list args )                            IM_FMTLIST( 1 );
IMGUI_API void          TextColored( const ImVec4& col, const char* fmt, ... )            IM_FMTARGS( 2 ); // shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor();
IMGUI_API void          TextColoredV( const ImVec4& col, const char* fmt, va_list args )  IM_FMTLIST( 2 );
IMGUI_API void          TextDisabled( const char* fmt, ... )                              IM_FMTARGS( 1 ); // shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor();
IMGUI_API void          TextDisabledV( const char* fmt, va_list args )                    IM_FMTLIST( 1 );
IMGUI_API void          TextWrapped( const char* fmt, ... )                               IM_FMTARGS( 1 ); // shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize().
IMGUI_API void          TextWrappedV( const char* fmt, va_list args )                     IM_FMTLIST( 1 );
IMGUI_API void          LabelText( const char* label, const char* fmt, ... )              IM_FMTARGS( 2 ); // display text+label aligned the same way as value+label widgets
IMGUI_API void          LabelTextV( const char* label, const char* fmt, va_list args )    IM_FMTLIST( 2 );
IMGUI_API void          BulletText( const char* fmt, ... )                                IM_FMTARGS( 1 ); // shortcut for Bullet()+Text()
IMGUI_API void          BulletTextV( const char* fmt, va_list args )                      IM_FMTLIST( 1 );

// Widgets: Main
// - Most widgets return true when the value has been changed or when pressed/selected
// - You may also use one of the many IsItemXXX functions (e.g. IsItemActive, IsItemHovered, etc.) to query widget state.
IMGUI_API bool          Button( const char* label, const ImVec2& size = ImVec2( 0, 0 ) );    // button
IMGUI_API bool          SmallButton( const char* label );                                 // button with FramePadding=(0,0) to easily embed within text
IMGUI_API bool          InvisibleButton( const char* str_id, const ImVec2& size );        // button behavior without the visuals, frequently useful to build custom behaviors using the public api (along with IsItemActive, IsItemHovered, etc.)
IMGUI_API bool          ArrowButton( const char* str_id, ImGuiDir dir );                  // square button with an arrow shape
IMGUI_API void          Image( ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2( 0, 0 ), const ImVec2& uv1 = ImVec2( 1, 1 ), const ImVec4& tint_col = ImVec4( 1, 1, 1, 1 ), const ImVec4& border_col = ImVec4( 0, 0, 0, 0 ) );
IMGUI_API bool          ImageButton( ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2( 0, 0 ), const ImVec2& uv1 = ImVec2( 1, 1 ), int frame_padding = -1, const ImVec4& bg_col = ImVec4( 0, 0, 0, 0 ), const ImVec4& tint_col = ImVec4( 1, 1, 1, 1 ) );    // <0 frame_padding uses default frame padding settings. 0 for no padding
IMGUI_API bool          Checkbox( const char* label, bool* v );
IMGUI_API bool          CheckboxFlags( const char* label, unsigned int* flags, unsigned int flags_value );
IMGUI_API bool          RadioButton( const char* label, bool active );                    // use with e.g. if (RadioButton("one", my_value==1)) { my_value = 1; }
IMGUI_API bool          RadioButton( const char* label, int* v, int v_button );           // shortcut to handle the above pattern when value is an integer
IMGUI_API void          ProgressBar( float fraction, const ImVec2& size_arg = ImVec2( -1, 0 ), const char* overlay = NULL );
IMGUI_API void          Bullet();                                                       // draw a small circle and keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses

// Widgets: Combo Box
// - The BeginCombo()/EndCombo() api allows you to manage your contents and selection state however you want it, by creating e.g. Selectable() items.
// - The old Combo() api are helpers over BeginCombo()/EndCombo() which are kept available for convenience purpose.
IMGUI_API bool          BeginCombo( const char* label, const char* preview_value, ImGuiComboFlags flags = 0 );
IMGUI_API void          EndCombo(); // only call EndCombo() if BeginCombo() returns true!
IMGUI_API bool          Combo( const char* label, int* current_item, const char* const items[], int items_count, int popup_max_height_in_items = -1 );
IMGUI_API bool          Combo( const char* label, int* current_item, const char* items_separated_by_zeros, int popup_max_height_in_items = -1 );      // Separate items with \0 within a string, end item-list with \0\0. e.g. "One\0Two\0Three\0"
IMGUI_API bool          Combo( const char* label, int* current_item, bool( *items_getter )( void* data, int idx, const char** out_text ), void* data, int items_count, int popup_max_height_in_items = -1 );

// Widgets: Drags
// - CTRL+Click on any drag box to turn them into an input box. Manually input values aren't clamped and can go off-bounds.
// - For all the Float2/Float3/Float4/Int2/Int3/Int4 versions of every functions, note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can pass address of your first element out of a contiguous set, e.g. &myvector.x
// - Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. "%.3f" -> 1.234; "%5.2f secs" -> 01.23 secs; "Biscuit: %.0f" -> Biscuit: 1; etc.
// - Speed are per-pixel of mouse movement (v_speed=0.2f: mouse needs to move by 5 pixels to increase value by 1). For gamepad/keyboard navigation, minimum speed is Max(v_speed, minimum_step_at_given_precision).
// - Use v_min < v_max to clamp edits to given limits. Note that CTRL+Click manual input can override those limits.
// - Use v_max = FLT_MAX / INT_MAX etc to avoid clamping to a maximum, same with v_min = -FLT_MAX / INT_MIN to avoid clamping to a minimum.
// - Use v_min > v_max to lock edits.
IMGUI_API bool          DragFloat( const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = SECURE("%.3f"), float power = 1.0f );     // If v_min >= v_max we have no bound
IMGUI_API bool          DragFloat2( const char* label, float v[ 2 ], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = SECURE("%.3f"), float power = 1.0f );
IMGUI_API bool          DragFloat3( const char* label, float v[ 3 ], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = SECURE("%.3f"), float power = 1.0f );
IMGUI_API bool          DragFloat4( const char* label, float v[ 4 ], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = SECURE("%.3f"), float power = 1.0f );
IMGUI_API bool          DragFloatRange2( const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = SECURE("%.3f"), const char* format_max = NULL, float power = 1.0f );
IMGUI_API bool          DragInt( const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = SECURE("%d") );                                       // If v_min >= v_max we have no bound
IMGUI_API bool          DragInt2( const char* label, int v[ 2 ], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = SECURE( "%d" ) );
IMGUI_API bool          DragInt3( const char* label, int v[ 3 ], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = SECURE( "%d" ) );
IMGUI_API bool          DragInt4( const char* label, int v[ 4 ], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = SECURE( "%d" ) );
IMGUI_API bool          DragIntRange2( const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = SECURE("%d"), const char* format_max = NULL );
IMGUI_API bool          DragScalar( const char* label, ImGuiDataType data_type, void* p_data, float v_speed, const void* p_min = NULL, const void* p_max = NULL, const char* format = NULL, float power = 1.0f );
IMGUI_API bool          DragScalarN( const char* label, ImGuiDataType data_type, void* p_data, int components, float v_speed, const void* p_min = NULL, const void* p_max = NULL, const char* format = NULL, float power = 1.0f );

// Widgets: Sliders
// - CTRL+Click on any slider to turn them into an input box. Manually input values aren't clamped and can go off-bounds.
// - Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. "%.3f" -> 1.234; "%5.2f secs" -> 01.23 secs; "Biscuit: %.0f" -> Biscuit: 1; etc.
IMGUI_API bool          SliderFloat( const char* label, float* v, float v_min, float v_max, const char* format = SECURE("%.3f"), float power = 1.0f );     // adjust format to decorate the value with a prefix or a suffix for in-slider labels or unit display. Use power!=1.0 for power curve sliders
IMGUI_API bool          SliderFloat2( const char* label, float v[ 2 ], float v_min, float v_max, const char* format = SECURE( "%.3f"), float power = 1.0f );
IMGUI_API bool          SliderFloat3( const char* label, float v[ 3 ], float v_min, float v_max, const char* format = SECURE( "%.3f"), float power = 1.0f );
IMGUI_API bool          SliderFloat4( const char* label, float v[ 4 ], float v_min, float v_max, const char* format = SECURE( "%.3f"), float power = 1.0f );
IMGUI_API bool          SliderAngle( const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f, const char* format = SECURE("%.0f deg") );
IMGUI_API bool          SliderInt( const char* label, int* v, int v_min, int v_max, const char* format = SECURE("%d") );
IMGUI_API bool          SliderInt2( const char* label, int v[ 2 ], int v_min, int v_max, const char* format = SECURE("%d") );
IMGUI_API bool          SliderInt3( const char* label, int v[ 3 ], int v_min, int v_max, const char* format = SECURE("%d") );
IMGUI_API bool          SliderInt4( const char* label, int v[ 4 ], int v_min, int v_max, const char* format = SECURE("%d") );
IMGUI_API bool          SliderScalar( const char* label, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format = NULL, float power = 1.0f );
IMGUI_API bool          SliderScalarN( const char* label, ImGuiDataType data_type, void* p_data, int components, const void* p_min, const void* p_max, const char* format = NULL, float power = 1.0f );
IMGUI_API bool          VSliderFloat( const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format = SECURE("%.3f"), float power = 1.0f );
IMGUI_API bool          VSliderInt( const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format = SECURE("%d") );
IMGUI_API bool          VSliderScalar( const char* label, const ImVec2& size, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format = NULL, float power = 1.0f );

// Widgets: Input with Keyboard
// - If you want to use InputText() with std::string or any custom dynamic string type, see misc/cpp/imgui_stdlib.h and comments in imgui_demo.cpp.
// - Most of the ImGuiInputTextFlags flags are only useful for InputText() and not for InputFloatX, InputIntX, InputDouble etc.
IMGUI_API bool          InputText( const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL );
IMGUI_API bool          InputTextMultiline( const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2( 0, 0 ), ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL );
IMGUI_API bool          InputTextWithHint( const char* label, const char* hint, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL );
IMGUI_API bool          InputFloat( const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, const char* format = SECURE("%.3f"), ImGuiInputTextFlags flags = 0 );
IMGUI_API bool          InputFloat2( const char* label, float v[ 2 ], const char* format = SECURE( "%.3f" ), ImGuiInputTextFlags flags = 0 );
IMGUI_API bool          InputFloat3( const char* label, float v[ 3 ], const char* format = SECURE( "%.3f" ), ImGuiInputTextFlags flags = 0 );
IMGUI_API bool          InputFloat4( const char* label, float v[ 4 ], const char* format = SECURE( "%.3f" ), ImGuiInputTextFlags flags = 0 );
IMGUI_API bool          InputInt( const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags flags = 0 );
IMGUI_API bool          InputInt2( const char* label, int v[ 2 ], ImGuiInputTextFlags flags = 0 );
IMGUI_API bool          InputInt3( const char* label, int v[ 3 ], ImGuiInputTextFlags flags = 0 );
IMGUI_API bool          InputInt4( const char* label, int v[ 4 ], ImGuiInputTextFlags flags = 0 );
IMGUI_API bool          InputDouble( const char* label, double* v, double step = 0.0, double step_fast = 0.0, const char* format = SECURE("%.6f"), ImGuiInputTextFlags flags = 0 );
IMGUI_API bool          InputScalar( const char* label, ImGuiDataType data_type, void* p_data, const void* p_step = NULL, const void* p_step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags flags = 0 );
IMGUI_API bool          InputScalarN( const char* label, ImGuiDataType data_type, void* p_data, int components, const void* p_step = NULL, const void* p_step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags flags = 0 );

// Widgets: Color Editor/Picker (tip: the ColorEdit* functions have a little colored preview square that can be left-clicked to open a picker, and right-clicked to open an option menu.)
// - Note that in C++ a 'float v[X]' function argument is the _same_ as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible.
// - You can pass the address of a first float element out of a contiguous structure, e.g. &myvector.x
IMGUI_API bool          ColorEdit3( const char* label, float col[ 3 ], ImGuiColorEditFlags flags = 0 );
IMGUI_API bool          ColorEdit4( const char* label, float col[ 4 ], ImGuiColorEditFlags flags = 0 );
IMGUI_API bool          ColorPicker3( const char* label, float col[ 3 ], ImGuiColorEditFlags flags = 0 );
IMGUI_API bool          ColorPicker4( const char* label, float col[ 4 ], ImGuiColorEditFlags flags = 0, const float* ref_col = NULL );
IMGUI_API bool          ColorButton( const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2( 0, 0 ) );  // display a colored square/button, hover for details, return true when pressed.
IMGUI_API void          SetColorEditOptions( ImGuiColorEditFlags flags );                     // initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls.

// Widgets: Trees
// - TreeNode functions return true when the node is open, in which case you need to also call TreePop() when you are finished displaying the tree node contents.
IMGUI_API bool          TreeNode( const char* label );
IMGUI_API bool          TreeNode( const char* str_id, const char* fmt, ... ) IM_FMTARGS( 2 );   // helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().
IMGUI_API bool          TreeNode( const void* ptr_id, const char* fmt, ... ) IM_FMTARGS( 2 );   // "
IMGUI_API bool          TreeNodeV( const char* str_id, const char* fmt, va_list args ) IM_FMTLIST( 2 );
IMGUI_API bool          TreeNodeV( const void* ptr_id, const char* fmt, va_list args ) IM_FMTLIST( 2 );
IMGUI_API bool          TreeNodeEx( const char* label, ImGuiTreeNodeFlags flags = 0 );
IMGUI_API bool          TreeNodeEx( const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ... ) IM_FMTARGS( 3 );
IMGUI_API bool          TreeNodeEx( const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ... ) IM_FMTARGS( 3 );
IMGUI_API bool          TreeNodeExV( const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args ) IM_FMTLIST( 3 );
IMGUI_API bool          TreeNodeExV( const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args ) IM_FMTLIST( 3 );
IMGUI_API void          TreePush( const char* str_id );                                       // ~ Indent()+PushId(). Already called by TreeNode() when returning true, but you can call TreePush/TreePop yourself if desired.
IMGUI_API void          TreePush( const void* ptr_id = NULL );                                // "
IMGUI_API void          TreePop();                                                          // ~ Unindent()+PopId()
IMGUI_API float         GetTreeNodeToLabelSpacing();                                        // horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode
IMGUI_API bool          CollapsingHeader( const char* label, ImGuiTreeNodeFlags flags = 0 );  // if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().
IMGUI_API bool          CollapsingHeader( const char* label, bool* p_open, ImGuiTreeNodeFlags flags = 0 ); // when 'p_open' isn't NULL, display an additional small close button on upper right of the header
IMGUI_API void          SetNextItemOpen( bool is_open, ImGuiCond cond = 0 );                  // set next TreeNode/CollapsingHeader open state.

// Widgets: Selectables
// - A selectable highlights when hovered, and can display another color when selected.
// - Neighbors selectable extend their highlight bounds in order to leave no gap between them. This is so a series of selected Selectable appear contiguous.
IMGUI_API bool          Selectable( const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2( 0, 0 ) );  // "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height
IMGUI_API bool          Selectable( const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2( 0, 0 ) );       // "bool* p_selected" point to the selection state (read-write), as a convenient helper.

// Widgets: List Boxes
// - FIXME: To be consistent with all the newer API, ListBoxHeader/ListBoxFooter should in reality be called BeginListBox/EndListBox. Will rename them.
IMGUI_API bool          ListBox( const char* label, int* current_item, const char* const items[], int items_count, int height_in_items = -1 );
IMGUI_API bool          ListBox( const char* label, int* current_item, bool ( *items_getter )( void* data, int idx, const char** out_text ), void* data, int items_count, int height_in_items = -1 );
IMGUI_API bool          ListBoxHeader( const char* label, const ImVec2& size = ImVec2( 0, 0 ) ); // use if you want to reimplement ListBox() will custom data or interactions. if the function return true, you can output elements then call ListBoxFooter() afterwards.
IMGUI_API bool          ListBoxHeader( const char* label, int items_count, int height_in_items = -1 ); // "
IMGUI_API void          ListBoxFooter();                                                    // terminate the scrolling region. only call ListBoxFooter() if ListBoxHeader() returned true!

// Widgets: Data Plotting
IMGUI_API void          PlotLines( const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2( 0, 0 ), int stride = sizeof( float ) );
IMGUI_API void          PlotLines( const char* label, float( *values_getter )( void* data, int idx ), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2( 0, 0 ) );
IMGUI_API void          PlotHistogram( const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2( 0, 0 ), int stride = sizeof( float ) );
IMGUI_API void          PlotHistogram( const char* label, float( *values_getter )( void* data, int idx ), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2( 0, 0 ) );

// Widgets: Value() Helpers.
// - Those are merely shortcut to calling Text() with a format string. Output single value in "name: value" format (tip: freely declare more in your code to handle your types. you can add functions to the ImGui namespace)
IMGUI_API void          Value( const char* prefix, bool b );
IMGUI_API void          Value( const char* prefix, int v );
IMGUI_API void          Value( const char* prefix, unsigned int v );
IMGUI_API void          Value( const char* prefix, float v, const char* float_format = NULL );

// Widgets: Menus
// - Use BeginMenuBar() on a window ImGuiWindowFlags_MenuBar to append to its menu bar.
// - Use BeginMainMenuBar() to create a menu bar at the top of the screen and append to it.
// - Use BeginMenu() to create a menu. You can call BeginMenu() multiple time with the same identifier to append more items to it.
IMGUI_API bool          BeginMenuBar();                                                     // append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set on parent window).
IMGUI_API void          EndMenuBar();                                                       // only call EndMenuBar() if BeginMenuBar() returns true!
IMGUI_API bool          BeginMainMenuBar();                                                 // create and append to a full screen menu-bar.
IMGUI_API void          EndMainMenuBar();                                                   // only call EndMainMenuBar() if BeginMainMenuBar() returns true!
IMGUI_API bool          BeginMenu( const char* label, bool enabled = true );                  // create a sub-menu entry. only call EndMenu() if this returns true!
IMGUI_API void          EndMenu();                                                          // only call EndMenu() if BeginMenu() returns true!
IMGUI_API bool          MenuItem( const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true );  // return true when activated. shortcuts are displayed for convenience but not processed by ImGui at the moment
IMGUI_API bool          MenuItem( const char* label, const char* shortcut, bool* p_selected, bool enabled = true );              // return true when activated + toggle (*p_selected) if p_selected != NULL

// Tooltips
// - Tooltip are windows following the mouse which do not take focus away.
IMGUI_API void          BeginTooltip();                                                     // begin/append a tooltip window. to create full-featured tooltip (with any kind of items).
IMGUI_API void          EndTooltip();
IMGUI_API void          SetTooltip( const char* fmt, ... ) IM_FMTARGS( 1 );                     // set a text-only tooltip, typically use with ImGui::IsItemHovered(). override any previous call to SetTooltip().
IMGUI_API void          SetTooltipV( const char* fmt, va_list args ) IM_FMTLIST( 1 );

// Popups, Modals
// The properties of popups windows are:
// - They block normal mouse hovering detection outside them. (*1)
// - Unless modal, they can be closed by clicking anywhere outside them, or by pressing ESCAPE.
//   Because hovering detection is disabled outside the popup, when clicking outside the click will not be seen by underlying widgets! (*1)
// - Their visibility state (~bool) is held internally by Dear ImGui instead of being held by the programmer as we are used to with regular Begin() calls.
//   User can manipulate the visibility state by calling OpenPopup(), CloseCurrentPopup() etc.
// - We default to use the right mouse (ImGuiMouseButton_Right=1) for the Popup Context functions.
// Those three properties are connected: we need to retain popup visibility state in the library because popups may be closed as any time.
// (*1) You can bypass that restriction and detect hovering even when normally blocked by a popup.
//      To do this use the ImGuiHoveredFlags_AllowWhenBlockedByPopup when calling IsItemHovered() or IsWindowHovered().
//      This is what BeginPopupContextItem() and BeginPopupContextWindow() are doing already, allowing a right-click to reopen another popups without losing the click.
IMGUI_API void          OpenPopup( const char* str_id );                                      // call to mark popup as open (don't call every frame!). popups are closed when user click outside, or if CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block. By default, Selectable()/MenuItem() are calling CloseCurrentPopup(). Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
IMGUI_API bool          BeginPopup( const char* str_id, ImGuiWindowFlags flags = 0 );                                             // return true if the popup is open, and you can start outputting to it. only call EndPopup() if BeginPopup() returns true!
IMGUI_API bool          BeginPopupContextItem( const char* str_id = NULL, ImGuiMouseButton mouse_button = 1 );                    // helper to open and begin popup when clicked on last item. if you can pass a NULL str_id only if the previous item had an id. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp!
IMGUI_API bool          BeginPopupContextWindow( const char* str_id = NULL, ImGuiMouseButton mouse_button = 1, bool also_over_items = true );  // helper to open and begin popup when clicked on current window.
IMGUI_API bool          BeginPopupContextVoid( const char* str_id = NULL, ImGuiMouseButton mouse_button = 1 );                    // helper to open and begin popup when clicked in void (where there are no imgui windows).
IMGUI_API bool          BeginPopupModal( const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0 );                     // modal dialog (regular window with title bar, block interactions behind the modal window, can't close the modal window by clicking outside)
IMGUI_API void          EndPopup();                                                                                             // only call EndPopup() if BeginPopupXXX() returns true!
IMGUI_API bool          OpenPopupOnItemClick( const char* str_id = NULL, ImGuiMouseButton mouse_button = 1 );                     // helper to open popup when clicked on last item (note: actually triggers on the mouse _released_ event to be consistent with popup behaviors). return true when just opened.
IMGUI_API bool          IsPopupOpen( const char* str_id );                                    // return true if the popup is open at the current begin-ed level of the popup stack.
IMGUI_API void          CloseCurrentPopup();                                                // close the popup we have begin-ed into. clicking on a MenuItem or Selectable automatically close the current popup.

// Columns
// - You can also use SameLine(pos_x) to mimic simplified columns.
// - The columns API is work-in-progress and rather lacking (columns are arguably the worst part of dear imgui at the moment!)
// - There is a maximum of 64 columns.
// - Currently working on new 'Tables' api which will replace columns around Q2 2020 (see GitHub #2957).
IMGUI_API void          Columns( int count = 1, const char* id = NULL, bool border = true );
IMGUI_API void          NextColumn();                                                       // next column, defaults to current row or next row if the current row is finished
IMGUI_API int           GetColumnIndex();                                                   // get current column index
IMGUI_API float         GetColumnWidth( int column_index = -1 );                              // get column width (in pixels). pass -1 to use current column
IMGUI_API void          SetColumnWidth( int column_index, float width );                      // set column width (in pixels). pass -1 to use current column
IMGUI_API float         GetColumnOffset( int column_index = -1 );                             // get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f
IMGUI_API void          SetColumnOffset( int column_index, float offset_x );                  // set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column
IMGUI_API int           GetColumnsCount();

// Tab Bars, Tabs
IMGUI_API bool          BeginTabBar( const char* str_id, ImGuiTabBarFlags flags = 0 );        // create and append into a TabBar
IMGUI_API void          EndTabBar();                                                        // only call EndTabBar() if BeginTabBar() returns true!
IMGUI_API bool          BeginTabItem( const char* label, bool* p_open = NULL, ImGuiTabItemFlags flags = 0 );// create a Tab. Returns true if the Tab is selected.
IMGUI_API void          EndTabItem();                                                       // only call EndTabItem() if BeginTabItem() returns true!
IMGUI_API void          SetTabItemClosed( const char* tab_or_docked_window_label );           // notify TabBar or Docking system of a closed tab/window ahead (useful to reduce visual flicker on reorderable tab bars). For tab-bar: call after BeginTabBar() and before Tab submissions. Otherwise call with a window name.

// Logging/Capture
// - All text output from the interface can be captured into tty/file/clipboard. By default, tree nodes are automatically opened during logging.
IMGUI_API void          LogToTTY( int auto_open_depth = -1 );                                 // start logging to tty (stdout)
IMGUI_API void          LogToFile( int auto_open_depth = -1, const char* filename = NULL );   // start logging to file
IMGUI_API void          LogToClipboard( int auto_open_depth = -1 );                           // start logging to OS clipboard
IMGUI_API void          LogFinish();                                                        // stop logging (close file, etc.)
IMGUI_API void          LogButtons();                                                       // helper to display buttons for logging to tty/file/clipboard
IMGUI_API void          LogText( const char* fmt, ... ) IM_FMTARGS( 1 );                        // pass text data straight to log (without being displayed)

// Drag and Drop
// - [BETA API] API may evolve!
// - If you stop calling BeginDragDropSource() the payload is preserved however it won't have a preview tooltip (we currently display a fallback "..." tooltip as replacement)
IMGUI_API bool          BeginDragDropSource( ImGuiDragDropFlags flags = 0 );                                      // call when the current item is active. If this return true, you can call SetDragDropPayload() + EndDragDropSource()
IMGUI_API bool          SetDragDropPayload( const char* type, const void* data, size_t sz, ImGuiCond cond = 0 );  // type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui.
IMGUI_API void          EndDragDropSource();                                                                    // only call EndDragDropSource() if BeginDragDropSource() returns true!
IMGUI_API bool                  BeginDragDropTarget();                                                          // call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()
IMGUI_API const ImGuiPayload* AcceptDragDropPayload( const char* type, ImGuiDragDropFlags flags = 0 );          // accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.
IMGUI_API void                  EndDragDropTarget();                                                            // only call EndDragDropTarget() if BeginDragDropTarget() returns true!
IMGUI_API const ImGuiPayload* GetDragDropPayload();                                                           // peek directly into the current payload from anywhere. may return NULL. use ImGuiPayload::IsDataType() to test for the payload type.

// Clipping
IMGUI_API void          PushClipRect( const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect );
IMGUI_API void          PopClipRect();

// Focus, Activation
// - Prefer using "SetItemDefaultFocus()" over "if (IsWindowAppearing()) SetScrollHereY()" when applicable to signify "this is the default item"
IMGUI_API void          SetItemDefaultFocus();                                              // make last item the default focused item of a window.
IMGUI_API void          SetKeyboardFocusHere( int offset = 0 );                               // focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.

// Item/Widgets Utilities
// - Most of the functions are referring to the last/previous item we submitted.
// - See Demo Window under "Widgets->Querying Status" for an interactive visualization of most of those functions.
IMGUI_API bool          IsItemHovered( ImGuiHoveredFlags flags = 0 );                         // is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.
IMGUI_API bool          IsItemActive();                                                     // is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false)
IMGUI_API bool          IsItemFocused();                                                    // is the last item focused for keyboard/gamepad navigation?
IMGUI_API bool          IsItemClicked( ImGuiMouseButton mouse_button = 0 );                   // is the last item clicked? (e.g. button/node just clicked on) == IsMouseClicked(mouse_button) && IsItemHovered()
IMGUI_API bool          IsItemVisible();                                                    // is the last item visible? (items may be out of sight because of clipping/scrolling)
IMGUI_API bool          IsItemEdited();                                                     // did the last item modify its underlying value this frame? or was pressed? This is generally the same as the "bool" return value of many widgets.
IMGUI_API bool          IsItemActivated();                                                  // was the last item just made active (item was previously inactive).
IMGUI_API bool          IsItemDeactivated();                                                // was the last item just made inactive (item was previously active). Useful for Undo/Redo patterns with widgets that requires continuous editing.
IMGUI_API bool          IsItemDeactivatedAfterEdit();                                       // was the last item just made inactive and made a value change when it was active? (e.g. Slider/Drag moved). Useful for Undo/Redo patterns with widgets that requires continuous editing. Note that you may get false positives (some widgets such as Combo()/ListBox()/Selectable() will return true even when clicking an already selected item).
IMGUI_API bool          IsItemToggledOpen();                                                // was the last item open state toggled? set by TreeNode().
IMGUI_API bool          IsAnyItemHovered();                                                 // is any item hovered?
IMGUI_API bool          IsAnyItemActive();                                                  // is any item active?
IMGUI_API bool          IsAnyItemFocused();                                                 // is any item focused?
IMGUI_API ImVec2        GetItemRectMin();                                                   // get upper-left bounding rectangle of the last item (screen space)
IMGUI_API ImVec2        GetItemRectMax();                                                   // get lower-right bounding rectangle of the last item (screen space)
IMGUI_API ImVec2        GetItemRectSize();                                                  // get size of last item
IMGUI_API void          SetItemAllowOverlap();                                              // allow last item to be overlapped by a subsequent item. sometimes useful with invisible buttons, selectables, etc. to catch unused area.

// Miscellaneous Utilities
IMGUI_API bool          IsRectVisible( const ImVec2& size );                                  // test if rectangle (of given size, starting from cursor position) is visible / not clipped.
IMGUI_API bool          IsRectVisible( const ImVec2& rect_min, const ImVec2& rect_max );      // test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.
IMGUI_API double        GetTime();                                                          // get global imgui time. incremented by io.DeltaTime every frame.
IMGUI_API int           GetFrameCount();                                                    // get global imgui frame count. incremented by 1 every frame.
IMGUI_API ImDrawList* GetBackgroundDrawList();                                            // this draw list will be the first rendering one. Useful to quickly draw shapes/text behind dear imgui contents.
IMGUI_API ImDrawList* GetForegroundDrawList();                                            // this draw list will be the last rendered one. Useful to quickly draw shapes/text over dear imgui contents.
IMGUI_API ImDrawListSharedData* GetDrawListSharedData();                                    // you may use this when creating your own ImDrawList instances.
IMGUI_API const char* GetStyleColorName( ImGuiCol idx );                                    // get a string corresponding to the enum value (for display, saving, etc.).
IMGUI_API void          SetStateStorage( ImGuiStorage* storage );                             // replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)
IMGUI_API ImGuiStorage* GetStateStorage();
IMGUI_API void          CalcListClipping( int items_count, float items_height, int* out_items_display_start, int* out_items_display_end );    // calculate coarse clipping for large list of evenly sized items. Prefer using the ImGuiListClipper higher-level helper if you can.
IMGUI_API bool          BeginChildFrame( ImGuiID id, const ImVec2& size, ImGuiWindowFlags flags = 0 ); // helper to create a child window / scrolling region that looks like a normal widget frame
IMGUI_API void          EndChildFrame();                                                    // always call EndChildFrame() regardless of BeginChildFrame() return values (which indicates a collapsed/clipped window)

// Text Utilities
IMGUI_API ImVec2        CalcTextSize( const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f );

// Color Utilities
IMGUI_API ImVec4        ColorConvertU32ToFloat4( ImU32 in );
IMGUI_API ImU32         ColorConvertFloat4ToU32( const ImVec4& in );
IMGUI_API void          ColorConvertRGBtoHSV( float r, float g, float b, float& out_h, float& out_s, float& out_v );
IMGUI_API void          ColorConvertHSVtoRGB( float h, float s, float v, float& out_r, float& out_g, float& out_b );

// Inputs Utilities: Keyboard
// - For 'int user_key_index' you can use your own indices/enums according to how your backend/engine stored them in io.KeysDown[].
// - We don't know the meaning of those value. You can use GetKeyIndex() to map a ImGuiKey_ value into the user index.
IMGUI_API int           GetKeyIndex( ImGuiKey imgui_key );                                    // map ImGuiKey_* values into user's key index. == io.KeyMap[key]
IMGUI_API bool          IsKeyDown( int user_key_index );                                      // is key being held. == io.KeysDown[user_key_index].
IMGUI_API bool          IsKeyPressed( int user_key_index, bool repeat = true );               // was key pressed (went from !Down to Down)? if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate
IMGUI_API bool          IsKeyReleased( int user_key_index );                                  // was key released (went from Down to !Down)?
IMGUI_API int           GetKeyPressedAmount( int key_index, float repeat_delay, float rate ); // uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate
IMGUI_API void          CaptureKeyboardFromApp( bool want_capture_keyboard_value = true );    // attention: misleading name! manually override io.WantCaptureKeyboard flag next frame (said flag is entirely left for your application to handle). e.g. force capture keyboard when your widget is being hovered. This is equivalent to setting "io.WantCaptureKeyboard = want_capture_keyboard_value"; after the next NewFrame() call.

// Inputs Utilities: Mouse
// - To refer to a mouse button, you may use named enums in your code e.g. ImGuiMouseButton_Left, ImGuiMouseButton_Right.
// - You can also use regular integer: it is forever guaranteed that 0=Left, 1=Right, 2=Middle.
// - Dragging operations are only reported after mouse has moved a certain distance away from the initial clicking position (see 'lock_threshold' and 'io.MouseDraggingThreshold')
IMGUI_API bool          IsMouseDown( ImGuiMouseButton button );                               // is mouse button held?
IMGUI_API bool          IsMouseClicked( ImGuiMouseButton button, bool repeat = false );       // did mouse button clicked? (went from !Down to Down)
IMGUI_API bool          IsMouseReleased( ImGuiMouseButton button );                           // did mouse button released? (went from Down to !Down)
IMGUI_API bool          IsMouseDoubleClicked( ImGuiMouseButton button );                      // did mouse button double-clicked? a double-click returns false in IsMouseClicked(). uses io.MouseDoubleClickTime.
IMGUI_API bool          IsMouseHoveringRect( const ImVec2& r_min, const ImVec2& r_max, bool clip = true );// is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focus/window ordering/popup-block.
IMGUI_API bool          IsMousePosValid( const ImVec2* mouse_pos = NULL );                    // by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse available
IMGUI_API bool          IsAnyMouseDown();                                                   // is any mouse button held?
IMGUI_API ImVec2        GetMousePos();                                                      // shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls
IMGUI_API ImVec2        GetMousePosOnOpeningCurrentPopup();                                 // retrieve mouse position at the time of opening popup we have BeginPopup() into (helper to avoid user backing that value themselves)
IMGUI_API bool          IsMouseDragging( ImGuiMouseButton button, float lock_threshold = -1.0f );         // is mouse dragging? (if lock_threshold < -1.0f, uses io.MouseDraggingThreshold)
IMGUI_API ImVec2        GetMouseDragDelta( ImGuiMouseButton button = 0, float lock_threshold = -1.0f );   // return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (if lock_threshold < -1.0f, uses io.MouseDraggingThreshold)
IMGUI_API void          ResetMouseDragDelta( ImGuiMouseButton button = 0 );                   //
IMGUI_API ImGuiMouseCursor GetMouseCursor();                                                // get desired cursor type, reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you
IMGUI_API void          SetMouseCursor( ImGuiMouseCursor cursor_type );                       // set desired cursor type
IMGUI_API void          CaptureMouseFromApp( bool want_capture_mouse_value = true );          // attention: misleading name! manually override io.WantCaptureMouse flag next frame (said flag is entirely left for your application to handle). This is equivalent to setting "io.WantCaptureMouse = want_capture_mouse_value;" after the next NewFrame() call.

// Clipboard Utilities
// - Also see the LogToClipboard() function to capture GUI into clipboard, or easily output text data to the clipboard.
IMGUI_API const char* GetClipboardText();
IMGUI_API void          SetClipboardText( const char* text );

// Settings/.Ini Utilities
// - The disk functions are automatically called if io.IniFilename != NULL (default is "imgui.ini").
// - Set io.IniFilename to NULL to load/save manually. Read io.WantSaveIniSettings description about handling .ini saving manually.
IMGUI_API void          LoadIniSettingsFromDisk( const char* ini_filename );                  // call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).
IMGUI_API void          LoadIniSettingsFromMemory( const char* ini_data, size_t ini_size = 0 ); // call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.
IMGUI_API void          SaveIniSettingsToDisk( const char* ini_filename );                    // this is automatically called (if io.IniFilename is not empty) a few seconds after any modification that should be reflected in the .ini file (and also by DestroyContext).
IMGUI_API const char* SaveIniSettingsToMemory( size_t* out_ini_size = NULL );               // return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.

// Debug Utilities
IMGUI_API bool          DebugCheckVersionAndDataLayout( const char* version_str, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_drawvert, size_t sz_drawidx ); // This is called by IMGUI_CHECKVERSION() macro.

// Memory Allocators
// - All those functions are not reliant on the current context.
// - If you reload the contents of imgui.cpp at runtime, you may need to call SetCurrentContext() + SetAllocatorFunctions() again because we use global storage for those.
IMGUI_API void          SetAllocatorFunctions( void* ( *alloc_func )( size_t sz, void* user_data ), void ( *free_func )( void* ptr, void* user_data ), void* user_data = NULL );
IMGUI_API void* MemAlloc( size_t size );
IMGUI_API void          MemFree( void* ptr );

} // namespace ImGui

//-----------------------------------------------------------------------------
// Flags & Enumerations
//-----------------------------------------------------------------------------

// Flags for ImGui::Begin()
enum ImGuiWindowFlags_
{
	ImGuiWindowFlags_None = 0,
	ImGuiWindowFlags_NoTitleBar = 1 << 0,   // Disable title-bar
	ImGuiWindowFlags_NoResize = 1 << 1,   // Disable user resizing with the lower-right grip
	ImGuiWindowFlags_NoMove = 1 << 2,   // Disable user moving the window
	ImGuiWindowFlags_NoScrollbar = 1 << 3,   // Disable scrollbars (window can still scroll with mouse or programmatically)
	ImGuiWindowFlags_NoScrollWithMouse = 1 << 4,   // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.
	ImGuiWindowFlags_NoCollapse = 1 << 5,   // Disable user collapsing window by double-clicking on it
	ImGuiWindowFlags_AlwaysAutoResize = 1 << 6,   // Resize every window to its content every frame
	ImGuiWindowFlags_NoBackground = 1 << 7,   // Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).
	ImGuiWindowFlags_NoSavedSettings = 1 << 8,   // Never load/save settings in .ini file
	ImGuiWindowFlags_NoMouseInputs = 1 << 9,   // Disable catching mouse, hovering test with pass through.
	ImGuiWindowFlags_MenuBar = 1 << 10,  // Has a menu-bar
	ImGuiWindowFlags_HorizontalScrollbar = 1 << 11,  // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.
	ImGuiWindowFlags_NoFocusOnAppearing = 1 << 12,  // Disable taking focus when transitioning from hidden to visible state
	ImGuiWindowFlags_NoBringToFrontOnFocus = 1 << 13,  // Disable bringing window to front when taking focus (e.g. clicking on it or programmatically giving it focus)
	ImGuiWindowFlags_AlwaysVerticalScrollbar = 1 << 14,  // Always show vertical scrollbar (even if ContentSize.y < Size.y)
	ImGuiWindowFlags_AlwaysHorizontalScrollbar = 1 << 15,  // Always show horizontal scrollbar (even if ContentSize.x < Size.x)
	ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 16,  // Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)
	ImGuiWindowFlags_NoNavInputs = 1 << 18,  // No gamepad/keyboard navigation within the window
	ImGuiWindowFlags_NoNavFocus = 1 << 19,  // No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB)
	ImGuiWindowFlags_UnsavedDocument = 1 << 20,  // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. When used in a tab/docking context, tab is selected on closure and closure is deferred by one frame to allow code to cancel the closure (with a confirmation popup, etc.) without flicker.
	ImGuiWindowFlags_NoNav = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,
	ImGuiWindowFlags_NoDecoration = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,
	ImGuiWindowFlags_NoInputs = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,

	// [Internal]
	ImGuiWindowFlags_NavFlattened = 1 << 23,  // [BETA] Allow gamepad/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!)
	ImGuiWindowFlags_ChildWindow = 1 << 24,  // Don't use! For internal use by BeginChild()
	ImGuiWindowFlags_Tooltip = 1 << 25,  // Don't use! For internal use by BeginTooltip()
	ImGuiWindowFlags_Popup = 1 << 26,  // Don't use! For internal use by BeginPopup()
	ImGuiWindowFlags_Modal = 1 << 27,  // Don't use! For internal use by BeginPopupModal()
	ImGuiWindowFlags_ChildMenu = 1 << 28   // Don't use! For internal use by BeginMenu()

	// [Obsolete]
	//ImGuiWindowFlags_ShowBorders          = 1 << 7,   // --> Set style.FrameBorderSize=1.0f or style.WindowBorderSize=1.0f to enable borders around items or windows.
	//ImGuiWindowFlags_ResizeFromAnySide    = 1 << 17,  // --> Set io.ConfigWindowsResizeFromEdges=true and make sure mouse cursors are supported by back-end (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors)
};

// Flags for ImGui::InputText()
enum ImGuiInputTextFlags_
{
	ImGuiInputTextFlags_None = 0,
	ImGuiInputTextFlags_CharsDecimal = 1 << 0,   // Allow 0123456789.+-*/
	ImGuiInputTextFlags_CharsHexadecimal = 1 << 1,   // Allow 0123456789ABCDEFabcdef
	ImGuiInputTextFlags_CharsUppercase = 1 << 2,   // Turn a..z into A..Z
	ImGuiInputTextFlags_CharsNoBlank = 1 << 3,   // Filter out spaces, tabs
	ImGuiInputTextFlags_AutoSelectAll = 1 << 4,   // Select entire text when first taking mouse focus
	ImGuiInputTextFlags_EnterReturnsTrue = 1 << 5,   // Return 'true' when Enter is pressed (as opposed to every time the value was modified). Consider looking at the IsItemDeactivatedAfterEdit() function.
	ImGuiInputTextFlags_CallbackCompletion = 1 << 6,   // Callback on pressing TAB (for completion handling)
	ImGuiInputTextFlags_CallbackHistory = 1 << 7,   // Callback on pressing Up/Down arrows (for history handling)
	ImGuiInputTextFlags_CallbackAlways = 1 << 8,   // Callback on each iteration. User code may query cursor position, modify text buffer.
	ImGuiInputTextFlags_CallbackCharFilter = 1 << 9,   // Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
	ImGuiInputTextFlags_AllowTabInput = 1 << 10,  // Pressing TAB input a '\t' character into the text field
	ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 11,  // In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter).
	ImGuiInputTextFlags_NoHorizontalScroll = 1 << 12,  // Disable following the cursor horizontally
	ImGuiInputTextFlags_AlwaysInsertMode = 1 << 13,  // Insert mode
	ImGuiInputTextFlags_ReadOnly = 1 << 14,  // Read-only mode
	ImGuiInputTextFlags_Password = 1 << 15,  // Password mode, display all characters as '*'
	ImGuiInputTextFlags_NoUndoRedo = 1 << 16,  // Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().
	ImGuiInputTextFlags_CharsScientific = 1 << 17,  // Allow 0123456789.+-*/eE (Scientific notation input)
	ImGuiInputTextFlags_CallbackResize = 1 << 18,  // Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. Notify when the string wants to be resized (for string types which hold a cache of their Size). You will be provided a new BufSize in the callback and NEED to honor it. (see misc/cpp/imgui_stdlib.h for an example of using this)
	// [Internal]
	ImGuiInputTextFlags_Multiline = 1 << 20,  // For internal use by InputTextMultiline()
	ImGuiInputTextFlags_NoMarkEdited = 1 << 21   // For internal use by functions using InputText() before reformatting data
};

// Flags for ImGui::TreeNodeEx(), ImGui::CollapsingHeader*()
enum ImGuiTreeNodeFlags_
{
	ImGuiTreeNodeFlags_None = 0,
	ImGuiTreeNodeFlags_Selected = 1 << 0,   // Draw as selected
	ImGuiTreeNodeFlags_Framed = 1 << 1,   // Full colored frame (e.g. for CollapsingHeader)
	ImGuiTreeNodeFlags_AllowItemOverlap = 1 << 2,   // Hit testing to allow subsequent widgets to overlap this one
	ImGuiTreeNodeFlags_NoTreePushOnOpen = 1 << 3,   // Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack
	ImGuiTreeNodeFlags_NoAutoOpenOnLog = 1 << 4,   // Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)
	ImGuiTreeNodeFlags_DefaultOpen = 1 << 5,   // Default node to be open
	ImGuiTreeNodeFlags_OpenOnDoubleClick = 1 << 6,   // Need double-click to open node
	ImGuiTreeNodeFlags_OpenOnArrow = 1 << 7,   // Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.
	ImGuiTreeNodeFlags_Leaf = 1 << 8,   // No collapsing, no arrow (use as a convenience for leaf nodes).
	ImGuiTreeNodeFlags_Bullet = 1 << 9,   // Display a bullet instead of arrow
	ImGuiTreeNodeFlags_FramePadding = 1 << 10,  // Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().
	ImGuiTreeNodeFlags_SpanAvailWidth = 1 << 11,  // Extend hit box to the right-most edge, even if not framed. This is not the default in order to allow adding other items on the same line. In the future we may refactor the hit system to be front-to-back, allowing natural overlaps and then this can become the default.
	ImGuiTreeNodeFlags_SpanFullWidth = 1 << 12,  // Extend hit box to the left-most and right-most edges (bypass the indented area).
	ImGuiTreeNodeFlags_NavLeftJumpsBackHere = 1 << 13,  // (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)
	//ImGuiTreeNodeFlags_NoScrollOnOpen     = 1 << 14,  // FIXME: TODO: Disable automatic scroll on TreePop() if node got just open and contents is not visible
	ImGuiTreeNodeFlags_CollapsingHeader = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_NoAutoOpenOnLog
};

// Flags for ImGui::Selectable()
enum ImGuiSelectableFlags_
{
	ImGuiSelectableFlags_None = 0,
	ImGuiSelectableFlags_DontClosePopups = 1 << 0,   // Clicking this don't close parent popup window
	ImGuiSelectableFlags_SpanAllColumns = 1 << 1,   // Selectable frame can span all columns (text will still fit in current column)
	ImGuiSelectableFlags_AllowDoubleClick = 1 << 2,   // Generate press events on double clicks too
	ImGuiSelectableFlags_Disabled = 1 << 3,   // Cannot be selected, display grayed out text
	ImGuiSelectableFlags_AllowItemOverlap = 1 << 4    // (WIP) Hit testing to allow subsequent widgets to overlap this one
};

// Flags for ImGui::BeginCombo()
enum ImGuiComboFlags_
{
	ImGuiComboFlags_None = 0,
	ImGuiComboFlags_PopupAlignLeft = 1 << 0,   // Align the popup toward the left by default
	ImGuiComboFlags_HeightSmall = 1 << 1,   // Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()
	ImGuiComboFlags_HeightRegular = 1 << 2,   // Max ~8 items visible (default)
	ImGuiComboFlags_HeightLarge = 1 << 3,   // Max ~20 items visible
	ImGuiComboFlags_HeightLargest = 1 << 4,   // As many fitting items as possible
	ImGuiComboFlags_NoArrowButton = 1 << 5,   // Display on the preview box without the square arrow button
	ImGuiComboFlags_NoPreview = 1 << 6,   // Display only a square arrow button
	ImGuiComboFlags_HeightMask_ = ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest
};

// Flags for ImGui::BeginTabBar()
enum ImGuiTabBarFlags_
{
	ImGuiTabBarFlags_None = 0,
	ImGuiTabBarFlags_Reorderable = 1 << 0,   // Allow manually dragging tabs to re-order them + New tabs are appended at the end of list
	ImGuiTabBarFlags_AutoSelectNewTabs = 1 << 1,   // Automatically select new tabs when they appear
	ImGuiTabBarFlags_TabListPopupButton = 1 << 2,   // Disable buttons to open the tab list popup
	ImGuiTabBarFlags_NoCloseWithMiddleMouseButton = 1 << 3,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
	ImGuiTabBarFlags_NoTabListScrollingButtons = 1 << 4,   // Disable scrolling buttons (apply when fitting policy is ImGuiTabBarFlags_FittingPolicyScroll)
	ImGuiTabBarFlags_NoTooltip = 1 << 5,   // Disable tooltips when hovering a tab
	ImGuiTabBarFlags_FittingPolicyResizeDown = 1 << 6,   // Resize tabs when they don't fit
	ImGuiTabBarFlags_FittingPolicyScroll = 1 << 7,   // Add scroll buttons when tabs don't fit
	ImGuiTabBarFlags_FittingPolicyMask_ = ImGuiTabBarFlags_FittingPolicyResizeDown | ImGuiTabBarFlags_FittingPolicyScroll,
	ImGuiTabBarFlags_FittingPolicyDefault_ = ImGuiTabBarFlags_FittingPolicyResizeDown
};

// Flags for ImGui::BeginTabItem()
enum ImGuiTabItemFlags_
{
	ImGuiTabItemFlags_None = 0,
	ImGuiTabItemFlags_UnsavedDocument = 1 << 0,   // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. Also: tab is selected on closure and closure is deferred by one frame to allow code to undo it without flicker.
	ImGuiTabItemFlags_SetSelected = 1 << 1,   // Trigger flag to programmatically make the tab selected when calling BeginTabItem()
	ImGuiTabItemFlags_NoCloseWithMiddleMouseButton = 1 << 2,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
	ImGuiTabItemFlags_NoPushId = 1 << 3    // Don't call PushID(tab->ID)/PopID() on BeginTabItem()/EndTabItem()
};

// Flags for ImGui::IsWindowFocused()
enum ImGuiFocusedFlags_
{
	ImGuiFocusedFlags_None = 0,
	ImGuiFocusedFlags_ChildWindows = 1 << 0,   // IsWindowFocused(): Return true if any children of the window is focused
	ImGuiFocusedFlags_RootWindow = 1 << 1,   // IsWindowFocused(): Test from root window (top most parent of the current hierarchy)
	ImGuiFocusedFlags_AnyWindow = 1 << 2,   // IsWindowFocused(): Return true if any window is focused. Important: If you are trying to tell how to dispatch your low-level inputs, do NOT use this. Use 'io.WantCaptureMouse' instead! Please read the FAQ!
	ImGuiFocusedFlags_RootAndChildWindows = ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows
};

// Flags for ImGui::IsItemHovered(), ImGui::IsWindowHovered()
// Note: if you are trying to check whether your mouse should be dispatched to Dear ImGui or to your app, you should use 'io.WantCaptureMouse' instead! Please read the FAQ!
// Note: windows with the ImGuiWindowFlags_NoInputs flag are ignored by IsWindowHovered() calls.
enum ImGuiHoveredFlags_
{
	ImGuiHoveredFlags_None = 0,        // Return true if directly over the item/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them.
	ImGuiHoveredFlags_ChildWindows = 1 << 0,   // IsWindowHovered() only: Return true if any children of the window is hovered
	ImGuiHoveredFlags_RootWindow = 1 << 1,   // IsWindowHovered() only: Test from root window (top most parent of the current hierarchy)
	ImGuiHoveredFlags_AnyWindow = 1 << 2,   // IsWindowHovered() only: Return true if any window is hovered
	ImGuiHoveredFlags_AllowWhenBlockedByPopup = 1 << 3,   // Return true even if a popup window is normally blocking access to this item/window
	//ImGuiHoveredFlags_AllowWhenBlockedByModal     = 1 << 4,   // Return true even if a modal popup window is normally blocking access to this item/window. FIXME-TODO: Unavailable yet.
	ImGuiHoveredFlags_AllowWhenBlockedByActiveItem = 1 << 5,   // Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns.
	ImGuiHoveredFlags_AllowWhenOverlapped = 1 << 6,   // Return true even if the position is obstructed or overlapped by another window
	ImGuiHoveredFlags_AllowWhenDisabled = 1 << 7,   // Return true even if the item is disabled
	ImGuiHoveredFlags_RectOnly = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped,
	ImGuiHoveredFlags_RootAndChildWindows = ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows
};

// Flags for ImGui::BeginDragDropSource(), ImGui::AcceptDragDropPayload()
enum ImGuiDragDropFlags_
{
	ImGuiDragDropFlags_None = 0,
	// BeginDragDropSource() flags
	ImGuiDragDropFlags_SourceNoPreviewTooltip = 1 << 0,   // By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disable this behavior.
	ImGuiDragDropFlags_SourceNoDisableHover = 1 << 1,   // By default, when dragging we clear data so that IsItemHovered() will return false, to avoid subsequent user code submitting tooltips. This flag disable this behavior so you can still call IsItemHovered() on the source item.
	ImGuiDragDropFlags_SourceNoHoldToOpenOthers = 1 << 2,   // Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.
	ImGuiDragDropFlags_SourceAllowNullID = 1 << 3,   // Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.
	ImGuiDragDropFlags_SourceExtern = 1 << 4,   // External source (from outside of dear imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.
	ImGuiDragDropFlags_SourceAutoExpirePayload = 1 << 5,   // Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged)
	// AcceptDragDropPayload() flags
	ImGuiDragDropFlags_AcceptBeforeDelivery = 1 << 10,  // AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.
	ImGuiDragDropFlags_AcceptNoDrawDefaultRect = 1 << 11,  // Do not draw the default highlight rectangle when hovering over target.
	ImGuiDragDropFlags_AcceptNoPreviewTooltip = 1 << 12,  // Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.
	ImGuiDragDropFlags_AcceptPeekOnly = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect  // For peeking ahead and inspecting the payload before delivery.
};

// Standard Drag and Drop payload types. You can define you own payload types using short strings. Types starting with '_' are defined by Dear ImGui.
#define IMGUI_PAYLOAD_TYPE_COLOR_3F     SECURE("_COL3F")    // float[3]: Standard type for colors, without alpha. User code may use this type.
#define IMGUI_PAYLOAD_TYPE_COLOR_4F     SECURE("_COL4F")    // float[4]: Standard type for colors. User code may use this type.

// A primary data type
enum ImGuiDataType_
{
	ImGuiDataType_S8,       // signed char / char (with sensible compilers)
	ImGuiDataType_U8,       // unsigned char
	ImGuiDataType_S16,      // short
	ImGuiDataType_U16,      // unsigned short
	ImGuiDataType_S32,      // int
	ImGuiDataType_U32,      // unsigned int
	ImGuiDataType_S64,      // long long / __int64
	ImGuiDataType_U64,      // unsigned long long / unsigned __int64
	ImGuiDataType_Float,    // float
	ImGuiDataType_Double,   // double
	ImGuiDataType_COUNT
};

// A cardinal direction
enum ImGuiDir_
{
	ImGuiDir_None = -1,
	ImGuiDir_Left = 0,
	ImGuiDir_Right = 1,
	ImGuiDir_Up = 2,
	ImGuiDir_Down = 3,
	ImGuiDir_COUNT
};

// User fill ImGuiIO.KeyMap[] array with indices into the ImGuiIO.KeysDown[512] array
enum ImGuiKey_
{
	ImGuiKey_Tab,
	ImGuiKey_LeftArrow,
	ImGuiKey_RightArrow,
	ImGuiKey_UpArrow,
	ImGuiKey_DownArrow,
	ImGuiKey_PageUp,
	ImGuiKey_PageDown,
	ImGuiKey_Home,
	ImGuiKey_End,
	ImGuiKey_Insert,
	ImGuiKey_Delete,
	ImGuiKey_Backspace,
	ImGuiKey_Space,
	ImGuiKey_Enter,
	ImGuiKey_Escape,
	ImGuiKey_KeyPadEnter,
	ImGuiKey_A,                 // for text edit CTRL+A: select all
	ImGuiKey_C,                 // for text edit CTRL+C: copy
	ImGuiKey_V,                 // for text edit CTRL+V: paste
	ImGuiKey_X,                 // for text edit CTRL+X: cut
	ImGuiKey_Y,                 // for text edit CTRL+Y: redo
	ImGuiKey_Z,                 // for text edit CTRL+Z: undo
	ImGuiKey_COUNT
};

// To test io.KeyMods (which is a combination of individual fields io.KeyCtrl, io.KeyShift, io.KeyAlt set by user/back-end)
enum ImGuiKeyModFlags_
{
	ImGuiKeyModFlags_None = 0,
	ImGuiKeyModFlags_Ctrl = 1 << 0,
	ImGuiKeyModFlags_Shift = 1 << 1,
	ImGuiKeyModFlags_Alt = 1 << 2,
	ImGuiKeyModFlags_Super = 1 << 3
};

// Gamepad/Keyboard navigation
// Keyboard: Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable. NewFrame() will automatically fill io.NavInputs[] based on your io.KeysDown[] + io.KeyMap[] arrays.
// Gamepad:  Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable. Back-end: set ImGuiBackendFlags_HasGamepad and fill the io.NavInputs[] fields before calling NewFrame(). Note that io.NavInputs[] is cleared by EndFrame().
// Read instructions in imgui.cpp for more details. Download PNG/PSD at http://goo.gl/9LgVZW.
enum ImGuiNavInput_
{
	// Gamepad Mapping
	ImGuiNavInput_Activate,      // activate / open / toggle / tweak value       // e.g. Cross  (PS4), A (Xbox), A (Switch), Space (Keyboard)
	ImGuiNavInput_Cancel,        // cancel / close / exit                        // e.g. Circle (PS4), B (Xbox), B (Switch), Escape (Keyboard)
	ImGuiNavInput_Input,         // text input / on-screen keyboard              // e.g. Triang.(PS4), Y (Xbox), X (Switch), Return (Keyboard)
	ImGuiNavInput_Menu,          // tap: toggle menu / hold: focus, move, resize // e.g. Square (PS4), X (Xbox), Y (Switch), Alt (Keyboard)
	ImGuiNavInput_DpadLeft,      // move / tweak / resize window (w/ PadMenu)    // e.g. D-pad Left/Right/Up/Down (Gamepads), Arrow keys (Keyboard)
	ImGuiNavInput_DpadRight,     //
	ImGuiNavInput_DpadUp,        //
	ImGuiNavInput_DpadDown,      //
	ImGuiNavInput_LStickLeft,    // scroll / move window (w/ PadMenu)            // e.g. Left Analog Stick Left/Right/Up/Down
	ImGuiNavInput_LStickRight,   //
	ImGuiNavInput_LStickUp,      //
	ImGuiNavInput_LStickDown,    //
	ImGuiNavInput_FocusPrev,     // next window (w/ PadMenu)                     // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)
	ImGuiNavInput_FocusNext,     // prev window (w/ PadMenu)                     // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)
	ImGuiNavInput_TweakSlow,     // slower tweaks                                // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)
	ImGuiNavInput_TweakFast,     // faster tweaks                                // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)

	// [Internal] Don't use directly! This is used internally to differentiate keyboard from gamepad inputs for behaviors that require to differentiate them.
	// Keyboard behavior that have no corresponding gamepad mapping (e.g. CTRL+TAB) will be directly reading from io.KeysDown[] instead of io.NavInputs[].
	ImGuiNavInput_KeyMenu_,      // toggle menu                                  // = io.KeyAlt
	ImGuiNavInput_KeyLeft_,      // move left                                    // = Arrow keys
	ImGuiNavInput_KeyRight_,     // move right
	ImGuiNavInput_KeyUp_,        // move up
	ImGuiNavInput_KeyDown_,      // move down
	ImGuiNavInput_COUNT,
	ImGuiNavInput_InternalStart_ = ImGuiNavInput_KeyMenu_
};

// Configuration flags stored in io.ConfigFlags. Set by user/application.
enum ImGuiConfigFlags_
{
	ImGuiConfigFlags_None = 0,
	ImGuiConfigFlags_NavEnableKeyboard = 1 << 0,   // Master keyboard navigation enable flag. NewFrame() will automatically fill io.NavInputs[] based on io.KeysDown[].
	ImGuiConfigFlags_NavEnableGamepad = 1 << 1,   // Master gamepad navigation enable flag. This is mostly to instruct your imgui back-end to fill io.NavInputs[]. Back-end also needs to set ImGuiBackendFlags_HasGamepad.
	ImGuiConfigFlags_NavEnableSetMousePos = 1 << 2,   // Instruct navigation to move the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is awkward. Will update io.MousePos and set io.WantSetMousePos=true. If enabled you MUST honor io.WantSetMousePos requests in your binding, otherwise ImGui will react as if the mouse is jumping around back and forth.
	ImGuiConfigFlags_NavNoCaptureKeyboard = 1 << 3,   // Instruct navigation to not set the io.WantCaptureKeyboard flag when io.NavActive is set.
	ImGuiConfigFlags_NoMouse = 1 << 4,   // Instruct imgui to clear mouse position/buttons in NewFrame(). This allows ignoring the mouse information set by the back-end.
	ImGuiConfigFlags_NoMouseCursorChange = 1 << 5,   // Instruct back-end to not alter mouse cursor shape and visibility. Use if the back-end cursor changes are interfering with yours and you don't want to use SetMouseCursor() to change mouse cursor. You may want to honor requests from imgui by reading GetMouseCursor() yourself instead.

	// User storage (to allow your back-end/engine to communicate to code that may be shared between multiple projects. Those flags are not used by core Dear ImGui)
	ImGuiConfigFlags_IsSRGB = 1 << 20,  // Application is SRGB-aware.
	ImGuiConfigFlags_IsTouchScreen = 1 << 21   // Application is using a touch screen instead of a mouse.
};

// Back-end capabilities flags stored in io.BackendFlags. Set by imgui_impl_xxx or custom back-end.
enum ImGuiBackendFlags_
{
	ImGuiBackendFlags_None = 0,
	ImGuiBackendFlags_HasGamepad = 1 << 0,   // Back-end Platform supports gamepad and currently has one connected.
	ImGuiBackendFlags_HasMouseCursors = 1 << 1,   // Back-end Platform supports honoring GetMouseCursor() value to change the OS cursor shape.
	ImGuiBackendFlags_HasSetMousePos = 1 << 2,   // Back-end Platform supports io.WantSetMousePos requests to reposition the OS mouse position (only used if ImGuiConfigFlags_NavEnableSetMousePos is set).
	ImGuiBackendFlags_RendererHasVtxOffset = 1 << 3    // Back-end Renderer supports ImDrawCmd::VtxOffset. This enables output of large meshes (64K+ vertices) while still using 16-bit indices.
};

// Enumeration for PushStyleColor() / PopStyleColor()
enum ImGuiCol_
{
	ImGuiCol_Text,
	ImGuiCol_TextDisabled,
	ImGuiCol_WindowBg,              // Background of normal windows
	ImGuiCol_ChildBg,               // Background of child windows
	ImGuiCol_PopupBg,               // Background of popups, menus, tooltips windows
	ImGuiCol_Border,
	ImGuiCol_BorderShadow,
	ImGuiCol_FrameBg,               // Background of checkbox, radio button, plot, slider, text input
	ImGuiCol_FrameBgHovered,
	ImGuiCol_FrameBgActive,
	ImGuiCol_TitleBg,
	ImGuiCol_TitleBgActive,
	ImGuiCol_TitleBgCollapsed,
	ImGuiCol_MenuBarBg,
	ImGuiCol_ScrollbarBg,
	ImGuiCol_ScrollbarGrab,
	ImGuiCol_ScrollbarGrabHovered,
	ImGuiCol_ScrollbarGrabActive,
	ImGuiCol_CheckMark,
	ImGuiCol_SliderGrab,
	ImGuiCol_SliderGrabActive,
	ImGuiCol_Button,
	ImGuiCol_ButtonHovered,
	ImGuiCol_ButtonActive,
	ImGuiCol_Header,                // Header* colors are used for CollapsingHeader, TreeNode, Selectable, MenuItem
	ImGuiCol_HeaderHovered,
	ImGuiCol_HeaderActive,
	ImGuiCol_Separator,
	ImGuiCol_SeparatorHovered,
	ImGuiCol_SeparatorActive,
	ImGuiCol_ResizeGrip,
	ImGuiCol_ResizeGripHovered,
	ImGuiCol_ResizeGripActive,
	ImGuiCol_Tab,
	ImGuiCol_TabHovered,
	ImGuiCol_TabActive,
	ImGuiCol_TabUnfocused,
	ImGuiCol_TabUnfocusedActive,
	ImGuiCol_PlotLines,
	ImGuiCol_PlotLinesHovered,
	ImGuiCol_PlotHistogram,
	ImGuiCol_PlotHistogramHovered,
	ImGuiCol_TextSelectedBg,
	ImGuiCol_DragDropTarget,
	ImGuiCol_NavHighlight,          // Gamepad/keyboard: current highlighted item
	ImGuiCol_NavWindowingHighlight, // Highlight window when using CTRL+TAB
	ImGuiCol_NavWindowingDimBg,     // Darken/colorize entire screen behind the CTRL+TAB window list, when active
	ImGuiCol_ModalWindowDimBg,      // Darken/colorize entire screen behind a modal window, when one is active
	ImGuiCol_COUNT

	// Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
	, ImGuiCol_ModalWindowDarkening = ImGuiCol_ModalWindowDimBg                      // [renamed in 1.63]
	//, ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered// [unused since 1.60+] the close button now uses regular button colors.
#endif
};

// Enumeration for PushStyleVar() / PopStyleVar() to temporarily modify the ImGuiStyle structure.
// - The enum only refers to fields of ImGuiStyle which makes sense to be pushed/popped inside UI code.
//   During initialization or between frames, feel free to just poke into ImGuiStyle directly.
// - Tip: Use your programming IDE navigation facilities on the names in the _second column_ below to find the actual members and their description.
//   In Visual Studio IDE: CTRL+comma ("Edit.NavigateTo") can follow symbols in comments, whereas CTRL+F12 ("Edit.GoToImplementation") cannot.
//   With Visual Assist installed: ALT+G ("VAssistX.GoToImplementation") can also follow symbols in comments.
// - When changing this enum, you need to update the associated internal table GStyleVarInfo[] accordingly. This is where we link enum values to members offset/type.
enum ImGuiStyleVar_
{
	// Enum name --------------------- // Member in ImGuiStyle structure (see ImGuiStyle for descriptions)
	ImGuiStyleVar_Alpha,               // float     Alpha
	ImGuiStyleVar_WindowPadding,       // ImVec2    WindowPadding
	ImGuiStyleVar_WindowRounding,      // float     WindowRounding
	ImGuiStyleVar_WindowBorderSize,    // float     WindowBorderSize
	ImGuiStyleVar_WindowMinSize,       // ImVec2    WindowMinSize
	ImGuiStyleVar_WindowTitleAlign,    // ImVec2    WindowTitleAlign
	ImGuiStyleVar_ChildRounding,       // float     ChildRounding
	ImGuiStyleVar_ChildBorderSize,     // float     ChildBorderSize
	ImGuiStyleVar_PopupRounding,       // float     PopupRounding
	ImGuiStyleVar_PopupBorderSize,     // float     PopupBorderSize
	ImGuiStyleVar_FramePadding,        // ImVec2    FramePadding
	ImGuiStyleVar_FrameRounding,       // float     FrameRounding
	ImGuiStyleVar_FrameBorderSize,     // float     FrameBorderSize
	ImGuiStyleVar_ItemSpacing,         // ImVec2    ItemSpacing
	ImGuiStyleVar_ItemInnerSpacing,    // ImVec2    ItemInnerSpacing
	ImGuiStyleVar_IndentSpacing,       // float     IndentSpacing
	ImGuiStyleVar_ScrollbarSize,       // float     ScrollbarSize
	ImGuiStyleVar_ScrollbarRounding,   // float     ScrollbarRounding
	ImGuiStyleVar_GrabMinSize,         // float     GrabMinSize
	ImGuiStyleVar_GrabRounding,        // float     GrabRounding
	ImGuiStyleVar_TabRounding,         // float     TabRounding
	ImGuiStyleVar_ButtonTextAlign,     // ImVec2    ButtonTextAlign
	ImGuiStyleVar_SelectableTextAlign, // ImVec2    SelectableTextAlign
	ImGuiStyleVar_COUNT

	// Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
	, ImGuiStyleVar_Count_ = ImGuiStyleVar_COUNT                    // [renamed in 1.60]
#endif
};

// Flags for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() / ColorButton()
enum ImGuiColorEditFlags_
{
	ImGuiColorEditFlags_None = 0,
	ImGuiColorEditFlags_NoAlpha = 1 << 1,   //              // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (will only read 3 components from the input pointer).
	ImGuiColorEditFlags_NoPicker = 1 << 2,   //              // ColorEdit: disable picker when clicking on colored square.
	ImGuiColorEditFlags_NoOptions = 1 << 3,   //              // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.
	ImGuiColorEditFlags_NoSmallPreview = 1 << 4,   //              // ColorEdit, ColorPicker: disable colored square preview next to the inputs. (e.g. to show only the inputs)
	ImGuiColorEditFlags_NoInputs = 1 << 5,   //              // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview colored square).
	ImGuiColorEditFlags_NoTooltip = 1 << 6,   //              // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.
	ImGuiColorEditFlags_NoLabel = 1 << 7,   //              // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).
	ImGuiColorEditFlags_NoSidePreview = 1 << 8,   //              // ColorPicker: disable bigger color preview on right side of the picker, use small colored square preview instead.
	ImGuiColorEditFlags_NoDragDrop = 1 << 9,   //              // ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.
	ImGuiColorEditFlags_NoBorder = 1 << 10,  //              // ColorButton: disable border (which is enforced by default)

	// User Options (right-click on widget to change some of them).
	ImGuiColorEditFlags_AlphaBar = 1 << 16,  //              // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.
	ImGuiColorEditFlags_AlphaPreview = 1 << 17,  //              // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.
	ImGuiColorEditFlags_AlphaPreviewHalf = 1 << 18,  //              // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.
	ImGuiColorEditFlags_HDR = 1 << 19,  //              // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).
	ImGuiColorEditFlags_DisplayRGB = 1 << 20,  // [Display]    // ColorEdit: override _display_ type among RGB/HSV/Hex. ColorPicker: select any combination using one or more of RGB/HSV/Hex.
	ImGuiColorEditFlags_DisplayHSV = 1 << 21,  // [Display]    // "
	ImGuiColorEditFlags_DisplayHex = 1 << 22,  // [Display]    // "
	ImGuiColorEditFlags_Uint8 = 1 << 23,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.
	ImGuiColorEditFlags_Float = 1 << 24,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.
	ImGuiColorEditFlags_PickerHueBar = 1 << 25,  // [Picker]     // ColorPicker: bar for Hue, rectangle for Sat/Value.
	ImGuiColorEditFlags_PickerHueWheel = 1 << 26,  // [Picker]     // ColorPicker: wheel for Hue, triangle for Sat/Value.
	ImGuiColorEditFlags_InputRGB = 1 << 27,  // [Input]      // ColorEdit, ColorPicker: input and output data in RGB format.
	ImGuiColorEditFlags_InputHSV = 1 << 28,  // [Input]      // ColorEdit, ColorPicker: input and output data in HSV format.

	// Defaults Options. You can set application defaults using SetColorEditOptions(). The intent is that you probably don't want to
	// override them in most of your calls. Let the user choose via the option menu and/or call SetColorEditOptions() once during startup.
	ImGuiColorEditFlags__OptionsDefault = ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_PickerHueBar,

	// [Internal] Masks
	ImGuiColorEditFlags__DisplayMask = ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_DisplayHex,
	ImGuiColorEditFlags__DataTypeMask = ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_Float,
	ImGuiColorEditFlags__PickerMask = ImGuiColorEditFlags_PickerHueWheel | ImGuiColorEditFlags_PickerHueBar,
	ImGuiColorEditFlags__InputMask = ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_InputHSV

	// Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
	, ImGuiColorEditFlags_RGB = ImGuiColorEditFlags_DisplayRGB, ImGuiColorEditFlags_HSV = ImGuiColorEditFlags_DisplayHSV, ImGuiColorEditFlags_HEX = ImGuiColorEditFlags_DisplayHex  // [renamed in 1.69]
#endif
};

// Identify a mouse button.
// Those values are guaranteed to be stable and we frequently use 0/1 directly. Named enums provided for convenience.
enum ImGuiMouseButton_
{
	ImGuiMouseButton_Left = 0,
	ImGuiMouseButton_Right = 1,
	ImGuiMouseButton_Middle = 2,
	ImGuiMouseButton_COUNT = 5
};

// Enumeration for GetMouseCursor()
// User code may request binding to display given cursor by calling SetMouseCursor(), which is why we have some cursors that are marked unused here
enum ImGuiMouseCursor_
{
	ImGuiMouseCursor_None = -1,
	ImGuiMouseCursor_Arrow = 0,
	ImGuiMouseCursor_TextInput,         // When hovering over InputText, etc.
	ImGuiMouseCursor_ResizeAll,         // (Unused by Dear ImGui functions)
	ImGuiMouseCursor_ResizeNS,          // When hovering over an horizontal border
	ImGuiMouseCursor_ResizeEW,          // When hovering over a vertical border or a column
	ImGuiMouseCursor_ResizeNESW,        // When hovering over the bottom-left corner of a window
	ImGuiMouseCursor_ResizeNWSE,        // When hovering over the bottom-right corner of a window
	ImGuiMouseCursor_Hand,              // (Unused by Dear ImGui functions. Use for e.g. hyperlinks)
	ImGuiMouseCursor_NotAllowed,        // When hovering something with disallowed interaction. Usually a crossed circle.
	ImGuiMouseCursor_COUNT

	// Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
	, ImGuiMouseCursor_Count_ = ImGuiMouseCursor_COUNT      // [renamed in 1.60]
#endif
};

// Enumeration for ImGui::SetWindow***(), SetNextWindow***(), SetNextItem***() functions
// Represent a condition.
// Important: Treat as a regular enum! Do NOT combine multiple values using binary operators! All the functions above treat 0 as a shortcut to ImGuiCond_Always.
enum ImGuiCond_
{
	ImGuiCond_Always = 1 << 0,   // Set the variable
	ImGuiCond_Once = 1 << 1,   // Set the variable once per runtime session (only the first call will succeed)
	ImGuiCond_FirstUseEver = 1 << 2,   // Set the variable if the object/window has no persistently saved data (no entry in .ini file)
	ImGuiCond_Appearing = 1 << 3    // Set the variable if the object/window is appearing after being hidden/inactive (or the first time)
};

//-----------------------------------------------------------------------------
// Helpers: Memory allocations macros
// IM_MALLOC(), IM_FREE(), IM_NEW(), IM_PLACEMENT_NEW(), IM_DELETE()
// We call C++ constructor on own allocated memory via the placement "new(ptr) Type()" syntax.
// Defining a custom placement new() with a dummy parameter allows us to bypass including <new> which on some platforms complains when user has disabled exceptions.
//-----------------------------------------------------------------------------

struct ImNewDummy
{ };
inline void* operator new( size_t, ImNewDummy, void* ptr )
{
	return ptr;
}
inline void  operator delete( void*, ImNewDummy, void* )
{ } // This is only required so we can use the symmetrical new()
#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
#define IM_PLACEMENT_NEW(_PTR)              new(ImNewDummy(), _PTR)
#define IM_NEW(_TYPE)                       new(ImNewDummy(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
template<typename T> void IM_DELETE( T* p )
{
	if( p )
	{
		p->~T(); ImGui::MemFree( p );
	}
}

//-----------------------------------------------------------------------------
// Helper: ImVector<>
// Lightweight std::vector<>-like class to avoid dragging dependencies (also, some implementations of STL with debug enabled are absurdly slow, we bypass it so our code runs fast in debug).
//-----------------------------------------------------------------------------
// - You generally do NOT need to care or use this ever. But we need to make it available in imgui.h because some of our public structures are relying on it.
// - We use std-like naming convention here, which is a little unusual for this codebase.
// - Important: clear() frees memory, resize(0) keep the allocated buffer. We use resize(0) a lot to intentionally recycle allocated buffers across frames and amortize our costs.
// - Important: our implementation does NOT call C++ constructors/destructors, we treat everything as raw data! This is intentional but be extra mindful of that,
//   Do NOT use this class as a std::vector replacement in your own code! Many of the structures used by dear imgui can be safely initialized by a zero-memset.
//-----------------------------------------------------------------------------

template<typename T>
struct ImVector
{
	int                 Size;
	int                 Capacity;
	T* Data;

	// Provide standard typedefs but we don't use them ourselves.
	typedef T                   value_type;
	typedef value_type* iterator;
	typedef const value_type* const_iterator;

	// Constructors, destructor
	inline ImVector()
	{
		Size = Capacity = 0; Data = NULL;
	}
	inline ImVector( const ImVector<T>& src )
	{
		Size = Capacity = 0; Data = NULL; operator=( src );
	}
	inline ImVector<T>& operator=( const ImVector<T>& src )
	{
		clear(); resize( src.Size ); memcpy( Data, src.Data, ( size_t )Size * sizeof( T ) ); return *this;
	}
	inline ~ImVector()
	{
		if( Data ) IM_FREE( Data );
	}

	inline bool         empty() const
	{
		return Size == 0;
	}
	inline int          size() const
	{
		return Size;
	}
	inline int          size_in_bytes() const
	{
		return Size * ( int )sizeof( T );
	}
	inline int          capacity() const
	{
		return Capacity;
	}
	inline T& operator[]( int i )
	{
		IM_ASSERT( i < Size ); return Data[ i ];
	}
	inline const T& operator[]( int i ) const
	{
		IM_ASSERT( i < Size ); return Data[ i ];
	}

	inline void         clear()
	{
		if( Data )
		{
			Size = Capacity = 0; IM_FREE( Data ); Data = NULL;
		}
	}
	inline T* begin()
	{
		return Data;
	}
	inline const T* begin() const
	{
		return Data;
	}
	inline T* end()
	{
		return Data + Size;
	}
	inline const T* end() const
	{
		return Data + Size;
	}
	inline T& front()
	{
		IM_ASSERT( Size > 0 ); return Data[ 0 ];
	}
	inline const T& front() const
	{
		IM_ASSERT( Size > 0 ); return Data[ 0 ];
	}
	inline T& back()
	{
		IM_ASSERT( Size > 0 ); return Data[ Size - 1 ];
	}
	inline const T& back() const
	{
		IM_ASSERT( Size > 0 ); return Data[ Size - 1 ];
	}
	inline void         swap( ImVector<T>& rhs )
	{
		int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data;
	}

	inline int          _grow_capacity( int sz ) const
	{
		int new_capacity = Capacity ? ( Capacity + Capacity / 2 ) : 8; return new_capacity > sz ? new_capacity : sz;
	}
	inline void         resize( int new_size )
	{
		if( new_size > Capacity ) reserve( _grow_capacity( new_size ) ); Size = new_size;
	}
	inline void         resize( int new_size, const T& v )
	{
		if( new_size > Capacity ) reserve( _grow_capacity( new_size ) ); if( new_size > Size ) for( int n = Size; n < new_size; n++ ) memcpy( &Data[ n ], &v, sizeof( v ) ); Size = new_size;
	}
	inline void         shrink( int new_size )
	{
		IM_ASSERT( new_size <= Size ); Size = new_size;
	} // Resize a vector to a smaller size, guaranteed not to cause a reallocation
	inline void         reserve( int new_capacity )
	{
		if( new_capacity <= Capacity ) return; T* new_data = ( T* )IM_ALLOC( ( size_t )new_capacity * sizeof( T ) ); if( Data )
		{
			memcpy( new_data, Data, ( size_t )Size * sizeof( T ) ); IM_FREE( Data );
		} Data = new_data; Capacity = new_capacity;
	}

	// NB: It is illegal to call push_back/push_front/insert with a reference pointing inside the ImVector data itself! e.g. v.push_back(v[10]) is forbidden.
	inline void         push_back( const T& v )
	{
		if( Size == Capacity ) reserve( _grow_capacity( Size + 1 ) ); memcpy( &Data[ Size ], &v, sizeof( v ) ); Size++;
	}
	inline void         pop_back()
	{
		IM_ASSERT( Size > 0 ); Size--;
	}
	inline void         push_front( const T& v )
	{
		if( Size == 0 ) push_back( v ); else insert( Data, v );
	}
	inline T* erase( const T* it )
	{
		IM_ASSERT( it >= Data && it < Data + Size ); const ptrdiff_t off = it - Data; memmove( Data + off, Data + off + 1, ( ( size_t )Size - ( size_t )off - 1 ) * sizeof( T ) ); Size--; return Data + off;
	}
	inline T* erase( const T* it, const T* it_last )
	{
		IM_ASSERT( it >= Data && it < Data + Size && it_last > it && it_last <= Data + Size ); const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove( Data + off, Data + off + count, ( ( size_t )Size - ( size_t )off - count ) * sizeof( T ) ); Size -= ( int )count; return Data + off;
	}
	inline T* erase_unsorted( const T* it )
	{
		IM_ASSERT( it >= Data && it < Data + Size );  const ptrdiff_t off = it - Data; if( it < Data + Size - 1 ) memcpy( Data + off, Data + Size - 1, sizeof( T ) ); Size--; return Data + off;
	}
	inline T* insert( const T* it, const T& v )
	{
		IM_ASSERT( it >= Data && it <= Data + Size ); const ptrdiff_t off = it - Data; if( Size == Capacity ) reserve( _grow_capacity( Size + 1 ) ); if( off < ( int )Size ) memmove( Data + off + 1, Data + off, ( ( size_t )Size - ( size_t )off ) * sizeof( T ) ); memcpy( &Data[ off ], &v, sizeof( v ) ); Size++; return Data + off;
	}
	inline bool         contains( const T& v ) const
	{
		const T* data = Data;  const T* data_end = Data + Size; while( data < data_end ) if( *data++ == v ) return true; return false;
	}
	inline T* find( const T& v )
	{
		T* data = Data;  const T* data_end = Data + Size; while( data < data_end ) if( *data == v ) break; else ++data; return data;
	}
	inline const T* find( const T& v ) const
	{
		const T* data = Data;  const T* data_end = Data + Size; while( data < data_end ) if( *data == v ) break; else ++data; return data;
	}
	inline bool         find_erase( const T& v )
	{
		const T* it = find( v ); if( it < Data + Size )
		{
			erase( it ); return true;
		} return false;
	}
	inline bool         find_erase_unsorted( const T& v )
	{
		const T* it = find( v ); if( it < Data + Size )
		{
			erase_unsorted( it ); return true;
		} return false;
	}
	inline int          index_from_ptr( const T* it ) const
	{
		IM_ASSERT( it >= Data && it < Data + Size ); const ptrdiff_t off = it - Data; return ( int )off;
	}
};

//-----------------------------------------------------------------------------
// ImGuiStyle
// You may modify the ImGui::GetStyle() main instance during initialization and before NewFrame().
// During the frame, use ImGui::PushStyleVar(ImGuiStyleVar_XXXX)/PopStyleVar() to alter the main style values,
// and ImGui::PushStyleColor(ImGuiCol_XXX)/PopStyleColor() for colors.
//-----------------------------------------------------------------------------

struct ImGuiStyle
{
	float       Alpha;                      // Global alpha applies to everything in Dear ImGui.
	ImVec2      WindowPadding;              // Padding within a window.
	float       WindowRounding;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows.
	float       WindowBorderSize;           // Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	ImVec2      WindowMinSize;              // Minimum window size. This is a global setting. If you want to constraint individual windows, use SetNextWindowSizeConstraints().
	ImVec2      WindowTitleAlign;           // Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.
	ImGuiDir    WindowMenuButtonPosition;   // Side of the collapsing/docking button in the title bar (None/Left/Right). Defaults to ImGuiDir_Left.
	float       ChildRounding;              // Radius of child window corners rounding. Set to 0.0f to have rectangular windows.
	float       ChildBorderSize;            // Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	float       PopupRounding;              // Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)
	float       PopupBorderSize;            // Thickness of border around popup/tooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	ImVec2      FramePadding;               // Padding within a framed rectangle (used by most widgets).
	float       FrameRounding;              // Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).
	float       FrameBorderSize;            // Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	ImVec2      ItemSpacing;                // Horizontal and vertical spacing between widgets/lines.
	ImVec2      ItemInnerSpacing;           // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).
	ImVec2      TouchExtraPadding;          // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
	float       IndentSpacing;              // Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
	float       ColumnsMinSpacing;          // Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).
	float       ScrollbarSize;              // Width of the vertical scrollbar, Height of the horizontal scrollbar.
	float       ScrollbarRounding;          // Radius of grab corners for scrollbar.
	float       GrabMinSize;                // Minimum width/height of a grab box for slider/scrollbar.
	float       GrabRounding;               // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
	float       TabRounding;                // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
	float       TabBorderSize;              // Thickness of border around tabs.
	ImGuiDir    ColorButtonPosition;        // Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.
	ImVec2      ButtonTextAlign;            // Alignment of button text when button is larger than text. Defaults to (0.5f, 0.5f) (centered).
	ImVec2      SelectableTextAlign;        // Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.
	ImVec2      DisplayWindowPadding;       // Window position are clamped to be visible within the display area by at least this amount. Only applies to regular windows.
	ImVec2      DisplaySafeAreaPadding;     // If you cannot see the edges of your screen (e.g. on a TV) increase the safe area padding. Apply to popups/tooltips as well regular windows. NB: Prefer configuring your TV sets correctly!
	float       MouseCursorScale;           // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
	bool        AntiAliasedLines;           // Enable anti-aliasing on lines/borders. Disable if you are really tight on CPU/GPU.
	bool        AntiAliasedFill;            // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)
	float       CurveTessellationTol;       // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
	float       CircleSegmentMaxError;      // Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.
	ImVec4      Colors[ ImGuiCol_COUNT ];

	IMGUI_API ImGuiStyle();
	IMGUI_API void ScaleAllSizes( float scale_factor );
};

//-----------------------------------------------------------------------------
// ImGuiIO
// Communicate most settings and inputs/outputs to Dear ImGui using this structure.
// Access via ImGui::GetIO(). Read 'Programmer guide' section in .cpp file for general usage.
//-----------------------------------------------------------------------------

struct ImGuiIO
{
	//------------------------------------------------------------------
	// Configuration (fill once)                // Default value
	//------------------------------------------------------------------

	ImGuiConfigFlags   ConfigFlags;             // = 0              // See ImGuiConfigFlags_ enum. Set by user/application. Gamepad/keyboard navigation options, etc.
	ImGuiBackendFlags  BackendFlags;            // = 0              // See ImGuiBackendFlags_ enum. Set by back-end (imgui_impl_xxx files or custom back-end) to communicate features supported by the back-end.
	ImVec2      DisplaySize;                    // <unset>          // Main display size, in pixels.
	float       DeltaTime;                      // = 1.0f/60.0f     // Time elapsed since last frame, in seconds.
	float       IniSavingRate;                  // = 5.0f           // Minimum time between saving positions/sizes to .ini file, in seconds.
	const char* IniFilename;                    // = "imgui.ini"    // Path to .ini file. Set NULL to disable automatic .ini loading/saving, if e.g. you want to manually load/save from memory.
	const char* LogFilename;                    // = "imgui_log.txt"// Path to .log file (default parameter to ImGui::LogToFile when no file is specified).
	float       MouseDoubleClickTime;           // = 0.30f          // Time for a double-click, in seconds.
	float       MouseDoubleClickMaxDist;        // = 6.0f           // Distance threshold to stay in to validate a double-click, in pixels.
	float       MouseDragThreshold;             // = 6.0f           // Distance threshold before considering we are dragging.
	int         KeyMap[ ImGuiKey_COUNT ];         // <unset>          // Map of indices into the KeysDown[512] entries array which represent your "native" keyboard state.
	float       KeyRepeatDelay;                 // = 0.250f         // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).
	float       KeyRepeatRate;                  // = 0.050f         // When holding a key/button, rate at which it repeats, in seconds.
	void* UserData;                       // = NULL           // Store your own data for retrieval by callbacks.

	ImFontAtlas* Fonts;                          // <auto>           // Font atlas: load, rasterize and pack one or more fonts into a single texture.
	float       FontGlobalScale;                // = 1.0f           // Global scale all fonts
	bool        FontAllowUserScaling;           // = false          // Allow user scaling text of individual window with CTRL+Wheel.
	ImFont* FontDefault;                    // = NULL           // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].
	ImVec2      DisplayFramebufferScale;        // = (1, 1)         // For retina display or other situations where window coordinates are different from framebuffer coordinates. This generally ends up in ImDrawData::FramebufferScale.

	// Miscellaneous options
	bool        MouseDrawCursor;                // = false          // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by back-end implementations.
	bool        ConfigMacOSXBehaviors;          // = defined(__APPLE__) // OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl (was called io.OptMacOSXBehaviors prior to 1.63)
	bool        ConfigInputTextCursorBlink;     // = true           // Set to false to disable blinking cursor, for users who consider it distracting. (was called: io.OptCursorBlink prior to 1.63)
	bool        ConfigWindowsResizeFromEdges;   // = true           // Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be a per-window ImGuiWindowFlags_ResizeFromAnySide flag)
	bool        ConfigWindowsMoveFromTitleBarOnly; // = false       // [BETA] Set to true to only allow moving windows when clicked+dragged from the title bar. Windows without a title bar are not affected.
	float       ConfigWindowsMemoryCompactTimer;// = 60.0f          // [BETA] Compact window memory usage when unused. Set to -1.0f to disable.

	//------------------------------------------------------------------
	// Platform Functions
	// (the imgui_impl_xxxx back-end files are setting those up for you)
	//------------------------------------------------------------------

	// Optional: Platform/Renderer back-end name (informational only! will be displayed in About Window) + User data for back-end/wrappers to store their own stuff.
	const char* BackendPlatformName;            // = NULL
	const char* BackendRendererName;            // = NULL
	void* BackendPlatformUserData;        // = NULL           // User data for platform back-end
	void* BackendRendererUserData;        // = NULL           // User data for renderer back-end
	void* BackendLanguageUserData;        // = NULL           // User data for non C++ programming language back-end

	// Optional: Access OS clipboard
	// (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)
	const char* ( *GetClipboardTextFn )( void* user_data );
	void        ( *SetClipboardTextFn )( void* user_data, const char* text );
	void* ClipboardUserData;

	// Optional: Notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME on Windows)
	// (default to use native imm32 api on Windows)
	void        ( *ImeSetInputScreenPosFn )( int x, int y );
	void* ImeWindowHandle;                // = NULL           // (Windows) Set this to your HWND to get automatic IME cursor positioning.

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
		// [OBSOLETE since 1.60+] Rendering function, will be automatically called in Render(). Please call your rendering function yourself now!
		// You can obtain the ImDrawData* by calling ImGui::GetDrawData() after Render(). See example applications if you are unsure of how to implement this.
	void        ( *RenderDrawListsFn )( ImDrawData* data );
#else
		// This is only here to keep ImGuiIO the same size/layout, so that IMGUI_DISABLE_OBSOLETE_FUNCTIONS can exceptionally be used outside of imconfig.h.
	void* RenderDrawListsFnUnused;
#endif

	//------------------------------------------------------------------
	// Input - Fill before calling NewFrame()
	//------------------------------------------------------------------

	ImVec2      MousePos;                       // Mouse position, in pixels. Set to ImVec2(-FLT_MAX,-FLT_MAX) if mouse is unavailable (on another screen, etc.)
	bool        MouseDown[ 5 ];                   // Mouse buttons: 0=left, 1=right, 2=middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
	float       MouseWheel;                     // Mouse wheel Vertical: 1 unit scrolls about 5 lines text.
	float       MouseWheelH;                    // Mouse wheel Horizontal. Most users don't have a mouse with an horizontal wheel, may not be filled by all back-ends.
	bool        KeyCtrl;                        // Keyboard modifier pressed: Control
	bool        KeyShift;                       // Keyboard modifier pressed: Shift
	bool        KeyAlt;                         // Keyboard modifier pressed: Alt
	bool        KeySuper;                       // Keyboard modifier pressed: Cmd/Super/Windows
	bool        KeysDown[ 512 ];                  // Keyboard keys that are pressed (ideally left in the "native" order your engine has access to keyboard keys, so you can use your own defines/enums for keys).
	float       NavInputs[ ImGuiNavInput_COUNT ]; // Gamepad inputs. Cleared back to zero by EndFrame(). Keyboard keys will be auto-mapped and be written here by NewFrame().

	// Functions
	IMGUI_API void  AddInputCharacter( unsigned int c );          // Queue new character input
	IMGUI_API void  AddInputCharacterUTF16( ImWchar16 c );        // Queue new character input from an UTF-16 character, it can be a surrogate
	IMGUI_API void  AddInputCharactersUTF8( const char* str );    // Queue new characters input from an UTF-8 string
	IMGUI_API void  ClearInputCharacters();                     // Clear the text input buffer manually

	//------------------------------------------------------------------
	// Output - Updated by NewFrame() or EndFrame()/Render()
	// (when reading from the io.WantCaptureMouse, io.WantCaptureKeyboard flags to dispatch your inputs, it is
	//  generally easier and more correct to use their state BEFORE calling NewFrame(). See FAQ for details!)
	//------------------------------------------------------------------

	bool        WantCaptureMouse;               // Set when Dear ImGui will use mouse inputs, in this case do not dispatch them to your main game/application (either way, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).
	bool        WantCaptureKeyboard;            // Set when Dear ImGui will use keyboard inputs, in this case do not dispatch them to your main game/application (either way, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).
	bool        WantTextInput;                  // Mobile/console: when set, you may display an on-screen keyboard. This is set by Dear ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).
	bool        WantSetMousePos;                // MousePos has been altered, back-end should reposition mouse on next frame. Rarely used! Set only when ImGuiConfigFlags_NavEnableSetMousePos flag is enabled.
	bool        WantSaveIniSettings;            // When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. Important: clear io.WantSaveIniSettings yourself after saving!
	bool        NavActive;                      // Keyboard/Gamepad navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.
	bool        NavVisible;                     // Keyboard/Gamepad navigation is visible and allowed (will handle ImGuiKey_NavXXX events).
	float       Framerate;                      // Application framerate estimate, in frame per second. Solely for convenience. Rolling average estimation based on io.DeltaTime over 120 frames.
	int         MetricsRenderVertices;          // Vertices output during last call to Render()
	int         MetricsRenderIndices;           // Indices output during last call to Render() = number of triangles * 3
	int         MetricsRenderWindows;           // Number of visible windows
	int         MetricsActiveWindows;           // Number of active windows
	int         MetricsActiveAllocations;       // Number of active allocations, updated by MemAlloc/MemFree based on current context. May be off if you have multiple imgui contexts.
	ImVec2      MouseDelta;                     // Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.

	//------------------------------------------------------------------
	// [Internal] Dear ImGui will maintain those fields. Forward compatibility not guaranteed!
	//------------------------------------------------------------------

	ImGuiKeyModFlags KeyMods;                   // Key mods flags (same as io.KeyCtrl/KeyShift/KeyAlt/KeySuper but merged into flags), updated by NewFrame()
	ImVec2      MousePosPrev;                   // Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)
	ImVec2      MouseClickedPos[ 5 ];             // Position at time of clicking
	double      MouseClickedTime[ 5 ];            // Time of last click (used to figure out double-click)
	bool        MouseClicked[ 5 ];                // Mouse button went from !Down to Down
	bool        MouseDoubleClicked[ 5 ];          // Has mouse button been double-clicked?
	bool        MouseReleased[ 5 ];               // Mouse button went from Down to !Down
	bool        MouseDownOwned[ 5 ];              // Track if button was clicked inside a dear imgui window. We don't request mouse capture from the application if click started outside ImGui bounds.
	bool        MouseDownWasDoubleClick[ 5 ];     // Track if button down was a double-click
	float       MouseDownDuration[ 5 ];           // Duration the mouse button has been down (0.0f == just clicked)
	float       MouseDownDurationPrev[ 5 ];       // Previous time the mouse button has been down
	ImVec2      MouseDragMaxDistanceAbs[ 5 ];     // Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point
	float       MouseDragMaxDistanceSqr[ 5 ];     // Squared maximum distance of how much mouse has traveled from the clicking point
	float       KeysDownDuration[ 512 ];          // Duration the keyboard key has been down (0.0f == just pressed)
	float       KeysDownDurationPrev[ 512 ];      // Previous duration the key has been down
	float       NavInputsDownDuration[ ImGuiNavInput_COUNT ];
	float       NavInputsDownDurationPrev[ ImGuiNavInput_COUNT ];
	ImWchar16   InputQueueSurrogate;            // For AddInputCharacterUTF16
	ImVector<ImWchar> InputQueueCharacters;     // Queue of _characters_ input (obtained by platform back-end). Fill using AddInputCharacter() helper.

	IMGUI_API   ImGuiIO();
};

//-----------------------------------------------------------------------------
// Misc data structures
//-----------------------------------------------------------------------------

// Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used.
// The callback function should return 0 by default.
// Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details)
// - ImGuiInputTextFlags_CallbackCompletion:  Callback on pressing TAB
// - ImGuiInputTextFlags_CallbackHistory:     Callback on pressing Up/Down arrows
// - ImGuiInputTextFlags_CallbackAlways:      Callback on each iteration
// - ImGuiInputTextFlags_CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
// - ImGuiInputTextFlags_CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow.
struct ImGuiInputTextCallbackData
{
	ImGuiInputTextFlags EventFlag;      // One ImGuiInputTextFlags_Callback*    // Read-only
	ImGuiInputTextFlags Flags;          // What user passed to InputText()      // Read-only
	void* UserData;       // What user passed to InputText()      // Read-only

	// Arguments for the different callback events
	// - To modify the text buffer in a callback, prefer using the InsertChars() / DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.
	// - If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf[]' directly. You need to update 'BufTextLen' accordingly (0 <= BufTextLen < BufSize) and set 'BufDirty'' to true so InputText can update its internal state.
	ImWchar             EventChar;      // Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;
	ImGuiKey            EventKey;       // Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History]
	char* Buf;            // Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!
	int                 BufTextLen;     // Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()
	int                 BufSize;        // Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1
	bool                BufDirty;       // Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always]
	int                 CursorPos;      //                                      // Read-write   // [Completion,History,Always]
	int                 SelectionStart; //                                      // Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)
	int                 SelectionEnd;   //                                      // Read-write   // [Completion,History,Always]

	// Helper functions for text manipulation.
	// Use those function to benefit from the CallbackResize behaviors. Calling those function reset the selection.
	IMGUI_API ImGuiInputTextCallbackData();
	IMGUI_API void      DeleteChars( int pos, int bytes_count );
	IMGUI_API void      InsertChars( int pos, const char* text, const char* text_end = NULL );
	bool                HasSelection() const
	{
		return SelectionStart != SelectionEnd;
	}
};

// Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().
// NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.
struct ImGuiSizeCallbackData
{
	void* UserData;       // Read-only.   What user passed to SetNextWindowSizeConstraints()
	ImVec2  Pos;            // Read-only.   Window position, for reference.
	ImVec2  CurrentSize;    // Read-only.   Current window size.
	ImVec2  DesiredSize;    // Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.
};

// Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()
struct ImGuiPayload
{
	// Members
	void* Data;               // Data (copied and owned by dear imgui)
	int             DataSize;           // Data size

	// [Internal]
	ImGuiID         SourceId;           // Source item id
	ImGuiID         SourceParentId;     // Source parent id (if available)
	int             DataFrameCount;     // Data timestamp
	char            DataType[ 32 + 1 ];     // Data type tag (short user-supplied string, 32 characters max)
	bool            Preview;            // Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)
	bool            Delivery;           // Set when AcceptDragDropPayload() was called and mouse button is released over the target item.

	ImGuiPayload()
	{
		Clear();
	}
	void Clear()
	{
		SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset( DataType, 0, sizeof( DataType ) ); DataFrameCount = -1; Preview = Delivery = false;
	}
	bool IsDataType( const char* type ) const
	{
		return DataFrameCount != -1 && strcmp( type, DataType ) == 0;
	}
	bool IsPreview() const
	{
		return Preview;
	}
	bool IsDelivery() const
	{
		return Delivery;
	}
};

//-----------------------------------------------------------------------------
// Obsolete functions (Will be removed! Read 'API BREAKING CHANGES' section in imgui.cpp for details)
// Please keep your copy of dear imgui up to date! Occasionally set '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' in imconfig.h to stay ahead.
//-----------------------------------------------------------------------------

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
namespace ImGui
{
// OBSOLETED in 1.72 (from July 2019)
static inline void  TreeAdvanceToLabelPos()
{
	SetCursorPosX( GetCursorPosX() + GetTreeNodeToLabelSpacing() );
}
// OBSOLETED in 1.71 (from June 2019)
static inline void  SetNextTreeNodeOpen( bool open, ImGuiCond cond = 0 )
{
	SetNextItemOpen( open, cond );
}
// OBSOLETED in 1.70 (from May 2019)
static inline float GetContentRegionAvailWidth()
{
	return GetContentRegionAvail().x;
}
// OBSOLETED in 1.69 (from Mar 2019)
static inline ImDrawList* GetOverlayDrawList()
{
	return GetForegroundDrawList();
}
// OBSOLETED in 1.66 (from Sep 2018)
static inline void  SetScrollHere( float center_ratio = 0.5f )
{
	SetScrollHereY( center_ratio );
}
// OBSOLETED in 1.63 (between Aug 2018 and Sept 2018)
static inline bool  IsItemDeactivatedAfterChange()
{
	return IsItemDeactivatedAfterEdit();
}
// OBSOLETED in 1.61 (between Apr 2018 and Aug 2018)
IMGUI_API bool      InputFloat( const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags flags = 0 ); // Use the 'const char* format' version instead of 'decimal_precision'!
IMGUI_API bool      InputFloat2( const char* label, float v[ 2 ], int decimal_precision, ImGuiInputTextFlags flags = 0 );
IMGUI_API bool      InputFloat3( const char* label, float v[ 3 ], int decimal_precision, ImGuiInputTextFlags flags = 0 );
IMGUI_API bool      InputFloat4( const char* label, float v[ 4 ], int decimal_precision, ImGuiInputTextFlags flags = 0 );
// OBSOLETED in 1.60 (between Dec 2017 and Apr 2018)
static inline bool  IsAnyWindowFocused()
{
	return IsWindowFocused( ImGuiFocusedFlags_AnyWindow );
}
static inline bool  IsAnyWindowHovered()
{
	return IsWindowHovered( ImGuiHoveredFlags_AnyWindow );
}
static inline ImVec2 CalcItemRectClosestPoint( const ImVec2& pos, bool on_edge = false, float outward = 0.f )
{
	IM_UNUSED( on_edge ); IM_UNUSED( outward ); IM_ASSERT( 0 ); return pos;
}
}
typedef ImGuiInputTextCallback      ImGuiTextEditCallback;    // OBSOLETED in 1.63 (from Aug 2018): made the names consistent
typedef ImGuiInputTextCallbackData  ImGuiTextEditCallbackData;
#endif

//-----------------------------------------------------------------------------
// Helpers
//-----------------------------------------------------------------------------

// Helper: Unicode defines
#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
#ifdef IMGUI_USE_WCHAR32
#define IM_UNICODE_CODEPOINT_MAX     0x10FFFF   // Maximum Unicode code point supported by this build.
#else
#define IM_UNICODE_CODEPOINT_MAX     0xFFFF     // Maximum Unicode code point supported by this build.
#endif

// Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create an UI within deep-nested code that runs multiple times every frame.
// Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text("This will be called only once per frame");
struct ImGuiOnceUponAFrame
{
	ImGuiOnceUponAFrame()
	{
		RefFrame = -1;
	}
	mutable int RefFrame;
	operator bool() const
	{
		int current_frame = ImGui::GetFrameCount(); if( RefFrame == current_frame ) return false; RefFrame = current_frame; return true;
	}
};

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
struct ImGuiTextFilter
{
	IMGUI_API           ImGuiTextFilter( const char* default_filter = "" );
	IMGUI_API bool      Draw( const char* label = "Filter (inc,-exc)", float width = 0.0f );  // Helper calling InputText+Build
	IMGUI_API bool      PassFilter( const char* text, const char* text_end = NULL ) const;
	IMGUI_API void      Build();
	void                Clear()
	{
		InputBuf[ 0 ] = 0; Build();
	}
	bool                IsActive() const
	{
		return !Filters.empty();
	}

	// [Internal]
	struct ImGuiTextRange
	{
		const char* b;
		const char* e;

		ImGuiTextRange()
		{
			b = e = NULL;
		}
		ImGuiTextRange( const char* _b, const char* _e )
		{
			b = _b; e = _e;
		}
		bool            empty() const
		{
			return b == e;
		}
		IMGUI_API void  split( char separator, ImVector<ImGuiTextRange>* out ) const;
	};
	char                    InputBuf[ 256 ];
	ImVector<ImGuiTextRange>Filters;
	int                     CountGrep;
};

// Helper: Growable text buffer for logging/accumulating text
// (this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder')
struct ImGuiTextBuffer
{
	ImVector<char>      Buf;
	IMGUI_API static char EmptyString[ 1 ];

	ImGuiTextBuffer()
	{ }
	inline char         operator[]( int i ) const
	{
		IM_ASSERT( Buf.Data != NULL ); return Buf.Data[ i ];
	}
	const char* begin() const
	{
		return Buf.Data ? &Buf.front() : EmptyString;
	}
	const char* end() const
	{
		return Buf.Data ? &Buf.back() : EmptyString;
	}   // Buf is zero-terminated, so end() will point on the zero-terminator
	int                 size() const
	{
		return Buf.Size ? Buf.Size - 1 : 0;
	}
	bool                empty() const
	{
		return Buf.Size <= 1;
	}
	void                clear()
	{
		Buf.clear();
	}
	void                reserve( int capacity )
	{
		Buf.reserve( capacity );
	}
	const char* c_str() const
	{
		return Buf.Data ? Buf.Data : EmptyString;
	}
	IMGUI_API void      append( const char* str, const char* str_end = NULL );
	IMGUI_API void      appendf( const char* fmt, ... ) IM_FMTARGS( 2 );
	IMGUI_API void      appendfv( const char* fmt, va_list args ) IM_FMTLIST( 2 );
};

// Helper: Key->Value storage
// Typically you don't have to worry about this since a storage is held within each Window.
// We use it to e.g. store collapse state for a tree (Int 0/1)
// This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)
// You can use it as custom user storage for temporary values. Declare your own storage if, for example:
// - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).
// - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)
// Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.
struct ImGuiStorage
{
	// [Internal]
	struct ImGuiStoragePair
	{
		ImGuiID key;
		union
		{
			int val_i; float val_f; void* val_p;
		};
		ImGuiStoragePair( ImGuiID _key, int _val_i )
		{
			key = _key; val_i = _val_i;
		}
		ImGuiStoragePair( ImGuiID _key, float _val_f )
		{
			key = _key; val_f = _val_f;
		}
		ImGuiStoragePair( ImGuiID _key, void* _val_p )
		{
			key = _key; val_p = _val_p;
		}
	};

	ImVector<ImGuiStoragePair>      Data;

	// - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)
	// - Set***() functions find pair, insertion on demand if missing.
	// - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.
	void                Clear()
	{
		Data.clear();
	}
	IMGUI_API int       GetInt( ImGuiID key, int default_val = 0 ) const;
	IMGUI_API void      SetInt( ImGuiID key, int val );
	IMGUI_API bool      GetBool( ImGuiID key, bool default_val = false ) const;
	IMGUI_API void      SetBool( ImGuiID key, bool val );
	IMGUI_API float     GetFloat( ImGuiID key, float default_val = 0.0f ) const;
	IMGUI_API void      SetFloat( ImGuiID key, float val );
	IMGUI_API void* GetVoidPtr( ImGuiID key ) const; // default_val is NULL
	IMGUI_API void      SetVoidPtr( ImGuiID key, void* val );

	// - Get***Ref() functions finds pair, insert on demand if missing, return pointer. Useful if you intend to do Get+Set.
	// - References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
	// - A typical use case where this is convenient for quick hacking (e.g. add storage during a live Edit&Continue session if you can't modify existing struct)
	//      float* pvar = ImGui::GetFloatRef(key); ImGui::SliderFloat("var", pvar, 0, 100.0f); some_var += *pvar;
	IMGUI_API int* GetIntRef( ImGuiID key, int default_val = 0 );
	IMGUI_API bool* GetBoolRef( ImGuiID key, bool default_val = false );
	IMGUI_API float* GetFloatRef( ImGuiID key, float default_val = 0.0f );
	IMGUI_API void** GetVoidPtrRef( ImGuiID key, void* default_val = NULL );

	// Use on your own storage if you know only integer are being stored (open/close all tree nodes)
	IMGUI_API void      SetAllInt( int val );

	// For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
	IMGUI_API void      BuildSortByKey();
};

// Helper: Manually clip large list of items.
// If you are submitting lots of evenly spaced items and you have a random access to the list, you can perform coarse clipping based on visibility to save yourself from processing those items at all.
// The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.
// ImGui already clip items based on their bounds but it needs to measure text size to do so. Coarse clipping before submission makes this cost and your own data fetching/submission cost null.
// Usage:
//     ImGuiListClipper clipper(1000);  // we have 1000 elements, evenly spaced.
//     while (clipper.Step())
//         for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
//             ImGui::Text("line number %d", i);
// - Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height (step skipped if we passed a known height as second arg to constructor).
// - Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.
// - (Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user call Step(). Does nothing and switch to Step 3.)
// - Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.
struct ImGuiListClipper
{
	int     DisplayStart, DisplayEnd;
	int     ItemsCount;

	// [Internal]
	int     StepNo;
	float   ItemsHeight;
	float   StartPosY;

	// items_count:  Use -1 to ignore (you can call Begin later). Use INT_MAX if you don't know how many items you have (in which case the cursor won't be advanced in the final step).
	// items_height: Use -1.0f to be calculated automatically on first step. Otherwise pass in the distance between your items, typically GetTextLineHeightWithSpacing() or GetFrameHeightWithSpacing().
	// If you don't specify an items_height, you NEED to call Step(). If you specify items_height you may call the old Begin()/End() api directly, but prefer calling Step().
	ImGuiListClipper( int items_count = -1, float items_height = -1.0f )
	{
		Begin( items_count, items_height );
	} // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).
	~ImGuiListClipper()
	{
		IM_ASSERT( ItemsCount == -1 );
	}      // Assert if user forgot to call End() or Step() until false.

	IMGUI_API bool Step();                                              // Call until it returns false. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.
	IMGUI_API void Begin( int items_count, float items_height = -1.0f );  // Automatically called by constructor if you passed 'items_count' or by Step() in Step 1.
	IMGUI_API void End();                                               // Automatically called on the last call of Step() that returns false.
};

// Helpers macros to generate 32-bit encoded colors
#ifdef IMGUI_USE_BGRA_PACKED_COLOR
#define IM_COL32_R_SHIFT    16
#define IM_COL32_G_SHIFT    8
#define IM_COL32_B_SHIFT    0
#define IM_COL32_A_SHIFT    24
#define IM_COL32_A_MASK     0xFF000000
#else
#define IM_COL32_R_SHIFT    0
#define IM_COL32_G_SHIFT    8
#define IM_COL32_B_SHIFT    16
#define IM_COL32_A_SHIFT    24
#define IM_COL32_A_MASK     0xFF000000
#endif
#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
#define IM_COL32_BLACK       IM_COL32(0,0,0,255)        // Opaque black
#define IM_COL32_BLACK_TRANS IM_COL32(0,0,0,0)          // Transparent black = 0x00000000

// Helper: ImColor() implicitly converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float)
// Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API.
// **Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE.
// **None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.
struct ImColor
{
	ImVec4              Value;

	ImColor()
	{
		Value.x = Value.y = Value.z = Value.w = 0.0f;
	}
	ImColor( int r, int g, int b, int a = 255 )
	{
		float sc = 1.0f / 255.0f; Value.x = ( float )r * sc; Value.y = ( float )g * sc; Value.z = ( float )b * sc; Value.w = ( float )a * sc;
	}
	ImColor( ImU32 rgba )
	{
		float sc = 1.0f / 255.0f; Value.x = ( float )( ( rgba >> IM_COL32_R_SHIFT ) & 0xFF ) * sc; Value.y = ( float )( ( rgba >> IM_COL32_G_SHIFT ) & 0xFF ) * sc; Value.z = ( float )( ( rgba >> IM_COL32_B_SHIFT ) & 0xFF ) * sc; Value.w = ( float )( ( rgba >> IM_COL32_A_SHIFT ) & 0xFF ) * sc;
	}
	ImColor( float r, float g, float b, float a = 1.0f )
	{
		Value.x = r; Value.y = g; Value.z = b; Value.w = a;
	}
	ImColor( const ImVec4& col )
	{
		Value = col;
	}
	inline operator ImU32() const
	{
		return ImGui::ColorConvertFloat4ToU32( Value );
	}
	inline operator ImVec4() const
	{
		return Value;
	}

	// FIXME-OBSOLETE: May need to obsolete/cleanup those helpers.
	inline void    SetHSV( float h, float s, float v, float a = 1.0f )
	{
		ImGui::ColorConvertHSVtoRGB( h, s, v, Value.x, Value.y, Value.z ); Value.w = a;
	}
	static ImColor HSV( float h, float s, float v, float a = 1.0f )
	{
		float r, g, b; ImGui::ColorConvertHSVtoRGB( h, s, v, r, g, b ); return ImColor( r, g, b, a );
	}
};

//-----------------------------------------------------------------------------
// Draw List API (ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListSplitter, ImDrawListFlags, ImDrawList, ImDrawData)
// Hold a series of drawing commands. The user provides a renderer for ImDrawData which essentially contains an array of ImDrawList.
//-----------------------------------------------------------------------------

// ImDrawCallback: Draw callbacks for advanced uses [configurable type: override in imconfig.h]
// NB: You most likely do NOT need to use draw callbacks just to create your own widget or customized UI rendering,
// you can poke into the draw list for that! Draw callback may be useful for example to:
//  A) Change your GPU render state,
//  B) render a complex 3D scene inside a UI element without an intermediate texture/render target, etc.
// The expected behavior from your rendering function is 'if (cmd.UserCallback != NULL) { cmd.UserCallback(parent_list, cmd); } else { RenderTriangles() }'
// If you want to override the signature of ImDrawCallback, you can simply use e.g. '#define ImDrawCallback MyDrawCallback' (in imconfig.h) + update rendering back-end accordingly.
#ifndef ImDrawCallback
typedef void ( *ImDrawCallback )( const ImDrawList* parent_list, const ImDrawCmd* cmd );
#endif

// Special Draw callback value to request renderer back-end to reset the graphics/render state.
// The renderer back-end needs to handle this special value, otherwise it will crash trying to call a function at this address.
// This is useful for example if you submitted callbacks which you know have altered the render state and you want it to be restored.
// It is not done by default because they are many perfectly useful way of altering render state for imgui contents (e.g. changing shader/blending settings before an Image call).
#define ImDrawCallback_ResetRenderState     (ImDrawCallback)(-1)

// Typically, 1 command = 1 GPU draw call (unless command is a callback)
// Pre 1.71 back-ends will typically ignore the VtxOffset/IdxOffset fields. When 'io.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset'
// is enabled, those fields allow us to render meshes larger than 64K vertices while keeping 16-bit indices.
struct ImDrawCmd
{
	unsigned int    ElemCount;              // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
	ImVec4          ClipRect;               // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData->DisplayPos to get clipping rectangle in "viewport" coordinates
	ImTextureID     TextureId;              // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.
	unsigned int    VtxOffset;              // Start offset in vertex buffer. Pre-1.71 or without ImGuiBackendFlags_RendererHasVtxOffset: always 0. With ImGuiBackendFlags_RendererHasVtxOffset: may be >0 to support meshes larger than 64K vertices with 16-bit indices.
	unsigned int    IdxOffset;              // Start offset in index buffer. Always equal to sum of ElemCount drawn so far.
	ImDrawCallback  UserCallback;           // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
	void* UserCallbackData;       // The draw callback code can access this.

	ImDrawCmd()
	{
		ElemCount = 0; TextureId = ( ImTextureID )NULL; VtxOffset = IdxOffset = 0;  UserCallback = NULL; UserCallbackData = NULL;
	}
};

// Vertex index, default to 16-bit
// To allow large meshes with 16-bit indices: set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset' and handle ImDrawCmd::VtxOffset in the renderer back-end (recommended).
// To use 32-bit indices: override with '#define ImDrawIdx unsigned int' in imconfig.h.
#ifndef ImDrawIdx
typedef unsigned short ImDrawIdx;
#endif

// Vertex layout
#ifndef IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT
struct ImDrawVert
{
	ImVec2  pos;
	ImVec2  uv;
	ImU32   col;
};
#else
// You can override the vertex format layout by defining IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT in imconfig.h
// The code expect ImVec2 pos (8 bytes), ImVec2 uv (8 bytes), ImU32 col (4 bytes), but you can re-order them or add other fields as needed to simplify integration in your engine.
// The type has to be described within the macro (you can either declare the struct or use a typedef). This is because ImVec2/ImU32 are likely not declared a the time you'd want to set your type up.
// NOTE: IMGUI DOESN'T CLEAR THE STRUCTURE AND DOESN'T CALL A CONSTRUCTOR SO ANY CUSTOM FIELD WILL BE UNINITIALIZED. IF YOU ADD EXTRA FIELDS (SUCH AS A 'Z' COORDINATES) YOU WILL NEED TO CLEAR THEM DURING RENDER OR TO IGNORE THEM.
IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT;
#endif

// For use by ImDrawListSplitter.
struct ImDrawChannel
{
	ImVector<ImDrawCmd>         _CmdBuffer;
	ImVector<ImDrawIdx>         _IdxBuffer;
};

// Split/Merge functions are used to split the draw list into different layers which can be drawn into out of order.
// This is used by the Columns api, so items of each column can be batched together in a same draw call.
struct ImDrawListSplitter
{
	int                         _Current;    // Current channel number (0)
	int                         _Count;      // Number of active channels (1+)
	ImVector<ImDrawChannel>     _Channels;   // Draw channels (not resized down so _Count might be < Channels.Size)

	inline ImDrawListSplitter()
	{
		Clear();
	}
	inline ~ImDrawListSplitter()
	{
		ClearFreeMemory();
	}
	inline void                 Clear()
	{
		_Current = 0; _Count = 1;
	} // Do not clear Channels[] so our allocations are reused next frame
	IMGUI_API void              ClearFreeMemory();
	IMGUI_API void              Split( ImDrawList* draw_list, int count );
	IMGUI_API void              Merge( ImDrawList* draw_list );
	IMGUI_API void              SetCurrentChannel( ImDrawList* draw_list, int channel_idx );
};

enum ImDrawCornerFlags_
{
	ImDrawCornerFlags_None = 0,
	ImDrawCornerFlags_TopLeft = 1 << 0, // 0x1
	ImDrawCornerFlags_TopRight = 1 << 1, // 0x2
	ImDrawCornerFlags_BotLeft = 1 << 2, // 0x4
	ImDrawCornerFlags_BotRight = 1 << 3, // 0x8
	ImDrawCornerFlags_Top = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_TopRight,   // 0x3
	ImDrawCornerFlags_Bot = ImDrawCornerFlags_BotLeft | ImDrawCornerFlags_BotRight,   // 0xC
	ImDrawCornerFlags_Left = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotLeft,    // 0x5
	ImDrawCornerFlags_Right = ImDrawCornerFlags_TopRight | ImDrawCornerFlags_BotRight,  // 0xA
	ImDrawCornerFlags_All = 0xF     // In your function calls you may use ~0 (= all bits sets) instead of ImDrawCornerFlags_All, as a convenience
};

enum ImDrawListFlags_
{
	ImDrawListFlags_None = 0,
	ImDrawListFlags_AntiAliasedLines = 1 << 0,  // Lines are anti-aliased (*2 the number of triangles for 1.0f wide line, otherwise *3 the number of triangles)
	ImDrawListFlags_AntiAliasedFill = 1 << 1,  // Filled shapes have anti-aliased edges (*2 the number of vertices)
	ImDrawListFlags_AllowVtxOffset = 1 << 2   // Can emit 'VtxOffset > 0' to allow large meshes. Set when 'ImGuiBackendFlags_RendererHasVtxOffset' is enabled.
};

// Draw command list
// This is the low-level list of polygons that ImGui:: functions are filling. At the end of the frame,
// all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.
// Each dear imgui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to
// access the current window draw list and draw custom primitives.
// You can interleave normal ImGui:: calls and adding primitives to the current draw list.
// All positions are generally in pixel coordinates (top-left at (0,0), bottom-right at io.DisplaySize), but you are totally free to apply whatever transformation matrix to want to the data (if you apply such transformation you'll want to apply it to ClipRect as well)
// Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.
struct ImDrawList
{
	// This is what you have to render
	ImVector<ImDrawCmd>     CmdBuffer;          // Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.
	ImVector<ImDrawIdx>     IdxBuffer;          // Index buffer. Each command consume ImDrawCmd::ElemCount of those
	ImVector<ImDrawVert>    VtxBuffer;          // Vertex buffer.
	ImDrawListFlags         Flags;              // Flags, you may poke into these to adjust anti-aliasing settings per-primitive.

	// [Internal, used while building lists]
	const ImDrawListSharedData* _Data;          // Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)
	const char* _OwnerName;         // Pointer to owner window's name for debugging
	unsigned int            _VtxCurrentOffset;  // [Internal] Always 0 unless 'Flags & ImDrawListFlags_AllowVtxOffset'.
	unsigned int            _VtxCurrentIdx;     // [Internal] Generally == VtxBuffer.Size unless we are past 64K vertices, in which case this gets reset to 0.
	ImDrawVert* _VtxWritePtr;       // [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
	ImDrawIdx* _IdxWritePtr;       // [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
	ImVector<ImVec4>        _ClipRectStack;     // [Internal]
	ImVector<ImTextureID>   _TextureIdStack;    // [Internal]
	ImVector<ImVec2>        _Path;              // [Internal] current path building
	ImDrawListSplitter      _Splitter;          // [Internal] for channels api

	// If you want to create ImDrawList instances, pass them ImGui::GetDrawListSharedData() or create and use your own ImDrawListSharedData (so you can use ImDrawList without ImGui)
	ImDrawList( const ImDrawListSharedData* shared_data )
	{
		_Data = shared_data; _OwnerName = NULL; Clear();
	}
	~ImDrawList()
	{
		ClearFreeMemory();
	}
	IMGUI_API void  PushClipRect( ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false );  // Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
	IMGUI_API void  PushClipRectFullScreen();
	IMGUI_API void  PopClipRect();
	IMGUI_API void  PushTextureID( ImTextureID texture_id );
	IMGUI_API void  PopTextureID();
	inline ImVec2   GetClipRectMin() const
	{
		const ImVec4& cr = _ClipRectStack.back(); return ImVec2( cr.x, cr.y );
	}
	inline ImVec2   GetClipRectMax() const
	{
		const ImVec4& cr = _ClipRectStack.back(); return ImVec2( cr.z, cr.w );
	}

	// Primitives
	// - For rectangular primitives, "p_min" and "p_max" represent the upper-left and lower-right corners.
	// - For circle primitives, use "num_segments == 0" to automatically calculate tessellation (preferred).
	//   In future versions we will use textures to provide cheaper and higher-quality circles.
	//   Use AddNgon() and AddNgonFilled() functions if you need to guaranteed a specific number of sides.
	IMGUI_API void  AddLine( const ImVec2& p1, const ImVec2& p2, ImU32 col, float thickness = 1.0f );
	IMGUI_API void  AddRect( const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding = 0.0f, ImDrawCornerFlags rounding_corners = ImDrawCornerFlags_All, float thickness = 1.0f );   // a: upper-left, b: lower-right (== upper-left + size), rounding_corners_flags: 4 bits corresponding to which corner to round
	IMGUI_API void  AddRectFilled( const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding = 0.0f, ImDrawCornerFlags rounding_corners = ImDrawCornerFlags_All );                     // a: upper-left, b: lower-right (== upper-left + size)
	IMGUI_API void  AddRectFilledMultiColor( const ImVec2& p_min, const ImVec2& p_max, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left );
	IMGUI_API void  AddQuad( const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness = 1.0f );
	IMGUI_API void  AddQuadFilled( const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col );
	IMGUI_API void  AddTriangle( const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness = 1.0f );
	IMGUI_API void  AddTriangleFilled( const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col );
	IMGUI_API void  AddCircle( const ImVec2& center, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f );
	IMGUI_API void  AddCircleFilled( const ImVec2& center, float radius, ImU32 col, int num_segments = 12 );
	IMGUI_API void  AddNgon( const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness = 1.0f );
	IMGUI_API void  AddNgonFilled( const ImVec2& center, float radius, ImU32 col, int num_segments );
	IMGUI_API void  AddText( const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL );
	IMGUI_API void  AddText( const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL );
	IMGUI_API void  AddPolyline( const ImVec2* points, int num_points, ImU32 col, bool closed, float thickness );
	IMGUI_API void  AddConvexPolyFilled( const ImVec2* points, int num_points, ImU32 col ); // Note: Anti-aliased filling requires points to be in clockwise order.
	IMGUI_API void  AddBezierCurve( const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments = 0 );

	// Image primitives
	// - Read FAQ to understand what ImTextureID is.
	// - "p_min" and "p_max" represent the upper-left and lower-right corners of the rectangle.
	// - "uv_min" and "uv_max" represent the normalized texture coordinates to use for those corners. Using (0,0)->(1,1) texture coordinates will generally display the entire texture.
	IMGUI_API void  AddImage( ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min = ImVec2( 0, 0 ), const ImVec2& uv_max = ImVec2( 1, 1 ), ImU32 col = IM_COL32_WHITE );
	IMGUI_API void  AddImageQuad( ImTextureID user_texture_id, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& uv1 = ImVec2( 0, 0 ), const ImVec2& uv2 = ImVec2( 1, 0 ), const ImVec2& uv3 = ImVec2( 1, 1 ), const ImVec2& uv4 = ImVec2( 0, 1 ), ImU32 col = IM_COL32_WHITE );
	IMGUI_API void  AddImageRounded( ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min, const ImVec2& uv_max, ImU32 col, float rounding, ImDrawCornerFlags rounding_corners = ImDrawCornerFlags_All );

	// Stateful path API, add points then finish with PathFillConvex() or PathStroke()
	inline    void  PathClear()
	{
		_Path.Size = 0;
	}
	inline    void  PathLineTo( const ImVec2& pos )
	{
		_Path.push_back( pos );
	}
	inline    void  PathLineToMergeDuplicate( const ImVec2& pos )
	{
		if( _Path.Size == 0 || memcmp( &_Path.Data[ _Path.Size - 1 ], &pos, 8 ) != 0 ) _Path.push_back( pos );
	}
	inline    void  PathFillConvex( ImU32 col )
	{
		AddConvexPolyFilled( _Path.Data, _Path.Size, col ); _Path.Size = 0;
	}  // Note: Anti-aliased filling requires points to be in clockwise order.
	inline    void  PathStroke( ImU32 col, bool closed, float thickness = 1.0f )
	{
		AddPolyline( _Path.Data, _Path.Size, col, closed, thickness ); _Path.Size = 0;
	}
	IMGUI_API void  PathArcTo( const ImVec2& center, float radius, float a_min, float a_max, int num_segments = 10 );
	IMGUI_API void  PathArcToFast( const ImVec2& center, float radius, int a_min_of_12, int a_max_of_12 );                                            // Use precomputed angles for a 12 steps circle
	IMGUI_API void  PathBezierCurveTo( const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments = 0 );
	IMGUI_API void  PathRect( const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, ImDrawCornerFlags rounding_corners = ImDrawCornerFlags_All );

	// Advanced
	IMGUI_API void  AddCallback( ImDrawCallback callback, void* callback_data );  // Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.
	IMGUI_API void  AddDrawCmd();                                               // This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible
	IMGUI_API ImDrawList* CloneOutput() const;                                  // Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.

	// Advanced: Channels
	// - Use to split render into layers. By switching channels to can render out-of-order (e.g. submit FG primitives before BG primitives)
	// - Use to minimize draw calls (e.g. if going back-and-forth between multiple clipping rectangles, prefer to append into separate channels then merge at the end)
	// - FIXME-OBSOLETE: This API shouldn't have been in ImDrawList in the first place!
	//   Prefer using your own persistent copy of ImDrawListSplitter as you can stack them.
	//   Using the ImDrawList::ChannelsXXXX you cannot stack a split over another.
	inline void     ChannelsSplit( int count )
	{
		_Splitter.Split( this, count );
	}
	inline void     ChannelsMerge()
	{
		_Splitter.Merge( this );
	}
	inline void     ChannelsSetCurrent( int n )
	{
		_Splitter.SetCurrentChannel( this, n );
	}

	// Internal helpers
	// NB: all primitives needs to be reserved via PrimReserve() beforehand!
	IMGUI_API void  Clear();
	IMGUI_API void  ClearFreeMemory();
	IMGUI_API void  PrimReserve( int idx_count, int vtx_count );
	IMGUI_API void  PrimUnreserve( int idx_count, int vtx_count );
	IMGUI_API void  PrimRect( const ImVec2& a, const ImVec2& b, ImU32 col );      // Axis aligned rectangle (composed of two triangles)
	IMGUI_API void  PrimRectUV( const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col );
	IMGUI_API void  PrimQuadUV( const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col );
	inline    void  PrimWriteVtx( const ImVec2& pos, const ImVec2& uv, ImU32 col )
	{
		_VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++;
	}
	inline    void  PrimWriteIdx( ImDrawIdx idx )
	{
		*_IdxWritePtr = idx; _IdxWritePtr++;
	}
	inline    void  PrimVtx( const ImVec2& pos, const ImVec2& uv, ImU32 col )
	{
		PrimWriteIdx( ( ImDrawIdx )_VtxCurrentIdx ); PrimWriteVtx( pos, uv, col );
	}
	IMGUI_API void  UpdateClipRect();
	IMGUI_API void  UpdateTextureID();
};

// All draw data to render a Dear ImGui frame
// (NB: the style and the naming convention here is a little inconsistent, we currently preserve them for backward compatibility purpose,
// as this is one of the oldest structure exposed by the library! Basically, ImDrawList == CmdList)
struct ImDrawData
{
	bool            Valid;                  // Only valid after Render() is called and before the next NewFrame() is called.
	ImDrawList** CmdLists;               // Array of ImDrawList* to render. The ImDrawList are owned by ImGuiContext and only pointed to from here.
	int             CmdListsCount;          // Number of ImDrawList* to render
	int             TotalIdxCount;          // For convenience, sum of all ImDrawList's IdxBuffer.Size
	int             TotalVtxCount;          // For convenience, sum of all ImDrawList's VtxBuffer.Size
	ImVec2          DisplayPos;             // Upper-left position of the viewport to render (== upper-left of the orthogonal projection matrix to use)
	ImVec2          DisplaySize;            // Size of the viewport to render (== io.DisplaySize for the main viewport) (DisplayPos + DisplaySize == lower-right of the orthogonal projection matrix to use)
	ImVec2          FramebufferScale;       // Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.

	// Functions
	ImDrawData()
	{
		Valid = false; Clear();
	}
	~ImDrawData()
	{
		Clear();
	}
	void Clear()
	{
		Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; DisplayPos = DisplaySize = FramebufferScale = ImVec2( 0.f, 0.f );
	} // The ImDrawList are owned by ImGuiContext!
	IMGUI_API void  DeIndexAllBuffers();                    // Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
	IMGUI_API void  ScaleClipRects( const ImVec2& fb_scale ); // Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than Dear ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.
};

//-----------------------------------------------------------------------------
// Font API (ImFontConfig, ImFontGlyph, ImFontAtlasFlags, ImFontAtlas, ImFontGlyphRangesBuilder, ImFont)
//-----------------------------------------------------------------------------

struct ImFontConfig
{
	void* FontData;               //          // TTF/OTF data
	int             FontDataSize;           //          // TTF/OTF data size
	bool            FontDataOwnedByAtlas;   // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
	int             FontNo;                 // 0        // Index of font within TTF/OTF file
	float           SizePixels;             //          // Size in pixels for rasterizer (more or less maps to the resulting font height).
	int             OversampleH;            // 3        // Rasterize at higher quality for sub-pixel positioning. Read https://github.com/nothings/stb/blob/master/tests/oversample/README.md for details.
	int             OversampleV;            // 1        // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.
	bool            PixelSnapH;             // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
	ImVec2          GlyphExtraSpacing;      // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.
	ImVec2          GlyphOffset;            // 0, 0     // Offset all glyphs from this font input.
	const ImWchar* GlyphRanges;            // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.
	float           GlyphMinAdvanceX;       // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font
	float           GlyphMaxAdvanceX;       // FLT_MAX  // Maximum AdvanceX for glyphs
	bool            MergeMode;              // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
	unsigned int    RasterizerFlags;        // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.
	float           RasterizerMultiply;     // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.
	ImWchar         EllipsisChar;           // -1       // Explicitly specify unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.

	// [Internal]
	char            Name[ 40 ];               // Name (strictly to ease debugging)
	ImFont* DstFont;

	IMGUI_API ImFontConfig();
};

// Hold rendering data for one glyph.
// (Note: some language parsers may fail to convert the 31+1 bitfield members, in this case maybe drop store a single u32 or we can rework this)
struct ImFontGlyph
{
	unsigned int    Codepoint : 31;     // 0x0000..0xFFFF
	unsigned int    Visible : 1;        // Flag to allow early out when rendering
	float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)
	float           X0, Y0, X1, Y1;     // Glyph corners
	float           U0, V0, U1, V1;     // Texture coordinates
};

// Helper to build glyph ranges from text/string data. Feed your application strings/characters to it then call BuildRanges().
// This is essentially a tightly packed of vector of 64k booleans = 8KB storage.
struct ImFontGlyphRangesBuilder
{
	ImVector<ImU32> UsedChars;            // Store 1-bit per Unicode code point (0=unused, 1=used)

	ImFontGlyphRangesBuilder()
	{
		Clear();
	}
	inline void     Clear()
	{
		int size_in_bytes = ( IM_UNICODE_CODEPOINT_MAX + 1 ) / 8; UsedChars.resize( size_in_bytes / ( int )sizeof( ImU32 ) ); memset( UsedChars.Data, 0, ( size_t )size_in_bytes );
	}
	inline bool     GetBit( size_t n ) const
	{
		int off = ( int )( n >> 5 ); ImU32 mask = 1u << ( n & 31 ); return ( UsedChars[ off ] & mask ) != 0;
	}  // Get bit n in the array
	inline void     SetBit( size_t n )
	{
		int off = ( int )( n >> 5 ); ImU32 mask = 1u << ( n & 31 ); UsedChars[ off ] |= mask;
	}               // Set bit n in the array
	inline void     AddChar( ImWchar c )
	{
		SetBit( c );
	}                      // Add character
	IMGUI_API void  AddText( const char* text, const char* text_end = NULL );     // Add string (each character of the UTF-8 string are added)
	IMGUI_API void  AddRanges( const ImWchar* ranges );                           // Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault()) to force add all of ASCII/Latin+Ext
	IMGUI_API void  BuildRanges( ImVector<ImWchar>* out_ranges );                 // Output new ranges
};

// See ImFontAtlas::AddCustomRectXXX functions.
struct ImFontAtlasCustomRect
{
	unsigned short  Width, Height;  // Input    // Desired rectangle dimension
	unsigned short  X, Y;           // Output   // Packed position in Atlas
	unsigned int    GlyphID;        // Input    // For custom font glyphs only (ID < 0x110000)
	float           GlyphAdvanceX;  // Input    // For custom font glyphs only: glyph xadvance
	ImVec2          GlyphOffset;    // Input    // For custom font glyphs only: glyph display offset
	ImFont* Font;           // Input    // For custom font glyphs only: target font
	ImFontAtlasCustomRect()
	{
		Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2( 0, 0 ); Font = NULL;
	}
	bool IsPacked() const
	{
		return X != 0xFFFF;
	}
};

enum ImFontAtlasFlags_
{
	ImFontAtlasFlags_None = 0,
	ImFontAtlasFlags_NoPowerOfTwoHeight = 1 << 0,   // Don't round the height to next power of two
	ImFontAtlasFlags_NoMouseCursors = 1 << 1    // Don't build software mouse cursors into the atlas
};

// Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:
//  - One or more fonts.
//  - Custom graphics data needed to render the shapes needed by Dear ImGui.
//  - Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).
// It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api.
//  - Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you.
//  - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.
//  - Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples)
//  - Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API.
//    This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details.
// Common pitfalls:
// - If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the
//   atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.
// - Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.
//   You can set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed,
// - Even though many functions are suffixed with "TTF", OTF data is supported just as well.
// - This is an old API and it is currently awkward for those and and various other reasons! We will address them in the future!
struct ImFontAtlas
{
	IMGUI_API ImFontAtlas();
	IMGUI_API ~ImFontAtlas();
	IMGUI_API ImFont* AddFont( const ImFontConfig* font_cfg );
	IMGUI_API ImFont* AddFontDefault( const ImFontConfig* font_cfg = NULL );
	IMGUI_API ImFont* AddFontFromFileTTF( const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL );
	IMGUI_API ImFont* AddFontFromMemoryTTF( void* font_data, int font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL ); // Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.
	IMGUI_API ImFont* AddFontFromMemoryCompressedTTF( const void* compressed_font_data, int compressed_font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL ); // 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.
	IMGUI_API ImFont* AddFontFromMemoryCompressedBase85TTF( const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL );              // 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.
	IMGUI_API void              ClearInputData();           // Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.
	IMGUI_API void              ClearTexData();             // Clear output texture data (CPU side). Saves RAM once the texture has been copied to graphics memory.
	IMGUI_API void              ClearFonts();               // Clear output font data (glyphs storage, UV coordinates).
	IMGUI_API void              Clear();                    // Clear all input and output.

	// Build atlas, retrieve pixel data.
	// User is in charge of copying the pixels into graphics memory (e.g. create a texture with your engine). Then store your texture handle with SetTexID().
	// The pitch is always = Width * BytesPerPixels (1 or 4)
	// Building in RGBA32 format is provided for convenience and compatibility, but note that unless you manually manipulate or copy color data into
	// the texture (e.g. when using the AddCustomRect*** api), then the RGB pixels emitted will always be white (~75% of memory/bandwidth waste.
	IMGUI_API bool              Build();                    // Build pixels data. This is called automatically for you by the GetTexData*** functions.
	IMGUI_API void              GetTexDataAsAlpha8( unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL );  // 1 byte per-pixel
	IMGUI_API void              GetTexDataAsRGBA32( unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL );  // 4 bytes-per-pixel
	bool                        IsBuilt() const
	{
		return Fonts.Size > 0 && ( TexPixelsAlpha8 != NULL || TexPixelsRGBA32 != NULL );
	}
	void                        SetTexID( ImTextureID id )
	{
		TexID = id;
	}

	//-------------------------------------------
	// Glyph Ranges
	//-------------------------------------------

	// Helpers to retrieve list of common Unicode ranges (2 value per range, values are inclusive, zero-terminated list)
	// NB: Make sure that your string are UTF-8 and NOT in your local code page. In C++11, you can create UTF-8 string literal using the u8"Hello world" syntax. See FAQ for details.
	// NB: Consider using ImFontGlyphRangesBuilder to build glyph ranges from textual data.
	IMGUI_API const ImWchar* GetGlyphRangesDefault();                // Basic Latin, Extended Latin
	IMGUI_API const ImWchar* GetGlyphRangesKorean();                 // Default + Korean characters
	IMGUI_API const ImWchar* GetGlyphRangesJapanese();               // Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs
	IMGUI_API const ImWchar* GetGlyphRangesChineseFull();            // Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs
	IMGUI_API const ImWchar* GetGlyphRangesChineseSimplifiedCommon();// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese
	IMGUI_API const ImWchar* GetGlyphRangesCyrillic();               // Default + about 400 Cyrillic characters
	IMGUI_API const ImWchar* GetGlyphRangesThai();                   // Default + Thai characters
	IMGUI_API const ImWchar* GetGlyphRangesVietnamese();             // Default + Vietnamese characters

	//-------------------------------------------
	// [BETA] Custom Rectangles/Glyphs API
	//-------------------------------------------

	// You can request arbitrary rectangles to be packed into the atlas, for your own purposes.
	// After calling Build(), you can query the rectangle position and render your pixels.
	// You can also request your rectangles to be mapped as font glyph (given a font + Unicode point),
	// so you can render e.g. custom colorful icons and use them as regular glyphs.
	// Read docs/FONTS.txt for more details about using colorful icons.
	// Note: this API may be redesigned later in order to support multi-monitor varying DPI settings.
	IMGUI_API int               AddCustomRectRegular( int width, int height );
	IMGUI_API int               AddCustomRectFontGlyph( ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2( 0, 0 ) );
	const ImFontAtlasCustomRect* GetCustomRectByIndex( int index ) const
	{
		if( index < 0 ) return NULL; return &CustomRects[ index ];
	}

	// [Internal]
	IMGUI_API void              CalcCustomRectUV( const ImFontAtlasCustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max ) const;
	IMGUI_API bool              GetMouseCursorTexData( ImGuiMouseCursor cursor, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[ 2 ], ImVec2 out_uv_fill[ 2 ] );

	//-------------------------------------------
	// Members
	//-------------------------------------------

	bool                        Locked;             // Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.
	ImFontAtlasFlags            Flags;              // Build flags (see ImFontAtlasFlags_)
	ImTextureID                 TexID;              // User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.
	int                         TexDesiredWidth;    // Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.
	int                         TexGlyphPadding;    // Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0.

	// [Internal]
	// NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.
	unsigned char* TexPixelsAlpha8;    // 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight
	unsigned int* TexPixelsRGBA32;    // 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4
	int                         TexWidth;           // Texture width calculated during Build().
	int                         TexHeight;          // Texture height calculated during Build().
	ImVec2                      TexUvScale;         // = (1.0f/TexWidth, 1.0f/TexHeight)
	ImVec2                      TexUvWhitePixel;    // Texture coordinates to a white pixel
	ImVector<ImFont*>           Fonts;              // Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.
	ImVector<ImFontAtlasCustomRect> CustomRects;    // Rectangles for packing custom texture data into the atlas.
	ImVector<ImFontConfig>      ConfigData;         // Internal data
	int                         CustomRectIds[ 1 ];   // Identifiers of custom texture rectangle used by ImFontAtlas/ImDrawList

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
	typedef ImFontAtlasCustomRect    CustomRect;         // OBSOLETED in 1.72+
	typedef ImFontGlyphRangesBuilder GlyphRangesBuilder; // OBSOLETED in 1.67+
#endif
};

// Font runtime data and rendering
// ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().
struct ImFont
{
	// Members: Hot ~20/24 bytes (for CalcTextSize)
	ImVector<float>             IndexAdvanceX;      // 12-16 // out //            // Sparse. Glyphs->AdvanceX in a directly indexable way (cache-friendly for CalcTextSize functions which only this this info, and are often bottleneck in large UI).
	float                       FallbackAdvanceX;   // 4     // out // = FallbackGlyph->AdvanceX
	float                       FontSize;           // 4     // in  //            // Height of characters/line, set during loading (don't change after loading)

	// Members: Hot ~36/48 bytes (for CalcTextSize + render loop)
	ImVector<ImWchar>           IndexLookup;        // 12-16 // out //            // Sparse. Index glyphs by Unicode code-point.
	ImVector<ImFontGlyph>       Glyphs;             // 12-16 // out //            // All glyphs.
	const ImFontGlyph* FallbackGlyph;      // 4-8   // out // = FindGlyph(FontFallbackChar)
	ImVec2                      DisplayOffset;      // 8     // in  // = (0,0)    // Offset font rendering by xx pixels

	// Members: Cold ~32/40 bytes
	ImFontAtlas* ContainerAtlas;     // 4-8   // out //            // What we has been loaded into
	const ImFontConfig* ConfigData;         // 4-8   // in  //            // Pointer within ContainerAtlas->ConfigData
	short                       ConfigDataCount;    // 2     // in  // ~ 1        // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.
	ImWchar                     FallbackChar;       // 2     // in  // = '?'      // Replacement character if a glyph isn't found. Only set via SetFallbackChar()
	ImWchar                     EllipsisChar;       // 2     // out // = -1       // Character used for ellipsis rendering.
	bool                        DirtyLookupTables;  // 1     // out //
	float                       Scale;              // 4     // in  // = 1.f      // Base font scale, multiplied by the per-window font scale which you can adjust with SetWindowFontScale()
	float                       Ascent, Descent;    // 4+4   // out //            // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]
	int                         MetricsTotalSurface;// 4     // out //            // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)
	ImU8                        Used4kPagesMap[ ( IM_UNICODE_CODEPOINT_MAX + 1 ) / 4096 / 8 ]; // 2 bytes if ImWchar=ImWchar16, 34 bytes if ImWchar==ImWchar32. Store 1-bit for each block of 4K codepoints that has one active glyph. This is mainly used to facilitate iterations across all used codepoints.

	// Methods
	IMGUI_API ImFont();
	IMGUI_API ~ImFont();
	IMGUI_API const ImFontGlyph* FindGlyph( ImWchar c ) const;
	IMGUI_API const ImFontGlyph* FindGlyphNoFallback( ImWchar c ) const;
	float                       GetCharAdvance( ImWchar c ) const
	{
		return ( ( int )c < IndexAdvanceX.Size ) ? IndexAdvanceX[ ( int )c ] : FallbackAdvanceX;
	}
	bool                        IsLoaded() const
	{
		return ContainerAtlas != NULL;
	}
	const char* GetDebugName() const
	{
		return ConfigData ? ConfigData->Name : "<unknown>";
	}

	// 'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.
	// 'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.
	IMGUI_API ImVec2            CalcTextSizeA( float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL ) const; // utf8
	IMGUI_API const char* CalcWordWrapPositionA( float scale, const char* text, const char* text_end, float wrap_width ) const;
	IMGUI_API void              RenderChar( ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, ImWchar c ) const;
	IMGUI_API void              RenderText( ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false ) const;

	// [Internal] Don't use!
	IMGUI_API void              BuildLookupTable();
	IMGUI_API void              ClearOutputData();
	IMGUI_API void              GrowIndex( int new_size );
	IMGUI_API void              AddGlyph( ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x );
	IMGUI_API void              AddRemapChar( ImWchar dst, ImWchar src, bool overwrite_dst = true ); // Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.
	IMGUI_API void              SetGlyphVisible( ImWchar c, bool visible );
	IMGUI_API void              SetFallbackChar( ImWchar c );
	IMGUI_API bool              IsGlyphRangeUnused( unsigned int c_begin, unsigned int c_last );
};

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

// Include imgui_user.h at the end of imgui.h (convenient for user to only explicitly include vanilla imgui.h)
#ifdef IMGUI_INCLUDE_IMGUI_USER_H
#include "imgui_user.h"
#endif

#endif // #ifndef IMGUI_DISABLE
```

`horizon/imgui/imgui_draw.cpp`:

```cpp
// dear imgui, v1.77 WIP
// (drawing and font code)

/*

Index of this file:

// [SECTION] STB libraries implementation
// [SECTION] Style functions
// [SECTION] ImDrawList
// [SECTION] ImDrawListSplitter
// [SECTION] ImDrawData
// [SECTION] Helpers ShadeVertsXXX functions
// [SECTION] ImFontConfig
// [SECTION] ImFontAtlas
// [SECTION] ImFontAtlas glyph ranges helpers
// [SECTION] ImFontGlyphRangesBuilder
// [SECTION] ImFont
// [SECTION] ImGui Internal Render Helpers
// [SECTION] Decompression code
// [SECTION] Default font data (ProggyClean.ttf)

*/

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.hpp"

// Atom includes
#include "../constant/character.hpp"
#include "../constant/hash.hpp"
#include "../constant/secure_string.hpp"
#include "../constant/string.hpp"

#include "../win32/math.hpp"
#include "../win32/string.hpp"

using namespace horizon;

#ifndef IMGUI_DISABLE

#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif
#include "imgui_internal.hpp"

#include <stdio.h>      // vsnprintf, sscanf, printf
#if !defined(alloca)
#if defined(__GLIBC__) || defined(__sun) || defined(__APPLE__) || defined(__NEWLIB__)
#include <alloca.h>     // alloca (glibc uses <alloca.h>. Note that Cygwin may have _WIN32 defined, so the order matters here)
#elif defined(_WIN32)
#include <malloc.h>     // alloca
#if !defined(alloca)
#define alloca _alloca  // for clang with MS Codegen
#endif
#else
#include <stdlib.h>     // alloca
#endif
#endif

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4127) // condition expression is constant
#pragma warning (disable: 4505) // unreferenced local function has been removed (stb stuff)
#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#pragma clang diagnostic ignored "-Wold-style-cast"         // warning : use of old-style cast                              // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants ok.
#pragma clang diagnostic ignored "-Wglobal-constructors"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference is.
#pragma clang diagnostic ignored "-Wsign-conversion"        // warning : implicit conversion changes signedness             //
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning : zero as null pointer constant              // some standard header variations use #define NULL 0
#endif
#if __has_warning("-Wcomma")
#pragma clang diagnostic ignored "-Wcomma"                  // warning : possible misuse of comma operator here             //
#endif
#if __has_warning("-Wreserved-id-macro")
#pragma clang diagnostic ignored "-Wreserved-id-macro"      // warning : macro name is a reserved identifier                //
#endif
#if __has_warning("-Wdouble-promotion")
#pragma clang diagnostic ignored "-Wdouble-promotion"       // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#endif
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wpragmas"                  // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wunused-function"          // warning: 'xxxx' defined but not used
#pragma GCC diagnostic ignored "-Wdouble-promotion"         // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored "-Wconversion"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value
#pragma GCC diagnostic ignored "-Wstack-protector"          // warning: stack protector not protecting local variables: variable length buffer
#pragma GCC diagnostic ignored "-Wclass-memaccess"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif

//-------------------------------------------------------------------------
// [SECTION] STB libraries implementation
//-------------------------------------------------------------------------

// Compile time options:
//#define IMGUI_STB_NAMESPACE           ImStb
//#define IMGUI_STB_TRUETYPE_FILENAME   "my_folder/stb_truetype.h"
//#define IMGUI_STB_RECT_PACK_FILENAME  "my_folder/stb_rect_pack.h"
//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION

#ifdef IMGUI_STB_NAMESPACE
namespace IMGUI_STB_NAMESPACE
{
#endif

#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable: 4456)                             // declaration of 'xx' hides previous local declaration
#endif

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wimplicit-fallthrough"
#pragma clang diagnostic ignored "-Wcast-qual"              // warning : cast from 'const xxxx *' to 'xxx *' drops const qualifier //
#endif

#if defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wtype-limits"              // warning: comparison is always true due to limited range of data type [-Wtype-limits]
#pragma GCC diagnostic ignored "-Wcast-qual"                // warning: cast from type 'const xxxx *' to type 'xxxx *' casts away qualifiers
#endif

#ifndef STB_RECT_PACK_IMPLEMENTATION                        // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)
#ifndef IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION
#define STBRP_STATIC
#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
#define STBRP_SORT          ImQsort
#define STB_RECT_PACK_IMPLEMENTATION
#endif
#ifdef IMGUI_STB_RECT_PACK_FILENAME
#include IMGUI_STB_RECT_PACK_FILENAME
#else
#include "imstb_rectpack.hpp"
#endif
#endif

#ifndef STB_TRUETYPE_IMPLEMENTATION                         // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)
#ifndef IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
#define STBTT_fmod(x,y)     ImFmod(x,y)
#define STBTT_sqrt(x)       ImSqrt(x)
#define STBTT_pow(x,y)      ImPow(x,y)
#define STBTT_fabs(x)       ImFabs(x)
#define STBTT_ifloor(x)     ((int)ImFloorStd(x))
#define STBTT_iceil(x)      ((int)ImCeil(x))
#define STBTT_STATIC
#define STB_TRUETYPE_IMPLEMENTATION
#else
#define STBTT_DEF extern
#endif
#ifdef IMGUI_STB_TRUETYPE_FILENAME
#include IMGUI_STB_TRUETYPE_FILENAME
#else
#include "imstb_truetype.hpp"
#endif
#endif

#if defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

#if defined(__clang__)
#pragma clang diagnostic pop
#endif

#if defined(_MSC_VER)
#pragma warning (pop)
#endif

#ifdef IMGUI_STB_NAMESPACE
} // namespace ImStb
using namespace IMGUI_STB_NAMESPACE;
#endif

//-----------------------------------------------------------------------------
// [SECTION] Style functions
//-----------------------------------------------------------------------------

void ImGui::StyleColorsDark( ImGuiStyle* dst )
{
  ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
  ImVec4* colors = style->Colors;

  colors[ ImGuiCol_Text ] = ImVec4( 1.00f, 1.00f, 1.00f, 1.00f );
  colors[ ImGuiCol_TextDisabled ] = ImVec4( 0.50f, 0.50f, 0.50f, 1.00f );
  colors[ ImGuiCol_WindowBg ] = ImVec4( 0.06f, 0.06f, 0.06f, 0.94f );
  colors[ ImGuiCol_ChildBg ] = ImVec4( 0.00f, 0.00f, 0.00f, 0.00f );
  colors[ ImGuiCol_PopupBg ] = ImVec4( 0.08f, 0.08f, 0.08f, 0.94f );
  colors[ ImGuiCol_Border ] = ImVec4( 0.43f, 0.43f, 0.50f, 0.50f );
  colors[ ImGuiCol_BorderShadow ] = ImVec4( 0.00f, 0.00f, 0.00f, 0.00f );
  colors[ ImGuiCol_FrameBg ] = ImVec4( 0.16f, 0.29f, 0.48f, 0.54f );
  colors[ ImGuiCol_FrameBgHovered ] = ImVec4( 0.26f, 0.59f, 0.98f, 0.40f );
  colors[ ImGuiCol_FrameBgActive ] = ImVec4( 0.26f, 0.59f, 0.98f, 0.67f );
  colors[ ImGuiCol_TitleBg ] = ImVec4( 0.04f, 0.04f, 0.04f, 1.00f );
  colors[ ImGuiCol_TitleBgActive ] = ImVec4( 0.16f, 0.29f, 0.48f, 1.00f );
  colors[ ImGuiCol_TitleBgCollapsed ] = ImVec4( 0.00f, 0.00f, 0.00f, 0.51f );
  colors[ ImGuiCol_MenuBarBg ] = ImVec4( 0.14f, 0.14f, 0.14f, 1.00f );
  colors[ ImGuiCol_ScrollbarBg ] = ImVec4( 0.02f, 0.02f, 0.02f, 0.53f );
  colors[ ImGuiCol_ScrollbarGrab ] = ImVec4( 0.31f, 0.31f, 0.31f, 1.00f );
  colors[ ImGuiCol_ScrollbarGrabHovered ] = ImVec4( 0.41f, 0.41f, 0.41f, 1.00f );
  colors[ ImGuiCol_ScrollbarGrabActive ] = ImVec4( 0.51f, 0.51f, 0.51f, 1.00f );
  colors[ ImGuiCol_CheckMark ] = ImVec4( 0.26f, 0.59f, 0.98f, 1.00f );
  colors[ ImGuiCol_SliderGrab ] = ImVec4( 0.24f, 0.52f, 0.88f, 1.00f );
  colors[ ImGuiCol_SliderGrabActive ] = ImVec4( 0.26f, 0.59f, 0.98f, 1.00f );
  colors[ ImGuiCol_Button ] = ImVec4( 0.26f, 0.59f, 0.98f, 0.40f );
  colors[ ImGuiCol_ButtonHovered ] = ImVec4( 0.26f, 0.59f, 0.98f, 1.00f );
  colors[ ImGuiCol_ButtonActive ] = ImVec4( 0.06f, 0.53f, 0.98f, 1.00f );
  colors[ ImGuiCol_Header ] = ImVec4( 0.26f, 0.59f, 0.98f, 0.31f );
  colors[ ImGuiCol_HeaderHovered ] = ImVec4( 0.26f, 0.59f, 0.98f, 0.80f );
  colors[ ImGuiCol_HeaderActive ] = ImVec4( 0.26f, 0.59f, 0.98f, 1.00f );
  colors[ ImGuiCol_Separator ] = colors[ ImGuiCol_Border ];
  colors[ ImGuiCol_SeparatorHovered ] = ImVec4( 0.10f, 0.40f, 0.75f, 0.78f );
  colors[ ImGuiCol_SeparatorActive ] = ImVec4( 0.10f, 0.40f, 0.75f, 1.00f );
  colors[ ImGuiCol_ResizeGrip ] = ImVec4( 0.26f, 0.59f, 0.98f, 0.25f );
  colors[ ImGuiCol_ResizeGripHovered ] = ImVec4( 0.26f, 0.59f, 0.98f, 0.67f );
  colors[ ImGuiCol_ResizeGripActive ] = ImVec4( 0.26f, 0.59f, 0.98f, 0.95f );
  colors[ ImGuiCol_Tab ] = ImLerp( colors[ ImGuiCol_Header ], colors[ ImGuiCol_TitleBgActive ], 0.80f );
  colors[ ImGuiCol_TabHovered ] = colors[ ImGuiCol_HeaderHovered ];
  colors[ ImGuiCol_TabActive ] = ImLerp( colors[ ImGuiCol_HeaderActive ], colors[ ImGuiCol_TitleBgActive ], 0.60f );
  colors[ ImGuiCol_TabUnfocused ] = ImLerp( colors[ ImGuiCol_Tab ], colors[ ImGuiCol_TitleBg ], 0.80f );
  colors[ ImGuiCol_TabUnfocusedActive ] = ImLerp( colors[ ImGuiCol_TabActive ], colors[ ImGuiCol_TitleBg ], 0.40f );
  colors[ ImGuiCol_PlotLines ] = ImVec4( 0.61f, 0.61f, 0.61f, 1.00f );
  colors[ ImGuiCol_PlotLinesHovered ] = ImVec4( 1.00f, 0.43f, 0.35f, 1.00f );
  colors[ ImGuiCol_PlotHistogram ] = ImVec4( 0.90f, 0.70f, 0.00f, 1.00f );
  colors[ ImGuiCol_PlotHistogramHovered ] = ImVec4( 1.00f, 0.60f, 0.00f, 1.00f );
  colors[ ImGuiCol_TextSelectedBg ] = ImVec4( 0.26f, 0.59f, 0.98f, 0.35f );
  colors[ ImGuiCol_DragDropTarget ] = ImVec4( 1.00f, 1.00f, 0.00f, 0.90f );
  colors[ ImGuiCol_NavHighlight ] = ImVec4( 0.26f, 0.59f, 0.98f, 1.00f );
  colors[ ImGuiCol_NavWindowingHighlight ] = ImVec4( 1.00f, 1.00f, 1.00f, 0.70f );
  colors[ ImGuiCol_NavWindowingDimBg ] = ImVec4( 0.80f, 0.80f, 0.80f, 0.20f );
  colors[ ImGuiCol_ModalWindowDimBg ] = ImVec4( 0.80f, 0.80f, 0.80f, 0.35f );
}

void ImGui::StyleColorsClassic( ImGuiStyle* dst )
{
  ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
  ImVec4* colors = style->Colors;

  colors[ ImGuiCol_Text ] = ImVec4( 0.90f, 0.90f, 0.90f, 1.00f );
  colors[ ImGuiCol_TextDisabled ] = ImVec4( 0.60f, 0.60f, 0.60f, 1.00f );
  colors[ ImGuiCol_WindowBg ] = ImVec4( 0.00f, 0.00f, 0.00f, 0.70f );
  colors[ ImGuiCol_ChildBg ] = ImVec4( 0.00f, 0.00f, 0.00f, 0.00f );
  colors[ ImGuiCol_PopupBg ] = ImVec4( 0.11f, 0.11f, 0.14f, 0.92f );
  colors[ ImGuiCol_Border ] = ImVec4( 0.50f, 0.50f, 0.50f, 0.50f );
  colors[ ImGuiCol_BorderShadow ] = ImVec4( 0.00f, 0.00f, 0.00f, 0.00f );
  colors[ ImGuiCol_FrameBg ] = ImVec4( 0.43f, 0.43f, 0.43f, 0.39f );
  colors[ ImGuiCol_FrameBgHovered ] = ImVec4( 0.47f, 0.47f, 0.69f, 0.40f );
  colors[ ImGuiCol_FrameBgActive ] = ImVec4( 0.42f, 0.41f, 0.64f, 0.69f );
  colors[ ImGuiCol_TitleBg ] = ImVec4( 0.27f, 0.27f, 0.54f, 0.83f );
  colors[ ImGuiCol_TitleBgActive ] = ImVec4( 0.32f, 0.32f, 0.63f, 0.87f );
  colors[ ImGuiCol_TitleBgCollapsed ] = ImVec4( 0.40f, 0.40f, 0.80f, 0.20f );
  colors[ ImGuiCol_MenuBarBg ] = ImVec4( 0.40f, 0.40f, 0.55f, 0.80f );
  colors[ ImGuiCol_ScrollbarBg ] = ImVec4( 0.20f, 0.25f, 0.30f, 0.60f );
  colors[ ImGuiCol_ScrollbarGrab ] = ImVec4( 0.40f, 0.40f, 0.80f, 0.30f );
  colors[ ImGuiCol_ScrollbarGrabHovered ] = ImVec4( 0.40f, 0.40f, 0.80f, 0.40f );
  colors[ ImGuiCol_ScrollbarGrabActive ] = ImVec4( 0.41f, 0.39f, 0.80f, 0.60f );
  colors[ ImGuiCol_CheckMark ] = ImVec4( 0.90f, 0.90f, 0.90f, 0.50f );
  colors[ ImGuiCol_SliderGrab ] = ImVec4( 1.00f, 1.00f, 1.00f, 0.30f );
  colors[ ImGuiCol_SliderGrabActive ] = ImVec4( 0.41f, 0.39f, 0.80f, 0.60f );
  colors[ ImGuiCol_Button ] = ImVec4( 0.35f, 0.40f, 0.61f, 0.62f );
  colors[ ImGuiCol_ButtonHovered ] = ImVec4( 0.40f, 0.48f, 0.71f, 0.79f );
  colors[ ImGuiCol_ButtonActive ] = ImVec4( 0.46f, 0.54f, 0.80f, 1.00f );
  colors[ ImGuiCol_Header ] = ImVec4( 0.40f, 0.40f, 0.90f, 0.45f );
  colors[ ImGuiCol_HeaderHovered ] = ImVec4( 0.45f, 0.45f, 0.90f, 0.80f );
  colors[ ImGuiCol_HeaderActive ] = ImVec4( 0.53f, 0.53f, 0.87f, 0.80f );
  colors[ ImGuiCol_Separator ] = ImVec4( 0.50f, 0.50f, 0.50f, 0.60f );
  colors[ ImGuiCol_SeparatorHovered ] = ImVec4( 0.60f, 0.60f, 0.70f, 1.00f );
  colors[ ImGuiCol_SeparatorActive ] = ImVec4( 0.70f, 0.70f, 0.90f, 1.00f );
  colors[ ImGuiCol_ResizeGrip ] = ImVec4( 1.00f, 1.00f, 1.00f, 0.16f );
  colors[ ImGuiCol_ResizeGripHovered ] = ImVec4( 0.78f, 0.82f, 1.00f, 0.60f );
  colors[ ImGuiCol_ResizeGripActive ] = ImVec4( 0.78f, 0.82f, 1.00f, 0.90f );
  colors[ ImGuiCol_Tab ] = ImLerp( colors[ ImGuiCol_Header ], colors[ ImGuiCol_TitleBgActive ], 0.80f );
  colors[ ImGuiCol_TabHovered ] = colors[ ImGuiCol_HeaderHovered ];
  colors[ ImGuiCol_TabActive ] = ImLerp( colors[ ImGuiCol_HeaderActive ], colors[ ImGuiCol_TitleBgActive ], 0.60f );
  colors[ ImGuiCol_TabUnfocused ] = ImLerp( colors[ ImGuiCol_Tab ], colors[ ImGuiCol_TitleBg ], 0.80f );
  colors[ ImGuiCol_TabUnfocusedActive ] = ImLerp( colors[ ImGuiCol_TabActive ], colors[ ImGuiCol_TitleBg ], 0.40f );
  colors[ ImGuiCol_PlotLines ] = ImVec4( 1.00f, 1.00f, 1.00f, 1.00f );
  colors[ ImGuiCol_PlotLinesHovered ] = ImVec4( 0.90f, 0.70f, 0.00f, 1.00f );
  colors[ ImGuiCol_PlotHistogram ] = ImVec4( 0.90f, 0.70f, 0.00f, 1.00f );
  colors[ ImGuiCol_PlotHistogramHovered ] = ImVec4( 1.00f, 0.60f, 0.00f, 1.00f );
  colors[ ImGuiCol_TextSelectedBg ] = ImVec4( 0.00f, 0.00f, 1.00f, 0.35f );
  colors[ ImGuiCol_DragDropTarget ] = ImVec4( 1.00f, 1.00f, 0.00f, 0.90f );
  colors[ ImGuiCol_NavHighlight ] = colors[ ImGuiCol_HeaderHovered ];
  colors[ ImGuiCol_NavWindowingHighlight ] = ImVec4( 1.00f, 1.00f, 1.00f, 0.70f );
  colors[ ImGuiCol_NavWindowingDimBg ] = ImVec4( 0.80f, 0.80f, 0.80f, 0.20f );
  colors[ ImGuiCol_ModalWindowDimBg ] = ImVec4( 0.20f, 0.20f, 0.20f, 0.35f );
}

// Those light colors are better suited with a thicker font than the default one + FrameBorder
void ImGui::StyleColorsLight( ImGuiStyle* dst )
{
  ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
  ImVec4* colors = style->Colors;

  colors[ ImGuiCol_Text ] = ImVec4( 0.00f, 0.00f, 0.00f, 1.00f );
  colors[ ImGuiCol_TextDisabled ] = ImVec4( 0.60f, 0.60f, 0.60f, 1.00f );
  colors[ ImGuiCol_WindowBg ] = ImVec4( 0.94f, 0.94f, 0.94f, 1.00f );
  colors[ ImGuiCol_ChildBg ] = ImVec4( 0.00f, 0.00f, 0.00f, 0.00f );
  colors[ ImGuiCol_PopupBg ] = ImVec4( 1.00f, 1.00f, 1.00f, 0.98f );
  colors[ ImGuiCol_Border ] = ImVec4( 0.00f, 0.00f, 0.00f, 0.30f );
  colors[ ImGuiCol_BorderShadow ] = ImVec4( 0.00f, 0.00f, 0.00f, 0.00f );
  colors[ ImGuiCol_FrameBg ] = ImVec4( 1.00f, 1.00f, 1.00f, 1.00f );
  colors[ ImGuiCol_FrameBgHovered ] = ImVec4( 0.26f, 0.59f, 0.98f, 0.40f );
  colors[ ImGuiCol_FrameBgActive ] = ImVec4( 0.26f, 0.59f, 0.98f, 0.67f );
  colors[ ImGuiCol_TitleBg ] = ImVec4( 0.96f, 0.96f, 0.96f, 1.00f );
  colors[ ImGuiCol_TitleBgActive ] = ImVec4( 0.82f, 0.82f, 0.82f, 1.00f );
  colors[ ImGuiCol_TitleBgCollapsed ] = ImVec4( 1.00f, 1.00f, 1.00f, 0.51f );
  colors[ ImGuiCol_MenuBarBg ] = ImVec4( 0.86f, 0.86f, 0.86f, 1.00f );
  colors[ ImGuiCol_ScrollbarBg ] = ImVec4( 0.98f, 0.98f, 0.98f, 0.53f );
  colors[ ImGuiCol_ScrollbarGrab ] = ImVec4( 0.69f, 0.69f, 0.69f, 0.80f );
  colors[ ImGuiCol_ScrollbarGrabHovered ] = ImVec4( 0.49f, 0.49f, 0.49f, 0.80f );
  colors[ ImGuiCol_ScrollbarGrabActive ] = ImVec4( 0.49f, 0.49f, 0.49f, 1.00f );
  colors[ ImGuiCol_CheckMark ] = ImVec4( 0.26f, 0.59f, 0.98f, 1.00f );
  colors[ ImGuiCol_SliderGrab ] = ImVec4( 0.26f, 0.59f, 0.98f, 0.78f );
  colors[ ImGuiCol_SliderGrabActive ] = ImVec4( 0.46f, 0.54f, 0.80f, 0.60f );
  colors[ ImGuiCol_Button ] = ImVec4( 0.26f, 0.59f, 0.98f, 0.40f );
  colors[ ImGuiCol_ButtonHovered ] = ImVec4( 0.26f, 0.59f, 0.98f, 1.00f );
  colors[ ImGuiCol_ButtonActive ] = ImVec4( 0.06f, 0.53f, 0.98f, 1.00f );
  colors[ ImGuiCol_Header ] = ImVec4( 0.26f, 0.59f, 0.98f, 0.31f );
  colors[ ImGuiCol_HeaderHovered ] = ImVec4( 0.26f, 0.59f, 0.98f, 0.80f );
  colors[ ImGuiCol_HeaderActive ] = ImVec4( 0.26f, 0.59f, 0.98f, 1.00f );
  colors[ ImGuiCol_Separator ] = ImVec4( 0.39f, 0.39f, 0.39f, 0.62f );
  colors[ ImGuiCol_SeparatorHovered ] = ImVec4( 0.14f, 0.44f, 0.80f, 0.78f );
  colors[ ImGuiCol_SeparatorActive ] = ImVec4( 0.14f, 0.44f, 0.80f, 1.00f );
  colors[ ImGuiCol_ResizeGrip ] = ImVec4( 0.80f, 0.80f, 0.80f, 0.56f );
  colors[ ImGuiCol_ResizeGripHovered ] = ImVec4( 0.26f, 0.59f, 0.98f, 0.67f );
  colors[ ImGuiCol_ResizeGripActive ] = ImVec4( 0.26f, 0.59f, 0.98f, 0.95f );
  colors[ ImGuiCol_Tab ] = ImLerp( colors[ ImGuiCol_Header ], colors[ ImGuiCol_TitleBgActive ], 0.90f );
  colors[ ImGuiCol_TabHovered ] = colors[ ImGuiCol_HeaderHovered ];
  colors[ ImGuiCol_TabActive ] = ImLerp( colors[ ImGuiCol_HeaderActive ], colors[ ImGuiCol_TitleBgActive ], 0.60f );
  colors[ ImGuiCol_TabUnfocused ] = ImLerp( colors[ ImGuiCol_Tab ], colors[ ImGuiCol_TitleBg ], 0.80f );
  colors[ ImGuiCol_TabUnfocusedActive ] = ImLerp( colors[ ImGuiCol_TabActive ], colors[ ImGuiCol_TitleBg ], 0.40f );
  colors[ ImGuiCol_PlotLines ] = ImVec4( 0.39f, 0.39f, 0.39f, 1.00f );
  colors[ ImGuiCol_PlotLinesHovered ] = ImVec4( 1.00f, 0.43f, 0.35f, 1.00f );
  colors[ ImGuiCol_PlotHistogram ] = ImVec4( 0.90f, 0.70f, 0.00f, 1.00f );
  colors[ ImGuiCol_PlotHistogramHovered ] = ImVec4( 1.00f, 0.45f, 0.00f, 1.00f );
  colors[ ImGuiCol_TextSelectedBg ] = ImVec4( 0.26f, 0.59f, 0.98f, 0.35f );
  colors[ ImGuiCol_DragDropTarget ] = ImVec4( 0.26f, 0.59f, 0.98f, 0.95f );
  colors[ ImGuiCol_NavHighlight ] = colors[ ImGuiCol_HeaderHovered ];
  colors[ ImGuiCol_NavWindowingHighlight ] = ImVec4( 0.70f, 0.70f, 0.70f, 0.70f );
  colors[ ImGuiCol_NavWindowingDimBg ] = ImVec4( 0.20f, 0.20f, 0.20f, 0.20f );
  colors[ ImGuiCol_ModalWindowDimBg ] = ImVec4( 0.20f, 0.20f, 0.20f, 0.35f );
}

//-----------------------------------------------------------------------------
// ImDrawList
//-----------------------------------------------------------------------------

ImDrawListSharedData::ImDrawListSharedData()
{
  Font = NULL;
  FontSize = 0.0f;
  CurveTessellationTol = 0.0f;
  CircleSegmentMaxError = 0.0f;
  ClipRectFullscreen = ImVec4( -8192.0f, -8192.0f, +8192.0f, +8192.0f );
  InitialFlags = ImDrawListFlags_None;

  // Lookup tables
  for( int i = 0; i < IM_ARRAYSIZE( ArcFastVtx ); i++ )
  {
    const float a = ( ( float )i * 2 * IM_PI ) / ( float )IM_ARRAYSIZE( ArcFastVtx );
    ArcFastVtx[ i ] = ImVec2( ImCos( a ), ImSin( a ) );
  }
  memset( CircleSegmentCounts, 0, sizeof( CircleSegmentCounts ) ); // This will be set by SetCircleSegmentMaxError()
}

void ImDrawListSharedData::SetCircleSegmentMaxError( float max_error )
{
  if( CircleSegmentMaxError == max_error )
    return;
  CircleSegmentMaxError = max_error;
  for( int i = 0; i < IM_ARRAYSIZE( CircleSegmentCounts ); i++ )
  {
    const float radius = i + 1.0f;
    const int segment_count = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC( radius, CircleSegmentMaxError );
    CircleSegmentCounts[ i ] = ( ImU8 )ImMin( segment_count, 255 );
  }
}

void ImDrawList::Clear()
{
  CmdBuffer.resize( 0 );
  IdxBuffer.resize( 0 );
  VtxBuffer.resize( 0 );
  Flags = _Data ? _Data->InitialFlags : ImDrawListFlags_None;
  _VtxCurrentOffset = 0;
  _VtxCurrentIdx = 0;
  _VtxWritePtr = NULL;
  _IdxWritePtr = NULL;
  _ClipRectStack.resize( 0 );
  _TextureIdStack.resize( 0 );
  _Path.resize( 0 );
  _Splitter.Clear();
}

void ImDrawList::ClearFreeMemory()
{
  CmdBuffer.clear();
  IdxBuffer.clear();
  VtxBuffer.clear();
  _VtxCurrentIdx = 0;
  _VtxWritePtr = NULL;
  _IdxWritePtr = NULL;
  _ClipRectStack.clear();
  _TextureIdStack.clear();
  _Path.clear();
  _Splitter.ClearFreeMemory();
}

ImDrawList* ImDrawList::CloneOutput() const
{
  ImDrawList* dst = IM_NEW( ImDrawList( _Data ) );
  dst->CmdBuffer = CmdBuffer;
  dst->IdxBuffer = IdxBuffer;
  dst->VtxBuffer = VtxBuffer;
  dst->Flags = Flags;
  return dst;
}

// Using macros because C++ is a terrible language, we want guaranteed inline, no code in header, and no overhead in Debug builds
#define GetCurrentClipRect()    (_ClipRectStack.Size ? _ClipRectStack.Data[_ClipRectStack.Size-1]  : _Data->ClipRectFullscreen)
#define GetCurrentTextureId()   (_TextureIdStack.Size ? _TextureIdStack.Data[_TextureIdStack.Size-1] : (ImTextureID)NULL)

void ImDrawList::AddDrawCmd()
{
  ImDrawCmd draw_cmd;
  draw_cmd.ClipRect = GetCurrentClipRect();
  draw_cmd.TextureId = GetCurrentTextureId();
  draw_cmd.VtxOffset = _VtxCurrentOffset;
  draw_cmd.IdxOffset = IdxBuffer.Size;

  IM_ASSERT( draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w );
  CmdBuffer.push_back( draw_cmd );
}

void ImDrawList::AddCallback( ImDrawCallback callback, void* callback_data )
{
  ImDrawCmd* current_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;
  if( !current_cmd || current_cmd->ElemCount != 0 || current_cmd->UserCallback != NULL )
  {
    AddDrawCmd();
    current_cmd = &CmdBuffer.back();
  }
  current_cmd->UserCallback = callback;
  current_cmd->UserCallbackData = callback_data;

  AddDrawCmd(); // Force a new command after us (see comment below)
}

// Our scheme may appears a bit unusual, basically we want the most-common calls AddLine AddRect etc. to not have to perform any check so we always have a command ready in the stack.
// The cost of figuring out if a new command has to be added or if we can merge is paid in those Update** functions only.
void ImDrawList::UpdateClipRect()
{
  // If current command is used with different settings we need to add a new command
  const ImVec4 curr_clip_rect = GetCurrentClipRect();
  ImDrawCmd* curr_cmd = CmdBuffer.Size > 0 ? &CmdBuffer.Data[ CmdBuffer.Size - 1 ] : NULL;
  if( !curr_cmd || ( curr_cmd->ElemCount != 0 && memcmp( &curr_cmd->ClipRect, &curr_clip_rect, sizeof( ImVec4 ) ) != 0 ) || curr_cmd->UserCallback != NULL )
  {
    AddDrawCmd();
    return;
  }

  // Try to merge with previous command if it matches, else use current command
  ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;
  if( curr_cmd->ElemCount == 0 && prev_cmd && memcmp( &prev_cmd->ClipRect, &curr_clip_rect, sizeof( ImVec4 ) ) == 0 && prev_cmd->TextureId == GetCurrentTextureId() && prev_cmd->UserCallback == NULL )
    CmdBuffer.pop_back();
  else
    curr_cmd->ClipRect = curr_clip_rect;
}

void ImDrawList::UpdateTextureID()
{
  // If current command is used with different settings we need to add a new command
  const ImTextureID curr_texture_id = GetCurrentTextureId();
  ImDrawCmd* curr_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;
  if( !curr_cmd || ( curr_cmd->ElemCount != 0 && curr_cmd->TextureId != curr_texture_id ) || curr_cmd->UserCallback != NULL )
  {
    AddDrawCmd();
    return;
  }

  // Try to merge with previous command if it matches, else use current command
  ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;
  if( curr_cmd->ElemCount == 0 && prev_cmd && prev_cmd->TextureId == curr_texture_id && memcmp( &prev_cmd->ClipRect, &GetCurrentClipRect(), sizeof( ImVec4 ) ) == 0 && prev_cmd->UserCallback == NULL )
    CmdBuffer.pop_back();
  else
    curr_cmd->TextureId = curr_texture_id;
}

#undef GetCurrentClipRect
#undef GetCurrentTextureId

// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
void ImDrawList::PushClipRect( ImVec2 cr_min, ImVec2 cr_max, bool intersect_with_current_clip_rect )
{
  ImVec4 cr( cr_min.x, cr_min.y, cr_max.x, cr_max.y );
  if( intersect_with_current_clip_rect && _ClipRectStack.Size )
  {
    ImVec4 current = _ClipRectStack.Data[ _ClipRectStack.Size - 1 ];
    if( cr.x < current.x ) cr.x = current.x;
    if( cr.y < current.y ) cr.y = current.y;
    if( cr.z > current.z ) cr.z = current.z;
    if( cr.w > current.w ) cr.w = current.w;
  }
  cr.z = ImMax( cr.x, cr.z );
  cr.w = ImMax( cr.y, cr.w );

  _ClipRectStack.push_back( cr );
  UpdateClipRect();
}

void ImDrawList::PushClipRectFullScreen()
{
  PushClipRect( ImVec2( _Data->ClipRectFullscreen.x, _Data->ClipRectFullscreen.y ), ImVec2( _Data->ClipRectFullscreen.z, _Data->ClipRectFullscreen.w ) );
}

void ImDrawList::PopClipRect()
{
  IM_ASSERT( _ClipRectStack.Size > 0 );
  _ClipRectStack.pop_back();
  UpdateClipRect();
}

void ImDrawList::PushTextureID( ImTextureID texture_id )
{
  _TextureIdStack.push_back( texture_id );
  UpdateTextureID();
}

void ImDrawList::PopTextureID()
{
  IM_ASSERT( _TextureIdStack.Size > 0 );
  _TextureIdStack.pop_back();
  UpdateTextureID();
}

// Reserve space for a number of vertices and indices.
// You must finish filling your reserved data before calling PrimReserve() again, as it may reallocate or
// submit the intermediate results. PrimUnreserve() can be used to release unused allocations.
void ImDrawList::PrimReserve( int idx_count, int vtx_count )
{
  // Large mesh support (when enabled)
  IM_ASSERT_PARANOID( idx_count >= 0 && vtx_count >= 0 );
  if( sizeof( ImDrawIdx ) == 2 && ( _VtxCurrentIdx + vtx_count >= ( 1 << 16 ) ) && ( Flags & ImDrawListFlags_AllowVtxOffset ) )
  {
    _VtxCurrentOffset = VtxBuffer.Size;
    _VtxCurrentIdx = 0;
    AddDrawCmd();
  }

  ImDrawCmd& draw_cmd = CmdBuffer.Data[ CmdBuffer.Size - 1 ];
  draw_cmd.ElemCount += idx_count;

  int vtx_buffer_old_size = VtxBuffer.Size;
  VtxBuffer.resize( vtx_buffer_old_size + vtx_count );
  _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;

  int idx_buffer_old_size = IdxBuffer.Size;
  IdxBuffer.resize( idx_buffer_old_size + idx_count );
  _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;
}

// Release the a number of reserved vertices/indices from the end of the last reservation made with PrimReserve().
void ImDrawList::PrimUnreserve( int idx_count, int vtx_count )
{
  IM_ASSERT_PARANOID( idx_count >= 0 && vtx_count >= 0 );

  ImDrawCmd& draw_cmd = CmdBuffer.Data[ CmdBuffer.Size - 1 ];
  draw_cmd.ElemCount -= idx_count;
  VtxBuffer.shrink( VtxBuffer.Size - vtx_count );
  IdxBuffer.shrink( IdxBuffer.Size - idx_count );
}

// Fully unrolled with inline call to keep our debug builds decently fast.
void ImDrawList::PrimRect( const ImVec2& a, const ImVec2& c, ImU32 col )
{
  ImVec2 b( c.x, a.y ), d( a.x, c.y ), uv( _Data->TexUvWhitePixel );
  ImDrawIdx idx = ( ImDrawIdx )_VtxCurrentIdx;
  _IdxWritePtr[ 0 ] = idx; _IdxWritePtr[ 1 ] = ( ImDrawIdx )( idx + 1 ); _IdxWritePtr[ 2 ] = ( ImDrawIdx )( idx + 2 );
  _IdxWritePtr[ 3 ] = idx; _IdxWritePtr[ 4 ] = ( ImDrawIdx )( idx + 2 ); _IdxWritePtr[ 5 ] = ( ImDrawIdx )( idx + 3 );
  _VtxWritePtr[ 0 ].pos = a; _VtxWritePtr[ 0 ].uv = uv; _VtxWritePtr[ 0 ].col = col;
  _VtxWritePtr[ 1 ].pos = b; _VtxWritePtr[ 1 ].uv = uv; _VtxWritePtr[ 1 ].col = col;
  _VtxWritePtr[ 2 ].pos = c; _VtxWritePtr[ 2 ].uv = uv; _VtxWritePtr[ 2 ].col = col;
  _VtxWritePtr[ 3 ].pos = d; _VtxWritePtr[ 3 ].uv = uv; _VtxWritePtr[ 3 ].col = col;
  _VtxWritePtr += 4;
  _VtxCurrentIdx += 4;
  _IdxWritePtr += 6;
}

void ImDrawList::PrimRectUV( const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col )
{
  ImVec2 b( c.x, a.y ), d( a.x, c.y ), uv_b( uv_c.x, uv_a.y ), uv_d( uv_a.x, uv_c.y );
  ImDrawIdx idx = ( ImDrawIdx )_VtxCurrentIdx;
  _IdxWritePtr[ 0 ] = idx; _IdxWritePtr[ 1 ] = ( ImDrawIdx )( idx + 1 ); _IdxWritePtr[ 2 ] = ( ImDrawIdx )( idx + 2 );
  _IdxWritePtr[ 3 ] = idx; _IdxWritePtr[ 4 ] = ( ImDrawIdx )( idx + 2 ); _IdxWritePtr[ 5 ] = ( ImDrawIdx )( idx + 3 );
  _VtxWritePtr[ 0 ].pos = a; _VtxWritePtr[ 0 ].uv = uv_a; _VtxWritePtr[ 0 ].col = col;
  _VtxWritePtr[ 1 ].pos = b; _VtxWritePtr[ 1 ].uv = uv_b; _VtxWritePtr[ 1 ].col = col;
  _VtxWritePtr[ 2 ].pos = c; _VtxWritePtr[ 2 ].uv = uv_c; _VtxWritePtr[ 2 ].col = col;
  _VtxWritePtr[ 3 ].pos = d; _VtxWritePtr[ 3 ].uv = uv_d; _VtxWritePtr[ 3 ].col = col;
  _VtxWritePtr += 4;
  _VtxCurrentIdx += 4;
  _IdxWritePtr += 6;
}

void ImDrawList::PrimQuadUV( const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col )
{
  ImDrawIdx idx = ( ImDrawIdx )_VtxCurrentIdx;
  _IdxWritePtr[ 0 ] = idx; _IdxWritePtr[ 1 ] = ( ImDrawIdx )( idx + 1 ); _IdxWritePtr[ 2 ] = ( ImDrawIdx )( idx + 2 );
  _IdxWritePtr[ 3 ] = idx; _IdxWritePtr[ 4 ] = ( ImDrawIdx )( idx + 2 ); _IdxWritePtr[ 5 ] = ( ImDrawIdx )( idx + 3 );
  _VtxWritePtr[ 0 ].pos = a; _VtxWritePtr[ 0 ].uv = uv_a; _VtxWritePtr[ 0 ].col = col;
  _VtxWritePtr[ 1 ].pos = b; _VtxWritePtr[ 1 ].uv = uv_b; _VtxWritePtr[ 1 ].col = col;
  _VtxWritePtr[ 2 ].pos = c; _VtxWritePtr[ 2 ].uv = uv_c; _VtxWritePtr[ 2 ].col = col;
  _VtxWritePtr[ 3 ].pos = d; _VtxWritePtr[ 3 ].uv = uv_d; _VtxWritePtr[ 3 ].col = col;
  _VtxWritePtr += 4;
  _VtxCurrentIdx += 4;
  _IdxWritePtr += 6;
}

// On AddPolyline() and AddConvexPolyFilled() we intentionally avoid using ImVec2 and superfluous function calls to optimize debug/non-inlined builds.
// Those macros expects l-values.
#define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     do { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = 1.0f / ImSqrt(d2); VX *= inv_len; VY *= inv_len; } } while (0)
#define IM_FIXNORMAL2F(VX,VY)               do { float d2 = VX*VX + VY*VY; if (d2 < 0.5f) d2 = 0.5f; float inv_lensq = 1.0f / d2; VX *= inv_lensq; VY *= inv_lensq; } while (0)

// TODO: Thickness anti-aliased lines cap are missing their AA fringe.
// We avoid using the ImVec2 math operators here to reduce cost to a minimum for debug/non-inlined builds.
void ImDrawList::AddPolyline( const ImVec2* points, const int points_count, ImU32 col, bool closed, float thickness )
{
  if( points_count < 2 )
    return;

  const ImVec2 uv = _Data->TexUvWhitePixel;

  int count = points_count;
  if( !closed )
    count = points_count - 1;

  const bool thick_line = thickness > 1.0f;
  if( Flags & ImDrawListFlags_AntiAliasedLines )
  {
    // Anti-aliased stroke
    const float AA_SIZE = 1.0f;
    const ImU32 col_trans = col & ~IM_COL32_A_MASK;

    const int idx_count = thick_line ? count * 18 : count * 12;
    const int vtx_count = thick_line ? points_count * 4 : points_count * 3;
    PrimReserve( idx_count, vtx_count );

    // Temporary buffer
    ImVec2* temp_normals = ( ImVec2* )alloca( points_count * ( thick_line ? 5 : 3 ) * sizeof( ImVec2 ) ); //-V630
    ImVec2* temp_points = temp_normals + points_count;

    for( int i1 = 0; i1 < count; i1++ )
    {
      const int i2 = ( i1 + 1 ) == points_count ? 0 : i1 + 1;
      float dx = points[ i2 ].x - points[ i1 ].x;
      float dy = points[ i2 ].y - points[ i1 ].y;
      IM_NORMALIZE2F_OVER_ZERO( dx, dy );
      temp_normals[ i1 ].x = dy;
      temp_normals[ i1 ].y = -dx;
    }
    if( !closed )
      temp_normals[ points_count - 1 ] = temp_normals[ points_count - 2 ];

    if( !thick_line )
    {
      if( !closed )
      {
        temp_points[ 0 ] = points[ 0 ] + temp_normals[ 0 ] * AA_SIZE;
        temp_points[ 1 ] = points[ 0 ] - temp_normals[ 0 ] * AA_SIZE;
        temp_points[ ( points_count - 1 ) * 2 + 0 ] = points[ points_count - 1 ] + temp_normals[ points_count - 1 ] * AA_SIZE;
        temp_points[ ( points_count - 1 ) * 2 + 1 ] = points[ points_count - 1 ] - temp_normals[ points_count - 1 ] * AA_SIZE;
      }

      // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
      unsigned int idx1 = _VtxCurrentIdx;
      for( int i1 = 0; i1 < count; i1++ )
      {
        const int i2 = ( i1 + 1 ) == points_count ? 0 : i1 + 1;
        unsigned int idx2 = ( i1 + 1 ) == points_count ? _VtxCurrentIdx : idx1 + 3;

        // Average normals
        float dm_x = ( temp_normals[ i1 ].x + temp_normals[ i2 ].x ) * 0.5f;
        float dm_y = ( temp_normals[ i1 ].y + temp_normals[ i2 ].y ) * 0.5f;
        IM_FIXNORMAL2F( dm_x, dm_y );
        dm_x *= AA_SIZE;
        dm_y *= AA_SIZE;

        // Add temporary vertices
        ImVec2* out_vtx = &temp_points[ i2 * 2 ];
        out_vtx[ 0 ].x = points[ i2 ].x + dm_x;
        out_vtx[ 0 ].y = points[ i2 ].y + dm_y;
        out_vtx[ 1 ].x = points[ i2 ].x - dm_x;
        out_vtx[ 1 ].y = points[ i2 ].y - dm_y;

        // Add indexes
        _IdxWritePtr[ 0 ] = ( ImDrawIdx )( idx2 + 0 ); _IdxWritePtr[ 1 ] = ( ImDrawIdx )( idx1 + 0 ); _IdxWritePtr[ 2 ] = ( ImDrawIdx )( idx1 + 2 );
        _IdxWritePtr[ 3 ] = ( ImDrawIdx )( idx1 + 2 ); _IdxWritePtr[ 4 ] = ( ImDrawIdx )( idx2 + 2 ); _IdxWritePtr[ 5 ] = ( ImDrawIdx )( idx2 + 0 );
        _IdxWritePtr[ 6 ] = ( ImDrawIdx )( idx2 + 1 ); _IdxWritePtr[ 7 ] = ( ImDrawIdx )( idx1 + 1 ); _IdxWritePtr[ 8 ] = ( ImDrawIdx )( idx1 + 0 );
        _IdxWritePtr[ 9 ] = ( ImDrawIdx )( idx1 + 0 ); _IdxWritePtr[ 10 ] = ( ImDrawIdx )( idx2 + 0 ); _IdxWritePtr[ 11 ] = ( ImDrawIdx )( idx2 + 1 );
        _IdxWritePtr += 12;

        idx1 = idx2;
      }

      // Add vertices
      for( int i = 0; i < points_count; i++ )
      {
        _VtxWritePtr[ 0 ].pos = points[ i ];          _VtxWritePtr[ 0 ].uv = uv; _VtxWritePtr[ 0 ].col = col;
        _VtxWritePtr[ 1 ].pos = temp_points[ i * 2 + 0 ]; _VtxWritePtr[ 1 ].uv = uv; _VtxWritePtr[ 1 ].col = col_trans;
        _VtxWritePtr[ 2 ].pos = temp_points[ i * 2 + 1 ]; _VtxWritePtr[ 2 ].uv = uv; _VtxWritePtr[ 2 ].col = col_trans;
        _VtxWritePtr += 3;
      }
    }
    else
    {
      const float half_inner_thickness = ( thickness - AA_SIZE ) * 0.5f;
      if( !closed )
      {
        temp_points[ 0 ] = points[ 0 ] + temp_normals[ 0 ] * ( half_inner_thickness + AA_SIZE );
        temp_points[ 1 ] = points[ 0 ] + temp_normals[ 0 ] * ( half_inner_thickness );
        temp_points[ 2 ] = points[ 0 ] - temp_normals[ 0 ] * ( half_inner_thickness );
        temp_points[ 3 ] = points[ 0 ] - temp_normals[ 0 ] * ( half_inner_thickness + AA_SIZE );
        temp_points[ ( points_count - 1 ) * 4 + 0 ] = points[ points_count - 1 ] + temp_normals[ points_count - 1 ] * ( half_inner_thickness + AA_SIZE );
        temp_points[ ( points_count - 1 ) * 4 + 1 ] = points[ points_count - 1 ] + temp_normals[ points_count - 1 ] * ( half_inner_thickness );
        temp_points[ ( points_count - 1 ) * 4 + 2 ] = points[ points_count - 1 ] - temp_normals[ points_count - 1 ] * ( half_inner_thickness );
        temp_points[ ( points_count - 1 ) * 4 + 3 ] = points[ points_count - 1 ] - temp_normals[ points_count - 1 ] * ( half_inner_thickness + AA_SIZE );
      }

      // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
      unsigned int idx1 = _VtxCurrentIdx;
      for( int i1 = 0; i1 < count; i1++ )
      {
        const int i2 = ( i1 + 1 ) == points_count ? 0 : i1 + 1;
        unsigned int idx2 = ( i1 + 1 ) == points_count ? _VtxCurrentIdx : idx1 + 4;

        // Average normals
        float dm_x = ( temp_normals[ i1 ].x + temp_normals[ i2 ].x ) * 0.5f;
        float dm_y = ( temp_normals[ i1 ].y + temp_normals[ i2 ].y ) * 0.5f;
        IM_FIXNORMAL2F( dm_x, dm_y );
        float dm_out_x = dm_x * ( half_inner_thickness + AA_SIZE );
        float dm_out_y = dm_y * ( half_inner_thickness + AA_SIZE );
        float dm_in_x = dm_x * half_inner_thickness;
        float dm_in_y = dm_y * half_inner_thickness;

        // Add temporary vertices
        ImVec2* out_vtx = &temp_points[ i2 * 4 ];
        out_vtx[ 0 ].x = points[ i2 ].x + dm_out_x;
        out_vtx[ 0 ].y = points[ i2 ].y + dm_out_y;
        out_vtx[ 1 ].x = points[ i2 ].x + dm_in_x;
        out_vtx[ 1 ].y = points[ i2 ].y + dm_in_y;
        out_vtx[ 2 ].x = points[ i2 ].x - dm_in_x;
        out_vtx[ 2 ].y = points[ i2 ].y - dm_in_y;
        out_vtx[ 3 ].x = points[ i2 ].x - dm_out_x;
        out_vtx[ 3 ].y = points[ i2 ].y - dm_out_y;

        // Add indexes
        _IdxWritePtr[ 0 ] = ( ImDrawIdx )( idx2 + 1 ); _IdxWritePtr[ 1 ] = ( ImDrawIdx )( idx1 + 1 ); _IdxWritePtr[ 2 ] = ( ImDrawIdx )( idx1 + 2 );
        _IdxWritePtr[ 3 ] = ( ImDrawIdx )( idx1 + 2 ); _IdxWritePtr[ 4 ] = ( ImDrawIdx )( idx2 + 2 ); _IdxWritePtr[ 5 ] = ( ImDrawIdx )( idx2 + 1 );
        _IdxWritePtr[ 6 ] = ( ImDrawIdx )( idx2 + 1 ); _IdxWritePtr[ 7 ] = ( ImDrawIdx )( idx1 + 1 ); _IdxWritePtr[ 8 ] = ( ImDrawIdx )( idx1 + 0 );
        _IdxWritePtr[ 9 ] = ( ImDrawIdx )( idx1 + 0 ); _IdxWritePtr[ 10 ] = ( ImDrawIdx )( idx2 + 0 ); _IdxWritePtr[ 11 ] = ( ImDrawIdx )( idx2 + 1 );
        _IdxWritePtr[ 12 ] = ( ImDrawIdx )( idx2 + 2 ); _IdxWritePtr[ 13 ] = ( ImDrawIdx )( idx1 + 2 ); _IdxWritePtr[ 14 ] = ( ImDrawIdx )( idx1 + 3 );
        _IdxWritePtr[ 15 ] = ( ImDrawIdx )( idx1 + 3 ); _IdxWritePtr[ 16 ] = ( ImDrawIdx )( idx2 + 3 ); _IdxWritePtr[ 17 ] = ( ImDrawIdx )( idx2 + 2 );
        _IdxWritePtr += 18;

        idx1 = idx2;
      }

      // Add vertices
      for( int i = 0; i < points_count; i++ )
      {
        _VtxWritePtr[ 0 ].pos = temp_points[ i * 4 + 0 ]; _VtxWritePtr[ 0 ].uv = uv; _VtxWritePtr[ 0 ].col = col_trans;
        _VtxWritePtr[ 1 ].pos = temp_points[ i * 4 + 1 ]; _VtxWritePtr[ 1 ].uv = uv; _VtxWritePtr[ 1 ].col = col;
        _VtxWritePtr[ 2 ].pos = temp_points[ i * 4 + 2 ]; _VtxWritePtr[ 2 ].uv = uv; _VtxWritePtr[ 2 ].col = col;
        _VtxWritePtr[ 3 ].pos = temp_points[ i * 4 + 3 ]; _VtxWritePtr[ 3 ].uv = uv; _VtxWritePtr[ 3 ].col = col_trans;
        _VtxWritePtr += 4;
      }
    }
    _VtxCurrentIdx += ( ImDrawIdx )vtx_count;
  }
  else
  {
    // Non Anti-aliased Stroke
    const int idx_count = count * 6;
    const int vtx_count = count * 4;      // FIXME-OPT: Not sharing edges
    PrimReserve( idx_count, vtx_count );

    for( int i1 = 0; i1 < count; i1++ )
    {
      const int i2 = ( i1 + 1 ) == points_count ? 0 : i1 + 1;
      const ImVec2& p1 = points[ i1 ];
      const ImVec2& p2 = points[ i2 ];

      float dx = p2.x - p1.x;
      float dy = p2.y - p1.y;
      IM_NORMALIZE2F_OVER_ZERO( dx, dy );
      dx *= ( thickness * 0.5f );
      dy *= ( thickness * 0.5f );

      _VtxWritePtr[ 0 ].pos.x = p1.x + dy; _VtxWritePtr[ 0 ].pos.y = p1.y - dx; _VtxWritePtr[ 0 ].uv = uv; _VtxWritePtr[ 0 ].col = col;
      _VtxWritePtr[ 1 ].pos.x = p2.x + dy; _VtxWritePtr[ 1 ].pos.y = p2.y - dx; _VtxWritePtr[ 1 ].uv = uv; _VtxWritePtr[ 1 ].col = col;
      _VtxWritePtr[ 2 ].pos.x = p2.x - dy; _VtxWritePtr[ 2 ].pos.y = p2.y + dx; _VtxWritePtr[ 2 ].uv = uv; _VtxWritePtr[ 2 ].col = col;
      _VtxWritePtr[ 3 ].pos.x = p1.x - dy; _VtxWritePtr[ 3 ].pos.y = p1.y + dx; _VtxWritePtr[ 3 ].uv = uv; _VtxWritePtr[ 3 ].col = col;
      _VtxWritePtr += 4;

      _IdxWritePtr[ 0 ] = ( ImDrawIdx )( _VtxCurrentIdx ); _IdxWritePtr[ 1 ] = ( ImDrawIdx )( _VtxCurrentIdx + 1 ); _IdxWritePtr[ 2 ] = ( ImDrawIdx )( _VtxCurrentIdx + 2 );
      _IdxWritePtr[ 3 ] = ( ImDrawIdx )( _VtxCurrentIdx ); _IdxWritePtr[ 4 ] = ( ImDrawIdx )( _VtxCurrentIdx + 2 ); _IdxWritePtr[ 5 ] = ( ImDrawIdx )( _VtxCurrentIdx + 3 );
      _IdxWritePtr += 6;
      _VtxCurrentIdx += 4;
    }
  }
}

// We intentionally avoid using ImVec2 and its math operators here to reduce cost to a minimum for debug/non-inlined builds.
void ImDrawList::AddConvexPolyFilled( const ImVec2* points, const int points_count, ImU32 col )
{
  if( points_count < 3 )
    return;

  const ImVec2 uv = _Data->TexUvWhitePixel;

  if( Flags & ImDrawListFlags_AntiAliasedFill )
  {
    // Anti-aliased Fill
    const float AA_SIZE = 1.0f;
    const ImU32 col_trans = col & ~IM_COL32_A_MASK;
    const int idx_count = ( points_count - 2 ) * 3 + points_count * 6;
    const int vtx_count = ( points_count * 2 );
    PrimReserve( idx_count, vtx_count );

    // Add indexes for fill
    unsigned int vtx_inner_idx = _VtxCurrentIdx;
    unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;
    for( int i = 2; i < points_count; i++ )
    {
      _IdxWritePtr[ 0 ] = ( ImDrawIdx )( vtx_inner_idx ); _IdxWritePtr[ 1 ] = ( ImDrawIdx )( vtx_inner_idx + ( ( i - 1 ) << 1 ) ); _IdxWritePtr[ 2 ] = ( ImDrawIdx )( vtx_inner_idx + ( i << 1 ) );
      _IdxWritePtr += 3;
    }

    // Compute normals
    ImVec2* temp_normals = ( ImVec2* )alloca( points_count * sizeof( ImVec2 ) ); //-V630
    for( int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++ )
    {
      const ImVec2& p0 = points[ i0 ];
      const ImVec2& p1 = points[ i1 ];
      float dx = p1.x - p0.x;
      float dy = p1.y - p0.y;
      IM_NORMALIZE2F_OVER_ZERO( dx, dy );
      temp_normals[ i0 ].x = dy;
      temp_normals[ i0 ].y = -dx;
    }

    for( int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++ )
    {
      // Average normals
      const ImVec2& n0 = temp_normals[ i0 ];
      const ImVec2& n1 = temp_normals[ i1 ];
      float dm_x = ( n0.x + n1.x ) * 0.5f;
      float dm_y = ( n0.y + n1.y ) * 0.5f;
      IM_FIXNORMAL2F( dm_x, dm_y );
      dm_x *= AA_SIZE * 0.5f;
      dm_y *= AA_SIZE * 0.5f;

      // Add vertices
      _VtxWritePtr[ 0 ].pos.x = ( points[ i1 ].x - dm_x ); _VtxWritePtr[ 0 ].pos.y = ( points[ i1 ].y - dm_y ); _VtxWritePtr[ 0 ].uv = uv; _VtxWritePtr[ 0 ].col = col;        // Inner
      _VtxWritePtr[ 1 ].pos.x = ( points[ i1 ].x + dm_x ); _VtxWritePtr[ 1 ].pos.y = ( points[ i1 ].y + dm_y ); _VtxWritePtr[ 1 ].uv = uv; _VtxWritePtr[ 1 ].col = col_trans;  // Outer
      _VtxWritePtr += 2;

      // Add indexes for fringes
      _IdxWritePtr[ 0 ] = ( ImDrawIdx )( vtx_inner_idx + ( i1 << 1 ) ); _IdxWritePtr[ 1 ] = ( ImDrawIdx )( vtx_inner_idx + ( i0 << 1 ) ); _IdxWritePtr[ 2 ] = ( ImDrawIdx )( vtx_outer_idx + ( i0 << 1 ) );
      _IdxWritePtr[ 3 ] = ( ImDrawIdx )( vtx_outer_idx + ( i0 << 1 ) ); _IdxWritePtr[ 4 ] = ( ImDrawIdx )( vtx_outer_idx + ( i1 << 1 ) ); _IdxWritePtr[ 5 ] = ( ImDrawIdx )( vtx_inner_idx + ( i1 << 1 ) );
      _IdxWritePtr += 6;
    }
    _VtxCurrentIdx += ( ImDrawIdx )vtx_count;
  }
  else
  {
    // Non Anti-aliased Fill
    const int idx_count = ( points_count - 2 ) * 3;
    const int vtx_count = points_count;
    PrimReserve( idx_count, vtx_count );
    for( int i = 0; i < vtx_count; i++ )
    {
      _VtxWritePtr[ 0 ].pos = points[ i ]; _VtxWritePtr[ 0 ].uv = uv; _VtxWritePtr[ 0 ].col = col;
      _VtxWritePtr++;
    }
    for( int i = 2; i < points_count; i++ )
    {
      _IdxWritePtr[ 0 ] = ( ImDrawIdx )( _VtxCurrentIdx ); _IdxWritePtr[ 1 ] = ( ImDrawIdx )( _VtxCurrentIdx + i - 1 ); _IdxWritePtr[ 2 ] = ( ImDrawIdx )( _VtxCurrentIdx + i );
      _IdxWritePtr += 3;
    }
    _VtxCurrentIdx += ( ImDrawIdx )vtx_count;
  }
}

void ImDrawList::PathArcToFast( const ImVec2& center, float radius, int a_min_of_12, int a_max_of_12 )
{
  if( radius == 0.0f || a_min_of_12 > a_max_of_12 )
  {
    _Path.push_back( center );
    return;
  }

  // For legacy reason the PathArcToFast() always takes angles where 2*PI is represented by 12,
  // but it is possible to set IM_DRAWLIST_ARCFAST_TESSELATION_MULTIPLIER to a higher value. This should compile to a no-op otherwise.
#if IM_DRAWLIST_ARCFAST_TESSELLATION_MULTIPLIER != 1
  a_min_of_12 *= IM_DRAWLIST_ARCFAST_TESSELLATION_MULTIPLIER;
  a_max_of_12 *= IM_DRAWLIST_ARCFAST_TESSELLATION_MULTIPLIER;
#endif

  _Path.reserve( _Path.Size + ( a_max_of_12 - a_min_of_12 + 1 ) );
  for( int a = a_min_of_12; a <= a_max_of_12; a++ )
  {
    const ImVec2& c = _Data->ArcFastVtx[ a % IM_ARRAYSIZE( _Data->ArcFastVtx ) ];
    _Path.push_back( ImVec2( center.x + c.x * radius, center.y + c.y * radius ) );
  }
}

void ImDrawList::PathArcTo( const ImVec2& center, float radius, float a_min, float a_max, int num_segments )
{
  if( radius == 0.0f )
  {
    _Path.push_back( center );
    return;
  }

  // Note that we are adding a point at both a_min and a_max.
  // If you are trying to draw a full closed circle you don't want the overlapping points!
  _Path.reserve( _Path.Size + ( num_segments + 1 ) );
  for( int i = 0; i <= num_segments; i++ )
  {
    const float a = a_min + ( ( float )i / ( float )num_segments ) * ( a_max - a_min );
    _Path.push_back( ImVec2( center.x + ImCos( a ) * radius, center.y + ImSin( a ) * radius ) );
  }
}

ImVec2 ImBezierCalc( const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, float t )
{
  float u = 1.0f - t;
  float w1 = u * u * u;
  float w2 = 3 * u * u * t;
  float w3 = 3 * u * t * t;
  float w4 = t * t * t;
  return ImVec2( w1 * p1.x + w2 * p2.x + w3 * p3.x + w4 * p4.x, w1 * p1.y + w2 * p2.y + w3 * p3.y + w4 * p4.y );
}

// Closely mimics BezierClosestPointCasteljauStep() in imgui.cpp
static void PathBezierToCasteljau( ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level )
{
  float dx = x4 - x1;
  float dy = y4 - y1;
  float d2 = ( ( x2 - x4 ) * dy - ( y2 - y4 ) * dx );
  float d3 = ( ( x3 - x4 ) * dy - ( y3 - y4 ) * dx );
  d2 = ( d2 >= 0 ) ? d2 : -d2;
  d3 = ( d3 >= 0 ) ? d3 : -d3;
  if( ( d2 + d3 ) * ( d2 + d3 ) < tess_tol * ( dx * dx + dy * dy ) )
  {
    path->push_back( ImVec2( x4, y4 ) );
  }
  else if( level < 10 )
  {
    float x12 = ( x1 + x2 ) * 0.5f, y12 = ( y1 + y2 ) * 0.5f;
    float x23 = ( x2 + x3 ) * 0.5f, y23 = ( y2 + y3 ) * 0.5f;
    float x34 = ( x3 + x4 ) * 0.5f, y34 = ( y3 + y4 ) * 0.5f;
    float x123 = ( x12 + x23 ) * 0.5f, y123 = ( y12 + y23 ) * 0.5f;
    float x234 = ( x23 + x34 ) * 0.5f, y234 = ( y23 + y34 ) * 0.5f;
    float x1234 = ( x123 + x234 ) * 0.5f, y1234 = ( y123 + y234 ) * 0.5f;
    PathBezierToCasteljau( path, x1, y1, x12, y12, x123, y123, x1234, y1234, tess_tol, level + 1 );
    PathBezierToCasteljau( path, x1234, y1234, x234, y234, x34, y34, x4, y4, tess_tol, level + 1 );
  }
}

void ImDrawList::PathBezierCurveTo( const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments )
{
  ImVec2 p1 = _Path.back();
  if( num_segments == 0 )
  {
    PathBezierToCasteljau( &_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, _Data->CurveTessellationTol, 0 ); // Auto-tessellated
  }
  else
  {
    float t_step = 1.0f / ( float )num_segments;
    for( int i_step = 1; i_step <= num_segments; i_step++ )
      _Path.push_back( ImBezierCalc( p1, p2, p3, p4, t_step * i_step ) );
  }
}

void ImDrawList::PathRect( const ImVec2& a, const ImVec2& b, float rounding, ImDrawCornerFlags rounding_corners )
{
  rounding = ImMin( rounding, ImFabs( b.x - a.x ) * ( ( ( rounding_corners & ImDrawCornerFlags_Top ) == ImDrawCornerFlags_Top ) || ( ( rounding_corners & ImDrawCornerFlags_Bot ) == ImDrawCornerFlags_Bot ) ? 0.5f : 1.0f ) - 1.0f );
  rounding = ImMin( rounding, ImFabs( b.y - a.y ) * ( ( ( rounding_corners & ImDrawCornerFlags_Left ) == ImDrawCornerFlags_Left ) || ( ( rounding_corners & ImDrawCornerFlags_Right ) == ImDrawCornerFlags_Right ) ? 0.5f : 1.0f ) - 1.0f );

  if( rounding <= 0.0f || rounding_corners == 0 )
  {
    PathLineTo( a );
    PathLineTo( ImVec2( b.x, a.y ) );
    PathLineTo( b );
    PathLineTo( ImVec2( a.x, b.y ) );
  }
  else
  {
    const float rounding_tl = ( rounding_corners & ImDrawCornerFlags_TopLeft ) ? rounding : 0.0f;
    const float rounding_tr = ( rounding_corners & ImDrawCornerFlags_TopRight ) ? rounding : 0.0f;
    const float rounding_br = ( rounding_corners & ImDrawCornerFlags_BotRight ) ? rounding : 0.0f;
    const float rounding_bl = ( rounding_corners & ImDrawCornerFlags_BotLeft ) ? rounding : 0.0f;
    PathArcToFast( ImVec2( a.x + rounding_tl, a.y + rounding_tl ), rounding_tl, 6, 9 );
    PathArcToFast( ImVec2( b.x - rounding_tr, a.y + rounding_tr ), rounding_tr, 9, 12 );
    PathArcToFast( ImVec2( b.x - rounding_br, b.y - rounding_br ), rounding_br, 0, 3 );
    PathArcToFast( ImVec2( a.x + rounding_bl, b.y - rounding_bl ), rounding_bl, 3, 6 );
  }
}

void ImDrawList::AddLine( const ImVec2& p1, const ImVec2& p2, ImU32 col, float thickness )
{
  if( ( col & IM_COL32_A_MASK ) == 0 )
    return;
  PathLineTo( p1 + ImVec2( 0.5f, 0.5f ) );
  PathLineTo( p2 + ImVec2( 0.5f, 0.5f ) );
  PathStroke( col, false, thickness );
}

// p_min = upper-left, p_max = lower-right
// Note we don't render 1 pixels sized rectangles properly.
void ImDrawList::AddRect( const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding, ImDrawCornerFlags rounding_corners, float thickness )
{
  if( ( col & IM_COL32_A_MASK ) == 0 )
    return;
  if( Flags & ImDrawListFlags_AntiAliasedLines )
    PathRect( p_min + ImVec2( 0.50f, 0.50f ), p_max - ImVec2( 0.50f, 0.50f ), rounding, rounding_corners );
  else
    PathRect( p_min + ImVec2( 0.50f, 0.50f ), p_max - ImVec2( 0.49f, 0.49f ), rounding, rounding_corners ); // Better looking lower-right corner and rounded non-AA shapes.
  PathStroke( col, true, thickness );
}

void ImDrawList::AddRectFilled( const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding, ImDrawCornerFlags rounding_corners )
{
  if( ( col & IM_COL32_A_MASK ) == 0 )
    return;
  if( rounding > 0.0f )
  {
    PathRect( p_min, p_max, rounding, rounding_corners );
    PathFillConvex( col );
  }
  else
  {
    PrimReserve( 6, 4 );
    PrimRect( p_min, p_max, col );
  }
}

// p_min = upper-left, p_max = lower-right
void ImDrawList::AddRectFilledMultiColor( const ImVec2& p_min, const ImVec2& p_max, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left )
{
  if( ( ( col_upr_left | col_upr_right | col_bot_right | col_bot_left ) & IM_COL32_A_MASK ) == 0 )
    return;

  const ImVec2 uv = _Data->TexUvWhitePixel;
  PrimReserve( 6, 4 );
  PrimWriteIdx( ( ImDrawIdx )( _VtxCurrentIdx ) ); PrimWriteIdx( ( ImDrawIdx )( _VtxCurrentIdx + 1 ) ); PrimWriteIdx( ( ImDrawIdx )( _VtxCurrentIdx + 2 ) );
  PrimWriteIdx( ( ImDrawIdx )( _VtxCurrentIdx ) ); PrimWriteIdx( ( ImDrawIdx )( _VtxCurrentIdx + 2 ) ); PrimWriteIdx( ( ImDrawIdx )( _VtxCurrentIdx + 3 ) );
  PrimWriteVtx( p_min, uv, col_upr_left );
  PrimWriteVtx( ImVec2( p_max.x, p_min.y ), uv, col_upr_right );
  PrimWriteVtx( p_max, uv, col_bot_right );
  PrimWriteVtx( ImVec2( p_min.x, p_max.y ), uv, col_bot_left );
}

void ImDrawList::AddQuad( const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness )
{
  if( ( col & IM_COL32_A_MASK ) == 0 )
    return;

  PathLineTo( p1 );
  PathLineTo( p2 );
  PathLineTo( p3 );
  PathLineTo( p4 );
  PathStroke( col, true, thickness );
}

void ImDrawList::AddQuadFilled( const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col )
{
  if( ( col & IM_COL32_A_MASK ) == 0 )
    return;

  PathLineTo( p1 );
  PathLineTo( p2 );
  PathLineTo( p3 );
  PathLineTo( p4 );
  PathFillConvex( col );
}

void ImDrawList::AddTriangle( const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness )
{
  if( ( col & IM_COL32_A_MASK ) == 0 )
    return;

  PathLineTo( p1 );
  PathLineTo( p2 );
  PathLineTo( p3 );
  PathStroke( col, true, thickness );
}

void ImDrawList::AddTriangleFilled( const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col )
{
  if( ( col & IM_COL32_A_MASK ) == 0 )
    return;

  PathLineTo( p1 );
  PathLineTo( p2 );
  PathLineTo( p3 );
  PathFillConvex( col );
}

void ImDrawList::AddCircle( const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness )
{
  if( ( col & IM_COL32_A_MASK ) == 0 || radius <= 0.0f )
    return;

  // Obtain segment count
  if( num_segments <= 0 )
  {
    // Automatic segment count
    const int radius_idx = ( int )radius - 1;
    if( radius_idx < IM_ARRAYSIZE( _Data->CircleSegmentCounts ) )
      num_segments = _Data->CircleSegmentCounts[ radius_idx ]; // Use cached value
    else
      num_segments = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC( radius, _Data->CircleSegmentMaxError );
  }
  else
  {
    // Explicit segment count (still clamp to avoid drawing insanely tessellated shapes)
    num_segments = ImClamp( num_segments, 3, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX );
  }

  // Because we are filling a closed shape we remove 1 from the count of segments/points
  const float a_max = ( IM_PI * 2.0f ) * ( ( float )num_segments - 1.0f ) / ( float )num_segments;
  if( num_segments == 12 )
    PathArcToFast( center, radius - 0.5f, 0, 12 );
  else
    PathArcTo( center, radius - 0.5f, 0.0f, a_max, num_segments - 1 );
  PathStroke( col, true, thickness );
}

void ImDrawList::AddCircleFilled( const ImVec2& center, float radius, ImU32 col, int num_segments )
{
  if( ( col & IM_COL32_A_MASK ) == 0 || radius <= 0.0f )
    return;

  // Obtain segment count
  if( num_segments <= 0 )
  {
    // Automatic segment count
    const int radius_idx = ( int )radius - 1;
    if( radius_idx < IM_ARRAYSIZE( _Data->CircleSegmentCounts ) )
      num_segments = _Data->CircleSegmentCounts[ radius_idx ]; // Use cached value
    else
      num_segments = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC( radius, _Data->CircleSegmentMaxError );
  }
  else
  {
    // Explicit segment count (still clamp to avoid drawing insanely tessellated shapes)
    num_segments = ImClamp( num_segments, 3, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX );
  }

  // Because we are filling a closed shape we remove 1 from the count of segments/points
  const float a_max = ( IM_PI * 2.0f ) * ( ( float )num_segments - 1.0f ) / ( float )num_segments;
  if( num_segments == 12 )
    PathArcToFast( center, radius, 0, 12 );
  else
    PathArcTo( center, radius, 0.0f, a_max, num_segments - 1 );
  PathFillConvex( col );
}

// Guaranteed to honor 'num_segments'
void ImDrawList::AddNgon( const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness )
{
  if( ( col & IM_COL32_A_MASK ) == 0 || num_segments <= 2 )
    return;

  // Because we are filling a closed shape we remove 1 from the count of segments/points
  const float a_max = ( IM_PI * 2.0f ) * ( ( float )num_segments - 1.0f ) / ( float )num_segments;
  PathArcTo( center, radius - 0.5f, 0.0f, a_max, num_segments - 1 );
  PathStroke( col, true, thickness );
}

// Guaranteed to honor 'num_segments'
void ImDrawList::AddNgonFilled( const ImVec2& center, float radius, ImU32 col, int num_segments )
{
  if( ( col & IM_COL32_A_MASK ) == 0 || num_segments <= 2 )
    return;

  // Because we are filling a closed shape we remove 1 from the count of segments/points
  const float a_max = ( IM_PI * 2.0f ) * ( ( float )num_segments - 1.0f ) / ( float )num_segments;
  PathArcTo( center, radius, 0.0f, a_max, num_segments - 1 );
  PathFillConvex( col );
}

// Cubic Bezier takes 4 controls points
void ImDrawList::AddBezierCurve( const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments )
{
  if( ( col & IM_COL32_A_MASK ) == 0 )
    return;

  PathLineTo( p1 );
  PathBezierCurveTo( p2, p3, p4, num_segments );
  PathStroke( col, false, thickness );
}

void ImDrawList::AddText( const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect )
{
  if( ( col & IM_COL32_A_MASK ) == 0 )
    return;

  if( text_end == NULL )
    text_end = text_begin + strlen( text_begin );
  if( text_begin == text_end )
    return;

  // Pull default font/size from the shared ImDrawListSharedData instance
  if( font == NULL )
    font = _Data->Font;
  if( font_size == 0.0f )
    font_size = _Data->FontSize;

  IM_ASSERT( font->ContainerAtlas->TexID == _TextureIdStack.back() );  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.

  ImVec4 clip_rect = _ClipRectStack.back();
  if( cpu_fine_clip_rect )
  {
    clip_rect.x = ImMax( clip_rect.x, cpu_fine_clip_rect->x );
    clip_rect.y = ImMax( clip_rect.y, cpu_fine_clip_rect->y );
    clip_rect.z = ImMin( clip_rect.z, cpu_fine_clip_rect->z );
    clip_rect.w = ImMin( clip_rect.w, cpu_fine_clip_rect->w );
  }
  font->RenderText( this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL );
}

void ImDrawList::AddText( const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end )
{
  AddText( NULL, 0.0f, pos, col, text_begin, text_end );
}

void ImDrawList::AddImage( ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min, const ImVec2& uv_max, ImU32 col )
{
  if( ( col & IM_COL32_A_MASK ) == 0 )
    return;

  const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();
  if( push_texture_id )
    PushTextureID( user_texture_id );

  PrimReserve( 6, 4 );
  PrimRectUV( p_min, p_max, uv_min, uv_max, col );

  if( push_texture_id )
    PopTextureID();
}

void ImDrawList::AddImageQuad( ImTextureID user_texture_id, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& uv1, const ImVec2& uv2, const ImVec2& uv3, const ImVec2& uv4, ImU32 col )
{
  if( ( col & IM_COL32_A_MASK ) == 0 )
    return;

  const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();
  if( push_texture_id )
    PushTextureID( user_texture_id );

  PrimReserve( 6, 4 );
  PrimQuadUV( p1, p2, p3, p4, uv1, uv2, uv3, uv4, col );

  if( push_texture_id )
    PopTextureID();
}

void ImDrawList::AddImageRounded( ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min, const ImVec2& uv_max, ImU32 col, float rounding, ImDrawCornerFlags rounding_corners )
{
  if( ( col & IM_COL32_A_MASK ) == 0 )
    return;

  if( rounding <= 0.0f || ( rounding_corners & ImDrawCornerFlags_All ) == 0 )
  {
    AddImage( user_texture_id, p_min, p_max, uv_min, uv_max, col );
    return;
  }

  const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();
  if( push_texture_id )
    PushTextureID( user_texture_id );

  int vert_start_idx = VtxBuffer.Size;
  PathRect( p_min, p_max, rounding, rounding_corners );
  PathFillConvex( col );
  int vert_end_idx = VtxBuffer.Size;
  ImGui::ShadeVertsLinearUV( this, vert_start_idx, vert_end_idx, p_min, p_max, uv_min, uv_max, true );

  if( push_texture_id )
    PopTextureID();
}


//-----------------------------------------------------------------------------
// ImDrawListSplitter
//-----------------------------------------------------------------------------
// FIXME: This may be a little confusing, trying to be a little too low-level/optimal instead of just doing vector swap..
//-----------------------------------------------------------------------------

void ImDrawListSplitter::ClearFreeMemory()
{
  for( int i = 0; i < _Channels.Size; i++ )
  {
    if( i == _Current )
      memset( &_Channels[ i ], 0, sizeof( _Channels[ i ] ) );  // Current channel is a copy of CmdBuffer/IdxBuffer, don't destruct again
    _Channels[ i ]._CmdBuffer.clear();
    _Channels[ i ]._IdxBuffer.clear();
  }
  _Current = 0;
  _Count = 1;
  _Channels.clear();
}

void ImDrawListSplitter::Split( ImDrawList* draw_list, int channels_count )
{
  IM_ASSERT( _Current == 0 && _Count <= 1 && "Nested channel splitting is not supported. Please use separate instances of ImDrawListSplitter." );
  int old_channels_count = _Channels.Size;
  if( old_channels_count < channels_count )
    _Channels.resize( channels_count );
  _Count = channels_count;

  // Channels[] (24/32 bytes each) hold storage that we'll swap with draw_list->_CmdBuffer/_IdxBuffer
  // The content of Channels[0] at this point doesn't matter. We clear it to make state tidy in a debugger but we don't strictly need to.
  // When we switch to the next channel, we'll copy draw_list->_CmdBuffer/_IdxBuffer into Channels[0] and then Channels[1] into draw_list->CmdBuffer/_IdxBuffer
  memset( &_Channels[ 0 ], 0, sizeof( ImDrawChannel ) );
  for( int i = 1; i < channels_count; i++ )
  {
    if( i >= old_channels_count )
    {
      IM_PLACEMENT_NEW( &_Channels[ i ] ) ImDrawChannel();
    }
    else
    {
      _Channels[ i ]._CmdBuffer.resize( 0 );
      _Channels[ i ]._IdxBuffer.resize( 0 );
    }
    if( _Channels[ i ]._CmdBuffer.Size == 0 )
    {
      ImDrawCmd draw_cmd;
      draw_cmd.ClipRect = draw_list->_ClipRectStack.back();
      draw_cmd.TextureId = draw_list->_TextureIdStack.back();
      _Channels[ i ]._CmdBuffer.push_back( draw_cmd );
    }
  }
}

static inline bool CanMergeDrawCommands( ImDrawCmd* a, ImDrawCmd* b )
{
  return memcmp( &a->ClipRect, &b->ClipRect, sizeof( a->ClipRect ) ) == 0 && a->TextureId == b->TextureId && a->VtxOffset == b->VtxOffset && !a->UserCallback && !b->UserCallback;
}

void ImDrawListSplitter::Merge( ImDrawList* draw_list )
{
  // Note that we never use or rely on channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.
  if( _Count <= 1 )
    return;

  SetCurrentChannel( draw_list, 0 );
  if( draw_list->CmdBuffer.Size != 0 && draw_list->CmdBuffer.back().ElemCount == 0 )
    draw_list->CmdBuffer.pop_back();

  // Calculate our final buffer sizes. Also fix the incorrect IdxOffset values in each command.
  int new_cmd_buffer_count = 0;
  int new_idx_buffer_count = 0;
  ImDrawCmd* last_cmd = ( _Count > 0 && draw_list->CmdBuffer.Size > 0 ) ? &draw_list->CmdBuffer.back() : NULL;
  int idx_offset = last_cmd ? last_cmd->IdxOffset + last_cmd->ElemCount : 0;
  for( int i = 1; i < _Count; i++ )
  {
    ImDrawChannel& ch = _Channels[ i ];
    if( ch._CmdBuffer.Size > 0 && ch._CmdBuffer.back().ElemCount == 0 )
      ch._CmdBuffer.pop_back();
    if( ch._CmdBuffer.Size > 0 && last_cmd != NULL && CanMergeDrawCommands( last_cmd, &ch._CmdBuffer[ 0 ] ) )
    {
      // Merge previous channel last draw command with current channel first draw command if matching.
      last_cmd->ElemCount += ch._CmdBuffer[ 0 ].ElemCount;
      idx_offset += ch._CmdBuffer[ 0 ].ElemCount;
      ch._CmdBuffer.erase( ch._CmdBuffer.Data ); // FIXME-OPT: Improve for multiple merges.
    }
    if( ch._CmdBuffer.Size > 0 )
      last_cmd = &ch._CmdBuffer.back();
    new_cmd_buffer_count += ch._CmdBuffer.Size;
    new_idx_buffer_count += ch._IdxBuffer.Size;
    for( int cmd_n = 0; cmd_n < ch._CmdBuffer.Size; cmd_n++ )
    {
      ch._CmdBuffer.Data[ cmd_n ].IdxOffset = idx_offset;
      idx_offset += ch._CmdBuffer.Data[ cmd_n ].ElemCount;
    }
  }
  draw_list->CmdBuffer.resize( draw_list->CmdBuffer.Size + new_cmd_buffer_count );
  draw_list->IdxBuffer.resize( draw_list->IdxBuffer.Size + new_idx_buffer_count );

  // Write commands and indices in order (they are fairly small structures, we don't copy vertices only indices)
  ImDrawCmd* cmd_write = draw_list->CmdBuffer.Data + draw_list->CmdBuffer.Size - new_cmd_buffer_count;
  ImDrawIdx* idx_write = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size - new_idx_buffer_count;
  for( int i = 1; i < _Count; i++ )
  {
    ImDrawChannel& ch = _Channels[ i ];
    if( int sz = ch._CmdBuffer.Size )
    {
      memcpy( cmd_write, ch._CmdBuffer.Data, sz * sizeof( ImDrawCmd ) ); cmd_write += sz;
    }
    if( int sz = ch._IdxBuffer.Size )
    {
      memcpy( idx_write, ch._IdxBuffer.Data, sz * sizeof( ImDrawIdx ) ); idx_write += sz;
    }
  }
  draw_list->_IdxWritePtr = idx_write;
  draw_list->UpdateClipRect(); // We call this instead of AddDrawCmd(), so that empty channels won't produce an extra draw call.
  draw_list->UpdateTextureID();
  _Count = 1;
}

void ImDrawListSplitter::SetCurrentChannel( ImDrawList* draw_list, int idx )
{
  IM_ASSERT( idx >= 0 && idx < _Count );
  if( _Current == idx )
    return;
  // Overwrite ImVector (12/16 bytes), four times. This is merely a silly optimization instead of doing .swap()
  memcpy( &_Channels.Data[ _Current ]._CmdBuffer, &draw_list->CmdBuffer, sizeof( draw_list->CmdBuffer ) );
  memcpy( &_Channels.Data[ _Current ]._IdxBuffer, &draw_list->IdxBuffer, sizeof( draw_list->IdxBuffer ) );
  _Current = idx;
  memcpy( &draw_list->CmdBuffer, &_Channels.Data[ idx ]._CmdBuffer, sizeof( draw_list->CmdBuffer ) );
  memcpy( &draw_list->IdxBuffer, &_Channels.Data[ idx ]._IdxBuffer, sizeof( draw_list->IdxBuffer ) );
  draw_list->_IdxWritePtr = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size;
}

//-----------------------------------------------------------------------------
// [SECTION] ImDrawData
//-----------------------------------------------------------------------------

// For backward compatibility: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
void ImDrawData::DeIndexAllBuffers()
{
  ImVector<ImDrawVert> new_vtx_buffer;
  TotalVtxCount = TotalIdxCount = 0;
  for( int i = 0; i < CmdListsCount; i++ )
  {
    ImDrawList* cmd_list = CmdLists[ i ];
    if( cmd_list->IdxBuffer.empty() )
      continue;
    new_vtx_buffer.resize( cmd_list->IdxBuffer.Size );
    for( int j = 0; j < cmd_list->IdxBuffer.Size; j++ )
      new_vtx_buffer[ j ] = cmd_list->VtxBuffer[ cmd_list->IdxBuffer[ j ] ];
    cmd_list->VtxBuffer.swap( new_vtx_buffer );
    cmd_list->IdxBuffer.resize( 0 );
    TotalVtxCount += cmd_list->VtxBuffer.Size;
  }
}

// Helper to scale the ClipRect field of each ImDrawCmd.
// Use if your final output buffer is at a different scale than draw_data->DisplaySize,
// or if there is a difference between your window resolution and framebuffer resolution.
void ImDrawData::ScaleClipRects( const ImVec2& fb_scale )
{
  for( int i = 0; i < CmdListsCount; i++ )
  {
    ImDrawList* cmd_list = CmdLists[ i ];
    for( int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++ )
    {
      ImDrawCmd* cmd = &cmd_list->CmdBuffer[ cmd_i ];
      cmd->ClipRect = ImVec4( cmd->ClipRect.x * fb_scale.x, cmd->ClipRect.y * fb_scale.y, cmd->ClipRect.z * fb_scale.x, cmd->ClipRect.w * fb_scale.y );
    }
  }
}

//-----------------------------------------------------------------------------
// [SECTION] Helpers ShadeVertsXXX functions
//-----------------------------------------------------------------------------

// Generic linear color gradient, write to RGB fields, leave A untouched.
void ImGui::ShadeVertsLinearColorGradientKeepAlpha( ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1 )
{
  ImVec2 gradient_extent = gradient_p1 - gradient_p0;
  float gradient_inv_length2 = 1.0f / ImLengthSqr( gradient_extent );
  ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
  ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
  for( ImDrawVert* vert = vert_start; vert < vert_end; vert++ )
  {
    float d = ImDot( vert->pos - gradient_p0, gradient_extent );
    float t = ImClamp( d * gradient_inv_length2, 0.0f, 1.0f );
    int r = ImLerp( ( int )( col0 >> IM_COL32_R_SHIFT ) & 0xFF, ( int )( col1 >> IM_COL32_R_SHIFT ) & 0xFF, t );
    int g = ImLerp( ( int )( col0 >> IM_COL32_G_SHIFT ) & 0xFF, ( int )( col1 >> IM_COL32_G_SHIFT ) & 0xFF, t );
    int b = ImLerp( ( int )( col0 >> IM_COL32_B_SHIFT ) & 0xFF, ( int )( col1 >> IM_COL32_B_SHIFT ) & 0xFF, t );
    vert->col = ( r << IM_COL32_R_SHIFT ) | ( g << IM_COL32_G_SHIFT ) | ( b << IM_COL32_B_SHIFT ) | ( vert->col & IM_COL32_A_MASK );
  }
}

// Distribute UV over (a, b) rectangle
void ImGui::ShadeVertsLinearUV( ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp )
{
  const ImVec2 size = b - a;
  const ImVec2 uv_size = uv_b - uv_a;
  const ImVec2 scale = ImVec2(
    size.x != 0.0f ? ( uv_size.x / size.x ) : 0.0f,
    size.y != 0.0f ? ( uv_size.y / size.y ) : 0.0f );

  ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
  ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
  if( clamp )
  {
    const ImVec2 min = ImMin( uv_a, uv_b );
    const ImVec2 max = ImMax( uv_a, uv_b );
    for( ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex )
      vertex->uv = ImClamp( uv_a + ImMul( ImVec2( vertex->pos.x, vertex->pos.y ) - a, scale ), min, max );
  }
  else
  {
    for( ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex )
      vertex->uv = uv_a + ImMul( ImVec2( vertex->pos.x, vertex->pos.y ) - a, scale );
  }
}

//-----------------------------------------------------------------------------
// [SECTION] ImFontConfig
//-----------------------------------------------------------------------------

ImFontConfig::ImFontConfig()
{
  FontData = NULL;
  FontDataSize = 0;
  FontDataOwnedByAtlas = true;
  FontNo = 0;
  SizePixels = 0.0f;
  OversampleH = 3; // FIXME: 2 may be a better default?
  OversampleV = 1;
  PixelSnapH = false;
  GlyphExtraSpacing = ImVec2( 0.0f, 0.0f );
  GlyphOffset = ImVec2( 0.0f, 0.0f );
  GlyphRanges = NULL;
  GlyphMinAdvanceX = 0.0f;
  GlyphMaxAdvanceX = FLT_MAX;
  MergeMode = false;
  RasterizerFlags = 0x00;
  RasterizerMultiply = 1.0f;
  EllipsisChar = ( ImWchar )-1;
  memset( Name, 0, sizeof( Name ) );
  DstFont = NULL;
}

//-----------------------------------------------------------------------------
// [SECTION] ImFontAtlas
//-----------------------------------------------------------------------------

// A work of art lies ahead! (. = white layer, X = black layer, others are blank)
// The white texels on the top left are the ones we'll use everywhere in Dear ImGui to render filled shapes.
const int FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF = 108;
const int FONT_ATLAS_DEFAULT_TEX_DATA_H = 27;

/*
static const char FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[ FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * FONT_ATLAS_DEFAULT_TEX_DATA_H + 1 ] =
{
    "..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX-     XX          "
    "..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X-    X..X         "
    "---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X-    X..X         "
    "X           -  X.X  - X.....X -        X.....X        -X...X            -            X...X-    X..X         "
    "XX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..X-    X..X         "
    "X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.X-    X..XXX       "
    "X..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XX-    X..X..XXX    "
    "X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      -    X..X..X..XX  "
    "X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       -    X..X..X..X.X "
    "X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        -XXX X..X..X..X..X"
    "X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         -X..XX........X..X"
    "X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          -X...X...........X"
    "X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           - X..............X"
    "X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            -  X.............X"
    "X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           -  X.............X"
    "X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          -   X............X"
    "X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          -   X...........X "
    "X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       -------------------------------------    X..........X "
    "X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           -    X..........X "
    "XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -           -     X........X  "
    "      X..X          -  X...X  -         X...X         -  X..X           X..X  -           -     X........X  "
    "       XX           -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           -     XXXXXXXXXX  "
    "------------        -    X    -           X           -X.....................X-           ------------------"
    "                    ----------------------------------- X...XXXXXXXXXXXXX...X -                             "
    "                                                      -  X..X           X..X  -                             "
    "                                                      -   X.X           X.X   -                             "
    "                                                      -    XX           XX    -                             "
};
*/

static const ImVec2 FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[ ImGuiMouseCursor_COUNT ][ 3 ] =
{
  // Pos ........ Size ......... Offset ......
  { ImVec2( 0,3 ), ImVec2( 12,19 ), ImVec2( 0, 0 ) }, // ImGuiMouseCursor_Arrow
  { ImVec2( 13,0 ), ImVec2( 7,16 ), ImVec2( 1, 8 ) }, // ImGuiMouseCursor_TextInput
  { ImVec2( 31,0 ), ImVec2( 23,23 ), ImVec2( 11,11 ) }, // ImGuiMouseCursor_ResizeAll
  { ImVec2( 21,0 ), ImVec2( 9,23 ), ImVec2( 4,11 ) }, // ImGuiMouseCursor_ResizeNS
  { ImVec2( 55,18 ),ImVec2( 23, 9 ), ImVec2( 11, 4 ) }, // ImGuiMouseCursor_ResizeEW
  { ImVec2( 73,0 ), ImVec2( 17,17 ), ImVec2( 8, 8 ) }, // ImGuiMouseCursor_ResizeNESW
  { ImVec2( 55,0 ), ImVec2( 17,17 ), ImVec2( 8, 8 ) }, // ImGuiMouseCursor_ResizeNWSE
  { ImVec2( 91,0 ), ImVec2( 17,22 ), ImVec2( 5, 0 ) }, // ImGuiMouseCursor_Hand
};

ImFontAtlas::ImFontAtlas()
{
  Locked = false;
  Flags = ImFontAtlasFlags_None;
  TexID = ( ImTextureID )NULL;
  TexDesiredWidth = 0;
  TexGlyphPadding = 1;

  TexPixelsAlpha8 = NULL;
  TexPixelsRGBA32 = NULL;
  TexWidth = TexHeight = 0;
  TexUvScale = ImVec2( 0.0f, 0.0f );
  TexUvWhitePixel = ImVec2( 0.0f, 0.0f );
  for( int n = 0; n < IM_ARRAYSIZE( CustomRectIds ); n++ )
    CustomRectIds[ n ] = -1;
}

ImFontAtlas::~ImFontAtlas()
{
  IM_ASSERT( !Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!" );
  Clear();
}

void    ImFontAtlas::ClearInputData()
{
  IM_ASSERT( !Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!" );
  for( int i = 0; i < ConfigData.Size; i++ )
    if( ConfigData[ i ].FontData && ConfigData[ i ].FontDataOwnedByAtlas )
    {
      IM_FREE( ConfigData[ i ].FontData );
      ConfigData[ i ].FontData = NULL;
    }

  // When clearing this we lose access to the font name and other information used to build the font.
  for( int i = 0; i < Fonts.Size; i++ )
    if( Fonts[ i ]->ConfigData >= ConfigData.Data && Fonts[ i ]->ConfigData < ConfigData.Data + ConfigData.Size )
    {
      Fonts[ i ]->ConfigData = NULL;
      Fonts[ i ]->ConfigDataCount = 0;
    }
  ConfigData.clear();
  CustomRects.clear();
  for( int n = 0; n < IM_ARRAYSIZE( CustomRectIds ); n++ )
    CustomRectIds[ n ] = -1;
}

void    ImFontAtlas::ClearTexData()
{
  IM_ASSERT( !Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!" );
  if( TexPixelsAlpha8 )
    IM_FREE( TexPixelsAlpha8 );
  if( TexPixelsRGBA32 )
    IM_FREE( TexPixelsRGBA32 );
  TexPixelsAlpha8 = NULL;
  TexPixelsRGBA32 = NULL;
}

void    ImFontAtlas::ClearFonts()
{
  IM_ASSERT( !Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!" );
  for( int i = 0; i < Fonts.Size; i++ )
    IM_DELETE( Fonts[ i ] );
  Fonts.clear();
}

void    ImFontAtlas::Clear()
{
  ClearInputData();
  ClearTexData();
  ClearFonts();
}

void    ImFontAtlas::GetTexDataAsAlpha8( unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel )
{
  // Build atlas on demand
  if( TexPixelsAlpha8 == NULL )
  {
    if( ConfigData.empty() )
      AddFontDefault();
    Build();
  }

  *out_pixels = TexPixelsAlpha8;
  if( out_width ) *out_width = TexWidth;
  if( out_height ) *out_height = TexHeight;
  if( out_bytes_per_pixel ) *out_bytes_per_pixel = 1;
}

void    ImFontAtlas::GetTexDataAsRGBA32( unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel )
{
  // Convert to RGBA32 format on demand
  // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
  if( !TexPixelsRGBA32 )
  {
    unsigned char* pixels = NULL;
    GetTexDataAsAlpha8( &pixels, NULL, NULL );
    if( pixels )
    {
      TexPixelsRGBA32 = ( unsigned int* )IM_ALLOC( ( size_t )TexWidth * ( size_t )TexHeight * 4 );
      const unsigned char* src = pixels;
      unsigned int* dst = TexPixelsRGBA32;
      for( int n = TexWidth * TexHeight; n > 0; n-- )
        *dst++ = IM_COL32( 255, 255, 255, ( unsigned int )( *src++ ) );
    }
  }

  *out_pixels = ( unsigned char* )TexPixelsRGBA32;
  if( out_width ) *out_width = TexWidth;
  if( out_height ) *out_height = TexHeight;
  if( out_bytes_per_pixel ) *out_bytes_per_pixel = 4;
}

ImFont* ImFontAtlas::AddFont( const ImFontConfig* font_cfg )
{
  IM_ASSERT( !Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!" );
  IM_ASSERT( font_cfg->FontData != NULL && font_cfg->FontDataSize > 0 );
  IM_ASSERT( font_cfg->SizePixels > 0.0f );

  // Create new font
  if( !font_cfg->MergeMode )
    Fonts.push_back( IM_NEW( ImFont ) );
  else
    IM_ASSERT( !Fonts.empty() && "Cannot use MergeMode for the first font" ); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.

  ConfigData.push_back( *font_cfg );
  ImFontConfig& new_font_cfg = ConfigData.back();
  if( new_font_cfg.DstFont == NULL )
    new_font_cfg.DstFont = Fonts.back();
  if( !new_font_cfg.FontDataOwnedByAtlas )
  {
    new_font_cfg.FontData = IM_ALLOC( new_font_cfg.FontDataSize );
    new_font_cfg.FontDataOwnedByAtlas = true;
    memcpy( new_font_cfg.FontData, font_cfg->FontData, ( size_t )new_font_cfg.FontDataSize );
  }

  if( new_font_cfg.DstFont->EllipsisChar == ( ImWchar )-1 )
    new_font_cfg.DstFont->EllipsisChar = font_cfg->EllipsisChar;

  // Invalidate texture
  ClearTexData();
  return new_font_cfg.DstFont;
}

// Default font TTF is compressed with stb_compress then base85 encoded (see misc/fonts/binary_to_compressed_c.cpp for encoder)
static unsigned int stb_decompress_length( const unsigned char* input );
static unsigned int stb_decompress( unsigned char* output, const unsigned char* input, unsigned int length );
static const char* GetDefaultCompressedFontDataTTFBase85();
static unsigned int Decode85Byte( char c )
{
  return c >= '\\' ? c - 36 : c - 35;
}
static void         Decode85( const unsigned char* src, unsigned char* dst )
{
  while( *src )
  {
    unsigned int tmp = Decode85Byte( src[ 0 ] ) + 85 * ( Decode85Byte( src[ 1 ] ) + 85 * ( Decode85Byte( src[ 2 ] ) + 85 * ( Decode85Byte( src[ 3 ] ) + 85 * Decode85Byte( src[ 4 ] ) ) ) );
    dst[ 0 ] = ( ( tmp >> 0 ) & 0xFF ); dst[ 1 ] = ( ( tmp >> 8 ) & 0xFF ); dst[ 2 ] = ( ( tmp >> 16 ) & 0xFF ); dst[ 3 ] = ( ( tmp >> 24 ) & 0xFF );   // We can't assume little-endianness.
    src += 5;
    dst += 4;
  }
}

extern const unsigned int ubuntu_mono_compressed_size;
extern const unsigned int ubuntu_mono_compressed_data[ 150392 / 4 ];

// Load embedded ProggyClean.ttf at size 13, disable oversampling
ImFont* ImFontAtlas::AddFontDefault( const ImFontConfig* font_cfg_template )
{
  ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
  if( !font_cfg_template )
  {
    font_cfg.OversampleH = font_cfg.OversampleV = 1;
    font_cfg.PixelSnapH = true;
  }
  if( font_cfg.SizePixels <= 0.0f )
    font_cfg.SizePixels = 13.0f * 1.0f;
  if( font_cfg.Name[ 0 ] == '\0' )
    ImFormatString( font_cfg.Name, IM_ARRAYSIZE( font_cfg.Name ), SECURE( "ProggyClean.ttf, %dpx" ), ( int )font_cfg.SizePixels );
  font_cfg.EllipsisChar = ( ImWchar )0x0085;

  // const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
  const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();
  // ImFont* font = AddFontFromMemoryCompressedBase85TTF( ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges );
  ImFont* font = AddFontFromMemoryCompressedTTF( ubuntu_mono_compressed_data, ubuntu_mono_compressed_size, font_cfg.SizePixels, &font_cfg, glyph_ranges );
  font->DisplayOffset.y = 1.0f;
  return font;
}

ImFont* ImFontAtlas::AddFontFromFileTTF( const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges )
{
  IM_ASSERT( !Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!" );
  size_t data_size = 0;
  void* data = ImFileLoadToMemory( filename, SECURE("rb"), &data_size, 0 );
  if( !data )
  {
    IM_ASSERT_USER_ERROR( 0, "Could not load font file!" );
    return NULL;
  }
  ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
  if( font_cfg.Name[ 0 ] == '\0' )
  {
    // Store a short copy of filename into into the font name for convenience
    const char* p;
    for( p = filename + strlen( filename ); p > filename && p[ -1 ] != '/' && p[ -1 ] != '\\'; p-- )
    {
    }
    ImFormatString( font_cfg.Name, IM_ARRAYSIZE( font_cfg.Name ), SECURE("%s, %.0fpx"), p, size_pixels );
  }
  return AddFontFromMemoryTTF( data, ( int )data_size, size_pixels, &font_cfg, glyph_ranges );
}

// NB: Transfer ownership of 'ttf_data' to ImFontAtlas, unless font_cfg_template->FontDataOwnedByAtlas == false. Owned TTF buffer will be deleted after Build().
ImFont* ImFontAtlas::AddFontFromMemoryTTF( void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges )
{
  IM_ASSERT( !Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!" );
  ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
  IM_ASSERT( font_cfg.FontData == NULL );
  font_cfg.FontData = ttf_data;
  font_cfg.FontDataSize = ttf_size;
  font_cfg.SizePixels = size_pixels;
  if( glyph_ranges )
    font_cfg.GlyphRanges = glyph_ranges;
  return AddFont( &font_cfg );
}

ImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF( const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges )
{
  const unsigned int buf_decompressed_size = stb_decompress_length( ( const unsigned char* )compressed_ttf_data );
  unsigned char* buf_decompressed_data = ( unsigned char* )IM_ALLOC( buf_decompressed_size );
  stb_decompress( buf_decompressed_data, ( const unsigned char* )compressed_ttf_data, ( unsigned int )compressed_ttf_size );

  ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
  IM_ASSERT( font_cfg.FontData == NULL );
  font_cfg.FontDataOwnedByAtlas = true;
  return AddFontFromMemoryTTF( buf_decompressed_data, ( int )buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges );
}

ImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF( const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges )
{
  int compressed_ttf_size = ( ( ( int )strlen( compressed_ttf_data_base85 ) + 4 ) / 5 ) * 4;
  void* compressed_ttf = IM_ALLOC( ( size_t )compressed_ttf_size );
  Decode85( ( const unsigned char* )compressed_ttf_data_base85, ( unsigned char* )compressed_ttf );
  ImFont* font = AddFontFromMemoryCompressedTTF( compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges );
  IM_FREE( compressed_ttf );
  return font;
}

int ImFontAtlas::AddCustomRectRegular( int width, int height )
{
  IM_ASSERT( width > 0 && width <= 0xFFFF );
  IM_ASSERT( height > 0 && height <= 0xFFFF );
  ImFontAtlasCustomRect r;
  r.Width = ( unsigned short )width;
  r.Height = ( unsigned short )height;
  CustomRects.push_back( r );
  return CustomRects.Size - 1; // Return index
}

int ImFontAtlas::AddCustomRectFontGlyph( ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset )
{
#ifdef IMGUI_USE_WCHAR32
  IM_ASSERT( id <= IM_UNICODE_CODEPOINT_MAX );
#endif
  IM_ASSERT( font != NULL );
  IM_ASSERT( width > 0 && width <= 0xFFFF );
  IM_ASSERT( height > 0 && height <= 0xFFFF );
  ImFontAtlasCustomRect r;
  r.Width = ( unsigned short )width;
  r.Height = ( unsigned short )height;
  r.GlyphID = id;
  r.GlyphAdvanceX = advance_x;
  r.GlyphOffset = offset;
  r.Font = font;
  CustomRects.push_back( r );
  return CustomRects.Size - 1; // Return index
}

void ImFontAtlas::CalcCustomRectUV( const ImFontAtlasCustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max ) const
{
  IM_ASSERT( TexWidth > 0 && TexHeight > 0 );   // Font atlas needs to be built before we can calculate UV coordinates
  IM_ASSERT( rect->IsPacked() );                // Make sure the rectangle has been packed
  *out_uv_min = ImVec2( ( float )rect->X * TexUvScale.x, ( float )rect->Y * TexUvScale.y );
  *out_uv_max = ImVec2( ( float )( rect->X + rect->Width ) * TexUvScale.x, ( float )( rect->Y + rect->Height ) * TexUvScale.y );
}

bool ImFontAtlas::GetMouseCursorTexData( ImGuiMouseCursor cursor_type, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[ 2 ], ImVec2 out_uv_fill[ 2 ] )
{
  if( cursor_type <= ImGuiMouseCursor_None || cursor_type >= ImGuiMouseCursor_COUNT )
    return false;
  if( Flags & ImFontAtlasFlags_NoMouseCursors )
    return false;

  IM_ASSERT( CustomRectIds[ 0 ] != -1 );
  ImFontAtlasCustomRect& r = CustomRects[ CustomRectIds[ 0 ] ];
  ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[ cursor_type ][ 0 ] + ImVec2( ( float )r.X, ( float )r.Y );
  ImVec2 size = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[ cursor_type ][ 1 ];
  *out_size = size;
  *out_offset = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[ cursor_type ][ 2 ];
  out_uv_border[ 0 ] = ( pos )*TexUvScale;
  out_uv_border[ 1 ] = ( pos + size ) * TexUvScale;
  pos.x += FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;
  out_uv_fill[ 0 ] = ( pos )*TexUvScale;
  out_uv_fill[ 1 ] = ( pos + size ) * TexUvScale;
  return true;
}

bool    ImFontAtlas::Build()
{
  IM_ASSERT( !Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!" );
  return ImFontAtlasBuildWithStbTruetype( this );
}

void    ImFontAtlasBuildMultiplyCalcLookupTable( unsigned char out_table[ 256 ], float in_brighten_factor )
{
  for( unsigned int i = 0; i < 256; i++ )
  {
    unsigned int value = ( unsigned int )( i * in_brighten_factor );
    out_table[ i ] = value > 255 ? 255 : ( value & 0xFF );
  }
}

void    ImFontAtlasBuildMultiplyRectAlpha8( const unsigned char table[ 256 ], unsigned char* pixels, int x, int y, int w, int h, int stride )
{
  unsigned char* data = pixels + x + y * stride;
  for( int j = h; j > 0; j--, data += stride )
    for( int i = 0; i < w; i++ )
      data[ i ] = table[ data[ i ] ];
}

// Temporary data for one source font (multiple source fonts can be merged into one destination ImFont)
// (C++03 doesn't allow instancing ImVector<> with function-local types so we declare the type here.)
struct ImFontBuildSrcData
{
  stbtt_fontinfo      FontInfo;
  stbtt_pack_range    PackRange;          // Hold the list of codepoints to pack (essentially points to Codepoints.Data)
  stbrp_rect* Rects;              // Rectangle to pack. We first fill in their size and the packer will give us their position.
  stbtt_packedchar* PackedChars;        // Output glyphs
  const ImWchar* SrcRanges;          // Ranges as requested by user (user is allowed to request too much, e.g. 0x0020..0xFFFF)
  int                 DstIndex;           // Index into atlas->Fonts[] and dst_tmp_array[]
  int                 GlyphsHighest;      // Highest requested codepoint
  int                 GlyphsCount;        // Glyph count (excluding missing glyphs and glyphs already set by an earlier source font)
  ImBitVector         GlyphsSet;          // Glyph bit map (random access, 1-bit per codepoint. This will be a maximum of 8KB)
  ImVector<int>       GlyphsList;         // Glyph codepoints list (flattened version of GlyphsMap)
};

// Temporary data for one destination ImFont* (multiple source fonts can be merged into one destination ImFont)
struct ImFontBuildDstData
{
  int                 SrcCount;           // Number of source fonts targeting this destination font.
  int                 GlyphsHighest;
  int                 GlyphsCount;
  ImBitVector         GlyphsSet;          // This is used to resolve collision when multiple sources are merged into a same destination font.
};

static void UnpackBitVectorToFlatIndexList( const ImBitVector* in, ImVector<int>* out )
{
  IM_ASSERT( sizeof( in->Storage.Data[ 0 ] ) == sizeof( int ) );
  const ImU32* it_begin = in->Storage.begin();
  const ImU32* it_end = in->Storage.end();
  for( const ImU32* it = it_begin; it < it_end; it++ )
    if( ImU32 entries_32 = *it )
      for( ImU32 bit_n = 0; bit_n < 32; bit_n++ )
        if( entries_32 & ( ( ImU32 )1 << bit_n ) )
          out->push_back( ( int )( ( ( it - it_begin ) << 5 ) + bit_n ) );
}

bool    ImFontAtlasBuildWithStbTruetype( ImFontAtlas* atlas )
{
  IM_ASSERT( atlas->ConfigData.Size > 0 );

  ImFontAtlasBuildInit( atlas );

  // Clear atlas
  atlas->TexID = ( ImTextureID )NULL;
  atlas->TexWidth = atlas->TexHeight = 0;
  atlas->TexUvScale = ImVec2( 0.0f, 0.0f );
  atlas->TexUvWhitePixel = ImVec2( 0.0f, 0.0f );
  atlas->ClearTexData();

  // Temporary storage for building
  ImVector<ImFontBuildSrcData> src_tmp_array;
  ImVector<ImFontBuildDstData> dst_tmp_array;
  src_tmp_array.resize( atlas->ConfigData.Size );
  dst_tmp_array.resize( atlas->Fonts.Size );
  memset( src_tmp_array.Data, 0, ( size_t )src_tmp_array.size_in_bytes() );
  memset( dst_tmp_array.Data, 0, ( size_t )dst_tmp_array.size_in_bytes() );

  // 1. Initialize font loading structure, check font data validity
  for( int src_i = 0; src_i < atlas->ConfigData.Size; src_i++ )
  {
    ImFontBuildSrcData& src_tmp = src_tmp_array[ src_i ];
    ImFontConfig& cfg = atlas->ConfigData[ src_i ];
    IM_ASSERT( cfg.DstFont && ( !cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas ) );

    // Find index from cfg.DstFont (we allow the user to set cfg.DstFont. Also it makes casual debugging nicer than when storing indices)
    src_tmp.DstIndex = -1;
    for( int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++ )
      if( cfg.DstFont == atlas->Fonts[ output_i ] )
        src_tmp.DstIndex = output_i;
    IM_ASSERT( src_tmp.DstIndex != -1 ); // cfg.DstFont not pointing within atlas->Fonts[] array?
    if( src_tmp.DstIndex == -1 )
      return false;

    // Initialize helper structure for font loading and verify that the TTF/OTF data is correct
    const int font_offset = stbtt_GetFontOffsetForIndex( ( unsigned char* )cfg.FontData, cfg.FontNo );
    IM_ASSERT( font_offset >= 0 && "FontData is incorrect, or FontNo cannot be found." );
    if( !stbtt_InitFont( &src_tmp.FontInfo, ( unsigned char* )cfg.FontData, font_offset ) )
      return false;

    // Measure highest codepoints
    ImFontBuildDstData& dst_tmp = dst_tmp_array[ src_tmp.DstIndex ];
    src_tmp.SrcRanges = cfg.GlyphRanges ? cfg.GlyphRanges : atlas->GetGlyphRangesDefault();
    for( const ImWchar* src_range = src_tmp.SrcRanges; src_range[ 0 ] && src_range[ 1 ]; src_range += 2 )
      src_tmp.GlyphsHighest = ImMax( src_tmp.GlyphsHighest, ( int )src_range[ 1 ] );
    dst_tmp.SrcCount++;
    dst_tmp.GlyphsHighest = ImMax( dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest );
  }

  // 2. For every requested codepoint, check for their presence in the font data, and handle redundancy or overlaps between source fonts to avoid unused glyphs.
  int total_glyphs_count = 0;
  for( int src_i = 0; src_i < src_tmp_array.Size; src_i++ )
  {
    ImFontBuildSrcData& src_tmp = src_tmp_array[ src_i ];
    ImFontBuildDstData& dst_tmp = dst_tmp_array[ src_tmp.DstIndex ];
    src_tmp.GlyphsSet.Create( src_tmp.GlyphsHighest + 1 );
    if( dst_tmp.GlyphsSet.Storage.empty() )
      dst_tmp.GlyphsSet.Create( dst_tmp.GlyphsHighest + 1 );

    for( const ImWchar* src_range = src_tmp.SrcRanges; src_range[ 0 ] && src_range[ 1 ]; src_range += 2 )
      for( unsigned int codepoint = src_range[ 0 ]; codepoint <= src_range[ 1 ]; codepoint++ )
      {
        if( dst_tmp.GlyphsSet.TestBit( codepoint ) )    // Don't overwrite existing glyphs. We could make this an option for MergeMode (e.g. MergeOverwrite==true)
          continue;
        if( !stbtt_FindGlyphIndex( &src_tmp.FontInfo, codepoint ) )    // It is actually in the font?
          continue;

        // Add to avail set/counters
        src_tmp.GlyphsCount++;
        dst_tmp.GlyphsCount++;
        src_tmp.GlyphsSet.SetBit( codepoint );
        dst_tmp.GlyphsSet.SetBit( codepoint );
        total_glyphs_count++;
      }
  }

  // 3. Unpack our bit map into a flat list (we now have all the Unicode points that we know are requested _and_ available _and_ not overlapping another)
  for( int src_i = 0; src_i < src_tmp_array.Size; src_i++ )
  {
    ImFontBuildSrcData& src_tmp = src_tmp_array[ src_i ];
    src_tmp.GlyphsList.reserve( src_tmp.GlyphsCount );
    UnpackBitVectorToFlatIndexList( &src_tmp.GlyphsSet, &src_tmp.GlyphsList );
    src_tmp.GlyphsSet.Clear();
    IM_ASSERT( src_tmp.GlyphsList.Size == src_tmp.GlyphsCount );
  }
  for( int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++ )
    dst_tmp_array[ dst_i ].GlyphsSet.Clear();
  dst_tmp_array.clear();

  // Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)
  // (We technically don't need to zero-clear buf_rects, but let's do it for the sake of sanity)
  ImVector<stbrp_rect> buf_rects;
  ImVector<stbtt_packedchar> buf_packedchars;
  buf_rects.resize( total_glyphs_count );
  buf_packedchars.resize( total_glyphs_count );
  memset( buf_rects.Data, 0, ( size_t )buf_rects.size_in_bytes() );
  memset( buf_packedchars.Data, 0, ( size_t )buf_packedchars.size_in_bytes() );

  // 4. Gather glyphs sizes so we can pack them in our virtual canvas.
  int total_surface = 0;
  int buf_rects_out_n = 0;
  int buf_packedchars_out_n = 0;
  for( int src_i = 0; src_i < src_tmp_array.Size; src_i++ )
  {
    ImFontBuildSrcData& src_tmp = src_tmp_array[ src_i ];
    if( src_tmp.GlyphsCount == 0 )
      continue;

    src_tmp.Rects = &buf_rects[ buf_rects_out_n ];
    src_tmp.PackedChars = &buf_packedchars[ buf_packedchars_out_n ];
    buf_rects_out_n += src_tmp.GlyphsCount;
    buf_packedchars_out_n += src_tmp.GlyphsCount;

    // Convert our ranges in the format stb_truetype wants
    ImFontConfig& cfg = atlas->ConfigData[ src_i ];
    src_tmp.PackRange.font_size = cfg.SizePixels;
    src_tmp.PackRange.first_unicode_codepoint_in_range = 0;
    src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data;
    src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size;
    src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars;
    src_tmp.PackRange.h_oversample = ( unsigned char )cfg.OversampleH;
    src_tmp.PackRange.v_oversample = ( unsigned char )cfg.OversampleV;

    // Gather the sizes of all rectangles we will need to pack (this loop is based on stbtt_PackFontRangesGatherRects)
    const float scale = ( cfg.SizePixels > 0 ) ? stbtt_ScaleForPixelHeight( &src_tmp.FontInfo, cfg.SizePixels ) : stbtt_ScaleForMappingEmToPixels( &src_tmp.FontInfo, -cfg.SizePixels );
    const int padding = atlas->TexGlyphPadding;
    for( int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++ )
    {
      int x0, y0, x1, y1;
      const int glyph_index_in_font = stbtt_FindGlyphIndex( &src_tmp.FontInfo, src_tmp.GlyphsList[ glyph_i ] );
      IM_ASSERT( glyph_index_in_font != 0 );
      stbtt_GetGlyphBitmapBoxSubpixel( &src_tmp.FontInfo, glyph_index_in_font, scale * cfg.OversampleH, scale * cfg.OversampleV, 0, 0, &x0, &y0, &x1, &y1 );
      src_tmp.Rects[ glyph_i ].w = ( stbrp_coord )( x1 - x0 + padding + cfg.OversampleH - 1 );
      src_tmp.Rects[ glyph_i ].h = ( stbrp_coord )( y1 - y0 + padding + cfg.OversampleV - 1 );
      total_surface += src_tmp.Rects[ glyph_i ].w * src_tmp.Rects[ glyph_i ].h;
    }
  }

  // We need a width for the skyline algorithm, any width!
  // The exact width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
  // User can override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use a simple heuristic to select the width based on expected surface.
  const int surface_sqrt = ( int )ImSqrt( ( float )total_surface ) + 1;
  atlas->TexHeight = 0;
  if( atlas->TexDesiredWidth > 0 )
    atlas->TexWidth = atlas->TexDesiredWidth;
  else
    atlas->TexWidth = ( surface_sqrt >= 4096 * 0.7f ) ? 4096 : ( surface_sqrt >= 2048 * 0.7f ) ? 2048 : ( surface_sqrt >= 1024 * 0.7f ) ? 1024 : 512;

  // 5. Start packing
  // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).
  const int TEX_HEIGHT_MAX = 1024 * 32;
  stbtt_pack_context spc = {};
  stbtt_PackBegin( &spc, NULL, atlas->TexWidth, TEX_HEIGHT_MAX, 0, atlas->TexGlyphPadding, NULL );
  ImFontAtlasBuildPackCustomRects( atlas, spc.pack_info );

  // 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.
  for( int src_i = 0; src_i < src_tmp_array.Size; src_i++ )
  {
    ImFontBuildSrcData& src_tmp = src_tmp_array[ src_i ];
    if( src_tmp.GlyphsCount == 0 )
      continue;

    stbrp_pack_rects( ( stbrp_context* )spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount );

    // Extend texture height and mark missing glyphs as non-packed so we won't render them.
    // FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
    for( int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++ )
      if( src_tmp.Rects[ glyph_i ].was_packed )
        atlas->TexHeight = ImMax( atlas->TexHeight, src_tmp.Rects[ glyph_i ].y + src_tmp.Rects[ glyph_i ].h );
  }

  // 7. Allocate texture
  atlas->TexHeight = ( atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight ) ? ( atlas->TexHeight + 1 ) : ImUpperPowerOfTwo( atlas->TexHeight );
  atlas->TexUvScale = ImVec2( 1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight );
  atlas->TexPixelsAlpha8 = ( unsigned char* )IM_ALLOC( atlas->TexWidth * atlas->TexHeight );
  memset( atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight );
  spc.pixels = atlas->TexPixelsAlpha8;
  spc.height = atlas->TexHeight;

  // 8. Render/rasterize font characters into the texture
  for( int src_i = 0; src_i < src_tmp_array.Size; src_i++ )
  {
    ImFontConfig& cfg = atlas->ConfigData[ src_i ];
    ImFontBuildSrcData& src_tmp = src_tmp_array[ src_i ];
    if( src_tmp.GlyphsCount == 0 )
      continue;

    stbtt_PackFontRangesRenderIntoRects( &spc, &src_tmp.FontInfo, &src_tmp.PackRange, 1, src_tmp.Rects );

    // Apply multiply operator
    if( cfg.RasterizerMultiply != 1.0f )
    {
      unsigned char multiply_table[ 256 ];
      ImFontAtlasBuildMultiplyCalcLookupTable( multiply_table, cfg.RasterizerMultiply );
      stbrp_rect* r = &src_tmp.Rects[ 0 ];
      for( int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++ )
        if( r->was_packed )
          ImFontAtlasBuildMultiplyRectAlpha8( multiply_table, atlas->TexPixelsAlpha8, r->x, r->y, r->w, r->h, atlas->TexWidth * 1 );
    }
    src_tmp.Rects = NULL;
  }

  // End packing
  stbtt_PackEnd( &spc );
  buf_rects.clear();

  // 9. Setup ImFont and glyphs for runtime
  for( int src_i = 0; src_i < src_tmp_array.Size; src_i++ )
  {
    ImFontBuildSrcData& src_tmp = src_tmp_array[ src_i ];
    if( src_tmp.GlyphsCount == 0 )
      continue;

    ImFontConfig& cfg = atlas->ConfigData[ src_i ];
    ImFont* dst_font = cfg.DstFont; // We can have multiple input fonts writing into a same destination font (when using MergeMode=true)

    const float font_scale = stbtt_ScaleForPixelHeight( &src_tmp.FontInfo, cfg.SizePixels );
    int unscaled_ascent, unscaled_descent, unscaled_line_gap;
    stbtt_GetFontVMetrics( &src_tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap );

    const float ascent = ImFloor( unscaled_ascent * font_scale + ( ( unscaled_ascent > 0.0f ) ? +1 : -1 ) );
    const float descent = ImFloor( unscaled_descent * font_scale + ( ( unscaled_descent > 0.0f ) ? +1 : -1 ) );
    ImFontAtlasBuildSetupFont( atlas, dst_font, &cfg, ascent, descent );
    const float font_off_x = cfg.GlyphOffset.x;
    const float font_off_y = cfg.GlyphOffset.y + IM_ROUND( dst_font->Ascent );

    for( int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++ )
    {
      const int codepoint = src_tmp.GlyphsList[ glyph_i ];
      const stbtt_packedchar& pc = src_tmp.PackedChars[ glyph_i ];

      const float char_advance_x_org = pc.xadvance;
      const float char_advance_x_mod = ImClamp( char_advance_x_org, cfg.GlyphMinAdvanceX, cfg.GlyphMaxAdvanceX );
      float char_off_x = font_off_x;
      if( char_advance_x_org != char_advance_x_mod )
        char_off_x += cfg.PixelSnapH ? ImFloor( ( char_advance_x_mod - char_advance_x_org ) * 0.5f ) : ( char_advance_x_mod - char_advance_x_org ) * 0.5f;

      // Register glyph
      stbtt_aligned_quad q;
      float dummy_x = 0.0f, dummy_y = 0.0f;
      stbtt_GetPackedQuad( src_tmp.PackedChars, atlas->TexWidth, atlas->TexHeight, glyph_i, &dummy_x, &dummy_y, &q, 0 );
      dst_font->AddGlyph( ( ImWchar )codepoint, q.x0 + char_off_x, q.y0 + font_off_y, q.x1 + char_off_x, q.y1 + font_off_y, q.s0, q.t0, q.s1, q.t1, char_advance_x_mod );
    }
  }

  // Cleanup temporary (ImVector doesn't honor destructor)
  for( int src_i = 0; src_i < src_tmp_array.Size; src_i++ )
    src_tmp_array[ src_i ].~ImFontBuildSrcData();

  ImFontAtlasBuildFinish( atlas );
  return true;
}

// Register default custom rectangles (this is called/shared by both the stb_truetype and the FreeType builder)
void ImFontAtlasBuildInit( ImFontAtlas* atlas )
{
  if( atlas->CustomRectIds[ 0 ] >= 0 )
    return;
  if( !( atlas->Flags & ImFontAtlasFlags_NoMouseCursors ) )
    atlas->CustomRectIds[ 0 ] = atlas->AddCustomRectRegular( FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * 2 + 1, FONT_ATLAS_DEFAULT_TEX_DATA_H );
  else
    atlas->CustomRectIds[ 0 ] = atlas->AddCustomRectRegular( 2, 2 );
}

void ImFontAtlasBuildSetupFont( ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent )
{
  if( !font_config->MergeMode )
  {
    font->ClearOutputData();
    font->FontSize = font_config->SizePixels;
    font->ConfigData = font_config;
    font->ContainerAtlas = atlas;
    font->Ascent = ascent;
    font->Descent = descent;
  }
  font->ConfigDataCount++;
}

void ImFontAtlasBuildPackCustomRects( ImFontAtlas* atlas, void* stbrp_context_opaque )
{
  stbrp_context* pack_context = ( stbrp_context* )stbrp_context_opaque;
  IM_ASSERT( pack_context != NULL );

  ImVector<ImFontAtlasCustomRect>& user_rects = atlas->CustomRects;
  IM_ASSERT( user_rects.Size >= 1 ); // We expect at least the default custom rects to be registered, else something went wrong.

  ImVector<stbrp_rect> pack_rects;
  pack_rects.resize( user_rects.Size );
  memset( pack_rects.Data, 0, ( size_t )pack_rects.size_in_bytes() );
  for( int i = 0; i < user_rects.Size; i++ )
  {
    pack_rects[ i ].w = user_rects[ i ].Width;
    pack_rects[ i ].h = user_rects[ i ].Height;
  }
  stbrp_pack_rects( pack_context, &pack_rects[ 0 ], pack_rects.Size );
  for( int i = 0; i < pack_rects.Size; i++ )
    if( pack_rects[ i ].was_packed )
    {
      user_rects[ i ].X = pack_rects[ i ].x;
      user_rects[ i ].Y = pack_rects[ i ].y;
      IM_ASSERT( pack_rects[ i ].w == user_rects[ i ].Width && pack_rects[ i ].h == user_rects[ i ].Height );
      atlas->TexHeight = ImMax( atlas->TexHeight, pack_rects[ i ].y + pack_rects[ i ].h );
    }
}

static void ImFontAtlasBuildRenderDefaultTexData( ImFontAtlas* atlas )
{
  IM_ASSERT( atlas->CustomRectIds[ 0 ] >= 0 );
  IM_ASSERT( atlas->TexPixelsAlpha8 != NULL );
  ImFontAtlasCustomRect& r = atlas->CustomRects[ atlas->CustomRectIds[ 0 ] ];
  IM_ASSERT( r.IsPacked() );

  auto SECURE_FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS = SECURE_STRING(
		"..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX-     XX          "
		"..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X-    X..X         "
		"---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X-    X..X         "
		"X           -  X.X  - X.....X -        X.....X        -X...X            -            X...X-    X..X         "
		"XX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..X-    X..X         "
		"X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.X-    X..XXX       "
		"X..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XX-    X..X..XXX    "
		"X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      -    X..X..X..XX  "
		"X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       -    X..X..X..X.X "
		"X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        -XXX X..X..X..X..X"
		"X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         -X..XX........X..X"
		"X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          -X...X...........X"
		"X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           - X..............X"
		"X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            -  X.............X"
		"X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           -  X.............X"
		"X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          -   X............X"
		"X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          -   X...........X "
		"X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       -------------------------------------    X..........X "
		"X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           -    X..........X "
		"XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -           -     X........X  "
		"      X..X          -  X...X  -         X...X         -  X..X           X..X  -           -     X........X  "
		"       XX           -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           -     XXXXXXXXXX  "
		"------------        -    X    -           X           -X.....................X-           ------------------"
		"                    ----------------------------------- X...XXXXXXXXXXXXX...X -                             "
		"                                                      -  X..X           X..X  -                             "
		"                                                      -   X.X           X.X   -                             "
		"                                                      -    XX           XX    -                             "
  );

  const auto FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS = SECURE_FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS.decrypt();

  const int w = atlas->TexWidth;
  if( !( atlas->Flags & ImFontAtlasFlags_NoMouseCursors ) )
  {
    // Render/copy pixels
    IM_ASSERT( r.Width == FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * 2 + 1 && r.Height == FONT_ATLAS_DEFAULT_TEX_DATA_H );
    for( int y = 0, n = 0; y < FONT_ATLAS_DEFAULT_TEX_DATA_H; y++ )
      for( int x = 0; x < FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF; x++, n++ )
      {
        const int offset0 = ( int )( r.X + x ) + ( int )( r.Y + y ) * w;
        const int offset1 = offset0 + FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;
        atlas->TexPixelsAlpha8[ offset0 ] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[ n ] == '.' ? 0xFF : 0x00;
        atlas->TexPixelsAlpha8[ offset1 ] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[ n ] == 'X' ? 0xFF : 0x00;
      }
  }
  else
  {
    IM_ASSERT( r.Width == 2 && r.Height == 2 );
    const int offset = ( int )( r.X ) + ( int )( r.Y ) * w;
    atlas->TexPixelsAlpha8[ offset ] = atlas->TexPixelsAlpha8[ offset + 1 ] = atlas->TexPixelsAlpha8[ offset + w ] = atlas->TexPixelsAlpha8[ offset + w + 1 ] = 0xFF;
  }
  atlas->TexUvWhitePixel = ImVec2( ( r.X + 0.5f ) * atlas->TexUvScale.x, ( r.Y + 0.5f ) * atlas->TexUvScale.y );
}

void ImFontAtlasBuildFinish( ImFontAtlas* atlas )
{
  // Render into our custom data block
  ImFontAtlasBuildRenderDefaultTexData( atlas );

  // Register custom rectangle glyphs
  for( int i = 0; i < atlas->CustomRects.Size; i++ )
  {
    const ImFontAtlasCustomRect& r = atlas->CustomRects[ i ];
    if( r.Font == NULL || r.GlyphID == 0 )
      continue;

    IM_ASSERT( r.Font->ContainerAtlas == atlas );
    ImVec2 uv0, uv1;
    atlas->CalcCustomRectUV( &r, &uv0, &uv1 );
    r.Font->AddGlyph( ( ImWchar )r.GlyphID, r.GlyphOffset.x, r.GlyphOffset.y, r.GlyphOffset.x + r.Width, r.GlyphOffset.y + r.Height, uv0.x, uv0.y, uv1.x, uv1.y, r.GlyphAdvanceX );
  }

  // Build all fonts lookup tables
  for( int i = 0; i < atlas->Fonts.Size; i++ )
    if( atlas->Fonts[ i ]->DirtyLookupTables )
      atlas->Fonts[ i ]->BuildLookupTable();

  // Ellipsis character is required for rendering elided text. We prefer using U+2026 (horizontal ellipsis).
  // However some old fonts may contain ellipsis at U+0085. Here we auto-detect most suitable ellipsis character.
  // FIXME: Also note that 0x2026 is currently seldom included in our font ranges. Because of this we are more likely to use three individual dots.
  for( int i = 0; i < atlas->Fonts.size(); i++ )
  {
    ImFont* font = atlas->Fonts[ i ];
    if( font->EllipsisChar != ( ImWchar )-1 )
      continue;
    const ImWchar ellipsis_variants[] = { ( ImWchar )0x2026, ( ImWchar )0x0085 };
    for( int j = 0; j < IM_ARRAYSIZE( ellipsis_variants ); j++ )
      if( font->FindGlyphNoFallback( ellipsis_variants[ j ] ) != NULL ) // Verify glyph exists
      {
        font->EllipsisChar = ellipsis_variants[ j ];
        break;
      }
  }
}

// Retrieve list of range (2 int per range, values are inclusive)
const ImWchar* ImFontAtlas::GetGlyphRangesDefault()
{
  static const ImWchar ranges[] =
  {
      0x0020, 0x00FF, // Basic Latin + Latin Supplement
      0,
  };
  return &ranges[ 0 ];
}

const ImWchar* ImFontAtlas::GetGlyphRangesKorean()
{
  static const ImWchar ranges[] =
  {
      0x0020, 0x00FF, // Basic Latin + Latin Supplement
      0x3131, 0x3163, // Korean alphabets
      0xAC00, 0xD79D, // Korean characters
      0,
  };
  return &ranges[ 0 ];
}

const ImWchar* ImFontAtlas::GetGlyphRangesChineseFull()
{
  static const ImWchar ranges[] =
  {
      0x0020, 0x00FF, // Basic Latin + Latin Supplement
      0x2000, 0x206F, // General Punctuation
      0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
      0x31F0, 0x31FF, // Katakana Phonetic Extensions
      0xFF00, 0xFFEF, // Half-width characters
      0x4e00, 0x9FAF, // CJK Ideograms
      0,
  };
  return &ranges[ 0 ];
}

static void UnpackAccumulativeOffsetsIntoRanges( int base_codepoint, const short* accumulative_offsets, int accumulative_offsets_count, ImWchar* out_ranges )
{
  for( int n = 0; n < accumulative_offsets_count; n++, out_ranges += 2 )
  {
    out_ranges[ 0 ] = out_ranges[ 1 ] = ( ImWchar )( base_codepoint + accumulative_offsets[ n ] );
    base_codepoint += accumulative_offsets[ n ];
  }
  out_ranges[ 0 ] = 0;
}

//-------------------------------------------------------------------------
// [SECTION] ImFontAtlas glyph ranges helpers
//-------------------------------------------------------------------------

const ImWchar* ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon()
{
  // Store 2500 regularly used characters for Simplified Chinese.
  // Sourced from https://zh.wiktionary.org/wiki/%E9%99%84%E5%BD%95:%E7%8E%B0%E4%BB%A3%E6%B1%89%E8%AF%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E8%A1%A8
  // This table covers 97.97% of all characters used during the month in July, 1987.
  // You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
  // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
  static const short accumulative_offsets_from_0x4E00[] =
  {
      0,1,2,4,1,1,1,1,2,1,3,2,1,2,2,1,1,1,1,1,5,2,1,2,3,3,3,2,2,4,1,1,1,2,1,5,2,3,1,2,1,2,1,1,2,1,1,2,2,1,4,1,1,1,1,5,10,1,2,19,2,1,2,1,2,1,2,1,2,
      1,5,1,6,3,2,1,2,2,1,1,1,4,8,5,1,1,4,1,1,3,1,2,1,5,1,2,1,1,1,10,1,1,5,2,4,6,1,4,2,2,2,12,2,1,1,6,1,1,1,4,1,1,4,6,5,1,4,2,2,4,10,7,1,1,4,2,4,
      2,1,4,3,6,10,12,5,7,2,14,2,9,1,1,6,7,10,4,7,13,1,5,4,8,4,1,1,2,28,5,6,1,1,5,2,5,20,2,2,9,8,11,2,9,17,1,8,6,8,27,4,6,9,20,11,27,6,68,2,2,1,1,
      1,2,1,2,2,7,6,11,3,3,1,1,3,1,2,1,1,1,1,1,3,1,1,8,3,4,1,5,7,2,1,4,4,8,4,2,1,2,1,1,4,5,6,3,6,2,12,3,1,3,9,2,4,3,4,1,5,3,3,1,3,7,1,5,1,1,1,1,2,
      3,4,5,2,3,2,6,1,1,2,1,7,1,7,3,4,5,15,2,2,1,5,3,22,19,2,1,1,1,1,2,5,1,1,1,6,1,1,12,8,2,9,18,22,4,1,1,5,1,16,1,2,7,10,15,1,1,6,2,4,1,2,4,1,6,
      1,1,3,2,4,1,6,4,5,1,2,1,1,2,1,10,3,1,3,2,1,9,3,2,5,7,2,19,4,3,6,1,1,1,1,1,4,3,2,1,1,1,2,5,3,1,1,1,2,2,1,1,2,1,1,2,1,3,1,1,1,3,7,1,4,1,1,2,1,
      1,2,1,2,4,4,3,8,1,1,1,2,1,3,5,1,3,1,3,4,6,2,2,14,4,6,6,11,9,1,15,3,1,28,5,2,5,5,3,1,3,4,5,4,6,14,3,2,3,5,21,2,7,20,10,1,2,19,2,4,28,28,2,3,
      2,1,14,4,1,26,28,42,12,40,3,52,79,5,14,17,3,2,2,11,3,4,6,3,1,8,2,23,4,5,8,10,4,2,7,3,5,1,1,6,3,1,2,2,2,5,28,1,1,7,7,20,5,3,29,3,17,26,1,8,4,
      27,3,6,11,23,5,3,4,6,13,24,16,6,5,10,25,35,7,3,2,3,3,14,3,6,2,6,1,4,2,3,8,2,1,1,3,3,3,4,1,1,13,2,2,4,5,2,1,14,14,1,2,2,1,4,5,2,3,1,14,3,12,
      3,17,2,16,5,1,2,1,8,9,3,19,4,2,2,4,17,25,21,20,28,75,1,10,29,103,4,1,2,1,1,4,2,4,1,2,3,24,2,2,2,1,1,2,1,3,8,1,1,1,2,1,1,3,1,1,1,6,1,5,3,1,1,
      1,3,4,1,1,5,2,1,5,6,13,9,16,1,1,1,1,3,2,3,2,4,5,2,5,2,2,3,7,13,7,2,2,1,1,1,1,2,3,3,2,1,6,4,9,2,1,14,2,14,2,1,18,3,4,14,4,11,41,15,23,15,23,
      176,1,3,4,1,1,1,1,5,3,1,2,3,7,3,1,1,2,1,2,4,4,6,2,4,1,9,7,1,10,5,8,16,29,1,1,2,2,3,1,3,5,2,4,5,4,1,1,2,2,3,3,7,1,6,10,1,17,1,44,4,6,2,1,1,6,
      5,4,2,10,1,6,9,2,8,1,24,1,2,13,7,8,8,2,1,4,1,3,1,3,3,5,2,5,10,9,4,9,12,2,1,6,1,10,1,1,7,7,4,10,8,3,1,13,4,3,1,6,1,3,5,2,1,2,17,16,5,2,16,6,
      1,4,2,1,3,3,6,8,5,11,11,1,3,3,2,4,6,10,9,5,7,4,7,4,7,1,1,4,2,1,3,6,8,7,1,6,11,5,5,3,24,9,4,2,7,13,5,1,8,82,16,61,1,1,1,4,2,2,16,10,3,8,1,1,
      6,4,2,1,3,1,1,1,4,3,8,4,2,2,1,1,1,1,1,6,3,5,1,1,4,6,9,2,1,1,1,2,1,7,2,1,6,1,5,4,4,3,1,8,1,3,3,1,3,2,2,2,2,3,1,6,1,2,1,2,1,3,7,1,8,2,1,2,1,5,
      2,5,3,5,10,1,2,1,1,3,2,5,11,3,9,3,5,1,1,5,9,1,2,1,5,7,9,9,8,1,3,3,3,6,8,2,3,2,1,1,32,6,1,2,15,9,3,7,13,1,3,10,13,2,14,1,13,10,2,1,3,10,4,15,
      2,15,15,10,1,3,9,6,9,32,25,26,47,7,3,2,3,1,6,3,4,3,2,8,5,4,1,9,4,2,2,19,10,6,2,3,8,1,2,2,4,2,1,9,4,4,4,6,4,8,9,2,3,1,1,1,1,3,5,5,1,3,8,4,6,
      2,1,4,12,1,5,3,7,13,2,5,8,1,6,1,2,5,14,6,1,5,2,4,8,15,5,1,23,6,62,2,10,1,1,8,1,2,2,10,4,2,2,9,2,1,1,3,2,3,1,5,3,3,2,1,3,8,1,1,1,11,3,1,1,4,
      3,7,1,14,1,2,3,12,5,2,5,1,6,7,5,7,14,11,1,3,1,8,9,12,2,1,11,8,4,4,2,6,10,9,13,1,1,3,1,5,1,3,2,4,4,1,18,2,3,14,11,4,29,4,2,7,1,3,13,9,2,2,5,
      3,5,20,7,16,8,5,72,34,6,4,22,12,12,28,45,36,9,7,39,9,191,1,1,1,4,11,8,4,9,2,3,22,1,1,1,1,4,17,1,7,7,1,11,31,10,2,4,8,2,3,2,1,4,2,16,4,32,2,
      3,19,13,4,9,1,5,2,14,8,1,1,3,6,19,6,5,1,16,6,2,10,8,5,1,2,3,1,5,5,1,11,6,6,1,3,3,2,6,3,8,1,1,4,10,7,5,7,7,5,8,9,2,1,3,4,1,1,3,1,3,3,2,6,16,
      1,4,6,3,1,10,6,1,3,15,2,9,2,10,25,13,9,16,6,2,2,10,11,4,3,9,1,2,6,6,5,4,30,40,1,10,7,12,14,33,6,3,6,7,3,1,3,1,11,14,4,9,5,12,11,49,18,51,31,
      140,31,2,2,1,5,1,8,1,10,1,4,4,3,24,1,10,1,3,6,6,16,3,4,5,2,1,4,2,57,10,6,22,2,22,3,7,22,6,10,11,36,18,16,33,36,2,5,5,1,1,1,4,10,1,4,13,2,7,
      5,2,9,3,4,1,7,43,3,7,3,9,14,7,9,1,11,1,1,3,7,4,18,13,1,14,1,3,6,10,73,2,2,30,6,1,11,18,19,13,22,3,46,42,37,89,7,3,16,34,2,2,3,9,1,7,1,1,1,2,
      2,4,10,7,3,10,3,9,5,28,9,2,6,13,7,3,1,3,10,2,7,2,11,3,6,21,54,85,2,1,4,2,2,1,39,3,21,2,2,5,1,1,1,4,1,1,3,4,15,1,3,2,4,4,2,3,8,2,20,1,8,7,13,
      4,1,26,6,2,9,34,4,21,52,10,4,4,1,5,12,2,11,1,7,2,30,12,44,2,30,1,1,3,6,16,9,17,39,82,2,2,24,7,1,7,3,16,9,14,44,2,1,2,1,2,3,5,2,4,1,6,7,5,3,
      2,6,1,11,5,11,2,1,18,19,8,1,3,24,29,2,1,3,5,2,2,1,13,6,5,1,46,11,3,5,1,1,5,8,2,10,6,12,6,3,7,11,2,4,16,13,2,5,1,1,2,2,5,2,28,5,2,23,10,8,4,
      4,22,39,95,38,8,14,9,5,1,13,5,4,3,13,12,11,1,9,1,27,37,2,5,4,4,63,211,95,2,2,2,1,3,5,2,1,1,2,2,1,1,1,3,2,4,1,2,1,1,5,2,2,1,1,2,3,1,3,1,1,1,
      3,1,4,2,1,3,6,1,1,3,7,15,5,3,2,5,3,9,11,4,2,22,1,6,3,8,7,1,4,28,4,16,3,3,25,4,4,27,27,1,4,1,2,2,7,1,3,5,2,28,8,2,14,1,8,6,16,25,3,3,3,14,3,
      3,1,1,2,1,4,6,3,8,4,1,1,1,2,3,6,10,6,2,3,18,3,2,5,5,4,3,1,5,2,5,4,23,7,6,12,6,4,17,11,9,5,1,1,10,5,12,1,1,11,26,33,7,3,6,1,17,7,1,5,12,1,11,
      2,4,1,8,14,17,23,1,2,1,7,8,16,11,9,6,5,2,6,4,16,2,8,14,1,11,8,9,1,1,1,9,25,4,11,19,7,2,15,2,12,8,52,7,5,19,2,16,4,36,8,1,16,8,24,26,4,6,2,9,
      5,4,36,3,28,12,25,15,37,27,17,12,59,38,5,32,127,1,2,9,17,14,4,1,2,1,1,8,11,50,4,14,2,19,16,4,17,5,4,5,26,12,45,2,23,45,104,30,12,8,3,10,2,2,
      3,3,1,4,20,7,2,9,6,15,2,20,1,3,16,4,11,15,6,134,2,5,59,1,2,2,2,1,9,17,3,26,137,10,211,59,1,2,4,1,4,1,1,1,2,6,2,3,1,1,2,3,2,3,1,3,4,4,2,3,3,
      1,4,3,1,7,2,2,3,1,2,1,3,3,3,2,2,3,2,1,3,14,6,1,3,2,9,6,15,27,9,34,145,1,1,2,1,1,1,1,2,1,1,1,1,2,2,2,3,1,2,1,1,1,2,3,5,8,3,5,2,4,1,3,2,2,2,12,
      4,1,1,1,10,4,5,1,20,4,16,1,15,9,5,12,2,9,2,5,4,2,26,19,7,1,26,4,30,12,15,42,1,6,8,172,1,1,4,2,1,1,11,2,2,4,2,1,2,1,10,8,1,2,1,4,5,1,2,5,1,8,
      4,1,3,4,2,1,6,2,1,3,4,1,2,1,1,1,1,12,5,7,2,4,3,1,1,1,3,3,6,1,2,2,3,3,3,2,1,2,12,14,11,6,6,4,12,2,8,1,7,10,1,35,7,4,13,15,4,3,23,21,28,52,5,
      26,5,6,1,7,10,2,7,53,3,2,1,1,1,2,163,532,1,10,11,1,3,3,4,8,2,8,6,2,2,23,22,4,2,2,4,2,1,3,1,3,3,5,9,8,2,1,2,8,1,10,2,12,21,20,15,105,2,3,1,1,
      3,2,3,1,1,2,5,1,4,15,11,19,1,1,1,1,5,4,5,1,1,2,5,3,5,12,1,2,5,1,11,1,1,15,9,1,4,5,3,26,8,2,1,3,1,1,15,19,2,12,1,2,5,2,7,2,19,2,20,6,26,7,5,
      2,2,7,34,21,13,70,2,128,1,1,2,1,1,2,1,1,3,2,2,2,15,1,4,1,3,4,42,10,6,1,49,85,8,1,2,1,1,4,4,2,3,6,1,5,7,4,3,211,4,1,2,1,2,5,1,2,4,2,2,6,5,6,
      10,3,4,48,100,6,2,16,296,5,27,387,2,2,3,7,16,8,5,38,15,39,21,9,10,3,7,59,13,27,21,47,5,21,6
  };
  static ImWchar base_ranges[] = // not zero-terminated
  {
      0x0020, 0x00FF, // Basic Latin + Latin Supplement
      0x2000, 0x206F, // General Punctuation
      0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
      0x31F0, 0x31FF, // Katakana Phonetic Extensions
      0xFF00, 0xFFEF  // Half-width characters
  };
  static ImWchar full_ranges[ IM_ARRAYSIZE( base_ranges ) + IM_ARRAYSIZE( accumulative_offsets_from_0x4E00 ) * 2 + 1 ] = { 0 };
  if( !full_ranges[ 0 ] )
  {
    memcpy( full_ranges, base_ranges, sizeof( base_ranges ) );
    UnpackAccumulativeOffsetsIntoRanges( 0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE( accumulative_offsets_from_0x4E00 ), full_ranges + IM_ARRAYSIZE( base_ranges ) );
  }
  return &full_ranges[ 0 ];
}

const ImWchar* ImFontAtlas::GetGlyphRangesJapanese()
{
  // 1946 common ideograms code points for Japanese
  // Sourced from http://theinstructionlimit.com/common-kanji-character-ranges-for-xna-spritefont-rendering
  // FIXME: Source a list of the revised 2136 Joyo Kanji list from 2010 and rebuild this.
  // You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
  // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
  static const short accumulative_offsets_from_0x4E00[] =
  {
      0,1,2,4,1,1,1,1,2,1,6,2,2,1,8,5,7,11,1,2,10,10,8,2,4,20,2,11,8,2,1,2,1,6,2,1,7,5,3,7,1,1,13,7,9,1,4,6,1,2,1,10,1,1,9,2,2,4,5,6,14,1,1,9,3,18,
      5,4,2,2,10,7,1,1,1,3,2,4,3,23,2,10,12,2,14,2,4,13,1,6,10,3,1,7,13,6,4,13,5,2,3,17,2,2,5,7,6,4,1,7,14,16,6,13,9,15,1,1,7,16,4,7,1,19,9,2,7,15,
      2,6,5,13,25,4,14,13,11,25,1,1,1,2,1,2,2,3,10,11,3,3,1,1,4,4,2,1,4,9,1,4,3,5,5,2,7,12,11,15,7,16,4,5,16,2,1,1,6,3,3,1,1,2,7,6,6,7,1,4,7,6,1,1,
      2,1,12,3,3,9,5,8,1,11,1,2,3,18,20,4,1,3,6,1,7,3,5,5,7,2,2,12,3,1,4,2,3,2,3,11,8,7,4,17,1,9,25,1,1,4,2,2,4,1,2,7,1,1,1,3,1,2,6,16,1,2,1,1,3,12,
      20,2,5,20,8,7,6,2,1,1,1,1,6,2,1,2,10,1,1,6,1,3,1,2,1,4,1,12,4,1,3,1,1,1,1,1,10,4,7,5,13,1,15,1,1,30,11,9,1,15,38,14,1,32,17,20,1,9,31,2,21,9,
      4,49,22,2,1,13,1,11,45,35,43,55,12,19,83,1,3,2,3,13,2,1,7,3,18,3,13,8,1,8,18,5,3,7,25,24,9,24,40,3,17,24,2,1,6,2,3,16,15,6,7,3,12,1,9,7,3,3,
      3,15,21,5,16,4,5,12,11,11,3,6,3,2,31,3,2,1,1,23,6,6,1,4,2,6,5,2,1,1,3,3,22,2,6,2,3,17,3,2,4,5,1,9,5,1,1,6,15,12,3,17,2,14,2,8,1,23,16,4,2,23,
      8,15,23,20,12,25,19,47,11,21,65,46,4,3,1,5,6,1,2,5,26,2,1,1,3,11,1,1,1,2,1,2,3,1,1,10,2,3,1,1,1,3,6,3,2,2,6,6,9,2,2,2,6,2,5,10,2,4,1,2,1,2,2,
      3,1,1,3,1,2,9,23,9,2,1,1,1,1,5,3,2,1,10,9,6,1,10,2,31,25,3,7,5,40,1,15,6,17,7,27,180,1,3,2,2,1,1,1,6,3,10,7,1,3,6,17,8,6,2,2,1,3,5,5,8,16,14,
      15,1,1,4,1,2,1,1,1,3,2,7,5,6,2,5,10,1,4,2,9,1,1,11,6,1,44,1,3,7,9,5,1,3,1,1,10,7,1,10,4,2,7,21,15,7,2,5,1,8,3,4,1,3,1,6,1,4,2,1,4,10,8,1,4,5,
      1,5,10,2,7,1,10,1,1,3,4,11,10,29,4,7,3,5,2,3,33,5,2,19,3,1,4,2,6,31,11,1,3,3,3,1,8,10,9,12,11,12,8,3,14,8,6,11,1,4,41,3,1,2,7,13,1,5,6,2,6,12,
      12,22,5,9,4,8,9,9,34,6,24,1,1,20,9,9,3,4,1,7,2,2,2,6,2,28,5,3,6,1,4,6,7,4,2,1,4,2,13,6,4,4,3,1,8,8,3,2,1,5,1,2,2,3,1,11,11,7,3,6,10,8,6,16,16,
      22,7,12,6,21,5,4,6,6,3,6,1,3,2,1,2,8,29,1,10,1,6,13,6,6,19,31,1,13,4,4,22,17,26,33,10,4,15,12,25,6,67,10,2,3,1,6,10,2,6,2,9,1,9,4,4,1,2,16,2,
      5,9,2,3,8,1,8,3,9,4,8,6,4,8,11,3,2,1,1,3,26,1,7,5,1,11,1,5,3,5,2,13,6,39,5,1,5,2,11,6,10,5,1,15,5,3,6,19,21,22,2,4,1,6,1,8,1,4,8,2,4,2,2,9,2,
      1,1,1,4,3,6,3,12,7,1,14,2,4,10,2,13,1,17,7,3,2,1,3,2,13,7,14,12,3,1,29,2,8,9,15,14,9,14,1,3,1,6,5,9,11,3,38,43,20,7,7,8,5,15,12,19,15,81,8,7,
      1,5,73,13,37,28,8,8,1,15,18,20,165,28,1,6,11,8,4,14,7,15,1,3,3,6,4,1,7,14,1,1,11,30,1,5,1,4,14,1,4,2,7,52,2,6,29,3,1,9,1,21,3,5,1,26,3,11,14,
      11,1,17,5,1,2,1,3,2,8,1,2,9,12,1,1,2,3,8,3,24,12,7,7,5,17,3,3,3,1,23,10,4,4,6,3,1,16,17,22,3,10,21,16,16,6,4,10,2,1,1,2,8,8,6,5,3,3,3,39,25,
      15,1,1,16,6,7,25,15,6,6,12,1,22,13,1,4,9,5,12,2,9,1,12,28,8,3,5,10,22,60,1,2,40,4,61,63,4,1,13,12,1,4,31,12,1,14,89,5,16,6,29,14,2,5,49,18,18,
      5,29,33,47,1,17,1,19,12,2,9,7,39,12,3,7,12,39,3,1,46,4,12,3,8,9,5,31,15,18,3,2,2,66,19,13,17,5,3,46,124,13,57,34,2,5,4,5,8,1,1,1,4,3,1,17,5,
      3,5,3,1,8,5,6,3,27,3,26,7,12,7,2,17,3,7,18,78,16,4,36,1,2,1,6,2,1,39,17,7,4,13,4,4,4,1,10,4,2,4,6,3,10,1,19,1,26,2,4,33,2,73,47,7,3,8,2,4,15,
      18,1,29,2,41,14,1,21,16,41,7,39,25,13,44,2,2,10,1,13,7,1,7,3,5,20,4,8,2,49,1,10,6,1,6,7,10,7,11,16,3,12,20,4,10,3,1,2,11,2,28,9,2,4,7,2,15,1,
      27,1,28,17,4,5,10,7,3,24,10,11,6,26,3,2,7,2,2,49,16,10,16,15,4,5,27,61,30,14,38,22,2,7,5,1,3,12,23,24,17,17,3,3,2,4,1,6,2,7,5,1,1,5,1,1,9,4,
      1,3,6,1,8,2,8,4,14,3,5,11,4,1,3,32,1,19,4,1,13,11,5,2,1,8,6,8,1,6,5,13,3,23,11,5,3,16,3,9,10,1,24,3,198,52,4,2,2,5,14,5,4,22,5,20,4,11,6,41,
      1,5,2,2,11,5,2,28,35,8,22,3,18,3,10,7,5,3,4,1,5,3,8,9,3,6,2,16,22,4,5,5,3,3,18,23,2,6,23,5,27,8,1,33,2,12,43,16,5,2,3,6,1,20,4,2,9,7,1,11,2,
      10,3,14,31,9,3,25,18,20,2,5,5,26,14,1,11,17,12,40,19,9,6,31,83,2,7,9,19,78,12,14,21,76,12,113,79,34,4,1,1,61,18,85,10,2,2,13,31,11,50,6,33,159,
      179,6,6,7,4,4,2,4,2,5,8,7,20,32,22,1,3,10,6,7,28,5,10,9,2,77,19,13,2,5,1,4,4,7,4,13,3,9,31,17,3,26,2,6,6,5,4,1,7,11,3,4,2,1,6,2,20,4,1,9,2,6,
      3,7,1,1,1,20,2,3,1,6,2,3,6,2,4,8,1,5,13,8,4,11,23,1,10,6,2,1,3,21,2,2,4,24,31,4,10,10,2,5,192,15,4,16,7,9,51,1,2,1,1,5,1,1,2,1,3,5,3,1,3,4,1,
      3,1,3,3,9,8,1,2,2,2,4,4,18,12,92,2,10,4,3,14,5,25,16,42,4,14,4,2,21,5,126,30,31,2,1,5,13,3,22,5,6,6,20,12,1,14,12,87,3,19,1,8,2,9,9,3,3,23,2,
      3,7,6,3,1,2,3,9,1,3,1,6,3,2,1,3,11,3,1,6,10,3,2,3,1,2,1,5,1,1,11,3,6,4,1,7,2,1,2,5,5,34,4,14,18,4,19,7,5,8,2,6,79,1,5,2,14,8,2,9,2,1,36,28,16,
      4,1,1,1,2,12,6,42,39,16,23,7,15,15,3,2,12,7,21,64,6,9,28,8,12,3,3,41,59,24,51,55,57,294,9,9,2,6,2,15,1,2,13,38,90,9,9,9,3,11,7,1,1,1,5,6,3,2,
      1,2,2,3,8,1,4,4,1,5,7,1,4,3,20,4,9,1,1,1,5,5,17,1,5,2,6,2,4,1,4,5,7,3,18,11,11,32,7,5,4,7,11,127,8,4,3,3,1,10,1,1,6,21,14,1,16,1,7,1,3,6,9,65,
      51,4,3,13,3,10,1,1,12,9,21,110,3,19,24,1,1,10,62,4,1,29,42,78,28,20,18,82,6,3,15,6,84,58,253,15,155,264,15,21,9,14,7,58,40,39,
  };
  static ImWchar base_ranges[] = // not zero-terminated
  {
      0x0020, 0x00FF, // Basic Latin + Latin Supplement
      0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
      0x31F0, 0x31FF, // Katakana Phonetic Extensions
      0xFF00, 0xFFEF  // Half-width characters
  };
  static ImWchar full_ranges[ IM_ARRAYSIZE( base_ranges ) + IM_ARRAYSIZE( accumulative_offsets_from_0x4E00 ) * 2 + 1 ] = { 0 };
  if( !full_ranges[ 0 ] )
  {
    memcpy( full_ranges, base_ranges, sizeof( base_ranges ) );
    UnpackAccumulativeOffsetsIntoRanges( 0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE( accumulative_offsets_from_0x4E00 ), full_ranges + IM_ARRAYSIZE( base_ranges ) );
  }
  return &full_ranges[ 0 ];
}

const ImWchar* ImFontAtlas::GetGlyphRangesCyrillic()
{
  static const ImWchar ranges[] =
  {
      0x0020, 0x00FF, // Basic Latin + Latin Supplement
      0x0400, 0x052F, // Cyrillic + Cyrillic Supplement
      0x2DE0, 0x2DFF, // Cyrillic Extended-A
      0xA640, 0xA69F, // Cyrillic Extended-B
      0,
  };
  return &ranges[ 0 ];
}

const ImWchar* ImFontAtlas::GetGlyphRangesThai()
{
  static const ImWchar ranges[] =
  {
      0x0020, 0x00FF, // Basic Latin
      0x2010, 0x205E, // Punctuations
      0x0E00, 0x0E7F, // Thai
      0,
  };
  return &ranges[ 0 ];
}

const ImWchar* ImFontAtlas::GetGlyphRangesVietnamese()
{
  static const ImWchar ranges[] =
  {
      0x0020, 0x00FF, // Basic Latin
      0x0102, 0x0103,
      0x0110, 0x0111,
      0x0128, 0x0129,
      0x0168, 0x0169,
      0x01A0, 0x01A1,
      0x01AF, 0x01B0,
      0x1EA0, 0x1EF9,
      0,
  };
  return &ranges[ 0 ];
}

//-----------------------------------------------------------------------------
// [SECTION] ImFontGlyphRangesBuilder
//-----------------------------------------------------------------------------

void ImFontGlyphRangesBuilder::AddText( const char* text, const char* text_end )
{
  while( text_end ? ( text < text_end ) : *text )
  {
    unsigned int c = 0;
    int c_len = ImTextCharFromUtf8( &c, text, text_end );
    text += c_len;
    if( c_len == 0 )
      break;
    AddChar( ( ImWchar )c );
  }
}

void ImFontGlyphRangesBuilder::AddRanges( const ImWchar* ranges )
{
  for( ; ranges[ 0 ]; ranges += 2 )
    for( ImWchar c = ranges[ 0 ]; c <= ranges[ 1 ]; c++ )
      AddChar( c );
}

void ImFontGlyphRangesBuilder::BuildRanges( ImVector<ImWchar>* out_ranges )
{
  const int max_codepoint = IM_UNICODE_CODEPOINT_MAX;
  for( int n = 0; n <= max_codepoint; n++ )
    if( GetBit( n ) )
    {
      out_ranges->push_back( ( ImWchar )n );
      while( n < max_codepoint && GetBit( n + 1 ) )
        n++;
      out_ranges->push_back( ( ImWchar )n );
    }
  out_ranges->push_back( 0 );
}

//-----------------------------------------------------------------------------
// [SECTION] ImFont
//-----------------------------------------------------------------------------

ImFont::ImFont()
{
  FontSize = 0.0f;
  FallbackAdvanceX = 0.0f;
  FallbackChar = ( ImWchar )'?';
  EllipsisChar = ( ImWchar )-1;
  DisplayOffset = ImVec2( 0.0f, 0.0f );
  FallbackGlyph = NULL;
  ContainerAtlas = NULL;
  ConfigData = NULL;
  ConfigDataCount = 0;
  DirtyLookupTables = false;
  Scale = 1.0f;
  Ascent = Descent = 0.0f;
  MetricsTotalSurface = 0;
  memset( Used4kPagesMap, 0, sizeof( Used4kPagesMap ) );
}

ImFont::~ImFont()
{
  ClearOutputData();
}

void    ImFont::ClearOutputData()
{
  FontSize = 0.0f;
  FallbackAdvanceX = 0.0f;
  Glyphs.clear();
  IndexAdvanceX.clear();
  IndexLookup.clear();
  FallbackGlyph = NULL;
  ContainerAtlas = NULL;
  DirtyLookupTables = true;
  Ascent = Descent = 0.0f;
  MetricsTotalSurface = 0;
}

void ImFont::BuildLookupTable()
{
  int max_codepoint = 0;
  for( int i = 0; i != Glyphs.Size; i++ )
    max_codepoint = ImMax( max_codepoint, ( int )Glyphs[ i ].Codepoint );

  // Build lookup table
  IM_ASSERT( Glyphs.Size < 0xFFFF ); // -1 is reserved
  IndexAdvanceX.clear();
  IndexLookup.clear();
  DirtyLookupTables = false;
  memset( Used4kPagesMap, 0, sizeof( Used4kPagesMap ) );
  GrowIndex( max_codepoint + 1 );
  for( int i = 0; i < Glyphs.Size; i++ )
  {
    int codepoint = ( int )Glyphs[ i ].Codepoint;
    IndexAdvanceX[ codepoint ] = Glyphs[ i ].AdvanceX;
    IndexLookup[ codepoint ] = ( ImWchar )i;

    // Mark 4K page as used
    const int page_n = codepoint / 4096;
    Used4kPagesMap[ page_n >> 3 ] |= 1 << ( page_n & 7 );
  }

  // Create a glyph to handle TAB
  // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)
  if( FindGlyph( ( ImWchar )' ' ) )
  {
    if( Glyphs.back().Codepoint != '\t' )   // So we can call this function multiple times (FIXME: Flaky)
      Glyphs.resize( Glyphs.Size + 1 );
    ImFontGlyph& tab_glyph = Glyphs.back();
    tab_glyph = *FindGlyph( ( ImWchar )' ' );
    tab_glyph.Codepoint = '\t';
    tab_glyph.AdvanceX *= IM_TABSIZE;
    IndexAdvanceX[ ( int )tab_glyph.Codepoint ] = ( float )tab_glyph.AdvanceX;
    IndexLookup[ ( int )tab_glyph.Codepoint ] = ( ImWchar )( Glyphs.Size - 1 );
  }

  // Mark special glyphs as not visible (note that AddGlyph already mark as non-visible glyphs with zero-size polygons)
  SetGlyphVisible( ( ImWchar )' ', false );
  SetGlyphVisible( ( ImWchar )'\t', false );

  // Setup fall-backs
  FallbackGlyph = FindGlyphNoFallback( FallbackChar );
  FallbackAdvanceX = FallbackGlyph ? FallbackGlyph->AdvanceX : 0.0f;
  for( int i = 0; i < max_codepoint + 1; i++ )
    if( IndexAdvanceX[ i ] < 0.0f )
      IndexAdvanceX[ i ] = FallbackAdvanceX;
}

// API is designed this way to avoid exposing the 4K page size
// e.g. use with IsGlyphRangeUnused(0, 255)
bool ImFont::IsGlyphRangeUnused( unsigned int c_begin, unsigned int c_last )
{
  unsigned int page_begin = ( c_begin / 4096 );
  unsigned int page_last = ( c_last / 4096 );
  for( unsigned int page_n = page_begin; page_n <= page_last; page_n++ )
    if( ( page_n >> 3 ) < sizeof( Used4kPagesMap ) )
      if( Used4kPagesMap[ page_n >> 3 ] & ( 1 << ( page_n & 7 ) ) )
        return false;
  return true;
}

void ImFont::SetGlyphVisible( ImWchar c, bool visible )
{
  if( ImFontGlyph* glyph = ( ImFontGlyph* )( void* )FindGlyph( ( ImWchar )c ) )
    glyph->Visible = visible ? 1 : 0;
}

void ImFont::SetFallbackChar( ImWchar c )
{
  FallbackChar = c;
  BuildLookupTable();
}

void ImFont::GrowIndex( int new_size )
{
  IM_ASSERT( IndexAdvanceX.Size == IndexLookup.Size );
  if( new_size <= IndexLookup.Size )
    return;
  IndexAdvanceX.resize( new_size, -1.0f );
  IndexLookup.resize( new_size, ( ImWchar )-1 );
}

// x0/y0/x1/y1 are offset from the character upper-left layout position, in pixels. Therefore x0/y0 are often fairly close to zero.
// Not to be mistaken with texture coordinates, which are held by u0/v0/u1/v1 in normalized format (0.0..1.0 on each texture axis).
void ImFont::AddGlyph( ImWchar codepoint, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x )
{
  Glyphs.resize( Glyphs.Size + 1 );
  ImFontGlyph& glyph = Glyphs.back();
  glyph.Codepoint = ( unsigned int )codepoint;
  glyph.Visible = ( x0 != x1 ) && ( y0 != y1 );
  glyph.X0 = x0;
  glyph.Y0 = y0;
  glyph.X1 = x1;
  glyph.Y1 = y1;
  glyph.U0 = u0;
  glyph.V0 = v0;
  glyph.U1 = u1;
  glyph.V1 = v1;
  glyph.AdvanceX = advance_x + ConfigData->GlyphExtraSpacing.x;  // Bake spacing into AdvanceX

  if( ConfigData->PixelSnapH )
    glyph.AdvanceX = IM_ROUND( glyph.AdvanceX );

  // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)
  DirtyLookupTables = true;
  MetricsTotalSurface += ( int )( ( glyph.U1 - glyph.U0 ) * ContainerAtlas->TexWidth + 1.99f ) * ( int )( ( glyph.V1 - glyph.V0 ) * ContainerAtlas->TexHeight + 1.99f );
}

void ImFont::AddRemapChar( ImWchar dst, ImWchar src, bool overwrite_dst )
{
  IM_ASSERT( IndexLookup.Size > 0 );    // Currently this can only be called AFTER the font has been built, aka after calling ImFontAtlas::GetTexDataAs*() function.
  unsigned int index_size = ( unsigned int )IndexLookup.Size;

  if( dst < index_size && IndexLookup.Data[ dst ] == ( ImWchar )-1 && !overwrite_dst ) // 'dst' already exists
    return;
  if( src >= index_size && dst >= index_size ) // both 'dst' and 'src' don't exist -> no-op
    return;

  GrowIndex( dst + 1 );
  IndexLookup[ dst ] = ( src < index_size ) ? IndexLookup.Data[ src ] : ( ImWchar )-1;
  IndexAdvanceX[ dst ] = ( src < index_size ) ? IndexAdvanceX.Data[ src ] : 1.0f;
}

const ImFontGlyph* ImFont::FindGlyph( ImWchar c ) const
{
  if( c >= ( size_t )IndexLookup.Size )
    return FallbackGlyph;
  const ImWchar i = IndexLookup.Data[ c ];
  if( i == ( ImWchar )-1 )
    return FallbackGlyph;
  return &Glyphs.Data[ i ];
}

const ImFontGlyph* ImFont::FindGlyphNoFallback( ImWchar c ) const
{
  if( c >= ( size_t )IndexLookup.Size )
    return NULL;
  const ImWchar i = IndexLookup.Data[ c ];
  if( i == ( ImWchar )-1 )
    return NULL;
  return &Glyphs.Data[ i ];
}

const char* ImFont::CalcWordWrapPositionA( float scale, const char* text, const char* text_end, float wrap_width ) const
{
  // Simple word-wrapping for English, not full-featured. Please submit failing cases!
  // FIXME: Much possible improvements (don't cut things like "word !", "word!!!" but cut within "word,,,,", more sensible support for punctuations, support for Unicode punctuations, etc.)

  // For references, possible wrap point marked with ^
  //  "aaa bbb, ccc,ddd. eee   fff. ggg!"
  //      ^    ^    ^   ^   ^__    ^    ^

  // List of hardcoded separators: .,;!?'"

  // Skip extra blanks after a line returns (that includes not counting them in width computation)
  // e.g. "Hello    world" --> "Hello" "World"

  // Cut words that cannot possibly fit within one line.
  // e.g.: "The tropical fish" with ~5 characters worth of width --> "The tr" "opical" "fish"

  float line_width = 0.0f;
  float word_width = 0.0f;
  float blank_width = 0.0f;
  wrap_width /= scale; // We work with unscaled widths to avoid scaling every characters

  const char* word_end = text;
  const char* prev_word_end = NULL;
  bool inside_word = true;

  const char* s = text;
  while( s < text_end )
  {
    unsigned int c = ( unsigned int )*s;
    const char* next_s;
    if( c < 0x80 )
      next_s = s + 1;
    else
      next_s = s + ImTextCharFromUtf8( &c, s, text_end );
    if( c == 0 )
      break;

    if( c < 32 )
    {
      if( c == '\n' )
      {
        line_width = word_width = blank_width = 0.0f;
        inside_word = true;
        s = next_s;
        continue;
      }
      if( c == '\r' )
      {
        s = next_s;
        continue;
      }
    }

    const float char_width = ( ( int )c < IndexAdvanceX.Size ? IndexAdvanceX.Data[ c ] : FallbackAdvanceX );
    if( ImCharIsBlankW( c ) )
    {
      if( inside_word )
      {
        line_width += blank_width;
        blank_width = 0.0f;
        word_end = s;
      }
      blank_width += char_width;
      inside_word = false;
    }
    else
    {
      word_width += char_width;
      if( inside_word )
      {
        word_end = next_s;
      }
      else
      {
        prev_word_end = word_end;
        line_width += word_width + blank_width;
        word_width = blank_width = 0.0f;
      }

      // Allow wrapping after punctuation.
      inside_word = !( c == '.' || c == ',' || c == ';' || c == '!' || c == '?' || c == '\"' );
    }

    // We ignore blank width at the end of the line (they can be skipped)
    if( line_width + word_width > wrap_width )
    {
      // Words that cannot possibly fit within an entire line will be cut anywhere.
      if( word_width < wrap_width )
        s = prev_word_end ? prev_word_end : word_end;
      break;
    }

    s = next_s;
  }

  return s;
}

ImVec2 ImFont::CalcTextSizeA( float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining ) const
{
  if( !text_end )
    text_end = text_begin + strlen( text_begin ); // FIXME-OPT: Need to avoid this.

  const float line_height = size;
  const float scale = size / FontSize;

  ImVec2 text_size = ImVec2( 0, 0 );
  float line_width = 0.0f;

  const bool word_wrap_enabled = ( wrap_width > 0.0f );
  const char* word_wrap_eol = NULL;

  const char* s = text_begin;
  while( s < text_end )
  {
    if( word_wrap_enabled )
    {
      // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
      if( !word_wrap_eol )
      {
        word_wrap_eol = CalcWordWrapPositionA( scale, s, text_end, wrap_width - line_width );
        if( word_wrap_eol == s ) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.
          word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below
      }

      if( s >= word_wrap_eol )
      {
        if( text_size.x < line_width )
          text_size.x = line_width;
        text_size.y += line_height;
        line_width = 0.0f;
        word_wrap_eol = NULL;

        // Wrapping skips upcoming blanks
        while( s < text_end )
        {
          const char c = *s;
          if( ImCharIsBlankA( c ) )
          {
            s++;
          }
          else if( c == '\n' )
          {
            s++; break;
          }
          else
          {
            break;
          }
        }
        continue;
      }
    }

    // Decode and advance source
    const char* prev_s = s;
    unsigned int c = ( unsigned int )*s;
    if( c < 0x80 )
    {
      s += 1;
    }
    else
    {
      s += ImTextCharFromUtf8( &c, s, text_end );
      if( c == 0 ) // Malformed UTF-8?
        break;
    }

    if( c < 32 )
    {
      if( c == '\n' )
      {
        text_size.x = ImMax( text_size.x, line_width );
        text_size.y += line_height;
        line_width = 0.0f;
        continue;
      }
      if( c == '\r' )
        continue;
    }

    const float char_width = ( ( int )c < IndexAdvanceX.Size ? IndexAdvanceX.Data[ c ] : FallbackAdvanceX ) * scale;
    if( line_width + char_width >= max_width )
    {
      s = prev_s;
      break;
    }

    line_width += char_width;
  }

  if( text_size.x < line_width )
    text_size.x = line_width;

  if( line_width > 0 || text_size.y == 0.0f )
    text_size.y += line_height;

  if( remaining )
    *remaining = s;

  return text_size;
}

void ImFont::RenderChar( ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, ImWchar c ) const
{
  const ImFontGlyph* glyph = FindGlyph( c );
  if( !glyph || !glyph->Visible )
    return;
  float scale = ( size >= 0.0f ) ? ( size / FontSize ) : 1.0f;
  pos.x = IM_FLOOR( pos.x + DisplayOffset.x );
  pos.y = IM_FLOOR( pos.y + DisplayOffset.y );
  draw_list->PrimReserve( 6, 4 );
  draw_list->PrimRectUV( ImVec2( pos.x + glyph->X0 * scale, pos.y + glyph->Y0 * scale ), ImVec2( pos.x + glyph->X1 * scale, pos.y + glyph->Y1 * scale ), ImVec2( glyph->U0, glyph->V0 ), ImVec2( glyph->U1, glyph->V1 ), col );
}

void ImFont::RenderText( ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width, bool cpu_fine_clip ) const
{
  if( !text_end )
    text_end = text_begin + strlen( text_begin ); // ImGui:: functions generally already provides a valid text_end, so this is merely to handle direct calls.

// Align to be pixel perfect
  pos.x = IM_FLOOR( pos.x + DisplayOffset.x );
  pos.y = IM_FLOOR( pos.y + DisplayOffset.y );
  float x = pos.x;
  float y = pos.y;
  if( y > clip_rect.w )
    return;

  const float scale = size / FontSize;
  const float line_height = FontSize * scale;
  const bool word_wrap_enabled = ( wrap_width > 0.0f );
  const char* word_wrap_eol = NULL;

  // Fast-forward to first visible line
  const char* s = text_begin;
  if( y + line_height < clip_rect.y && !word_wrap_enabled )
    while( y + line_height < clip_rect.y && s < text_end )
    {
      s = ( const char* )memchr( s, '\n', text_end - s );
      s = s ? s + 1 : text_end;
      y += line_height;
    }

  // For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()
  // Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)
  if( text_end - s > 10000 && !word_wrap_enabled )
  {
    const char* s_end = s;
    float y_end = y;
    while( y_end < clip_rect.w && s_end < text_end )
    {
      s_end = ( const char* )memchr( s_end, '\n', text_end - s_end );
      s_end = s_end ? s_end + 1 : text_end;
      y_end += line_height;
    }
    text_end = s_end;
  }
  if( s == text_end )
    return;

  // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
  const int vtx_count_max = ( int )( text_end - s ) * 4;
  const int idx_count_max = ( int )( text_end - s ) * 6;
  const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;
  draw_list->PrimReserve( idx_count_max, vtx_count_max );

  ImDrawVert* vtx_write = draw_list->_VtxWritePtr;
  ImDrawIdx* idx_write = draw_list->_IdxWritePtr;
  unsigned int vtx_current_idx = draw_list->_VtxCurrentIdx;

  while( s < text_end )
  {
    if( word_wrap_enabled )
    {
      // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
      if( !word_wrap_eol )
      {
        word_wrap_eol = CalcWordWrapPositionA( scale, s, text_end, wrap_width - ( x - pos.x ) );
        if( word_wrap_eol == s ) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.
          word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below
      }

      if( s >= word_wrap_eol )
      {
        x = pos.x;
        y += line_height;
        word_wrap_eol = NULL;

        // Wrapping skips upcoming blanks
        while( s < text_end )
        {
          const char c = *s;
          if( ImCharIsBlankA( c ) )
          {
            s++;
          }
          else if( c == '\n' )
          {
            s++; break;
          }
          else
          {
            break;
          }
        }
        continue;
      }
    }

    // Decode and advance source
    unsigned int c = ( unsigned int )*s;
    if( c < 0x80 )
    {
      s += 1;
    }
    else
    {
      s += ImTextCharFromUtf8( &c, s, text_end );
      if( c == 0 ) // Malformed UTF-8?
        break;
    }

    if( c < 32 )
    {
      if( c == '\n' )
      {
        x = pos.x;
        y += line_height;
        if( y > clip_rect.w )
          break; // break out of main loop
        continue;
      }
      if( c == '\r' )
        continue;
    }

    const ImFontGlyph* glyph = FindGlyph( ( ImWchar )c );
    if( glyph == NULL )
      continue;

    float char_width = glyph->AdvanceX * scale;
    if( glyph->Visible )
    {
      // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
      float x1 = x + glyph->X0 * scale;
      float x2 = x + glyph->X1 * scale;
      float y1 = y + glyph->Y0 * scale;
      float y2 = y + glyph->Y1 * scale;
      if( x1 <= clip_rect.z && x2 >= clip_rect.x )
      {
        // Render a character
        float u1 = glyph->U0;
        float v1 = glyph->V0;
        float u2 = glyph->U1;
        float v2 = glyph->V1;

        // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
        if( cpu_fine_clip )
        {
          if( x1 < clip_rect.x )
          {
            u1 = u1 + ( 1.0f - ( x2 - clip_rect.x ) / ( x2 - x1 ) ) * ( u2 - u1 );
            x1 = clip_rect.x;
          }
          if( y1 < clip_rect.y )
          {
            v1 = v1 + ( 1.0f - ( y2 - clip_rect.y ) / ( y2 - y1 ) ) * ( v2 - v1 );
            y1 = clip_rect.y;
          }
          if( x2 > clip_rect.z )
          {
            u2 = u1 + ( ( clip_rect.z - x1 ) / ( x2 - x1 ) ) * ( u2 - u1 );
            x2 = clip_rect.z;
          }
          if( y2 > clip_rect.w )
          {
            v2 = v1 + ( ( clip_rect.w - y1 ) / ( y2 - y1 ) ) * ( v2 - v1 );
            y2 = clip_rect.w;
          }
          if( y1 >= y2 )
          {
            x += char_width;
            continue;
          }
        }

        // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:
        {
          idx_write[ 0 ] = ( ImDrawIdx )( vtx_current_idx ); idx_write[ 1 ] = ( ImDrawIdx )( vtx_current_idx + 1 ); idx_write[ 2 ] = ( ImDrawIdx )( vtx_current_idx + 2 );
          idx_write[ 3 ] = ( ImDrawIdx )( vtx_current_idx ); idx_write[ 4 ] = ( ImDrawIdx )( vtx_current_idx + 2 ); idx_write[ 5 ] = ( ImDrawIdx )( vtx_current_idx + 3 );
          vtx_write[ 0 ].pos.x = x1; vtx_write[ 0 ].pos.y = y1; vtx_write[ 0 ].col = col; vtx_write[ 0 ].uv.x = u1; vtx_write[ 0 ].uv.y = v1;
          vtx_write[ 1 ].pos.x = x2; vtx_write[ 1 ].pos.y = y1; vtx_write[ 1 ].col = col; vtx_write[ 1 ].uv.x = u2; vtx_write[ 1 ].uv.y = v1;
          vtx_write[ 2 ].pos.x = x2; vtx_write[ 2 ].pos.y = y2; vtx_write[ 2 ].col = col; vtx_write[ 2 ].uv.x = u2; vtx_write[ 2 ].uv.y = v2;
          vtx_write[ 3 ].pos.x = x1; vtx_write[ 3 ].pos.y = y2; vtx_write[ 3 ].col = col; vtx_write[ 3 ].uv.x = u1; vtx_write[ 3 ].uv.y = v2;
          vtx_write += 4;
          vtx_current_idx += 4;
          idx_write += 6;
        }
      }
    }
    x += char_width;
  }

  // Give back unused vertices (clipped ones, blanks) ~ this is essentially a PrimUnreserve() action.
  draw_list->VtxBuffer.Size = ( int )( vtx_write - draw_list->VtxBuffer.Data ); // Same as calling shrink()
  draw_list->IdxBuffer.Size = ( int )( idx_write - draw_list->IdxBuffer.Data );
  draw_list->CmdBuffer[ draw_list->CmdBuffer.Size - 1 ].ElemCount -= ( idx_expected_size - draw_list->IdxBuffer.Size );
  draw_list->_VtxWritePtr = vtx_write;
  draw_list->_IdxWritePtr = idx_write;
  draw_list->_VtxCurrentIdx = vtx_current_idx;
}

//-----------------------------------------------------------------------------
// [SECTION] ImGui Internal Render Helpers
//-----------------------------------------------------------------------------
// Vaguely redesigned to stop accessing ImGui global state:
// - RenderArrow()
// - RenderBullet()
// - RenderCheckMark()
// - RenderMouseCursor()
// - RenderArrowPointingAt()
// - RenderRectFilledRangeH()
//-----------------------------------------------------------------------------
// Function in need of a redesign (legacy mess)
// - RenderColorRectWithAlphaCheckerboard()
//-----------------------------------------------------------------------------

// Render an arrow aimed to be aligned with text (p_min is a position in the same space text would be positioned). To e.g. denote expanded/collapsed state
void ImGui::RenderArrow( ImDrawList* draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir, float scale )
{
  const float h = draw_list->_Data->FontSize * 1.00f;
  float r = h * 0.40f * scale;
  ImVec2 center = pos + ImVec2( h * 0.50f, h * 0.50f * scale );

  ImVec2 a, b, c;
  switch( dir )
  {
    case ImGuiDir_Up:
    case ImGuiDir_Down:
      if( dir == ImGuiDir_Up ) r = -r;
      a = ImVec2( +0.000f, +0.750f ) * r;
      b = ImVec2( -0.866f, -0.750f ) * r;
      c = ImVec2( +0.866f, -0.750f ) * r;
      break;
    case ImGuiDir_Left:
    case ImGuiDir_Right:
      if( dir == ImGuiDir_Left ) r = -r;
      a = ImVec2( +0.750f, +0.000f ) * r;
      b = ImVec2( -0.750f, +0.866f ) * r;
      c = ImVec2( -0.750f, -0.866f ) * r;
      break;
    case ImGuiDir_None:
    case ImGuiDir_COUNT:
      IM_ASSERT( 0 );
      break;
  }
  draw_list->AddTriangleFilled( center + a, center + b, center + c, col );
}

void ImGui::RenderBullet( ImDrawList* draw_list, ImVec2 pos, ImU32 col )
{
  draw_list->AddCircleFilled( pos, draw_list->_Data->FontSize * 0.20f, col, 8 );
}

void ImGui::RenderCheckMark( ImDrawList* draw_list, ImVec2 pos, ImU32 col, float sz )
{
  float thickness = ImMax( sz / 5.0f, 1.0f );
  sz -= thickness * 0.5f;
  pos += ImVec2( thickness * 0.25f, thickness * 0.25f );

  float third = sz / 3.0f;
  float bx = pos.x + third;
  float by = pos.y + sz - third * 0.5f;
  draw_list->PathLineTo( ImVec2( bx - third, by - third ) );
  draw_list->PathLineTo( ImVec2( bx, by ) );
  draw_list->PathLineTo( ImVec2( bx + third * 2.0f, by - third * 2.0f ) );
  draw_list->PathStroke( col, false, thickness );
}

void ImGui::RenderMouseCursor( ImDrawList* draw_list, ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor, ImU32 col_fill, ImU32 col_border, ImU32 col_shadow )
{
  if( mouse_cursor == ImGuiMouseCursor_None )
    return;
  IM_ASSERT( mouse_cursor > ImGuiMouseCursor_None && mouse_cursor < ImGuiMouseCursor_COUNT );

  ImFontAtlas* font_atlas = draw_list->_Data->Font->ContainerAtlas;
  ImVec2 offset, size, uv[ 4 ];
  if( font_atlas->GetMouseCursorTexData( mouse_cursor, &offset, &size, &uv[ 0 ], &uv[ 2 ] ) )
  {
    pos -= offset;
    const ImTextureID tex_id = font_atlas->TexID;
    draw_list->PushTextureID( tex_id );
    draw_list->AddImage( tex_id, pos + ImVec2( 1, 0 ) * scale, pos + ImVec2( 1, 0 ) * scale + size * scale, uv[ 2 ], uv[ 3 ], col_shadow );
    draw_list->AddImage( tex_id, pos + ImVec2( 2, 0 ) * scale, pos + ImVec2( 2, 0 ) * scale + size * scale, uv[ 2 ], uv[ 3 ], col_shadow );
    draw_list->AddImage( tex_id, pos, pos + size * scale, uv[ 2 ], uv[ 3 ], col_border );
    draw_list->AddImage( tex_id, pos, pos + size * scale, uv[ 0 ], uv[ 1 ], col_fill );
    draw_list->PopTextureID();
  }
}

// Render an arrow. 'pos' is position of the arrow tip. half_sz.x is length from base to tip. half_sz.y is length on each side.
void ImGui::RenderArrowPointingAt( ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col )
{
  switch( direction )
  {
    case ImGuiDir_Left:  draw_list->AddTriangleFilled( ImVec2( pos.x + half_sz.x, pos.y - half_sz.y ), ImVec2( pos.x + half_sz.x, pos.y + half_sz.y ), pos, col ); return;
    case ImGuiDir_Right: draw_list->AddTriangleFilled( ImVec2( pos.x - half_sz.x, pos.y + half_sz.y ), ImVec2( pos.x - half_sz.x, pos.y - half_sz.y ), pos, col ); return;
    case ImGuiDir_Up:    draw_list->AddTriangleFilled( ImVec2( pos.x + half_sz.x, pos.y + half_sz.y ), ImVec2( pos.x - half_sz.x, pos.y + half_sz.y ), pos, col ); return;
    case ImGuiDir_Down:  draw_list->AddTriangleFilled( ImVec2( pos.x - half_sz.x, pos.y - half_sz.y ), ImVec2( pos.x + half_sz.x, pos.y - half_sz.y ), pos, col ); return;
    case ImGuiDir_None: case ImGuiDir_COUNT: break; // Fix warnings
  }
}

static inline float ImAcos01( float x )
{
  if( x <= 0.0f ) return IM_PI * 0.5f;
  if( x >= 1.0f ) return 0.0f;
  return ImAcos( x );
  //return (-0.69813170079773212f * x * x - 0.87266462599716477f) * x + 1.5707963267948966f; // Cheap approximation, may be enough for what we do.
}

// FIXME: Cleanup and move code to ImDrawList.
void ImGui::RenderRectFilledRangeH( ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding )
{
  if( x_end_norm == x_start_norm )
    return;
  if( x_start_norm > x_end_norm )
    ImSwap( x_start_norm, x_end_norm );

  ImVec2 p0 = ImVec2( ImLerp( rect.Min.x, rect.Max.x, x_start_norm ), rect.Min.y );
  ImVec2 p1 = ImVec2( ImLerp( rect.Min.x, rect.Max.x, x_end_norm ), rect.Max.y );
  if( rounding == 0.0f )
  {
    draw_list->AddRectFilled( p0, p1, col, 0.0f );
    return;
  }

  rounding = ImClamp( ImMin( ( rect.Max.x - rect.Min.x ) * 0.5f, ( rect.Max.y - rect.Min.y ) * 0.5f ) - 1.0f, 0.0f, rounding );
  const float inv_rounding = 1.0f / rounding;
  const float arc0_b = ImAcos01( 1.0f - ( p0.x - rect.Min.x ) * inv_rounding );
  const float arc0_e = ImAcos01( 1.0f - ( p1.x - rect.Min.x ) * inv_rounding );
  const float half_pi = IM_PI * 0.5f; // We will == compare to this because we know this is the exact value ImAcos01 can return.
  const float x0 = ImMax( p0.x, rect.Min.x + rounding );
  if( arc0_b == arc0_e )
  {
    draw_list->PathLineTo( ImVec2( x0, p1.y ) );
    draw_list->PathLineTo( ImVec2( x0, p0.y ) );
  }
  else if( arc0_b == 0.0f && arc0_e == half_pi )
  {
    draw_list->PathArcToFast( ImVec2( x0, p1.y - rounding ), rounding, 3, 6 ); // BL
    draw_list->PathArcToFast( ImVec2( x0, p0.y + rounding ), rounding, 6, 9 ); // TR
  }
  else
  {
    draw_list->PathArcTo( ImVec2( x0, p1.y - rounding ), rounding, IM_PI - arc0_e, IM_PI - arc0_b, 3 ); // BL
    draw_list->PathArcTo( ImVec2( x0, p0.y + rounding ), rounding, IM_PI + arc0_b, IM_PI + arc0_e, 3 ); // TR
  }
  if( p1.x > rect.Min.x + rounding )
  {
    const float arc1_b = ImAcos01( 1.0f - ( rect.Max.x - p1.x ) * inv_rounding );
    const float arc1_e = ImAcos01( 1.0f - ( rect.Max.x - p0.x ) * inv_rounding );
    const float x1 = ImMin( p1.x, rect.Max.x - rounding );
    if( arc1_b == arc1_e )
    {
      draw_list->PathLineTo( ImVec2( x1, p0.y ) );
      draw_list->PathLineTo( ImVec2( x1, p1.y ) );
    }
    else if( arc1_b == 0.0f && arc1_e == half_pi )
    {
      draw_list->PathArcToFast( ImVec2( x1, p0.y + rounding ), rounding, 9, 12 ); // TR
      draw_list->PathArcToFast( ImVec2( x1, p1.y - rounding ), rounding, 0, 3 );  // BR
    }
    else
    {
      draw_list->PathArcTo( ImVec2( x1, p0.y + rounding ), rounding, -arc1_e, -arc1_b, 3 ); // TR
      draw_list->PathArcTo( ImVec2( x1, p1.y - rounding ), rounding, +arc1_b, +arc1_e, 3 ); // BR
    }
  }
  draw_list->PathFillConvex( col );
}

// Helper for ColorPicker4()
// NB: This is rather brittle and will show artifact when rounding this enabled if rounded corners overlap multiple cells. Caller currently responsible for avoiding that.
// Spent a non reasonable amount of time trying to getting this right for ColorButton with rounding+anti-aliasing+ImGuiColorEditFlags_HalfAlphaPreview flag + various grid sizes and offsets, and eventually gave up... probably more reasonable to disable rounding altogether.
// FIXME: uses ImGui::GetColorU32
void ImGui::RenderColorRectWithAlphaCheckerboard( ImDrawList* draw_list, ImVec2 p_min, ImVec2 p_max, ImU32 col, float grid_step, ImVec2 grid_off, float rounding, int rounding_corners_flags )
{
  if( ( ( col & IM_COL32_A_MASK ) >> IM_COL32_A_SHIFT ) < 0xFF )
  {
    ImU32 col_bg1 = ImGui::GetColorU32( ImAlphaBlendColors( IM_COL32( 204, 204, 204, 255 ), col ) );
    ImU32 col_bg2 = ImGui::GetColorU32( ImAlphaBlendColors( IM_COL32( 128, 128, 128, 255 ), col ) );
    draw_list->AddRectFilled( p_min, p_max, col_bg1, rounding, rounding_corners_flags );

    int yi = 0;
    for( float y = p_min.y + grid_off.y; y < p_max.y; y += grid_step, yi++ )
    {
      float y1 = ImClamp( y, p_min.y, p_max.y ), y2 = ImMin( y + grid_step, p_max.y );
      if( y2 <= y1 )
        continue;
      for( float x = p_min.x + grid_off.x + ( yi & 1 ) * grid_step; x < p_max.x; x += grid_step * 2.0f )
      {
        float x1 = ImClamp( x, p_min.x, p_max.x ), x2 = ImMin( x + grid_step, p_max.x );
        if( x2 <= x1 )
          continue;
        int rounding_corners_flags_cell = 0;
        if( y1 <= p_min.y )
        {
          if( x1 <= p_min.x ) rounding_corners_flags_cell |= ImDrawCornerFlags_TopLeft; if( x2 >= p_max.x ) rounding_corners_flags_cell |= ImDrawCornerFlags_TopRight;
        }
        if( y2 >= p_max.y )
        {
          if( x1 <= p_min.x ) rounding_corners_flags_cell |= ImDrawCornerFlags_BotLeft; if( x2 >= p_max.x ) rounding_corners_flags_cell |= ImDrawCornerFlags_BotRight;
        }
        rounding_corners_flags_cell &= rounding_corners_flags;
        draw_list->AddRectFilled( ImVec2( x1, y1 ), ImVec2( x2, y2 ), col_bg2, rounding_corners_flags_cell ? rounding : 0.0f, rounding_corners_flags_cell );
      }
    }
  }
  else
  {
    draw_list->AddRectFilled( p_min, p_max, col, rounding, rounding_corners_flags );
  }
}

//-----------------------------------------------------------------------------
// [SECTION] Decompression code
//-----------------------------------------------------------------------------
// Compressed with stb_compress() then converted to a C array and encoded as base85.
// Use the program in misc/fonts/binary_to_compressed_c.cpp to create the array from a TTF file.
// The purpose of encoding as base85 instead of "0x00,0x01,..." style is only save on _source code_ size.
// Decompression from stb.h (public domain) by Sean Barrett https://github.com/nothings/stb/blob/master/stb.h
//-----------------------------------------------------------------------------

static unsigned int stb_decompress_length( const unsigned char* input )
{
  return ( input[ 8 ] << 24 ) + ( input[ 9 ] << 16 ) + ( input[ 10 ] << 8 ) + input[ 11 ];
}

static unsigned char* stb__barrier_out_e, * stb__barrier_out_b;
static const unsigned char* stb__barrier_in_b;
static unsigned char* stb__dout;
static void stb__match( const unsigned char* data, unsigned int length )
{
  // INVERSE of memmove... write each byte before copying the next...
  IM_ASSERT( stb__dout + length <= stb__barrier_out_e );
  if( stb__dout + length > stb__barrier_out_e )
  {
    stb__dout += length; return;
  }
  if( data < stb__barrier_out_b )
  {
    stb__dout = stb__barrier_out_e + 1; return;
  }
  while( length-- ) *stb__dout++ = *data++;
}

static void stb__lit( const unsigned char* data, unsigned int length )
{
  IM_ASSERT( stb__dout + length <= stb__barrier_out_e );
  if( stb__dout + length > stb__barrier_out_e )
  {
    stb__dout += length; return;
  }
  if( data < stb__barrier_in_b )
  {
    stb__dout = stb__barrier_out_e + 1; return;
  }
  memcpy( stb__dout, data, length );
  stb__dout += length;
}

#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))

static const unsigned char* stb_decompress_token( const unsigned char* i )
{
  if( *i >= 0x20 )
  { // use fewer if's for cases that expand small
    if( *i >= 0x80 )       stb__match( stb__dout - i[ 1 ] - 1, i[ 0 ] - 0x80 + 1 ), i += 2;
    else if( *i >= 0x40 )  stb__match( stb__dout - ( stb__in2( 0 ) - 0x4000 + 1 ), i[ 2 ] + 1 ), i += 3;
    else /* *i >= 0x20 */ stb__lit( i + 1, i[ 0 ] - 0x20 + 1 ), i += 1 + ( i[ 0 ] - 0x20 + 1 );
  }
  else
  { // more ifs for cases that expand large, since overhead is amortized
    if( *i >= 0x18 )       stb__match( stb__dout - ( stb__in3( 0 ) - 0x180000 + 1 ), i[ 3 ] + 1 ), i += 4;
    else if( *i >= 0x10 )  stb__match( stb__dout - ( stb__in3( 0 ) - 0x100000 + 1 ), stb__in2( 3 ) + 1 ), i += 5;
    else if( *i >= 0x08 )  stb__lit( i + 2, stb__in2( 0 ) - 0x0800 + 1 ), i += 2 + ( stb__in2( 0 ) - 0x0800 + 1 );
    else if( *i == 0x07 )  stb__lit( i + 3, stb__in2( 1 ) + 1 ), i += 3 + ( stb__in2( 1 ) + 1 );
    else if( *i == 0x06 )  stb__match( stb__dout - ( stb__in3( 1 ) + 1 ), i[ 4 ] + 1 ), i += 5;
    else if( *i == 0x04 )  stb__match( stb__dout - ( stb__in3( 1 ) + 1 ), stb__in2( 4 ) + 1 ), i += 6;
  }
  return i;
}

static unsigned int stb_adler32( unsigned int adler32, unsigned char* buffer, unsigned int buflen )
{
  const unsigned long ADLER_MOD = 65521;
  unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
  unsigned long blocklen = buflen % 5552;

  unsigned long i;
  while( buflen )
  {
    for( i = 0; i + 7 < blocklen; i += 8 )
    {
      s1 += buffer[ 0 ], s2 += s1;
      s1 += buffer[ 1 ], s2 += s1;
      s1 += buffer[ 2 ], s2 += s1;
      s1 += buffer[ 3 ], s2 += s1;
      s1 += buffer[ 4 ], s2 += s1;
      s1 += buffer[ 5 ], s2 += s1;
      s1 += buffer[ 6 ], s2 += s1;
      s1 += buffer[ 7 ], s2 += s1;

      buffer += 8;
    }

    for( ; i < blocklen; ++i )
      s1 += *buffer++, s2 += s1;

    s1 %= ADLER_MOD, s2 %= ADLER_MOD;
    buflen -= blocklen;
    blocklen = 5552;
  }
  return ( unsigned int )( s2 << 16 ) + ( unsigned int )s1;
}

static unsigned int stb_decompress( unsigned char* output, const unsigned char* i, unsigned int /*length*/ )
{
  if( stb__in4( 0 ) != 0x57bC0000 ) return 0;
  if( stb__in4( 4 ) != 0 )          return 0; // error! stream is > 4GB
  const unsigned int olen = stb_decompress_length( i );
  stb__barrier_in_b = i;
  stb__barrier_out_e = output + olen;
  stb__barrier_out_b = output;
  i += 16;

  stb__dout = output;
  for( ;;)
  {
    const unsigned char* old_i = i;
    i = stb_decompress_token( i );
    if( i == old_i )
    {
      if( *i == 0x05 && i[ 1 ] == 0xfa )
      {
        IM_ASSERT( stb__dout == output + olen );
        if( stb__dout != output + olen ) return 0;
        if( stb_adler32( 1, output, olen ) != ( unsigned int )stb__in4( 2 ) )
          return 0;
        return olen;
      }
      else
      {
        IM_ASSERT( 0 ); /* NOTREACHED */
        return 0;
      }
    }
    IM_ASSERT( stb__dout <= output + olen );
    if( stb__dout > output + olen )
      return 0;
  }
}

//-----------------------------------------------------------------------------
// [SECTION] Default font data (ProggyClean.ttf)
//-----------------------------------------------------------------------------
// ProggyClean.ttf
// Copyright (c) 2004, 2005 Tristan Grimmer
// MIT license (see License.txt in http://www.upperbounds.net/download/ProggyClean.ttf.zip)
// Download and more information at http://upperbounds.net
//-----------------------------------------------------------------------------
// File: 'ProggyClean.ttf' (41208 bytes)
// Exported using misc/fonts/binary_to_compressed_c.cpp (with compression + base85 string encoding).
// The purpose of encoding as base85 instead of "0x00,0x01,..." style is only save on _source code_ size.
//-----------------------------------------------------------------------------
static const char proggy_clean_ttf_compressed_data_base85[ 11980 + 1 ] =
"7])#######hV0qs'/###[),##/l:$#Q6>##5[n42>c-TH`->>#/e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb';9Crc6tgXmKVeU2cD4Eo3R/"
"2*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:U(jcW2p/W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(lf(r/7GrRgwV%MS=C#"
"`8ND>Qo#t'X#(v#Y9w0#1D$CIf;W'#pWUPXOuxXuU(H9M(1<q-UE31#^-V'8IRUo7Qf./L>=Ke$$'5F%)]0^#0X@U.a<r:QLtFsLcL6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uL"
"i@^rMl9t=cWq6##weg>$FBjVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//L[MkA#W@lK.N'[0#7RL_&#w+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*oJMHRC`N"
"kfimM2J,W-jXS:)r0wK#@Fge$U>`w'N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%?76%^GMHePW-Z5l'&GiF#$956:rS?dA#fiK:)Yr+`&#0j@'DbG&#^$PG.Ll+DNa<XCMKEV*N)LN/N"
"*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl'&hF;;$<_=X(b.RS%%)###MPBuuE1V:v&cX&#2m#(&cV]`k9OhLMbn%s$G2,B$BfD3X*sp5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)"
"tm+/Us9pG)XPu`<0s-)WTt(gCRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/L>&VZ>1i%h1S9u5o@YaaW$e+b<TWFn/Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CX"
"ow0i(?$Q[cjOd[P4d)]>ROPOpxTO7Stwi1::iB1q)C_=dV26J;2,]7op$]uQr@_V7$q^%lQwtuHY]=DX,n3L#0PHDO4f9>dC@O>HBuKPpP*E,N+b3L#lpR/MrTEH.IAQk.a>D[.e;mc."
"x]Ip.PH^'/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ'NQ(3_PLhE48R.qAPSwQ0/WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/-ZpKrUss?d#dZq]DAbkU*JqkL+nwX@@47`5>w=4h(9.`G"
"CRUxHPeR`5Mjol(dUWxZa(>STrPkrJiWx`5U7F#.g*jrohGg`cg:lSTvEY/EV_7H4Q9[Z%cnv;JQYZ5q.l7Zeas:HOIZOB?G<Nald$qs]@]L<J7bR*>gv:[7MI2k).'2($5FNP&EQ(,)"
"U]W]+fh18.vsai00);D3@4ku5P?DP8aJt+;qUM]=+b'8@;mViBKx0DE[-auGl8:PJ&Dj+M6OC]O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$UV(?#P6YY#"
"'/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]'/4C#v$U`0#V.[0>xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$x4AG8.kK/HSB==-'Ie/QTtG?-.*^N-4B/ZM"
"_3YlQC7(p7q)&](`6_c)$/*JL(L-^(]$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw'.,MRsqVr.L;aN&#/EgJ)PBc[-f>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`gu"
"Ft(c%=;Am_Qs@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8'=l_f-b49'UOqkLu7-##oDY2L(te+Mch&gLYtJ,MEtJfLh'x'M=$CS-ZZ%P]8bZ>#S?YY#%Q&q'3^Fw&?D)UDNrocM3A76/"
"/oL?#h7gl85[qW/NDOk%16ij;+:1a'iNIdb-ou8.P*w,v5#EI$TWS>Pot-R*H'-SEpA:g)f+O$%%`kA#G=8RMmG1&O`>to8bC]T&$,n.LoO>29sp3dt-52U%VM#q7'DHpg+#Z9%H[K<L"
"%a2E-grWVM3@2=-k22tL]4$##6We'8UJCKE[d_=%wI;'6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&#*h^D&R?jp7+/u&#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#"
"OQFKNX@QI'IoPp7nb,QU//MQ&ZDkKP)X<WSVL(68uVl&#c'[0#(s1X&xm$Y%B7*K:eDA323j998GXbA#pwMs-jgD$9QISB-A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682-SjMXJK)("
"h$hxua_K]ul92%'BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDPmL<LYs8i#XwJOYaKPKc1h:'9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuYa%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5h"
"o;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;)f#Km8&+DC$I46>#Kr]]u-[=99tts1.qb#q72g1WJO81q+eN'03'eM>&1XxY-caEnO"
"j%2n8)),?ILR5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew'He]h:sI[2LM$[guka3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1]MupW^-"
"sj_$%[HK%'F####QRZJ::Y3EGl4'@%FkiAOg#p[##O`gukTfBHagL<LHw%q&OV0##F=6/:chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg*%K8ln(wcf3/'DW-$.lR?n[nCH-"
"eXOONTJlh:.RYF%3'p6sq:UIMA945&^HFS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%#HMP'vh1/R&O_J9'um,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56'hl;.s5CUrxjO"
"M7-##.l+Au'A&O:-T72L]P`&=;ctp'XScX*rU.>-XTt,%OVU4)S1+R-#dg0/Nn?Ku1^0f$B*P:Rowwm-`0PKjYDDM'3]d39VZHEl4,.j']Pk-M.h^&:0FACm$maq-&sgw0t7/6(^xtk%"
"LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P'$M<Jnq79VsJW/mWS*PUiq76;]/NM_>hLbxfc$mj`,O;&%W2m`Zh:/)Uetw:aJ%]K9h:TcF]u_-Sj9,VK3M.*'&0D[Ca]J9gp8,kAW]"
"%(?A%R$f<->Zts'^kn=-^@c4%-pY6qI%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,UVf3839acAWAW-W?#ao/^#%KYo8fRULNd2.>%m]UK:n%r$'sw]J;5pAoO_#2mO3n,'=H5(et"
"Hg*`+RLgv>=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ':+Q_k+uvOSLiEo(<aD/K<CCc`'Lx>'?;++O'>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRbA#Kjm%upV1g:"
"a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'ircp0LaE_OtlMb&1#6T.#FDKu#1Lw%u%+GM+X'e?YLfjM[VO0MbuFp7;>Q&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL("
"$/V,;(kXZejWO`<[5?\?ewY(*9=%wDc;,u<'9t3W-(H1th3+G]ucQ]kLs7df($/*JL]@*t7Bu_G3_7mp7<iaQjO@.kLg;x3B0lqp7Hf,^Ze7-##@/c58Mo(3;knp0%)A7?-W+eI'o8)b<"
"nKnw'Ho8C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE5^V8O(x<<aG/1N$#FX$0V5Y6x'aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM(=/M0:JxG'?"
"7WhH%o'a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-e47&Kl+f//9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?'(<S:68tq*WoDfZu';mM?8X[ma8W%*`-=;D.(nc7/;"
")g:T1=^J$&BRV(-lTmNB6xqB[@0*o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<-ui#qUq2$##Ri;u75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3M"
"D?@f&1'BW-)Ju<L25gl8uhVm1hL$##*8###'A3/LkKW+(^rWX?5W_8g)a(m&K8P>#bmmWCMkk&#TR`C,5d>g)F;t,4:@_l8G/5h4vUd%&%950:VXD'QdWoY-F$BtUwmfe$YqL'8(PWX("
"P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w'KD`LP5IbH;rTV>n3cEK8U#bX]l-/V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO*5NK,((W-i:$,kp'UDAO(G0Sq7MVjJs"
"bIu)'Z,*[>br5fX^:FPAWr-m2KgL<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/k=rKbxuV`>Q_nN6'8uTG&#1T5g)uLv:873UpTLgH+#FgpH'_o1780Ph8KmxQJ8#H72L4@768@Tm&Q"
"h4CB/5OvmA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//,]1?#`VY[Jr*3&&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z'<$#4H)6,>e0jT6'N#(q%.O=?2S]u*(m<-"
"V8J'(1)G][68hW$5'q[GC&5j`TE?m'esFGNRM)j,ffZ?-qx8;->g4t*:CIP/[Qap7/9'#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFFcL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5i"
"sZ88+dKQ)W6>J%CL<KE>`.d*(B`-n8D9oK<Up]c$X$(,)M8Zt7/[rdkqTgl-0cuGMv'?>-XV1q['-5k'cAZ69e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE=68>K8r0=dSC%%(@p7"
".m7jilQ02'0-VWAg<a/''3u.=4L$Y)6k/K:_[3=&jvL<L0C/2'v:^;-DIBW,B4E68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW'b)Tq7VT9q^*^$$.:&N@@"
"$&)WHtPm*5_rO0&e%K&#-30j(E4#'Zb.o/(Tpm$>K'f@[PvFl,hfINTNU6u'0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'lQSu/m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*"
"hv^BFpQj:K'#SJ,sB-'#](j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/,;qB3ebNW[?,Hqj2L.1NP&GjUR=1D8QaS3Up&@*9wP?+lo7b?@%'k4`p0Z$22%K3+iCZj?XJN4Nm&+YF]u"
"@-W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAKjKjseK</xKT*)B,N9X3]krc12t'pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8cY#YZ?=,`Wdxu/ae&#"
"w6)R89tI#6@s'(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,;^R)7[$s<Eh#c&)q.MXI%#v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D###EC><?-aF&#RNQv>o8lKN%5/$(vdfq7+ebA#"
"u1p]ovUKW&Y%q]'>$1@-[xfn$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)jEIF*+?P2a8g%)$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0"
"d=j.LQf./Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c)QL5uJ#%u%lJj+D-r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrLW-1pG_&2UdB8"
"6e%B/:=>)N4xeW.*wft-;$'58-ESqr<b?UI(_%@[P46>#U`'6AQ]m&6/`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc%QJv92.(Db*B)gb*BM9dM*hJMAo*c&#"
"b0v=Pjer]$gG&JXDf->'StvU7505l9$AFvgYRI^&<^b68?j#q9QX4SM'RO#&sL1IM.rJfLUAj221]d##DW=m83u5;'bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''X.`$#8+1GD"
":k$YUWsbn8ogh6rxZ2Z9]%nd+>V#*8U_72Lh+2Q8Cj0i:6hp&$C/:p(HK>T8Y[gHQ4`4)'$Ab(Nof%V'8hL&#<NEdtg(n'=S1A(Q1/I&4([%dM`,Iu'1:_hL>SfD07&6D<fp8dHM7/g+"
"tlPN9J*rKaPct&?'uBCem^jn%9_K)<,C5K3s=5g&GmJb*[SYq7K;TRLGCsM-$$;S%:Y@r7AK0pprpL<Lrh,q7e/%KWK:50I^+m'vi`3?%Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*"
"$3WoJSCLweV[aZ'MQIjO<7;X-X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+J5AlrB#$p(H68LvEA'q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7"
":d[/;r_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup'D#L$Pb_`N*g]2e;X/Dtg,bsj&K#2[-:iYr'_wgH)NUIR8a1n#S?Yej'h8^58UbZd+^FKD*T@;6A"
"7aQC[K8d-(v6GI$x:T<&'Gp5Uf>@M.*J:;$-rv29'M]8qMv-tLp,'886iaC=Hb*YJoKJ,(j%K=H`K.v9HggqBIiZu'QvBT.#=)0ukruV&.)3=(^1`o*Pj4<-<aN((^7('#Z0wK#5GX@7"
"u][`*S^43933A4rl][`*O4CgLEl]v$1Q3AeF37dbXk,.)vj#x'd`;qgbQR%FW,2(?LO=s%Sc68%NP'##Aotl8x=BE#j1UD([3$M(]UI2LX3RpKN@;/#f'f/&_mt&F)XdF<9t4)Qa.*kT"
"LwQ'(TTB9.xH'>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/Usj(T7`Q8tT72LnYl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2'IM%L3I)X((e/dl2&8'<M"
":^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En'CR.q7E)p'/kle2HM,u;^%OKC-N+Ll%F9CF<Nf'^#t2L,;27W:0O@6##U6W7:$rJfLWHj$#)woqBefIZ.PK<b*t7ed;p*_m;4ExK#h@&]>"
"_>@kXQtMacfD.m-VAb8;IReM3$wf0''hra*so568'Ip&vRs849'MRYSp%:t:h5qSgwpEr$B>Q,;s(C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP'##p#C0c%-Gb%"
"hd+<-j'Ai*x&&HMkT]C'OSl##5RG[JXaHN;d'uA#x._U;.`PU@(Z3dt4r152@:v,'R.Sj'w#0<-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%>.G690a:$##<,);?;72#?x9+d;"
"^V'9;jY@;)br#q^YQpx:X#Te$Z^'=-=bGhLf:D6&bNwZ9-ZD#n^9HhLMr5G;']d&6'wYmTFmL<LD)F^%[tC'8;+9E#C$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s'B;K-M6$EB%is00:"
"+A4[7xks.LrNk0&E)wILYF@2L'0Nb$+pv<(2.768/FrY&h$^3i&@+G%JT'<-,v`3;_)I9M^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<2Len$b*aTX=-8QxN)k11IM1c^j%"
"9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8'je'D7k`e;)2pYwPA'_p9&@^18ml1^[@g4t*[JOa*[=Qp7(qJ_oOL^('7fB&Hq-:sf,sNj8xq^>$U4O]GKx'm9)b@p7YsvK3w^YR-"
"CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp^iI9O8KnTj,]H?D*r7'M;PwZ9K0E^k&-cpI;.p/6_vwoFMV<->#%Xi.LxVnrU(4&8/P+:hLSKj$#U%]49t'I:rgMi'FL@a:0Y-uA[39',(vbma*"
"hU%<-SRF`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>Ti1O*H&#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*Vj>SsD<U4JHY"
"8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK'-x?'(:siIfL<$pFM`i<?%W(mGDHM%>iWP,##P`%/L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa8wD8=^GlPa8TKI1CjhsCTSLJM'/Wl>-"
"S(qw%sf/@%#B6;/U7K]uZbi^Oc^2n<bhPmUkMw>%t<)'mEVE''n`WnJra$^TKvX5B>;_aSEK',(hwa0:i4G?.Bci.(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs'6,'85`"
"0?t/'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/);TTm8VI;?%OtJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/ML3m;Z[$oF3g)GAWqpARc=<ROu7cL5l;-[A]%/"
"+fsd;l#SafT/f*W]0=O'$(Tb<[)*@e775R-:Yob%g*>l*:xP?Yb.5)%w_I?7uk5JC+FS(m#i'k.'a0i)9<7b'fs'59hq$*5Uhv##pi^8+hIEBF`nvo`;'l0.^S1<-wUK2/Coh58KKhLj"
"M=SO*rfO`+qC`W-On.=AJ56>>i2@2LH6A:&5q`?9I3@@'04&p2/LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]u7-P=.-_:YJ]aS@V"
"?6*C()dOp7:WL,b&3Rg/.cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+AurK<m86QIth*#v;-OBqi+L7wDE-Ir8K['m+DDSLwK&/.?-V%U_%3:qKNu$_b*B-kp7NaD'QdWQPK"
"Yq[@>P)hI;*_F]u`Rb[.j8_Q/<&>uu+VsH$sM9TA%?)(vmJ80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/Qt$F&:K*-(N/'+1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa"
">gXm8YB`1d@K#n]76-a$U,mF<fX]idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?0olP1C9Sa&H[d&c$ooQUj]Exd*3ZM@-WGW2%s',B-_M%>%Ul:#/'xoFM9QX-$.QN'>"
"[%$Z$uF6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o'$?X3B</R90;eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*'3E>=-<)Gt*Iw)'QG:`@I"
"wOf7&]1i'S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/6Aj7:'1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0'1<Vc52=u`3^o-n1'g4v58Hj&6_t7$##?M)c<$bgQ_'SY((-xkA#"
"Y(,p'H9rIVY-b,'%bCPF7.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*7NH%$c4Vs,eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$"
"MlvAF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo'RS1R84=@paTKt)>=%&1[)*vp'u+x,VrwN;&]kuO9JDbg=pO$J*.jVe;u'm0dr9l,<*wMK*Oe=g8lV_KEBFkO'oU]^=[-792#ok,)"
"i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K1<-rGdO'$Wr.Lc.CG)$/*JL4tNR/,SVO3,aUw'DJN:)Ss;wGn9A32ijw%FL+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo"
"1*c-(aY168o<`JsSbk-,1N;$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS[0;T%&Qc=+STRxX'q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W'$P"
"iDDG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7fSkgl6-++D:'A,uq7SvlB$pcpH'q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF6##$l84N1w?AO>'IAO"
"URQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi68%0xi_&[qFJ(77j_&JWoF.V735&T,[R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#"
";u.T%fAr%4tJ8&><1=GHZ_+m9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/+4T<XoIB&hx=T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>"
"w$)F./^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/X-TI(;P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*A#]-=A#a9OA#"
"d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%#NR@%#R_R%#Vke%#Zww%#_-4&#3^Rh%Sflr-k'MS.o?.5/sWel/wpEM0%3'/1)K^f1-d>G21&v(35>V`39V7A4=onx4"
"A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,;WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#'9$C#+E6C#"
"/QHC#3^ZC#7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L-d3#rWM4#Hga1#,<w0#T.j<#O#'2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`+78#4uI-#"
"m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$0#n`-0#sf60#(F24#wrH0#%/e0#"
"TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]PBB:xlBCC=2CDLXMCEUtiCf&0g2'tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP"
"GT4CPGT4CPGT4CPGT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI'O?;xp"
"O?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xp;7q-#lLYI:xvD=#";

// File: 'UbuntuMono-R.ttf' (205748 bytes)
// Exported using binary_to_compressed_c.cpp
const unsigned int ubuntu_mono_compressed_size = 150389;
const unsigned int ubuntu_mono_compressed_data[ 150392 / 4 ] =
{
		0x0000bc57, 0x00000000, 0xb4230300, 0x00000400, 0x00010025, 0x82110000, 0x042e0804, 0x53441000, 0xd26f4749, 0x03003045, 0x0000840a, 0x53473019,
		0xff0f4255, 0x0200b85a, 0x000048e1, 0x534f3c29, 0xc188322f, 0x0000d2fd, 0x35829801, 0x56603b08, 0x6c584d44, 0x004274ab, 0x001c0c00, 0x63e00500,
		0xf670616d, 0x003f5078, 0x00fc1100, 0x63860600, 0x0b207476, 0x004e124f, 0x00342000, 0x66040200, 0x766d6770, 0x00c444bd, 0x5f821800, 0x67230629,
		0xff707361, 0x820300ff, 0x8240205f, 0x6708384f, 0xac66796c, 0x001e1e29, 0x007c3600, 0x689c7702, 0xf5646165, 0x82dd1e06, 0x821c206f, 0x6836211f,
		0x05231082, 0x82a70035, 0x8254200f, 0x6824280f, 0x5f78746d, 0x82ed55a6, 0x00f83c0f, 0x6c220a00, 0x0661636f, 0x002478ed, 0x00382200, 0x6d441400,
		0x0b707861, 0x82a30980, 0x8278201f, 0x202c082f, 0x656d616e, 0x82fd3987, 0x18ae0200, 0x74040000, 0x74736f70, 0xf4b4da33, 0x8cb20200, 0xb12e0000,
		0x70657270, 0xa42f3e92, 0xa81e0000, 0x8a223382, 0x35820100, 0xcccc002e, 0x0d85bd7a, 0xf53c0f5f, 0xe8030900, 0xc9231183, 0x83cbbee5, 0xa6ca2b07,
		0xc4fecb4f, 0x990256ff, 0x0f823e03, 0x02000922, 0x05833185, 0xff3e032d, 0x01000056, 0xff5bfff4, 0x8699025b, 0x86248217, 0x00012102, 0x05295b82,
		0x00540110, 0x006e0055, 0x2c398207, 0x002f0010, 0x05000059, 0x00af07a7, 0x2c1d8203, 0x01f40103, 0x00050090, 0x02bc0200, 0x2035828a, 0x2507858c,
		0x3200dd01, 0x1582fa00, 0x09050b30, 0x03020603, 0x00e00402, 0x0050ff02, 0x23825b20, 0x442f0284, 0x00414d41, 0xff000040, 0xffb502fd, 0x8231005b,
		0x20aa259b, 0x569f0000, 0x02237182, 0x82b50208, 0x00202124, 0x47825d82, 0x02820a82, 0x8100b52e, 0x36001b00, 0x1f001200, 0x7100ce00, 0x392a0182,
		0x95002e00, 0xb1008c00, 0x09824500, 0x39004b28, 0x24003b00, 0x23824200, 0x33003f22, 0xb1240182, 0x31007d00, 0x31261982, 0x28005c00, 0x17820900,
		0x03822e20, 0x5b005b22, 0x2d201382, 0x3620c582, 0x5b287f82, 0x37002000, 0x49001d00, 0x37200382, 0x27240982, 0x0d003000, 0x19201382, 0x36260582,
		0x46008f00, 0x3b827600, 0xa3000826, 0x47003a00, 0x28204d82, 0x3f200d82, 0x47200382, 0x47204982, 0x36221182, 0x05822900, 0x03842820, 0x7b826b20,
		0x44003f26, 0x13001e00, 0x24264d82, 0x4f004900, 0x0582d400, 0x95822520, 0x07009424, 0xb9822a00, 0x48004822, 0x0920c782, 0x90206982, 0x9524cd82,
		0x2b009400, 0x72201782, 0x0024c182, 0x12007000, 0x9f204182, 0x0d202582, 0xb620ef82, 0x2d226d82, 0x87822600, 0x5382d420, 0x22007122, 0x3f208982,
		0x8c206d82, 0x7b200982, 0x2e26d982, 0x7e007c00, 0x7982aa00, 0xb1001c24, 0x0b829c00, 0x55005922, 0x11224182, 0xef821500, 0xef820920, 0x1b220387,
		0xf3822e00, 0x5b20f783, 0x5920f582, 0x12200384, 0x1d20f584, 0x0383a782, 0x07824620, 0xf9823020, 0x0d200383, 0x4720b182, 0x3a20ed82, 0x1f200388,
		0xfb83f786, 0xf7823620, 0x37200383, 0x1183f184, 0x2e220383, 0xa3822800, 0x03844420, 0x19822420, 0x7d822420, 0x03883a20, 0x85412e20, 0x22078706,
		0x82140036, 0x822820a7, 0x83039193, 0x22038b49, 0x822c002d, 0x8214202b, 0x903620b3, 0x00362203, 0x2213842a, 0x82400047, 0x20038373, 0x8b9d825b,
		0x82122003, 0x87a9830f, 0x001d2203, 0x22f7820b, 0x821d0047, 0x220387af, 0x826b0037, 0x822a2013, 0x20078303, 0x85078242, 0x00272303, 0x0387003f,
		0xd9823020, 0x20260393, 0x0d001300, 0x65822400, 0x03884920, 0x4184a120, 0x3f002722, 0xc42f9382, 0x7b008100, 0xbe008200, 0xab009e00, 0x83006400,
		0x8303872f, 0x00192e37, 0x00690074, 0x007d007f, 0x00770086, 0x240d8284, 0x007c007e, 0x28138c7e, 0x001b0035, 0xff15000c, 0x20bb82ff, 0x2003840b,
		0x20758215, 0x200f820f, 0x8403821c, 0x8383820b, 0x0015221f, 0x2009820f, 0x2e1d820b, 0x00090026, 0x0031003a, 0x002e0012, 0x82b10019, 0x001e24ef,
		0x8225004b, 0x822e200d, 0x00272203, 0x2201861c, 0x82870074, 0x8280206f, 0x0077226f, 0x20778275, 0x930d8277, 0x82d22013, 0x00b924bd, 0x827100d2,
		0x008c2401, 0x43280045, 0x4f250619, 0x90004900, 0x05bd4200, 0xb6009f22, 0x5524f382, 0x14005c00, 0x36207782, 0x0b20fd82, 0x2a208582, 0x87836f82,
		0x8d821220, 0x27002822, 0x19203982, 0x03200382, 0xff831582, 0x59004424, 0x29824000, 0xa1823620, 0xcfff2d22, 0x1d200982, 0x28220982, 0xf3822d00,
		0x0d821220, 0x37003724, 0x2f824100, 0x59822b20, 0x03821220, 0x30002724, 0x5d824400, 0x0d002d22, 0x3620e582, 0x18227d82, 0x17824300, 0x39003122,
		0x3a222582, 0x33823e00, 0x7900d426, 0xb5002300, 0x1b284182, 0x24000500, 0x63003600, 0x24200582, 0x09220382, 0x6f823a00, 0x28206b83, 0xd1414784,
		0x422d200f, 0x1b2208b1, 0xa1821f00, 0x03842820, 0x2b004022, 0x22082f42, 0x822c0018, 0x821b2061, 0x8405205b, 0x8224201b, 0x82372081, 0x83598311,
		0x821d2033, 0x830b8385, 0x825b2003, 0x2203830b, 0x882f0053, 0x221f8375, 0x82530037, 0x886b20d5, 0x821e2081, 0x822d20bb, 0x002d2257, 0x20a38219,
		0x20af8221, 0x20878449, 0x203f825b, 0x8303861e, 0x420b8337, 0x2522056b, 0xdd843f00, 0x83860920, 0x0f821220, 0x44004a26, 0x12005500, 0x09240182,
		0x26005b00, 0x47204582, 0x1226b584, 0x15002100, 0x5f822a00, 0x6400822a, 0x7000a700, 0x6b008900, 0x71240184, 0x8c009c00, 0x50210182, 0x20018300,
		0x2035825b, 0x20358212, 0x229b8226, 0x825a005a, 0x00092209, 0x204d822d, 0x220f8240, 0x82310009, 0x05f94391, 0x27821220, 0x5f820420, 0x17823720,
		0x0d004024, 0x25822000, 0x03821d20, 0x8b824920, 0x25822720, 0xc5822a20, 0x3d822d20, 0x3d842d20, 0x05822420, 0x03822e20, 0x3a003922, 0x47200582,
		0x1b207782, 0x0722d182, 0xb1824800, 0x47003f22, 0x1b203f82, 0x28200582, 0x47200382, 0x3a206382, 0x1a20ff82, 0x4720b582, 0x2d203f88, 0x3b201982,
		0x67440d82, 0x82142005, 0x0031223f, 0x200f8242, 0x223b8436, 0x82140036, 0x823f2007, 0x00472235, 0x20ab8227, 0x203b8212, 0x20538228, 0x209b821e,
		0x200f843f, 0x201f8249, 0x22358236, 0x84210036, 0x0004227f, 0x22bb8207, 0x82400048, 0x82302017, 0x84122047, 0x84112025, 0x836b831b, 0x821d20e3,
		0x822e20a1, 0x8227208d, 0x000d22b3, 0x204f841e, 0x83598219, 0x0503412b, 0x2f843620, 0x12233b85, 0x83005900, 0x842e2055, 0x8c0d2091, 0x00202249,
		0x421d821b, 0x1b24070f, 0x5b001f00, 0x19205b82, 0x03832382, 0x18228b87, 0xaf842c00, 0x3f003722, 0x240c9744, 0x003b002e, 0x87db8209, 0x207b8503,
		0x2011826b, 0x2003822d, 0x204d8200, 0x224d8221, 0x4174001b, 0x0920069b, 0x99835d82, 0x73821d20, 0x13824020, 0x55822220, 0x51822520, 0x49002d22,
		0x24202782, 0x2a26c782, 0x2b001600, 0xdb821200, 0x17824720, 0x45002722, 0x47207182, 0x36200d82, 0x1d20bb82, 0x1e220382, 0x29824000, 0x09824720,
		0x07823f20, 0x07823f20, 0x27821a20, 0x6d822520, 0xbcff092e, 0xb6ff88ff, 0xb8ff5900, 0x0d007eff, 0x31200982, 0x47213d82, 0x20938300, 0x20338626,
		0x22278247, 0x82ce00a4, 0x82312043, 0x2e038b53, 0xfff5ff06, 0xff58ff45, 0xff62ff78, 0x82a4ffae, 0x87452039, 0xb1ff2b03, 0x07ffb5ff, 0x1aff19ff,
		0x6f8207ff, 0x03887b83, 0xff83ff2b, 0xfed9fe88, 0xfeecfeea, 0x201f82d9, 0x416d841a, 0x05840505, 0xffb0ff27, 0xff06ffb4, 0x243d8218, 0xff48ff06,
		0x42878248, 0x05820527, 0xffa2ff27, 0xfed6fe86, 0x201b82e8, 0x26579004, 0xfef3fe85, 0x82fffec4, 0x8b2420af, 0x9fff2f03, 0xd5fe84ff, 0x17ffe7fe,
		0x56ff02ff, 0xc5843cff, 0x9183a983, 0x57827183, 0x35834b84, 0xff2fe38e, 0xfea8ffb9, 0xff0bfff8, 0xff16ff2b, 0x9057ff60, 0xff832273, 0x8ccb8c83,
		0x24003179, 0x7bff96ff, 0xdefeccfe, 0xf9fe0eff, 0x2aff44ff, 0x2c0e4141, 0xff090009, 0x00e2ffbf, 0x00b90009, 0x220382b3, 0x89700082, 0x84ff3061,
		0x55ff86ff, 0x2d0059ff, 0x6a006000, 0x41008300, 0x05830595, 0x5900362a, 0x83ff5900, 0x690085ff, 0x83201b82, 0x002b958f, 0xff0d000d, 0xff42ff66,
		0x824900a4, 0x41982001, 0xff2b090d, 0xff9cff70, 0x009aff6e, 0x82980012, 0x0ec1416f, 0x410f9941, 0x3b441039, 0x003f2605, 0x005bff3a, 0x22b58204,
		0x84d20000, 0x86002001, 0x86d22000, 0x85068307, 0x2005870b, 0x20128382, 0x8405a300, 0x21048428, 0x01820001, 0x00820120, 0x000c002b, 0x00ff08f8,
		0xff0a0008, 0x207582fd, 0x2105820b, 0x0583000a, 0x0c000b22, 0x0c200b82, 0xf3830584, 0x0e00fd24, 0x11820e00, 0x05840f20, 0x0f001022, 0x11220b82,
		0x05821000, 0x05841220, 0x11001322, 0x14280b82, 0xfcff1200, 0x13001500, 0x16200582, 0x17220584, 0x0b821400, 0x15001822, 0x19200582, 0x1a220584,
		0x0b821600, 0x18001b26, 0x1c00fbff, 0x1d220584, 0x0b821900, 0x1a001e22, 0x1f200582, 0x20220584, 0x0b821c00, 0x1d002126, 0x2200faff, 0x23220584,
		0x0b821f00, 0x20002428, 0x2500f9ff, 0x05822100, 0x05842620, 0x22002722, 0x28220b82, 0x05822300, 0x05842920, 0x25002a22, 0x2b200b82, 0x2c220584,
		0x0b822600, 0x27002d28, 0x2e00f8ff, 0x05822800, 0x29002f22, 0x30220582, 0x05822a00, 0x05843120, 0x2b003228, 0x3300f7ff, 0x05822c00, 0x2d003422,
		0x35220582, 0x05822e00, 0x05843620, 0x2f003722, 0x38280b82, 0xf6ff3000, 0x31003900, 0x3a220582, 0x05823200, 0x33003b22, 0x3c220582, 0x05823500,
		0x05843d20, 0x36003e28, 0x3f00f5ff, 0x05823700, 0x05844020, 0x38004128, 0x4200f4ff, 0x05823900, 0x05844320, 0x3b004422, 0x45220b82, 0x05823c00,
		0x3d004622, 0x47200582, 0x48200584, 0x49220584, 0x11823e00, 0x05824a20, 0x4b00f32a, 0xf3ff3f00, 0x41004c00, 0x4d200582, 0x4e280584, 0xf2ff4200,
		0x43004f00, 0x50220582, 0x05824400, 0x45005122, 0x52220582, 0x05824600, 0x05845320, 0x47005428, 0x5500f1ff, 0x05824800, 0x49005622, 0x57220582,
		0x05824a00, 0x05845820, 0x4b005922, 0x5a220b82, 0x05824c00, 0x05845b20, 0x4e005c26, 0x5d00f0ff, 0x5e220584, 0x0b824f00, 0x50005f22, 0x60220582,
		0x05825100, 0x52006122, 0x62260582, 0xefff5300, 0x05846300, 0x54006422, 0x65220b82, 0x05825500, 0x05826620, 0x6700ee28, 0xeeff5700, 0x05846800,
		0x59006922, 0x6a260b82, 0xedff5a00, 0x05846b00, 0x5b006c22, 0x6d220b82, 0x05825c00, 0x05846e20, 0x5d006f22, 0x70220b82, 0x05825e00, 0x05847120,
		0x60007222, 0x73280b82, 0xecff6100, 0x63007400, 0x75200582, 0x76220584, 0x0b826400, 0x65007722, 0x78200582, 0x79280584, 0xebff6600, 0x67007a00,
		0x7b200582, 0xea280582, 0x68007c00, 0x7d00eaff, 0x7e220584, 0x0b826900, 0x6a007f22, 0x80220582, 0x05826b00, 0x6c008122, 0x82200582, 0x83220584,
		0x0b826e00, 0x6f008422, 0x85260582, 0xe9ff7000, 0x05848600, 0x71008722, 0x88200b82, 0x89220584, 0x0b827200, 0x74008a22, 0x8b200582, 0xe8280582,
		0x76008c00, 0x8d00e8ff, 0x8e220584, 0x0b827700, 0x78008f22, 0x90200582, 0x91280584, 0xe7ff7900, 0x7a009200, 0x93220582, 0x05827b00, 0x7c009426,
		0x9500e6ff, 0x96220584, 0x0b827d00, 0x7e009722, 0x98220582, 0x05827f00, 0x80009922, 0x9a220582, 0x05828100, 0x82009b22, 0x9c200582, 0xe5280582,
		0x84009d00, 0x9e00e5ff, 0x9f220584, 0x0b828500, 0x0584a020, 0x8700a122, 0xa2200b82, 0xe42a0582, 0x8800a300, 0xa400e4ff, 0x05828900, 0x8a00a522,
		0xa6200582, 0xa7280584, 0xe3ff8b00, 0x8c00a800, 0xa9220582, 0x05828e00, 0x0584aa20, 0x8f00ab22, 0xac220b82, 0x05829000, 0x9100ad28, 0xae00e2ff,
		0x05829200, 0x0584af20, 0x9300b028, 0xb100e1ff, 0x05829400, 0x0584b220, 0x9600b322, 0xb4200b82, 0xb5220584, 0x0b829700, 0x9800b622, 0xb7220582,
		0x05829900, 0x0584b820, 0x9b00b926, 0xba00e0ff, 0xbb220584, 0x0b829c00, 0x9d00bc22, 0xbd200582, 0xbe220584, 0x0b829e00, 0x9f00bf28, 0xc000dfff,
		0x0582a000, 0x0584c120, 0xa100c222, 0xc3260b82, 0xdeffa300, 0x0584c400, 0xa400c522, 0xc6220b82, 0x0582a500, 0xa600c722, 0xc8220582, 0x0582a700,
		0x0584c920, 0xa800ca22, 0xcb260b82, 0xddffaa00, 0x0584cc00, 0xab00cd22, 0xce220b82, 0x0582ac00, 0xad00cf22, 0xd0220582, 0x0582ae00, 0x0582d120,
		0xd200dc2a, 0xdcffaf00, 0xb000d300, 0xd4220582, 0x0582b100, 0x0582d520, 0xd600db2a, 0xdbffb200, 0xb300d700, 0xd8220582, 0x0582b400, 0xb500d922,
		0xda200582, 0xdb280584, 0xdaffb600, 0xb800dc00, 0xdd200582, 0xde220584, 0x0b82b900, 0xba00df22, 0xe5820582, 0xe1220582, 0x0582bc00, 0xbd00e222,
		0xe3200582, 0xd9280582, 0xbf00e400, 0xe500d9ff, 0xe6220584, 0x0b82c000, 0xc100e722, 0xe8200582, 0xe92c0584, 0xd8ffc200, 0xc400ea00, 0xeb00d7ff,
		0xec220584, 0x0b82c500, 0x0584ed20, 0xc600ee22, 0xef220b82, 0x0582c700, 0xc800f022, 0xf1220582, 0x0582c900, 0xca00f222, 0xf3220582, 0x0582cb00,
		0xcc00f422, 0xf5200582, 0xd6280582, 0xcd00f600, 0xf700d6ff, 0xf8220584, 0x0b82ce00, 0xcf00f922, 0xfa280582, 0xd5ffd100, 0xd200fb00, 0xfc200582,
		0xfd220584, 0x0b82d300, 0xd400fe22, 0xff200582, 0x00230584, 0x85000300, 0x001c2203, 0x24098201, 0x007c0400, 0x24098403, 0x0404001c, 0x26118260,
		0x008000e2, 0x82620006, 0x09de0809, 0x1d000d00, 0x31017e00, 0x48013701, 0x53015101, 0x61015f01, 0x7f017701, 0x92019101, 0x1b021702, 0x37023602,
		0x92024f02, 0xc702bc02, 0xdd02c902, 0x86031103, 0x8c038a03, 0xa1039003, 0xb003a903, 0xce03c903, 0x63045f04, 0xf9047504, 0xf31e851e, 0x1d1f151f,
		0x4d1f451f, 0x591f571f, 0x5d1f5b1f, 0xb41f7d1f, 0xd31fc41f, 0xef1fdb1f, 0xfe1ff41f, 0x1a201520, 0x22201e20, 0x30202620, 0x44203a20, 0x79207020,
		0xac208920, 0xb420ae20, 0x1321b920, 0x22211621, 0x2e212621, 0x02225e21, 0x0f220622, 0x15221222, 0x1e221a22, 0x48222b22, 0x65226022, 0x02250025,
		0x10250c25, 0x18251425, 0x24251c25, 0x34252c25, 0x6c253c25, 0x93258825, 0xffe0ca25, 0x02f0fdef, 0x1df811f5, 0xfdff02fb, 0xe182ffff, 0x08000022,
		0x203ce384, 0x3201a000, 0x49013801, 0x54015201, 0x62016001, 0x80017801, 0x93019201, 0x1c021802, 0x3820e382, 0xc620e384, 0xd820e382, 0x8422e382,
		0xe3828803, 0x038e2008, 0x03a30391, 0x03b103aa, 0x040004ca, 0x04720462, 0x1e801e8a, 0x1f001ff2, 0x1f201f18, 0x86501f48, 0x1f5f36e3, 0x1fb61f80,
		0x1fd61fc6, 0x1ff21fdd, 0x201320f6, 0x201c2018, 0x20e38420, 0x22e38439, 0x92802074, 0x865320e3, 0x821120e3, 0x881920e3, 0x966420e3, 0x825020e3,
		0x869120e3, 0xf50026e3, 0xfb0af806, 0x34e38401, 0xfff9ff01, 0xffe4fff5, 0xffdbffe3, 0xffddffdc, 0xff0000de, 0x200382dc, 0x34fd82da, 0x00d2fe59,
		0x0041ff58, 0x0026ff54, 0xfe110053, 0xfe0000a2, 0x201b8297, 0x221b8293, 0x823b003b, 0xff002605, 0xff0000ff, 0x081782f8, 0xb2feb32a, 0x90fea4fe,
		0x7ae2e6e2, 0xd7e4d9e4, 0xd3e4d5e4, 0xd0e4d1e4, 0xcee4cfe4, 0xcbe4cde4, 0xc9e4cae4, 0xc6e4c7e4, 0xc3e4c4e4, 0x03833783, 0x40e02708, 0x00003ae0,
		0xffe02ae1, 0xf6e0fce0, 0xdfe2b6df, 0x24e4d8e2, 0x74e26de0, 0x78e054df, 0x000053e0, 0x95df98df, 0x07828ddf, 0xdf8b2208, 0xdf85df88, 0xdf5ddf79,
		0xdf43df46, 0xdfe3dfe6, 0xdfdedfd8, 0xdfcadfcf, 0xdfc3dfce, 0xdfb5dfbc, 0x342582af, 0xdb7adf82, 0x14df23df, 0x0c0000e4, 0x00a40988, 0x00e30400,
		0x8e698301, 0x82d02003, 0x8203870f, 0x20028c0a, 0x830d82cc, 0x82d42003, 0x00002107, 0xde200589, 0x04a70f84, 0xbe00ba26, 0xc600c200, 0x05852e84,
		0x04900a84, 0x1186ae20, 0x0786be20, 0x9c20069d, 0xca201e8a, 0x05850b84, 0x006dca08, 0x006b0079, 0x017a0077, 0x01530152, 0x01550154, 0x01570156,
		0x01690058, 0x0161015f, 0x01630162, 0x01750064, 0x03d60365, 0x03c203d8, 0x03ca03c8, 0x03c603d0, 0x03cb03c9, 0x03cd03cc, 0x03d403ce, 0x03d203cf,
		0x03d303d1, 0x007300d5, 0x008b0374, 0x006f006e, 0x00700063, 0x00650071, 0x00680067, 0x006c0072, 0x01820178, 0x01880183, 0x018a0189, 0x018c018b,
		0x0184018d, 0x01860185, 0x019d0187, 0x0401059f, 0x05f604f7, 0x04000509, 0x040805f5, 0x05f304ff, 0x04fd0406, 0x040505f2, 0x05f004fc, 0x04fa0403,
		0x040205ef, 0x05f404f9, 0x04fe0407, 0x040405f1, 0x050f05fb, 0x04f8040e, 0x01aa01df, 0x01ab01ac, 0x020600ad, 0x21d5830a, 0xb5410001, 0x00012310,
		0x00850002, 0x00200787, 0x01200096, 0xbc081784, 0x00040003, 0x00060005, 0x00080007, 0x000a0009, 0x000c000b, 0x000e000d, 0x0010000f, 0x00120011,
		0x00140013, 0x00160015, 0x00180017, 0x001a0019, 0x001c001b, 0x001e001d, 0x0020001f, 0x00220021, 0x00240023, 0x00260025, 0x00280027, 0x002a0029,
		0x002c002b, 0x002e002d, 0x0030002f, 0x00320031, 0x00340033, 0x00360035, 0x00380037, 0x003a0039, 0x003c003b, 0x003e003d, 0x0040003f, 0x00420041,
		0x00440043, 0x00460045, 0x00480047, 0x004a0049, 0x004c004b, 0x004e004d, 0x0050004f, 0x00520051, 0x00540053, 0x00560055, 0x00580057, 0x005a0059,
		0x005c005b, 0x005e005d, 0x0060005f, 0x08c18261, 0xa0009fde, 0xa400a200, 0xb100ac00, 0xbc00b700, 0xbd00bb00, 0xbe00bf00, 0xc200c000, 0xc300c400,
		0xc600c500, 0xc700c800, 0xca00c900, 0xce00cc00, 0xcf00cd00, 0xd000d100, 0xd400d500, 0xd700d600, 0x8b006700, 0x7e007d00, 0x72008200, 0xba009100,
		0x84008900, 0x8f007600, 0xa6018300, 0xb300a100, 0x8c00a301, 0xa801a701, 0x90008000, 0x9d019a01, 0xb8039c01, 0x8500a401, 0x9e019500, 0xd300c100,
		0x7c009a00, 0xa2018700, 0xa5016400, 0x86009b01, 0x66009600, 0x9b007b00, 0xb0009e00, 0x79006d00, 0x74007300, 0x71007000, 0x6f006e00, 0xa901d200,
		0x7a00da00, 0x62006e01, 0x78006c00, 0xad01ab01, 0x92006800, 0x65006300, 0x9d006a00, 0x9c00a500, 0xa300a600, 0xa900a800, 0xa700aa00, 0xaf00ae00,
		0xad2ee182, 0xb600b500, 0x0c01b400, 0x75006900, 0xa7428a00, 0x005a0805, 0x01650193, 0x005f0164, 0x583f4000, 0x52535455, 0x4e4f5051, 0x4a4b4c4d,
		0x46474849, 0x42434445, 0x3e3f4041, 0x3a3b3c3d, 0x36373839, 0x2d2e2f35, 0x2526282c, 0x1f222324, 0x10111418, 0x0a0b0d0f, 0x06070809, 0x02030405,
		0x452c0001, 0x20604623, 0xb06026b0, 0x48232604, 0x0f832d48, 0x82612321, 0x8a612010, 0xb0602210, 0x20128220, 0x21238d46, 0x378320b0, 0x1a826120,
		0x4020298c, 0x66202982, 0x4020298e, 0x40202985, 0x01355388, 0x003c2010, 0x202c2d3c, 0xb0202345, 0x202344cd, 0x515a01b8, 0x260b8258, 0x5923448d,
		0x84edb020, 0x844d200b, 0x2604210b, 0x0d200c84, 0x21210c82, 0x08318221, 0x18452023, 0xb0204468, 0x45206001, 0x687646b0, 0x4460458a, 0xb1012c2d,
		0x23430a0b, 0x2d0a6543, 0x0ab1002c, 0x200a820b, 0x2809820b, 0x702328b0, 0x3e2801b1, 0x28088401, 0x3a452802, 0x080002b1, 0x3044820d, 0x2503b045,
		0xb0646145, 0x45585150, 0x21211b44, 0x21138459, 0x4b844300, 0x4306b024, 0x4b8407b0, 0xb0692022, 0x0037b382, 0x2cb1208b, 0xb88c8ac0, 0x60620010,
		0x23640c2b, 0x585c6164, 0x826103b0, 0x038a3d34, 0x878a8a45, 0xb02b11b0, 0xb0442329, 0x18e47a29, 0x65452c2d, 0x44232cb0, 0x232bb045, 0x4b219882,
		0x29608852, 0x2505b001, 0x8a202310, 0xbc8200f5, 0xeced2322, 0x118ab582, 0x11866120, 0x10250624, 0x1c8300f5, 0x2641e283, 0x01b02208, 0x200b8761,
		0x829b8200, 0x21df82a1, 0x8b832121, 0x40b88b2b, 0x2c2d6200, 0x5180b021, 0x2c0f8558, 0x1b620020, 0x2f4000b2, 0x02b0592b, 0x20198360, 0x211987c0,
		0x19835515, 0x19878020, 0x60223e88, 0xb7822123, 0x60452322, 0x762b0286, 0x80b01868, 0x2c2d2062, 0x842604b0, 0xb0252e02, 0x23452504, 0x03b02045,
		0x63626026, 0x24078368, 0x238a6561, 0x28e18244, 0x00b04520, 0x40b05854, 0x21088244, 0x4c416140, 0xb1452306, 0x2f822f30, 0x82606121, 0x826920ea,
		0x514b2a24, 0x232fb058, 0x2314b070, 0x056d4142, 0x44821082, 0x69452524, 0x32845853, 0x45271585, 0xb04314b0, 0x86636000, 0x2fb02235, 0x253b8245,
		0x45202345, 0x0884608a, 0x06834520, 0x51234b32, 0x3300b958, 0x34b1e0ff, 0x33b31b20, 0x59003400, 0xb0238783, 0x82584316, 0x4525089e, 0x6664588a,
		0x1b601fb0, 0x6020b064, 0x1b582066, 0x5940b021, 0x596101b0, 0x59655823, 0x442329b0, 0x29b01023, 0x236e82e0, 0x59212121, 0x3583e082, 0x2d8edb82,
		0xf6822c87, 0x2507b02d, 0x02582008, 0xb059031b, 0x82102505, 0x46202110, 0x23220482, 0x18823c42, 0x06b01023, 0x820e8425, 0x241182b0, 0x1b015820,
		0x82268700, 0x83218665, 0x25042109, 0x0c82478a, 0x43250323, 0x223c8248, 0x822503b0, 0x4843243a, 0x8259211b, 0x9a02838f, 0x851b2092, 0x218682c0,
		0x938808b0, 0x93820420, 0x84850520, 0xaf868182, 0x2d859a98, 0x29249083, 0x44654520, 0x0f832786, 0x8a250521, 0x840c8254, 0x96b585a0, 0x820220a7,
		0x8420206c, 0x422321fd, 0x08209382, 0x4521cb82, 0x20c28548, 0x200b8202, 0x221e8220, 0x8202b008, 0x081382e7, 0x452c2d2d, 0x18452023, 0x5000b020,
		0x65235820, 0x68235923, 0x5040b020, 0x40b02158, 0x65582359, 0x44608a59, 0x534b2c2d, 0x5a514b23, 0x82452058, 0x050f420d, 0x8c544b21, 0x201f850d,
		0x861b8838, 0x02b02709, 0xb0585443, 0x17822b46, 0x8405d341, 0x8447200f, 0x2d59220f, 0x201e852c, 0x201e8e48, 0x820f8449, 0x8a20261e, 0x534b2308,
		0x2079838a, 0x2f508623, 0x498a2000, 0x585100b0, 0x202340b0, 0x3412388a, 0x2b087085, 0x46234601, 0x61462360, 0x20102023, 0xb8618a46, 0x8a6280ff,
		0x8a4040b1, 0x68604570, 0x202c2d3a, 0x6449238a, 0x5853238a, 0x59211b3c, 0x5224cc82, 0x7a1b7d58, 0x26080882, 0x4b0012b0, 0x42544b01, 0x02b12c2d,
		0x23b14200, 0xb1518801, 0x53880140, 0x10b9585a, 0x88200000, 0x02b15854, 0x82594201, 0x18453629, 0x514b2368, 0x45202358, 0x40b06420, 0x597c5850,
		0x59608a68, 0x24c18244, 0x02b01600, 0x37028225, 0x2301b001, 0x02b0003e, 0x01b13e23, 0xb00c0602, 0x4265230a, 0x42230bb0, 0x3f201783, 0x3f201783,
		0x06201785, 0x27081783, 0xb0422307, 0x2d011601, 0x9f0e4000, 0x02a3afa3, 0x211a9d40, 0x2a799b46, 0xc0ffb81f, 0x0c9a0c40, 0x79974612, 0x73951f48,
		0x54211085, 0x28108294, 0x1f137392, 0x1f487391, 0x2025828f, 0x201c828e, 0x201c828c, 0x200f828b, 0x28078281, 0x1f2a838a, 0x1f488689, 0x201b8288,
		0x201b8285, 0x202b8283, 0x20178282, 0x201f827f, 0x20078278, 0x2c17827c, 0x79bf79af, 0x400379cf, 0x46231f79, 0x08138276, 0x0101ba2b, 0x00014300,
		0x68552240, 0x66556743, 0x64556543, 0x63556143, 0x62556043, 0x5e555f43, 0x5c555d43, 0x5a555b43, 0xb0555943, 0x232682b8, 0x650f014a, 0x43080282,
		0x658f657f, 0x01613003, 0x61306110, 0x61906160, 0x61e061b0, 0x015faf06, 0x30015d00, 0x905d605d, 0x4358035d, 0x43575556, 0x90535555, 0x9052554d,
		0x9051554b, 0x9050554a, 0x5b465549, 0x5b455542, 0x53545541, 0xb3374e82, 0x01050116, 0x4b9001b8, 0x52e703b8, 0x5008b04b, 0x8801b05b, 0x835325b0,
		0x40220805, 0x06b05a51, 0x5500b088, 0xb1585b5a, 0x598e0101, 0x008d8d85, 0xb04b1d42, 0xb058531d, 0x4b591da0, 0x088248b0, 0x08834020, 0x08828020,
		0xb11d002a, 0x59420016, 0x2b002b2b, 0x73220086, 0x02827374, 0x86737421, 0x2b2b220e, 0x821b8201, 0x8201200d, 0x82248510, 0x82088209, 0x82358505,
		0x1874221f, 0x82004000, 0x866b0221, 0xff0d2284, 0x290983f3, 0x0000d001, 0x00005bff, 0x0d83b502, 0xff0a0027, 0x00f6fff6, 0x250b830a, 0xf2ff6b02,
		0x2f820e00, 0x21820e20, 0x3401f22a, 0x1901f2ff, 0x78017002, 0x09261582, 0xfa00f7ff, 0x17820900, 0x2983f720, 0x52200390, 0x54201184, 0x52220582,
		0x05824600, 0x48003a22, 0x42210582, 0x26178300, 0x00550052, 0x823d0073, 0x82432017, 0x00482413, 0x82780043, 0x82542017, 0x84462007, 0x00522225,
		0x24178260, 0x00540087, 0x2023823c, 0x200b8436, 0x200b8248, 0x8709822d, 0x872a2002, 0xaf074008, 0xff190122, 0x20073141, 0x8bbb8244, 0x00bc3403,
		0x00140100, 0x00200200, 0x006c0300, 0x007c0400, 0x82500600, 0x00982403, 0x82580700, 0x00f42303, 0x23820800, 0x00080925, 0x82680900, 0x82902003,
		0xcc270803, 0x0c0a0000, 0x840b0000, 0x040c0000, 0x180d0000, 0x9c0e0000, 0x540f0000, 0x78100000, 0xc8110000, 0x24120000, 0x82130000, 0x2015253b,
		0x4c150000, 0x64200382, 0xf8240382, 0x44160000, 0xdc370382, 0xd0170000, 0x3c190000, 0x701a0000, 0x8c1b0000, 0xa81c0000, 0x821d0000, 0xac1d2427,
		0x821e0000, 0x821f2053, 0x781f2453, 0x821f0000, 0x60202527, 0x10210000, 0x97820382, 0x00a42229, 0x00302300, 0x822c2400, 0x00d82303, 0x5f822600,
		0xd2822720, 0x00682824, 0x3b822800, 0x00482930, 0x00d42900, 0x00fc2b00, 0x00b82c00, 0x6f822d00, 0xbf822d20, 0x7b822d20, 0x00342e25, 0x82702e00,
		0x20378203, 0x2033822f, 0x200f822f, 0x30038230, 0x00001c31, 0x0000c431, 0x00009032, 0x0000c833, 0x24238234, 0x0000b835, 0x20778236, 0x25f78237,
		0x0000a437, 0x03825438, 0x0000e42f, 0x0000a039, 0x0000403a, 0x0000383b, 0x20a3823c, 0x2057823c, 0x2497823d, 0x0000ac3e, 0x357b823f, 0x0000e43f,
		0x00009c40, 0x00006442, 0x00002443, 0x00009444, 0x03821445, 0x0000f423, 0x200f8246, 0x28db8247, 0x0000b447, 0x0000d848, 0x20438249, 0x203f8249,
		0x202f824a, 0x240b824b, 0x0000984b, 0x2053824c, 0x2033824c, 0x20b7824e, 0x2087824e, 0x2097824e, 0x208b824f, 0x24178250, 0x00007450, 0x25ab8251,
		0x0000c051, 0x03821052, 0x52203382, 0x5225a382, 0x530000f0, 0x820382b0, 0x82542053, 0x6c55241f, 0x82550000, 0x200383a7, 0x247b8256, 0x0000e056,
		0x241f8257, 0x00008458, 0x20c78259, 0x20678259, 0x2853825b, 0x0000285c, 0x0000ec5d, 0x2503825e, 0x00005c5f, 0x03828c5f, 0x61288b82, 0x610000d4,
		0x620000fc, 0x63242782, 0x64000000, 0x6520d782, 0x65207382, 0x6624c382, 0x66000088, 0x67206f82, 0x6720c782, 0x6720a782, 0x6820bf82, 0x69200782,
		0x69242782, 0x6b0000d0, 0x6c24a782, 0x6d0000dc, 0x6e208b82, 0x6e242382, 0x6e000030, 0x6e205b82, 0x6e203782, 0x6f201f82, 0x70242f82, 0x720000ac,
		0x72200f82, 0x72248382, 0x730000e4, 0x7320a382, 0x73206382, 0x7320df82, 0x7324b782, 0x740000cc, 0x74203b82, 0x75208782, 0x75255782, 0x7500002c,
		0x20038258, 0x82038284, 0x827520c7, 0x44762533, 0x40780000, 0x70200382, 0xb3820382, 0x82c87821, 0x20b38207, 0x20d38279, 0x20a78279, 0x207f827b,
		0x203b827c, 0x250f827c, 0x0000507c, 0x0382787c, 0x0382a820, 0x7e245382, 0x7f000064, 0x7f20b382, 0x7f25d382, 0x800000e8, 0x82038210, 0x6c80214b,
		0x98200782, 0xc4200382, 0xa7820382, 0x0f828220, 0x0f828220, 0x27828220, 0x27828220, 0x27828320, 0x00388325, 0x82688300, 0x200f8203, 0x20eb8285,
		0x20878285, 0x20278285, 0x204f8285, 0x24378285, 0x0000ec85, 0x24ff8286, 0x00000c87, 0x212b8287, 0x07826087, 0x03828c20, 0x0000b423, 0x20f78288,
		0x24d7828a, 0x0000308a, 0x20cf828a, 0x20cf828a, 0x8213838a, 0x828b20ab, 0x828b20ab, 0x548b24e7, 0x828b0000, 0x828c2017, 0x748c24a3, 0x828d0000,
		0x828d205b, 0x828d20df, 0x828d205b, 0x1c8e25d7, 0x4c8e0000, 0x1b820382, 0xdb828f20, 0x2b829020, 0x00b09024, 0x43829000, 0x5b829120, 0x43829120,
		0x5b829120, 0x00809125, 0x82ac9100, 0x20ef8203, 0x24cb8291, 0x00002092, 0x20378292, 0x247b8293, 0x0000cc93, 0x201b8294, 0x20338294, 0x20338295,
		0x25138295, 0x00005c95, 0x03828895, 0x9620a782, 0x97240b82, 0x9700003c, 0x9720e782, 0x97202382, 0x9820eb82, 0x99209782, 0x99204382, 0x99204382,
		0x99207b82, 0x99209382, 0x9a259382, 0x9b0000a0, 0x82038250, 0x829c206f, 0x829c2047, 0x7c9c247b, 0x829c0000, 0x829c2017, 0x829c201f, 0x0c9d243b,
		0x829d0000, 0x829e20a7, 0x789e243b, 0x829e0000, 0xc89e211b, 0xf0230782, 0x829f0000, 0x489f24cf, 0x82a00000, 0x82a02043, 0x38a12443, 0x82a10000,
		0x24a224af, 0x82a20000, 0x82a2202f, 0x82a2202f, 0xd4a2242f, 0x82a30000, 0x34a321ab, 0x9f820782, 0x4f82a320, 0xc382a320, 0x00dca324, 0x1782a400,
		0x7b82a420, 0x7b82a420, 0x1782a420, 0x1782a420, 0x0098a625, 0x8244a800, 0x20638203, 0x204f82a9, 0x204f82aa, 0x206782aa, 0x20df82aa, 0x255382ab,
		0x0000a4ab, 0x0382ccab, 0xac201b82, 0xac20d782, 0xac206b82, 0xac25d782, 0xac00009c, 0x230382c0, 0xad0000f4, 0xae243382, 0xae000000, 0xaf246382,
		0xaf000008, 0xaf217b82, 0x20078260, 0x82038288, 0x82af2047, 0x82b02017, 0x82b020db, 0x64b02517, 0x8cb00000, 0xfc230382, 0x82b10000, 0x82b12037,
		0x82b1204f, 0x82b1204f, 0x82b22087, 0x82b22023, 0x82b220b3, 0x82b22073, 0x10b32437, 0x82b30000, 0x82b3201f, 0x40b424d3, 0x82b40000, 0xbcb42137,
		0xe8240782, 0x14b50000, 0x3c200382, 0x70200382, 0xf7820382, 0x82d0b521, 0x24538207, 0x000038b6, 0x820383b7, 0xd8b82497, 0x82ba0000, 0x82bb201b,
		0x68be2467, 0x82bf0000, 0x82bf207b, 0x82bf20d3, 0x82bf2047, 0x82bf2017, 0xc8bf2163, 0x9f821782, 0xff82bf20, 0x0004c025, 0x8218c000, 0x002c2303,
		0x2782c100, 0x0048c224, 0x9382c400, 0xf782c620, 0x7382c720, 0x00a8ca24, 0xa782cd00, 0x7782cf20, 0xa782d020, 0x1782d220, 0x00e4d330, 0x0044d500,
		0x0094d600, 0x0058d800, 0x1382d900, 0x3f82da20, 0x0080db24, 0x6f82dc00, 0x00dcdd24, 0x2f82df00, 0x7382e020, 0x001ce224, 0xaf82e300, 0x2382e520,
		0x0050e628, 0x00ace800, 0xb782e900, 0x2782ea20, 0xf382ea20, 0x6f82eb20, 0x0028ec24, 0x1b82ec00, 0x8260ec21, 0x82742007, 0x243f8203, 0x0000b8ed,
		0x213b82ee, 0x078234ee, 0x33820b83, 0x8f82ee20, 0x7b82ef20, 0x3782f020, 0x8b82f120, 0xa782f220, 0x00bcf225, 0x82ccf200, 0x21338203, 0x0782ecf2,
		0x0000fc23, 0x201782f3, 0x203b82f3, 0x209382f3, 0x218782f3, 0x13824cf3, 0xf3202f82, 0xf3218782, 0x820b8284, 0x82f320cf, 0xc0f32187, 0xd4200b82,
		0x57820382, 0x3782f320, 0x0010f425, 0x8224f400, 0x208b8203, 0x202382f4, 0x206b82f4, 0x201382f5, 0x25bb82f5, 0x000030f5, 0x038240f5, 0xf5201b82,
		0xf520a782, 0xf5204b82, 0xf521ef82, 0x20138290, 0x200382a0, 0x820382b0, 0x82f5204f, 0xe0f521a7, 0xf0240b82, 0x00f60000, 0x14200382, 0x53820382,
		0xc782f620, 0xeb82f620, 0x8782f720, 0x00d8f828, 0x00b4f900, 0x8382fa00, 0x3b82fb20, 0x0382fc20, 0x4b82fd20, 0x0782fe20, 0x78ff2108, 0x88ff0000,
		0x78000100, 0x58010100, 0x24020100, 0xb4030100, 0x10040100, 0x28050100, 0x7c060100, 0xf4230382, 0x82080100, 0x82092017, 0x0c0b2907, 0x980b0100,
		0x200c0100, 0xf0270382, 0xbc0d0100, 0x820e0100, 0x820f2037, 0x3010383f, 0xe0100100, 0x74110100, 0xb0120100, 0xfc130100, 0x14150100, 0x82160100,
		0x9017241f, 0x82180100, 0x9c192423, 0x821a0100, 0x2c1c250b, 0x941d0100, 0xa4230382, 0x821e0100, 0xd01f292b, 0x3c200100, 0x08210100, 0x27820382,
		0x005c2224, 0x83822301, 0x67822420, 0x47822420, 0x00ac252c, 0x00a02601, 0x00642701, 0x8b822801, 0x00502924, 0x3b822a01, 0x00cc2b28, 0x00e42c01,
		0x27822e01, 0x53822f20, 0x00343028, 0x006c3101, 0x0b823201, 0x4f823220, 0x82543221, 0x201f820b, 0x20bb8232, 0x208b8234, 0x243f8235, 0x0100a836,
		0x200b8237, 0x24e78237, 0x01006838, 0x20c78238, 0x24b78239, 0x0100c43a, 0x250b823a, 0x0100183b, 0x0382443b, 0x03827020, 0x3b20af82, 0x3b201782,
		0x3c201782, 0x3d201782, 0x3d249f82, 0x3d010040, 0x3d20a382, 0x3d24b782, 0x3e0100e8, 0x3e207b82, 0x3e20e382, 0x3f20d782, 0x4028b782, 0x40010080,
		0x410100b8, 0x41201f82, 0x42245782, 0x4201000c, 0x43249782, 0x44010074, 0x4420c382, 0x4420b382, 0x45208f82, 0x4620c782, 0x47241b82, 0x4801004c,
		0x48219382, 0x820782d4, 0x284924eb, 0x82490100, 0x824920df, 0x824a2063, 0x984b2453, 0x824c0100, 0x824c201f, 0x824c201f, 0x824d201f, 0x824e200b,
		0x824e20b7, 0x824e2017, 0x824f209b, 0x1c50254b, 0x48500100, 0xb3820382, 0xb3825020, 0x17825020, 0x00f85024, 0x4b825101, 0x82545121, 0x827c2007,
		0x208f8203, 0x208f8251, 0x20738252, 0x208f8252, 0x20438252, 0x242b8252, 0x0100c852, 0x20438252, 0x202b8253, 0x24bf8253, 0x01008853, 0x242b8253,
		0x0100e453, 0x20f38254, 0x20578254, 0x21578254, 0x0f82a454, 0x0100d824, 0x03820455, 0x01002c23, 0x289f8256, 0x0100c057, 0x0100ec57, 0x20438258,
		0x29278259, 0x0100ac5a, 0x0100e85b, 0x0382205d, 0x5e201382, 0x5e203782, 0x5e206382, 0x5f248f82, 0x61010094, 0x62294f82, 0x62010084, 0x640100bc,
		0x82038274, 0xd0642153, 0xab820782, 0x003c6625, 0x826c6601, 0x20d78203, 0x20578266, 0x202f8267, 0x241f8268, 0x0100a069, 0x20f7826a, 0x2453826c,
		0x0100386d, 0x2013826e, 0x242f826f, 0x01005870, 0x207b8270, 0x20078272, 0x20df8273, 0x20078274, 0x20038275, 0x204f8276, 0x246f8277, 0x0100d477,
		0x284b8278, 0x0100b879, 0x01004c7a, 0x28f7827b, 0x0100407c, 0x0100447d, 0x24e7827e, 0x0100cc7e, 0x205b827f, 0x20278280, 0x200b8281, 0x20ff8282,
		0x24d38282, 0x01002483, 0x28178283, 0x0100f483, 0x0100b484, 0x20a78285, 0x203b8286, 0x25938286, 0x0100f086, 0x03823487, 0x87202782, 0x88249382,
		0x8901008c, 0x89203782, 0x89207782, 0x8a200b82, 0x8a20ef82, 0x8b25ef82, 0x8d0100e8, 0x20038250, 0x230382a8, 0x8e0100dc, 0x8f20d782, 0x8f20df82,
		0x9020b782, 0x90255382, 0x910100e4, 0x82038210, 0x8291208f, 0x829120a3, 0x82912027, 0xc89125a7, 0x14920100, 0x8f820382, 0x37829220, 0xdf829320,
		0xf3829520, 0x7b829520, 0x0b839520, 0x96207382, 0x9620ff82, 0x96204382, 0x9620e382, 0x9724bb82, 0x97010018, 0x97208382, 0x97282782, 0x98010048,
		0x99010030, 0x9920a382, 0x9920e782, 0x9a205b82, 0x9a200f82, 0x9b249b82, 0x9b010004, 0x9c20d382, 0x9d243f82, 0x9e010060, 0x9f25c382, 0xa0010080,
		0x82038294, 0xe0a12413, 0x82a20100, 0x2ca3241f, 0x82a30100, 0xd8a32487, 0x82a50100, 0x1ca625a3, 0xaca60100, 0x6b820382, 0xb782a620, 0x0084a725,
		0x8274a801, 0x201f8203, 0x20e782a8, 0x206b82a9, 0x256b82a9, 0x010054a9, 0x0382a0a9, 0x0100b023, 0x209b82aa, 0x202f82aa, 0x207b82ab, 0x20ab82ab,
		0x244782ac, 0x010088ac, 0x202382ad, 0x200b82ae, 0x201b82ae, 0x207782af, 0x249782b0, 0x01007cb1, 0x207f82b1, 0x201382b1, 0x20f382b2, 0x20a782b3,
		0x207f82b3, 0x205f82b3, 0x205f82b3, 0x207f82b4, 0x209382b4, 0x200782b5, 0x250f82b5, 0x0100f8b5, 0x038220b6, 0xb621eb82, 0x23078270, 0xb80100d0,
		0xb9206782, 0xba20ff82, 0xbb205b82, 0xbc20f382, 0xbd204b82, 0xbe285782, 0xbf010024, 0xc0010028, 0xc1240782, 0xc2010008, 0xc3204382, 0xc420fb82,
		0xc4207b82, 0xc5204b82, 0xc5241b82, 0xc501009c, 0xc6205382, 0xc7200f82, 0xc9204b82, 0xca295b82, 0xcc010064, 0xce010080, 0x82038218, 0x82cf2013,
		0x3cd02433, 0x82d10100, 0x82d12047, 0x82d2202b, 0x82d3205f, 0x82d420bb, 0x82d42013, 0x82d520ef, 0x82d52017, 0x00d62853, 0xf4d60100, 0x82d70100,
		0x5cd924ff, 0x82da0100, 0x82da2053, 0x82db202f, 0x82db207b, 0xbcdb2d43, 0xccdb0100, 0x68dc0100, 0x0cdd0100, 0xb4230382, 0x82de0100, 0x82df2017,
		0x82df200b, 0xecdf24af, 0x82e00100, 0x82e12047, 0x82e12097, 0x82e22063, 0x04e32827, 0x14e30100, 0x82e40100, 0x6ce52493, 0x82e60100, 0x82e82053,
		0x82e8202f, 0x4ce828cb, 0x74e80100, 0x82e90100, 0x82ea203b, 0x38eb242b, 0x82eb0100, 0x82ec207f, 0x82ed200f, 0xa0ed2573, 0x2cee0100, 0xd0230382,
		0x82ef0100, 0xa8f0251f, 0xe0f10100, 0xf0230382, 0x82f20100, 0x44f2213f, 0x78200782, 0x17820382, 0x82b8f221, 0x82c82007, 0x25af8203, 0x010020f3,
		0x038230f3, 0x03824020, 0xf3205f82, 0xf3241f82, 0xf40100dc, 0xf4207782, 0xf4201382, 0xf4211382, 0x820f8284, 0xc0f421ab, 0x93820782, 0x4f82f520,
		0x8f82f520, 0x0080f528, 0x00b0f501, 0x3382f601, 0x0088f724, 0xf382f701, 0xd782f720, 0x5382f820, 0x0054f824, 0x1f82f801, 0x1b82f820, 0x4f82f820,
		0x4f82f920, 0x4f82f920, 0x0070f925, 0x82a4f901, 0x20f38203, 0x20fb82fa, 0x205f82fa, 0x312382fa, 0x0100d8fa, 0x0100f0fb, 0x010018fc, 0x0100acfd,
		0x038290fe, 0xff254b82, 0x000200f8, 0x24038244, 0x01020054, 0x24038270, 0x02020080, 0x20038218, 0x20038228, 0x240382a0, 0x030200b0, 0x2c0382ec,
		0x040200fc, 0x050200b8, 0x0602004c, 0x24038240, 0x070200cc, 0x20038238, 0x24038248, 0x08020058, 0x2303823c, 0x090200e4, 0x09203782, 0x09201782,
		0x09201782, 0x0a203782, 0x0b243f82, 0x0c0200c0, 0x0d240782, 0x0e0200f0, 0x0f2c6382, 0x100200bc, 0x110200a8, 0x120200b4, 0x13242782, 0x13020084,
		0x13202b82, 0x14256382, 0x150200f8, 0x82038208, 0x90162483, 0x82160200, 0x82162083, 0x8217203b, 0x8218202b, 0xdc19240b, 0x821a0200, 0x821a206f,
		0x821b2007, 0xf41b246f, 0x821c0200, 0xd81d255f, 0x001e0200, 0x37820382, 0x9f821e20, 0x82681e21, 0x829c200b, 0x20378203, 0x20ab821e, 0x201b821f,
		0x259b821f, 0x0200501f, 0x0382781f, 0x1f214b82, 0x820782c8, 0x82202073, 0x602024af, 0x82200200, 0x8220206f, 0x822020e3, 0x822120a7, 0x82212047,
		0x8021252b, 0x0c220200, 0x23820382, 0x82642221, 0x82982007, 0x204f8203, 0x25378222, 0x02002c23, 0x03825c23, 0x23203782, 0x23243782, 0x240200e0,
		0x24202b82, 0x24202b82, 0x24202b82, 0x24201782, 0x2425eb82, 0x250200e8, 0x20038210, 0x2003823c, 0x8203826c, 0xd425257b, 0x04260200, 0x43820382,
		0x82542621, 0x21678207, 0x0782ac26, 0x2720c782, 0x27241782, 0x27020030, 0x2721e782, 0x8207828c, 0x822720df, 0x242824e7, 0x82280200, 0x82282013,
		0x82282013, 0xdc2825d7, 0x08290200, 0x34200382, 0xbf820382, 0x17822920, 0x87822920, 0x00e42924, 0x6f822a02, 0x6f822a20, 0x82702a21, 0x82a4200b,
		0x20578203, 0x259b822b, 0x0200402b, 0x0382742b, 0x03829c20, 0x0382c420, 0x2c25eb82, 0x2c02001c, 0x82038248, 0x822c2017, 0xcc2c219b, 0x6f820b82,
		0x17822d20, 0x004c2d25, 0x827c2d02, 0x209b8203, 0x206f822d, 0x209b822e, 0x20b3822e, 0x2587822e, 0x0200842e, 0x0382b02e, 0x2f201782, 0x2f201782,
		0x2f241782, 0x2f02005c, 0x2f208782, 0x2f24f782, 0x300200ec, 0x30204382, 0x30204382, 0x30205b82, 0x30205b82, 0x30245b82, 0x310200f8, 0x3120cb82,
		0x31201782, 0x3120f782, 0x3125cb82, 0x320200e8, 0x82038218, 0x82322013, 0xa8322113, 0xd0200b82, 0xfc240382, 0x28330200, 0x54200382, 0x17820382,
		0x87823320, 0xcb823320, 0x6f823420, 0x6f823420, 0x87823420, 0x17823420, 0x2f823420, 0x2f823420, 0x2f823420, 0x2f823520, 0x00503525, 0x82783502,
		0x21738203, 0x0782c835, 0x3620e782, 0x36255f82, 0x36020044, 0x82038270, 0x82362017, 0x0037252f, 0x30370200, 0x60200382, 0x90200382, 0xb8200382,
		0xe0240382, 0x0c380200, 0x38200382, 0x64200382, 0x17820382, 0xcf823820, 0xa3823820, 0x43823920, 0x00483924, 0x5b823902, 0x73823920, 0x8b823920,
		0x00083a24, 0x2b823a02, 0x82683a21, 0x218b8207, 0x0782983a, 0x0382c420, 0x3b207382, 0x3b20ff82, 0x3b202f82, 0x3b20ff82, 0x3b207382, 0x3b20ff82,
		0x3c20ff82, 0x3c20a382, 0x3c24bb82, 0x3c020088, 0x3c207382, 0x3d205b82, 0x3d245b82, 0x3d020040, 0x3d214782, 0x20078294, 0x230382c0, 0x3e0200ec,
		0x3e201782, 0x3e20b782, 0x3e21b782, 0x820f829c, 0x823e20cf, 0x823f2043, 0x823f205b, 0x823f205b, 0x823f2017, 0x823f2017, 0xf43f2417, 0x82400200,
		0x82402017, 0x8241202f, 0x8241201b, 0x82412073, 0x8241205b, 0x5442292f, 0xfc420200, 0x2c430200, 0x0b820382, 0x82844321, 0x82b02007, 0x20ef8203,
		0x24c38244, 0x02003044, 0x20938244, 0x24c38244, 0x02002045, 0x243b8245, 0x02002446, 0x20878246, 0x20878246, 0x20878247, 0x25378247, 0x02009047,
		0x0382bc47, 0x48205382, 0x48251f82, 0x48020050, 0x82038278, 0x8249202f, 0x8249207b, 0x344a25ff, 0x5c4a0200, 0x63820382, 0x2b824a20, 0x97824a20,
		0x53824b20, 0x004c4b25, 0x82744b02, 0x82ac2003, 0x00d82403, 0x82044c02, 0x208f8203, 0x21af824c, 0x0b826c4c, 0x4d245382, 0x4d020088, 0x4d207382,
		0x4e257382, 0x4e020010, 0x2003823c, 0x82038268, 0x824e2057, 0x824e2017, 0x004f2837, 0x284f0200, 0x82500200, 0x8250205f, 0x8251205f, 0x40512527,
		0x70510200, 0xa4200382, 0x23820382, 0x000c5224, 0x13825202, 0x6f825220, 0x82a85221, 0x2013820b, 0x20e78253, 0x204f8253, 0x20278253, 0x20278253,
		0x20138253, 0x20278254, 0x20278254, 0x20138254, 0x24c38254, 0x0200d454, 0x20278255, 0x20278255, 0x20138255, 0x20278255, 0x24278255, 0x0200fc55,
		0x20c38256, 0x28ab8256, 0x02003057, 0x0200b058, 0x24078261, 0x0200e061, 0x20c78262, 0x21f38262, 0x0b826462, 0x03829420, 0x62259382, 0x630200e4,
		0x2003821c, 0x20038254, 0x2303828c, 0x640200c4, 0x6420a782, 0x6421e782, 0x820b82c8, 0x486524eb, 0x82650200, 0x826520d7, 0x8266202b, 0x826620cf,
		0x826620ab, 0x826720e3, 0x4c67244f, 0x82670200, 0x826820df, 0x8268209f, 0x82682087, 0x38692597, 0x88690200, 0x8f820382, 0x0b826a20, 0x0b826a20,
		0x0b826a20, 0x00146b25, 0x82606b02, 0x20938203, 0x20a7826b, 0x20a3826c, 0x2073826c, 0x201b826c, 0x2083826d, 0x2497826d, 0x0200906d, 0x246b826f,
		0x02005873, 0x20638276, 0x08bb8277, 0x009c7731, 0x00320002, 0x02c20100, 0x000300ee, 0x401b0007, 0x0903040b, 0x05080007, 0x44000401, 0x2fcd3f00,
		0xd61001cd, 0xcdde10cd, 0x11333031, 0x82271121, 0x32810803, 0xfe329001, 0xfdee02d4, 0x8a023212, 0x000076fd, 0xb5000200, 0x3b01f4ff, 0x0d006b02,
		0x23001900, 0x91001140, 0x94170b0b, 0x1a1b1111, 0x0e9a1406, 0x00590c5c, 0xcefd3f3f, 0x39121101, 0x2f33ed2f, 0x013031ed, 0x07020e14, 0x35032e23,
		0x22033335, 0x36343526, 0x15163233, 0x25010614, 0x03060502, 0x05060339, 0x1b2d5902, 0x1c1b2828, 0xc3012727, 0x37383e25, 0x38371e1e, 0xfda8253e,
		0x1f1f2589, 0x82038325, 0x3d778276, 0x01ae0181, 0x00a70273, 0x00130009, 0x130ab715, 0x040f0900, 0x2f000013, 0x0132cd32, 0xb583dd2f, 0x56821320,
		0x26230723, 0x88698226, 0x0ace3509, 0x0a072a08, 0x2a070af2, 0xa7020a08, 0x2f712c2d, 0x2c2d712f, 0x00200787, 0x1b245782, 0xd9010000, 0x1b3dcf82,
		0xaf001f00, 0x0a0d5a40, 0x0e050609, 0x0f910e05, 0x031e1d10, 0x0f040f04, 0x18171412, 0x0874821b, 0x1c1f0231, 0x12011211, 0x16131391, 0x9100211a,
		0x05910401, 0x20070b05, 0x59125913, 0x1c1d590f, 0x0d970a17, 0x0d101114, 0x0602031b, 0x1e1f0997, 0x820d0918, 0x0e052c01, 0x04600559, 0x00600160,
		0x833f0060, 0x39122d00, 0x112f2f39, 0x10333333, 0x323232ed, 0x1a820888, 0xc610012a, 0xfd2f3232, 0xce10edde, 0x7d220783, 0x0082c487, 0x05841020,
		0x10180124, 0x108510ce, 0xed200a82, 0x31260a86, 0x37232130, 0x03820723, 0x37333523, 0x23038223, 0x37330733, 0x15260382, 0x15330723, 0x05822723,
		0x4b41012c, 0x4b1f6f1f, 0x1e4d401f, 0x0782796b, 0x4b1e6f33, 0x1f4d401e, 0x6e20796c, 0xa3a36e1f, 0x429f43a3, 0x080082a4, 0x439f423f, 0x00009fe2,
		0xff360001, 0x02bf019f, 0x003500b5, 0x311140b3, 0x4d001218, 0x110f2031, 0x28314c00, 0x2b4d000e, 0xb4e8ffb8, 0x4c000c0b, 0xd8ffb82a, 0x000a09b4,
		0xffb8274c, 0x0010b3e0, 0x2907824d, 0x0e0db4e8, 0xb8264c00, 0x1083f0ff, 0x2a822220, 0x0f3c4026, 0x28114d00, 0x0d212783, 0x08248220, 0x0a200936,
		0x2c154d00, 0x2f2f128b, 0x1818290f, 0x37298c05, 0x8c1f3232, 0x2f0a360f, 0x3315241c, 0x2c8f0033, 0x362e2e2f, 0x8f1c1919, 0x00131512, 0xed32dd2f,
		0x33112f32, 0x392b0786, 0x01391211, 0x33edd610, 0x82de102f, 0x250d8204, 0x32ed332f, 0x4c593031, 0x08088208, 0x3e3237ed, 0x2e343502, 0x032e2702,
		0x37363435, 0x16153335, 0x26071716, 0x06222326, 0x021e1415, 0x15031e17, 0x15070614, 0x26263523, 0x16163727, 0x1c3124e9, 0x3429180c, 0x29351b1c,
		0x4a484c1a, 0x11144328, 0x36314015, 0x2b201139, 0x3040221b, 0x4a514e1d, 0x16134e3f, 0x0b554a1b, 0x19111d15, 0x0a151b23, 0x3123180a, 0x0b504024,
		0x0f026467, 0x11084608, 0x1c152628, 0x0d0a1216, 0x2738281d, 0x730a523b, 0x0b180270, 0x00170d45, 0x12000500, 0xe201f3ff, 0x03007802, 0x1b000f00,
		0x33002700, 0x48407700, 0x1cf01ce0, 0x2eef1c02, 0x2e022eff, 0x28f028e0, 0x00222802, 0x8d020102, 0x03140003, 0x22030300, 0xff0aef35, 0xe00a020a,
		0x0210f010, 0xff16ef10, 0x04160216, 0x34040101, 0x25311f2b, 0x130d1957, 0x03025807, 0x55010056, 0x82333f00, 0xdccd2301, 0x03823fcd, 0xc6100136,
		0xdd102f32, 0xcd5dde5d, 0x32ce105d, 0x872b872f, 0x1801c47d, 0x31261186, 0x01233330, 0x77430533, 0x22232407, 0x41343726, 0x16240512, 0x13363233,
		0x5f2a1796, 0x467b0146, 0x333a38fe, 0x03833a33, 0x17189c2a, 0x17191917, 0x395b1817, 0x39251185, 0x1717199c, 0x2e158318, 0x4c8e6b02, 0x4c4c4f4f,
		0x2d4c5050, 0x822d3a3a, 0xdefe2103, 0x14821084, 0x22081086, 0x03000000, 0xf8ff1f00, 0x7902d901, 0x36002b00, 0x0c014200, 0x112041b6, 0x314c0012,
		0xb3e0ffb8, 0x824d0012, 0xb3e82207, 0x2a078411, 0x000fb3f0, 0xffb82d4d, 0x820940e8, 0x082c2508, 0x264d0008, 0x1f2c0d83, 0x4c000d09, 0x000c1820,
		0x0b10204d, 0x18260482, 0x4c000a09, 0x3482181a, 0x82301a21, 0xb8112723, 0x10b3d8ff, 0x07824d00, 0x0eb3e828, 0xb8024d00, 0x5983d0ff, 0xe8200782,
		0x07825983, 0x1f83e020, 0xf0200782, 0x01231f83, 0x83f0ffb8, 0x2207821f, 0x823c40e8, 0x37480845, 0x07282876, 0x1b2c3410, 0x760e1e04, 0x402b030a,
		0x0d0d3d04, 0x44077306, 0x1e1e763d, 0x4318762f, 0x2b1b2c40, 0x34030a10, 0x0606342b, 0x237c3a32, 0x137c3245, 0x420e0d46, 0x3f333f00, 0x12ed3fed,
		0x39392f39, 0x33333311, 0xab420383, 0x10ed2b05, 0x2f33edde, 0xed391712, 0x1a821711, 0x42ed2f21, 0xbc420db0, 0x16012a07, 0x36361716, 0x06061737,
		0x08098207, 0x27262321, 0x22230606, 0x3435022e, 0x26263736, 0x023e3435, 0x021e3233, 0x07061415, 0x15060607, 0x83161614, 0x08c44116, 0x8f083982,
		0x25111001, 0x030c0813, 0x11170645, 0x57112a17, 0x4f201511, 0x2a3c262b, 0x1a353117, 0x372a1920, 0x26321a1d, 0x42413c17, 0x3a281d1d, 0x47211c44,
		0x1a192754, 0x301d122d, 0x141b0128, 0x421c1729, 0x5b3a0928, 0x26442025, 0x23282023, 0x203a2c19, 0x2329602f, 0x3a272648, 0x21101325, 0x612e1f30,
		0x441a2429, 0x0d332720, 0x4d2d281d, 0x292424f9, 0x26321d29, 0x0100441e, 0x9c01ce00, 0xa7022501, 0x14000d00, 0x0c9101b7, 0x070e0f0c, 0xcd2f000d,
		0x2305fd45, 0x15013031, 0x0808fb45, 0x0325012b, 0x33040605, 0x03050604, 0x162da702, 0x173b3d39, 0x3a3d3b17, 0x00002c16, 0x71000100, 0x820159ff,
		0x1000bd02, 0x00b97f00, 0x05114207, 0xffb80729, 0x0011b3f0, 0x82b8064d, 0x2307870f, 0x014d000e, 0x82063142, 0x83e82007, 0x2107821f, 0x1782b3f0,
		0x2f820e20, 0x0d094026, 0x180a4d00, 0x052a0482, 0x40e8ffb8, 0x4d000f15, 0x04822002, 0x09090f3e, 0x0c030800, 0x5a0f0011, 0x2f000908, 0x01333f33,
		0xceddd610, 0x33113232, 0x2b003031, 0x01200082, 0x21068b41, 0x2b440601, 0x07270805, 0x34352626, 0x01173736, 0x17625d80, 0x2d32492f, 0x72727173,
		0x4881022c, 0x64386fbc, 0x3c2b565c, 0x7c7de155, 0x823c53e2, 0x25bf8abe, 0xb9580012, 0xb7820f00, 0x86820d20, 0x2f208f83, 0x07210882, 0x26bd8318,
		0x4d001218, 0x820f1005, 0x26048390, 0x12111001, 0x83074c00, 0x09112314, 0x9b821209, 0x11001429, 0x005a0908, 0x8d2f333f, 0x3598879b, 0x35363617,
		0x27022e34, 0x15161637, 0x07020e14, 0x635d7327, 0x98843017, 0x55391d25, 0x8b6b2c39, 0x783e2499, 0x8629636f, 0x3930089b, 0xbb01fa00, 0x2c006b02,
		0x17403300, 0x04042029, 0x0e1f1620, 0x2e1f1f0e, 0x1609292d, 0x05171728, 0x00591f0d, 0x3932cc3f, 0x32cd332f, 0x12110132, 0x2f240882, 0x32cdcc10,
		0x31340482, 0x16160130, 0x27071717, 0x06272626, 0x27070706, 0x37363637, 0x27220b82, 0x17821737, 0x82086947, 0x375b0814, 0x06060717, 0x3a1b1f01,
		0x05460414, 0x100f2215, 0x45051722, 0x1b381605, 0x07234e25, 0x4723071b, 0x560d0820, 0x4620080d, 0x061a0723, 0xa1014d24, 0x051f3719, 0x471e0633,
		0x1e472121, 0x1f063205, 0x0b051936, 0x0352020c, 0x2412220e, 0x0707264e, 0x13244e26, 0x52030d21, 0x410c0b02, 0x2e3c0563, 0xc7012b00, 0x0b00e201,
		0x0f402400, 0x0b070406, 0x0d0a0a01, 0x0102040c, 0x000a0709, 0xdd22bb82, 0xbc8533cd, 0xddcd4108, 0x3031cd32, 0x33353313, 0x23153315, 0x23352315,
		0xa948a82e, 0x01a848a9, 0x46b8b82a, 0x0100b9b9, 0x70ff9500, 0x8b005f01, 0x1f001300, 0x0e050e40, 0x08080094, 0x13001415, 0x5c059a0b, 0xdced3f00,
		0x2705c042, 0x3139edce, 0x033e1730, 0xb548f082, 0x0e240807, 0x12950702, 0x07181e23, 0x1d2d1d20, 0x2f172625, 0x044f3046, 0x14170f08, 0x28152b03,
		0x1d263529, 0x0627373f, 0x8c345f82, 0x6801d700, 0x03002501, 0x02b30d00, 0x00030003, 0x2f01cd2f, 0x15279484, 0xdcdc8c23, 0x854e2501, 0xffb126d3,
		0x004401f4, 0x27d3828d, 0x9400b610, 0x039a0906, 0x01287f83, 0x3031ed2f, 0x23061425, 0x31072e49, 0x21284401, 0x22282822, 0x1e402821, 0x1f1e2e2e,
		0x63822e2e, 0x5bff4526, 0xbb02af01, 0x23235c82, 0x82021140, 0x018d2706, 0x01011402, 0x02820302, 0x2f2c1e82, 0x01332f33, 0x10872f2f, 0xc47d872b,
		0x232ac782, 0x559a3301, 0xa5531701, 0x7b836003, 0x2e000328, 0xc601f3ff, 0x7b827902, 0x2b001733, 0x29b6f600, 0x000e0d10, 0xffb8254c, 0x000eb3e8,
		0x2507824d, 0x000db3f0, 0x0f861f4d, 0xf0220782, 0x10821440, 0x26841b20, 0x1018162a, 0x20164d00, 0x144d000f, 0xb4252082, 0x4c00100f, 0x06fb4710,
		0xd0220782, 0x19820e40, 0x23830e20, 0x82100e21, 0x83082009, 0x0022221a, 0x2007844d, 0x0807841e, 0x1bb4e832, 0x004c001d, 0x40c0ffb8, 0x001c1b27,
		0x0100904c, 0x00800050, 0x00c00090, 0x00f000e0, 0x09400006, 0x8f00480c, 0xcf069f06, 0x40060306, 0x06481e1b, 0x20202b83, 0x2d081582, 0x18220606,
		0x222d128c, 0x3f2c0c8c, 0xa0030103, 0x09090109, 0x158f270f, 0x0f8f1d57, 0xed3f0058, 0x3911ed3f, 0x5dcd5d2f, 0xedd61001, 0x0c83de10, 0x5d2b2b27,
		0x715d2bcd, 0x117d452b, 0x65410120, 0x0b22470a, 0x34252d08, 0x2223022e, 0x1415020e, 0x3233021e, 0x3401023e, 0x201a191f, 0x1f191a20, 0x616bfafe,
		0x626a6a62, 0x44016b61, 0x222e1c0c, 0x0c1c2e22, 0x012d0787, 0x26261a41, 0x28281a1a, 0xa7a79c25, 0x2703839c, 0x28445b33, 0x335b4428, 0x00240786,
		0x4b000100, 0xb6300482, 0x10006b02, 0x26404200, 0x000c1802, 0x1228014d, 0x22080482, 0x4d000d20, 0x0a090000, 0x038b0506, 0x11120a0a, 0x088e0a05,
		0x10100055, 0x0056030b, 0x2f33333f, 0x43ed3fcd, 0xfd25069d, 0x32cd10cd, 0x08cc842f, 0x3636132d, 0x33113337, 0x33352115, 0x07030e11, 0x2960334b,
		0xb3fe753a, 0x251f0b86, 0xeb011328, 0xfd2f3d14, 0x014646db, 0x14150ab2, 0x82000612, 0x01220800, 0x00003900, 0x7902bd01, 0x90002c00, 0xff2c00b9,
		0x0c0bb4f0, 0xb82c4c00, 0x0b40e0ff, 0x4c000a09, 0x05831827, 0x0f832220, 0x96820f20, 0x11181d2f, 0x164c0012, 0x4d000f08, 0xe8ffb805, 0x200782b3,
		0x06804503, 0xe8250782, 0x4d0011b3, 0x06484702, 0xe8220782, 0x10821b40, 0x008c1a3a, 0x2e000b0b, 0x2d0f8c0a, 0x24102525, 0x2a8f1f24, 0x0d8e0a58,
		0xed3f0055, 0x2f2cc382, 0x2f332f01, 0x10edd610, 0x102f32ce, 0x340d1047, 0x020e1401, 0x15030e07, 0x26211521, 0x3e343534, 0x033e3702, 0x06894135,
		0x27075708, 0x3233033e, 0x19a40116, 0x0f1b3429, 0x01182428, 0x0189fe1d, 0x1b372c1c, 0x131f2916, 0x16261d11, 0x18212b1a, 0x20082906, 0x6120382d,
		0x20cd015d, 0x1b383a3c, 0x2a2c2a0f, 0x0b05460f, 0x40482a05, 0x2a161b39, 0x1b182d2a, 0x0e0c1926, 0x3a061314, 0x10171a09, 0x00820059, 0x3b00012f,
		0xba01f3ff, 0x32007902, 0x2eb5f400, 0x24f68228, 0xd8ffb827, 0x200785b3, 0x82e383d0, 0x4ae8200f, 0xd82507f2, 0x4d0008b3, 0x28208224, 0x001211b4,
		0xffb8214c, 0x200884e0, 0x066f481d, 0xe0200782, 0x07833283, 0x0a08b428, 0xb81c4c00, 0x4b83e8ff, 0x18840782, 0xffb81524, 0x648340f0, 0x0f180e28,
		0x054c0010, 0x19461018, 0x10052606, 0x014d000d, 0x250e8220, 0x0011102d, 0x0483154d, 0x55822220, 0x82294021, 0x222b080d, 0x1f1f8c10, 0x34258c03,
		0x09091717, 0x0922332f, 0x1a0a0a8e, 0x8f003030, 0x166f572a, 0x1602167f, 0x1a8f1316, 0xed3f0058, 0x835d2f32, 0x39112a04, 0x0139ed2f, 0x2f32c610,
		0x05324b32, 0x2b32ed24, 0x5e643031, 0x0b364b07, 0x372b2b39, 0x34353632, 0x2323022e, 0x3e323335, 0x26343502, 0x07062223, 0x48363627, 0x16270776,
		0x0e141516, 0x46222302, 0xba08057e, 0x1c434fd4, 0x15213c2e, 0x272f161d, 0x2b2a3f18, 0x1520143c, 0x46313455, 0x2833162d, 0x371b4630, 0x31173c57,
		0x1007212a, 0x3f3c4610, 0x1c2e2235, 0x1709430c, 0x2b331f28, 0x0f3f0d19, 0x3b2c1821, 0x12443123, 0x2843510e, 0x071c3245, 0x47030b0b, 0x00001608,
		0x24000200, 0xd2010000, 0x0e006b02, 0x6d001500, 0x0fc24240, 0x0105d301, 0x0105b203, 0x0105a202, 0xbc0114dd, 0x0214cc14, 0x050114ad, 0x8d140f14,
		0x00140500, 0x0d0f0500, 0x070a8b15, 0x16001708, 0x8e140007, 0x0c0d0d0a, 0xd00fb055, 0x0fa3020f, 0x56050f01, 0x5d333f00, 0x2f333f5d, 0x3232ed33,
		0x10c61001, 0x8232d5de, 0x05104509, 0x825d0121, 0x5d5f2d00, 0x30315d5f, 0x3e375d00, 0x11333703, 0x08052b46, 0x0e01212b, 0x24330703, 0x544a3b11,
		0x4949502b, 0x01ebfe50, 0x34371b15, 0xd6c5122d, 0x6b6f6828, 0x4477fe2b, 0x6b019e9e, 0x504d461d, 0x27b68227, 0x42000100, 0xba01f3ff, 0x2735b782,
		0x0c40b000, 0x000d2018, 0x11280c4d, 0x064c0012, 0xb3e8ffb8, 0x06bf4810, 0x07840f20, 0x0eb3f023, 0x05464300, 0x05241782, 0xb3e0ffb8, 0x20055643,
		0x201788d0, 0x241f840a, 0x0009b3f0, 0x0aaf4a4d, 0x2783e820, 0x40210f83, 0x08408224, 0x1622222b, 0x2329038c, 0x201b8b00, 0x1b100d0d, 0x1b281b01,
		0x1100008f, 0x56208e23, 0x8f110e0e, 0x3f005708, 0x3f2f32ed, 0x2f3912ed, 0x2af782ed, 0x322f325d, 0x1032ed10, 0x4433edde, 0xfb410533, 0x41132009,
		0xfc410dd8, 0x2e670805, 0x033e2302, 0x23152137, 0x86ba030e, 0x55371a7a, 0x2a2f183a, 0x10100720, 0x36283343, 0x39170f21, 0x07064b63, 0x01020305,
		0x0301e22a, 0x7c010404, 0x295b6c05, 0x071c3246, 0x47040b0a, 0x1f121608, 0x35221628, 0x4d2c1324, 0x46284849, 0x2e322d0e, 0x36000200, 0xc101f3ff,
		0x1a006e02, 0xc9002d00, 0xff2400b9, 0x821340f0, 0x181a27c9, 0x194d0008, 0x04821020, 0x000f282d, 0xffb8164d, 0x100fb4d8, 0x41154c00, 0x0782063a,
		0xfa83f020, 0x2a820f84, 0x17831120, 0xe24b0b20, 0x84092006, 0xb3d82107, 0x10201782, 0x8206ad43, 0xb3c02407, 0x824d0011, 0xb3e82207, 0x0667460c,
		0x000e0d2d, 0xffb8044c, 0x0e2640e0, 0x83034d00, 0x8c2b3e6c, 0x13060613, 0x8c210b2f, 0x00010010, 0x8f1b1e2e, 0x050e0e0b, 0x57188f26, 0x56058f06,
		0x06414600, 0x32ed3328, 0x5dd61001, 0xa84432ed, 0x05424112, 0x3e343728, 0x0e173702, 0x29430703, 0x020e2a07, 0x37262223, 0x06070622, 0x07384614,
		0x34354f08, 0x5b313626, 0x35075282, 0x0c2e4457, 0x34203918, 0x16142c49, 0x6732482e, 0x3520c566, 0x1b0b011b, 0x281e242e, 0xf8370b1a, 0x325e8b5a,
		0x15014601, 0x0b364a2f, 0x4635200e, 0x3b472225, 0x0cbb8a25, 0x0b130a0c, 0x1f354527, 0x152f2619, 0x7342403d, 0x3f210805, 0xc7010000, 0x0e006b02,
		0x12402500, 0x00008c0e, 0x098c0506, 0x090f0610, 0x56078e05, 0x3f005500, 0x31bc833f, 0xedde10c6, 0xed2f3912, 0x3e333031, 0x35213703, 0xab821521,
		0x29059b3a, 0xfe22463a, 0x1e8801d4, 0x062e3f46, 0x7f959f47, 0x23454829, 0x53a79376, 0x35051748, 0x01f3ff33, 0x007902c1, 0x002b001b, 0xb520013b,
		0x000e183a, 0xac42384d, 0x21078206, 0x0f82b3e8, 0x0f823320, 0x11284032, 0x2f4c0012, 0x4d001218, 0x0011282f, 0x0f30284d, 0x18210482, 0x2504820a,
		0x4d000928, 0x18822823, 0x82302321, 0x451f2018, 0x1b280722, 0xb3e8ffb8, 0x194d000d, 0x27820783, 0x18821520, 0x0785b320, 0x82b3f021, 0x270f8332,
		0x00083340, 0x0a200f4d, 0x08240483, 0x200c4d00, 0x0c272f82, 0x000a0938, 0x8308094c, 0x1806256f, 0x064d000b, 0x06221f83, 0x09830918, 0x01202482,
		0xb4204f82, 0x08822283, 0x2c40e022, 0x28081182, 0x260d290b, 0x1a39008c, 0x8c2c0036, 0x3d001717, 0x0d0d8c36, 0x3c088c1c, 0x1239391a, 0x29290b21,
		0x128f3103, 0x038f2158, 0x06ed4157, 0x11331132, 0x33113912, 0xedd61001, 0x10ed2f33, 0xed2f32ce, 0x39251082, 0x3911ed10, 0x11354839, 0x23094143,
		0x14252b2b, 0x4d09ab4d, 0x16210baa, 0x063a4805, 0x26343526, 0x13060627, 0x08085048, 0x3617166a, 0x63c10136, 0x2d4c3a65, 0x55283a13, 0x2b45301a,
		0x142c4732, 0xfe672336, 0x2e1c0cc2, 0x1d2d1f21, 0x2848520e, 0x190ce02c, 0x271d1c28, 0x443b0b1a, 0x4ea12d26, 0x3c311f60, 0x1952351d, 0x3e226330,
		0x2f1e1c2e, 0x4d351b39, 0x10733117, 0x11131e23, 0x3912241d, 0x4216103d, 0x210d0f01, 0x1b12131b, 0x47291021, 0x003c1610, 0x02310082, 0xfeff3300,
		0x7902bf01, 0x29001600, 0x00b9ad00, 0x05954424, 0xffb8242a, 0x0f0e40f0, 0x20204d00, 0x10250483, 0x164d000e, 0x231a82b8, 0x154d0008, 0x27097d43,
		0x0a2840e8, 0x18114d00, 0x08250484, 0x300c4d00, 0x21048212, 0x04821138, 0x820c1021, 0x0a182604, 0x0c4c000b, 0x05ad4410, 0x5d4fd820, 0x40e02206,
		0x3952821e, 0x008c1d07, 0x0f8c272b, 0x2a0f0404, 0x078f171a, 0x22030a0a, 0x0458148f, 0x0748038f, 0x39112e05, 0x32ed332f, 0x32c61001, 0x10ed102f,
		0x0fcb51de, 0x00822b20, 0x06140127, 0x36322707, 0x070d4f37, 0x33023e25, 0x82071632, 0x34362210, 0x094e4135, 0xb4bf012c, 0x897003b5, 0x203a1816,
		0x5b434835, 0x68662905, 0x1a3720c6, 0x2f1b0b01, 0x08055b43, 0xb9730137, 0x594601bb, 0x1f0d0b6d, 0x22264435, 0x8c263a47, 0x0a0b0cb7, 0x46270a12,
		0x25191f34, 0x3f3d152e, 0xff000000, 0xffb100ff, 0x014401f4, 0x002602d0, 0x01000011, 0x32058407, 0x40100043, 0x1100010b, 0x5000050c, 0x4f0e0801,
		0x84342b2b, 0xff7d242b, 0x82470170, 0x0036252b, 0x0000e80f, 0x01352b87, 0x37003100, 0xc601ca01, 0x6c000600, 0x18050b40, 0x024d0012, 0x3b048228,
		0xd0ffb800, 0x12111240, 0x10064c00, 0xbb4d0011, 0x08040105, 0x034d0013, 0xb6f0ffb8, 0xb4230782, 0x82010102, 0x4032080a, 0x4d001116, 0x00080106,
		0x05060703, 0x021f0100, 0x0202026f, 0x00000304, 0x32322f19, 0xcd185ddd, 0x18dd1019, 0xc61001cd, 0x32ce1032, 0x2b003031, 0x02822b71, 0x2b2b013a,
		0x0705372b, 0x17253525, 0x173d018d, 0x82017efe, 0x4583ff17, 0x45a447a4, 0x28050342, 0x0184002e, 0x008901c7, 0x3ca78203, 0x06134026, 0x00070901,
		0x03070408, 0xe00100a0, 0x003f0100, 0x2f000001, 0xcd715d5d, 0x245a89de, 0x21152137, 0x24038211, 0xfe99012e, 0x24038367, 0x050147cb, 0x89298247,
		0x407024df, 0x8230060b, 0x380621da, 0x0520b482, 0x8206e548, 0xb3d82107, 0x04200f82, 0x2b28cd83, 0xb34d0013, 0x10010104, 0xbb240782, 0x10000101,
		0x00222d82, 0xe2821130, 0x00080331, 0x1f050705, 0x02046f04, 0x01000604, 0x82060203, 0x333321e2, 0xe182dc82, 0xe28ae782, 0xe582e082, 0xe4822b20,
		0x05371331, 0x25270515, 0x82011731, 0x01177efe, 0x8481013d, 0x828320e3, 0x000231e4, 0x01f4ff5c, 0x0079029a, 0x0028001c, 0x1a00b97c, 0x23057449,
		0xf8ffb81a, 0x19208e83, 0x8206bc4a, 0xb3f02507, 0x134d000e, 0x0c200f83, 0xf0220784, 0x07840bb3, 0x2640e826, 0x0e4d000a, 0x0e21a383, 0x37a38318,
		0x951c1595, 0x2601010d, 0x2a202094, 0x9a231c29, 0x0c0c5c1d, 0x5a109b09, 0x56055f47, 0xce2209e4, 0xc74adcfd, 0x2737220b, 0x11444934, 0x15040e23,
		0x0afd5607, 0x01b93808, 0x302c352c, 0x1d391d2f, 0x2b4c1e17, 0x0f264133, 0x22282217, 0x271c1c17, 0x281b1c27, 0x2b13d328, 0x2336363f, 0x100e2e26,
		0x1c131140, 0x1e18342b, 0x29262a2f, 0x57df1d30, 0x28240d13, 0xd40179ff, 0x2d27f382, 0xc3003c00, 0x4a3b00b9, 0x3120068a, 0x82068b41, 0x83f02007,
		0xb82c25fc, 0x1f40f0ff, 0x282bdc82, 0x4d000e20, 0x0d0c1028, 0x83224c00, 0x082221e7, 0x2226e782, 0x000c0b10, 0x9345194c, 0x2d078206, 0x0009b3e0,
		0xffb8144d, 0x0010b3f8, 0x3b83134d, 0x000b3c26, 0x1218104d, 0x30830482, 0x0c080926, 0x10094d00, 0x06201382, 0x06200983, 0x20080983, 0x0073360e,
		0x3e001e1e, 0x7316082e, 0x7c3a3d25, 0x2a7c110b, 0x037c3345, 0x00207c1b, 0xeddefd2f, 0x2a03823f, 0xfdd61001, 0xce10cdde, 0x43102f32, 0x2b2313ee,
		0x43252b2b, 0x362607ea, 0x17163233, 0x824d2634, 0x17372109, 0x21066645, 0x1a82023e, 0x14071523, 0x2307821e, 0x26353736, 0x75082382, 0x1ed40106,
		0x3c231a3e, 0x4d60192d, 0x34080f08, 0x2a3a2339, 0x4f331818, 0x082b2837, 0x6b492d35, 0x41252245, 0x66583256, 0x211205cb, 0x0b14081d, 0x2b081109,
		0x090c3f2f, 0x344b3017, 0x0101615d, 0x4b224a3f, 0x753f5476, 0x430d3558, 0x886a410e, 0x5e946747, 0xa86a772d, 0x1b272e14, 0x03f50302, 0x00004302,
		0x00090002, 0x02eb0100, 0x000f006b, 0x40e40016, 0x184d1617, 0x10102d05, 0x18164d00, 0x4c000e0d, 0x00111014, 0x82055642, 0xb8122807, 0x19b3f8ff,
		0x83114d00, 0x841a2007, 0xb4e82507, 0x4c001211, 0xf0211082, 0x05a554b3, 0x0f40f022, 0x0d2a3783, 0x4d001e10, 0x000e100b, 0x2c83084d, 0x2205b954,
		0x824040f0, 0x83012045, 0x02400852, 0x09101113, 0x78031003, 0x04140904, 0x14010904, 0x10000a10, 0x0a0f7800, 0x0a0f0f14, 0x8f041010, 0x180f010f,
		0x02011704, 0x13131479, 0x090a1003, 0x44030441, 0x0044000f, 0x333f323f, 0x1233333f, 0x30076845, 0x115dce10, 0x872f3d39, 0x872b1018, 0xc410c47d,
		0x260987c4, 0xc405c40e, 0x523031c4, 0xdd460769, 0x215d0807, 0x23072327, 0x3337033e, 0x0317031e, 0x33070606, 0x94012626, 0x5424ee25, 0x36312a11,
		0x351d661e, 0xf2112a2f, 0xc8183617, 0xa2a23517, 0xa3a29a42, 0xa2a34a4a, 0x2302429a, 0x5a58a63f, 0x000000a7, 0xff360003, 0x02c301fb, 0x001a0071,
		0x00380029, 0x7b51407a, 0x326a0132, 0x012e7901, 0x0802826a, 0x267a2645, 0x7b226b02, 0x19850222, 0x95021995, 0x16810117, 0x01139401, 0x90011385,
		0x0e14010e, 0x05020e84, 0x3015010e, 0x24101076, 0x2a3a1876, 0x0510731b, 0x15390501, 0x2a2a791b, 0x0b7c351f, 0x007c1f41, 0x553f0043, 0xed210579,
		0x06ac4939, 0x33edde28, 0x3132ed2f, 0x008c5d30, 0x2e221727, 0x3e112702, 0x05d14c03, 0x07020e2b, 0x14151616, 0x16150306, 0x08f44a16, 0x09882720,
		0x06227a08, 0x280fcc07, 0x0f0f2828, 0x10272927, 0x213b502e, 0x1321190e, 0xc5764533, 0x1f1f2902, 0x191b2c39, 0x541d3629, 0x28321941, 0x2f241618,
		0x08271a1a, 0x06030205, 0x04580204, 0x10020306, 0x162e3e26, 0x071b2429, 0x5c3c4b0e, 0xdd26015e, 0x1b0a0301, 0x2a1f232c, 0x0a440b19, 0x1b1d2616,
		0x010a1826, 0x00010002, 0x01f3ff2e, 0x007902cc, 0xb9b70020, 0xf0ff1b00, 0x4d0012b3, 0x06ad441b, 0x974f0782, 0x43162005, 0x07820685, 0x094bf020,
		0x83e02006, 0xb8152528, 0x11b3e8ff, 0x2805ab47, 0x000c0bb7, 0x0115284c, 0x8213830f, 0x20078244, 0x821b83c8, 0x40e02d07, 0x00100e0b, 0x0d18054c,
		0x014c000e, 0x2309f056, 0x1110b4e0, 0xe8391084, 0x000f1740, 0x0010104d, 0x08761822, 0x13111121, 0x20450d7c, 0x037c1d20, 0x05e44446, 0x2f32ed23,
		0x06ab4f01, 0x20080649, 0x0720425d, 0x2608ad43, 0x3233023e, 0x43071716, 0x39080aae, 0xcc013736, 0x372d4f23, 0x2927445d, 0x25355e46, 0x4218254d,
		0x2e41293a, 0x43301b19, 0x22401d27, 0x2713141a, 0x4f537a4f, 0x142a5278, 0x23264417, 0x40395c42, 0x0f1e3e5e, 0x00820013, 0x36000238, 0xcc01fbff,
		0x0e007102, 0x45001c00, 0x28180d40, 0x4c001211, 0x05831813, 0xc5830c20, 0x4d000d23, 0x21078203, 0x08821640, 0x00761631, 0x10730f1e, 0x1d070107,
		0x410a7c19, 0x42057c11, 0xb7820514, 0x10ed5d23, 0x069945de, 0x0e14012d, 0x27222302, 0x32333611, 0x4101021e, 0xb08206f5, 0x07063a08, 0x4b2bcc01,
		0x3f3e3c67, 0x673c3e3f, 0xbcfe2b4b, 0x462d1a19, 0x5f611a30, 0x010a190d, 0x4b785636, 0x58020f22, 0x784c220f, 0x1b03bafe, 0x7e415d3b, 0x00020176,
		0x00010000, 0x0804825b, 0x6b02cc25, 0x36000b00, 0x07071d40, 0x0d0a0303, 0x00730905, 0x02001000, 0x79080c00, 0x04090505, 0x09410179, 0x42440079,
		0x4f4c08a3, 0x2f322c09, 0x11333031, 0x15211521, 0x82231533, 0x015b2f05, 0xe8f7fe5b, 0x021f01e8, 0x46be466b, 0x5f8646db, 0x5f82ba20, 0x2f000928,
		0x06061940, 0x5d880b03, 0x5d830a20, 0x5d830020, 0xe84d5b83, 0x07aa4c07, 0x1127588a, 0xfe5f015b, 0x82ededf3, 0x45c12354, 0xb682e1fe, 0x2e355782,
		0xc701f3ff, 0x25007902, 0x00b9a200, 0xb4e0ff20, 0x4c001211, 0x060e4720, 0xf0220782, 0xf6530bb3, 0x42102006, 0x07820690, 0x5b421a20, 0x24078206,
		0x0011b3e0, 0x2d07824d, 0x0c0bb4e8, 0xb8124c00, 0x12b3e0ff, 0x07824d00, 0x1883c020, 0x2c080782, 0x0d2640e8, 0x074c0010, 0x4d000e18, 0x000d1007,
		0x0014144d, 0x1d270173, 0x00260a76, 0x15152200, 0x450f7c18, 0x057c2225, 0xed3f0046, 0x06aa5032, 0xd6100123, 0x13a14eed, 0x11330122, 0x240bfd49,
		0x0717021e, 0x0d664226, 0x52753808, 0x38395413, 0x2824415c, 0x22355c45, 0x06182534, 0x233f171b, 0x1a2e4126, 0x2a412c17, 0x0108201d, 0x07defe31,
		0x79522b15, 0x52784e4d, 0x0f0e0a2b, 0x17124504, 0x825d4224, 0x25422934, 0x00000408, 0x2d000100, 0x2c080482, 0x006b02c7, 0x4031000b, 0x73030b1a,
		0x060a0d02, 0x050c0773, 0x1f0a0f79, 0x0a0a020a, 0x41080007, 0x00440703, 0x333f333f, 0x5d2f3912, 0x20af83ed, 0x05b54a32, 0x2321a282, 0x27018311,
		0x01331133, 0xf6525275, 0x022b0282, 0x0195fd6b, 0x02e0fe20, 0x82fbfe6b, 0x5900215a, 0x9b200482, 0x2b365f84, 0x05081540, 0x01020b06, 0x0c060673,
		0x7907000d, 0x06014109, 0x5a820479, 0x3f32ed22, 0x2906e053, 0x1032cdfd, 0x303132cd, 0xd8531101, 0x35233605, 0x23011521, 0x78befe78, 0x02420178,
		0x4621fe25, 0x46df0146, 0x24b78246, 0x01f3ff36, 0x315782a4, 0x404a0013, 0x0f181017, 0x0a4c0010, 0x4d000e18, 0x5b82200a, 0x0b3f0a82, 0xb8054d00,
		0x1640f0ff, 0x4c001211, 0x15037312, 0x140b0000, 0x7c0f0c0c, 0x79004608, 0x53004101, 0x10230690, 0x432f32c6, 0x36080829, 0x2135132b, 0x020e1411,
		0x27262223, 0x33161637, 0x11353632, 0x1325017f, 0x3c3c4f2f, 0x13211352, 0x3f402a3f, 0xfe462502, 0x394e2c5c, 0x43102221, 0x5144200e, 0x82005601,
		0x00012300, 0x23470040, 0x16490805, 0x37406100, 0x03521e03, 0x090e0900, 0x14030878, 0x16030808, 0x78030003, 0x13141613, 0x00001613, 0x0e131808,
		0x10100073, 0x17100210, 0x13411600, 0x1003030e, 0x44104111, 0x00440908, 0x3f3f333f, 0x2f193912, 0x3f183333, 0x09324333, 0x0805b851, 0x10188749,
		0x2b08872b, 0x013031c4, 0x1e070606, 0x2e231703, 0x23112703, 0x36113311, 0xd6013736, 0x20447531, 0x153d4548, 0x413a195d, 0x52522345, 0x022d7741,
		0x4890496b, 0x6055481b, 0x4c582e32, 0xd8fe173f, 0xecfe6b02, 0x433f9243, 0x05340bc3, 0x11402000, 0x73050700, 0x02100200, 0x03060202, 0x02790541,
		0xed218982, 0x267f843f, 0x3031ce10, 0x82211525, 0xcc012a64, 0x46528ffe, 0xfd6b0246, 0x203f83db, 0x29048220, 0x006b02d4, 0xb9f9001a, 0xf2471a00,
		0xb81a2105, 0x13220782, 0x07824d00, 0x0ab3e025, 0x82184d00, 0x1a403b0f, 0x4c001c1b, 0x00100818, 0x0e08174d, 0x0d044d00, 0x010c0c01, 0x001b0803,
		0x1e82034d, 0x110fb424, 0x08824c00, 0x4e40f022, 0x01211c82, 0x08358238, 0x01013d2f, 0x0c01012c, 0x7b010001, 0x0b140c0b, 0x060b0c0b, 0x25011a36,
		0x1a0d011a, 0x0e7b1a00, 0x0e0e140d, 0x1300000d, 0x18027306, 0x024d001d, 0x385f8320, 0x001a1802, 0x01020b4d, 0x02010246, 0x130e1c05, 0xffb81973,
		0x1a1a40e0, 0x3d5c821d, 0x14190119, 0x411a0e1b, 0x01000f0c, 0x060d0d00, 0x010b4414, 0x333f0041, 0x2f33333f, 0x105b7133, 0x71322d05, 0x1032ed2b,
		0x715d32de, 0xed2b2b2b, 0x250a2b48, 0x115d5d01, 0x37488733, 0x460b8205, 0x71200509, 0x28822583, 0x3313132e, 0x23171216, 0x0327032e, 0x030e0323,
		0x08053248, 0x4d60fb3b, 0x50071114, 0x03030201, 0x5c485a02, 0x03030301, 0x08035001, 0x4c090f0b, 0x34013701, 0xa7cefe92, 0x8a867e36, 0x01e6fe41,
		0x8789411a, 0xa04c367e, 0x00479a9e, 0x00010000, 0x08048237, 0x6b02bd36, 0x4e001100, 0x001a3040, 0x01000d01, 0x04010926, 0x02091409, 0x00050009,
		0x14090e7e, 0x730e090e, 0x73051311, 0x01010710, 0x12070107, 0x0905410f, 0x0e440741, 0x8205f448, 0x100128d4, 0xed5d5dd6, 0x5ffdde10, 0x5d20050a,
		0x31220082, 0x29422130, 0x1e500806, 0x33111703, 0x22690111, 0x1c36373c, 0x3d29544b, 0x4b1e3033, 0x69768753, 0x0212fe35, 0x69704b6b, 0xdc01496f,
		0x000095fd, 0xff1d0002, 0x02d801f3, 0x00130079, 0xb99a001f, 0xe8ff1e00, 0x4d000eb3, 0xf0ffb81e, 0x000d1040, 0x0d181c4d, 0x184c000e, 0x16210584,
		0x821c85b8, 0x40f02207, 0x2b1c820f, 0x100f1811, 0x18114c00, 0x0d4d0008, 0xb4201b82, 0x08830d83, 0x1082b320, 0x10870720, 0xf8220882, 0x11822340,
		0x2d840320, 0x2d830320, 0x0a761a39, 0x00761421, 0x48100b40, 0x7c172000, 0x7c1d460f, 0x3f004505, 0x82ed3fed, 0x462b20d6, 0x855009d2, 0x5e132009,
		0xa5550822, 0x37200805, 0x32331614, 0x26343536, 0x1d062223, 0x32513a20, 0x213a5231, 0x31523a21, 0x203a5132, 0x46454254, 0x45370082, 0x53360142,
		0x27274f7a, 0x53537a4f, 0x2626507a, 0x7a537a50, 0x827a8282, 0x82002003, 0x00023b00, 0x01000049, 0x007102c7, 0x001a0010, 0x1a11405a, 0x4d001010,
		0x000f181a, 0xaa84174d, 0xe820b982, 0x0220ca83, 0x4021ca82, 0x3cc18220, 0x1c057619, 0x730a1515, 0x0b100b00, 0x08030b20, 0x79091b0b, 0x0b001515,
		0x007c1144, 0x22be8341, 0x832f3912, 0x5d5e22c1, 0x0c6d44ed, 0x2b05da5e, 0x23152323, 0x17033e11, 0x15070622, 0x3c08bb84, 0x375337eb, 0x4872721b,
		0x2b2b1252, 0x301a1729, 0x494b440c, 0x331c7102, 0x69612b46, 0x046202e7, 0x47010406, 0x3cfa0201, 0x02007c45, 0x5bff1d00, 0x7802d801, 0x28001c00,
		0x00b9cf00, 0x058a4127, 0xffb8272b, 0x0d1840e0, 0x10254d00, 0x2004820e, 0x20098220, 0x20098321, 0x24138321, 0xf0ffb81f, 0x821682b3, 0x40e82207,
		0x2e1a821f, 0x100f281b, 0x081b4c00, 0x1b4d000c, 0x820a0910, 0x8218200a, 0x830d20d5, 0x0bb64135, 0x830a4021, 0x10072126, 0x07203182, 0x33205f83,
		0x03272482, 0x4d001018, 0x820f2003, 0x3d338304, 0x1a1a760f, 0x0a762300, 0x2a0a1414, 0x4000761d, 0x0048100c, 0x157c1429, 0x0f1a7c20, 0xcc412646,
		0xed332206, 0x06cf41dc, 0x2f32ce26, 0x3911ed10, 0x41171c60, 0x07290bdc, 0x0717031e, 0x2627032e, 0x14e24126, 0x44301a30, 0x2b1c0329, 0x29131e37,
		0x072a3c4b, 0xeb415e51, 0x41352009, 0x4a3207eb, 0x072e5071, 0x0e151d14, 0x16074204, 0x11263424, 0xf641939b, 0x00022707, 0x01000037, 0xaf4b02cf,
		0x40652405, 0x8220283d, 0x832320d7, 0x830220dc, 0x09032209, 0x07cc450c, 0x000c0c3e, 0x76250808, 0x111f2b00, 0x10120073, 0x2a120212, 0x7910030c,
		0x1b121f1f, 0x1241187c, 0x2108c745, 0xd78212ed, 0x4b323221, 0x11210a9b, 0x08935c33, 0xe3510120, 0x25d48206, 0x27262623, 0x04422206, 0x32332306,
		0x07422716, 0x05cf6305, 0xaf016108, 0x250f333c, 0x58102526, 0x0621471e, 0x53460417, 0x2829270f, 0xda717010, 0x35092b17, 0x16293924, 0x01312416,
		0x185739ae, 0x49453d18, 0x29844823, 0x6202f401, 0x02030604, 0x02011b62, 0x2f1b0aef, 0x1b2e2426, 0x0001000b, 0x01f3ff37, 0x007902bd, 0x40d80031,
		0x0e182c0b, 0x102c4d00, 0x274d000d, 0x8206fb4e, 0xb3f02907, 0x244d0009, 0xb3f0ffb8, 0x07821782, 0x0ab3d025, 0x83234d00, 0x000f230f, 0x27831b4d,
		0x2505fd48, 0x0012b3e0, 0x1549144d, 0x21078206, 0x1782b3f0, 0xe0250782, 0x00100fb4, 0x2818844c, 0x134d000e, 0x40e0ffb8, 0x2d08823e, 0x0f0e100b,
		0x200b4c00, 0x4c000a09, 0x2a821002, 0x82280121, 0x1524083f, 0x26760315, 0x1c2e2e33, 0x100d0076, 0x320d020d, 0x08010859, 0x10211929, 0x7c002f2f,
		0x16164629, 0x45107c19, 0x2908884b, 0x12113911, 0x10015d39, 0x05655dd6, 0x13995407, 0xcb593720, 0x05036505, 0x49323321, 0x01650731, 0x07c7590a,
		0x3fea5508, 0x32281842, 0x2b371e1a, 0x195b6619, 0x0a212a31, 0x2b46141a, 0x2113422d, 0x3f261a2c, 0x666d192d, 0x222d3a21, 0x4e141909, 0x1d30303a,
		0x0a171f29, 0x36281e0c, 0x075b5125, 0x45070e0a, 0x2d2d180c, 0x161b241a, 0x2c20100b, 0x57512b3c, 0x060e0e09, 0x001d0b44, 0x013d0082, 0x00002700,
		0x6b02cd01, 0x20000700, 0x03010f40, 0x04040673, 0x05020809, 0x04410779, 0x059c5644, 0x2f29ca82, 0x31cefdce, 0x23150130, 0x2d018211, 0xaacd0135,
		0x6b02aa52, 0x02dbfd46, 0x3e824625, 0xff300025, 0x82c401f3, 0x00193843, 0x0f0d404a, 0x00121120, 0x0f100f4c, 0x0b4c0010, 0xb3d8ffb8, 0x824d0012,
		0xb3e02207, 0x22078411, 0x831340f0, 0x73123419, 0x73081b15, 0x06131a05, 0x007c0d41, 0xed3f0046, 0x4a01333f, 0x2a410559, 0x22172806, 0x1135022e,
		0x5d141133, 0x0a8405d6, 0x020e2c08, 0x304d37fa, 0x1f115216, 0x2c1c1c2c, 0x1652111f, 0x200d4d30, 0x0134543a, 0x2f73fe96, 0x1010263f, 0x012f3f26,
		0x346afe8d, 0x82203a54, 0x010027de, 0x00000d00, 0x9b82e801, 0x00162708, 0x05234041, 0x000a0500, 0x14111678, 0x05111616, 0x0b780a0a, 0x100b1410,
		0x1716180b, 0x10411600, 0x0a441105, 0x6847410b, 0x2c8c8305, 0x87de10c6, 0xc4107d2b, 0x2b101887, 0x08078208, 0x1330313d, 0x3e17031e, 0x0e333703,
		0x2e230703, 0x0c662703, 0x122a2925, 0x252a2b10, 0x2408560c, 0x66213d32, 0x24323b1f, 0x3f6b0209, 0x33889595, 0x94958a33, 0xa787283e, 0xba5a5abb,
		0x482888a7, 0x142a0b83, 0x00b9df01, 0xb3e0ff13, 0x86500019, 0x84172005, 0x40f02307, 0x08821418, 0x82122821, 0x11182104, 0x10210482, 0x28048210,
		0x4d000d28, 0xf8ffb812, 0x280785b3, 0x0b1440e8, 0x0a4c000c, 0x213b8220, 0x3882100a, 0x15100a26, 0xb80a4d00, 0x82054745, 0x83f02007, 0xb8092328,
		0x5d83f0ff, 0x402c0783, 0x4d001723, 0x0e0d2009, 0x10014c00, 0x012a4482, 0x4d000c28, 0x000b1001, 0x4483004d, 0x44830020, 0x4cb80021, 0x0882065d,
		0x82b3e821, 0x22078276, 0x820fb3e0, 0x20798322, 0x2007840e, 0x235883c8, 0xb0ffb814, 0x07825883, 0x18b3d024, 0x07824d00, 0x82b3a021, 0x2007845f,
		0x210f8415, 0xc582b3b0, 0x90220f82, 0x0f8413b3, 0x82b39821, 0x270f823f, 0x0d0940d0, 0x580b4d00, 0x0b221582, 0x0d82ffb8, 0x08211682, 0x200d8238,
		0x21bc8208, 0x0d825e40, 0x06013d08, 0x08010807, 0x08077806, 0x07080714, 0x01127c08, 0x1201126e, 0x120b0c0d, 0x0c780d0b, 0x0b0c140b, 0x521f0a0c,
		0x7b131413, 0x0b140a0b, 0x1f090a0b, 0x00140052, 0x1409087b, 0xbb090808, 0x15373a82, 0x0b010bb4, 0x15141416, 0x44130b16, 0x14410c0d, 0x0709090a,
		0x48084106, 0x3325056d, 0x33332f33, 0x2801823f, 0x39121101, 0x39122f3d, 0x2602825d, 0x2b101887, 0x86c42b87, 0x18013106, 0x102b87d5, 0x0587c100,
		0x01c4107d, 0x10187171, 0x31210f8a, 0x20421830, 0x642b2008, 0xa05d0a87, 0x270d850d, 0x032e2333, 0x13133327, 0x32080283, 0x2307030e, 0x094d9903,
		0x03080b0d, 0x485a0b50, 0x03500b5c, 0x080e0c09, 0x933d614c, 0xfd53a8a0, 0xfe1a01fb, 0x540502e6, 0x3e929fa8, 0x00003401, 0x82190001, 0xdb470804,
		0x15006b02, 0x41406c00, 0x080e1512, 0x10090f11, 0x090c0e15, 0x05000d10, 0x000d1108, 0x10091008, 0x14081178, 0x11110811, 0x000d0115, 0x0e150e00,
		0x14000d78, 0x15000d0d, 0x090d0d17, 0x41101116, 0x09410d0e, 0x52154408, 0x3f21085d, 0x05c15733, 0x9d4bce20, 0xc40e2c06, 0x18331101, 0x872b872f,
		0x820fc47d, 0x05754900, 0x06063a08, 0x36362307, 0x17330337, 0x16033337, 0x80011716, 0x27221e0b, 0x1e462315, 0x32582159, 0x82795ba1, 0x5a30a459,
		0x48441b23, 0x91381f48, 0x50ad4a45, 0xeded2401, 0xa84edffe, 0x0d6f4354, 0x00102b08, 0x0829404d, 0x0b05080b, 0x140f0c78, 0x0f0c0f0c, 0x05080173,
		0x01047805, 0x04010414, 0x12110101, 0x0f410b0c, 0x05010108, 0xa3834104, 0x39333f24, 0x9b413311, 0xdd2f2a06, 0x107d2b87, 0x101801c4, 0x430982fd,
		0x3325057b, 0x27262635, 0x82918233, 0x8233209d, 0xd2153da5, 0x5c25633d, 0x2e2b4b1d, 0x265a1d47, 0x64e63c62, 0x995463be, 0x50995551, 0xe867ba62,
		0x36218b85, 0x057b5b00, 0x37001129, 0x0e051d40, 0x5e780e09, 0x0630058c, 0x0f130006, 0x0012090f, 0x4110790e, 0x08790509, 0x2608d34d, 0x2f32c610,
		0x4632ce10, 0x2f0809f7, 0x2107030e, 0x3e352115, 0x35213703, 0x20bf0121, 0x1d4d524f, 0x6ffe3301, 0x4e4e4b1f, 0x01e5fe24, 0x2c2b027a, 0x37858479,
		0x853f3646, 0x46337880, 0x2c087882, 0xff8f0001, 0x027e015b, 0x000700bb, 0x020b401b, 0x07040502, 0x03070408, 0x3f005a00, 0x01cd2fcd, 0xcdddd610,
		0x30312f32, 0x23153313, 0x2e038211, 0xa1a1ef8f, 0x41bb02ef, 0x004122fd, 0x82460001, 0x82ae203b, 0x0003373b, 0x01104021, 0x8d030003, 0x02140102,
		0x03000201, 0x00000102, 0x2a64322f, 0x872b2305, 0x4183c47d, 0x4623012e, 0x54150153, 0xa0fcbb02, 0x76000100, 0x65203b82, 0x05297787, 0x00030205,
		0x5a070409, 0x21368203, 0x77893fcd, 0x35230524, 0x03821133, 0x83650121, 0x41a52378, 0x7783de02, 0x19012836, 0x6b02cc01, 0x41000600, 0xff0400b9,
		0x0e2140f0, 0x10024d00, 0x03270482, 0x4d001038, 0x820f3003, 0x82202004, 0x0504210e, 0x032c8982, 0x06030402, 0xcd332f00, 0x2f190132, 0x21050958,
		0x1f43cd18, 0x2b013b05, 0x0713012b, 0x13270727, 0x42ad1f01, 0xad429090, 0xd0fe6b02, 0x22fcfc22, 0xa3823001, 0xa3820820, 0xa1ffec28, 0x0f000300,
		0x058201b4, 0x10000434, 0x2f01cdde, 0x1730312f, 0x08211521, 0x1cfee401, 0x2782465f, 0x0602a326, 0xb5024a01, 0x18222182, 0xfc830940, 0x80000324,
		0x72820201, 0x73821a20, 0xfe827883, 0x07173a08, 0x2a72d827, 0x8ab5027d, 0x00007a25, 0xff3a0002, 0x01b001f5, 0x000e00db, 0x40730030, 0x12182816,
		0x181f4d00, 0x4c000b0a, 0x000b201b, 0x0a181b4d, 0xb8124d00, 0x0ab4e8ff, 0x050e510c, 0x0908b425, 0x820a4c00, 0x40260811, 0x00121124, 0x7f24044c,
		0x2e2e3214, 0x311d820c, 0x22008907, 0x08022210, 0x000f2222, 0x2d511888, 0x0f882a2d, 0xad5f0050, 0x39112305, 0x57505e2f, 0x2f332105, 0x210c0e5b,
		0xe6563237, 0x020e2906, 0x13161415, 0x15021e32, 0x240c1351, 0x2e343517, 0x06b06102, 0x1fff5008, 0x2d101031, 0x222c1719, 0x342c3d16, 0x1d122c47,
		0x4826325f, 0x37232238, 0x2f312447, 0x222b1909, 0x0a11402b, 0x043b4f11, 0x06058a03, 0x161d1207, 0xa001232d, 0x27422e1a, 0x0e05defe, 0x2d3a210d,
		0x0f223728, 0x2715170b, 0x060c1320, 0x820c0844, 0x824720ff, 0x02cc32ff, 0x001200b5, 0x407e0021, 0x10301c2a, 0x201c4d00, 0x2404820f, 0x4d000e18,
		0x210e8317, 0x0e823817, 0x0d181723, 0x20f7820e, 0x211e8210, 0xef60180a, 0xb3e82205, 0x05805008, 0xd760b320, 0xe8240805, 0x00091d40, 0x0882194d,
		0x7f130023, 0x08011000, 0x12112210, 0x0d88164d, 0x881e2151, 0x00500300, 0x32ed333f, 0x2306b447, 0x32ed5d5e, 0x45099350, 0x13200500, 0x240c685f,
		0x11371127, 0x05e84c16, 0x08050041, 0x390f9a3e, 0x334a2f23, 0x523a201b, 0x1a563732, 0x11261353, 0x1e0e4e45, 0x361d212f, 0x09bf010e, 0x59402413,
		0x3f5a3836, 0x02081022, 0x93fd0e9a, 0x55550505, 0x1a2d3f24, 0x00000d17, 0x31000100, 0xc322e782, 0xe582db01, 0x00b94326, 0xb4e0ff14, 0x2108ce83,
		0xe0ffb80e, 0x0e0d1d40, 0x08084c00, 0x8211231a, 0x001f000f, 0x19220002, 0x1d881619, 0x0c090951, 0xbf410588, 0x2f322807, 0x5dd61001, 0x65ce10ed,
		0x37210599, 0x07145534, 0x200cae52, 0x05cd5217, 0x28313808, 0x22355d46, 0x21132643, 0x40241c37, 0x2f1a1c2f, 0x3b202842, 0x48230c23, 0x435d382a,
		0x5c3fe725, 0x0c091d3c, 0x13070c47, 0x2c2e4129, 0x0714293f, 0x0b0d450c, 0x825b3c1f, 0x8228207c, 0x02ad24a7, 0x820e00b5, 0x40612fa9, 0x0f201c12,
		0x1b4c0010, 0x4d000a10, 0x7942181b, 0xb3d82506, 0x0a4d000e, 0x2006c44a, 0x21078205, 0x10821e40, 0x7f0e213a, 0x82082311, 0x0c094019, 0x00221948,
		0x1e218803, 0x14880b50, 0x4d100f51, 0x2205c16c, 0x8232ed33, 0xed2b21c3, 0x200b7e42, 0x076e5301, 0x32331626, 0x37113736, 0x080c7a42, 0x0117163d,
		0x1d360e5a, 0x0e1e2f21, 0x2b1f3d4c, 0x541b530a, 0x3a523238, 0x49341b20, 0x0e38252f, 0x170d6e01, 0x243f2d1a, 0x03065851, 0xfd0e5f02, 0x22100858,
		0x36385a3f, 0x12244059, 0x8600000a, 0x01c724cb, 0x821800db, 0xb9cf23cb, 0xff611e00, 0xb81e2506, 0x0e40e0ff, 0x1b22b282, 0xd6821018, 0x000f1022,
		0x82059c5e, 0x8316200c, 0x830920cd, 0x08102410, 0x82124d00, 0x82b3200d, 0x8211200c, 0x24078330, 0xe8ffb807, 0x822582b3, 0x86d02007, 0x05c7410f,
		0x18830220, 0x4d000922, 0xe0210782, 0x053160b3, 0x12b3d828, 0xb8014d00, 0x446cd0ff, 0x40250807, 0x4d000a23, 0x0c048219, 0x2123040c, 0x40148205,
		0x14480c09, 0x21860522, 0x0b0b0021, 0x510f8808, 0x5000881c, 0x05325300, 0x2f391122, 0x2005bd4d, 0x181d6232, 0x1632012b, 0x16211515, 0x36323316,
		0x06f64137, 0x3e343523, 0x06d55a02, 0x01074d08, 0xfe665e03, 0x4d5505b4, 0x0b103e2c, 0x3c314e0f, 0x261e3c5b, 0x3e994e3e, 0x222f1d33, 0xdb010314,
		0x481d7775, 0x46080e4b, 0x40251208, 0x5c3e3459, 0x3bc61e3c, 0x2e241645, 0x00010018, 0x0100003f, 0x00b502e2, 0xb956001b, 0xf0ff1400, 0x1325c283,
		0x40e0ffb8, 0x26d3822a, 0x000c1007, 0x8218074d, 0x0d0d3ecc, 0x1a171d19, 0x0001047f, 0x02080102, 0x110e0e1c, 0x1a4d0a88, 0x04178501, 0x004a0049,
		0x056d433f, 0x012f3228, 0x5d5ed610, 0xe96232d5, 0x05284b05, 0x23113324, 0xae833335, 0x4205d857, 0x2d0805c3, 0x23153315, 0x6262a111, 0x2441311e,
		0x0f204924, 0x15224216, 0xbb101c25, 0x458b01bb, 0x2c47362a, 0x470b1012, 0x1b0b100b, 0x4529222d, 0xdf4175fe, 0x01583905, 0x00db01ad, 0x002d001e,
		0x2800b9c2, 0x10b3e0ff, 0xb8284d00, 0x0fb3e8ff, 0xf0280784, 0x4d000eb3, 0xd0ffb823, 0x07821783, 0x1783d820, 0x17870782, 0x0db3e822, 0xf0271f84,
		0x000c0940, 0x82181c4d, 0xb812263d, 0x11b4f0ff, 0x0d6b4512, 0x3940f032, 0x4c00100f, 0x0009100a, 0x08180a4d, 0x18064d00, 0x06210982, 0x3f098220,
		0x117f1e2d, 0x0882252f, 0x2e081717, 0x030f882a, 0x0802031f, 0x182e0303, 0x14881b18, 0x0d88224b, 0x2008d241, 0x05804533, 0x581a9060, 0x11220ef0,
		0x24550614, 0x0868720b, 0x32336608, 0x5a013736, 0x29263a0e, 0x1d1f3547, 0x3c335037, 0x6e6d1d55, 0x0f1c492d, 0x4828431a, 0x242a0c3e, 0x21134340,
		0x371f182a, 0x12082b11, 0x3a55371b, 0x233e5533, 0x62fe0811, 0x0a0e606c, 0x3a0e0b49, 0x046c0141, 0x28495807, 0x12112539, 0x0001000c, 0x01000047,
		0x00b502b0, 0x40600015, 0x12201015, 0x28104d00, 0x21048211, 0x04821018, 0x000f1028, 0xffb8094d, 0xec82b3d8, 0xffb80827, 0x000ab3e8, 0x2c07824d,
		0x091a40d8, 0x7f0d4d00, 0x1503170c, 0x2c3f827f, 0x11160008, 0x01500688, 0x000d4d02, 0x051c5c4a, 0x45078e51, 0x33230b67, 0x45153711, 0x11210666,
		0x05425223, 0x11072208, 0x32145347, 0x2a473518, 0x3e305212, 0x020b311a, 0x08ec0ea7, 0x4e381f09, 0xf4fafe2f, 0x050b4756, 0x3a6082fe, 0x00020000,
		0x01f5ff36, 0x009e02c2, 0x0021000b, 0x1f294044, 0x000d0b18, 0x82281f4c, 0x1f210890, 0x4d000920, 0x0f098303, 0x0d0c0c7f, 0x220d2317, 0x88131616,
		0x8a06511c, 0x0f850c00, 0xed3f0049, 0x051b6ade, 0x10c61028, 0x2f3911ce, 0xb759d4fd, 0x5f132005, 0x07250a33, 0x11333523, 0x054f4314, 0x030e2608,
		0x022e2223, 0x261ad135, 0x251b1a26, 0xd8863025, 0x311d2626, 0x16060c0e, 0x2c13231d, 0x020e233a, 0x1f1f2418, 0x30038324, 0xe3fe458d, 0x080e2f45,
		0x08090346, 0x47301806, 0x24a7822f, 0x0156ff47, 0x3ea78480, 0xb939001f, 0xe8ff1100, 0x0a091c40, 0x83094c00, 0x7f1e0303, 0x1717210f, 0x1b18200c,
		0x82521488, 0x851f229f, 0x4a9f880e, 0xde2305ec, 0x832f32ed, 0x8b01209e, 0x1134579c, 0x86340121, 0x01dd2f9d, 0x3b2d1b0e, 0x224d2621, 0x1c3d1919,
		0x9b8c3428, 0x4330352e, 0x1110122a, 0x29110c46, 0x0087013b, 0x0805eb41, 0xb502de42, 0x65001600, 0x00063640, 0x0b810005, 0x000b1406, 0x13060b14,
		0x13140010, 0x10810014, 0x13101413, 0x14141000, 0x0b101805, 0x010d007f, 0x0b170d08, 0x49140510, 0x0d4d0f0e, 0x4a06054a, 0x3f333f00, 0x12270282,
		0x10013939, 0x435d5ed6, 0x102305d8, 0x4c0487c1, 0x872c0885, 0x2b101808, 0xc47d0587, 0x1e373031, 0x24054457, 0x37112315, 0x05074b11, 0x1bee2908,
		0x123c4344, 0x3f381362, 0x5353193f, 0x612c6e37, 0x14ff792b, 0x1f49463d, 0x323c411f, 0xa702df11, 0x3059fe0e, 0x6c33335f, 0xf341af82, 0x00b02e05,
		0x40450017, 0x0e18032c, 0x20034d00, 0x2104820d, 0x04820c18, 0x830b2021, 0x00093504, 0x067f094d, 0x19130706, 0x85061807, 0x12124d09, 0x5100880f,
		0x2006f848, 0x06f24101, 0x2905f041, 0x22052b2b, 0x1135022e, 0xa44f3523, 0x36260806, 0x030e1737, 0x3a2c5201, 0xd8860e22, 0x131c1309, 0x0c0e321d,
		0x231e1606, 0x4730180b, 0x46b7012f, 0x2c2303fe, 0xdf410a1b, 0x3c8f8206, 0x01000029, 0x00da01d0, 0xb9560021, 0xe8ff0a00, 0x00100db4, 0xffb80a4c,
		0x000cb3f0, 0x0807824d, 0x2140e822, 0x154d000b, 0x197f1805, 0x7f0e2119, 0x7f20230d, 0x19192221, 0x124a210e, 0x15500788, 0x0205881d, 0x21098848,
		0x456e2f33, 0x32ed2d09, 0x2b303132, 0x36132b2b, 0x17163233, 0x1e2e0482, 0x23111502, 0x23263411, 0x16070622, 0x2d431515, 0x07370805, 0x3c292311,
		0x12331d35, 0x2b18312b, 0x204b1421, 0x0b1a0c18, 0x20164b06, 0x014b1914, 0x121117c3, 0x36241223, 0x01b6fe24, 0x0c26244c, 0x971c170d, 0x09282398,
		0x820073fe, 0x43012000, 0xbb8205e7, 0x5e001336, 0x080c0c40, 0x0c4d0016, 0x00100f10, 0xffb8054c, 0x0012b3e0, 0x63053b6a, 0xb425066c, 0x4c000a08,
		0x21188204, 0x11821b40, 0xef7f0836, 0x15070107, 0x13007f12, 0x080213e0, 0x13081413, 0x03880e4a, 0x0351c982, 0x5d5e2505, 0x5dde10ed, 0x82076341,
		0x20bf82c3, 0x49be8416, 0x2208053b, 0x2d472311, 0x5f5d2759, 0x291d1052, 0x152d1418, 0x0bc30153, 0xfe6a600c, 0x2d0101f0, 0x050c1f38, 0x4778fe04,
		0xcc3206af, 0x1300db01, 0x98001f00, 0x181e1040, 0x1e4d0010, 0x04820f20, 0x000e0824, 0x8c821c4d, 0xae83b420, 0xf0210882, 0x201082b3, 0x82108718,
		0x40f82208, 0x2111820f, 0x1f832016, 0x2d831620, 0xffb8122b, 0x081140e8, 0x0c4c0009, 0x20058310, 0x20058407, 0x22328203, 0x5d0009b3, 0x183805de,
		0x144d0008, 0x1a210082, 0x09400a82, 0x200a480c, 0x500f8817, 0x5105881d, 0x211c0d57, 0x05571425, 0x05be4605, 0x07021e23, 0x09ee7634, 0xcc013308,
		0x2e4e381f, 0x1f384d2d, 0x2d4d381f, 0x1f384e2e, 0x393a4455, 0x3a394343, 0x5937e844, 0x40232340, 0x5a373759, 0x3f23233f, 0x5b4f375a, 0x5b4e4f5b,
		0xf782005b, 0x5bff4732, 0xda01cc01, 0x21000e00, 0x00b97600, 0xb4f0ff20, 0x1f26b283, 0xb3f8ffb8, 0x24710010, 0x000f2105, 0x8305064c, 0x26db82e0,
		0x0a09b4f0, 0x82114c00, 0x294021ce, 0x0c20c682, 0x023ff283, 0x4d000e18, 0x000d1002, 0x0f82004d, 0x7f180723, 0x08011900, 0x88032219, 0x4b19501d,
		0x8414880a, 0x453f20d7, 0x2b221395, 0xc584252b, 0x16110728, 0x3e323316, 0xe3843702, 0x15272624, 0xac451123, 0x77012605, 0x27223d4c, 0x068d490b,
		0x1b552b08, 0x252f4a33, 0x1b530e38, 0x52323755, 0x51e7203a, 0xfe040659, 0x1a160ddb, 0x35243d2d, 0x12244059, 0x6702b70b, 0x3f221008, 0xdf83005a,
		0xdf822820, 0xdf86ad20, 0x2a407825, 0x82091820, 0x832820d4, 0x0f2021d9, 0x18210982, 0x2004830a, 0x20e08208, 0x20138208, 0x26138312, 0x09081011,
		0x820d4c00, 0x82b320de, 0x210782d3, 0x945fb3f0, 0x40e82205, 0x2410821b, 0x187f1908, 0x33e48223, 0x480c0940, 0x8805220f, 0x4b19511d, 0x5014880c,
		0x3fed3f00, 0x7909c758, 0x372e0dbf, 0x33021e14, 0x11373632, 0x22232626, 0x404b0706, 0x23112206, 0x05334b35, 0x4b0f7d21, 0x340805c9, 0x3d22270b,
		0x3a20554d, 0x53363253, 0x380f531d, 0x334a2f23, 0x3d24e71c, 0x0d161a2d, 0x06042501, 0x5a385159, 0x0811223f, 0x0ab79afd, 0x59402413, 0x00010000,
		0x2004826b, 0x27df82b6, 0x4024000d, 0x0d0f0612, 0x29050f47, 0x0a07070e, 0x00500388, 0x9382004a, 0x27060649, 0x31ce10ed, 0x36113330, 0x3708f748,
		0x666b1107, 0x233a2068, 0x1d31200f, 0xb7013f3d, 0x49080523, 0xfe110509, 0x24084283, 0xf5ff4200, 0xdb01b201, 0xec002700, 0x20221240, 0x4c001210,
		0x0f0e2822, 0x08214c00, 0x1d4d000e, 0xb3e0ffb8, 0x2207840c, 0x840bb3e8, 0xb3e02207, 0x2207840a, 0x8409b3c8, 0xb3e02507, 0x1b4d0008, 0x0d262783,
		0xb81a4d00, 0x2f83d0ff, 0xe8200782, 0x19202783, 0x2706d54a, 0xe8ffb817, 0x4d0010b3, 0xf0280782, 0x000e5140, 0x0b18084d, 0x20260482, 0x4c000a09,
		0x40821808, 0x82280621, 0x3005363d, 0x054d000c, 0x4d000a18, 0x000f1004, 0x0820034d, 0x024c0009, 0x3d378210, 0x82000d0d, 0x2222291c, 0x07018215,
		0x28070801, 0x23230a18, 0x1f038826, 0x130e0e51, 0xc04c0a88, 0xed392406, 0x46112f32, 0x3321062f, 0x138b5f2f, 0x23099252, 0x042e3425, 0x2a051275,
		0x032e0717, 0x14152223, 0x4915041e, 0x53080a0c, 0x3d295f01, 0x5b293d48, 0x1d512661, 0x241c080f, 0x296c1329, 0x293e483e, 0x50306a62, 0x4d231024,
		0x1974712c, 0x22171820, 0x4b382832, 0x044a090b, 0x3b040709, 0x19181d15, 0x3f273324, 0x4b101045, 0x01001510, 0xf5ff3f00, 0x6002c201, 0x49001b00,
		0x18132940, 0x2208dc82, 0x000b2013, 0x7f03004d, 0x17161619, 0x1d020d0d, 0x08011700, 0x1b1a1c17, 0x00851603, 0x0c0c4919, 0x46108809, 0x332b0654,
		0x32cd32ed, 0x5ec61001, 0x83ce105d, 0x822f20d6, 0x30312710, 0x33132b2b, 0x996d2315, 0x09934b05, 0x23353008, 0x37353335, 0x0ac4c4f3, 0x241a2417,
		0x0e0c142c, 0x42342d3d, 0x62620e25, 0x45d00152, 0x1b2c23d8, 0x460a0c0a, 0x30181406, 0x45d82f47, 0x82000e82, 0x4425089b, 0xad01f6ff, 0x1500d001,
		0x00b95600, 0xb3d8ff0d, 0x0d4d0011, 0x40e8ffb8, 0x00100f30, 0x1218064c, 0x20064d00, 0x25048209, 0x4d000818, 0x0e822005, 0x0a100536, 0x7f134d00,
		0x7f0b1700, 0x08010800, 0x09141608, 0x03880e49, 0x3f25af83, 0xd6100133, 0x0aab625e, 0x672b2b21, 0x11230808, 0x43141533, 0x250805f0, 0xad013311,
		0x353c591b, 0x52122c46, 0x1b0d3c33, 0x53031218, 0x1f10070d, 0x012f4e39, 0x4856f305, 0x01030302, 0x9b828801, 0xa0821e20, 0x9b82d620, 0x6e001428,
		0xff0b00b9, 0x7d82b3f0, 0xffb80f28, 0x1210b4e0, 0x08824c00, 0x2f40e823, 0x2f99820f, 0x810a0f0a, 0x09140609, 0x14050609, 0x0081140f, 0x31055071,
		0x004f090f, 0x0002005f, 0x00150916, 0x090a4914, 0x4e480f49, 0x05e15405, 0x66c61021, 0x87220d43, 0x33521018, 0x003e0805, 0x2b012b2b, 0x07030e01,
		0x27262623, 0x17031e33, 0x0137033e, 0x302e12d6, 0x2f4b1732, 0x0c5a2560, 0x1123221f, 0x21242511, 0x41d0010c, 0x2f6c777d, 0x2c82f05e, 0x245b6262,
		0x62625b24, 0x0082002c, 0x13000126, 0xe1010000, 0x2a25b782, 0x28b54801, 0x27a28218, 0xf0ffb828, 0x00091b40, 0x2605a26c, 0x0017101c, 0x82201b4d,
		0x181a2104, 0xec230482, 0x8219011a, 0x82b620d4, 0x19e6270a, 0xffb81801, 0x0a82b3e8, 0xffb81725, 0x820e40f8, 0x10162608, 0x154d0010, 0x82048318,
		0x82b32045, 0x4c132044, 0x0c200674, 0x40210f82, 0x345e8213, 0x000b180c, 0x09180c4d, 0x080b4d00, 0x084d000b, 0xb3d0ffb8, 0x21078412, 0xb376b3e8,
		0xb3e02505, 0x074d000e, 0x40213782, 0x2010824d, 0x21938303, 0x22821802, 0x82080221, 0x1802210e, 0x56081c82, 0x1a1f1a00, 0x14000584, 0x1f000505,
		0x0a257f24, 0x84191419, 0x05140a05, 0x0e05050a, 0x1f250f2a, 0x5f254f25, 0x0525df25, 0x0f142c25, 0x2b0e0b7f, 0x1a492425, 0xffb80519, 0x161340c8,
		0x05054d00, 0x0e0f1919, 0x0a141449, 0x1f2a4a0b, 0x2f00001f, 0x3f322f32, 0x832f3333, 0x2f332303, 0x965f112b, 0x32ed2506, 0x325dce10, 0x28058f5f,
		0xc47d872b, 0xed101801, 0x05705532, 0x2311b567, 0x5d2b2b2b, 0x06820182, 0x212b2b25, 0x4127032e, 0x9b410d94, 0x82332006, 0x01520815, 0x15160f57,
		0x160e0e15, 0x3e0f1715, 0x4e09251c, 0x0d0a0703, 0x12161008, 0x0a3e0a11, 0x0f141210, 0x080a0e09, 0x0e054b03, 0x220d1814, 0x273d3838, 0x38383d27,
		0x64f17b22, 0x60524b27, 0x363c283c, 0x38232338, 0x37273c36, 0x294e535e, 0x7b787232, 0x00820039, 0x00014f08, 0x0100001d, 0x00d001d8, 0x40700017,
		0x130a1441, 0x0b111017, 0x0e101712, 0x120b0f00, 0x0a090605, 0x0b120a13, 0x0a138112, 0x130a1314, 0x00011713, 0x1710000f, 0x000f8110, 0x000f0f14,
		0x0f0f1917, 0x1213180b, 0x490f1049, 0x174a0a0b, 0xa84c4a00, 0x56332005, 0x87271b67, 0xc4c4c40e, 0x560f0f0f, 0xd982056b, 0x36233908, 0x33273736,
		0x07333717, 0x01171616, 0x221d0a7c, 0x28121225, 0x550b2025, 0xa72e5f21, 0x58737d5d, 0x205b2d99, 0x32333014, 0x33321716, 0x7f3c1330, 0xa2a2dc39,
		0x3e803bd7, 0x0025ba82, 0x0158ff24, 0x31bf82cd, 0x40080120, 0x11101942, 0x10184d00, 0x174d0010, 0x04821218, 0x820f1021, 0x0c182504, 0x10164d00,
		0x12200482, 0x11200e83, 0x934d0e83, 0x82182005, 0x2010212c, 0x10212282, 0x201d8220, 0x2518830f, 0xe8ffb80c, 0x17822a40, 0x10380725, 0x83064d00,
		0x10062821, 0x4c00100f, 0x830c2806, 0x0b0a240f, 0x83054c00, 0x2005210a, 0x0f200a83, 0x82068542, 0x67d82007, 0xc82306c3, 0x820e3c40, 0x12302129,
		0x142a8882, 0x1581140f, 0x15151418, 0xbf430618, 0x0f200809, 0x151f090f, 0x20221501, 0x01092020, 0x0f182109, 0x03090606, 0x154b1d88, 0x090a4914,
		0x333f0049, 0xed250182, 0x33113912, 0x050d7433, 0x2119c343, 0x036a2b2b, 0x842b200f, 0x50172000, 0xdb4305c5, 0x33460809, 0x0e070606, 0x26222303,
		0x21093327, 0x1737310e, 0x5a206238, 0x27221b0a, 0x181c1016, 0x20560d18, 0x27112d4f, 0x13253a2e, 0x0557082d, 0x6a312b06, 0x5d2879f3, 0x2e2d6362,
		0x355f5b5a, 0x2868f482, 0x0a12263a, 0x00820004, 0x49000135, 0xab010000, 0x1100d001, 0x24404200, 0x05010515, 0x440e090e, 0x0637068e, 0x0f130006,
		0x0109000f, 0x00120908, 0x4910850e, 0x08850509, 0x653f004a, 0x1027052a, 0x325d5ec6, 0x57c6102f, 0x01280758, 0x0130315d, 0x3307030e, 0x08055a57,
		0x21352323, 0x3e12a401, 0xff1b4647, 0x3f159efe, 0xe4184144, 0x92014e01, 0x645b4b15, 0x2837462d, 0x1c545d5f, 0x357a8245, 0x5bff4f00, 0xbb02ab01,
		0x67002c00, 0x10234440, 0x234d000f, 0x04820e18, 0x820d1021, 0x0a182d04, 0x094c000c, 0x4d000f18, 0x0e0d1009, 0x0c200a83, 0x20210a82, 0x0804820b,
		0x000a182d, 0x131e0e4d, 0x162c7f1a, 0x2e252506, 0x002c162d, 0x1f1e0d00, 0x2f000d0e, 0x11cd2fcd, 0x39cd2f39, 0x39121101, 0xce33332f, 0x48ce32fd,
		0x13360bea, 0x023e3233, 0x3e343535, 0x15333302, 0x15062223, 0x07061415, 0x06821616, 0x10841620, 0x1c832e20, 0x022e4408, 0x284f2323, 0x09111a11,
		0x2e3d240f, 0x232a5551, 0x281a1a28, 0x51542a24, 0x0f243d2e, 0x11191109, 0x0f2b0129, 0xa1101f19, 0x14273825, 0x8a322641, 0x0c0b3f43, 0x328a3f42,
		0x27144126, 0x0fa12538, 0x8310191f, 0x82d420df, 0x822120df, 0x00032edf, 0x7f02b714, 0x04050303, 0x2f000003, 0x2e9b842f, 0x133031ed, 0xd4231133,
		0xbb024d4d, 0x4100a0fc, 0x2f82058f, 0x0f41a520, 0x00b92505, 0xb3f0ff23, 0x2323fc82, 0x51e8ffb8, 0xe02006a9, 0x26069151, 0x0c0ab4e8, 0x82094c00,
		0x0bb42218, 0x3608840d, 0x0a1840e0, 0x0e1e4d00, 0x26911219, 0x07070016, 0x00162d2e, 0x410e2c2c, 0x12200812, 0x22081241, 0x413333ce, 0x25240b12,
		0x020e2223, 0x0e20fd82, 0x352af282, 0x35363233, 0x37363435, 0x06822626, 0x23232622, 0x1e201082, 0x1e261c83, 0x01333302, 0xf78228a5, 0x250f0922,
		0x220f1041, 0x82080f25, 0xeb292118, 0x2d230f41, 0x01bd0025, 0x005101cf, 0xb9460021, 0xd7821900, 0x4d001137, 0xf0ffb819, 0x00100a40, 0x0918144d,
		0x034c000c, 0x40e0ffb8, 0x08098313, 0x10002120, 0x16212111, 0x881c0b88, 0x05101005, 0x2f332f00, 0xeddced10, 0x2f012f32, 0x31cddccd, 0x00822b30,
		0x09430120, 0x05285505, 0x2006a67a, 0x06a64b17, 0x03cf0137, 0x1f2c1d0f, 0x18152d1b, 0x140e1a2c, 0x39030a0d, 0x2b1c1003, 0x21108320, 0x1084192d,
		0x113a012e, 0x151a262c, 0x0d1c0e0d, 0x100b1914, 0x00200c8b, 0x2c058f44, 0x02d301f4, 0x00310076, 0x240c4096, 0x26a48210, 0x0e0d1824, 0x821a4c00,
		0x12b323b3, 0x07824d00, 0x82b3f821, 0x820c20c3, 0x4040080f, 0x4d00133f, 0x0e0e1717, 0x33200606, 0x19283030, 0x2676130d, 0x19322c00, 0x16297926,
		0x792f1029, 0x0f000d00, 0x02291f29, 0x00af004f, 0x290300bf, 0x03002900, 0x7c1c1f1f, 0x07074623, 0x45037c0a, 0x2d06934f, 0x39112f32, 0x5d2f2f39,
		0x1033115d, 0x048432ed, 0xd410012b, 0x32ed3232, 0x2f32ce32, 0x21038210, 0x4d782f32, 0x36132108, 0x2a092d4b, 0x07330706, 0x15140623, 0x82171414,
		0x05364408, 0x06176708, 0x26222306, 0x33352327, 0x34353426, 0x35233734, 0x5f73126a, 0x10183328, 0x441b3315, 0x0cc70a40, 0xb30101c4, 0x490da00c,
		0x1536263c, 0x2e4b0f12, 0x440e6d68, 0x3d01013d, 0x676aa501, 0x0846090a, 0x403f4b0a, 0x0b0d170b, 0x50400a16, 0x470b0d3e, 0x65721208, 0x0b160a40,
		0x400b170d, 0x01000000, 0x70ff9400, 0xcf7f5e01, 0x12942f35, 0x07181e23, 0x1c2e1d20, 0x2f172625, 0xcf7f2f46, 0x073a0814, 0xe20156ff, 0x2800b502,
		0x00b94a00, 0x40e0ff1b, 0x00090829, 0x0c10054c, 0x18054d00, 0x4c000a08, 0x190b1517, 0x0002217f, 0x292a2727, 0x521e8824, 0x4d08880f, 0x15852818,
		0xd3584902, 0x01ed3207, 0x2f391211, 0xfdcc33ce, 0x31ce33cc, 0x2b2b2b30, 0x16615513, 0x2706da4d, 0x32331637, 0x3f113536, 0x2b116e55, 0x203c2d1b,
		0x120e1e1c, 0x35271715, 0x08137a55, 0x42307837, 0x03061229, 0x3b2b0847, 0x00008701, 0x2a000200, 0xca017cff, 0x11007900, 0x30002500, 0x20171740,
		0x20941a12, 0x940c0327, 0x12260600, 0x1d112500, 0x03179a09, 0x36aa845c, 0x32cd32dc, 0xced61001, 0xd61039ed, 0x3912cefd, 0x36173031, 0x18263736,
		0x2308b849, 0x3707020e, 0x0f134118, 0x39222a39, 0x211d1d0d, 0x112b1d21, 0xda314127, 0x161c2011, 0x201d1d06, 0x832a1d22, 0x074a350f, 0x27032316,
		0x27291917, 0x2e371d2c, 0x043a0622, 0x12150e07, 0xa382118b, 0x00032a08, 0x01f4ff1f, 0x006000d5, 0x0017000b, 0x40330023, 0x1e95181a, 0x0012950c,
		0x121e0695, 0x1e120606, 0x21242503, 0x1b9a0915, 0x2da8840f, 0x3232ed33, 0x17121101, 0x2f2f2f39, 0x0183ed10, 0x37303122, 0x200acc7f, 0x240b9617,
		0x18181d89, 0x2403831d, 0x18181ca6, 0x8803831c, 0x162a2408, 0x92162020, 0x00240803, 0xff480001, 0x02ac017f, 0x0011006b, 0x110f4024, 0x0a0c000f,
		0x12130909, 0x0c0f0900, 0x2f00050d, 0xcd32dd2f, 0x39238c83, 0x8233cd2f, 0x312c080a, 0x14150130, 0x26230706, 0x23353526, 0x33353335, 0x01153315,
		0x2908071e, 0x8e8e0808, 0x64018e48, 0x3d7a4be3, 0xe34b7a3d, 0x45c2c245, 0x5f8afa82, 0x00172108, 0x0c1c403c, 0x17130708, 0x0e001115, 0x1907070a,
		0x110b1418, 0x08010e0f, 0x0a150f0e, 0x00040700, 0x2f236b84, 0x875d5edd, 0x82332072, 0x250b8272, 0x3132cd10, 0x76862530, 0x79877583, 0x7d842320,
		0x84070821, 0x2a7f837d, 0x49788e8e, 0x753b3b75, 0x83a84449, 0x44a82180, 0x81347f82, 0x73010802, 0x0500af02, 0x1b405b00, 0x00100805, 0x1220034d,
		0x18210482, 0x3b048211, 0x4d001010, 0x70056004, 0xb8050205, 0x1b40c0ff, 0x05481815, 0x7f016f02, 0x40010201, 0x012a0b82, 0x01030040, 0x00030202,
		0x9e820580, 0xcd1a3329, 0x33113332, 0x822f1901, 0x822b2009, 0x5d0382a5, 0x380807c2, 0x27071713, 0x79fa2707, 0x22575722, 0x2780af02, 0x00274e4e,
		0xff090007, 0x02eb01f3, 0x000b0078, 0x001f0013, 0x00330027, 0x003f003b, 0x283bb6fa, 0x4c00130d, 0xd8ffb839, 0x250883b4, 0xd0ffb837, 0x09831140,
		0x18843520, 0x83302721, 0x8725200b, 0x8223201e, 0x201e8508, 0x201e8421, 0x23058413, 0xe0ffb811, 0x0f203d84, 0x40210882, 0x21318364, 0x0583200d,
		0x3f3e3c08, 0x9614383f, 0x20502040, 0x20032060, 0x244f961a, 0x246f245f, 0x96282403, 0x34503440, 0x34033460, 0x4138962e, 0x0c3d3d3c, 0x104f9606,
		0x106f105f, 0x96001003, 0x3e3f400c, 0x823e3c3d, 0x0e3d0801, 0x981d3126, 0x01224036, 0x98172b22, 0x035c263a, 0x01124f98, 0x0e980912, 0xed3f005a,
		0x3fed5dd4, 0xd432ed33, 0x32ed325d, 0x39391211, 0xcd102f2f, 0x1001cd10, 0x5ddcfdd6, 0x2f3311ed, 0x21098533, 0x0f875dde, 0x220dc765, 0x69161413,
		0x072808bd, 0x15323334, 0x17222314, 0x37201392, 0x25291392, 0x46170127, 0x0e0d0d0d, 0x2604820e, 0x50514e35, 0x820ea24f, 0x260e820c, 0x514d330e,
		0x82f94f4f, 0x3a0c8217, 0x4e340e0d, 0xfe504e50, 0xc5011de1, 0x33ef011d, 0x33332727, 0x89332626, 0x83e98a89, 0x23038307, 0x89898a8a, 0xda280b8a,
		0x2d28012d, 0xffff0000, 0x2f054367, 0x26023d03, 0x00003600, 0x5f010701, 0x8b001200, 0x2c052379, 0x252e3632, 0x370f0150, 0x342b2b4f, 0x081c8200,
		0x00900073, 0x01550138, 0x000500c3, 0x0300b934, 0x0cb3e8ff, 0xb8034d00, 0x1040f8ff, 0x014d000b, 0x02020405, 0x06000304, 0x03000105, 0x332f1900,
		0x1801cdcd, 0xcd32d610, 0xcd102f32, 0x2b303132, 0x1737372b, 0x90071707, 0x63633a8b, 0x1fc5fe3a, 0x0020a6a6, 0xff1b0002, 0x02e201fa, 0x000e0071,
		0xb5870024, 0x000f0814, 0xffb8144d, 0x0e0e40e8, 0x10104d00, 0x20048210, 0x29128218, 0xf0ffb807, 0x000e0db4, 0xba48024c, 0x24078206, 0x000db3f0,
		0x0807824d, 0x2940f82e, 0x4c000c0b, 0x0b73201c, 0x1e1e120b, 0x26211a1a, 0x25127605, 0x1c1c791f, 0x23792018, 0x18791b42, 0x157c0041, 0x0f7c0841,
		0xed3f0042, 0xf15b0185, 0x46ed2006, 0x0d8305fc, 0x270ad249, 0x020e2213, 0x33161415, 0x2005bd52, 0x07175803, 0x15331724, 0x03861523, 0xdc065c08,
		0x0f1c2b1b, 0x14143839, 0x09150d03, 0x5a686859, 0xc10e1e0b, 0x8d696980, 0x2a021dce, 0x3a5d4224, 0x01067874, 0x0205db01, 0xa093d0fd, 0x0204a4a0,
		0xdb46be46, 0x00000646, 0x95000100, 0x5f01ab01, 0x1300c602, 0x0c401b00, 0x08000e05, 0x9a0b0e94, 0x5a130005, 0xdccd3f00, 0x452f01ed, 0x012205a8,
		0xd774030e, 0x83232005, 0x023e2480, 0x465f0137, 0x2e290bdc, 0x85022f47, 0x180f0804, 0xad461813, 0x265f830c, 0x01a80194, 0x82c3025e, 0x40192c5f,
		0x940e050b, 0x13000800, 0x820b9a05, 0xdcfd2a5e, 0xce2f01cd, 0x303139ed, 0x0ff54513, 0x210f3947, 0x4718e901, 0x0029110a, 0x012b0002, 0x02ca01b7,
		0x285b82b5, 0x402e0027, 0x94221916, 0x2ac1851c, 0x1f0b1c14, 0x0019059a, 0x82271314, 0xcd332668, 0xed32dc32, 0x206c8232, 0x20cd83de, 0x90728310,
		0x900720d0, 0x11ca25e1, 0x06161b20, 0x20097c46, 0x0e7c46d9, 0x467b0221, 0x1826066d, 0x2c282919, 0x7f46381c, 0x2511890a, 0x02000000, 0xa7822a00,
		0xa786c920, 0x14402a22, 0x1420a782, 0x942ba882, 0x00140800, 0x05191327, 0x830b1f9a, 0x82fd20a5, 0x83cd20a5, 0x39fd22a5, 0x151641de, 0x9d111d47,
		0x013022a2, 0x24a282f1, 0x28021216, 0x47a28317, 0x118d0822, 0x003ba282, 0x00720001, 0x018201ad, 0x001300cb, 0x0a00b30d, 0x2f00050f, 0xcd2f01cd,
		0x56013031, 0x21080ef2, 0x23138201, 0x32201f33, 0x23131323, 0x331f2032, 0x3c011323, 0x1727341d, 0x1d342717, 0x1728341c, 0x9f432817, 0x00452805,
		0x01af01ec, 0x82030032, 0x0301214f, 0x4f860682, 0x1521132c, 0x6a014521, 0x320196fe, 0x77820046, 0x27820020, 0x2786f420, 0x86020321, 0x312f2327,
		0x27821130, 0xfef40123, 0x8226840c, 0x02703727, 0x02840124, 0x001b0091, 0x1811b637, 0x4c00100b, 0xe0ffb802, 0x09831640, 0x002f1b30, 0x0002003f,
		0x1b1b0e0d, 0x05180a13, 0x4d4b0d0d, 0xdccd2205, 0x054d4bcd, 0xc7825d20, 0x4b2b2b21, 0x2322074c, 0x4a4b0622, 0x32333308, 0x84013736, 0x1e160f03,
		0x0b230d13, 0x180d101a, 0x0d832b06, 0x0d851220, 0x0206192d, 0x181c0b7b, 0x0e050e11, 0x83170e1a, 0x830f2009, 0x82002009, 0x1241086c, 0xdc016501,
		0x07006b02, 0x53002400, 0x1e232840, 0x1608241d, 0x0d091d16, 0x010f8014, 0x261d180f, 0x06050201, 0x17172325, 0x02151509, 0x16590705, 0x0f0f0808,
		0x2f00041e, 0x33113333, 0xcd3f332f, 0x82078232, 0x01760802, 0xddddd610, 0x32d610cd, 0xcd325ddc, 0x11391232, 0xcd103333, 0x13303132, 0x23152315,
		0x05352335, 0x15030e27, 0x37033e23, 0x33371733, 0x2317031e, 0x27022e34, 0x3a40cc07, 0x27340140, 0x01010202, 0x0706033a, 0x2c360507, 0x0705362f,
		0x3a030506, 0x01020101, 0x326b022a, 0xc132d4d4, 0x393c1474, 0x4a32042c, 0x881b333c, 0x3c341b88, 0x2c04314a, 0x74143c39, 0x5f56ffff, 0x02480805,
		0x002602b2, 0x01000056, 0x0a5f0106, 0x40100000, 0x280a010b, 0x501b222c, 0x4f2d0901, 0x00342b2b, 0x009f0001, 0x01640138, 0x000500c3, 0x020f4021,
		0x000c0b10, 0x0405024c, 0x04010300, 0x19000200, 0x01cdcd2f, 0xcd332f18, 0x3124ba82, 0x27372b30, 0x172d0182, 0x63633ad9, 0x20388b3a, 0xc51fa6a6,
		0x33008200, 0xff1f0003, 0x01de01f5, 0x002700db, 0x0042003b, 0x2200b993, 0x2105417d, 0x5f60b822, 0x831a2005, 0x05a55607, 0x0cb3e824, 0x0f834d00,
		0x0b40402c, 0x10114d00, 0x4c000b09, 0x0a82100b, 0x180b2e08, 0x4c000a09, 0x1f420616, 0x0e2d2d82, 0x001b823c, 0x37441b00, 0x1f430e82, 0x24424286,
		0x19883f16, 0x13883250, 0x09882850, 0x06272751, 0x05ff5424, 0x2f323222, 0x20056245, 0x06217032, 0xce10ed24, 0x126f2f32, 0x18322005, 0x200b7e41,
		0x05484c25, 0x0c0e4018, 0x3636172a, 0x14153233, 0x14230714, 0x21053d58, 0x346e3205, 0x22232405, 0x8215020e, 0x37830813, 0x22232634, 0xd1011506,
		0x23162e14, 0x2e11143c, 0x1f2f212a, 0x301e0f0f, 0x0e362521, 0x791d3012, 0x150bb001, 0x1e0d1621, 0x0fe3fe17, 0x06050d14, 0x0f10170e, 0x07060d16,
		0x1afb170f, 0x0f1d1914, 0x33270c0e, 0x452a2c2e, 0x572d2e58, 0x302a2944, 0x06ec2b2f, 0x351c090e, 0x0e081929, 0x3c2f1c17, 0x313f2020, 0x3d2e1d1f,
		0x323e211f, 0x453bd71e, 0x00003947, 0x00ffff00, 0x0100000d, 0x021a03e8, 0x823c0026, 0x00073f09, 0x00020083, 0x4017008b, 0x01010210, 0x0c042513,
		0x1d040250, 0x1104014f, 0x2b2b2b4f, 0x33823434, 0xb6261f82, 0x3c015bff, 0x3b82d101, 0x21001937, 0x910b0f40, 0x94110000, 0x1a1b1717, 0x0e9a1405,
		0x2f2f000d, 0x595518fd, 0x34372d0b, 0x3337023e, 0x1515031e, 0x16321323, 0x36058057, 0xcc363435, 0x03070403, 0x05060339, 0x1c2d5a02, 0x1b1c2727,
		0x18032828, 0x290a5755, 0x1f257602, 0x1f24241f, 0x7383251f, 0x31000132, 0xc2019fff, 0x23006b02, 0x00b96000, 0xb3c8ff16, 0x28056d63, 0x000eb3e0,
		0xffb8114d, 0x065f63d0, 0x2040e822, 0x23081082, 0x057f1e08, 0x0b002121, 0x14251b0b, 0x1a240082, 0x1e89171a, 0x0c0c2021, 0x0805880f, 0xdd2f0006,
		0x2f32ed32, 0x01230585, 0x57edd610, 0x2b220d7c, 0xb083132b, 0x0a965318, 0x08083447, 0x06061746, 0x35231507, 0x1e312626, 0x4a2c4b36, 0x121f361b,
		0x241c3621, 0x631a2e3f, 0x233a2050, 0x223c1e0c, 0x016f5c4a, 0x3a513504, 0x7c7f0622, 0x450a0902, 0x2713070c, 0x4f532b3f, 0x0b440c08, 0x7e7c020a,
		0x0100740d, 0x2c06c777, 0x00220076, 0x1f00b96a, 0x12b3f0ff, 0x059c5b00, 0x07841120, 0x3140f02e, 0x144d0010, 0x000c0b10, 0x0a18144c, 0x2a080a83,
		0x1a4d0009, 0x0801011a, 0x91000324, 0x230f110e, 0x9b1d1b1b, 0x970e0317, 0x17111100, 0x0a97075a, 0xed3f0060, 0x332f393f, 0x821032ed, 0x100122da,
		0x48e283d6, 0xb5490503, 0x05545807, 0x21070629, 0x36362115, 0x4d233535, 0x23210bd6, 0x08e38222, 0xaaaad27a, 0x03010707, 0x0f0aa0fe, 0x321c5353,
		0x35272c47, 0x382d1419, 0x0f1d2718, 0x07434d01, 0x472d622d, 0x0d407d40, 0x57424a43, 0x0b0d1432, 0x220e1647, 0x00002b39, 0x26000200, 0xcf016100,
		0x1c000a02, 0x53002800, 0x19042340, 0x1a1a0319, 0x13130a00, 0x1d12120b, 0x2900230e, 0x131a1a12, 0x0b161919, 0x040a0303, 0x26072004, 0xcd2f0016,
		0x2f33cddc, 0x2f193333, 0x18331133, 0x01230885, 0x92d61018, 0x30313e16, 0x27373413, 0x33361737, 0x17371732, 0x14151607, 0x07170706, 0x22230627,
		0x37270727, 0x05715c26, 0x2e05d648, 0x3341194e, 0x33342b42, 0x4334432b, 0x820d0d1a, 0x332b2d05, 0x33422936, 0x15011941, 0x3e2b2b3e, 0x013e0383,
		0x42283736, 0x1a1a4333, 0x28423343, 0x142e1d37, 0x19423442, 0x41344219, 0x3c333828, 0x0382333c, 0x0120d382, 0x08051743, 0x006b023d, 0x4076001e,
		0x1d1c183e, 0x120f1216, 0x14161378, 0x19131613, 0x0801731d, 0x780c0f0c, 0x0b14080b, 0x02060b08, 0x20010105, 0x13120f1f, 0x79051941, 0x080f1608,
		0x0479011d, 0x8208041a, 0x0b0c2d01, 0x00420041, 0x39333f3f, 0x112f2f39, 0x8305a550, 0x333f2c05, 0x12112f01, 0xcd332f39, 0x5787dc32, 0xfd20062c,
		0xcd250a89, 0x33303132, 0x061f4d35, 0xfb6b2620, 0x06a7490c, 0xd2152b08, 0x7a919191, 0x5b265731, 0x27294c20, 0x285b2049, 0x907b3156, 0x3f5f9090,
		0x9b4e405b, 0x408b4649, 0x4b468b40, 0x5b404e99, 0xcf825f3f, 0x53000221, 0x0736095f, 0x0c401d00, 0x07910106, 0x08090000, 0x03000407, 0x2fcd2f00,
		0x561801cd, 0x372408ab, 0x11231133, 0x28056e53, 0xfeb14d4d, 0xfe6003aa, 0x364282aa, 0x44000200, 0xaf019fff, 0x38007902, 0x4b014a00, 0x122047b5,
		0x5b3a4d00, 0x078206f4, 0x0db3f025, 0x82334d00, 0x0bb4240f, 0x824c000c, 0xb4e02a08, 0x4c000a09, 0xd8ffb830, 0x822982b3, 0xb3e82407, 0x844d0010,
		0x8229820f, 0xb3d02207, 0x300f840c, 0x000bb3e0, 0xffb82f4d, 0x0011b3e0, 0xffb82e4d, 0x200783d0, 0x82378328, 0x2107840f, 0x8e65000f, 0x840d2005,
		0x83e02007, 0x86272037, 0xb8242a2f, 0x7240f8ff, 0x164d000e, 0x22458218, 0x830a2016, 0x00092509, 0x1218134d, 0x20280482, 0x4c001110, 0x0d0c2813,
		0x1f830582, 0x15830b20, 0x82200b21, 0x100b2757, 0x0b4d000f, 0x04820d10, 0x820c1821, 0x0534087e, 0x45323276, 0x1b1b2a76, 0x22124c2a, 0x3c151576,
		0x38380d76, 0x08010d00, 0x4a124b0d, 0x1f354a08, 0x4125412f, 0x03000018, 0x1c1c357c, 0x00187c1f, 0x2f32ed2f, 0x11260383, 0x33113939, 0x05831211,
		0x55100121, 0xed2105ec, 0x46188233, 0x0983051e, 0x200d384d, 0x2e00902b, 0x33161617, 0x26343532, 0x35032e27, 0x50023e34, 0x172e08c6, 0x23262607,
		0x14150622, 0x031e1716, 0x40181415, 0x2325070f, 0x13272622, 0x08168206, 0x17021e28, 0x35363617, 0x27022e34, 0x32401b5a, 0x21393065, 0x0f192c39,
		0x160d1c17, 0x2e4e571a, 0x1613184e, 0x32232f3d, 0x1683322c, 0x1b160e32, 0x5f201a0d, 0x174d3c58, 0x15201a84, 0x111d3224, 0x46080682, 0x011a2f23,
		0x203e110b, 0x190b1323, 0x17243223, 0x08192128, 0x3e1e2e12, 0x45081148, 0x1e1d1208, 0x0b10221f, 0x24312419, 0x1a212716, 0x21321308, 0x0b134443,
		0x2d11b801, 0x1820171b, 0x11060a12, 0x1f171c2c, 0x420a1216, 0x713a051f, 0x83012602, 0x0b008f02, 0x25001700, 0xff1500b9, 0x0f1040c0, 0x0f154812,
		0x06824003, 0x12090333, 0x00000c06, 0x32cd322f, 0x2bcd2f01, 0x312bcdde, 0x0b386530, 0x8f4c3320, 0x14152b07, 0x2014a506, 0x1f151420, 0x0382951f,
		0x03821520, 0x1e260229, 0x1d1d1717, 0x871e1717, 0x00003e07, 0xff220003, 0x01d201f5, 0x001300db, 0x01450031, 0x1043b502, 0x394d0010, 0x40e8ffb8,
		0x20088228, 0x2a0d8335, 0x000f181f, 0x0b201f4d, 0x831a4d00, 0x08192104, 0x11210e82, 0x26048330, 0x000c0b20, 0x46b80d4c, 0x07820539, 0x83b4e021,
		0xb80c2b10, 0x11b3f8ff, 0xb8074d00, 0x9a69d8ff, 0x0cb32107, 0x40210f85, 0x21468218, 0x3c822803, 0x0d180326, 0x20034d00, 0x03211782, 0x20138228,
		0x2072820a, 0x068972b3, 0x820e4021, 0x1800211a, 0x00200d82, 0x0f202483, 0x16221a83, 0x07824d00, 0x2b40f022, 0x05211582, 0x210d8218, 0x09821005,
		0x24242308, 0x3c960014, 0x1c962b47, 0x4632960a, 0x0f17982e, 0x285c4198, 0x98052198, 0x3701374f, 0xfd5d2f00, 0x4418edde, 0xed27088f, 0xcefdd610,
		0x71002f32, 0x5342087c, 0x0f521814, 0x4807200f, 0x4e420d84, 0x32332508, 0x34253736, 0x07b05718, 0x29058762, 0x2d1b9801, 0x381e1e38, 0x07841b2d,
		0x2c392608, 0x2511511b, 0x1c2b1d11, 0x2b1c0e0e, 0x1123101e, 0x09160b14, 0x1e211b20, 0xfe0b1709, 0x4e3d26ec, 0x3c4e2828, 0x2c078325, 0x253c4d29,
		0x2f4730e7, 0x472f1818, 0x0807852e, 0x08404623, 0x2d231508, 0x242e1818, 0x36080516, 0x19280305, 0x05042520, 0x3d5c3d3a, 0x5b3d1e1e, 0x3d5b3d3c,
		0x05276c1f, 0x26017634, 0x76028001, 0x2d000e00, 0x1b407700, 0x00151825, 0x4f6b1b4d, 0x181b3208, 0x184d000e, 0x00100e20, 0xffb8114c, 0x0010b3c8,
		0x2007824d, 0x06ec47e8, 0xfc47d820, 0xe0320806, 0x0d0b1e40, 0x04214c00, 0x2b2b2f12, 0x072e190c, 0x1e301e20, 0x1e031e40, 0x16000f1e, 0x5a0f275e,
		0x3fcd3f00, 0x2f3911cd, 0x1001cd5d, 0x2f33cdd6, 0xb94fde10, 0x06894305, 0xbb6e0120, 0x1516240e, 0x4e060615, 0x3323069d, 0x6e171632, 0x74080aba,
		0x26140301, 0x0e1e0a05, 0x101a1f0f, 0x3a491f2a, 0x3b254816, 0x3328174c, 0x131d0d1d, 0x171d1005, 0x09123015, 0x5d013611, 0x02590202, 0x130a0402,
		0x01171a0f, 0xc8384419, 0x38300705, 0x0b18271c, 0x0d020202, 0x050d151b, 0x08053806, 0x02000000, 0x4f003f00, 0xae019d01, 0x0b000500, 0x19403a00,
		0x08400b07, 0x0006090a, 0x40050180, 0x03800402, 0x07050b00, 0x380f8201, 0x2f190003, 0xcd333333, 0x0132cd32, 0x1a332f18, 0xcd1a32dd, 0xdc101a32,
		0x21088432, 0x83503031, 0x32058505, 0x5434773f, 0x783e3250, 0x32505333, 0x951bb0fe, 0x84af1f90, 0x306f8205, 0x00290001, 0x01c2012b, 0x0005005b,
		0x0003b511, 0x05254d04, 0x01cd2508, 0x31cddd2f, 0x23110130, 0x01352135, 0xaefe47c2, 0xd0fe5b01, 0xffff46ea, 0xd7008c00, 0x25016801, 0x10000602,
		0x04203f82, 0x2f0a7343, 0x003a0027, 0x40720145, 0x1310380b, 0x08374d00, 0x30210482, 0x05cc48b8, 0xe8240782, 0x4d0011b3, 0x40380783, 0x4d000e0f,
		0x12110826, 0x10254c00, 0x1c4d0010, 0xb3f8ffb8, 0x1b4d0012, 0x40252b82, 0x4d001015, 0x27158317, 0x14131011, 0x28114c00, 0x21069443, 0x0e83b4e8,
		0x25059543, 0x074c000d, 0x1185ffb8, 0xb3230883, 0x824d000d, 0x40e02207, 0x272c8315, 0x00141803, 0x1320034d, 0x3c840482, 0x2a821120, 0x6016b321,
		0x0e2006e7, 0x07210882, 0x21048218, 0x04821003, 0xffb80a26, 0x000fb3e0, 0x29055d67, 0x4d000d09, 0x000f2000, 0x30820f4d, 0x15304026, 0x18054d00,
		0x3a340482, 0x3301335f, 0x01364b37, 0x3f963f36, 0x40310131, 0x40481c19, 0x00220782, 0x2f820d20, 0x471e962e, 0x3096293b, 0xb82a012a, 0x2940c0ff,
		0x2a351b82, 0x1430960a, 0x33461401, 0x3a013a3f, 0x013b3098, 0x362e3b3b, 0x2c2082df, 0x4623980f, 0x052e9842, 0x01194f98, 0x07cc4319, 0x325dce39,
		0x712f3911, 0x013271ed, 0xfd72d610, 0xed722bde, 0xfdd61032, 0x825dde2b, 0x5dd62c09, 0x3271c532, 0x012b2b00, 0x542b2b2b, 0xe85c058c, 0x0fe54315,
		0x330fc943, 0x35231537, 0x32333636, 0x07141516, 0x23171616, 0x27272626, 0x4309aa53, 0xfe2111e7, 0x0fcd438a, 0x0e36ba37, 0x37391322, 0x0d1a0c28,
		0x0a140d39, 0x1a1b1224, 0x0b061120, 0x0fe54305, 0xcf432f20, 0x1022080e, 0x0504ee4d, 0x17302a2c, 0x181a2f11, 0x0e321025, 0x010d1417, 0x00000001,
		0x027b0001, 0x0279013b, 0x5818007b, 0x7b25136b, 0x7b02fefe, 0x3c268240, 0x7d000200, 0x7701bd01, 0x1300b502, 0x39001f00, 0xff1200b9, 0x081140e0,
		0x0c4c000b, 0x20058320, 0x21058408, 0x1582b802, 0x0f830c20, 0x0a140031, 0x1d170f1a, 0xdd2f0005, 0x2f01cdde, 0x45cddecd, 0x69500517, 0x0c5c670f,
		0x23147728, 0x2d19192d, 0x07871423, 0x1b263c24, 0x0383261b, 0x1d390229, 0x1111202e, 0x871d2e20, 0x24202307, 0x03822024, 0x2e209b85, 0xc73ec882,
		0x0b002a02, 0x33000f00, 0x0c0c1740, 0x0d0d0a0b, 0x01070406, 0x11100a0a, 0x045b0f0c, 0x59180102, 0x3f2009e5, 0x20065249, 0x062954dd, 0x18312f21,
		0x230cec59, 0x21152115, 0x07f05918, 0x67fe992b, 0xb4b47601, 0xe9b4b446, 0x3a628247, 0x19017c00, 0x79027801, 0xe1002000, 0xff2000b9, 0x0014b3e8,
		0xffb8204d, 0x8413b3f0, 0xb3e82207, 0x22078412, 0x8411b3e0, 0xb3d82207, 0x22078410, 0x840fb3e0, 0xb4d82507, 0x4c000e0c, 0xd0273082, 0x000b2740,
		0x82101c4d, 0x10102716, 0x0f4d0012, 0x04821318, 0x00111026, 0x13200e4d, 0x18200482, 0x0d201382, 0x12280e83, 0xb3e0ffb8, 0x114d001a, 0x1b230783,
		0x83104d00, 0x200f826c, 0x250f860f, 0xe8ffb80e, 0x10822840, 0x19200425, 0x83034d00, 0x18022104, 0x13370982, 0x09090096, 0x1b1b0b00, 0x1a0b9608,
		0x1e98151a, 0x0b98085a, 0x6d3f005f, 0x2f290524, 0x102f33ed, 0x102f32cd, 0x0a3d78ed, 0x340fba5f, 0x020e1401, 0x07060607, 0x26231533, 0x3637023e,
		0x23343536, 0x08128222, 0x36362755, 0x01163233, 0x261d116a, 0x021e0f15, 0x0e03eea6, 0x1e12231a, 0x1b0f3726, 0x20051016, 0x3e283d10, 0x1316023b,
		0x12242323, 0x390b1d0d, 0x1f262d1e, 0x152c1a10, 0x0c0b082d, 0x1f102c04, 0x01000033, 0x12017e00, 0x79027601, 0xf8002b00, 0x1b2024b5, 0x82234d00,
		0x0bb425c7, 0x1e4c0010, 0xb3200882, 0x1c201082, 0xb4240782, 0x4c001411, 0xe0230882, 0x820e2840, 0x081b271a, 0x184d0024, 0x04821718, 0x00161025,
		0x82080e4d, 0x180521f6, 0x05212b82, 0x20098210, 0x2d098328, 0xf8ffb818, 0x4d0018b3, 0xd8ffb817, 0x1a823c40, 0x15831520, 0x1718152c, 0x054c0018,
		0x4d001918, 0x1d821005, 0x43830520, 0x101f2908, 0x22401d96, 0x401d482d, 0x1d48201a, 0x2d229603, 0x09281717, 0x091f2809, 0x1a0a0a98, 0xc0ffb829,
		0x001c2340, 0x1b40294d, 0x38210482, 0x2104821a, 0x04821940, 0x98002926, 0x40166225, 0x162b1982, 0x1a981316, 0xed3f005a, 0x842b2f32, 0x2b2b3604,
		0x2f39112b, 0x2f0139ed, 0x33112f33, 0xedde102f, 0xed2b2bd4, 0x16624132, 0x36321322, 0x16335718, 0x67051d44, 0x4508090f, 0x102330e2, 0x1113241b,
		0x161b0d16, 0x181a210f, 0x0e170f29, 0x36411e3d, 0x44242031, 0x10391c4f, 0x012c140d, 0x0f171d4a, 0x33060e15, 0x0e120b05, 0x07111316, 0x34140a31,
		0x0a1c2b2a, 0x3e2d202d, 0x0835080d, 0x0082000a, 0xaa000137, 0x52010602, 0x0300b502, 0x09401800, 0x02010003, 0x02800300, 0x0cbf7601, 0x07012008,
		0x52013727, 0x02722a7e, 0x8a257a80, 0x47000100, 0xad015bff, 0x1a00d001, 0x00b93e00, 0x18e0ff11, 0x3808864c, 0x100f1a40, 0x7f174c00, 0x0d091c00,
		0x010c007f, 0x191b0c08, 0x4b0b490c, 0x05965113, 0x97663f20, 0x07867507, 0x2f067e51, 0x15151616, 0x15331123, 0x33021e14, 0x37023e32, 0x2a069866,
		0x03112d29, 0x0b535301, 0x661e2919, 0x1133079c, 0x2e170f12, 0x75025c1a, 0x263c2bf3, 0x03020211, 0x85890101, 0x821c20c7, 0x02bf3993, 0x00120071,
		0x05114026, 0x0801020f, 0x14100002, 0x05051308, 0x04120d02, 0x2f35cf82, 0x012f33cd, 0xde10c610, 0x5d5ededd, 0x013031cd, 0x23110726, 0x0c611811,
		0x16330807, 0x01231117, 0x45292e79, 0x4625645d, 0x50233e63, 0x29024624, 0x30fd0406, 0x5c0a8f01, 0x3249315c, 0xfc0a0619, 0x00fffffa, 0x01b800b1,
		0x02510144, 0x82110007, 0x82c42078, 0x00012603, 0x0157ff9c, 0x3e798241, 0x4034001c, 0x1a031118, 0x140b1900, 0x00001e14, 0x081d1414, 0x0f1d1919,
		0x08010800, 0x822f0008, 0x33112176, 0x29054a4e, 0x3911012f, 0xdd33cc2f, 0x8982dd32, 0xff820520, 0x020e1422, 0x0808f871, 0x2734353b, 0x37033e27,
		0x01060633, 0x09171a10, 0x171a2315, 0x0b0a0b28, 0x25200f18, 0x0b0b0307, 0x0539020a, 0x1e0c2110, 0x13170a1d, 0x3305070d, 0x14140504, 0x1809020b,
		0x0b041318, 0x088f841d, 0x19017e23, 0x72027f01, 0x2e000e00, 0x05051740, 0x0e010e2f, 0x960a0b00, 0x000a0008, 0x055f0d98, 0x08010404, 0x005c1859,
		0x2f470809, 0x10cdfd32, 0x2f3271cd, 0x35133031, 0x27070606, 0x33373636, 0x23153311, 0x3214e735, 0x42221112, 0xfa592c18, 0x0dce5201, 0x0b310514,
		0xe0fe1725, 0x02003939, 0x25015900, 0x78029b01, 0x1f001300, 0x00b93b00, 0x45e8ff12, 0x182506fb, 0x4c000b08, 0x25058408, 0xe0ffb802, 0x0f830e40,
		0x1a00142e, 0x5a0f170a, 0x005e051d, 0xcd3fcd3f, 0x560bea60, 0xfd450e67, 0x189b280c, 0x23233b2b, 0x87182b3b, 0x42220807, 0x322d2e31, 0x312e2e31,
		0x3e27cf01, 0x2d18182d, 0x3e27273e, 0x2c18182c, 0x3a33273e, 0x3c32333a, 0x9b82003c, 0x4f005524, 0xa749b501, 0x40363606, 0x08070b17, 0x04400105,
		0x09000302, 0x080a8006, 0x07010b05, 0x490b8206, 0xa04910a5, 0xcd102b06, 0x25303132, 0x27372707, 0x05840737, 0x78b5012d, 0x32505434, 0x5434773f,
		0x49ff3251, 0x04200ca4, 0x4408f882, 0x02dd01fc, 0x000a0072, 0x001c0017, 0x40630020, 0x1e1f1d34, 0x1d209c1f, 0x201d2014, 0x1818171e, 0x12120f0c,
		0x050e141b, 0x1f000603, 0x1e1d5920, 0x14130f67, 0x111b1b0c, 0x11651718, 0x00610667, 0x03070a0a, 0x068e4160, 0x333f3f36, 0x332f3912, 0x3f32cd33,
		0x01333f33, 0xcd32dc2f, 0x3932cd2f, 0x33260382, 0x2f2f3311, 0x4f7b2b87, 0x36362b05, 0x23153337, 0x07060635, 0x08821501, 0x23210a82, 0x20138235,
		0x08108217, 0x23053363, 0x22123301, 0x3b281830, 0x01122014, 0x3b242496, 0x1f301a81, 0x0f221518, 0x46e1fe46, 0x02467b01, 0x171c0e31, 0x0e0ba8fa,
		0x98f9fe06, 0x29303032, 0x2b284b2e, 0x661a381b, 0x03006b02, 0x00001100, 0x7202e201, 0x29001e00, 0xb8002d00, 0xff1e00b9, 0x0016b3f0, 0xffb81c4d,
		0x0015b3e0, 0xffb81b4d, 0x260788d8, 0x184d0013, 0x83e8ffb8, 0x2207820f, 0x8614b3e0, 0x2817850f, 0x0e4440e0, 0x144c0012, 0x27168230, 0x17161008,
		0x10074c00, 0x3b080a82, 0x2c2b2c2a, 0x142a2d9c, 0x2b2d2a2d, 0x1f252224, 0x0019040c, 0x051e1900, 0x2c051313, 0x2b2a592d, 0x1f612567, 0x22262929,
		0x160f1260, 0x5b031e66, 0x3fcd3f00, 0x333f32cd, 0x3fcd2f33, 0x24051541, 0xcd102f33, 0x2404832f, 0x32dc2fcd, 0x081641cd, 0x2b0bae46, 0x26231525,
		0x36343534, 0x36363737, 0x0b7d5c18, 0x14151626, 0x0107020e, 0x08094041, 0x01231346, 0xc5e20133, 0x161a2801, 0x10171218, 0x200c200f, 0x2f1a3411,
		0x28261a2f, 0x23b4fe0d, 0x3b29182f, 0x2e122114, 0x467b0146, 0x11033232, 0x10232003, 0x0e190e0f, 0x0d0d1011, 0x32131328, 0x1c251a20, 0xff010c18,
		0x08075241, 0x02fffd2b, 0x0000006b, 0x00150004, 0x02df0100, 0x000c0079, 0x003c0037, 0xb9070140, 0xe0ff3200, 0x001514b4, 0xffb8324c, 0x0013b3e8,
		0x2207824d, 0x8412b3e0, 0xb4e82307, 0x18841110, 0x0fb3d822, 0xb3241085, 0x2e4d000e, 0xb4282882, 0x4c00100e, 0xd8ffb82d, 0x2b231083, 0x83f8ffb8,
		0xb8292720, 0x18b3e0ff, 0x07824d00, 0x17b3e822, 0xd8220784, 0x078416b3, 0x13b4e025, 0x834c0015, 0x404a0818, 0x00121148, 0x3e3f3d4c, 0x3d409c3f,
		0x403d4014, 0x2b1c2e3e, 0x3730132b, 0x17372323, 0x380c3717, 0x07040138, 0x03093b07, 0x3d59403f, 0x172e673e, 0x0d261818, 0x6435100d, 0x261f2222,
		0x09080463, 0x063b3b01, 0x06650c38, 0x96420067, 0x32cd230a, 0x03823f2f, 0x2f391124, 0x8d4139cd, 0x099f4205, 0x2305e446, 0x2f33cddd, 0xac422182,
		0x0e444807, 0xb0422520, 0x1625220b, 0x06ec4a16, 0x4a352321, 0x273309f5, 0x32333636, 0x1415021e, 0x15160706, 0x23020e14, 0x42052722, 0x012107d9,
		0x06d042b9, 0xbefe2f08, 0x1614210b, 0x0c262621, 0x191c1a16, 0x0c240e0e, 0x1a310f13, 0x0f192011, 0x0c2b100f, 0x2e1e2a1a, 0x15690125, 0xfe460f22,
		0x7b0146e6, 0xe942fa46, 0xb4260807, 0x110d0805, 0x0b320c15, 0x0a090f12, 0x0d092b05, 0x12190f07, 0x140b1e0f, 0x171d0e2d, 0x1bae0e0e, 0x02621a38,
		0x0082006b, 0x5c000238, 0x9a0156ff, 0x1d00d101, 0x84002900, 0x181b1040, 0x144d0012, 0x04820a20, 0x18092821, 0x2214755d, 0x860db3e0, 0x05955e17,
		0x0a40e827, 0x4c000d0c, 0x0838830f, 0xffb80823, 0x111b40e8, 0x95084d00, 0x911d1616, 0x000e0e00, 0x27942100, 0x1d2a2b27, 0x0b1e9a24, 0x2f00119b,
		0x088c57ed, 0x332f322c, 0x32ed102f, 0x312bed2f, 0x594c0030, 0x17252909, 0x15040e14, 0x32331614, 0x220aff79, 0x57373504, 0x012b0aaa, 0x1f15013d,
		0x30151f25, 0x18393b2e, 0x3c140856, 0x2c1d14f3, 0x26222126, 0x1e2e2617, 0x1c141040, 0x1e18342b, 0x2824272e, 0x25de1e2d, 0x06c5571f, 0x00ffff2d,
		0x01000009, 0x023e03eb, 0x82240026, 0x00073a09, 0x00040043, 0x40100089, 0x1a00020b, 0x500f0418, 0x4f190902, 0x00342b2b, 0x222b9200, 0x86fdff8f,
		0x1901222b, 0x202b8417, 0x202b8e18, 0x2257883a, 0x5f000069, 0x578205eb, 0x0a091a22, 0x1c205792, 0x75202b88, 0x25202b89, 0x24205785, 0x1a20578e,
		0x83202b88, 0x23082b84, 0x1022402c, 0x02261020, 0x30012630, 0x50204020, 0xc0209020, 0xe020d020, 0x0820f020, 0x23090320, 0x1709024f, 0x01254282,
		0x715d5d10, 0x20318231, 0x36f78503, 0x1a00ed02, 0x2d002100, 0x00b99f00, 0x40d8ff11, 0x000f085d, 0x83280d4c, 0x12550805, 0x9d0c229d, 0x1e022828,
		0x03091b1c, 0x0478031b, 0x04041409, 0x1b1f0109, 0x001b0015, 0x14151a78, 0x041b151a, 0x1a9f1a8f, 0x5f1a4f02, 0xaf1a7f1a, 0xef1abf1a, 0x071aff1a,
		0x2e042f1a, 0x2b25a30f, 0x1f790201, 0x1b041e1e, 0x412b0915, 0x03421a00, 0x3f004204, 0x22018333, 0x58123333, 0xde2b0515, 0xc61001ed, 0x715dde10,
		0x18873911, 0x2f135755, 0x2f183301, 0x31eddeed, 0x212b2b30, 0x23072327, 0x220c455f, 0x181e0706, 0x21085b55, 0xa6743437, 0x2594350a, 0x105424ee,
		0x1a33302b, 0x2537140e, 0x0e133725, 0x292f3319, 0x076e5518, 0x141b1a24, 0x03831b14, 0xa2a22108, 0x969f9b3f, 0x17250c3b, 0x2a31312a, 0x3b0b2616,
		0x3e9ba097, 0xa63f2302, 0xaba75a58, 0x171a1a17, 0x00210382, 0x08ec8202, 0xe201002d, 0x11006b02, 0x6a001600, 0x15133840, 0x03070302, 0x04780312,
		0x04041407, 0x0f0b1207, 0x04000073, 0x09090d0d, 0x17041810, 0x820b790e, 0x161523f6, 0x01820b15, 0x0a120f25, 0x82410779, 0x790f22f7, 0x20fb8200,
		0x22fb82ed, 0x571232ed, 0x10200874, 0xce2afd84, 0x2f322f32, 0xed2f3911, 0x966e3332, 0xc4102805, 0x31c40ec4, 0x82352130, 0x123622f0, 0x075a5737,
		0x15333a08, 0x07060603, 0x76070133, 0x5c2d5125, 0x6980fa37, 0x1cdb8d69, 0xa2641533, 0x3101aea2, 0x46be468c, 0x360246db, 0x004aae58, 0x2e000100,
		0xcc0157ff, 0x37007902, 0x00b93a01, 0x05a25236, 0x55543620, 0xb8352906, 0x11b4e8ff, 0x2f4c0012, 0x82061751, 0xb3e82407, 0x834d0011, 0x0bb42d07,
		0x2a4c000c, 0xb3f8ffb8, 0x294d0010, 0x08822987, 0x0cb3f022, 0xb3241085, 0x244d000b, 0xb3211882, 0x20078412, 0x283983e0, 0xe0ffb823, 0x00100fb4,
		0x2708824c, 0x0e1540c8, 0x081a4d00, 0x19286183, 0x000e0d28, 0x0810194c, 0x2a052b44, 0x001514b4, 0xffb8054c, 0x8413b3d8, 0x83e02010, 0x460f8243,
		0x08820513, 0x0fb3d02d, 0xb8024d00, 0x13b4c8ff, 0x824c0014, 0x83d02008, 0x08078221, 0x3240d833, 0x4c00110f, 0x40033011, 0x03035003, 0x17003703,
		0x1c14140b, 0x39352424, 0x381c762c, 0x38141400, 0x3808400f, 0x31343480, 0x4637177c, 0x7c272525, 0x068f6921, 0x32ed332d, 0xdc101a2f, 0x3912cd1a,
		0x5b01cd2f, 0xcc250958, 0xd532dd33, 0x06994f5d, 0x8310fc56, 0x13ad4a10, 0x37363622, 0x21050e57, 0x55183233, 0x17240fb4, 0x3d010706, 0x280fc54a,
		0x31060c04, 0x29213c53, 0xc7551846, 0x3a162212, 0x10dc4a4a, 0x0d1b0b27, 0x74502b05, 0xdc55184d, 0x21443311, 0x00000005, 0x5b00ffff, 0xcc010000,
		0x26023e03, 0xaf442800, 0x000e3306, 0xb9130089, 0xf1ff0100, 0x0d0f0940, 0x01500a00, 0x2e440e01, 0x222f9305, 0x441a008f, 0x012305b3, 0x840c0e04,
		0x440d202c, 0x5b85085b, 0x5b883a20, 0x12006924, 0x5b858b00, 0x0940f923, 0x205b9611, 0x202f881a, 0x2a2f8483, 0x0102b11a, 0x40f9ffb8, 0x82200e0d,
		0x0102265f, 0x01014f18, 0x05aa5d0c, 0x5920bf82, 0x9b20b582, 0x2c20bf84, 0x0520bf86, 0x01278f86, 0x02040d0f, 0x86090150, 0x222b92bc, 0x860a008f,
		0x0e0e222b, 0x892b840c, 0x835785bb, 0x455785bb, 0x0122086f, 0x57951100, 0x2b85b783, 0x31054345, 0x1015401e, 0x50155015, 0x041b6f1b, 0x15011baf,
		0xb9820902, 0x450c0921, 0x712b0536, 0x00020031, 0x01fbff12, 0x827102cc, 0x002430e5, 0x1d154060, 0x4d001228, 0x0011201d, 0x8218184d, 0x83182009,
		0xb8102809, 0x0db3e8ff, 0x82034d00, 0x1e402107, 0x1b3f0882, 0x23260076, 0x0b731321, 0x24250709, 0x0b217908, 0x7c1e160b, 0x7c16410e, 0x3f004205,
		0x45ed3fed, 0x0128050b, 0x33ced610, 0x10ce32fd, 0x2005ee44, 0x5200822b, 0x272b052e, 0x33352311, 0x32333635, 0x6d01021e, 0x44080518, 0x23263435,
		0x33150722, 0xcc012315, 0x39624729, 0x35353d3d, 0x62393d3d, 0xcefe2947, 0x2a0b180b, 0x5b182d41, 0x62121958, 0x56360162, 0x0f224b78, 0xff401901,
		0x784c220f, 0x0102bafe, 0x415d3b1b, 0xc403767e, 0x054b4240, 0x0000372a, 0x1c03bd01, 0x31002602, 0x07210982, 0x08774600, 0x20000129, 0x50100712,
		0x421f0801, 0x1d26081b, 0xd801f3ff, 0x2b823e03, 0xb7413220, 0x0102290d, 0x09002123, 0x22040250, 0x8f222b98, 0xb7410900, 0x0c022305, 0x2b842022,
		0x2b8e2120, 0x57883a20, 0x2208b741, 0x95250002, 0x85af8357, 0x22af8883, 0x852e0002, 0x05d56157, 0xffff0023, 0x20af8500, 0x2057881a, 0x29f28283,
		0x4017008b, 0x00020310, 0x84823422, 0x2c040326, 0x2004024f, 0x08094360, 0x46000127, 0xae015200, 0x0b00bb01, 0x10402d00, 0x0b090008, 0x03050206,
		0x06080509, 0x0200030b, 0x19332f00, 0xdc1832c5, 0x21058232, 0x0c8a1801, 0x25303132, 0x37270727, 0x37173727, 0x01170717, 0x3282827c, 0x52240287,
		0x83328383, 0x83220e85, 0x93820300, 0x01df2608, 0x008b02d8, 0x00230019, 0xb967012d, 0xf0ff2c00, 0x4d000cb3, 0xf8ffb82c, 0x000b2c40, 0x1138294d,
		0x18284d00, 0x20048313, 0x3004820f, 0x4d000e10, 0x00142027, 0x1108234d, 0x10224d00, 0x2004820c, 0x2d278208, 0xe0ffb81e, 0x4d0013b3, 0xd8ffb81d,
		0x1f821d40, 0x11101c27, 0x28184d00, 0x2004820d, 0x21248220, 0x0e822017, 0x0e181724, 0x8f424d00, 0x450b2007, 0x078206fe, 0x82b3e021, 0x22078217,
		0x820940d8, 0x1003212f, 0x2005bf5c, 0x208883d0, 0x82258327, 0x2007821d, 0x210f86e8, 0x6f82b3d8, 0xffb82626, 0x120940b8, 0x40207082, 0x75825882,
		0x1d40d027, 0x1c4d000c, 0x20128220, 0x2612831c, 0x0010281c, 0x8228174d, 0x830b201c, 0xb807237a, 0x3f83c8ff, 0xffb80625, 0x823140a8, 0x0a32081a,
		0x15141e1d, 0x28071509, 0x15161727, 0x78081608, 0x09141509, 0x1a090915, 0x162f0d76, 0x00762416, 0x2115162e, 0x0946127c, 0x057c2b08, 0xed3f0045,
		0x038332c6, 0xd6100124, 0x517933ed, 0x05214805, 0x82c40e21, 0x87102100, 0x5d520684, 0x05c0450a, 0x850e814b, 0x2b2b2614, 0x023e3413, 0x05a65f33,
		0x3407664b, 0x26372707, 0x26342526, 0x16160327, 0x25363233, 0x13171614, 0xf2531826, 0x385f0808, 0x1e3e152f, 0x3a21231f, 0x2e3e3152, 0x1e203d17,
		0x0b67011f, 0x270fbf0c, 0xfe464614, 0xbe0b06ed, 0x4515240f, 0x53360142, 0x1b274f7a, 0x293d1f2d, 0x7a53557b, 0x301c2650, 0x7928421f, 0x1f543255,
		0x0a0d76fe, 0x53307a82, 0x0c88011f, 0x0000820a, 0x00ffff00, 0x01f3ff30, 0x023e03c4, 0x43380026, 0x0020063f, 0x2a07b745, 0x1d0940fd, 0x5014041b,
		0x451c0601, 0x2f8f09b7, 0x23084343, 0x1a1c0d01, 0x1b202c84, 0x85084343, 0x883a202b, 0x0843435b, 0x1f000122, 0x8788588c, 0x2b881a20, 0x24081743,
		0x1c000102, 0x2658822e, 0x4f260602, 0x431a0601, 0x8f630817, 0x20bb8308, 0x89bb843c, 0x130c288b, 0x500c0411, 0x85120401, 0x0200238b, 0x21824900,
		0x6b02c731, 0x1e000f00, 0x15406f00, 0x0010101c, 0x8328184d, 0x0f182104, 0x102c0982, 0x094d000e, 0xb3e8ffb8, 0x064d0008, 0x82064748, 0xae721807,
		0x1f402108, 0x1a3f1882, 0x14200776, 0x00730d02, 0x200f100f, 0x0f08030f, 0x0d79141f, 0x7913420f, 0x00410002, 0x82eddd3f, 0x05f77902, 0x60533220,
		0x05eb4107, 0x15331322, 0x2c056258, 0x2323020e, 0x22132315, 0x33150722, 0x05d46432, 0x52492f08, 0x7c731e1f, 0x375b4023, 0x199c5237, 0x233a0e23,
		0x19172a3a, 0x6b023328, 0x585b0367, 0x1633503b, 0x01bf0180, 0x35200df9, 0x192b2129, 0xc682000a, 0xff47003a, 0x02dc01f5, 0x013f00b5, 0x3e00b935,
		0x0db3f0ff, 0xb83e4d00, 0x0cb3d8ff, 0xe0250784, 0x000b0ab4, 0x2010844c, 0x21108509, 0xbd820e40, 0x82083921, 0x1039251e, 0x314d000a, 0x0782e086,
		0x1840e027, 0x2a4d0011, 0x21418218, 0x04821025, 0x0b102425, 0x83234d00, 0x82102009, 0x0cb42424, 0x824c000e, 0xb3e02108, 0x07821582, 0x0ab3d824,
		0x07824d00, 0x08b4e024, 0x2a7e0009, 0x203d8205, 0x227a830d, 0x824d0010, 0x7ef82007, 0xe820063a, 0x0c219283, 0x069a54b8, 0xd0210882, 0x202082b3,
		0x21108203, 0x4a824140, 0x17174b08, 0x40088227, 0x2f4d0009, 0x6f083f08, 0x08080308, 0x00822d0f, 0x480b0840, 0x82200000, 0x7f34410f, 0x08013500,
		0x2d004035, 0x200f0827, 0x08203b2d, 0x88301d08, 0x4a354d3b, 0x5112881d, 0x3fed3f00, 0x3912ed3f, 0x3912392f, 0x01833311, 0x2d057541, 0x33edde10,
		0x11ed2b2f, 0x2b5d2f33, 0x6b1832ed, 0x8a410f19, 0x20058405, 0x05475701, 0x2f08e37c, 0x3727022e, 0x3233031e, 0x2e343536, 0x36343504, 0x0808b350,
		0x2311159f, 0x023e3411, 0x021e3233, 0x160f9001, 0x0d0e0c1c, 0x282e281b, 0x1057521b, 0x05151d21, 0x1a14050e, 0x26290f1e, 0x2830281b, 0x15171e1b,
		0x2a282421, 0x2a17532d, 0x402e263d, 0x26021126, 0x1c212818, 0x0f15100d, 0x18171a14, 0x4c273323, 0x0808064d, 0x09034903, 0x26280609, 0x171b231b,
		0x241e271d, 0x28141730, 0x442d2617, 0x0113fe3c, 0x34492cef, 0x3428171d, 0x00ffff00, 0x01f5ff3a, 0x02b502b0, 0x00440026, 0x00060100, 0x00000043,
		0x020b4010, 0x1c323401, 0x0f025013, 0x2b2b4f33, 0x21279234, 0x2785128f, 0x31331b22, 0x32202784, 0xaf20278c, 0x69214f88, 0x21278509, 0x4f93360e,
		0x27889120, 0x77867520, 0x853f0521, 0x8c3e204f, 0x888f204f, 0x82832027, 0x40172727, 0x05020310, 0x78824533, 0x3d0f0326, 0x310f024f, 0x8806ad43,
		0x87b820a7, 0x6301212f, 0x14222f82, 0x2f820d40, 0x58833620, 0x0f02032a, 0x342b4f34, 0x0034342b, 0x0809b768, 0x42003421, 0xbb004b00, 0x18252b40,
		0x254d0010, 0x000e0d10, 0x0b18244c, 0x204c000c, 0x4d000d20, 0x820c1020, 0x0b203104, 0x101f4d00, 0x194d000e, 0x4d001218, 0xe8ffb80e, 0x22069360,
		0x831940e8, 0x4b27082a, 0x3e820c03, 0x41411a2a, 0x0b824322, 0x4d0b1212, 0x32228238, 0x40c0ffb8, 0x48161328, 0x4c223232, 0x0c278935, 0x82274b86,
		0x3b003501, 0x511d1a88, 0x880f1111, 0x48035117, 0x31500688, 0x00882e31, 0x2b064d7f, 0xed3f32ed, 0x333f2f32, 0x393911ed, 0x2705a072, 0x32c61001,
		0xed102b2f, 0x2208db68, 0x18333333, 0x20075144, 0x2300852b, 0x17163213, 0x2409ce68, 0x37323316, 0x055a7617, 0x530d6c60, 0x13230921, 0x6e150622,
		0x26280575, 0x37262726, 0x23022e34, 0x9b081182, 0x0f382c96, 0x811a2a10, 0x2934b901, 0x040b2520, 0x0d1c1813, 0x1b133321, 0x31211d38, 0x22111021,
		0x1d0c2131, 0x1626240c, 0x0909082a, 0x21213035, 0x2711201f, 0x020c0b0e, 0x0f09d114, 0x24170812, 0x1e22db01, 0x05ec221e, 0x4b480711, 0x09044616,
		0x14170508, 0x28191417, 0x371f1b33, 0x06051729, 0x0c402f17, 0x0c084406, 0x242afcfe, 0x0d10301e, 0x0b203b19, 0x1e31253e, 0x00463a0c, 0x31000100,
		0xc30157ff, 0x3700db01, 0x00b98c00, 0xb4e0ff2e, 0x4c000e0d, 0xe0ffb828, 0x4d000eb3, 0xe8270782, 0x000d0940, 0x4d18184d, 0xe02b0550, 0x00150fb4,
		0xffb8024c, 0x833040d8, 0x40112509, 0x02035003, 0x27061c4d, 0x3422221a, 0x1a822b39, 0x2b091c4d, 0x88303333, 0x23513717, 0x1f882623, 0x4d066a41,
		0xcd22191c, 0x1c4dd432, 0x16094d09, 0x18095258, 0x250e5860, 0x07060617, 0x0b4d2601, 0x070d2310, 0x4d186e5b, 0x222216bc, 0x0b4d2a46, 0x0e1e2411,
		0x186a770d, 0x2213ce4d, 0x47010b0c, 0x282a0553, 0xc701f5ff, 0x2602b502, 0xbb434800, 0xb9132e08, 0xffff0200, 0x23250940, 0x02500213, 0x05385100,
		0x00ffff22, 0xbf432b8f, 0x24182207, 0x20288422, 0x066f4323, 0xaf202785, 0x69215388, 0x05bf430d, 0x8a270f21, 0x204f8850, 0x2027888f, 0x27278283,
		0x03104017, 0x36240f02, 0x03265082, 0x024f2e00, 0x97432200, 0x82362009, 0x83c220ab, 0x0c0121ab, 0xdd21ab85, 0x05594d00, 0x0940d829, 0x0b011719,
		0x52020150, 0x5b82053c, 0x8f212b8f, 0x242b86e6, 0x180940e8, 0x202b8416, 0x21598217, 0x2b880034, 0x5786af82, 0x57876920, 0x0940db23, 0x8257941b,
		0x202b86b3, 0x4d2b8283, 0xdb2405ad, 0x2a180d40, 0x02265882, 0x014f2202, 0xfc471602, 0x00022208, 0x32b78237, 0x00b502cc, 0x00350022, 0x331040d0,
		0x4d000f18, 0x820e1033, 0x0d083104, 0xb82f4d00, 0x0fb3f0ff, 0xb82a4d00, 0x2840e8ff, 0x103b0882, 0x4d001018, 0x000a1810, 0x08280f4d, 0x0c4c0009,
		0x4d000920, 0x0008180c, 0x82200b4d, 0x100b2519, 0x074d000a, 0x0c823483, 0x40210783, 0x0825833e, 0x1e01214c, 0x001d1e04, 0x1a191900, 0x141d1d17,
		0x37048223, 0x360e822c, 0x00180117, 0x221a2122, 0x88291819, 0x10110011, 0x03112011, 0x11182208, 0x03221811, 0x314d1e1d, 0x00510988, 0x333fed3f,
		0x2f2f3917, 0x105d5e2f, 0x11cd10ed, 0x04843939, 0xd6100133, 0xedde10ed, 0x392f3232, 0x332f3339, 0x1133112f, 0x0b106d12, 0x22053644, 0x4a160701,
		0x2e2e0612, 0x36343502, 0x17163233, 0x07272626, 0x05823727, 0x16163729, 0x34033717, 0x52263526, 0xb35b055c, 0x015e0805, 0x271d60cc, 0x3b4c2c11,
		0x172d442d, 0x3a265360, 0x141c050e, 0x0f5c156b, 0x142e171f, 0x586e1a33, 0x17391901, 0x190d3438, 0x2d221825, 0x4b020a1a, 0x5a8d3121, 0x34536531,
		0x274c3e26, 0x0d1d7872, 0x251f4224, 0x1f112038, 0x2b0d3011, 0x8cfe2620, 0x1b081216, 0x1d475a16, 0x25182936, 0xd7424c3c, 0x00472a05, 0x02b00100,
		0x00260291, 0x22098251, 0x82750006, 0xb9132e16, 0xffff0100, 0x14220940, 0x01500500, 0x05404d02, 0x22068742, 0x82b502cc, 0x8452202b, 0x4643202b,
		0x0528066f, 0x00092123, 0x220e0250, 0x8b0ad742, 0x868f2027, 0x220d2227, 0x84278420, 0x204f8850, 0x204f88af, 0x06974669, 0x93250021, 0x85a3834f,
		0x07bf4677, 0x852e0021, 0x8c2d204f, 0x888f2077, 0x08bf464f, 0x34220022, 0x03257882, 0x024f2c0e, 0x08854d0e, 0x00032008, 0x0124002e, 0x00e901c7,
		0x000f0003, 0x4026001b, 0x04021010, 0x0a0a0316, 0x0d071c1d, 0x82131903, 0xdd2f2517, 0xde10cdde, 0x2d05c960, 0xcedd33ce, 0x13303133, 0x05211521,
		0x79180614, 0x112008f5, 0x2e2e0b8a, 0x67fe9901, 0x1a200601, 0x1b21211b, 0x0787201a, 0x462a0134, 0x24241884, 0x25251918, 0x25183301, 0x24191825,
		0x5d820024, 0xe0ff282a, 0xf001cc01, 0x24001a00, 0x9d278b82, 0xff2d00b9, 0x580fb4e8, 0xf027059b, 0x000e0f40, 0x8318234d, 0x1023210e, 0x1e200a82,
		0x2a06a758, 0xf0ffb814, 0x00084040, 0x8210074d, 0x19420804, 0x040e1e1f, 0x28011a0d, 0x0c040b29, 0x0d0d0c00, 0x3011821b, 0x2500001a, 0x1f2f0482,
		0x04291e28, 0x1688222c, 0x0b1a1a00, 0x0419010e, 0x2c511609, 0x0c0d0988, 0x0050090c, 0x332f333f, 0x123fed10, 0x08843917, 0x39171122, 0x2305004d,
		0xedde1033, 0x11201182, 0x03831882, 0x21086667, 0x83453737, 0x37172207, 0x08ca4217, 0x07272624, 0x04823401, 0x33161628, 0x14273632, 0x25821716,
		0x06222330, 0x1b172d2d, 0x2d4d381f, 0x2f2a3045, 0x0a82182e, 0x2e4e2608, 0x2a193a21, 0x09071c01, 0x15240eb5, 0x07fa443a, 0x250eb409, 0x04433915,
		0x3353203e, 0x233f5a37, 0x3f243924, 0x080a821f, 0x23405926, 0x01391113, 0x14321c08, 0x5b0a0cf5, 0x142e1f4e, 0x5b0b0cf4, 0xffff0000, 0xf6ff4400,
		0xb502ad01, 0x58002602, 0x2b0b8345, 0x40feff01, 0x07171909, 0x09015000, 0x8f08d744, 0x0683422b, 0x180e0123, 0x20288416, 0x06334217, 0xaf202785,
		0x83425388, 0x01012206, 0x88508a1b, 0x888f207b, 0x065b4227, 0x01010224, 0x50822a18, 0x22090225, 0x4409014f, 0x2f8207cc, 0x58ff2424, 0xab84cd01,
		0xab845c20, 0x000f8f2c, 0x0b401000, 0x21231401, 0xa8821520, 0x7f832220, 0x00020039, 0x015bff47, 0x00b502cc, 0x00250014, 0x231f407c, 0x4d001020,
		0x820f1823, 0x0e102404, 0x83184d00, 0x2818210e, 0x18200e82, 0x13290e83, 0xb4e8ffb8, 0x4c000a08, 0x23088202, 0x4d000ab3, 0xe0220782, 0x078409b3,
		0x40e82608, 0x4d00081e, 0x27008215, 0x7f080d1e, 0x08010a00, 0x881a260a, 0x0c0b5010, 0x214b0a4d, 0x00510588, 0x3f3fed3f, 0xb74a1833, 0x0dce4c08,
		0x252b2b23, 0x052e5f14, 0x18231521, 0x20085a50, 0x05aa4807, 0x11074908, 0x32331616, 0xcc01023e, 0x2f4a331b, 0x530e3825, 0x1a361d53, 0x1e35482a,
		0x2d211255, 0x1a2f1a1a, 0x211d360e, 0xe70e1e2f, 0x24405935, 0x03b70b12, 0x0ff60e4c, 0x5a3f210d, 0x2a412b3a, 0xfe111215, 0x1a160df3, 0x00003d2d,
		0x23081741, 0x0026028f, 0x35051741, 0x00000f83, 0x02104017, 0x35231001, 0x02501520, 0x014f2d09, 0xcb462109, 0x05335909, 0x83580620, 0x588a2008,
		0x172009af, 0x4b0f3359, 0x7b20055f, 0x2008bf4a, 0x0677448a, 0x4b310e21, 0x53850d0f, 0x53872820, 0x89610121, 0x291b2353, 0x84820f04, 0xef4e1720,
		0x20538508, 0x08e34a9d, 0x10292b83, 0x05020b40, 0x131c4335, 0x050e4b50, 0x00344f08, 0xff090002, 0x02f00159, 0x0022006b, 0x40750029, 0x2426163d,
		0x23171d23, 0x1d187817, 0x1d181814, 0x1e232715, 0x78142314, 0x00141e00, 0x00231e00, 0x060c1118, 0x2a182b00, 0x2a0e4008, 0x79161580, 0x18262627,
		0x411d1e23, 0x14421817, 0x6e184400, 0x1a2f0d13, 0xcd1adc10, 0x10c61001, 0xcdccdede, 0x57391211, 0x873b08bb, 0x872b1018, 0x0e10c47d, 0xc4c405c4,
		0x06253031, 0x06060706, 0x32331415, 0x44173736, 0x3720069f, 0x2306cb58, 0x03031e33, 0x4d081e82, 0x01262633, 0x0b150eea, 0x06240e0d, 0x17070a14,
		0x282c3324, 0x24ee2617, 0x312a1154, 0x1d661e36, 0xe0292f35, 0xc8183617, 0x08023517, 0x150e0b12, 0x03031a0d, 0x20220a36, 0xa513321d, 0xa29a42a2,
		0xa24a4aa3, 0xdf0199a2, 0x5a58a63f, 0x008200a7, 0x3a000222, 0x2608f782, 0x00db01b1, 0x00430034, 0x3f00b99a, 0x12b3f0ff, 0xb83f4d00, 0x1a40e8ff,
		0x2c4d0011, 0x00121110, 0x0b18234c, 0x831f4d00, 0x18182904, 0x4c00110f, 0xe0ffb803, 0x2306647a, 0x0b09b4e8, 0x29081085, 0x00082e40, 0x2919394d,
		0x1116057f, 0x4145050b, 0x32322182, 0x400d4421, 0x3c804413, 0x10260089, 0x26080226, 0x88350026, 0xc24b511c, 0x3911250c, 0xed5d5e2f, 0x29072441,
		0xed102f32, 0xccdcde10, 0xb54b10cd, 0x3213270d, 0x1115021e, 0x1e41030e, 0x0bb24b0e, 0x200be66a, 0x0c116b13, 0x4734f737, 0x1a09122c, 0x06231218,
		0x16060b14, 0x1b2f3325, 0x1225111b, 0xb2591826, 0x35250812, 0x1010311f, 0x2c17192d, 0x013d1622, 0x422e1adb, 0x06defe27, 0x0c1b1915, 0x3603031a,
		0x1520240a, 0x02021d2a, 0xc159180d, 0x60fe3411, 0x058a0304, 0x1d120706, 0x00232d16, 0x2e00ffff, 0x5701f3ff, 0x2620057b, 0x2f060751, 0x00890036,
		0x010b4010, 0x07212337, 0x0c015000, 0x2a090355, 0x01f5ff31, 0x02b502c3, 0x44460026, 0x2d20056b, 0x27056b44, 0x00222431, 0x0401501a, 0x85076f4a,
		0x823a2053, 0x22538527, 0x5c360069, 0x01230527, 0x84222633, 0x24298453, 0xffff0000, 0x20538500, 0x215388af, 0x53853269, 0x23273222, 0x24205384,
		0x85063f45, 0x87222053, 0x62012153, 0x23215389, 0x55538429, 0x5385097f, 0x53879720, 0x36620122, 0x36225385, 0x53842a24, 0xfb88d184, 0x53883d20,
		0x53895f20, 0x84252121, 0x43262053, 0x5385089f, 0x5388b220, 0xa7875f20, 0x84262221, 0x86272053, 0xff3625a7, 0x03cc01fb, 0x27285383, 0x07010000,
		0xddff5f01, 0x26056f58, 0x40d6ff02, 0x45211d09, 0x2b2306c3, 0x8200342b, 0x00033000, 0x01f5ff14, 0x00b502f4, 0x0021000e, 0x186a0025, 0x3927c159,
		0x4d000e23, 0x0e212522, 0x0827117f, 0x09401982, 0x2619480c, 0x004d2524, 0x59188803, 0x3f2b12c6, 0xd61001cd, 0xde10ed2b, 0x5ade32ed, 0x5918081e,
		0x23081eca, 0x35230737, 0x2c0b1901, 0x17241a19, 0x19303c0b, 0x18520823, 0x472c334b, 0x2c171c32, 0x2e202840, 0x3718db0c, 0x1cd15918, 0xc7c7f625,
		0x58ffff00, 0x0223075f, 0x82ab0006, 0x000222ef, 0x20ef8228, 0x27ef82e0, 0x0029001a, 0x2500b97e, 0x0d5f8218, 0xffb82025, 0x824240f0, 0x181530db,
		0x4c00100f, 0x00091014, 0x0820144d, 0x83104d00, 0x1b320804, 0x7f000103, 0x2b090607, 0x2a128223, 0x06860009, 0x1e050303, 0x01174188, 0x17101700,
		0x08031720, 0x88265017, 0x0504510d, 0x333f004d, 0x5e3fed3f, 0x8b585d5d, 0x25fe8209, 0xcdfdcd32, 0x6a483333, 0x23012908, 0x37353335, 0x23153315,
		0x0ec65a18, 0x26261523, 0x09c27d23, 0x4c013708, 0x4252b1b1, 0x36501a42, 0x1f384f30, 0x2c47321a, 0x0e0e3423, 0x2c1f1c31, 0x39480d1c, 0x0209281d,
		0x0e453e24, 0xe9fd3e53, 0x3f221008, 0x5936385a, 0x0a122440, 0x5a180d51, 0xe35a08ec, 0x5a06200a, 0x8a200857, 0x200c875a, 0x10875a0c, 0x2005b34d,
		0x4e2f827b, 0x63460507, 0x220b2107, 0x260db34d, 0x0100005b, 0x872803cc, 0x61012157, 0x1024578c, 0x500a001e, 0x2005aa5a, 0x0b5f4e34, 0x57879d20,
		0x46610121, 0x0b2506bb, 0x02133426, 0x05de4d50, 0x935b3420, 0x88222008, 0x00622257, 0x05c74216, 0xfdff0126, 0x140e0940, 0x97205795, 0x62205788,
		0x24215787, 0x0857892a, 0x0001003c, 0x0159ff5b, 0x006b02cf, 0x404a0021, 0x050b1025, 0x1a1e1e21, 0x2321161a, 0x1773201c, 0x1c791f22, 0x791b201c,
		0x20204118, 0x07177921, 0x00800d40, 0x3f004217, 0x1adc1a33, 0x7e1810cd, 0xd6300ac5, 0xce1032ed, 0x322f3232, 0xccdc102f, 0x253031cd, 0x23129146,
		0x21373636, 0x09527118, 0x19cc0123, 0x058d4617, 0x24160636, 0x10152c33, 0xfe050e08, 0xfe5b01e5, 0x01e8e8f7, 0x170e021f, 0x21098446, 0x1c822615,
		0x6b020426, 0xdb46be46, 0x20057b46, 0x35b38228, 0x00db01c7, 0x0037002e, 0x3400b9b7, 0x1d40e8ff, 0x2d4d000e, 0x04821010, 0x820f1821, 0x08102404,
		0x83284d00, 0x2027210e, 0x2105044e, 0x2082b3e8, 0xffb80729, 0x0d0cb4e0, 0x82024c00, 0x748a1808, 0x49092008, 0xb3200546, 0x01273282, 0xb3d0ffb8,
		0x824d0012, 0x83e82007, 0x0807821f, 0x2740d826, 0x4c00100f, 0x2212181d, 0x822f0c0c, 0x05373903, 0x14382a82, 0x80381a40, 0x37378605, 0x080b0b00,
		0x32512588, 0x21055a52, 0x685fed3f, 0x06954605, 0x32edd622, 0x2105554b, 0xe643ccde, 0x05144e08, 0x182b2b21, 0x470e7f5c, 0x362111c1, 0x09a44637,
		0x26361728, 0x020e2223, 0x5c180107, 0x0a3f0b95, 0x0f0d0f23, 0x0a140624, 0x33241606, 0x09101730, 0x08100809, 0x1e3c5b3c, 0x994e3e26, 0x18333f01,
		0x210fa85c, 0x53411119, 0x20242807, 0x0a102415, 0x18010107, 0x2508ba5c, 0x24164739, 0xcb5d182e, 0x423d2009, 0x5f220867, 0x2b461b00, 0x0c012806,
		0x500a0010, 0x45110101, 0x13430883, 0x42b22005, 0x5f200863, 0x26076342, 0x02132622, 0x45000250, 0x2e260783, 0xc701f3ff, 0x27823a03, 0x00002a28,
		0x69000701, 0x53862d00, 0x272b2c28, 0x01500109, 0x538a280e, 0xad015824, 0x2b82af02, 0x2b824a20, 0x2b820620, 0x1000002e, 0x0f020b40, 0x10072f33,
		0x300c0250, 0x220a7f46, 0x872803c7, 0x61012153, 0x22082b46, 0x84382a35, 0x092b4653, 0x83ff2821, 0x879d2053, 0x862b8253, 0x40322153, 0x2e205384,
		0x2220538c, 0x62205388, 0x2821a789, 0x2053942e, 0x21538897, 0x53860062, 0x8e363021, 0x01562453, 0x867902c7, 0x01062b53, 0x000012c3, 0x0d01b60a,
		0x5082292f, 0x00342b26, 0x00ffff00, 0xb9209f85, 0xc4214b88, 0x224b8516, 0x8c383025, 0x002d224b, 0x06474100, 0x09822b20, 0x5e000721, 0x07240c7f,
		0x00015001, 0x2306d75e, 0x2c000200, 0xb0292182, 0x15003e03, 0x8a001b00, 0x955c1840, 0x092e3429, 0x7f0d4d00, 0x1a401d0c, 0x6017181b, 0x1c191916,
		0x827f1503, 0x0008314b, 0x0688111c, 0x40171b50, 0x80181619, 0x01181a1a, 0x09a95c18, 0x2f32ce29, 0x32cd101a, 0x4c32cd1a, 0x11240865, 0x332f1933,
		0x15821082, 0x705e1820, 0x332b210a, 0x2008644c, 0xbf5c1815, 0x17112509, 0x27072707, 0x0ec55c18, 0x541a6e28, 0x9d021a54, 0x5c18e20e, 0x03270eca,
		0x3728553e, 0x82002837, 0x821220e3, 0xe2350897, 0x13006b02, 0x55001700, 0x0e172c40, 0x11137302, 0x0d161901, 0x080a7305, 0x06010600, 0x07001518,
		0x0a0d110a, 0x00167904, 0x0a080116, 0x06160a16, 0x02410b0f, 0x05276406, 0x39391222, 0x2205d351, 0x82333311, 0x01322dbf, 0xce5dd610, 0x3232ed33,
		0xce32de10, 0x31240682, 0x23110130, 0x35240185, 0x15333533, 0x152b0384, 0x33152323, 0xc053ad01, 0x83353553, 0xc0882e04, 0xfed401c0, 0xfe20012c,
		0x3dd401e0, 0x2500825a, 0x01006e3d, 0x9b821400, 0xb502b027, 0x87001d00, 0x053c47b6, 0xffb80e24, 0xd656b3d8, 0xb3f02405, 0x844d0011, 0x8409200f,
		0xb3e02807, 0x0d4d0008, 0x83e8ffb8, 0x0807821f, 0x2d40e034, 0x124d000a, 0x081f117f, 0x7f1a0406, 0x1b00011d, 0x121e1b01, 0x1c074a1b, 0x03010104,
		0x0b008816, 0x0b200b10, 0x08040b40, 0x0302500b, 0x333f004d, 0x5b475e3f, 0x32cd2305, 0xc783333f, 0xfdce3225, 0x4133cc32, 0x13200b7a, 0x18065c47,
		0x82113f5e, 0x42143ae3, 0x13a2a252, 0x43311631, 0x2d521228, 0x0a311737, 0x62024252, 0x3e530e45, 0x0e7f415b, 0x00240223, 0x08376100, 0x26021c23,
		0x05df6000, 0x2208275f, 0x611a0001, 0xd3660537, 0x056b5409, 0x26029122, 0x20061354, 0x0a3f5475, 0x01162426, 0x0201500b, 0x8805804a, 0x88062057,
		0x08f74d57, 0x0c000122, 0x850f6361, 0x887b2057, 0x8a8a2057, 0x54162057, 0x59260e97, 0x9b010000, 0x57872803, 0x2909fb4d, 0x1e100001, 0x01500204,
		0x83440c09, 0x20578508, 0x2157879d, 0x578a6101, 0x84281a21, 0x851620af, 0x0136082c, 0x59ff5900, 0x6b029b01, 0x41002100, 0x1b1e2040, 0x0f14191c,
		0x04022109, 0x1c1c7301, 0x400b2223, 0x00802211, 0x411f791d, 0x04791c01, 0x3f004219, 0x3f32ed33, 0x1f4632ed, 0x12112905, 0x32fd2f39, 0xccdc32cd,
		0x0a517618, 0x3a472320, 0x23373013, 0x23113335, 0x01152135, 0x10777823, 0x4d100d17, 0x2f2507c6, 0x0b0d1016, 0x78761877, 0x470c2008, 0x24310836,
		0x11251520, 0x01460810, 0x004646df, 0x00020000, 0x08a78236, 0x9e02c238, 0x33002700, 0x26404800, 0x0d091825, 0x2b314c00, 0x171c272b, 0x040b2211,
		0x2727017f, 0x40133435, 0x0b803419, 0x51228807, 0x8500282e, 0x3f004903, 0x3fcddeed, 0xaf8933ed, 0xdcfdce2e, 0xcdccde32, 0xcd2f3311, 0x132b3031,
		0xe2589783, 0x4e172005, 0x36261385, 0x2e223736, 0xed7a3502, 0xbc34080b, 0x2626d886, 0x0c0e311d, 0x0d07171e, 0x1506230f, 0x2516060a, 0x10182f33,
		0x2c040804, 0x150e233a, 0x1a26261a, 0x0125251b, 0xe3fe458b, 0x080e2f45, 0x08151546, 0x2a0ab846, 0x08031125, 0x47301802, 0x1865012f, 0x42074260,
		0x22200a8f, 0x2008df41, 0x28f58262, 0x4010008b, 0x0e00010b, 0x0bdf4114, 0x01002108, 0xf5ff3600, 0xd001c201, 0x28001500, 0x20131640, 0x4c000d09,
		0x017f040b, 0x16171515, 0x51108807, 0x3f29f986, 0x121101ed, 0xfdce2f39, 0x22e98ecc, 0x8323030e, 0x18c988d5, 0x8908d560, 0x090323b3, 0xa4830608,
		0x3f578482, 0x029e2408, 0x824c0006, 0x00022c10, 0x01f3ff2a, 0x006b02d7, 0x82130003, 0x0b143581, 0x7312000b, 0x73001505, 0x7c0f1401, 0x02134608,
		0x00420141, 0x2d07b251, 0xedde10ed, 0x312f3911, 0x11233330, 0x74542133, 0x27320805, 0x33161637, 0x11353632, 0x0152527c, 0x234b575b, 0x11211b46,
		0x2927222f, 0x40fe6b02, 0x19195662, 0x331b1343, 0x00bf013f, 0x59000400, 0x9c0159ff, 0x6b849702, 0x2b001f36, 0x27404700, 0x1717831d, 0x2d117f0e,
		0x23238329, 0x03070700, 0x3005de45, 0x148a1a2c, 0x880b490f, 0x8a264b04, 0x00490120, 0x2682824a, 0xed3fedde, 0x5dedde3f, 0x33240592, 0x2f33112f,
		0x32228e83, 0x8e82ed2f, 0x11331125, 0x88262217, 0x8233208a, 0x0be7419a, 0x35082755, 0x6c061415, 0x220b2c52, 0x17090a0b, 0x52252c0a, 0x23192851,
		0x03821923, 0x0786e420, 0xfed0013b, 0x0505a730, 0x35040344, 0xfec80133, 0x02565a39, 0x1b1c21c5, 0x1c1b2121, 0x41078721, 0xf3280747, 0x3a03a501,
		0x2d002602, 0x2006ff46, 0x06474832, 0x15193f27, 0x0150020b, 0x06964301, 0x00ffff2d, 0x0156ff47, 0x02af0287, 0x485d0126, 0x14270547, 0x40100000,
		0x8b2a010b, 0x20278229, 0x22278240, 0x826b02eb, 0x832e2053, 0xc3013127, 0x0d0000ef, 0xff0100b9, 0x1a20b4cf, 0x2b500810, 0x8306a74b, 0x02de224f,
		0x202782b5, 0x20278d4e, 0x212782d2, 0x2785050d, 0x02004808, 0x00004000, 0xa7020602, 0x22000d00, 0x37406900, 0x0e110e1f, 0x141f2278, 0x171f2222,
		0x78111611, 0x1a14171a, 0x0706171a, 0x0e00000d, 0x1f24160e, 0x231c731a, 0x111a1f11, 0x411d1c11, 0x1617421c, 0x06060c42, 0x70410e22, 0x333806c2,
		0x39123f3f, 0x33332f19, 0x102f1801, 0x1032edd6, 0x332f32ce, 0xcddedd2f, 0x08050b52, 0x10188721, 0x7d04872b, 0x013031c4, 0x36373434, 0x06173736,
		0x16141506, 0x06062717, 0x17031e07, 0x18262623, 0x08097b79, 0x03018736, 0x13401922, 0x5d010113, 0x1f335026, 0x152a2d34, 0x3357225d, 0x4d2a5252,
		0x0bd0011e, 0x5b2e0912, 0x4f281528, 0x0b140923, 0x4d874d9b, 0x5e51461e, 0x2d9e5d37, 0x0c8f7918, 0xf9824720, 0xd001de26, 0x65001600, 0x31fb6218,
		0x62184920, 0x33213cfb, 0x22de8215, 0x18060633, 0x271ffb62, 0x30c2d001, 0x6c33335f, 0x200ec768, 0x24b9822f, 0xff8f0007, 0x070f63c2, 0x0940ad2a,
		0x00020608, 0x07030150, 0x1805c945, 0x29081f65, 0x17003e03, 0x55001b00, 0x63183440, 0x1831182d, 0x091a1a80, 0x0706067f, 0x1c071d13, 0x191a1b18,
		0x35631806, 0xcdde2f0f, 0x1001cddd, 0x11ce10c6, 0x33ed2f39, 0xfe4b1a2f, 0x18052007, 0x24123d63, 0x37270703, 0x41631801, 0x96202f12, 0x180b9013,
		0x012f4730, 0x0dfe46ad, 0x63182c23, 0x03320845, 0x46313608, 0x00ffff00, 0x0156ff5b, 0x026b02cc, 0xdf830026, 0xc3010624, 0xbb420000, 0xb4e22305,
		0xdc82090f, 0x2007bb42, 0x22278236, 0x82b002c2, 0x424f2027, 0x362b05bb, 0xb60a0000, 0x1b212f01, 0x4a501307, 0x5b200683, 0xcc221982, 0x4b886c02,
		0xb72cc222, 0x12222383, 0x48860608, 0x2008c744, 0x244786b5, 0x00c20107, 0x82718283, 0x1a802249, 0x82498418, 0x87478523, 0x01072793, 0xfe710062,
		0x238200ea, 0x0e085722, 0x47854984, 0x881b0221, 0x2023838f, 0x222385e5, 0x84201ae3, 0x01002347, 0x8f841200, 0x0d006b3d, 0x20404200, 0x0b0a0f00,
		0x04730c09, 0x0e030605, 0x0b04030c, 0x0a06090a, 0x820a0405, 0x41072d01, 0x4202790d, 0x3fed3f00, 0x2f2f3939, 0x230c9b5b, 0xfd32cd32, 0x2a080382,
		0x3031ce10, 0x11211525, 0x11372707, 0x17371533, 0xcc011507, 0x1d42a5fe, 0x1c6b535f, 0x01464687, 0x313b2200, 0x37f62101, 0x82e5463b, 0x051b4672,
		0xb0023508, 0x65001f00, 0x18033a40, 0x4c000c0b, 0x0a092003, 0x10024c00, 0x0f4d000d, 0x110e1b10, 0x0b08077f, 0x01060009, 0x21060608, 0x07061120,
		0x090e0f10, 0x0f07080f, 0x17280182, 0x4d0d850a, 0x51008817, 0xed219183, 0x27938e12, 0x2f391211, 0xcc335d5e, 0x04829883, 0x2b30312a, 0x22052b2b,
		0x3535022e, 0x35249c82, 0x11333523, 0x14269e83, 0x3233021e, 0x65183736, 0x42270857, 0xd8865e1c, 0x186a1c4e, 0x2b105d65, 0x3037227e, 0xf1fe46f4,
		0xa8373728, 0x690a1e42, 0x3e200b77, 0x20087769, 0x071f698f, 0x140d0129, 0x50100712, 0x42130801, 0xff2305f8, 0x4a4700ff, 0x0b5c05ab, 0x07335908,
		0x14160b28, 0x01500500, 0x1f4d1502, 0xff372606, 0x02bd0156, 0x2353866b, 0xf8c30106, 0x23066f42, 0x151bb4f4, 0x2b455382, 0x01b0220b, 0x454f87da,
		0xe9230953, 0x82171db4, 0x20278751, 0x22778237, 0x863d03bd, 0x0107224f, 0x09b3475f, 0x84161221, 0x098f57a3, 0xb220a385, 0x2b835388, 0x2107af5c,
		0xa6841814, 0x2206704a, 0x831d0002, 0xb5023e57, 0x1b000f00, 0x00b9aa00, 0xb3e0ff0b, 0x094d000f, 0xb3f8ffb8, 0x084d000e, 0x40d0ffb8, 0x22088209,
		0x4f101802, 0x402105fa, 0x211e8230, 0x04832001, 0x17821020, 0x0c002d08, 0x010f4f73, 0x15141d0f, 0x1f100f1b, 0x03102f10, 0x73030710, 0x06100600,
		0x06b00620, 0x080506c0, 0xc0ffb806, 0x100d1640, 0x141c0648, 0x40201b82, 0x7f283982, 0x07030103, 0x0c410d07, 0x0a201a83, 0x25081082, 0x0c010c70,
		0x00420400, 0x5d32333f, 0x11333f2b, 0x102b5d33, 0x1001cdd6, 0x5d5e2bd6, 0x5dde32ed, 0x10c5d6dd, 0xc07a71de, 0x4521200b, 0x490806af, 0x1117031e,
		0x15011133, 0x27070614, 0x34353636, 0x72012726, 0x461c3516, 0x1b1d0e4b, 0xfe460918, 0x381c1cd0, 0x01010f11, 0xfe72d360, 0x326b025b, 0x2c616667,
		0x95fd8c01, 0x3309b502, 0x23152e52, 0x1409233f, 0xffff0005, 0xd7410b00, 0x0107240c, 0x5d47ff5e, 0x482307e5, 0x411b0940, 0x1a2005dc, 0x82050642,
		0x3700302a, 0xbd0159ff, 0x20006b02, 0x2f405300, 0x18250915, 0x3e0bd27d, 0x19190e00, 0x2211730e, 0x07107305, 0x07020720, 0x09050f21, 0x167c1d41,
		0x08010e0f, 0x8407000e, 0x5d5e26e7, 0x333feddc, 0x20e38233, 0x0527485d, 0x87c11034, 0x05872b04, 0x5d01c47d, 0x2e253031, 0x23112703, 0xde853311,
		0x4806755a, 0x390806c9, 0x37147201, 0x4b204540, 0x3f401c54, 0x084b1438, 0x0d283119, 0x08080a20, 0x17210717, 0x7e732c15, 0x12fe3b81, 0x76316b02,
		0x012f7379, 0x2595fdc2, 0x05182c3e, 0x02024102, 0xb783292b, 0xb7824720, 0xda01b030, 0x59002100, 0x401a1040, 0x1a4d0012, 0x04821128, 0x00102029,
		0xffb8054d, 0x840ab3e8, 0xb3e02107, 0x3f056974, 0x081a40d8, 0x160f4d00, 0x2023077f, 0x0121007f, 0x21222108, 0x0c89134a, 0x03881c4b, 0xed3f0050,
		0xc2820182, 0xc3835e20, 0x31ccfd23, 0x05b15130, 0x36361326, 0x15163233, 0x0f7a8118, 0x2907295b, 0x592d4723, 0x0b5f5d27, 0xb885331e, 0x21081624,
		0x6718101a, 0x29230eab, 0x86152a3f, 0x100121b5, 0x08b66718, 0x2008476c, 0x08476c06, 0x2208f34c, 0x6c200002, 0x28260f9f, 0xcc01f5ff, 0xeb5e7b02,
		0x222b8308, 0x830b4010, 0x0c8b5f29, 0x20059b6c, 0x4c538728, 0x022609ef, 0x00322400, 0x966c5009, 0x00342105, 0x83057f50, 0x879d2053, 0x081f5153,
		0x53842982, 0xff432020, 0x6d538506, 0x0125089f, 0x00240065, 0x05ef6c89, 0x24222322, 0x03255482, 0x024f2504, 0x07c55b04, 0x3b605b8a, 0x65012308,
		0x31850024, 0x24222422, 0x03215c82, 0x2031820e, 0x2831870e, 0x3700ffff, 0xcf010000, 0x20638303, 0x05b34735, 0x47000021, 0x022c05b3, 0x0940fbff,
		0x08122a2c, 0x2b170250, 0x8206b342, 0x826b202f, 0x02b62125, 0x55205f83, 0x280c0359, 0x000e101a, 0x02015006, 0x0abb440f, 0x7102cf22, 0x5783e382,
		0xc301062e, 0x0d0000dd, 0xff0200b9, 0x2d33b4d0, 0x93445482, 0xff2a2607, 0x01b60156, 0x832782da, 0x0107244f, 0x827fffc3, 0x25298281, 0xb464ff01,
		0x53821117, 0xa7882982, 0x4f863d20, 0x5f010724, 0x8f55e6ff, 0xff022605, 0x2a0940dd, 0x20a7842e, 0x20a78f2f, 0x2c5786b2, 0x245f0106, 0x40100000,
		0x0e0d010b, 0x20a78412, 0x22a78813, 0x84bd01f3, 0x863620ff, 0x591220ff, 0x162806ff, 0x252e3234, 0x330f0150, 0x2408b745, 0x01f5ff42, 0x20fb84b2,
		0x20fb8556, 0x27538609, 0x1b22282a, 0x29090150, 0x3a20538c, 0x53857b82, 0x09006922, 0x2206374b, 0x84333709, 0x8e342053, 0x82af2053, 0x6853852b,
		0x0123065b, 0x84292d09, 0x842a2053, 0x01200829, 0x57ff3700, 0x7902bd01, 0x21014700, 0xff4600b9, 0x0a09b4e8, 0xb8464c00, 0x08b3e0ff, 0xb8454d00,
		0x82050e5c, 0xb3e82507, 0x424d0011, 0x0d230f83, 0x83414d00, 0x840f201f, 0x83d82007, 0xb83f2827, 0x09b3d0ff, 0x833d4d00, 0x000e2317, 0x0783384d,
		0x07841220, 0x3783d820, 0x0f833220, 0x07843f82, 0x2205cc79, 0x822f40d8, 0x182c2128, 0x2c216e83, 0x216b8220, 0x18821829, 0x0a202526, 0x18244d00,
		0x51081982, 0x00102019, 0x0e18194d, 0x194c000f, 0x4d000d10, 0xffb80311, 0x0b3640c0, 0x4703480e, 0x140b1700, 0x331a4414, 0x44762133, 0x3a1a1a49,
		0x012b0076, 0x00482b08, 0x0f171414, 0x80480840, 0x261e2e3f, 0x37343417, 0x1b452e7c, 0x177c1e1b, 0xed3f0046, 0xd4552f32, 0x12112305, 0xe3731a39,
		0x5d5e220a, 0x06346eed, 0x2f261882, 0x32dd33cc, 0xe3552bd5, 0x05394410, 0x662b2b21, 0x3d4d18dc, 0x2e342f07, 0x032e2702, 0x33363435, 0x17021e32,
		0x0d642607, 0x1e172807, 0x06141503, 0x66070107, 0x0b2b10e8, 0x11543c06, 0x384e1419, 0x1818423f, 0x211b257e, 0xf4665358, 0x1b0a2810, 0x0b1d030c,
		0x181d0b44, 0x0820367e, 0x08564821, 0x01000000, 0x57ff4200, 0xdb01b201, 0xff003e00, 0xff3c00b9, 0x000db3e0, 0xffb83c4d, 0x840cb3f0, 0xb3e82207,
		0x2507840b, 0x0a09b4d8, 0x18824c00, 0x08b3d026, 0xb83a4d00, 0x39212885, 0x05cc6cb8, 0xe02a0782, 0x4d000ab3, 0xc8ffb837, 0x078409b3, 0x2783e020,
		0xffb83630, 0x0e6540e8, 0x274c0010, 0x4d000b18, 0x23822027, 0x09282726, 0x20244d00, 0x24226682, 0x09820c28, 0x13821820, 0x10212908, 0x214d0010,
		0x4d000f18, 0x12102819, 0x03114c00, 0x0b17003e, 0x193b1414, 0x821f2c2c, 0x1919403b, 0x26008234, 0x3f260801, 0x3c05ce41, 0x2937803f, 0x3217221d,
		0x1d502988, 0x51173e88, 0x00511500, 0x333f333f, 0x11ed3fed, 0x07cd4139, 0x2f391122, 0x4105ea45, 0xcb410fcc, 0x17c94116, 0x2005c841, 0x05726c35,
		0x16323323, 0x78691817, 0x13bf410b, 0x56060c28, 0x4d231041, 0x6918712c, 0x4d21158a, 0x10b64152, 0x0d1b0b2a, 0x104b1d03, 0x20193915, 0x159b6918,
		0x07423934, 0x27000100, 0xcd0157ff, 0x20006b02, 0x1db44800, 0xfe42181f, 0x0b1d3e05, 0x0003480e, 0x1a14140b, 0x21221818, 0x1b79191e, 0x14140041,
		0x08400f18, 0x42181f80, 0x05d05900, 0x2f391126, 0x32ed3fcd, 0x2b05f450, 0xddcc2f33, 0x10cd2bd5, 0x3031ced4, 0x2325f496, 0x21352311, 0x42058215,
		0x0528119e, 0xaa0d070f, 0x0baaa601, 0x0d29c590, 0x25020e23, 0xdbfd4646, 0x20ab8200, 0x36ab823f, 0x006002c2, 0x40760033, 0x0e181944, 0x194c0010,
		0x4d000d20, 0x820c1819, 0x0b202404, 0x84114d00, 0x301d32b5, 0x26232530, 0x1d1d207f, 0x0035251e, 0x1e08011e, 0x20be8234, 0x2ebe8233, 0x882c8034,
		0x21513317, 0x851d2622, 0x82492023, 0x32ed25c9, 0x333f32cd, 0x83051760, 0x100126d1, 0x105d5ec6, 0x270a82ce, 0x1132ed33, 0x39122f33, 0xde41d983,
		0x23d99606, 0x3535032e, 0x20088b5c, 0x078f4b15, 0x07060624, 0x88434601, 0x070d3410, 0x0a1b2f25, 0xc4526262, 0x24170ac4, 0x142c241a, 0x6a3a0d0c,
		0x0d2b1369, 0x412f1d05, 0x8245d829, 0x1845900e, 0x3008b66a, 0xff000212, 0x002700ff, 0x03cd0100, 0x0026023d, 0x4b098237, 0x08260c07, 0x5000060c,
		0x83760001, 0x693f2009, 0x002107e3, 0x302b8257, 0x68c50106, 0xb60a0000, 0x1c1e6101, 0x2b500d17, 0xdf811834, 0x0f29080c, 0x1b403700, 0x06010305,
		0x0a0c0e73, 0x11100909, 0x0f790d02, 0x03790906, 0x0f080c0c, 0x00420841, 0x39123f3f, 0x32ed332f, 0x06f64110, 0xcc33cd30, 0xcd33ccfd, 0x15013031,
		0x15331523, 0x01821123, 0x35333539, 0xcd013523, 0x527676aa, 0x02aa7777, 0x40c8466b, 0x1d01e3fe, 0x8446c840, 0x088f856b, 0x2300603b, 0x35406100,
		0x000b2017, 0x0c18164d, 0x00074d00, 0x1a217f03, 0x111f1e1e, 0x02050511, 0x001c1c25, 0x1f08011f, 0x03232224, 0x0721851e, 0x1d1d041a, 0x10492100,
		0x14880d10, 0x05644551, 0x88823320, 0x8883cd20, 0x0132cd2a, 0x5d5ec610, 0xce102f32, 0x6d06b77a, 0x13200889, 0x4107a97a, 0x23230992, 0x41022e22,
		0x232005ac, 0x3722a882, 0x0082c4f3, 0x27078741, 0x342d3d0e, 0x620e2542, 0x52260082, 0x7a45d001, 0x6c18203e, 0x20260c2d, 0x82457a3e, 0xaf72000e,
		0x021c2108, 0x56073773, 0x28270acb, 0x5014041a, 0x47270601, 0x3766081f, 0x66912005, 0x2b83080f, 0x0b40102c, 0x16240101, 0x01500007, 0x73472309,
		0xff302606, 0x03c401f3, 0x49538806, 0x012208d3, 0x2f731a00, 0x2053850f, 0x8353887b, 0x2053842b, 0x0d8b6616, 0x28205385, 0xd3495387, 0x00012309,
		0xa7842c1e, 0x6606cc4b, 0x9d2008b7, 0x2b845387, 0x1a215384, 0x20a78428, 0x20a78c16, 0x2b53883e, 0x00000063, 0xb70c0086, 0x1f000102, 0x2b23fb83,
		0x67003434, 0xb8200983, 0x27834f88, 0x01212583, 0x82f7831b, 0x117f7425, 0x00650123, 0x051f4a1b, 0x1b010224, 0xa0821e1c, 0x1f060226, 0x1b06014f,
		0x8808fa6b, 0x08db67a7, 0x1b650123, 0x05176600, 0x1a181c22, 0x0226a882, 0x014f1b09, 0x31871709, 0x3000013b, 0xc40159ff, 0x2b006b02, 0x0fb65e00,
		0x00100f10, 0xffb80b4c, 0x0010b3e8, 0x2807824d, 0x0f2b40f0, 0x20024d00, 0x2104820c, 0x04820b10, 0x0a182408, 0x29004d00, 0x051e1e24, 0x2d157312,
		0x2c057308, 0x132c2620, 0x0d1b4106, 0x0046007c, 0x3f33ed3f, 0x7bdc1033, 0xde2405b3, 0x2f3912ed, 0x2207954f, 0x182b2b2b, 0x21138b84, 0xe5560706,
		0x37f03612, 0x52132d49, 0x1c2c1f11, 0x111f2c1c, 0x0b2b2552, 0x0f0e0e26, 0x07326424, 0x23180e24, 0x8418573f, 0x452710ac, 0x1c071b64, 0x65180e0e,
		0x24270569, 0x001e1520, 0x82440001, 0x01ad29db, 0x002a00d0, 0x2200b960, 0x2230d585, 0x40f0ffb8, 0x4d000f33, 0x0011101b, 0x13101a4d, 0xd5830482,
		0x281a2408, 0x4c000908, 0x050b1015, 0x2c007f28, 0x1d007f20, 0x2b1d0801, 0x292b0d07, 0x8823491e, 0x00511800, 0x87ed333f, 0x5d5e26dd, 0xedde10ed,
		0x20dd8ade, 0x10126525, 0x23086f5e, 0x14153311, 0x09d46e18, 0x1b1a0623, 0x076d5814, 0x10183027, 0x2b170c0c, 0xe56e1810, 0x1606230d, 0xe6641d1b,
		0x10252508, 0x0402080d, 0x0ff66e18, 0x00ffff2d, 0x01000020, 0x023a03d4, 0x5c3a0026, 0x1a260fbb, 0x500d0616, 0xeb4f0601, 0x82132009, 0x02e12221,
		0x202b82af, 0x3709825a, 0xfe690006, 0xb9130000, 0xfeff0100, 0x2c300940, 0x0150250e, 0x2b4f2d0e, 0x2005874b, 0x2021820d, 0x205784e8, 0x26578f3c,
		0x0c041216, 0x50040150, 0x9b6909e7, 0x20578305, 0x0b5b5e5c, 0x26010125, 0x43152022, 0x36200abb, 0xc7221d82, 0x7f823e03, 0x8b763d20, 0x1408270e,
		0x50060812, 0x53891001, 0x21824920, 0xb502ab22, 0x5d202b82, 0x8b0d834b, 0x85ff8229, 0x87222053, 0x58012053, 0xd584059f, 0x0940fc24, 0x56841a14,
		0x2f4c1220, 0x20578509, 0x84578797, 0x4010242f, 0x8b00010b, 0x2057882a, 0x5157883d, 0x57870543, 0x84161221, 0x065a4157, 0x2f820020, 0xb2205785,
		0x2f835788, 0x2a8c5784, 0xa1000122, 0x2008cd82, 0x00b502e2, 0xb92e0013, 0xe8ff0f00, 0x12111540, 0x7f134c00, 0x14150000, 0x0a150909, 0x06880d0a,
		0x9b73184d, 0x33112b08, 0x3912112f, 0x3031ed2f, 0x6575332b, 0x4a162005, 0x0e2505c6, 0xa1111502, 0x917c181e, 0xfa01300d, 0x122c4736, 0x0b470b10,
		0x2d1b0b10, 0x8307fe22, 0x055b5297, 0x97827920, 0x79823620, 0x27089f4d, 0xb4d9ff01, 0x252e353b, 0x26088757, 0x0156ff42, 0x4cdb01b2, 0xc74d079f,
		0x23278307, 0x1b222b31, 0x27202788, 0xcd222782, 0x27826b02, 0x4f853720, 0x0000e42d, 0x0100b90d, 0x11b4e0ff, 0x8800060b, 0x823f2027, 0x02c22227,
		0x47278260, 0xc329054f, 0x0a000024, 0x251901b6, 0x094f471f, 0x23824720, 0x01802c08, 0x001300d0, 0x0500b92f, 0x1640e8ff, 0x4c000a09, 0x15037f12,
		0x14000b0b, 0x880f0c0c, 0x85135208, 0x3f004902, 0x32ed3fed, 0x1810012f, 0x2008b091, 0x777a1813, 0x01722211, 0x6e7a180e, 0x8b01290c, 0x3035fe45,
		0x10122a43, 0x08657a18, 0x2a08b082, 0xf901c400, 0xb5023401, 0x1a000d00, 0x0f0c0a40, 0x0707060e, 0x060d0d00, 0x01cc2f00, 0x2f33cd2f, 0x391211cd,
		0x14013031, 0x52060714, 0x34310925, 0x151f0301, 0x010f1138, 0x0ab50201, 0x4b2e080e, 0x070c5223, 0x00012208, 0x010b0281, 0x00b20273, 0x40250005,
		0x0104030f, 0x02024000, 0x03030607, 0x05028001, 0x1a332f00, 0x82b782cd, 0x2f192153, 0x27080982, 0x303132cd, 0x37173713, 0x22810717, 0x79225757,
		0x4e278b02, 0x0080274e, 0x00ffff00, 0x013b027b, 0x027b0279, 0x008a0006, 0x8238a783, 0x72012102, 0x15009d02, 0x11b71500, 0x10060510, 0x00000b06,
		0x32cedd2f, 0xde21a682, 0x294782cd, 0x37022e22, 0x33031e33, 0x07823e32, 0x020e1632, 0x212c19fa, 0x01360112, 0x13180f06, 0x060e1913, 0x26080a82,
		0x022c2112, 0x2e1f1121, 0x13170a1e, 0x17130c0c, 0x1f2e1e0a, 0x00010011, 0x011e02be, 0x00970236, 0xb30d000b, 0x82060309, 0x82cd2057, 0x18538355,
		0x2108ef68, 0x455afa06, 0x1e022106, 0x290a2b5a, 0x9e000200, 0x56010102, 0x3b82b802, 0x3900172f, 0xff0b00b9, 0x081140e0, 0x074c000f, 0x20058320,
		0x21058405, 0x1582b801, 0x0f830c20, 0x060c0027, 0x150f0912, 0x4f511803, 0x09f06f11, 0x0c4d4b18, 0x25375624, 0x03833725, 0x141b2d24, 0x03831b14,
		0x2b5d0231, 0x2a2b3131, 0x172a3131, 0x18171a1a, 0x82001a1a, 0x01230800, 0x59ffab00, 0x07004901, 0x20001600, 0x03080d40, 0x110f0915, 0x80170040,
		0x00170808, 0x1a2f3311, 0x821adc10, 0xcc3327d3, 0x303132cd, 0xd6832205, 0x37363723, 0x0c654633, 0x330e012b, 0x15101730, 0x190b530e, 0x07f95d0d,
		0x2024a72a, 0x17112515, 0x0e140808, 0x82071b5d, 0x026428f3, 0x02900106, 0x820300b5, 0x2b6d826f, 0x06050407, 0x02010003, 0x05800307, 0x0b854e18,
		0x8332dc21, 0x0713246d, 0x82173727, 0x6efd2403, 0x82c5672b, 0x83022503, 0x328f207d, 0xb6820382, 0x2008af45, 0x08af453e, 0x16824320, 0x85458920,
		0x40fd2305, 0xb2451809, 0x8200200c, 0x05b3452f, 0xb345b520, 0x242f8308, 0x0100b913, 0x202d82ff, 0x0eb3452e, 0x89050b46, 0x848f205b, 0x40102c5b,
		0x1704010b, 0x500d0615, 0x49160601, 0x578f086f, 0x29842b83, 0x0e2b2d27, 0x0e015025, 0x06c7482c, 0x1a205385, 0x8320af88, 0x8b205382, 0x22054948,
		0x82291700, 0x06022654, 0x06014f21, 0x0b7b4815, 0x8f205b85, 0xdb6fb388, 0x2d002208, 0x265c823f, 0x4f370e02, 0x862b0e01, 0x12a37c31, 0x230a1341,
		0x140940fc, 0x6e0c6e46, 0xb52009f3, 0x6f465f82, 0x08134105, 0x0940fe23, 0x0a724624, 0x01000024, 0x04821900, 0x02da2008, 0x0003006b, 0x00124023,
		0x8d020102, 0x03140003, 0x02010300, 0x01005603, 0x333f0055, 0x1801333f, 0x28089e4b, 0x33012333, 0x7b01465f, 0x39318446, 0x01120174, 0x00790280,
		0x001f000b, 0xb582002b, 0x0015101d, 0xffb8194d, 0x0782b3e0, 0xffb81325, 0x820f40e8, 0x830f2008, 0x180b2615, 0x4c000d0b, 0x20138207, 0x200883b4,
		0x21088205, 0x09832840, 0x83100121, 0x26360805, 0x0c202620, 0x0c009616, 0xcf000696, 0x40230123, 0x23481c19, 0x29012930, 0x981b0329, 0x0101b809,
		0x039811b3, 0xed3f0063, 0x3911ed3f, 0x2bcd712f, 0xdc2f015d, 0x477910ed, 0x08c86905, 0x34132b2b, 0x16323336, 0x23061415, 0x06f77822, 0x4d020e21,
		0x3e220547, 0x15842702, 0x21843520, 0x3f477424, 0x0383473f, 0x1006ca29, 0x1a14141a, 0x85070710, 0x1e063d07, 0x14111115, 0x15111114, 0x5c57c601,
		0x5c58575c, 0x2e19585c, 0x21141421, 0x2d1a192e, 0x2d2e0783, 0x17170f1c, 0x1717100f, 0x69000200, 0xff821901, 0x0e007229, 0x79001300, 0x821000b9,
		0x001023f8, 0xdb83104d, 0x000f4525, 0x82200e4d, 0x200c26fd, 0x0c4d0018, 0x26098310, 0x4d001408, 0x8217180b, 0x16102104, 0x18210482, 0x26048215,
		0x4d001410, 0x830e1209, 0x0f0e3506, 0x0196070f, 0x08041504, 0x12120109, 0x600e0f06, 0x0001b806, 0x0ab74b18, 0xde100128, 0x1132fd32, 0x59182b33,
		0x2b200c4c, 0x093e4e18, 0x033e3c08, 0x06060737, 0x53013307, 0xae3c2d2d, 0x3430270c, 0x3a1c031a, 0x72026b15, 0x545435d0, 0x3c3a1629, 0x1d4a163a,
		0x00002247, 0x017f0001, 0x02770112, 0x001d0072, 0x1d00b984, 0x82b3d8ff, 0xb81d21b0, 0x0e22c182, 0x07824d00, 0x0db3d822, 0xe0220784, 0x07840cb3,
		0x0bb3d829, 0xb8014d00, 0x82b3f0ff, 0x280782e1, 0x0b2640e0, 0x0f4c000f, 0x08dd8218, 0x15961820, 0x0d171712, 0x961b0096, 0x12060612, 0x1b1b9812,
		0x1598180a, 0x0a070760, 0x01b80398, 0xcd520001, 0x39123105, 0x2f01ed2f, 0xed102f32, 0x2f33eddc, 0x31edd610, 0x0a164b18, 0x06140123, 0x09d55f23,
		0x022e3429, 0x37363623, 0x82231533, 0x163a08ce, 0x47770116, 0x0f3a1d4b, 0x1c2d0e0d, 0x250f2430, 0x08062e3d, 0x028cc102, 0x4c550401, 0x3d307f01,
		0x0535080d, 0x0f141f0d, 0x2d0a1119, 0x12382a5b, 0x39051324, 0x02000000, 0xe3827d00, 0x74028228, 0x25001800, 0xe5835401, 0x82b3c821, 0x27dd83ae,
		0x17161040, 0x18184c00, 0x1826e482, 0x000c0b20, 0xcc4b134c, 0x22078206, 0x820eb4e0, 0x230882d9, 0x0d0cb4e8, 0xe0201984, 0x0f27fc83, 0xb3d0ffb8,
		0x824d0011, 0xb3e82207, 0x22078410, 0x840fb3d8, 0xb3e82207, 0x2207840e, 0x840db3e0, 0xb3d82207, 0x2007840c, 0x203783e8, 0x2637830e, 0x084d000b,
		0x83d8ffb8, 0x2207827e, 0x8416b3e8, 0xb3e8220f, 0x25078414, 0x0013b3f0, 0x1f83074d, 0x07861720, 0x07841520, 0x6783d020, 0xe0201782, 0x07826783,
		0x06206784, 0xc6824f83, 0xd8240782, 0x4d0017b3, 0xc8200782, 0x17844f83, 0x0f841520, 0x2640d831, 0x4c001413, 0x001b2001, 0x1c10144d, 0x83134d00,
		0x1b093a04, 0x96230096, 0x11040411, 0x0c981900, 0x981e030c, 0x0101b816, 0x039804b3, 0x07584360, 0x2f01ed28, 0x102f32cc, 0x1e5a10ed, 0x75421806,
		0x075f5416, 0x34132b2f, 0x0e173736, 0x36360703, 0x021e3233, 0x055b5915, 0x22376108, 0x33160607, 0x35023e32, 0x7c7d2634, 0x361e066b, 0x1206202c,
		0x30220e21, 0x1f0f0d1e, 0x4444202f, 0x02212382, 0x17112b20, 0x011f060f, 0x026964a5, 0x160b0137, 0x0408151f, 0x16281e12, 0x15222814, 0x310b5f4e,
		0x16120c3c, 0x001e1d09, 0x00010000, 0x01190186, 0x00720285, 0xb94f000e, 0xf0ff0b00, 0x0b2bee83, 0x40f8ffb8, 0x4d001229, 0x82132804, 0x11182604,
		0x10034d00, 0x21048215, 0x04821418, 0x00131030, 0x9600064d, 0x0996050e, 0x08980510, 0x49430060, 0x01ed2605, 0xdeedde10, 0x085c59ed, 0x3e132b28,
		0x35233703, 0xc3821533, 0x04ba3a08, 0x152a2218, 0x2d12ffb1, 0x01041e28, 0x4d512619, 0x313a1843, 0x59504012, 0x0300002d, 0x12017700, 0x79027d01,
		0x29001b00, 0xa6023500, 0x28260b40, 0x264d0018, 0x4d001120, 0x063b421a, 0xf0220782, 0x0f860fb3, 0x4d000e24, 0xaa82b818, 0x0782a182, 0x82b3e821,
		0xb8142827, 0x0cb4d8ff, 0x824c0011, 0x40e02808, 0x4d000b1f, 0x820b200f, 0x200c210e, 0x0c212482, 0x21218228, 0x1e832006, 0x43280621, 0xe022056b,
		0x1e830a40, 0x16083325, 0x83324d00, 0x842e2063, 0xb3f02207, 0x2907842b, 0x0029b3e8, 0xffb8314d, 0x1782b3d0, 0xe0200782, 0x0f841783, 0xe0221785,
		0x1f8420b3, 0x1fb3f022, 0xe8220784, 0x07841db3, 0x19b4d025, 0x844c001b, 0x82c18230, 0x40e82807, 0x00161593, 0x8230294c, 0x18282147, 0x1c250484,
		0x10284d00, 0x2104821b, 0x04821a18, 0x82191021, 0x18182104, 0x12230483, 0x83274d00, 0x83262018, 0x1826212c, 0x26276982, 0x4d001f10, 0x821e2826,
		0x1a182504, 0x264c001c, 0x26222d83, 0x0f831820, 0x04821720, 0xbd821020, 0x82182621, 0x402521dc, 0x25215a82, 0x21328228, 0x32822825, 0x1d182527,
		0x28254d00, 0x2004821c, 0x22908338, 0x82151825, 0x1430210a, 0x28200482, 0x1a256582, 0xb3f0ffb8, 0x064c411e, 0x07841720, 0x0940c827, 0x184d0016,
		0x23158220, 0xd8ffb814, 0x0782de83, 0x1db4e825, 0x824c001e, 0xb3f02408, 0x844d0014, 0x2b3e8207, 0xe8ffb80f, 0x00200940, 0x1f180f4d, 0x0d830482,
		0x001d0e24, 0xb1830c4d, 0xac830c20, 0x5f830a20, 0x07825782, 0x0e40d827, 0x064d0016, 0x21578218, 0x24821006, 0x1a830520, 0x4d001f23, 0x21648201,
		0x08834940, 0x1a821020, 0xaf830120, 0x33193908, 0x16040b27, 0x0e0e9630, 0x16962a08, 0x0124ff16, 0x1c009624, 0x10270896, 0x5b4d0018, 0x273f0127,
		0x19982701, 0x8f335f0b, 0x337f0233, 0x8f0233df, 0x2d330133, 0x21631198, 0x35070945, 0x5d2fed3f, 0x33337271, 0x2b7171ed, 0xdced2f01, 0x2f335ded,
		0x038211ed, 0x39171222, 0x10f54518, 0xa6086843, 0x0faf4308, 0x0614012b, 0x022e2223, 0x37363435, 0x05ba4a26, 0x15021e28, 0x16070614, 0xca520716,
		0x34352505, 0x06062726, 0x08634e18, 0x36178908, 0x437d0136, 0x1e322641, 0x1415200c, 0x21384118, 0x1a0e1d2e, 0xc6172015, 0x131a1007, 0x2d331f25,
		0x1b801513, 0x261b2121, 0x0116122a, 0x13382d77, 0x1910221d, 0x2a0f0e2c, 0x123a2817, 0x1910211b, 0x28100e28, 0x0d100720, 0x19121b09, 0x1e0e0b1c,
		0x1c1d0b94, 0x0821120e, 0x02001c0d, 0x18018400, 0x79028901, 0x23001600, 0x0c408c00, 0x0018181c, 0x16201c4d, 0x164c0017, 0x40d8ffb8, 0x000d0b57,
		0x1910124c, 0x08114d00, 0x18210483, 0x28098210, 0x000f0b20, 0x0e180d4c, 0x20058210, 0x2d208328, 0x18171806, 0x20064c00, 0x064d0016, 0x04821518,
		0x1b832020, 0x82380521, 0x1a07360a, 0x96220096, 0x0f04040f, 0x0a0a9817, 0x14981d03, 0x03980463, 0x0add445f, 0x102f3326, 0x32eddced, 0x0fcc6118,
		0x06140125, 0x18362723, 0x201352aa, 0x05007226, 0x7b890127, 0x5c410274, 0x0ac6440d, 0x82454325, 0x44102212, 0x310805c7, 0x64e70107, 0x2a02366b,
		0x1205082b, 0x1315281f, 0x4d152229, 0x3106045f, 0x15120c3c, 0x00003a0a, 0x7400ffff, 0x8001faff, 0x07026101, 0x00006f01, 0x1384e8fe, 0x01007e2a,
		0x5a017f01, 0x94000702, 0x7c201388, 0x78201382, 0x00212783, 0x2013888d, 0x203b827e, 0x20138476, 0x2013888e, 0x20278269, 0x213b8380, 0x13887001,
		0x27827f20, 0x13847720, 0x13887120, 0x13827d20, 0x5c018222, 0x72207782, 0x86201388, 0x85203b82, 0x73202784, 0x77201388, 0x7d202782, 0x74209f84,
		0x84241388, 0x89010000, 0x75201384, 0x00391385, 0xff350002, 0x02ad01f3, 0x002100b5, 0x40c0002f, 0x11182320, 0x28234d00, 0x2604820f, 0x4d000910,
		0x820c201c, 0x0b182104, 0x20260482, 0x4c000a09, 0x3148b817, 0x450d2005, 0x0784060a, 0x22051361, 0x4609b3d8, 0xb42905fc, 0x4c000e0d, 0xe8ffb808,
		0x823b82b3, 0x40e02807, 0x000b0a36, 0x8210034c, 0x8303200e, 0x1003264a, 0x034d000a, 0x082e8218, 0x160b2538, 0x22310b16, 0x2121000e, 0x2230001f,
		0x0e1f2100, 0x06192020, 0x19121515, 0x00062a5c, 0xcd3fcd2f, 0x12112f32, 0x33332f39, 0x013232cd, 0x3232c410, 0x32cd102f, 0x0683ce10, 0x230ff441,
		0x372b2b2b, 0x43053350, 0x15280514, 0x32331614, 0x06173736, 0x08053343, 0x2707355d, 0x35363637, 0x23022e34, 0x15020e22, 0x36281890, 0x1b2f261d,
		0x2a546609, 0x10261d2d, 0x2b401721, 0x0f243c2c, 0x39ad203b, 0x150c0440, 0x12180e11, 0x0201e40b, 0x132e513d, 0x1a362d1c, 0x27469d5f, 0x0b16393f,
		0x1a17143e, 0x07203b2d, 0x3482302a, 0x1e0f4c79, 0x1e0a0f18, 0x82002b35, 0x02340800, 0xf4ff1b00, 0x8601d901, 0x31002000, 0x19404200, 0x0e560e46,
		0x010e0502, 0x210d0d0c, 0x032b3320, 0x2e003215, 0x1a26092e, 0xc0ffb80c, 0x480e09b6, 0x10090c0c, 0x3224e382, 0xcd2f2b2f, 0xcd23e382, 0x82d61001,
		0xcdde2cdb, 0x31332f33, 0x5d5d0030, 0x82152237, 0x161721c3, 0x3320c684, 0x2109c571, 0xe0823233, 0x3427152a, 0x23262627, 0x06070622, 0x4f082582,
		0x35322133, 0x02030470, 0x2c2a441c, 0x1d201b49, 0x512f365e, 0x3c23233c, 0x512e2f51, 0x0552233d, 0x2928451a, 0x04061b45, 0xb7031401, 0x05046e02,
		0x251f1d03, 0x202b231e, 0x2a294936, 0x2020364a, 0x052a4a36, 0x1a07067d, 0x061b201f, 0x04046b08, 0x0029ce82, 0xff0c0003, 0x02e001f9, 0x2f098272,
		0x0139002e, 0x2a00b91d, 0x11b3e8ff, 0xb8294d00, 0x15200782, 0xf0220784, 0x078414b3, 0x13b3e822, 0xe0220784, 0x078412b3, 0x10b3e822, 0xe0220784,
		0x07840fb3, 0x0eb3e828, 0xb8254d00, 0x2783e0ff, 0xe8250782, 0x001210b4, 0x2608824c, 0x0f0eb4f0, 0x83204c00, 0x00182219, 0x2207824d, 0x8417b3e8,
		0xb4e02307, 0x18841613, 0x5283d820, 0x40251883, 0x4d001151, 0x088d8202, 0x023a9c4c, 0x023a3a14, 0x35329634, 0x2f01012f, 0x0e0e1a1a, 0x1325272e,
		0x27222296, 0x960a0303, 0x39613527, 0x32362f2f, 0x0e3f2560, 0x0e020e4f, 0x400f3098, 0x0f0f020f, 0x0704041d, 0x19682c98, 0x1d981619, 0x59030266,
		0x005b0100, 0x0182333f, 0x08089c5d, 0xed712f21, 0x333f3971, 0x3fcd2f33, 0x33ed2f01, 0x2f33112f, 0xcd1032ed, 0x2f322f32, 0x102f332f, 0x69ed32dc,
		0x31210530, 0x0f994530, 0x23332b2e, 0x16033301, 0x36323316, 0x23263435, 0x1e3a5718, 0x0c4b0120, 0x06352e05, 0x46520706, 0x9f467b01, 0x1714210b,
		0x37571820, 0x0f200813, 0x291a0c2a, 0xfe252f1e, 0x182f23f1, 0x21143b29, 0xfd6b0212, 0x0d0804cc, 0x320c1610, 0x0a0e120b, 0x122f5718, 0x182a0221,
		0x2907f958, 0x15000300, 0xe301f9ff, 0x09827802, 0x4c002235, 0x00b93d01, 0xb4e0ff47, 0x4c001514, 0xe8ffb847, 0x841311b4, 0xb4e02d08, 0x4c00100e,
		0xc8ffb840, 0x4d0010b3, 0xd0260782, 0x000f0eb4, 0x95413f4c, 0x24078206, 0x0017b3e8, 0x200f844d, 0x22078416, 0x8213b4e8, 0x20108443, 0x25108412,
		0x0011b3d8, 0x30831f4d, 0x07841520, 0x14b3e822, 0xe0220784, 0x638212b4, 0xffb81c24, 0x1882b3f0, 0x74820782, 0x4c001422, 0xd8220882, 0x74820fb4,
		0xe0240882, 0x4d000eb3, 0xd03d0782, 0x000d4f40, 0x1518184d, 0x434c0016, 0x45419632, 0x2d2d4c39, 0x4596294c, 0x02010200, 0x05c64e9c, 0x45032708,
		0x0496104e, 0x0917161d, 0x96220101, 0x2e2d4309, 0x23233c2e, 0x38684a26, 0x663c3538, 0x98131616, 0x9822631a, 0xde416106, 0xed3f240c, 0x183f2f32,
		0x2d0b2459, 0x33ed2f01, 0x32c0102f, 0x10edc62f, 0xc11832ce, 0xfd270849, 0x102f32c4, 0x46d410c6, 0xaf471150, 0x23332405, 0x18053301, 0x201cc45a,
		0x1d014213, 0x4b160721, 0x273e0553, 0x7b014668, 0xc6f9fe46, 0x161a2901, 0x10171317, 0x210c200f, 0x301a3312, 0x28251b2f, 0x0d42d00d, 0x421e2017,
		0x0222060c, 0x5a18c16b, 0x163108f6, 0x0c10110e, 0x1313270d, 0x241a2032, 0xfe0c161c, 0x131c428d, 0x18203208, 0x1d0e2e13, 0x000e0e17, 0xff050000,
		0x01f9ffff, 0x007202d7, 0x0023001f, 0x0039002e, 0x40fd0044, 0x1630310c, 0x281e4d00, 0x4c00150e, 0xe0ffb818, 0x270883b4, 0xc8ffb812, 0x4d0017b3,
		0xd0210782, 0x251e82b3, 0xd0ffb80e, 0x19831140, 0x83200821, 0x28042b05, 0x4c001716, 0xf0ffb83b, 0x26827040, 0x18203326, 0x18334d00, 0x2d820984,
		0x09833120, 0x82103121, 0x20302709, 0x4c001817, 0x1e821812, 0x23830420, 0x96294c08, 0x20242a27, 0x9c222122, 0x23142023, 0x24212023, 0x03162323,
		0x04133d32, 0x10963f06, 0x963a1610, 0x96340606, 0x16962f00, 0x242e612a, 0x60272b24, 0x20592322, 0x3d3d1321, 0x3203370b, 0x42681b32, 0x3f00660b,
		0x11393fcd, 0x8211cd33, 0x332f2204, 0x4301823f, 0xdc2106b6, 0x098149ed, 0x2f331124, 0xb343332f, 0x18012405, 0x1832dc10, 0x200b4963, 0x08c3432b,
		0x4f493720, 0x023e2306, 0x3b463233, 0x6a451805, 0x23072409, 0x43053301, 0x012409ae, 0x06272634, 0x08055946, 0x1614272a, 0x34353617, 0x06222326,
		0x0f1912ff, 0x241c1113, 0x1c241213, 0x14170f11, 0x271e131a, 0x1e271514, 0x0146ba12, 0x50fe467b, 0x0807bb43, 0x297b0130, 0x11201f1a, 0x1e591e13,
		0x15161d16, 0x0c45180e, 0x1c090b24, 0x121b1217, 0x1b120908, 0x0d1c0e11, 0x13191d09, 0x080a131d, 0x02301d12, 0x5e183a6b, 0x43080815, 0x080f1244,
		0x0c0e1910, 0x0f0e820d, 0x0a121106, 0x05000d0d, 0xf9ff0b00, 0x7902d701, 0x23001f00, 0x5a004f00, 0xa2016500, 0xff5400b9, 0x0018b3e8, 0xffb8544d,
		0x0016b3e0, 0xffb8534d, 0x171340d8, 0x50524d00, 0x52211582, 0x20098328, 0x20178240, 0x07e3414a, 0xd0230882, 0x630c0bb4, 0x23820674, 0x19874620,
		0x42864520, 0xe8260782, 0x00150eb4, 0x1082404c, 0x110b4025, 0x424c0018, 0x13200e27, 0x12202986, 0x7c836c82, 0x220a2f42, 0x838840d8, 0x2808213a,
		0x04210583, 0x265f8218, 0x00163004, 0x8228034d, 0x20522104, 0x08208d83, 0x12200982, 0x04209783, 0x33270e83, 0x2a424296, 0x424f4896, 0x46080b1d,
		0x3a3a4f21, 0x4f2e2e4f, 0x03162323, 0x04135e53, 0x10966006, 0x965b1610, 0x96550606, 0x1f965000, 0x45160116, 0x2e012e6f, 0x2f402f30, 0x2f032f60,
		0x24243d2f, 0x644d9827, 0x98363939, 0x2322633d, 0x5b212059, 0x825e5e13, 0x402608a4, 0x4d001d16, 0x5e015e34, 0x0398580b, 0x01534b53, 0x63681b53,
		0x00660b98, 0x393fed3f, 0xed331171, 0x2b713911, 0x15463311, 0x71cd260f, 0x712f0139, 0x105942ed, 0x33112f22, 0x60420283, 0xeddd2308, 0x62422f33,
		0x10214607, 0x20054344, 0x206c422b, 0x201d4244, 0x3b451806, 0x42272008, 0x1123168b, 0x42140e1a, 0x0e22078b, 0x8b421317, 0x45af3008, 0xfe477a01,
		0x14210b56, 0x26272117, 0x1819170c, 0x2a0ea25d, 0x0c17140f, 0x2f1e291b, 0x42890125, 0x0c2111a5, 0x0aa54208, 0x420c1d21, 0xbd200ca5, 0x14be5d18,
		0x0a0b1d2b, 0x1d0e1721, 0xfe0e0e17, 0x11bc42c8, 0x42000021, 0x874408bf, 0x01552609, 0x3e00b9fb, 0x052146ff, 0x53b83e21, 0x0782057e, 0x0eb4d827,
		0x3c4c000f, 0x211982b8, 0x08841410, 0x0fb3e022, 0x27052a64, 0x000e1940, 0x15101e4d, 0x18210482, 0x221b8213, 0x8312201e, 0x0011230a, 0x2e82184d,
		0x8414b321, 0xb4f02507, 0x4c001311, 0x830b9442, 0x480e2018, 0x0782068d, 0x82b3f021, 0x22078235, 0x823f40e0, 0x18083739, 0x4c001514, 0x00131008,
		0x1118084d, 0x054c0012, 0x4d001610, 0x04822804, 0x09832720, 0x09832620, 0x1f18253b, 0x254c0021, 0x4d001e20, 0x18172025, 0x181e4c00, 0x194d0016,
		0xb3f8ffb8, 0x83748523, 0xb8082507, 0x4a40f0ff, 0x04211882, 0x08158218, 0x01273445, 0x20232022, 0x1422569c, 0x21225656, 0x4d434321, 0x964a5353,
		0x3a10553d, 0x52963a01, 0x4d002f20, 0x27034d52, 0x10041332, 0x2906962f, 0x96240096, 0x16232316, 0x16109634, 0x4dbf4d9f, 0xb83a4d02, 0x82b3c0ff,
		0x08078325, 0x1f184020, 0x3a304d00, 0x3a503a40, 0x3a903a70, 0x3a063ab0, 0x9855473a, 0xb8446052, 0x20b3d0ff, 0x07824d00, 0x82b3c021, 0x2e078223,
		0x1c3240e0, 0x44404d00, 0x47444401, 0x43644098, 0x302d0611, 0x27320132, 0x20272703, 0x274d001d, 0x29c38318, 0x27012740, 0x1b982c0b, 0x13433768,
		0x11ed2b06, 0x2b2b7139, 0xc9103311, 0x14433271, 0x25108207, 0x12ed3f2b, 0x08822f39, 0x0171cd3b, 0x11edd42f, 0xfd102f33, 0xedd4edd4, 0x2f391712,
		0x72ed2b33, 0x33eddc32, 0x2115822f, 0x1a432f33, 0x71002105, 0x430bac4b, 0x18431619, 0x4503201f, 0x0322147a, 0x1f561616, 0x053a6505, 0x3435362b,
		0x033e2326, 0x23153337, 0x1c0843ff, 0xe3423020, 0x38dd390e, 0x183b3a36, 0x0a0e0c2e, 0x221a1523, 0x0303402f, 0x93010203, 0x240c4560, 0x211bfa42,
		0xda42dafd, 0x57013510, 0x28272b02, 0x30080d30, 0x13100e05, 0x1f171317, 0x32151d1c, 0x3414ef42, 0x40d20048, 0x11201e0c, 0x1e4c0015, 0x4d001018,
		0xe0ffb818, 0x820d83b4, 0xb3e82108, 0x14231082, 0x83d8ffb8, 0x870e2007, 0x22088218, 0x825d40e8, 0x18082119, 0x08212783, 0x450a8220, 0x70290c29,
		0x3a400140, 0x963f4896, 0x15474243, 0x983f4326, 0x613a6041, 0x2d060142, 0x01324232, 0x32013234, 0x03982c0b, 0xf6412727, 0x45392009, 0x71200509,
		0x22060945, 0x4132ed3f, 0xdc2008e6, 0x2506e641, 0xcceddeed, 0xdf41325d, 0x0b0f4b06, 0x2035c641, 0x09b85327, 0x2c2db741, 0x120e06fd, 0xaf681219,
		0x0d141e18, 0x31ad4106, 0x22b42b08, 0x1a2b2d34, 0x2c1b2932, 0x0025362f, 0x0b000300, 0xd701f7ff, 0x0a007202, 0x2a002600, 0x00b99800, 0xb4d8ff0f,
		0x4c00140e, 0x0886b80d, 0xb8154a08, 0x2d40e8ff, 0x274d001c, 0x9c292829, 0x2a14272a, 0x0e2a2a27, 0x231e0b26, 0x0e1e1414, 0x961b2525, 0x0028280e,
		0x06039605, 0x592a2900, 0x1e5b2827, 0xc0ffb80b, 0x201c1640, 0x180b0b48, 0x65239826, 0x68119818, 0x000a6106, 0x64661800, 0x3fed270a, 0x2f3912ed,
		0x9f59cd2b, 0x32dc3105, 0x2f3311ed, 0x2f33ed2f, 0x2f32cc10, 0x32cd1032, 0x87250e82, 0xc47d872b, 0x05645731, 0x92481320, 0x1801430a, 0x01230524,
		0x7b481033, 0x42482008, 0xfe2715e1, 0x7a0145e4, 0x48310247, 0xa220086a, 0x2313bf42, 0x006b02c8, 0x033a0082, 0xf7ff1500, 0x7902e401, 0x1f001b00,
		0x10013c00, 0xff3900b9, 0x0015b3e0, 0x6e45394d, 0x22078206, 0x8613b3f0, 0x0012330f, 0xffb8364d, 0x0e1440e0, 0x324c0015, 0x4d001620, 0x2b821832,
		0x14203229, 0xb8044d00, 0x83b4d8ff, 0xb8022517, 0x4440d0ff, 0x4f080983, 0x3737962a, 0x1e1c2320, 0x1f9c1e1d, 0x1f1f141c, 0x3c1d1d1c, 0x23313123,
		0x1b031f1f, 0x09181300, 0x1a031309, 0x0396101a, 0x982d3030, 0x983c6334, 0x1f1e6122, 0x5b1d1c59, 0x134f133f, 0x00981302, 0x40c0ffb8, 0x48211c0b,
		0x1b0d0000, 0x0a651898, 0xb3235882, 0x824d0021, 0xb4d82507, 0x4c00201f, 0x1e201084, 0xc0241084, 0x1d1c0a40, 0x0a2a1182, 0x6806980d, 0x32ed3f00,
		0x00822b2f, 0x21058341, 0xea4471ed, 0x4c158305, 0x83410529, 0x332f2409, 0x4433112f, 0x012607d6, 0x32cd1018, 0xdb44ed2f, 0x4125200b, 0x05221c8c,
		0x66182315, 0x692019ff, 0x28169f41, 0x7b0146fd, 0xc6f7fe46, 0x082a4c28, 0x4c112021, 0x2922052a, 0xab41a30d, 0x32c32216, 0x14671817, 0x05c34114,
		0xf7ff133a, 0x7902dc01, 0x46002a00, 0xf3004a00, 0xff2f00b9, 0x150eb4d0, 0xb82d4c00, 0x25220886, 0xf249ffb8, 0x87222005, 0x1c3e0811, 0x40e0ffb8,
		0x00181139, 0x4849474c, 0x474a9c49, 0x4a474a14, 0x2b462e4a, 0x34433e96, 0x452e3e34, 0x2e963b45, 0x212a4848, 0x1e1e960f, 0x2a239606, 0x0a2a1616,
		0x4a492a0a, 0x5b484759, 0x9a412b3e, 0x2b2b2707, 0x43984638, 0x0f823565, 0x001db323, 0x2307824d, 0x1c2440d8, 0x21080882, 0x31983835, 0x0a6f2168,
		0x0b300a01, 0x0b600b40, 0x190b0b03, 0x98030000, 0x15156428, 0x63199812, 0xa54f3f00, 0x71cd220a, 0x05b24139, 0x2b0c3443, 0x33112f33, 0xeddd102f,
		0x32ed2f33, 0x840c3d43, 0x063d430e, 0x4d057c46, 0x06201ea7, 0x2008a84d, 0x1ccf4105, 0x4c492220, 0x492b2019, 0x5620064b, 0x2616d541, 0x7b0146f5,
		0x49ae0146, 0x1e29143a, 0x0e2d140b, 0x0e0e171d, 0x16de41da, 0x0004003c, 0x01f7ff0f, 0x007202e5, 0x0028001b, 0x0031002d, 0x281040c8, 0x4d001618,
		0x04822027, 0x04832620, 0x080d6043, 0x150e3e21, 0x1d1e4c00, 0x29239620, 0x312e3023, 0x302f9c2e, 0x28302f14, 0x2c2f2f23, 0x03313125, 0x4396001b,
		0x312f0b60, 0x5b2f2e59, 0x25602829, 0x23202c1d, 0x43136122, 0xd82b125a, 0x4d001db3, 0xd0ffb80a, 0x821c0940, 0x0b484308, 0x23079541, 0x32cd32dd,
		0x20053648, 0x0a474333, 0x1132ed36, 0x332f2f33, 0x32ce2f33, 0x7d872b87, 0x331101c4, 0x32fd1018, 0x20064a6b, 0x1941432b, 0x18150321, 0x240f576b,
		0x33012303, 0x16374301, 0x2323a031, 0x2f1b823b, 0x21161820, 0x46274710, 0x43467b01, 0x0121142c, 0x856818aa, 0x1b2b2507, 0x26fe1a38, 0x3905e744,
		0xffffff04, 0x02c001f7, 0x00150072, 0x002b0020, 0xb6b8002f, 0x150e200f, 0xf1824c00, 0x0fb4e022, 0xd8200885, 0x080c4618, 0x74081083, 0xd8ffb806,
		0x000e5540, 0x1d10134d, 0x2e2c4d00, 0x2f9c2e2d, 0x2f2f142c, 0x162d2d2c, 0x1a011a0f, 0x161d1996, 0x03082f2f, 0x29109623, 0x00000896, 0x2e302c08,
		0x1c2d592f, 0x162f2061, 0x164f163f, 0x1d161603, 0x9821601a, 0x26050503, 0x0001004d, 0x158f157f, 0x26661502, 0x00680d98, 0x713fed3f, 0x391271cd,
		0x3fed332f, 0x5d2f3333, 0x3f2f3fcd, 0x01331133, 0x0579492f, 0x33113228, 0x32dd2f2f, 0x078271ed, 0x5d057149, 0x2523098b, 0x5f070606, 0x0e290545,
		0x26222302, 0x023e3435, 0x0a7f5233, 0x07220123, 0x06b55214, 0x01230538, 0x2fa80133, 0x12170d3b, 0x180c2d30, 0x31371723, 0x2e432c15, 0x42466dfe,
		0x34200808, 0x16191617, 0xfe151514, 0x7b0146da, 0x1802d146, 0x23340d1b, 0x0f1a2111, 0x3a1f303d, 0x2e011a2c, 0x28084446, 0x1e220e76, 0x17100e19,
		0x064f4177, 0xff1c0034, 0x02dd01f7, 0x00150072, 0x003c0031, 0xb9040140, 0x00461a00, 0xb8182906, 0x0b40d0ff, 0x4c00150e, 0x830a6241, 0xb807250e,
		0x4e40d8ff, 0x3d200983, 0x08316b18, 0x40544f08, 0x08404001, 0x10963403, 0x481c1940, 0x08963a10, 0x081b0000, 0x01085b01, 0x3e3e4208, 0x04303029,
		0x19260126, 0x2e291631, 0x3f291f1f, 0x3e3d5940, 0x1c40295b, 0x9829481f, 0x16b41694, 0xffb81602, 0x1c0b40c0, 0x16164820, 0x2e983123, 0x0f832060,
		0x0022293e, 0x0120b44d, 0x02012073, 0x30012061, 0x20200120, 0x641c9823, 0x05039832, 0x98003705, 0x20068841, 0x07884137, 0x8741ed20, 0x32ed2705,
		0x5f71712f, 0x0c4b7171, 0x712b2305, 0xbb472bed, 0x05af4705, 0x71cddc22, 0x2e058f44, 0x32715dc6, 0xdcfd102f, 0x1132ed2b, 0x445d2f33, 0x9b410c86,
		0x18714414, 0xaa411320, 0x44d42021, 0xdb20156d, 0x2007b741, 0x15b741f7, 0x67441820, 0x37fe2113, 0x080dc341, 0xffff0344, 0xd3010000, 0x0a007202,
		0x1d001900, 0x37406200, 0x1c1b1c1a, 0x141a1d9c, 0x1d1d1a1d, 0x0b961914, 0x9610110b, 0x001b1b14, 0x07039605, 0x1e1a1b00, 0x14591d1c, 0x65139810,
		0x61065b0b, 0x0840000a, 0xf348480d, 0xcd2b2e09, 0xed3f3f3f, 0x11333f32, 0x2f013333, 0x06f048dd, 0x2f39cd23, 0x09ea48ed, 0x4a0be548, 0x21200920,
		0x2e0cd648, 0x120e0619, 0xaf68121a, 0x0d151e18, 0x83d0fe06, 0x09cc48e0, 0x49fffd21, 0x2e2208df, 0xc3482537, 0x08c78208, 0x7902e322, 0x20000300,
		0x7d002f00, 0xff1f00b9, 0x0019b3e8, 0xffb81a4d, 0x0e3e40d8, 0x274c0015, 0x2a2f9621, 0x3f0b7654, 0x0e2a9626, 0x04041b96, 0x0101061b, 0x15069620,
		0x262a0615, 0x21652898, 0x1114145b, 0x20631898, 0x82147254, 0x2f0125de, 0xed102f33, 0xcd210382, 0x20078232, 0x2709822f, 0x7d872b87, 0x101801c4,
		0x5406b65e, 0x16480653, 0x0ad15e18, 0x20053454, 0x140848f8, 0x0541de20, 0x6b02210b, 0x2414ff47, 0xfe0c171d, 0x0b0f4158, 0x03000035, 0x00001300,
		0x7902d601, 0x39002a00, 0xa4003d00, 0x532500b9, 0x200806fb, 0xe0ffb81c, 0x15115840, 0x3c3a4c00, 0x3d9c3c3b, 0x3a3d143a, 0x39343d3d, 0x312b2b96,
		0x3b349630, 0x0fea473b, 0x593d3c36, 0x345b3b3a, 0x65329830, 0x3f215b2b, 0x6f0a4f0a, 0x980a030a, 0x2222ce47, 0x423971ed, 0x3f23050a, 0x472f0133,
		0x124210c5, 0x2b01220d, 0x28bc472b, 0x33420120, 0x22ad470d, 0x4c422720, 0x47e6200c, 0xfe2123a3, 0x0e624283, 0x00045908, 0x0100000f, 0x007202e0,
		0x001b000e, 0x00240020, 0x213c406e, 0x9c232223, 0x24142124, 0x22222124, 0x1c1c1b18, 0x16961310, 0x181f1116, 0x0e092424, 0x07000096, 0x23099605,
		0x22215924, 0x601b1c5b, 0x981f1018, 0x61151613, 0x07980509, 0x005b0065, 0x32ed3f3f, 0xed32dd3f, 0x410a4c47, 0x2f210614, 0x22088333, 0x82113332,
		0x088b4d01, 0xf6892120, 0x20163247, 0x20e68b43, 0x0b2847b2, 0xf2832c20, 0x7220d08c, 0x22131f47, 0x820d0003, 0x82dc20e3, 0x001b29e3, 0x002e002a,
		0x0400b9ea, 0x20063a4a, 0x07d74b02, 0xffb81135, 0x0022b3f0, 0xffb80b4d, 0x001fb3e0, 0xffb80a4d, 0x825340c0, 0x2d2b3b08, 0x2e9c2d2c, 0x2b2e142b,
		0x1c252e2e, 0x22252a96, 0x2c259621, 0x1a1a132c, 0x88489610, 0x182c0805, 0x4c002b2a, 0x09091318, 0x592e2d13, 0x255b2c2b, 0x65239821, 0x136f5b1c,
		0x4f133f01, 0x7f136f13, 0x05139f13, 0x00609813, 0x01009001, 0x20069b48, 0x06f64b20, 0x67836020, 0x862fb321, 0x1d0e356f, 0x0a304d00, 0x0a020a50,
		0x06980d0a, 0xed3f0064, 0x2b712f32, 0x2307b245, 0x7271ed72, 0x220d7942, 0x50ed102b, 0x2f2407bc, 0xde10cdfd, 0x230a8c44, 0x2b2b2b00, 0x50057d42,
		0xaa431670, 0x2321240a, 0x45663301, 0xda20158b, 0x260c6242, 0x7b0146d7, 0x451b0246, 0xfd21137f, 0x0c8741c0, 0x18006b21, 0x3a08c372, 0x007b02da,
		0x00190003, 0x00340028, 0x160c40c3, 0x4d001218, 0x150e2013, 0x410e4c00, 0x0b20077c, 0x40210882, 0x25128368, 0x00202017, 0x0483164d, 0x82100521,
		0x05572b09, 0x1a962801, 0x1f20231a, 0xe0442396, 0x2336080b, 0x040c9632, 0xa00c8004, 0x030cb00c, 0x962c070c, 0x14010114, 0x65211f23, 0x98295b1a,
		0x90098007, 0x0309b009, 0x6c2f0909, 0x02047c04, 0x0401045e, 0x982f5a19, 0x67596411, 0x71cd390d, 0x2f391271, 0x3fed3371, 0x0132cd3f, 0x102f332f,
		0x71cc32fd, 0xed102f32, 0xf8440b82, 0xcdfd2907, 0xed2f3911, 0x71003031, 0x26055041, 0x23332b2b, 0x48053301, 0x504112a6, 0x2203220a, 0x08a74806,
		0x01465f38, 0xf2fe467b, 0x130d3a2f, 0x0c2e2f15, 0x36182318, 0x432b1531, 0x5941742e, 0x0cfc2f0b, 0x15190b16, 0x02151514, 0x1802226b, 0xa7480c1a,
		0x85fd210b, 0x230b5941, 0x0608ef01, 0x2105ac48, 0xf7490000, 0x02d52f05, 0x00150072, 0x002a0020, 0xb9ba002e, 0x9f181200, 0xd820085d, 0x2605fc58,
		0x150e280a, 0x84074c00, 0xb8132805, 0x4840e8ff, 0x424d001d, 0x560808d5, 0x2c2c2b2e, 0x19961a16, 0x2e2e161d, 0x10962303, 0x00089628, 0x01088f00,
		0x01108008, 0x2f2b2c10, 0x1c592e2d, 0x40162061, 0x16480d0a, 0x60191d16, 0x05039821, 0x48211e40, 0x00250505, 0x40c0ffb8, 0x001d1c0c, 0x1598004c,
		0x0d982568, 0xed3f0066, 0x122bed3f, 0x492b2f39, 0x2b2205f9, 0x31473fcd, 0x41712006, 0x10220558, 0xfb4932ed, 0x11fa4905, 0x36362523, 0x86811837,
		0x1415240a, 0x4923020e, 0x32340bf9, 0x22232637, 0x16141506, 0x33012305, 0x3a2e1e01, 0x2f12160d, 0x200bf849, 0x08f849ed, 0x18145038, 0x15142d01,
		0x46eafe15, 0x29467b01, 0x0b1a1702, 0x21112334, 0xf8491019, 0x58022005, 0x822709a8, 0x0e19410d, 0x47831710, 0x0435056b, 0xf7ff1500, 0x7902de01,
		0x32001500, 0x40003c00, 0x00b9d000, 0x06f7492c, 0x41b81221, 0x20201058, 0x82095841, 0xb3e82a1d, 0x114d001e, 0x40e8ffb8, 0x4a088259, 0x40310803,
		0x193e3e3d, 0x162d9620, 0x19322d16, 0x40192727, 0x05064a40, 0x1f080f2d, 0x8f087f08, 0x03080408, 0x49109635, 0x263105fb, 0x2a982326, 0x18983263,
		0x03983361, 0x051f050f, 0x066b4102, 0x15003724, 0x60413768, 0x12cd2706, 0x712b2f39, 0x766fed33, 0x05c54905, 0x2c07b842, 0x2f2f3311, 0xcd102f33,
		0x102f32cd, 0x0c6341ed, 0x41063f5a, 0x03201365, 0x411be74f, 0x07200876, 0x20157641, 0x14e04748, 0x41150121, 0xf8200682, 0x21148141, 0xf14fb101,
		0xdbfe2116, 0x080b9041, 0x0f000521, 0xe201f7ff, 0x15007202, 0x2c002200, 0x35003100, 0x00b9b000, 0xb3e8ff30, 0x2e4d0017, 0x83e0ffb8, 0xb8122807,
		0x12b3f8ff, 0x820f4d00, 0x5440260f, 0x4c00150e, 0x0a98410a, 0x34324008, 0x359c3433, 0x35351432, 0x30333332, 0x2d2d221f, 0x961a181d, 0x351d9617,
		0x96250335, 0x08962a10, 0x10080000, 0x32593534, 0x222d5b33, 0x30171f60, 0x611c1d1a, 0x05039823, 0x98002705, 0x41276815, 0x464b0675, 0x0c244e06,
		0x6832cc21, 0x332a05ad, 0xfded2f2f, 0x113311cd, 0x6d512f33, 0x08645408, 0x4e157141, 0x13200a1b, 0x25086241, 0x07060603, 0x67410333, 0x46572015,
		0xf82006f7, 0x25065841, 0x102116ca, 0x5d412a47, 0x7b022114, 0x21070447, 0x4e4111fe, 0xc4012105, 0x25082d4e, 0xff0d0004, 0x334401f7, 0x00312605,
		0x003f003b, 0x0ddb4cf5, 0x150eb424, 0x53414c00, 0x40d8220a, 0x0f534116, 0x0d201b29, 0xb8174d00, 0x82b3d8ff, 0x860e2007, 0x820b2007, 0x5e402107,
		0x06211082, 0x08048230, 0x3d3e3c27, 0x3c3f9c3e, 0x3c3f3f14, 0x30293d3d, 0x4f962630, 0x31190119, 0x292e2916, 0x29411f1f, 0x3f3f2901, 0x10963403,
		0x057e4139, 0x593f3e27, 0x295b3d3c, 0x07e64c98, 0x9823203a, 0x1c011c40, 0x05983264, 0x98003605, 0x98366815, 0x0d010d4f, 0x5d3f0066, 0x20057954,
		0x270882ed, 0xed3f2f32, 0xed2f3912, 0x41050143, 0x5d290a8b, 0x33112f33, 0xdc32cd10, 0x05d7575d, 0x2009634e, 0x07c3452b, 0x412b2b21, 0xcc4c1496,
		0x44012018, 0xbd201f7d, 0x21153e47, 0xae410801, 0xfafe2106, 0x2015aa41, 0x134b4724, 0x4343fe21, 0x04220905, 0xaf410b00, 0x05434706, 0x9b003225,
		0x421600b9, 0x132305f1, 0x42d8ffb8, 0x0e2705f1, 0x00150e20, 0x83280b4c, 0x96282905, 0x5f1f1a1a, 0x20230123, 0x08083147, 0x01000329, 0x01205001,
		0x962b0720, 0x0c963014, 0x140c0404, 0x23140303, 0x6021981f, 0x9829611a, 0x2d090907, 0x68199804, 0x6211982d, 0x3f200d69, 0x4c06f542, 0x6441071a,
		0x5d2f2107, 0x220b5454, 0x5439325d, 0x33240756, 0x03330123, 0x2012c845, 0x09e44903, 0x37321723, 0x05c84534, 0x0145502a, 0x2eae477a, 0x14150d3b,
		0x200bc845, 0x0b2357dd, 0x1715f02e, 0x1515142e, 0xbefd6b02, 0x0c1b1702, 0x210bc645, 0x17478101, 0x362f2308, 0x3241f525, 0x00240805, 0xff130006,
		0x02e101f7, 0x001f0079, 0x003f0035, 0x0057004c, 0xb954015b, 0xd8ff2f00, 0x150e1740, 0x182a4c00, 0x27210583, 0x21058320, 0x4160301e, 0x6613200c,
		0x0e210630, 0x202c82b8, 0x09095e36, 0x18204627, 0x28464d00, 0x24048217, 0x4d001620, 0x270e8343, 0x17161843, 0x18424c00, 0x42211982, 0x2d0a8320,
		0x15121832, 0xb8224c00, 0x11b3e0ff, 0x07824d00, 0x26071459, 0x1513b4e0, 0x82144c00, 0x12b32353, 0x07824d00, 0x8f6bd020, 0x40e02d06, 0x4d001064,
		0x18161804, 0x18044c00, 0x62080a82, 0x5a595a58, 0x14585b9c, 0x5b5b585b, 0x30963823, 0x2028963d, 0x59302820, 0x50130059, 0x06040345, 0x10109652,
		0x00169640, 0x0606964d, 0x5a009647, 0x5958595b, 0x2398365b, 0x203a2525, 0x3a683598, 0x13662d98, 0x03459850, 0x4a554545, 0x011b7098, 0x9855641b,
		0x3f00630b, 0xed5d3fed, 0x33113912, 0x8232e910, 0x06d4410b, 0x333f332a, 0x33ed2f01, 0xdc10ed2f, 0x12210583, 0x20208217, 0x08816d2f, 0x67623320,
		0x12146a05, 0x2008105b, 0x1a886013, 0x04420120, 0x43372012, 0x03230844, 0x60022e34, 0x13261298, 0x13330123, 0x9c601a11, 0x111b2107, 0x2408105e,
		0x01121e26, 0x10f2470b, 0x5c434e20, 0xac270806, 0x0d18130b, 0x14111f1e, 0x151f581d, 0x0e16151c, 0x01460f17, 0xbb01467b, 0x090b250c, 0x1a12171c,
		0x12090812, 0x600f111a, 0xfe210baf, 0x0f164883, 0x41428c20, 0x38012905, 0x07090c09, 0x0e1b0e04, 0x3e0abe60, 0x6b02c6fd, 0x00020000, 0x01f5ff26,
		0x00b502bf, 0x00320020, 0x31114092, 0x4d001118, 0x820d182d, 0x0b103204, 0x294c000c, 0xb3f8ffb8, 0x234d0010, 0xb3e0ffb8, 0x2d07840f, 0x0d1540f0,
		0x204c000e, 0x4d000d10, 0x24832020, 0x34831320, 0xffb81029, 0x0e0e40f0, 0x830f4d00, 0x0e2d083d, 0x4d000c08, 0xd8ffb809, 0x000e1a40, 0x82301e4d,
		0x8226340c, 0x16040416, 0x1b882133, 0x882b071b, 0x07006811, 0x3fcd2f00, 0x2f3911ed, 0x056977ed, 0x1810ed21, 0x24119fd4, 0x07062213, 0x0b0e6f27,
		0x35022e2d, 0x33023e34, 0x26171632, 0x72220726, 0x9908098e, 0xbe262635, 0x0c142e1a, 0x481f3d1a, 0x1616375e, 0x2c435935, 0x1a162d43, 0x26364f35,
		0x4e06113a, 0x21342318, 0x27190d10, 0x20362a1a, 0x023a1a0e, 0x45090b6e, 0x603a0b0b, 0x803c427c, 0x3c244369, 0x562c2a4e, 0x0d172a43, 0x1ff86f67,
		0x1b1f3f32, 0x34172733, 0x192a5f50, 0x00020015, 0x01000009, 0x006b02eb, 0x0016000b, 0x06274047, 0x78120c12, 0x0b14060b, 0x1105060b, 0x0078110c,
		0x00001405, 0x0b000c05, 0x0b170018, 0x05060c44, 0x79111241, 0x3f004400, 0x333f32ed, 0xdc823f33, 0x11ce1023, 0xea4f1839, 0x7d3f080a, 0x333031c4,
		0x3337033e, 0x0317031e, 0x2107030e, 0x1709032e, 0x1e322d2c, 0x31351b66, 0x0af2112a, 0x12282621, 0x28121501, 0x9d592026, 0x444e9295, 0x429ea5a2,
		0x601b2302, 0x5050957d, 0x82607d95, 0x3a00258e, 0xba019fff, 0x073b9382, 0x0b401b00, 0x05090102, 0x07040806, 0x00060259, 0xcd3f332f, 0xcdd61001,
		0x18cdde10, 0x3209f756, 0xdc52ba01, 0xfd6b0252, 0xfd860234, 0x00cc027a, 0x82310001, 0x82bf203f, 0x172d083f, 0x2a405400, 0x03001300, 0x0a0f7813,
		0x0a0f0f14, 0x19041212, 0x78030300, 0x07140a07, 0x0f0f0a07, 0x0a0a1807, 0x0f030000, 0x07411013, 0x305e8203, 0xcd3f32cd, 0x19391132, 0x1801332f,
		0x32c6102f, 0x26d8822f, 0x01c4107d, 0x84ce1018, 0x8208200b, 0x2d78820c, 0x21070606, 0x36352115, 0x032e3736, 0x0a823527, 0x031e2f08, 0x62384c01,
		0xfe2e0121, 0x41631e72, 0x1a2c4130, 0xfe8a0107, 0x322b0ed8, 0x530f0134, 0x3b454296, 0x4962963f, 0x0e274262, 0x44174638, 0xa3824e4c, 0xe8821220,
		0x7902e22a, 0x60002d00, 0xff0700b9, 0x2408ee55, 0x000d2e40, 0xd54f184d, 0x130f3d09, 0x0a761813, 0x2f0a1010, 0x22252529, 0x28280076, 0x25132e00,
		0x79290f25, 0x1d442712, 0x0808c618, 0x11323223, 0x06684233, 0x332f3222, 0x1021ad83, 0x5a0882ed, 0x1321053d, 0x077c6434, 0x07020e28, 0x35231533,
		0xaa6a033e, 0x16142208, 0x08108217, 0x032e332c, 0x4f3c2320, 0x3c4f2d2d, 0x201a1223, 0x18c5650d, 0x100c1824, 0x21213120, 0x2a102031, 0x1167c736,
		0x010f1a1f, 0x4b714b4c, 0x04822626, 0x434c283d, 0x33461639, 0x504b4118, 0x3e502d27, 0x513d2524, 0x3c904e2d, 0x3e194633, 0x82004843, 0x00012e00,
		0x01e4002e, 0x002a01c7, 0xb30d0003, 0xef991803, 0x21132f0a, 0x012e2115, 0x0167fe99, 0xff00462a, 0x537600ff, 0x06022406, 0x83006e01, 0x00b12a0f,
		0x014401ca, 0x00070263, 0x20478211, 0x3e4b84d6, 0x01f3ff1d, 0x00bb02e2, 0x402e000e, 0x04070814, 0x06050104, 0x00010d10, 0x055c0804, 0x820e0e06,
		0x2f420809, 0x2f2f32cd, 0x01333f33, 0x10cddd2f, 0x3911cdde, 0x33332f19, 0x37133031, 0x13171616, 0x2e230333, 0x1d072703, 0x142b1d83, 0x4ac1499d,
		0x1b17160b, 0x39014110, 0x3e7b502b, 0x38fd6002, 0x49454324, 0xa982152a, 0x001e3708, 0x01d60188, 0x000b0085, 0x0037002b, 0x1f1b4039, 0x0303350f,
		0x09272f17, 0x22223217, 0x1f35030f, 0x1c061204, 0x0c0c2c12, 0x2f001200, 0xcd2f33cd, 0x12cddc10, 0x08823917, 0xcd2f0123, 0x2a76822f, 0x3939cd2f,
		0x32373031, 0x4c263736, 0x172306ff, 0x18272622, 0x430d7c6f, 0x272009f1, 0x0805d069, 0x07062222, 0x14981616, 0x250f1023, 0x21211713, 0x0e3524e0,
		0x1024330f, 0x19192429, 0x24102924, 0x340f0f33, 0x182a0d83, 0x13292418, 0x16212116, 0x29822414, 0x25c22208, 0x22251f20, 0x3a222322, 0x28171728,
		0x25311d0c, 0x0c1d3025, 0x29171729, 0x25301d0c, 0x0c1d3125, 0x081c823a, 0x20242224, 0x00002520, 0x4b000100, 0xa8015bff, 0x1700b502, 0x0c401d00,
		0x17130c07, 0x14181917, 0x5a040810, 0xb9823f00, 0x1211013e, 0xddce2f39, 0x133031ce, 0x32333634, 0x23151732, 0x11150622, 0x22230614, 0x33352722,
		0xd02ca782, 0x13035853, 0x2c332717, 0x12055851, 0x2b2b0782, 0x615afa01, 0x333e4701, 0x845919fe, 0xffff3107, 0x5f002500, 0xb101cf01, 0x61003602,
		0x06006000, 0xa2200582, 0x3e087b84, 0x010e002e, 0x00fd01c7, 0x40420013, 0x0b0c0f21, 0x10070408, 0x05020112, 0x07061104, 0x100d0a07, 0x00031111,
		0x0b050608, 0x10010c02, 0x2f00120f, 0x32ddcd33, 0xcddd32de, 0x332f0133, 0x84cd2f33, 0x17113404, 0x17121139, 0x37303139, 0x35233733, 0x07173733,
		0x84231533, 0x37273a03, 0x3d882e23, 0x3a3be9c5, 0x3d89652a, 0x3b3aeac6, 0x77ca642a, 0x55207547, 0x82058447, 0x2e9b8282, 0x0101002e, 0x020302c7,
		0x009f0127, 0x821dff00, 0xfd1f229d, 0x3b17943d, 0x003dfd21, 0xff270002, 0x02cd01f1, 0x0011007b, 0x408c0021, 0x0f20191a, 0x28174d00, 0x15200482,
		0x0f210483, 0x20098218, 0x2813830c, 0xe0ffb807, 0x4d000db3, 0x21078203, 0x08821d40, 0x1717053c, 0x1f0a121f, 0x1f0d001c, 0x1c22231f, 0x00000a12,
		0x16201f05, 0xb81f4d00, 0xc86ad0ff, 0x40c02306, 0x1082100d, 0x30170d28, 0x4c001110, 0xf2820517, 0x332f2b28, 0x122b2b2b, 0xed821939, 0x1101332b,
		0x332f3912, 0x19cd18dd, 0x23048210, 0x33113311, 0x0809d947, 0x033e1325, 0x17031e37, 0x2e070606, 0x032e2503, 0x07030e27, 0x36171616, 0x361e2736,
		0x1a1a3233, 0x1e363332, 0x8334643b, 0x32013f07, 0x1e1e1e12, 0x1d1f1111, 0x3822111f, 0x01382223, 0x4f573136, 0x49252549, 0x6231574f, 0x0782499a,
		0x1f32563c, 0x182d3136, 0x35312e18, 0x2e603d1f, 0x00005e2e, 0x1c000300, 0xcc010000, 0x0982b502, 0x000f4908, 0x404d0026, 0x0c20122a, 0x83074d00,
		0x007f010d, 0x161e2028, 0x10257f22, 0x23012723, 0x1a17174c, 0x214d1488, 0x0a108524, 0x0202048a, 0x0049101e, 0x1033333f, 0xed10edde, 0x32ed3f32,
		0x01333f2f, 0xce32d610, 0xce33ccfd, 0xd4291482, 0x2b3031ed, 0x33112321, 0x4d941827, 0x3505220a, 0x21b78234, 0x2f430717, 0x33152405, 0x82112315,
		0x35380801, 0x5353c001, 0x1f1f162a, 0x1f1f1716, 0x5a56a4fe, 0x0a0c182f, 0x2c381317, 0x35537b7b, 0x1e54d001, 0x1d1d1919, 0x541e1919, 0x06615a2a,
		0x3f030448, 0xfe452936, 0x458b0175, 0x4422bf92, 0xba892440, 0xba822120, 0xba8c2420, 0xbc83b482, 0xde23b982, 0x8b333fed, 0x82cd20b7, 0x86cd20b7,
		0x2eb6e1b7, 0x1c000200, 0xeb01f7ff, 0x0b00b502, 0x82002200, 0x0b2508b5, 0x067f030b, 0x121a1c24, 0x0c217f1d, 0x4c1f2320, 0x88161313, 0x201d4d10,
		0x490c1a85, 0x0b4d0504, 0x00510088, 0x88b4823f, 0x100123b6, 0xb58532d6, 0x33eddc31, 0x0530312f, 0x11352626, 0x1e141137, 0x41011702, 0xe0291667,
		0x05533844, 0xfe0f140c, 0x0d644166, 0x3e02092f, 0x0e2e0242, 0x1a15d2fd, 0x01030810, 0x11684193, 0x2faeaf40, 0x7400ffff, 0x80017d01, 0x0602e402,
		0x6b006f01, 0x872b0f82, 0x88018401, 0x0602dd02, 0x83099400, 0x827c200f, 0x8378200f, 0x8d00211f, 0x80201f84, 0x0f852f82, 0x83028e21, 0x8269201f,
		0x8380201f, 0x7001212f, 0x77201f84, 0x6f201f82, 0x71210f84, 0x201f83f8, 0x220f8275, 0x82df027a, 0x8472205f, 0x827e200f, 0x847d202f, 0x8473201f,
		0x8277200f, 0x847d201f, 0x8474207f, 0x017c243f, 0x84810183, 0x8475200f, 0xff74261f, 0x00800160, 0x06f773c7, 0x00004e33, 0x8700ffff, 0x880167ff,
		0x0702c000, 0x09009400, 0x201385fe, 0x2013827c, 0x82278378, 0x860020a7, 0x82802013, 0x2213853b, 0x8602008e, 0x82692013, 0x83802027, 0x87af823b,
		0x82772027, 0x846f2027, 0xff712213, 0x202786f8, 0x22138275, 0x82c2007a, 0x88722077, 0x827e2013, 0x847d203b, 0x88732027, 0x203b8313, 0x219f847d,
		0x4f870074, 0x66ff7c24, 0x13848101, 0x27857520, 0x00010039, 0x01ee01d2, 0x00b50221, 0xb5110003, 0x03034000, 0x2f000280, 0x8201cd1a, 0x30312e03,
		0x35230701, 0x37182101, 0xc7c7b502, 0x362b8200, 0x0156ffab, 0x00d3ff40, 0xb613000e, 0x0700010a, 0x000f000a, 0x82dede10, 0xcecd252d, 0x33173031,
		0x4606e44f, 0xee350584, 0x3d010150, 0x0f16142e, 0x052d1321, 0x3039040b, 0x1d1d3006, 0x2a008200, 0x02b90001, 0x023b0120, 0x820f00b9, 0x0f0a2773,
		0x000a0904, 0x45832f00, 0x4582dd20, 0x23012908, 0x34353426, 0x1737023e, 0x0115030e, 0x12014f09, 0x1d12241d, 0x070e120b, 0x0b052002, 0x202f2003,
		0x08280413, 0x18201610, 0x00204a82, 0x0221bf82, 0x32bfa208, 0xff00adad, 0xff7100ff, 0x02820183, 0x000602e7, 0x8c2a000b, 0x840c200f, 0x018c260f,
		0x0168010d, 0x221f825b, 0x82360010, 0xff45261f, 0x02af0185, 0x200f82e5, 0x261f8412, 0x01b5ff28, 0x82b502d4, 0x0023220f, 0x201f823c, 0x201f828f,
		0x201f847e, 0x201f843e, 0x200f8246, 0x200f84ae, 0x200f843f, 0x200f8276, 0x200f8465, 0x200f8440, 0x200f824f, 0x200f84ab, 0x200f845e, 0x200f8249,
		0x200f84a5, 0x260f8460, 0x016f0090, 0x82fa0155, 0x006c225f, 0x265f8237, 0x01c40072, 0x82e20182, 0x0072220f, 0x260f8217, 0x01120145, 0x825801af,
		0x0073220f, 0x200f8226, 0x200f8200, 0x200f84f4, 0x200f8474, 0x203f829f, 0x203f8464, 0x3a3f8478, 0x01faffb6, 0x0270023c, 0x007c0007, 0x009f0000,
		0x00ffff00, 0x0185003f, 0x82e4019d, 0x84862043, 0x825520e3, 0x84b5200f, 0x8496200f, 0xff5c260f, 0x029a01f8, 0x20338273, 0x2033829a, 0x380382a2,
		0xff140002, 0x02cc01f5, 0x001a00b5, 0x40990029, 0x1018241c, 0x20244d00, 0x3904820f, 0x4d000e18, 0x100f281f, 0x181f4c00, 0x4c000e0d, 0xe0ffb80e,
		0x000a08b4, 0x08820a4c, 0x000ab323, 0x0807844d, 0x4d000842, 0xd0ffb809, 0x00093240, 0x0c82214d, 0x0002292b, 0x16187f03, 0x15011500, 0x0015032a,
		0x19071818, 0x1e1b4d1a, 0x51111488, 0x04882629, 0x07100700, 0x07400720, 0x50070804, 0x5d5e3f00, 0x3f32ed33, 0x122e0384, 0xcd332f39, 0xd6100132,
		0xfd33cd5d, 0x6218cd32, 0x2b260c8d, 0x1533132b, 0xb0491523, 0x22232a09, 0x23112726, 0x37353335, 0x06496d11, 0x022e3e08, 0x07062223, 0x0fa2a2a8,
		0x462d2236, 0x381e1a30, 0x5236304e, 0x5242421a, 0x40102412, 0x2c1b0d49, 0x0e331c1e, 0x653e6202, 0x40241309, 0x5a383659, 0x0810223f, 0x453e1702,
		0x0593fd0e, 0x3ec61805, 0x03003f0a, 0xfbff1200, 0x7102e201, 0x31002200, 0xc7003e00, 0x383a2f40, 0x3a4d0012, 0x4d001128, 0x09822836, 0x82303621,
		0x402f2109, 0x2e200982, 0x2e2c0983, 0x4d001018, 0x12113029, 0x10294c00, 0x22280a82, 0xb3e8ffb8, 0x214d0009, 0xb4250782, 0x4c000c0a, 0x23088218,
		0x4d000cb3, 0xf0220782, 0x07840bb3, 0x0ab3e022, 0xe8270784, 0x00093740, 0x8210114d, 0x114a081d, 0x4d000b18, 0x1a76381d, 0x20762c1a, 0x733e2340,
		0x06200600, 0x09060802, 0x0f010f00, 0x060c0c3f, 0x1d14793b, 0x32327923, 0x7c274114, 0x3f004300, 0x2f393fed, 0xed1039ed, 0x012f3232, 0xdd5dd610,
		0xed5d5ede, 0xedde1032, 0xdc722f33, 0x22052c14, 0x1127022e, 0x14150606, 0x62260717, 0x0a710523, 0x0306240b, 0x7e161615, 0x2e230502, 0x85272302,
		0x269b0809, 0x07062223, 0x210e1f01, 0x260d2123, 0x02430421, 0x5a482c05, 0x3d240f2f, 0x262d1a2d, 0x965b3c33, 0x160b190b, 0x15121f29, 0x22182d23,
		0x1e261218, 0x092c2e14, 0x02050b14, 0x02040603, 0x1d200518, 0x06081110, 0x39320d19, 0x2610071c, 0x4a2c2e3e, 0x3c4c0e0e, 0x26015d5d, 0x0a0202dd,
		0x20232d1a, 0x440a192a, 0x1e261708, 0x02012d36, 0x02000000, 0xfbff3600, 0x6b02c301, 0x1f001000, 0x16407900, 0x00102018, 0x0f18184d, 0x20144d00,
		0x4c00100f, 0x000e1813, 0xffb8084d, 0x840ab3e8, 0xb3e02507, 0x054d0008, 0xb4240f82, 0x4c001211, 0xe0200882, 0x07821883, 0x1c40e822, 0x163a1982,
		0x10100776, 0x1d012107, 0x1c200d73, 0x11010179, 0x410e7900, 0x430a7c11, 0x12553f00, 0x18012006, 0x20072b5f, 0x0be36710, 0x41151321, 0x4708061a,
		0x27262223, 0x03152111, 0x35023e32, 0x23022e34, 0x16161523, 0x5d3b4288, 0x777f2140, 0x01215323, 0x3a22bb56, 0x2d18192b, 0x1a3e273f, 0xa625021d,
		0x354a2d14, 0x09066163, 0xfe466102, 0x301d0d1b, 0x1c312524, 0x0103f80c, 0x4730db84, 0xcc01f5ff, 0x1400b102, 0x89002300, 0x181e2a40, 0x1e21db82,
		0x20db8228, 0x21d5831e, 0xe0833019, 0x0e28192a, 0x10194d00, 0x0b4d000d, 0x0b281e83, 0x4d000f10, 0xf0ffb806, 0x0782d683, 0x09b3e022, 0xe8220f84,
		0xde822340, 0x821b2008, 0x09141409, 0x7f150125, 0x08011100, 0x85002411, 0x18154d12, 0x510e1188, 0x01882023, 0x43005004, 0xed20055b, 0x096b6718,
		0x6805924e, 0x2b210bcd, 0x0f584313, 0x01152122, 0x320c5543, 0x23390f9a, 0x1b334a2f, 0x32523a20, 0x011a5637, 0x1800ff53, 0x220b8fc9, 0x43ac6b02,
		0xa4230c53, 0x43ddfd46, 0x02220b51, 0xf7840b00, 0x1500b522, 0x8324f782, 0x201e1540, 0x1e20e282, 0x1920e283, 0x19220983, 0x4b440d18, 0xb3e02a0c,
		0x094d0010, 0xb3e8ffb8, 0x8407840f, 0x210f83fa, 0xfb822240, 0x0c821b32, 0x7f160325, 0x01140000, 0x16241408, 0x11148818, 0x042eec83, 0x00005007,
		0x004d0315, 0x1939cd3f, 0xf787182f, 0xd6100126, 0xedce5d5e, 0x0ec77418, 0x36361323, 0x26f48f37, 0x32331613, 0x44343536, 0x0b250547, 0x10274a20,
		0x33f48936, 0x25521a53, 0x0e4e4523, 0x1d212f1e, 0x78020e34, 0xf60a2013, 0x2623f38c, 0x440a15fe, 0x02310b43, 0xfbff0900, 0x7102c301, 0x21001000,
		0x00b99600, 0x05537b18, 0xffb81723, 0x82de83d8, 0x83d02007, 0x450782de, 0x15200553, 0x07821886, 0x1883e020, 0x0a220f84, 0x07824d00, 0x82b3e821,
		0x290782f6, 0x082940d8, 0x180e4d00, 0x9750000e, 0x76003b05, 0x09112316, 0x1c001e73, 0x221c0801, 0x211d1e1e, 0x11117c08, 0x7c0c4121, 0x1c444319,
		0xcd102606, 0x012f1939, 0x14044118, 0x252b2b22, 0x2222ed84, 0xf7431107, 0x36272405, 0x5e323332, 0x560806f6, 0x36362711, 0x19710137, 0x0d20392a,
		0x27130d21, 0x28321a10, 0x240bd719, 0x6d79ec0e, 0x3e215322, 0xc22a4720, 0x0d1f3428, 0x03fcfe02, 0x321e0d01, 0x64ca02ed, 0x01090663, 0x201343e6,
		0x0000000b, 0xff2a0001, 0x02c601f3, 0x001f0079, 0x1e114081, 0x4d001228, 0x8211201e, 0x0f182d04, 0x1a4c0010, 0xb3e8ffb8, 0x144d000d, 0x40280782,
		0x000e0d41, 0x10280f4c, 0x2683db82, 0x82180e21, 0x08083226, 0x084d000c, 0x4d000b28, 0x12111004, 0x18044c00, 0x830a820c, 0x7606330f, 0x0d0d2117,
		0x0000201f, 0x461c7c03, 0x7c090c0c, 0x376a4512, 0x057a5108, 0xad6bde20, 0x2b2b230c, 0xce42372b, 0x18262006, 0x20088aaa, 0xf842181e, 0x27340807,
		0x1d3e233f, 0x58596253, 0x1523401d, 0x2c2c290f, 0x425b3512, 0x5d452826, 0x234d2d35, 0x7a0f135e, 0x0d827880, 0x100a4114, 0x4f26050a, 0x7a53547a,
		0x1413274f, 0x2e20df83, 0xeb37df82, 0x2e00be02, 0x0b409600, 0x000e1816, 0x0d20164d, 0xb8124d00, 0x83b4e0ff, 0x210882b1, 0xd382b3d0, 0xc0250782,
		0x4d000fb3, 0x07a3440b, 0x0b240884, 0x054c000c, 0xb3231182, 0x824d0012, 0xb3f02107, 0x0782f382, 0x86b4e821, 0x40f02618, 0x000a091d, 0x29e5824c,
		0x08301126, 0x2a2f1976, 0xf1831e23, 0x10451e27, 0x147c0d10, 0x18f18846, 0x23089150, 0x332f33ce, 0x210cd643, 0x077f2601, 0x021e2106, 0x210b227d,
		0x0e823e34, 0x36361725, 0x4d163233, 0x650805ec, 0x8401020e, 0x24172f1c, 0x18172a3b, 0x1a233a2a, 0x20151e3a, 0x56322947, 0x4127233f, 0x1d242d55,
		0x0a2a2e0d, 0x050d081b, 0x130f0512, 0x12020a0e, 0x42250e10, 0x5e40375c, 0x130f1e3e, 0x27131444, 0x4c537a4f, 0x0b2c5378, 0x05061f31, 0x1304033d,
		0x0000261f, 0x31000100, 0xe601f5ff, 0x31003202, 0x18b54a00, 0x00410e30, 0x0db32905, 0xb8064d00, 0x1c40e0ff, 0x23300882, 0x11290000, 0x1b820833,
		0x00262d32, 0x50208805, 0x882ada82, 0x49015116, 0xed3f3f00, 0x03822f32, 0x01cddc27, 0x10edd610, 0x27db88de, 0x23032e01, 0x14150622, 0x0e20d286,
		0xab550d82, 0x08d38d09, 0x16058254, 0x490f1f1b, 0x3c27124f, 0x1037212b, 0x231b070c, 0x573a1228, 0x3c201e3b, 0x1c0e3554, 0x2d320a0e, 0x0e091b0b,
		0x12061007, 0x01050b14, 0x06070180, 0x26555705, 0x0b182c3e, 0x08054508, 0x40240407, 0x5a353559, 0x02032541, 0x05062734, 0x1403033c, 0x7318291f,
		0x12301213, 0xe401fbff, 0x1b007102, 0x6d002a00, 0x48264d40, 0x2621ea82, 0x36de8220, 0x00121825, 0x1110254d, 0x10224d00, 0x4c001211, 0x000e1821,
		0x8210214d, 0x43072019, 0x2d0808c2, 0x2c057624, 0x0e007329, 0x0e200e10, 0x00110e03, 0x17080117, 0x0a7c1f2b, 0x290e1443, 0x00410079, 0xcc32fd3f,
		0x1001ed3f, 0xd55d5ed6, 0xdc185dd6, 0x01200e2f, 0x09be4518, 0x210dd647, 0xc7471613, 0x23263106, 0x01070622, 0x3b502f08, 0x503b2222, 0x16391a2f,
		0x3b05c347, 0x0c554b33, 0x1f061008, 0x42112130, 0x04100841, 0x4c227102, 0x78565578, 0x0609224b, 0x2e0ab547, 0x051b3935, 0x0102d4fd, 0x415d3b1b,
		0x4602767e, 0x312005c3, 0xbf20ef82, 0x23069f47, 0x1e00b97f, 0x2705cf44, 0xe0ffb81d, 0x4d000fb3, 0xe8210782, 0x27e782b3, 0xe8ffb819, 0x4d0010b3,
		0xd8200782, 0x07821783, 0x3040f822, 0x0b271882, 0x4d001210, 0x8211180b, 0x08202404, 0x83074d00, 0x140f3b04, 0x1b210373, 0x00000976, 0x79152009,
		0x11010f0f, 0x0043067c, 0x00410179, 0xbb57ed3f, 0x3513231c, 0xa2181121, 0x33270984, 0x36320335, 0x57233537, 0x3c0806b0, 0x22570168, 0x7f772353,
		0x3b5d4021, 0x1d124942, 0x3f273e1a, 0x2b19182d, 0x4625023a, 0x06099ffd, 0x4a356361, 0xfea6142d, 0xf802021b, 0x25311c0c, 0x0d1d3024, 0x28000200,
		0xad01f5ff, 0x05a34702, 0x00b95f33, 0xb4e8ff1f, 0x4c000e0d, 0xf0ffb81f, 0x4d000cb3, 0x2b07821a, 0x000e2a40, 0x0f180f4d, 0x0e4c0010, 0x143bbf83,
		0x25047f23, 0x010c821d, 0x15240c01, 0x11148818, 0x88202350, 0x01510704, 0x834d0285, 0x4a3320c2, 0x805805e3, 0x23012111, 0xc442c086, 0xbe741809,
		0xfe5a240e, 0x181b5101, 0x200c89cf, 0xa4cf180e, 0x6b02260a, 0x085cfd46, 0xb8741810, 0x00023516, 0x015bff27, 0x00db01cc, 0x003c0028, 0x3a00b9e1,
		0x1e40e8ff, 0x362cb583, 0x4d001018, 0x000f1036, 0x1228304d, 0x20210482, 0x83048211, 0xb82c210e, 0x8206bd44, 0xb3e82108, 0x27201f82, 0x40261082,
		0x4d000919, 0x04822021, 0x0b101d34, 0x181c4d00, 0x194d0009, 0x00121118, 0xffb8094c, 0x5083b4e8, 0xe0230882, 0x850e0db4, 0x0cb32311, 0x10844d00,
		0x000b0a24, 0x4082074c, 0x4310b321, 0x2d0805f5, 0x000f0eb4, 0xffb8034c, 0x0b2340f0, 0x052e4d00, 0x08821729, 0x00823308, 0x1f82293e, 0x3d1f0e0e,
		0x1205052e, 0x50248838, 0x89120f0f, 0xe2444b0b, 0x39122106, 0x4a085157, 0x122005da, 0x11368118, 0x87182b20, 0x8b5e09dd, 0x023e270d, 0x27263435,
		0xce59032e, 0x021e2605, 0x021e1405, 0x09755717, 0xcc017008, 0x28382310, 0x4e5a291f, 0x0f114f2c, 0x0c2c4409, 0x2d131b20, 0x32402329, 0x5032171d,
		0x334f373a, 0x14b1fe19, 0x26172b21, 0x0d0c1e32, 0x2023301d, 0x010f1e2f, 0x393f2007, 0x32131031, 0x10333526, 0x13054406, 0x0b0d0702, 0x171a2718,
		0x3249382d, 0x243b4925, 0x294e3922, 0x202a3724, 0x2e260c0d, 0x331c1a34, 0x26151727, 0x00000032, 0x82280001, 0x99200804, 0x0b006b02, 0x19403200,
		0x73020606, 0x08080d0b, 0x0c010404, 0x06067903, 0x0b79020a, 0x0a790744, 0x210ef542, 0xf6822f32, 0x312f3229, 0x21353330, 0x83352335, 0x21310805,
		0x1f012811, 0xf8fee8e8, 0xdb465a01, 0xfd46be46, 0x00020095, 0x01f3ff19, 0x007902d8, 0x0026001d, 0x231640a2, 0x00121118, 0x0d28234c, 0x10234d00,
		0x2904820c, 0x4d000b08, 0xe8ffb820, 0x12825c40, 0x0e18182b, 0x10184d00, 0x154d0008, 0x210e8218, 0x04821014, 0x82201021, 0x180a2704, 0x0a4d0012,
		0x04821120, 0x100f1825, 0x84014c00, 0x28012646, 0x014d0010, 0x211f8240, 0x46822001, 0x76002639, 0x761e2812, 0x1a08081a, 0x26790027, 0x7c210226,
		0x07074617, 0x470d7c02, 0x12200789, 0x201c6f5b, 0x2900822b, 0x22232601, 0x2707020e, 0x684b033e, 0x6e0e2005, 0x630805b7, 0x06173736, 0x3e323316,
		0x84013702, 0x2313ac0c, 0x1507181f, 0x30281c05, 0x41614219, 0x553f241f, 0x02706631, 0x49015001, 0x2435223d, 0x4a010214, 0x0c0c08e9, 0x0e054104,
		0x5630090d, 0x7a524575, 0x9b9a2951, 0x45051508, 0x3b256964, 0x00002449, 0xff280001, 0x02d401f4, 0x00360076, 0x3200b9ba, 0x0eb4f0ff, 0x2827d682,
		0xb3d0ffb8, 0x824d0012, 0x40e82207, 0x20ed8238, 0x21f78322, 0x09821022, 0x82202121, 0x18212117, 0x082b0984, 0x1d4c000a, 0x00121118, 0x8220194c,
		0x40152110, 0x15211a82, 0x25098328, 0x4d000818, 0x1b44b80f, 0x44082006, 0x290806ec, 0xf0ffb804, 0x00102540, 0x0029294d, 0x1c380d00, 0x1f1f7630,
		0x37177606, 0x3679001c, 0x2a240936, 0x247c2d2a, 0x090c0c45, 0xbf47127c, 0x12113309, 0x39ed2f39, 0xedd61001, 0x32ed2f33, 0x2f32ce10, 0xc6472f32,
		0x05da420c, 0x2505d444, 0x36323316, 0xf5461737, 0x19372009, 0x47095200, 0x1a4705cb, 0x33850805, 0x292a6c01, 0x57203649, 0x16543947, 0x30240b19,
		0x5936223b, 0x2616223f, 0x37361b32, 0x2c4b361e, 0x242e351c, 0x50141b0c, 0x22433630, 0x211e4035, 0x1a0a2401, 0x353e242f, 0x05420b1d, 0x140a0e0f,
		0x2432452c, 0x071a2836, 0x292b4c11, 0x0613273d, 0x41070e0a, 0x2933150b, 0x09182920, 0x00010000, 0x0159ff03, 0x006b02c3, 0x402d0017, 0x12151516,
		0x73001419, 0x17180f08, 0x18141479, 0x41107913, 0x00057c0c, 0x095f4d2f, 0xd885cc20, 0x33303126, 0x23020e14, 0x09314e18, 0x21112c08, 0x33152115,
		0x0bb62315, 0x0d27311d, 0x09080a1c, 0x17200811, 0xf3fe5f01, 0x3e27eded, 0x0203172b, 0x2b010242, 0x467a0229, 0x490045c1, 0x2f2e0b73, 0x1cb5a600,
		0x4d000810, 0xe8ffb81b, 0x07840eb3, 0x0db3f825, 0x83184d00, 0x2307820f, 0xd0ffb817, 0x0b201783, 0x200a7449, 0x201086d8, 0x232883e0, 0xf0ffb805,
		0x20067b49, 0x067b49e8, 0x17821f84, 0x2140e022, 0x273d4182, 0x11000021, 0x08311273, 0x2b301976, 0x11111e24, 0x7c03000d, 0x10451e21, 0x16137c0d,
		0x08574d46, 0x2f391222, 0x24088149, 0x332f33ed, 0x0dbb41cc, 0x210e8349, 0xae463335, 0x1632210a, 0x3a0f8549, 0x2916301a, 0x1414293c, 0x1d2e422a,
		0x13520820, 0x81783954, 0x2c564329, 0x490e1f10, 0x29361184, 0x38315b45, 0x0825425c, 0xdefeea04, 0x9ba81507, 0x28517951, 0x85490605, 0x0002320a,
		0x015cff0d, 0x006b02e8, 0x01330025, 0x33104035, 0x08e94210, 0x000e1829, 0xffb81e4d, 0x822d40e8, 0x20162608, 0x164d0012, 0x271c8230, 0x000b2011,
		0x0a28114d, 0x0b8fd218, 0x0d18102b, 0x104c000e, 0x4d000c20, 0x06e8420c, 0xf0220782, 0x0f850fb3, 0x1d83b420, 0xe0211082, 0x242082b3, 0xe0ffb80b,
		0x824282b3, 0x4ed82007, 0xd82906b0, 0x12110a40, 0x08034c00, 0x067f440e, 0x38822220, 0x1f403037, 0x76304d00, 0x201b1709, 0x171a781b, 0x171a1a14,
		0x25202505, 0x05e55e78, 0xffb82a25, 0x823740c0, 0x762a3e21, 0x13202613, 0x0901090f, 0x20132013, 0x201a0309, 0x02003000, 0x1a3f3500, 0x1a7f1a6f,
		0x08048303, 0x341a0221, 0x26412500, 0x17170520, 0x2d411a1b, 0x2f000e79, 0x39333fed, 0x33333311, 0x1001333f, 0x82715dc6, 0x17112e03, 0x182f1939,
		0x115d2f2f, 0xed103912, 0x0c255f2b, 0x82180121, 0x30312211, 0x29421800, 0xb74b1809, 0x0e01240b, 0x18170703, 0x34092842, 0x37363435, 0x27262637,
		0x17031e33, 0x0337033e, 0x15060607, 0x05384e14, 0x27268308, 0x2a0ce801, 0x371e3b33, 0x1d0c100b, 0x30252530, 0x0e0d0c1d, 0x2a613738, 0x24201056,
		0x2e151b2a, 0x9a09212a, 0x1b0a0822, 0x0a1b1a1a, 0x1f6b0208, 0x428a7e68, 0x1130166c, 0x18242b14, 0x142b2418, 0x6d1c2a11, 0x2d71ed72, 0x426b5d55,
		0x596d7836, 0x40eafd18, 0x180e1c10, 0x0e182323, 0x00000f1d, 0xff240001, 0x02ce01f6, 0x002d00b5, 0x2b00b994, 0x0cb4e8ff, 0x2b4c0010, 0x40e0ffb8,
		0x4d000b19, 0x04833015, 0x0a09202f, 0x20144c00, 0x144d000e, 0x4d000c18, 0x211d8210, 0x07840eb3, 0x0cb3e829, 0xb80f4d00, 0x82b3d0ff, 0x22078227,
		0x840ab3e0, 0xd838080f, 0x00092240, 0x177f004d, 0x7f0a2217, 0x21242f0d, 0x202e227f, 0x2825881d, 0x4d242350, 0x88054a22, 0x490b5112, 0xed3f3f00,
		0x3f333f3f, 0x0132ed33, 0x32edd610, 0x11edde10, 0x4108bf64, 0x25200631, 0x0d8ae118, 0x2e222324, 0x514f3502, 0x23112207, 0x08724f11, 0x1b014b08,
		0x0c130d07, 0x060d120c, 0x321d0b4f, 0x1c322828, 0x110d090a, 0x08180b08, 0x210b4e4e, 0x2027140f, 0x3027bb13, 0x1a08091a, 0x16012730, 0x4427defe,
		0x321c1c31, 0x1c8a2744, 0x0a061323, 0x027efe05, 0x09ee0ea7, 0x39220e0a, 0x0082002b, 0x4400012f, 0xc801f3ff, 0x15006b02, 0x29404500, 0x26f68313,
		0x000b1013, 0x8220134d, 0x73053be0, 0x0d010000, 0x0017040d, 0x01080101, 0x090c0c16, 0x0546107c, 0x41027900, 0x645a3f00, 0x10012805, 0x105d5ec6,
		0x882f32ce, 0x231327d0, 0x23152135, 0x4a181411, 0x22080c5b, 0x530178bc, 0x1a312b89, 0x0c100b29, 0x3e2e203f, 0x25021025, 0x80fe4646, 0x060e2c3d,
		0x150f0945, 0x8230452c, 0x59002169, 0x9b200482, 0x2a088b82, 0x404a0013, 0x09101026, 0x0613130a, 0x73050103, 0x0a000c0e, 0x0a0a0801, 0x0f001415,
		0x0b041179, 0x0e0e0179, 0x0a054111, 0x84440879, 0x2f392188, 0x0a5b6118, 0xce5d5e2a, 0xce32fd33, 0x102f32cd, 0x31260382, 0x33150130, 0x03822315,
		0x33352124, 0x03842335, 0x0115213b, 0x785b5b23, 0x5c78befe, 0x4201785c, 0x41c22502, 0xdc4646dc, 0x4646c241, 0x31008200, 0x00400001, 0x02fb0100,
		0x001d0077, 0x0d3e406e, 0x0882120d, 0x0b783708, 0x0b0b140d, 0x120d130d, 0x1318780d, 0x13181814, 0x0b010b2f, 0x1f120505, 0x73191d18, 0x1a101a00,
		0x1e1a0802, 0x0d0d181d, 0x1a411b1a, 0x44131244, 0x7c09000b, 0x9f834502, 0xeb183220, 0x4f5009ca, 0x32ed2805, 0x32ce1032, 0x435d332f, 0x08220a4d,
		0xab82c47d, 0x08095a4e, 0x07070645, 0x2317031e, 0x1127032e, 0x11331123, 0x3a353001, 0x24143117, 0x130a1a0e, 0x20691d23, 0x153e4649, 0x413a195d,
		0x52522345, 0x154a2d02, 0x0d0e3916, 0x1a8e282b, 0x32615749, 0x3f4c582e, 0x02d8fe17, 0x82ecfe6b, 0x004408ce, 0x00470001, 0x02de0100, 0x002400b5,
		0x0034405e, 0x1e210500, 0x00228121, 0x00222214, 0x00050006, 0x14060b81, 0x0b00060b, 0x26052222, 0x0b16161e, 0x010d007f, 0x21250d08, 0x891a4922,
		0x4a0d4d13, 0x004a0506, 0xed2ac183, 0x1001333f, 0xed5d5ed6, 0xbe842f32, 0xc100102d, 0x872b0587, 0x1887c47d, 0x84872b10, 0x863720bf, 0x231523b2,
		0x04643411, 0x5d072005, 0x11230513, 0x18373636, 0x2f0f5572, 0x29331e0b, 0x080a200d, 0x21071708, 0x2c6e371a, 0x0f5dd518, 0x18290e21, 0x2609c76b,
		0x5f30f1fe, 0x826c3333, 0xff3635cb, 0x02c201f5, 0x001f00b0, 0x1b224042, 0x110e101b, 0x07090b7f, 0x09257018, 0x090e862b, 0x850a1709, 0x1a1a4d0d,
		0x055b5c17, 0x3806b569, 0x0132ed33, 0x2f391211, 0x33cd5d5e, 0xcd32fdcc, 0x30312f32, 0x022e2205, 0x06154235, 0x33113324, 0x1e4f2315, 0x52012b0a,
		0x0e223a2c, 0xd8868686, 0x70188484, 0x95271012, 0xfe46e43e, 0x18953ed6, 0x3a0b0e70, 0x001d0001, 0x02d40100, 0x002700b5, 0x1e6140a3, 0x4d001328,
		0x86011d95, 0x8313011d, 0x1353080a, 0x4d001230, 0x6c01137c, 0x21210112, 0x03080e03, 0x0e098108, 0x0e090914, 0x00030023, 0x14232781, 0x11232727,
		0x09030311, 0x19192927, 0x0f222809, 0x121f2110, 0x110e2020, 0x10201010, 0x10031030, 0x0e032310, 0x8915090e, 0x09084d1c, 0x4a00274a, 0x18323f00,
		0x2c08d2ca, 0xcd5d2f33, 0x392f3311, 0x3911cd39, 0x052c4d39, 0x3911ce22, 0x2a088e6d, 0x2b101887, 0x01c47d87, 0x82183311, 0x5d5d23f5, 0x03822b2b,
		0x2626212d, 0x07030e27, 0x37033e23, 0x61270727, 0xcb6505ec, 0x168d0805, 0x07173717, 0x0117031e, 0x233c1677, 0x1d262d1a, 0x290d5209, 0x131e3933,
		0x0e59145e, 0x110d1921, 0x20050c05, 0x153e3416, 0x1f6c156f, 0x0f293138, 0x2f5bc65b, 0x245d6567, 0x7c7c7632, 0x38202e37, 0x031b1a1f, 0x05024202,
		0x38262b34, 0x8b924925, 0x00003881, 0x2d000100, 0xc701f3ff, 0x25006b02, 0x29404800, 0x000c180b, 0x0b100b4d, 0x731b4d00, 0x18180516, 0x0073230d,
		0x0d731027, 0x190e2426, 0x16410e19, 0x08057c13, 0x027c2046, 0x08064e46, 0x33112f26, 0xedd61001, 0x29053e45, 0x31ed3333, 0x252b2b30, 0x9c622306,
		0x33112109, 0x23067744, 0x33353526, 0x8207ca41, 0xc73a0834, 0x29192d36, 0x1d251411, 0x1827341b, 0x0e241e4b, 0x4b110a14, 0x15190d04, 0x4b071105,
		0x0c0e180b, 0x2a110c0e, 0xbd013848, 0x413b49fe, 0x3c2b0807, 0x2c15ccd2, 0x02021724, 0xb7832f02, 0xffcfff25, 0x82bd0159, 0x1f3f08b7, 0x2e404c00,
		0x0a190a09, 0x01011502, 0x01010106, 0x7e0a0f0a, 0x06140106, 0x09730601, 0x18730f21, 0x1f101f00, 0x1c201f02, 0x0a06157c, 0x0f410744, 0x3f004101,
		0x333f3f33, 0x1001ed2f, 0x82cc5dd6, 0x8aed18ba, 0x30312609, 0x031e3313, 0x24b38217, 0x27032e23, 0x0dde4911, 0x1f54372d, 0x15363c41, 0x350f4b4b,
		0x49224842, 0x0f3706e3, 0x2108100a, 0x396b0216, 0x316f7375, 0x95fdc101, 0x8782782e, 0x4912fe3f, 0xae820aef, 0x00010033, 0x015bff47, 0x00da01b0,
		0xb6520013, 0x100f100c, 0x05dc5700, 0x1839d718, 0x0011173c, 0x077f084d, 0x007f1215, 0x13080113, 0x084a1314, 0x03880e4b, 0xed3f0050, 0xf3433f3f,
		0x54102005, 0x132a0818, 0x32333636, 0x23111516, 0xf0553411, 0x23112505, 0x27592d47, 0x1133d718, 0xaa014b2e, 0x0c1f382d, 0x74fe0405, 0x1d000300,
		0x3506634d, 0x001a0013, 0xb6cd0021, 0x0e0d1821, 0xb81c4c00, 0x0eb3f0ff, 0x07824d00, 0x0db3e026, 0xb81a4d00, 0x8205944a, 0x40e02207, 0x21108219,
		0x1d821815, 0x82201521, 0x18112109, 0x112ac883, 0x4d000810, 0xe0ffb80d, 0x078410b3, 0x0fb3e822, 0x40210785, 0x2218820e, 0x820d100c, 0x180483c9,
		0x220b5aee, 0x823540f0, 0x2003211b, 0x03253182, 0x4d000f18, 0x3f438303, 0x0a76171f, 0x76181e23, 0x100b4000, 0x18220048, 0x1f1e0f79, 0x031e4f1e,
		0x14051e1e, 0x1b460f7c, 0x2b069666, 0x2f3911ed, 0x1001ed5d, 0x32ed2bd6, 0x4712fe68, 0x9c6605bd, 0x2223320b, 0x3217022e, 0x16213736, 0x06221316,
		0x26262107, 0x7aee181d, 0x42db330f, 0xeefe0544, 0x40414105, 0x12010542, 0x36014505, 0xee187a53, 0x20080c81, 0x6c6c72a9, 0x70f80172, 0x00706a6a,
		0x00020000, 0x01f3ff1d, 0x00cb02ee, 0x002c0020, 0x2b00b9c8, 0x06e269ff, 0x0e102930, 0x18294d00, 0x254d000d, 0x000e0d10, 0x4d41234c, 0x22078206,
		0x821340e8, 0x281e2116, 0x1e20f382, 0x1e20f383, 0x5718f383, 0xe0210ab8, 0xb85718b3, 0x00082307, 0x3783134d, 0x07822982, 0x1783e820, 0x0f821220,
		0x82354021, 0x18083010, 0x084d0012, 0x4d001110, 0x100f1003, 0x83034c00, 0x110a2845, 0x07147627, 0x41212e17, 0x2d34063b, 0x461c7c24, 0x2a070714,
		0x45050d7c, 0xedce3f00, 0x3f331133, 0x25053241, 0x3232de10, 0x6b18dced, 0x344115e3, 0x36172b05, 0x26343536, 0x14163327, 0x49181415, 0x2e2109ba,
		0xd8ed1802, 0x35503210, 0x01010a14, 0x22240152, 0x3a211917, 0x51323152, 0xc3ef183a, 0x17313b0f, 0x14091d2d, 0x05110a05, 0x27204c2b, 0x7a53486f,
		0x50262650, 0x827a537a, 0x03827a82, 0x00820020, 0x28000232, 0xdc01f5ff, 0x1f003102, 0x98002b00, 0x202a0c40, 0x2a29d783, 0x4d000e10, 0xe0ffb828,
		0x820d83b4, 0xb3f02108, 0x24201082, 0x82066642, 0xb3e82407, 0x824d000f, 0x40f02207, 0x2618821d, 0x00102822, 0x8220224d, 0x83222012, 0x180c2538,
		0x084d0008, 0x02250483, 0x40f0ffb8, 0x080d821f, 0x201b1422, 0x00111e82, 0x0a82262d, 0x480c0940, 0x88232c0a, 0x0f11171e, 0x05882950, 0xed3f0051,
		0x33ce333f, 0x261b2141, 0x020e1425, 0x6b2e2223, 0x2341064a, 0x3407240e, 0x4b222326, 0x0120063b, 0x0cc8d918, 0x36482f08, 0x01010710, 0x1e1c014f,
		0x3a44552a, 0x39434339, 0x37e8443a, 0x23234059, 0x37375940, 0x2a233f5a, 0x081d2b16, 0x100b0515, 0x1f462a05, 0xd9185c3e, 0x002308da, 0x432d0002,
		0x2030069f, 0xae003400, 0xff3200b9, 0x110e40e8, 0x182e4d00, 0x28200482, 0xfd820483, 0x1e271285, 0x4d001320, 0x8212301e, 0xffb82c04, 0x0011b3e8,
		0xffb81a4d, 0x8413b3e0, 0x40d82207, 0x20188209, 0x2930831a, 0xf0ffb819, 0x000a09b4, 0x08820b4c, 0x0d0a402b, 0x28034d00, 0x4c001312, 0x082d8203,
		0x11254030, 0x762b4d00, 0x40170714, 0x17480c09, 0x360c730f, 0x35007621, 0x461c7c26, 0x1214440e, 0x3045097c, 0x4505077c, 0xed333f00, 0x3f32ed3f,
		0xf845ed3f, 0xdefd2405, 0x5832322b, 0x2b200fa1, 0x44074942, 0x26220796, 0x4c182223, 0x2e220804, 0x594b3702, 0x342a0807, 0x2223022e, 0x132d020e,
		0x30223525, 0x37302621, 0x1f144e3e, 0x100f1314, 0x22372614, 0x13243523, 0x1910084e, 0x11191111, 0x04820808, 0x19114e08, 0x36010810, 0x244e7b56,
		0x5f522122, 0xb70139fe, 0x27164438, 0x7a574e72, 0x4e24244e, 0x5d37577a, 0x44262644, 0x5e39375d, 0x42242442, 0x0000005e, 0xff1b0002, 0x01bf015b,
		0x002600db, 0x40a80032, 0x0918250c, 0x18244d00, 0x4c001211, 0x21f38220, 0xc54d12b3, 0x82b32005, 0xb81f27fa, 0x0bb3f0ff, 0x07824d00, 0x09b4e82e,
		0x0e4c000a, 0xb3d0ffb8, 0x0d4d0009, 0xb4242882, 0x4c00100b, 0xd8220882, 0x10840ab3, 0x3640c027, 0x034d0008, 0x26488310, 0x0b0a1803, 0x83024c00,
		0x2d230859, 0x0f081a82, 0x021d1f1d, 0x107f131d, 0x00822734, 0x22882a33, 0x1a4b1251, 0x0b088818, 0x05883050, 0x663f0050, 0x3e41050d, 0x415d2009,
		0x3720113e, 0x2506a949, 0x32333636, 0xd745021e, 0x0c414108, 0x0806a64d, 0x06222344, 0x3126181b, 0x112a151a, 0x271a2c0e, 0x4f08192f, 0x0f140a04,
		0x0b0b1114, 0x1a312718, 0x1827321a, 0x22211b4e, 0x21221a1a, 0x5e47e81b, 0x110f1737, 0x341b140b, 0x49fe2f4a, 0x3729a501, 0x1b140f22, 0x1783304a,
		0x5d38173f, 0x59595447, 0x58585554, 0x00020000, 0x01000012, 0x007102d5, 0x00230019, 0x0600b97c, 0x25f984ff, 0xe0ffb806, 0xf88209b3, 0x20063b41,
		0x066d4203, 0xffb80228, 0x1211b4d8, 0x08824c00, 0x0ab3e024, 0x07824d00, 0x2440e822, 0x2e082982, 0x25057622, 0x00731d09, 0x200c100c, 0x0c08030c,
		0x0924150f, 0x001e1e79, 0x1212440b, 0x007c1a0c, 0xed3f0041, 0x3f2f3232, 0xed2f3912, 0x5fd61001, 0x785008f4, 0x05165808, 0x23230624, 0xec5f2315,
		0x172e080c, 0x15070622, 0x35363233, 0x301e0134, 0x5b152d45, 0x26522e5b, 0x02430421, 0x604c3005, 0x0822123f, 0x0232342a, 0x46331c71, 0xe769612b,
		0xbb5f2202, 0x3a342a08, 0x0147051b, 0x453cfa02, 0x35e7837c, 0x015bff47, 0x00b502cc, 0x00300021, 0x2e104097, 0x4d000e10, 0x04832024, 0x420d1821,
		0xef83050b, 0xffb81f2b, 0x080940f0, 0x100e4d00, 0x22fd840f, 0x8410b3f0, 0xb3e02107, 0xf4850f87, 0x1783e020, 0x3583fc83, 0xe03f0782, 0x00082040,
		0x0082224d, 0x131b2932, 0x0a007f08, 0x310a0801, 0x501d8825, 0x4d108917, 0x442c4b0a, 0x3f22067b, 0x16593fed, 0xccfd2205, 0x0e2a6233, 0x182b2b21,
		0x4b0ba692, 0x15230dc2, 0x18323336, 0x5c0745de, 0x012907f6, 0x4a331bcc, 0x0e38252f, 0x0ccc4b53, 0x2e2e2e2b, 0x5520394f, 0x2c1d3d4c, 0x0673570b,
		0x5935e729, 0x0b122440, 0x4bb302b7, 0x25080ad5, 0x3f221255, 0x5951385a, 0xe0fe030c, 0x2d1a160d, 0x0002003d, 0x019fff37, 0x00b502eb, 0x002a001b,
		0x1b00b976, 0xe583d8ff, 0xffb81b24, 0xdc82b3e0, 0xf020e582, 0xc022f586, 0x10823040, 0x09033d08, 0x0878090e, 0x03081403, 0x76260808, 0x0e0e2c00,
		0x73131720, 0x14101400, 0x0e2b1402, 0x20791203, 0x7c1c1420, 0x14411916, 0x00090844, 0x3f3f332f, 0x3912edce, 0x3232ed2f, 0x5dd61001, 0x32250682,
		0xedde102f, 0x077a7233, 0x822b0121, 0x14012200, 0x077b4d06, 0x23220627, 0x11231523, 0x21fc8333, 0x05422716, 0x05cd6005, 0xaf014a08, 0x2e15333c,
		0x5d112a2d, 0x2b2a260f, 0x04150615, 0x25535346, 0xda71701f, 0x35092b17, 0x16293924, 0x01312416, 0x175839ae, 0x605e5825, 0x595c2b2c, 0xf4012353,
		0x0347b502, 0x02011b62, 0x2f1b0aef, 0x1b2e2426, 0x0000000b, 0x32f38201, 0x02be01f3, 0x01310079, 0x3100b90f, 0x12b3e8ff, 0x83314d00, 0x001123f1,
		0x07832d4d, 0x4d000f24, 0x1782b82c, 0x4d000e23, 0x200f832b, 0x2d07840a, 0x0009b3d8, 0xffb8284d, 0x0008b3f0, 0x2786274d, 0xd8280782, 0x4d000ab3,
		0xc8ffb824, 0xe0200786, 0x0f822783, 0x3d40d82b, 0x1e4d0008, 0x00121118, 0x0519484c, 0x3f612020, 0x28182107, 0x18217282, 0x266f8220, 0x000e1813,
		0x82200f4d, 0x100e2728, 0x0b4d000d, 0x04820a18, 0x09082829, 0xb8064c00, 0x82b3d8ff, 0x2107821c, 0x1a82b3e8, 0x91830520, 0x4d001022, 0x21080782,
		0x0f2040e0, 0x76164d00, 0x25040425, 0x0c762f33, 0x320c1d1d, 0x1c1c092a, 0x22117c19, 0x00030345, 0xb555097c, 0xed392406, 0x4c112f32, 0xed2006a0,
		0x49124f61, 0x0589054f, 0xb4552520, 0x35262907, 0x37023e34, 0x3435033e, 0x0809885e, 0x14151675, 0x0e07020e, 0x16141503, 0x4e380b01, 0x22091914,
		0x66213a2d, 0x3f2e196e, 0x212c1a26, 0x2b2d4213, 0x0a1a1446, 0x1a302a21, 0x2b19665b, 0x321a1e37, 0x3a421828, 0x06440b1d, 0x57090e0e, 0x2c3c2b51,
		0x160b1020, 0x2d1a241b, 0x450c182d, 0x070a0e07, 0x3625515b, 0x0a0c1e28, 0x1d291f17, 0x00003030, 0xff410001, 0x01b101f5, 0x002700db, 0x2600b9f6,
		0x82b3e8ff, 0xb82624f1, 0x82b3f0ff, 0x442520f0, 0x078206a1, 0x08b3d82a, 0xb8234d00, 0x0cb3d8ff, 0xe8250784, 0x4d000ab3, 0x241f8322, 0x204d000d,
		0x823782b8, 0x21078217, 0x4b58b3e0, 0x821f8306, 0x40d8260f, 0x0009082b, 0x07dc4a4c, 0x4d000e24, 0x3182200e, 0x0c280e22, 0x18200982, 0x0b2f4382,
		0x000c0b18, 0x08200b4c, 0x074c000a, 0x41c8ffb8, 0x285f0681, 0x82062005, 0x0fb42470, 0x824c0010, 0xe0250808, 0x000e2340, 0x2182134d, 0x29210606,
		0x82001b1b, 0x08010c00, 0x0925280c, 0x88151a1a, 0x05501e10, 0x09880205, 0x05195a51, 0x25078641, 0xed5d5ed6, 0x87412f33, 0x1437211d, 0x2408025f,
		0x3e343526, 0x3fb91804, 0x1570080c, 0x94040e14, 0x234d2b72, 0x30502410, 0x3e29626a, 0x6c293e48, 0x1c242814, 0x511d0f08, 0x295b6027, 0x293d483d,
		0x10153974, 0x4510104b, 0x2433273f, 0x151d1819, 0x0907043b, 0x0b094a04, 0x3228384b, 0x20181722, 0xffff0000, 0x00002800, 0x6b02bf01, 0xa2030602,
		0x02000000, 0x5bff2b00, 0xb502b901, 0x2c001f00, 0x00b98c00, 0xb3e0ff1e, 0x1e4d000a, 0x082bf083, 0x1d4c0009, 0xb3e8ffb8, 0x824d000d, 0x40e02807,
		0x000c0b48, 0x82101a4c, 0x201a320e, 0x1a4d000c, 0x4d000b18, 0x0a082019, 0x20154c00, 0x2b1a820a, 0x00092815, 0x0820154d, 0x18144d00, 0x21082482,
		0x01170026, 0x060f1708, 0x0f207f00, 0x102d2e0f, 0x23292c12, 0x88054d1c, 0x3f004b0a, 0xdedd3fed, 0x2950cd32, 0xfd332605, 0x5edc10ce, 0x0ebe4a5d,
		0x1e14252f, 0x15333302, 0x22232206, 0x1135022e, 0x09a74906, 0x27151622, 0x080a9a49, 0x34013758, 0x1422190f, 0x05180827, 0x122a4432, 0x2c1e261e,
		0x1d0c0d1c, 0x3e4b2631, 0x1d1e1f52, 0x14201a1d, 0x21160d1c, 0x470b1b2c, 0x49321a01, 0x12b80130, 0x152b2115, 0x19262a10, 0x23184c56, 0x14142527,
		0x000e0f27, 0x00010000, 0x0159ff3f, 0x006002c7, 0xb9940032, 0x1f442100, 0xb8212105, 0x8206ad4a, 0xb3d82408, 0x844d000e, 0x0d0c2310, 0x08824c00,
		0x4040d827, 0x034d000b, 0x22ec8210, 0x820c1803, 0x82202009, 0x2e2a080e, 0x0e0e1f82, 0x0f0c341f, 0x0006097f, 0x07080107, 0x01273033, 0x2701270f,
		0x892b2f27, 0x4a1b4b24, 0x060f0b0a, 0x49090c85, 0x38511519, 0x333f3506, 0x32cd32ed, 0x01ed3f3f, 0x5d2f332f, 0x5ed6105d, 0xed32dd5d, 0x4905fc51,
		0x45510a85, 0x15372109, 0x25084351, 0x1e37023e, 0xd54e1503, 0x3454080d, 0x01062734, 0x243f3142, 0x5262620d, 0x170abbbb, 0x24131a24, 0x0104161e,
		0x09010202, 0x0d27311a, 0x05070a1f, 0x17230719, 0x17061801, 0xd82f452e, 0x900e8245, 0x2c23d845, 0x03030a1b, 0x13060104, 0x27071515, 0x05172c3d,
		0x03023d02, 0x0604282d, 0x00000306, 0x3c068774, 0x006b02cd, 0x40280014, 0x05730213, 0x16010f05, 0x0c150f09, 0x7905020c, 0x44044114, 0x67c28200,
		0xcd2505e8, 0x3911ce10, 0x23bb822f, 0x11231501, 0x22200182, 0x080bd167, 0x98cd0121, 0x27224252, 0x05024304, 0x213e301d, 0xfd466b02, 0x252502db,
		0x08111020, 0x280d1906, 0x820c1f35, 0x653f206b, 0x3008068f, 0xb95a0027, 0xe8ff2500, 0x12113240, 0x201b4c00, 0x134d000c, 0x000c0b18, 0x0d20204c,
		0x0029020d, 0x16197f03, 0x08011700, 0x21212817, 0x4d1d8824, 0x9de11803, 0xed3f2413, 0x41012f32, 0xc05a0b56, 0x41132006, 0x36230846, 0x42061737,
		0x35250562, 0x35333523, 0x0a205434, 0x41f31521, 0x24380542, 0x0e0c142c, 0x4234303a, 0x62620e25, 0x392a6755, 0x2d0c0f0c, 0x012f4121, 0x11b6e118,
		0x62592a32, 0x0548050a, 0x00333d0b, 0x00010000, 0x0159ff27, 0x3a053741, 0x1315402a, 0x10730007, 0x08010e00, 0x15160e0e, 0x11790f14, 0x097c0341,
		0x82ed2f00, 0x063753a3, 0xccfdce26, 0x053031ce, 0x0807da55, 0x2e222329, 0x23113502, 0x23152135, 0x20172301, 0x08091108, 0x32271c16, 0x01aa0b1d,
		0x290faaa6, 0x4202012b, 0x3e2b1705, 0x55250227, 0x30200757, 0x2306c74e, 0xb96d0028, 0xc8267c82, 0x4d0008b3, 0xd943b826, 0x28078205, 0x090e40e8,
		0x100f4d00, 0x2f048212, 0x4d001118, 0xf0ffb80b, 0x12112740, 0x20034c00, 0x07116118, 0x0828023f, 0x1e174d00, 0x2a247312, 0x29057308, 0x13131a23,
		0x7c0d4106, 0x3f004600, 0x10333fed, 0x06f562ce, 0x200d744e, 0x21a98417, 0x63571133, 0x4e322009, 0x37080975, 0x1107020e, 0xdf020e14, 0x11294332,
		0x23170b52, 0x17231818, 0x140d400b, 0x01520101, 0x1b251709, 0x0d432911, 0x3150391f, 0x6afe9f01, 0x10243b2c, 0x2c3b2410, 0x1f1f9601, 0x2b05694e,
		0x19222914, 0x319dfe04, 0x001f3950, 0x012f0082, 0xf6ff4400, 0x3102dc01, 0x4e002200, 0x430d00b9, 0x0d2005ab, 0x4021e382, 0x08d18226, 0x0a180622,
		0x20064d00, 0x4c000908, 0x7f121d16, 0x7f0b2422, 0x08010800, 0x19222308, 0x49091212, 0x5103880e, 0x5e26c78a, 0xde10ed5d, 0x7f44dded, 0x42252006,
		0x11210607, 0x05365933, 0x33113722, 0x0131c58d, 0x334f177e, 0x10253e2e, 0x14302752, 0x17390526, 0x24c2840f, 0x0d1b2515, 0x20e31807, 0x02072509,
		0x1f208801, 0x3505044e, 0x18222915, 0x00010004, 0x01f2ff12, 0x006b02e2, 0xb593002b, 0x55451821, 0x40e82205, 0x2a08820e, 0x000e180b, 0x08100b4d,
		0x48074d00, 0x0782067f, 0x82b3f021, 0xb8013b0f, 0x3b40f0ff, 0x014d0010, 0x29af297f, 0x290329bf, 0x04762429, 0x2d040000, 0x15821811, 0x1500113e,
		0x15701510, 0x15b015a0, 0x1a151505, 0x12120e76, 0x15292c0e, 0x79110115, 0x1f41142a, 0x22051048, 0x77ed333f, 0x5d220cf4, 0x8b462b33, 0x2f322105,
		0x954b0a82, 0x23012107, 0x250d445a, 0x15333523, 0xde53030e, 0x058b4905, 0x35274a08, 0x6de20133, 0x371b2e30, 0x52363652, 0x2f2f1b37, 0x2618c56b,
		0x21100e19, 0x33232333, 0x190e1021, 0x02c71826, 0x4a953d25, 0x2e4c6538, 0x38654c2e, 0x463d954a, 0x4d441a3c, 0x4c2a2852, 0x39222239, 0x52282a4c,
		0x3c1a444d, 0x08a75400, 0x6e02c92a, 0x76002100, 0x0f1020b5, 0x09070619, 0xffb81f25, 0x821940e8, 0x381521fd, 0x15351582, 0x4d000e10, 0x12110811,
		0x10104c00, 0x0d4d000d, 0xb3e0ffb8, 0x25078412, 0x0011b3e8, 0x2d83034d, 0x000e183b, 0x0b1a1a4d, 0x23007613, 0x2208730b, 0x411d7c16, 0x7c0e4109,
		0x3f004605, 0x08d74eed, 0x3911ed23, 0x4aee872f, 0x0e250581, 0x26222302, 0x06d05435, 0xf648e583, 0x36810805, 0x1e323336, 0x22c90102, 0x5b2f513b,
		0x3f2e5264, 0x1625331d, 0x0f0c4839, 0x21050206, 0x2d4b370d, 0x5a3e0114, 0x69244f7e, 0xfe94017b, 0x18555c80, 0x774a623a, 0x45010179, 0x512e0102,
		0x0100006f, 0x00000d00, 0x74021602, 0x59001b00, 0x050a3140, 0x78050b0a, 0x04140104, 0x0a0b0104, 0x191a780a, 0x1a191a14, 0x01010073, 0x13010108,
		0x13191c04, 0x7c160b19, 0x0a1a4510, 0x04050101, 0x00440041, 0x05205c3f, 0x32ed3f28, 0x332f0132, 0xb882c610, 0xfd5d5e2b, 0x107d2b87, 0x101887c4,
		0x055c7a2b, 0x5b353321, 0x372206e7, 0x2b67033e, 0x23360805, 0x03070622, 0x663bd215, 0x210a5c24, 0x5a142927, 0x1d1a170b, 0x122d1b11, 0x0d181a25,
		0xe6680e18, 0x2363bf63, 0x2451524e, 0x16261ddf, 0x39131809, 0xfe23191b, 0xaf82eafb, 0xff135608, 0x01e80158, 0x002900dc, 0x4a404072, 0x15390115,
		0x1e191501, 0x15188119, 0x15181814, 0x06010667, 0x81211e21, 0x03140603, 0x181e0603, 0x01030f03, 0x2b270308, 0x2a180e0e, 0x00030321, 0x1e502488,
		0x0b151506, 0x12491819, 0x004b0b88, 0x333fed3f, 0x33113912, 0x21c08233, 0x2857322f, 0x5e322506, 0x3912115d, 0x21058b59, 0x2b575d01, 0x5d5d2407,
		0x82013031, 0x060625b6, 0x23030e07, 0x2008795f, 0x23da8637, 0x36373636, 0x08068c45, 0x16b5014d, 0x35190615, 0x2c241121, 0x2d132336, 0x1f0a0f08,
		0x14332c0f, 0x5a1e5b35, 0x251f1809, 0x12201614, 0x11332f0b, 0x0c0e111f, 0x1b1b9601, 0x2850b46a, 0x0a12263a, 0x06054304, 0xf06b312b, 0x625d287b,
		0x86462e63, 0x0737324f, 0x82084106, 0x364108f3, 0xc7010000, 0x19006b02, 0x36406e00, 0x15000a0a, 0x0d0e1013, 0x03010d16, 0x00090806, 0x160d1609,
		0x14090078, 0x04090000, 0x171b0004, 0x0d111117, 0x7916001a, 0x79100619, 0x19131303, 0x79090d41, 0x0e175b0c, 0x32c61029, 0x102f322f, 0x852f32ce,
		0x0e8728e5, 0xc4c405c4, 0x8710c40e, 0x06195808, 0xec820120, 0x23153322, 0x22091b7c, 0x82333523, 0x212f08e8, 0xbf012135, 0x7724451b, 0x1a41249f,
		0x6ffe3301, 0x6123431d, 0x1e412188, 0x7a01e5fe, 0x68272b02, 0x713b4039, 0x39364631, 0x36403b79, 0x82462b61, 0x490021be, 0xab220482, 0xc382d001,
		0x37406c22, 0xc285c385, 0x8120c185, 0x0023c18d, 0x8308010d, 0x828520c5, 0x37c483c5, 0x85090d49, 0x3f004a0c, 0x393f32ed, 0x32cd332f, 0x0132ed10,
		0x5d5ec610, 0xc385c68e, 0xc190ca84, 0x21153323, 0x85bb8235, 0x822320c1, 0xa42908c1, 0x62203812, 0x14331b8e, 0x139efeff, 0x784d1e36, 0xe413311b,
		0x92014e01, 0x3b2a4214, 0x46224a25, 0x2a532337, 0x173f233b, 0x34ba8245, 0xf3ff1800, 0x6b02cf01, 0xba002500, 0x20231140, 0x204d0010, 0x27048218,
		0x0e0d1819, 0xb8134c00, 0x8205d845, 0xb3d82407, 0x844d0011, 0x00082807, 0xffb8104d, 0x8412b3c8, 0x83e82007, 0x820f8417, 0x830f2017, 0x05315e2f,
		0x3940d023, 0x2d4b8209, 0x050f010e, 0x052f051f, 0x0e050803, 0xbc5f0e09, 0x09200806, 0x11762209, 0x1b000027, 0x0106101b, 0x7c242606, 0x080e0e00,
		0x7c1f1c1c, 0x05094616, 0x00410879, 0x2706755d, 0x332f3911, 0xc61001ed, 0x21050e41, 0x4318edde, 0x5e22081a, 0x46445d5d, 0x132b2a0b, 0x2137033e,
		0x0e152135, 0x0ace5103, 0xd26b2720, 0x23430807, 0x3116a623, 0xfe0e292f, 0x0e8c01e2, 0x1935312a, 0x3e1e685d, 0x3c23405e, 0x1a0a2430, 0x51385614,
		0x0111c658, 0x3737165d, 0x31461232, 0x3b393414, 0x505e071b, 0x1b324529, 0x050f0e0a, 0x401e0b44, 0x82007639, 0x00013200, 0x01f3ff43, 0x006b02ce,
		0xb9d1002c, 0xf0ff2900, 0x2aea82b3, 0xe0ffb829, 0x00093140, 0x82201c4d, 0x281c210d, 0x1b270982, 0x4d001208, 0x8211101b, 0x08282404, 0x83174d00,
		0x10172209, 0x2009820a, 0x261d8218, 0x00082017, 0x51b8104d, 0x088206db, 0x10b3e028, 0xb80f4d00, 0x0783f8ff, 0x4e820820, 0x04200783, 0x2e080789,
		0x0d2f40f0, 0x274c000f, 0x781e231e, 0x2c14272c, 0x0f2c2c27, 0x232e260f, 0x00760623, 0x19080119, 0x7927232d, 0x7c012c24, 0x41241e1e, 0x6b090e0e,
		0x392808f9, 0x1033ed2f, 0x100132ed, 0x2009fd4c, 0x0cff4f32, 0x290c844e, 0x0e222301, 0x16141502, 0x7b753233, 0x22232505, 0x3435022e, 0x367f0b82,
		0x17720808, 0x22115201, 0x511c303e, 0x252b1542, 0x091a091e, 0x1b352c22, 0x213c5433, 0x223f301d, 0x242c2e16, 0xff69010c, 0x2a240c00, 0x2901132b,
		0x242f1d0b, 0x0a06373d, 0x0544050c, 0x16070b0d, 0x2d30462d, 0x05192c40, 0x33383a1b, 0x12463414, 0x16373732, 0x01000000, 0x5bff3f00, 0xd001c201,
		0xaf002800, 0xff2500b9, 0x093c40e0, 0x20184d00, 0x174d000a, 0x04821210, 0x82111821, 0x10102104, 0x28200482, 0x27073c41, 0x12111013, 0x18134c00,
		0x13211482, 0x25148218, 0x00082013, 0x0e83124d, 0xffb8082d, 0x000fb3e8, 0xffb8044d, 0x822e40f0, 0x23300808, 0x811a1f1a, 0x28142328, 0x0d282823,
		0x1f2a220d, 0x0082061f, 0x15080115, 0x85231f29, 0x89012820, 0x49201a1a, 0x89090c0c, 0x3f004b10, 0x3f2f32ed, 0x202a3441, 0x08314125, 0x4109bc4a,
		0x4a080930, 0x17031e23, 0x220f5401, 0x511f3342, 0x14492b48, 0x31531612, 0x213d5635, 0x2642321d, 0x262c2f16, 0xf45b010c, 0x2c2a250b, 0x19098e14,
		0x433a232c, 0x0b440a10, 0x49301810, 0x293d2c30, 0x3a190517, 0x3014353a, 0x36321245, 0x82001637, 0x00012f00, 0x0157ff31, 0x00d001a7, 0xb994002c,
		0x82691e00, 0x1e3f0806, 0xb3d0ffb8, 0x194d000d, 0x40d8ffb8, 0x000b0a4c, 0x12280c4c, 0x380c4d00, 0x084d0011, 0x4d001020, 0x0d0c2002, 0x17044c00,
		0x15171101, 0x110e8117, 0x110e0e14, 0x820a1515, 0x0e0e2e1c, 0x82822612, 0x12250859, 0x2d120801, 0x0e2a1121, 0x2a06860d, 0x2a141717, 0x8511154b,
		0x3f004914, 0x123f32ed, 0x39122f39, 0x121133ed, 0x06944439, 0x3311ed22, 0x5d064652, 0x85430567, 0x50172009, 0x272008b6, 0x25058d44, 0x07061521,
		0xb950031e, 0x17520809, 0x31262607, 0x192d2314, 0x1b2e3b20, 0x4a2e604e, 0x5901f416, 0x402b6139, 0x3a21152a, 0x1f0c2d4d, 0x0206121b, 0x660b0541,
		0x0e18261d, 0x150d0806, 0x2b281d22, 0x4a283802, 0x4a33451a, 0x22150656, 0x352b2332, 0x030a1423, 0x11150e07, 0x0e05140e, 0xbd821f0b, 0x00012508,
		0x01000039, 0x007902bd, 0x40c20028, 0x0e102616, 0x10264d00, 0x254d0008, 0x4d000918, 0x0908181d, 0xb8174c00, 0x82055152, 0xb3f02107, 0x2c065070,
		0x4d000cb3, 0xe0ffb814, 0x000b0ab4, 0x2108824c, 0x2e82b3c8, 0xd8220782, 0x3c820a40, 0x09180f23, 0x05c2760a, 0x11374027, 0x064c0012, 0x08058320,
		0x151b182a, 0x2227011f, 0x20157604, 0x15191920, 0x22761f2a, 0x0d0d2828, 0x08012200, 0x271b2922, 0x12010118, 0x4422791f, 0x7c070c0c, 0x21086e70,
		0xb1763911, 0x07d24505, 0xbd67ed20, 0xed102405, 0x18393911, 0x2512dcab, 0x36363313, 0xf6683435, 0x1516280a, 0x33070614, 0x46072315, 0x5d0805aa,
		0x37023e26, 0x20a95d23, 0x1e2a3c2b, 0x0617212d, 0x2b210d29, 0x5e5c2237, 0x894d1d1d, 0x02352632, 0x89fe1d01, 0x31241204, 0x4201671b, 0x36284020,
		0x13140e30, 0x1a0d3b06, 0x53560d15, 0x40234526, 0x1d452634, 0x3f472946, 0x00001b38, 0x28000100, 0xba01f3ff, 0x25006b02, 0x18409a00, 0xe4831817,
		0x0d281726, 0x0b4c000e, 0x0a21f084, 0x05946b40, 0x0fb3f029, 0xb8054d00, 0x53b3d8ff, 0x0f860605, 0xa954e020, 0x54e82006, 0xe02006a9, 0x02201783,
		0x23082782, 0x00082340, 0x1420204d, 0x21270376, 0x191c7600, 0x1d0b0b19, 0x791c2126, 0x007c191e, 0x0c411e00, 0x087c0f0c, 0x23072853, 0xed10ed2f,
		0x2305a048, 0xed332f32, 0x45059a76, 0x154b0ddb, 0x45262007, 0x0a4b05d0, 0x234b0805, 0x23373636, 0x23152135, 0x80ba030e, 0x513d2580, 0x2350272b,
		0x2546190f, 0x1929351c, 0x45603c1c, 0x57040907, 0x01d97901, 0x01040404, 0x5c6d037c, 0x162e4732, 0x0e461010, 0x2b1b0c11, 0x2435221f, 0x396f4413,
		0x2e0c4646, 0x82002f32, 0x00013400, 0x01f5ff3a, 0x00d001b4, 0xb99f0023, 0xe8ff2200, 0x520013b3, 0x0c2005d7, 0xe8220784, 0x07840bb3, 0x09b4e02b,
		0x224c000a, 0x40e8ffb8, 0x2de4820e, 0x00125013, 0x1128134d, 0xb8014d00, 0x3383e0ff, 0xf0200782, 0x0f842b83, 0x17840a20, 0x40e82208, 0x00090824,
		0x111c1c4c, 0x1d250082, 0x1518821e, 0x19080815, 0x1e891424, 0x181d0e1e, 0x09491a86, 0x06114d09, 0x3f2f3224, 0x186b32ed, 0x16104108, 0x06142526,
		0x022e2223, 0x0896b418, 0x41232621, 0x5108080c, 0x1e323307, 0x68b40102, 0x2c331964, 0x050f0620, 0x172e271c, 0x675b4239, 0x0209062d, 0xd6670149,
		0x5230130a, 0x438c223c, 0x08090654, 0x08034603, 0x2b260609, 0x4f33262f, 0x6d42422b, 0x00392410, 0x3e000100, 0xce01f5ff, 0x24006002, 0x2040d000,
		0xde82281a, 0x0c181a2d, 0x20114d00, 0x4c001211, 0x83102811, 0x820f200a, 0x0e282904, 0xb80c4d00, 0x0cb3f0ff, 0xe8200784, 0x0f82f383, 0x82b3e021,
		0x220782f3, 0x8409b3c8, 0xb3d82a17, 0x094d0008, 0xb3d0ffb8, 0x22078412, 0x8411b3e0, 0xb3d02807, 0x084d000d, 0x83b0ffb8, 0x2007820f, 0x083783e8,
		0xffb8072c, 0x112840f8, 0x03004d00, 0x1f1f227f, 0x0b821720, 0x260b0202, 0x20001111, 0x25200801, 0x034d2423, 0x2200851f, 0x15121249, 0xe2530e88,
		0xed332406, 0x44333f32, 0x544d069e, 0x39112205, 0x4214822f, 0xe9460c43, 0x50132005, 0xf218056d, 0x35230cbb, 0x63042e34, 0x37320519, 0x21bcbcf2,
		0x21303a30, 0x50306a62, 0x4d231024, 0x0e85732b, 0x52622008, 0x1f45d001, 0x12192925, 0x3f2b311e, 0x4b101045, 0x1b391510, 0x2414141e, 0x4521343d,
		0x82000e82, 0x00023d00, 0x015bff47, 0x00da01ce, 0x0019000b, 0x1900b968, 0x4540e8ff, 0x4c000908, 0x1211200a, 0x28260582, 0x0a4d000f, 0x04820e10,
		0x000d0826, 0x0a10094d, 0x1984fd82, 0x10280227, 0x18024d00, 0x24f4820f, 0x071b0c82, 0x059a6011, 0x88031a2f, 0x88075017, 0x4b131111, 0x2f333f00,
		0x06c958ed, 0x080fa476, 0x26340144, 0x07062223, 0x37033e11, 0x07020e14, 0x36112315, 0x16323336, 0x3f457901, 0x270d2826, 0x55284050, 0x3f705431,
		0x3b571d53, 0x0c017365, 0x050a473e, 0x240f9cfe, 0x47364d36, 0x14334965, 0x0b5b0273, 0xbe826f19, 0x00ffff23, 0x2cbf82d4, 0x02bb0221, 0x005f0006,
		0x00ffff00, 0x200f8279, 0x290f827c, 0xa55f0036, 0x00060000, 0x27825b5f, 0x00010023, 0x08178223, 0xbb02d042, 0x53001300, 0x0d112c40, 0x0608040c,
		0x137f0902, 0x010c000f, 0x14150c0c, 0x13861005, 0x0c091302, 0x0f060f86, 0x131f130f, 0x0f130802, 0x4b0b0f13, 0x3f005300, 0x2f39393f, 0x115d5e2f,
		0x32ed1033, 0x01340484, 0x2f391211, 0xfd33335d, 0x32cd3232, 0x3132cd10, 0x11331330, 0x2105c566, 0x88181123, 0x3323072a, 0x82b04dd3, 0x2a048400,
		0xcafebb02, 0xfe426942, 0x823d01c3, 0x2aa78406, 0x01f4ffb5, 0x026b023b, 0x82040006, 0x044708a0, 0xfbff1b00, 0x3103f301, 0x17000500, 0x34002800,
		0x42408100, 0x341d762e, 0x04264073, 0x05020504, 0x05600000, 0x15150605, 0x0f140b0f, 0x0b067e14, 0x0b060614, 0x060c0f0f, 0x7c2c0c06, 0x7c314222,
		0x14064118, 0x82401679, 0x01032a4b, 0x16050280, 0x790b0f41, 0x05654c0e, 0x1a32de24, 0xb88232cd, 0xbe821a20, 0x54ed3f21, 0x7964052c, 0x11013008,
		0x122f1833, 0x1a2f1939, 0x112f18cd, 0x82101933, 0x1a2f3006, 0x31eddced, 0x17370130, 0x17071737, 0x8207030e, 0x3e3528da, 0x35233703, 0x76322533,
		0x5b08095d, 0x13363611, 0x32333216, 0x23263435, 0x01072222, 0x56561d0d, 0x0d5f731d, 0x0c1f2220, 0x1c11c27a, 0x63131e1b, 0x2d8afeac, 0x0b12283f,
		0x11374224, 0x25171229, 0x0508050b, 0x042b2a53, 0x10030507, 0x214e4e21, 0x792c6c79, 0x46378584, 0x737a4936, 0x06464475, 0x4975522c, 0x3c5d6e33,
		0x6329f282, 0xd2fd0406, 0x787df301, 0x081f4101, 0x8902fd22, 0x2e081f41, 0x301540b0, 0x4d001020, 0x000f1830, 0x82282d4d, 0x202d2109, 0x21200982,
		0x8206b243, 0x5ed82007, 0xd82d06fa, 0x4d0012b3, 0xe8ffb81a, 0x00113f40, 0x0654414d, 0x01030525, 0x41000060, 0x84200750, 0x41065041, 0x853d0d4f,
		0x40010516, 0x03800204, 0x0f491600, 0x4c0e850b, 0x32ed3f00, 0x1acdde3f, 0xcd1a32dd, 0x0a4d4132, 0x4dcd1021, 0x4c4105b6, 0xcd33220a, 0x06464118,
		0x2805c343, 0x27012b2b, 0x17371737, 0x284e4107, 0x1e619d36, 0x1b1e4243, 0x1c1e1b09, 0x0aac680a, 0x0b1d1d1c, 0x87fea362, 0x35164e41, 0x24590c02,
		0xd3243636, 0x615a4c18, 0x2837462d, 0x1c545d5f, 0x4e41a145, 0x04003b17, 0xf5ff0500, 0xb502fd01, 0x13000500, 0x38002600, 0x20b69900, 0x000b0a18,
		0x2451104c, 0x21078206, 0xe453b3f0, 0x40e82505, 0x4d001243, 0x3a053141, 0x30363627, 0x3530352c, 0x142c2784, 0x302c2727, 0x2d27272d, 0x167f1326,
		0x411e7f0e, 0x353b072c, 0x30493785, 0x2f852c4e, 0x0949274c, 0x11502389, 0x14511989, 0x3f004d15, 0x82ed3f33, 0x41028401, 0x01280744, 0xeddced2f,
		0x2f332f32, 0x45144241, 0x3841050b, 0x77052005, 0x162507f2, 0x11373233, 0x19a91837, 0x4105200e, 0x01200c56, 0x3d053b41, 0x1c07bffe, 0x11160d0f,
		0x1c1c2909, 0x3a11480e, 0x23352427, 0x2c221511, 0x08211417, 0x58412f01, 0x063f410d, 0x110ded3b, 0x33432810, 0x02075661, 0x58fd0e6f, 0x41231008,
		0x5d463659, 0x0a121838, 0x0c5a412d, 0x00002908, 0x24000200, 0xd9010000, 0x0c006b02, 0x29001200, 0x05001540, 0x0d140873, 0x130f7312, 0x12411006,
		0x00440f79, 0x00440c7c, 0x333af484, 0xfdd61001, 0xfdde10cd, 0x253031ce, 0x35023e16, 0x14113311, 0x27232306, 0x09822315, 0x2425013e, 0x52031328,
		0x29165a44, 0x014552d8, 0x1f2e1f0f, 0x2ffeac01, 0x46464f4b, 0xdbfd6b02, 0x033a6b82, 0x59ff3600, 0x9702d801, 0x11000500, 0x34002100, 0x090f1b40,
		0x731c1509, 0x7582231f, 0x0c22022e, 0x19491d06, 0x034b1288, 0x02790541, 0x76827384, 0x87cdde21, 0x33cc2375, 0x7882cd2f, 0x47186c85, 0x03200a18,
		0x85083651, 0x28013890, 0x160152f2, 0x17222217, 0x8f212119, 0x0b0b220b, 0x2b0a1709, 0x85515225, 0xd9012e88, 0x211b1c20, 0x201c1b21, 0x05053afd,
		0xa89e1844, 0x03002309, 0x9f826300, 0x02a22108, 0x000b00b5, 0x00270017, 0x151c4036, 0x221b0f0f, 0x0b29257f, 0x28037f06, 0x49230c12, 0x4b18881f,
		0x0c514618, 0x853fed21, 0x10ce23a1, 0xa185fdde, 0x18261721, 0x18084b46, 0x8f0b439f, 0x43dd28a6, 0x0c055237, 0x83800f14, 0x211823a9, 0xa9828e21,
		0xa9830a20, 0x51522622, 0x0e534618, 0xb197e220, 0x830bbf41, 0x40393fb3, 0x0805001d, 0x12111619, 0x0c101714, 0x1611180f, 0x17411344, 0x440e4110,
		0x440b7c00, 0x246e4106, 0x333f2807, 0xcdd61001, 0x82dc3232, 0xde102703, 0x3031cedd, 0xcf413225, 0x15273908, 0x13331123, 0x11333527, 0x3d010323,
		0x0311221f, 0xdb564647, 0x0977423e, 0x45220382, 0xd7411e0f, 0xfb200807, 0xfe6b02fb, 0xfdfdb74c, 0x00b40195, 0xff240003, 0x02dc0159, 0x000b0097,
		0x0026001a, 0x6026b573, 0x22058a62, 0x823c40a0, 0x25410808, 0x841f201f, 0x26142526, 0x21202526, 0x240f0f24, 0x48130e40, 0x83091524, 0x73150303,
		0x1c262818, 0x1d011d50, 0x44252027, 0x1f264122, 0x06441d41, 0x4916008a, 0x4b0c8812, 0x3fed3f00, 0x3f3fedde, 0x82028233, 0xcd5d30b4, 0xedde1032,
		0x10ed2f32, 0x2f322bce, 0x4432cd10, 0x312505b4, 0x2b2b0030, 0x10144201, 0x36323322, 0x8b061342, 0x41a320d3, 0x8a2c0671, 0x0b0b220b, 0x272b1713,
		0xe3fe4847, 0x0221df86, 0x0c6b411f, 0x3335072a, 0x39fec801, 0xa201565a, 0x0020ed8b, 0xd820ef86, 0x3408ef82, 0x00210015, 0xb94d0031, 0xd8ff0600,
		0x10092940, 0x191f4c00, 0x25252c19, 0x08af7f0b, 0x080208bf, 0x332f7f2c, 0x32007f13, 0x492d161c, 0x4b228829, 0x104c150a, 0x05f66888, 0xdf423320,
		0x10ed2507, 0x5ddefdd6, 0x1127d682, 0x31cd2f33, 0x63132b30, 0x06230e27, 0x91231107, 0x881620dd, 0x202432de, 0x30201c3f, 0x0a4b1121, 0x080c1510,
		0x014b091b, 0x0cff427a, 0x2b0a1c39, 0x01514b27, 0x0d0c0bc3, 0xfe384525, 0x271e01d5, 0x0507182d, 0x8e78fe04, 0x0a0d43ef, 0xffff002e, 0x00000900,
		0x3d03eb01, 0x24002602, 0x90180982, 0x022e0acb, 0x041b1700, 0x0902500f, 0x2b2b4f1c, 0x2b830034, 0xf5ff3a26, 0xb202b001, 0x44202b82, 0x063a2b82,
		0x00005f01, 0x0b401000, 0x35310502, 0x0250131c, 0x2b4f360f, 0xffff342b, 0x1d825900, 0x53849b20, 0x538d2c20, 0x0c000129, 0x50020410, 0x88110901,
		0x82362053, 0x83c22053, 0x0c012153, 0xdd325385, 0xb9130000, 0xdbff0100, 0x1a160940, 0x01500b01, 0x2c841b02, 0x1d245782, 0xd801f3ff, 0x32205784,
		0x0229578d, 0x00242000, 0x04025009, 0x20578825, 0x20578228, 0x20ab84cc, 0x82ab8c52, 0x00092429, 0x840e0250, 0x038f1829, 0x20ff8308, 0x29538d38,
		0x1e1a0001, 0x01501404, 0x53881f06, 0xf6ff4424, 0x5384ad01, 0x538b5820, 0x16010125, 0x8200071a, 0x22a885d5, 0x82300004, 0xc42608a7, 0x0b003d03,
		0x1b001700, 0x57003500, 0x80093140, 0x02039003, 0x0f1b0303, 0x13104015, 0x09401548, 0x1515480c, 0x01821b1a, 0x2e212108, 0x24373173, 0x18362173,
		0x0c06121b, 0x41222f00, 0x461c7c29, 0x3fed3f00, 0xdd32de33, 0x01cdde32, 0x2a05ac6c, 0x2f393912, 0x2f33112f, 0x82cd2b2b, 0xcd5d2305, 0x7b443031,
		0x4333200b, 0x27240a19, 0x13231533, 0x2810ab5a, 0x020e1411, 0x1b1b15a0, 0x24038215, 0x1c1c149f, 0x27038214, 0x71e2e2df, 0x16304d37, 0x090e8f18,
		0x4d30162c, 0x161b8702, 0x171a1a17, 0x07871b16, 0xfc39b63e, 0x543a20ef, 0xfe820134, 0x263f2f87, 0x3f261010, 0xfe79012f, 0x3a54347e, 0x00ffff20,
		0x08051741, 0x2602cc26, 0x00005800, 0xa7020601, 0x1e000000, 0x02031540, 0x2a180101, 0x03500007, 0x024f3009, 0x014f2209, 0x2b4f1609, 0x34210082,
		0x054f4234, 0x20052741, 0x2037823e, 0x20378438, 0x303788b1, 0x04262c00, 0x06035014, 0x06024f2a, 0x06014f1e, 0x85378c1b, 0x88fb206f, 0xb6aa206f,
		0x88b2206f, 0x1c002237, 0x206f842e, 0x206f8237, 0x206f8226, 0x206f921a, 0x206f88e6, 0x206f90ab, 0x20dfa433, 0x223788b0, 0x8c322000, 0x921c20df,
		0x20df896f, 0x416f90a9, 0x4d08124f, 0x2d000200, 0xcc01f5ff, 0x1a00db01, 0x5f002300, 0xff1d00b9, 0x0f3a40f0, 0x094c0010, 0x4d001020, 0x0e0d2009,
		0x10024c00, 0x4c001413, 0x00122001, 0x1118014d, 0x07234d00, 0x0e251682, 0x1b24030e, 0x86070482, 0x0d002323, 0x11880a0d, 0xb95f1e50, 0xed3f3005,
		0x39112f32, 0x2f01ed2f, 0x32c610ed, 0x18de102f, 0x2809d446, 0x35262217, 0x21373434, 0x0b505a26, 0x14154908, 0x0627020e, 0x3e323316, 0x5ef13702,
		0x47010166, 0x2c4e5005, 0x0f0b103e, 0x5b3c314e, 0x3e261e3c, 0x3d01964f, 0x212d1d33, 0x750b0313, 0x07120577, 0x070f4b48, 0x25120845, 0x3e345940,
		0xc71e3d5b, 0x24164839, 0x0500182f, 0x43079744, 0x3f080643, 0x0032002b, 0x1a464089, 0x090f151a, 0x2c2d2f1e, 0x1f2c1f25, 0x14252078, 0x1d252020,
		0x1c262c30, 0x2b781c2c, 0x2b2b1426, 0x031b1b26, 0x2c2c0909, 0x20342b20, 0x442b1c33, 0x30791e1d, 0x20252f2f, 0x2b055a43, 0x4125262c, 0x0044201f,
		0x333f333f, 0x23065b43, 0x2f391211, 0x2707e24e, 0x3911ce10, 0xcd2f3311, 0x2207dd58, 0x59c4c410, 0x102906c4, 0xc405c40e, 0x101801c4, 0x431c82de,
		0x01241d77, 0x23072327, 0x07f35518, 0x07060625, 0x43262633, 0x01371274, 0x28e52a0b, 0x312a1154, 0x1d661e36, 0x112a2f35, 0x183217f2, 0x433017bf,
		0xfc33147a, 0x9442a2a2, 0x4a4a9d9a, 0x42949a9d, 0x923f0f02, 0x45935a58, 0xcc200a8f, 0x43078f45, 0x04330777, 0x33050203, 0x50131c45, 0x4f4b0f04,
		0x4f3d0f03, 0x42310f02, 0x0021095f, 0x085b4104, 0x16000f38, 0x26002200, 0x40407f00, 0x20262625, 0x13021a1a, 0x03091011, 0x27190310, 0x0f39171c,
		0x23270428, 0x09171d26, 0x14790201, 0x10031313, 0x0441090a, 0x000f4403, 0x05447244, 0x41333321, 0x102d054e, 0xcddeddde, 0x10c61001, 0x3d3911ce,
		0x0744412f, 0x290f4e41, 0xcd2f1833, 0x31cd2f33, 0x33412130, 0x44272011, 0x01210ece, 0x15304194, 0x1c151624, 0x0382151c, 0xe2e28622, 0x24122541,
		0x17171bb4, 0x2103831b, 0xbf4639b6, 0x092f4109, 0x0000a831, 0x10401700, 0x3d050203, 0x50131c3e, 0x413f0f03, 0x3421072a, 0x2a2f8334, 0x0100001b,
		0x020603e2, 0x82a10026, 0x00073409, 0x0059008a, 0x4010008b, 0x1754020b, 0x50100418, 0x46190702, 0x1f26081b, 0xde01f5ff, 0x2b827b02, 0x2b82c120,
		0x8a000624, 0x29830009, 0x4c040329, 0x5007214d, 0x844e0003, 0x00013229, 0x01f3ff2e, 0x007902da, 0xb9c1002d, 0xe0ff2800, 0x05027db3, 0x11b3d822,
		0x2d058367, 0x000c0bb4, 0xffb8274c, 0x0010b3f0, 0xb558234d, 0xb8222306, 0x2883e8ff, 0xf0200782, 0x08a25b18, 0x4d000c22, 0x0b200f84, 0x2605354e,
		0x00120fb4, 0x82b81a4c, 0x850e2051, 0x31402610, 0x0f4d000d, 0x210d8218, 0x0982100f, 0x0001033a, 0x1c1c0973, 0x2f090607, 0x2e127625, 0x7c201d1d,
		0x79010917, 0x04020602, 0x17290182, 0x0d7c2a45, 0xed3f0046, 0x0565463f, 0x32ed1022, 0x2f200282, 0x26057a46, 0x2f33cd32, 0x18cdfd10, 0x230ddb44,
		0x252b2b2b, 0x0915f718, 0x22065460, 0x18023e34, 0x2109129d, 0x5c5f020e, 0x36420805, 0x475b0137, 0x2c2c5347, 0x35345013, 0x26213e55, 0x20315740,
		0x06162230, 0x203a151b, 0x172a3a23, 0x263b2815, 0xae071b19, 0x41565641, 0x2b15079f, 0x4e4d7952, 0x0a2b5278, 0x45040f0e, 0x42241712, 0x657b395d,
		0x00003b05, 0xff280002, 0x01e20158, 0x002200db, 0xb9980035, 0xf0ff3000, 0x4d000eb3, 0xd568b82b, 0xb3f02108, 0x0f83ec82, 0x0c4c4036, 0x18204d00,
		0x4c001211, 0x00101020, 0x0f180b4d, 0x064c0010, 0x05210584, 0x20168310, 0x380b8405, 0x22232426, 0x1511137f, 0x08822d37, 0x36081b1b, 0x11262314,
		0x03883226, 0x3a018226, 0x881f360d, 0x882a4b18, 0x3f00500d, 0x11ed3fed, 0x2f393912, 0x11ed102f, 0x55cd1033, 0x10280554, 0x32de10ed, 0xcc32fdce,
		0x610c1c41, 0x342d0763, 0x3233023e, 0x33151716, 0x14152315, 0x09fc5d06, 0x21051153, 0x45182626, 0x66080a48, 0x360d4901, 0x33442723, 0x4c351b1d,
		0x1c503932, 0x6a684747, 0x0f1a452a, 0x43253e19, 0x0c5a5a3b, 0x3e3c2026, 0x16271e12, 0x2b10331c, 0x371b1208, 0x55333a55, 0x0811233e, 0x6cb23daf,
		0x490a0e60, 0x413a0e0b, 0x04743dbb, 0x28495807, 0x12112539, 0x00ffff0c, 0x01f3ff2e, 0x023d03c7, 0x002a0026, 0x01070100, 0x4236005f, 0x012905bf,
		0x092a2635, 0x0e015001, 0x08bf422b, 0x58ff2822, 0x2006db48, 0x05db484a, 0x0000122f, 0x020b4010, 0x07322e21, 0x0c025010, 0x06db4933, 0x2f4a4020,
		0x492e2008, 0x132e0a2f, 0xff0100b9, 0x170940e5, 0x5008101b, 0x324a0001, 0x00002406, 0x822b0002, 0x03de2c25, 0x0016003e, 0x4085001c, 0x78000645,
		0x00260628, 0x13060b14, 0x0d190010, 0x24080e81, 0x1b1c401e, 0x19196017, 0x007f0b10, 0x0d08010d, 0x05100b1d, 0x171b4914, 0x80181a40, 0x0f0e1c19,
		0x054a0d4d, 0x05467806, 0x9b4f3320, 0x3f290807, 0x01393912, 0x5d5ed610, 0x193232ed, 0xcdcd1a2f, 0x10181a33, 0x102f32ce, 0x2b0487c1, 0x87c10010,
		0xc4107d05, 0x10180887, 0x2209822b, 0x783031c4, 0x373b0a5c, 0x37363611, 0x03060633, 0x17371737, 0x441bee07, 0x62123c43, 0x3f3f3813, 0x78535319,
		0x23080549, 0x54541afd, 0x14ff6e1a, 0x1f49463d, 0x323c411f, 0x8902df11, 0x3077fe0e, 0x6c33335f, 0x3628e501, 0x00552836, 0x02310082, 0x59ff1d00,
		0x7902d801, 0x30002400, 0x00b9b300, 0x0597422f, 0xffb82f2b, 0x0d1440f8, 0x182d4d00, 0x2004820e, 0x23098210, 0x0e0d1029, 0x2005e143, 0x2c0883b4,
		0xd8ffb817, 0x000c08b4, 0xffb8134c, 0x200884e8, 0x23088212, 0x4d0010b3, 0xf02d0782, 0x000f3f40, 0x0f180e4d, 0x0d4c0010, 0x21258318, 0x19821008,
		0x82200821, 0x84082015, 0x0625080f, 0x1d1a2303, 0x762b251d, 0x76253215, 0x100b400b, 0x1f310b48, 0x7c2e3100, 0x7c284510, 0x0046061a, 0x3fed333f,
		0x051f7fed, 0x10ed2b28, 0x3911edde, 0x9818332f, 0xf5510a57, 0x052b2707, 0x34352622, 0x43183736, 0x152309a7, 0x18070614, 0x22097498, 0x64161403,
		0x25080526, 0x01062223, 0x212f3324, 0x38503011, 0x513b201f, 0x3b513132, 0x092f3720, 0x24182021, 0x060b1406, 0x4543d816, 0x02824546, 0x24a7432c,
		0x112e1720, 0x78502801, 0x97745352, 0x8c6e2e06, 0x1e180724, 0x031a0e20, 0x010a3603, 0x095073dd, 0x28000232, 0xcc0159ff, 0x2700db01, 0xc6003300,
		0x20320c40, 0x3227f383, 0x4d000e18, 0x73ffb830, 0x0882054f, 0x82b3e821, 0x872c2010, 0x22088210, 0x821340f0, 0x282a2711, 0x2a4d0010, 0x04820f20,
		0xfd441020, 0xb4f02205, 0x050e4511, 0x0ab3d825, 0x83194d00, 0x09082931, 0xb8154c00, 0x0b40e8ff, 0x0f210983, 0x25058318, 0xf0ffb80b, 0x3c822b40,
		0x0e840a20, 0x03082108, 0x1c262620, 0x282e2020, 0x2e351782, 0x09400d82, 0x340d480c, 0x2b340022, 0x31501288, 0x51081c88, 0x22144f41, 0x18102f33,
		0x410d5a90, 0x52410555, 0x0f544106, 0x0c2c9418, 0x44341321, 0x25080504, 0x36323316, 0x30331601, 0x08081017, 0x1d34472a, 0x2d4d381f, 0x1f384e2e,
		0x25172d34, 0x240e0d12, 0x070a1406, 0x8c733d17, 0x24a73a07, 0x11251520, 0x26030608, 0x3734563f, 0x23233f5a, 0x48375a3f, 0x180e1f6b, 0x5e941813,
		0x8f012107, 0x21069573, 0x9b42ffff, 0x06032d05, 0x42022602, 0x07010000, 0x00008a00, 0x29050744, 0x32310002, 0x0250140a, 0x0744330f, 0x0159240a,
		0x827b02cc, 0x4643202b, 0x2b8205c7, 0x0b40102b, 0x35340002, 0x0250160c, 0x07e34d11, 0xf3ff1826, 0x3d03cf01, 0x0f202782, 0x270e374d, 0x1b2a2606,
		0x07015010, 0x26095b44, 0x015bff2c, 0x82b202af, 0x4da3202b, 0x0c240c37, 0x121b2d29, 0x2e202982, 0x24065b44, 0x0156ff47, 0x21278397, 0x27855d01,
		0x0000242e, 0x010b4010, 0x0b18143a, 0x01015002, 0x38056d47, 0xff1b0003, 0x02df01fb, 0x00110071, 0x002e0022, 0x2a0b408c, 0x4d000f18, 0x23048327,
		0xe0ffb81a, 0x74074755, 0x10230852, 0x47144d00, 0x07820641, 0x40e03008, 0x00111031, 0x1f76284c, 0x2d170117, 0x0e052073, 0x007e0e09, 0x00001405,
		0x090f0f05, 0x06000006, 0x421c7c26, 0x41127c2b, 0x11790e00, 0x7e050941, 0xed21071e, 0x07965632, 0x234a1020, 0x18012608, 0x5ddced2f, 0x080d59ed,
		0xe0530120, 0x1b86560c, 0x8056df20, 0x2b022126, 0x20257a56, 0x05174100, 0x1741e220, 0x407c2908, 0x0e182a0d, 0x274c000f, 0x1a290584, 0xb4e0ffb8,
		0x4c001210, 0x21088214, 0x09833740, 0x2f762828, 0x02176f17, 0x04412e17, 0x41842005, 0x00230704, 0x41080109, 0x85260e08, 0x05094911, 0x5a560885,
		0x0b084105, 0x4b5d5e21, 0x0a41072e, 0x2907410c, 0xe054e220, 0x1839560d, 0x54920121, 0x33560cd8, 0x00033f19, 0x01f5ff05, 0x00b502eb, 0x0020000d,
		0xb67b0032, 0x0b0a101b, 0xb80a4c00, 0x12b3d8ff, 0x07824d00, 0x11b3f02a, 0xb8054d00, 0x3540f0ff, 0x30081082, 0x2f2a2f26, 0x14262184, 0x30262121,
		0x012a0030, 0x21272a08, 0x00202721, 0x82080f7f, 0x852f2118, 0x262a4931, 0x034c2985, 0x0b501d89, 0x0e511389, 0x0823560f, 0x3f32ed2f, 0x2f0132ed,
		0xc0fddced, 0x102f332f, 0x090c41cd, 0x01303123, 0x2000822b, 0x2a0d5613, 0x0556bc20, 0x78012129, 0x4829ff55, 0x3e200807, 0x33070748, 0x38008f00,
		0x10008900, 0x3b010b40, 0x01092628, 0x270e0150, 0x200e0748, 0x282b82b5, 0x0100004a, 0x298f0006, 0x29298300, 0x2e303c02, 0x02501007, 0x29842f0c,
		0x24000139, 0xd201f3ff, 0x21006b02, 0x17b64800, 0x00100a20, 0xffb8124c, 0x832140e8, 0x1c203c09, 0x02211d73, 0x1d1a1a73, 0x1b0f730c, 0x1d202079,
		0x1d411e00, 0x147c0744, 0x54490d46, 0x122006a0, 0x2005564e, 0x0610622f, 0x2b303124, 0x596b132b, 0x1411220b, 0x05ba780e, 0x23353908, 0x33112311,
		0x4fd83311, 0x0c110b05, 0x060c120c, 0x311c0b4e, 0x1c302626, 0x4e4e660a, 0xfe6b0266, 0x1f372b59, 0x371f0b0b, 0xfe0c012b, 0x364d32f4, 0x4d361c1c,
		0xe0fe5c32, 0x21081a82, 0x000000fb, 0xff490002, 0x02cd015b, 0x000d0071, 0x406c0019, 0x0f301515, 0x18154d00, 0x114d000e, 0x04821210, 0x00110829,
		0xffb8074d, 0x8410b3e0, 0xb3f02207, 0x2207840a, 0x7208b4e8, 0xe82205ad, 0x19821b40, 0x08761325, 0x680d0e1b, 0x1a3105d3, 0x440d7c0e, 0x027c1619,
		0x00014105, 0xed333f2f, 0x15405c32, 0x5c231721, 0x15200530, 0x3408cc82, 0x033e3507, 0x23263435, 0x9b070622, 0x345a1d52, 0x532f6f6a, 0x512d4070,
		0x3b49233d, 0xa50c2d21, 0x1c0ded02, 0x794e7174, 0x4e1d485f, 0x624a3719, 0x0d524944, 0x29be8205, 0x3700ffff, 0xbd010000, 0xaf183e03, 0x00210777,
		0x20168243, 0x05255389, 0x0940fd2e, 0x10071315, 0x14080150, 0x342b2b4f, 0x47202f85, 0xb0222f82, 0x2f82b502, 0x09825120, 0x43000624, 0x2d8500f3,
		0x0940ee2a, 0x05001517, 0x16020150, 0x04202d85, 0x37060b4e, 0x0019003e, 0x002c0020, 0xb9990030, 0xd8ff1900, 0x11084f40, 0x28154c00, 0x4e080583,
		0x2d272100, 0x27142f2f, 0x1b1d0a27, 0x1a0b111a, 0x110c780b, 0x110c0c14, 0x0208091e, 0x78081a08, 0x07140207, 0x070c1a02, 0x2d310c32, 0x2e2e2f30,
		0x092a2417, 0x1d1e790a, 0x2a2a0c1d, 0x0b11021a, 0x0708440c, 0x333f0044, 0x332f333f, 0x4e2f3333, 0xcd310721, 0xddcd2f32, 0xc61001cd, 0x3911de10,
		0x7d872b87, 0x106f4fc4, 0x2f183322, 0x102d2583, 0x3031cdde, 0x14012b2b, 0x17031e07, 0x062b4e23, 0x35262628, 0x32333634, 0x634f0716, 0x47372005,
		0x27080a47, 0x37270737, 0x18174e01, 0x112a3031, 0x24ee2557, 0x312b1054, 0x0c0b1832, 0x32212330, 0x1c321755, 0x16321ac8, 0x19121219, 0x2b080383,
		0x86138c29, 0x17236e02, 0x95989039, 0x3ea2a23e, 0x388e9896, 0x26131e0b, 0x3f7b2c2c, 0x995e5f95, 0x17171591, 0x18181515, 0x3c312ca4, 0x2109734f,
		0x734f2d03, 0x00a63108, 0x400f0000, 0x02030409, 0x1c313a05, 0x342b5013, 0x200b3b4e, 0x083b4e3e, 0x65008f22, 0x29057343, 0x17196402, 0x02501004,
		0x3b4e1807, 0x4eb5200e, 0x8f30083b, 0x10000022, 0x21030b40, 0x07214c4e, 0x4d000350, 0x25061f47, 0x01dfff1d, 0x538303d8, 0x0000b328, 0x8f000701,
		0x53851500, 0x30180328, 0x500c002e, 0x9d430803, 0xff002905, 0xff2800ff, 0x02cc01e0, 0xd3205383, 0x06232b82, 0x85178f00, 0x311b2853, 0x5010032f,
		0x86300c03, 0x05ff5553, 0x24205383, 0x07222782, 0xcf82a502, 0x154f8920, 0x1e002c05, 0x500f0418, 0x4f1d0903, 0x82190902, 0x82da822e, 0x565b821c,
		0x5b830507, 0x33824420, 0x33840620, 0x2805474f, 0x131c3238, 0x370f0350, 0x0552484f, 0x63563183, 0x56282008, 0x02210763, 0x097f48a4, 0x63562920,
		0x419d2015, 0x2b83085f, 0x0b401025, 0x56430502, 0x5b200d63, 0xcc217982, 0x20b78303, 0x34b78a28, 0x0102b11a, 0x40e7ffb8, 0x000d130d, 0x0102500a,
		0x01014f12, 0x82ba850e, 0xff282287, 0x1bd218f5, 0x2cb7890b, 0x13232902, 0x00035002, 0x00024f28, 0x202e8524, 0x852f8200, 0x85b78363, 0x00a42263,
		0x0537491b, 0x1e010123, 0x215f8210, 0xc7560101, 0x185b8509, 0x210817c4, 0x3f4da402, 0x34142206, 0x225a8226, 0x41270002, 0x5320066f, 0x9b20ad82,
		0x2c20b784, 0xff24b785, 0x008900ef, 0xef20b785, 0x0424b783, 0x09025002, 0x0920b782, 0x2f20b789, 0xc224b782, 0x2602b502, 0x23052357, 0x00cba502,
		0xc92e3186, 0x171d0d40, 0x02500b01, 0x014f1c02, 0xba861802, 0x83570020, 0x85bb8308, 0x08734167, 0x1e000122, 0x82158357, 0x205f86bb, 0x0a8357a4,
		0x83572820, 0x023e2414, 0x8c320026, 0x020323bf, 0xbf82ffb8, 0x0021272b, 0x04035009, 0x04024f26, 0x0c774122, 0x20058b42, 0x052f4252, 0xbf83ef20,
		0x09243188, 0x0e035000, 0x0e203182, 0x00203186, 0xeb57bf83, 0x85bf8305, 0x22bf8867, 0x57320002, 0xbf8215eb, 0x5f850020, 0x82073342, 0x575b8229,
		0x372009eb, 0xcf217d82, 0x20bb8303, 0x25bb8635, 0x008900e6, 0x8983b11a, 0x0d40dd2e, 0x08122b31, 0x30170350, 0x2c17024f, 0x5320bb88, 0x0dafb018,
		0x84a50221, 0x010232bb, 0x40d9ffb8, 0x000f150d, 0x02025006, 0x02014f14, 0x0a7b4110, 0xbb836785, 0xa42f6785, 0x8b00e6ff, 0x00b91300, 0x40ddff02,
		0x822e3c09, 0x17022166, 0x8306aa43, 0x846b20eb, 0x20bf8363, 0x2c098255, 0x1ba40206, 0x40100000, 0x2004010b, 0x225f8212, 0x42130201, 0x2f57063b,
		0x0207240d, 0x42f8ffa5, 0xf82e083b, 0x1b210d40, 0x02501404, 0x014f2006, 0xbf881c06, 0x20052b57, 0x08bb56b5, 0xf12dbf89, 0x171d0d40, 0x02500007,
		0x014f1c09, 0x0b3b4209, 0xbf836785, 0x8f823820, 0xaf430720, 0x00012209, 0x1513592c, 0x5820bb83, 0x0020bb85, 0x0122bb85, 0x5b821a28, 0x1b090122,
		0x343d8982, 0x1e000100, 0xd5015bff, 0x32007802, 0x00b9bf00, 0xb3d0ff29, 0x284d000b, 0xb3d8ffb8, 0x05bb730c, 0x0f0eb42c, 0xb8254c00, 0x11b3e8ff,
		0x07824d00, 0x10b3e028, 0xb8234d00, 0x1884f0ff, 0xffb81f2b, 0x085840e0, 0x201a4d00, 0x20048212, 0x22238228, 0x8210181a, 0x0f202509, 0x28144d00,
		0x18260483, 0x104d000e, 0x04820d20, 0x820c1821, 0x0b102404, 0x830f4d00, 0x30072122, 0x28081382, 0x21761224, 0x27760521, 0x0c2f2f34, 0x2433190c,
		0x0c0c790b, 0x2c7c001c, 0x7c151818, 0x3f00451c, 0x2f2f32ed, 0x2f3911ed, 0x05537aed, 0x85693220, 0xc25d1805, 0x172b2114, 0x08875c18, 0x84333521,
		0x0d01570a, 0x226d0620, 0x226d0808, 0x16163727, 0x516d3d57, 0x51422a2f, 0x2e1b2227, 0x491f384e, 0x1451354d, 0x3c63171b, 0x233d5532, 0x4c44393d,
		0x4a896a3f, 0x050a210a, 0x0f5a1908, 0x2d334227, 0x440e223a, 0x22332111, 0x0b17433b, 0x16170e44, 0x31344a30, 0x6614185a, 0x3b604840, 0x014b0219,
		0x00010001, 0x015bff39, 0x00dc01b1, 0x40bc0031, 0x10202224, 0x28224d00, 0x2504820f, 0x4d000e10, 0x1641301a, 0x83152007, 0x20152dfd, 0x0d4d000c,
		0xb4e0ffb8, 0x4c000f0e, 0xe8270882, 0x4d000db3, 0x7effb80a, 0x062005fa, 0x82062e4d, 0xb3e82507, 0x034d0011, 0xb3211882, 0x20078412, 0x260f86e0,
		0x0a08b4e8, 0x82024c00, 0x22402118, 0x24082182, 0x05822408, 0x0b821805, 0x111f1f33, 0x08322d11, 0x1f1f851e, 0x10891100, 0x272c2c4b, 0x00500088,
		0x2f32ed3f, 0x254a413f, 0x18321321, 0x290c0490, 0x35053e27, 0x23022e34, 0x55413523, 0x0e620807, 0x3e270702, 0x4b2bd103, 0x2c371f37, 0x6b433d3a,
		0x19064084, 0x303e413f, 0x433d2a1d, 0x43240b19, 0x393f1f34, 0x1b252c17, 0x20080f06, 0xdc012f2a, 0x2b3c2612, 0x0d124729, 0x523e304e, 0x01451431,
		0x1f130b05, 0x28211e2c, 0x0a450615, 0x2b1d2718, 0x0908062f, 0x08034803, 0x00000607, 0x2d00ffff, 0x1f530000, 0x4e2b2006, 0x00270ec3, 0x0107100c,
		0x45000150, 0x002306df, 0x822c0002, 0x03b03021, 0x0015003e, 0x4080001b, 0x12201015, 0x19104d00, 0x31223522, 0x4d000929, 0x1d0c7f0d, 0x16181a40,
		0x031b1b60, 0x48827f15, 0x1c000838, 0x50068811, 0x1940161a, 0x1b188017, 0x0d4d0201, 0x3f004a00, 0xd4523f32, 0x055a7f09, 0x2306d252, 0x181acd33,
		0x09394718, 0x332b2b22, 0x09c84d18, 0x4a231121, 0x11200654, 0x0805c452, 0x14534729, 0x47351832, 0x3052122a, 0x0b311a3e, 0x54541a6e, 0x89026e1a,
		0x0908ce0e, 0x2f4e381f, 0x56f4fafe, 0xfe050b47, 0x5216037f, 0x013f07bc, 0x5bff2d00, 0x7802c701, 0x3b001300, 0xff1100b9, 0x082240e0, 0x044c000c,
		0x4d001028, 0x820f1804, 0x0e103404, 0x73024d00, 0x73081513, 0x7c05140b, 0x440a450e, 0x742f0001, 0x31220975, 0x00822b30, 0x11230529, 0x22232634,
		0x4a110706, 0x240805f5, 0x0115021e, 0x483f52c7, 0x5212401d, 0x3b3f6b21, 0xa5143050, 0x60661002, 0xddfd0509, 0x120b5b02, 0x365b4125, 0x3c008200,
		0xff190003, 0x02f40158, 0x000e00b5, 0x00420035, 0x202fb6a7, 0x4c000f0a, 0xe0ffb82a, 0x200883b4, 0x21088226, 0x09832140, 0x11281833, 0x184c0012,
		0x000a0820, 0x1228134c, 0x18134d00, 0x84048211, 0xb80a270f, 0x10b3e8ff, 0x07824d00, 0x3040e022, 0x3134b582, 0x20393232, 0x0f1d307f, 0x08400e0e,
		0x40431582, 0x23332028, 0x27081382, 0x31313630, 0x1e4b2d3d, 0x85034d1f, 0x2336501a, 0x12850b23, 0xed3f0051, 0x3fcd2f32, 0x3f333fed, 0x122f33cd,
		0x11333939, 0x012d0482, 0xd610cd2f, 0x2f3912ed, 0xed333333, 0xdd5b1832, 0x0bdb4d0e, 0x2206a16e, 0x55343526, 0x352505f1, 0x36361137, 0x0a846633,
		0x37270729, 0x22373426, 0x53150706, 0x87080748, 0x16240af0, 0x07101812, 0x1914252b, 0x1d0c0108, 0x11554c0e, 0x1a223323, 0x11520b29, 0x27181522,
		0x1d0e0f1c, 0x3b2f1f2e, 0x5e2b4310, 0x1a138c01, 0x1a1a200e, 0x7001191a, 0x2f1a170d, 0x5851243f, 0x0844040a, 0x36717f09, 0x15244059, 0xfd0eeb0a,
		0x150d0d8b, 0x16192f22, 0x2917252e, 0x70265125, 0x141b0a09, 0x28201610, 0x261b1a27, 0x24000200, 0xd001fcff, 0x2f006b02, 0x83004100, 0x10183ab5,
		0xb8374d00, 0x1440e8ff, 0x16210882, 0x2b048210, 0x00082012, 0x1120114d, 0x0d4c0012, 0x82060544, 0xb3d02907, 0x0c4d0011, 0xb3e0ffb8, 0x08251d82,
		0x40f0ffb8, 0x082b8222, 0x7629052f, 0x763d0000, 0x2319430a, 0x351c1c76, 0x19421476, 0x267c3005, 0x411f2c26, 0x420f7c38, 0x3fed3f00, 0xed2f3933,
		0x10013939, 0x2f33edd6, 0x05766ced, 0x230c4e45, 0x020e1401, 0x3106c06e, 0x022e2223, 0x023e3435, 0x35262637, 0x33373634, 0x24410606, 0x33272508,
		0x22071616, 0x08083871, 0x2e343530, 0x09a70102, 0x17131c12, 0x18131f2a, 0x39395034, 0x12183452, 0x26172a1f, 0x52080723, 0x2f2b0905, 0x05092b2f,
		0xad070852, 0x1524301b, 0x0583394b, 0x24152808, 0x16e10130, 0x091d262a, 0x33261b09, 0x33442920, 0x45321c1c, 0x26332029, 0x4f12091b, 0x233c2b2b,
		0x3c203d20, 0x823c3f3f, 0x232b0806, 0x1c0de13c, 0x363f1f2b, 0x202c1c0d, 0x0d1c2b1f, 0x02000000, 0xf5ff2100, 0xb502d401, 0x35000b00, 0x15409c00,
		0x0011182d, 0x18102d4d, 0x2008bccc, 0x06805820, 0x1110b439, 0xb82b4c00, 0x0a40f0ff, 0x4c000f0e, 0x0008181a, 0xffb8144d, 0x820a40e8, 0x180a2a08,
		0x4c00100d, 0xe0ffb808, 0x200883b4, 0x20178304, 0x20098329, 0x3e188402, 0x0c822f0f, 0x1282000c, 0x82291f37, 0x82062222, 0x0f1f361c, 0x2c2c8803,
		0x094d2532, 0x41511788, 0x2b232351, 0x4d252b2b, 0x13200a05, 0x0c074918, 0x36343522, 0x08165e41, 0x4a820124, 0x4b4b3d3d, 0x344a3d3d, 0x3f2d232b,
		0x2f503a20, 0x203a5030, 0x2b232d3f, 0x05500509, 0x33343506, 0x08820635, 0x45d20925, 0x82455050, 0x95013f03, 0x160f4f33, 0x52344564, 0x391f1e39,
		0x64453352, 0x334f0f16, 0x20264726, 0x4148203e, 0x06824841, 0x47263408, 0x01000000, 0x59ff3600, 0x6b02c701, 0x40002100, 0x170f2140, 0x05060673,
		0x781e191e, 0x00140500, 0x1f230005, 0x0022191f, 0x4121791e, 0x05190c13, 0x82441879, 0xdc3223e3, 0xad6e3fcd, 0xde103306, 0x7d872b87, 0x183301c4,
		0x31ccfd2f, 0x030e0130, 0x067e2107, 0x2135210e, 0x0ff32f19, 0x341c0b31, 0x0a200d28, 0x08160808, 0xbffe1b21, 0x194e4b1f, 0x200d0030, 0x09501829,
		0x360f2709, 0x7880853f, 0xa7834633, 0xa7824920, 0xd001ab22, 0x7f20a787, 0x8120a785, 0x8522a78c, 0xa7834921, 0x4c188522, 0x3320a7a0, 0x232ea794,
		0xa4012135, 0x46473e12, 0x1a09ff1b, 0xa6822730, 0x1905073a, 0xfe172208, 0x443f15e9, 0x01e41841, 0x1592014e, 0x2d645b4b, 0x2c3d2746, 0x20079a7e,
		0x06216913, 0x63000021, 0x312009ab, 0x3307474d, 0x02006201, 0x10009a00, 0x02020b40, 0x0f041f19, 0x17090250, 0x4d08534e, 0x972005a3, 0x2008ab63,
		0x83428262, 0x33052529, 0x50131c39, 0x0805115e, 0x01003439, 0x57ff5b00, 0x6b02cc01, 0x5b002600, 0xb80311b1, 0x2b40c0ff, 0x03480e0b, 0x0b170024,
		0x1f181414, 0x221b1b1f, 0x73211d28, 0x79202718, 0x1c211d1d, 0x21411979, 0x82001879, 0x080f311a, 0x00441823, 0xcddc333f, 0xcd2f3912, 0xed3fed10,
		0xed230782, 0x7fd61001, 0x322b05d8, 0x2f39112f, 0x32dd33cc, 0x18cd2bd5, 0x261a92b6, 0x15211521, 0x82231533, 0x23230805, 0x27010606, 0x1509171a,
		0x28171a23, 0x180b0a0b, 0x0725200f, 0xa3070f05, 0xf7fe5b01, 0x1f01e8e8, 0x18090594, 0x28149eb6, 0x46be466b, 0x120846db, 0x22008200, 0x82280002,
		0x01c73acf, 0x003000db, 0xb9da0039, 0xf0ff3600, 0x4d000eb3, 0xe0ffb828, 0x000e0db4, 0x2208824c, 0x4a0cb3e8, 0xb3210559, 0x22078414, 0x8413b3f8,
		0xb3d82207, 0x22078410, 0x860fb3f0, 0x00092107, 0x2005a270, 0x20078412, 0x08795dd8, 0x0f851020, 0x820f4021, 0x101f2128, 0x1f210d82, 0x41098218,
		0x3b08053d, 0x480e0b2e, 0x17003003, 0x1c14140b, 0x2d258231, 0x393b252d, 0x3a1c8226, 0x30141400, 0x263a080f, 0x21393986, 0x88292c2c, 0x34513017,
		0x00502188, 0x333fed3f, 0x112f32ed, 0x10ed2f39, 0x41054a41, 0x10220842, 0x424112ed, 0x08a9590a, 0x05200884, 0x240eb571, 0x27273435, 0x09695836,
		0x1515162e, 0x33161621, 0x17373632, 0x13070606, 0x2106f272, 0x5f411b01, 0x0420080f, 0x4a32060d, 0x3e261931, 0x665e294e, 0x5505b4fe, 0x103e2c4d,
		0x2d460e0b, 0x1d333e4d, 0x0314222f, 0x08107141, 0x0e1d0b28, 0x523f2906, 0x3c5c3e2f, 0x1d77751e, 0x080e4b48, 0x02100846, 0x453b2001, 0x182e2416,
		0x05000000, 0xf3ff1e00, 0xff64d901, 0x002f3608, 0xb9ca0039, 0xf0ff3800, 0x000e1440, 0x0d10364d, 0x344c000e, 0x290a8218, 0x000d1034, 0xffb8324d,
		0x0c82b3e8, 0xf0220782, 0x10821340, 0x08182e27, 0x182d4d00, 0x24048210, 0x4d000f10, 0xe05e1829, 0x82282007, 0x82b32008, 0x8624201a, 0x47232007,
		0x078206f0, 0x3840f022, 0x1f202982, 0x1f213383, 0x21098220, 0x2782101e, 0x1a1a3e08, 0x1b090f15, 0x0909031b, 0x2676351c, 0x1c76303b, 0x48100b40,
		0x7c333a1c, 0x1b18462b, 0x000c0612, 0x41217c37, 0xdeed3f00, 0xde32dd32, 0x01ed3fcd, 0xed2bd610, 0x12edde10, 0x32cd2f39, 0x06eb612f, 0x820d7641,
		0x1b74650d, 0x18340321, 0x2d095d76, 0x022e2223, 0x33161437, 0x23343532, 0x03620622, 0x186b2012, 0x260fcf4f, 0x8c454254, 0x6242458c, 0xfe361303,
		0x4c765328, 0x764c2424, 0x4c775353, 0x774c2323, 0xf2787a53, 0xd35078f2, 0x02cc2406, 0x4e2602cc, 0xa72006fb, 0x33052b64, 0x00020304, 0x00093422,
		0x3a0e0450, 0x2c0e034f, 0x200e024f, 0x410c0362, 0x1d2b07a3, 0x35002100, 0xff003f00, 0x413e00b9, 0x3c3006a1, 0x000e0d18, 0x0e183a4c, 0x103a4d00,
		0x384d000d, 0x8206a141, 0x40f02207, 0x3210820f, 0x00081834, 0x0f20334d, 0x2f4c0010, 0xb3f0ffb8, 0x824d0010, 0xb3e82507, 0x2e4d000f, 0x20069c41,
		0x2007862a, 0x21078229, 0x29831c40, 0x83182521, 0x83242005, 0x1012213a, 0x12200a83, 0x03236684, 0x83e0ffb8, 0x20078240, 0x824083f0, 0xb3e82207,
		0x05814c0e, 0x2f403908, 0x204d000d, 0x0f001d20, 0x0f0e2121, 0x763b220f, 0x7636412c, 0x100b4022, 0x39402248, 0x1e46317c, 0x1d1d1421, 0x051a0b14,
		0x3d050e0e, 0x0041277c, 0x32ceed3f, 0xdccd102f, 0x4105bf41, 0x33250dd2, 0xcddc102f, 0x0c1f7f33, 0x200adc41, 0x059c7d01, 0x48182620, 0x17200a16,
		0x23054143, 0x23153327, 0x0819d841, 0x03840122, 0x111e1610, 0x0f0d1e10, 0x170f0b12, 0x0f032806, 0x11121c16, 0x11100d1d, 0x06180f0b, 0x6ae3e3d3,
		0x2e17e741, 0x161a0bd7, 0x07080a10, 0x120d1907, 0x82171a0b, 0x0608250a, 0x39540d18, 0x2116ec41, 0xd7530000, 0x01f52105, 0x200bef41, 0x311682ac,
		0x03104017, 0x202f0002, 0x03500009, 0x024f400e, 0xc3522e0e, 0x05475109, 0x51022221, 0x012106af, 0x097b5362, 0x00282227, 0x04025009, 0x08334620,
		0x20053369, 0x074b4297, 0x10262b84, 0x00020b40, 0x5a822822, 0x22054142, 0x43040034, 0x0f290adf, 0x2d002300, 0x00b9c000, 0x05c4432c, 0xffb82c2b,
		0x0d1840f8, 0x182a4d00, 0x2004820e, 0x21098210, 0x09822028, 0x09832820, 0x85b82621, 0x22078224, 0x820f40f8, 0x18212b1a, 0x4c00100f, 0x00081821,
		0x47421d4d, 0x22078206, 0x840fb3e8, 0xb3e8210f, 0x17201782, 0x8207fd43, 0x40e02208, 0x2011822d, 0x20348413, 0x2b348313, 0x03090f0e, 0x76291003,
		0x76242f1a, 0x1034a782, 0x272e1048, 0x0c461f7c, 0x2b00060f, 0x0041157c, 0xdddeed3f, 0x210fd843, 0xb974cdd6, 0x0e6d6413, 0x2119ee41, 0x6f6415fa,
		0x1abf4308, 0x41087564, 0xb74316ca, 0x088b6412, 0x2d2c0029, 0x03500009, 0x414f2e0e, 0x2b200570, 0x2a054f56, 0x0100000d, 0x020603e8, 0x5d3c0026,
		0x01250dc3, 0x04121100, 0x37b7180c, 0x827b2012, 0x825c202b, 0x0006232b, 0x9351008a, 0x22212106, 0x0937b718, 0x0002003b, 0x0158ff36, 0x00b002b3,
		0x00260019, 0x180eb65f, 0x4c000c09, 0xe0ffb809, 0x200883b4, 0x21088205, 0x09832540, 0x07243508, 0x7f191d28, 0x1017160f, 0x27171111, 0x4d198516,
		0x1d1d0f12, 0x1a020021, 0x10110c21, 0x004b0c10, 0x332f333f, 0xcddedd10, 0x11391232, 0xed3f3333, 0x32c61001, 0x32221183, 0xbc5732ed, 0x372b2106,
		0x25110e4d, 0x35231135, 0x134d1333, 0x25eb3e0b, 0x1f2c1b2c, 0x32200f11, 0x11403323, 0x015d2b43, 0x1745b563, 0x20240f1f, 0x401f2020, 0x0cdf4c1a,
		0x080d0827, 0xfd465f02, 0x09e44c6c, 0x0222e582, 0xd3822500, 0xda01f434, 0x39002c00, 0x23b66d00, 0x000d0820, 0xffb81e4c, 0x0883b4d8, 0x08871a20,
		0x08821120, 0x09284023, 0x08ef820e, 0x3a0a7f26, 0x24262625, 0x30147f2c, 0x24301c37, 0x2714252d, 0x342d1726, 0x25252621, 0x88054b21, 0x4c0a500e,
		0xed3f3f00, 0x1120e287, 0x2305587a, 0xdedd2f01, 0xe583dd82, 0xfd5dd620, 0x34132306, 0xfe4e022e, 0x4e15200d, 0x34251003, 0x35342626, 0x0c064e17,
		0x1b11072e, 0x051e0f13, 0x30481653, 0x0d21372a, 0x2111fb4d, 0xfc4d8d01, 0x2b033108, 0x080c2037, 0x0179fe02, 0x180f08c3, 0xdc2f4730, 0x250ef44d,
		0x10131004, 0x12410d04, 0x00023a09, 0x0158ff3f, 0x006002b3, 0x002d0020, 0x200fb679, 0x4c000d08, 0xe0ffb80a, 0x250883b4, 0xd8ffb806, 0x09833340,
		0x2b082d08, 0x201d2424, 0x17101a7f, 0x2f1f1817, 0x00121211, 0x18080118, 0x201c1b2e, 0x1a1d8517, 0x21102449, 0x12130011, 0x0d282103, 0x0d111112,
		0x4109f141, 0x3f33060e, 0xcd32ed33, 0xc6100132, 0x2f325d5e, 0x11ce1033, 0x82332f39, 0x0afd4112, 0x2516fe41, 0x33153735, 0x04422315, 0x12f3230c,
		0x05421720, 0x11383408, 0x015d2b43, 0xbb526262, 0x17173dbb, 0x20201c0f, 0x8e401f20, 0x0d082bf4, 0x45800108, 0x45900e82, 0xfa8991fe, 0x03002308,
		0xf5ff1b00, 0xb502d901, 0x2f001e00, 0xa3004000, 0xff3b00b9, 0x1211b4e8, 0xb8354c00, 0x12b3e8ff, 0x07824d00, 0x1d40f028, 0x184d0011, 0x04820c10,
		0x820b1821, 0x0a202104, 0x28250482, 0x144d0009, 0x05627910, 0x0bb3f02a, 0xb8084d00, 0x0db3f0ff, 0xe8210784, 0x822b82b3, 0x40e0220f, 0x08188228,
		0x021f1023, 0x1e3f7f2f, 0x27163030, 0x38420a82, 0x33411682, 0x3d501b89, 0x22511389, 0x2c510d89, 0x00500589, 0x092f5e01, 0x18ed3f21, 0x220c795a,
		0x44393232, 0x13200d8d, 0x08a05f18, 0x18052e66, 0x22095969, 0x18171632, 0x4208536a, 0x23200567, 0x08075b5e, 0x33021e7b, 0xd5373632, 0x12200e4a,
		0x15232c16, 0x2a18404b, 0x17281011, 0x24164948, 0x1f14172e, 0x14084a08, 0x141b0f08, 0x150f080b, 0x0b1b0e0d, 0x0f1a074a, 0x0911160d, 0x0e18130b,
		0x0204170e, 0x0df60ea7, 0x5d38180f, 0x0d797a46, 0x820d0909, 0x385d4671, 0xfe0a1218, 0x12060585, 0x3630432a, 0x150e2744, 0x0e170d0f, 0x30364427,
		0x07122a43, 0x00000003, 0xff1b0003, 0x01d9015b, 0x065b41db, 0x00b96e24, 0x7363ff2a, 0xb8242105, 0x35063c7f, 0xe8ffb816, 0x000b3540, 0x0918094d,
		0x10064d00, 0x4c000b0a, 0x0a822006, 0x1c0e2408, 0x1f007f40, 0x8238081f, 0x82274214, 0x4b1e4108, 0x51198933, 0x5011893d, 0x500b8922, 0x5103892c,
		0x86ed3f00, 0x0a2e4101, 0x2c41ed20, 0x68372009, 0x3625076e, 0x17163233, 0x2a058336, 0x020e1415, 0x27262223, 0x41112315, 0x33220d17, 0xa6551616,
		0x05354105, 0x200ed525, 0x412b1712, 0x27210725, 0x1d254118, 0x132eb482, 0x170e0d19, 0x0f0e1204, 0x465d3818, 0x2241787b, 0x0b88080a, 0x063102b7,
		0x43291205, 0x27443631, 0x0d10150e, 0x44270e18, 0x29433136, 0x00040712, 0x00030000, 0x01a6ff09, 0x00b602eb, 0x00210019, 0x409d0024, 0x13031253,
		0x12047e03, 0x12040414, 0x1d061313, 0x070d1a1b, 0x0878071a, 0x0808140d, 0x0124210d, 0x1a000e00, 0x0e197800, 0x1a0e1914, 0x04261908, 0x00250804,
		0x12134419, 0x02050d12, 0x24790601, 0x1f221e23, 0x0d041114, 0x1a081d1d, 0x07410d0e, 0x03044408, 0x3f332f00, 0x332f0182, 0x122f3912, 0x33333917,
		0x3232ed33, 0x83331132, 0x6d012015, 0x5d5d05b3, 0xc40e2509, 0x10180587, 0x098be418, 0x18330123, 0x075c732f, 0x23272126, 0x23372707, 0x3d05bb6c,
		0x37171616, 0x031e0717, 0x06060317, 0x26373307, 0x33071726, 0x58259401, 0x52423f47, 0xb66c5424, 0x05340805, 0x3d270609, 0x2124133f, 0x17f20d1e,
		0x3a521836, 0x1d40120b, 0x12fca239, 0x9a42a2ea, 0x104aa3a2, 0x1087101c, 0x75793bde, 0x2302306f, 0xce58a63f, 0x64c13421, 0x2f05a34d, 0x01a6ff2e,
		0x00b602d9, 0x002b0023, 0x2a00b9de, 0x27058c43, 0xf0ffb82a, 0x4d0011b3, 0x402b0783, 0x4d000d14, 0x000b1029, 0x8208284d, 0x18282f09, 0x4c000c0b,
		0xe8ffb826, 0x00100fb4, 0x0882194c, 0x830a4021, 0x200f2a09, 0x014d000e, 0xb3d8ffb8, 0x20078412, 0x824083e8, 0xb3d0220f, 0x080f8410, 0x3940d848,
		0x094d000f, 0x15142827, 0x1d171508, 0x1607061e, 0x00001616, 0x08072d1a, 0x0c762408, 0x1b1d282c, 0x117c291b, 0x17151516, 0x27451114, 0x201e2323,
		0x0708037c, 0x03060907, 0x333f0046, 0x332f3333, 0x3232ed10, 0x0b88322f, 0x32322f2b, 0xedd61001, 0x10cd2f33, 0x231782ce, 0xc4877d2f, 0x01220082,
		0x0885dd18, 0x4a06f761, 0x252a0858, 0x22230606, 0x27072726, 0x1c542637, 0x17372108, 0x81088582, 0x27260717, 0x32331603, 0x14253736, 0x23131716,
		0xcc010622, 0x112d4f23, 0x40170f21, 0x28453b19, 0x083b6247, 0x3e120810, 0x10201011, 0x85201c18, 0x401d1c1b, 0x24ccfe22, 0x5e098120, 0x13141a5e,
		0x12550503, 0x7190225b, 0x2a52784f, 0x103f0101, 0x090e053c, 0xfe0a0f44, 0x130f0821, 0x1e664bd8, 0x0088c901, 0x00020000, 0x01b5ff28, 0x002502c3,
		0x002d0024, 0x2b00b9c3, 0x1340e0ff, 0x294d000c, 0x04820e10, 0x000b0838, 0x1008284d, 0xb8274d00, 0x6240f0ff, 0x234d000c, 0x4d000d28, 0x12822003,
		0x0e280327, 0x034c000f, 0x270f8230, 0x000f1002, 0x0e20024d, 0x18210482, 0x0804820d, 0x00082039, 0x13120b4d, 0x200a201f, 0x08292822, 0x0a092109,
		0x0e1a1a0a, 0x2121202f, 0x2e008225, 0x1d202021, 0x13191928, 0x1f228816, 0x0f12511d, 0x0588290f, 0x0b09090a, 0x41500508, 0x2f2d0953, 0x33333f32,
		0x2f3232ed, 0x2f331132, 0x0c524133, 0x22064a41, 0x82c48710, 0x0f504100, 0x3e343727, 0x32323302, 0x07444117, 0x03272622, 0x2108e84e, 0x68412223,
		0x37600805, 0x13171614, 0x28020e22, 0x365f4829, 0x18070c06, 0x1c0e1437, 0x1e111310, 0x190c690f, 0x233e210e, 0x2c4a230c, 0x38161e21, 0x544a4015,
		0x2566242a, 0xe71c3142, 0x1d3c5c3f, 0x3e134b01, 0x47050603, 0xfe020805, 0x070202b5, 0x0b0d450c, 0x42134606, 0x37556f19, 0x3d011447, 0x00402914,
		0x24000100, 0xcc3b0482, 0x0d006b02, 0x16402d00, 0x090b0f00, 0x0406730c, 0x030c0e03, 0x06060979, 0x780d4107, 0x392106da, 0x82e0822f, 0x33cd30d9,
		0x10cd32fd, 0x253031ce, 0x23112115, 0x82113335, 0x23153701, 0xfecc0115, 0x524949a1, 0x46468d8d, 0x01432101, 0x43f9fe07, 0x008200db, 0x00024008,
		0x01ddff12, 0x00a502f6, 0x000f000c, 0x042b4056, 0x0a0e0305, 0x0b0d0b0d, 0x0873000c, 0x01030006, 0x11030308, 0x05060d10, 0x0a790e07, 0x040c0300,
		0x0a0b0b0c, 0x04040541, 0x3f004402, 0x83332f33, 0x12112a03, 0xed103939, 0x39391132, 0x280a8201, 0x335d5e2f, 0x32cdfdcc, 0x24168433, 0x303132cd,
		0x22888201, 0x82132707, 0x21230805, 0x37071737, 0x52110123, 0xaaad3578, 0x36258601, 0x015d5de5, 0x9ae5fe1b, 0x110122bd, 0x3a461501, 0x8294f222,
		0xff3f39f3, 0x01b1015b, 0x003f00db, 0x1d00b9bc, 0x0cb3e8ff, 0xb81d4d00, 0x0bb3e0ff, 0xd8220784, 0x07840ab3, 0x09b3d02d, 0xb81b4d00, 0x0fb3d8ff,
		0x831a4d00, 0x840d201f, 0x822f8407, 0x40f0220f, 0x2728824c, 0x0b0a1808, 0x28084c00, 0x06212b82, 0x21208228, 0x4d823005, 0x82180521, 0x022d0819,
		0x4d000e10, 0x0d1c2a2a, 0x1c82000d, 0x37372241, 0x07008215, 0x40070801, 0x4b2d8926, 0x38388837, 0x893b0a18, 0x4e1f2203, 0x88130e0e, 0x066e5a0a,
		0xed393325, 0x7f323911, 0x332809c5, 0xde10332f, 0x112f33ed, 0x2811ed4d, 0x042e3425, 0x33363435, 0xf2c91832, 0x2223230d, 0xee4d2726, 0x46172006,
		0x2724055b, 0x3727032e, 0x32053a46, 0x3d295e01, 0x5b293d48, 0x1d512661, 0x241d080e, 0x846d1329, 0x5d280810, 0x0b13106b, 0x36431837, 0x080b1608,
		0x240b220b, 0x15232733, 0x201f2012, 0x452a1c13, 0x202a1720, 0x20197413, 0x32221718, 0x11973319, 0x41363208, 0x15310101, 0x4302021e, 0x140a0303,
		0x210f121c, 0x49081a1e, 0x0a040811, 0x00010011, 0x015bff4a, 0x00d001cd, 0x40a5002a, 0x12201d15, 0x101d4d00, 0x2004830f, 0x2c04820c, 0x4d000b18,
		0xd8ffb80d, 0x4d0010b3, 0x2007830c, 0x2507840e, 0x000db3e0, 0x12510b4d, 0x5d072006, 0x05210647, 0x626b18b8, 0xb3f02408, 0x824d000f, 0x40e8230f,
		0x08820928, 0x22272908, 0x05008127, 0x05000014, 0x2c001313, 0x22002828, 0x2b220801, 0x29852700, 0x86052249, 0x880f4c21, 0x3f004b16, 0x32ed3fed,
		0x21059055, 0x4b185d5e, 0x01210bf7, 0x0cb6482b, 0x030e0129, 0x17031e07, 0x5233031e, 0x51080570, 0x022e2223, 0x23032e27, 0x033e3523, 0x21352337,
		0x3d13a401, 0x151e4847, 0x08161d22, 0x24201e0f, 0x0b160415, 0x0b220b09, 0x20242b1e, 0x261d0a12, 0x15121d30, 0x1841433f, 0x014f01e5, 0x5c491592,
		0x11043167, 0x0f081414, 0x01101a20, 0x03034402, 0x2682180f, 0x10181a2f, 0x5d5f2837, 0x00451d53, 0x00010000, 0x30048244, 0x007902c1, 0xb9740023,
		0xe0ff2000, 0x4d0010b3, 0x20fe861e, 0x2507821b, 0x000f0eb4, 0x0882184c, 0x000ab323, 0x2207824d, 0x8409b3f0, 0x40e82707, 0x4d000827, 0x2e822012,
		0x0f28122e, 0x760a4d00, 0x11732319, 0x02100200, 0x25340082, 0x10011e24, 0x01077c0d, 0x44014516, 0x123f3f00, 0x1132ed39, 0x23054143, 0xdcfdce5d,
		0x2909e669, 0x3523332b, 0x37023e34, 0x58183636, 0x3a081448, 0x1c0e52fa, 0x30221e2b, 0x4e313447, 0x260a1c13, 0x661b362f, 0x291d1067, 0x16211718,
		0x3424bb0b, 0x14112028, 0x2f2d2630, 0x07430c1c, 0x5a080d10, 0x24302245, 0x1a0f0f1e, 0x821b261d, 0x550021d6, 0xa9260482, 0x2500dc01, 0x6b439100,
		0x00122105, 0x2005204f, 0x064b4311, 0x22055343, 0x860cb3e0, 0x840b200f, 0x83e02007, 0xb81a2bea, 0x3840d8ff, 0x4c000908, 0x2e821015, 0xe8831520,
		0x0f18152b, 0x20154d00, 0x144d000e, 0x254a8220, 0x251b820a, 0xf286137f, 0x2026272d, 0x0d121201, 0x18010788, 0x864c0150, 0x952f20f3, 0x822b20f4,
		0x2af88d00, 0x2707020e, 0x3233033e, 0x82141516, 0x0e42080a, 0x50fe1503, 0x16261b0f, 0x2a39291a, 0x1e252712, 0x23091a09, 0x5818312c, 0x231a105b,
		0x151b1112, 0x2b1e720b, 0x0f0e1b22, 0x1c231b26, 0x050d0b08, 0x0c0e0545, 0x1b3e4408, 0x0c182029, 0x1d17140b, 0x00820013, 0x1200033f, 0xc301fbff,
		0x1e007102, 0x40003100, 0x1240c500, 0x100f1036, 0x182e4c00, 0x2a4d0010, 0x210a8318, 0x644ab81d, 0x26088206, 0x0a09b4e8, 0x4b1b4c00, 0x078206d2,
		0x82b3d821, 0x861720f8, 0x2007820f, 0x270f83e0, 0xd0ffb812, 0x4d0012b3, 0x1f840782, 0xe0200782, 0x11253884, 0x40f0ffb8, 0x0819822f, 0x7638193e,
		0x762c1414, 0x2232421c, 0x09732320, 0x19410607, 0x2332791f, 0x20097906, 0x0132bf09, 0x09320932, 0x0f7c3d27, 0x007c2741, 0xed3f0042, 0x3912ed3f,
		0x5d2f2f39, 0xed103311, 0x39ed1032, 0x4407e845, 0xeb5a057a, 0x822b200c, 0x22172b00, 0x3527022e, 0x11333523, 0x185c033e, 0x16072a07, 0x06141516,
		0x15331503, 0xf77d1823, 0x05af4a12, 0x0fd98708, 0x0f262826, 0x260f3535, 0x2c0f2627, 0x0e1f384b, 0x33132119, 0x6dba6f45, 0x1d1d0a6d, 0x1928361c,
		0x1b322616, 0x2e173b4e, 0x21131624, 0x2417182b, 0x03020508, 0x3e860406, 0x06049401, 0x26100203, 0x29162e3e, 0x0e071b24, 0x5d5d3c4b, 0x3e532601,
		0x0a02024c, 0x1f232c1b, 0x440b192a, 0x1d26160a, 0x0a18261b, 0x00000201, 0xff120002, 0x02e201f3, 0x0014006b, 0xb9980021, 0xd8ff2000, 0x4d0012b3,
		0xe0ffb820, 0x078411b3, 0x1140f02a, 0x4c00100f, 0x12112017, 0x10200582, 0x14280b83, 0xb4f0ffb8, 0x4c000c0b, 0xe8240882, 0x4d000ab3, 0xf02d0782,
		0x00093340, 0x0a18014d, 0x014c000c, 0x080a8210, 0x731a0b29, 0x23120e10, 0x07731d0a, 0x10030005, 0x03032003, 0x1c220308, 0x0e790411, 0x0c07070a,
		0x7c154108, 0x3f004600, 0x4e333fed, 0x012c0637, 0x5d5ed610, 0x32ed33ce, 0xce32de10, 0x2a0d4b41, 0x35262217, 0x33352335, 0x84153335, 0x23152803,
		0x27061415, 0x82023e32, 0x14153d15, 0x61fa021e, 0x53353552, 0x353553c0, 0x24166152, 0x0dc00d19, 0x700d2319, 0xfc3d6669, 0x73080082, 0x7168663d,
		0x3c230d47, 0x2f5d5d2f, 0xff0d233c, 0x000900ff, 0x02eb0100, 0x0306026b, 0x0000009b, 0xff5b0003, 0x02d30197, 0x000f00a8, 0x00170013, 0x033f4070,
		0x12111615, 0x07020606, 0x090c0d00, 0x08080104, 0x190e0a0a, 0x04731410, 0x00020201, 0x20041004, 0x04080304, 0x79170c18, 0x05101009, 0x07070814,
		0x41057913, 0x0479140d, 0x00010102, 0x3f004404, 0x2606444a, 0x2f33ed3f, 0x48121133, 0xc6260614, 0x2f325d5e, 0x2b5910cd, 0x17123a07, 0x1711cd39,
		0x33303139, 0x23372707, 0x17372111, 0x23153303, 0x01153307, 0x820e8233, 0xf6270803, 0x561d4022, 0x3f152401, 0x49503965, 0x7be1febe, 0x491bbb40,
		0x58116964, 0x113d6b02, 0xdb46d0fe, 0xbe670146, 0x82db21fe, 0x045708c3, 0xb5ff2600, 0x2502c901, 0x2f002500, 0x38003400, 0x3d406f00, 0x0d343306,
		0x1c061b0e, 0x38371e05, 0x06032726, 0x0505041d, 0x15098230, 0x2f3a0915, 0x1c218235, 0x39211d1d, 0x3486380d, 0x37002626, 0x110e1414, 0x181b1e88,
		0x2a273351, 0x00030689, 0x323f0050, 0x4932ed32, 0xc38709b0, 0x1020c189, 0xc083dc82, 0xc8821120, 0x01303124, 0x9f491632, 0x14152505, 0x07230714,
		0x4b0a9f49, 0x172a0a09, 0x23262237, 0x07020e22, 0x15823433, 0x31820720, 0x0803012f, 0x3818080f, 0x01393517, 0x220f2ebc, 0x06387a13, 0x28175208,
		0x18371812, 0x3e273536, 0x022a084f, 0x30200206, 0xf9021321, 0xa6241918, 0x01252c03, 0x4c0101db, 0x6c174813, 0x070f0558, 0x0e03058f, 0x12084408,
		0x134a0505, 0x466d1f4d, 0x1e3c5c3e, 0x160183c8, 0x26193025, 0x3f72113b, 0x0073244f, 0x00010000, 0x06e74236, 0x001b2b08, 0x0e234041, 0x000e0b18,
		0x17181a4c, 0x06030573, 0x0f00001d, 0x7917061c, 0x011a1a03, 0x7c131010, 0x791b460c, 0x3f004101, 0xa3593fed, 0x5c332005, 0x3221089d, 0x051077cd,
		0x21351326, 0x23153311, 0x20077e4e, 0x42ec8437, 0x640805a0, 0x471c017f, 0x4d2d1347, 0x12513b3a, 0x283e1221, 0x7d7d3c3e, 0xfe462502, 0x2c5a43f9,
		0x2221394e, 0x200e4310, 0x43525144, 0x020000c1, 0x56ff4700, 0x9e02cd01, 0x27000b00, 0x29404e00, 0x26030309, 0x0f117f23, 0x24242912, 0x281b0c0c,
		0x0f862312, 0x26102600, 0x26260802, 0x1f1c1c0e, 0x06521888, 0x0e852700, 0x219b8249, 0x9d86cdde, 0x875d5e21, 0x2f322c9f, 0xcd32de10, 0x2f3232ed,
		0x183031cd, 0x210b5640, 0x6f5b3507, 0x505b1805, 0x3527080d, 0x35333523, 0x261a3401, 0x251b1a26, 0x0e01dd25, 0x2d1b4d4d, 0x4d26213b, 0x3d191922,
		0xbc34281c, 0x241802bc, 0x83241f1f, 0x458d3203, 0x30d13fbb, 0x10122a43, 0x110c4611, 0x3fd23b29, 0x08bf8376, 0x59ff1d20, 0x79020002, 0x30002200,
		0x00b9a800, 0xb3e8ff2f, 0x2f4d000e, 0x40f8ffb8, 0x4d000d13, 0x0d82182d, 0x82102d21, 0x10282109, 0x25210982, 0x05975bb8, 0xe8220782, 0x15820e40,
		0x0f18202f, 0x18204d00, 0x1c4d0008, 0xb3e0ffb8, 0x27078412, 0x110fb4e8, 0xb8074c00, 0x0f224b82, 0x07824d00, 0x2940f022, 0x03202182, 0x03202b83,
		0x1a382b83, 0x0a12762b, 0x00762332, 0x48100b40, 0x7c0e3100, 0x261b3115, 0x2e461e7c, 0x07756918, 0xdc103222, 0x2007d659, 0x0d4644cc, 0x00832b20,
		0x59341321, 0x112206af, 0xbb481614, 0x3535210a, 0x2005034a, 0x21158337, 0xe247023e, 0x1d290805, 0x2d4b351e, 0x1e364b2e, 0x1405160f, 0x1c080805,
		0x182b230b, 0x2d430b08, 0x1e354b2d, 0x1f3c3954, 0x3d0f1f2e, 0x01393c3e, 0x07ed7436, 0xbbfe3008, 0x02022b29, 0x15050241, 0x3d293f2a, 0x50262a20,
		0x827a537a, 0x44603c1c, 0x0082827a, 0x28000200, 0xf20159ff, 0x2000da01, 0x76002f00, 0x822e00b9, 0x000e21f8, 0x28054259, 0x244d000d, 0x40f0ffb8,
		0x2d108241, 0x100f100b, 0x100b4c00, 0x4c000908, 0x0b832005, 0x0a100527, 0x18054d00, 0x08048209, 0x00082021, 0x7f20294d, 0x21311118, 0x09400882,
		0x3008480c, 0x4b1b8914, 0x500d882d, 0x00882629, 0x6e005103, 0x0b59059e, 0x0d074108, 0x410ea978, 0x27210e07, 0x055b5214, 0x26113e08, 0x06222326,
		0x350e4901, 0x31472c20, 0x4e371f1a, 0x1b513430, 0x14061a14, 0x1e080806, 0x1b2e250b, 0x1c0dcc0a, 0x321c1e2b, 0x20230b0d, 0x0a124738, 0x59402413,
		0x3f5a3835, 0xfe081122, 0x0a064130, 0x24e72808, 0x161a2d3d, 0x0425010d, 0x00005906, 0x12000200, 0xd7010000, 0x1e007102, 0x95002d00, 0x0f1827b5,
		0xb81e4d00, 0x49b3d0ff, 0xf82205ce, 0x0f840ab3, 0x82b3e821, 0x261782eb, 0x080940e0, 0x83024d00, 0xb8012525, 0x3440e8ff, 0x63182682, 0x2d0808ba,
		0x0e0e0308, 0x08081300, 0x2f007629, 0x18731323, 0x01140016, 0x0e2e1408, 0x23791503, 0x1f141818, 0x14411c7c, 0x44080944, 0x3f333f00, 0x8945ed3f,
		0x46322005, 0xed230a69, 0x82112f33, 0x07115115, 0x852b0121, 0xc6631800, 0x23352910, 0x36113335, 0x16323336, 0x0dc96318, 0x3cb83c08, 0x26250f32,
		0x0e5d0f24, 0x0f212121, 0x35031806, 0x1f404052, 0x71702046, 0x0a1817db, 0x29392424, 0x31251616, 0x5739ae01, 0x453e1818, 0x46222249, 0x01143841,
		0x0144f4f4, 0x1807082a, 0x080dcd63, 0x21000126, 0xae010000, 0x1500da01, 0x17402f00, 0x1113170a, 0x02047f14, 0x01141601, 0x04041186, 0x07880e00,
		0x004c0050, 0x654ec688, 0x8333200b, 0x8335209f, 0x172a089e, 0x23262607, 0x33150722, 0x63152315, 0x68664242, 0x0f233b1f, 0x3e1d3120, 0xb7a6a63e,
		0x0523c13f, 0x05094908, 0xb73f8b11, 0x67820200, 0xdf010026, 0x1b006b02, 0x3a087982, 0x1c384069, 0x110a1c11, 0x141a1278, 0x151a1212, 0x731a1215,
		0x0a0a1c01, 0x14010978, 0x06010909, 0x01010906, 0x12112223, 0x171f2041, 0x0d0e1404, 0x031c1a01, 0x090a0707, 0x82440041, 0x39332f92, 0x3339172f,
		0x32cd3333, 0x333f3232, 0x4e5d1101, 0x3d941805, 0x75fd2008, 0x5918053b, 0x232f0ae1, 0x27263335, 0x17161633, 0x37363633, 0x82070633, 0x060624ae,
		0x82031507, 0x233a080d, 0x361ed216, 0x21344b18, 0x1b0b5d19, 0x1a0fa710, 0x1f1b5a0d, 0x35174c34, 0x1e11281d, 0xe61e7c0e, 0x40305e31, 0x42234541,
		0x23412221, 0x2f404145, 0x01e8315d, 0x1e3b1f2d, 0xd382003c, 0xff2a4e08, 0x01dd0158, 0x002700d0, 0x40a3002e, 0x1e1b1955, 0x16211821, 0x28292b14,
		0x17281721, 0x14211881, 0x13211818, 0x2810282c, 0x0f06090c, 0x10281006, 0x14060f81, 0x28060f0f, 0x1c1c0f28, 0x27273018, 0x2f0f0b0b, 0x091e2b2c,
		0x0c13141b, 0x34168221, 0x0c2f0c1f, 0x0f0c0c02, 0x4b248803, 0x10491817, 0x3f00490f, 0x28018233, 0x2f3911ed, 0x3311395d, 0x84028233, 0x10012df8,
		0x322f32c6, 0x32ce102f, 0x1939112f, 0x2307027f, 0x10c4c487, 0x87200382, 0x200b8453, 0x3312820e, 0x0ec4c405, 0x173031c4, 0x32331616, 0x26263736,
		0x33352327, 0x13410582, 0x07144109, 0x08054d52, 0x36363770, 0x16162337, 0x0e200a39, 0x1c163732, 0x435a1735, 0x580d1d11, 0x8d111b0a, 0x540c170b,
		0x3c0e180c, 0x172b144f, 0x134a5923, 0x0cea082d, 0x0d650b15, 0x0605571c, 0x7334312b, 0x5c2e3c3c, 0x325e272d, 0x2f325a2b, 0x3f3c2d5b, 0x4a503676,
		0x22f0040a, 0x44232243, 0x01000000, 0x5bff2c00, 0xd001af01, 0x82002800, 0x10241040, 0x204d000f, 0x04821020, 0x09821820, 0x79181520, 0x112007ca,
		0xe022088a, 0x1f822f40, 0x090e0523, 0x06504e0e, 0x22090925, 0x822a1382, 0x0008374b, 0x061b1b00, 0x00892829, 0x1c070e0e, 0x18881f1c, 0x8505094b,
		0x58184907, 0x32290f7e, 0x5e2f322f, 0xedde105d, 0x088d5433, 0x20067b43, 0x053f4e37, 0x030e1522, 0x21082a66, 0x62472726, 0x344a0806, 0x2323022e,
		0x2a2c139a, 0x01f40c25, 0x2c250c5b, 0x4226162f, 0x3e211c32, 0x53313456, 0x49141216, 0x1e4c492a, 0x0f223f32, 0x363716c4, 0x30451232, 0x3a3a3514,
		0x29170519, 0x49302c3d, 0x0b101830, 0x41100a46, 0x192c233a, 0xab820009, 0x82002b08, 0x72012102, 0x15009d02, 0x05b71500, 0x00101106, 0x0011050b,
		0xcddc332f, 0xdecd2f01, 0x133031cd, 0x07021e32, 0x23032e23, 0x07820e22, 0x023e2632, 0x212c19fa, 0x01360112, 0x13190e06, 0x060f1813, 0x12340a82,
		0x9d022c21, 0x1d2e2011, 0x0c13170a, 0x0a17130c, 0x11202e1d, 0x0ee7cd18, 0x0f402431, 0x00050704, 0x01024003, 0x04000506, 0x82060280, 0xcd1a2365,
		0x6b820132, 0x07823220, 0x32cd1029, 0x17013031, 0x82272707, 0x29012503, 0x616e2b67, 0x02250382, 0x7d208fb5, 0x82038232, 0x00033dab, 0x010102a7,
		0x002d034d, 0x000f0003, 0xb94f001b, 0xe0ff0f00, 0x11081140, 0x200b4c00, 0x09210583, 0x25058328, 0xd8ffb805, 0x09831740, 0x1610042b, 0x02800040,
		0x00160a02, 0x273a8203, 0x0719130d, 0xdedd2f00, 0x20068173, 0x2207822f, 0x5b1acd1a, 0x2b2807a8, 0x37270701, 0x23061417, 0x2007135d, 0x0a546607,
		0x8d4d012e, 0x32198713, 0x30302321, 0x28322123, 0x34074573, 0x3135eb02, 0x2d26d946, 0x2c26262d, 0x1714262c, 0x18151417, 0x82aa8218, 0x02702aa1,
		0x0284010c, 0x000b00cc, 0x08ab8217, 0x12402722, 0x92151a1a, 0x1b1b090f, 0x18099203, 0x9206121b, 0x2f00000c, 0xde32fd32, 0xed2f01cd, 0xde102f32,
		0x43180482, 0x4a611d61, 0x0c022112, 0x07a94618, 0xc0250787, 0x00020039, 0x207b8289, 0x2e7b846b, 0x401a000f, 0x0f0f0e0b, 0x0c039209, 0x8292060f,
		0x84fd2072, 0x2f332270, 0x236c8dcd, 0x23153327, 0x820ae35d, 0x06cb5d58, 0xd0825082, 0x6b000322, 0x89225382, 0xcf86fb02, 0x0b40662a, 0x0011181b,
		0x10101b4d, 0x21055d50, 0x078514b3, 0x822d4021, 0x18240815, 0x19701a1b, 0x19b019a0, 0x15191903, 0x010f7f92, 0x4092030f, 0x09010970, 0x1980181b,
		0x1a2f1a1f, 0x1a031a3f, 0x33070241, 0x71dc32ed, 0x32cd1a32, 0x1a5d2f01, 0xed5ddeed, 0x335d2f33, 0x6207557c, 0x172b1873, 0x149b2707, 0x15141c1c,
		0x82a91c1c, 0x82152003, 0x55a2230b, 0x0f416328, 0x7eef2311, 0xbf937122, 0x1900b926, 0x3e40f0ff, 0x1821bd83, 0x20ba8215, 0x83bf8310, 0x191831d1,
		0x011b6f1a, 0x1b9f1b7f, 0x1bbf1baf, 0x091b1b04, 0x092ac188, 0x1b801819, 0x1f1a401a, 0xbd8a1a48, 0x2b2f3323, 0x84be8433, 0x821120bd, 0xb47120be,
		0x364423bf, 0xbf922863, 0x22712f22, 0xe630bf8a, 0x17000b00, 0x3a001d00, 0x1a1c1c40, 0x1d1d6018, 0x0f2d9d82, 0x1b099203, 0x1a181c19, 0x1d011d1f,
		0x0956411d, 0x712f3333, 0xcd32ddcd, 0xed2f0132, 0x3912edde, 0xcd1a2f19, 0x0ef54133, 0xff5f3320, 0x1737240b, 0x41071737, 0xe2200f55, 0x4205476d,
		0xb22f1067, 0x28363628, 0x00020055, 0x010b0271, 0x82cc0284, 0x21220893, 0x0c404900, 0x000e1812, 0x0c20124d, 0x034c000d, 0x40e8ffb8, 0x4d000c19,
		0x2110001d, 0x1f100e21, 0xb762011f, 0x2f00220b, 0x09b16233, 0x0c820120, 0x82cd2f21, 0x60dc2010, 0x012005a6, 0x201c9562, 0x207b6201, 0x625c0221,
		0x5e321463, 0x00000039, 0x029c0001, 0x034501c7, 0x0003003e, 0xc282b511, 0x01020329, 0xddcd2f00, 0x822f01cd, 0x07012d7c, 0x45013727, 0x02901396,
		0x463136fd, 0x00272e82, 0x028c0001, 0x826801c1, 0x0005322f, 0x050e4023, 0x03006001, 0x03040501, 0x02800040, 0x2cc58204, 0xcd1add1a, 0x0132cd10,
		0x1a332f19, 0x324182cd, 0x27071713, 0x6efa2707, 0x1a54541a, 0x28553e03, 0x8c283737, 0x40212643, 0x0004050d, 0x253b8260, 0x80010340, 0x7b820502,
		0x32dd1a23, 0x8241841a, 0x31332940, 0x17371330, 0x8c071737, 0x6e204083, 0x2609af6e, 0x02500003, 0x84a40191, 0x000f27b7, 0x402c001b, 0xba820013,
		0x13190127, 0x0a160d07, 0x218e8304, 0x90831002, 0x1a2f3324, 0x91831acd, 0xdccd2f28, 0x332f33cd, 0x528232cd, 0xed419483, 0x0bf9410a, 0x2846e22c,
		0x1c152b54, 0x1c14151c, 0x0382de1c, 0x1d141429, 0x6b3e031d, 0x447f5f22, 0x00200f5d, 0x343c838f, 0x00031740, 0x19070d00, 0x13020201, 0x10160a19,
		0x80030040, 0x04010102, 0x332f0010, 0xd5827a82, 0x0c828986, 0x8d841020, 0x01303126, 0x17372707, 0x21208b8a, 0x01250b8a, 0x4828564a, 0x06da435f,
		0x82f9fe21, 0x82142089, 0x1003250c, 0xad6b225f, 0x00208d90, 0x17438f8a, 0x3c240805, 0x0f151a40, 0x40031d0f, 0x1a1c0909, 0x1c1d6018, 0x191b4018,
		0x1d1d1a80, 0x000c0612, 0xcd322f00, 0xcd2f3332, 0x270a6d41, 0x1833cd33, 0x11cd1a2f, 0x43100f45, 0x81201119, 0xde208b86, 0xe2279c86, 0x1a39391a,
		0x8f910253, 0x28852795, 0x42282323, 0x47770000, 0x023e3308, 0x00280026, 0x00070100, 0x000e0043, 0xb9130089, 0x16190100, 0x1a201b9f, 0x83252f88,
		0x8b001200, 0x05237700, 0x0d40f92e, 0x0a00200e, 0x18010250, 0x0c01014f, 0x3606e864, 0xff120001, 0x02cc01fe, 0x0024006b, 0x171f4079, 0x4d001220,
		0x82102017, 0x0f182604, 0x28124d00, 0x21048212, 0x04821018, 0x0e822020, 0xb8042e08, 0x2d40e8ff, 0x4c000a09, 0x76142323, 0x0f1c2605, 0x020d1f0d,
		0x73240d0d, 0x08011f00, 0x2425201f, 0x1c21791f, 0x02007c19, 0x1e412102, 0xaa901844, 0x393f3207, 0x32ed332f, 0x0132ed10, 0x5eddd610, 0x2f32ed5d,
		0x05d76e5d, 0x21080b57, 0x09553613, 0xe9451806, 0x0914620a, 0x35234c08, 0xb9231521, 0x63582b2d, 0x2b3f2a15, 0x030b1b0d, 0x310d0f05, 0x291e1133,
		0x15271318, 0x65015552, 0x0d7801be, 0x45275d6c, 0x02011e34, 0x46010141, 0x20332634, 0xfe06070d, 0x462502cd, 0x00ffff46, 0x01000036, 0x023e03cc,
		0x82c60226, 0x00072509, 0x0047008f, 0x2805c77d, 0x080a0c44, 0x01015002, 0x06047c0b, 0x26000136, 0xcc01f3ff, 0x26007902, 0x0c40d900, 0x0e0d1025,
		0x181f4c00, 0x18053756, 0x5d081b43, 0x1a21054d, 0x05774eb8, 0x2c581120, 0x24078206, 0x0011b3e0, 0x2207824d, 0x840cb3d8, 0xb3e02207, 0x2207840b,
		0x840ab3e8, 0xb3f02507, 0x104d0009, 0x10232f83, 0x86094d00, 0x20078237, 0x823783e8, 0xb4e02607, 0x4c000c0b, 0x82188602, 0x82188407, 0x40e02207,
		0x3c31821f, 0x03030e0e, 0x0f0c2818, 0x0e272276, 0x000d0d79, 0x7c121717, 0x0404461d, 0x45007c07, 0x05407400, 0x112f3224, 0x4d6c2f39, 0x0864410b,
		0x24085a5d, 0x32012b2b, 0x05e24c16, 0x07020e27, 0x16231533, 0x5c611816, 0x0144080f, 0x12553d27, 0x31461115, 0x192d412b, 0x07e5e404, 0x28135560,
		0x15081d24, 0x36291b07, 0x45603921, 0x5e442426, 0x0b1d7902, 0x1f180940, 0x462f4e37, 0x0b077867, 0x0542060c, 0x2b090e0d, 0x4e4e7852, 0x002b5278,
		0x0a577118, 0x40d80033, 0x0e182c0b, 0x102c4d00, 0x274d000d, 0xb3e8ffb8, 0x2207840a, 0x4f09b3f0, 0xb32005b0, 0x2005b84f, 0x201783d0, 0x23ff8323,
		0x1b4d000f, 0xba572783, 0xb3e02405, 0x184d0012, 0x200a8b42, 0x4fa518f0, 0x55b42007, 0xe821064b, 0x255d82b3, 0xe0ffb813, 0x08823e40, 0x0e100b2d,
		0x0b4c000f, 0x000a0920, 0x8210024c, 0x28012142, 0x152c3f82, 0x26760315, 0x1c2e2e33, 0x100d0076, 0x82e76419, 0x14194208, 0x422d2b47, 0x1a2c2113,
		0x192e3f26, 0x3a21666e, 0x1809222d, 0x303a4f14, 0x1f291d30, 0x1e0c0a17, 0x51253628, 0x0e0a075b, 0x190c4607, 0x241a2d2d, 0x100b161b, 0x2b3c2c20,
		0x0e095751, 0x0b46060e, 0x055f461f, 0x005a2308, 0x029b0100, 0x000b006b, 0x0815402b, 0x020b0605, 0x06067301, 0x07000d0c, 0x01410979, 0x44047906,
		0x905a3f00, 0x12112605, 0xcdfd2f39, 0x052c4b32, 0x33112008, 0x33352115, 0x21352311, 0x78230115, 0x7777bffe, 0x25024101, 0x464621fe, 0x4646df01,
		0x8400ffff, 0x1a032557, 0xb9022602, 0x07226182, 0x6e828300, 0x17008b32, 0x01021040, 0x04200e00, 0x09025002, 0x09014f18, 0x54074c44, 0xa4200823,
		0x13318b82, 0x17404a00, 0x100f1810, 0x180a4c00, 0x0a4d000e, 0x828f8220, 0x000b3a0a, 0xffb8054d, 0x111640f0, 0x124c0012, 0x00150373, 0x0c140b00,
		0x087c0f0c, 0x368d1846, 0x2f322208, 0x05826101, 0x2307385a, 0x11213513, 0x350d7953, 0x25017f11, 0x3c4f2f13, 0x2113523c, 0x402a3f13, 0x4625023f,
		0x1e545cfe, 0x5601210a, 0x00278e82, 0xff090002, 0x82de01f7, 0x001c278f, 0xb9560028, 0x7a820100, 0x0b0c3108, 0x254c000d, 0x0b0a7319, 0xb8181873,
		0x1f40c0ff, 0x0a480c09, 0x11180a18, 0x2a037620, 0x7c232911, 0x0b1d0000, 0x11411879, 0x1d46107c, 0x0046067c, 0x6f055463, 0xc63d05a7, 0x11edde10,
		0x2f2f3939, 0x10ed102b, 0x303132ed, 0x1632012b, 0x23061415, 0x11272622, 0x08a58223, 0x3e27075a, 0x15333505, 0x32133636, 0x26343536, 0x15072223,
		0x51011616, 0x4d494845, 0x441a3017, 0x363b1b05, 0x121b1409, 0xd801040a, 0x23061008, 0x0d22251f, 0x0110080c, 0x5f61648c, 0x0208086f, 0x7acca01c,
		0x06490e3a, 0x774c2f18, 0x01e173a8, 0x3cb3fe01, 0x03403f4c, 0x000203ff, 0x2d22cf82, 0xcf84f9ff, 0x00162708, 0xb94f0023, 0xe8ff0200, 0x000d2840,
		0x7321144d, 0x0d090911, 0x2503761a, 0x0d730c10, 0x1d411224, 0x790b007c, 0x01820010, 0x410e0d25, 0x8617440d, 0x123f21c7, 0xba83bb83, 0x10013f25,
		0x8432edd6, 0x332f21cd, 0x1122c890, 0x28581123, 0x8dc78905, 0x497124c8, 0x864a7149, 0x0d0622c0, 0x21c18206, 0xc1845f87, 0xfe2c0128, 0xf06b02cb,
		0xba82e6f0, 0xba82b820, 0xfb023b22, 0x0034ba83, 0x00120001, 0x02bf0100, 0x0019006b, 0x1400b96b, 0x0cb3e8ff, 0xb824b882, 0x0bb3f0ff, 0xe8200784,
		0x28060659, 0x092c40e0, 0x18024d00, 0x08048212, 0x0011282b, 0x1873194d, 0x08010d0f, 0x1b180d0d, 0x09730e06, 0x44191a0a, 0x12127c03, 0x79090e08,
		0x4408410b, 0xed3f3f00, 0x2f391232, 0x20d083ed, 0x25d182dd, 0x5e2f32ce, 0x3b42105d, 0x252b2307, 0x5e682634, 0x35232506, 0x15231521, 0x08065c68,
		0x0123152f, 0x1a33286c, 0x55520b33, 0x0ebe6501, 0x3f301d38, 0xa7530f25, 0x040a4653, 0x2502cefe, 0x05ae4646, 0x53381c09, 0x0000a737, 0x00ffff00,
		0x26bb8240, 0x023e03eb, 0x822e0026, 0x00072209, 0x4713828f, 0xe82a068b, 0x17190940, 0x01500810, 0x46461800, 0x181b8206, 0x21087b42, 0x2f84cb02,
		0x04004322, 0x28067346, 0x00131500, 0x01015009, 0x822c8514, 0xff092a2b, 0x03ee01f8, 0x02260223, 0x212b83d6, 0x72829003, 0xe7478b20, 0x40fe2a05,
		0x0b312909, 0x0b015015, 0xbff01826, 0x31290809, 0xc6015bff, 0x0b006b02, 0x16402c00, 0x09097306, 0x0573020a, 0x0a73010d, 0x410b030c, 0x79010608,
		0x3f00440a, 0x3fce33ed, 0x09066633, 0x3031ed25, 0x82331113, 0x15233701, 0x11233523, 0xa453f083, 0x6b02a34e, 0x2502dbfd, 0xa5a595fd, 0xd3596b02,
		0x2400210b, 0x362af384, 0xc301fbff, 0x06026b02, 0x0f8adb01, 0x06027124, 0xa1822500, 0x57470120, 0x33878205, 0x40250009, 0x060b0312, 0x00730506,
		0x00050a09, 0x04440879, 0x8208fe57, 0xd5240882, 0x102f32ed, 0x373031ce, 0x23152111, 0x21153311, 0x3d018f35, 0xcffe86eb, 0x46250246, 0x464621fe,
		0x12000200, 0xd920d382, 0x22084b82, 0x00190010, 0x11144065, 0x730b0a73, 0x010a0019, 0x0a190a08, 0x73100419, 0xb8171b0d, 0x11b4d8ff, 0x824c0012,
		0xb3e82408, 0x824d0010, 0x40f02307, 0x08820f16, 0x0004043a, 0x111a0373, 0x17410a79, 0x0f79040c, 0x00440001, 0xed32cd3f, 0xed3f3232, 0xed277e82,
		0x2b332f33, 0x43102b2b, 0x5e3106b7, 0x10ed105d, 0x333031ed, 0x33352315, 0x3737033e, 0x08928221, 0x03352334, 0x07030e07, 0x4e601133, 0x11242324,
		0x01030305, 0xa44e2719, 0x0f060202, 0xa5cb1b1e, 0x796d30eb, 0xfd434884, 0x02a5ebdb, 0x6c324325, 0x012d666b, 0xa34900df, 0x6b022f08, 0x28000602,
		0x01000000, 0x00000400, 0xc782f101, 0x002d4e08, 0x1b4c408a, 0x10210027, 0x27210221, 0x2678272c, 0x26261421, 0x732c1821, 0x0c120601, 0x78121512,
		0x11140c11, 0x01150c11, 0x1c1c0701, 0x2601269f, 0x0711112f, 0x4427262e, 0x18411b1c, 0x2c0c1515, 0x0c210101, 0x1241160c, 0x06074111, 0x21d18344,
		0x0182333f, 0x22052c53, 0x83113311, 0x01332c0c, 0x2f33c610, 0x325dce10, 0x1839112f, 0x250848cc, 0x10183311, 0x8e5532ed, 0x5d012305, 0xea823311,
		0xdb821120, 0xeb822320, 0x27032e26, 0x17161633, 0x36233e82, 0x82333736, 0x031e2314, 0x14822317, 0xd5116c08, 0x1c202314, 0x220c520c, 0x12152b28,
		0x12232322, 0x1f391d52, 0x1d3a1e4a, 0x22241252, 0x2b151222, 0x530c2229, 0x24201c0c, 0x182d0113, 0x28565146, 0x4e585e2b, 0x4542221b, 0x854d2c4c,
		0xfe0b0139, 0x4c8439f7, 0x42454c2c, 0x584e1b22, 0x55282b5e, 0xfe184651, 0x000100d4, 0x01f4ff26, 0x007602d1, 0x40b90034, 0x10183015, 0x832c4d00,
		0x20252f04, 0x254d000e, 0x4d000d10, 0xd0ffb81f, 0x078412b3, 0x11b3d822, 0xe0220784, 0xfd4708b3, 0x07ee4105, 0x2083e020, 0x0e481720, 0x42132006,
		0x08820707, 0x3640e030, 0x4c000a08, 0x1211200e, 0x10044c00, 0x0582100f, 0x0e182308, 0x06184d00, 0x2e151576, 0x34361d76, 0x270d0d34, 0x79341835,
		0x28100000, 0x227c2b28, 0x090c0c46, 0x2e49107c, 0x1fbc7e0d, 0x32331322, 0x2107cd58, 0x3e442707, 0x18142006, 0x23074668, 0x022e2223, 0x080c5b53,
		0x1e218d84, 0x43223540, 0x144f3036, 0x3860171b, 0x1e364b2c, 0x311b3637, 0x3f221626, 0x3b223658, 0x190a2431, 0x48395415, 0x49362056, 0x6a012a29,
		0x20291809, 0x0b153329, 0x13160f41, 0x2b293d27, 0x1a07114c, 0x32243628, 0x0a142c45, 0x42050f0e, 0x3e351d0b, 0x0a1a2f24, 0x37000100, 0xbd010000,
		0x11006b02, 0x2f404c00, 0x08490829, 0x01080a02, 0x11251105, 0x0c110802, 0x08037811, 0x08030314, 0x1309730c, 0xee827303, 0x0002002e, 0x44110312,
		0x080c440b, 0x00410241, 0x09275c18, 0xde10ed23, 0x071d42ed, 0x5d5d3108, 0x11333031, 0x033e1133, 0x23113337, 0x07030e11, 0x301e4b37, 0x54293d33,
		0x38351c4b, 0x6b02223c, 0x6f4924fe, 0xfd4b7069, 0x35ee0195, 0x53877669, 0x2208db44, 0x44260223, 0xaf4405db, 0x40102c06, 0x1500010b, 0x5009001d,
		0x44120101, 0x402008db, 0xeb27b382, 0x06026b02, 0x82002e00, 0x0d00250a, 0xc701f7ff, 0x1529c382, 0x0cb55a00, 0x4d000d10, 0x06ed4a06, 0x82074a7f,
		0x05185f07, 0x18820520, 0x121c403c, 0x73004d00, 0x08011100, 0x14091111, 0x09171373, 0x00441416, 0x09411179, 0x9747087c, 0x10012106, 0x22059247,
		0x455d5e2f, 0x132307f3, 0x82070606, 0x362727ca, 0x033e3736, 0xd8822135, 0x03ee2a08, 0x1e0b160c, 0x0926392b, 0x0a14302c, 0x0103070d, 0x25025229,
		0x2851b466, 0x021f3446, 0x45410748, 0x766c5e24, 0x0295fd3b, 0x82a68225, 0x822020e3, 0x84d420ac, 0x003024b7, 0x7effff00, 0x0f8405f3, 0x0f842b20,
		0xf3ff1d26, 0x7902d801, 0x3220d782, 0x2d20d784, 0xd7832f82, 0x20000731, 0x73001040, 0x73030907, 0x79020804, 0x43044105, 0x894405bb, 0xde102105,
		0x8f83a282, 0x21112335, 0xf6750111, 0x029a0152, 0x02dbfd25, 0xff95fd6b, 0x844900ff, 0x82712043, 0x84332053, 0x4c2e2063, 0x0f82058b, 0x0f842620,
		0x1f822720, 0x8384cd20, 0x73843720, 0xff095408, 0x02ee01f8, 0x0025006b, 0x1d00b974, 0x0eb3f0ff, 0xb81b4d00, 0x3b40f0ff, 0x034d0008, 0x4d000d18,
		0x1411141a, 0x141a1578, 0x061a1515, 0x000a0910, 0x110c064c, 0x060b780c, 0x060b0b14, 0x27150b11, 0x260b2222, 0x0606111a, 0x1f7c000b, 0x41141546,
		0x57410b0c, 0x12240698, 0x33331139, 0x22058649, 0x423911ce, 0x2b20062e, 0x68068157, 0x372d055c, 0x37023e32, 0x27032e37, 0x17031e33, 0x054f4436,
		0x08057751, 0x16163749, 0x1d241871, 0x25080b17, 0x11323d46, 0x2f290f5a, 0x40251833, 0x2714591b, 0x12142727, 0x31473326, 0x0f082d14, 0x0d3f200b,
		0x0e132016, 0x6d7a7f3a, 0x635c2628, 0xb9592e63, 0x636c3f64, 0x4e2a305d, 0x0509243c, 0x82080546, 0x000322e7, 0x34f7822a, 0x009302d4, 0x001c0015,
		0x40970021, 0x0d102111, 0x1e4c000e, 0x21ef8218, 0xe682101e, 0xe821f482, 0x241283b4, 0xe8ffb818, 0x821582b3, 0x40f02207, 0x2119821b, 0x0482181d,
		0x0e062029, 0x11031973, 0x831d0011, 0x761d2431, 0x82162309, 0x26402127, 0x28083183, 0x001f7616, 0x50004001, 0xc0007000, 0x0500d000, 0x0001002f,
		0x7c192022, 0x4410110e, 0x067c1a1f, 0x2f000403, 0x32ed32dd, 0x2b04833f, 0x5dd61001, 0x2bed715d, 0x2bedd610, 0x6507aa6f, 0x132608d2, 0x35373634,
		0x60781533, 0x075c0805, 0x2e352315, 0x16143703, 0x06061117, 0x11273405, 0x50612a36, 0x19614f49, 0x4927412f, 0x192f4128, 0x32322d52, 0x5e06012d,
		0x764c015e, 0x4a4a0b7c, 0x3b767c0b, 0x06243f5a, 0x24064e4e, 0x523b5a3f, 0x72010b5c, 0xa0515d0b, 0x1790fe18, 0x00ffff00, 0x01000019, 0x026b02db,
		0x003b0006, 0x00210a82, 0x062f472d, 0x28000b3f, 0x73031440, 0x07730a06, 0x0b73020d, 0x7902060c, 0x04440b09, 0x3f004100, 0xedce3f32, 0x2ab28232,
		0xedde10ed, 0x3031edd5, 0x84113313, 0x289a8201, 0xe1522d21, 0xfe4e2752, 0x060148a2, 0xa5ebdb23, 0x05cf4700, 0x6b02bf30, 0x4d001700, 0x30131040,
		0x134d000a, 0x04820918, 0x18082821, 0x3c0d0582, 0x00111740, 0x730c084d, 0x7300190b, 0x7c051815, 0x160c1010, 0x09440c41, 0x3f3f0041, 0x05254b3f,
		0x7483d620, 0x7c4e3220, 0x5d132006, 0x3322070e, 0x225e2311, 0x35280806, 0x0b893335, 0x2024301c, 0x52520e3b, 0x3c23420f, 0x53102b4c, 0x3926b801,
		0x040a1226, 0x95fd3c01, 0x1f0905e8, 0xb333523a, 0x0482eb84, 0x9782c720, 0x2e000b2c, 0x73061740, 0x070b0303, 0xed870a73, 0x08440b23, 0x20ee8504,
		0x0573672f, 0x11227a84, 0xf18a2f39, 0x2128f782, 0x4b5d4b2d, 0x66fe4b5c, 0x0127f183, 0x02c6fe3a, 0x8295fd25, 0x074741f3, 0x41000f24, 0x5b832540,
		0x73070f3a, 0x0a5f0a4f, 0x0abf0aaf, 0x730e0a04, 0x7302110b, 0x060a100f, 0x0f0d7902, 0xce21698b, 0x05d06ced, 0xedde1025, 0x90ed5dd5, 0x1533236e,
		0x72823523, 0x524b5223, 0x0766414b, 0xdb2b7486, 0x0000a5eb, 0xff120002, 0x82cc01f9, 0x00132ed3, 0x40800024, 0x0f20231f, 0x18224d00, 0x25048210,
		0x4d000e10, 0x09823017, 0x82201721, 0x28162109, 0x12211882, 0x05314fb8, 0xf02a0782, 0x4d0009b3, 0xd8ffb802, 0x078412b3, 0x11b3e022, 0xf03c0784,
		0x0a091b40, 0x76144c00, 0x0c1c2600, 0x250a0973, 0x0f0f7c19, 0x0c790920, 0x057c2041, 0x41052945, 0xdd220699, 0xb48232ed, 0x200c1750, 0x065c4d25,
		0x3523112a, 0x33361533, 0x07021e32, 0x50077f51, 0x4608051c, 0x3a22cc01, 0x421f2e4f, 0x19b05e22, 0x394f3019, 0x26145420, 0x14092134, 0x0c180d0a,
		0x1424311c, 0x2f4d38c2, 0x02080815, 0x03e2461c, 0x364d3017, 0x0d1e3326, 0xfefe0101, 0x1e0d0102, 0x00000032, 0xff240003, 0x82d001fa, 0x000e30ef,
		0x0021001d, 0x1c2a4045, 0x00121110, 0x8318124c, 0x0f250805, 0x01000f76, 0x73210008, 0x18092320, 0x21220673, 0x14411e44, 0x070c0c7c, 0x037c1b41,
		0xed3f0043, 0xed2f393f, 0x07b04c3f, 0x45defd21, 0x252006e9, 0x8206754d, 0x20b482b3, 0x20b38716, 0x08b38315, 0x3313363b, 0x47012311, 0x411a535b,
		0x140b4e1a, 0x515a520a, 0x1c26160a, 0x0c0a1008, 0x29300a15, 0xc24e4e8c, 0x08076464, 0x02e36202, 0x1e636702, 0x02132330, 0x0203fe02, 0xfdeb0141,
		0x05674d95, 0xcc01fa22, 0x1f32af84, 0x1b405800, 0x100f301d, 0x181d4c00, 0x124d000e, 0x04821040, 0x820f3021, 0x2d0e8304, 0xe0ffb80e, 0x4d0008b3,
		0xe8ffb801, 0x08821640, 0x00760f23, 0x20c58321, 0x4dc19020, 0x7b410770, 0x22c08a08, 0x86323332, 0x072222c0, 0x07744111, 0x25808339, 0x11522552,
		0x80881222, 0x44301b54, 0x11201128, 0x211c260f, 0x821c2e3d, 0x090634bc, 0x02e16202, 0x33266664, 0xfe020d1f, 0x0d0102fd, 0x8200321f, 0x00013b00,
		0x01f3ff2e, 0x007902d5, 0x40a50026, 0x12282554, 0x20254d00, 0x4c001110, 0x0a82181e, 0x09821e20, 0x201e4d33, 0x1e4d000d, 0x000c0b18, 0x1008174c,
		0x10164d00, 0x21048212, 0x04821118, 0x19823820, 0x28830d20, 0x28830d20, 0x10200d2c, 0x180d4d00, 0x4c000f0e, 0x19821807, 0x82100321, 0x83022004,
		0x0e1f3cea, 0x181b4d00, 0x24280576, 0x0f191924, 0x1a791927, 0x1010001a, 0x460a7c15, 0x52202323, 0xc6261190, 0x2f322f32, 0x4c62de10, 0x2b2b2212,
		0xf0431813, 0x022e2308, 0x0e6b3727, 0x234f0805, 0x032e3335, 0x07062223, 0xd4363627, 0x25435f3a, 0x39604527, 0x1c293521, 0x1d081507, 0x55132824,
		0xe5e60761, 0x412d1a04, 0x1146312b, 0x02551215, 0x79522979, 0x5179504f, 0x0d0e0929, 0x0c064205, 0x6c73070b, 0x374e2f46, 0x4009181f, 0x41001d0b,
		0xf33205d3, 0x7902d901, 0x2c001800, 0x10b68600, 0x00121128, 0x4a430c4c, 0x21078206, 0xff82b3e0, 0x0f860620, 0xe0220782, 0x10821b40, 0x83200321,
		0x6d022026, 0x092a0564, 0x76234d00, 0x76192e09, 0x38501301, 0x00133b07, 0x2d167315, 0x000f7914, 0x0002001f, 0x41171600, 0x7c1e4416, 0x7c28460e,
		0x38504504, 0x123f2d05, 0xed5d2f39, 0xfdd61001, 0x322bde32, 0x0d099f18, 0x76331321, 0xfe820beb, 0x23112324, 0x30453311, 0x3e210805, 0x2e343502,
		0x0e222302, 0x053d7b02, 0x36243f4a, 0x26141326, 0x34222237, 0x3c011424, 0x088b4e4e, 0x2e891810, 0x9266350e, 0x7b4e2481, 0x4e7a5756, 0x72482224,
		0x02e0fe51, 0x37cbfe6b, 0x0f288918, 0x00022108, 0x01000039, 0x007102ca, 0x002b001c, 0x1f00b996, 0x6240f8ff, 0x094d000e, 0x00100f30, 0x0a10094c,
		0x18300a82, 0x4c000908, 0x00101007, 0x0f18074d, 0x38064d00, 0x06211482, 0x27fe8230, 0x00083806, 0x1210044d, 0x37080482, 0x4d001108, 0x0500051c,
		0x141c1778, 0x17171c17, 0x11731228, 0x2200002d, 0x01080076, 0x172c0808, 0x28791305, 0x44120b28, 0x410b7c1d, 0x0044001c, 0xed3f323f, 0x2f39123f,
		0x26053945, 0x33ed5d5e, 0x82de102f, 0xfc75180c, 0x336d0813, 0x2637033e, 0x36343526, 0x021e3233, 0x35231117, 0x27222223, 0x1307030e, 0x15020e22,
		0x33021e14, 0x26263533, 0x24240f39, 0x3c340f23, 0x28106f72, 0x520f2729, 0x07140347, 0x2222210e, 0x311b9c0f, 0x29161625, 0x0a36233a, 0x444a242a,
		0x5619173c, 0x0262613a, 0xfd040603, 0x1501f39e, 0x21444139, 0x1d0c2b02, 0x2e262430, 0x02ef091a, 0x9b4f1803, 0xdb012307, 0xa8820602, 0x34052b42,
		0x02cc01f4, 0x002200b5, 0x40a10035, 0x0f183015, 0x10304d00, 0x2e59180e, 0x6d26200b, 0x2120072e, 0x402c0882, 0x4d000913, 0x000a0813, 0x10180d4d,
		0x08270483, 0xb8094d00, 0x82b3c0ff, 0x4408200c, 0x05240622, 0xb3d8ffb8, 0x04201782, 0x17820783, 0x40210783, 0x3c37821e, 0x1b06822d, 0x0037061b,
		0x36108235, 0x00893235, 0x1b280303, 0x284d1a88, 0x00510b88, 0xd82c193f, 0x32ed250b, 0x2f32ce10, 0x2009db50, 0x2000862b, 0x0acb7513, 0x35022e33,
		0x37023e34, 0x1737033e, 0x0607030e, 0x1e140706, 0x0bc97502, 0x1a867f08, 0x64632144, 0x36503319, 0x122e4f3e, 0x50653a15, 0x161c2319, 0x0e06090c,
		0x561f2718, 0x1b0a0f5c, 0x3021252f, 0x1e0c0f1e, 0x3f242632, 0x169b0112, 0x2f6d7a18, 0x2f274256, 0x4e3c6b50, 0x0c436685, 0x03040504, 0x03024803,
		0x0b030503, 0x4c2aec59, 0x2e1b223b, 0x3b1e223d, 0x17231c2d, 0x00030000, 0x01f8ff47, 0x00dc01c3, 0x001b000e, 0xb9800032, 0xe8ff3000, 0x000b0ab4,
		0xffb8304c, 0xef82b3e0, 0xe8260782, 0x4d0008b3, 0x1882b826, 0x000d0c23, 0x2208824c, 0x840bb3f0, 0x40e02810, 0x4d000a2d, 0x82121006, 0x08220804,
		0x2b4d0011, 0x28288212, 0x342e8208, 0x007f001b, 0x1f08011f, 0x860e2b33, 0x17031b1b, 0x03502388, 0x20411c88, 0x39ed2708, 0x5ed61001, 0x4718ed5d,
		0x37201133, 0x27054e45, 0x022e3435, 0x32372323, 0x0829a718, 0x22131524, 0x48182726, 0x4c18086f, 0x7008077f, 0x1a340a98, 0x15232f1a, 0x192c2013,
		0x3f305661, 0x162c2315, 0x550e2815, 0x1a1a5636, 0x46243656, 0x1d222136, 0x3a212e26, 0x03023f4e, 0x171e1207, 0x07121e16, 0x15291d3d, 0x02040e19,
		0xe6fe8301, 0xc401060a, 0x1e0c0a06, 0x2f232632, 0x30330e0e, 0x0e21382a, 0x6b000100, 0xb8010000, 0x0500d001, 0x0c401a00, 0x7f050703, 0x85040600,
		0x4a004901, 0x0f4a1800, 0x31ce3a07, 0x21113330, 0x6b112315, 0x01fb4d01, 0x75fe45d0, 0x00020000, 0x017fff1b, 0x083782d0, 0x17000f46, 0x00b94d00,
		0xb3f8ff15, 0x154d0009, 0x40e8ffb8, 0x4d000822, 0x06068212, 0x087f1001, 0x19097f0c, 0x0d018217, 0x0b18007f, 0x0108170e, 0x124a0d85, 0x00490685,
		0xed3fed3f, 0x32cd3232, 0xedd61001, 0xde10edd5, 0xab480482, 0x2b2b2505, 0x033e3337, 0x8206fb50, 0x252e0875, 0x0e142311, 0x241b0702, 0x0611221e,
		0x27120101, 0x4ee7fe4e, 0x08713c01, 0x46172013, 0x69615a2b, 0xc776fe3b, 0x01c78181, 0x56592845, 0x537f1f4f, 0x01c72708, 0x000602db, 0xde820048,
		0x82070021, 0x82eb2004, 0x314f08ab, 0x5f40a800, 0x0b100b00, 0x060b0b02, 0x81111611, 0x10140b10, 0x050b0b10, 0x06810500, 0x0606140b, 0x2924240b,
		0x811e191e, 0x1f14241f, 0x2a24241f, 0x29812a2f, 0x29291424, 0x16002f24, 0x1f19197f, 0x33100606, 0x321f2929, 0x242f2f00, 0x82191916, 0x30182f2e,
		0x492a2949, 0x184a1e1f, 0x4a11104a, 0xd9820506, 0x333f3323, 0x2602823f, 0x39123f33, 0x4a333311, 0xb04c05da, 0x2f322106, 0x3221e483, 0x05b64c33,
		0x10188726, 0x7d08872b, 0x8708c477, 0x5d01260f, 0x3e013031, 0x0b075103, 0x35231522, 0x080a2951, 0x17031e62, 0x1e013335, 0x1a1b1c0c, 0x2310530a,
		0x15102424, 0x0e252a2c, 0x211e0a52, 0x10490f23, 0x0a1e2123, 0x2a260e52, 0x2410152b, 0x520f2324, 0x1c1c1a0a, 0x0d01490c, 0x32343315, 0x3a391a15,
		0x3b141637, 0x1a1f4642, 0x1434393a, 0x3414d6d5, 0x1f1a3b39, 0x143b4246, 0x3a3a3716, 0x35331519, 0x00c51533, 0x01350082, 0xf5ff4800, 0xdc01bf01,
		0x8b002c00, 0x281f0b40, 0x1f4d0012, 0x05485a20, 0x6f08405a, 0xe02a0772, 0x4d0008b3, 0xe8ffb806, 0x07840cb3, 0x0bb3c822, 0xe0300784, 0x000a2840,
		0x82260d4d, 0x821d0808, 0x21212e10, 0x163b5882, 0x2d160801, 0x2286210d, 0x17170322, 0x5113881a, 0x88292c2c, 0x3f005003, 0x6a2f32ed, 0xed2606f9,
		0xc6100139, 0x9b475d5e, 0x18332006, 0x200c7cad, 0x09994613, 0xa2180720, 0x36240d9a, 0x23263435, 0x0b42e218, 0x21564508, 0x4626274f, 0x160e2036,
		0x33260c19, 0x573c6171, 0x4e0f1112, 0x3c3c4237, 0x335c6233, 0x1c3c3832, 0xc4011a49, 0x200d0d0b, 0x20122633, 0x0e04121a, 0x49433035, 0x05460812,
		0x24202613, 0x1d22422a, 0x0c0e241f, 0x3f08b282, 0x003f0001, 0x01b60100, 0x001100d0, 0x24314050, 0x11490108, 0x11791159, 0x01113803, 0x1101112b,
		0x84080308, 0x0c14110c, 0x7f03110c, 0x7f0c1300, 0x08010900, 0x11031209, 0x0c490b49, 0x4a024a08, 0x2109e550, 0xe6505d5e, 0x315d230d, 0xe0500130,
		0x50232005, 0x013905ee, 0x3b1b51b6, 0x4a15363b, 0x3a361750, 0xd0011c3a, 0x620130fe, 0x5e615c22, 0x280a8225, 0x5b5b27b2, 0xff001e53, 0x258f85ff,
		0x26029802, 0x9982eb02, 0x90030622, 0x1030a682, 0x0b010b40, 0x00091d15, 0x12000150, 0x342b2b4f, 0x47202782, 0xde261d82, 0x0602d001, 0xc7841501,
		0xf7ff0d24, 0xc782ad01, 0x5200152b, 0x180c1240, 0x4c00100f, 0x2405850b, 0x4d000b20, 0x07c35207, 0xe03a0882, 0x0d0c1940, 0x7f004c00, 0x14091111,
		0x0917137f, 0x004a1416, 0x09491185, 0xdc440885, 0x503f2005, 0xdf5008e1, 0x0e142f08, 0x06060702, 0x36362707, 0x34023e37, 0xd9822135, 0x03eb2408,
		0x140a0c07, 0x2c0c4c52, 0x0d0d0f33, 0x53120106, 0x431e8b01, 0x391c4143, 0x08460852, 0x4c1e2331, 0x82255454, 0x828b20e3, 0x0100279e, 0x00001b00,
		0x9f82d901, 0x00244f08, 0x5a4b407c, 0x02106a10, 0x103b102b, 0x1003104b, 0x841f1a1f, 0x0d14100d, 0x64171a10, 0x0a52010a, 0x440a3401, 0x0a23020a,
		0x00200a01, 0x0a0d8420, 0x0a0d0d14, 0x8217030d, 0x00261611, 0x04098203, 0x49101a25, 0x1f490a00, 0x1720200d, 0xb76f4a04, 0x069c5405, 0xed32d627,
		0x32de1032, 0x084050ed, 0x00825d20, 0x8733112d, 0x7d872b18, 0x5d5d01c4, 0x82133031, 0x3e2327c5, 0x16333703, 0xcc821716, 0x1e334308, 0x26231703,
		0x030e2726, 0x032e2307, 0x03010877, 0x09070150, 0x134d060b, 0x35292834, 0x0b064c14, 0x50020609, 0x0d070303, 0x0f161315, 0x13160e52, 0x5b560115,
		0x76374ead, 0x30357678, 0x90646490, 0x0a823530, 0xb44e372c, 0x38351f54, 0x3f2a2a3f, 0xef853538, 0x00004724, 0xef82ad01, 0x000b2308, 0x09204039,
		0x0d007f01, 0x007f0408, 0x0c050105, 0x8503490a, 0x081f080f, 0x08080802, 0x05490605, 0xc482014a, 0x123f3f2b, 0x5d5e2f39, 0x10013fed, 0x055346d6,
		0x30313233, 0x23352321, 0x33112315, 0x33353315, 0xc053ad01, 0x25028253, 0xd001cdcd, 0x6382bdbd, 0x079b4218, 0x02db0125, 0x82520006, 0x00012110,
		0x07247387, 0x14402600, 0x09207282, 0x08247184, 0x85030805, 0xed206789, 0x2205b646, 0x83edde10, 0x23112160, 0x21200182, 0x01255c84, 0xfe8b0166,
		0x2bb28275, 0xffff0000, 0x5bff4700, 0xda01cc01, 0x53205b82, 0x31240f84, 0xc301f5ff, 0x46206b84, 0x3a206b84, 0xba20df82, 0x6b832c82, 0x03011332,
		0x0400067f, 0x04040801, 0x05020809, 0x04490785, 0xed22d283, 0xd3780132, 0xfdce2505, 0x013031ce, 0x6c82c982, 0xba013528, 0x01975297, 0x6a8245d0,
		0x82458b21, 0xffff264a, 0x58ff2400, 0x82d68201, 0x825c206b, 0x00032210, 0x2d7b821a, 0x00b502da, 0x000d0006, 0xb99a0027, 0x1e771f00, 0xb81f2b05,
		0x1a40f8ff, 0x0c4d0011, 0x04821020, 0x0f0e2828, 0x28084c00, 0x0582100f, 0x000e2028, 0xffb8054d, 0x1882b3d0, 0xe0210782, 0x241b83b4, 0xd8ffb802,
		0x821e83b4, 0x40d02208, 0x08228229, 0x00820a2b, 0x22080122, 0x7f27071d, 0x15820010, 0x1010031a, 0x1c1b2829, 0x88040d4d, 0x07491a1d, 0x10278803,
		0x004b0f4c, 0xed333f3f, 0x84038532, 0x333328c2, 0xfd10eddd, 0x53dd3232, 0x2b2009f2, 0x6f510083, 0x17300806, 0x34353636, 0x23112726, 0x35032e35,
		0x37023e34, 0x1e153735, 0x0e141503, 0x3d6c0702, 0xb23d2c2c, 0x2c3e3e2c, 0x34432649, 0x43341e1e, 0x44264926, 0x442d0883, 0x554ee826, 0x024a0102,
		0x5502f355, 0x2f0a824e, 0x01a2cefd, 0x37573c20, 0x203c5737, 0xe20ed401, 0x002f0c89, 0x1d00ffff, 0xd8010000, 0x0602d001, 0x82005b00, 0x4700210a,
		0x3f06a747, 0x402e000b, 0x007f0918, 0x0d017f04, 0x05007f08, 0x0c050801, 0x0049060a, 0x05038508, 0xce3f004a, 0x0122c783, 0x9e44de10, 0xedd52905,
		0x33253031, 0x21352315, 0x3006be46, 0xfe4e27a9, 0x52bd53c5, 0x0181c746, 0x0176fed0, 0x0867598a, 0x01ad2c08, 0x001700d0, 0x1424403b, 0x000b0a20,
		0x0918144c, 0x20144d00, 0x074d0008, 0x190a7f0b, 0x18167f01, 0x11118804, 0x0b49170b, 0x5149084a, 0x39081487, 0x16141513, 0x37363233, 0x23113335,
		0x23030e35, 0x35022e22, 0x32398835, 0x53133024, 0x1f190753, 0x42281022, 0xd0011a2f, 0x072a3588, 0x30fedb05, 0x050502b3, 0x3f261104, 0x8351892e,
		0xd0013e08, 0x30000b00, 0x7f071840, 0x08000404, 0x030d0b7f, 0x090c007f, 0x01050501, 0x85030749, 0x83df8200, 0x112f21de, 0x470d775a, 0xe284069b,
		0x84058551, 0xfe1f2adb, 0xfe8a01e1, 0x00010030, 0x08e3482d, 0x40412608, 0x0b7f0e25, 0x7f0f070b, 0x025f024f, 0x02bf02af, 0x7f060204, 0x7f0a1103,
		0x0c0c1007, 0x0e490800, 0x05850a02, 0x05484107, 0x333f3224, 0xdf522f33, 0x07835107, 0x6d820120, 0x82095041, 0x4b5e2989, 0xabfe4e27, 0x4e4b4d4b,
		0x57417583, 0x277b8206, 0x12000200, 0xd001f6ff, 0x1433d382, 0x5b002500, 0xff0e00b9, 0x000bb3e8, 0xffb80e4d, 0x840ab3d0, 0xb3e82607, 0x0a4d0009,
		0x06bd4ab8, 0xe0220882, 0x11821a40, 0x0c821824, 0xfa822027, 0x1d26012a, 0x03070789, 0x51118915, 0x084b1519, 0x7e611120, 0x0c645105, 0x35231322,
		0x2905a250, 0x1415021e, 0x2223020e, 0x864a2726, 0x1e3f080b, 0xad5b6d03, 0x24193a0e, 0x1b1c3040, 0x2b2b4732, 0x30a92752, 0x251c1036, 0x112f1715,
		0x1a181405, 0xb1458b01, 0x24110703, 0x3b2a283a, 0x0b091126, 0x162e2930, 0x030a1520, 0x02019f05, 0x82000101, 0x00032200, 0x20cb822d, 0x29cb82c7,
		0x001d000c, 0xb9530021, 0xcd821800, 0x294a0d20, 0x0eb32105, 0xf0220784, 0x10822140, 0x820a2208, 0x0801170f, 0x1e7f1f17, 0x7f040f23, 0x4a1f221d,
		0x12128900, 0x1a89070d, 0x490d2051, 0x3f333f00, 0x20c383ed, 0x06ac503f, 0x24086c51, 0x0622372b, 0x055a5107, 0x26343523, 0x20d08927, 0x08cf8306,
		0x11230520, 0x1d10b433, 0x0d22080c, 0xa12e2921, 0x14250b4e, 0x1727331c, 0x3f234557, 0x4e9a0121, 0xac82e64e, 0x29030226, 0xea282d2e, 0x5424ca86,
		0x0a0b0948, 0x0023b082, 0x82470002, 0x82cc20bb, 0x000e270a, 0xb962001f, 0x1d7d1a00, 0xb81a2a05, 0x09b4d8ff, 0x174c000a, 0x821085b8, 0xb3d82407,
		0x824d000a, 0xe8250807, 0x00092140, 0x1120064d, 0x18054d00, 0x034d0012, 0x11211982, 0x201f7f0c, 0x14148908, 0x1c89000f, 0x00490f51, 0x51c9853f,
		0x7b411075, 0x1616220b, 0x3ac98e03, 0x13403afe, 0x1a192d21, 0x3d0c1337, 0x4010539c, 0x3648281d, 0x2f60731f, 0x413a2c57, 0x02230876, 0x8a960103,
		0x000036c6, 0xff3b0001, 0x01cc01f5, 0x002400db, 0x17304050, 0x4d000e28, 0x2104840e, 0x09820d20, 0x000c103f, 0x8211144d, 0x1d1d2600, 0x25081212,
		0x88191c1c, 0x13861220, 0x09502013, 0x05880c09, 0x05924951, 0xed2f3924, 0xfb60ed10, 0x0b2b5106, 0x4c079d53, 0x372006c7, 0x080b1a51, 0x1e323343,
		0x23cc0102, 0x33395d41, 0x140c1351, 0x3d242649, 0xd5031c2e, 0x2c1c04d3, 0x3527223a, 0x4618131d, 0x425c3832, 0x5b3aea24, 0x090f213f, 0x140c0945,
		0x43213625, 0x1322311e, 0x08470b0a, 0x5a3e220d, 0x22008200, 0x82360002, 0x82d920bf, 0x001a24bf, 0x42870026, 0x0b21053d, 0x05007c00, 0x9d5f0a20,
		0x4c402705, 0x4c000b0a, 0x1682180e, 0x82280e21, 0x10032613, 0x4c000d0c, 0x210f8303, 0x0f821003, 0x82212c08, 0x821b2816, 0x3005200c, 0x03054005,
		0x7f070b05, 0x08010820, 0x11882427, 0x0f850650, 0x020b1f0b, 0x080b0b08, 0x4a084909, 0x8300881e, 0x086347f2, 0x1001ed28, 0x32fd5dd6, 0x1c515dde,
		0x2205240e, 0x4727022e, 0xfd790671, 0x14272309, 0x59613316, 0x01063c06, 0x262f1950, 0x4e41031a, 0x1a03404e, 0x1a182f26, 0x17182732, 0x1a573127,
		0x831a2222, 0x140b3c03, 0xc43c4f30, 0x3dc7d001, 0x17143051, 0x47475e37, 0xf317375e, 0x54595954, 0x84585855, 0x282008f7, 0xad010000, 0x1a00dc01,
		0x7f002500, 0xff2000b9, 0x114d40e8, 0x114c0012, 0x4d000b10, 0x0a092811, 0x20240a82, 0x0d4d0008, 0x0d220f83, 0x0f820838, 0x03060c3c, 0x0c078106,
		0x0c070714, 0x250f0303, 0x27187f19, 0x82210707, 0x08010f00, 0x1282260f, 0x25861a30, 0x4a191425, 0x5014851e, 0x004a0607, 0xf650333f, 0x732f2007,
		0xf7500535, 0x39112106, 0x230fb66f, 0x27262225, 0x18060f49, 0x2909f542, 0x35352311, 0x22232626, 0xf7821506, 0x01333e08, 0x0b190e14, 0x5415341d,
		0x1e1e1c0b, 0x1d23320e, 0x3b2a4734, 0x0a531c50, 0x3e331e2b, 0xb4513340, 0x612b0101, 0x33371a2a, 0x4312122f, 0x273a2726, 0xfe080a14, 0x02dfb436,
		0x2d2d2a03, 0xcb5f1822, 0x43003111, 0x10000001, 0x00020b40, 0x02132325, 0x24000250, 0x3b06cf4a, 0x01f5ff28, 0x028f02c7, 0x00480026, 0x00060100,
		0x00000d83, 0x03104017, 0x36240f02, 0x03262882, 0x024f2e00, 0x2c822200, 0x34342b22, 0x003a2082, 0x0159ff14, 0x00b502b0, 0x408b002b, 0x1218230b,
		0x10234d00, 0x134d0010, 0xfb47ffb8, 0x22088205, 0x450db3e8, 0x11200655, 0x34080784, 0x083740e0, 0x0f4c000a, 0x02191f19, 0x20281919, 0x072d117f,
		0x7f280406, 0x2900012b, 0x292c2901, 0x16891d4a, 0x042a074b, 0x24030101, 0x100b0088, 0x030b200b, 0x071e1908, 0x05a44912, 0xfdce322b, 0x1033cc32,
		0x3911edde, 0xff85182f, 0x33132508, 0x33153735, 0x6409f461, 0x1a620f45, 0x42142d09, 0x13a2a252, 0x43311631, 0x1e0b1228, 0x0a0e5518, 0x17372d35,
		0x42520a31, 0x0e456202, 0x085b3e53, 0x4e381f09, 0x18fafe2f, 0x2c0a1155, 0x47560301, 0x7ffe050b, 0xff002402, 0x05e74fff, 0xb5023c08, 0xe6022602,
		0x06010000, 0x00368f00, 0x0b401000, 0x06082201, 0x01500200, 0x2b4f0701, 0x0100342b, 0xf5ff3100, 0xdb01c201, 0x58002400, 0xff1700b9, 0x000eb3c0,
		0xffb8174d, 0x840db3d8, 0xb3e82507, 0x0e4d000c, 0x403d0f82, 0x4d000e1d, 0x261d0808, 0x00821411, 0x12861325, 0x1c1c0512, 0x51208819, 0x880c0909,
		0x0dcc4d05, 0x08015318, 0x24056056, 0x023e3437, 0x0dea6733, 0x20055b55, 0x05a67717, 0x24313d08, 0x32385c42, 0x1d131846, 0x3a222735, 0xd3041c2c,
		0x2e1c03d5, 0x4926243d, 0x51130c14, 0x415d3933, 0x5a37ea23, 0x080d223e, 0x130a0b47, 0x431e3122, 0x14253621, 0x0945090c, 0x5b3f210f, 0x4220eb82,
		0xb227c382, 0x0602db01, 0x83005600, 0x823620fb, 0x02c2220f, 0x200f829e, 0x2c0f8a4c, 0x0126028f, 0x0100000c, 0xdc830006, 0x068d6a00, 0x0d40da2e,
		0x0b012a18, 0x22020250, 0x1602014f, 0x0a036018, 0x56ff4724, 0x43848001, 0x00004d37, 0x0d000200, 0xde01f6ff, 0x1d00d001, 0x77002900, 0xff1700b9,
		0x0b2141e0, 0x38071a46, 0xe8ffb814, 0x100b1140, 0x0f234c00, 0x7f01007f, 0xb00ea00e, 0xb80e020e, 0x05dc65ff, 0x000e003e, 0x821e080e, 0x2a082b15,
		0x12128921, 0x1a88270e, 0x0e850151, 0x07880849, 0xed3f0051, 0x11230183, 0x4ded2f39, 0x39240767, 0x5d2b2f2f, 0x2507dd65, 0x132b2b2b, 0xd7651523,
		0x35032105, 0x20051f59, 0x08c64716, 0x23263423, 0x06154722, 0x44f04108, 0x343b1d07, 0x10231f0c, 0x1a16d604, 0x25143e37, 0x32171f33, 0x2019a11a,
		0x0e08140b, 0x011a2107, 0x8253228b, 0x4607385e, 0x76502b07, 0x07ae4952, 0x3b2b4552, 0x08081125, 0x052d268b, 0x270101a1, 0x3620ef83, 0x1727ef86,
		0x67002200, 0x471100b9, 0xc98205c5, 0x0fb4f022, 0x0882de82, 0x40e82008, 0x000e0d2c, 0x7f1e0a4c, 0x03171707, 0x240f8218, 0x107f0206, 0x23030103,
		0x010c891b, 0x820c0686, 0x20042c01, 0x08511488, 0x03490449, 0x823f004a, 0x11ed2200, 0x83d48239, 0x08cf4cd2, 0x0a8e8418, 0xd54c3720, 0x36152108,
		0x860b896b, 0x32332adc, 0x4971f036, 0x17497149, 0x2bd58d19, 0x1a210d10, 0xd001d3d3, 0x08afbbbb, 0xa021cb8b, 0x2fca8203, 0x1400ffff, 0xb0010000,
		0x0602b502, 0x00000201, 0x8207234f, 0x0126220f, 0x23198215, 0x228f0006, 0x28051b43, 0x0d17190d, 0x0e015005, 0x067b4418, 0x1d823f20, 0x2783b620,
		0x2205734f, 0x85044300, 0x15002827, 0x50000913, 0x86140001, 0xff242a27, 0x02cd0158, 0x00260298, 0x059b4f5c, 0x27851220, 0x2c241328, 0x01501520,
		0x6b432109, 0xff472206, 0x06fb4d7f, 0x40322308, 0x0a7f071a, 0x7f030b0a, 0x7f020d06, 0x08010b00, 0x07090c0b, 0x4a0b8502, 0x00490004, 0xed3f323f,
		0x8f4dce33, 0x0cd45b08, 0x23152336, 0x53472335, 0x4e8c53c0, 0xfed0018c, 0xfe8a0176, 0x00818130, 0x02390082, 0xf4ff2700, 0xb502cc01, 0x3c001100,
		0x37b5b300, 0x4d000818, 0xe8ffb833, 0x3a0782b3, 0xc8ffb82d, 0x4d0009b3, 0xd8ffb82b, 0x4d0010b3, 0xe0ffb829, 0x000f3340, 0x8318164d, 0x0e202104,
		0x0d200983, 0x28210482, 0x2104820c, 0x04820b20, 0x0a092826, 0x18134c00, 0x10211482, 0x26318220, 0x100f180a, 0x82064c00, 0x83b4204f, 0x83012008,
		0x82222040, 0x00123f17, 0x30820d15, 0x3e301e1e, 0x15158226, 0x3d3a8203, 0x1212002b, 0x35880818, 0x18882151, 0xd442004d, 0x33112205, 0x05016533,
		0x3856ed20, 0x18112005, 0x231381b4, 0x15060613, 0x2f0a2456, 0x35262627, 0x32333634, 0x37363632, 0x23060617, 0x20067257, 0x05424d17, 0x2e222323,
		0x081e8202, 0x4440ff65, 0x23301e0e, 0x0f1f3020, 0x562b2316, 0x4e5a2a22, 0x181b2318, 0x430e050e, 0x1d1f0c2c, 0x20170c13, 0x31402414, 0x5032171d,
		0x3350363a, 0x98015319, 0x21436112, 0x191b2e3c, 0x29213b2c, 0x361f2c3b, 0x3f223c18, 0x0201013a, 0x01010247, 0x0e121209, 0x0e151414, 0x4f3d3118,
		0x41522a36, 0x56402628, 0x41735430, 0x2008055f, 0x01fbff12, 0x009302d5, 0x00260015, 0x1e2a4098, 0x00100f30, 0x12381d4c, 0x201d4d00, 0x194d0011,
		0x20098228, 0x21098419, 0x0e821018, 0x000f202e, 0x1220184d, 0xb8084d00, 0x0ab3e8ff, 0xd8250784, 0x4d0009b3, 0x820f8605, 0x40e02207, 0x39108225,
		0x2807761b, 0x00131521, 0x0e0d1073, 0x790d0027, 0x21101310, 0x01000179, 0x01821001, 0x7c161131, 0x3f004309, 0x39392fed, 0x105d2f2f, 0x6e3311ed,
		0x322406c3, 0x33cd32fd, 0x340f425d, 0x3315132b, 0x15021e32, 0x26222314, 0x35231127, 0x15333533, 0x7bbf1833, 0x1e3a080b, 0x34bd3202, 0x1d395638,
		0x204822e0, 0xa7525959, 0x25331f6c, 0x37261414, 0x0f0c3124, 0x04020c0c, 0x4a2d1485, 0x0906c435, 0x4946fa01, 0x3cfe4649, 0x24301d0d, 0x0c1c3125,
		0xe34b02f8, 0x05af4c05, 0xb502cc33, 0x27001800, 0x00b96300, 0xb4e0ff11, 0x4c000a09, 0x21d6820e, 0x09833040, 0x821c2f08, 0x06222910, 0x017f0704,
		0x07281817, 0x04018617, 0x0b891f01, 0x011f010f, 0x014f013f, 0x0b010804, 0x19030b01, 0x02511389, 0x3f004d03, 0x16443f33, 0x975e2005, 0x0f3d47dc,
		0x85061421, 0x490120dc, 0x2908077e, 0x031e1507, 0x9f525912, 0x193a0e9f, 0x1c2f3f24, 0x522b5766, 0x02015927, 0x2a3c3630, 0x06112f17, 0x011a1814,
		0xe50ed7d0, 0xbe4c6d44, 0x48542b05, 0x82010b09, 0x2e29aefe, 0xbd4c282d, 0x03260808, 0xf3ff1d00, 0x7902d801, 0x24001300, 0xe7003500, 0x102c0b40,
		0x2c4d000e, 0x4d000d08, 0xf0ffb82a, 0x000e0db4, 0x26641c4c, 0x25078206, 0x0011b3f8, 0xf4831b4d, 0x26822d20, 0x83181921, 0x82102004, 0x18192a2b,
		0x194d000c, 0x4d000b10, 0x055b5e18, 0x00081026, 0x1010114d, 0x18240482, 0x0d4d000f, 0xb3203182, 0x07820c82, 0x82b3f021, 0x430c200f, 0x082006a2,
		0x07200786, 0x07821f86, 0x3040e022, 0x03262082, 0x00100f10, 0x4583034c, 0x76172e3e, 0x1d28370a, 0x0b400076, 0x36004810, 0x2e202528, 0x1d141731,
		0x2b052020, 0x1a460f7c, 0x2b07367f, 0x332f3911, 0x32cd32dc, 0x0132cd10, 0x1db2a818, 0x2b2b2b22, 0x3708447f, 0x23020e14, 0x25022e22, 0x26373632,
		0x06222326, 0x33363607, 0x07021e32, 0x16220982, 0x15823316, 0x2805ae47, 0x513b201d, 0x3b513132, 0x21078220, 0x07823231, 0x0e35013e, 0x45030a1a,
		0x04424243, 0x151c260e, 0x84222224, 0x080b2418, 0x443e3d41, 0x121a0c08, 0x23211082, 0x08547f01, 0x7a532408, 0x50262650, 0x0b0e4e7a, 0x6f767870,
		0x19141510, 0x121e0314, 0x6167655f, 0x18140a0a, 0x00000014, 0x4c280003, 0x132d06c3, 0x34002300, 0x00b9a000, 0xb3e0ff2b, 0x06bc4410, 0x07840f20,
		0x1b40f038, 0x294d000e, 0x00100f30, 0x0e18294c, 0x18224d00, 0x4c001211, 0x7d631022, 0x05a54606, 0xffb8122a, 0x080e40e8, 0x100c4d00, 0x08200482,
		0x02250483, 0x40f0ffb8, 0x3f0d8226, 0x00821d27, 0x82172d36, 0x0a2f0a1f, 0x0a030a3f, 0x271f1d35, 0x2d141724, 0x2a1a3030, 0x1a500f88, 0x28050e4d,
		0x3912ed3f, 0x32cd332f, 0x05bb58dc, 0x20088253, 0x4d008a2b, 0x2e2a0517, 0x3e343502, 0x1e323302, 0x30410502, 0x22232409, 0x4137022e, 0x30080e4f,
		0x381fcc01, 0x4d2d2e4e, 0x381f1f38, 0x4e2e2d4d, 0xecfe1f38, 0x08081e13, 0x42343240, 0x15201406, 0x7a202022, 0x08091810, 0x41333341, 0x161d0b07,
		0x08108214, 0x5937e823, 0x40232340, 0x5a373759, 0x3f23233f, 0x0d143a5a, 0x424a463f, 0x0e100e12, 0x3f0a0d0f, 0x0b414a48, 0x080b820e, 0x0001004d,
		0x0100000d, 0x007402fd, 0x4048001b, 0x16171627, 0x0b781713, 0x0b0b140c, 0x1313160c, 0x140d1278, 0x1c120d12, 0x13030b0d, 0x0c164112, 0x0b17440d,
		0x45007c06, 0x32ed3f00, 0x33333f32, 0x2f01333f, 0xd6102f33, 0x107d2b87, 0x181887c4, 0x0807c697, 0x1632014f, 0x23260717, 0x07020e22, 0x032e2303,
		0x12163327, 0x033e1317, 0x2418b301, 0x110f250e, 0x08080907, 0x17627806, 0x192a2829, 0x243f1d59, 0x180e0760, 0x13740224, 0x0610390c, 0xfe181d11,
		0x928a4b20, 0xfe8a62a2, 0xa4017eee, 0x11212f1e, 0x08008200, 0x1e00013e, 0xe9010000, 0x1900dc01, 0x2f405400, 0x0b0a0b00, 0x14001981, 0x0f001919,
		0x19080119, 0x05011b13, 0x0481050a, 0x01041401, 0x0a341a04, 0x0b190a01, 0x50108816, 0x0a490405, 0x004a0100, 0xb483ab84, 0x5d2f0122, 0x8729ae83,
		0x1801c47d, 0x5e32ce10, 0x0e51185d, 0x26232608, 0x1e332726, 0x18a88303, 0x08097a98, 0x4b030160, 0x5a214f2a, 0x1c1b180a, 0x1208530e, 0x111a241a,
		0x0d0e1222, 0x0a14171d, 0x2c83ee5f, 0x245b6163, 0x27181201, 0x06070f1b, 0x1a1c0841, 0x00020000, 0x0157ff37, 0x002303e2, 0x0029001b, 0x104a4080,
		0x0b731611, 0x201f2627, 0x380a0020, 0x082a0108, 0x01080901, 0x1b261b06, 0x181b0802, 0xfa687e1b, 0x73182905, 0x0c08400a, 0x2b0b0a48, 0x08070069,
		0x1b032a2b, 0x0a101144, 0x18441779, 0x20264108, 0x41021c23, 0xddde3f00, 0x333f32ce, 0x19dced3f, 0x333f18c5, 0x5dd61001, 0xddde10ed, 0x0a13692b,
		0x12115d2d, 0xc52f1839, 0xfd10c5d6, 0x69c519de, 0x33320a21, 0x07020e16, 0x37033e27, 0x02061123, 0x26221307, 0xa2433727, 0x17830805, 0x4f370606,
		0x423c330f, 0x0127561e, 0x17291d10, 0x1517093c, 0x4b1a0512, 0x386c2370, 0x083f0846, 0x221d1d22, 0x45083e08, 0x22fe6b02, 0x8283782b, 0x1fdffd36,
		0x173b4042, 0x231c0926, 0xea011427, 0x5500ff95, 0x3339a602, 0x23231d11, 0x3933111d, 0x00020000, 0x016cff3f, 0x009802e3, 0x0029001b, 0x05414076,
		0x027f0b06, 0x201f2627, 0x39130120, 0x1b2b011b, 0x0d121b01, 0x1b168112, 0x1b161614, 0x83017f0d, 0x02012dfb, 0x007f162b, 0x13080113, 0x491b0d2a,
		0x152bf183, 0x4a121649, 0x85010506, 0x87004a0c, 0x060241f3, 0x5e20fa82, 0xf984fb8f, 0xcddecd22, 0x0124f986, 0x06163311, 0x0e23f186, 0x59230703,
		0x2720053b, 0x0139f88c, 0x360227ba, 0x13063a29, 0x22051113, 0x383c3d1b, 0x17504a15, 0x1c3c3b38, 0x2cf98c6a, 0x75fed001, 0x2326743f, 0x231f1806,
		0x0f6a5911, 0xf98b4b20, 0xf347fb83, 0x006b3305, 0x00250016, 0x1f1a4078, 0x4d000f28, 0x0010201e, 0x04841a4d, 0x000e1024, 0x1383194d, 0x47b80821,
		0x2d080605, 0xe8ffb805, 0x0a092940, 0x761c4c00, 0x16222707, 0x11730014, 0x00260f0e, 0x1411790e, 0x01792211, 0x01100100, 0x11011102, 0x17411201,
		0x54640a7c, 0x1fd84705, 0x4607d347, 0xd44706f7, 0x162f0811, 0x383dab16, 0x78203d58, 0x20512271, 0x7a524747, 0x28361f36, 0x3a291717, 0x1b183a24,
		0x1466e501, 0x63354a2d, 0x01090661, 0x464640db, 0x475bfe40, 0x032108d3, 0x067f5401, 0xe801cc36, 0x2d001c00, 0x15409100, 0x00122022, 0x1118224d,
		0x181f4d00, 0x1f210982, 0x20098210, 0x21de8214, 0x80510cb3, 0x0ab42505, 0x104c000b, 0xb422e682, 0x08840c0b, 0x40e03608, 0x4d000a32, 0x2f128220,
		0x07040628, 0x1c1b017f, 0x861b072e, 0x25010401, 0x012f0d89, 0x0002013f, 0x400d100d, 0x040d500d, 0x010d0108, 0x891d020d, 0x00025117, 0x08f6472f,
		0x4517f747, 0x13200563, 0x2105c248, 0x7a511523, 0x05fe4709, 0x425f1320, 0x1e2f080a, 0x52481203, 0x19079e9e, 0x240c1f1e, 0x1d1e3342, 0x2c2b4835,
		0xf948275a, 0x1f133f30, 0x38161528, 0x1b160611, 0x3eaa011d, 0x01513a3e, 0x54020304, 0x012309c4, 0x54cafe66, 0x240810c7, 0x00490002, 0x02c70100,
		0x00150071, 0xb6d50024, 0x12111021, 0xb8214c00, 0x0940f0ff, 0x0a4d0010, 0x4d000e10, 0x210d8207, 0x07860fb3, 0x07840c20, 0x055de820, 0xb3f02106,
		0x06202482, 0x18071142, 0x200a225f, 0x843083e8, 0x000a220f, 0x2107824d, 0x4567b3e8, 0x22941805, 0x31402108, 0x1e2b5182, 0x09091f0a, 0x08200721,
		0x82081f20, 0x231a3f01, 0x1a260576, 0x1000730f, 0x25100801, 0x0e07090a, 0x1e202179, 0x10001a1a, 0x007c1644, 0xd6510041, 0xcc332605, 0xce32fd33,
		0x054b4333, 0xde10322b, 0x393912ed, 0x33112f2f, 0x84078211, 0x0c696704, 0xed642b20, 0x075b0807, 0x06270717, 0x15232306, 0x033e1123, 0x07062217,
		0x32323315, 0x17372737, 0xeb343536, 0x1b375337, 0x443a3f61, 0x48132011, 0x2b2b1252, 0x301a1729, 0x110a440c, 0x33382b08, 0x1c710231, 0x7c2b4633,
		0x77216b31, 0x02e70503, 0x04060462, 0x02014701, 0x224a02fa, 0x7c4f1e5a, 0x5a000200, 0x0029062b, 0x00290016, 0x1d2040b4, 0x30db8238, 0x000e181d,
		0x0d101d4d, 0x10194d00, 0x4c001211, 0x2e0a8319, 0x000f2015, 0xffb8154d, 0x0908b4e8, 0x49144c00, 0x03200600, 0x0c230783, 0x83024d00, 0x860e2007,
		0x310f8507, 0x0b3040e0, 0x28064d00, 0x18052905, 0x17041703, 0x01820429, 0x1b222908, 0x222b0082, 0x0e007f0d, 0x2a0e0801, 0x5012881e, 0x18284b0e,
		0x06882517, 0x51090305, 0xce333f00, 0x33ccfd33, 0xed3f3f33, 0x22272441, 0x41061425, 0x2225061f, 0x23152726, 0x06104911, 0x0805d759, 0x06222354,
		0x16161107, 0x37323233, 0x2ccc0127, 0x34383427, 0x25101e0e, 0x1b530e38, 0x52323755, 0x35af203a, 0x3d4c1114, 0x0e0b2722, 0x0f091d36, 0x42e73609,
		0x20592066, 0x1206055a, 0x6702b70b, 0x3f221008, 0x175d615a, 0x59512946, 0xdbfe0406, 0x5d01160d, 0xcb720100, 0xe1210806, 0x28000b00, 0x73021440,
		0x07080d05, 0x0c0b0073, 0x0a790007, 0x03790644, 0x3f004101, 0xed3fedce, 0x2cc28232, 0x10cdfddd, 0x3031edde, 0x35331137, 0x269d8233, 0x35211533,
		0x724fee8f, 0x762406d0, 0x4621febc, 0x3d05935b, 0x0100006b, 0x004402b8, 0x401f0007, 0x057f020f, 0x007f0709, 0x03850608, 0x4a004901, 0x4f823f00,
		0x2406bc58, 0x11333031, 0x2a4a8421, 0x4b02016b, 0x74d001fb, 0x8875feb9, 0x6b240893, 0x3e001100, 0x13071f40, 0x090e0b0b, 0x0004730d, 0x11020211,
		0x79010c12, 0x05040409, 0x1079000d, 0x05790844, 0x9d839e82, 0x2f391122, 0x086a4b18, 0xfd32dd25, 0x7332cd32, 0x35220578, 0x62823523, 0x15231522,
		0x0382af82, 0x5932af82, 0xeb3d0159, 0xfe868686, 0x43d646cf, 0xc6460c01, 0xb582d643, 0x21000122, 0x0134b383, 0x000d00d0, 0x0717402f, 0x0c090b0f,
		0x0201047f, 0x86010c0e, 0x00236e82, 0x85058508, 0x12ed21bb, 0xd6206986, 0x10216684, 0x83c382ce, 0x21352164, 0x6b2f6486, 0x4d014a4a, 0xb79e9efb,
		0x9545da3f, 0x8200b73f, 0x2d002f56, 0xd0015bff, 0x2b006b02, 0x00b97200, 0xc162ff2a, 0x18142f05, 0x144d000e, 0x4d000d10, 0x0011180f, 0x04850e4d,
		0x0e201382, 0x08086a68, 0x00082227, 0x1120204d, 0x222d0076, 0x0f1d731c, 0x08080108, 0x7c162c1d, 0x211d2727, 0x1d411e79, 0x057c0c44, 0x3fed2f00,
		0x2794833f, 0xc61001ed, 0x105d2f32, 0x43060764, 0x2526097c, 0x23020e14, 0x97182222, 0x22290cac, 0x1107020e, 0x15211123, 0x06e44421, 0xd0014908,
		0x3755391d, 0x020b1a0d, 0x220d0f05, 0x17182a39, 0x0e22392a, 0x06151a1e, 0xfe630152, 0x1e1807ef, 0x573a0e1f, 0x39711c3a, 0x022c4b66, 0x1b010143,
		0x37344f35, 0x0318324e, 0xfe020505, 0x466b02cf, 0x050603b1, 0x66482703, 0x472fef83, 0xcf015aff, 0x2300d001, 0x15407c00, 0x83101814, 0x000f24e7,
		0x8210104d, 0x18102109, 0x02230982, 0x44e0ffb8, 0xd8200689, 0x0808436a, 0x000a2c2e, 0x121d1d4d, 0x1f250382, 0x201a7f19, 0x0b0f010b, 0x0b020b1f,
		0x011a000b, 0x15241a08, 0x1a000089, 0x491b861e, 0x890f4a1a, 0x3f004b08, 0x5e21f78a, 0x91f9825d, 0x320121fa, 0x2009af52, 0x093b5716, 0x83150721,
		0x822320f9, 0x013008f9, 0x18606a05, 0x0a2f4730, 0x05050816, 0x3e39080b, 0x34144642, 0x46015313, 0x1e1907f3, 0x751e011f, 0x3d54306b, 0x42020123,
		0x544d0101, 0x05064755, 0x4421d482, 0x20f2837d, 0x3f008200, 0xff040001, 0x02eb015b, 0x0031006b, 0x0f6e40c1, 0x2100010c, 0x21202110, 0x21210803,
		0x2b302b1c, 0x2d06f974, 0x1b181b21, 0x14211c78, 0x0c211c1c, 0x0075070c, 0x18302909, 0x0c007331, 0x78060106, 0x35055257, 0x00001501, 0x1c1c0726,
		0x732a2626, 0x11113327, 0x26293207, 0x15752b79, 0x01302207, 0x233e8201, 0x12114116, 0x32191575, 0x1001ceed, 0x102f32c6, 0x2f33edde, 0x12112f33,
		0x64332f39, 0x01260609, 0x32ed1018, 0x0e648732, 0x735e2016, 0x0064050c, 0x0f2a750a, 0x15338e08, 0x2e233523, 0xc3112703, 0x181c1e11, 0x1e0a520a,
		0x0e132623, 0x0d1f2020, 0x1a311852, 0x1c361d49, 0x23210e52, 0x21110f23, 0x280c1c20, 0x1b0b184e, 0x0112221f, 0x5147182e, 0x5d2d2856, 0x1e1e4d56,
		0x244d4b46, 0x0139864d, 0x39f4fe0c, 0x4b234e85, 0x191f484b, 0x2248443e, 0x5728a5eb, 0xfe184751, 0x010000d1, 0x7fff0700, 0xd001e001, 0xb6003100,
		0x240f6840, 0x10090001, 0x03092009, 0x090c1108, 0x81030003, 0x04140904, 0x24240904, 0x0937651f, 0x7f160024, 0x51652419, 0xa02f3009, 0x0219b019,
		0x1f0c1919, 0x0c0c0404, 0x650d7f10, 0x39820b4d, 0x270a4d65, 0x850c0f0f, 0x03044a11, 0x2205f95b, 0x653f2f33, 0x4b411552, 0x415d2009, 0x4a410b4b,
		0x1101320e, 0x5d5d5e33, 0x36013031, 0x0e333736, 0x16160703, 0x07324117, 0x65231521, 0x75081159, 0x13341715, 0x23200d53, 0x3e221225, 0x0a4f2918,
		0x201f1b09, 0x200f490f, 0x520a1b1f, 0x2827220c, 0x22230f14, 0x09520b1e, 0x0b1a1918, 0x2b150149, 0x37152967, 0x24193c3a, 0x81c72f5c, 0x33373819,
		0x14dacf14, 0x1b3c3b34, 0x3a424420, 0x3c3a1815, 0x34161538, 0xc9153436, 0x00010000, 0x0157ff26, 0x007602d1, 0xb948014c, 0xf0ff4900, 0x4d0013b3,
		0xe8ffb849, 0x078412b3, 0x11b3d822, 0xe02e0784, 0x4d0008b3, 0xe0ffb845, 0x001211b4, 0x0887414c, 0x85b83d21, 0x20078231, 0x823183e0, 0x40e82807,
		0x000a082f, 0x8210384c, 0x18382140, 0x32213d82, 0x31048228, 0x100f102e, 0x182e4c00, 0x254d000e, 0x4d001018, 0x04822021, 0x0d181a26, 0x054c0011,
		0x15226d83, 0x07824d00, 0x14b3e022, 0xe8230784, 0x841312b4, 0x83e02018, 0x2118827e, 0x3e83b4e8, 0xffb80228, 0x1413b4d8, 0x08824c00, 0x82b4d021,
		0x08088360, 0x0b40d851, 0x424d000f, 0x3f3f7630, 0xb8031147, 0x3340c0ff, 0x03480e0b, 0x0f17004c, 0x0b08010b, 0x231c1414, 0x374e4776, 0x1c292937,
		0x1414004d, 0x4d080f17, 0x7c333636, 0x7929423a, 0x453a2a2a, 0x7c201d1d, 0x0046174c, 0x32ed333f, 0x2f393f2f, 0x821039ed, 0xdc102a08, 0x2f3912cd,
		0xc61001cd, 0x058e6d32, 0xcc290d82, 0xdd335d5e, 0xcd2bd532, 0x0dff6511, 0x850a694f, 0x7217200a, 0x232105da, 0x06f54c22, 0x27343528, 0x37363627,
		0x5345032e, 0x05576905, 0x6a352321, 0x2620056b, 0x2406bb6d, 0x021e3233, 0x082c7715, 0x1afe0723, 0xa96c1817, 0x0c04270d, 0x2b361f06, 0x13770921,
		0x173f770a, 0x4a341c23, 0x576b182e, 0x0d1b2511, 0x0e0d0a01, 0x20092777, 0x16507746, 0x2c412d25, 0x82000318, 0x00013700, 0x0157ff48, 0x00dc01bf,
		0xb9d60045, 0xe0ff4200, 0x4d000bb3, 0x6d5eb842, 0xb8372806, 0x0bb4e8ff, 0x824c000c, 0xb3e02d08, 0x054d000a, 0xb4e0ffb8, 0x4c001413, 0xd8230882,
		0x841211b4, 0x62e82008, 0xb32007d8, 0x2205c645, 0x4110b4d0, 0xb64105bf, 0x2a3e2505, 0x41393982, 0x3c05b641, 0x480e0b35, 0x17004403, 0x0b010b0f,
		0x211a1414, 0x31474182, 0x00252531, 0x1a08011a, 0x05b94146, 0x30304637, 0x3e34882d, 0x26268625, 0x1e1b5034, 0x51174488, 0xed333f00, 0x12b74132,
		0x2308ac67, 0xcc2f3912, 0x4117b841, 0x262016a9, 0x6706b841, 0xd47810bf, 0x020e2108, 0x2105ea67, 0xa8410607, 0x47312213, 0x10d66710, 0xfa671220,
		0x5461220c, 0x11a14107, 0x020d1c23, 0x0eea670f, 0x0b684920, 0x3e51080d, 0x000b0548, 0xff400001, 0x02d9015b, 0x0018006b, 0x03394065, 0x15180603,
		0x03007818, 0x03000014, 0x0306030b, 0x140b1078, 0x000b1010, 0x730a0600, 0x10151a07, 0x01120073, 0x00191208, 0x10154118, 0x13120303, 0x09441241,
		0x440b7906, 0xceed3f00, 0x05146a3f, 0x964b3f20, 0x18c5200a, 0x21076f83, 0xff451887, 0x30312405, 0x44060601, 0x27080ba2, 0x33112311, 0x37363611,
		0x7531d601, 0x2a663544, 0x19164e28, 0x233d3832, 0x77415252, 0x496b022d, 0x872d4890, 0x2ea5eb50, 0x09dec118, 0x3f924322, 0x6b05e747, 0x220805a3,
		0x403c001a, 0x0518181e, 0x1c067f09, 0x117f0f14, 0x1717181b, 0x14000f12, 0x49121114, 0x05084a11, 0x8a4a0a85, 0x3311229c, 0x249e832f, 0xde1032ed,
		0x249c82ed, 0x1e373031, 0x0a2e4503, 0x15331122, 0x332f8b82, 0x13ee0606, 0x15313130, 0x13094e28, 0x183e3d38, 0x36086089, 0x31290fff, 0x81c71a36,
		0x323c411f, 0xd001df11, 0x335f30c2, 0x82006c33, 0x01670800, 0x00003000, 0x6b02eb01, 0x7e001e00, 0x03004640, 0x05050801, 0x1e191e08, 0x14050078,
		0x09050000, 0x78050805, 0x0c14090c, 0x160c1909, 0x0fbf0faf, 0x120f0f02, 0x20080000, 0x12731115, 0x411e001f, 0x100c0e0e, 0x17151915, 0x15150517,
		0x12411312, 0x44090844, 0x3f333f00, 0x2f39123f, 0x112f3333, 0x32cd1033, 0x863f2f32, 0x32ce2ebc, 0x2f39112f, 0x32dd335d, 0x7d872b87, 0x0a5d41c4,
		0x015d5e22, 0x08050346, 0x26262348, 0x35231527, 0x11231123, 0x35331133, 0x033e1533, 0x0bd60137, 0x2131251b, 0x5d2d5530, 0x41264e2c, 0x2b52522b,
		0x1f2a1c41, 0x6b020b19, 0x4d443f21, 0x709e3c30, 0x8925916a, 0x02e2fe87, 0x87f6fe6b, 0x3e452986, 0x134b213c, 0xde480806, 0x2200d001, 0x4b408400,
		0x00100000, 0x08030020, 0x061e0000, 0x0581060b, 0x05051400, 0x181d0000, 0x001e811d, 0x1e001e14, 0x0b18051e, 0xbf0eaf15, 0x0e0e020e, 0x14240511,
		0x23117f0f, 0x0d491d1e, 0x140f0b0d, 0x16161418, 0x20079a41, 0x05a65f05, 0xde84e096, 0x1132cd23, 0x05a87033, 0x012be187, 0x30315d5e, 0x17031e25,
		0x84032e23, 0x681520de, 0xde83061a, 0x0e334108, 0x182d0103, 0x12292d31, 0x22211062, 0x2d3d1324, 0x3d2d5252, 0x191c2115, 0x2214610e, 0x17ff2a25,
		0x2147443c, 0x32373b1c, 0xd6656213, 0x67c1d001, 0x272b1b50, 0x311c1627, 0x00003430, 0x12000100, 0xeb2e0482, 0x1c006b02, 0x45407900, 0x1c060303,
		0x0b431c19, 0x07360806, 0x78030603, 0x0c14070c, 0x0000070c, 0x190c1e06, 0x73181517, 0x0f001012, 0x001d0f01, 0x0c19411c, 0x150f1803, 0x1f120f03,
		0x03122f12, 0x0e121208, 0x440e4113, 0xc2410706, 0x5d5e2308, 0xcd833339, 0x333f332f, 0x5dd61001, 0x32fd33cd, 0x103333cd, 0x181f43ce, 0x1121df83,
		0x08d35823, 0x43152321, 0x60250523, 0x30764040, 0x0521435d, 0x5247472f, 0x63413636, 0x496b0228, 0xad36498f, 0x06234367, 0x40e50129, 0x8e404646,
		0x88409143, 0x01de37d3, 0x001f00e8, 0x00484080, 0x181a0500, 0x001b811a, 0x001b1b14, 0xc5180006, 0x29080907, 0x21051b1b, 0x1416180b, 0x0f117f17,
		0x08010e00, 0x1a1b200e, 0x140e1749, 0x14180b11, 0x02182418, 0x08401118, 0x1111480d, 0x8c18120d, 0x2f2908d4, 0x2b2f3912, 0x33115d39, 0x84d98211,
		0x8b5e20d6, 0x001021d7, 0x1029c518, 0x8b09b741, 0x372308d7, 0x01030e33, 0x3d3e1b00, 0x13621236, 0x193a3832, 0x52484852, 0x58673737, 0x36331561,
		0x3d14fd36, 0x431f4845, 0x702b0670, 0x3a3e3e3a, 0x1a675b62, 0x41343737, 0x18300baf, 0x37406400, 0x09000303, 0x0878090e, 0x08081403, 0x18220b82,
		0xc9440315, 0x00032806, 0x0e1a0800, 0x44117315, 0x0e2609bb, 0x14791110, 0x64431041, 0x12ed2308, 0xc2863939, 0xee71dd20, 0x2b872105, 0x088d8d18,
		0x420cba44, 0x9a41067a, 0x05b84405, 0x5c242d08, 0x383a1940, 0x145d1535, 0x1d38342f, 0x3bb05e52, 0x6b022357, 0x15528c43, 0x32645847, 0x3b4e5c32,
		0x02d8fe11, 0xecfe4625, 0x00428a48, 0x1120b783, 0xde340482, 0x1800d001, 0x36406200, 0x15050000, 0x16811512, 0x16161400, 0x260c9341, 0x1a051616,
		0x417f120b, 0x192a058f, 0x12491516, 0x850e0d0b, 0x81414911, 0x8a3f2008, 0x85cd20b6, 0x207541b6, 0x0806df44, 0x1813012a, 0x12323837, 0x322e1362,
		0x5b521833, 0x235634ad, 0xff572a61, 0x4a463d13, 0x3c421f1f, 0x01df0f33, 0x33c2458b, 0x66352e61, 0x080caf79, 0x21403c22, 0x0273070f, 0x11037306,
		0x0b730a0e, 0x0f790910, 0x020e1f0e, 0x000b0e0e, 0x440b410c, 0x07790205, 0x21060b46, 0x80751233, 0x26988206, 0xedd5edde, 0x68303132, 0x23210626,
		0x06944411, 0x52600138, 0xe12b4e27, 0x02e15252, 0xebdbfd6b, 0xfe2001a5, 0xfe6b02e0, 0xdf4500fb, 0x0f28080b, 0x25404200, 0x007f050d, 0x11017f04,
		0x007f080c, 0x10090109, 0x0c0f8507, 0x08020c1f, 0x0e090c0c, 0x4a09490a, 0x05850003, 0x8306e645, 0x5d5e2477, 0x6c1001ed, 0x79840642, 0x15332524,
		0x486c3523, 0x82a9200b, 0x53bd2178, 0x6c05f469, 0x0122074d, 0x78822d00, 0x6b02e23a, 0x3a000d00, 0x0d051f40, 0x0f010273, 0x0873070b, 0x0d79020e,
		0x7906090d, 0x2406134e, 0x04410908, 0x20e58208, 0x05637633, 0x10331122, 0xe6836d83, 0xe584dd20, 0xe0851520, 0x33112322, 0x012c0182, 0xb3525ee2,
		0x02b35252, 0xdbfd466b, 0x0121e087, 0x29e28205, 0x47000100, 0xe2010000, 0x6f82d001, 0x21403b25, 0x847f0d05, 0x007f256f, 0x02081008, 0x852e7482,
		0x8506490d, 0x0b010b0f, 0x4909080b, 0xdf820804, 0x3f207186, 0xdc84dd88, 0x70830120, 0x2c08246d, 0x525be201, 0x9b53539b, 0xfe45d001, 0x82da8775,
		0xff36216b, 0x24050750, 0x40880023, 0x05ab5b0d, 0x13101436, 0x0a4c0014, 0xb4d8ffb8, 0x4c001211, 0xf0ffb806, 0x4d000cb3, 0xe8260782, 0x000b09b4,
		0x1082054c, 0x34403a08, 0x004d0009, 0x0f1e731d, 0x1e0e010e, 0x17221e0e, 0x01071f76, 0x49094807, 0x73212507, 0x22202210, 0x22032230, 0x047c1924,
		0x79202204, 0x221e4123, 0x0c7c1244, 0x3fed2f00, 0x071a5033, 0xed5dd626, 0x5d2bde10, 0x2305f75c, 0x32ed105d, 0x21071f50, 0x41751501, 0x3527210a,
		0x24073174, 0x07062223, 0x05434111, 0x1a013808, 0x4a0e110a, 0x3a271543, 0x03080a25, 0x1f180708, 0x09490712, 0x52490910, 0xe16b0249, 0x86820101,
		0x20477151, 0x01014502, 0x38563c1f, 0xfe0101bb, 0xfd2502be, 0x416b02db, 0xf384055f, 0x00d0012f, 0xb96c0022, 0xe8ff1900, 0x4d000eb3, 0x21d48219,
		0x07840db3, 0x8305724a, 0x402c0810, 0x4d000a2a, 0x0d7f0c14, 0x2201220f, 0x110d220d, 0x241a8206, 0x11107f10, 0x03231101, 0x084b1f89, 0x11171788,
		0x4912850f, 0x004a110d, 0x8641d987, 0xde102106, 0x0520d98f, 0x8206f04f, 0x422320c8, 0xef68060c, 0x08125005, 0x82230121, 0x1f3125cc, 0x08150549,
		0xe423ca82, 0x8506190a, 0x0d052ae4, 0x01015e05, 0x0187535c, 0x05876ed5, 0x0102b53d, 0x5b416d67, 0x01011a39, 0x1d000200, 0xd9015cff, 0x2c007902,
		0xec003a00, 0x5d2032b5, 0xb32506ab, 0x2a4d0012, 0x20de82b8, 0x22078411, 0x840cb3e0, 0xb3e82207, 0x2307840b, 0x090e40f0, 0x1821ef82, 0x2d04820e,
		0x4d000810, 0xd8ffb812, 0x001210b4, 0x73540a4c, 0x20078206, 0x822b83f0, 0xb3e02407, 0x824d000a, 0x40e82207, 0x29338210, 0x0c0b1006, 0x18064c00,
		0x4d180a09, 0xf02b0c20, 0x000d0bb4, 0xffb8014c, 0x822e40f0, 0x10400872, 0x762d1330, 0x05130317, 0x76351c05, 0x2413130b, 0x003c0b24, 0x383b1c76,
		0x2528087c, 0x217c2825, 0x7c033045, 0x13461710, 0x2f00147c, 0xed333fed, 0x32ed3f32, 0xedde102f, 0xedd61001, 0x2f32ce10, 0xed260c82, 0x122f3911,
		0x06823939, 0xba553920, 0x822b200f, 0x14132300, 0x1f611716, 0x15162c05, 0x07020e14, 0x07171616, 0x6e272626, 0x6e650569, 0x1771080a, 0x3e171614,
		0x26343503, 0x6f062223, 0x4d12333a, 0x12483842, 0x14273924, 0x450b2d3f, 0x4f2f1d61, 0x48292139, 0x44253862, 0x321a1514, 0x32462b17, 0x0808ac1b,
		0x0a162319, 0x201d1a15, 0x796b3601, 0x7f564912, 0x29686772, 0x0d354751, 0x45023229, 0x03435105, 0x50774f28, 0x2b52784e, 0x0b430b0e, 0x5e42240b,
		0x234d2a95, 0x3f362909, 0x5241431e, 0x08008200, 0x2800022c, 0xd6017fff, 0x0b00db01, 0xd5003f00, 0x103a0c40, 0x354d0008, 0x00090810, 0xffb82c4c,
		0x1210b4c0, 0xb8224c00, 0x0db3e8ff, 0x07824d00, 0x0cb3e022, 0xe8220784, 0x07840bb3, 0x0ab3e025, 0x82214d00, 0x0f40261f, 0x1d4d000e, 0x26048210,
		0x0d0a201c, 0x82164c00, 0x10b32313, 0x07824d00, 0x0eb4f026, 0x114c000f, 0x40271082, 0x00100f3e, 0x8320044c, 0x04350854, 0x4d000f10, 0x031a3417,
		0x242e2e29, 0x0f1a8200, 0x1a3f011a, 0x06371a3f, 0x14412482, 0x09403782, 0x0c0f1f89, 0x3c890f0c, 0x89031750, 0x2e513429, 0x004b2f89, 0x1082413f,
		0x2509c042, 0x392f3311, 0xae621239, 0x14252512, 0x36361716, 0x22055841, 0x62262637, 0x1621059e, 0x07316917, 0x2705636d, 0x17031e07, 0x27032e07,
		0x7f081587, 0x1a011716, 0x352c0609, 0x1d1e1e17, 0x1221082f, 0x1729361f, 0x0807362e, 0x2433200f, 0x0f203122, 0x21342413, 0x2123220a, 0x37180b0a,
		0x5f102e34, 0x513e2571, 0x082e1a2c, 0x163722a5, 0x29364c08, 0x03a73737, 0x412c1507, 0x0e5a482c, 0x27203718, 0x191c3042, 0x23213a2c, 0x0925343f,
		0x060e1813, 0x0e013d01, 0x05202c1c, 0x5a3a737e, 0x03081f3c, 0xffff0000, 0x57ff2e00, 0x7902cc01, 0xa2000602, 0x31200f84, 0xc3220f82, 0x0f82db01,
		0x00c22608, 0x00010000, 0x015bff27, 0x006b02cd, 0x402a000b, 0x04730715, 0x0a730301, 0x0c0d0808, 0x0b790902, 0x79030641, 0x05bf4608, 0x0132ed32,
		0x2f391211, 0xddcefdce, 0x013031ed, 0x33112315, 0x31054d4b, 0xaacd0135, 0xaa2b4e27, 0xfe466b02, 0x02a5eb21, 0x56824625, 0x3a245782, 0xba017fff,
		0x0806ab6f, 0x7f0a1920, 0x7f060407, 0x010b0001, 0x0d0b0b08, 0x8506090c, 0x00054a0b, 0x00490285, 0x3f32ed3f, 0x5b84ceed, 0x865d5e21, 0x2313235d,
		0x60872135, 0x0197d124, 0x5f829780, 0x458b0127, 0xc7bbfe45, 0x26c38481, 0x0100000d, 0x826b02e8, 0x823c20c3, 0x0001226c, 0x20c3821e, 0x086b82d6,
		0x5400143d, 0x0a0f2e40, 0x810a140f, 0x09140609, 0x140f0609, 0x03008114, 0x00030014, 0x00097f03, 0x06080106, 0x00161506, 0x030f4914, 0x0a050606,
		0x4b054909, 0x333f3f00, 0x33113912, 0x86333f33, 0xfdcd2284, 0x0f035fdd, 0x07060622, 0x545eec82, 0x3e2a0806, 0xd6013703, 0x522e6125, 0x5a255f2e,
		0x25231f0c, 0x24251011, 0xd0010c1f, 0xb05ee780, 0x7fe65eb2, 0x5b61632c, 0x615b2424, 0xa6822c63, 0xab860020, 0x18003008, 0x2e405600, 0x100b1014,
		0x14141178, 0x16111411, 0x0b017317, 0x07780808, 0x04071404, 0x01020407, 0x101a1901, 0x01174111, 0x040b1479, 0x18070804, 0x23088f5d, 0x32ed3333,
		0xcd229c86, 0x9a84dc33, 0x10180124, 0x0a82cdfd, 0xc47d8727, 0x35333031, 0x705c1823, 0x209b8208, 0x32ac8233, 0x15231533, 0x3c7a80d2, 0x215c295a,
		0x26172b47, 0x82112123, 0x7d3b340a, 0x6142bd81, 0x94505bb0, 0x4b4c2a51, 0xad5b294b, 0x41bd4264, 0x1a340c3f, 0x2e405400, 0x1015100c, 0x140c0f81,
		0x090f0c0f, 0x1a151a03, 0x3a064041, 0x0b7f0604, 0x1b1c0909, 0x490f1015, 0x860c0315, 0x4b084a09, 0x0049001a, 0x603f323f, 0x012b0541, 0x3912112f,
		0xcdfdcd2f, 0x822b87dd, 0x87a38298, 0x860120a1, 0x87232092, 0x031e22a9, 0x2ca98217, 0x5320d601, 0x527b6329, 0x512a637a, 0x0c494120, 0x58cb7029,
		0x3da5a53d, 0x416fcc58, 0x19210d4b, 0x059b4fff, 0x00193908, 0x102f4056, 0x78020f02, 0x17141017, 0x18171710, 0x120b120a, 0x140a1378, 0x130a1313,
		0x1b187301, 0x1a0b0f0f, 0x10411312, 0x0b0a410f, 0x00791744, 0x3f004402, 0x333fedce, 0x98550183, 0x10872108, 0x1122a884, 0x544d1833, 0x30312705,
		0x2e233505, 0xae822703, 0x36234208, 0x33033736, 0x03333717, 0x33171616, 0x178b0115, 0x24201b0b, 0x1e422414, 0x32552159, 0x83765b9e, 0x4326a659,
		0xa5a5281e, 0x4848441b, 0x4591381f, 0x0150ad4a, 0xfeeded24, 0x43833edf, 0x000100eb, 0x064f721d, 0x001b3308, 0x0c2d4052, 0x81140d14, 0x15140c15,
		0x0115150c, 0x121d1a7f, 0x81021102, 0x19141219, 0x11111219, 0x14191c0d, 0x11124915, 0x4a0d0c49, 0x4a028519, 0xa8873f00, 0xc6102f22, 0x2107104d,
		0xc4181801, 0xa7850ba2, 0x07030e22, 0x2720a783, 0x4350a783, 0x01350805, 0x1b0a0e82, 0x12122320, 0x0b1f2527, 0x2e5d2155, 0x737b5da5, 0x3e209958,
		0x8181281c, 0x32333014, 0x33321716, 0x7f3c1330, 0xa2a2dc39, 0x2e5b2ad7, 0x000000c7, 0xf74c1801, 0x0f2b0808, 0x1f403900, 0x07077304, 0x1108730b,
		0x01b001a0, 0x73020102, 0x02100e0d, 0x0f05790d, 0x79040741, 0x00440b0a, 0x32edcd3f, 0x5aed333f, 0x5d200684, 0x12449684, 0x72112007, 0x233407f8,
		0x550e0135, 0x4e2752a7, 0x0255dcfe, 0x21fe466b, 0xdbfd2502, 0x83061d44, 0x05ab506f, 0x7f206f85, 0x7f206f82, 0x7f206f88, 0x85296f84, 0x07490f05,
		0x0b0a8504, 0x206faa4a, 0x2f6f839e, 0xcf0155e5, 0x01bcfe45, 0xc776fe8a, 0x458a0181, 0x3620df83, 0x2c063742, 0x4056001b, 0x08281710, 0x20164d00,
		0x2204820a, 0x5d000918, 0x12200588, 0xf03d0784, 0x00111c40, 0x7310094d, 0x0c730f0b, 0x1973001d, 0x147c051c, 0x1a091014, 0x790b0e41, 0x05074510,
		0x39123323, 0x05a8472f, 0x2006c44b, 0x058f472b, 0x33021e25, 0x86373632, 0x604618ff, 0x1908260b, 0x3720242d, 0x289a820e, 0x233d102b, 0x0d28493c,
		0x62461853, 0xebdb220a, 0x644618a5, 0x00012208, 0x08334236, 0x40452708, 0x0d100e2a, 0x180e4d00, 0x4c000c0b, 0x0a08200e, 0x051a4c00, 0x7f04007f,
		0x7f131d01, 0x89161c10, 0x1a050b0b, 0xe84b4911, 0x4b989309, 0x677506e6, 0x75332007, 0x2708087c, 0x4e27a901, 0x1f19082b, 0x41281021, 0x3552192e,
		0x13302532, 0x81c74652, 0x040502b4, 0x3e261004, 0x3688892e, 0xdb050729, 0x2906eb50, 0x006b02bf, 0xb95b001a, 0xa3560200, 0x47022006, 0x07820689,
		0x40e02508, 0x4d000f23, 0x04130510, 0x0d091804, 0x001c0c73, 0x01181073, 0x04061b18, 0x10127c03, 0x0a0d1313, 0x440d4119, 0x30056645, 0xfdcd332f,
		0x100133cd, 0x10ed5dd6, 0x1132edde, 0x4a108239, 0x420805fd, 0x17161413, 0x36153335, 0x33113736, 0x06352311, 0x35231507, 0x3535032e, 0x31238933,
		0x0b2a1843, 0x34195252, 0x25413343, 0xb801530e, 0x710a4842, 0x03080273, 0x95fd3c01, 0x730508e8, 0x39220473, 0x86b3304e, 0xad2a08ab, 0x1b00d001,
		0x22404100, 0x000b1018, 0x0413074d, 0x0b1a1414, 0x1d0d7f0e, 0x1c1a7f01, 0x88040507, 0x15151214, 0x491b0b0e, 0x948e4a0e, 0x1321938d, 0x20928815,
		0x88928435, 0x882a0893, 0x163e262a, 0x53530e20, 0x3e16240a, 0x172b3c24, 0x2e88d001, 0x5252052b, 0xdb040502, 0x03b330fe, 0x50530208, 0x3d261302,
		0x9382892c, 0x00002d3b, 0x6b02c401, 0x56001500, 0x280d1140, 0x4c001211, 0x0010180d, 0x0f100d4d, 0x0c0c6a00, 0x1c6ab320, 0x40d03c05, 0x4d000816,
		0x1709730a, 0x13731200, 0x037c0e16, 0x41141303, 0x0044130a, 0x423f333f, 0x3223077c, 0x4aedde10, 0x13290717, 0x32333636, 0x1515021e, 0x058e4823,
		0x11072408, 0x7f331123, 0x3f264111, 0x52112d50, 0x3e204e39, 0x0152520e, 0x2009058c, 0xb634543c, 0x084e4eb6, 0x82bbfe05, 0x060b6d90, 0xb502b03f,
		0x4b000602, 0x02000000, 0xf3ff1200, 0x7902db01, 0x2f002600, 0x00b9bf00, 0xb3f0ff21, 0x058a4912, 0x8411b321, 0xb4d82a07, 0x4c00100f, 0xe8ffb821,
		0x05a349b3, 0x1e40f827, 0x1f4d0009, 0x21168320, 0x1382101f, 0x82081f21, 0x200c260f, 0x0c4d0010, 0x23e08218, 0xe0ffb808, 0x07824383, 0x4383d820,
		0xd0210782, 0x081c82b3, 0xffb8023e, 0x0d2e40f8, 0x274c000e, 0x07072376, 0x002f3123, 0x0f001d76, 0x0f200f10, 0x1a0f0803, 0x0f301476, 0x171d7900,
		0x2a032f2f, 0x0645207c, 0x0a7c0306, 0xed3f0046, 0xed3f2f32, 0xcc2f3912, 0x24057e44, 0x5d5edcfd, 0x8d421832, 0x08136518, 0x22237408, 0x2e27022e,
		0x36343503, 0x15061737, 0x36171614, 0x16323336, 0x07061415, 0x23263427, 0x07020e22, 0x433304ed, 0x16072f22, 0x352e4307, 0x01152e49, 0x1625321c,
		0x04430205, 0x56082024, 0x02504c45, 0x24294b01, 0x0a131e15, 0x73210101, 0x41081876, 0x512d1a0a, 0x1103426f, 0x0d23311f, 0x11080619, 0x01242010,
		0x979f8989, 0x46051508, 0x3a256864, 0x82002449, 0x02220800, 0xf5ff1200, 0xdb01c701, 0x2f002600, 0x00b97900, 0x40f0ff2c, 0x00100f15, 0x1408254c,
		0x18254d00, 0x0a821312, 0x11103f08, 0xb8074d00, 0x0fb3e0ff, 0xb8014d00, 0x2b40d8ff, 0x4c001211, 0x0c038227, 0x2f31030c, 0x00228205, 0x02141014,
		0x19821f14, 0x86051430, 0x2f2f1c22, 0x080b0b00, 0x2a510f88, 0x00500088, 0x447fed3f, 0x08124106, 0x20111141, 0x21ec8201, 0x0e412315, 0x033e2219,
		0x06074117, 0x32013e08, 0x04e04d48, 0x261a3235, 0x340a0b0a, 0x2e422c20, 0x2f1a0218, 0x02051523, 0x1d200443, 0x332b1f05, 0x0f1e265e, 0x010c121a,
		0x707cdb01, 0x0e4b481d, 0x12084608, 0x30523c21, 0x2f1e1103, 0x050b4122, 0x03251d2d, 0x18314b32, 0x16433dc6, 0x41182e24, 0x5b2d0607, 0x7902db01,
		0x32002900, 0x00b9e500, 0x05574224, 0xa24d2420, 0x42078206, 0x08820557, 0x0ab3f024, 0x07824d00, 0x3340c82d, 0x224d0009, 0x00100f20, 0x8208224c,
		0x10222113, 0x0f270f82, 0x4d000f28, 0x820c080f, 0x0b182104, 0x102a0482, 0x4c000a09, 0x0010280e, 0x6c420e4d, 0x05b94f06, 0xffb80823, 0x066542e0,
		0xb3f04208, 0x024d000e, 0x40f8ffb8, 0x4d000d34, 0x0d0d730a, 0x26762a12, 0x34260707, 0x20760032, 0x12101200, 0x08031220, 0x17761d12, 0x79001233,
		0x32321a20, 0x237c2d03, 0x03060645, 0x0a0b0d7c, 0xcd3f0046, 0x1b754233, 0x2f391122, 0x5a088843, 0x13200bab, 0x44086e41, 0x7f4205c9, 0x30062725,
		0x38274e23, 0x80421023, 0x15082920, 0x099e9a05, 0x3a644e34, 0x081e8442, 0x1200022d, 0xc7017fff, 0x2700db01, 0x92003000, 0xff2d00b9, 0x0f1640e8,
		0x264c0010, 0x00121110, 0x0c18134c, 0x10134d00, 0x4c000b0a, 0x5cffb807, 0x01270509, 0xb3d8ffb8, 0x824d0012, 0xe0320807, 0x00113340, 0x127f0f4d,
		0x82281512, 0x3032030c, 0x00238205, 0x20151015, 0x15080315, 0x311a8220, 0x8605150d, 0x30301d23, 0x080b0b00, 0x0f101288, 0x95422b51, 0x33cd2506,
		0x112f32ed, 0x2206aa43, 0x43d6102f, 0xde2207ab, 0x3341ed32, 0x0e9c420c, 0x4306674b, 0x9e420bad, 0x1f082615, 0x44424f15, 0x1f9d4203, 0x040d0627,
		0x75107b79, 0x1a9f4255, 0x00ffff3d, 0x01000059, 0x026b029b, 0x002c0006, 0x00ffff00, 0x01000004, 0x022303f1, 0x18c90226, 0x2f0f0b57, 0x310940ff,
		0x50260739, 0x4f2e1101, 0x00342b2b, 0x07202f84, 0xeb222582, 0x2f829802, 0x0982e920, 0x90030622, 0x102c1682, 0x00010b40, 0x101f3d35, 0x32050150,
		0x20082a84, 0xff2e0001, 0x02d8015b, 0x002b006b, 0x23164087, 0x00121118, 0x0e20224c, 0x10224d00, 0x1e4d000d, 0x2b098218, 0xf0ffb814, 0x4d000fb3,
		0xe8ffb813, 0x092b0788, 0xb80e4d00, 0x2a40e0ff, 0x604d0008, 0x340808a4, 0x2007070c, 0x012d1176, 0x73281919, 0x7c252c2a, 0x2a0c0c01, 0x442a412b,
		0x06167c1d, 0x3f004107, 0x3fed2f33, 0x2f39123f, 0x1001ed33, 0x2f32edd6, 0xedde1032, 0xe5481833, 0x11132110, 0x087b4418, 0x9b621520, 0x9f46180b,
		0x114c0808, 0x1e801123, 0x153b4143, 0x3c381966, 0x52301f3f, 0x341a233e, 0x1b0d344d, 0x0f05030b, 0x294e3c0d, 0x0c1c463e, 0x02520d1a, 0x1ee5fe6b,
		0x1d484d4b, 0x45474521, 0x3b1e041f, 0x5f38425b, 0x43022846, 0x62600101, 0x0b264b40, 0xe6fe0101, 0x2e078752, 0x015aff47, 0x00d001cc, 0x40750027,
		0x82301f11, 0x101f27ef, 0x4c000e0d, 0x0a82201b, 0xfa830d20, 0xe9820920, 0xffb83208, 0x0a2b40f0, 0x821d4d00, 0x0505000e, 0x140b0681, 0x06050b06,
		0x16290e06, 0x7f230016, 0x220b2825, 0x250b0b89, 0x4a254926, 0x4b13891a, 0x3f004906, 0x22f2853f, 0x832f01ed, 0x2f3231f2, 0x2f32ce10, 0x0587c100,
		0x107d042b, 0x101801c4, 0x2007aa43, 0x5ef48613, 0xcf4f0e4b, 0x07450806, 0x33112315, 0x3b3a169a, 0x14611135, 0x18363631, 0x3019685c, 0x160b2f48,
		0x0b050508, 0x57413908, 0x06200d51, 0x06015353, 0x35373515, 0x31311714, 0x74051630, 0x3b4e2b67, 0x42020123, 0x484c0101, 0x02034e56, 0x29de82d0,
		0x01000000, 0x57ff0d00, 0xf882e201, 0x63002125, 0x490600b9, 0x5a54063f, 0xf82f080a, 0x4d000bb3, 0xf8ffb803, 0x000d2240, 0x1f1a194d, 0x73001473,
		0x20091111, 0x23141373, 0x191a2209, 0x44207913, 0x41117900, 0x46087909, 0x83ed3f00, 0x19dc2201, 0x28cd82c5, 0xd5de10c6, 0x2f3911ed, 0x06266bed,
		0x00822b20, 0x0f745418, 0x6c163321, 0xee21082b, 0x7d541803, 0x6c1c200f, 0x1d210b25, 0x89541802, 0x0b1e6c12, 0x86250221, 0x016c22cf, 0x25dc82e3,
		0xb556001f, 0xbb82200b, 0xffb80724, 0xba82b3f0, 0xe82c0782, 0x000c2240, 0x1d18174d, 0x7f00147f, 0x1e2bc382, 0x2114137f, 0x17182009, 0x181e8513,
		0x200e4e44, 0x20c398ed, 0x57441813, 0x6b332010, 0x441808fd, 0x1f200f5f, 0x2109f46b, 0x44180124, 0x75201269, 0x0809eb6b, 0x01008b31, 0x59ff2d00,
		0x6b02c701, 0x35001900, 0x0a191c40, 0x1b027311, 0x15731418, 0x0f79131a, 0x02181f18, 0x00151818, 0x44154116, 0x2f00070e, 0x573f3fcd, 0xfd270cb1,
		0x303133cc, 0x82113301, 0x2223219c, 0x2008c25e, 0x07b95711, 0x79527521, 0x172c08af, 0xf61b2107, 0x02f65252, 0x2995fd6b, 0x09b38e18, 0x572f0121,
		0x012207cc, 0x87824700, 0xd001ad22, 0x27088782, 0x1722403d, 0x007f0f08, 0x7f12161b, 0x13011300, 0x0f85111a, 0x02161f16, 0x13161608, 0x13491418,
		0x05890c4a, 0xed3f004b, 0xc7578d85, 0x208f840a, 0x568d8d21, 0x332208f3, 0x8e85ad01, 0x08080b2b, 0x1b200817, 0xc05353c0, 0x268b8a53, 0xd001cddc,
		0x8200bdbd, 0x00012200, 0x069f422d, 0x47001736, 0x09082540, 0x1703730e, 0x0302730f, 0x73121619, 0x79111813, 0x8c828d84, 0x4114002a, 0x08094413,
		0x440f7902, 0xdc238e82, 0x4118c519, 0xd5220e20, 0x874232ed, 0x33012206, 0x0a764211, 0x21072141, 0x6d425268, 0x52e9250c, 0x6b02e952, 0x200d7f6e,
		0x08ee5820, 0x00010024, 0x6742ff47, 0x82152005, 0x24230897, 0x7f0a0504, 0x7f0b1301, 0x12170100, 0x0f007f0d, 0x160f0801, 0x1212850d, 0x4910140f,
		0x04054a0f, 0x6e0b8500, 0x3f200858, 0x2107094d, 0x92825d5e, 0x9789de20, 0x47422520, 0x0a284108, 0x260a366e, 0x5353ce24, 0x424552ce, 0x2c580832,
		0x00013a07, 0x015bff36, 0x006b02bf, 0x4050001b, 0x0a181710, 0x10174d00, 0x164d0009, 0x05c86b10, 0x1e40e026, 0x4c001211, 0x2006384e, 0x08394e0b,
		0x1a090c2c, 0x0d790f41, 0x3f00440c, 0x9688edcd, 0x8210ed21, 0x08f55793, 0x0b965418, 0x3523152d, 0x06063533, 0x022e2223, 0x18333535, 0x26089a54,
		0x0f274f2a, 0x183c2342, 0x220f9c54, 0x18a2eba5, 0x20089e54, 0x053b4e00, 0x2405fb4c, 0x18294045, 0x0d851818, 0x09183b08, 0x0f084d00, 0x7f0e0a7f,
		0x011d0a0b, 0x041c1a7f, 0x0b151588, 0x0e491b08, 0x5d4f0c85, 0x18999505, 0x840ba943, 0xad431898, 0x4f2b220e, 0xaf431827, 0xc7812212, 0xb143186d,
		0x8200200a, 0x42202097, 0x262d065f, 0x00b9c400, 0xb3f0ff26, 0x264d000c, 0x05ef62b8, 0xffb80328, 0x1310b4f8, 0x08824c00, 0x0fb3f024, 0x07844d00,
		0xb0490d20, 0x820a2006, 0x01520808, 0x000c0b28, 0xffb80b4c, 0x124640e8, 0x0c0b4d00, 0x19067311, 0x7b260026, 0x1a14191a, 0x0118191a, 0x177b0100,
		0x17171418, 0x171a0018, 0x02731217, 0x05300520, 0x28060502, 0x25731f1a, 0x261a2720, 0x19001841, 0x44201f19, 0x79050b0c, 0x01174412, 0x75710041,
		0x2f332209, 0x057f5e33, 0x32ed3226, 0x5dd5d610, 0x11220682, 0x15523912, 0x18872105, 0x25051c52, 0xdefd1018, 0x5718c519, 0x2b26085f, 0x16331313,
		0xdf421712, 0x032e2509, 0x03230327, 0x2606ae67, 0x4d55ef33, 0x42061112, 0x183c0be8, 0x03030201, 0x51474f02, 0x03030301, 0x08035001, 0x4c090f0b,
		0x34013701, 0x92f3fe82, 0x330a7c71, 0x8a867e36, 0x01e6fe41, 0x8789411a, 0xa04c367e, 0x00479a9e, 0x01220082, 0x07431b00, 0x002c3806, 0x182340ad,
		0x157f1e19, 0x0f0e1810, 0x28104c00, 0x104d000d, 0x820c0b20, 0x22272b0a, 0x100d8427, 0x22100d14, 0x4a4c0a1f, 0x25078206, 0x0e0db4d8, 0x10844c00,
		0x4d000c22, 0xd8230782, 0x820b2e40, 0x00282208, 0x41491828, 0x7f1f3f08, 0x2e151411, 0x097f0300, 0x18192d04, 0x4a1f8514, 0x00491022, 0x0d27490a,
		0x4a042828, 0x22413f00, 0x06324105, 0x1018012b, 0x32ed32d6, 0x32d5de10, 0x4d4918ed, 0x822b2008, 0x18112000, 0x82074d49, 0x0530410b, 0x11544918,
		0x17161622, 0x20087f43, 0x5c491826, 0x30142912, 0x152e201d, 0x050f0b4d, 0x2e09d345, 0x07030220, 0x15101009, 0x130e520e, 0x18011010, 0x28086449,
		0x59599536, 0xce5b3695, 0x08ab4362, 0x55b34e2b, 0x3b353625, 0x353b2a2a, 0x05934936, 0x2a0fd349, 0x01000009, 0x022303eb, 0x49240026, 0x102a0ad3,
		0x00020b40, 0x0f04221a, 0x93180250, 0x9820107f, 0x44202b82, 0x300bcf49, 0x3c340402, 0x0250131c, 0x2b4f310f, 0xffff342b, 0x20538500, 0x2153871a,
		0x7a828300, 0x17008b29, 0x02031040, 0x822b1900, 0x09032354, 0x58854f23, 0x34342b22, 0x3a269785, 0xb001f5ff, 0x5b878f02, 0x31843384, 0x45330522,
		0x03235c82, 0x854f3d0f, 0x82318360, 0x821b2063, 0x02e22c81, 0x0006026b, 0xff0000a1, 0x821f00ff, 0x01de223f, 0x200f82db, 0x200f84c1, 0x201f825b,
		0x20d784cc, 0x33d78628, 0x008b0012, 0x0100b913, 0x0940f8ff, 0x0a00170f, 0x0c010150, 0x2009ab4a, 0x213f8228, 0xdb8302c7, 0xdb8c4820, 0x2d250228,
		0x02500213, 0x2a832200, 0x00ffff2d, 0x01f3ff19, 0x027902d8, 0x84e80106, 0x772d2067, 0x02230597, 0x84350206, 0x201f840f, 0x83fb8203, 0x0701251f,
		0xefff8300, 0x1a347782, 0xb80203b1, 0x0d40f1ff, 0x11193b29, 0x330c0350, 0x270c024f, 0xcc825182, 0x00ffff22, 0xfb834384, 0x01264383, 0xf8830006,
		0x31850000, 0x0d40f62e, 0x15023826, 0x30100350, 0x2410024f, 0x8b4b3185, 0x4b67820a, 0x6341058b, 0x01022b09, 0x07423000, 0x11025026, 0x8d4b4f3a,
		0x08634105, 0x20058f4b, 0x078f4b8f, 0x172e3384, 0x01021040, 0x1f463401, 0x05025010, 0x944b4f3e, 0x06634105, 0xf4ff2624, 0xcb83d101, 0x00ca0223,
		0x20cb8400, 0x32cb84f8, 0xffb80102, 0x370d40f7, 0x501c2749, 0x4f410f02, 0x88350f01, 0xff4824cb, 0x84bf01f5, 0x82ea20cb, 0x83cb8733, 0x40ef2e31,
		0x16412f0d, 0x0202500f, 0x02014f39, 0x2acb8a2d, 0x01f3ff18, 0x026b02cf, 0x840f0206, 0xff2c26db, 0x01af015b, 0x200f82d0, 0x200f84a3, 0x22498237,
		0x820603bd, 0x82cb20b7, 0x00072d09, 0x0000008a, 0x4010008b, 0x1200010b, 0x0faf6318, 0x21823f20, 0x7b02b622, 0xeb202b82, 0x2b837f84, 0x09202986,
		0x850b9f7e, 0x881a2053, 0x08a34253, 0x0001022e, 0x09002614, 0x1e010250, 0x1201014f, 0x0b23a418, 0x8f205b85, 0x33835b88, 0x10401722, 0x5c823184,
		0x82000221, 0x87002031, 0xffff2131, 0x20053b7b, 0x21638203, 0xb7843200, 0x03246388, 0x34220002, 0x03266382, 0x024f2c04, 0x638b2004, 0xf5ff2825,
		0x8202cc01, 0x52002163, 0x6386bf84, 0x63823184, 0x0af69218, 0x00343423, 0x0b9f7b00, 0x21001a2f, 0x21b58800, 0x4d000e10, 0xf0ffb81c, 0x200782b3,
		0x2607891a, 0x0d1440e8, 0x83154d00, 0x1815211d, 0x11260982, 0x00100f10, 0x20820d4c, 0x0883b420, 0xffb80725, 0x832a40e8, 0x10033009, 0x034d0010,
		0x4d000f18, 0x0a76171f, 0x7b181e23, 0x222e0658, 0x1e1e7918, 0x0f7c1405, 0x057c1b46, 0x41180045, 0xd6230997, 0x1832ed2b, 0x7b103c58, 0x172d0f40,
		0x21373632, 0x22131616, 0x26210706, 0x102e7b26, 0x4442dc2f, 0x05edfe05, 0x43404142, 0x06130105, 0x101b7b44, 0x6b72a92b, 0xf801726b, 0x6f69696f,
		0x0e0f7b00, 0x7324f783, 0x20210c40, 0xfe87bd83, 0x82b3d821, 0x451c20c5, 0x0e4106f4, 0x40e8220a, 0x2126832b, 0x05831815, 0x82171f23, 0x39e08200,
		0x09400a82, 0x220a480c, 0x1e3f8618, 0x1e021e4f, 0x881b141e, 0x8814500f, 0xe5845105, 0x8f07a062, 0x0fe27ae6, 0xe2820720, 0xe2852320, 0x26263322,
		0x2d11d17a, 0x064436d3, 0x354108fe, 0xfc084332, 0xbd7a4408, 0x4ae02c0f, 0x01494847, 0x42424453, 0x42000044, 0x03210b3b, 0x0d3b4278, 0x0003042d,
		0x09003624, 0x2e040450, 0x1804034f, 0x8308e545, 0x083b4233, 0x42790321, 0x31840b3b, 0x50000924, 0x31820e04, 0x31870e20, 0x2e2a6382, 0xd501f3ff,
		0x26021a03, 0x6385e002, 0x3106ab44, 0xffb80102, 0x290d40e8, 0x50040f3b, 0x4f330002, 0xab440001, 0x423b2009, 0x0321079f, 0x20638500, 0x374418ef,
		0x40e62e07, 0x0839270d, 0x1f025000, 0x1f014f31, 0x0adf4325, 0xf8ff0926, 0x0603ee01, 0xd6206782, 0x8a226784, 0xbf430900, 0x26072806, 0x50150b27,
		0x45280b01, 0x4e180588, 0x022007df, 0x0ae79118, 0x0000122a, 0x010b4010, 0x20222113, 0x09212982, 0x06874523, 0xbb835385, 0x83205385, 0x17275384,
		0x01021040, 0x823a2807, 0x0b022654, 0x0b014f32, 0x0b5b4326, 0x58ff2426, 0x8f02cd01, 0x07934218, 0x82830021, 0x2231845b, 0x82352313, 0x0902265c,
		0x09014f2d, 0x82318621, 0x2063858b, 0x26b7873e, 0x24006501, 0x84008900, 0x28222231, 0x2063842a, 0x4163822b, 0x0022061c, 0xbf880000, 0x6387b520,
		0x2d650123, 0x22318500, 0x8425232e, 0x82262063, 0x0a834163, 0x00003625, 0x8303bf01, 0x41da20c7, 0x022a0de7, 0x2c1a0001, 0x02500a14, 0x31822409,
		0xc78b1820, 0xad203383, 0x0221c783, 0x0be741fa, 0x08010229, 0x09152c1a, 0x82000250, 0x88002031, 0x05a74b31, 0x6b02cc37, 0x28000b00, 0x0d031440,
		0x05067309, 0x0c0b0073, 0x08790005, 0x0d68180a, 0x5ace2008, 0xdd2206ba, 0x681810ed, 0x23330a0e, 0x8f352335, 0x86eb3d01, 0x0246e24f, 0x21fe4625,
		0x8246a5eb, 0x012a08e8, 0x7fff6b00, 0xd001b801, 0x24000900, 0x0b041240, 0x06007f07, 0x050a017f, 0x09490285, 0x4a018506, 0xceed3f00, 0x1001ed3f,
		0x4f85edd6, 0x11233322, 0x2c06bb5e, 0x4d0138a3, 0x014f35fb, 0xbbfe45d0, 0x2d4a82c7, 0x2400ffff, 0xd001faff, 0x26021a03, 0x0341de02, 0x03042d0d,
		0x06362400, 0x0704501f, 0x07034f2e, 0x260ceb42, 0x01f6ff2d, 0x828f02c7, 0x42fe2033, 0x0d2410eb, 0x0d04501e, 0x0d203182, 0x04223188, 0x25822400,
		0x7802e230, 0x17000b00, 0x27001b00, 0x00b99d00, 0x2e61ff0a, 0xb80a2b05, 0x1840e8ff, 0x084d000d, 0x04830f10, 0x4d000d23, 0x20098304, 0x20138304,
		0x06795202, 0x4d080782, 0x0d3540e8, 0x184c000e, 0x120c0618, 0x00191900, 0x21202629, 0x26277e20, 0x26272714, 0x24211d27, 0x2301234f, 0x21281e1d,
		0x41234426, 0x0f412027, 0x1e1b1803, 0x45091544, 0x3fcd3f00, 0xcddedddc, 0x3f3f333f, 0xd6100133, 0xcd5ddcdd, 0xaa711133, 0x32c62309, 0x1e82102f,
		0x622f3221, 0x012109d2, 0xab781814, 0x534b180a, 0x032a080a, 0x27231533, 0x33112315, 0x33352713, 0x01032311, 0x2b2b25e2, 0x2b2b2626, 0x0c0f6b25,
		0x0b10100b, 0xa1360f0c, 0x423edfa1, 0x03820977, 0x4ecf012a, 0x4e4e5c5c, 0x384f5b5b, 0x22080083, 0xc5fe3737, 0x02fb7545, 0xb74cfe6b, 0x0195fdfd,
		0x010000b4, 0xec000000, 0x3201f401, 0x0d000300, 0x820203b3, 0xcd2f2306, 0x89822f01, 0x15211129, 0xfef40121, 0x4132010c, 0x1f3405ef, 0xd401f3ff,
		0x3c007802, 0x1140e800, 0x000d1830, 0x0c10304d, 0x182b0482, 0x4c000b0a, 0xe8ffb82b, 0x841211b4, 0xb3e02608, 0x254d0010, 0x05cb56b8, 0xe8250782,
		0x4d0011b3, 0x820f8613, 0x220f8707, 0x850cb3f8, 0x54402217, 0x08428209, 0x18181f48, 0x171a1e21, 0x35231504, 0x04023c38, 0x15760432, 0x3e152a2a,
		0x23363600, 0x0d0d3276, 0x32103200, 0x08033220, 0x3c1a3d32, 0x02170279, 0x38793521, 0x02af381e, 0x0f0202bf, 0x02381f38, 0x38023802, 0x26292910,
		0x68182d7c, 0x39291144, 0x5d5d2f2f, 0xed103311, 0x2d048432, 0x5ec61001, 0x102f325d, 0x332f33ed, 0x0883cc10, 0x39171129, 0x39171211, 0x64332f32,
		0x13220c54, 0xef532135, 0x08856f08, 0x15330726, 0x07060623, 0x21210682, 0x06375c06, 0x9b4e1720, 0x34710806, 0x35233736, 0x37363633, 0x31011f37,
		0x261e130c, 0x153d2e14, 0x25462611, 0x142c4934, 0x15512f09, 0xe9272339, 0x380ed2fe, 0x1e433440, 0x2b592a18, 0x132e4d3b, 0x53300504, 0x21284015,
		0x163c6601, 0x1723171c, 0x4808110c, 0x2f1d0d0b, 0x151c1e3b, 0x1524133c, 0x1f153c16, 0x0e13302a, 0x1a101642, 0x111e382b, 0x143c0c1d, 0x00131724,
		0x00010000, 0x08048221, 0x6b02d25d, 0x97001700, 0x10074e40, 0x140f080f, 0x13130403, 0x0d160f13, 0x090e0d0a, 0x1211060e, 0x09050505, 0x03060701,
		0x1114730a, 0x190d0d10, 0x080e1218, 0x79150204, 0x09040517, 0x0f121308, 0x2008100e, 0x0e000208, 0x08040801, 0x120e0e12, 0x0c040408, 0x440c4117,
		0x123f3f00, 0x822f3917, 0x5d5e2400, 0x8533115d, 0xed102301, 0x11820132, 0x12112f3b, 0x33332f39, 0x3232fd33, 0x32cdcc32, 0x04877d2f, 0x8710c4c4,
		0x1801c4c4, 0x280f8c10, 0x15013031, 0x17371523, 0x24038407, 0x27073523, 0x27038437, 0xd2013523, 0x831b68b0, 0x51230282, 0x82821a68, 0x02b03a02,
		0x3188486b, 0x31673e38, 0x89ab3d38, 0x673c3931, 0xaa3d3830, 0x00020048, 0x20e38228, 0x2de382cb, 0x000b0007, 0x0a15402b, 0x01090406, 0xa5827303,
		0x06020d29, 0x790a0779, 0x8304410b, 0xdefd21ac, 0x25068963, 0x1032cefd, 0x798432ce, 0x1123113d, 0x15253523, 0xcb013521, 0x01a951a9, 0x015dfea3,
		0x75fe45d0, 0x9b458b01, 0x82004646, 0x821b205b, 0x02d0315b, 0x0018006f, 0xb59c0027, 0x00101021, 0xffb8144d, 0x82052b59, 0xb4e02d08, 0x4c000a09,
		0xe0ffb812, 0x4d0012b3, 0xd0220782, 0x078411b3, 0x0ab3e822, 0xe0250784, 0x4d0009b3, 0x211f8211, 0x20823040, 0x76232908, 0x13000013, 0x1d060a29,
		0x0c730318, 0x09280408, 0x0c1d7917, 0x7902051d, 0x0f180818, 0x021d1f1d, 0x181d181d, 0x107c1904, 0xed25b285, 0x2f393912, 0x0c98422f, 0x3232d625,
		0x843232ed, 0x485e18c1, 0x1525280c, 0x35231523, 0x18333523, 0x2609a681, 0x23061415, 0x7c131523, 0x3e2a059c, 0x2e343502, 0xc97e0102, 0x00824951,
		0x4c214a08, 0x7b706c23, 0x1f452878, 0x2523071e, 0x15172a3d, 0x3f9e2f24, 0x5b3f5f5f, 0x09270140, 0x625e5e06, 0x8c015b58, 0x0aee0102, 0x2226301b,
		0x000c1b2d, 0x74000100, 0x7f011b02, 0x0d009802, 0x0bb71500, 0x0a04030a, 0x00000704, 0x434d192f, 0x1826200b, 0x200a4f41, 0x3d4018fa, 0x1b02230c,
		0x41183339, 0x6e18081b, 0x003d0fab, 0xff360003, 0x02c201fb, 0x001a0071, 0x00380029, 0x7b51407a, 0x326a0132, 0x012e7901, 0x3e02826a, 0x02267a26,
		0x227b226b, 0x95198502, 0x17950219, 0x01168101, 0x85011394, 0x0e900113, 0x190e1401, 0x088be3e5, 0x101e183a, 0xc5754030, 0x1f1f2902, 0x141a2c39,
		0x611e3124, 0x232e194e, 0x2f241614, 0x08271a1a, 0x06030205, 0x04580204, 0x10020306, 0x162e3e26, 0x091c2228, 0x5c3c4811, 0xdd26015e, 0x14e3e519,
		0x7cffff21, 0x6b2806db, 0xc6020602, 0x02000000, 0x08053b4f, 0x006b0243, 0x0016000b, 0x0629404c, 0x78120c12, 0x0b14060b, 0x1105060b, 0x0078110c,
		0x00001405, 0x000c0c05, 0x1700180b, 0x4106440b, 0x1241050c, 0x44007911, 0x32ed3f00, 0x3f3f333f, 0x10c61001, 0x3d3911ce, 0x06a9512f, 0x08156a18,
		0x3e333b08, 0x1e333703, 0x0e031703, 0x2e210703, 0x2d170903, 0x5f1e332e, 0x2c33361b, 0x2109ee10, 0x01142b27, 0x24291417, 0x959d591e, 0xa3464e92,
		0x02409da5, 0x7c5b1923, 0x98555598, 0xa7825c7c, 0x00005b25, 0x8202cc01, 0x280021a7, 0x0120a782, 0xc720b784, 0x1128a782, 0x1d403700, 0x0e090e05,
		0x06309a86, 0x0f130006, 0x0012090f, 0x4110790e, 0x08790509, 0xed219985, 0x58988232, 0x48520579, 0x30312205, 0x22888301, 0x82352115, 0x21280897,
		0xbf012135, 0x4d524f20, 0xfe33011d, 0x4e4b216f, 0xe5fe234d, 0x28027a01, 0x8483782c, 0x3d434637, 0x33767d7f, 0xff000046, 0x0eeb6b18, 0x330aff4c,
		0x00170003, 0xb9d00023, 0xf0ff2200, 0x0e0d1540, 0x10204c00, 0x1c290583, 0x4d000e18, 0x000d101c, 0x0a0c4d4d, 0x1340e022, 0x15271082, 0x4d001020,
		0x820f1015, 0x08182804, 0xb8114d00, 0x82b3e8ff, 0x21078211, 0x1482b3f0, 0x17820784, 0xffb80b23, 0x821783f0, 0x83e82007, 0x22078217, 0x823b40f0,
		0x08072118, 0x07212d82, 0x212a8218, 0x0e821007, 0x014f2708, 0x4002015f, 0x02005000, 0x00010001, 0x0e761e18, 0x04761825, 0x48100b40, 0x79032404,
		0x1b090000, 0x2146137c, 0x3b4d097c, 0x08176c0e, 0x7c465d20, 0x06355d0c, 0x15331329, 0x3e342723, 0x69323302, 0x2324053b, 0x37022e22, 0x2b0a1048,
		0x929898af, 0x32513a20, 0x213a5231, 0x11faef18, 0x22475b22, 0x0e3ef118, 0x827a5324, 0x03827a82, 0x5b000021, 0x00350fdf, 0x00400001, 0x02d00100,
		0x001a006b, 0x05384063, 0x151a0a05, 0x06d5411a, 0x0a050b23, 0x08e37505, 0x151c0a24, 0x225e7310, 0x151b3208, 0x12050510, 0x44124113, 0x1a440a0b,
		0x3f004100, 0x058f7432, 0x332f192b, 0x10180133, 0xed5d5ed6, 0x14c17232, 0x07030e22, 0x08092671, 0x3e11333a, 0xbb013703, 0x3432341e, 0x3f421e1f,
		0x165d1538, 0x1f3e3a34, 0x391c5252, 0x02132e34, 0x444d326b, 0x471b223e, 0x2e325f55, 0x173f4e58, 0x6b02d6fe, 0x4620ecfe, 0x00214647, 0x01200082,
		0x08083743, 0x4a00162c, 0x0a102740, 0x0b780a05, 0x0b0b1410, 0x05001110, 0x11167800, 0x11161614, 0x160b0505, 0x00170b18, 0x05114416, 0x0b0a4110,
		0xa8820044, 0x4305ea54, 0x21231633, 0x5427032e, 0xaa8207c3, 0x92012108, 0x232b2f14, 0x2c240908, 0x1754142f, 0x1e322d2c, 0x31361a66, 0xb265102b,
		0x1918658f, 0x62b19067, 0x24093d43, 0x00010000, 0x36048222, 0x006b02d3, 0x4099001a, 0x0f280123, 0x20014d00, 0x4c000e0d, 0x830c1801, 0x820b200a,
		0x0d0e2604, 0x01007b0e, 0x26288214, 0xb81a080d, 0x82b3d8ff, 0x22078224, 0x820cb4e8, 0x22088227, 0x822b40e0, 0x0f250826, 0x7e1a001a, 0x10140f10,
		0x15000f10, 0x07027308, 0x7315101c, 0x101b1619, 0x000e411a, 0x16150f0f, 0x44070844, 0x05c4550d, 0x333f3322, 0x200cc055, 0x0d9454de, 0x44331121,
		0x01210611, 0x2400822b, 0x13133031, 0x06844133, 0x0323033c, 0x07020e14, 0x37123623, 0x5b5bfa33, 0x08080a06, 0x02024f03, 0x55020303, 0x06825752,
		0x4f012108, 0x5b0e0e06, 0x34013701, 0xaaa1923b, 0x8a823653, 0xdbfe418d, 0x8d412501, 0xa136828a, 0x009b2f01, 0x0021c582, 0x20048237, 0x08f382be,
		0x4e001144, 0x001a3040, 0x01000d01, 0x04010926, 0x02091409, 0x00050009, 0x14090e7e, 0x730e090e, 0x73051311, 0x01010710, 0x12070107, 0x0905410f,
		0x0e440741, 0x3f004400, 0x333f3f32, 0xd610013f, 0x10ed5d5d, 0x3169fdde, 0x825d2005, 0x30312800, 0x27032e21, 0x83112311, 0x112808ad, 0x6b011133,
		0x463c3111, 0x1f534b25, 0x0f354046, 0x7f6d2a4b, 0x12fe4a8e, 0x83366b02, 0x012b7984, 0x0095fde1, 0x25000300, 0xcf208b82, 0x21088b82, 0x00070003,
		0x4033000b, 0x000a0a19, 0x0b0d0500, 0x0401010b, 0x08790b0c, 0x79040208, 0x79014407, 0xce504102, 0x32c6220a, 0x05a7442f, 0x312f322c, 0x35210130,
		0x15210121, 0x03821321, 0xfec70139, 0xfe990167, 0xfeaa015e, 0x4a013056, 0x2402b6fe, 0x47dcfd47, 0x4f496901, 0x022508af, 0x00060279, 0x0da74432,
		0x00d20227, 0x00020000, 0x368b8249, 0x007102c7, 0x001d000e, 0x1b154087, 0x4d001018, 0x000f101b, 0x8218174d, 0x28162104, 0x04200e82, 0x82063f64,
		0xb3f02407, 0x824d0009, 0xb3e02507, 0x024d0008, 0x12201783, 0xf0220784, 0x078511b3, 0x0a09b424, 0x18824c00, 0x1b40e022, 0x19352182, 0x131f0376,
		0x09007307, 0x1e090801, 0x13137907, 0x0f440900, 0x0645187c, 0x01ed2108, 0x65068543, 0x2b20091d, 0x13220083, 0x46481632, 0x11232105, 0x08e74418,
		0x24054a48, 0x7a726aeb, 0xde44186a, 0x36213f0a, 0x24161627, 0x6371022f, 0xe65b6b62, 0x07046102, 0x02470203, 0x1e0cfa02, 0x31242631, 0xe2820c1c,
		0x01002408, 0x00002800, 0x6b02bf01, 0x59001500, 0x0a0a2f40, 0x11001107, 0x140a0d78, 0x100a0d0d, 0x03170410, 0x770a070a, 0x0d310626, 0x0a16070d,
		0x0300000a, 0x0e79110d, 0x79030741, 0x07254606, 0x19391126, 0x1801332f, 0x200de169, 0x05ed69ce, 0xc47d0833, 0x06013031, 0x15210706, 0x36363521,
		0x27262637, 0x080a8235, 0x01031e2b, 0x2a6a3145, 0x69fe3f01, 0x34366a22, 0x89011e63, 0x260ddcfe, 0x4201322e, 0x463c8040, 0x45843741, 0x372d8145,
		0x3c341346, 0x21a78541, 0xe7440024, 0x00073005, 0x010f4020, 0x04067303, 0x02080904, 0x49077905, 0xd36d0698, 0x09464a08, 0xadd00130, 0x6b02ad52,
		0x02dbfd46, 0xff004625, 0x6b6d00ff, 0x200f820c, 0x2653822a, 0x029302d4, 0x82d70206, 0x00012264, 0x080f8216, 0x6b02d833, 0x55001500, 0x0c0f2d40,
		0x09100809, 0x08117810, 0x11081114, 0x0e001511, 0x0d780e15, 0x0d0d1400, 0x0d171500, 0x1116090d, 0x0d0e4110, 0x44080941, 0x05044315, 0x200a906b,
		0x0f8e6bce, 0xc40e1023, 0x050e43c4, 0x360f906b, 0x1e0b7d01, 0x23152722, 0x215a1e45, 0x5ba23259, 0xa459817a, 0x6b235a30, 0x4f29098a, 0xeded2501,
		0xa84edffe, 0x20a38454, 0x20a3822b, 0x2ea382c9, 0xb976001b, 0xe8ff1900, 0x001413b4, 0x4ab8194c, 0x078205ef, 0x11b3e822, 0x21056f60, 0x078410b3,
		0x2c40e827, 0x044d000f, 0x08268310, 0x11200422, 0x1b4c0012, 0x0e02730f, 0x7313070e, 0x730a1d16, 0x021b1c07, 0x0e0d1079, 0x14010e0d, 0x44014108,
		0x22054768, 0x662f2f39, 0xed250596, 0x11edde10, 0x460c8339, 0x212208e8, 0xd45b3523, 0x14152905, 0x33353316, 0x35363215, 0x28080582, 0x23020e14,
		0x2f4a1f01, 0x52122841, 0x314a3127, 0x28125227, 0x249e2f41, 0xd1395d42, 0xf75465ce, 0xce6554f7, 0x425d39d1, 0x21be8224, 0x04821200, 0x7902e232,
		0x98002b00, 0xff2100b9, 0x0d0940e8, 0x181d4d00, 0x11200482, 0x2007b863, 0x2708820b, 0x100e5140, 0x18074c00, 0x072ac882, 0x4d000f10, 0x000e1807,
		0x0e83014d, 0x0e830120, 0x6f113008, 0xaf157f15, 0x0415bf15, 0x761a1515, 0x0e12120e, 0x2960012d, 0x29a02970, 0x290429b0, 0x04762429, 0x2c040000,
		0x2a790129, 0x79111544, 0x471f4414, 0x322107c6, 0x07d9483f, 0x2f32ed29, 0xce10335d, 0x84102f32, 0x23e38809, 0x33372b2b, 0x2b0bff70, 0x15330706,
		0x033e3523, 0x022e3435, 0x26051f71, 0x1517021e, 0x186d1223, 0x301ea3e7, 0x4a953d46, 0x2e4c6637, 0x37664c2e, 0x463d954a, 0xa2e7183c, 0x00023413,
		0x01f6ff31, 0x00da01d7, 0x002b0019, 0x2a00b967, 0x82b3f0ff, 0xb82523e9, 0x0786e0ff, 0x3440f028, 0x184d000d, 0x04821010, 0x000f1824, 0x8218124d,
		0x12390843, 0x4d000818, 0x047f200d, 0x2d040909, 0x2c158227, 0x5110881a, 0x510a8809, 0x06bc6424, 0xd151ed20, 0x05344f05, 0x2005a06a, 0x2500832b,
		0x17163201, 0xc6821411, 0x26260723, 0x070c4f27, 0x13023e25, 0x82373632, 0x263526f9, 0x06222326, 0x081f8215, 0x300d014e, 0x09031757, 0x1d0d0e12,
		0x41141124, 0x314a302d, 0x52391f1a, 0x0d342022, 0x2a070203, 0x0d4b3f18, 0xda012d1d, 0xd4fe0813, 0x0c131d16, 0x12064604, 0x241e1116, 0x38355840,
		0xfe223f5a, 0x0d0b1764, 0x03f10f1b, 0x24515b08, 0x001a2e3d, 0x022f0082, 0x5bff4700, 0xb502cc01, 0x33001b00, 0x82b9b100, 0xb3e825fe, 0x314d0012,
		0x4026ef82, 0x4d001113, 0x0d82102b, 0x82182b21, 0x20212109, 0x1720ec82, 0x7306cb49, 0xe8260a32, 0x000a08b4, 0x1882114c, 0x0f0eb422, 0x210eec74,
		0xe474000a, 0x082e2605, 0x044c0009, 0x08288310, 0x0f292925, 0x0c0c822d, 0x35148224, 0x007f1b1c, 0x01080101, 0x86280f34, 0x1f072929, 0x30511988,
		0x014d0788, 0x573f004b, 0x3920071d, 0x23097945, 0x32ed2f33, 0x200be251, 0x2200832b, 0x49112317, 0x781808dc, 0xe37609b4, 0x23262109, 0x0aca6718,
		0x9a157908, 0x41311d53, 0x2d3c2324, 0x252e301a, 0x230f2135, 0x3d244738, 0x1931142f, 0x15232e19, 0x07064e47, 0x262d3d2d, 0x02a5342c, 0x31493197,
		0x402c1618, 0x134b292b, 0x3a31270a, 0x314f381d, 0x114b1c17, 0x3220100f, 0x444f4522, 0x34333635, 0x0000413f, 0x1d000100, 0xd4015bff, 0x1500d001,
		0x19403300, 0x0f00030c, 0x15101082, 0x17078206, 0x16158200, 0x100c0c03, 0x10491506, 0x3324d183, 0x33113912, 0xc643ce82, 0x11ed2a06, 0x30313939,
		0x17161613, 0x4f441836, 0x232e0808, 0x7927032e, 0x39184124, 0x0a521142, 0x2a423121, 0x50020a08, 0x39362905, 0x5cd00116, 0xc2645bbe, 0x7b6f2b4f,
		0x502a3f82, 0xa6b45725, 0x7f823490, 0x18000221, 0x30099f57, 0x40a7003a, 0x0b103a0b, 0x10394d00, 0x284d000c, 0x058e4bb8, 0xf0280782, 0x000f3440,
		0x0e18164d, 0x10210482, 0x3d04820d, 0x000c0b20, 0x1138134c, 0x124c0012, 0x4d001108, 0x0d0c1810, 0x20104c00, 0x0a4d000b, 0x04821018, 0x780f1021,
		0xb320059f, 0x06250c82, 0x40f0ffb8, 0x3d108223, 0x820d1b1b, 0x26123c2e, 0x03151582, 0x123b3882, 0x00008829, 0x18000001, 0x51338808, 0x57188921,
		0x2f290896, 0x0132ed5d, 0x33edd610, 0xa748182f, 0x852b2010, 0x06132100, 0x14935718, 0x07171624, 0xd243032e, 0x17162105, 0x1f905718, 0x1149312f,
		0x1f150512, 0x1f0c1626, 0x282f131d, 0x8e571824, 0x183e3021, 0x09034008, 0x0b03070a, 0x25181215, 0x1831181c, 0x3c0e8d57, 0xff450001, 0x01d201f5,
		0x003500dc, 0x34354056, 0x000d0b18, 0x0a20344c, 0x10294d00, 0x8304820b, 0x14143c09, 0x2e372305, 0x3333820e, 0x2b00821b, 0x362b0801, 0x1486152e,
		0x881d0014, 0x430b5126, 0x112307e5, 0x42ed2f39, 0x332506b8, 0x1032ed2f, 0x08b742ce, 0x1e320123, 0x41e48502, 0x33210500, 0x24ee8515, 0x023e3233,
		0x0a065337, 0x032e7f08, 0x01363435, 0x272e1721, 0x050d071e, 0x132a251b, 0x1d124435, 0x5a591224, 0x14202a17, 0x2a341b83, 0x1116081f, 0x49214966,
		0x252c273c, 0x0d13160a, 0x04dc016e, 0x47030807, 0x06070802, 0x1a15231e, 0x0742050e, 0x49151d12, 0x040b0a07, 0x0b190946, 0x242c371f, 0x1004103e,
		0x43152119, 0x01000042, 0x58ff3f00, 0xaf02bf01, 0x8d002c00, 0xff2b00b9, 0x0e0bb4e8, 0xb8274c00, 0x10b3d0ff, 0x07824d00, 0x0fb3e022, 0xf02a0784,
		0x4d000eb3, 0xf8ffb823, 0x078412b3, 0x3840f027, 0x184d0011, 0x20048210, 0x2b048317, 0x000a1810, 0x0928104d, 0x201a4d00, 0x33082182, 0x041e1e1a,
		0x00038209, 0x1382252e, 0x2d131b1b, 0x0e0e8928, 0x851a1e2d, 0x4b034d1d, 0xed3f3f00, 0x2f331132, 0xc61001ed, 0xed102f32, 0xed32de10, 0x332f3332,
		0x27090561, 0x052b2b2b, 0x27070614, 0x0805dd45, 0x032e276b, 0x043e3435, 0x21352337, 0x15050e15, 0x1e171614, 0x1bbf0103, 0x0b044810, 0x1d0e080b,
		0x4630202d, 0x2d1b152c, 0x14373a38, 0x155601eb, 0x313d3f3b, 0x2c4a421e, 0x2f11253d, 0x16173f23, 0x1b191506, 0x0e140f0c, 0x1e08050b, 0x2c2e4430,
		0x3d474f55, 0x41461231, 0x493e3312, 0x412a544f, 0x15070b3b, 0x0000281e, 0xff470001, 0xd300195b, 0xa6340884, 0x0c1f382d, 0x78fe0405, 0x31000300,
		0xc301f2ff, 0x1300b502, 0x29001e00, 0x0b40bb00, 0x000e1828, 0x0d10284d, 0xb8214d00, 0x0db4f0ff, 0x1d4c000e, 0xb3e8ffb8, 0x07821582, 0x82b3f021,
		0x181c2018, 0x210a4758, 0xa1411540, 0x00122405, 0x8310164c, 0x1812212c, 0x2606934f, 0x000e0940, 0x82100c4d, 0x830c200d, 0x200c822f, 0x21478208,
		0x10820e40, 0x82100821, 0x8303200d, 0x82022068, 0x1f40211a, 0x253b1282, 0x2b058219, 0x0f821a24, 0x020f1f0f, 0x851a2a0f, 0x14002424, 0x1f510a88,
		0x4b4d0088, 0xd6200af5, 0x14c55618, 0x254b2b20, 0x097a4f05, 0x3e343539, 0x3e321302, 0x1e233702, 0x0e221303, 0x2e330702, 0x4c32fa03, 0x82191932,
		0x2a078704, 0x0e1c2b1e, 0x0e01eb02, 0x821e2c1d, 0x020f320a, 0x1c0f02eb, 0x31b5022b, 0x5252835c, 0x31315b83, 0x3607835b, 0x84fd315c, 0x3a5e4324,
		0x24435e3a, 0x3f223502, 0x59373759, 0x8200223f, 0x00013f00, 0x01f5ff36, 0x00d001c2, 0x40230015, 0x097f0c11, 0x17000a09, 0x8509160a, 0x8812490c,
		0xb5845103, 0x2406e651, 0x3031ed2f, 0x06714725, 0x35233525, 0x73141133, 0x22080570, 0x3c1cc201, 0x2238281c, 0x08d88610, 0x0e171e12, 0x0e0f1734,
		0x442b130c, 0xfe45e331, 0x1a2e24e5, 0x180c0a0a, 0x3912176d, 0x0100001d, 0x00b502d4, 0xb98a0024, 0xe0ff1d00, 0x4d000ab3, 0xd0ffb81c, 0x08824d40,
		0x08065363, 0x09081041, 0x180e4c00, 0x0e4d000e, 0x81080308, 0x09140e09, 0x001f0e09, 0x24810003, 0x2424141f, 0x0920031f, 0x03034d00, 0x17262409,
		0x00250917, 0xa01f4a24, 0xc003b003, 0x0e030303, 0x1a89130e, 0x7d09084d, 0x32260519, 0x335d3311, 0x4a43333f, 0x11ce2505, 0x2b2f3d39, 0x210fb152,
		0x00832b01, 0x15632120, 0x033e3206, 0x23032e37, 0x27070622, 0x32333636, 0x1e17021e, 0x84051903, 0x0f450810, 0x151e1919, 0x0c05110d, 0x1e162005,
		0x0b1b222d, 0x2b343c21, 0x5bc65b10, 0x5d65672f, 0x7c763224, 0x3a27377c, 0x02031326, 0x12050242, 0x4d1b2c20, 0x3b889399, 0xff000000, 0xff4700ff,
		0x01ad015b, 0x000602d0, 0x240f8490, 0x0100001e, 0x200f84d6, 0x36208259, 0xff400001, 0x02c30158, 0x003a00b5, 0x3a00b9d2, 0x0fb3e0ff, 0x423a4d00,
		0x362306bf, 0x83d0ffb8, 0x2407820f, 0x000eb3d8, 0x3b07824d, 0x000db3f8, 0xffb8354d, 0x0f3440d8, 0x101d4d00, 0x1c4d0010, 0x00121020, 0x09101c4c,
		0x08250a83, 0x28184d00, 0x2b048212, 0x00111020, 0x1018114c, 0x28104d00, 0x18210483, 0x05d84d08, 0x4883f020, 0xb8023d08, 0x2d40e0ff, 0x314d000d,
		0x22220331, 0x3c03820c, 0x1a822b17, 0x0082381a, 0x12080112, 0x8532173b, 0x001f3131, 0x3b0f0f89, 0x88262323, 0x06074d1f, 0x333f004b, 0x2f32ed3f,
		0xed2f3311, 0x220fc745, 0x1833edde, 0x26133ea4, 0x252b2b2b, 0x44151616, 0x262107b7, 0x05ad4a27, 0x06853720, 0x240a357d, 0x021e1415, 0x07f24533,
		0x01163308, 0x1b445629, 0x0b044711, 0x3d36080b, 0x291c605f, 0x3433132f, 0x2c4d3920, 0x0e0e412d, 0x2424350f, 0x180f2032, 0x44213a2a, 0x3f42173c,
		0x0f4d4c2c, 0xd5443538, 0x1e250808, 0x5a0f0b18, 0x2a3b2752, 0x5310071b, 0x2d422c2e, 0x47050d16, 0x1d110d05, 0x2a1c1627, 0x0b460d1b, 0x382b361e,
		0xc7721835, 0x01cc2608, 0x000602db, 0x220f8452, 0x41000047, 0x022105a7, 0x09ff49f2, 0x00da012a, 0x001f0010, 0x1d00b9a2, 0x2805ab53, 0xe8ffb81d,
		0x000f1d40, 0x05674f4d, 0x09822020, 0x10181625, 0x84164d00, 0x0e082509, 0xb80f4d00, 0x0a202982, 0xe8220784, 0x078409b3, 0x53b3e021, 0xe02005ed,
		0x0b200f83, 0x2f204183, 0x08311082, 0x00121110, 0x0a10084c, 0x20084d00, 0x074d0008, 0x392d8218, 0x210c8219, 0x007f1f03, 0x06080106, 0x09881c20,
		0x144b0550, 0x00510088, 0x5318ed3f, 0xd1530c49, 0x22052711, 0x23152726, 0x6a733411, 0x020e2205, 0xcd401827, 0x26370807, 0x15062223, 0x3b230801,
		0x59605211, 0x331a6963, 0x36189d49, 0x1e2e1f17, 0x323f360e, 0x0b160b37, 0x67a901bb, 0x34777c6f, 0x6c254059, 0x2e1a1014, 0x5b51243e, 0x4700514c,
		0x0132080b, 0x002600dc, 0x2500b97a, 0x0db3e8ff, 0xb8204d00, 0x0786e0ff, 0x1e40e836, 0x174d000c, 0x4d000e10, 0x100e1012, 0x20114c00, 0x114d000e,
		0x1121c783, 0x45d18210, 0x1b38082b, 0x03820c1b, 0x00822228, 0x14080114, 0x0f890027, 0x1c1c270f, 0x5019881f, 0x290d5742, 0x5ed61001, 0xde10ed5d,
		0xb15c33ed, 0x0e43420a, 0x35032e29, 0x33023e34, 0x4b071732, 0x392209fd, 0xfc463b4b, 0x2e293806, 0x1532533e, 0x3e5e3f1f, 0x14123b48, 0x5a551f36,
		0x483c2e1a, 0x4233360e, 0x25080821, 0x0b08191a, 0x2f4a3826, 0x27445932, 0x0c084516, 0x392e4e60, 0x02001121, 0xf4ff2800, 0xd001d901, 0x27001400,
		0x3969c500, 0x20cc8205, 0x85ed8321, 0x88f02007, 0x873b20f5, 0x101027f5, 0x104d0010, 0x04820f20, 0xef820820, 0x82180f21, 0x100f210e, 0x0b200e82,
		0x0b200983, 0x0a201883, 0x0a202283, 0x22820985, 0x4f830620, 0x20063b4a, 0x054b4ab3, 0x82b3e021, 0x4c052017, 0x0782063f, 0x9974e820, 0x40e82206,
		0x37678217, 0x1403821a, 0x23290314, 0x00280d82, 0x4912851e, 0x51088815, 0x3fed3f00, 0x4e054a4a, 0x0d420516, 0x832b2011, 0x16012200, 0x05637016,
		0x35022e26, 0x33023e34, 0x07996018, 0x49272621, 0x4308055c, 0x7b01021e, 0x361d2123, 0x4a262d4b, 0x41262339, 0xe5c72f54, 0x101e2c1d, 0x15122525,
		0x131e2c33, 0x8b012b21, 0x302d5e2b, 0x1d223c53, 0x423b5739, 0x451b3a5d, 0x2a19b3fe, 0x60301f37, 0x45260d24, 0x273c2837, 0x20052f5c, 0x0657463f,
		0x00162108, 0x051e4036, 0x000c0b18, 0x087f0d4c, 0x00000908, 0x0900180c, 0x17090801, 0x0a85080d, 0x02881349, 0xc622bb88, 0xbc835d5e, 0x23069b72,
		0x22230625, 0x3525a582, 0x15213523, 0x08d71823, 0xc2550808, 0x3f2a3f3b, 0x01621529, 0x160abb6f, 0x2e1f1a25, 0x111a0f17, 0xdc37482a, 0x23d64545,
		0x0b0b1b2d, 0x0001000b, 0x01f6ff47, 0x00d001ab, 0x403c0015, 0x12280c0b, 0x200c4d00, 0x0a4d0011, 0x40d8ffb8, 0x00121117, 0x117f0e4c, 0x007f0817,
		0x05080105, 0x49060f16, 0x064e430b, 0x6d423320, 0x30312508, 0x172b2b2b, 0x11227f83, 0x02571133, 0x08088305, 0xf9020e25, 0x0f284536, 0x302f3053,
		0x280f5230, 0x3c240a45, 0x0701274c, 0x414efdfe, 0x03014e41, 0x4c27f9fe, 0x8200243c, 0x00033300, 0x015bff1a, 0x00d801da, 0x000d0006, 0xb9940024,
		0x2d442200, 0x64222005, 0x07840627, 0x4d000923, 0x06fd4121, 0xd8280782, 0x000a0e40, 0x1020124d, 0x99780482, 0xb3d82506, 0x054d000e, 0x20065e43,
		0x45bf8202, 0xe83e06a9, 0x000d1f40, 0x7f24074d, 0x15101003, 0x261f820a, 0x25158200, 0x1a88040d, 0x88030750, 0x71181024, 0x1342092b, 0x100d5106,
		0x2b28de82, 0x17161437, 0x17060611, 0x0e257118, 0x2007fe57, 0x23711807, 0x3d23290e, 0x512e2f52, 0x341e233d, 0x18227118, 0x3c5a3c24, 0x04821e1e,
		0x3c573735, 0x00000120, 0x00ffff00, 0x0100001d, 0x02d001d8, 0x825b0006, 0x00012910, 0x015bff25, 0x00d001ce, 0x29080752, 0x4c00100f, 0xe8ffb819,
		0xd1820a40, 0x11101124, 0x2f6b0012, 0x00122305, 0x16820a4d, 0xb841b320, 0xb3e82105, 0x08051f4f, 0x1f40e028, 0x0c4d0009, 0x1b0f7f00, 0x7f04141b,
		0x7f171d07, 0x1b1b1c14, 0x01491505, 0x0f0c881a, 0x004b0e51, 0xed333f3f, 0x70183f32, 0x07520912, 0x1101210e, 0xf951ef82, 0x05177605, 0x0c833520,
		0x17162f08, 0x311e0111, 0x2b14522d, 0x2f492e43, 0x52142b42, 0x6501322c, 0x5704d7fe, 0x34e6da5f, 0x02264058, 0x26029b9b, 0xe6335841, 0x04575fda,
		0xcb842901, 0xf7ff2435, 0xda01d201, 0x83003400, 0xff3300b9, 0x0d0cb4f0, 0x84334c00, 0x000b23cb, 0xcb84294d, 0xffb81225, 0x453f40f0, 0x0c2405d6,
		0x18084d00, 0x03351982, 0x1d1d7f1e, 0x1f2a0f0b, 0xbf2aaf2a, 0x2a2a042a, 0x36308225, 0x38fb8200, 0x11b011a0, 0x16111104, 0x2b350b82, 0x101d1d10,
		0x19032250, 0x51060088, 0x82d28300, 0x4f2f20d3, 0x32250515, 0xde105d2f, 0x820582ed, 0x18ed20da, 0x21089c44, 0x10512205, 0x1737240b, 0x4215030e,
		0xdf8405b9, 0x36323328, 0x022e3435, 0x2c4e3727, 0x01430805, 0x10301b56, 0x231a3110, 0x0d0d1d2f, 0x4a142017, 0x0a151d14, 0x1d171913, 0x19171d4a,
		0x1e150a13, 0x21134a13, 0x1d0d0d17, 0x25220930, 0x351f2225, 0x53272747, 0x1a18424d, 0x4a49441b, 0x413f3020, 0x8257573f, 0x20303204, 0x1b44494a,
		0x4d42181a, 0x47272753, 0x00001f35, 0x08935d00, 0xe76b7920, 0xffd72208, 0x2d18823e, 0x0200b90d, 0x19b44fff, 0x500f0417, 0x2782342b, 0x00bcff2d,
		0x02cc0100, 0x03370279, 0x82eefed7, 0x00062221, 0x213f8328, 0x178288ff, 0x1782c720, 0x2b002622, 0x07200982, 0xba201d82, 0x01273f85, 0x0eb4cbfe,
		0x8601070c, 0x82b6203f, 0x849b201d, 0x862c2027, 0x87e82027, 0xb4f92527, 0x02040c0e, 0x00212785, 0x221d8259, 0x821a039b, 0x2127848f, 0x25828300,
		0x29658b20, 0xbf901805, 0xffff2415, 0x6bffb8ff, 0x9b83057b, 0x9b84ea20, 0x9b843220, 0x4b827e20, 0xb386e820, 0x1784b020, 0x17833c20, 0x830d0021,
		0x82638417, 0x0701210f, 0x132b638c, 0x500c0425, 0x4f1d0402, 0x65110401, 0xff200a5b, 0xe220bf83, 0x26224b82, 0xbf91a803, 0x002c2e23, 0x2abf8612,
		0x01f6ff31, 0x02bb02d7, 0x82a90326, 0x03063227, 0x00001ed6, 0x020b4010, 0x142c2e10, 0x00025009, 0x06a7662d, 0xf5ff4524, 0x2784d201, 0x2785ad20,
		0x27842b20, 0x38160129, 0x50232a36, 0x86370001, 0xff472427, 0x84b0015b, 0x85af2027, 0x85162027, 0x16112827, 0x50050014, 0x86150201, 0x82362027,
		0x84c2204f, 0x85b12027, 0x85092027, 0x18032827, 0x50000a16, 0x8c170b01, 0x828f2027, 0x2f27849f, 0x00dd8300, 0x02b11a00, 0xdbffb801, 0x2a180d40,
		0x02262b82, 0x014f220b, 0xa767160b, 0x8426200a, 0x87b9205b, 0xd8032733, 0x210000e6, 0x348503b2, 0x22281122, 0x03263482, 0x024f260b, 0x38821a0b,
		0x2b256883, 0x3434342b, 0x09a74900, 0x00219783, 0x29bf8b52, 0x20221202, 0x02500009, 0xe788210e, 0xab01f623, 0x20978302, 0x0dbb66bd, 0x2a180127,
		0x02501004, 0x20948206, 0x21948706, 0x3746ffff, 0x84ef8405, 0xd603212f, 0x22061741, 0x82161813, 0x0601212e, 0x4721ef87, 0x835783ff, 0x262785bb,
		0x000009d8, 0x8215401e, 0x280122bc, 0x21298222, 0xb8820603, 0xb8820620, 0xb8863184, 0x24225f82, 0x9f41f7ff, 0x85c12006, 0x411920b7, 0x4308054f,
		0x0a353714, 0x1001502f, 0x2b2b4f36, 0x00010034, 0x010102a4, 0x00bb0249, 0x401b0003, 0x01000309, 0x80030002, 0x2f000102, 0x32cd1a33, 0xc5192f01,
		0xc519dd18, 0x07013031, 0x49013727, 0x02653174, 0x98228e8f, 0x00275082, 0x01b701ce, 0x82790248, 0xb6122137, 0x012a3683, 0x3f004503, 0xcd2f01cd,
		0x2e86cddd, 0x3d3d4834, 0xae650229, 0x0000b30f, 0x40000300, 0xa2010402, 0x0982b902, 0x1b000f29, 0x15403000, 0x8319070d, 0x13022837, 0x40160a19,
		0x8a101004, 0x86332077, 0x82cd207d, 0x32cd2308, 0x5186dc10, 0x99181720, 0x99180a73, 0x37310c7f, 0x77502f5d, 0x151c1c15, 0xfe1c1c14, 0x1d1d14eb,
		0x29088214, 0x1c8e9202, 0x171a8e99, 0x98181b16, 0x00240bed, 0x00ffff00, 0x2005e342, 0x07e342b9, 0x82870421, 0xb91333a1, 0xf6ff0200, 0x372c0940,
		0x02500914, 0x2b4f3d00, 0x2b93342b, 0x0009c123, 0x242b8400, 0x300940ff, 0x202b843c, 0x432b8d2c, 0x0421083b, 0x6e578296, 0x2c2108ef, 0x232c823f,
		0x4f400003, 0x2b225c85, 0x8b8a3434, 0xa3203389, 0x2e21338b, 0x2033843d, 0x8333823e, 0x2b339764, 0x00002497, 0x03104017, 0x3e2c1a02, 0x3f203084,
		0xef88648a, 0xa4216389, 0x222f8612, 0x843c2e08, 0x8a3d202f, 0x212f8760, 0x1f411303, 0x88982008, 0x414b212f, 0x43202f84, 0x3c202f82, 0x24094f6a,
		0x01f6ff31, 0x202f8ad7, 0x8ac38ba5, 0x26c38b32, 0x01000006, 0x457a02eb, 0x042f07b7, 0xff4dff87, 0xb90d00c1, 0x4dff0200, 0x452217b4, 0xf52008b7,
		0xc122278e, 0x27873cff, 0x1bb43c23, 0x20278827, 0x20278445, 0x224f887c, 0x82e5fe96, 0xb10f2927, 0xfeb80203, 0x2a17b4e5, 0xd3432884, 0x58ff2105,
		0xa3222b8e, 0x2b88effe, 0x19b4ef23, 0x202b8b28, 0x222b8e78, 0x870eff97, 0x0eff242b, 0x8b2917b4, 0x8e62202b, 0xffa4222b, 0x222b8802, 0x8519b402,
		0x208386ac, 0x202b84ae, 0x25af88b4, 0xff2bff98, 0xaf8400a1, 0xb42bff24, 0x578b2c36, 0x2b8ea420, 0x21ffa522, 0x21202b88, 0x2b552b8d, 0xb9022505,
		0xad032602, 0x06233582, 0x431b8704, 0x092805f7, 0x232a4136, 0x47000150, 0x890cbf45, 0x06d74227, 0xf7ff0126, 0x463a0940, 0x22442a84, 0xffff2105,
		0xbb205386, 0x96205388, 0x24056f42, 0x36120102, 0x23298249, 0x4f4a0002, 0x2b235885, 0x92003434, 0x05d3422f, 0xb8010228, 0x0d40efff, 0x32844738,
		0x32824820, 0xd3426083, 0x0e4f4607, 0x00970422, 0x8207d745, 0x48362133, 0x49203384, 0x6793668a, 0x2306d742, 0x38000102, 0x0220c183, 0x0121ec82,
		0x2d648700, 0xb1ffffff, 0xcc010000, 0x26027a02, 0x09822800, 0x87040724, 0x4b42f8fe, 0xfe012705, 0x170cb4de, 0x03470a00, 0xb5ff2105, 0xc122278e,
		0x2787fcfe, 0x10b4e223, 0x2027881c, 0x20278407, 0x224f887c, 0x82a7fe96, 0xb10f2127, 0xfe24e982, 0x1f0cb48e, 0xef412884, 0x8e192006, 0xfea3222b,
		0x232b88b0, 0x1d0eb497, 0x1a202b8b, 0x97202b8e, 0x0c212b8c, 0x8f2b8b1e, 0x8ca42083, 0x850e2083, 0x208385ac, 0x058b4700, 0x2602b924, 0x1b42af03,
		0x00003205, 0x00b91300, 0x40feff01, 0x001f1409, 0x02015005, 0x07cb4425, 0xc1212b8f, 0x05474209, 0x24180722, 0x14202884, 0x4415df47, 0x022806f3,
		0xffffb801, 0x27140d40, 0x02232b82, 0x854f2802, 0x07eb4158, 0x200e1348, 0x091f4204, 0x16213382, 0x20338425, 0x83338226, 0x42339763, 0x3382091f,
		0x84261421, 0x9e272033, 0x081f4267, 0x24161022, 0x25203084, 0xff20648a, 0x22052b53, 0x411303b0, 0x9820081f, 0x82088342, 0x29332163, 0x2b203284,
		0x24203282, 0x840a5b48, 0x44338acb, 0xff8605fb, 0xcb8a338a, 0x0083ff28, 0x02c70100, 0x734a027a, 0x87042306, 0x5f42cafe, 0xb4ca2307, 0x734a170c,
		0x059b4a08, 0xc1222789, 0x2787cffe, 0x10b4cf23, 0x2127871c, 0x4f84d9fe, 0x4f887c20, 0x79fe9622, 0x23085b42, 0x1f0cb479, 0x03422884, 0xeafe2105,
		0xa3222b8e, 0x2b8881fe, 0x0eb48123, 0x202b8b1d, 0x222b8eec, 0x8882fe97, 0xb482232b, 0x2b8b1e0c, 0xa420838f, 0x0e20838c, 0x8385ac85, 0x841aff21,
		0x88b42057, 0xfe9825af, 0x00a1ff97, 0x23053743, 0x212bb497, 0x2b90578a, 0x2b99a520, 0x21055f56, 0xe749b902, 0x87042207, 0x06df42dd, 0x0940db2a,
		0x000a2116, 0x270b0150, 0x4a07df42, 0x2b89056f, 0x86e6c121, 0x40e4242b, 0x84261a09, 0x8d16202b, 0x88bb202b, 0x82962057, 0x05734a2b, 0x0d40e424,
		0x2c822916, 0x2a0b0222, 0x210b3071, 0x8b86ffff, 0xa3203389, 0x1821338b, 0x20338427, 0x0ea74a28, 0x220e034b, 0x45f89704, 0xf6200703, 0x28206782,
		0x29203384, 0xa420679e, 0x2308b772, 0x180d40ed, 0x0220c883, 0x0f4bf482, 0x2167840d, 0xcf881303, 0x9b8b9820, 0x842b3521, 0x722d2067, 0xcf870b64,
		0xa520338a, 0x774b3396, 0xb0ff270a, 0x9b010000, 0x0b4d7a02, 0x87042307, 0xbf42f7fe, 0xb4f72307, 0x334d170c, 0xb4ff2107, 0xc122278e, 0x2787fbfe,
		0x10b4fb23, 0x2027881c, 0x20278406, 0x224f887c, 0x42a6fe96, 0xa623088f, 0x841f0cb4, 0x06634228, 0x2b8e1820, 0xaffea322, 0xaf232b88, 0x8b1d0eb4,
		0x8e19202b, 0x8c97202b, 0x1e0c212b, 0x838f2b8b, 0x838ca420, 0xac850e20, 0x48208386, 0xb4205784, 0x9822af88, 0xe742c5fe, 0xb4c52308, 0x578b212b,
		0xa5202b8f, 0x00272b99, 0x01f5ff28, 0x82b902cc, 0x45522057, 0x102c08c7, 0x00020b40, 0x00092b20, 0x310e0250, 0x8f069b45, 0x06c34527, 0x24080223,
		0x20278430, 0x20278c20, 0x214f88bb, 0x1f4a0096, 0x20002206, 0x23288233, 0x4f340e03, 0xdf475485, 0x89578506, 0x88a3202f, 0x3122212f, 0x32202f84,
		0xfd772f82, 0xffff2107, 0x2f89af86, 0x2f889720, 0x84322021, 0x9d33202f, 0x08af4a5f, 0x30221222, 0x31202f84, 0xff275f8c, 0x01f3ffa2, 0x827a02d8,
		0x473220bf, 0xe92006d7, 0x27053f42, 0xb4e8fe02, 0x09002b20, 0x2006d747, 0x22278e86, 0x87cdfec1, 0xb4cc2327, 0x27873024, 0x84d6fe21, 0x887c2027,
		0xfe96224f, 0x081f4a76, 0x20b47623, 0x41288433, 0xfe2105e3, 0x222b8ee8, 0x887ffea3, 0xb47f232b, 0x2b8a3122, 0x8e19ff21, 0x0767422b, 0xb8020327,
		0x20b4affe, 0x202b8b32, 0x222b8e04, 0x88a4fea4, 0xb4a42257, 0x47ac8522, 0x234e08d7, 0x8704220c, 0x05ab4700, 0x21160028, 0x01501004, 0xa34e2706,
		0x084b4e0c, 0x0f420420, 0x09012306, 0x2784261a, 0x278c1620, 0x2602bb29, 0x0000bd03, 0x42040601, 0x0224060f, 0x29160101, 0x02232882, 0x854f2a06,
		0x060f4254, 0x8905a34e, 0x060f422f, 0x18212f82, 0x202f8427, 0x4e2f8228, 0x042019fb, 0x82060f42, 0x2816212f, 0x29202f84, 0xc7475f9d, 0x18132108,
		0x0220b883, 0x0120e082, 0x21105b4f, 0xbf881303, 0x6f429820, 0x215f8205, 0x5f842b35, 0x5f822d20, 0x20074177, 0x068b4fff, 0xa5202f8a, 0xbf892f93,
		0x0085ff2b, 0x02e80100, 0x0026027a, 0x2409823c, 0xfec10407, 0x054742cc, 0xcbfe0127, 0x042115b4, 0x056f420c, 0x82f3fe21, 0x02e8221d, 0x2227887c,
		0x448afea3, 0x8a230883, 0x842213b4, 0x05c34128, 0x8ec4fe21, 0xfea4222b, 0x222b8864, 0x8513b464, 0x202b8654, 0x202b84ff, 0x225788b4, 0x447cfea5,
		0x7c230857, 0x8a2630b4, 0x50002057, 0xb9240507, 0xc1032602, 0x2f082b44, 0x0100b913, 0x0940ffff, 0x2f0a4035, 0x46100150, 0x8f07e746, 0x08f3492b,
		0x84453921, 0x42352028, 0x5b50061f, 0x0df3490e, 0x82483521, 0x1002232b, 0x58854f49, 0x8f07bf49, 0x0cf34933, 0x84463721, 0x82472033, 0x97638333,
		0x0cf34933, 0x84473521, 0x9e482033, 0x082b4267, 0x45371122, 0x46203084, 0x2751648a, 0x13032107, 0x49081f41, 0x54210cf3, 0x2032844a, 0x2032824c,
		0x0af34945, 0x338acb84, 0x8a0cf349, 0x27cb8a33, 0x00009fff, 0x7a02e201, 0xa8206782, 0x07240982, 0xe6fe8704, 0x23073342, 0x372cb4e6, 0x21077f53,
		0x278e84ff, 0xcbfec122, 0x21095b42, 0x27873c30, 0x84d5fe21, 0x887c2027, 0xfe96224f, 0x082f4275, 0x2cb47523, 0x4228843f, 0xe720062f, 0xa3222b8e,
		0x2b887efe, 0x2eb47e23, 0x212b8a3d, 0x2b8e17ff, 0xadfe9722, 0xad232b88, 0x8b3e2cb4, 0x8e02202b, 0xfea4222b, 0x222b88a2, 0x852eb4a2, 0x218385ac,
		0x2b8456ff, 0xaf88b420, 0xd3fe9822, 0x2308b342, 0x414bb4d3, 0x3c20578b, 0xa5222b8e, 0x2b88b9fe, 0x2b8db920, 0x2006cb51, 0x08ab50b5, 0x0004b533,
		0x00b91300, 0x40faff02, 0x142d2f09, 0x00025009, 0x0d9f512e, 0xc0282b89, 0x1000001e, 0x13020b40, 0x8314db54, 0x05434f27, 0x012c5386, 0x0940f2ff,
		0x232a3739, 0x38000150, 0xb74e5387, 0x862b8905, 0x0c012153, 0x83140755, 0x057b4d27, 0x7b825383, 0x17020128, 0x50050015, 0x7b450201, 0x015b2309,
		0x278902b0, 0x1c204f87, 0x83142f55, 0x00b12627, 0x04060100, 0x0abf4ab5, 0x0a171927, 0x0b015000, 0x0dbf4a18, 0xc0222b89, 0xf74d00f8, 0x40f62205,
		0x0b5e5509, 0x82096b7d, 0x05ef542b, 0xa7860420, 0x23030228, 0x50000921, 0x42180e02, 0x0348072f, 0x86278905, 0x1d0221a7, 0x82141755, 0x064b4627,
		0x01284f86, 0x04171904, 0x06015010, 0x0f55a484, 0x86278908, 0x1e01214f, 0x250e0f55, 0x01f7ff24, 0x278302d2, 0x4105cf44, 0x38270847, 0x502f0a36,
		0x44371001, 0x27890ca3, 0x54084741, 0x77820bff, 0x56ff3125, 0x5402d701, 0x0036060b, 0x00870426, 0x04060100, 0x00001288, 0x0203b70c, 0x14422c05,
		0x8f445009, 0x212b8f07, 0x2b8b09c1, 0x41300a22, 0x73532b90, 0x20578206, 0x2a578896, 0x0304b211, 0xf6ffb802, 0x853f2cb4, 0x0034212f, 0x2f898788,
		0x2f91a320, 0x9a3d2e21, 0x2497212f, 0x0f228b87, 0x60820940, 0x56050a54, 0xbb8509c7, 0xa4215f89, 0x542f8d12, 0x2f8e050a, 0x03540320, 0x20bf8206,
		0x202f8f98, 0x43ed864b, 0x002005df, 0x2f8a5f84, 0xbf91a520, 0xff2d3189, 0xffb9ffff, 0x02f401f7, 0x0426027a, 0x050f4586, 0x4400ff21, 0x032705e7,
		0x29b4fbfe, 0x471d0334, 0xff210543, 0x22278ea8, 0x87effec1, 0xb4ea2327, 0x2787392d, 0x84f8fe21, 0x887c2027, 0xfe96224f, 0x29278298, 0x0304b10f,
		0xb494feb8, 0x28843c29, 0xff21ab85, 0x202b8e0b, 0x06b744a3, 0x9e232b83, 0x8b3a2bb4, 0x8e2b202b, 0xfe97222b, 0x235788c1, 0x3b29b4bd, 0x16202b8b,
		0xa4222b8e, 0x2b88b6fe, 0x2bb4b222, 0x8386ac85, 0x2b846020, 0xaf88b420, 0xddfe9825, 0x8500a1ff, 0xb4d923af, 0x578b3e48, 0x2b8e5720, 0xd4fea522,
		0xd0202b88, 0x00262b8d, 0x0156ff47, 0xe35102b0, 0x09cf4206, 0x82009521, 0x0102295b, 0xb4c6ffb8, 0x05001f2f, 0x6405d242, 0x2f8d051f, 0x8806d342,
		0xb4ca232f, 0x2f91242e, 0x2351bb20, 0x09d74205, 0x11202f82, 0x23055159, 0x2733b4f3, 0x34203085, 0x2f895f89, 0x8906d742, 0xb4ee232f, 0x2f9a2531,
		0x47429720, 0x212f8b05, 0x2f9a2633, 0x8906d742, 0xb4fc222f, 0x89c08631, 0x5103208f, 0xbf8206e3, 0x5f8f9820, 0x42b4e123, 0x8a5f8f29, 0x06d7422f,
		0x2f8d5f89, 0xff83ff22, 0x2005d742, 0x06d55137, 0x82040621, 0xffff212a, 0xc125178a, 0xc1ffcafe, 0x21178600, 0x3342d9fe, 0x22278208, 0x51040701,
		0x032907bb, 0x63feb802, 0x152d1ab4, 0x08ab410d, 0x8eeafe21, 0x07bb512b, 0x6b232b83, 0x8b2b1cb4, 0x8eec202b, 0x5197202b, 0x2b8306bb, 0x1ab46c23,
		0x8f2b8b2c, 0x07bb5183, 0x1c218385, 0x212b8a2a, 0x8b421aff, 0x51af8508, 0x2b8307bb, 0x39b48123, 0x512b9b2f, 0x2b9207bb, 0xff240026, 0x02d20156,
		0x4206a74a, 0x1b2b09b7, 0xb70c0000, 0x35130102, 0x452f0a4b, 0x2b8f0887, 0x8606b342, 0x3917222b, 0x262b904a, 0x032602bb, 0x420000c1, 0x2b8209af,
		0x2306af42, 0x4835b4ff, 0x34232f85, 0x86ffff00, 0x422f8987, 0x2f8b06af, 0x9a463721, 0x06af422f, 0x47205f8c, 0xaf422f9a, 0x252f8206, 0x0309400f,
		0xa64a0102, 0x09874505, 0x0320eb84, 0x42069f4a, 0x5f8b09af, 0xef865420, 0x2f8abf89, 0x9706af42, 0x96ff212f, 0x28085f45, 0x010000bf, 0xfe870407,
		0x055f45dd, 0xd4fe0227, 0x01493eb4, 0x0687453d, 0x278e7b20, 0xc2fec122, 0xb9232787, 0x874e42b4, 0xccfe2127, 0x85087742, 0xfe96224f, 0x08b74e6c,
		0x3eb46323, 0x45288451, 0xfe210503, 0x202b8ede, 0x06c34aa3, 0x2105a342, 0x2b8a4f40, 0x8e0eff21, 0x4f97202b, 0x9b230a0f, 0x8a503eb4, 0xf9fe212b,
		0xa4222b8e, 0x838899fe, 0x40b49022, 0x8385ac85, 0x4244ff21, 0xaf8508cf, 0xc1fe9824, 0x8759a1ff, 0xb8fe2405, 0x8a535db4, 0x2aff2157, 0xa5222b8e,
		0x2b88a7fe, 0x2b8d9e20, 0xff310027, 0x02d701f6, 0x07974a9d, 0x5c610121, 0x30210a63, 0x13375c3e, 0x2b877b20, 0x8a8a0021, 0x4a2c202b, 0x562010c3,
		0xc34a5782, 0x26002406, 0x4704b504, 0xb12708c7, 0xffb80203, 0x832fb4fa, 0x1b4b1831, 0xff312108, 0x01212f82, 0x081f4bda, 0x00128829, 0x02b60a00,
		0x8230350b, 0x342b2183, 0x8d06835c, 0x1ec02153, 0x4b0bd748, 0x7b5c051d, 0x21d7880d, 0x4f828a04, 0x0b401025, 0x833e0802, 0x00022150, 0x84077b52,
		0x82ff8777, 0x492782a7, 0x2d850a57, 0x09265387, 0xeb010000, 0x0b5b2803, 0x61012107, 0x8b21ff82, 0x25558300, 0x04291b00, 0x4d18500f, 0x2b850bab,
		0x2b870620, 0x4b180020, 0x02230833, 0x84181700, 0x4f19222b, 0x21d7852b, 0x5783bfff, 0x88760221, 0xff43222b, 0x06b3421c, 0xb419ff23, 0x822d831a,
		0xffff2328, 0x278ee2ff, 0x38ff8f22, 0x6209635c, 0x5d080743, 0x09000300, 0xf401f7ff, 0x0f006b02, 0x28001d00, 0x4b408800, 0x27262400, 0x0f091e28,
		0x0e780f1e, 0x0e0e1409, 0x20210109, 0x02081e1f, 0x0378021e, 0x03031408, 0xaf031e08, 0x020ebf0e, 0x0e010e39, 0x1873150e, 0x16031d18, 0x107c1d49,
		0x440e0f46, 0x01004109, 0x23232479, 0x41081e03, 0xb37b0302, 0x39123705, 0x32ed332f, 0x3f333f3f, 0x2f013fed, 0xed2f322f, 0x5d5d2f32, 0x2a773912,
		0x0e102605, 0x05c4c4c4, 0x064e6cc4, 0xc4260d86, 0x23373031, 0x047f2307, 0x23750806, 0x35032e17, 0x14113311, 0x0117021e, 0x3307030e, 0x84ee032e,
		0x190b4b16, 0x6612211c, 0x181c2012, 0x23e44e0b, 0x4909192d, 0x10140c04, 0x0b05b8fe, 0x700a110d, 0x0c0d110a, 0x9a42a2a2, 0x4a4aa3a2, 0x429aa2a3,
		0x21140309, 0x55011e2e, 0x1913b9fe, 0x01040a12, 0x4b3717e6, 0x63434262, 0x0100374a, 0x0102b900, 0xb9023a01, 0x18001100, 0x0c030940, 0x09060011,
		0x300c8203, 0xcddd332f, 0x32ce2f01, 0x303132cd, 0x37363613, 0xae681826, 0xb93a080b, 0x0f0a1c12, 0x17161e13, 0x241a1020, 0x0f200213, 0x1806111c,
		0x1c1b150f, 0x23220f1b, 0x00000d20, 0xb3000100, 0x480156ff, 0x0e00d3ff, 0x05b61300, 0x03070a00, 0x10000f0e, 0x5482dede, 0x31ccdd2c, 0x16140530,
		0x06153333, 0x56832223, 0x0133373b, 0x0f211305, 0x3d2e1317, 0x3a500101, 0x06301d1d, 0x0b043930, 0xff000005, 0x239f87ff, 0x87040602, 0x82205784,
		0x102bc018, 0x00100624, 0x5883332f, 0xcddecd22, 0x3224ac82, 0x2307021e, 0x2205df72, 0x18262307, 0x082a2bc0, 0x7000032a, 0x84010c02, 0x0b000403,
		0x2b001700, 0x11402800, 0x25261f1d, 0x030f1509, 0x1f221809, 0x0c061225, 0x322f0000, 0x32de32dd, 0x10216d86, 0x847285d4, 0x323326c5, 0x06141516,
		0x200b8a33, 0x2d8a8227, 0x26231515, 0x06222326, 0x34352307, 0xbf18023e, 0x6e2f0f3e, 0x14212b17, 0x23220230, 0x30022223, 0x182b2114, 0x30117bbd,
		0x281c0ef8, 0x2415021b, 0x1b021524, 0x000e1c28, 0x09834900, 0x4406534e, 0xe3490933, 0xb4d82308, 0xe3491521, 0xda012110, 0x2008075b, 0x28298288,
		0x0100b90d, 0x1db497ff, 0x95288418, 0x06374457, 0xe5235788, 0x8d1421b4, 0x015b2457, 0x889d02b0, 0x448a2057, 0x012505e7, 0x0940ffff, 0x21588326,
		0xbc430201, 0xffff2105, 0x8606c74a, 0x82b3822b, 0x0601222b, 0x28898304, 0x0102b10f, 0xb4e2ffb8, 0x458a8533, 0x842606c7, 0xcc010000, 0x8b5d7602,
		0x43002307, 0xc343e1fe, 0xfe012605, 0x0d0fb4c4, 0x07db5d00, 0x278e8620, 0xdcfe8f22, 0xc7232787, 0x880c0eb4, 0x82552027, 0x84c72027, 0x822b204f,
		0x82072009, 0x87b2204f, 0x82af2027, 0x08a35b4f, 0x278e5920, 0xaffe8f22, 0xb3202787, 0x23083f66, 0x2d000200, 0x08063b44, 0x19000d30, 0x2d404b00,
		0x30731418, 0x02154015, 0x73111915, 0x102f100f, 0x73051002, 0x081f080f, 0x0d080802, 0x18187913, 0x41160e15, 0x06441511, 0x2f6a0d49, 0x333f3206,
		0x3912333f, 0x2f01ed2f, 0xfd5d5ede, 0x32ed5dde, 0x2203822f, 0x43053031, 0x33220af0, 0x01842311, 0x33113324, 0xe643e901, 0x4afb2609, 0x4949794a,
		0x0ed64379, 0xfd2e022b, 0xfe200195, 0xfe6b02e0, 0x089f82fb, 0x01026021, 0xbb029401, 0x15001100, 0x17403400, 0x80134014, 0x110c1512, 0x0c030600,
		0x11141413, 0x43121215, 0x322108e7, 0x2e60822f, 0x2f01332f, 0x32cedd33, 0x1acdde10, 0x43cd1add, 0x373512f5, 0x60270717, 0x100a1a13, 0x15171b10,
		0x2119101f, 0x2f62b112, 0x0dfd4370, 0x0d212226, 0x8e2298ba, 0x6a207f82, 0x8a207f82, 0x36267f86, 0x40151840, 0x77828012, 0x14268085, 0x12111313,
		0x80951515, 0x2f331122, 0x25278197, 0x6a372707, 0x840b1a12, 0x0f1e2981, 0x0112211a, 0x612e7100, 0x8e248290, 0x0098228e, 0x83208382, 0x713b8382,
		0x10001303, 0x2c002400, 0x18161340, 0x101e1e1f, 0x0b020500, 0x1e181b11, 0x8202081e, 0x20f38218, 0x21ff82cd, 0xfd85cdde, 0xde207b82, 0xf044fb84,
		0x4313200d, 0xb32d10c9, 0x0e0b0e24, 0x1b151917, 0x10221c12, 0x0fc6432e, 0x131a2033, 0x100c1408, 0x111a1a1b, 0x09171b1f, 0x1c0e1201, 0x07c54329,
		0x0e1c2922, 0x09e79218, 0xb35b9d20, 0x61012107, 0x210adb5c, 0xaf5c281a, 0x677b2013, 0x8a200823, 0x16202b8a, 0x200e1b52, 0x0d1b6726, 0x82b30421,
		0x091b672b, 0x672e1c21, 0x18210c1b, 0x120a194f, 0x5d938908, 0x03220843, 0x5767f8d8, 0x40ed2108, 0x201e5767, 0x88778436, 0x8b0420cf, 0x1a2821a3,
		0x1b20cf84, 0x210cbf52, 0xaf5c0403, 0x8c8b2008, 0x2a1821a3, 0x3421a384, 0x0af8674f, 0x69093f4b, 0x2820058f, 0x4807835b, 0x0129095b, 0x041e1000,
		0x09015002, 0x1866840c, 0x21083744, 0xbb690603, 0x085b4808, 0x0c000123, 0x202b840d, 0x085b480e, 0x00008326, 0x76029b01, 0x43222b88, 0xf743e0fe,
		0xb4dd2207, 0x482d830f, 0x8520055b, 0x8f22278e, 0x2787dbfe, 0x376adf20, 0x002c0808, 0x02690002, 0x028b0101, 0x000f00bb, 0x40320013, 0x11401216,
		0x00131080, 0x09030c0f, 0x00121211, 0x06101013, 0x00000f0c, 0xcddd322f, 0x23087e43, 0x32ce32cd, 0x47087d43, 0x2c080970, 0x16160706, 0x07173717,
		0x3824c527, 0x1b17151f, 0x1a0a1010, 0x2f624313, 0x1c010270, 0x1c1b1f46, 0x180f151b, 0x0f1c1106, 0x8e22989b, 0x21008200, 0xfb430002, 0x257b8607,
		0x80104013, 0x7b841211, 0x11111226, 0x13131000, 0x07237bae, 0x8abc3727, 0x71b7237b, 0x7b8e612e, 0x228e6f23, 0x437b8598, 0x2e2c0b73, 0x10001440,
		0x1f18160b, 0x050e1e1e, 0x21067443, 0xf588100e, 0x01cdde34, 0x3232cd2f, 0xcddecd2f, 0x3132ce10, 0x032e0130, 0x70723435, 0x20f38205, 0x113e4717,
		0x1028012e, 0x1c121c22, 0x0e171914, 0x47240e0b, 0x2f0f7543, 0x1b170901, 0x1a1a111f, 0x140c101b, 0xf31a1308, 0x200d7443, 0x06175aff, 0x5a9d0221,
		0x01210747, 0x26b28261, 0x010b4010, 0x5b281a01, 0x7b20122f, 0x00212787, 0x2027878a, 0x13e35416, 0x20097f5b, 0x692782b3, 0x1c2106cb, 0x0ccb692e,
		0x880a6843, 0x31036a87, 0x5bff4722, 0x2105275e, 0xfb59b903, 0xff022c0b, 0x200940f0, 0x500b052b, 0x63310802, 0xcc210bef, 0x85638302, 0x08e7682b,
		0x0940f924, 0x2b843024, 0x2b892020, 0xab01f622, 0x20091741, 0x21ef8804, 0xc5821a28, 0x1b060122, 0x210b475c, 0x875b0403, 0x898b2008, 0x2a1821ef,
		0x3421ef84, 0x0a186b4f, 0x1805b443, 0x22078342, 0x5b022803, 0xb343065f, 0x2315240b, 0x6c500c04, 0x342105da, 0xaf421800, 0x06032108, 0x0f4c2b87,
		0x00012309, 0x2b841211, 0xb3431320, 0x00662608, 0x02e80100, 0x222b8876, 0x43c3fe43, 0xbf22078b, 0x2d8314b4, 0x2005b343, 0x24278642, 0xfe8f0037,
		0x22218298, 0x833c0006, 0xa4ff216b, 0xc7221782, 0xcf827a02, 0x0982a120, 0xc1040724, 0x3f85ebfe, 0xddfe0228, 0x092e22b4, 0x3f825002, 0x00030027,
		0x01040249, 0x08eb6aab, 0x17403439, 0x02131319, 0x00800140, 0x0d070303, 0x10400a16, 0x00030404, 0x6b020180, 0xed6a0565, 0x1acd2e0a, 0x33cd1add,
		0x3031cd2f, 0x27071713, 0x16274a07, 0x2f50f02c, 0x1c143b5d, 0x1c15141c, 0xf66aed1c, 0xb9022506, 0x678e1c99, 0x9210ed6a, 0x070d248b, 0x83400307,
		0x1e796b7d, 0x01238b89, 0x6b372707, 0x4020187b, 0x240b7b6b, 0x1d1d13ea, 0x6b918213, 0x0033177b, 0x02980001, 0x025b0106, 0x000300b5, 0x000a401a,
		0x85010203, 0x4700208c, 0x012405c4, 0x32cd332f, 0xc72bfd85, 0x02a02394, 0x712e81b5, 0x51000000, 0xcf570897, 0x09c34a06, 0x2206f351, 0x513d3804,
		0x01210ff3, 0x08d35bda, 0x25828820, 0x01b60a25, 0x84393e1d, 0x514f8a24, 0x032608e7, 0x010019d6, 0x29830406, 0x02b70c25, 0x8d371501, 0x01f7244f,
		0x889d02d2, 0x0bb74a4f, 0x53834720, 0x3a100122, 0x2009435d, 0x822b8956, 0x825182a7, 0x4a318357, 0xff2205b7, 0x6e5256b4, 0x22d78406, 0x6fff70ff,
		0x262205fb, 0x674a3200, 0x08936006, 0x23b4c924, 0xbb600021, 0x869c2007, 0x00372827, 0xfff2fe8f, 0x830600c1, 0xffff232f, 0x35826eff, 0x210ad76f,
		0x2f5c4300, 0xb4c82309, 0x575c2d2f, 0x8e9a2008, 0xfe8f2227, 0x05bb42f0, 0xf4fe0123, 0x07ff6fb4, 0x02002208, 0xf7ff1200, 0x7902f401, 0x3d002f00,
		0x00b9b400, 0x40f0ff27, 0x00100f0f, 0x1020234c, 0x18234d00, 0x0651780f, 0x07841420, 0x13b3f022, 0xe82a0784, 0x12115740, 0x100b4c00, 0x05821412,
		0x11185508, 0x5f174d00, 0x021b6f1b, 0x1613401b, 0x201b1b48, 0x18181276, 0x121f120f, 0x1203122f, 0x380f7335, 0x3d380801, 0xc02fb003, 0x032fd02f,
		0x2f012fa1, 0x08762a2f, 0x36080202, 0x30883d49, 0x0d7c2551, 0x2f2f1b45, 0x1a790317, 0x3f004400, 0x3232ed32, 0xed3f3311, 0x01320182, 0x102f332f,
		0x5d2f32ed, 0xde2f335d, 0xcefd5d5e, 0x0f84325d, 0x185d2b21, 0x260ae052, 0x33352333, 0x1835032e, 0x21087e42, 0x4418020e, 0x364b1398, 0x9a26080a,
		0x160d4388, 0x23110911, 0x37272738, 0x100a1123, 0x86410d16, 0x090f150c, 0x161c1007, 0x07111c16, 0x0c150f09, 0x4f4b4f01, 0x46270808, 0x514c4116,
		0x4c663927, 0x654c2d2d, 0x4c522739, 0x3c461641, 0x504b4015, 0x3c522f26, 0x523c2323, 0x4b50262f, 0x4f451540, 0x00200d45, 0x290ffb42, 0x02010003,
		0x80034000, 0xfb420102, 0x07012e0d, 0x5b013727, 0x0294249f, 0x812e7177, 0x4f378300, 0x102b0773, 0x09401800, 0x050d1000, 0x470d080b, 0x01230616,
		0x4732cd2f, 0x28080e0b, 0x17161607, 0x23141a01, 0x1720101a, 0x0a221d17, 0x0102121c, 0x2223200d, 0x1b1c1b0f, 0x110d2015, 0xff000f1c, 0xff0600ff,
		0x097f6d56, 0x6d270021, 0xa151057f, 0x05856c06, 0x17b4b623, 0x06856c2d, 0xffffff23, 0x242f8ef5, 0xff3cffc1, 0x232f8cc1, 0x2c1bb4ae, 0x45202f89,
		0x7c202f84, 0x82057b51, 0xfe96225f, 0x5b2f88e5, 0x56230601, 0x853117b4, 0x82342030, 0x206382e6, 0x22338e58, 0x8feffea3, 0xb45f2333, 0x338c2f19,
		0x338e7820, 0x0eff9722, 0x6f20338f, 0x6220678f, 0xa422338e, 0x338f02ff, 0x678f6420, 0x3384ae20, 0xcf88b420, 0x2bff9824, 0xff86a1ff, 0x8a23cf86,
		0x8c4036b4, 0x8ea4209b, 0xffa52233, 0x20338f21, 0x20338f85, 0x6a338283, 0x0025081b, 0xfe870427, 0x219b85ca, 0xc159001b, 0xb4792e06, 0x0107220c,
		0x34342b50, 0xffffff00, 0x222f8e88, 0x8ecffec1, 0xb47c222f, 0x07516910, 0xfeffff23, 0x202f84d9, 0x057b697c, 0x96225f82, 0x2f8879fe, 0x23061157,
		0x260cb424, 0x97416085, 0xeafe2105, 0xa322338e, 0x338f81fe, 0x0eb42d23, 0x20338c24, 0x22338eec, 0x8f82fe97, 0x8f2e2033, 0x209b8f67, 0x8d9b93a4,
		0x1aff2167, 0xb4206784, 0x9822cf88, 0x634197fe, 0x09f15605, 0x2bb44523, 0x909b8b35, 0xa2a52033, 0x829f2033, 0x08bf6167, 0x61270021, 0x314605bf,
		0x05d94506, 0x2cb48725, 0x41120042, 0x84200797, 0xc1222f8e, 0x9741cbfe, 0xb47a220e, 0x07f56030, 0xfeffff23, 0x612f84d5, 0x5f8206cf, 0x75fe9622,
		0x230f2f41, 0x462cb422, 0x97416085, 0x8ee72006, 0xfea32233, 0x23338f7e, 0x442eb42b, 0xff21338b, 0x22338e17, 0x8fadfe97, 0x8e432033, 0x02ff2167,
		0xa422338e, 0x338fa2fe, 0x678f3920, 0x33845620, 0x8206ef61, 0xfe9822cf, 0x0f9741d3, 0x4bb46323, 0x209b8c55, 0x22338e3c, 0x8fb9fea5, 0x8e562033,
		0x09002133, 0xeb223382, 0x97436b02, 0x068f4305, 0x02b60a28, 0x041b2015, 0x0756500f, 0x2d002105, 0xc7202382, 0x2b212384, 0x07e54700, 0x01b60a27,
		0x0710151e, 0x20238701, 0x207b8412, 0x069f6279, 0x83050948, 0x30352123, 0xb018a284, 0x54080827, 0x006b02d9, 0x40740028, 0x11200b40, 0x1d234d00,
		0x28781d22, 0x28281423, 0x06222223, 0x18157609, 0x11131616, 0x0f2a1511, 0x2807070f, 0x79071829, 0x1d081508, 0x20007928, 0x02003000, 0x00080008,
		0x44222310, 0x10790f13, 0xed3f0041, 0x12333f32, 0x2f2f3939, 0xc259185d, 0x2f32250a, 0xcc102f32, 0x02820582, 0xd5181682, 0x13370b66, 0x023e3233,
		0x33352337, 0x2323032e, 0x23072135, 0x07331716, 0x18030e23, 0x08076d52, 0x19413f46, 0x08253037, 0x1704f0ee, 0x73172a21, 0x7c0c9a01, 0x0d3b0927,
		0x3b290631, 0x3c19274a, 0x6114363b, 0x393b3a19, 0x083e0116, 0x40192113, 0x0714221b, 0x37214040, 0x23342640, 0x3e180412, 0x231f4645, 0x15384146,
		0x4308ea82, 0x3a000700, 0xbb013401, 0x1300b502, 0x2b001f00, 0x4e003c00, 0x6c006000, 0x1d403700, 0x5d284165, 0x37335e40, 0x5d5e2c37, 0x670a0004,
		0x5555254a, 0x3d141a50, 0x0f05064a, 0xcc3f004d, 0x33113917, 0x2f013311, 0x11260886, 0x31333333, 0x42190130, 0x1e250cdc, 0x06220502, 0x05307a15,
		0x26342008, 0x17060617, 0x36371616, 0x26262736, 0x37363427, 0x07060627, 0x07141516, 0x26371716, 0x84323726, 0x06273706, 0x26272627, 0x17072223,
		0x27221736, 0x32331607, 0x36373637, 0x2d843617, 0x82163721, 0x2f1e820b, 0x16060706, 0x351ebb01, 0x46282846, 0x341e1e34, 0x35270783, 0x0bbdfe1e,
		0x820b0f0f, 0x09ac2803, 0x14060506, 0x8205090a, 0x89390805, 0x11140f12, 0x0e0e0518, 0x0f14230b, 0x2a1e4b12, 0x12022503, 0x10100f0e, 0x1b120c01,
		0x0f101216, 0x1612100f, 0x010c121b, 0x0e0f1010, 0x03250212, 0x1409172a, 0x09050506, 0x2205820a, 0x8bf40106, 0x2a708260, 0x0a0b0f0e, 0x0b0a0f0f,
		0x8205750f, 0x063b0860, 0x09150506, 0x1456040a, 0x0c200b1f, 0x13091422, 0x1a270b11, 0x5f1f0b20, 0x15011d28, 0x07050e25, 0x0c04100a, 0x0797071f,
		0x10040c1f, 0x0e05070a, 0x1d011525, 0x0506a728, 0x8215090a, 0x0833089c, 0x0e00130b, 0x00005bff, 0xb4029902, 0x07000300, 0x0f000b00, 0x17001300,
		0x1f001b00, 0x27002300, 0x2f002b00, 0x37003300, 0x1f40af07, 0x00091033, 0x8218324d, 0x082b2104, 0x2a200482, 0x27200483, 0x26201383, 0x23240483,
		0xb3f0ffb8, 0x22251682, 0x40f8ffb8, 0x2008820e, 0x20158321, 0x20248320, 0x2012831e, 0x201282b9, 0x2012831d, 0x3d41831c, 0x1b261b06, 0x1b461b36,
		0x1b861b66, 0x1b073d06, 0x1a060901, 0x1a361a26, 0x1a661a46, 0x11821a86, 0x11821a20, 0x16139b08, 0x66132613, 0x12060413, 0x12261216, 0x3d041266,
		0x09010509, 0x093e0104, 0x02011901, 0x00190009, 0x26074102, 0x01250701, 0x07012207, 0x1f090121, 0x781c0901, 0x17094909, 0x09021769, 0x02146914,
		0x0e360e06, 0x06030e66, 0x660d360d, 0x0b09030d, 0x09020b39, 0x02083908, 0xaa319a3d, 0x31690231, 0x31893179, 0x0a403103, 0x310a480e, 0x802f3101,
		0x2f483b34, 0x288f287f, 0x6e285e02, 0x284d0228, 0x01283e01, 0x8001b828, 0x2b284e40, 0xaa289a48, 0x28690228, 0x28892879, 0x33832803, 0x09b02825,
		0x83242849, 0x7f260834, 0x02248f24, 0x246e245e, 0x01244d02, 0x243e242e, 0x1d240d02, 0x24fd0224, 0xaa249a01, 0x24690224, 0x24892479, 0x68842403,
		0x24012428, 0x80ffb836, 0x6c820940, 0x01360725, 0x83323536, 0x0c24080d, 0x1748130d, 0x37322732, 0x2b320332, 0x4000feb8, 0x48312d13, 0x20012b31,
		0x2b01012b, 0xf1022b11, 0x2b00012b, 0x10282887, 0x302b202b, 0x272b032b, 0xb3202882, 0x07822782, 0x28b34025, 0x8327482c, 0x82ff2020, 0x10730849,
		0x30272027, 0x1c270327, 0x0901200c, 0x2f222003, 0x02158f15, 0x3b011509, 0x159f158f, 0x5e0315ff, 0x15bd0115, 0x15fd15ed, 0x01155b03, 0x1b01154c,
		0x15aa0115, 0x790215ba, 0x15080115, 0x0a021518, 0x01130915, 0x0c0f133b, 0x0c6f0c3f, 0x0c4f3d03, 0x0cbf0c8f, 0x1e040cef, 0x0cad010c, 0x7b020ced,
		0x0c4c010c, 0x010c0b01, 0x0cda0caa, 0x690c3902, 0x8308020c, 0x2f0d090f, 0x02085f08, 0x3b010809, 0x8f0108e9, 0x0208bf08, 0xed01081e, 0x087b0108,
		0x01084c01, 0x08da08aa, 0x38080802, 0x080b0208, 0x1a861a66, 0x011a0702, 0x00191a33, 0x02176017, 0x8017503d, 0xf0179017, 0x17e10417, 0xb20217f1,
		0x17530117, 0x44171401, 0x17b50217, 0xa6177601, 0x17070217, 0x0a021717, 0x300f0017, 0x030f600f, 0xb00f803d, 0x030fe00f, 0x0f410f11, 0x010fe102,
		0x0fa20f72, 0x440f0402, 0x40d4020f, 0xa5010f3e, 0x0f66010f, 0x370f0701, 0x0f0b020f, 0x0a300a00, 0x0a903d02, 0x21020ac0, 0x0af1010a, 0x010a8201,
		0xe4010a54, 0x0ab5010a, 0x010a4601, 0x0a010a17, 0xe6390400, 0x06030103, 0xb81f1910, 0x094080ff, 0x1f484534, 0x38352c22, 0x00feb835, 0x3b313b40,
		0x01356148, 0x35503540, 0x31352102, 0x35100235, 0x01350101, 0x35f135e1, 0xc235b202, 0x0335d235, 0x35a33593, 0x01358202, 0x35733563, 0x01355402,
		0x00013543, 0x83258392, 0x0e12264d, 0x35334812, 0x08368201, 0x02352031, 0x03013508, 0xffb82235, 0x18164000, 0x22b5481d, 0x22d522c5, 0x0122a603,
		0x01335822, 0x012cdd33, 0x4001b82c, 0x26200c40, 0x5b2c4b48, 0x843c022c, 0x40003510, 0x481c171c, 0x2cba2caa, 0x2c032cca, 0x48131080, 0x49012c5a,
		0x402a1a82, 0x2c480d0a, 0x0002b81f, 0xb08232b7, 0x26313123, 0x2a0b8234, 0x483b30b3, 0xc001b834, 0x832f2cb3, 0x40803407, 0x482b2333, 0x348c347c,
		0x01346b02, 0x4b01345c, 0x84340134, 0x3f078243, 0x480e0a40, 0x2b231b34, 0x03233b23, 0x1a14c023, 0x29572348, 0x5b2b2901, 0x80feb82d, 0x482724b3,
		0xc0230782, 0x82231eb3, 0x00ff2407, 0x831d1ab3, 0xb3402307, 0x07831911, 0x0d408034, 0x0748100d, 0x272d172d, 0x2d0a032d, 0x00feb81e, 0x8682ae40,
		0x081e2308, 0x240f0124, 0x19205926, 0x19501940, 0x19801960, 0x170619a0, 0x19000119, 0x19c03b01, 0xb10219e0, 0x15850119, 0x01035108, 0x21191119,
		0x04194119, 0xa20119e1, 0x0219c219, 0x72011983, 0x19630119, 0x24190401, 0x03194419, 0x19c519a5, 0x19e519d5, 0x86196604, 0x19470219, 0x01193601,
		0x0b011907, 0x01062019, 0x3c010607, 0x800106d6, 0x06770106, 0x0106e101, 0xa5010643, 0x4d081584, 0x1769060c, 0x08021799, 0x17330117, 0x102f101f,
		0x107f103f, 0x01100804, 0xef10af3c, 0x109e0210, 0x8f104f01, 0x100d0210, 0x01b81001, 0x2aff4060, 0x5c104c49, 0xac106c10, 0x0510ec10, 0xcb01100b,
		0x10aa0110, 0x190210ba, 0x69102910, 0x38820310, 0x100b4808, 0x031f030f, 0x03d84102, 0x9f038f01, 0x03fd0203, 0x0103ee01, 0x035c034c, 0x0103bb02,
		0x090103aa, 0x02031903, 0x1517030f, 0x0a151501, 0x182f180f, 0x185f184f, 0x188f186f, 0x3b0718af, 0x18cf18bf, 0xae0318ef, 0x844f0118, 0x03b60813,
		0x181e180e, 0x8d03182e, 0xcd18ad18, 0x0418ed18, 0x186c184c, 0x0b03187c, 0x02182b18, 0x18eb18db, 0xaa188a02, 0x0318ca18, 0x18691849, 0x01183802,
		0x08011829, 0x180b0118, 0x3e01070f, 0x8e0107d9, 0x07780107, 0x0107ed01, 0xaa01074b, 0x07080107, 0x66070c01, 0x0d07010d, 0x0f0d3301, 0x1011005b,
		0x60112011, 0x803d0411, 0xa0119011, 0x0411e011, 0x11411101, 0xf111e102, 0x11a20211, 0x63115301, 0x11040211, 0x65021144, 0xb511a511, 0x3940c511,
		0x11070411, 0x11271117, 0x00110b03, 0x02021002, 0xf002e041, 0x02a70202, 0x01025001, 0xb2010241, 0x02a30102, 0x1a840001, 0x02600124, 0x00820270,
		0x0108af32, 0x00590a08, 0x3272cd3f, 0x715f5d5f, 0x7271715f, 0x5e260082, 0x5d5e325d, 0x0082715d, 0x5e727225, 0x82cd3f5d, 0x8810850c, 0x825d201b,
		0x831e8400, 0x39122420, 0x82335d2f, 0x83318323, 0x820b840f, 0x852b200c, 0x8e5d204b, 0x855c843f, 0x2042883f, 0x2165845d, 0x66822b32, 0x00832b20,
		0x5dcd3f29, 0x32712b32, 0x822b5d2b, 0x82712022, 0x25638211, 0x2b332b33, 0x12845d5d, 0x82712b21, 0x820b821f, 0x5f5d23b4, 0xba832b5d, 0xbd852783,
		0x012b7229, 0xdc32dc10, 0x82de2b32, 0xcc722404, 0x883232cd, 0x84d885ad, 0x82a883da, 0x200b846d, 0x20e58271, 0x20a58910, 0x85e68471, 0x070441a6,
		0x2d892a82, 0x5d232e82, 0x825fcd10, 0x5d32214d, 0x04829b82, 0x33835f20, 0x08822b20, 0x5dcd1022, 0x56820683, 0x72244482, 0x2b322b72, 0x0b83b383,
		0xbc82dc82, 0x30315d24, 0x8f835e00, 0x2b5d5d22, 0x01200785, 0x02870682, 0x835d5e21, 0x89528201, 0x11012402, 0x82031133, 0x35012303, 0x03841521,
		0x15200b82, 0x17860b83, 0x022a1b97, 0x1d1d1d7c, 0x3401affe, 0x0382ccfe, 0x841daf21, 0x1c9b2304, 0x13821c1c, 0xcbfe3527, 0xaefe3501, 0x2604851d,
		0xfe2a016b, 0x83b4fed6, 0x79022805, 0x68fd1c1c, 0x84011d1d, 0x821f2013, 0x83d32040, 0x4c012116, 0x002b22a0, 0x00030000, 0x01f3ff04, 0x82de01f0,
		0x001d3709, 0x40320029, 0x21091716, 0x111c0427, 0x00022727, 0x24040e14, 0x01820e1e, 0x0003012e, 0x3939cc2f, 0xde102f2f, 0x01ce10cd, 0x2f3a0b82,
		0x10ced4cd, 0x31cedcde, 0x17373730, 0x3e343707, 0x2e343502, 0x06222302, 0xa9571707, 0x020e2905, 0x32171715, 0x26343536, 0x57081482, 0x04161415,
		0x14f6f6f6, 0x09171c18, 0x15192315, 0x1d11122c, 0x1715121d, 0x1f01161b, 0x0e15150e, 0xe8161610, 0xb1f5f6f6, 0x201d2116, 0x151b0c16, 0x2e0c0b0e,
		0x100f0d11, 0x17201b18, 0x1114690a, 0x11151511, 0x00001411, 0xdeffffff, 0x1302f4ff, 0x27007902, 0x6aff6f01, 0x262ac182, 0x00001100, 0x74010701,
		0x0d829600, 0x013f0283, 0x22010000, 0x3e032201, 0x11000500, 0x000104b5, 0x00000502, 0x012fcd2f, 0x31cd2f2f, 0x82331130, 0xd2212a01, 0x01defe50,
		0xfdcc0172, 0x212c82e4, 0x2f82d200, 0x2f86f420, 0x03050224, 0x2f820205, 0x85cd2f21, 0x8213202f, 0x8215202f, 0xfed2272f, 0xfe3e03de, 0x2f845034,
		0x0156ff25, 0x847201f4, 0x0302245f, 0x82030500, 0x295f832f, 0x30312fcd, 0x23152113, 0x51822311, 0x0150d226, 0x34fe5072, 0x8f832f87, 0x0d000329,
		0x020203b3, 0x822f0001, 0x2a8b828c, 0x33112305, 0x50502201, 0x82e803aa, 0x83b785bb, 0x22278357, 0x82000102, 0x82848327, 0x213522b3, 0x82708215,
		0x82268229, 0x82002016, 0x294f837f, 0xb7150007, 0x04050207, 0xe5820306, 0xe2852f20, 0x57853320, 0x82352321, 0x295b82b7, 0xaa50d2d2, 0x0150cc01,
		0x378600cc, 0x37835f83, 0x05020627, 0x07050201, 0x218b8204, 0xea8332cd, 0x0120bb82, 0x1127ba83, 0xf4013523, 0x84d250d2, 0x833a82bd, 0x061f4137,
		0x05243784, 0x05030102, 0x33209b84, 0x7482c582, 0x6c829f83, 0x15331122, 0x22203583, 0xfe226b82, 0xa8825034, 0xd2000122, 0xf423a782, 0x83003e03,
		0x05032437, 0x41070001, 0x37820659, 0x8232cd21, 0x8213206f, 0x82728336, 0x50d22337, 0x36823e03, 0x83052f41, 0x333783df, 0x401e000b, 0x0609070c,
		0x0b020300, 0x06010904, 0x332f0002, 0x3e823882, 0x31220784, 0xe6841330, 0x23237982, 0x82d22311, 0x820282ea, 0xcc0121f3, 0x00234986, 0x87000200,
		0x0007324b, 0x4026000f, 0x0a070810, 0x0f020d05, 0x0f0e0a00, 0x2592830c, 0x32c52f00, 0x04822f2f, 0xc02f0122, 0xc0205484, 0x1d21ce88, 0x22558202,
		0x84352311, 0x01d22e9d, 0x7c015072, 0x505084fe, 0x0184fe50, 0x90df837c, 0x0d0b2f5b, 0x06020809, 0x06080407, 0x040a030d, 0xad82010f, 0x82332f21,
		0x0133215e, 0x63826083, 0x1720f282, 0x35245382, 0x023b1133, 0x5022b486, 0x52828282, 0xa5410482, 0x20b88705, 0x20b78401, 0x06634222, 0x00040125,
		0x82010402, 0x832f20aa, 0x24a08249, 0x11231121, 0x82e98223, 0xe4fd2395, 0xe787cc01, 0x4105f342, 0x0a210535, 0x26318206, 0x00060b09, 0x82000205,
		0xc52f217e, 0x09823b84, 0x20070243, 0x23448415, 0xdefe50d2, 0xc2204884, 0x3426dd82, 0x0134fe50, 0x0082007c, 0xbb410220, 0x00052108, 0x0b224f84,
		0x4f820a07, 0x090a0722, 0x48828886, 0x56828b83, 0x01303124, 0xc8411121, 0x21112a06, 0xdefef401, 0x50d2d250, 0x26bb8201, 0x84fecc01, 0x8684fef0,
		0xd200229f, 0x050b4201, 0x08214f85, 0x21988207, 0x6c430b0a, 0x32c52105, 0x2f214f87, 0x0a7f412f, 0xd2352126, 0x0cfed250, 0x20097a41, 0x209b8550,
		0x854b8200, 0x00092aeb, 0x060a401a, 0x01040705, 0x21e98909, 0x4f832f01, 0x1520e789, 0x2305ee43, 0x01defe22, 0x5024e585, 0xd2000200, 0x05288f86,
		0x1b000900, 0x06070b40, 0x0923de82, 0x825a0206, 0xc52f2406, 0x84c52f3f, 0x858c82dd, 0x210522dc, 0x82da8615, 0x20488344, 0x20dc8372, 0x278f87a0,
		0xf40156ff, 0x0700c201, 0x22062b41, 0x82020708, 0x02082556, 0x00040706, 0x8505fa41, 0x0962434d, 0x21023d23, 0x05654315, 0x2201f422, 0x21055142,
		0x4d825050, 0x20055342, 0x824b8222, 0x2cdb8340, 0x04010809, 0x03090600, 0x2f000005, 0x062441c5, 0x47823220, 0x11211126, 0x35231123, 0x22239683,
		0x8301d250, 0xfe222592, 0xf07c0134, 0x8f86db84, 0x05274388, 0x09060401, 0x42030401, 0x01200509, 0x43824983, 0x41822520, 0x25211122, 0xd221da84,
		0x25438650, 0x84fed2de, 0xd983cc01, 0x82000222, 0x72304782, 0x03003e03, 0x15000700, 0x020405b7, 0x07020403, 0x8305d642, 0x31c52a43, 0x11231730,
		0x2311023b, 0x29bc82d2, 0x03aa5050, 0x0018fce8, 0x73430400, 0x05220808, 0x11000b00, 0x36001700, 0x10071840, 0x0c0b0d0a, 0x01160512, 0x15090413,
		0x130a1607, 0x040d0110, 0x2343020e, 0x05274308, 0x06833320, 0x2f332f22, 0xbf410782, 0x05232106, 0x3328a583, 0x33112335, 0x33053311, 0x8220f583,
		0xf420f082, 0xd2240482, 0x0cfe8250, 0xd5410482, 0x83a02005, 0x015025b7, 0xa084fecc, 0x2005c542, 0x85878403, 0x430920bf, 0x0a2405fd, 0x0b060e09,
		0x0327c182, 0x050a0e0d, 0x83060009, 0x2fc5247d, 0x83332fc5, 0x227b84ce, 0x82013031, 0x82038263, 0x84152005, 0x2201256d, 0xdefe5050, 0x03256e85,
		0x0218fc3e, 0x0a29436c, 0x82000322, 0x2106e344, 0x63860003, 0x0e070b30, 0x02040f06, 0x000e0b03, 0x0806030d, 0x5f830005, 0xc520d282, 0xd9856384,
		0xcd821720, 0xd1840120, 0xdd841520, 0x5050d224, 0xc9822201, 0xaa226582, 0xbe82e803, 0x24093943, 0x00030000, 0x06ab4200, 0x0e2f6388, 0x030a000b,
		0x0e080509, 0x0c080b05, 0x86030206, 0x32c52163, 0x2f216386, 0x25c782c5, 0x35352115, 0xc3821133, 0x69842120, 0xfef40123, 0x215f820c, 0x6782f401,
		0xa020d383, 0x0120c683, 0x53436882, 0x03722309, 0xef43003e, 0x070a2506, 0x00060401, 0x08210583, 0x06254102, 0xc4830120, 0x53825983, 0x15215582,
		0x20078221, 0x23518321, 0x8efe5022, 0x24058341, 0xfd1c0250, 0x204f8594, 0x085f4382, 0x1e000b30, 0x0a070c40, 0x000b0104, 0x08020a07, 0xad850104,
		0x4f88c520, 0x84060941, 0x219e844f, 0x3f448efe, 0x6c022509, 0x0000e4fd, 0x2205cb41, 0x82c201f4, 0x06674109, 0x27070341, 0x0e050d07, 0x00010b08,
		0x45425584, 0x82c52005, 0x843320a9, 0x213522a9, 0x05614115, 0xcb412120, 0x82f42005, 0x053342af, 0x50507225, 0x8284fea0, 0x013423ff, 0x2746007c,
		0x82722006, 0x21ff865f, 0xb1830b00, 0x090a0723, 0x21af8a03, 0x59822fc5, 0x82303121, 0x112331f7, 0x11213523, 0xd2211123, 0x72018250, 0x01defe50,
		0x24057d43, 0x1c0294fd, 0x43008200, 0xaf83053b, 0x29084f41, 0x04010605, 0x070a0903, 0xa9830401, 0x83077342, 0x232521a5, 0x33204982, 0x01204f85,
		0xde24a184, 0xd2720150, 0x50249d83, 0x6c02e4fd, 0x00234f84, 0x8501d200, 0x000724ff, 0x8202b715, 0x04052346, 0x4a840100, 0xee830120, 0x35303122,
		0x2520ec82, 0x01260382, 0x010cfef4, 0xdf82d2f4, 0x9f445020, 0x0372220a, 0x089f443e, 0x06020a29, 0x060a0307, 0x82090502, 0x42332040, 0x2f2205ff,
		0x8b8332c5, 0x24069f46, 0x11231333, 0x23db8233, 0x50a05082, 0x24064048, 0xe80318fc, 0x89d78600, 0x09082b4b, 0x00010503, 0x08000b07, 0x8c830205,
		0x332f3323, 0x834a8301, 0x4601204b, 0x03270615, 0x01231133, 0x84825022, 0x06e6474c, 0x48052a44, 0x0b300a5b, 0x0c401e00, 0x0605090a, 0x05090003,
		0x0302070b, 0x33204d82, 0x2f204d84, 0xcf42a082, 0x20508206, 0x42038311, 0x502305cb, 0x82720150, 0xfecc2303, 0x03820134, 0x00239b82, 0x42012201,
		0x092605c3, 0x0b401c00, 0x45820607, 0x09020625, 0x47000409, 0x9a8205e6, 0x44844b85, 0x82012321, 0x05bf4297, 0x01284882, 0x02e4fdcc, 0x00e4fd1c,
		0x82204782, 0x2b080f4a, 0x401a0009, 0x0509080a, 0x08020203, 0x2005b941, 0x82e08432, 0x30312193, 0x2305b742, 0x33112305, 0x2005b542, 0x288c82de,
		0xfe1c0222, 0x1c025034, 0x0b6f4900, 0x0b2bdb84, 0x03070408, 0x080a0600, 0x83010b04, 0x8648848e, 0x351125db, 0x11231521, 0x01230185, 0x835082f4,
		0x50502148, 0x0121d785, 0x464b82cc, 0x72230517, 0x45007201, 0x072806d3, 0x01040506, 0x04060309, 0x33204b83, 0x9b429389, 0x82252005, 0x06e643d9,
		0xfd720126, 0x50cc01e4, 0xbb41d882, 0x82438906, 0x040123d7, 0x96830108, 0x2f332f27, 0x2f0133c5, 0x83d787c5, 0x23d784d3, 0xfed25082, 0xfe25d784,
		0xfd1c0234, 0x48d883e4, 0x2208059b, 0x003e03f4, 0xb30d0003, 0x02030003, 0x012f2f00, 0x30312f2f, 0x11211101, 0x0cfef401, 0x18fc3e03, 0x8200e803,
		0x002e2500, 0x016eff00, 0xdf542b85, 0x00460818, 0x003f003b, 0x00470043, 0x004f004b, 0x00570053, 0x005f005b, 0x00670063, 0x006f006b, 0x00770073,
		0x007f007b, 0x00870083, 0x008f008b, 0x00970093, 0x009f009b, 0x00a700a3, 0x00af00ab, 0x00b700b3, 0x15331100, 0x03821723, 0x07863720, 0x0fd20720,
		0x13205b83, 0x638b578a, 0x4f830bb3, 0x4e272722, 0xea200287, 0x9c220bbd, 0x02822727, 0x20214d83, 0x2808af20, 0x0320209c, 0x2727273e, 0x83038275,
		0x20078b02, 0x82179628, 0x03272216, 0x831c84d0, 0x8475202e, 0x2775223c, 0x83119076, 0x0000221d, 0x64074255, 0x00bb4c08, 0x00c300bf, 0x00cb00c7,
		0x00d300cf, 0x00db00d7, 0x00e300df, 0x00eb00e7, 0x00f300ef, 0x00fb00f7, 0x010301ff, 0x010b0107, 0x0113010f, 0x011b0117, 0x0123011f, 0x012b0127,
		0x0133012f, 0x013b0137, 0x0143013f, 0x014b0147, 0x4253014f, 0x37240555, 0x07231533, 0x83065942, 0x200f9b0b, 0x87278e05, 0x2017df2f, 0x97778213,
		0x40838363, 0x27238b1b, 0x83274e27, 0x21059a00, 0x0a437afe, 0x051f430a, 0x272412cb, 0x2cfe2020, 0x4e206190, 0x032115ef, 0x126d433e, 0x8f0b7d43,
		0x8676200b, 0x43178f2f, 0x178307ad, 0x43820321, 0x2d8508c4, 0x27211c8b, 0x43428b27, 0x299309ee, 0x0022378d, 0xd34b4900, 0x1aa75a08, 0x4340c745,
		0x3b2733bf, 0x33130000, 0x82172335, 0x86072003, 0x9e372007, 0x9e05200f, 0x403f8f1f, 0x1325bf2f, 0x23352311, 0x21039415, 0x09432711, 0x43119011,
		0xb646127d, 0x40088808, 0x47219324, 0x0a334320, 0xf0022722, 0x4616cb46, 0x064305c0, 0x2313870d, 0x28282876, 0x078b1983, 0x9505e446, 0x1343472f,
		0x03235f97, 0x8b18fc82, 0xe8032200, 0x095b4900, 0x00132008, 0x0314402e, 0x0a110600, 0x0c10070d, 0x070e1201, 0x00100a03, 0x0009050d, 0x332f332f,
		0x4a32c533, 0x0982063f, 0x2105534e, 0x424a3301, 0x06155308, 0x01331124, 0x5e528272, 0x50502106, 0x2606cf53, 0xcc0134fe, 0x83cc0150, 0x09a34a06,
		0x003e0322, 0x00356f84, 0x0f021311, 0x070c0509, 0x0c0f0d0a, 0x05020912, 0x00040813, 0x05c4522f, 0x2f32c523, 0x217a8201, 0x7a843232, 0x09596e18,
		0x53353321, 0xd2500884, 0x05885305, 0x5309d650, 0x6c820536, 0x011e0024, 0xe182006e, 0x00210a83, 0x85058249, 0x0001220b, 0x850d820b, 0x0002240b,
		0x86540007, 0x00032423, 0x865b0020, 0x8a04200b, 0x00052423, 0x867b000c, 0x00062417, 0x86870012, 0x0007240b, 0x86990040, 0x0008240b, 0x86d9000f,
		0x8a09200b, 0x000b240b, 0x86e8001a, 0x8a0c2017, 0x8a10200b, 0x8a11205f, 0x84122083, 0x00032417, 0x82090401, 0x019223af, 0x0b850002, 0x16000124,
		0x0b869401, 0x0e000224, 0x0b86aa01, 0x40000324, 0x0b86b801, 0x238a0420, 0x18000524, 0x1786f801, 0x24000624, 0x0b861002, 0x80000724, 0x0b863402,
		0x1e000824, 0x0b86b402, 0x0b8a0920, 0x34000b24, 0x1786d202, 0x0b8a0c20, 0x5f8a1020, 0x838a1120, 0x17831220, 0x6f433c08, 0x69727970, 0x20746867,
		0x31313032, 0x6e614320, 0x63696e6f, 0x4c206c61, 0x202e6474, 0x63694c20, 0x65736e65, 0x6e752064, 0x20726564, 0x20656874, 0x6e756255, 0x46207574,
		0x85746e6f, 0x6563251e, 0x302e3120, 0x4d2a1686, 0x526f6e6f, 0x6c756765, 0x118a7261, 0x12862020, 0x6556202c, 0x6f697372, 0x2e30206e, 0x0b8b3038,
		0x3c832b85, 0x3d8d2d20, 0x646e6122, 0x612b948a, 0x72206572, 0x73696765, 0x82726574, 0x72742c94, 0x6d656461, 0x736b7261, 0x8e666f20, 0x614423bb,
		0x6882746c, 0x61614d23, 0x2bcb8367, 0x70747468, 0x772f2f3a, 0x642e7777, 0x6d201984, 0x2e3e1882, 0x2f6d6f63, 0x6f004300, 0x79007000, 0x69007200,
		0x68006700, 0x20007400, 0x30003200, 0x01823100, 0x1d822020, 0x6e006122, 0x6e202182, 0x63241d82, 0x6c006100, 0x4c201d82, 0x64222382, 0x09822e00,
		0x4c002022, 0x65201784, 0x73242382, 0x64006500, 0x75201382, 0x64200b82, 0x72200b82, 0x74200b82, 0x65204f82, 0x55230782, 0x83006200, 0x82742017,
		0x00202205, 0x204f8446, 0x22498474, 0x82630069, 0x846e202b, 0x82202005, 0x822e2071, 0x202d8d79, 0x222d844d, 0x8252006f, 0x82672027, 0x006c223f,
		0x95ab8261, 0x8e202023, 0x00202225, 0x22358256, 0x82730072, 0x826f20a5, 0x82202097, 0x002e225d, 0x97058238, 0x87578b17, 0x8e2d2079, 0x207b8d55,
		0x41ef8461, 0xa9831529, 0x7220ff83, 0x6920bb84, 0x74208782, 0x29418f84, 0x82742005, 0x006122c7, 0x20118264, 0x20d3846d, 0x201f826b, 0x21ed8220,
		0x4d950066, 0x20077741, 0x222d8244, 0x8274006c, 0x826e2029, 0x824d2029, 0x0061220d, 0x85098267, 0x8268201f, 0x00742619, 0x003a0070, 0x2101822f,
		0x01830077, 0x65822e20, 0x87006121, 0x836d8333, 0x002e2231, 0x20438263, 0x2125826d, 0x00840002, 0x0085ff23, 0x086f4414, 0x02870882, 0x10052908,
		0x02010000, 0x03000200, 0x05000400, 0x07000600, 0x09000800, 0x0b000a00, 0x0d000c00, 0x0f000e00, 0x11001000, 0x13001200, 0x15343f82, 0x17001600,
		0x19001800, 0x1b001a00, 0x1d001c00, 0x1f001e00, 0x213a9d82, 0x23002200, 0x25002400, 0x27002600, 0x29002800, 0x2b002a00, 0x2d002c00, 0x81822e00,
		0x31003032, 0x33003200, 0x35003400, 0x37003600, 0x39003800, 0x0907c182, 0x3c003bbb, 0x3e003d00, 0x40003f00, 0x42004100, 0x44004300, 0x46004500,
		0x48004700, 0x4a004900, 0x4c004b00, 0x4e004d00, 0x50004f00, 0x52005100, 0x54005300, 0x56005500, 0x58005700, 0x5a005900, 0x5c005b00, 0x5e005d00,
		0x60005f00, 0x03016100, 0xa600c400, 0xab00c500, 0xc2008200, 0xc600d800, 0xbe00e400, 0xb600b000, 0xb400b700, 0x8700b500, 0xb300b200, 0x8c00d900,
		0xbf00e500, 0xbb00b100, 0xa3000401, 0x85008400, 0x9600bd00, 0x8600e800, 0x8b008e00, 0xa9009d00, 0x0501a400, 0x06018a00, 0x93008300, 0xf300f200,
		0x97008d00, 0x07018800, 0xf100de00, 0xaa009e00, 0xf400f500, 0xa200f600, 0xc900ad00, 0xae00c700, 0x63006200, 0x64009000, 0x6500cb00, 0xca00c800,
		0xcc00cf00, 0xce00cd00, 0x6600e900, 0xd000d300, 0xaf00d100, 0xf0006700, 0xd6009100, 0xd500d400, 0xeb006800, 0x8900ed00, 0x69006a00, 0x6d006b00,
		0x6e006c00, 0x6f00a000, 0x70007100, 0x73007200, 0x74007500, 0x77007600, 0x7800ea00, 0x79007a00, 0x7d007b00, 0xb8007c00, 0x7f00a100, 0x80007e00,
		0xec008100, 0xba00ee00, 0x09010801, 0x0b010a01, 0x0d010c01, 0xfe00fd00, 0x0f010e01, 0x11011001, 0x0001ff00, 0x13011201, 0x15011401, 0x17011601,
		0x19011801, 0x1b011a01, 0x1d011c01, 0x1f011e01, 0x21012001, 0xf900f800, 0x23012201, 0x25012401, 0x27012601, 0x29012801, 0x2b012a01, 0x2d012c01,
		0x2f012e01, 0x31013001, 0xd7003201, 0x34013301, 0x36013501, 0x38013701, 0x3a013901, 0x3c013b01, 0x3e013d01, 0x40013f01, 0x42014101, 0xe2004301,
		0x4401e300, 0x46014501, 0x48014701, 0x4a014901, 0x4c014b01, 0x4e014d01, 0x50014f01, 0x52015101, 0x54015301, 0x56015501, 0x58015701, 0x5a015901,
		0x5c015b01, 0xfb005d01, 0x5e01fc00, 0x60015f01, 0x62016101, 0x64016301, 0x66016501, 0x68016701, 0x6a016901, 0x6c016b01, 0x6e016d01, 0x70016f01,
		0x72017101, 0x74017301, 0x76017501, 0xe6007701, 0x7801e700, 0x7a017901, 0x7c017b01, 0x7e017d01, 0x7f01e100, 0xdc00db00, 0xe000dd00, 0x8001df00,
		0x82018101, 0x84018301, 0x86018501, 0xbc008701, 0x89018801, 0x8b018a01, 0x8d018c01, 0x8f018e01, 0x91019001, 0x93019201, 0x95019401, 0x97019601,
		0x99019801, 0x9b019a01, 0x9d019c01, 0x9f019e01, 0xa101a001, 0xa301a201, 0xa501a401, 0xa701a601, 0xa901a801, 0xab01aa01, 0xad01ac01, 0xaf01ae01,
		0xb101b001, 0x9800b201, 0x9a00b301, 0xb4019900, 0xb501ef00, 0xa500b601, 0x9c009200, 0x8f00a700, 0x95009400, 0xc000b900, 0xc100b701, 0xb901b801,
		0xbb01ba01, 0xbd01bc01, 0xbf01be01, 0xc101c001, 0xc301c201, 0xc501c401, 0xc701c601, 0xc901c801, 0xcb01ca01, 0xcd01cc01, 0xcf01ce01, 0xd101d001,
		0xd301d201, 0xd501d401, 0xd701d601, 0xd901d801, 0xdb01da01, 0xdd01dc01, 0xdf01de01, 0xe101e001, 0xe301e201, 0xe501e401, 0xe701e601, 0xe901e801,
		0xeb01ea01, 0xed01ec01, 0xef01ee01, 0xf101f001, 0xf301f201, 0xf501f401, 0xf701f601, 0xf901f801, 0xfb01fa01, 0xfd01fc01, 0xff01fe01, 0x01020002,
		0x03020202, 0x05020402, 0x07020602, 0x09020802, 0x0b020a02, 0x0d020c02, 0x0f020e02, 0x11021002, 0x13021202, 0x15021402, 0x17021602, 0x19021802,
		0x1b021a02, 0x1d021c02, 0x1f021e02, 0x21022002, 0x23022202, 0x25022402, 0x27022602, 0x29022802, 0x2b022a02, 0x2d022c02, 0x2f022e02, 0x31023002,
		0x33023202, 0x35023402, 0x37023602, 0x39023802, 0x3b023a02, 0x3d023c02, 0x3f023e02, 0x41024002, 0x43024202, 0x45024402, 0x47024602, 0x49024802,
		0x4b024a02, 0x4d024c02, 0x4f024e02, 0x51025002, 0x53025202, 0x55025402, 0x57025602, 0x59025802, 0x5b025a02, 0x5d025c02, 0x5f025e02, 0x61026002,
		0x63026202, 0x65026402, 0x67026602, 0x69026802, 0x6b026a02, 0x6d026c02, 0x6f026e02, 0x71027002, 0x73027202, 0x75027402, 0x77027602, 0x79027802,
		0x7b027a02, 0x7d027c02, 0x7f027e02, 0x81028002, 0x83028202, 0x85028402, 0x87028602, 0x89028802, 0x8b028a02, 0x8d028c02, 0x8f028e02, 0x91029002,
		0x93029202, 0x95029402, 0x97029602, 0x99029802, 0x9b029a02, 0x9d029c02, 0x9f029e02, 0xa102a002, 0xa302a202, 0xa502a402, 0xa702a602, 0xa902a802,
		0xab02aa02, 0xad02ac02, 0xaf02ae02, 0xb102b002, 0xb302b202, 0xb502b402, 0xb702b602, 0xb902b802, 0xbb02ba02, 0xbd02bc02, 0xbf02be02, 0xc102c002,
		0xc302c202, 0xc502c402, 0xc702c602, 0xc902c802, 0xcb02ca02, 0xcd02cc02, 0xcf02ce02, 0xd102d002, 0xd302d202, 0xd502d402, 0xd702d602, 0xd902d802,
		0xdb02da02, 0xdd02dc02, 0xdf02de02, 0xe102e002, 0xe302e202, 0xe502e402, 0xe702e602, 0xe902e802, 0xeb02ea02, 0xed02ec02, 0xef02ee02, 0xf102f002,
		0xf302f202, 0xf502f402, 0xf702f602, 0xf902f802, 0xfb02fa02, 0xfd02fc02, 0xff02fe02, 0x01030003, 0x03030203, 0x05030403, 0x07030603, 0x09030803,
		0x0b030a03, 0x0d030c03, 0x0f030e03, 0x11031003, 0x13031203, 0x15031403, 0x17031603, 0x19031803, 0x1b031a03, 0x1d031c03, 0x1f031e03, 0x21032003,
		0x23032203, 0x25032403, 0x27032603, 0x29032803, 0x2b032a03, 0x2d032c03, 0x2f032e03, 0x31033003, 0x33033203, 0x35033403, 0x37033603, 0x39033803,
		0x3b033a03, 0x3d033c03, 0x3f033e03, 0x41034003, 0x43034203, 0x45034403, 0x47034603, 0x49034803, 0x4b034a03, 0x4d034c03, 0x4f034e03, 0x51035003,
		0x53035203, 0x55035403, 0x57035603, 0x59035803, 0x5b035a03, 0x5d035c03, 0x5f035e03, 0x61036003, 0x63036203, 0x65036403, 0x67036603, 0x69036803,
		0x6b036a03, 0x6d036c03, 0x6f036e03, 0x71037003, 0x73037203, 0x75037403, 0x77037603, 0x79037803, 0x7b037a03, 0x7d037c03, 0x7f037e03, 0x81038003,
		0x83038203, 0x85038403, 0x87038603, 0x89038803, 0x8b038a03, 0x8d038c03, 0x8f038e03, 0x91039003, 0x93039203, 0x95039403, 0x97039603, 0x99039803,
		0x9b039a03, 0x9d039c03, 0x9f039e03, 0xa103a003, 0xa303a203, 0xa503a403, 0xa703a603, 0xa903a803, 0xab03aa03, 0xad03ac03, 0xaf03ae03, 0xb103b003,
		0x9f00b203, 0xb403b303, 0xb603b503, 0xb803b703, 0xba03b903, 0xbc03bb03, 0xbe03bd03, 0xc003bf03, 0x9b00c103, 0xc303c203, 0xc503c403, 0xc703c603,
		0xc903c803, 0xcb03ca03, 0xcd03cc03, 0xcf03ce03, 0xd103d003, 0xd303d203, 0xd503d403, 0xd703d603, 0xd903d803, 0xdb03da03, 0xdd03dc03, 0xdf03de03,
		0xe103e003, 0xe303e203, 0xe503e403, 0xe703e603, 0xe903e803, 0xeb03ea03, 0xed03ec03, 0xef03ee03, 0xf103f003, 0xf303f203, 0xf503f403, 0xf703f603,
		0xf903f803, 0xfb03fa03, 0xfd03fc03, 0xff03fe03, 0x01040004, 0x03040204, 0x05040404, 0x07040604, 0x09040804, 0x0b040a04, 0x0d040c04, 0x0f040e04,
		0x11041004, 0x13041204, 0x15041404, 0x17041604, 0x19041804, 0x1b041a04, 0x1d041c04, 0x1f041e04, 0x21042004, 0x23042204, 0x25042404, 0x27042604,
		0x29042804, 0x2b042a04, 0x2d042c04, 0x2f042e04, 0x31043004, 0x33043204, 0x35043404, 0x37043604, 0x39043804, 0x3b043a04, 0x3d043c04, 0x3f043e04,
		0x41044004, 0x43044204, 0x45044404, 0x47044604, 0x49044804, 0x4b044a04, 0x4d044c04, 0x4f044e04, 0x51045004, 0x53045204, 0x55045404, 0x57045604,
		0x59045804, 0x5b045a04, 0x5d045c04, 0x5f045e04, 0x61046004, 0x63046204, 0x65046404, 0x67046604, 0x69046804, 0x6b046a04, 0x6d046c04, 0x6f046e04,
		0x71047004, 0x73047204, 0x75047404, 0x77047604, 0x79047804, 0x7b047a04, 0x7d047c04, 0x7f047e04, 0x81048004, 0x83048204, 0x85048404, 0x87048604,
		0x89048804, 0x8b048a04, 0x8d048c04, 0x8f048e04, 0x91049004, 0x93049204, 0x95049404, 0x97049604, 0x99049804, 0x9b049a04, 0x9d049c04, 0x9f049e04,
		0xa104a004, 0xa304a204, 0xa504a404, 0xa704a604, 0xa904a804, 0xab04aa04, 0xad04ac04, 0xaf04ae04, 0xb104b004, 0xb304b204, 0xb504b404, 0xb704b604,
		0xb904b804, 0xbb04ba04, 0xbd04bc04, 0xbf04be04, 0xc104c004, 0xc304c204, 0xc504c404, 0xc704c604, 0xc904c804, 0xcb04ca04, 0xcd04cc04, 0xcf04ce04,
		0xd104d004, 0xd304d204, 0xd504d404, 0xd704d604, 0xd904d804, 0xdb04da04, 0xdd04dc04, 0xdf04de04, 0xe104e004, 0xe304e204, 0xe504e404, 0xe704e604,
		0xe904e804, 0x1905ea04, 0x1b051a05, 0x1d051c05, 0x1f051e05, 0x21052005, 0xf5042205, 0x2305f604, 0xf904f804, 0xfb04fa04, 0xfd04fc04, 0xff04fe04,
		0x01050005, 0x03050205, 0x05050405, 0x07050605, 0x09050805, 0x0b050a05, 0x0d050c05, 0x0f050e05, 0x11051005, 0x13051205, 0x15051405, 0x17051605,
		0x2e051805, 0x6c6c756e, 0x72754504, 0x6e75076f, 0x41303069, 0x38078630, 0x616d0644, 0x6e6f7263, 0x7265700e, 0x63646f69, 0x65746e65, 0x07646572,
		0x21168541, 0x07856107, 0x62410628, 0x65766572, 0x06846106, 0x6f410729, 0x656e6f67, 0x8561076b, 0x430b2d07, 0x63726963, 0x6c666d75, 0x630b7865,
		0x0a260b89, 0x746f6443, 0x54836361, 0x88630a21, 0x4406230a, 0x71826163, 0x85640621, 0x63442506, 0x74616f72, 0x06830d82, 0x85450721, 0x6507216f,
		0x06210785, 0x21708445, 0x06846506, 0x88450a21, 0x650a2144, 0x07210a88, 0x21858545, 0x07856507, 0x85450621, 0x84652058, 0x470b2106, 0x0b218f89,
		0x210b8967, 0x4b89470a, 0x0a886720, 0x63470c26, 0x616d6d6f, 0x0c21b385, 0x210c8a67, 0x3b89480b, 0x89680b21, 0x4804260b, 0x04726162, 0x28048268,
		0x69744906, 0x0665646c, 0x21068469, 0xc1854907, 0x85690721, 0x49062107, 0x0621c284, 0x21068469, 0xab854907, 0x85690721, 0x490a2107, 0x062e8288,
		0x6f6c2e69, 0x49026c63, 0x6a69024a, 0x69894a0b, 0x896a0b21, 0x4b0c210b, 0x0c219a8a, 0x320c8a6b, 0x72676b11, 0x6c6e6565, 0x69646e61, 0x61632e63,
		0x8b0c6573, 0x4c062811, 0x74756361, 0x846c0665, 0x4c0c2106, 0x0c21398a, 0x280c8a6c, 0x61634c06, 0x066e6f72, 0x2106846c, 0x9e824c04, 0x826c0421,
		0x4e062104, 0x6e203f85, 0x4e203f85, 0x0c21328a, 0x210c8a6e, 0x38844e06, 0x846e0621, 0x6e102b06, 0x736f7061, 0x706f7274, 0x93846568, 0x108a0b20,
		0x6e450329, 0x6e650367, 0x414f0767, 0x07210529, 0x2807856f, 0x72624f06, 0x06657665, 0x2f06846f, 0x75684f0d, 0x7261676e, 0x616c6d75, 0x6f0d7475,
		0x06210d8b, 0x218d8452, 0x06847206, 0x8a520c21, 0x720c2187, 0x06210c8a, 0x218d8452, 0x06857206, 0x2e845320, 0x84730621, 0x530b2106, 0x21095d41,
		0x0b89730b, 0x6e750727, 0x36313069, 0x22078632, 0x85540633, 0x8474203c, 0x54042606, 0x04726162, 0x28048274, 0x69745506, 0x0665646c, 0x21068475,
		0xc3855507, 0x85750721, 0x55062107, 0x0621c484, 0x27068475, 0x69725505, 0x7505676e, 0x0d210583, 0x20d78c55, 0x210d8b75, 0x1d425507, 0x75072105,
		0x0b210785, 0x21978957, 0x0b8a770b, 0x0b8a5920, 0x0b897920, 0x845a0621, 0x7a0621da, 0x0a210684, 0x0863425a, 0x887a0a21, 0x6c05270a, 0x73676e6f,
		0x2641530c, 0x730c210a, 0xf7840c8a, 0x41313222, 0x42210786, 0x25398208, 0x7373656c, 0xd2410a6a, 0x2a1b8509, 0x57063943, 0x76617267, 0x85770665,
		0x84572006, 0x77062176, 0x092b0684, 0x65696457, 0x69736572, 0x87770973, 0x59062109, 0x79202885, 0x0c310684, 0x6f72657a, 0x65707573, 0x726f6972,
		0x756f660c, 0x220c8972, 0x87657669, 0x730b230c, 0x0b877869, 0x65730d25, 0x886e6576, 0x6965240d, 0x88746867, 0x696e2234, 0x8434886e, 0x6e69225b,
		0x235b8466, 0x656e6f0b, 0x74220b88, 0x0b876f77, 0x68740d24, 0x19886572, 0x1a878184, 0x82660c21, 0x82338881, 0x84338881, 0x840d8881, 0x83348881,
		0x3d0c8781, 0x69666109, 0x32313669, 0x65093938, 0x6d697473, 0x64657461, 0x656e6f08, 0x72696874, 0x85820964, 0x73210884, 0x84128209, 0x0c682144,
		0x0b858d84, 0x830b7321, 0x200b867f, 0x8672840c, 0x2442830c, 0x74666966, 0x84428368, 0x0b732108, 0x0b853884, 0x6f660a24, 0x0a857275, 0xb8822983,
		0x0a687422, 0x09844b83, 0x820a7321, 0x224d846d, 0x820b6874, 0x200a8682, 0x05084173, 0x0c200d87, 0x0c894383, 0x65766922, 0x0b200c87, 0x0b874582,
		0x4a820820, 0x8885ef82, 0x73200884, 0x0a877c84, 0x0a853682, 0x31840b20, 0xc5840b86, 0x052d0b85, 0x746c6544, 0x6e750761, 0x32313269, 0x22078436,
		0x86353132, 0x03392407, 0x82695f66, 0x096c2a03, 0x6f72657a, 0x7075732e, 0x85708373, 0x84b98208, 0x840a2008, 0x200a84f8, 0x86b38309, 0x84798209,
		0x82082009, 0x200884ad, 0x8581840a, 0x8480840a, 0x8209200a, 0x85652086, 0x22638509, 0x85666e69, 0x84088363, 0x87088263, 0x860a8263, 0x84098463,
		0x85098263, 0x87088263, 0x860a8363, 0x860a8263, 0x29098363, 0x6f726163, 0x6c612e6e, 0x6c430b74, 0x720e230a, 0x0e8a7665, 0x24880f20, 0x68732e30,
		0x0974726f, 0x65726150, 0x66656c6e, 0x09840a74, 0x6769723c, 0x48067468, 0x65687079, 0x6c53056e, 0x02687361, 0x420b7441, 0x6b636172, 0x26837465,
		0x82420921, 0x8373200a, 0x860c2018, 0x20328415, 0x200c8309, 0x84478465, 0x29148409, 0x6975470d, 0x6e69736c, 0x18836c67, 0x75420622, 0x74240782,
		0x646e4506, 0x06225682, 0x06836d45, 0x22880e20, 0x0a2a3184, 0x6c637845, 0x6f646d61, 0x3c846e77, 0x6d656c23, 0x8476846f, 0x840d8427, 0x510c2827,
		0x74736575, 0x836e6f69, 0x75072629, 0x3130696e, 0x057f4838, 0x31383122, 0x5f450f86, 0x33382106, 0x34200f86, 0x35200786, 0x36200786, 0x37200786,
		0x38200786, 0x39200786, 0x9f440786, 0x38312205, 0x200f8642, 0x20078643, 0x20078644, 0x20078645, 0x21078546, 0x07863039, 0x07863120, 0x39207786,
		0x39207786, 0x39207786, 0x39207786, 0x39207786, 0x39207786, 0x39207786, 0x39207786, 0x39207786, 0x39207786, 0x39207786, 0x39297786, 0x684f0546,
		0x056e726f, 0x8505836f, 0x86412073, 0x864120f3, 0x8641207b, 0x8641207b, 0x8641207b, 0x8641207b, 0x8641207b, 0x8641207b, 0x8641207b, 0x8641207b,
		0x8641207b, 0x8641207b, 0x4541237b, 0x73845505, 0x73897520, 0x85314221, 0x8642207b, 0x8642207b, 0x8642207b, 0x8642207b, 0x8642207b, 0x8642207b,
		0x8642207b, 0x8642207b, 0x8642207b, 0x8642207b, 0x8642207b, 0x8642207b, 0x8642207b, 0x464221f7, 0x43216f85, 0x20078630, 0x86078631, 0x8643207f,
		0x8643207f, 0x8643207f, 0x8643207f, 0x8643207f, 0x8643207f, 0x8643207f, 0x8643207f, 0x8643207f, 0x8643207f, 0x8643207f, 0x8643207f, 0x8643207f,
		0x3044217f, 0x44217785, 0x86078631, 0x8644207f, 0x8644207f, 0x8644207f, 0x8644207f, 0x8644207f, 0x8644207f, 0x8644207f, 0x8644207f, 0x8644207f,
		0x8644207f, 0x8644207f, 0x8644207f, 0x8644207f, 0x3045217f, 0x45217785, 0x86078631, 0x8645207f, 0x8645207f, 0x3545237f, 0xbd4a4706, 0x84672005,
		0x862d8606, 0x8645207d, 0x8645207d, 0x8645207d, 0x8645207d, 0x4445217d, 0x7d862f86, 0x7d864520, 0x85304621, 0x31462117, 0x7d860786, 0x7d864620,
		0x7d864620, 0xfd864620, 0xfd864620, 0xfd864620, 0x7f864620, 0x0a39462e, 0x6e697241, 0x75636167, 0x610a6574, 0x07220a88, 0x12844541, 0x65610722,
		0x0b260784, 0x616c734f, 0x0b856873, 0x0b896f20, 0x32227d84, 0x07863030, 0x32218d85, 0x218d8530, 0x8d853032, 0x85303221, 0x3032218d, 0x32218d85,
		0x218d8530, 0x8d853032, 0x85303221, 0x3032218d, 0x21050d41, 0x0d413032, 0x30322105, 0x21050d41, 0x0d413032, 0x30322105, 0x21050d41, 0x0d413032,
		0x30322105, 0x22050d41, 0x85303132, 0x3131217f, 0x7f860786, 0x7f863120, 0x7f863120, 0x22057c46, 0x86313230, 0x8631207f, 0x8631207f, 0x8631205f,
		0x8631205f, 0x8631205f, 0x8632205f, 0x8632205f, 0x8632205f, 0x8632205f, 0x8632205f, 0x8632205f, 0x05ec46df, 0x32323022, 0x32205f86, 0x3220df86,
		0x3220df86, 0x3220df86, 0x3220df86, 0x32207f86, 0x32207f86, 0x32207f86, 0x33217f86, 0x21d78530, 0x07863133, 0x33207f86, 0x33207f86, 0x33207f86,
		0x33207f86, 0x3320df86, 0x33207786, 0x33207786, 0x33207786, 0x33207786, 0x33207786, 0x33207786, 0x33207786, 0x34217786, 0x216f8530, 0x07863134,
		0x34207786, 0x34207786, 0x34207786, 0x34207786, 0x34207786, 0x3420f786, 0x34207f86, 0x34207f86, 0x34207f86, 0x34207f86, 0x34207f86, 0x34207f86,
		0x34207f86, 0x29087f86, 0x620e3239, 0x65766572, 0x766e695f, 0x65747265, 0x6f640c64, 0x656c6275, 0x6172675f, 0x720a6576, 0x5f676e69, 0x74756361,
		0x7f4a0f65, 0x4b5f2007, 0x0a23059c, 0x86746f64, 0x880e200a, 0x8934841a, 0x8938840e, 0x2568840e, 0x6c69740c, 0x39866564, 0x21840920, 0x73612e24,
		0x804b0e63, 0x210e8309, 0xe9476309, 0x63732205, 0x235c8d12, 0x7061632e, 0x3e851289, 0x6484128c, 0x07312583, 0x30696e75, 0x09303034, 0x69696661,
		0x32303031, 0x21098733, 0x09883135, 0x09883220, 0x34201d89, 0x35201388, 0x36200988, 0x37200988, 0x38200988, 0x39200988, 0x36200987, 0x36216d88,
		0x207f8631, 0x871b8844, 0x3431216b, 0x31205788, 0x31204d88, 0x31204d88, 0x32204d88, 0xb188bb89, 0xb1883220, 0xa7883220, 0x4f883220, 0xa7883220,
		0x59883220, 0x59883220, 0x59883220, 0x59883320, 0x59883320, 0x59883320, 0x0b413320, 0x88332008, 0x88332063, 0x88332063, 0x88332063, 0x88332063,
		0x88332063, 0x88342063, 0x88342063, 0x88342063, 0x88342063, 0x88342063, 0x09174163, 0x63883420, 0x63883420, 0x63883420, 0x63883420, 0x95883620,
		0x31883620, 0x31883620, 0x31883620, 0x31883620, 0x95883720, 0x8b883720, 0x8b883720, 0x8b883720, 0x59883720, 0x59883720, 0x59883720, 0x59883720,
		0x59883720, 0x59883820, 0xef883820, 0x63883820, 0x63883820, 0x63883820, 0x63883820, 0x63883820, 0x63883820, 0x63883820, 0x63883820, 0x63883920,
		0x63883920, 0x63883920, 0x63883920, 0x63883920, 0x63883920, 0x63883920, 0x3b443920, 0x35342105, 0x37204d88, 0x6b874d89, 0x39433120, 0x30312108,
		0x31211d87, 0x08c34230, 0x6b873020, 0x87303121, 0x3031216b, 0x31216b87, 0x216b8730, 0xcf873031, 0x87303121, 0x463120cf, 0x34210683, 0x071b4335,
		0x30313122, 0x23062543, 0x0e333931, 0x2606af43, 0x6c2e3636, 0x436c636f, 0x4a500546, 0x36342106, 0x21051645, 0x26453734, 0x37342105, 0x26450f87,
		0x37342105, 0x21052645, 0x06453834, 0x4a342005, 0x342106da, 0x05064538, 0x45383421, 0x34210506, 0x05064538, 0x46383422, 0x4108c443, 0xae4a080c,
		0x39342106, 0x39206386, 0x39206386, 0x39206386, 0x39206386, 0x20058a45, 0x074e4134, 0x8a453788, 0x4a342005, 0x342006e6, 0x2006e64a, 0x06e64a34,
		0xe64a3420, 0x39342106, 0x39208386, 0x20058a45, 0x065e5434, 0x31413422, 0xea4af385, 0x4a342006, 0x342006ea, 0x2006ea4a, 0x06ea4a34, 0xea4a3420,
		0x4a342006, 0x342006ea, 0x2006ea4a, 0x06ea4a34, 0xea4a3420, 0x4a342006, 0x342006ea, 0x2006ea4a, 0x06ea4a34, 0x86413421, 0x8641207f, 0x3042217f,
		0x42207785, 0xee4a7f86, 0x4a342006, 0x342006ee, 0x2106ee4a, 0xff864234, 0x2006ee4a, 0x06ee4a34, 0xee4a3420, 0x42342106, 0xee4aff86, 0x4a342006,
		0x342006ee, 0x2006ee4a, 0x06ee4a34, 0xee4a3420, 0x4a342006, 0x342006ee, 0x2106ee4a, 0x7f864334, 0x7f414320, 0x06ee4a06, 0xee4a3420, 0x4a342006,
		0x342006ee, 0x2006ee4a, 0x06ee4a34, 0xee4a3420, 0x4a342006, 0x342006ee, 0x2006ee4a, 0x06ee4a34, 0xee4a3420, 0x4a342006, 0x342006ee, 0x2006ee4a,
		0x06ee4a34, 0xee4a3420, 0x4a342006, 0x342106ee, 0x4a7f8644, 0x342006ee, 0x2006ee4a, 0x06ee4a34, 0xee4a3420, 0x4a342006, 0x342006ee, 0x2006ee4a,
		0x06ee4a34, 0xee4a3420, 0x4a342006, 0x342006ee, 0x2006ee4a, 0x06ee4a34, 0xee4a3420, 0x4a342006, 0x342006ee, 0x2006ee4a, 0x06ee4a34, 0x86453421,
		0x06ee4a7f, 0xee4a3420, 0x45342106, 0x20067f41, 0x067f4245, 0xce434520, 0x48452006, 0x3420050a, 0x2006f04a, 0x06f04a34, 0xf04a3420, 0x4a342006,
		0x342006f0, 0x2106f04a, 0xff414534, 0x06f04a06, 0xf04a3420, 0x46342106, 0x20067f41, 0x4a7f8646, 0x342006f0, 0x2106f04a, 0x7f864634, 0x2006f04a,
		0x06f04a34, 0xf04a3420, 0x46342106, 0x23054244, 0x35333136, 0x21052e44, 0x7e4a3030, 0x30322106, 0x08054342, 0x4130323a, 0x65740545, 0x0665676e,
		0x62756f72, 0x6b06656c, 0x6b746172, 0x6c410561, 0x04616870, 0x61746542, 0x6d614705, 0x7507616d, 0x3330696e, 0x45073439, 0x6c697370, 0x5a046e6f,
		0x03211a82, 0x211e8245, 0x09826854, 0x6f490422, 0x2f080a82, 0x7070614b, 0x614c0661, 0x6164626d, 0x02754d02, 0x5802754e, 0x6d4f0769, 0x6f726369,
		0x6950026e, 0x6f685203, 0x67695305, 0x5403616d, 0x55077561, 0x03254a85, 0x03696850, 0x24038243, 0x05697350, 0x20778461, 0x21528262, 0x77836705,
		0x65640527, 0x0761746c, 0x212a8565, 0x18827a04, 0x03820320, 0x84740521, 0x83692075, 0x846b2075, 0x846c2075, 0x29a68575, 0x6e024342, 0x69780275,
		0x7a856f07, 0x68720325, 0x8373066f, 0x05312177, 0x03210684, 0x207e8274, 0x21538575, 0x7a827003, 0x03826320, 0x05260e82, 0x67656d6f, 0xfc840a61,
		0x6e6f7425, 0x860c736f, 0x200c84ee, 0x84ee8208, 0x83092008, 0x200984ed, 0x4909830c, 0x0c200717, 0x1985e986, 0x5e855520, 0x0f200c84, 0x29870c86,
		0x834f0a21, 0x201a8467, 0x85f1840a, 0x85e5866c, 0x85e5826c, 0x85e4836c, 0x8709836c, 0x8b112042, 0x861e850c, 0x200c84ed, 0x88dd860f, 0x840f869b,
		0x8e14201c, 0x2014841c, 0x84fb840a, 0x8405200a, 0x84092005, 0x632e2405, 0x870d7061, 0x25118445, 0x696e7507, 0x064d4631, 0x20078205, 0x200f8631,
		0x20078632, 0x20078633, 0x20078634, 0x20078635, 0x20078636, 0x20078637, 0x20078638, 0x20078639, 0x20078641, 0x20078642, 0x20078643, 0x20078644,
		0x20078645, 0x4d078546, 0x31210506, 0x05064d46, 0x7f860782, 0x7f863120, 0x7f863120, 0x7f863120, 0x6f863120, 0x6f863120, 0x6f863120, 0x6f863120,
		0x6f863120, 0x85443121, 0x05064d5f, 0x4d463121, 0x07820506, 0x064d5f86, 0x860f8205, 0x05064d5f, 0xdf860f82, 0x8205064d, 0x4d6f860f, 0x0f820506,
		0x064d6f86, 0x860f8205, 0x05064d6f, 0xdf860f82, 0x2105064d, 0x064d4631, 0x20078205, 0x208f8531, 0x4d7f8633, 0x17820506, 0x17863420, 0x064ddf86,
		0x41178205, 0x0e4d065f, 0x860f8205, 0x863320ef, 0x050e4d7f, 0x7f861782, 0x82050e4d, 0x4d7f860f, 0x3121050e, 0x050e4d46, 0x7f860782, 0x7f863420,
		0x82050e4d, 0x4d7f8617, 0x0f82050e, 0xfe4cef86, 0x860f8205, 0x05fe4c6f, 0x6f860f82, 0x2305fe4c, 0x30354631, 0x3520bf85, 0x35205f86, 0x35205f86,
		0x2006bf41, 0x205f8635, 0x20df8635, 0x065f4135, 0xdf863520, 0xd7863520, 0xbf413520, 0x41352006, 0x352006b7, 0x20061f42, 0x4b5f8636, 0x312105fe,
		0x05b74846, 0x5f860782, 0x5f863620, 0x5f863620, 0x5f863620, 0x5f863620, 0xcf863620, 0x67863620, 0xcf863620, 0x6f863620, 0xcf863620, 0x77863620,
		0x3f413620, 0x86362006, 0x8637207f, 0x3137217f, 0x2749e785, 0x46312105, 0x82052749, 0x497f8607, 0x0f820527, 0x37207f86, 0x37207f86, 0x37207f86,
		0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x38207f86, 0x92546f86, 0x46312205, 0x064f4138, 0xef863820, 0x6f863820, 0xef863820, 0x6f863820,
		0x6f863820, 0x6f863820, 0x6f863820, 0x8205b749, 0x496f8647, 0x0f8205b7, 0xef866f87, 0xef863820, 0x85303921, 0x313921e7, 0x7f860786, 0x2205b349,
		0x86394631, 0x05b3497f, 0x7f860f82, 0x8205b349, 0x207f860f, 0x497f8639, 0x178205b3, 0xb3497f86, 0x860f8205, 0x05b3497f, 0x7f860f82, 0x2105b349,
		0xb3494631, 0x86078205, 0x05b3497f, 0x7f860f82, 0x8205b349, 0x497f860f, 0x0f8205b3, 0xb3497f86, 0x410f8205, 0xb349066f, 0x410f8205, 0xb349066f,
		0x860f8205, 0x05b349ff, 0x49463121, 0x078205b3, 0xb349ff86, 0x410f8205, 0x6f47067f, 0x860f8205, 0x05ab4977, 0x77860f82, 0x8205ab49, 0x4977860f,
		0x0f8205ab, 0xab497786, 0x860f8205, 0x05ab4977, 0x49463121, 0x078205ab, 0xab497786, 0x860f8205, 0x05ab4977, 0x77860f82, 0x8205a349, 0x4977860f,
		0x0f8205a3, 0xa3497786, 0x860f8205, 0x05a34977, 0x77860f82, 0x2105a349, 0xa3494631, 0x86078205, 0x05a34977, 0x77860f82, 0x82059349, 0x065f420f,
		0x82059349, 0x06df410f, 0x82059349, 0x06df410f, 0x82058b49, 0x4967860f, 0x3121058b, 0x058b4946, 0x31200782, 0x49055742, 0x0f82058b, 0x8b496786,
		0x420f8205, 0x8b4906d7, 0x860f8205, 0x058b4977, 0x77860f82, 0x82058b49, 0x4977860f, 0x0f82058b, 0x49065742, 0x0f82058b, 0x49065742, 0x3121057b,
		0x057b4946, 0x47420782, 0x05734906, 0x67860f82, 0x82057349, 0x2067860f, 0x064f4146, 0x67864620, 0x4f414620, 0x86462006, 0x45462d67, 0x696e750b,
		0x38384631, 0x746c612e, 0x39200b86, 0x41200b8a, 0x42200b8a, 0x43200b8a, 0x44200b8a, 0x45200b8a, 0x46200b8a, 0x39200b89, 0x39205f8a, 0x39205f8a,
		0x39205f8a, 0x39205f8a, 0x39205f8a, 0x39205f8a, 0x39205f8a, 0x41205f8a, 0x41205f8a, 0x41205f8a, 0x41205f8a, 0x41205f8a, 0x41205f8a, 0x41205f8a,
		0x41205f8a, 0x42205f8a, 0x43202f8a, 0x46200b8a, 0x07250b84, 0x32696e75, 0x053b4330, 0x46304523, 0x230f8346, 0x30303046, 0x46200784, 0x20056b41,
		0x24078245, 0x3046530c, 0x24178234, 0x30302e30, 0x200c8331, 0x200c8b32, 0x200c8a31, 0x830c8c31, 0x20338818, 0x21268a39, 0x0c8b3630, 0x0c8b3720,
		0x0c8b3820, 0x0c8a3520, 0x818b3520, 0x8a333521, 0x88302019, 0x5308230c, 0x67843146, 0x33200882, 0x08826384, 0x45843420, 0x32200882, 0x08825b84,
		0x30201084, 0x34200882, 0x08827a84, 0xd1843220, 0x35220882, 0x00823031, 0x32200882, 0x08826e84, 0x08873420, 0x66843220, 0x2c871183, 0x47831984,
		0x6b873220, 0x62873320, 0x47883420, 0x35826c84, 0x98873320, 0x47873420, 0x3e834684, 0x86873320, 0x47873420, 0x11883220, 0x59873588, 0x86313221,
		0x843520a1, 0x62052e3f, 0x6b636f6c, 0x73746c07, 0x65646168, 0x22058405, 0x846b6407, 0x41758207, 0x08830528, 0x0882ac84, 0x8305c941, 0x833f8408,
		0x41518708, 0x118205bd, 0x99831084, 0x7e873020, 0x8205b141, 0x8730201a, 0x87302099, 0x87302090, 0x058741e1, 0x00840020, 0xffff0126, 0x01000200,
		0x0a390b82, 0x16077401, 0x79630300, 0x14006c72, 0x6b657267, 0x616c9000, 0xb0006e74, 0x37158200, 0x20524742, 0x4b4d2e00, 0x48002044, 0x20425253,
		0x00006200, 0x0900ffff, 0x0b2e3782, 0x1f001400, 0x3e003000, 0x56004b00, 0x17846100, 0x51820a20, 0x15000c2e, 0x2a002000, 0x3f003100, 0x57004c00,
		0x0a203186, 0x0d206d82, 0x212c5182, 0x32002b00, 0x4d004000, 0x63005800, 0x03343386, 0x17000e00, 0x2c002200, 0x41003300, 0x59004e00, 0x04006400,
		0x69836182, 0x09820b20, 0x18000f32, 0x34002300, 0x42003c00, 0x4f004900, 0x65005a00, 0x053e2d82, 0x20455a41, 0x52434000, 0x5a002054, 0x204c4f4d,
		0x4f527400, 0x8a00204d, 0x204b5254, 0x5b84a000, 0x05000c38, 0x19001000, 0x35002400, 0x3d003b00, 0x4a004300, 0x5b005000, 0x1d846600, 0x06000a34,
		0x1a001100, 0x2d002500, 0x44003600, 0x5c005100, 0x19866700, 0x12000732, 0x26001b00, 0x37002e00, 0x52004500, 0x68005d00, 0x08301984, 0x1c000800,
		0x38002700, 0x53004600, 0x69005e00, 0x092e1586, 0x28001d00, 0x47003900, 0x5f005400, 0x15846a00, 0x0a000a3c, 0x1e001300, 0x2f002900, 0x48003a00,
		0x60005500, 0x6c006b00, 0x63726661, 0x05848a02, 0x05849420, 0x05849e20, 0x0584a820, 0x0584b220, 0x0584bc20, 0x0584c620, 0x0584d020, 0x0584da20,
		0x0584e420, 0x6163ee26, 0xf8026573, 0x03210583, 0x20058400, 0x20058408, 0x20058410, 0x20058418, 0x20058420, 0x20058428, 0x26058430, 0x6f6e6438,
		0x8440036d, 0x84462005, 0x844c2005, 0x84522005, 0x84582005, 0x845e2005, 0x84642005, 0x846a2005, 0x84702005, 0x84762005, 0x667c2605, 0x03636172,
		0x20058482, 0x2005848a, 0x20058492, 0x2005849a, 0x200584a2, 0x200584aa, 0x200584b2, 0x200584ba, 0x200584c2, 0x260584ca, 0x636f6cd2, 0x84da036c,
		0x84e02005, 0x84e62005, 0x84ec2005, 0x84f22005, 0x6ef82605, 0x03726d75, 0x210583fe, 0x05840404, 0x05840a20, 0x05841020, 0x05841620, 0x05841c20,
		0x05842220, 0x05842820, 0x05842e20, 0x05843420, 0x726f3a2c, 0x40046e64, 0x746c6173, 0x05844604, 0x69735026, 0x5a04666e, 0x60200584, 0x66200584,
		0x6c200584, 0x72200584, 0x78200584, 0x7e200584, 0x84200584, 0x8a200584, 0x90200584, 0x96260584, 0x31307373, 0x05849c04, 0x0582a620, 0xb0043222,
		0xba200584, 0xc4200584, 0xce200584, 0xd8200584, 0xe2200584, 0xec200584, 0xf6200584, 0x05210583, 0x20058400, 0x2605840a, 0x62757314, 0x841e0573,
		0x84242005, 0x842a2005, 0x84302005, 0x84362005, 0x843c2005, 0x84422005, 0x84482005, 0x844e2005, 0x84542005, 0x735a2605, 0x05737075, 0x20058460,
		0x20058466, 0x2005846c, 0x20058472, 0x20058478, 0x2005847e, 0x20058484, 0x2005848a, 0x20058490, 0x25058496, 0x0000009c, 0x7f720003, 0x2409e505,
		0x00110002, 0xbf758212, 0x00012207, 0xbb458208, 0x00022405, 0x820d000c, 0x2207cf43, 0x84030001, 0x84042099, 0x84052005, 0x27048205, 0x02000100,
		0x01000000, 0x05830182, 0x0b840620, 0x072005bb, 0x03214182, 0x05317400, 0x89000021, 0x00012209, 0xb95b840b, 0x42559305, 0x01226d25, 0xc3840a00,
		0x092005bb, 0x05b74184, 0x00172e08, 0x00380030, 0x00480040, 0x00580050, 0x00680060, 0x00780070, 0x00880080, 0x00980090, 0x00a800a0, 0x00b800b0,
		0x00c800c0, 0x00d800d0, 0x06d541e0, 0x0786b820, 0x0786b620, 0x0786b420, 0x0786b220, 0x0786b020, 0x0786ae20, 0x0786ac20, 0x0786fa20, 0x0785fc20,
		0x864a0121, 0x86982007, 0x85e62007, 0x34022307, 0xd5830400, 0x85360221, 0x321d210f, 0x34220786, 0x17830600, 0x86821d21, 0x868c200f, 0x207f8607,
		0x2177861e, 0x1785c01e, 0x86d01e21, 0x27b78207, 0xc100f21e, 0xec1e0100, 0xe6200584, 0x2f200586, 0xe0211182, 0x20058300, 0x2c0582da, 0x00da1e02,
		0x006f0128, 0x008d0094, 0x0c2d748e, 0x002913ba, 0x009a1e02, 0x00850002, 0x20098295, 0x225f8298, 0x74770176, 0x01210d75, 0x220f847f, 0x74760177,
		0x13820989, 0x13922793, 0x64205582, 0x4d745582, 0xb3013308, 0xb501b401, 0xb701b601, 0xb101b001, 0xae01af01, 0x138ab201, 0x13922793, 0x30205582,
		0xb8205582, 0x22127374, 0x82bb01ba, 0x74b82015, 0x27930c87, 0x00231392, 0xd4da1d02, 0xa65c0855, 0x6e010200, 0x01006e01, 0x2800a41d, 0xe8015600,
		0x7c03b202, 0xde041404, 0x78051205, 0x7606ac05, 0xd2084007, 0x340a6a09, 0xce0a680a, 0x940c020b, 0x280e5e0d, 0x8a0fc00e, 0x2410be0f, 0xea115810,
		0x7e13b412, 0xe0141614, 0x7a151415, 0x4017ae15, 0xd4180a18, 0x361a6c19, 0xd01a6a1a, 0x52085182, 0x005a0052, 0x006a0062, 0x007a0072, 0x008a0082,
		0x009a0092, 0x00aa00a2, 0x00ba00b2, 0x00ca00c2, 0x00da00d2, 0x00ea00e2, 0x01fa00f2, 0x010a0102, 0x011a0112, 0x012a0122, 0x013a0132, 0x014a0142,
		0x015a0152, 0x016a0162, 0x017a0172, 0x008a0182, 0x82030098, 0x011522ad, 0x22078482, 0x84970016, 0x01172207, 0x22078488, 0x848c0118, 0x01192207,
		0x2207848e, 0x8484011a, 0x011b2207, 0x20078494, 0x203f861c, 0x203f868d, 0x213f858e, 0x3f857001, 0x85710121, 0x846d823f, 0x7301213f, 0x01213f85,
		0x213f8574, 0x3f857501, 0x85780121, 0x7901213f, 0x7a203f86, 0x7b203f86, 0x7c203f86, 0x01217f85, 0x203f867d, 0x203f867e, 0x203f867f, 0x203f86b0,
		0x203f86b1, 0x203f86b2, 0x203f86b3, 0x203f86b4, 0x203f86b5, 0x203f86b6, 0x203f86b7, 0x203f86ba, 0x203f86bb, 0x203f86bc, 0x203f86bd, 0x203f86be,
		0x203f86bf, 0x2d3f86c0, 0x001400c1, 0x0032002a, 0x0042003a, 0x9b41004a, 0x8301291c, 0x6e010300, 0x89011600, 0x18220784, 0x07848f01, 0x95011a22,
		0x1c200784, 0x8e201f86, 0x01211f85, 0x211f8571, 0x1f857301, 0x85750121, 0x7901211f, 0x7b201f86, 0x7d201f86, 0x7f201f86, 0xb1201f86, 0xb3201f86,
		0xb5201f86, 0xb7201f86, 0xbb201f86, 0xbd201f86, 0xbf201f86, 0xc9aa1f86, 0x84990021, 0x011722b1, 0x2207848a, 0x84900118, 0x011a2207, 0x20078485,
		0x211f851b, 0x1f857001, 0x1f84c982, 0x1f84c982, 0x86740121, 0x867a201f, 0x857b201f, 0x7d01213f, 0x01213f85, 0x201f867e, 0x201f86b2, 0x201f86b3,
		0x201f86b5, 0x201f86b6, 0x201f86bc, 0x201f86bd, 0x261f86bf, 0x000f00c0, 0x46280020, 0x0121194d, 0x22a7848b, 0x84910118, 0x011a2207, 0x20078496,
		0x8217851c, 0x821784af, 0x211784af, 0x17867501, 0x2f857b20, 0x1785a782, 0x17867f20, 0x1786b320, 0x4785b520, 0x86b70121, 0x86bd2017, 0x86bf2017,
		0x2a614117, 0x848d0121, 0x01192291, 0x22078492, 0x8486011a, 0x011b2107, 0x20059d43, 0x211f851c, 0x1f857201, 0x1f84a982, 0x85740121, 0x84b1821f,
		0x7c01213f, 0x7d201f86, 0x01213f85, 0x201f867e, 0x203f867f, 0x201f86b4, 0x201f86b5, 0x201f86b6, 0x201f86b7, 0x201f86be, 0x201f86bf, 0x2e1f86c0,
		0x000500c1, 0x0014000c, 0x0024001c, 0x8493012c, 0x851a209b, 0x848b8207, 0x7d01210f, 0xb5200f86, 0xbf380786, 0x16000a00, 0x26001e00, 0x36002e00,
		0x46003e00, 0x56004e00, 0x87015e00, 0x1b213d84, 0x05874401, 0x0f851c20, 0x0f84c982, 0x1f84c982, 0x0f85b982, 0x1f867f20, 0x2f85b620, 0x86b70121,
		0x86c0200f, 0x42998d0f, 0x1c2105a7, 0x82078401, 0x2007854b, 0x200f867f, 0x410786b7, 0x03102b97, 0x206901c3, 0x1d4d4528, 0x01e90610, 0x55051072,
		0x03102f02, 0x109101c1, 0xc303ab0a, 0x0a550510, 0x020222ab, 0x060d5b98, 0x0a020222, 0x2452cf5c, 0x02010003, 0x2403826e, 0x0000007e, 0x26038201,
		0x02020016, 0x18150082, 0x23258350, 0x2d003600, 0x80222f82, 0x53187f00, 0xce0834e1, 0x006d006b, 0x009c009b, 0x009e009d, 0x00a0009f, 0x00a200a1,
		0x00a400a3, 0x00a600a5, 0x00a800a7, 0x00aa00a9, 0x00ac00ab, 0x00ae00ad, 0x00b000af, 0x00b300b1, 0x00b500b4, 0x00b700b6, 0x00b900b8, 0x00db007a,
		0x00df00dd, 0x00e300e1, 0x00e700e5, 0x00eb00e9, 0x00ef00ed, 0x00f300f1, 0x00f700f5, 0x00fb00f9, 0x01ff00fd, 0x01030101, 0x01070105, 0x010b0109,
		0x0110010e, 0x01140112, 0x01180116, 0x011c011a, 0x0120011e, 0x01240122, 0x01280126, 0x012c012a, 0x0130012e, 0x01340132, 0x01380136, 0x013c013a,
		0x0140013e, 0x01440142, 0x01480146, 0x014c014a, 0x0150014e, 0x01540152, 0x01590156, 0x0166015b, 0x016a0168, 0x0202006c, 0x1809007e, 0x2010bb4b,
		0x201782da, 0x18178276, 0x200fc34b, 0x201782db, 0x1817826e, 0x260fcb4b, 0x000200dc, 0x5e0a00f0, 0x0021133f, 0x20018201, 0x2203824c, 0x82e40201,
		0x00032a25, 0x001c0013, 0x01760100, 0x242f827f, 0x00c101ae, 0x241b8214, 0x00440002, 0x201d8252, 0x271d8505, 0x8e008d00, 0x94000a00, 0x0c270182,
		0x75016f01, 0x85010d00, 0x00022129, 0x7f202195, 0xb8202182, 0x1e204b82, 0x21834398, 0xb701ae24, 0x6d841e00, 0xa0011222, 0x07202982, 0x1b227b82,
		0x6d840000, 0x6d840820, 0x70010a3a, 0x0b007401, 0x7e017701, 0xaf011000, 0x1800b601, 0xc001b901, 0x02002000, 0x8506cb42, 0x840120b9, 0x828d20c9,
		0x840020a5, 0x84022037, 0x820320a5, 0x152a085b, 0x0c000b00, 0x12001000, 0x3e002300, 0x40003f00, 0x60005e00, 0x72006c00, 0x74007300, 0x7c007800,
		0x96008600, 0x58019a00, 0x2d825d01, 0x56187f20, 0xd808341f, 0x00790077, 0x00bc00bb, 0x00be00bd, 0x00c000bf, 0x00c200c1, 0x00c400c3, 0x00c600c5,
		0x00c800c7, 0x00ca00c9, 0x00cc00cb, 0x00ce00cd, 0x00d000cf, 0x00d300d1, 0x00d500d4, 0x00d700d6, 0x00d900d8, 0x00dc00da, 0x00e000de, 0x00e400e2,
		0x00e800e6, 0x00ec00ea, 0x00f000ee, 0x00f400f2, 0x00f800f6, 0x00fc00fa, 0x010001fe, 0x01040102, 0x01080106, 0x010d010a, 0x0111010f, 0x01150113,
		0x01190117, 0x011d011b, 0x0121011f, 0x01250123, 0x01290127, 0x012d012b, 0x0131012f, 0x01350133, 0x01390137, 0x013d013b, 0x0141013f, 0x01450143,
		0x01490147, 0x014d014b, 0x0151014f, 0x01550153, 0x015a0157, 0x0167015c, 0x016b0169, 0x0002006d, 0x04530402, 0x0400005a, 0x00860486, 0x280f8408,
		0x006a0463, 0x04950400, 0x220f8695, 0x827a0473, 0x04bf220f, 0x220f82bf, 0x84010000, 0x26078301, 0x001a1900, 0x82140000, 0x08028203, 0x3012192e,
		0x060e1982, 0x48862a09, 0x010df786, 0x82a00207, 0x8230ff18, 0x0102fb18, 0x300b3101, 0x2b050609, 0x1a02030e, 0x61300005, 0x062b0a06, 0x8221d882,
		0x25de8237, 0x513053a0, 0x118a2c30, 0x1ea21c26, 0x3c001c80, 0x4f2c0184, 0x73006200, 0x6c006f00, 0x74006500, 0x3e210382, 0x21018200, 0x4c8a2130,
		0x14042c08, 0x381c7860, 0x0dc93bd3, 0xf1b582cc, 0x072d286c, 0x8e0b8379, 0x821382a0, 0x56058230, 0x3e048230, 0x010203a0, 0x20020202, 0x880d3005,
		0x0501219c, 0x81218682, 0x2c9684cf, 0x06045503, 0x53550213, 0x0e301031, 0x2d0c8206, 0x41071308, 0x6f7a6972, 0x1331616e, 0x11831130, 0x0a130730,
		0x746f6353, 0x61647374, 0x2531656c, 0x14832330, 0x130a2208, 0x6174531c, 0x65696672, 0x5420646c, 0x6e686365, 0x676f6c6f, 0x2c736569, 0x636e4920,
		0x303a312e, 0x37268338, 0x6831130b, 0x3a707474, 0x65632f2f, 0x66697472, 0x74616369, 0x732e7365, 0x74203a87, 0x2e333982, 0x2f6d6f63, 0x6f706572,
		0x6f746973, 0x312f7972, 0x83343036, 0x1303223b, 0x2e62892d, 0x76726553, 0x73656369, 0x6f6f5220, 0x89432074, 0x4120334c, 0x6f687475, 0x79746972,
		0x0d171e30, 0x35303131, 0x0d6b3330, 0x825a2005, 0x8a36200e, 0x8130220e, 0x22f1dbc1, 0x85313033, 0x8a2a20f1, 0x22ea9ff1, 0x852d302f, 0x922620ea,
		0x695428ea, 0x7473656d, 0x8a706d61, 0x018222e3, 0x0bc84122, 0x05012d09, 0x01820300, 0x8230000f, 0x82020a01, 0xf2000101, 0xbaa591b3, 0x0d49d6d7,
		0xc2d67df6, 0xfbce902d, 0x1a5a60e9, 0x9c191563, 0x9ba030b4, 0x06ea78d4, 0x9ded3b43, 0x26322823, 0xe825325f, 0x3e0d8595, 0x20b4804f, 0x5ea29cb0,
		0xfa8f513e, 0xb2bb2e93, 0x113bc6ca, 0x20005602, 0x8429418b, 0x79352bb4, 0x0769b0fb, 0x725d88f1, 0xcbe2c0ad, 0xaf250e45, 0xd6c2b4c4, 0x61b465ac,
		0x2ddfe21a, 0x97760c12, 0x794c1963, 0x740cbb3c, 0x1901f566, 0x0de25059, 0x24595f9b, 0x991f39fa, 0x557089d3, 0xa699a648, 0xa67be00b, 0x8ae52028,
		0xad925dcb, 0x80ff2850, 0x2f2acc20, 0xb9f1bfd3, 0x3d5e4aab, 0x08757a97, 0x029915a1, 0xcced5e5f, 0x81d640a7, 0x45e85d55, 0xffbbee27, 0xc218f89d,
		0xecb7f580, 0xc2ceb074, 0xf7333e3f, 0x0b1cc1ef, 0x65c948d5, 0x0b6d3732, 0x4f55c955, 0xbf1c22cd, 0x2f94f19f, 0xa8a0ab2b, 0x2c437430, 0x204b8ae7,
		0x40ab220d, 0x02cb5178, 0x01000103, 0x460182a3, 0x42018230, 0x03060c30, 0x01131d55, 0x0204ff01, 0x0e300030, 0x0f200d83, 0x04260d83, 0xc0060203,
		0x0f831630, 0x0f832520, 0x0a300c2e, 0x062b0806, 0x07050501, 0x1d300803, 0x0e3a1783, 0x14041604, 0x20a323ca, 0x726bb1b4, 0x9a6fba9f, 0xc90b3e83,
		0xa7d8b1d8, 0x1e831f30, 0x1804233c, 0x14801630, 0x1a7fc6b4, 0x759bcc43, 0x4bc42f5d, 0x10988bf2, 0x1051f1e9, 0x4b873a30, 0x04010127, 0x302c302e,
		0x230f872a, 0x1e860130, 0x23061c42, 0x7073636f, 0x21120643, 0x5c833930, 0x32041f2c, 0x2e303030, 0x2aa02ca0, 0x30862886, 0x6c726322, 0x73272f92,
		0x6f727366, 0x822e746f, 0x5330211d, 0x20373a83, 0x4a304c04, 0x0b064830, 0x01488660, 0x016efd86, 0x30021807, 0x87373039, 0x01022382, 0x51832b16,
		0x92437320, 0x1ea04206, 0x090e3444, 0x0182030c, 0x53180001, 0xa7ac747e, 0xea2ba37a, 0x3cd25978, 0xf7c2f9c2, 0x37425f25, 0x61113c5b, 0xff03a61c,
		0xbe686a34, 0x21a422da, 0x9085485a, 0xabce4d55, 0xc634cba6, 0xbaadc6c0, 0x0bbe80b6, 0xe4a7c079, 0xe71aa7da, 0xc81e57cf, 0xdfeff939, 0xa0d03030,
		0x8d5caf2a, 0x4c2d5325, 0xb46df5f7, 0x52ae727b, 0xeab9b7a3, 0x3a3e8355, 0x1a944b45, 0xd6166496, 0xafe360e8, 0x25548d35, 0xd6f85b4c, 0xab04d937,
		0x4ae036b8, 0x690afb89, 0xe157cc6f, 0xb222dcea, 0x1e41c5b5, 0x9ee963d7, 0xc3b2ac64, 0x77dabec7, 0x369d58e0, 0x86ae9901, 0x1d386617, 0xc6f664bd,
		0x2f105e52, 0xcbcad060, 0x6f72c4c3, 0x22448536, 0x41c59c40, 0x6c233354, 0xd98ea37b, 0xaaf18558, 0xbb7e34b8, 0x5468aeb5, 0x520c2078, 0x4bb24d93,
		0x88c1f201, 0x6ccd9547, 0x4ca853d2, 0x8c3e18f0, 0x8ac4a333, 0x9273cecf, 0xed8f2249, 0x7c9cc8bb, 0x8230ab63, 0x82300004, 0x5945e802, 0x00012105,
		0x210e2341, 0x65446330, 0x3021220d, 0x0530451f, 0x68541832, 0x6f472065, 0x64614420, 0x47207964, 0x70756f72, 0x22062c45, 0x442f3031, 0x2820053a,
		0x43261e88, 0x7373616c, 0xe9443220, 0x6f69220a, 0x0a07446e, 0x0d171e2a, 0x36303430, 0x37313932, 0x30240582, 0x330d175a, 0x84e50e8b, 0x20018222,
		0x09118c44, 0x30000d13, 0x02080182, 0x00010182, 0xead79dde, 0xa1491857, 0x5fd7eb5b, 0xbeea8648, 0xefe4ffdd, 0x65f41c67, 0x7157b368, 0xbb775ea0,
		0xe9499bed, 0x563d8070, 0x6f086318, 0xd0ccf2da, 0x54027f3f, 0xd8105422, 0xc0d481b2, 0x7f4b3d75, 0x3ec377c7, 0x031aab78, 0x2f6b20b5, 0xc5b12b6a,
		0xbbc47e88, 0xd8c1b01e, 0xaa6f2745, 0x87f75837, 0x2dd8d726, 0xb717a9f6, 0x4e36721f, 0x653f17a6, 0x2adb9298, 0xfea25d6e, 0xde0be088, 0x158de57f,
		0x3acbebe1, 0xa212e2d5, 0x8ed82d13, 0x3d125faf, 0x080508a0, 0x65a55cb6, 0x99450438, 0x6060a31e, 0xa541c574, 0x621b6272, 0x5f6f1fc5, 0x02be421a,
		0xaea86551, 0xfc6a1823, 0x4da90378, 0xfac3807f, 0xa1fc5aab, 0x19caa440, 0xc8b2fe16, 0x0d735eef, 0x9abd77ee, 0xbc9879f6, 0xa26707b1, 0xa0dd0d15,
		0x7b44c658, 0x28623e0a, 0x0741ba5f, 0x11cf5853, 0xc574387e, 0x69b5fff8, 0x74848f90, 0xaf1b97ea, 0xa3030102, 0x8130c081, 0x0a5244bd, 0xb0c4d236,
		0x4cd491d2, 0x61b37111, 0xfea13dcb, 0xd46aa8dd, 0x8d8130e3, 0x26055344, 0x81308581, 0x93148082, 0x67a12323, 0xd54165a4, 0x01822264, 0x06374500,
		0x30050426, 0xff010103, 0x090edf42, 0x0182030c, 0x4b320001, 0x3ecab2f3, 0xc612fc91, 0x8e8c07a1, 0x0633a077, 0x1e905c14, 0xa608f718, 0xf9190a3d,
		0x6e118087, 0x1796e469, 0x9134ff30, 0xee387263, 0xa3011ccc, 0xa428941d, 0xc47af631, 0xe5f6d754, 0xa2035831, 0xdb62cecc, 0xb5734594, 0x24c945bf,
		0x0282d5b5, 0x697923ad, 0x4db6b88d, 0xca4ccfce, 0x1ce82333, 0x8b9daa88, 0xc9166e41, 0x9e89e520, 0x70da3bcd, 0x26997ef7, 0x25541420, 0x85736eab,
		0x9d219be6, 0x0e826c0a, 0x0cc2f8a8, 0x6c1e10fa, 0x0d87ef96, 0x8b610fc4, 0x2b83eead, 0x928ef895, 0xeb397284, 0xed83ea20, 0x6e97cd83, 0x4eebbc08,
		0x2b73b626, 0x4cf6d3e4, 0xe27126fe, 0x4a741161, 0x871a57ff, 0x2e48750f, 0x176951cf, 0x611202a0, 0x40d1d595, 0xee4c10b2, 0x4310acc4, 0x0a9ea5a6,
		0x9a6295d5, 0x8288cf0d, 0xe40c32c5, 0xe6459f2b, 0x9c289f0d, 0x5a2ab9b1, 0x0f37ad57, 0xdb7f1daf, 0x82309fbd, 0x8230de04, 0x0344c603, 0x03022205,
		0x0e244101, 0x3364a941, 0x0d171e30, 0x31313630, 0x31303631, 0x37333435, 0x320d175a, 0x30220e8b, 0x8a44ca81, 0x26e2490d, 0x18301a22, 0x2b05b144,
		0x446f4711, 0x79646461, 0x6d6f632e, 0x4806aa44, 0xd74914e5, 0x6f672208, 0x492f8764, 0x31230ad1, 0x482e3030, 0x272005e5, 0x2508df44, 0x75636553,
		0xde446572, 0x11312317, 0x31830f30, 0x0813052b, 0x36393730, 0x37383239, 0x1ff94830, 0x2dc4ff08, 0x9c8c15d5, 0x32ec4c26, 0xb85feb35, 0xa65a0159,
		0x3b598161, 0xe3ab6370, 0x2ac73ddc, 0xd333c9b8, 0xed3ae479, 0x8423303c, 0x1430b38e, 0xc387b2b6, 0x0454953d, 0xdd99df9e, 0x211e250b, 0x7e2965de,
		0x54a9a835, 0x32f7f6eb, 0x5526d439, 0xfbefad95, 0xd78658fe, 0x8d00f49e, 0xbd0c2a8c, 0xa7ce0442, 0xeef6043f, 0xefaaf280, 0x6669a152, 0xad1abeda,
		0x662cda5d, 0xbb6b1aea, 0x4a511ae5, 0xc7482f00, 0xb9d87598, 0xf8eec829, 0x9c0a6d66, 0x78fcf3b3, 0xa3f8a27c, 0xf3c3b5f2, 0xc1917ab9, 0x2e25e6a7,
		0x12eda89c, 0xf66a6e65, 0x70534412, 0x9cc39530, 0x3d2b582b, 0xf24a7408, 0xbfb051be, 0x274cd087, 0x35b56b58, 0x17af9dc5, 0x8f0bf831, 0x3681adee,
		0x98088905, 0x25af3acf, 0xea49c087, 0xf767fda7, 0xcc978e45, 0x36e23914, 0x1a7eb585, 0xf616fd37, 0x749a1171, 0x13fe1630, 0x843fa394, 0xf9484f0d,
		0x30322407, 0x442e0182, 0xfd330a70, 0x933261ac, 0xe2d6456c, 0x9a5f85ee, 0x9976e7ba, 0x48e7cc68, 0x6d440cc3, 0x12302113, 0x2a083949, 0x01063008,
		0x0102ff01, 0x48333000, 0x01270744, 0x30270401, 0x48233025, 0x17200ad7, 0x2406a648, 0x7073636f, 0x0a06422e, 0x48463021, 0x3f2a05d0, 0x3b303d30,
		0x37a039a0, 0x104c3586, 0x15384213, 0x64672f22, 0x2008dd48, 0x05dd484b, 0x4230442e, 0x04064030, 0x00201d55, 0x36303830, 0x4b0ad648, 0x90420b76,
		0x0d094a1e, 0x43060121, 0x0c090ebc, 0x01018203, 0xc086d200, 0xa1f9bdec, 0x66ee67b6, 0x3a06a20b, 0x158e5004, 0x744aac72, 0x37cb5395, 0xef4944cb,
		0x336b9007, 0x94f096d9, 0x3013a556, 0x32853c05, 0xc7c97b21, 0xa424a80a, 0xd346de90, 0x03142325, 0xd610c267, 0x7b5d0f6f, 0xc59fcc7a, 0xc4c12a58,
		0x5aa8219e, 0x46a4acf3, 0x63e49ef3, 0xa4902fcb, 0xd9012929, 0xdf292c72, 0xbc270137, 0xd368ee4f, 0xb3c08f21, 0xed09f5e4, 0x53aa10d2, 0xccf0beb4,
		0x3bd60b59, 0x24951c96, 0xeccedf49, 0x9148a7fd, 0x3a0e4514, 0x45da6f36, 0x41a245b3, 0x44d7d4c9, 0x74b93e4e, 0x13a2d576, 0x87c62c55, 0xac99b5a3,
		0x7f878406, 0xbffc0675, 0xcc0e4c14, 0x3ddfc46e, 0xf47112b7, 0x4051f1e8, 0xe0492822, 0xa8874b1d, 0xa206cc34, 0xd15a12dd, 0x03643686, 0x776f6f35,
		0x85f2eb6e, 0xab5e9850, 0x91ad5303, 0x161f6323, 0xb2b9cd9c, 0xe13a6305, 0x171b68f4, 0x53953505, 0x058230ee, 0x0482303e, 0x05e14426, 0xef0b0626,
		0x7b69bff4, 0x440e2841, 0x1e33cd60, 0x39300d17, 0x34323930, 0x34343331, 0x175a3332, 0x8a32310d, 0x6b30210e, 0x250a4c45, 0x0f314247, 0x2f4f0d30,
		0x4c062605, 0x6f646e6f, 0x2110876e, 0x10871307, 0x1a301c22, 0x21054745, 0x6a184413, 0x69260b5b, 0x6574696d, 0x1d863164, 0x93130321, 0x20ed441d,
		0x04a2ff08, 0xdbd8e65f, 0xf3a2a1d2, 0xe734c57e, 0xfbaed872, 0xa4eccf95, 0x001d0eea, 0x16db9207, 0x1f53acf6, 0x0194f135, 0x908ea39c, 0xe0460899,
		0x912b0f05, 0x0bffa6b6, 0x2bba0c1b, 0xe6626e46, 0x410ba789, 0xc0e614f5, 0x72556bea, 0xcf8e5d11, 0x893358dc, 0x7590e5ff, 0x2dccc3dc, 0x03d63e60,
		0x54c6a9e9, 0xecbc943e, 0x7a36918a, 0xd8fd55ed, 0x46276b3d, 0xdbd45f09, 0xf7a25fc1, 0x7e88e488, 0xe082e3fa, 0x5162422f, 0x30c6bb46, 0xccb27b71,
		0xed76338c, 0xad99b5e0, 0xe30d1dc3, 0x31787788, 0x1552543c, 0xccdcde6c, 0x9b1c9770, 0xf738f485, 0x274b4705, 0x3ca35db0, 0x28a52266, 0x94760a97,
		0x8fbbc167, 0x06f01a9f, 0x5891807c, 0x2020751a, 0x0b5a9406, 0xed26ef71, 0xd3825ef2, 0x93e60b9a, 0x411607b7, 0xd4d562ea, 0xaa938cd2, 0xd734c1f8,
		0x458dfb8a, 0x8c6f6e4c, 0x8d01af7c, 0xeb31f466, 0xed441dae, 0x30862607, 0x30820182, 0x08ad440f, 0x03300527, 0x30000101, 0x21108313, 0xd74d0425,
		0x4303200b, 0x07230df5, 0x44323080, 0x2b2a059a, 0x27302930, 0x23a025a0, 0x6b4d2186, 0x0b91440a, 0x73646725, 0x4d302d32, 0x6d231864, 0x4d170701,
		0xf6501464, 0x16e5440f, 0x80813022, 0x240a5945, 0x30723074, 0x0a594524, 0x59451820, 0x302f2216, 0x2225884a, 0x453e8602, 0x5f2c2c55, 0x65746e69,
		0x64656d72, 0x65746169, 0x7420d782, 0x460c1046, 0x144f1431, 0x66683309, 0x55671030, 0xe9a1b3a1, 0x1175c637, 0x85e33389, 0x184413d7, 0x0312090e,
		0x00010182, 0x093e56bd, 0xfa7d13b4, 0x45fed3ed, 0x19dfdfb6, 0x8ca3f848, 0x8f5411d5, 0x134492d4, 0xa36971c1, 0x800630c3, 0xae37da1d, 0xd96847ca,
		0x360925b3, 0x3b04e90c, 0x1051dbe2, 0x5e10fe74, 0x0f3bdec9, 0x9eb10324, 0xa0c39639, 0xca524c0f, 0x116642e7, 0x4968755a, 0x6b232d3a, 0x43c4065e,
		0xb1019ef1, 0x9ca50b2f, 0x3d3e1e12, 0xb05a6e18, 0x2e3f7495, 0x6d30e14b, 0x6f9ec373, 0x470fe3af, 0x6024ddfa, 0x635ca764, 0xb7a9dd00, 0xc7653450,
		0xfe490528, 0xea187a5a, 0xb646c01c, 0x81d92a9a, 0xca91b265, 0x887bd60c, 0xe93eeaf0, 0x87305518, 0xa891afcf, 0x6b08231e, 0x06999045, 0x0d3791dc,
		0x66ddd4bf, 0xf400555f, 0x60ede3f1, 0x973e9534, 0x6acac2a2, 0x3040618d, 0x01a5c491, 0x60d05b06, 0x1f344f6d, 0x31099d7e, 0x78e9e553, 0xc483d096,
		0x62e5bdaa, 0x221c32aa, 0x2e124e23, 0x9fb6087c, 0x96235cdf, 0xfe048231, 0xfa048230, 0x30010102, 0x2b45d581, 0x460220cc, 0xd654070f, 0x81a02409,
		0x54103086, 0x0c290ac7, 0x00300231, 0x09061430, 0x05eb542b, 0x3101282c, 0x00050307, 0x00000003, 0x89541930, 0x03092308, 0x348a0c31, 0x1c300422,
		0x0b230d8a, 0x8b300e31, 0x3015221d, 0x38388923, 0x04163104, 0x7bbc4914, 0xe8f32059, 0xf7d4101e, 0x174116d9, 0x486fcd0b, 0x0b8a426a, 0x05010e09,
		0x01820400, 0x1ac15a00, 0x7c62e627, 0x81377520, 0x3f5b3af2, 0x2b804396, 0xba63d13b, 0xd45d48a4, 0x244d4c56, 0x31a79a6b, 0xbcd40a76, 0xb2806f21,
		0x416dbdf2, 0xa0faf966, 0x4b46cd4f, 0xe704a875, 0xa3fce5ef, 0x82fe4f9d, 0x57bcbe33, 0x6e41439c, 0x23bc502c, 0x17dcd1f2, 0xa42badb8, 0xfd200255,
		0x7d20d12e, 0x6cf54cfa, 0xc8d2a5d0, 0xd129c6aa, 0x94524633, 0xae271fde, 0xe606c6f9, 0xfcc4df0b, 0x8aea412d, 0xb7abb5de, 0x9efdbeb7, 0x2804dbe0,
		0x1fd9d76c, 0xadb29cb8, 0xb1dda831, 0xb7307203, 0x97a25ef2, 0xf6ef6825, 0xe172eb61, 0x624498c3, 0xf2e99372, 0x5e89171a, 0x3d2c1f42, 0x5b4bd427,
		0x9a302643, 0xc2ba409c, 0xcf8f9b45, 0x686b3300, 0x0fd240b9, 0x61f082ff, 0xdf81c2e2, 0xf9349852, 0x2f098df2, 0xae8b96ef, 0x5c326604, 0xf4aa05d8,
		0xcee65392, 0xbccfbce3, 0x151d8eaa, 0x038f1ebc, 0x4c855556, 0x0282a16e, 0x02823074, 0x093d4170, 0x82310624, 0x12826102, 0x01025d27, 0xd6813001,
		0xd00c5630, 0x2312f156, 0x18305da0, 0x22090141, 0x880b3103, 0x0107230c, 0x0c881c30, 0x31050932, 0x310d170f, 0x32393031, 0x34353132, 0x5a333430,
		0x33107742, 0xe8263897, 0xfe04f700, 0x7fcb23b2, 0x485da4d1, 0x34392dd8, 0x09127742, 0x91f5c801, 0x3190f2e0, 0xb28684cc, 0x15896650, 0x4c0576a7,
		0x80523da2, 0x5670d239, 0x891d3388, 0x86e7c443, 0xc21b7b8c, 0xbf71b344, 0xba8c0a44, 0xc2cd67b1, 0xa826e8dc, 0x43429969, 0x61489346, 0x76560c9d,
		0xcd30afa1, 0x34fd134c, 0xafa56d74, 0x777a3c5b, 0x3e7c96f8, 0x89cfcef8, 0x3b625052, 0x76a1ce42, 0x1815a0f3, 0x9701ac24, 0xe34c8689, 0x2491c2ea,
		0x512a11a9, 0xdae001ad, 0xbab76b76, 0xc645e1b2, 0x6cc5eb3c, 0x9265156d, 0x1fbeb480, 0xb70af670, 0x7d5f0213, 0x0ccc6c2b, 0xc1380e86, 0xe1451ff6,
		0x9a3a17b8, 0xeed36ff8, 0xd5939d56, 0xee01a60b, 0xfd83928a, 0x4bce3300, 0xe633851a, 0x88d0d3c0, 0x98b977b1, 0xb130c6c2, 0x925aeb86, 0x4a0298e8,
		0x41c30b1a, 0x865c4594, 0x0258f271, 0x7fff46d8, 0x230031bd, 0x696419b1, 0xbacee821, 0x9271a56e, 0x1cd0616b, 0x68cee50c, 0x594e1437, 0x050000d1,
		0x5e827afa, 0x00000001,
};

static const char* GetDefaultCompressedFontDataTTFBase85()
{
  return proggy_clean_ttf_compressed_data_base85;
}

#endif // #ifndef IMGUI_DISABLE
```

`horizon/imgui/imgui_impl_dx11.cpp`:

```cpp
// dear imgui: Renderer for DirectX11
// This needs to be used along with a Platform Binding (e.g. Win32)

// Implemented features:
//  [X] Renderer: User texture binding. Use 'ID3D11ShaderResourceView*' as ImTextureID. Read the FAQ about ImTextureID!
//  [X] Renderer: Support for large meshes (64k+ vertices) with 16-bit indices.

// You can copy and use unmodified imgui_impl_* files in your project. See main.cpp for an example of using this.
// If you are new to dear imgui, read examples/README.txt and read the documentation at the top of imgui.cpp
// https://github.com/ocornut/imgui

// CHANGELOG
// (minor and older changes stripped away, please see git history for details)
//  2019-08-01: DirectX11: Fixed code querying the Geometry Shader state (would generally error with Debug layer enabled).
//  2019-07-21: DirectX11: Backup, clear and restore Geometry Shader is any is bound when calling ImGui_ImplDX10_RenderDrawData. Clearing Hull/Domain/Compute shaders without backup/restore.
//  2019-05-29: DirectX11: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.
//  2019-04-30: DirectX11: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.
//  2018-12-03: Misc: Added #pragma comment statement to automatically link with d3dcompiler.lib when using D3DCompile().
//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.
//  2018-08-01: DirectX11: Querying for IDXGIFactory instead of IDXGIFactory1 to increase compatibility.
//  2018-07-13: DirectX11: Fixed unreleased resources in Init and Shutdown functions.
//  2018-06-08: Misc: Extracted imgui_impl_dx11.cpp/.h away from the old combined DX11+Win32 example.
//  2018-06-08: DirectX11: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.
//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplDX11_RenderDrawData() in the .h file so you can call it yourself.
//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.
//  2016-05-07: DirectX11: Disabling depth-write.

#include "imgui.hpp"
#include "imgui_impl_dx11.hpp"
#include "imgui_shader_dx11.hpp"

#include "../constant/character.hpp"
#include "../constant/hash.hpp"
#include "../constant/secure_string.hpp"
#include "../constant/string.hpp"

#include "../core/map_data.hpp"

#include "../memory/operation.hpp"

#include "../win32/time.hpp"
#include "../win32/trace.hpp"

using namespace horizon;

// DirectX
#include <stdio.h>
#include <d3d11.h>

// DirectX data
ID3D11Device* g_pd3dDevice = nullptr;
ID3D11DeviceContext* g_pd3dDeviceContext = nullptr;
IDXGIFactory* g_pFactory = nullptr;
ID3D11Buffer* g_pVB = nullptr;
ID3D11Buffer* g_pIB = nullptr;
ID3D10Blob* g_pVertexShaderBlob = nullptr;
ID3D11VertexShader* g_pVertexShader = nullptr;
ID3D11InputLayout* g_pInputLayout = nullptr;
ID3D11Buffer* g_pVertexConstantBuffer = nullptr;
ID3D10Blob* g_pPixelShaderBlob = nullptr;
ID3D11PixelShader* g_pPixelShader = nullptr;
ID3D11SamplerState* g_pFontSampler = nullptr;
ID3D11ShaderResourceView* g_pFontTextureView = nullptr;
ID3D11RasterizerState* g_pRasterizerState = nullptr;
ID3D11BlendState* g_pBlendState = nullptr;
ID3D11DepthStencilState* g_pDepthStencilState = nullptr;

int g_VertexBufferSize = 5000;
int g_IndexBufferSize = 10000;

win32::LARGE_INTEGER g_dx11_counter = { };
win32::LARGE_INTEGER g_dx11_frequency = { };

struct VERTEX_CONSTANT_BUFFER
{
	float mvp[ 4 ][ 4 ] = { };
};

void ImGui_ImplDX11_SetupRenderState( ImDrawData* draw_data, ID3D11DeviceContext* ctx )
{
	// Setup viewport
	D3D11_VIEWPORT vp;
	memset( &vp, 0, sizeof( D3D11_VIEWPORT ) );
	vp.Width = draw_data->DisplaySize.x;
	vp.Height = draw_data->DisplaySize.y;
	vp.MinDepth = 0.0f;
	vp.MaxDepth = 1.0f;
	vp.TopLeftX = vp.TopLeftY = 0;
	ctx->RSSetViewports( 1, &vp );

	// Setup shader and vertex buffers
	unsigned int stride = sizeof( ImDrawVert );
	unsigned int offset = 0;
	ctx->IASetInputLayout( g_pInputLayout );
	ctx->IASetVertexBuffers( 0, 1, &g_pVB, &stride, &offset );
	ctx->IASetIndexBuffer( g_pIB, sizeof( ImDrawIdx ) == 2 ? DXGI_FORMAT_R16_UINT : DXGI_FORMAT_R32_UINT, 0 );
	ctx->IASetPrimitiveTopology( D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST );
	ctx->VSSetShader( g_pVertexShader, NULL, 0 );
	ctx->VSSetConstantBuffers( 0, 1, &g_pVertexConstantBuffer );
	ctx->PSSetShader( g_pPixelShader, NULL, 0 );
	ctx->PSSetSamplers( 0, 1, &g_pFontSampler );
	ctx->GSSetShader( NULL, NULL, 0 );
	ctx->HSSetShader( NULL, NULL, 0 ); // In theory we should backup and restore this as well.. very infrequently used..
	ctx->DSSetShader( NULL, NULL, 0 ); // In theory we should backup and restore this as well.. very infrequently used..
	ctx->CSSetShader( NULL, NULL, 0 ); // In theory we should backup and restore this as well.. very infrequently used..

	// Setup blend state
	const float blend_factor[ 4 ] = { 0.f, 0.f, 0.f, 0.f };
	ctx->OMSetBlendState( g_pBlendState, blend_factor, 0xffffffff );
	ctx->OMSetDepthStencilState( g_pDepthStencilState, 0 );
	ctx->RSSetState( g_pRasterizerState );
}

// Render function
// (this used to be set in io.RenderDrawListsFn and called by ImGui::Render(), but you can now call this directly from your main loop)
void ImGui_ImplDX11_RenderDrawData( ImDrawData* draw_data )
{
	// Avoid rendering when minimized
	if( draw_data->DisplaySize.x <= 0.0f || draw_data->DisplaySize.y <= 0.0f )
		return;

	ID3D11DeviceContext* ctx = g_pd3dDeviceContext;

	// Create and grow vertex/index buffers if needed
	if( !g_pVB || g_VertexBufferSize < draw_data->TotalVtxCount )
	{
		if( g_pVB )
		{
			g_pVB->Release(); g_pVB = NULL;
		}
		g_VertexBufferSize = draw_data->TotalVtxCount + 5000;
		D3D11_BUFFER_DESC desc;
		memset( &desc, 0, sizeof( D3D11_BUFFER_DESC ) );
		desc.Usage = D3D11_USAGE_DYNAMIC;
		desc.ByteWidth = g_VertexBufferSize * sizeof( ImDrawVert );
		desc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
		desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
		desc.MiscFlags = 0;
		if( g_pd3dDevice->CreateBuffer( &desc, NULL, &g_pVB ) < 0 )
			return;
	}
	if( !g_pIB || g_IndexBufferSize < draw_data->TotalIdxCount )
	{
		if( g_pIB )
		{
			g_pIB->Release(); g_pIB = NULL;
		}
		g_IndexBufferSize = draw_data->TotalIdxCount + 10000;
		D3D11_BUFFER_DESC desc;
		memset( &desc, 0, sizeof( D3D11_BUFFER_DESC ) );
		desc.Usage = D3D11_USAGE_DYNAMIC;
		desc.ByteWidth = g_IndexBufferSize * sizeof( ImDrawIdx );
		desc.BindFlags = D3D11_BIND_INDEX_BUFFER;
		desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
		if( g_pd3dDevice->CreateBuffer( &desc, NULL, &g_pIB ) < 0 )
			return;
	}

	// Upload vertex/index data into a single contiguous GPU buffer
	D3D11_MAPPED_SUBRESOURCE vtx_resource, idx_resource;
	if( ctx->Map( g_pVB, 0, D3D11_MAP_WRITE_DISCARD, 0, &vtx_resource ) != S_OK )
		return;
	if( ctx->Map( g_pIB, 0, D3D11_MAP_WRITE_DISCARD, 0, &idx_resource ) != S_OK )
		return;
	ImDrawVert* vtx_dst = ( ImDrawVert* )vtx_resource.pData;
	ImDrawIdx* idx_dst = ( ImDrawIdx* )idx_resource.pData;
	for( int n = 0; n < draw_data->CmdListsCount; n++ )
	{
		const ImDrawList* cmd_list = draw_data->CmdLists[ n ];
		memcpy( vtx_dst, cmd_list->VtxBuffer.Data, cmd_list->VtxBuffer.Size * sizeof( ImDrawVert ) );
		memcpy( idx_dst, cmd_list->IdxBuffer.Data, cmd_list->IdxBuffer.Size * sizeof( ImDrawIdx ) );
		vtx_dst += cmd_list->VtxBuffer.Size;
		idx_dst += cmd_list->IdxBuffer.Size;
	}
	ctx->Unmap( g_pVB, 0 );
	ctx->Unmap( g_pIB, 0 );

	// Setup orthographic projection matrix into our constant buffer
	// Our visible imgui space lies from draw_data->DisplayPos (top left) to draw_data->DisplayPos+data_data->DisplaySize (bottom right). DisplayPos is (0,0) for single viewport apps.
	{
		D3D11_MAPPED_SUBRESOURCE mapped_resource;
		if( ctx->Map( g_pVertexConstantBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &mapped_resource ) != S_OK )
			return;
		VERTEX_CONSTANT_BUFFER* constant_buffer = ( VERTEX_CONSTANT_BUFFER* )mapped_resource.pData;
		float L = draw_data->DisplayPos.x;
		float R = draw_data->DisplayPos.x + draw_data->DisplaySize.x;
		float T = draw_data->DisplayPos.y;
		float B = draw_data->DisplayPos.y + draw_data->DisplaySize.y;
		float mvp[ 4 ][ 4 ] =
		{
				{ 2.0f / ( R - L ),   0.0f,           0.0f,       0.0f },
				{ 0.0f,         2.0f / ( T - B ),     0.0f,       0.0f },
				{ 0.0f,         0.0f,           0.5f,       0.0f },
				{ ( R + L ) / ( L - R ),  ( T + B ) / ( B - T ),    0.5f,       1.0f },
		};
		memcpy( &constant_buffer->mvp, mvp, sizeof( mvp ) );
		ctx->Unmap( g_pVertexConstantBuffer, 0 );
	}

	// Backup DX state that will be modified to restore it afterwards (unfortunately this is very ugly looking and verbose. Close your eyes!)
	struct BACKUP_DX11_STATE
	{
		UINT                        ScissorRectsCount, ViewportsCount;
		D3D11_RECT                  ScissorRects[ D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE ];
		D3D11_VIEWPORT              Viewports[ D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE ];
		ID3D11RasterizerState* RS;
		ID3D11BlendState* BlendState;
		FLOAT                       BlendFactor[ 4 ];
		UINT                        SampleMask;
		UINT                        StencilRef;
		ID3D11DepthStencilState* DepthStencilState;
		ID3D11ShaderResourceView* PSShaderResource;
		ID3D11SamplerState* PSSampler;
		ID3D11PixelShader* PS;
		ID3D11VertexShader* VS;
		ID3D11GeometryShader* GS;
		UINT                        PSInstancesCount, VSInstancesCount, GSInstancesCount;
		ID3D11ClassInstance* PSInstances[ 256 ], * VSInstances[ 256 ], * GSInstances[ 256 ];   // 256 is max according to PSSetShader documentation
		D3D11_PRIMITIVE_TOPOLOGY    PrimitiveTopology;
		ID3D11Buffer* IndexBuffer, * VertexBuffer, * VSConstantBuffer;
		UINT                        IndexBufferOffset, VertexBufferStride, VertexBufferOffset;
		DXGI_FORMAT                 IndexBufferFormat;
		ID3D11InputLayout* InputLayout;
	};
	BACKUP_DX11_STATE old;
	old.ScissorRectsCount = old.ViewportsCount = D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE;
	ctx->RSGetScissorRects( &old.ScissorRectsCount, old.ScissorRects );
	ctx->RSGetViewports( &old.ViewportsCount, old.Viewports );
	ctx->RSGetState( &old.RS );
	ctx->OMGetBlendState( &old.BlendState, old.BlendFactor, &old.SampleMask );
	ctx->OMGetDepthStencilState( &old.DepthStencilState, &old.StencilRef );
	ctx->PSGetShaderResources( 0, 1, &old.PSShaderResource );
	ctx->PSGetSamplers( 0, 1, &old.PSSampler );
	old.PSInstancesCount = old.VSInstancesCount = old.GSInstancesCount = 256;
	ctx->PSGetShader( &old.PS, old.PSInstances, &old.PSInstancesCount );
	ctx->VSGetShader( &old.VS, old.VSInstances, &old.VSInstancesCount );
	ctx->VSGetConstantBuffers( 0, 1, &old.VSConstantBuffer );
	ctx->GSGetShader( &old.GS, old.GSInstances, &old.GSInstancesCount );

	ctx->IAGetPrimitiveTopology( &old.PrimitiveTopology );
	ctx->IAGetIndexBuffer( &old.IndexBuffer, &old.IndexBufferFormat, &old.IndexBufferOffset );
	ctx->IAGetVertexBuffers( 0, 1, &old.VertexBuffer, &old.VertexBufferStride, &old.VertexBufferOffset );
	ctx->IAGetInputLayout( &old.InputLayout );

	// Setup desired DX state
	ImGui_ImplDX11_SetupRenderState( draw_data, ctx );

	// Render command lists
	// (Because we merged all buffers into a single one, we maintain our own offset into them)
	int global_idx_offset = 0;
	int global_vtx_offset = 0;
	ImVec2 clip_off = draw_data->DisplayPos;
	for( int n = 0; n < draw_data->CmdListsCount; n++ )
	{
		const ImDrawList* cmd_list = draw_data->CmdLists[ n ];
		for( int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++ )
		{
			const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[ cmd_i ];
			if( pcmd->UserCallback != NULL )
			{
				// User callback, registered via ImDrawList::AddCallback()
				// (ImDrawCallback_ResetRenderState is a special callback value used by the user to request the renderer to reset render state.)
				if( pcmd->UserCallback == ImDrawCallback_ResetRenderState )
					ImGui_ImplDX11_SetupRenderState( draw_data, ctx );
				else
					pcmd->UserCallback( cmd_list, pcmd );
			}
			else
			{
				// Apply scissor/clipping rectangle
				const D3D11_RECT r = { ( LONG )( pcmd->ClipRect.x - clip_off.x ), ( LONG )( pcmd->ClipRect.y - clip_off.y ), ( LONG )( pcmd->ClipRect.z - clip_off.x ), ( LONG )( pcmd->ClipRect.w - clip_off.y ) };
				ctx->RSSetScissorRects( 1, &r );

				// Bind texture, Draw
				ID3D11ShaderResourceView* texture_srv = ( ID3D11ShaderResourceView* )pcmd->TextureId;
				ctx->PSSetShaderResources( 0, 1, &texture_srv );
				ctx->DrawIndexed( pcmd->ElemCount, pcmd->IdxOffset + global_idx_offset, pcmd->VtxOffset + global_vtx_offset );
			}
		}
		global_idx_offset += cmd_list->IdxBuffer.Size;
		global_vtx_offset += cmd_list->VtxBuffer.Size;
	}

	// Restore modified DX state
	ctx->RSSetScissorRects( old.ScissorRectsCount, old.ScissorRects );
	ctx->RSSetViewports( old.ViewportsCount, old.Viewports );
	ctx->RSSetState( old.RS ); if( old.RS ) old.RS->Release();
	ctx->OMSetBlendState( old.BlendState, old.BlendFactor, old.SampleMask ); if( old.BlendState ) old.BlendState->Release();
	ctx->OMSetDepthStencilState( old.DepthStencilState, old.StencilRef ); if( old.DepthStencilState ) old.DepthStencilState->Release();
	ctx->PSSetShaderResources( 0, 1, &old.PSShaderResource ); if( old.PSShaderResource ) old.PSShaderResource->Release();
	ctx->PSSetSamplers( 0, 1, &old.PSSampler ); if( old.PSSampler ) old.PSSampler->Release();
	ctx->PSSetShader( old.PS, old.PSInstances, old.PSInstancesCount ); if( old.PS ) old.PS->Release();
	for( UINT i = 0; i < old.PSInstancesCount; i++ ) if( old.PSInstances[ i ] ) old.PSInstances[ i ]->Release();
	ctx->VSSetShader( old.VS, old.VSInstances, old.VSInstancesCount ); if( old.VS ) old.VS->Release();
	ctx->VSSetConstantBuffers( 0, 1, &old.VSConstantBuffer ); if( old.VSConstantBuffer ) old.VSConstantBuffer->Release();
	ctx->GSSetShader( old.GS, old.GSInstances, old.GSInstancesCount ); if( old.GS ) old.GS->Release();
	for( UINT i = 0; i < old.VSInstancesCount; i++ ) if( old.VSInstances[ i ] ) old.VSInstances[ i ]->Release();
	ctx->IASetPrimitiveTopology( old.PrimitiveTopology );
	ctx->IASetIndexBuffer( old.IndexBuffer, old.IndexBufferFormat, old.IndexBufferOffset ); if( old.IndexBuffer ) old.IndexBuffer->Release();
	ctx->IASetVertexBuffers( 0, 1, &old.VertexBuffer, &old.VertexBufferStride, &old.VertexBufferOffset ); if( old.VertexBuffer ) old.VertexBuffer->Release();
	ctx->IASetInputLayout( old.InputLayout ); if( old.InputLayout ) old.InputLayout->Release();
}

struct Shader
{
	Shader( std::uint8_t key, const std::uint8_t* const code, std::size_t size )
		: m_key( key )
		, m_code( code )
		, m_data( nullptr )
		, m_size( size )
	{
		m_data = new std::uint8_t[ m_size ];
	}

	~Shader()
	{
		memory::SafeDeleteArray( m_data );
	}

	bool empty() const
	{
		return ( m_size == 0 );
	}

	std::size_t size() const
	{
		return m_size;
	}

	const std::uint8_t* decrypt() const
	{
		for( std::size_t index = 0; index < m_size; index++ )
		{
			m_data[ index ] = m_code[ index ] ^ m_key;
		}

		return m_data;
	}

	std::uint8_t m_key = 0;
	const std::uint8_t* m_code = nullptr;
	std::uint8_t* m_data = nullptr;
	std::size_t m_size = 0;
};

bool ImGui_ImplDX11_CreateFontsTexture()
{
	auto& io = ImGui::GetIO();

	std::uint8_t* pixels = nullptr;
	
	std::int32_t width = 0;
	std::int32_t height = 0;

	io.Fonts->GetTexDataAsRGBA32( &pixels, &width, &height );

	D3D11_TEXTURE2D_DESC texture2d_desc = { };

	texture2d_desc.Width = static_cast< UINT >( width );
	texture2d_desc.Height = static_cast< UINT >( height );
	texture2d_desc.MipLevels = 1;
	texture2d_desc.ArraySize = 1;
	texture2d_desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	texture2d_desc.SampleDesc.Count = 1;
	texture2d_desc.Usage = D3D11_USAGE_DEFAULT;
	texture2d_desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	texture2d_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA subresource_data = { };
	
	subresource_data.pSysMem = pixels;
	subresource_data.SysMemPitch = texture2d_desc.Width * 4;
	subresource_data.SysMemSlicePitch = 0;

	ID3D11Texture2D* texture2d = nullptr;

	auto result = g_pd3dDevice->CreateTexture2D( &texture2d_desc, &subresource_data, &texture2d );

	if( FAILED( result ) )
	{
		TRACE( "%s: ID3D11Device::CreateTexture2D( ... ) error! (0x%08X)", ATOM_FUNCTION, result );
		return false;
	}
	
	D3D11_SHADER_RESOURCE_VIEW_DESC shader_resource_view_desc = { };

	shader_resource_view_desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	shader_resource_view_desc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
	shader_resource_view_desc.Texture2D.MipLevels = texture2d_desc.MipLevels;
	shader_resource_view_desc.Texture2D.MostDetailedMip = 0;

	result = g_pd3dDevice->CreateShaderResourceView( texture2d, &shader_resource_view_desc, &g_pFontTextureView );

	memory::SafeRelease( texture2d );

	if( FAILED( result ) )
	{
		TRACE( "%s: ID3D11Device::CreateShaderResourceView( ... ) error! (0x%08X)", ATOM_FUNCTION, result );
		return false;
	}

	// 
	// store characters texture
	// 
	io.Fonts->TexID = static_cast< ImTextureID >( g_pFontTextureView );

	D3D11_SAMPLER_DESC sampler_desc = { };

	sampler_desc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
	sampler_desc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
	sampler_desc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
	sampler_desc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
	sampler_desc.MipLODBias = 0.f;
	sampler_desc.ComparisonFunc = D3D11_COMPARISON_ALWAYS;
	sampler_desc.MinLOD = 0.f;
	sampler_desc.MaxLOD = 0.f;

	result = g_pd3dDevice->CreateSamplerState( &sampler_desc, &g_pFontSampler );

	if( FAILED( result ) )
	{
		TRACE( "%s: ID3D11Device::CreateSamplerState( ... ) error! (0x%08X)", ATOM_FUNCTION, result );
		return false;
	}

	return true;
}

bool ImGui_ImplDX11_CreateDeviceObjects()
{
	if( !g_pd3dDevice )
	{
		TRACE( "%s: g_pd3dDevice is nullptr!", ATOM_FUNCTION );
		return false;
	}

	if( g_pFontSampler )
	{
		// 
		// release resources
		// 
		ImGui_ImplDX11_InvalidateDeviceObjects();
	}

	Shader vs( g_vs_key, g_vs_code, g_vs_size );

	auto result = g_pd3dDevice->CreateVertexShader( vs.decrypt(), vs.size(), nullptr, &g_pVertexShader );

	if( FAILED( result ) )
	{
		TRACE( "%s: ID3D11Device::CreateVertexShader( ... ) error! (0x%08X)", ATOM_FUNCTION, result );
		return false;
	}

	auto position = SECURE_STRING( "POSITION" );
	auto texcoord = SECURE_STRING( "TEXCOORD" );
	auto color = SECURE_STRING( "COLOR" );

	D3D11_INPUT_ELEMENT_DESC input_element_desc[] =
	{
		{ position.decrypt(), 0, DXGI_FORMAT_R32G32_FLOAT, 0, 0x0000, D3D11_INPUT_PER_VERTEX_DATA, 0 },
		{ texcoord.decrypt(), 0, DXGI_FORMAT_R32G32_FLOAT, 0, 0x0008, D3D11_INPUT_PER_VERTEX_DATA, 0 },
		{ color.decrypt(), 0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, 0x0010, D3D11_INPUT_PER_VERTEX_DATA, 0 },
	};

	result = g_pd3dDevice->CreateInputLayout( input_element_desc, ARRAYSIZE( input_element_desc ), vs.decrypt(), vs.size(), &g_pInputLayout );

	if( FAILED( result ) )
	{
		TRACE( "%s: ID3D11Device::CreateInputLayout( ... ) error! (0x%08X)", ATOM_FUNCTION, result );
		return false;
	}

	D3D11_BUFFER_DESC buffer_desc =
	{
		sizeof( VERTEX_CONSTANT_BUFFER ),
		D3D11_USAGE_DYNAMIC,
		D3D11_BIND_CONSTANT_BUFFER,
		D3D11_CPU_ACCESS_WRITE,
		0, 0,
	};

	result = g_pd3dDevice->CreateBuffer( &buffer_desc, nullptr, &g_pVertexConstantBuffer );

	if( FAILED( result ) )
	{
		TRACE( "%s: ID3D11Device::CreateBuffer( ... ) error! (0x%08X)", ATOM_FUNCTION, result );
		return false;
	}

	Shader ps( g_ps_key, g_ps_code, g_ps_size );

	result = g_pd3dDevice->CreatePixelShader( ps.decrypt(), ps.size(), nullptr, &g_pPixelShader );

	if( FAILED( result ) )
	{
		TRACE( "%s: ID3D11Device::CreatePixelShader( ... ) error! (0x%08X)", ATOM_FUNCTION, result );
		return false;
	}

	D3D11_BLEND_DESC blend_desc = { };
	
	blend_desc.AlphaToCoverageEnable = FALSE;
	blend_desc.RenderTarget[ 0 ].BlendEnable = TRUE;
	blend_desc.RenderTarget[ 0 ].SrcBlend = D3D11_BLEND_SRC_ALPHA;
	blend_desc.RenderTarget[ 0 ].DestBlend = D3D11_BLEND_INV_SRC_ALPHA;
	blend_desc.RenderTarget[ 0 ].BlendOp = D3D11_BLEND_OP_ADD;
	blend_desc.RenderTarget[ 0 ].SrcBlendAlpha = D3D11_BLEND_INV_SRC_ALPHA;
	blend_desc.RenderTarget[ 0 ].DestBlendAlpha = D3D11_BLEND_ZERO;
	blend_desc.RenderTarget[ 0 ].BlendOpAlpha = D3D11_BLEND_OP_ADD;
	blend_desc.RenderTarget[ 0 ].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;

	result = g_pd3dDevice->CreateBlendState( &blend_desc, &g_pBlendState );

	if( FAILED( result ) )
	{
		TRACE( "%s: ID3D11Device::CreateBlendState( ... ) error! (0x%08X)", ATOM_FUNCTION, result );
		return false;
	}

	D3D11_RASTERIZER_DESC rasterizer_desc = { };

	rasterizer_desc.FillMode = D3D11_FILL_SOLID;
	rasterizer_desc.CullMode = D3D11_CULL_NONE;
	rasterizer_desc.ScissorEnable = TRUE;
	rasterizer_desc.DepthClipEnable = TRUE;

	result = g_pd3dDevice->CreateRasterizerState( &rasterizer_desc, &g_pRasterizerState );

	if( FAILED( result ) )
	{
		TRACE( "%s: ID3D11Device::CreateRasterizerState( ... ) error! (0x%08X)", ATOM_FUNCTION, result );
		return false;
	}

	D3D11_DEPTH_STENCIL_DESC depth_stencil_desc = { };

	depth_stencil_desc.DepthEnable = false;
	depth_stencil_desc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
	depth_stencil_desc.DepthFunc = D3D11_COMPARISON_ALWAYS;
	depth_stencil_desc.StencilEnable = false;
	depth_stencil_desc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
	depth_stencil_desc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
	depth_stencil_desc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
	depth_stencil_desc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
	depth_stencil_desc.BackFace = depth_stencil_desc.FrontFace;
	
	result = g_pd3dDevice->CreateDepthStencilState( &depth_stencil_desc, &g_pDepthStencilState );

	if( FAILED( result ) )
	{
		TRACE( "%s: ID3D11Device::CreateDepthStencilState( ... ) error! (0x%08X)", ATOM_FUNCTION, result );
		return false;
	}

	return ImGui_ImplDX11_CreateFontsTexture();
}

void ImGui_ImplDX11_InvalidateDeviceObjects()
{
	auto& io = ImGui::GetIO();

	if( !g_pd3dDevice )
	{
		TRACE( "%s: g_pd3dDevice is nullptr!", ATOM_FUNCTION );
		return;
	}

	memory::SafeRelease( g_pFontSampler );
	memory::SafeRelease( g_pFontTextureView );
	memory::SafeRelease( g_pIB );
	memory::SafeRelease( g_pVB );
	memory::SafeRelease( g_pBlendState );
	memory::SafeRelease( g_pDepthStencilState );
	memory::SafeRelease( g_pRasterizerState );
	memory::SafeRelease( g_pPixelShader );
	memory::SafeRelease( g_pPixelShaderBlob );
	memory::SafeRelease( g_pVertexConstantBuffer );
	memory::SafeRelease( g_pInputLayout );
	memory::SafeRelease( g_pVertexShader );
	memory::SafeRelease( g_pVertexShaderBlob );

	io.Fonts->TexID = nullptr;
}

bool ImGui_ImplDX11_Init( ID3D11Device* device, ID3D11DeviceContext* device_context )
{
	auto& io = ImGui::GetIO();

	// 
	// setup backend
	// 
	io.BackendRendererName = SECURE( "imgui_impl_dx11" );
	io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;
	
	// 
	// capture performance frequency & counter
	// 
	g_map_data.RtlQueryPerformanceFrequency( &g_dx11_frequency );
	g_map_data.RtlQueryPerformanceCounter( &g_dx11_counter );

	// 
	// capture factory
	// 
	
	IDXGIDevice* dxgi_device = nullptr;
	IDXGIAdapter* dxgi_adapter = nullptr;
	IDXGIFactory* dxgi_factory = nullptr;

	

	auto result = device->QueryInterface( IID_PPV_ARGS( &dxgi_device ) );

	if( SUCCEEDED( result ) )
	{
		result = dxgi_device->GetParent( IID_PPV_ARGS( &dxgi_adapter ) );

		if( SUCCEEDED( result ) )
		{
			result = dxgi_adapter->GetParent( IID_PPV_ARGS( &dxgi_factory ) );

			if( SUCCEEDED( result ) )
			{
				g_pd3dDevice = device;
				g_pd3dDeviceContext = device_context;
				g_pFactory = dxgi_factory;

				g_pd3dDevice->AddRef();
				g_pd3dDeviceContext->AddRef();
			}
			else
			{
				TRACE( "%s: IDXGIAdapter::GetParent( ... ) error! (0x%08X)", ATOM_FUNCTION, result );
			}
		}
		else
		{
			TRACE( "%s: IDXGIDevice::GetParent( ... ) error! (0x%08X)", ATOM_FUNCTION, result );
		}
	}
	else
	{
		TRACE( "%s: ID3D11Device::QueryInterface( ... ) error! (0x%08X)", ATOM_FUNCTION, result );
	}

	memory::SafeRelease( dxgi_adapter );
	memory::SafeRelease( dxgi_device );

	return ( g_pd3dDevice && g_pd3dDeviceContext && g_pFactory );
}

void ImGui_ImplDX11_Shutdown()
{
	ImGui_ImplDX11_InvalidateDeviceObjects();

	memory::SafeRelease( g_pFactory );
	memory::SafeRelease( g_pd3dDevice );
	memory::SafeRelease( g_pd3dDeviceContext );
}

void ImGui_ImplDX11_NewFrame()
{
	auto& io = ImGui::GetIO();

	UINT viewport_count = 1;
	D3D11_VIEWPORT viewport = { };

	// 
	// capture viewport
	// 
	g_pd3dDeviceContext->RSGetViewports( &viewport_count, &viewport );

	// 
	// update screen size
	// 
	io.DisplaySize = { viewport.Width, viewport.Height };

	// 
	// get current time
	// 
	win32::LARGE_INTEGER counter = { };
	g_map_data.RtlQueryPerformanceCounter( &counter );

	// 
	// update delta time
	// 
	io.DeltaTime = static_cast< float >( counter.QuadPart - g_dx11_counter.QuadPart ) / static_cast< float >( g_dx11_frequency.QuadPart );

	// 
	// store current counter
	// 
	g_dx11_counter = counter;

	if( !g_pFontSampler )
	{
		if( !ImGui_ImplDX11_CreateDeviceObjects() )
		{
			TRACE( "%s: ImGui_ImplDX11_CreateDeviceObjects() error!", ATOM_FUNCTION );
		}
	}
}
```

`horizon/imgui/imgui_impl_dx11.hpp`:

```hpp
// dear imgui: Renderer for DirectX11
// This needs to be used along with a Platform Binding (e.g. Win32)

// Implemented features:
//  [X] Renderer: User texture binding. Use 'ID3D11ShaderResourceView*' as ImTextureID. Read the FAQ about ImTextureID!
//  [X] Renderer: Support for large meshes (64k+ vertices) with 16-bit indices.

// You can copy and use unmodified imgui_impl_* files in your project. See main.cpp for an example of using this.
// If you are new to dear imgui, read examples/README.txt and read the documentation at the top of imgui.cpp.
// https://github.com/ocornut/imgui

#pragma once

struct ID3D11Device;
struct ID3D11DeviceContext;

IMGUI_IMPL_API bool ImGui_ImplDX11_Init( ID3D11Device* device, ID3D11DeviceContext* device_context );
IMGUI_IMPL_API void ImGui_ImplDX11_Shutdown();
IMGUI_IMPL_API void ImGui_ImplDX11_NewFrame();
IMGUI_IMPL_API void ImGui_ImplDX11_RenderDrawData( ImDrawData* draw_data );

// Use if you want to reset your rendering device without losing ImGui state.
IMGUI_IMPL_API void ImGui_ImplDX11_InvalidateDeviceObjects();
IMGUI_IMPL_API bool ImGui_ImplDX11_CreateDeviceObjects();
```

`horizon/imgui/imgui_impl_win32.cpp`:

```cpp
// dear imgui: Platform Binding for Windows (standard windows API for 32 and 64 bits applications)
// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)

// Implemented features:
//  [X] Platform: Clipboard support (for Win32 this is actually part of core imgui)
//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.
//  [X] Platform: Keyboard arrays indexed using VK_* Virtual Key Codes, e.g. ImGui::IsKeyPressed(VK_SPACE).
//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.

#include "imgui.hpp"
#include "imgui_impl_win32.hpp"
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <tchar.h>

#include "../constant/character.hpp"
#include "../constant/hash.hpp"
#include "../constant/secure_string.hpp"
#include "../constant/string.hpp"

#include "../core/map_data.hpp"

#include "../win32/time.hpp"
#include "../win32/trace.hpp"

using namespace horizon;

// CHANGELOG
// (minor and older changes stripped away, please see git history for details)
//  2020-01-14: Inputs: Added support for #define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD/IMGUI_IMPL_WIN32_DISABLE_LINKING_XINPUT.
//  2019-12-05: Inputs: Added support for ImGuiMouseCursor_NotAllowed mouse cursor.
//  2019-05-11: Inputs: Don't filter value from WM_CHAR before calling AddInputCharacter().
//  2019-01-17: Misc: Using GetForegroundWindow()+IsChild() instead of GetActiveWindow() to be compatible with windows created in a different thread or parent.
//  2019-01-17: Inputs: Added support for mouse buttons 4 and 5 via WM_XBUTTON* messages.
//  2019-01-15: Inputs: Added support for XInput gamepads (if ImGuiConfigFlags_NavEnableGamepad is set by user application).
//  2018-11-30: Misc: Setting up io.BackendPlatformName so it can be displayed in the About Window.
//  2018-06-29: Inputs: Added support for the ImGuiMouseCursor_Hand cursor.
//  2018-06-10: Inputs: Fixed handling of mouse wheel messages to support fine position messages (typically sent by track-pads).
//  2018-06-08: Misc: Extracted imgui_impl_win32.cpp/.h away from the old combined DX9/DX10/DX11/DX12 examples.
//  2018-03-20: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors and ImGuiBackendFlags_HasSetMousePos flags + honor ImGuiConfigFlags_NoMouseCursorChange flag.
//  2018-02-20: Inputs: Added support for mouse cursors (ImGui::GetMouseCursor() value and WM_SETCURSOR message handling).
//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.
//  2018-02-06: Inputs: Honoring the io.WantSetMousePos by repositioning the mouse (when using navigation and ImGuiConfigFlags_NavMoveMouse is set).
//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.
//  2018-01-20: Inputs: Added Horizontal Mouse Wheel support.
//  2018-01-08: Inputs: Added mapping for ImGuiKey_Insert.
//  2018-01-05: Inputs: Added WM_LBUTTONDBLCLK double-click handlers for window classes with the CS_DBLCLKS flag.
//  2017-10-23: Inputs: Added WM_SYSKEYDOWN / WM_SYSKEYUP handlers so e.g. the VK_MENU key can be read.
//  2017-10-23: Inputs: Using Win32 ::SetCapture/::GetCapture() to retrieve mouse positions outside the client area when dragging.
//  2016-11-12: Inputs: Only call Win32 ::SetCursor(NULL) when io.MouseDrawCursor is set.

// Win32 Data
HWND g_window = nullptr;

win32::LARGE_INTEGER g_win32_counter = { };
win32::LARGE_INTEGER g_win32_frequency = { };

ImGuiMouseCursor g_mouse_cursor = ImGuiMouseCursor_COUNT;

// Functions
bool ImGui_ImplWin32_Init( void* window )
{
	auto& io = ImGui::GetIO();
	
	g_map_data.RtlQueryPerformanceFrequency( &g_win32_frequency );
	g_map_data.RtlQueryPerformanceCounter( &g_win32_counter );

	// 
	// setup backend
	// 
	g_window = static_cast< HWND >( window );

	io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;         // We can honor GetMouseCursor() values (optional)
	io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;          // We can honor io.WantSetMousePos requests (optional, rarely used)
	io.BackendPlatformName = SECURE( "imgui_impl_win32" );
	io.ImeWindowHandle = window;

	// 
	// keyboard map
	// 
	io.KeyMap[ ImGuiKey_Tab ] = VK_TAB;
	io.KeyMap[ ImGuiKey_LeftArrow ] = VK_LEFT;
	io.KeyMap[ ImGuiKey_RightArrow ] = VK_RIGHT;
	io.KeyMap[ ImGuiKey_UpArrow ] = VK_UP;
	io.KeyMap[ ImGuiKey_DownArrow ] = VK_DOWN;
	io.KeyMap[ ImGuiKey_PageUp ] = VK_PRIOR;
	io.KeyMap[ ImGuiKey_PageDown ] = VK_NEXT;
	io.KeyMap[ ImGuiKey_Home ] = VK_HOME;
	io.KeyMap[ ImGuiKey_End ] = VK_END;
	io.KeyMap[ ImGuiKey_Insert ] = VK_INSERT;
	io.KeyMap[ ImGuiKey_Delete ] = VK_DELETE;
	io.KeyMap[ ImGuiKey_Backspace ] = VK_BACK;
	io.KeyMap[ ImGuiKey_Space ] = VK_SPACE;
	io.KeyMap[ ImGuiKey_Enter ] = VK_RETURN;
	io.KeyMap[ ImGuiKey_Escape ] = VK_ESCAPE;
	io.KeyMap[ ImGuiKey_KeyPadEnter ] = VK_RETURN;
	io.KeyMap[ ImGuiKey_A ] = 'A';
	io.KeyMap[ ImGuiKey_C ] = 'C';
	io.KeyMap[ ImGuiKey_V ] = 'V';
	io.KeyMap[ ImGuiKey_X ] = 'X';
	io.KeyMap[ ImGuiKey_Y ] = 'Y';
	io.KeyMap[ ImGuiKey_Z ] = 'Z';
	
	return true;
}

void ImGui_ImplWin32_Shutdown()
{
	g_window = nullptr;
}

void ImGui_ImplWin32_NewFrame()
{
	auto& io = ImGui::GetIO();

	IM_ASSERT( io.Fonts->IsBuilt() && "Font atlas not built! It is generally built by the renderer back-end. Missing call to renderer _NewFrame() function? e.g. ImGui_ImplOpenGL3_NewFrame()." );

	// 
	// capture current counter
	// 
	win32::LARGE_INTEGER counter = { };
	g_map_data.RtlQueryPerformanceCounter( &counter );

	// 
	// update delta time
	// 
	io.DeltaTime = static_cast< float >( counter.QuadPart - g_win32_counter.QuadPart ) / static_cast< float >( g_win32_frequency.QuadPart );
	
	// 
	// store current counter
	// 
	g_win32_counter = counter;

	// 
	// capture keyboard state
	// 
	io.KeyCtrl = ( win32::GetKeyState( VK_CONTROL ) & 0x8000 ) != 0;
	io.KeyShift = ( win32::GetKeyState( VK_SHIFT ) & 0x8000 ) != 0;
	io.KeyAlt = ( win32::GetKeyState( VK_MENU ) & 0x8000 ) != 0;
	io.KeySuper = false;
}

#ifndef WM_MOUSEHWHEEL
#define WM_MOUSEHWHEEL 0x020E
#endif // !WM_MOUSEHWHEEL
#ifndef DBT_DEVNODES_CHANGED
#define DBT_DEVNODES_CHANGED 0x0007
#endif // !DBT_DEVNODES_CHANGED

int GetMouseButton( std::uint16_t key )
{
	auto button = 0;

	switch( key )
	{
		case XBUTTON1:
		{
			button = 3;
			break;
		}
		case XBUTTON2:
		{
			button = 4;
			break;
		}
	}

	return button;
}

int GetMouseButton( std::uint32_t message, std::uintptr_t wparam )
{
	auto button = 0;

	switch( message )
	{
		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
		case WM_LBUTTONUP:
		{
			button = 0;
			break;
		}
		case WM_RBUTTONDOWN:
		case WM_RBUTTONDBLCLK:
		case WM_RBUTTONUP:
		{
			button = 1;
			break;
		}
		case WM_MBUTTONDOWN:
		case WM_MBUTTONDBLCLK:
		case WM_MBUTTONUP:
		{
			button = 2;
			break;
		}
		case WM_XBUTTONDOWN:
		case WM_XBUTTONDBLCLK:
		case WM_XBUTTONUP:
		{
			button = GetMouseButton( GET_XBUTTON_WPARAM( wparam ) );
			break;
		}
	}

	return button;
}

ImVec2 GetMouseLocation( std::intptr_t lparam )
{
	const auto x = static_cast< std::uint16_t >( lparam );
	const auto y = static_cast< std::uint16_t >( lparam >> 16 );

	ImVec2 location =
	{
		static_cast< float >( x ),
		static_cast< float >( y ),
	};

	return std::move( location );
}

// Process Win32 mouse/keyboard inputs.
// You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your inputs.
// - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application.
// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application.
// Generally you may always pass all inputs to dear imgui, and hide them from your application based on those two flags.
// PS: In this Win32 handler, we use the capture API (GetCapture/SetCapture/ReleaseCapture) to be able to read mouse coordinates when dragging mouse outside of our window bounds.
// PS: We treat DBLCLK messages as regular mouse down messages, so this code will work on windows classes that have the CS_DBLCLKS flag set. Our own example app code doesn't set this flag.
IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler( const void* window, UINT message, WPARAM wparam, LPARAM lparam )
{
	auto current_context = ImGui::GetCurrentContext();

	if( !current_context )
	{
		TRACE( "%s: ImGui::GetCurrentContext() error!", ATOM_FUNCTION );
		return FALSE;
	}

	auto& io = ImGui::GetIO();

	switch( message )
	{
		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
		case WM_RBUTTONDOWN:
		case WM_RBUTTONDBLCLK:
		case WM_MBUTTONDOWN:
		case WM_MBUTTONDBLCLK:
		case WM_XBUTTONDOWN:
		case WM_XBUTTONDBLCLK:
		{
			const auto button = GetMouseButton( message, wparam );
			io.MouseDown[ button ] = true;
			return TRUE;
		}
		case WM_LBUTTONUP:
		case WM_RBUTTONUP:
		case WM_MBUTTONUP:
		case WM_XBUTTONUP:
		{
			const auto button = GetMouseButton( message, wparam );
			io.MouseDown[ button ] = false;
			return TRUE;
		}
		case WM_MOUSEWHEEL:
		{
			const auto amount = static_cast< float >( GET_WHEEL_DELTA_WPARAM( wparam ) );
			io.MouseWheel += ( amount / static_cast< float >( WHEEL_DELTA ) );
			return TRUE;
		}
		case WM_MOUSEHWHEEL:
		{
			const auto amount = static_cast< float >( GET_WHEEL_DELTA_WPARAM( wparam ) );
			io.MouseWheelH += ( amount / static_cast< float >( WHEEL_DELTA ) );
			return TRUE;
		}
		case WM_MOUSEMOVE:
		{
			io.MousePos = GetMouseLocation( lparam );
			return FALSE;
		}
		case WM_KEYDOWN:
		case WM_SYSKEYDOWN:
		{
			if( wparam < 256 )
			{
				io.KeysDown[ wparam ] = true;
			}
			return TRUE;
		}
		case WM_KEYUP:
		case WM_SYSKEYUP:
		{
			if( wparam < 256 )
			{
				io.KeysDown[ wparam ] = false;
			}
			return TRUE;
		}
		case WM_CHAR:
		{
			const auto character = static_cast< std::uint32_t >( wparam );
			io.AddInputCharacter( character );
			return TRUE;
		}
	}

	return FALSE;
}
```

`horizon/imgui/imgui_impl_win32.hpp`:

```hpp
// dear imgui: Platform Binding for Windows (standard windows API for 32 and 64 bits applications)
// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)

// Implemented features:
//  [X] Platform: Clipboard support (for Win32 this is actually part of core imgui)
//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.
//  [X] Platform: Keyboard arrays indexed using VK_* Virtual Key Codes, e.g. ImGui::IsKeyPressed(VK_SPACE).
//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.

#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

IMGUI_IMPL_API bool ImGui_ImplWin32_Init( void* window );
IMGUI_IMPL_API void ImGui_ImplWin32_Shutdown();
IMGUI_IMPL_API void ImGui_ImplWin32_NewFrame();

// Configuration: Disable gamepad support or linking with xinput.lib
#define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD
#define IMGUI_IMPL_WIN32_DISABLE_LINKING_XINPUT

// Handler for Win32 messages, update mouse/keyboard data.
// You may or not need this for your implementation, but it can serve as reference for handling inputs.
// Intentionally commented out to avoid dragging dependencies on <windows.h> types. You can COPY this line into your .cpp code instead.
IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler( const void* window, UINT message, WPARAM wparam, LPARAM lparam );
```

`horizon/imgui/imgui_internal.hpp`:

```hpp
// dear imgui, v1.77 WIP
// (internal structures/api)

// You may use this file to debug, understand or extend ImGui features but we don't provide any guarantee of forward compatibility!
// Set:
//   #define IMGUI_DEFINE_MATH_OPERATORS
// To implement maths operators for ImVec2 (disabled by default to not collide with using IM_VEC2_CLASS_EXTRA along with your own math types+operators)

/*

Index of this file:
// Header mess
// Forward declarations
// STB libraries includes
// Context pointer
// Generic helpers
// Misc data structures
// Main imgui context
// Tab bar, tab item
// Internal API

*/

#pragma once
#ifndef IMGUI_DISABLE

//-----------------------------------------------------------------------------
// Header mess
//-----------------------------------------------------------------------------

#ifndef IMGUI_VERSION
#error Must include imgui.h before imgui_internal.h
#endif

#include <stdio.h>      // FILE*, sscanf
#include <stdlib.h>     // NULL, malloc, free, qsort, atoi, atof
#include <math.h>       // sqrtf, fabsf, fmodf, powf, floorf, ceilf, cosf, sinf
#include <limits.h>     // INT_MIN, INT_MAX

// Atom includes
using namespace horizon;

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable: 4251) // class 'xxx' needs to have dll-interface to be used by clients of struct 'xxx' // when IMGUI_API is set to__declspec(dllexport)
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"        // for stb_textedit.h
#pragma clang diagnostic ignored "-Wmissing-prototypes"     // for stb_textedit.h
#pragma clang diagnostic ignored "-Wold-style-cast"
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
#endif
#if __has_warning("-Wdouble-promotion")
#pragma clang diagnostic ignored "-Wdouble-promotion"
#endif
#elif defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpragmas"                  // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wclass-memaccess"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif

// Legacy defines
#ifdef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS                // Renamed in 1.74
#error Use IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
#endif
#ifdef IMGUI_DISABLE_MATH_FUNCTIONS                         // Renamed in 1.74
#error Use IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS
#endif

//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------

struct ImBitVector;                 // Store 1-bit per value
struct ImRect;                      // An axis-aligned rectangle (2 points)
struct ImDrawDataBuilder;           // Helper to build a ImDrawData instance
struct ImDrawListSharedData;        // Data shared between all ImDrawList instances
struct ImGuiColorMod;               // Stacked color modifier, backup of modified data so we can restore it
struct ImGuiColumnData;             // Storage data for a single column
struct ImGuiColumns;                // Storage data for a columns set
struct ImGuiContext;                // Main Dear ImGui context
struct ImGuiDataTypeInfo;           // Type information associated to a ImGuiDataType enum
struct ImGuiGroupData;              // Stacked storage data for BeginGroup()/EndGroup()
struct ImGuiInputTextState;         // Internal state of the currently focused/edited text input box
struct ImGuiItemHoveredDataBackup;  // Backup and restore IsItemHovered() internal data
struct ImGuiMenuColumns;            // Simple column measurement, currently used for MenuItem() only
struct ImGuiNavMoveResult;          // Result of a gamepad/keyboard directional navigation move query result
struct ImGuiNextWindowData;         // Storage for SetNextWindow** functions
struct ImGuiNextItemData;           // Storage for SetNextItem** functions
struct ImGuiPopupData;              // Storage for current popup stack
struct ImGuiSettingsHandler;        // Storage for one type registered in the .ini file
struct ImGuiStyleMod;               // Stacked style modifier, backup of modified data so we can restore it
struct ImGuiTabBar;                 // Storage for a tab bar
struct ImGuiTabItem;                // Storage for a tab item (within a tab bar)
struct ImGuiWindow;                 // Storage for one window
struct ImGuiWindowTempData;         // Temporary storage for one window (that's the data which in theory we could ditch at the end of the frame)
struct ImGuiWindowSettings;         // Storage for a window .ini settings (we keep one of those even if the actual window wasn't instanced during this session)

// Use your programming IDE "Go to definition" facility on the names of the center columns to find the actual flags/enum lists.
typedef int ImGuiLayoutType;            // -> enum ImGuiLayoutType_         // Enum: Horizontal or vertical
typedef int ImGuiButtonFlags;           // -> enum ImGuiButtonFlags_        // Flags: for ButtonEx(), ButtonBehavior()
typedef int ImGuiColumnsFlags;          // -> enum ImGuiColumnsFlags_       // Flags: BeginColumns()
typedef int ImGuiDragFlags;             // -> enum ImGuiDragFlags_          // Flags: for DragBehavior()
typedef int ImGuiItemFlags;             // -> enum ImGuiItemFlags_          // Flags: for PushItemFlag()
typedef int ImGuiItemStatusFlags;       // -> enum ImGuiItemStatusFlags_    // Flags: for DC.LastItemStatusFlags
typedef int ImGuiNavHighlightFlags;     // -> enum ImGuiNavHighlightFlags_  // Flags: for RenderNavHighlight()
typedef int ImGuiNavDirSourceFlags;     // -> enum ImGuiNavDirSourceFlags_  // Flags: for GetNavInputAmount2d()
typedef int ImGuiNavMoveFlags;          // -> enum ImGuiNavMoveFlags_       // Flags: for navigation requests
typedef int ImGuiNextItemDataFlags;     // -> enum ImGuiNextItemDataFlags_  // Flags: for SetNextItemXXX() functions
typedef int ImGuiNextWindowDataFlags;   // -> enum ImGuiNextWindowDataFlags_// Flags: for SetNextWindowXXX() functions
typedef int ImGuiSeparatorFlags;        // -> enum ImGuiSeparatorFlags_     // Flags: for SeparatorEx()
typedef int ImGuiSliderFlags;           // -> enum ImGuiSliderFlags_        // Flags: for SliderBehavior()
typedef int ImGuiTextFlags;             // -> enum ImGuiTextFlags_          // Flags: for TextEx()
typedef int ImGuiTooltipFlags;          // -> enum ImGuiTooltipFlags_       // Flags: for BeginTooltipEx()

//-------------------------------------------------------------------------
// STB libraries includes
//-------------------------------------------------------------------------

namespace ImStb
{

#undef STB_TEXTEDIT_STRING
#undef STB_TEXTEDIT_CHARTYPE
#define STB_TEXTEDIT_STRING             ImGuiInputTextState
#define STB_TEXTEDIT_CHARTYPE           ImWchar
#define STB_TEXTEDIT_GETWIDTH_NEWLINE   -1.0f
#define STB_TEXTEDIT_UNDOSTATECOUNT     99
#define STB_TEXTEDIT_UNDOCHARCOUNT      999
#include "imstb_textedit.hpp"

} // namespace ImStb

//-----------------------------------------------------------------------------
// Context pointer
//-----------------------------------------------------------------------------

#ifndef GImGui
extern IMGUI_API ImGuiContext* GImGui;  // Current implicit context pointer
#endif

//-----------------------------------------------------------------------------
// Macros
//-----------------------------------------------------------------------------

// Debug Logging
#ifndef IMGUI_DEBUG_LOG
#define IMGUI_DEBUG_LOG(_FMT,...)       printf("[%05d] " _FMT, GImGui->FrameCount, __VA_ARGS__)
#endif

// Static Asserts
#if (__cplusplus >= 201100)
#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
#else
#define IM_STATIC_ASSERT(_COND)         typedef char static_assertion_##__line__[(_COND)?1:-1]
#endif

// "Paranoid" Debug Asserts are meant to only be enabled during specific debugging/work, otherwise would slow down the code too much.
// We currently don't have many of those so the effect is currently negligible, but onward intent to add more aggressive ones in the code.
//#define IMGUI_DEBUG_PARANOID
#ifdef IMGUI_DEBUG_PARANOID
#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
#else
#define IM_ASSERT_PARANOID(_EXPR)
#endif

// Error handling
// Down the line in some frameworks/languages we would like to have a way to redirect those to the programmer and recover from more faults.
#ifndef IM_ASSERT_USER_ERROR
#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
#endif

// Misc Macros
#define IM_PI                           3.14159265358979323846f
#ifdef _WIN32
#define IM_NEWLINE                      "\r\n"   // Play it nice with Windows users (Update: since 2018-05, Notepad finally appears to support Unix-style carriage returns!)
#else
#define IM_NEWLINE                      "\n"
#endif
#define IM_TABSIZE                      (4)
#define IM_F32_TO_INT8_UNBOUND(_VAL)    ((int)((_VAL) * 255.0f + ((_VAL)>=0 ? 0.5f : -0.5f)))   // Unsaturated, for display purpose
#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
#define IM_ROUND(_VAL)                  ((float)(int)((_VAL) + 0.5f))                           //

// Enforce cdecl calling convention for functions called by the standard library, in case compilation settings changed the default to e.g. __vectorcall
#ifdef _MSC_VER
#define IMGUI_CDECL __cdecl
#else
#define IMGUI_CDECL
#endif

//-----------------------------------------------------------------------------
// Generic helpers
// Note that the ImXXX helpers functions are lower-level than ImGui functions.
// ImGui functions or the ImGui context are never called/used from other ImXXX functions.
//-----------------------------------------------------------------------------
// - Helpers: Misc
// - Helpers: Bit manipulation
// - Helpers: String, Formatting
// - Helpers: UTF-8 <> wchar conversions
// - Helpers: ImVec2/ImVec4 operators
// - Helpers: Maths
// - Helpers: Geometry
// - Helpers: Bit arrays
// - Helper: ImBitVector
// - Helper: ImPool<>
// - Helper: ImChunkStream<>
//-----------------------------------------------------------------------------

// Helpers: Misc
#define ImQsort         win32::qsort
IMGUI_API ImU32         ImHashData( const void* data, size_t data_size, ImU32 seed = 0 );
IMGUI_API ImU32         ImHashStr( const char* data, size_t data_size = 0, ImU32 seed = 0 );
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
static inline ImU32     ImHash( const void* data, int size, ImU32 seed = 0 )
{
	return size ? ImHashData( data, ( size_t )size, seed ) : ImHashStr( ( const char* )data, 0, seed );
} // [moved to ImHashStr/ImHashData in 1.68]
#endif

// Helpers: Color Blending
IMGUI_API ImU32         ImAlphaBlendColors( ImU32 col_a, ImU32 col_b );

// Helpers: Bit manipulation
static inline bool      ImIsPowerOfTwo( int v )
{
	return v != 0 && ( v & ( v - 1 ) ) == 0;
}
static inline int       ImUpperPowerOfTwo( int v )
{
	v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v;
}

// Helpers: String, Formatting
IMGUI_API int           ImStricmp( const char* str1, const char* str2 );
IMGUI_API int           ImStrnicmp( const char* str1, const char* str2, size_t count );
IMGUI_API void          ImStrncpy( char* dst, const char* src, size_t count );
IMGUI_API char* ImStrdup( const char* str );
IMGUI_API char* ImStrdupcpy( char* dst, size_t* p_dst_size, const char* str );
IMGUI_API const char* ImStrchrRange( const char* str_begin, const char* str_end, char c );
IMGUI_API int           ImStrlenW( const ImWchar* str );
IMGUI_API const char* ImStreolRange( const char* str, const char* str_end );                // End end-of-line
IMGUI_API const ImWchar* ImStrbolW( const ImWchar* buf_mid_line, const ImWchar* buf_begin );   // Find beginning-of-line
IMGUI_API const char* ImStristr( const char* haystack, const char* haystack_end, const char* needle, const char* needle_end );
IMGUI_API void          ImStrTrimBlanks( char* str );
IMGUI_API const char* ImStrSkipBlank( const char* str );
IMGUI_API int           ImFormatString( char* buf, size_t buf_size, const char* fmt, ... ) IM_FMTARGS( 3 );
IMGUI_API int           ImFormatStringV( char* buf, size_t buf_size, const char* fmt, va_list args ) IM_FMTLIST( 3 );
IMGUI_API const char* ImParseFormatFindStart( const char* format );
IMGUI_API const char* ImParseFormatFindEnd( const char* format );
IMGUI_API const char* ImParseFormatTrimDecorations( const char* format, char* buf, size_t buf_size );
IMGUI_API int           ImParseFormatPrecision( const char* format, int default_value );
static inline bool      ImCharIsBlankA( char c )
{
	return c == ' ' || c == '\t';
}
static inline bool      ImCharIsBlankW( unsigned int c )
{
	return c == ' ' || c == '\t' || c == 0x3000;
}

// Helpers: UTF-8 <> wchar conversions
IMGUI_API int           ImTextStrToUtf8( char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end );      // return output UTF-8 bytes count
IMGUI_API int           ImTextCharFromUtf8( unsigned int* out_char, const char* in_text, const char* in_text_end );          // read one character. return input UTF-8 bytes count
IMGUI_API int           ImTextStrFromUtf8( ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_remaining = NULL );   // return input UTF-8 bytes count
IMGUI_API int           ImTextCountCharsFromUtf8( const char* in_text, const char* in_text_end );                            // return number of UTF-8 code-points (NOT bytes count)
IMGUI_API int           ImTextCountUtf8BytesFromChar( const char* in_text, const char* in_text_end );                        // return number of bytes to express one char in UTF-8
IMGUI_API int           ImTextCountUtf8BytesFromStr( const ImWchar* in_text, const ImWchar* in_text_end );                   // return number of bytes to express string in UTF-8

// Helpers: ImVec2/ImVec4 operators
// We are keeping those disabled by default so they don't leak in user space, to allow user enabling implicit cast operators between ImVec2 and their own types (using IM_VEC2_CLASS_EXTRA etc.)
// We unfortunately don't have a unary- operator for ImVec2 because this would needs to be defined inside the class itself.
#ifdef IMGUI_DEFINE_MATH_OPERATORS
static inline ImVec2 operator*( const ImVec2& lhs, const float rhs )
{
	return ImVec2( lhs.x * rhs, lhs.y * rhs );
}
static inline ImVec2 operator/( const ImVec2& lhs, const float rhs )
{
	return ImVec2( lhs.x / rhs, lhs.y / rhs );
}
static inline ImVec2 operator+( const ImVec2& lhs, const ImVec2& rhs )
{
	return ImVec2( lhs.x + rhs.x, lhs.y + rhs.y );
}
static inline ImVec2 operator-( const ImVec2& lhs, const ImVec2& rhs )
{
	return ImVec2( lhs.x - rhs.x, lhs.y - rhs.y );
}
static inline ImVec2 operator*( const ImVec2& lhs, const ImVec2& rhs )
{
	return ImVec2( lhs.x * rhs.x, lhs.y * rhs.y );
}
static inline ImVec2 operator/( const ImVec2& lhs, const ImVec2& rhs )
{
	return ImVec2( lhs.x / rhs.x, lhs.y / rhs.y );
}
static inline ImVec2& operator*=( ImVec2& lhs, const float rhs )
{
	lhs.x *= rhs; lhs.y *= rhs; return lhs;
}
static inline ImVec2& operator/=( ImVec2& lhs, const float rhs )
{
	lhs.x /= rhs; lhs.y /= rhs; return lhs;
}
static inline ImVec2& operator+=( ImVec2& lhs, const ImVec2& rhs )
{
	lhs.x += rhs.x; lhs.y += rhs.y; return lhs;
}
static inline ImVec2& operator-=( ImVec2& lhs, const ImVec2& rhs )
{
	lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs;
}
static inline ImVec2& operator*=( ImVec2& lhs, const ImVec2& rhs )
{
	lhs.x *= rhs.x; lhs.y *= rhs.y; return lhs;
}
static inline ImVec2& operator/=( ImVec2& lhs, const ImVec2& rhs )
{
	lhs.x /= rhs.x; lhs.y /= rhs.y; return lhs;
}
static inline ImVec4 operator+( const ImVec4& lhs, const ImVec4& rhs )
{
	return ImVec4( lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z, lhs.w + rhs.w );
}
static inline ImVec4 operator-( const ImVec4& lhs, const ImVec4& rhs )
{
	return ImVec4( lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z, lhs.w - rhs.w );
}
static inline ImVec4 operator*( const ImVec4& lhs, const ImVec4& rhs )
{
	return ImVec4( lhs.x * rhs.x, lhs.y * rhs.y, lhs.z * rhs.z, lhs.w * rhs.w );
}
#endif

// Helpers: File System
#ifdef IMGUI_DISABLE_FILE_FUNCTIONS
#define IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS
typedef void* ImFileHandle;
static inline ImFileHandle  ImFileOpen( const char*, const char* )
{
	return NULL;
}
static inline bool          ImFileClose( ImFileHandle )
{
	return false;
}
static inline ImU64         ImFileGetSize( ImFileHandle )
{
	return ( ImU64 )-1;
}
static inline ImU64         ImFileRead( void*, ImU64, ImU64, ImFileHandle )
{
	return 0;
}
static inline ImU64         ImFileWrite( const void*, ImU64, ImU64, ImFileHandle )
{
	return 0;
}
#endif

#ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS
typedef FILE* ImFileHandle;
IMGUI_API ImFileHandle      ImFileOpen( const char* filename, const char* mode );
IMGUI_API bool              ImFileClose( ImFileHandle file );
IMGUI_API ImU64             ImFileGetSize( ImFileHandle file );
IMGUI_API ImU64             ImFileRead( void* data, ImU64 size, ImU64 count, ImFileHandle file );
IMGUI_API ImU64             ImFileWrite( const void* data, ImU64 size, ImU64 count, ImFileHandle file );
#else
#define IMGUI_DISABLE_TTY_FUNCTIONS // Can't use stdout, fflush if we are not using default file functions
#endif
IMGUI_API void* ImFileLoadToMemory( const char* filename, const char* mode, size_t* out_file_size = NULL, int padding_bytes = 0 );

// Helpers: Maths
// - Wrapper for standard libs functions. (Note that imgui_demo.cpp does _not_ use them to keep the code easy to copy)
#ifndef IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS
#define ImFabs(X)           win32::fabsf(X)
#define ImSqrt(X)           win32::sqrtf(X)
#define ImFmod(X, Y)        win32::fmodf((X), (Y))
#define ImCos(X)            win32::cosf(X)
#define ImSin(X)            win32::sinf(X)
#define ImAcos(X)           win32::acosf(X)
#define ImAtan2(Y, X)       win32::atan2f((Y), (X))
#define ImAtof(STR)         win32::atof(STR)
#define ImFloorStd(X)       win32::floorf(X)           // We already uses our own ImFloor() { return (float)(int)v } internally so the standard one wrapper is named differently (it's used by e.g. stb_truetype)
#define ImCeil(X)           win32::ceilf(X)
static inline float  ImPow( float x, float y )
{
	return win32::powf( x, y );
}          // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision
static inline double ImPow( double x, double y )
{
	return win32::pow( x, y );
}
#endif
// - ImMin/ImMax/ImClamp/ImLerp/ImSwap are used by widgets which support variety of types: signed/unsigned int/long long float/double
// (Exceptionally using templates here but we could also redefine them for those types)
template<typename T> static inline T ImMin( T lhs, T rhs )
{
	return lhs < rhs ? lhs : rhs;
}
template<typename T> static inline T ImMax( T lhs, T rhs )
{
	return lhs >= rhs ? lhs : rhs;
}
template<typename T> static inline T ImClamp( T v, T mn, T mx )
{
	return ( v < mn ) ? mn : ( v > mx ) ? mx : v;
}
template<typename T> static inline T ImLerp( T a, T b, float t )
{
	return ( T )( a + ( b - a ) * t );
}
template<typename T> static inline void ImSwap( T& a, T& b )
{
	T tmp = a; a = b; b = tmp;
}
template<typename T> static inline T ImAddClampOverflow( T a, T b, T mn, T mx )
{
	if( b < 0 && ( a < mn - b ) ) return mn; if( b > 0 && ( a > mx - b ) ) return mx; return a + b;
}
template<typename T> static inline T ImSubClampOverflow( T a, T b, T mn, T mx )
{
	if( b > 0 && ( a < mn + b ) ) return mn; if( b < 0 && ( a > mx + b ) ) return mx; return a - b;
}
// - Misc maths helpers
static inline ImVec2 ImMin( const ImVec2& lhs, const ImVec2& rhs )
{
	return ImVec2( lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y );
}
static inline ImVec2 ImMax( const ImVec2& lhs, const ImVec2& rhs )
{
	return ImVec2( lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y );
}
static inline ImVec2 ImClamp( const ImVec2& v, const ImVec2& mn, ImVec2 mx )
{
	return ImVec2( ( v.x < mn.x ) ? mn.x : ( v.x > mx.x ) ? mx.x : v.x, ( v.y < mn.y ) ? mn.y : ( v.y > mx.y ) ? mx.y : v.y );
}
static inline ImVec2 ImLerp( const ImVec2& a, const ImVec2& b, float t )
{
	return ImVec2( a.x + ( b.x - a.x ) * t, a.y + ( b.y - a.y ) * t );
}
static inline ImVec2 ImLerp( const ImVec2& a, const ImVec2& b, const ImVec2& t )
{
	return ImVec2( a.x + ( b.x - a.x ) * t.x, a.y + ( b.y - a.y ) * t.y );
}
static inline ImVec4 ImLerp( const ImVec4& a, const ImVec4& b, float t )
{
	return ImVec4( a.x + ( b.x - a.x ) * t, a.y + ( b.y - a.y ) * t, a.z + ( b.z - a.z ) * t, a.w + ( b.w - a.w ) * t );
}
static inline float  ImSaturate( float f )
{
	return ( f < 0.0f ) ? 0.0f : ( f > 1.0f ) ? 1.0f : f;
}
static inline float  ImLengthSqr( const ImVec2& lhs )
{
	return lhs.x * lhs.x + lhs.y * lhs.y;
}
static inline float  ImLengthSqr( const ImVec4& lhs )
{
	return lhs.x * lhs.x + lhs.y * lhs.y + lhs.z * lhs.z + lhs.w * lhs.w;
}
static inline float  ImInvLength( const ImVec2& lhs, float fail_value )
{
	float d = lhs.x * lhs.x + lhs.y * lhs.y; if( d > 0.0f ) return 1.0f / ImSqrt( d ); return fail_value;
}
static inline float  ImFloor( float f )
{
	return ( float )( int )( f );
}
static inline ImVec2 ImFloor( const ImVec2& v )
{
	return ImVec2( ( float )( int )( v.x ), ( float )( int )( v.y ) );
}
static inline int    ImModPositive( int a, int b )
{
	return ( a + b ) % b;
}
static inline float  ImDot( const ImVec2& a, const ImVec2& b )
{
	return a.x * b.x + a.y * b.y;
}
static inline ImVec2 ImRotate( const ImVec2& v, float cos_a, float sin_a )
{
	return ImVec2( v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a );
}
static inline float  ImLinearSweep( float current, float target, float speed )
{
	if( current < target ) return ImMin( current + speed, target ); if( current > target ) return ImMax( current - speed, target ); return current;
}
static inline ImVec2 ImMul( const ImVec2& lhs, const ImVec2& rhs )
{
	return ImVec2( lhs.x * rhs.x, lhs.y * rhs.y );
}

// Helpers: Geometry
IMGUI_API ImVec2     ImBezierCalc( const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, float t );                                         // Cubic Bezier
IMGUI_API ImVec2     ImBezierClosestPoint( const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, int num_segments );       // For curves with explicit number of segments
IMGUI_API ImVec2     ImBezierClosestPointCasteljau( const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, float tess_tol );// For auto-tessellated curves you can use tess_tol = style.CurveTessellationTol
IMGUI_API ImVec2     ImLineClosestPoint( const ImVec2& a, const ImVec2& b, const ImVec2& p );
IMGUI_API bool       ImTriangleContainsPoint( const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p );
IMGUI_API ImVec2     ImTriangleClosestPoint( const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p );
IMGUI_API void       ImTriangleBarycentricCoords( const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w );
inline float         ImTriangleArea( const ImVec2& a, const ImVec2& b, const ImVec2& c )
{
	return ImFabs( ( a.x * ( b.y - c.y ) ) + ( b.x * ( c.y - a.y ) ) + ( c.x * ( a.y - b.y ) ) ) * 0.5f;
}
IMGUI_API ImGuiDir   ImGetDirQuadrantFromDelta( float dx, float dy );

// Helpers: Bit arrays
inline bool          ImBitArrayTestBit( const ImU32* arr, int n )
{
	ImU32 mask = ( ImU32 )1 << ( n & 31 ); return ( arr[ n >> 5 ] & mask ) != 0;
}
inline void          ImBitArrayClearBit( ImU32* arr, int n )
{
	ImU32 mask = ( ImU32 )1 << ( n & 31 ); arr[ n >> 5 ] &= ~mask;
}
inline void          ImBitArraySetBit( ImU32* arr, int n )
{
	ImU32 mask = ( ImU32 )1 << ( n & 31 ); arr[ n >> 5 ] |= mask;
}
inline void          ImBitArraySetBitRange( ImU32* arr, int n, int n2 )
{
	while( n <= n2 )
	{
		int a_mod = ( n & 31 );
		int b_mod = ( ( n2 >= n + 31 ) ? 31 : ( n2 & 31 ) ) + 1;
		ImU32 mask = ( ImU32 )( ( ( ImU64 )1 << b_mod ) - 1 ) & ~( ImU32 )( ( ( ImU64 )1 << a_mod ) - 1 );
		arr[ n >> 5 ] |= mask;
		n = ( n + 32 ) & ~31;
	}
}

// Helper: ImBitVector
// Store 1-bit per value.
struct IMGUI_API ImBitVector
{
	ImVector<ImU32> Storage;
	void            Create( int sz )
	{
		Storage.resize( ( sz + 31 ) >> 5 ); memset( Storage.Data, 0, ( size_t )Storage.Size * sizeof( Storage.Data[ 0 ] ) );
	}
	void            Clear()
	{
		Storage.clear();
	}
	bool            TestBit( int n ) const
	{
		IM_ASSERT( n < ( Storage.Size << 5 ) ); return ImBitArrayTestBit( Storage.Data, n );
	}
	void            SetBit( int n )
	{
		IM_ASSERT( n < ( Storage.Size << 5 ) ); ImBitArraySetBit( Storage.Data, n );
	}
	void            ClearBit( int n )
	{
		IM_ASSERT( n < ( Storage.Size << 5 ) ); ImBitArrayClearBit( Storage.Data, n );
	}
};

// Helper: ImPool<>
// Basic keyed storage for contiguous instances, slow/amortized insertion, O(1) indexable, O(Log N) queries by ID over a dense/hot buffer,
// Honor constructor/destructor. Add/remove invalidate all pointers. Indexes have the same lifetime as the associated object.
typedef int ImPoolIdx;
template<typename T>
struct IMGUI_API ImPool
{
	ImVector<T>     Buf;        // Contiguous data
	ImGuiStorage    Map;        // ID->Index
	ImPoolIdx       FreeIdx;    // Next free idx to use

	ImPool()
	{
		FreeIdx = 0;
	}
	~ImPool()
	{
		Clear();
	}
	T* GetByKey( ImGuiID key )
	{
		int idx = Map.GetInt( key, -1 ); return ( idx != -1 ) ? &Buf[ idx ] : NULL;
	}
	T* GetByIndex( ImPoolIdx n )
	{
		return &Buf[ n ];
	}
	ImPoolIdx   GetIndex( const T* p ) const
	{
		IM_ASSERT( p >= Buf.Data && p < Buf.Data + Buf.Size ); return ( ImPoolIdx )( p - Buf.Data );
	}
	T* GetOrAddByKey( ImGuiID key )
	{
		int* p_idx = Map.GetIntRef( key, -1 ); if( *p_idx != -1 ) return &Buf[ *p_idx ]; *p_idx = FreeIdx; return Add();
	}
	bool        Contains( const T* p ) const
	{
		return ( p >= Buf.Data && p < Buf.Data + Buf.Size );
	}
	void        Clear()
	{
		for( int n = 0; n < Map.Data.Size; n++ )
		{
			int idx = Map.Data[ n ].val_i; if( idx != -1 ) Buf[ idx ].~T();
		} Map.Clear(); Buf.clear(); FreeIdx = 0;
	}
	T* Add()
	{
		int idx = FreeIdx; if( idx == Buf.Size )
		{
			Buf.resize( Buf.Size + 1 ); FreeIdx++;
		}
		else
		{
			FreeIdx = *( int* )&Buf[ idx ];
		} IM_PLACEMENT_NEW( &Buf[ idx ] ) T(); return &Buf[ idx ];
	}
	void        Remove( ImGuiID key, const T* p )
	{
		Remove( key, GetIndex( p ) );
	}
	void        Remove( ImGuiID key, ImPoolIdx idx )
	{
		Buf[ idx ].~T(); *( int* )&Buf[ idx ] = FreeIdx; FreeIdx = idx; Map.SetInt( key, -1 );
	}
	void        Reserve( int capacity )
	{
		Buf.reserve( capacity ); Map.Data.reserve( capacity );
	}
	int         GetSize() const
	{
		return Buf.Size;
	}
};

// Helper: ImChunkStream<>
// Build and iterate a contiguous stream of variable-sized structures.
// This is used by Settings to store persistent data while reducing allocation count.
// We store the chunk size first, and align the final size on 4 bytes boundaries (this what the '(X + 3) & ~3' statement is for)
// The tedious/zealous amount of casting is to avoid -Wcast-align warnings.
template<typename T>
struct IMGUI_API ImChunkStream
{
	ImVector<char>  Buf;

	void    clear()
	{
		Buf.clear();
	}
	bool    empty() const
	{
		return Buf.Size == 0;
	}
	int     size() const
	{
		return Buf.Size;
	}
	T* alloc_chunk( size_t sz )
	{
		size_t HDR_SZ = 4; sz = ( ( HDR_SZ + sz ) + 3u ) & ~3u; int off = Buf.Size; Buf.resize( off + ( int )sz ); ( ( int* )( void* )( Buf.Data + off ) )[ 0 ] = ( int )sz; return ( T* )( void* )( Buf.Data + off + ( int )HDR_SZ );
	}
	T* begin()
	{
		size_t HDR_SZ = 4; if( !Buf.Data ) return NULL; return ( T* )( void* )( Buf.Data + HDR_SZ );
	}
	T* next_chunk( T* p )
	{
		size_t HDR_SZ = 4; IM_ASSERT( p >= begin() && p < end() ); p = ( T* )( void* )( ( char* )( void* )p + chunk_size( p ) ); if( p == ( T* )( void* )( ( char* )end() + HDR_SZ ) ) return ( T* )0; IM_ASSERT( p < end() ); return p;
	}
	int     chunk_size( const T* p )
	{
		return ( ( const int* )p )[ -1 ];
	}
	T* end()
	{
		return ( T* )( void* )( Buf.Data + Buf.Size );
	}
	int     offset_from_ptr( const T* p )
	{
		IM_ASSERT( p >= begin() && p < end() ); const ptrdiff_t off = ( const char* )p - Buf.Data; return ( int )off;
	}
	T* ptr_from_offset( int off )
	{
		IM_ASSERT( off >= 4 && off < Buf.Size ); return ( T* )( void* )( Buf.Data + off );
	}
};

//-----------------------------------------------------------------------------
// Misc data structures
//-----------------------------------------------------------------------------

enum ImGuiButtonFlags_
{
	ImGuiButtonFlags_None = 0,
	ImGuiButtonFlags_Repeat = 1 << 0,   // hold to repeat
	ImGuiButtonFlags_PressedOnClick = 1 << 1,   // return true on click (mouse down event)
	ImGuiButtonFlags_PressedOnClickRelease = 1 << 2,   // [Default] return true on click + release on same item <-- this is what the majority of Button are using
	ImGuiButtonFlags_PressedOnClickReleaseAnywhere = 1 << 3, // return true on click + release even if the release event is not done while hovering the item
	ImGuiButtonFlags_PressedOnRelease = 1 << 4,   // return true on release (default requires click+release)
	ImGuiButtonFlags_PressedOnDoubleClick = 1 << 5,   // return true on double-click (default requires click+release)
	ImGuiButtonFlags_PressedOnDragDropHold = 1 << 6,   // return true when held into while we are drag and dropping another item (used by e.g. tree nodes, collapsing headers)
	ImGuiButtonFlags_FlattenChildren = 1 << 7,   // allow interactions even if a child window is overlapping
	ImGuiButtonFlags_AllowItemOverlap = 1 << 8,   // require previous frame HoveredId to either match id or be null before being usable, use along with SetItemAllowOverlap()
	ImGuiButtonFlags_DontClosePopups = 1 << 9,   // disable automatically closing parent popup on press // [UNUSED]
	ImGuiButtonFlags_Disabled = 1 << 10,  // disable interactions
	ImGuiButtonFlags_AlignTextBaseLine = 1 << 11,  // vertically align button to match text baseline - ButtonEx() only // FIXME: Should be removed and handled by SmallButton(), not possible currently because of DC.CursorPosPrevLine
	ImGuiButtonFlags_NoKeyModifiers = 1 << 12,  // disable mouse interaction if a key modifier is held
	ImGuiButtonFlags_NoHoldingActiveId = 1 << 13,  // don't set ActiveId while holding the mouse (ImGuiButtonFlags_PressedOnClick only)
	ImGuiButtonFlags_NoNavFocus = 1 << 14,  // don't override navigation focus when activated
	ImGuiButtonFlags_NoHoveredOnFocus = 1 << 15,  // don't report as hovered when nav focus is on this item
	ImGuiButtonFlags_MouseButtonLeft = 1 << 16,  // [Default] react on left mouse button
	ImGuiButtonFlags_MouseButtonRight = 1 << 17,  // react on right mouse button
	ImGuiButtonFlags_MouseButtonMiddle = 1 << 18,  // react on center mouse button

	ImGuiButtonFlags_MouseButtonMask_ = ImGuiButtonFlags_MouseButtonLeft | ImGuiButtonFlags_MouseButtonRight | ImGuiButtonFlags_MouseButtonMiddle,
	ImGuiButtonFlags_MouseButtonShift_ = 16,
	ImGuiButtonFlags_MouseButtonDefault_ = ImGuiButtonFlags_MouseButtonLeft,
	ImGuiButtonFlags_PressedOnMask_ = ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick | ImGuiButtonFlags_PressedOnDragDropHold,
	ImGuiButtonFlags_PressedOnDefault_ = ImGuiButtonFlags_PressedOnClickRelease
};

enum ImGuiSliderFlags_
{
	ImGuiSliderFlags_None = 0,
	ImGuiSliderFlags_Vertical = 1 << 0
};

enum ImGuiDragFlags_
{
	ImGuiDragFlags_None = 0,
	ImGuiDragFlags_Vertical = 1 << 0
};

enum ImGuiColumnsFlags_
{
	// Default: 0
	ImGuiColumnsFlags_None = 0,
	ImGuiColumnsFlags_NoBorder = 1 << 0,   // Disable column dividers
	ImGuiColumnsFlags_NoResize = 1 << 1,   // Disable resizing columns when clicking on the dividers
	ImGuiColumnsFlags_NoPreserveWidths = 1 << 2,   // Disable column width preservation when adjusting columns
	ImGuiColumnsFlags_NoForceWithinWindow = 1 << 3,   // Disable forcing columns to fit within window
	ImGuiColumnsFlags_GrowParentContentsSize = 1 << 4    // (WIP) Restore pre-1.51 behavior of extending the parent window contents size but _without affecting the columns width at all_. Will eventually remove.
};

// Extend ImGuiSelectableFlags_
enum ImGuiSelectableFlagsPrivate_
{
	// NB: need to be in sync with last value of ImGuiSelectableFlags_
	ImGuiSelectableFlags_NoHoldingActiveID = 1 << 20,
	ImGuiSelectableFlags_SelectOnClick = 1 << 21,  // Override button behavior to react on Click (default is Click+Release)
	ImGuiSelectableFlags_SelectOnRelease = 1 << 22,  // Override button behavior to react on Release (default is Click+Release)
	ImGuiSelectableFlags_SpanAvailWidth = 1 << 23,  // Span all avail width even if we declared less for layout purpose. FIXME: We may be able to remove this (added in 6251d379, 2bcafc86 for menus)
	ImGuiSelectableFlags_DrawHoveredWhenHeld = 1 << 24,  // Always show active when held, even is not hovered. This concept could probably be renamed/formalized somehow.
	ImGuiSelectableFlags_SetNavIdOnHover = 1 << 25
};

// Extend ImGuiTreeNodeFlags_
enum ImGuiTreeNodeFlagsPrivate_
{
	ImGuiTreeNodeFlags_ClipLabelForTrailingButton = 1 << 20
};

enum ImGuiSeparatorFlags_
{
	ImGuiSeparatorFlags_None = 0,
	ImGuiSeparatorFlags_Horizontal = 1 << 0,   // Axis default to current layout type, so generally Horizontal unless e.g. in a menu bar
	ImGuiSeparatorFlags_Vertical = 1 << 1,
	ImGuiSeparatorFlags_SpanAllColumns = 1 << 2
};

// Transient per-window flags, reset at the beginning of the frame. For child window, inherited from parent on first Begin().
// This is going to be exposed in imgui.h when stabilized enough.
enum ImGuiItemFlags_
{
	ImGuiItemFlags_None = 0,
	ImGuiItemFlags_NoTabStop = 1 << 0,  // false
	ImGuiItemFlags_ButtonRepeat = 1 << 1,  // false    // Button() will return true multiple times based on io.KeyRepeatDelay and io.KeyRepeatRate settings.
	ImGuiItemFlags_Disabled = 1 << 2,  // false    // [BETA] Disable interactions but doesn't affect visuals yet. See github.com/ocornut/imgui/issues/211
	ImGuiItemFlags_NoNav = 1 << 3,  // false
	ImGuiItemFlags_NoNavDefaultFocus = 1 << 4,  // false
	ImGuiItemFlags_SelectableDontClosePopup = 1 << 5,  // false    // MenuItem/Selectable() automatically closes current Popup window
	ImGuiItemFlags_MixedValue = 1 << 6,  // false    // [BETA] Represent a mixed/indeterminate value, generally multi-selection where values differ. Currently only supported by Checkbox() (later should support all sorts of widgets)
	ImGuiItemFlags_Default_ = 0
};

// Storage for LastItem data
enum ImGuiItemStatusFlags_
{
	ImGuiItemStatusFlags_None = 0,
	ImGuiItemStatusFlags_HoveredRect = 1 << 0,
	ImGuiItemStatusFlags_HasDisplayRect = 1 << 1,
	ImGuiItemStatusFlags_Edited = 1 << 2,   // Value exposed by item was edited in the current frame (should match the bool return value of most widgets)
	ImGuiItemStatusFlags_ToggledSelection = 1 << 3,   // Set when Selectable(), TreeNode() reports toggling a selection. We can't report "Selected" because reporting the change allows us to handle clipping with less issues.
	ImGuiItemStatusFlags_ToggledOpen = 1 << 4,   // Set when TreeNode() reports toggling their open state.
	ImGuiItemStatusFlags_HasDeactivated = 1 << 5,   // Set if the widget/group is able to provide data for the ImGuiItemStatusFlags_Deactivated flag.
	ImGuiItemStatusFlags_Deactivated = 1 << 6    // Only valid if ImGuiItemStatusFlags_HasDeactivated is set.

#ifdef IMGUI_ENABLE_TEST_ENGINE
	, // [imgui_tests only]
	ImGuiItemStatusFlags_Openable = 1 << 10,  //
	ImGuiItemStatusFlags_Opened = 1 << 11,  //
	ImGuiItemStatusFlags_Checkable = 1 << 12,  //
	ImGuiItemStatusFlags_Checked = 1 << 13   //
#endif
};

enum ImGuiTextFlags_
{
	ImGuiTextFlags_None = 0,
	ImGuiTextFlags_NoWidthForLargeClippedText = 1 << 0
};

enum ImGuiTooltipFlags_
{
	ImGuiTooltipFlags_None = 0,
	ImGuiTooltipFlags_OverridePreviousTooltip = 1 << 0      // Override will clear/ignore previously submitted tooltip (defaults to append)
};

// FIXME: this is in development, not exposed/functional as a generic feature yet.
// Horizontal/Vertical enums are fixed to 0/1 so they may be used to index ImVec2
enum ImGuiLayoutType_
{
	ImGuiLayoutType_Horizontal = 0,
	ImGuiLayoutType_Vertical = 1
};

enum ImGuiLogType
{
	ImGuiLogType_None = 0,
	ImGuiLogType_TTY,
	ImGuiLogType_File,
	ImGuiLogType_Buffer,
	ImGuiLogType_Clipboard
};

// X/Y enums are fixed to 0/1 so they may be used to index ImVec2
enum ImGuiAxis
{
	ImGuiAxis_None = -1,
	ImGuiAxis_X = 0,
	ImGuiAxis_Y = 1
};

enum ImGuiPlotType
{
	ImGuiPlotType_Lines,
	ImGuiPlotType_Histogram
};

enum ImGuiInputSource
{
	ImGuiInputSource_None = 0,
	ImGuiInputSource_Mouse,
	ImGuiInputSource_Nav,
	ImGuiInputSource_NavKeyboard,   // Only used occasionally for storage, not tested/handled by most code
	ImGuiInputSource_NavGamepad,    // "
	ImGuiInputSource_COUNT
};

// FIXME-NAV: Clarify/expose various repeat delay/rate
enum ImGuiInputReadMode
{
	ImGuiInputReadMode_Down,
	ImGuiInputReadMode_Pressed,
	ImGuiInputReadMode_Released,
	ImGuiInputReadMode_Repeat,
	ImGuiInputReadMode_RepeatSlow,
	ImGuiInputReadMode_RepeatFast
};

enum ImGuiNavHighlightFlags_
{
	ImGuiNavHighlightFlags_None = 0,
	ImGuiNavHighlightFlags_TypeDefault = 1 << 0,
	ImGuiNavHighlightFlags_TypeThin = 1 << 1,
	ImGuiNavHighlightFlags_AlwaysDraw = 1 << 2,       // Draw rectangular highlight if (g.NavId == id) _even_ when using the mouse.
	ImGuiNavHighlightFlags_NoRounding = 1 << 3
};

enum ImGuiNavDirSourceFlags_
{
	ImGuiNavDirSourceFlags_None = 0,
	ImGuiNavDirSourceFlags_Keyboard = 1 << 0,
	ImGuiNavDirSourceFlags_PadDPad = 1 << 1,
	ImGuiNavDirSourceFlags_PadLStick = 1 << 2
};

enum ImGuiNavMoveFlags_
{
	ImGuiNavMoveFlags_None = 0,
	ImGuiNavMoveFlags_LoopX = 1 << 0,   // On failed request, restart from opposite side
	ImGuiNavMoveFlags_LoopY = 1 << 1,
	ImGuiNavMoveFlags_WrapX = 1 << 2,   // On failed request, request from opposite side one line down (when NavDir==right) or one line up (when NavDir==left)
	ImGuiNavMoveFlags_WrapY = 1 << 3,   // This is not super useful for provided for completeness
	ImGuiNavMoveFlags_AllowCurrentNavId = 1 << 4,   // Allow scoring and considering the current NavId as a move target candidate. This is used when the move source is offset (e.g. pressing PageDown actually needs to send a Up move request, if we are pressing PageDown from the bottom-most item we need to stay in place)
	ImGuiNavMoveFlags_AlsoScoreVisibleSet = 1 << 5,   // Store alternate result in NavMoveResultLocalVisibleSet that only comprise elements that are already fully visible.
	ImGuiNavMoveFlags_ScrollToEdge = 1 << 6
};

enum ImGuiNavForward
{
	ImGuiNavForward_None,
	ImGuiNavForward_ForwardQueued,
	ImGuiNavForward_ForwardActive
};

enum ImGuiNavLayer
{
	ImGuiNavLayer_Main = 0,    // Main scrolling layer
	ImGuiNavLayer_Menu = 1,    // Menu layer (access with Alt/ImGuiNavInput_Menu)
	ImGuiNavLayer_COUNT
};

enum ImGuiPopupPositionPolicy
{
	ImGuiPopupPositionPolicy_Default,
	ImGuiPopupPositionPolicy_ComboBox
};

// 1D vector (this odd construct is used to facilitate the transition between 1D and 2D, and the maintenance of some branches/patches)
struct ImVec1
{
	float   x;
	ImVec1()
	{
		x = 0.0f;
	}
	ImVec1( float _x )
	{
		x = _x;
	}
};

// 2D vector (half-size integer)
struct ImVec2ih
{
	short   x, y;
	ImVec2ih()
	{
		x = y = 0;
	}
	ImVec2ih( short _x, short _y )
	{
		x = _x; y = _y;
	}
	explicit ImVec2ih( const ImVec2& rhs )
	{
		x = ( short )rhs.x; y = ( short )rhs.y;
	}
};

// 2D axis aligned bounding-box
// NB: we can't rely on ImVec2 math operators being available here
struct IMGUI_API ImRect
{
	ImVec2      Min;    // Upper-left
	ImVec2      Max;    // Lower-right

	ImRect() : Min( 0.0f, 0.0f ), Max( 0.0f, 0.0f )
	{ }
	ImRect( const ImVec2& min, const ImVec2& max ) : Min( min ), Max( max )
	{ }
	ImRect( const ImVec4& v ) : Min( v.x, v.y ), Max( v.z, v.w )
	{ }
	ImRect( float x1, float y1, float x2, float y2 ) : Min( x1, y1 ), Max( x2, y2 )
	{ }

	ImVec2      GetCenter() const
	{
		return ImVec2( ( Min.x + Max.x ) * 0.5f, ( Min.y + Max.y ) * 0.5f );
	}
	ImVec2      GetSize() const
	{
		return ImVec2( Max.x - Min.x, Max.y - Min.y );
	}
	float       GetWidth() const
	{
		return Max.x - Min.x;
	}
	float       GetHeight() const
	{
		return Max.y - Min.y;
	}
	ImVec2      GetTL() const
	{
		return Min;
	}                   // Top-left
	ImVec2      GetTR() const
	{
		return ImVec2( Max.x, Min.y );
	}  // Top-right
	ImVec2      GetBL() const
	{
		return ImVec2( Min.x, Max.y );
	}  // Bottom-left
	ImVec2      GetBR() const
	{
		return Max;
	}                   // Bottom-right
	bool        Contains( const ImVec2& p ) const
	{
		return p.x >= Min.x && p.y >= Min.y && p.x < Max.x&& p.y < Max.y;
	}
	bool        Contains( const ImRect& r ) const
	{
		return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y;
	}
	bool        Overlaps( const ImRect& r ) const
	{
		return r.Min.y <  Max.y&& r.Max.y >  Min.y && r.Min.x <  Max.x&& r.Max.x >  Min.x;
	}
	void        Add( const ImVec2& p )
	{
		if( Min.x > p.x )     Min.x = p.x;     if( Min.y > p.y )     Min.y = p.y;     if( Max.x < p.x )     Max.x = p.x;     if( Max.y < p.y )     Max.y = p.y;
	}
	void        Add( const ImRect& r )
	{
		if( Min.x > r.Min.x ) Min.x = r.Min.x; if( Min.y > r.Min.y ) Min.y = r.Min.y; if( Max.x < r.Max.x ) Max.x = r.Max.x; if( Max.y < r.Max.y ) Max.y = r.Max.y;
	}
	void        Expand( const float amount )
	{
		Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount;
	}
	void        Expand( const ImVec2& amount )
	{
		Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y;
	}
	void        Translate( const ImVec2& d )
	{
		Min.x += d.x; Min.y += d.y; Max.x += d.x; Max.y += d.y;
	}
	void        TranslateX( float dx )
	{
		Min.x += dx; Max.x += dx;
	}
	void        TranslateY( float dy )
	{
		Min.y += dy; Max.y += dy;
	}
	void        ClipWith( const ImRect& r )
	{
		Min = ImMax( Min, r.Min ); Max = ImMin( Max, r.Max );
	}                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.
	void        ClipWithFull( const ImRect& r )
	{
		Min = ImClamp( Min, r.Min, r.Max ); Max = ImClamp( Max, r.Min, r.Max );
	} // Full version, ensure both points are fully clipped.
	void        Floor()
	{
		Min.x = IM_FLOOR( Min.x ); Min.y = IM_FLOOR( Min.y ); Max.x = IM_FLOOR( Max.x ); Max.y = IM_FLOOR( Max.y );
	}
	bool        IsInverted() const
	{
		return Min.x > Max.x || Min.y > Max.y;
	}
};

// Type information associated to one ImGuiDataType. Retrieve with DataTypeGetInfo().
struct ImGuiDataTypeInfo
{
	size_t      Size;           // Size in byte
	const char* PrintFmt;       // Default printf format for the type
	const char* ScanFmt;        // Default scanf format for the type
};

// Extend ImGuiDataType_
enum ImGuiDataTypePrivate_
{
	ImGuiDataType_String = ImGuiDataType_COUNT + 1,
	ImGuiDataType_Pointer,
	ImGuiDataType_ID
};

// Stacked color modifier, backup of modified data so we can restore it
struct ImGuiColorMod
{
	ImGuiCol    Col;
	ImVec4      BackupValue;
};

// Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.
struct ImGuiStyleMod
{
	ImGuiStyleVar   VarIdx;
	union
	{
		int BackupInt[ 2 ]; float BackupFloat[ 2 ];
	};
	ImGuiStyleMod( ImGuiStyleVar idx, int v )
	{
		VarIdx = idx; BackupInt[ 0 ] = v;
	}
	ImGuiStyleMod( ImGuiStyleVar idx, float v )
	{
		VarIdx = idx; BackupFloat[ 0 ] = v;
	}
	ImGuiStyleMod( ImGuiStyleVar idx, ImVec2 v )
	{
		VarIdx = idx; BackupFloat[ 0 ] = v.x; BackupFloat[ 1 ] = v.y;
	}
};

// Stacked storage data for BeginGroup()/EndGroup()
struct ImGuiGroupData
{
	ImVec2      BackupCursorPos;
	ImVec2      BackupCursorMaxPos;
	ImVec1      BackupIndent;
	ImVec1      BackupGroupOffset;
	ImVec2      BackupCurrLineSize;
	float       BackupCurrLineTextBaseOffset;
	ImGuiID     BackupActiveIdIsAlive;
	bool        BackupActiveIdPreviousFrameIsAlive;
	bool        EmitItem;
};

// Simple column measurement, currently used for MenuItem() only.. This is very short-sighted/throw-away code and NOT a generic helper.
struct IMGUI_API ImGuiMenuColumns
{
	float       Spacing;
	float       Width, NextWidth;
	float       Pos[ 3 ], NextWidths[ 3 ];

	ImGuiMenuColumns();
	void        Update( int count, float spacing, bool clear );
	float       DeclColumns( float w0, float w1, float w2 );
	float       CalcExtraSpace( float avail_w ) const;
};

// Internal state of the currently focused/edited text input box
// For a given item ID, access with ImGui::GetInputTextState()
struct IMGUI_API ImGuiInputTextState
{
	ImGuiID                 ID;                     // widget id owning the text state
	int                     CurLenW, CurLenA;       // we need to maintain our buffer length in both UTF-8 and wchar format. UTF-8 length is valid even if TextA is not.
	ImVector<ImWchar>       TextW;                  // edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.
	ImVector<char>          TextA;                  // temporary UTF8 buffer for callbacks and other operations. this is not updated in every code-path! size=capacity.
	ImVector<char>          InitialTextA;           // backup of end-user buffer at the time of focus (in UTF-8, unaltered)
	bool                    TextAIsValid;           // temporary UTF8 buffer is not initially valid before we make the widget active (until then we pull the data from user argument)
	int                     BufCapacityA;           // end-user buffer capacity
	float                   ScrollX;                // horizontal scrolling/offset
	ImStb::STB_TexteditState Stb;                   // state for stb_textedit.h
	float                   CursorAnim;             // timer for cursor blink, reset on every user action so the cursor reappears immediately
	bool                    CursorFollow;           // set when we want scrolling to follow the current cursor position (not always!)
	bool                    SelectedAllMouseLock;   // after a double-click to select all, we ignore further mouse drags to update selection
	ImGuiInputTextFlags     UserFlags;              // Temporarily set while we call user's callback
	ImGuiInputTextCallback  UserCallback;           // "
	void* UserCallbackData;       // "

	ImGuiInputTextState()
	{
		memset( this, 0, sizeof( *this ) );
	}
	void        ClearText()
	{
		CurLenW = CurLenA = 0; TextW[ 0 ] = 0; TextA[ 0 ] = 0; CursorClamp();
	}
	void        ClearFreeMemory()
	{
		TextW.clear(); TextA.clear(); InitialTextA.clear();
	}
	int         GetUndoAvailCount() const
	{
		return Stb.undostate.undo_point;
	}
	int         GetRedoAvailCount() const
	{
		return STB_TEXTEDIT_UNDOSTATECOUNT - Stb.undostate.redo_point;
	}
	void        OnKeyPressed( int key );      // Cannot be inline because we call in code in stb_textedit.h implementation

	// Cursor & Selection
	void        CursorAnimReset()
	{
		CursorAnim = -0.30f;
	}                                   // After a user-input the cursor stays on for a while without blinking
	void        CursorClamp()
	{
		Stb.cursor = ImMin( Stb.cursor, CurLenW ); Stb.select_start = ImMin( Stb.select_start, CurLenW ); Stb.select_end = ImMin( Stb.select_end, CurLenW );
	}
	bool        HasSelection() const
	{
		return Stb.select_start != Stb.select_end;
	}
	void        ClearSelection()
	{
		Stb.select_start = Stb.select_end = Stb.cursor;
	}
	void        SelectAll()
	{
		Stb.select_start = 0; Stb.cursor = Stb.select_end = CurLenW; Stb.has_preferred_x = 0;
	}
};

// Windows data saved in imgui.ini file
// Because we never destroy or rename ImGuiWindowSettings, we can store the names in a separate buffer easily.
// (this is designed to be stored in a ImChunkStream buffer, with the variable-length Name following our structure)
struct ImGuiWindowSettings
{
	ImGuiID     ID;
	ImVec2ih    Pos;
	ImVec2ih    Size;
	bool        Collapsed;

	ImGuiWindowSettings()
	{
		ID = 0; Pos = Size = ImVec2ih( 0, 0 ); Collapsed = false;
	}
	char* GetName()
	{
		return ( char* )( this + 1 );
	}
};

struct ImGuiSettingsHandler
{
	const char* TypeName;       // Short description stored in .ini file. Disallowed characters: '[' ']'
	ImGuiID     TypeHash;       // == ImHashStr(TypeName)
	void* ( *ReadOpenFn )( ImGuiContext* ctx, ImGuiSettingsHandler* handler, const char* name );              // Read: Called when entering into a new ini entry e.g. "[Window][Name]"
	void        ( *ReadLineFn )( ImGuiContext* ctx, ImGuiSettingsHandler* handler, void* entry, const char* line ); // Read: Called for every line of text within an ini entry
	void        ( *WriteAllFn )( ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* out_buf );      // Write: Output every entries into 'out_buf'
	void* UserData;

	ImGuiSettingsHandler()
	{
		memset( this, 0, sizeof( *this ) );
	}
};

// Storage for current popup stack
struct ImGuiPopupData
{
	ImGuiID             PopupId;        // Set on OpenPopup()
	ImGuiWindow* Window;         // Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()
	ImGuiWindow* SourceWindow;   // Set on OpenPopup() copy of NavWindow at the time of opening the popup
	int                 OpenFrameCount; // Set on OpenPopup()
	ImGuiID             OpenParentId;   // Set on OpenPopup(), we need this to differentiate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)
	ImVec2              OpenPopupPos;   // Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)
	ImVec2              OpenMousePos;   // Set on OpenPopup(), copy of mouse position at the time of opening popup

	ImGuiPopupData()
	{
		PopupId = 0; Window = SourceWindow = NULL; OpenFrameCount = -1; OpenParentId = 0;
	}
};

struct ImGuiColumnData
{
	float               OffsetNorm;         // Column start offset, normalized 0.0 (far left) -> 1.0 (far right)
	float               OffsetNormBeforeResize;
	ImGuiColumnsFlags   Flags;              // Not exposed
	ImRect              ClipRect;

	ImGuiColumnData()
	{
		OffsetNorm = OffsetNormBeforeResize = 0.0f; Flags = ImGuiColumnsFlags_None;
	}
};

struct ImGuiColumns
{
	ImGuiID             ID;
	ImGuiColumnsFlags   Flags;
	bool                IsFirstFrame;
	bool                IsBeingResized;
	int                 Current;
	int                 Count;
	float               OffMinX, OffMaxX;       // Offsets from HostWorkRect.Min.x
	float               LineMinY, LineMaxY;
	float               HostCursorPosY;         // Backup of CursorPos at the time of BeginColumns()
	float               HostCursorMaxPosX;      // Backup of CursorMaxPos at the time of BeginColumns()
	ImRect              HostClipRect;           // Backup of ClipRect at the time of BeginColumns()
	ImRect              HostWorkRect;           // Backup of WorkRect at the time of BeginColumns()
	ImVector<ImGuiColumnData> Columns;
	ImDrawListSplitter  Splitter;

	ImGuiColumns()
	{
		Clear();
	}
	void Clear()
	{
		ID = 0;
		Flags = ImGuiColumnsFlags_None;
		IsFirstFrame = false;
		IsBeingResized = false;
		Current = 0;
		Count = 1;
		OffMinX = OffMaxX = 0.0f;
		LineMinY = LineMaxY = 0.0f;
		HostCursorPosY = 0.0f;
		HostCursorMaxPosX = 0.0f;
		Columns.clear();
	}
};

// ImDrawList: Helper function to calculate a circle's segment count given its radius and a "maximum error" value.
#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN                     12
#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX                     512
#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp((int)((IM_PI * 2.0f) / ImAcos(((_RAD) - (_MAXERROR)) / (_RAD))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)

// ImDrawList: You may set this to higher values (e.g. 2 or 3) to increase tessellation of fast rounded corners path.
#ifndef IM_DRAWLIST_ARCFAST_TESSELLATION_MULTIPLIER
#define IM_DRAWLIST_ARCFAST_TESSELLATION_MULTIPLIER             1
#endif

// Data shared between all ImDrawList instances
// You may want to create your own instance of this if you want to use ImDrawList completely without ImGui. In that case, watch out for future changes to this structure.
struct IMGUI_API ImDrawListSharedData
{
	ImVec2          TexUvWhitePixel;            // UV of white pixel in the atlas
	ImFont* Font;                       // Current/default font (optional, for simplified AddText overload)
	float           FontSize;                   // Current/default font size (optional, for simplified AddText overload)
	float           CurveTessellationTol;       // Tessellation tolerance when using PathBezierCurveTo()
	float           CircleSegmentMaxError;      // Number of circle segments to use per pixel of radius for AddCircle() etc
	ImVec4          ClipRectFullscreen;         // Value for PushClipRectFullscreen()
	ImDrawListFlags InitialFlags;               // Initial flags at the beginning of the frame (it is possible to alter flags on a per-drawlist basis afterwards)

	// [Internal] Lookup tables
	ImVec2          ArcFastVtx[ 12 * IM_DRAWLIST_ARCFAST_TESSELLATION_MULTIPLIER ];  // FIXME: Bake rounded corners fill/borders in atlas
	ImU8            CircleSegmentCounts[ 64 ];    // Precomputed segment count for given radius (array index + 1) before we calculate it dynamically (to avoid calculation overhead)

	ImDrawListSharedData();
	void SetCircleSegmentMaxError( float max_error );
};

struct ImDrawDataBuilder
{
	ImVector<ImDrawList*>   Layers[ 2 ];           // Global layers for: regular, tooltip

	void Clear()
	{
		for( int n = 0; n < IM_ARRAYSIZE( Layers ); n++ ) Layers[ n ].resize( 0 );
	}
	void ClearFreeMemory()
	{
		for( int n = 0; n < IM_ARRAYSIZE( Layers ); n++ ) Layers[ n ].clear();
	}
	IMGUI_API void FlattenIntoSingleLayer();
};

struct ImGuiNavMoveResult
{
	ImGuiWindow* Window;             // Best candidate window
	ImGuiID         ID;                 // Best candidate ID
	ImGuiID         FocusScopeId;       // Best candidate focus scope ID
	float           DistBox;            // Best candidate box distance to current NavId
	float           DistCenter;         // Best candidate center distance to current NavId
	float           DistAxial;
	ImRect          RectRel;            // Best candidate bounding box in window relative space

	ImGuiNavMoveResult()
	{
		Clear();
	}
	void Clear()
	{
		Window = NULL; ID = FocusScopeId = 0; DistBox = DistCenter = DistAxial = FLT_MAX; RectRel = ImRect();
	}
};

enum ImGuiNextWindowDataFlags_
{
	ImGuiNextWindowDataFlags_None = 0,
	ImGuiNextWindowDataFlags_HasPos = 1 << 0,
	ImGuiNextWindowDataFlags_HasSize = 1 << 1,
	ImGuiNextWindowDataFlags_HasContentSize = 1 << 2,
	ImGuiNextWindowDataFlags_HasCollapsed = 1 << 3,
	ImGuiNextWindowDataFlags_HasSizeConstraint = 1 << 4,
	ImGuiNextWindowDataFlags_HasFocus = 1 << 5,
	ImGuiNextWindowDataFlags_HasBgAlpha = 1 << 6,
	ImGuiNextWindowDataFlags_HasScroll = 1 << 7
};

// Storage for SetNexWindow** functions
struct ImGuiNextWindowData
{
	ImGuiNextWindowDataFlags    Flags;
	ImGuiCond                   PosCond;
	ImGuiCond                   SizeCond;
	ImGuiCond                   CollapsedCond;
	ImVec2                      PosVal;
	ImVec2                      PosPivotVal;
	ImVec2                      SizeVal;
	ImVec2                      ContentSizeVal;
	ImVec2                      ScrollVal;
	bool                        CollapsedVal;
	ImRect                      SizeConstraintRect;
	ImGuiSizeCallback           SizeCallback;
	void* SizeCallbackUserData;
	float                       BgAlphaVal;             // Override background alpha
	ImVec2                      MenuBarOffsetMinVal;    // *Always on* This is not exposed publicly, so we don't clear it.

	ImGuiNextWindowData()
	{
		memset( this, 0, sizeof( *this ) );
	}
	inline void ClearFlags()
	{
		Flags = ImGuiNextWindowDataFlags_None;
	}
};

enum ImGuiNextItemDataFlags_
{
	ImGuiNextItemDataFlags_None = 0,
	ImGuiNextItemDataFlags_HasWidth = 1 << 0,
	ImGuiNextItemDataFlags_HasOpen = 1 << 1
};

struct ImGuiNextItemData
{
	ImGuiNextItemDataFlags      Flags;
	float                       Width;          // Set by SetNextItemWidth()
	ImGuiID                     FocusScopeId;   // Set by SetNextItemMultiSelectData() (!= 0 signify value has been set, so it's an alternate version of HasSelectionData, we don't use Flags for this because they are cleared too early. This is mostly used for debugging)
	ImGuiCond                   OpenCond;
	bool                        OpenVal;        // Set by SetNextItemOpen()

	ImGuiNextItemData()
	{
		memset( this, 0, sizeof( *this ) );
	}
	inline void ClearFlags()
	{
		Flags = ImGuiNextItemDataFlags_None;
	} // Also cleared manually by ItemAdd()!
};

//-----------------------------------------------------------------------------
// Tabs
//-----------------------------------------------------------------------------

struct ImGuiShrinkWidthItem
{
	int             Index;
	float           Width;
};

struct ImGuiPtrOrIndex
{
	void* Ptr;                // Either field can be set, not both. e.g. Dock node tab bars are loose while BeginTabBar() ones are in a pool.
	int             Index;              // Usually index in a main pool.

	ImGuiPtrOrIndex( void* ptr )
	{
		Ptr = ptr; Index = -1;
	}
	ImGuiPtrOrIndex( int index )
	{
		Ptr = NULL; Index = index;
	}
};

//-----------------------------------------------------------------------------
// Main Dear ImGui context
//-----------------------------------------------------------------------------

struct ImGuiContext
{
	bool                    Initialized;
	bool                    FontAtlasOwnedByContext;            // IO.Fonts-> is owned by the ImGuiContext and will be destructed along with it.
	ImGuiIO                 IO;
	ImGuiStyle              Style;
	ImFont* Font;                               // (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()
	float                   FontSize;                           // (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.
	float                   FontBaseSize;                       // (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.
	ImDrawListSharedData    DrawListSharedData;
	double                  Time;
	int                     FrameCount;
	int                     FrameCountEnded;
	int                     FrameCountRendered;
	bool                    WithinFrameScope;                   // Set by NewFrame(), cleared by EndFrame()
	bool                    WithinFrameScopeWithImplicitWindow; // Set by NewFrame(), cleared by EndFrame() when the implicit debug window has been pushed
	bool                    WithinEndChild;                     // Set within EndChild()
	bool                    TestEngineHookItems;                // Will call test engine hooks: ImGuiTestEngineHook_ItemAdd(), ImGuiTestEngineHook_ItemInfo(), ImGuiTestEngineHook_Log()
	ImGuiID                 TestEngineHookIdInfo;               // Will call test engine hooks: ImGuiTestEngineHook_IdInfo() from GetID()
	void* TestEngine;                         // Test engine user data

	// Windows state
	ImVector<ImGuiWindow*>  Windows;                            // Windows, sorted in display order, back to front
	ImVector<ImGuiWindow*>  WindowsFocusOrder;                  // Windows, sorted in focus order, back to front. (FIXME: We could only store root windows here! Need to sort out the Docking equivalent which is RootWindowDockStop and is unfortunately a little more dynamic)
	ImVector<ImGuiWindow*>  WindowsTempSortBuffer;              // Temporary buffer used in EndFrame() to reorder windows so parents are kept before their child
	ImVector<ImGuiWindow*>  CurrentWindowStack;
	ImGuiStorage            WindowsById;                        // Map window's ImGuiID to ImGuiWindow*
	int                     WindowsActiveCount;                 // Number of unique windows submitted by frame
	ImGuiWindow* CurrentWindow;                      // Window being drawn into
	ImGuiWindow* HoveredWindow;                      // Will catch mouse inputs
	ImGuiWindow* HoveredRootWindow;                  // Will catch mouse inputs (for focus/move only)
	ImGuiWindow* MovingWindow;                       // Track the window we clicked on (in order to preserve focus). The actually window that is moved is generally MovingWindow->RootWindow.
	ImGuiWindow* WheelingWindow;                     // Track the window we started mouse-wheeling on. Until a timer elapse or mouse has moved, generally keep scrolling the same window even if during the course of scrolling the mouse ends up hovering a child window.
	ImVec2                  WheelingWindowRefMousePos;
	float                   WheelingWindowTimer;

	// Item/widgets state and tracking information
	ImGuiID                 HoveredId;                          // Hovered widget
	bool                    HoveredIdAllowOverlap;
	ImGuiID                 HoveredIdPreviousFrame;
	float                   HoveredIdTimer;                     // Measure contiguous hovering time
	float                   HoveredIdNotActiveTimer;            // Measure contiguous hovering time where the item has not been active
	ImGuiID                 ActiveId;                           // Active widget
	ImGuiID                 ActiveIdIsAlive;                    // Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)
	float                   ActiveIdTimer;
	bool                    ActiveIdIsJustActivated;            // Set at the time of activation for one frame
	bool                    ActiveIdAllowOverlap;               // Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)
	bool                    ActiveIdHasBeenPressedBefore;       // Track whether the active id led to a press (this is to allow changing between PressOnClick and PressOnRelease without pressing twice). Used by range_select branch.
	bool                    ActiveIdHasBeenEditedBefore;        // Was the value associated to the widget Edited over the course of the Active state.
	bool                    ActiveIdHasBeenEditedThisFrame;
	ImU32                   ActiveIdUsingNavDirMask;            // Active widget will want to read those nav move requests (e.g. can activate a button and move away from it)
	ImU32                   ActiveIdUsingNavInputMask;          // Active widget will want to read those nav inputs.
	ImU64                   ActiveIdUsingKeyInputMask;          // Active widget will want to read those key inputs. When we grow the ImGuiKey enum we'll need to either to order the enum to make useful keys come first, either redesign this into e.g. a small array.
	ImVec2                  ActiveIdClickOffset;                // Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)
	ImGuiWindow* ActiveIdWindow;
	ImGuiInputSource        ActiveIdSource;                     // Activating with mouse or nav (gamepad/keyboard)
	int                     ActiveIdMouseButton;
	ImGuiID                 ActiveIdPreviousFrame;
	bool                    ActiveIdPreviousFrameIsAlive;
	bool                    ActiveIdPreviousFrameHasBeenEditedBefore;
	ImGuiWindow* ActiveIdPreviousFrameWindow;
	ImGuiID                 LastActiveId;                       // Store the last non-zero ActiveId, useful for animation.
	float                   LastActiveIdTimer;                  // Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.

	// Next window/item data
	ImGuiNextWindowData     NextWindowData;                     // Storage for SetNextWindow** functions
	ImGuiNextItemData       NextItemData;                       // Storage for SetNextItem** functions

	// Shared stacks
	ImVector<ImGuiColorMod> ColorModifiers;                     // Stack for PushStyleColor()/PopStyleColor()
	ImVector<ImGuiStyleMod> StyleModifiers;                     // Stack for PushStyleVar()/PopStyleVar()
	ImVector<ImFont*>       FontStack;                          // Stack for PushFont()/PopFont()
	ImVector<ImGuiPopupData>OpenPopupStack;                     // Which popups are open (persistent)
	ImVector<ImGuiPopupData>BeginPopupStack;                    // Which level of BeginPopup() we are in (reset every frame)

	// Gamepad/keyboard Navigation
	ImGuiWindow* NavWindow;                          // Focused window for navigation. Could be called 'FocusWindow'
	ImGuiID                 NavId;                              // Focused item for navigation
	ImGuiID                 NavFocusScopeId;
	ImGuiID                 NavActivateId;                      // ~~ (g.ActiveId == 0) && IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0, also set when calling ActivateItem()
	ImGuiID                 NavActivateDownId;                  // ~~ IsNavInputDown(ImGuiNavInput_Activate) ? NavId : 0
	ImGuiID                 NavActivatePressedId;               // ~~ IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0
	ImGuiID                 NavInputId;                         // ~~ IsNavInputPressed(ImGuiNavInput_Input) ? NavId : 0
	ImGuiID                 NavJustTabbedId;                    // Just tabbed to this id.
	ImGuiID                 NavJustMovedToId;                   // Just navigated to this id (result of a successfully MoveRequest).
	ImGuiID                 NavJustMovedToFocusScopeId;         // Just navigated to this focus scope id (result of a successfully MoveRequest).
	ImGuiKeyModFlags        NavJustMovedToKeyMods;
	ImGuiID                 NavNextActivateId;                  // Set by ActivateItem(), queued until next frame.
	ImGuiInputSource        NavInputSource;                     // Keyboard or Gamepad mode? THIS WILL ONLY BE None or NavGamepad or NavKeyboard.
	ImRect                  NavScoringRect;                     // Rectangle used for scoring, in screen space. Based of window->DC.NavRefRectRel[], modified for directional navigation scoring.
	int                     NavScoringCount;                    // Metrics for debugging
	ImGuiNavLayer           NavLayer;                           // Layer we are navigating on. For now the system is hard-coded for 0=main contents and 1=menu/title bar, may expose layers later.
	int                     NavIdTabCounter;                    // == NavWindow->DC.FocusIdxTabCounter at time of NavId processing
	bool                    NavIdIsAlive;                       // Nav widget has been seen this frame ~~ NavRefRectRel is valid
	bool                    NavMousePosDirty;                   // When set we will update mouse position if (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) if set (NB: this not enabled by default)
	bool                    NavDisableHighlight;                // When user starts using mouse, we hide gamepad/keyboard highlight (NB: but they are still available, which is why NavDisableHighlight isn't always != NavDisableMouseHover)
	bool                    NavDisableMouseHover;               // When user starts using gamepad/keyboard, we hide mouse hovering highlight until mouse is touched again.
	bool                    NavAnyRequest;                      // ~~ NavMoveRequest || NavInitRequest
	bool                    NavInitRequest;                     // Init request for appearing window to select first item
	bool                    NavInitRequestFromMove;
	ImGuiID                 NavInitResultId;
	ImRect                  NavInitResultRectRel;
	bool                    NavMoveFromClampedRefRect;          // Set by manual scrolling, if we scroll to a point where NavId isn't visible we reset navigation from visible items
	bool                    NavMoveRequest;                     // Move request for this frame
	ImGuiNavMoveFlags       NavMoveRequestFlags;
	ImGuiNavForward         NavMoveRequestForward;              // None / ForwardQueued / ForwardActive (this is used to navigate sibling parent menus from a child menu)
	ImGuiKeyModFlags        NavMoveRequestKeyMods;
	ImGuiDir                NavMoveDir, NavMoveDirLast;         // Direction of the move request (left/right/up/down), direction of the previous move request
	ImGuiDir                NavMoveClipDir;                     // FIXME-NAV: Describe the purpose of this better. Might want to rename?
	ImGuiNavMoveResult      NavMoveResultLocal;                 // Best move request candidate within NavWindow
	ImGuiNavMoveResult      NavMoveResultLocalVisibleSet;       // Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)
	ImGuiNavMoveResult      NavMoveResultOther;                 // Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)

	// Navigation: Windowing (CTRL+TAB, holding Menu button + directional pads to move/resize)
	ImGuiWindow* NavWindowingTarget;                 // When selecting a window (holding Menu+FocusPrev/Next, or equivalent of CTRL-TAB) this window is temporarily displayed top-most.
	ImGuiWindow* NavWindowingTargetAnim;             // Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0f
	ImGuiWindow* NavWindowingList;
	float                   NavWindowingTimer;
	float                   NavWindowingHighlightAlpha;
	bool                    NavWindowingToggleLayer;

	// Legacy Focus/Tabbing system (older than Nav, active even if Nav is disabled, misnamed. FIXME-NAV: This needs a redesign!)
	ImGuiWindow* FocusRequestCurrWindow;             //
	ImGuiWindow* FocusRequestNextWindow;             //
	int                     FocusRequestCurrCounterRegular;     // Any item being requested for focus, stored as an index (we on layout to be stable between the frame pressing TAB and the next frame, semi-ouch)
	int                     FocusRequestCurrCounterTabStop;     // Tab item being requested for focus, stored as an index
	int                     FocusRequestNextCounterRegular;     // Stored for next frame
	int                     FocusRequestNextCounterTabStop;     // "
	bool                    FocusTabPressed;                    //

	// Render
	ImDrawData              DrawData;                           // Main ImDrawData instance to pass render information to the user
	ImDrawDataBuilder       DrawDataBuilder;
	float                   DimBgRatio;                         // 0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)
	ImDrawList              BackgroundDrawList;                 // First draw list to be rendered.
	ImDrawList              ForegroundDrawList;                 // Last draw list to be rendered. This is where we the render software mouse cursor (if io.MouseDrawCursor is set) and most debug overlays.
	ImGuiMouseCursor        MouseCursor;

	// Drag and Drop
	bool                    DragDropActive;
	bool                    DragDropWithinSource;               // Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag source.
	bool                    DragDropWithinTarget;               // Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag target.
	ImGuiDragDropFlags      DragDropSourceFlags;
	int                     DragDropSourceFrameCount;
	int                     DragDropMouseButton;
	ImGuiPayload            DragDropPayload;
	ImRect                  DragDropTargetRect;                 // Store rectangle of current target candidate (we favor small targets when overlapping)
	ImGuiID                 DragDropTargetId;
	ImGuiDragDropFlags      DragDropAcceptFlags;
	float                   DragDropAcceptIdCurrRectSurface;    // Target item surface (we resolve overlapping targets by prioritizing the smaller surface)
	ImGuiID                 DragDropAcceptIdCurr;               // Target item id (set at the time of accepting the payload)
	ImGuiID                 DragDropAcceptIdPrev;               // Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)
	int                     DragDropAcceptFrameCount;           // Last time a target expressed a desire to accept the source
	ImGuiID                 DragDropHoldJustPressedId;          // Set when holding a payload just made ButtonBehavior() return a press.
	ImVector<unsigned char> DragDropPayloadBufHeap;             // We don't expose the ImVector<> directly, ImGuiPayload only holds pointer+size
	unsigned char           DragDropPayloadBufLocal[ 16 ];        // Local buffer for small payloads

	// Tab bars
	ImGuiTabBar* CurrentTabBar;
	ImPool<ImGuiTabBar>             TabBars;
	ImVector<ImGuiPtrOrIndex>       CurrentTabBarStack;
	ImVector<ImGuiShrinkWidthItem>  ShrinkWidthBuffer;

	// Widget state
	ImVec2                  LastValidMousePos;
	ImGuiInputTextState     InputTextState;
	ImFont                  InputTextPasswordFont;
	ImGuiID                 TempInputId;                        // Temporary text input when CTRL+clicking on a slider, etc.
	ImGuiColorEditFlags     ColorEditOptions;                   // Store user options for color edit widgets
	float                   ColorEditLastHue;                   // Backup of last Hue associated to LastColor[3], so we can restore Hue in lossy RGB<>HSV round trips
	float                   ColorEditLastSat;                   // Backup of last Saturation associated to LastColor[3], so we can restore Saturation in lossy RGB<>HSV round trips
	float                   ColorEditLastColor[ 3 ];
	ImVec4                  ColorPickerRef;                     // Initial/reference color at the time of opening the color picker.
	bool                    DragCurrentAccumDirty;
	float                   DragCurrentAccum;                   // Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings
	float                   DragSpeedDefaultRatio;              // If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio
	float                   ScrollbarClickDeltaToGrabCenter;    // Distance between mouse and center of grab box, normalized in parent space. Use storage?
	int                     TooltipOverrideCount;
	ImVector<char>          ClipboardHandlerData;               // If no custom clipboard handler is defined
	ImVector<ImGuiID>       MenusIdSubmittedThisFrame;          // A list of menu IDs that were rendered at least once

	// Platform support
	ImVec2                  PlatformImePos;                     // Cursor position request & last passed to the OS Input Method Editor
	ImVec2                  PlatformImeLastPos;

	// Settings
	bool                    SettingsLoaded;
	float                   SettingsDirtyTimer;                 // Save .ini Settings to memory when time reaches zero
	ImGuiTextBuffer         SettingsIniData;                    // In memory .ini settings
	ImVector<ImGuiSettingsHandler>      SettingsHandlers;       // List of .ini settings handlers
	ImChunkStream<ImGuiWindowSettings>  SettingsWindows;        // ImGuiWindow .ini settings entries

	// Capture/Logging
	bool                    LogEnabled;
	ImGuiLogType            LogType;
	ImFileHandle            LogFile;                            // If != NULL log to stdout/ file
	ImGuiTextBuffer         LogBuffer;                          // Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.
	float                   LogLinePosY;
	bool                    LogLineFirstItem;
	int                     LogDepthRef;
	int                     LogDepthToExpand;
	int                     LogDepthToExpandDefault;            // Default/stored value for LogDepthMaxExpand if not specified in the LogXXX function call.

	// Debug Tools
	bool                    DebugItemPickerActive;
	ImGuiID                 DebugItemPickerBreakId;             // Will call IM_DEBUG_BREAK() when encountering this id

	// Misc
	float                   FramerateSecPerFrame[ 120 ];          // Calculate estimate of framerate for user over the last 2 seconds.
	int                     FramerateSecPerFrameIdx;
	float                   FramerateSecPerFrameAccum;
	int                     WantCaptureMouseNextFrame;          // Explicit capture via CaptureKeyboardFromApp()/CaptureMouseFromApp() sets those flags
	int                     WantCaptureKeyboardNextFrame;
	int                     WantTextInputNextFrame;
	char                    TempBuffer[ 1024 * 3 + 1 ];               // Temporary text buffer

	ImGuiContext( ImFontAtlas* shared_font_atlas ) : BackgroundDrawList( &DrawListSharedData ), ForegroundDrawList( &DrawListSharedData )
	{
		Initialized = false;
		FontAtlasOwnedByContext = shared_font_atlas ? false : true;
		Font = NULL;
		FontSize = FontBaseSize = 0.0f;
		IO.Fonts = shared_font_atlas ? shared_font_atlas : IM_NEW( ImFontAtlas )( );
		Time = 0.0f;
		FrameCount = 0;
		FrameCountEnded = FrameCountRendered = -1;
		WithinFrameScope = WithinFrameScopeWithImplicitWindow = WithinEndChild = false;
		TestEngineHookItems = false;
		TestEngineHookIdInfo = 0;
		TestEngine = NULL;

		WindowsActiveCount = 0;
		CurrentWindow = NULL;
		HoveredWindow = NULL;
		HoveredRootWindow = NULL;
		MovingWindow = NULL;
		WheelingWindow = NULL;
		WheelingWindowTimer = 0.0f;

		HoveredId = 0;
		HoveredIdAllowOverlap = false;
		HoveredIdPreviousFrame = 0;
		HoveredIdTimer = HoveredIdNotActiveTimer = 0.0f;
		ActiveId = 0;
		ActiveIdIsAlive = 0;
		ActiveIdTimer = 0.0f;
		ActiveIdIsJustActivated = false;
		ActiveIdAllowOverlap = false;
		ActiveIdHasBeenPressedBefore = false;
		ActiveIdHasBeenEditedBefore = false;
		ActiveIdHasBeenEditedThisFrame = false;
		ActiveIdUsingNavDirMask = 0x00;
		ActiveIdUsingNavInputMask = 0x00;
		ActiveIdUsingKeyInputMask = 0x00;
		ActiveIdClickOffset = ImVec2( -1, -1 );
		ActiveIdWindow = NULL;
		ActiveIdSource = ImGuiInputSource_None;
		ActiveIdMouseButton = 0;
		ActiveIdPreviousFrame = 0;
		ActiveIdPreviousFrameIsAlive = false;
		ActiveIdPreviousFrameHasBeenEditedBefore = false;
		ActiveIdPreviousFrameWindow = NULL;
		LastActiveId = 0;
		LastActiveIdTimer = 0.0f;

		NavWindow = NULL;
		NavId = NavFocusScopeId = NavActivateId = NavActivateDownId = NavActivatePressedId = NavInputId = 0;
		NavJustTabbedId = NavJustMovedToId = NavJustMovedToFocusScopeId = NavNextActivateId = 0;
		NavJustMovedToKeyMods = ImGuiKeyModFlags_None;
		NavInputSource = ImGuiInputSource_None;
		NavScoringRect = ImRect();
		NavScoringCount = 0;
		NavLayer = ImGuiNavLayer_Main;
		NavIdTabCounter = INT_MAX;
		NavIdIsAlive = false;
		NavMousePosDirty = false;
		NavDisableHighlight = true;
		NavDisableMouseHover = false;
		NavAnyRequest = false;
		NavInitRequest = false;
		NavInitRequestFromMove = false;
		NavInitResultId = 0;
		NavMoveFromClampedRefRect = false;
		NavMoveRequest = false;
		NavMoveRequestFlags = ImGuiNavMoveFlags_None;
		NavMoveRequestForward = ImGuiNavForward_None;
		NavMoveRequestKeyMods = ImGuiKeyModFlags_None;
		NavMoveDir = NavMoveDirLast = NavMoveClipDir = ImGuiDir_None;

		NavWindowingTarget = NavWindowingTargetAnim = NavWindowingList = NULL;
		NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;
		NavWindowingToggleLayer = false;

		FocusRequestCurrWindow = FocusRequestNextWindow = NULL;
		FocusRequestCurrCounterRegular = FocusRequestCurrCounterTabStop = INT_MAX;
		FocusRequestNextCounterRegular = FocusRequestNextCounterTabStop = INT_MAX;
		FocusTabPressed = false;

		DimBgRatio = 0.0f;
		BackgroundDrawList._OwnerName = SECURE("##Background"); // Give it a name for debugging
		ForegroundDrawList._OwnerName = SECURE("##Foreground"); // Give it a name for debugging
		MouseCursor = ImGuiMouseCursor_Arrow;

		DragDropActive = DragDropWithinSource = DragDropWithinTarget = false;
		DragDropSourceFlags = ImGuiDragDropFlags_None;
		DragDropSourceFrameCount = -1;
		DragDropMouseButton = -1;
		DragDropTargetId = 0;
		DragDropAcceptFlags = ImGuiDragDropFlags_None;
		DragDropAcceptIdCurrRectSurface = 0.0f;
		DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;
		DragDropAcceptFrameCount = -1;
		DragDropHoldJustPressedId = 0;
		memset( DragDropPayloadBufLocal, 0, sizeof( DragDropPayloadBufLocal ) );

		CurrentTabBar = NULL;

		LastValidMousePos = ImVec2( 0.0f, 0.0f );
		TempInputId = 0;
		ColorEditOptions = ImGuiColorEditFlags__OptionsDefault;
		ColorEditLastHue = ColorEditLastSat = 0.0f;
		ColorEditLastColor[ 0 ] = ColorEditLastColor[ 1 ] = ColorEditLastColor[ 2 ] = FLT_MAX;
		DragCurrentAccumDirty = false;
		DragCurrentAccum = 0.0f;
		DragSpeedDefaultRatio = 1.0f / 100.0f;
		ScrollbarClickDeltaToGrabCenter = 0.0f;
		TooltipOverrideCount = 0;

		PlatformImePos = PlatformImeLastPos = ImVec2( FLT_MAX, FLT_MAX );

		SettingsLoaded = false;
		SettingsDirtyTimer = 0.0f;

		LogEnabled = false;
		LogType = ImGuiLogType_None;
		LogFile = NULL;
		LogLinePosY = FLT_MAX;
		LogLineFirstItem = false;
		LogDepthRef = 0;
		LogDepthToExpand = LogDepthToExpandDefault = 2;

		DebugItemPickerActive = false;
		DebugItemPickerBreakId = 0;

		memset( FramerateSecPerFrame, 0, sizeof( FramerateSecPerFrame ) );
		FramerateSecPerFrameIdx = 0;
		FramerateSecPerFrameAccum = 0.0f;
		WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;
		memset( TempBuffer, 0, sizeof( TempBuffer ) );
	}
};

//-----------------------------------------------------------------------------
// ImGuiWindow
//-----------------------------------------------------------------------------

// Transient per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the DC variable name in ImGuiWindow.
// FIXME: That's theory, in practice the delimitation between ImGuiWindow and ImGuiWindowTempData is quite tenuous and could be reconsidered.
struct IMGUI_API ImGuiWindowTempData
{
	// Layout
	ImVec2                  CursorPos;              // Current emitting position, in absolute coordinates.
	ImVec2                  CursorPosPrevLine;
	ImVec2                  CursorStartPos;         // Initial position after Begin(), generally ~ window position + WindowPadding.
	ImVec2                  CursorMaxPos;           // Used to implicitly calculate the size of our contents, always growing during the frame. Used to calculate window->ContentSize at the beginning of next frame
	ImVec2                  CurrLineSize;
	ImVec2                  PrevLineSize;
	float                   CurrLineTextBaseOffset; // Baseline offset (0.0f by default on a new line, generally == style.FramePadding.y when a framed item has been added).
	float                   PrevLineTextBaseOffset;
	ImVec1                  Indent;                 // Indentation / start position from left of window (increased by TreePush/TreePop, etc.)
	ImVec1                  ColumnsOffset;          // Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.
	ImVec1                  GroupOffset;

	// Last item status
	ImGuiID                 LastItemId;             // ID for last item
	ImGuiItemStatusFlags    LastItemStatusFlags;    // Status flags for last item (see ImGuiItemStatusFlags_)
	ImRect                  LastItemRect;           // Interaction rect for last item
	ImRect                  LastItemDisplayRect;    // End-user display rect for last item (only valid if LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect)

	// Keyboard/Gamepad navigation
	ImGuiNavLayer           NavLayerCurrent;        // Current layer, 0..31 (we currently only use 0..1)
	int                     NavLayerCurrentMask;    // = (1 << NavLayerCurrent) used by ItemAdd prior to clipping.
	int                     NavLayerActiveMask;     // Which layer have been written to (result from previous frame)
	int                     NavLayerActiveMaskNext; // Which layer have been written to (buffer for current frame)
	ImGuiID                 NavFocusScopeIdCurrent; // Current focus scope ID while appending
	bool                    NavHideHighlightOneFrame;
	bool                    NavHasScroll;           // Set when scrolling can be used (ScrollMax > 0.0f)

	// Miscellaneous
	bool                    MenuBarAppending;       // FIXME: Remove this
	ImVec2                  MenuBarOffset;          // MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x, saved/restored as we switch to the menu bar. The only situation when MenuBarOffset.y is > 0 if when (SafeAreaPadding.y > FramePadding.y), often used on TVs.
	ImGuiMenuColumns        MenuColumns;            // Simplified columns storage for menu items measurement
	int                     TreeDepth;              // Current tree depth.
	ImU32                   TreeJumpToParentOnPopMask; // Store a copy of !g.NavIdIsAlive for TreeDepth 0..31.. Could be turned into a ImU64 if necessary.
	ImVector<ImGuiWindow*>  ChildWindows;
	ImGuiStorage* StateStorage;           // Current persistent per-window storage (store e.g. tree node open/close state)
	ImGuiColumns* CurrentColumns;         // Current columns set
	ImGuiLayoutType         LayoutType;
	ImGuiLayoutType         ParentLayoutType;       // Layout type of parent window at the time of Begin()
	int                     FocusCounterRegular;    // (Legacy Focus/Tabbing system) Sequential counter, start at -1 and increase as assigned via FocusableItemRegister() (FIXME-NAV: Needs redesign)
	int                     FocusCounterTabStop;    // (Legacy Focus/Tabbing system) Same, but only count widgets which you can Tab through.

	// Local parameters stacks
	// We store the current settings outside of the vectors to increase memory locality (reduce cache misses). The vectors are rarely modified. Also it allows us to not heap allocate for short-lived windows which are not using those settings.
	ImGuiItemFlags          ItemFlags;              // == ItemFlagsStack.back() [empty == ImGuiItemFlags_Default]
	float                   ItemWidth;              // == ItemWidthStack.back(). 0.0: default, >0.0: width in pixels, <0.0: align xx pixels to the right of window
	float                   TextWrapPos;            // == TextWrapPosStack.back() [empty == -1.0f]
	ImVector<ImGuiItemFlags>ItemFlagsStack;
	ImVector<float>         ItemWidthStack;
	ImVector<float>         TextWrapPosStack;
	ImVector<ImGuiGroupData>GroupStack;
	short                   StackSizesBackup[ 6 ];    // Store size of various stacks for asserting

	ImGuiWindowTempData()
	{
		CursorPos = CursorPosPrevLine = CursorStartPos = CursorMaxPos = ImVec2( 0.0f, 0.0f );
		CurrLineSize = PrevLineSize = ImVec2( 0.0f, 0.0f );
		CurrLineTextBaseOffset = PrevLineTextBaseOffset = 0.0f;
		Indent = ImVec1( 0.0f );
		ColumnsOffset = ImVec1( 0.0f );
		GroupOffset = ImVec1( 0.0f );

		LastItemId = 0;
		LastItemStatusFlags = ImGuiItemStatusFlags_None;
		LastItemRect = LastItemDisplayRect = ImRect();

		NavLayerActiveMask = NavLayerActiveMaskNext = 0x00;
		NavLayerCurrent = ImGuiNavLayer_Main;
		NavLayerCurrentMask = ( 1 << ImGuiNavLayer_Main );
		NavFocusScopeIdCurrent = 0;
		NavHideHighlightOneFrame = false;
		NavHasScroll = false;

		MenuBarAppending = false;
		MenuBarOffset = ImVec2( 0.0f, 0.0f );
		TreeDepth = 0;
		TreeJumpToParentOnPopMask = 0x00;
		StateStorage = NULL;
		CurrentColumns = NULL;
		LayoutType = ParentLayoutType = ImGuiLayoutType_Vertical;
		FocusCounterRegular = FocusCounterTabStop = -1;

		ItemFlags = ImGuiItemFlags_Default_;
		ItemWidth = 0.0f;
		TextWrapPos = -1.0f;
		memset( StackSizesBackup, 0, sizeof( StackSizesBackup ) );
	}
};

// Storage for one window
struct IMGUI_API ImGuiWindow
{
	char* Name;                               // Window name, owned by the window.
	ImGuiID                 ID;                                 // == ImHashStr(Name)
	ImGuiWindowFlags        Flags;                              // See enum ImGuiWindowFlags_
	ImVec2                  Pos;                                // Position (always rounded-up to nearest pixel)
	ImVec2                  Size;                               // Current size (==SizeFull or collapsed title bar size)
	ImVec2                  SizeFull;                           // Size when non collapsed
	ImVec2                  ContentSize;                        // Size of contents/scrollable client area (calculated from the extents reach of the cursor) from previous frame. Does not include window decoration or window padding.
	ImVec2                  ContentSizeExplicit;                // Size of contents/scrollable client area explicitly request by the user via SetNextWindowContentSize().
	ImVec2                  WindowPadding;                      // Window padding at the time of Begin().
	float                   WindowRounding;                     // Window rounding at the time of Begin().
	float                   WindowBorderSize;                   // Window border size at the time of Begin().
	int                     NameBufLen;                         // Size of buffer storing Name. May be larger than strlen(Name)!
	ImGuiID                 MoveId;                             // == window->GetID("#MOVE")
	ImGuiID                 ChildId;                            // ID of corresponding item in parent window (for navigation to return from child window to parent window)
	ImVec2                  Scroll;
	ImVec2                  ScrollMax;
	ImVec2                  ScrollTarget;                       // target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)
	ImVec2                  ScrollTargetCenterRatio;            // 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered
	ImVec2                  ScrollbarSizes;                     // Size taken by each scrollbars on their smaller axis. Pay attention! ScrollbarSizes.x == width of the vertical scrollbar, ScrollbarSizes.y = height of the horizontal scrollbar.
	bool                    ScrollbarX, ScrollbarY;             // Are scrollbars visible?
	bool                    Active;                             // Set to true on Begin(), unless Collapsed
	bool                    WasActive;
	bool                    WriteAccessed;                      // Set to true when any widget access the current window
	bool                    Collapsed;                          // Set when collapsing window to become only title-bar
	bool                    WantCollapseToggle;
	bool                    SkipItems;                          // Set when items can safely be all clipped (e.g. window not visible or collapsed)
	bool                    Appearing;                          // Set during the frame where the window is appearing (or re-appearing)
	bool                    Hidden;                             // Do not display (== (HiddenFrames*** > 0))
	bool                    IsFallbackWindow;                   // Set on the "Debug##Default" window.
	bool                    HasCloseButton;                     // Set when the window has a close button (p_open != NULL)
	signed char             ResizeBorderHeld;                   // Current border being held for resize (-1: none, otherwise 0-3)
	short                   BeginCount;                         // Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin/End pairs)
	short                   BeginOrderWithinParent;             // Order within immediate parent window, if we are a child window. Otherwise 0.
	short                   BeginOrderWithinContext;            // Order within entire imgui context. This is mostly used for debugging submission order related issues.
	ImGuiID                 PopupId;                            // ID in the popup stack when this window is used as a popup/menu (because we use generic Name/ID for recycling)
	ImS8                    AutoFitFramesX, AutoFitFramesY;
	ImS8                    AutoFitChildAxises;
	bool                    AutoFitOnlyGrows;
	ImGuiDir                AutoPosLastDirection;
	int                     HiddenFramesCanSkipItems;           // Hide the window for N frames
	int                     HiddenFramesCannotSkipItems;        // Hide the window for N frames while allowing items to be submitted so we can measure their size
	ImGuiCond               SetWindowPosAllowFlags;             // store acceptable condition flags for SetNextWindowPos() use.
	ImGuiCond               SetWindowSizeAllowFlags;            // store acceptable condition flags for SetNextWindowSize() use.
	ImGuiCond               SetWindowCollapsedAllowFlags;       // store acceptable condition flags for SetNextWindowCollapsed() use.
	ImVec2                  SetWindowPosVal;                    // store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)
	ImVec2                  SetWindowPosPivot;                  // store window pivot for positioning. ImVec2(0,0) when positioning from top-left corner; ImVec2(0.5f,0.5f) for centering; ImVec2(1,1) for bottom right.

	ImVector<ImGuiID>       IDStack;                            // ID stack. ID are hashes seeded with the value at the top of the stack. (In theory this should be in the TempData structure)
	ImGuiWindowTempData     DC;                                 // Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the "DC" variable name.

	// The best way to understand what those rectangles are is to use the 'Metrics -> Tools -> Show windows rectangles' viewer.
	// The main 'OuterRect', omitted as a field, is window->Rect().
	ImRect                  OuterRectClipped;                   // == Window->Rect() just after setup in Begin(). == window->Rect() for root window.
	ImRect                  InnerRect;                          // Inner rectangle (omit title bar, menu bar, scroll bar)
	ImRect                  InnerClipRect;                      // == InnerRect shrunk by WindowPadding*0.5f on each side, clipped within viewport or parent clip rect.
	ImRect                  WorkRect;                           // Cover the whole scrolling region, shrunk by WindowPadding*1.0f on each side. This is meant to replace ContentRegionRect over time (from 1.71+ onward).
	ImRect                  ClipRect;                           // Current clipping/scissoring rectangle, evolve as we are using PushClipRect(), etc. == DrawList->clip_rect_stack.back().
	ImRect                  ContentRegionRect;                  // FIXME: This is currently confusing/misleading. It is essentially WorkRect but not handling of scrolling. We currently rely on it as right/bottom aligned sizing operation need some size to rely on.

	int                     LastFrameActive;                    // Last frame number the window was Active.
	float                   LastTimeActive;                     // Last timestamp the window was Active (using float as we don't need high precision there)
	float                   ItemWidthDefault;
	ImGuiStorage            StateStorage;
	ImVector<ImGuiColumns>  ColumnsStorage;
	float                   FontWindowScale;                    // User scale multiplier per-window, via SetWindowFontScale()
	int                     SettingsOffset;                     // Offset into SettingsWindows[] (offsets are always valid as we only grow the array from the back)

	ImDrawList* DrawList;                           // == &DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)
	ImDrawList              DrawListInst;
	ImGuiWindow* ParentWindow;                       // If we are a child _or_ popup window, this is pointing to our parent. Otherwise NULL.
	ImGuiWindow* RootWindow;                         // Point to ourself or first ancestor that is not a child window.
	ImGuiWindow* RootWindowForTitleBarHighlight;     // Point to ourself or first ancestor which will display TitleBgActive color when this window is active.
	ImGuiWindow* RootWindowForNav;                   // Point to ourself or first ancestor which doesn't have the NavFlattened flag.

	ImGuiWindow* NavLastChildNavWindow;              // When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)
	ImGuiID                 NavLastIds[ ImGuiNavLayer_COUNT ];    // Last known NavId for this window, per layer (0/1)
	ImRect                  NavRectRel[ ImGuiNavLayer_COUNT ];    // Reference rectangle, in window relative space

	bool                    MemoryCompacted;
	int                     MemoryDrawListIdxCapacity;
	int                     MemoryDrawListVtxCapacity;

public:
	ImGuiWindow( ImGuiContext* context, const char* name );
	~ImGuiWindow();

	ImGuiID     GetID( const char* str, const char* str_end = NULL );
	ImGuiID     GetID( const void* ptr );
	ImGuiID     GetID( int n );
	ImGuiID     GetIDNoKeepAlive( const char* str, const char* str_end = NULL );
	ImGuiID     GetIDNoKeepAlive( const void* ptr );
	ImGuiID     GetIDNoKeepAlive( int n );
	ImGuiID     GetIDFromRectangle( const ImRect& r_abs );

	// We don't use g.FontSize because the window may be != g.CurrentWidow.
	ImRect      Rect() const
	{
		return ImRect( Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y );
	}
	float       CalcFontSize() const
	{
		ImGuiContext& g = *GImGui; float scale = g.FontBaseSize * FontWindowScale; if( ParentWindow ) scale *= ParentWindow->FontWindowScale; return scale;
	}
	float       TitleBarHeight() const
	{
		ImGuiContext& g = *GImGui; return ( Flags & ImGuiWindowFlags_NoTitleBar ) ? 0.0f : CalcFontSize() + g.Style.FramePadding.y * 2.0f;
	}
	ImRect      TitleBarRect() const
	{
		return ImRect( Pos, ImVec2( Pos.x + SizeFull.x, Pos.y + TitleBarHeight() ) );
	}
	float       MenuBarHeight() const
	{
		ImGuiContext& g = *GImGui; return ( Flags & ImGuiWindowFlags_MenuBar ) ? DC.MenuBarOffset.y + CalcFontSize() + g.Style.FramePadding.y * 2.0f : 0.0f;
	}
	ImRect      MenuBarRect() const
	{
		float y1 = Pos.y + TitleBarHeight(); return ImRect( Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight() );
	}
};

// Backup and restore just enough data to be able to use IsItemHovered() on item A after another B in the same window has overwritten the data.
struct ImGuiItemHoveredDataBackup
{
	ImGuiID                 LastItemId;
	ImGuiItemStatusFlags    LastItemStatusFlags;
	ImRect                  LastItemRect;
	ImRect                  LastItemDisplayRect;

	ImGuiItemHoveredDataBackup()
	{
		Backup();
	}
	void Backup()
	{
		ImGuiWindow* window = GImGui->CurrentWindow; LastItemId = window->DC.LastItemId; LastItemStatusFlags = window->DC.LastItemStatusFlags; LastItemRect = window->DC.LastItemRect; LastItemDisplayRect = window->DC.LastItemDisplayRect;
	}
	void Restore() const
	{
		ImGuiWindow* window = GImGui->CurrentWindow; window->DC.LastItemId = LastItemId; window->DC.LastItemStatusFlags = LastItemStatusFlags; window->DC.LastItemRect = LastItemRect; window->DC.LastItemDisplayRect = LastItemDisplayRect;
	}
};

//-----------------------------------------------------------------------------
// Tab bar, tab item
//-----------------------------------------------------------------------------

// Extend ImGuiTabBarFlags_
enum ImGuiTabBarFlagsPrivate_
{
	ImGuiTabBarFlags_DockNode = 1 << 20,  // Part of a dock node [we don't use this in the master branch but it facilitate branch syncing to keep this around]
	ImGuiTabBarFlags_IsFocused = 1 << 21,
	ImGuiTabBarFlags_SaveSettings = 1 << 22   // FIXME: Settings are handled by the docking system, this only request the tab bar to mark settings dirty when reordering tabs
};

// Extend ImGuiTabItemFlags_
enum ImGuiTabItemFlagsPrivate_
{
	ImGuiTabItemFlags_NoCloseButton = 1 << 20   // Track whether p_open was set or not (we'll need this info on the next frame to recompute ContentWidth during layout)
};

// Storage for one active tab item (sizeof() 26~32 bytes)
struct ImGuiTabItem
{
	ImGuiID             ID;
	ImGuiTabItemFlags   Flags;
	int                 LastFrameVisible;
	int                 LastFrameSelected;      // This allows us to infer an ordered list of the last activated tabs with little maintenance
	int                 NameOffset;             // When Window==NULL, offset to name within parent ImGuiTabBar::TabsNames
	float               Offset;                 // Position relative to beginning of tab
	float               Width;                  // Width currently displayed
	float               ContentWidth;           // Width of actual contents, stored during BeginTabItem() call

	ImGuiTabItem()
	{
		ID = 0; Flags = ImGuiTabItemFlags_None; LastFrameVisible = LastFrameSelected = -1; NameOffset = -1; Offset = Width = ContentWidth = 0.0f;
	}
};

// Storage for a tab bar (sizeof() 92~96 bytes)
struct ImGuiTabBar
{
	ImVector<ImGuiTabItem> Tabs;
	ImGuiID             ID;                     // Zero for tab-bars used by docking
	ImGuiID             SelectedTabId;          // Selected tab/window
	ImGuiID             NextSelectedTabId;
	ImGuiID             VisibleTabId;           // Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)
	int                 CurrFrameVisible;
	int                 PrevFrameVisible;
	ImRect              BarRect;
	float               LastTabContentHeight;   // Record the height of contents submitted below the tab bar
	float               OffsetMax;              // Distance from BarRect.Min.x, locked during layout
	float               OffsetMaxIdeal;         // Ideal offset if all tabs were visible and not clipped
	float               OffsetNextTab;          // Distance from BarRect.Min.x, incremented with each BeginTabItem() call, not used if ImGuiTabBarFlags_Reorderable if set.
	float               ScrollingAnim;
	float               ScrollingTarget;
	float               ScrollingTargetDistToVisibility;
	float               ScrollingSpeed;
	ImGuiTabBarFlags    Flags;
	ImGuiID             ReorderRequestTabId;
	ImS8                ReorderRequestDir;
	bool                WantLayout;
	bool                VisibleTabWasSubmitted;
	short               LastTabItemIdx;         // For BeginTabItem()/EndTabItem()
	ImVec2              FramePadding;           // style.FramePadding locked at the time of BeginTabBar()
	ImGuiTextBuffer     TabsNames;              // For non-docking tab bar we re-append names in a contiguous buffer.

	ImGuiTabBar();
	int                 GetTabOrder( const ImGuiTabItem* tab ) const
	{
		return Tabs.index_from_ptr( tab );
	}
	const char* GetTabName( const ImGuiTabItem* tab ) const
	{
		IM_ASSERT( tab->NameOffset != -1 && tab->NameOffset < TabsNames.Buf.Size );
		return TabsNames.Buf.Data + tab->NameOffset;
	}
};

//-----------------------------------------------------------------------------
// Internal API
// No guarantee of forward compatibility here.
//-----------------------------------------------------------------------------

namespace ImGui
{
// Windows
// We should always have a CurrentWindow in the stack (there is an implicit "Debug" window)
// If this ever crash because g.CurrentWindow is NULL it means that either
// - ImGui::NewFrame() has never been called, which is illegal.
// - You are calling ImGui functions after ImGui::EndFrame()/ImGui::Render() and before the next ImGui::NewFrame(), which is also illegal.
inline    ImGuiWindow* GetCurrentWindowRead()
{
	ImGuiContext& g = *GImGui; return g.CurrentWindow;
}
inline    ImGuiWindow* GetCurrentWindow()
{
	ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow;
}
IMGUI_API ImGuiWindow* FindWindowByID( ImGuiID id );
IMGUI_API ImGuiWindow* FindWindowByName( const char* name );
IMGUI_API void          UpdateWindowParentAndRootLinks( ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window );
IMGUI_API ImVec2        CalcWindowExpectedSize( ImGuiWindow* window );
IMGUI_API bool          IsWindowChildOf( ImGuiWindow* window, ImGuiWindow* potential_parent );
IMGUI_API bool          IsWindowNavFocusable( ImGuiWindow* window );
IMGUI_API ImRect        GetWindowAllowedExtentRect( ImGuiWindow* window );
IMGUI_API void          SetWindowPos( ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond = 0 );
IMGUI_API void          SetWindowSize( ImGuiWindow* window, const ImVec2& size, ImGuiCond cond = 0 );
IMGUI_API void          SetWindowCollapsed( ImGuiWindow* window, bool collapsed, ImGuiCond cond = 0 );

// Windows: Display Order and Focus Order
IMGUI_API void          FocusWindow( ImGuiWindow* window );
IMGUI_API void          FocusTopMostWindowUnderOne( ImGuiWindow* under_this_window, ImGuiWindow* ignore_window );
IMGUI_API void          BringWindowToFocusFront( ImGuiWindow* window );
IMGUI_API void          BringWindowToDisplayFront( ImGuiWindow* window );
IMGUI_API void          BringWindowToDisplayBack( ImGuiWindow* window );

// Fonts, drawing
IMGUI_API void          SetCurrentFont( ImFont* font );
inline ImFont* GetDefaultFont()
{
	ImGuiContext& g = *GImGui; return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[ 0 ];
}
inline ImDrawList* GetForegroundDrawList( ImGuiWindow* window )
{
	IM_UNUSED( window ); ImGuiContext& g = *GImGui; return &g.ForegroundDrawList;
} // This seemingly unnecessary wrapper simplifies compatibility between the 'master' and 'docking' branches.

// Init
IMGUI_API void          Initialize( ImGuiContext* context );
IMGUI_API void          Shutdown( ImGuiContext* context );    // Since 1.60 this is a _private_ function. You can call DestroyContext() to destroy the context created by CreateContext().

// NewFrame
IMGUI_API void          UpdateHoveredWindowAndCaptureFlags();
IMGUI_API void          StartMouseMovingWindow( ImGuiWindow* window );
IMGUI_API void          UpdateMouseMovingWindowNewFrame();
IMGUI_API void          UpdateMouseMovingWindowEndFrame();

// Settings
IMGUI_API void                  MarkIniSettingsDirty();
IMGUI_API void                  MarkIniSettingsDirty( ImGuiWindow* window );
IMGUI_API ImGuiWindowSettings* CreateNewWindowSettings( const char* name );
IMGUI_API ImGuiWindowSettings* FindWindowSettings( ImGuiID id );
IMGUI_API ImGuiWindowSettings* FindOrCreateWindowSettings( const char* name );
IMGUI_API ImGuiSettingsHandler* FindSettingsHandler( const char* type_name );

// Scrolling
IMGUI_API void          SetNextWindowScroll( const ImVec2& scroll ); // Use -1.0f on one axis to leave as-is
IMGUI_API void          SetScrollX( ImGuiWindow* window, float new_scroll_x );
IMGUI_API void          SetScrollY( ImGuiWindow* window, float new_scroll_y );
IMGUI_API void          SetScrollFromPosX( ImGuiWindow* window, float local_x, float center_x_ratio = 0.5f );
IMGUI_API void          SetScrollFromPosY( ImGuiWindow* window, float local_y, float center_y_ratio = 0.5f );
IMGUI_API ImVec2        ScrollToBringRectIntoView( ImGuiWindow* window, const ImRect& item_rect );

// Basic Accessors
inline ImGuiID          GetItemID()
{
	ImGuiContext& g = *GImGui; return g.CurrentWindow->DC.LastItemId;
}
inline ImGuiItemStatusFlags GetItemStatusFlags()
{
	ImGuiContext& g = *GImGui; return g.CurrentWindow->DC.LastItemStatusFlags;
}
inline ImGuiID          GetActiveID()
{
	ImGuiContext& g = *GImGui; return g.ActiveId;
}
inline ImGuiID          GetFocusID()
{
	ImGuiContext& g = *GImGui; return g.NavId;
}
IMGUI_API void          SetActiveID( ImGuiID id, ImGuiWindow* window );
IMGUI_API void          SetFocusID( ImGuiID id, ImGuiWindow* window );
IMGUI_API void          ClearActiveID();
IMGUI_API ImGuiID       GetHoveredID();
IMGUI_API void          SetHoveredID( ImGuiID id );
IMGUI_API void          KeepAliveID( ImGuiID id );
IMGUI_API void          MarkItemEdited( ImGuiID id );     // Mark data associated to given item as "edited", used by IsItemDeactivatedAfterEdit() function.
IMGUI_API void          PushOverrideID( ImGuiID id );     // Push given value at the top of the ID stack (whereas PushID combines old and new hashes)

// Basic Helpers for widget code
IMGUI_API void          ItemSize( const ImVec2& size, float text_baseline_y = -1.0f );
IMGUI_API void          ItemSize( const ImRect& bb, float text_baseline_y = -1.0f );
IMGUI_API bool          ItemAdd( const ImRect& bb, ImGuiID id, const ImRect* nav_bb = NULL );
IMGUI_API bool          ItemHoverable( const ImRect& bb, ImGuiID id );
IMGUI_API bool          IsClippedEx( const ImRect& bb, ImGuiID id, bool clip_even_when_logged );
IMGUI_API bool          FocusableItemRegister( ImGuiWindow* window, ImGuiID id );   // Return true if focus is requested
IMGUI_API void          FocusableItemUnregister( ImGuiWindow* window );
IMGUI_API ImVec2        CalcItemSize( ImVec2 size, float default_w, float default_h );
IMGUI_API float         CalcWrapWidthForPos( const ImVec2& pos, float wrap_pos_x );
IMGUI_API void          PushMultiItemsWidths( int components, float width_full );
IMGUI_API void          PushItemFlag( ImGuiItemFlags option, bool enabled );
IMGUI_API void          PopItemFlag();
IMGUI_API bool          IsItemToggledSelection();                           // Was the last item selection toggled? (after Selectable(), TreeNode() etc. We only returns toggle _event_ in order to handle clipping correctly)
IMGUI_API ImVec2        GetContentRegionMaxAbs();
IMGUI_API void          ShrinkWidths( ImGuiShrinkWidthItem* items, int count, float width_excess );

// Logging/Capture
IMGUI_API void          LogBegin( ImGuiLogType type, int auto_open_depth );   // -> BeginCapture() when we design v2 api, for now stay under the radar by using the old name.
IMGUI_API void          LogToBuffer( int auto_open_depth = -1 );              // Start logging/capturing to internal buffer

// Popups, Modals, Tooltips
IMGUI_API bool          BeginChildEx( const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags );
IMGUI_API void          OpenPopupEx( ImGuiID id );
IMGUI_API void          ClosePopupToLevel( int remaining, bool restore_focus_to_window_under_popup );
IMGUI_API void          ClosePopupsOverWindow( ImGuiWindow* ref_window, bool restore_focus_to_window_under_popup );
IMGUI_API bool          IsPopupOpen( ImGuiID id ); // Test for id within current popup stack level (currently begin-ed into); this doesn't scan the whole popup stack!
IMGUI_API bool          BeginPopupEx( ImGuiID id, ImGuiWindowFlags extra_flags );
IMGUI_API void          BeginTooltipEx( ImGuiWindowFlags extra_flags, ImGuiTooltipFlags tooltip_flags );
IMGUI_API ImGuiWindow* GetTopMostPopupModal();
IMGUI_API ImVec2        FindBestWindowPosForPopup( ImGuiWindow* window );
IMGUI_API ImVec2        FindBestWindowPosForPopupEx( const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy = ImGuiPopupPositionPolicy_Default );

// Navigation
IMGUI_API void          NavInitWindow( ImGuiWindow* window, bool force_reinit );
IMGUI_API bool          NavMoveRequestButNoResultYet();
IMGUI_API void          NavMoveRequestCancel();
IMGUI_API void          NavMoveRequestForward( ImGuiDir move_dir, ImGuiDir clip_dir, const ImRect& bb_rel, ImGuiNavMoveFlags move_flags );
IMGUI_API void          NavMoveRequestTryWrapping( ImGuiWindow* window, ImGuiNavMoveFlags move_flags );
IMGUI_API float         GetNavInputAmount( ImGuiNavInput n, ImGuiInputReadMode mode );
IMGUI_API ImVec2        GetNavInputAmount2d( ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor = 0.0f, float fast_factor = 0.0f );
IMGUI_API int           CalcTypematicRepeatAmount( float t0, float t1, float repeat_delay, float repeat_rate );
IMGUI_API void          ActivateItem( ImGuiID id );   // Remotely activate a button, checkbox, tree node etc. given its unique ID. activation is queued and processed on the next frame when the item is encountered again.
IMGUI_API void          SetNavID( ImGuiID id, int nav_layer, ImGuiID focus_scope_id );
IMGUI_API void          SetNavIDWithRectRel( ImGuiID id, int nav_layer, ImGuiID focus_scope_id, const ImRect& rect_rel );

// Focus scope (WIP)
IMGUI_API void          PushFocusScope( ImGuiID id );     // Note: this is storing in same stack as IDStack, so Push/Pop mismatch will be reported there.
IMGUI_API void          PopFocusScope();
inline ImGuiID          GetFocusScopeID()
{
	ImGuiContext& g = *GImGui; return g.NavFocusScopeId;
}

// Inputs
// FIXME: Eventually we should aim to move e.g. IsActiveIdUsingKey() into IsKeyXXX functions.
inline bool             IsActiveIdUsingNavDir( ImGuiDir dir )
{
	ImGuiContext& g = *GImGui; return ( g.ActiveIdUsingNavDirMask & ( 1 << dir ) ) != 0;
}
inline bool             IsActiveIdUsingNavInput( ImGuiNavInput input )
{
	ImGuiContext& g = *GImGui; return ( g.ActiveIdUsingNavInputMask & ( 1 << input ) ) != 0;
}
inline bool             IsActiveIdUsingKey( ImGuiKey key )
{
	ImGuiContext& g = *GImGui; IM_ASSERT( key < 64 ); return ( g.ActiveIdUsingKeyInputMask & ( ( ImU64 )1 << key ) ) != 0;
}
IMGUI_API bool          IsMouseDragPastThreshold( ImGuiMouseButton button, float lock_threshold = -1.0f );
inline bool             IsKeyPressedMap( ImGuiKey key, bool repeat = true )
{
	ImGuiContext& g = *GImGui; const int key_index = g.IO.KeyMap[ key ]; return ( key_index >= 0 ) ? IsKeyPressed( key_index, repeat ) : false;
}
inline bool             IsNavInputDown( ImGuiNavInput n )
{
	ImGuiContext& g = *GImGui; return g.IO.NavInputs[ n ] > 0.0f;
}
inline bool             IsNavInputTest( ImGuiNavInput n, ImGuiInputReadMode rm )
{
	return ( GetNavInputAmount( n, rm ) > 0.0f );
}
IMGUI_API ImGuiKeyModFlags GetMergedKeyModFlags();

// Drag and Drop
IMGUI_API bool          BeginDragDropTargetCustom( const ImRect& bb, ImGuiID id );
IMGUI_API void          ClearDragDrop();
IMGUI_API bool          IsDragDropPayloadBeingAccepted();

// Internal Columns API (this is not exposed because we will encourage transitioning to the Tables api)
IMGUI_API void          BeginColumns( const char* str_id, int count, ImGuiColumnsFlags flags = 0 ); // setup number of columns. use an identifier to distinguish multiple column sets. close with EndColumns().
IMGUI_API void          EndColumns();                                                             // close columns
IMGUI_API void          PushColumnClipRect( int column_index );
IMGUI_API void          PushColumnsBackground();
IMGUI_API void          PopColumnsBackground();
IMGUI_API ImGuiID       GetColumnsID( const char* str_id, int count );
IMGUI_API ImGuiColumns* FindOrCreateColumns( ImGuiWindow* window, ImGuiID id );
IMGUI_API float         GetColumnOffsetFromNorm( const ImGuiColumns* columns, float offset_norm );
IMGUI_API float         GetColumnNormFromOffset( const ImGuiColumns* columns, float offset );

// Tab Bars
IMGUI_API bool          BeginTabBarEx( ImGuiTabBar* tab_bar, const ImRect& bb, ImGuiTabBarFlags flags );
IMGUI_API ImGuiTabItem* TabBarFindTabByID( ImGuiTabBar* tab_bar, ImGuiID tab_id );
IMGUI_API void          TabBarRemoveTab( ImGuiTabBar* tab_bar, ImGuiID tab_id );
IMGUI_API void          TabBarCloseTab( ImGuiTabBar* tab_bar, ImGuiTabItem* tab );
IMGUI_API void          TabBarQueueChangeTabOrder( ImGuiTabBar* tab_bar, const ImGuiTabItem* tab, int dir );
IMGUI_API bool          TabItemEx( ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags );
IMGUI_API ImVec2        TabItemCalcSize( const char* label, bool has_close_button );
IMGUI_API void          TabItemBackground( ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImU32 col );
IMGUI_API bool          TabItemLabelAndCloseButton( ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char* label, ImGuiID tab_id, ImGuiID close_button_id );

// Render helpers
// AVOID USING OUTSIDE OF IMGUI.CPP! NOT FOR PUBLIC CONSUMPTION. THOSE FUNCTIONS ARE A MESS. THEIR SIGNATURE AND BEHAVIOR WILL CHANGE, THEY NEED TO BE REFACTORED INTO SOMETHING DECENT.
// NB: All position are in absolute pixels coordinates (we are never using window coordinates internally)
IMGUI_API void          RenderText( ImVec2 pos, const char* text, const char* text_end = NULL, bool hide_text_after_hash = true );
IMGUI_API void          RenderTextWrapped( ImVec2 pos, const char* text, const char* text_end, float wrap_width );
IMGUI_API void          RenderTextClipped( const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2( 0, 0 ), const ImRect* clip_rect = NULL );
IMGUI_API void          RenderTextClippedEx( ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2( 0, 0 ), const ImRect* clip_rect = NULL );
IMGUI_API void          RenderTextEllipsis( ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, float clip_max_x, float ellipsis_max_x, const char* text, const char* text_end, const ImVec2* text_size_if_known );
IMGUI_API void          RenderFrame( ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border = true, float rounding = 0.0f );
IMGUI_API void          RenderFrameBorder( ImVec2 p_min, ImVec2 p_max, float rounding = 0.0f );
IMGUI_API void          RenderColorRectWithAlphaCheckerboard( ImDrawList* draw_list, ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, float grid_step, ImVec2 grid_off, float rounding = 0.0f, int rounding_corners_flags = ~0 );
IMGUI_API void          RenderNavHighlight( const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags = ImGuiNavHighlightFlags_TypeDefault ); // Navigation highlight
IMGUI_API const char* FindRenderedTextEnd( const char* text, const char* text_end = NULL ); // Find the optional ## from which we stop displaying text.
IMGUI_API void          LogRenderedText( const ImVec2* ref_pos, const char* text, const char* text_end = NULL );

// Render helpers (those functions don't access any ImGui state!)
IMGUI_API void          RenderArrow( ImDrawList* draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir, float scale = 1.0f );
IMGUI_API void          RenderBullet( ImDrawList* draw_list, ImVec2 pos, ImU32 col );
IMGUI_API void          RenderCheckMark( ImDrawList* draw_list, ImVec2 pos, ImU32 col, float sz );
IMGUI_API void          RenderMouseCursor( ImDrawList* draw_list, ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor, ImU32 col_fill, ImU32 col_border, ImU32 col_shadow );
IMGUI_API void          RenderArrowPointingAt( ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col );
IMGUI_API void          RenderRectFilledRangeH( ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding );

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
// [1.71: 2019/06/07: Updating prototypes of some of the internal functions. Leaving those for reference for a short while]
inline void RenderArrow( ImVec2 pos, ImGuiDir dir, float scale = 1.0f )
{
	ImGuiWindow* window = GetCurrentWindow(); RenderArrow( window->DrawList, pos, GetColorU32( ImGuiCol_Text ), dir, scale );
}
inline void RenderBullet( ImVec2 pos )
{
	ImGuiWindow* window = GetCurrentWindow(); RenderBullet( window->DrawList, pos, GetColorU32( ImGuiCol_Text ) );
}
#endif

// Widgets
IMGUI_API void          TextEx( const char* text, const char* text_end = NULL, ImGuiTextFlags flags = 0 );
IMGUI_API bool          ButtonEx( const char* label, const ImVec2& size_arg = ImVec2( 0, 0 ), ImGuiButtonFlags flags = 0 );
IMGUI_API bool          CloseButton( ImGuiID id, const ImVec2& pos );
IMGUI_API bool          CollapseButton( ImGuiID id, const ImVec2& pos );
IMGUI_API bool          ArrowButtonEx( const char* str_id, ImGuiDir dir, ImVec2 size_arg, ImGuiButtonFlags flags = 0 );
IMGUI_API void          Scrollbar( ImGuiAxis axis );
IMGUI_API bool          ScrollbarEx( const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* p_scroll_v, float avail_v, float contents_v, ImDrawCornerFlags rounding_corners );
IMGUI_API ImRect        GetWindowScrollbarRect( ImGuiWindow* window, ImGuiAxis axis );
IMGUI_API ImGuiID       GetWindowScrollbarID( ImGuiWindow* window, ImGuiAxis axis );
IMGUI_API ImGuiID       GetWindowResizeID( ImGuiWindow* window, int n ); // 0..3: corners, 4..7: borders
IMGUI_API void          SeparatorEx( ImGuiSeparatorFlags flags );

// Widgets low-level behaviors
IMGUI_API bool          ButtonBehavior( const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags = 0 );
IMGUI_API bool          DragBehavior( ImGuiID id, ImGuiDataType data_type, void* p_v, float v_speed, const void* p_min, const void* p_max, const char* format, float power, ImGuiDragFlags flags );
IMGUI_API bool          SliderBehavior( const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* p_v, const void* p_min, const void* p_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb );
IMGUI_API bool          SplitterBehavior( const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend = 0.0f, float hover_visibility_delay = 0.0f );
IMGUI_API bool          TreeNodeBehavior( ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end = NULL );
IMGUI_API bool          TreeNodeBehaviorIsOpen( ImGuiID id, ImGuiTreeNodeFlags flags = 0 );                     // Consume previous SetNextItemOpen() data, if any. May return true when logging
IMGUI_API void          TreePushOverrideID( ImGuiID id );

// Template functions are instantiated in imgui_widgets.cpp for a finite number of types.
// To use them externally (for custom widget) you may need an "extern template" statement in your code in order to link to existing instances and silence Clang warnings (see #2036).
// e.g. " extern template IMGUI_API float RoundScalarWithFormatT<float, float>(const char* format, ImGuiDataType data_type, float v); "
template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API bool  DragBehaviorT( ImGuiDataType data_type, T* v, float v_speed, T v_min, T v_max, const char* format, float power, ImGuiDragFlags flags );
template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API bool  SliderBehaviorT( const ImRect& bb, ImGuiID id, ImGuiDataType data_type, T* v, T v_min, T v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb );
template<typename T, typename FLOAT_T>                      IMGUI_API float SliderCalcRatioFromValueT( ImGuiDataType data_type, T v, T v_min, T v_max, float power, float linear_zero_pos );
template<typename T, typename SIGNED_T>                     IMGUI_API T     RoundScalarWithFormatT( const char* format, ImGuiDataType data_type, T v );

// Data type helpers
IMGUI_API const ImGuiDataTypeInfo* DataTypeGetInfo( ImGuiDataType data_type );
IMGUI_API int           DataTypeFormatString( char* buf, int buf_size, ImGuiDataType data_type, const void* p_data, const char* format );
IMGUI_API void          DataTypeApplyOp( ImGuiDataType data_type, int op, void* output, void* arg_1, const void* arg_2 );
IMGUI_API bool          DataTypeApplyOpFromText( const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* p_data, const char* format );

// InputText
IMGUI_API bool          InputTextEx( const char* label, const char* hint, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback = NULL, void* user_data = NULL );
IMGUI_API bool          TempInputText( const ImRect& bb, ImGuiID id, const char* label, char* buf, int buf_size, ImGuiInputTextFlags flags );
IMGUI_API bool          TempInputScalar( const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* p_data, const char* format );
inline bool             TempInputIsActive( ImGuiID id )
{
	ImGuiContext& g = *GImGui; return ( g.ActiveId == id && g.TempInputId == id );
}
inline ImGuiInputTextState* GetInputTextState( ImGuiID id )
{
	ImGuiContext& g = *GImGui; return ( g.InputTextState.ID == id ) ? &g.InputTextState : NULL;
} // Get input text state if active

// Color
IMGUI_API void          ColorTooltip( const char* text, const float* col, ImGuiColorEditFlags flags );
IMGUI_API void          ColorEditOptionsPopup( const float* col, ImGuiColorEditFlags flags );
IMGUI_API void          ColorPickerOptionsPopup( const float* ref_col, ImGuiColorEditFlags flags );

// Plot
IMGUI_API int           PlotEx( ImGuiPlotType plot_type, const char* label, float ( *values_getter )( void* data, int idx ), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 frame_size );

// Shade functions (write over already created vertices)
IMGUI_API void          ShadeVertsLinearColorGradientKeepAlpha( ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1 );
IMGUI_API void          ShadeVertsLinearUV( ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp );

// Garbage collection
IMGUI_API void          GcCompactTransientWindowBuffers( ImGuiWindow* window );
IMGUI_API void          GcAwakeTransientWindowBuffers( ImGuiWindow* window );

// Debug Tools
inline void             DebugDrawItemRect( ImU32 col = IM_COL32( 255, 0, 0, 255 ) )
{
	ImGuiContext& g = *GImGui; ImGuiWindow* window = g.CurrentWindow; GetForegroundDrawList( window )->AddRect( window->DC.LastItemRect.Min, window->DC.LastItemRect.Max, col );
}
inline void             DebugStartItemPicker()
{
	ImGuiContext& g = *GImGui; g.DebugItemPickerActive = true;
}

} // namespace ImGui

// ImFontAtlas internals
IMGUI_API bool              ImFontAtlasBuildWithStbTruetype( ImFontAtlas* atlas );
IMGUI_API void              ImFontAtlasBuildInit( ImFontAtlas* atlas );
IMGUI_API void              ImFontAtlasBuildSetupFont( ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent );
IMGUI_API void              ImFontAtlasBuildPackCustomRects( ImFontAtlas* atlas, void* stbrp_context_opaque );
IMGUI_API void              ImFontAtlasBuildFinish( ImFontAtlas* atlas );
IMGUI_API void              ImFontAtlasBuildMultiplyCalcLookupTable( unsigned char out_table[ 256 ], float in_multiply_factor );
IMGUI_API void              ImFontAtlasBuildMultiplyRectAlpha8( const unsigned char table[ 256 ], unsigned char* pixels, int x, int y, int w, int h, int stride );

// Debug Tools
// Use 'Metrics->Tools->Item Picker' to break into the call-stack of a specific item.
#ifndef IM_DEBUG_BREAK
#if defined(__clang__)
#define IM_DEBUG_BREAK()    __builtin_debugtrap()
#elif defined (_MSC_VER)
#define IM_DEBUG_BREAK()    __debugbreak()
#else
#define IM_DEBUG_BREAK()    IM_ASSERT(0)    // It is expected that you define IM_DEBUG_BREAK() into something that will break nicely in a debugger!
#endif
#endif // #ifndef IM_DEBUG_BREAK

// Test Engine Hooks (imgui_tests)
//#define IMGUI_ENABLE_TEST_ENGINE
#ifdef IMGUI_ENABLE_TEST_ENGINE
extern void                 ImGuiTestEngineHook_PreNewFrame( ImGuiContext* ctx );
extern void                 ImGuiTestEngineHook_PostNewFrame( ImGuiContext* ctx );
extern void                 ImGuiTestEngineHook_ItemAdd( ImGuiContext* ctx, const ImRect& bb, ImGuiID id );
extern void                 ImGuiTestEngineHook_ItemInfo( ImGuiContext* ctx, ImGuiID id, const char* label, ImGuiItemStatusFlags flags );
extern void                 ImGuiTestEngineHook_IdInfo( ImGuiContext* ctx, ImGuiDataType data_type, ImGuiID id, const void* data_id );
extern void                 ImGuiTestEngineHook_IdInfo( ImGuiContext* ctx, ImGuiDataType data_type, ImGuiID id, const void* data_id, const void* data_id_end );
extern void                 ImGuiTestEngineHook_Log( ImGuiContext* ctx, const char* fmt, ... );
#define IMGUI_TEST_ENGINE_ITEM_ADD(_BB,_ID)                 if (g.TestEngineHookItems) ImGuiTestEngineHook_ItemAdd(&g, _BB, _ID)               // Register item bounding box
#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID,_LABEL,_FLAGS)      if (g.TestEngineHookItems) ImGuiTestEngineHook_ItemInfo(&g, _ID, _LABEL, _FLAGS)   // Register item label and status flags (optional)
#define IMGUI_TEST_ENGINE_LOG(_FMT,...)                     if (g.TestEngineHookItems) ImGuiTestEngineHook_Log(&g, _FMT, __VA_ARGS__)          // Custom log entry from user land into test log
#define IMGUI_TEST_ENGINE_ID_INFO(_ID,_TYPE,_DATA)          if (g.TestEngineHookIdInfo == id) ImGuiTestEngineHook_IdInfo(&g, _TYPE, _ID, (const void*)(_DATA));
#define IMGUI_TEST_ENGINE_ID_INFO2(_ID,_TYPE,_DATA,_DATA2)  if (g.TestEngineHookIdInfo == id) ImGuiTestEngineHook_IdInfo(&g, _TYPE, _ID, (const void*)(_DATA), (const void*)(_DATA2));
#else
#define IMGUI_TEST_ENGINE_ITEM_ADD(_BB,_ID)                 do { } while (0)
#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID,_LABEL,_FLAGS)      do { } while (0)
#define IMGUI_TEST_ENGINE_LOG(_FMT,...)                     do { } while (0)
#define IMGUI_TEST_ENGINE_ID_INFO(_ID,_TYPE,_DATA)          do { } while (0)
#define IMGUI_TEST_ENGINE_ID_INFO2(_ID,_TYPE,_DATA,_DATA2)  do { } while (0)
#endif

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

#ifdef _MSC_VER
#pragma warning (pop)
#endif

#endif // #ifndef IMGUI_DISABLE
```

`horizon/imgui/imgui_shader_dx11.cpp`:

```cpp
#include "imgui_shader_dx11.hpp"

const std::size_t g_vs_size = 888;
const std::size_t g_ps_size = 672;

const std::uint8_t g_vs_code[] =
{
	0xAF, 0xB3, 0xA9, 0xA8, 0x4E, 0x8E, 0x87, 0x51,
	0xD3, 0x91, 0xCC, 0xBA, 0x45, 0x97, 0x0B, 0xF3,
	0x06, 0x35, 0x2B, 0x0F, 0xEA, 0xEB, 0xEB, 0xEB,
	0x93, 0xE8, 0xEB, 0xEB, 0xEE, 0xEB, 0xEB, 0xEB,
	0xDF, 0xEB, 0xEB, 0xEB, 0xFB, 0xEA, 0xEB, 0xEB,
	0x6B, 0xEA, 0xEB, 0xEB, 0x1F, 0xEA, 0xEB, 0xEB,
	0x17, 0xE9, 0xEB, 0xEB, 0xB9, 0xAF, 0xAE, 0xAD,
	0x3F, 0xEB, 0xEB, 0xEB, 0xEA, 0xEB, 0xEB, 0xEB,
	0xA7, 0xEB, 0xEB, 0xEB, 0xEA, 0xEB, 0xEB, 0xEB,
	0xF7, 0xEB, 0xEB, 0xEB, 0xEB, 0xEF, 0x15, 0x14,
	0xEB, 0xEA, 0xEB, 0xEB, 0x4B, 0xEB, 0xEB, 0xEB,
	0xD7, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEA, 0xEB, 0xEB, 0xEB, 0xEA, 0xEB, 0xEB, 0xEB,
	0x9D, 0x8E, 0x99, 0x9F, 0x8E, 0x93, 0xA9, 0x9E,
	0x8D, 0x8D, 0x8E, 0x99, 0xEB, 0x40, 0x40, 0x40,
	0xD7, 0xEB, 0xEB, 0xEB, 0xEA, 0xEB, 0xEB, 0xEB,
	0x8F, 0xEB, 0xEB, 0xEB, 0xAB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0x97, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xAB, 0xEB, 0xEB, 0xEB, 0xE9, 0xEB, 0xEB, 0xEB,
	0x7B, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xBB, 0x99, 0x84, 0x81, 0x8E, 0x88, 0x9F, 0x82,
	0x84, 0x85, 0xA6, 0x8A, 0x9F, 0x99, 0x82, 0x93,
	0xEB, 0x40, 0x40, 0x40, 0xE8, 0xEB, 0xE8, 0xEB,
	0xEF, 0xEB, 0xEF, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xA6, 0x82, 0x88, 0x99,
	0x84, 0x98, 0x84, 0x8D, 0x9F, 0xCB, 0xC3, 0xB9,
	0xC2, 0xCB, 0xA3, 0xA7, 0xB8, 0xA7, 0xCB, 0xB8,
	0x83, 0x8A, 0x8F, 0x8E, 0x99, 0xCB, 0xA8, 0x84,
	0x86, 0x9B, 0x82, 0x87, 0x8E, 0x99, 0xCB, 0xDA,
	0xDB, 0xC5, 0xDB, 0xC5, 0xDA, 0xDB, 0xDB, 0xDA,
	0xDA, 0xC5, 0xDA, 0xDD, 0xD8, 0xD3, 0xDF, 0xEB,
	0xA2, 0xB8, 0xAC, 0xA5, 0x83, 0xEB, 0xEB, 0xEB,
	0xE8, 0xEB, 0xEB, 0xEB, 0xE3, 0xEB, 0xEB, 0xEB,
	0xBB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xE8, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xE8, 0xE8, 0xEB, 0xEB,
	0xB2, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xE8, 0xEB, 0xEB, 0xEB,
	0xEA, 0xEB, 0xEB, 0xEB, 0xE4, 0xE4, 0xEB, 0xEB,
	0xB4, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xE8, 0xEB, 0xEB, 0xEB,
	0xE9, 0xEB, 0xEB, 0xEB, 0xE8, 0xE8, 0xEB, 0xEB,
	0xBB, 0xA4, 0xB8, 0xA2, 0xBF, 0xA2, 0xA4, 0xA5,
	0xEB, 0xA8, 0xA4, 0xA7, 0xA4, 0xB9, 0xEB, 0xBF,
	0xAE, 0xB3, 0xA8, 0xA4, 0xA4, 0xB9, 0xAF, 0xEB,
	0xA4, 0xB8, 0xAC, 0xA5, 0x87, 0xEB, 0xEB, 0xEB,
	0xE8, 0xEB, 0xEB, 0xEB, 0xE3, 0xEB, 0xEB, 0xEB,
	0xBB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEA, 0xEB, 0xEB, 0xEB, 0xE8, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xE4, 0xEB, 0xEB, 0xEB,
	0xB7, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xE8, 0xEB, 0xEB, 0xEB,
	0xEA, 0xEB, 0xEB, 0xEB, 0xE4, 0xEB, 0xEB, 0xEB,
	0x89, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xE8, 0xEB, 0xEB, 0xEB,
	0xE9, 0xEB, 0xEB, 0xEB, 0xE8, 0xE7, 0xEB, 0xEB,
	0xB8, 0xBD, 0xB4, 0xBB, 0xA4, 0xB8, 0xA2, 0xBF,
	0xA2, 0xA4, 0xA5, 0xEB, 0xA8, 0xA4, 0xA7, 0xA4,
	0xB9, 0xEB, 0xBF, 0xAE, 0xB3, 0xA8, 0xA4, 0xA4,
	0xB9, 0xAF, 0xEB, 0x40, 0xB8, 0xA3, 0xAF, 0xB9,
	0xEB, 0xEA, 0xEB, 0xEB, 0xAB, 0xEB, 0xEA, 0xEB,
	0xAB, 0xEB, 0xEB, 0xEB, 0xB2, 0xEB, 0xEB, 0xEF,
	0xAD, 0x65, 0xCB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEF, 0xEB, 0xEB, 0xEB, 0xB4, 0xEB, 0xEB, 0xE8,
	0xD9, 0xFB, 0xFB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xB4, 0xEB, 0xEB, 0xE8, 0x19, 0xFB, 0xFB, 0xEB,
	0xEA, 0xEB, 0xEB, 0xEB, 0xB4, 0xEB, 0xEB, 0xE8,
	0xD9, 0xFB, 0xFB, 0xEB, 0xE9, 0xEB, 0xEB, 0xEB,
	0x8C, 0xEB, 0xEB, 0xEF, 0x19, 0xCB, 0xFB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEA, 0xEB, 0xEB, 0xEB,
	0x8E, 0xEB, 0xEB, 0xE8, 0x19, 0xCB, 0xFB, 0xEB,
	0xEA, 0xEB, 0xEB, 0xEB, 0x8E, 0xEB, 0xEB, 0xE8,
	0xD9, 0xCB, 0xFB, 0xEB, 0xE9, 0xEB, 0xEB, 0xEB,
	0x83, 0xEB, 0xEB, 0xE9, 0xEA, 0xEB, 0xEB, 0xEB,
	0xD3, 0xEB, 0xEB, 0xE3, 0x19, 0xEB, 0xFB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xBD, 0xFE, 0xFB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xAD, 0x65, 0xCB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEA, 0xEB, 0xEB, 0xEB,
	0xD9, 0xEB, 0xEB, 0xE1, 0x19, 0xEB, 0xFB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xAD, 0x65, 0xCB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xED, 0xFB, 0xFB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xAD, 0xE5, 0xFB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xE3, 0x19, 0xCB, 0xFB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xAD, 0xE5, 0xFB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xAD, 0x65, 0xCB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xE8, 0xEB, 0xEB, 0xEB,
	0xDD, 0xEB, 0xEB, 0xEE, 0x19, 0xCB, 0xFB, 0xEB,
	0xEA, 0xEB, 0xEB, 0xEB, 0xAD, 0xF5, 0xFB, 0xEB,
	0xEA, 0xEB, 0xEB, 0xEB, 0xDD, 0xEB, 0xEB, 0xEE,
	0xD9, 0xCB, 0xFB, 0xEB, 0xE9, 0xEB, 0xEB, 0xEB,
	0xAD, 0xFB, 0xFB, 0xEB, 0xE9, 0xEB, 0xEB, 0xEB,
	0xD5, 0xEB, 0xEB, 0xEA, 0xB8, 0xBF, 0xAA, 0xBF,
	0x9F, 0xEB, 0xEB, 0xEB, 0xED, 0xEB, 0xEB, 0xEB,
	0xEA, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xED, 0xEB, 0xEB, 0xEB, 0xE8, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEA, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xE9, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
};

const std::uint8_t g_ps_code[] =
{
	0xAF, 0xB3, 0xA9, 0xA8, 0x1F, 0xDC, 0xD4, 0x46,
	0xA7, 0x4E, 0x57, 0x33, 0xB6, 0x21, 0x32, 0xA4,
	0x0B, 0x91, 0x25, 0x71, 0xEA, 0xEB, 0xEB, 0xEB,
	0x4B, 0xE9, 0xEB, 0xEB, 0xEE, 0xEB, 0xEB, 0xEB,
	0xDF, 0xEB, 0xEB, 0xEB, 0x0B, 0xEB, 0xEB, 0xEB,
	0xBF, 0xEA, 0xEB, 0xEB, 0x63, 0xEA, 0xEB, 0xEB,
	0xCF, 0xE9, 0xEB, 0xEB, 0xB9, 0xAF, 0xAE, 0xAD,
	0x4F, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xE9, 0xEB, 0xEB, 0xEB,
	0xF7, 0xEB, 0xEB, 0xEB, 0xEB, 0xEF, 0x14, 0x14,
	0xEB, 0xEA, 0xEB, 0xEB, 0x85, 0xEB, 0xEB, 0xEB,
	0xB7, 0xEB, 0xEB, 0xEB, 0xE8, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEA, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0x8E, 0xEB, 0xEB, 0xEB, 0xE9, 0xEB, 0xEB, 0xEB,
	0xEE, 0xEB, 0xEB, 0xEB, 0xEF, 0xEB, 0xEB, 0xEB,
	0x14, 0x14, 0x14, 0x14, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEA, 0xEB, 0xEB, 0xEB, 0xE7, 0xEB, 0xEB, 0xEB,
	0x98, 0x8A, 0x86, 0x9B, 0x87, 0x8E, 0x99, 0xDB,
	0xEB, 0x9F, 0x8E, 0x93, 0x9F, 0x9E, 0x99, 0x8E,
	0xDB, 0xEB, 0xA6, 0x82, 0x88, 0x99, 0x84, 0x98,
	0x84, 0x8D, 0x9F, 0xCB, 0xC3, 0xB9, 0xC2, 0xCB,
	0xA3, 0xA7, 0xB8, 0xA7, 0xCB, 0xB8, 0x83, 0x8A,
	0x8F, 0x8E, 0x99, 0xCB, 0xA8, 0x84, 0x86, 0x9B,
	0x82, 0x87, 0x8E, 0x99, 0xCB, 0xDA, 0xDB, 0xC5,
	0xDB, 0xC5, 0xDA, 0xDB, 0xDB, 0xDA, 0xDA, 0xC5,
	0xDA, 0xDD, 0xD8, 0xD3, 0xDF, 0xEB, 0x40, 0x40,
	0xA2, 0xB8, 0xAC, 0xA5, 0x87, 0xEB, 0xEB, 0xEB,
	0xE8, 0xEB, 0xEB, 0xEB, 0xE3, 0xEB, 0xEB, 0xEB,
	0xBB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEA, 0xEB, 0xEB, 0xEB, 0xE8, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xE4, 0xEB, 0xEB, 0xEB,
	0xB7, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xE8, 0xEB, 0xEB, 0xEB,
	0xEA, 0xEB, 0xEB, 0xEB, 0xE4, 0xE4, 0xEB, 0xEB,
	0x89, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xE8, 0xEB, 0xEB, 0xEB,
	0xE9, 0xEB, 0xEB, 0xEB, 0xE8, 0xE8, 0xEB, 0xEB,
	0xB8, 0xBD, 0xB4, 0xBB, 0xA4, 0xB8, 0xA2, 0xBF,
	0xA2, 0xA4, 0xA5, 0xEB, 0xA8, 0xA4, 0xA7, 0xA4,
	0xB9, 0xEB, 0xBF, 0xAE, 0xB3, 0xA8, 0xA4, 0xA4,
	0xB9, 0xAF, 0xEB, 0x40, 0xA4, 0xB8, 0xAC, 0xA5,
	0xC7, 0xEB, 0xEB, 0xEB, 0xEA, 0xEB, 0xEB, 0xEB,
	0xE3, 0xEB, 0xEB, 0xEB, 0xCB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xE8, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xE4, 0xEB, 0xEB, 0xEB, 0xB8, 0xBD, 0xB4, 0xBF,
	0x8A, 0x99, 0x8C, 0x8E, 0x9F, 0xEB, 0x40, 0x40,
	0xB8, 0xA3, 0xAF, 0xB9, 0x7F, 0xEB, 0xEB, 0xEB,
	0xAB, 0xEB, 0xEB, 0xEB, 0xCE, 0xEB, 0xEB, 0xEB,
	0xB1, 0xEB, 0xEB, 0xE8, 0xEB, 0x8B, 0xFB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xB3, 0xF3, 0xEB, 0xEF,
	0xEB, 0x9B, 0xFB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xBE, 0xBE, 0xEB, 0xEB, 0x89, 0xFB, 0xEB, 0xE8,
	0x19, 0xFB, 0xFB, 0xEB, 0xEA, 0xEB, 0xEB, 0xEB,
	0x89, 0xFB, 0xEB, 0xE8, 0xD9, 0xFB, 0xFB, 0xEB,
	0xE9, 0xEB, 0xEB, 0xEB, 0x8E, 0xEB, 0xEB, 0xE8,
	0x19, 0xCB, 0xFB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0x83, 0xEB, 0xEB, 0xE9, 0xEA, 0xEB, 0xEB, 0xEB,
	0xAE, 0xEB, 0xEB, 0xE2, 0x19, 0xEB, 0xFB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xAD, 0xFB, 0xFB, 0xEB,
	0xE9, 0xEB, 0xEB, 0xEB, 0xAD, 0x95, 0xFB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0x8B, 0xFB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xD3, 0xEB, 0xEB, 0xEC,
	0x19, 0xCB, 0xFB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xAD, 0xE5, 0xFB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xAD, 0xF5, 0xFB, 0xEB, 0xEA, 0xEB, 0xEB, 0xEB,
	0xD5, 0xEB, 0xEB, 0xEA, 0xB8, 0xBF, 0xAA, 0xBF,
	0x9F, 0xEB, 0xEB, 0xEB, 0xE8, 0xEB, 0xEB, 0xEB,
	0xEA, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xE8, 0xEB, 0xEB, 0xEB, 0xEA, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEA, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEA, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
	0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
};
```

`horizon/imgui/imgui_shader_dx11.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

constexpr std::uint8_t g_vs_key = 0xEB;
constexpr std::uint8_t g_ps_key = 0xEB;

extern const std::size_t g_vs_size;
extern const std::size_t g_ps_size;

extern const std::uint8_t g_vs_code[];
extern const std::uint8_t g_ps_code[];
```

`horizon/imgui/imgui_widgets.cpp`:

```cpp
// dear imgui, v1.77 WIP
// (widgets code)

/*

Index of this file:

// [SECTION] Forward Declarations
// [SECTION] Widgets: Text, etc.
// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)
// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)
// [SECTION] Widgets: ComboBox
// [SECTION] Data Type and Data Formatting Helpers
// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.
// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.
// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.
// [SECTION] Widgets: InputText, InputTextMultiline
// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.
// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.
// [SECTION] Widgets: Selectable
// [SECTION] Widgets: ListBox
// [SECTION] Widgets: PlotLines, PlotHistogram
// [SECTION] Widgets: Value helpers
// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.
// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.
// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.
// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.

*/

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.hpp"

// Atom includes
#include "../constant/character.hpp"
#include "../constant/hash.hpp"
#include "../constant/secure_string.hpp"
#include "../constant/string.hpp"

#include "../core/map_data.hpp"

#include "../win32/math.hpp"
#include "../win32/string.hpp"

using namespace horizon;

#ifndef IMGUI_DISABLE

#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif
#include "imgui_internal.hpp"

#include <ctype.h>      // toupper
#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
#include <stddef.h>     // intptr_t
#else
#include <stdint.h>     // intptr_t
#endif

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4127)     // condition expression is constant
#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later
#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types
#endif
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#pragma clang diagnostic ignored "-Wold-style-cast"         // warning : use of old-style cast                              // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants (typically 0.0f) is ok.
#pragma clang diagnostic ignored "-Wformat-nonliteral"      // warning : format string is not a string literal              // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
#pragma clang diagnostic ignored "-Wsign-conversion"        // warning : implicit conversion changes signedness             //
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning : zero as null pointer constant              // some standard header variations use #define NULL 0
#endif
#if __has_warning("-Wdouble-promotion")
#pragma clang diagnostic ignored "-Wdouble-promotion"       // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#endif
#if __has_warning("-Wdeprecated-enum-enum-conversion")
#pragma clang diagnostic ignored "-Wdeprecated-enum-enum-conversion" // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated
#endif
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wpragmas"                  // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wformat-nonliteral"        // warning: format not a string literal, format string not checked
#pragma GCC diagnostic ignored "-Wclass-memaccess"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif

//-------------------------------------------------------------------------
// Data
//-------------------------------------------------------------------------

// Those MIN/MAX values are not define because we need to point to them
static const signed char    IM_S8_MIN = -128;
static const signed char    IM_S8_MAX = 127;
static const unsigned char  IM_U8_MIN = 0;
static const unsigned char  IM_U8_MAX = 0xFF;
static const signed short   IM_S16_MIN = -32768;
static const signed short   IM_S16_MAX = 32767;
static const unsigned short IM_U16_MIN = 0;
static const unsigned short IM_U16_MAX = 0xFFFF;
static const ImS32          IM_S32_MIN = INT_MIN;    // (-2147483647 - 1), (0x80000000);
static const ImS32          IM_S32_MAX = INT_MAX;    // (2147483647), (0x7FFFFFFF)
static const ImU32          IM_U32_MIN = 0;
static const ImU32          IM_U32_MAX = UINT_MAX;   // (0xFFFFFFFF)
#ifdef LLONG_MIN
static const ImS64          IM_S64_MIN = LLONG_MIN;  // (-9223372036854775807ll - 1ll);
static const ImS64          IM_S64_MAX = LLONG_MAX;  // (9223372036854775807ll);
#else
static const ImS64          IM_S64_MIN = -9223372036854775807LL - 1;
static const ImS64          IM_S64_MAX = 9223372036854775807LL;
#endif
static const ImU64          IM_U64_MIN = 0;
#ifdef ULLONG_MAX
static const ImU64          IM_U64_MAX = ULLONG_MAX; // (0xFFFFFFFFFFFFFFFFull);
#else
static const ImU64          IM_U64_MAX = ( 2ULL * 9223372036854775807LL + 1 );
#endif

//-------------------------------------------------------------------------
// [SECTION] Forward Declarations
//-------------------------------------------------------------------------

// For InputTextEx()
static bool             InputTextFilterCharacter( unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data );
static int              InputTextCalcTextLenAndLineCount( const char* text_begin, const char** out_text_end );
static ImVec2           InputTextCalcTextSizeW( const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining = NULL, ImVec2* out_offset = NULL, bool stop_on_new_line = false );

//-------------------------------------------------------------------------
// [SECTION] Widgets: Text, etc.
//-------------------------------------------------------------------------
// - TextEx() [Internal]
// - TextUnformatted()
// - Text()
// - TextV()
// - TextColored()
// - TextColoredV()
// - TextDisabled()
// - TextDisabledV()
// - TextWrapped()
// - TextWrappedV()
// - LabelText()
// - LabelTextV()
// - BulletText()
// - BulletTextV()
//-------------------------------------------------------------------------

void ImGui::TextEx( const char* text, const char* text_end, ImGuiTextFlags flags )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return;

	ImGuiContext& g = *GImGui;
	IM_ASSERT( text != NULL );
	const char* text_begin = text;
	if( text_end == NULL )
		text_end = text + strlen( text ); // FIXME-OPT

	const ImVec2 text_pos( window->DC.CursorPos.x, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset );
	const float wrap_pos_x = window->DC.TextWrapPos;
	const bool wrap_enabled = ( wrap_pos_x >= 0.0f );
	if( text_end - text > 2000 && !wrap_enabled )
	{
		// Long text!
		// Perform manual coarse clipping to optimize for long multi-line text
		// - From this point we will only compute the width of lines that are visible. Optimization only available when word-wrapping is disabled.
		// - We also don't vertically center the text within the line full height, which is unlikely to matter because we are likely the biggest and only item on the line.
		// - We use memchr(), pay attention that well optimized versions of those str/mem functions are much faster than a casually written loop.
		const char* line = text;
		const float line_height = GetTextLineHeight();
		ImVec2 text_size( 0, 0 );

		// Lines to skip (can't skip when logging text)
		ImVec2 pos = text_pos;
		if( !g.LogEnabled )
		{
			int lines_skippable = ( int )( ( window->ClipRect.Min.y - text_pos.y ) / line_height );
			if( lines_skippable > 0 )
			{
				int lines_skipped = 0;
				while( line < text_end && lines_skipped < lines_skippable )
				{
					const char* line_end = ( const char* )memchr( line, '\n', text_end - line );
					if( !line_end )
						line_end = text_end;
					if( ( flags & ImGuiTextFlags_NoWidthForLargeClippedText ) == 0 )
						text_size.x = ImMax( text_size.x, CalcTextSize( line, line_end ).x );
					line = line_end + 1;
					lines_skipped++;
				}
				pos.y += lines_skipped * line_height;
			}
		}

		// Lines to render
		if( line < text_end )
		{
			ImRect line_rect( pos, pos + ImVec2( FLT_MAX, line_height ) );
			while( line < text_end )
			{
				if( IsClippedEx( line_rect, 0, false ) )
					break;

				const char* line_end = ( const char* )memchr( line, '\n', text_end - line );
				if( !line_end )
					line_end = text_end;
				text_size.x = ImMax( text_size.x, CalcTextSize( line, line_end ).x );
				RenderText( pos, line, line_end, false );
				line = line_end + 1;
				line_rect.Min.y += line_height;
				line_rect.Max.y += line_height;
				pos.y += line_height;
			}

			// Count remaining lines
			int lines_skipped = 0;
			while( line < text_end )
			{
				const char* line_end = ( const char* )memchr( line, '\n', text_end - line );
				if( !line_end )
					line_end = text_end;
				if( ( flags & ImGuiTextFlags_NoWidthForLargeClippedText ) == 0 )
					text_size.x = ImMax( text_size.x, CalcTextSize( line, line_end ).x );
				line = line_end + 1;
				lines_skipped++;
			}
			pos.y += lines_skipped * line_height;
		}
		text_size.y = ( pos - text_pos ).y;

		ImRect bb( text_pos, text_pos + text_size );
		ItemSize( text_size, 0.0f );
		ItemAdd( bb, 0 );
	}
	else
	{
		const float wrap_width = wrap_enabled ? CalcWrapWidthForPos( window->DC.CursorPos, wrap_pos_x ) : 0.0f;
		const ImVec2 text_size = CalcTextSize( text_begin, text_end, false, wrap_width );

		ImRect bb( text_pos, text_pos + text_size );
		ItemSize( text_size, 0.0f );
		if( !ItemAdd( bb, 0 ) )
			return;

		// Render (we don't hide text after ## in this end-user function)
		RenderTextWrapped( bb.Min, text_begin, text_end, wrap_width );
	}
}

void ImGui::TextUnformatted( const char* text, const char* text_end )
{
	TextEx( text, text_end, ImGuiTextFlags_NoWidthForLargeClippedText );
}

void ImGui::Text( const char* fmt, ... )
{
	va_list args;
	va_start( args, fmt );
	TextV( fmt, args );
	va_end( args );
}

void ImGui::TextV( const char* fmt, va_list args )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return;

	ImGuiContext& g = *GImGui;
	const char* text_end = g.TempBuffer + ImFormatStringV( g.TempBuffer, IM_ARRAYSIZE( g.TempBuffer ), fmt, args );
	TextEx( g.TempBuffer, text_end, ImGuiTextFlags_NoWidthForLargeClippedText );
}

void ImGui::TextColored( const ImVec4& col, const char* fmt, ... )
{
	va_list args;
	va_start( args, fmt );
	TextColoredV( col, fmt, args );
	va_end( args );
}

void ImGui::TextColoredV( const ImVec4& col, const char* fmt, va_list args )
{
	PushStyleColor( ImGuiCol_Text, col );
	TextV( fmt, args );
	PopStyleColor();
}

void ImGui::TextDisabled( const char* fmt, ... )
{
	va_list args;
	va_start( args, fmt );
	TextDisabledV( fmt, args );
	va_end( args );
}

void ImGui::TextDisabledV( const char* fmt, va_list args )
{
	PushStyleColor( ImGuiCol_Text, GImGui->Style.Colors[ ImGuiCol_TextDisabled ] );
	TextV( fmt, args );
	PopStyleColor();
}

void ImGui::TextWrapped( const char* fmt, ... )
{
	va_list args;
	va_start( args, fmt );
	TextWrappedV( fmt, args );
	va_end( args );
}

void ImGui::TextWrappedV( const char* fmt, va_list args )
{
	ImGuiWindow* window = GetCurrentWindow();
	bool need_backup = ( window->DC.TextWrapPos < 0.0f );  // Keep existing wrap position if one is already set
	if( need_backup )
		PushTextWrapPos( 0.0f );
	TextV( fmt, args );
	if( need_backup )
		PopTextWrapPos();
}

void ImGui::LabelText( const char* label, const char* fmt, ... )
{
	va_list args;
	va_start( args, fmt );
	LabelTextV( label, fmt, args );
	va_end( args );
}

// Add a label+text combo aligned to other label+value widgets
void ImGui::LabelTextV( const char* label, const char* fmt, va_list args )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const float w = CalcItemWidth();

	const ImVec2 label_size = CalcTextSize( label, NULL, true );
	const ImRect value_bb( window->DC.CursorPos, window->DC.CursorPos + ImVec2( w, label_size.y + style.FramePadding.y * 2 ) );
	const ImRect total_bb( window->DC.CursorPos, window->DC.CursorPos + ImVec2( w + ( label_size.x > 0.0f ? style.ItemInnerSpacing.x : 0.0f ), style.FramePadding.y * 2 ) + label_size );
	ItemSize( total_bb, style.FramePadding.y );
	if( !ItemAdd( total_bb, 0 ) )
		return;

	// Render
	const char* value_text_begin = &g.TempBuffer[ 0 ];
	const char* value_text_end = value_text_begin + ImFormatStringV( g.TempBuffer, IM_ARRAYSIZE( g.TempBuffer ), fmt, args );
	RenderTextClipped( value_bb.Min, value_bb.Max, value_text_begin, value_text_end, NULL, ImVec2( 0.0f, 0.5f ) );
	if( label_size.x > 0.0f )
		RenderText( ImVec2( value_bb.Max.x + style.ItemInnerSpacing.x, value_bb.Min.y + style.FramePadding.y ), label );
}

void ImGui::BulletText( const char* fmt, ... )
{
	va_list args;
	va_start( args, fmt );
	BulletTextV( fmt, args );
	va_end( args );
}

// Text with a little bullet aligned to the typical tree node.
void ImGui::BulletTextV( const char* fmt, va_list args )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;

	const char* text_begin = g.TempBuffer;
	const char* text_end = text_begin + ImFormatStringV( g.TempBuffer, IM_ARRAYSIZE( g.TempBuffer ), fmt, args );
	const ImVec2 label_size = CalcTextSize( text_begin, text_end, false );
	const ImVec2 total_size = ImVec2( g.FontSize + ( label_size.x > 0.0f ? ( label_size.x + style.FramePadding.x * 2 ) : 0.0f ), label_size.y );  // Empty text doesn't add padding
	ImVec2 pos = window->DC.CursorPos;
	pos.y += window->DC.CurrLineTextBaseOffset;
	ItemSize( total_size, 0.0f );
	const ImRect bb( pos, pos + total_size );
	if( !ItemAdd( bb, 0 ) )
		return;

	// Render
	ImU32 text_col = GetColorU32( ImGuiCol_Text );
	RenderBullet( window->DrawList, bb.Min + ImVec2( style.FramePadding.x + g.FontSize * 0.5f, g.FontSize * 0.5f ), text_col );
	RenderText( bb.Min + ImVec2( g.FontSize + style.FramePadding.x * 2, 0.0f ), text_begin, text_end, false );
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Main
//-------------------------------------------------------------------------
// - ButtonBehavior() [Internal]
// - Button()
// - SmallButton()
// - InvisibleButton()
// - ArrowButton()
// - CloseButton() [Internal]
// - CollapseButton() [Internal]
// - GetWindowScrollbarID() [Internal]
// - GetWindowScrollbarRect() [Internal]
// - Scrollbar() [Internal]
// - ScrollbarEx() [Internal]
// - Image()
// - ImageButton()
// - Checkbox()
// - CheckboxFlags()
// - RadioButton()
// - ProgressBar()
// - Bullet()
//-------------------------------------------------------------------------

// The ButtonBehavior() function is key to many interactions and used by many/most widgets.
// Because we handle so many cases (keyboard/gamepad navigation, drag and drop) and many specific behavior (via ImGuiButtonFlags_),
// this code is a little complex.
// By far the most common path is interacting with the Mouse using the default ImGuiButtonFlags_PressedOnClickRelease button behavior.
// See the series of events below and the corresponding state reported by dear imgui:
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnClickRelease:             return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+0 (mouse is outside bb)        -             -                -               -                  -                    -
//   Frame N+1 (mouse moves inside bb)      -             true             -               -                  -                    -
//   Frame N+2 (mouse button is down)       -             true             true            true               -                    true
//   Frame N+3 (mouse button is down)       -             true             true            -                  -                    -
//   Frame N+4 (mouse moves outside bb)     -             -                true            -                  -                    -
//   Frame N+5 (mouse moves inside bb)      -             true             true            -                  -                    -
//   Frame N+6 (mouse button is released)   true          true             -               -                  true                 -
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
//   Frame N+8 (mouse moves outside bb)     -             -                -               -                  -                    -
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnClick:                    return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+2 (mouse button is down)       true          true             true            true               -                    true
//   Frame N+3 (mouse button is down)       -             true             true            -                  -                    -
//   Frame N+6 (mouse button is released)   -             true             -               -                  true                 -
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnRelease:                  return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+2 (mouse button is down)       -             true             -               -                  -                    true
//   Frame N+3 (mouse button is down)       -             true             -               -                  -                    -
//   Frame N+6 (mouse button is released)   true          true             -               -                  -                    -
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnDoubleClick:              return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+0 (mouse button is down)       -             true             -               -                  -                    true
//   Frame N+1 (mouse button is down)       -             true             -               -                  -                    -
//   Frame N+2 (mouse button is released)   -             true             -               -                  -                    -
//   Frame N+3 (mouse button is released)   -             true             -               -                  -                    -
//   Frame N+4 (mouse button is down)       true          true             true            true               -                    true
//   Frame N+5 (mouse button is down)       -             true             true            -                  -                    -
//   Frame N+6 (mouse button is released)   -             true             -               -                  true                 -
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
//------------------------------------------------------------------------------------------------------------------------------------------------
// Note that some combinations are supported,
// - PressedOnDragDropHold can generally be associated with any flag.
// - PressedOnDoubleClick can be associated by PressedOnClickRelease/PressedOnRelease, in which case the second release event won't be reported.
//------------------------------------------------------------------------------------------------------------------------------------------------
// The behavior of the return-value changes when ImGuiButtonFlags_Repeat is set:
//                                         Repeat+                  Repeat+           Repeat+             Repeat+
//                                         PressedOnClickRelease    PressedOnClick    PressedOnRelease    PressedOnDoubleClick
//-------------------------------------------------------------------------------------------------------------------------------------------------
//   Frame N+0 (mouse button is down)       -                        true              -                   true
//   ...                                    -                        -                 -                   -
//   Frame N + RepeatDelay                  true                     true              -                   true
//   ...                                    -                        -                 -                   -
//   Frame N + RepeatDelay + RepeatRate*N   true                     true              -                   true
//-------------------------------------------------------------------------------------------------------------------------------------------------

bool ImGui::ButtonBehavior( const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags )
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = GetCurrentWindow();

	if( flags & ImGuiButtonFlags_Disabled )
	{
		if( out_hovered ) *out_hovered = false;
		if( out_held ) *out_held = false;
		if( g.ActiveId == id ) ClearActiveID();
		return false;
	}

	// Default only reacts to left mouse button
	if( ( flags & ImGuiButtonFlags_MouseButtonMask_ ) == 0 )
		flags |= ImGuiButtonFlags_MouseButtonDefault_;

	// Default behavior requires click + release inside bounding box
	if( ( flags & ImGuiButtonFlags_PressedOnMask_ ) == 0 )
		flags |= ImGuiButtonFlags_PressedOnDefault_;

	ImGuiWindow* backup_hovered_window = g.HoveredWindow;
	const bool flatten_hovered_children = ( flags & ImGuiButtonFlags_FlattenChildren ) && g.HoveredRootWindow == window;
	if( flatten_hovered_children )
		g.HoveredWindow = window;

#ifdef IMGUI_ENABLE_TEST_ENGINE
	if( id != 0 && window->DC.LastItemId != id )
		IMGUI_TEST_ENGINE_ITEM_ADD( bb, id );
#endif

	bool pressed = false;
	bool hovered = ItemHoverable( bb, id );

	// Drag source doesn't report as hovered
	if( hovered && g.DragDropActive && g.DragDropPayload.SourceId == id && !( g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover ) )
		hovered = false;

	// Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button
	if( g.DragDropActive && ( flags & ImGuiButtonFlags_PressedOnDragDropHold ) && !( g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers ) )
		if( IsItemHovered( ImGuiHoveredFlags_AllowWhenBlockedByActiveItem ) )
		{
			const float DRAG_DROP_HOLD_TIMER = 0.70f;
			hovered = true;
			SetHoveredID( id );
			if( CalcTypematicRepeatAmount( g.HoveredIdTimer + 0.0001f - g.IO.DeltaTime, g.HoveredIdTimer + 0.0001f, DRAG_DROP_HOLD_TIMER, 0.00f ) )
			{
				pressed = true;
				g.DragDropHoldJustPressedId = id;
				FocusWindow( window );
			}
		}

	if( flatten_hovered_children )
		g.HoveredWindow = backup_hovered_window;

	// AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match. This allows using patterns where a later submitted widget overlaps a previous one.
	if( hovered && ( flags & ImGuiButtonFlags_AllowItemOverlap ) && ( g.HoveredIdPreviousFrame != id && g.HoveredIdPreviousFrame != 0 ) )
		hovered = false;

	// Mouse handling
	if( hovered )
	{
		if( !( flags & ImGuiButtonFlags_NoKeyModifiers ) || ( !g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt ) )
		{
			// Poll buttons
			int mouse_button_clicked = -1;
			int mouse_button_released = -1;
			if( ( flags & ImGuiButtonFlags_MouseButtonLeft ) && g.IO.MouseClicked[ 0 ] )
			{
				mouse_button_clicked = 0;
			}
			else if( ( flags & ImGuiButtonFlags_MouseButtonRight ) && g.IO.MouseClicked[ 1 ] )
			{
				mouse_button_clicked = 1;
			}
			else if( ( flags & ImGuiButtonFlags_MouseButtonMiddle ) && g.IO.MouseClicked[ 2 ] )
			{
				mouse_button_clicked = 2;
			}
			if( ( flags & ImGuiButtonFlags_MouseButtonLeft ) && g.IO.MouseReleased[ 0 ] )
			{
				mouse_button_released = 0;
			}
			else if( ( flags & ImGuiButtonFlags_MouseButtonRight ) && g.IO.MouseReleased[ 1 ] )
			{
				mouse_button_released = 1;
			}
			else if( ( flags & ImGuiButtonFlags_MouseButtonMiddle ) && g.IO.MouseReleased[ 2 ] )
			{
				mouse_button_released = 2;
			}

			if( mouse_button_clicked != -1 && g.ActiveId != id )
			{
				if( flags & ( ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere ) )
				{
					SetActiveID( id, window );
					g.ActiveIdMouseButton = mouse_button_clicked;
					if( !( flags & ImGuiButtonFlags_NoNavFocus ) )
						SetFocusID( id, window );
					FocusWindow( window );
				}
				if( ( flags & ImGuiButtonFlags_PressedOnClick ) || ( ( flags & ImGuiButtonFlags_PressedOnDoubleClick ) && g.IO.MouseDoubleClicked[ mouse_button_clicked ] ) )
				{
					pressed = true;
					if( flags & ImGuiButtonFlags_NoHoldingActiveId )
						ClearActiveID();
					else
						SetActiveID( id, window ); // Hold on ID
					g.ActiveIdMouseButton = mouse_button_clicked;
					FocusWindow( window );
				}
			}
			if( ( flags & ImGuiButtonFlags_PressedOnRelease ) && mouse_button_released != -1 )
			{
				// Repeat mode trumps on release behavior
				if( !( ( flags & ImGuiButtonFlags_Repeat ) && g.IO.MouseDownDurationPrev[ mouse_button_released ] >= g.IO.KeyRepeatDelay ) )
					pressed = true;
				ClearActiveID();
			}

			// 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).
			// Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.
			if( g.ActiveId == id && ( flags & ImGuiButtonFlags_Repeat ) )
				if( g.IO.MouseDownDuration[ g.ActiveIdMouseButton ] > 0.0f && IsMouseClicked( g.ActiveIdMouseButton, true ) )
					pressed = true;
		}

		if( pressed )
			g.NavDisableHighlight = true;
	}

	// Gamepad/Keyboard navigation
	// We report navigated item as hovered but we don't set g.HoveredId to not interfere with mouse.
	if( g.NavId == id && !g.NavDisableHighlight && g.NavDisableMouseHover && ( g.ActiveId == 0 || g.ActiveId == id || g.ActiveId == window->MoveId ) )
		if( !( flags & ImGuiButtonFlags_NoHoveredOnFocus ) )
			hovered = true;
	if( g.NavActivateDownId == id )
	{
		bool nav_activated_by_code = ( g.NavActivateId == id );
		bool nav_activated_by_inputs = IsNavInputTest( ImGuiNavInput_Activate, ( flags & ImGuiButtonFlags_Repeat ) ? ImGuiInputReadMode_Repeat : ImGuiInputReadMode_Pressed );
		if( nav_activated_by_code || nav_activated_by_inputs )
			pressed = true;
		if( nav_activated_by_code || nav_activated_by_inputs || g.ActiveId == id )
		{
			// Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
			g.NavActivateId = id; // This is so SetActiveId assign a Nav source
			SetActiveID( id, window );
			if( ( nav_activated_by_code || nav_activated_by_inputs ) && !( flags & ImGuiButtonFlags_NoNavFocus ) )
				SetFocusID( id, window );
		}
	}

	bool held = false;
	if( g.ActiveId == id )
	{
		if( g.ActiveIdSource == ImGuiInputSource_Mouse )
		{
			if( g.ActiveIdIsJustActivated )
				g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;

			const int mouse_button = g.ActiveIdMouseButton;
			IM_ASSERT( mouse_button >= 0 && mouse_button < ImGuiMouseButton_COUNT );
			if( g.IO.MouseDown[ mouse_button ] )
			{
				held = true;
			}
			else
			{
				bool release_in = hovered && ( flags & ImGuiButtonFlags_PressedOnClickRelease ) != 0;
				bool release_anywhere = ( flags & ImGuiButtonFlags_PressedOnClickReleaseAnywhere ) != 0;
				if( ( release_in || release_anywhere ) && !g.DragDropActive )
				{
					bool is_double_click_release = ( flags & ImGuiButtonFlags_PressedOnDoubleClick ) && g.IO.MouseDownWasDoubleClick[ mouse_button ];
					bool is_repeating_already = ( flags & ImGuiButtonFlags_Repeat ) && g.IO.MouseDownDurationPrev[ mouse_button ] >= g.IO.KeyRepeatDelay; // Repeat mode trumps <on release>
					if( !is_double_click_release && !is_repeating_already )
						pressed = true;
				}
				ClearActiveID();
			}
			if( !( flags & ImGuiButtonFlags_NoNavFocus ) )
				g.NavDisableHighlight = true;
		}
		else if( g.ActiveIdSource == ImGuiInputSource_Nav )
		{
			if( g.NavActivateDownId != id )
				ClearActiveID();
		}
		if( pressed )
			g.ActiveIdHasBeenPressedBefore = true;
	}

	if( out_hovered ) *out_hovered = hovered;
	if( out_held ) *out_held = held;

	return pressed;
}

bool ImGui::ButtonEx( const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID( label );
	const ImVec2 label_size = CalcTextSize( label, NULL, true );

	ImVec2 pos = window->DC.CursorPos;
	if( ( flags & ImGuiButtonFlags_AlignTextBaseLine ) && style.FramePadding.y < window->DC.CurrLineTextBaseOffset ) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)
		pos.y += window->DC.CurrLineTextBaseOffset - style.FramePadding.y;
	ImVec2 size = CalcItemSize( size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f );

	const ImRect bb( pos, pos + size );
	ItemSize( size, style.FramePadding.y );
	if( !ItemAdd( bb, id ) )
		return false;

	if( window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat )
		flags |= ImGuiButtonFlags_Repeat;
	bool hovered, held;
	bool pressed = ButtonBehavior( bb, id, &hovered, &held, flags );

	// Render
	const ImU32 col = GetColorU32( ( held && hovered ) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button );
	RenderNavHighlight( bb, id );
	RenderFrame( bb.Min, bb.Max, col, true, style.FrameRounding );
	RenderTextClipped( bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb );

	// Automatically close popups
	//if (pressed && !(flags & ImGuiButtonFlags_DontClosePopups) && (window->Flags & ImGuiWindowFlags_Popup))
	//    CloseCurrentPopup();

	IMGUI_TEST_ENGINE_ITEM_INFO( id, label, window->DC.LastItemStatusFlags );
	return pressed;
}

bool ImGui::Button( const char* label, const ImVec2& size_arg )
{
	return ButtonEx( label, size_arg, 0 );
}

// Small buttons fits within text without additional vertical spacing.
bool ImGui::SmallButton( const char* label )
{
	ImGuiContext& g = *GImGui;
	float backup_padding_y = g.Style.FramePadding.y;
	g.Style.FramePadding.y = 0.0f;
	bool pressed = ButtonEx( label, ImVec2( 0, 0 ), ImGuiButtonFlags_AlignTextBaseLine );
	g.Style.FramePadding.y = backup_padding_y;
	return pressed;
}

// Tip: use ImGui::PushID()/PopID() to push indices or pointers in the ID stack.
// Then you can keep 'str_id' empty or the same for all your buttons (instead of creating a string based on a non-string id)
bool ImGui::InvisibleButton( const char* str_id, const ImVec2& size_arg )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	// Cannot use zero-size for InvisibleButton(). Unlike Button() there is not way to fallback using the label size.
	IM_ASSERT( size_arg.x != 0.0f && size_arg.y != 0.0f );

	const ImGuiID id = window->GetID( str_id );
	ImVec2 size = CalcItemSize( size_arg, 0.0f, 0.0f );
	const ImRect bb( window->DC.CursorPos, window->DC.CursorPos + size );
	ItemSize( size );
	if( !ItemAdd( bb, id ) )
		return false;

	bool hovered, held;
	bool pressed = ButtonBehavior( bb, id, &hovered, &held );

	return pressed;
}

bool ImGui::ArrowButtonEx( const char* str_id, ImGuiDir dir, ImVec2 size, ImGuiButtonFlags flags )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiID id = window->GetID( str_id );
	const ImRect bb( window->DC.CursorPos, window->DC.CursorPos + size );
	const float default_size = GetFrameHeight();
	ItemSize( size, ( size.y >= default_size ) ? g.Style.FramePadding.y : -1.0f );
	if( !ItemAdd( bb, id ) )
		return false;

	if( window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat )
		flags |= ImGuiButtonFlags_Repeat;

	bool hovered, held;
	bool pressed = ButtonBehavior( bb, id, &hovered, &held, flags );

	// Render
	const ImU32 bg_col = GetColorU32( ( held && hovered ) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button );
	const ImU32 text_col = GetColorU32( ImGuiCol_Text );
	RenderNavHighlight( bb, id );
	RenderFrame( bb.Min, bb.Max, bg_col, true, g.Style.FrameRounding );
	RenderArrow( window->DrawList, bb.Min + ImVec2( ImMax( 0.0f, ( size.x - g.FontSize ) * 0.5f ), ImMax( 0.0f, ( size.y - g.FontSize ) * 0.5f ) ), text_col, dir );

	return pressed;
}

bool ImGui::ArrowButton( const char* str_id, ImGuiDir dir )
{
	float sz = GetFrameHeight();
	return ArrowButtonEx( str_id, dir, ImVec2( sz, sz ), ImGuiButtonFlags_None );
}

// Button to close a window
bool ImGui::CloseButton( ImGuiID id, const ImVec2& pos )//, float size)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	// We intentionally allow interaction when clipped so that a mechanical Alt,Right,Validate sequence close a window.
	// (this isn't the regular behavior of buttons, but it doesn't affect the user much because navigation tends to keep items visible).
	const ImRect bb( pos, pos + ImVec2( g.FontSize, g.FontSize ) + g.Style.FramePadding * 2.0f );
	bool is_clipped = !ItemAdd( bb, id );

	bool hovered, held;
	bool pressed = ButtonBehavior( bb, id, &hovered, &held );
	if( is_clipped )
		return pressed;

	// Render
	ImU32 col = GetColorU32( held ? ImGuiCol_ButtonActive : ImGuiCol_ButtonHovered );
	ImVec2 center = bb.GetCenter();
	if( hovered )
		window->DrawList->AddCircleFilled( center, ImMax( 2.0f, g.FontSize * 0.5f + 1.0f ), col, 12 );

	float cross_extent = g.FontSize * 0.5f * 0.7071f - 1.0f;
	ImU32 cross_col = GetColorU32( ImGuiCol_Text );
	center -= ImVec2( 0.5f, 0.5f );
	window->DrawList->AddLine( center + ImVec2( +cross_extent, +cross_extent ), center + ImVec2( -cross_extent, -cross_extent ), cross_col, 1.0f );
	window->DrawList->AddLine( center + ImVec2( +cross_extent, -cross_extent ), center + ImVec2( -cross_extent, +cross_extent ), cross_col, 1.0f );

	return pressed;
}

bool ImGui::CollapseButton( ImGuiID id, const ImVec2& pos )
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	ImRect bb( pos, pos + ImVec2( g.FontSize, g.FontSize ) + g.Style.FramePadding * 2.0f );
	ItemAdd( bb, id );
	bool hovered, held;
	bool pressed = ButtonBehavior( bb, id, &hovered, &held, ImGuiButtonFlags_None );

	// Render
	ImU32 bg_col = GetColorU32( ( held && hovered ) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button );
	ImU32 text_col = GetColorU32( ImGuiCol_Text );
	ImVec2 center = bb.GetCenter();
	if( hovered || held )
		window->DrawList->AddCircleFilled( center/*+ ImVec2(0.0f, -0.5f)*/, g.FontSize * 0.5f + 1.0f, bg_col, 12 );
	RenderArrow( window->DrawList, bb.Min + g.Style.FramePadding, text_col, window->Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f );

	// Switch to moving the window after mouse is moved beyond the initial drag threshold
	if( IsItemActive() && IsMouseDragging( 0 ) )
		StartMouseMovingWindow( window );

	return pressed;
}

ImGuiID ImGui::GetWindowScrollbarID( ImGuiWindow* window, ImGuiAxis axis )
{
	return window->GetIDNoKeepAlive( axis == ImGuiAxis_X ? SECURE("#SCROLLX") : SECURE("#SCROLLY") );
}

// Return scrollbar rectangle, must only be called for corresponding axis if window->ScrollbarX/Y is set.
ImRect ImGui::GetWindowScrollbarRect( ImGuiWindow* window, ImGuiAxis axis )
{
	const ImRect outer_rect = window->Rect();
	const ImRect inner_rect = window->InnerRect;
	const float border_size = window->WindowBorderSize;
	const float scrollbar_size = window->ScrollbarSizes[ axis ^ 1 ]; // (ScrollbarSizes.x = width of Y scrollbar; ScrollbarSizes.y = height of X scrollbar)
	IM_ASSERT( scrollbar_size > 0.0f );
	if( axis == ImGuiAxis_X )
		return ImRect( inner_rect.Min.x, ImMax( outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size ), inner_rect.Max.x, outer_rect.Max.y );
	else
		return ImRect( ImMax( outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size ), inner_rect.Min.y, outer_rect.Max.x, inner_rect.Max.y );
}

void ImGui::Scrollbar( ImGuiAxis axis )
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	const ImGuiID id = GetWindowScrollbarID( window, axis );
	KeepAliveID( id );

	// Calculate scrollbar bounding box
	ImRect bb = GetWindowScrollbarRect( window, axis );
	ImDrawCornerFlags rounding_corners = 0;
	if( axis == ImGuiAxis_X )
	{
		rounding_corners |= ImDrawCornerFlags_BotLeft;
		if( !window->ScrollbarY )
			rounding_corners |= ImDrawCornerFlags_BotRight;
	}
	else
	{
		if( ( window->Flags & ImGuiWindowFlags_NoTitleBar ) && !( window->Flags & ImGuiWindowFlags_MenuBar ) )
			rounding_corners |= ImDrawCornerFlags_TopRight;
		if( !window->ScrollbarX )
			rounding_corners |= ImDrawCornerFlags_BotRight;
	}
	float size_avail = window->InnerRect.Max[ axis ] - window->InnerRect.Min[ axis ];
	float size_contents = window->ContentSize[ axis ] + window->WindowPadding[ axis ] * 2.0f;
	ScrollbarEx( bb, id, axis, &window->Scroll[ axis ], size_avail, size_contents, rounding_corners );
}

// Vertical/Horizontal scrollbar
// The entire piece of code below is rather confusing because:
// - We handle absolute seeking (when first clicking outside the grab) and relative manipulation (afterward or when clicking inside the grab)
// - We store values as normalized ratio and in a form that allows the window content to change while we are holding on a scrollbar
// - We handle both horizontal and vertical scrollbars, which makes the terminology not ideal.
// Still, the code should probably be made simpler..
bool ImGui::ScrollbarEx( const ImRect& bb_frame, ImGuiID id, ImGuiAxis axis, float* p_scroll_v, float size_avail_v, float size_contents_v, ImDrawCornerFlags rounding_corners )
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	if( window->SkipItems )
		return false;

	const float bb_frame_width = bb_frame.GetWidth();
	const float bb_frame_height = bb_frame.GetHeight();
	if( bb_frame_width <= 0.0f || bb_frame_height <= 0.0f )
		return false;

	// When we are too small, start hiding and disabling the grab (this reduce visual noise on very small window and facilitate using the window resize grab)
	float alpha = 1.0f;
	if( ( axis == ImGuiAxis_Y ) && bb_frame_height < g.FontSize + g.Style.FramePadding.y * 2.0f )
		alpha = ImSaturate( ( bb_frame_height - g.FontSize ) / ( g.Style.FramePadding.y * 2.0f ) );
	if( alpha <= 0.0f )
		return false;

	const ImGuiStyle& style = g.Style;
	const bool allow_interaction = ( alpha >= 1.0f );

	ImRect bb = bb_frame;
	bb.Expand( ImVec2( -ImClamp( IM_FLOOR( ( bb_frame_width - 2.0f ) * 0.5f ), 0.0f, 3.0f ), -ImClamp( IM_FLOOR( ( bb_frame_height - 2.0f ) * 0.5f ), 0.0f, 3.0f ) ) );

	// V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)
	const float scrollbar_size_v = ( axis == ImGuiAxis_X ) ? bb.GetWidth() : bb.GetHeight();

	// Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)
	// But we maintain a minimum size in pixel to allow for the user to still aim inside.
	IM_ASSERT( ImMax( size_contents_v, size_avail_v ) > 0.0f ); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.
	const float win_size_v = ImMax( ImMax( size_contents_v, size_avail_v ), 1.0f );
	const float grab_h_pixels = ImClamp( scrollbar_size_v * ( size_avail_v / win_size_v ), style.GrabMinSize, scrollbar_size_v );
	const float grab_h_norm = grab_h_pixels / scrollbar_size_v;

	// Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().
	bool held = false;
	bool hovered = false;
	ButtonBehavior( bb, id, &hovered, &held, ImGuiButtonFlags_NoNavFocus );

	float scroll_max = ImMax( 1.0f, size_contents_v - size_avail_v );
	float scroll_ratio = ImSaturate( *p_scroll_v / scroll_max );
	float grab_v_norm = scroll_ratio * ( scrollbar_size_v - grab_h_pixels ) / scrollbar_size_v; // Grab position in normalized space
	if( held && allow_interaction && grab_h_norm < 1.0f )
	{
		float scrollbar_pos_v = bb.Min[ axis ];
		float mouse_pos_v = g.IO.MousePos[ axis ];

		// Click position in scrollbar normalized space (0.0f->1.0f)
		const float clicked_v_norm = ImSaturate( ( mouse_pos_v - scrollbar_pos_v ) / scrollbar_size_v );
		SetHoveredID( id );

		bool seek_absolute = false;
		if( g.ActiveIdIsJustActivated )
		{
			// On initial click calculate the distance between mouse and the center of the grab
			seek_absolute = ( clicked_v_norm < grab_v_norm || clicked_v_norm > grab_v_norm + grab_h_norm );
			if( seek_absolute )
				g.ScrollbarClickDeltaToGrabCenter = 0.0f;
			else
				g.ScrollbarClickDeltaToGrabCenter = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;
		}

		// Apply scroll (p_scroll_v will generally point on one member of window->Scroll)
		// It is ok to modify Scroll here because we are being called in Begin() after the calculation of ContentSize and before setting up our starting position
		const float scroll_v_norm = ImSaturate( ( clicked_v_norm - g.ScrollbarClickDeltaToGrabCenter - grab_h_norm * 0.5f ) / ( 1.0f - grab_h_norm ) );
		*p_scroll_v = IM_ROUND( scroll_v_norm * scroll_max );//(win_size_contents_v - win_size_v));

		// Update values for rendering
		scroll_ratio = ImSaturate( *p_scroll_v / scroll_max );
		grab_v_norm = scroll_ratio * ( scrollbar_size_v - grab_h_pixels ) / scrollbar_size_v;

		// Update distance to grab now that we have seeked and saturated
		if( seek_absolute )
			g.ScrollbarClickDeltaToGrabCenter = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;
	}

	// Render
	const ImU32 bg_col = GetColorU32( ImGuiCol_ScrollbarBg );
	const ImU32 grab_col = GetColorU32( held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab, alpha );
	window->DrawList->AddRectFilled( bb_frame.Min, bb_frame.Max, bg_col, window->WindowRounding, rounding_corners );
	ImRect grab_rect;
	if( axis == ImGuiAxis_X )
		grab_rect = ImRect( ImLerp( bb.Min.x, bb.Max.x, grab_v_norm ), bb.Min.y, ImLerp( bb.Min.x, bb.Max.x, grab_v_norm ) + grab_h_pixels, bb.Max.y );
	else
		grab_rect = ImRect( bb.Min.x, ImLerp( bb.Min.y, bb.Max.y, grab_v_norm ), bb.Max.x, ImLerp( bb.Min.y, bb.Max.y, grab_v_norm ) + grab_h_pixels );
	window->DrawList->AddRectFilled( grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding );

	return held;
}

void ImGui::Image( ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return;

	ImRect bb( window->DC.CursorPos, window->DC.CursorPos + size );
	if( border_col.w > 0.0f )
		bb.Max += ImVec2( 2, 2 );
	ItemSize( bb );
	if( !ItemAdd( bb, 0 ) )
		return;

	if( border_col.w > 0.0f )
	{
		window->DrawList->AddRect( bb.Min, bb.Max, GetColorU32( border_col ), 0.0f );
		window->DrawList->AddImage( user_texture_id, bb.Min + ImVec2( 1, 1 ), bb.Max - ImVec2( 1, 1 ), uv0, uv1, GetColorU32( tint_col ) );
	}
	else
	{
		window->DrawList->AddImage( user_texture_id, bb.Min, bb.Max, uv0, uv1, GetColorU32( tint_col ) );
	}
}

// frame_padding < 0: uses FramePadding from style (default)
// frame_padding = 0: no framing
// frame_padding > 0: set framing size
// The color used are the button colors.
bool ImGui::ImageButton( ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;

	// Default to using texture ID as ID. User can still push string/integer prefixes.
	// We could hash the size/uv to create a unique ID but that would prevent the user from animating UV.
	PushID( ( void* )( intptr_t )user_texture_id );
	const ImGuiID id = window->GetID( SECURE("#image") );
	PopID();

	const ImVec2 padding = ( frame_padding >= 0 ) ? ImVec2( ( float )frame_padding, ( float )frame_padding ) : style.FramePadding;
	const ImRect bb( window->DC.CursorPos, window->DC.CursorPos + size + padding * 2 );
	const ImRect image_bb( window->DC.CursorPos + padding, window->DC.CursorPos + padding + size );
	ItemSize( bb );
	if( !ItemAdd( bb, id ) )
		return false;

	bool hovered, held;
	bool pressed = ButtonBehavior( bb, id, &hovered, &held );

	// Render
	const ImU32 col = GetColorU32( ( held && hovered ) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button );
	RenderNavHighlight( bb, id );
	RenderFrame( bb.Min, bb.Max, col, true, ImClamp( ( float )ImMin( padding.x, padding.y ), 0.0f, style.FrameRounding ) );
	if( bg_col.w > 0.0f )
		window->DrawList->AddRectFilled( image_bb.Min, image_bb.Max, GetColorU32( bg_col ) );
	window->DrawList->AddImage( user_texture_id, image_bb.Min, image_bb.Max, uv0, uv1, GetColorU32( tint_col ) );

	return pressed;
}

bool ImGui::Checkbox( const char* label, bool* v )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID( label );
	const ImVec2 label_size = CalcTextSize( label, NULL, true );

	const float square_sz = GetFrameHeight();
	const ImVec2 pos = window->DC.CursorPos;
	const ImRect total_bb( pos, pos + ImVec2( square_sz + ( label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f ), label_size.y + style.FramePadding.y * 2.0f ) );
	ItemSize( total_bb, style.FramePadding.y );
	if( !ItemAdd( total_bb, id ) )
		return false;

	bool hovered, held;
	bool pressed = ButtonBehavior( total_bb, id, &hovered, &held );
	if( pressed )
	{
		*v = !( *v );
		MarkItemEdited( id );
	}

	const ImRect check_bb( pos, pos + ImVec2( square_sz, square_sz ) );
	RenderNavHighlight( total_bb, id );
	RenderFrame( check_bb.Min, check_bb.Max, GetColorU32( ( held && hovered ) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg ), true, style.FrameRounding );
	ImU32 check_col = GetColorU32( ImGuiCol_CheckMark );
	if( window->DC.ItemFlags & ImGuiItemFlags_MixedValue )
	{
		// Undocumented tristate/mixed/indeterminate checkbox (#2644)
		ImVec2 pad( ImMax( 1.0f, IM_FLOOR( square_sz / 3.6f ) ), ImMax( 1.0f, IM_FLOOR( square_sz / 3.6f ) ) );
		window->DrawList->AddRectFilled( check_bb.Min + pad, check_bb.Max - pad, check_col, style.FrameRounding );
	}
	else if( *v )
	{
		const float pad = ImMax( 1.0f, IM_FLOOR( square_sz / 6.0f ) );
		RenderCheckMark( window->DrawList, check_bb.Min + ImVec2( pad, pad ), check_col, square_sz - pad * 2.0f );
	}

	if( g.LogEnabled )
		LogRenderedText( &total_bb.Min, *v ? SECURE("[x]") : SECURE("[ ]") );
	if( label_size.x > 0.0f )
		RenderText( ImVec2( check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y ), label );

	IMGUI_TEST_ENGINE_ITEM_INFO( id, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Checkable | ( *v ? ImGuiItemStatusFlags_Checked : 0 ) );
	return pressed;
}

bool ImGui::CheckboxFlags( const char* label, unsigned int* flags, unsigned int flags_value )
{
	bool v = ( ( *flags & flags_value ) == flags_value );
	bool pressed = Checkbox( label, &v );
	if( pressed )
	{
		if( v )
			*flags |= flags_value;
		else
			*flags &= ~flags_value;
	}

	return pressed;
}

bool ImGui::RadioButton( const char* label, bool active )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID( label );
	const ImVec2 label_size = CalcTextSize( label, NULL, true );

	const float square_sz = GetFrameHeight();
	const ImVec2 pos = window->DC.CursorPos;
	const ImRect check_bb( pos, pos + ImVec2( square_sz, square_sz ) );
	const ImRect total_bb( pos, pos + ImVec2( square_sz + ( label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f ), label_size.y + style.FramePadding.y * 2.0f ) );
	ItemSize( total_bb, style.FramePadding.y );
	if( !ItemAdd( total_bb, id ) )
		return false;

	ImVec2 center = check_bb.GetCenter();
	center.x = IM_ROUND( center.x );
	center.y = IM_ROUND( center.y );
	const float radius = ( square_sz - 1.0f ) * 0.5f;

	bool hovered, held;
	bool pressed = ButtonBehavior( total_bb, id, &hovered, &held );
	if( pressed )
		MarkItemEdited( id );

	RenderNavHighlight( total_bb, id );
	window->DrawList->AddCircleFilled( center, radius, GetColorU32( ( held && hovered ) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg ), 16 );
	if( active )
	{
		const float pad = ImMax( 1.0f, IM_FLOOR( square_sz / 6.0f ) );
		window->DrawList->AddCircleFilled( center, radius - pad, GetColorU32( ImGuiCol_CheckMark ), 16 );
	}

	if( style.FrameBorderSize > 0.0f )
	{
		window->DrawList->AddCircle( center + ImVec2( 1, 1 ), radius, GetColorU32( ImGuiCol_BorderShadow ), 16, style.FrameBorderSize );
		window->DrawList->AddCircle( center, radius, GetColorU32( ImGuiCol_Border ), 16, style.FrameBorderSize );
	}

	if( g.LogEnabled )
		LogRenderedText( &total_bb.Min, active ? SECURE("(x)") : SECURE("( )") );
	if( label_size.x > 0.0f )
		RenderText( ImVec2( check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y ), label );

	IMGUI_TEST_ENGINE_ITEM_INFO( id, label, window->DC.ItemFlags );
	return pressed;
}

// FIXME: This would work nicely if it was a public template, e.g. 'template<T> RadioButton(const char* label, T* v, T v_button)', but I'm not sure how we would expose it..
bool ImGui::RadioButton( const char* label, int* v, int v_button )
{
	const bool pressed = RadioButton( label, *v == v_button );
	if( pressed )
		*v = v_button;
	return pressed;
}

// size_arg (for each axis) < 0.0f: align to end, 0.0f: auto, > 0.0f: specified size
void ImGui::ProgressBar( float fraction, const ImVec2& size_arg, const char* overlay )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;

	ImVec2 pos = window->DC.CursorPos;
	ImVec2 size = CalcItemSize( size_arg, CalcItemWidth(), g.FontSize + style.FramePadding.y * 2.0f );
	ImRect bb( pos, pos + size );
	ItemSize( size, style.FramePadding.y );
	if( !ItemAdd( bb, 0 ) )
		return;

	// Render
	fraction = ImSaturate( fraction );
	RenderFrame( bb.Min, bb.Max, GetColorU32( ImGuiCol_FrameBg ), true, style.FrameRounding );
	bb.Expand( ImVec2( -style.FrameBorderSize, -style.FrameBorderSize ) );
	const ImVec2 fill_br = ImVec2( ImLerp( bb.Min.x, bb.Max.x, fraction ), bb.Max.y );
	RenderRectFilledRangeH( window->DrawList, bb, GetColorU32( ImGuiCol_PlotHistogram ), 0.0f, fraction, style.FrameRounding );

	// Default displaying the fraction as percentage string, but user can override it
	char overlay_buf[ 32 ];
	if( !overlay )
	{
		ImFormatString( overlay_buf, IM_ARRAYSIZE( overlay_buf ), SECURE("%.0f%%"), fraction * 100 + 0.01f );
		overlay = overlay_buf;
	}

	ImVec2 overlay_size = CalcTextSize( overlay, NULL );
	if( overlay_size.x > 0.0f )
		RenderTextClipped( ImVec2( ImClamp( fill_br.x + style.ItemSpacing.x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x ), bb.Min.y ), bb.Max, overlay, NULL, &overlay_size, ImVec2( 0.0f, 0.5f ), &bb );
}

void ImGui::Bullet()
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const float line_height = ImMax( ImMin( window->DC.CurrLineSize.y, g.FontSize + g.Style.FramePadding.y * 2 ), g.FontSize );
	const ImRect bb( window->DC.CursorPos, window->DC.CursorPos + ImVec2( g.FontSize, line_height ) );
	ItemSize( bb );
	if( !ItemAdd( bb, 0 ) )
	{
		SameLine( 0, style.FramePadding.x * 2 );
		return;
	}

	// Render and stay on same line
	ImU32 text_col = GetColorU32( ImGuiCol_Text );
	RenderBullet( window->DrawList, bb.Min + ImVec2( style.FramePadding.x + g.FontSize * 0.5f, line_height * 0.5f ), text_col );
	SameLine( 0, style.FramePadding.x * 2.0f );
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Low-level Layout helpers
//-------------------------------------------------------------------------
// - Spacing()
// - Dummy()
// - NewLine()
// - AlignTextToFramePadding()
// - SeparatorEx() [Internal]
// - Separator()
// - SplitterBehavior() [Internal]
// - ShrinkWidths() [Internal]
//-------------------------------------------------------------------------

void ImGui::Spacing()
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return;
	ItemSize( ImVec2( 0, 0 ) );
}

void ImGui::Dummy( const ImVec2& size )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return;

	const ImRect bb( window->DC.CursorPos, window->DC.CursorPos + size );
	ItemSize( size );
	ItemAdd( bb, 0 );
}

void ImGui::NewLine()
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return;

	ImGuiContext& g = *GImGui;
	const ImGuiLayoutType backup_layout_type = window->DC.LayoutType;
	window->DC.LayoutType = ImGuiLayoutType_Vertical;
	if( window->DC.CurrLineSize.y > 0.0f )     // In the event that we are on a line with items that is smaller that FontSize high, we will preserve its height.
		ItemSize( ImVec2( 0, 0 ) );
	else
		ItemSize( ImVec2( 0.0f, g.FontSize ) );
	window->DC.LayoutType = backup_layout_type;
}

void ImGui::AlignTextToFramePadding()
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return;

	ImGuiContext& g = *GImGui;
	window->DC.CurrLineSize.y = ImMax( window->DC.CurrLineSize.y, g.FontSize + g.Style.FramePadding.y * 2 );
	window->DC.CurrLineTextBaseOffset = ImMax( window->DC.CurrLineTextBaseOffset, g.Style.FramePadding.y );
}

// Horizontal/vertical separating line
void ImGui::SeparatorEx( ImGuiSeparatorFlags flags )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return;

	ImGuiContext& g = *GImGui;
	IM_ASSERT( ImIsPowerOfTwo( flags & ( ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical ) ) );   // Check that only 1 option is selected

	float thickness_draw = 1.0f;
	float thickness_layout = 0.0f;
	if( flags & ImGuiSeparatorFlags_Vertical )
	{
		// Vertical separator, for menu bars (use current line height). Not exposed because it is misleading and it doesn't have an effect on regular layout.
		float y1 = window->DC.CursorPos.y;
		float y2 = window->DC.CursorPos.y + window->DC.CurrLineSize.y;
		const ImRect bb( ImVec2( window->DC.CursorPos.x, y1 ), ImVec2( window->DC.CursorPos.x + thickness_draw, y2 ) );
		ItemSize( ImVec2( thickness_layout, 0.0f ) );
		if( !ItemAdd( bb, 0 ) )
			return;

		// Draw
		window->DrawList->AddLine( ImVec2( bb.Min.x, bb.Min.y ), ImVec2( bb.Min.x, bb.Max.y ), GetColorU32( ImGuiCol_Separator ) );
		if( g.LogEnabled )
			LogText( SECURE(" |") );
	}
	else if( flags & ImGuiSeparatorFlags_Horizontal )
	{
		// Horizontal Separator
		float x1 = window->Pos.x;
		float x2 = window->Pos.x + window->Size.x;
		if( !window->DC.GroupStack.empty() )
			x1 += window->DC.Indent.x;

		ImGuiColumns* columns = ( flags & ImGuiSeparatorFlags_SpanAllColumns ) ? window->DC.CurrentColumns : NULL;
		if( columns )
			PushColumnsBackground();

		// We don't provide our width to the layout so that it doesn't get feed back into AutoFit
		const ImRect bb( ImVec2( x1, window->DC.CursorPos.y ), ImVec2( x2, window->DC.CursorPos.y + thickness_draw ) );
		ItemSize( ImVec2( 0.0f, thickness_layout ) );
		const bool item_visible = ItemAdd( bb, 0 );
		if( item_visible )
		{
			// Draw
			window->DrawList->AddLine( bb.Min, ImVec2( bb.Max.x, bb.Min.y ), GetColorU32( ImGuiCol_Separator ) );
			if( g.LogEnabled )
				LogRenderedText( &bb.Min, SECURE("--------------------------------") );
		}
		if( columns )
		{
			PopColumnsBackground();
			columns->LineMinY = window->DC.CursorPos.y;
		}
	}
}

void ImGui::Separator()
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	if( window->SkipItems )
		return;

	// Those flags should eventually be overridable by the user
	ImGuiSeparatorFlags flags = ( window->DC.LayoutType == ImGuiLayoutType_Horizontal ) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;
	flags |= ImGuiSeparatorFlags_SpanAllColumns;
	SeparatorEx( flags );
}

// Using 'hover_visibility_delay' allows us to hide the highlight and mouse cursor for a short time, which can be convenient to reduce visual noise.
bool ImGui::SplitterBehavior( const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay )
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;
	window->DC.ItemFlags |= ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus;
	bool item_add = ItemAdd( bb, id );
	window->DC.ItemFlags = item_flags_backup;
	if( !item_add )
		return false;

	bool hovered, held;
	ImRect bb_interact = bb;
	bb_interact.Expand( axis == ImGuiAxis_Y ? ImVec2( 0.0f, hover_extend ) : ImVec2( hover_extend, 0.0f ) );
	ButtonBehavior( bb_interact, id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_AllowItemOverlap );
	if( g.ActiveId != id )
		SetItemAllowOverlap();

	if( held || ( g.HoveredId == id && g.HoveredIdPreviousFrame == id && g.HoveredIdTimer >= hover_visibility_delay ) )
		SetMouseCursor( axis == ImGuiAxis_Y ? ImGuiMouseCursor_ResizeNS : ImGuiMouseCursor_ResizeEW );

	ImRect bb_render = bb;
	if( held )
	{
		ImVec2 mouse_delta_2d = g.IO.MousePos - g.ActiveIdClickOffset - bb_interact.Min;
		float mouse_delta = ( axis == ImGuiAxis_Y ) ? mouse_delta_2d.y : mouse_delta_2d.x;

		// Minimum pane size
		float size_1_maximum_delta = ImMax( 0.0f, *size1 - min_size1 );
		float size_2_maximum_delta = ImMax( 0.0f, *size2 - min_size2 );
		if( mouse_delta < -size_1_maximum_delta )
			mouse_delta = -size_1_maximum_delta;
		if( mouse_delta > size_2_maximum_delta )
			mouse_delta = size_2_maximum_delta;

		// Apply resize
		if( mouse_delta != 0.0f )
		{
			if( mouse_delta < 0.0f )
				IM_ASSERT( *size1 + mouse_delta >= min_size1 );
			if( mouse_delta > 0.0f )
				IM_ASSERT( *size2 - mouse_delta >= min_size2 );
			*size1 += mouse_delta;
			*size2 -= mouse_delta;
			bb_render.Translate( ( axis == ImGuiAxis_X ) ? ImVec2( mouse_delta, 0.0f ) : ImVec2( 0.0f, mouse_delta ) );
			MarkItemEdited( id );
		}
	}

	// Render
	const ImU32 col = GetColorU32( held ? ImGuiCol_SeparatorActive : ( hovered && g.HoveredIdTimer >= hover_visibility_delay ) ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator );
	window->DrawList->AddRectFilled( bb_render.Min, bb_render.Max, col, 0.0f );

	return held;
}

static int IMGUI_CDECL ShrinkWidthItemComparer( const void* lhs, const void* rhs )
{
	const ImGuiShrinkWidthItem* a = ( const ImGuiShrinkWidthItem* )lhs;
	const ImGuiShrinkWidthItem* b = ( const ImGuiShrinkWidthItem* )rhs;
	if( int d = ( int )( b->Width - a->Width ) )
		return d;
	return ( b->Index - a->Index );
}

// Shrink excess width from a set of item, by removing width from the larger items first.
void ImGui::ShrinkWidths( ImGuiShrinkWidthItem* items, int count, float width_excess )
{
	if( count == 1 )
	{
		items[ 0 ].Width = ImMax( items[ 0 ].Width - width_excess, 1.0f );
		return;
	}
	ImQsort( items, ( size_t )count, sizeof( ImGuiShrinkWidthItem ), ShrinkWidthItemComparer );
	int count_same_width = 1;
	while( width_excess > 0.0f && count_same_width < count )
	{
		while( count_same_width < count && items[ 0 ].Width <= items[ count_same_width ].Width )
			count_same_width++;
		float max_width_to_remove_per_item = ( count_same_width < count ) ? ( items[ 0 ].Width - items[ count_same_width ].Width ) : ( items[ 0 ].Width - 1.0f );
		float width_to_remove_per_item = ImMin( width_excess / count_same_width, max_width_to_remove_per_item );
		for( int item_n = 0; item_n < count_same_width; item_n++ )
			items[ item_n ].Width -= width_to_remove_per_item;
		width_excess -= width_to_remove_per_item * count_same_width;
	}

	// Round width and redistribute remainder left-to-right (could make it an option of the function?)
	// Ensure that e.g. the right-most tab of a shrunk tab-bar always reaches exactly at the same distance from the right-most edge of the tab bar separator.
	width_excess = 0.0f;
	for( int n = 0; n < count; n++ )
	{
		float width_rounded = ImFloor( items[ n ].Width );
		width_excess += items[ n ].Width - width_rounded;
		items[ n ].Width = width_rounded;
	}
	if( width_excess > 0.0f )
		for( int n = 0; n < count; n++ )
			if( items[ n ].Index < ( int )( width_excess + 0.01f ) )
				items[ n ].Width += 1.0f;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ComboBox
//-------------------------------------------------------------------------
// - BeginCombo()
// - EndCombo()
// - Combo()
//-------------------------------------------------------------------------

static float CalcMaxPopupHeightFromItemCount( int items_count )
{
	ImGuiContext& g = *GImGui;
	if( items_count <= 0 )
		return FLT_MAX;
	return ( g.FontSize + g.Style.ItemSpacing.y ) * items_count - g.Style.ItemSpacing.y + ( g.Style.WindowPadding.y * 2 );
}

bool ImGui::BeginCombo( const char* label, const char* preview_value, ImGuiComboFlags flags )
{
	// Always consume the SetNextWindowSizeConstraint() call in our early return paths
	ImGuiContext& g = *GImGui;
	bool has_window_size_constraint = ( g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint ) != 0;
	g.NextWindowData.Flags &= ~ImGuiNextWindowDataFlags_HasSizeConstraint;

	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	IM_ASSERT( ( flags & ( ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview ) ) != ( ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview ) ); // Can't use both flags together

	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID( label );

	const float arrow_size = ( flags & ImGuiComboFlags_NoArrowButton ) ? 0.0f : GetFrameHeight();
	const ImVec2 label_size = CalcTextSize( label, NULL, true );
	const float expected_w = CalcItemWidth();
	const float w = ( flags & ImGuiComboFlags_NoPreview ) ? arrow_size : expected_w;
	const ImRect frame_bb( window->DC.CursorPos, window->DC.CursorPos + ImVec2( w, label_size.y + style.FramePadding.y * 2.0f ) );
	const ImRect total_bb( frame_bb.Min, frame_bb.Max + ImVec2( label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f ) );
	ItemSize( total_bb, style.FramePadding.y );
	if( !ItemAdd( total_bb, id, &frame_bb ) )
		return false;

	bool hovered, held;
	bool pressed = ButtonBehavior( frame_bb, id, &hovered, &held );
	bool popup_open = IsPopupOpen( id );

	const ImU32 frame_col = GetColorU32( hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg );
	const float value_x2 = ImMax( frame_bb.Min.x, frame_bb.Max.x - arrow_size );
	RenderNavHighlight( frame_bb, id );
	if( !( flags & ImGuiComboFlags_NoPreview ) )
		window->DrawList->AddRectFilled( frame_bb.Min, ImVec2( value_x2, frame_bb.Max.y ), frame_col, style.FrameRounding, ( flags & ImGuiComboFlags_NoArrowButton ) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Left );
	if( !( flags & ImGuiComboFlags_NoArrowButton ) )
	{
		ImU32 bg_col = GetColorU32( ( popup_open || hovered ) ? ImGuiCol_ButtonHovered : ImGuiCol_Button );
		ImU32 text_col = GetColorU32( ImGuiCol_Text );
		window->DrawList->AddRectFilled( ImVec2( value_x2, frame_bb.Min.y ), frame_bb.Max, bg_col, style.FrameRounding, ( w <= arrow_size ) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Right );
		if( value_x2 + arrow_size - style.FramePadding.x <= frame_bb.Max.x )
			RenderArrow( window->DrawList, ImVec2( value_x2 + style.FramePadding.y, frame_bb.Min.y + style.FramePadding.y ), text_col, ImGuiDir_Down, 1.0f );
	}
	RenderFrameBorder( frame_bb.Min, frame_bb.Max, style.FrameRounding );
	if( preview_value != NULL && !( flags & ImGuiComboFlags_NoPreview ) )
		RenderTextClipped( frame_bb.Min + style.FramePadding, ImVec2( value_x2, frame_bb.Max.y ), preview_value, NULL, NULL, ImVec2( 0.0f, 0.0f ) );
	if( label_size.x > 0 )
		RenderText( ImVec2( frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y ), label );

	if( ( pressed || g.NavActivateId == id ) && !popup_open )
	{
		if( window->DC.NavLayerCurrent == 0 )
			window->NavLastIds[ 0 ] = id;
		OpenPopupEx( id );
		popup_open = true;
	}

	if( !popup_open )
		return false;

	if( has_window_size_constraint )
	{
		g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSizeConstraint;
		g.NextWindowData.SizeConstraintRect.Min.x = ImMax( g.NextWindowData.SizeConstraintRect.Min.x, w );
	}
	else
	{
		if( ( flags & ImGuiComboFlags_HeightMask_ ) == 0 )
			flags |= ImGuiComboFlags_HeightRegular;
		IM_ASSERT( ImIsPowerOfTwo( flags & ImGuiComboFlags_HeightMask_ ) );    // Only one
		int popup_max_height_in_items = -1;
		if( flags & ImGuiComboFlags_HeightRegular )     popup_max_height_in_items = 8;
		else if( flags & ImGuiComboFlags_HeightSmall )  popup_max_height_in_items = 4;
		else if( flags & ImGuiComboFlags_HeightLarge )  popup_max_height_in_items = 20;
		SetNextWindowSizeConstraints( ImVec2( w, 0.0f ), ImVec2( FLT_MAX, CalcMaxPopupHeightFromItemCount( popup_max_height_in_items ) ) );
	}

	char name[ 16 ];
	ImFormatString( name, IM_ARRAYSIZE( name ), SECURE("##Combo_%02d"), g.BeginPopupStack.Size ); // Recycle windows based on depth

	// Peak into expected window size so we can position it
	if( ImGuiWindow* popup_window = FindWindowByName( name ) )
		if( popup_window->WasActive )
		{
			ImVec2 size_expected = CalcWindowExpectedSize( popup_window );
			if( flags & ImGuiComboFlags_PopupAlignLeft )
				popup_window->AutoPosLastDirection = ImGuiDir_Left;
			ImRect r_outer = GetWindowAllowedExtentRect( popup_window );
			ImVec2 pos = FindBestWindowPosForPopupEx( frame_bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, r_outer, frame_bb, ImGuiPopupPositionPolicy_ComboBox );
			SetNextWindowPos( pos );
		}

	// We don't use BeginPopupEx() solely because we have a custom name string, which we could make an argument to BeginPopupEx()
	ImGuiWindowFlags window_flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoMove;

	// Horizontally align ourselves with the framed text
	PushStyleVar( ImGuiStyleVar_WindowPadding, ImVec2( style.FramePadding.x, style.WindowPadding.y ) );
	bool ret = Begin( name, NULL, window_flags );
	PopStyleVar();
	if( !ret )
	{
		EndPopup();
		IM_ASSERT( 0 );   // This should never happen as we tested for IsPopupOpen() above
		return false;
	}
	return true;
}

void ImGui::EndCombo()
{
	EndPopup();
}

// Getter for the old Combo() API: const char*[]
static bool Items_ArrayGetter( void* data, int idx, const char** out_text )
{
	const char* const* items = ( const char* const* )data;
	if( out_text )
		*out_text = items[ idx ];
	return true;
}

// Getter for the old Combo() API: "item1\0item2\0item3\0"
static bool Items_SingleStringGetter( void* data, int idx, const char** out_text )
{
	// FIXME-OPT: we could pre-compute the indices to fasten this. But only 1 active combo means the waste is limited.
	const char* items_separated_by_zeros = ( const char* )data;
	int items_count = 0;
	const char* p = items_separated_by_zeros;
	while( *p )
	{
		if( idx == items_count )
			break;
		p += strlen( p ) + 1;
		items_count++;
	}
	if( !*p )
		return false;
	if( out_text )
		*out_text = p;
	return true;
}

// Old API, prefer using BeginCombo() nowadays if you can.
bool ImGui::Combo( const char* label, int* current_item, bool ( *items_getter )( void*, int, const char** ), void* data, int items_count, int popup_max_height_in_items )
{
	ImGuiContext& g = *GImGui;

	// Call the getter to obtain the preview string which is a parameter to BeginCombo()
	const char* preview_value = NULL;
	if( *current_item >= 0 && *current_item < items_count )
		items_getter( data, *current_item, &preview_value );

	// The old Combo() API exposed "popup_max_height_in_items". The new more general BeginCombo() API doesn't have/need it, but we emulate it here.
	if( popup_max_height_in_items != -1 && !( g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint ) )
		SetNextWindowSizeConstraints( ImVec2( 0, 0 ), ImVec2( FLT_MAX, CalcMaxPopupHeightFromItemCount( popup_max_height_in_items ) ) );

	if( !BeginCombo( label, preview_value, ImGuiComboFlags_None ) )
		return false;

	// Display items
	// FIXME-OPT: Use clipper (but we need to disable it on the appearing frame to make sure our call to SetItemDefaultFocus() is processed)
	bool value_changed = false;
	for( int i = 0; i < items_count; i++ )
	{
		PushID( ( void* )( intptr_t )i );
		const bool item_selected = ( i == *current_item );
		const char* item_text;
		if( !items_getter( data, i, &item_text ) )
			item_text = SECURE("*Unknown item*");
		if( Selectable( item_text, item_selected ) )
		{
			value_changed = true;
			*current_item = i;
		}
		if( item_selected )
			SetItemDefaultFocus();
		PopID();
	}

	EndCombo();
	return value_changed;
}

// Combo box helper allowing to pass an array of strings.
bool ImGui::Combo( const char* label, int* current_item, const char* const items[], int items_count, int height_in_items )
{
	const bool value_changed = Combo( label, current_item, Items_ArrayGetter, ( void* )items, items_count, height_in_items );
	return value_changed;
}

// Combo box helper allowing to pass all items in a single string literal holding multiple zero-terminated items "item1\0item2\0"
bool ImGui::Combo( const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items )
{
	int items_count = 0;
	const char* p = items_separated_by_zeros;       // FIXME-OPT: Avoid computing this, or at least only when combo is open
	while( *p )
	{
		p += strlen( p ) + 1;
		items_count++;
	}
	bool value_changed = Combo( label, current_item, Items_SingleStringGetter, ( void* )items_separated_by_zeros, items_count, height_in_items );
	return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Data Type and Data Formatting Helpers [Internal]
//-------------------------------------------------------------------------
// - PatchFormatStringFloatToInt()
// - DataTypeGetInfo()
// - DataTypeFormatString()
// - DataTypeApplyOp()
// - DataTypeApplyOpFromText()
// - GetMinimumStepAtDecimalPrecision
// - RoundScalarWithFormat<>()
//-------------------------------------------------------------------------

static const ImGuiDataTypeInfo GDataTypeInfo[] =
{
		{ sizeof( char ),             "%d",   "%d"    },  // ImGuiDataType_S8
		{ sizeof( unsigned char ),    "%u",   "%u"    },
		{ sizeof( short ),            "%d",   "%d"    },  // ImGuiDataType_S16
		{ sizeof( unsigned short ),   "%u",   "%u"    },
		{ sizeof( int ),              "%d",   "%d"    },  // ImGuiDataType_S32
		{ sizeof( unsigned int ),     "%u",   "%u"    },
#ifdef _MSC_VER
		{ sizeof( ImS64 ),            SECURE( "%I64d" ),SECURE("%I64d") },  // ImGuiDataType_S64
		{ sizeof( ImU64 ),            SECURE( "%I64u" ),SECURE("%I64u") },
#else
		{ sizeof( ImS64 ),            "%lld", "%lld"  },  // ImGuiDataType_S64
		{ sizeof( ImU64 ),            "%llu", "%llu"  },
#endif
		{ sizeof( float ),            "%f",   "%f"    },  // ImGuiDataType_Float (float are promoted to double in va_arg)
		{ sizeof( double ),           "%f",   SECURE("%lf")   },  // ImGuiDataType_Double
};
IM_STATIC_ASSERT( IM_ARRAYSIZE( GDataTypeInfo ) == ImGuiDataType_COUNT );

static const char* GetDataTypeFormat( ImGuiDataType data_type )
{
	switch( data_type )
	{
		case ImGuiDataType_S8:
		case ImGuiDataType_S16:
		case ImGuiDataType_S32:
		{
			return SECURE( "%d" );
		}
		case ImGuiDataType_U8:
		case ImGuiDataType_U16:
		case ImGuiDataType_U32:
		{
			return SECURE( "%u" );
		}
		case ImGuiDataType_S64:
		{
			return SECURE( "%I64d" );
		}
		case ImGuiDataType_U64:
		{
			return SECURE( "%I64u" );
		}
		case ImGuiDataType_Float:
		{
			return SECURE( "%f" );
		}
		case ImGuiDataType_Double:
		{
			return SECURE( "%f" );
		}
	}

	return SECURE( "%d" );
}

static const char* GetDataTypeScanFormat( ImGuiDataType data_type )
{
	switch( data_type )
	{
		case ImGuiDataType_S8:
		case ImGuiDataType_S16:
		case ImGuiDataType_S32:
		{
			return SECURE( "%d" );
		}
		case ImGuiDataType_U8:
		case ImGuiDataType_U16:
		case ImGuiDataType_U32:
		{
			return SECURE( "%u" );
		}
		case ImGuiDataType_S64:
		{
			return SECURE( "%I64d" );
		}
		case ImGuiDataType_U64:
		{
			return SECURE( "%I64u" );
		}
		case ImGuiDataType_Float:
		{
			return SECURE( "%f" );
		}
		case ImGuiDataType_Double:
		{
			return SECURE( "%lf" );
		}
	}

	return SECURE( "%d" );
}

// FIXME-LEGACY: Prior to 1.61 our DragInt() function internally used floats and because of this the compile-time default value for format was "%.0f".
// Even though we changed the compile-time default, we expect users to have carried %f around, which would break the display of DragInt() calls.
// To honor backward compatibility we are rewriting the format string, unless IMGUI_DISABLE_OBSOLETE_FUNCTIONS is enabled. What could possibly go wrong?!
static const char* PatchFormatStringFloatToInt( const char* fmt )
{
	if( fmt[ 0 ] == '%' && fmt[ 1 ] == '.' && fmt[ 2 ] == '0' && fmt[ 3 ] == 'f' && fmt[ 4 ] == 0 ) // Fast legacy path for "%.0f" which is expected to be the most common case.
		return SECURE("%d");
	const char* fmt_start = ImParseFormatFindStart( fmt );    // Find % (if any, and ignore %%)
	const char* fmt_end = ImParseFormatFindEnd( fmt_start );  // Find end of format specifier, which itself is an exercise of confidence/recklessness (because snprintf is dependent on libc or user).
	if( fmt_end > fmt_start && fmt_end[ -1 ] == 'f' )
	{
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
		if( fmt_start == fmt && fmt_end[ 0 ] == 0 )
			return SECURE("%d");
		ImGuiContext& g = *GImGui;
		ImFormatString( g.TempBuffer, IM_ARRAYSIZE( g.TempBuffer ), SECURE("%.*s%%d%s"), ( int )( fmt_start - fmt ), fmt, fmt_end ); // Honor leading and trailing decorations, but lose alignment/precision.
		return g.TempBuffer;
#else
		IM_ASSERT( 0 && "DragInt(): Invalid format string!" ); // Old versions used a default parameter of "%.0f", please replace with e.g. "%d"
#endif
	}
	return fmt;
}

const ImGuiDataTypeInfo* ImGui::DataTypeGetInfo( ImGuiDataType data_type )
{
	IM_ASSERT( data_type >= 0 && data_type < ImGuiDataType_COUNT );
	return &GDataTypeInfo[ data_type ];
}

int ImGui::DataTypeFormatString( char* buf, int buf_size, ImGuiDataType data_type, const void* p_data, const char* format )
{
	// Signedness doesn't matter when pushing integer arguments
	if( data_type == ImGuiDataType_S32 || data_type == ImGuiDataType_U32 )
		return ImFormatString( buf, buf_size, format, *( const ImU32* )p_data );
	if( data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64 )
		return ImFormatString( buf, buf_size, format, *( const ImU64* )p_data );
	if( data_type == ImGuiDataType_Float )
		return ImFormatString( buf, buf_size, format, *( const float* )p_data );
	if( data_type == ImGuiDataType_Double )
		return ImFormatString( buf, buf_size, format, *( const double* )p_data );
	if( data_type == ImGuiDataType_S8 )
		return ImFormatString( buf, buf_size, format, *( const ImS8* )p_data );
	if( data_type == ImGuiDataType_U8 )
		return ImFormatString( buf, buf_size, format, *( const ImU8* )p_data );
	if( data_type == ImGuiDataType_S16 )
		return ImFormatString( buf, buf_size, format, *( const ImS16* )p_data );
	if( data_type == ImGuiDataType_U16 )
		return ImFormatString( buf, buf_size, format, *( const ImU16* )p_data );
	IM_ASSERT( 0 );
	return 0;
}

void ImGui::DataTypeApplyOp( ImGuiDataType data_type, int op, void* output, void* arg1, const void* arg2 )
{
	IM_ASSERT( op == '+' || op == '-' );
	switch( data_type )
	{
		case ImGuiDataType_S8:
			if( op == '+' )
			{
				*( ImS8* )output = ImAddClampOverflow( *( const ImS8* )arg1, *( const ImS8* )arg2, IM_S8_MIN, IM_S8_MAX );
			}
			if( op == '-' )
			{
				*( ImS8* )output = ImSubClampOverflow( *( const ImS8* )arg1, *( const ImS8* )arg2, IM_S8_MIN, IM_S8_MAX );
			}
			return;
		case ImGuiDataType_U8:
			if( op == '+' )
			{
				*( ImU8* )output = ImAddClampOverflow( *( const ImU8* )arg1, *( const ImU8* )arg2, IM_U8_MIN, IM_U8_MAX );
			}
			if( op == '-' )
			{
				*( ImU8* )output = ImSubClampOverflow( *( const ImU8* )arg1, *( const ImU8* )arg2, IM_U8_MIN, IM_U8_MAX );
			}
			return;
		case ImGuiDataType_S16:
			if( op == '+' )
			{
				*( ImS16* )output = ImAddClampOverflow( *( const ImS16* )arg1, *( const ImS16* )arg2, IM_S16_MIN, IM_S16_MAX );
			}
			if( op == '-' )
			{
				*( ImS16* )output = ImSubClampOverflow( *( const ImS16* )arg1, *( const ImS16* )arg2, IM_S16_MIN, IM_S16_MAX );
			}
			return;
		case ImGuiDataType_U16:
			if( op == '+' )
			{
				*( ImU16* )output = ImAddClampOverflow( *( const ImU16* )arg1, *( const ImU16* )arg2, IM_U16_MIN, IM_U16_MAX );
			}
			if( op == '-' )
			{
				*( ImU16* )output = ImSubClampOverflow( *( const ImU16* )arg1, *( const ImU16* )arg2, IM_U16_MIN, IM_U16_MAX );
			}
			return;
		case ImGuiDataType_S32:
			if( op == '+' )
			{
				*( ImS32* )output = ImAddClampOverflow( *( const ImS32* )arg1, *( const ImS32* )arg2, IM_S32_MIN, IM_S32_MAX );
			}
			if( op == '-' )
			{
				*( ImS32* )output = ImSubClampOverflow( *( const ImS32* )arg1, *( const ImS32* )arg2, IM_S32_MIN, IM_S32_MAX );
			}
			return;
		case ImGuiDataType_U32:
			if( op == '+' )
			{
				*( ImU32* )output = ImAddClampOverflow( *( const ImU32* )arg1, *( const ImU32* )arg2, IM_U32_MIN, IM_U32_MAX );
			}
			if( op == '-' )
			{
				*( ImU32* )output = ImSubClampOverflow( *( const ImU32* )arg1, *( const ImU32* )arg2, IM_U32_MIN, IM_U32_MAX );
			}
			return;
		case ImGuiDataType_S64:
			if( op == '+' )
			{
				*( ImS64* )output = ImAddClampOverflow( *( const ImS64* )arg1, *( const ImS64* )arg2, IM_S64_MIN, IM_S64_MAX );
			}
			if( op == '-' )
			{
				*( ImS64* )output = ImSubClampOverflow( *( const ImS64* )arg1, *( const ImS64* )arg2, IM_S64_MIN, IM_S64_MAX );
			}
			return;
		case ImGuiDataType_U64:
			if( op == '+' )
			{
				*( ImU64* )output = ImAddClampOverflow( *( const ImU64* )arg1, *( const ImU64* )arg2, IM_U64_MIN, IM_U64_MAX );
			}
			if( op == '-' )
			{
				*( ImU64* )output = ImSubClampOverflow( *( const ImU64* )arg1, *( const ImU64* )arg2, IM_U64_MIN, IM_U64_MAX );
			}
			return;
		case ImGuiDataType_Float:
			if( op == '+' )
			{
				*( float* )output = *( const float* )arg1 + *( const float* )arg2;
			}
			if( op == '-' )
			{
				*( float* )output = *( const float* )arg1 - *( const float* )arg2;
			}
			return;
		case ImGuiDataType_Double:
			if( op == '+' )
			{
				*( double* )output = *( const double* )arg1 + *( const double* )arg2;
			}
			if( op == '-' )
			{
				*( double* )output = *( const double* )arg1 - *( const double* )arg2;
			}
			return;
		case ImGuiDataType_COUNT: break;
	}
	IM_ASSERT( 0 );
}

// User can input math operators (e.g. +100) to edit a numerical values.
// NB: This is _not_ a full expression evaluator. We should probably add one and replace this dumb mess..
bool ImGui::DataTypeApplyOpFromText( const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* p_data, const char* format )
{
	while( ImCharIsBlankA( *buf ) )
		buf++;

	// We don't support '-' op because it would conflict with inputing negative value.
	// Instead you can use +-100 to subtract from an existing value
	char op = buf[ 0 ];
	if( op == '+' || op == '*' || op == '/' )
	{
		buf++;
		while( ImCharIsBlankA( *buf ) )
			buf++;
	}
	else
	{
		op = 0;
	}
	if( !buf[ 0 ] )
		return false;

	// Copy the value in an opaque buffer so we can compare at the end of the function if it changed at all.
	IM_ASSERT( data_type < ImGuiDataType_COUNT );
	int data_backup[ 2 ];
	const ImGuiDataTypeInfo* type_info = ImGui::DataTypeGetInfo( data_type );
	IM_ASSERT( type_info->Size <= sizeof( data_backup ) );
	memcpy( data_backup, p_data, type_info->Size );

	if( format == NULL )
		format = GetDataTypeScanFormat( data_type );
		// format = type_info->ScanFmt;

	// FIXME-LEGACY: The aim is to remove those operators and write a proper expression evaluator at some point..
	int arg1i = 0;
	if( data_type == ImGuiDataType_S32 )
	{
		int* v = ( int* )p_data;
		int arg0i = *v;
		float arg1f = 0.0f;
		if( op && g_map_data.sscanf( initial_value_buf, format, &arg0i ) < 1 )
			return false;
		// Store operand in a float so we can use fractional value for multipliers (*1.1), but constant always parsed as integer so we can fit big integers (e.g. 2000000003) past float precision
		if( op == '+' )
		{
			if( g_map_data.sscanf( buf, SECURE("%d"), &arg1i ) ) *v = ( int )( arg0i + arg1i );
		}                   // Add (use "+-" to subtract)
		else if( op == '*' )
		{
			if( g_map_data.sscanf( buf, SECURE("%f"), &arg1f ) ) *v = ( int )( arg0i * arg1f );
		}                   // Multiply
		else if( op == '/' )
		{
			if( g_map_data.sscanf( buf, SECURE("%f"), &arg1f ) && arg1f != 0.0f ) *v = ( int )( arg0i / arg1f );
		}  // Divide
		else
		{
			if( g_map_data.sscanf( buf, format, &arg1i ) == 1 ) *v = arg1i;
		}                           // Assign constant
	}
	else if( data_type == ImGuiDataType_Float )
	{
		// For floats we have to ignore format with precision (e.g. "%.2f") because sscanf doesn't take them in
		format = SECURE("%f");
		float* v = ( float* )p_data;
		float arg0f = *v, arg1f = 0.0f;
		if( op && g_map_data.sscanf( initial_value_buf, format, &arg0f ) < 1 )
			return false;
		if( g_map_data.sscanf( buf, format, &arg1f ) < 1 )
			return false;
		if( op == '+' )
		{
			*v = arg0f + arg1f;
		}                    // Add (use "+-" to subtract)
		else if( op == '*' )
		{
			*v = arg0f * arg1f;
		}                    // Multiply
		else if( op == '/' )
		{
			if( arg1f != 0.0f ) *v = arg0f / arg1f;
		} // Divide
		else
		{
			*v = arg1f;
		}                            // Assign constant
	}
	else if( data_type == ImGuiDataType_Double )
	{
		format = SECURE("%lf"); // scanf differentiate float/double unlike printf which forces everything to double because of ellipsis
		double* v = ( double* )p_data;
		double arg0f = *v, arg1f = 0.0;
		if( op && g_map_data.sscanf( initial_value_buf, format, &arg0f ) < 1 )
			return false;
		if( g_map_data.sscanf( buf, format, &arg1f ) < 1 )
			return false;
		if( op == '+' )
		{
			*v = arg0f + arg1f;
		}                    // Add (use "+-" to subtract)
		else if( op == '*' )
		{
			*v = arg0f * arg1f;
		}                    // Multiply
		else if( op == '/' )
		{
			if( arg1f != 0.0f ) *v = arg0f / arg1f;
		} // Divide
		else
		{
			*v = arg1f;
		}                            // Assign constant
	}
	else if( data_type == ImGuiDataType_U32 || data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64 )
	{
		// All other types assign constant
		// We don't bother handling support for legacy operators since they are a little too crappy. Instead we will later implement a proper expression evaluator in the future.
		g_map_data.sscanf( buf, format, p_data );
	}
	else
	{
		// Small types need a 32-bit buffer to receive the result from scanf()
		int v32;
		g_map_data.sscanf( buf, format, &v32 );
		if( data_type == ImGuiDataType_S8 )
			*( ImS8* )p_data = ( ImS8 )ImClamp( v32, ( int )IM_S8_MIN, ( int )IM_S8_MAX );
		else if( data_type == ImGuiDataType_U8 )
			*( ImU8* )p_data = ( ImU8 )ImClamp( v32, ( int )IM_U8_MIN, ( int )IM_U8_MAX );
		else if( data_type == ImGuiDataType_S16 )
			*( ImS16* )p_data = ( ImS16 )ImClamp( v32, ( int )IM_S16_MIN, ( int )IM_S16_MAX );
		else if( data_type == ImGuiDataType_U16 )
			*( ImU16* )p_data = ( ImU16 )ImClamp( v32, ( int )IM_U16_MIN, ( int )IM_U16_MAX );
		else
			IM_ASSERT( 0 );
	}

	return memcmp( data_backup, p_data, type_info->Size ) != 0;
}

static float GetMinimumStepAtDecimalPrecision( int decimal_precision )
{
	static const float min_steps[ 10 ] = { 1.0f, 0.1f, 0.01f, 0.001f, 0.0001f, 0.00001f, 0.000001f, 0.0000001f, 0.00000001f, 0.000000001f };
	if( decimal_precision < 0 )
		return FLT_MIN;
	return ( decimal_precision < IM_ARRAYSIZE( min_steps ) ) ? min_steps[ decimal_precision ] : ImPow( 10.0f, ( float )-decimal_precision );
}

template<typename TYPE>
static const char* ImAtoi( const char* src, TYPE* output )
{
	int negative = 0;
	if( *src == '-' )
	{
		negative = 1; src++;
	}
	if( *src == '+' )
	{
		src++;
	}
	TYPE v = 0;
	while( *src >= '0' && *src <= '9' )
		v = ( v * 10 ) + ( *src++ - '0' );
	*output = negative ? -v : v;
	return src;
}

template<typename TYPE, typename SIGNEDTYPE>
TYPE ImGui::RoundScalarWithFormatT( const char* format, ImGuiDataType data_type, TYPE v )
{
	const char* fmt_start = ImParseFormatFindStart( format );
	if( fmt_start[ 0 ] != '%' || fmt_start[ 1 ] == '%' ) // Don't apply if the value is not visible in the format string
		return v;
	char v_str[ 64 ];
	ImFormatString( v_str, IM_ARRAYSIZE( v_str ), fmt_start, v );
	const char* p = v_str;
	while( *p == ' ' )
		p++;
	if( data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double )
		v = ( TYPE )ImAtof( p );
	else
		ImAtoi( p, ( SIGNEDTYPE* )&v );
	return v;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.
//-------------------------------------------------------------------------
// - DragBehaviorT<>() [Internal]
// - DragBehavior() [Internal]
// - DragScalar()
// - DragScalarN()
// - DragFloat()
// - DragFloat2()
// - DragFloat3()
// - DragFloat4()
// - DragFloatRange2()
// - DragInt()
// - DragInt2()
// - DragInt3()
// - DragInt4()
// - DragIntRange2()
//-------------------------------------------------------------------------

// This is called by DragBehavior() when the widget is active (held by mouse or being manipulated with Nav controls)
template<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
bool ImGui::DragBehaviorT( ImGuiDataType data_type, TYPE* v, float v_speed, const TYPE v_min, const TYPE v_max, const char* format, float power, ImGuiDragFlags flags )
{
	ImGuiContext& g = *GImGui;
	const ImGuiAxis axis = ( flags & ImGuiDragFlags_Vertical ) ? ImGuiAxis_Y : ImGuiAxis_X;
	const bool is_decimal = ( data_type == ImGuiDataType_Float ) || ( data_type == ImGuiDataType_Double );
	const bool is_clamped = ( v_min < v_max );
	const bool is_power = ( power != 1.0f && is_decimal && is_clamped && ( v_max - v_min < FLT_MAX ) );
	const bool is_locked = ( v_min > v_max );
	if( is_locked )
		return false;

	// Default tweak speed
	if( v_speed == 0.0f && is_clamped && ( v_max - v_min < FLT_MAX ) )
		v_speed = ( float )( ( v_max - v_min ) * g.DragSpeedDefaultRatio );

	// Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
	float adjust_delta = 0.0f;
	if( g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && g.IO.MouseDragMaxDistanceSqr[ 0 ] > 1.0f * 1.0f )
	{
		adjust_delta = g.IO.MouseDelta[ axis ];
		if( g.IO.KeyAlt )
			adjust_delta *= 1.0f / 100.0f;
		if( g.IO.KeyShift )
			adjust_delta *= 10.0f;
	}
	else if( g.ActiveIdSource == ImGuiInputSource_Nav )
	{
		int decimal_precision = is_decimal ? ImParseFormatPrecision( format, 3 ) : 0;
		adjust_delta = GetNavInputAmount2d( ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f )[ axis ];
		v_speed = ImMax( v_speed, GetMinimumStepAtDecimalPrecision( decimal_precision ) );
	}
	adjust_delta *= v_speed;

	// For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
	if( axis == ImGuiAxis_Y )
		adjust_delta = -adjust_delta;

	// Clear current value on activation
	// Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
	bool is_just_activated = g.ActiveIdIsJustActivated;
	bool is_already_past_limits_and_pushing_outward = is_clamped && ( ( *v >= v_max && adjust_delta > 0.0f ) || ( *v <= v_min && adjust_delta < 0.0f ) );
	bool is_drag_direction_change_with_power = is_power && ( ( adjust_delta < 0 && g.DragCurrentAccum > 0 ) || ( adjust_delta > 0 && g.DragCurrentAccum < 0 ) );
	if( is_just_activated || is_already_past_limits_and_pushing_outward || is_drag_direction_change_with_power )
	{
		g.DragCurrentAccum = 0.0f;
		g.DragCurrentAccumDirty = false;
	}
	else if( adjust_delta != 0.0f )
	{
		g.DragCurrentAccum += adjust_delta;
		g.DragCurrentAccumDirty = true;
	}

	if( !g.DragCurrentAccumDirty )
		return false;

	TYPE v_cur = *v;
	FLOATTYPE v_old_ref_for_accum_remainder = ( FLOATTYPE )0.0f;

	if( is_power )
	{
		// Offset + round to user desired precision, with a curve on the v_min..v_max range to get more precision on one side of the range
		FLOATTYPE v_old_norm_curved = ImPow( ( FLOATTYPE )( v_cur - v_min ) / ( FLOATTYPE )( v_max - v_min ), ( FLOATTYPE )1.0f / power );
		FLOATTYPE v_new_norm_curved = v_old_norm_curved + ( g.DragCurrentAccum / ( v_max - v_min ) );
		v_cur = v_min + ( SIGNEDTYPE )ImPow( ImSaturate( ( float )v_new_norm_curved ), power ) * ( v_max - v_min );
		v_old_ref_for_accum_remainder = v_old_norm_curved;
	}
	else
	{
		v_cur += ( SIGNEDTYPE )g.DragCurrentAccum;
	}

	// Round to user desired precision based on format string
	v_cur = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>( format, data_type, v_cur );

	// Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
	g.DragCurrentAccumDirty = false;
	if( is_power )
	{
		FLOATTYPE v_cur_norm_curved = ImPow( ( FLOATTYPE )( v_cur - v_min ) / ( FLOATTYPE )( v_max - v_min ), ( FLOATTYPE )1.0f / power );
		g.DragCurrentAccum -= ( float )( v_cur_norm_curved - v_old_ref_for_accum_remainder );
	}
	else
	{
		g.DragCurrentAccum -= ( float )( ( SIGNEDTYPE )v_cur - ( SIGNEDTYPE )*v );
	}

	// Lose zero sign for float/double
	if( v_cur == ( TYPE )-0 )
		v_cur = ( TYPE )0;

	// Clamp values (+ handle overflow/wrap-around for integer types)
	if( *v != v_cur && is_clamped )
	{
		if( v_cur < v_min || ( v_cur > * v && adjust_delta < 0.0f && !is_decimal ) )
			v_cur = v_min;
		if( v_cur > v_max || ( v_cur < *v && adjust_delta > 0.0f && !is_decimal ) )
			v_cur = v_max;
	}

	// Apply result
	if( *v == v_cur )
		return false;
	*v = v_cur;
	return true;
}

bool ImGui::DragBehavior( ImGuiID id, ImGuiDataType data_type, void* p_v, float v_speed, const void* p_min, const void* p_max, const char* format, float power, ImGuiDragFlags flags )
{
	ImGuiContext& g = *GImGui;
	if( g.ActiveId == id )
	{
		if( g.ActiveIdSource == ImGuiInputSource_Mouse && !g.IO.MouseDown[ 0 ] )
			ClearActiveID();
		else if( g.ActiveIdSource == ImGuiInputSource_Nav && g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated )
			ClearActiveID();
	}
	if( g.ActiveId != id )
		return false;

	switch( data_type )
	{
		case ImGuiDataType_S8:
		{
			ImS32 v32 = ( ImS32 ) * ( ImS8* )p_v;  bool r = DragBehaviorT<ImS32, ImS32, float>( ImGuiDataType_S32, &v32, v_speed, p_min ? *( const ImS8* )p_min : IM_S8_MIN, p_max ? *( const ImS8* )p_max : IM_S8_MAX, format, power, flags ); if( r ) *( ImS8* )p_v = ( ImS8 )v32; return r;
		}
		case ImGuiDataType_U8:
		{
			ImU32 v32 = ( ImU32 ) * ( ImU8* )p_v;  bool r = DragBehaviorT<ImU32, ImS32, float>( ImGuiDataType_U32, &v32, v_speed, p_min ? *( const ImU8* )p_min : IM_U8_MIN, p_max ? *( const ImU8* )p_max : IM_U8_MAX, format, power, flags ); if( r ) *( ImU8* )p_v = ( ImU8 )v32; return r;
		}
		case ImGuiDataType_S16:
		{
			ImS32 v32 = ( ImS32 ) * ( ImS16* )p_v; bool r = DragBehaviorT<ImS32, ImS32, float>( ImGuiDataType_S32, &v32, v_speed, p_min ? *( const ImS16* )p_min : IM_S16_MIN, p_max ? *( const ImS16* )p_max : IM_S16_MAX, format, power, flags ); if( r ) *( ImS16* )p_v = ( ImS16 )v32; return r;
		}
		case ImGuiDataType_U16:
		{
			ImU32 v32 = ( ImU32 ) * ( ImU16* )p_v; bool r = DragBehaviorT<ImU32, ImS32, float>( ImGuiDataType_U32, &v32, v_speed, p_min ? *( const ImU16* )p_min : IM_U16_MIN, p_max ? *( const ImU16* )p_max : IM_U16_MAX, format, power, flags ); if( r ) *( ImU16* )p_v = ( ImU16 )v32; return r;
		}
		case ImGuiDataType_S32:    return DragBehaviorT<ImS32, ImS32, float >( data_type, ( ImS32* )p_v, v_speed, p_min ? *( const ImS32* )p_min : IM_S32_MIN, p_max ? *( const ImS32* )p_max : IM_S32_MAX, format, power, flags );
		case ImGuiDataType_U32:    return DragBehaviorT<ImU32, ImS32, float >( data_type, ( ImU32* )p_v, v_speed, p_min ? *( const ImU32* )p_min : IM_U32_MIN, p_max ? *( const ImU32* )p_max : IM_U32_MAX, format, power, flags );
		case ImGuiDataType_S64:    return DragBehaviorT<ImS64, ImS64, double>( data_type, ( ImS64* )p_v, v_speed, p_min ? *( const ImS64* )p_min : IM_S64_MIN, p_max ? *( const ImS64* )p_max : IM_S64_MAX, format, power, flags );
		case ImGuiDataType_U64:    return DragBehaviorT<ImU64, ImS64, double>( data_type, ( ImU64* )p_v, v_speed, p_min ? *( const ImU64* )p_min : IM_U64_MIN, p_max ? *( const ImU64* )p_max : IM_U64_MAX, format, power, flags );
		case ImGuiDataType_Float:  return DragBehaviorT<float, float, float >( data_type, ( float* )p_v, v_speed, p_min ? *( const float* )p_min : -FLT_MAX, p_max ? *( const float* )p_max : FLT_MAX, format, power, flags );
		case ImGuiDataType_Double: return DragBehaviorT<double, double, double>( data_type, ( double* )p_v, v_speed, p_min ? *( const double* )p_min : -DBL_MAX, p_max ? *( const double* )p_max : DBL_MAX, format, power, flags );
		case ImGuiDataType_COUNT:  break;
	}
	IM_ASSERT( 0 );
	return false;
}

// Note: p_data, p_min and p_max are _pointers_ to a memory address holding the data. For a Drag widget, p_min and p_max are optional.
// Read code of e.g. SliderFloat(), SliderInt() etc. or examples in 'Demo->Widgets->Data Types' to understand how to use this function directly.
bool ImGui::DragScalar( const char* label, ImGuiDataType data_type, void* p_data, float v_speed, const void* p_min, const void* p_max, const char* format, float power )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	if( power != 1.0f )
		IM_ASSERT( p_min != NULL && p_max != NULL ); // When using a power curve the drag needs to have known bounds

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID( label );
	const float w = CalcItemWidth();
	const ImVec2 label_size = CalcTextSize( label, NULL, true );
	const ImRect frame_bb( window->DC.CursorPos, window->DC.CursorPos + ImVec2( w, label_size.y + style.FramePadding.y * 2.0f ) );
	const ImRect total_bb( frame_bb.Min, frame_bb.Max + ImVec2( label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f ) );

	ItemSize( total_bb, style.FramePadding.y );
	if( !ItemAdd( total_bb, id, &frame_bb ) )
		return false;

	// Default format string when passing NULL
	if( format == NULL )
		format = GetDataTypeFormat( data_type );
	else if( data_type == ImGuiDataType_S32 && strcmp( format, SECURE("%d") ) != 0 ) // (FIXME-LEGACY: Patch old "%.0f" format string to use "%d", read function more details.)
		format = PatchFormatStringFloatToInt( format );

	// Tabbing or CTRL-clicking on Drag turns it into an input box
	const bool hovered = ItemHoverable( frame_bb, id );
	bool temp_input_is_active = TempInputIsActive( id );
	bool temp_input_start = false;
	if( !temp_input_is_active )
	{
		const bool focus_requested = FocusableItemRegister( window, id );
		const bool clicked = ( hovered && g.IO.MouseClicked[ 0 ] );
		const bool double_clicked = ( hovered && g.IO.MouseDoubleClicked[ 0 ] );
		if( focus_requested || clicked || double_clicked || g.NavActivateId == id || g.NavInputId == id )
		{
			SetActiveID( id, window );
			SetFocusID( id, window );
			FocusWindow( window );
			g.ActiveIdUsingNavDirMask = ( 1 << ImGuiDir_Left ) | ( 1 << ImGuiDir_Right );
			if( focus_requested || ( clicked && g.IO.KeyCtrl ) || double_clicked || g.NavInputId == id )
			{
				temp_input_start = true;
				FocusableItemUnregister( window );
			}
		}
	}
	if( temp_input_is_active || temp_input_start )
		return TempInputScalar( frame_bb, id, label, data_type, p_data, format );

	// Draw frame
	const ImU32 frame_col = GetColorU32( g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg );
	RenderNavHighlight( frame_bb, id );
	RenderFrame( frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding );

	// Drag behavior
	const bool value_changed = DragBehavior( id, data_type, p_data, v_speed, p_min, p_max, format, power, ImGuiDragFlags_None );
	if( value_changed )
		MarkItemEdited( id );

	// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
	char value_buf[ 64 ];
	const char* value_buf_end = value_buf + DataTypeFormatString( value_buf, IM_ARRAYSIZE( value_buf ), data_type, p_data, format );
	RenderTextClipped( frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2( 0.5f, 0.5f ) );

	if( label_size.x > 0.0f )
		RenderText( ImVec2( frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y ), label );

	IMGUI_TEST_ENGINE_ITEM_INFO( id, label, window->DC.ItemFlags );
	return value_changed;
}

bool ImGui::DragScalarN( const char* label, ImGuiDataType data_type, void* p_data, int components, float v_speed, const void* p_min, const void* p_max, const char* format, float power )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	bool value_changed = false;
	BeginGroup();
	PushID( label );
	PushMultiItemsWidths( components, CalcItemWidth() );
	size_t type_size = GDataTypeInfo[ data_type ].Size;
	for( int i = 0; i < components; i++ )
	{
		PushID( i );
		if( i > 0 )
			SameLine( 0, g.Style.ItemInnerSpacing.x );
		value_changed |= DragScalar( "", data_type, p_data, v_speed, p_min, p_max, format, power );
		PopID();
		PopItemWidth();
		p_data = ( void* )( ( char* )p_data + type_size );
	}
	PopID();

	const char* label_end = FindRenderedTextEnd( label );
	if( label != label_end )
	{
		SameLine( 0, g.Style.ItemInnerSpacing.x );
		TextEx( label, label_end );
	}

	EndGroup();
	return value_changed;
}

bool ImGui::DragFloat( const char* label, float* v, float v_speed, float v_min, float v_max, const char* format, float power )
{
	return DragScalar( label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, power );
}

bool ImGui::DragFloat2( const char* label, float v[ 2 ], float v_speed, float v_min, float v_max, const char* format, float power )
{
	return DragScalarN( label, ImGuiDataType_Float, v, 2, v_speed, &v_min, &v_max, format, power );
}

bool ImGui::DragFloat3( const char* label, float v[ 3 ], float v_speed, float v_min, float v_max, const char* format, float power )
{
	return DragScalarN( label, ImGuiDataType_Float, v, 3, v_speed, &v_min, &v_max, format, power );
}

bool ImGui::DragFloat4( const char* label, float v[ 4 ], float v_speed, float v_min, float v_max, const char* format, float power )
{
	return DragScalarN( label, ImGuiDataType_Float, v, 4, v_speed, &v_min, &v_max, format, power );
}

bool ImGui::DragFloatRange2( const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* format, const char* format_max, float power )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	PushID( label );
	BeginGroup();
	PushMultiItemsWidths( 2, CalcItemWidth() );

	bool value_changed = DragFloat( SECURE("##min"), v_current_min, v_speed, ( v_min >= v_max ) ? -FLT_MAX : v_min, ( v_min >= v_max ) ? *v_current_max : ImMin( v_max, *v_current_max ), format, power );
	PopItemWidth();
	SameLine( 0, g.Style.ItemInnerSpacing.x );
	value_changed |= DragFloat( SECURE("##max"), v_current_max, v_speed, ( v_min >= v_max ) ? *v_current_min : ImMax( v_min, *v_current_min ), ( v_min >= v_max ) ? FLT_MAX : v_max, format_max ? format_max : format, power );
	PopItemWidth();
	SameLine( 0, g.Style.ItemInnerSpacing.x );

	TextEx( label, FindRenderedTextEnd( label ) );
	EndGroup();
	PopID();
	return value_changed;
}

// NB: v_speed is float to allow adjusting the drag speed with more precision
bool ImGui::DragInt( const char* label, int* v, float v_speed, int v_min, int v_max, const char* format )
{
	return DragScalar( label, ImGuiDataType_S32, v, v_speed, &v_min, &v_max, format );
}

bool ImGui::DragInt2( const char* label, int v[ 2 ], float v_speed, int v_min, int v_max, const char* format )
{
	return DragScalarN( label, ImGuiDataType_S32, v, 2, v_speed, &v_min, &v_max, format );
}

bool ImGui::DragInt3( const char* label, int v[ 3 ], float v_speed, int v_min, int v_max, const char* format )
{
	return DragScalarN( label, ImGuiDataType_S32, v, 3, v_speed, &v_min, &v_max, format );
}

bool ImGui::DragInt4( const char* label, int v[ 4 ], float v_speed, int v_min, int v_max, const char* format )
{
	return DragScalarN( label, ImGuiDataType_S32, v, 4, v_speed, &v_min, &v_max, format );
}

bool ImGui::DragIntRange2( const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* format, const char* format_max )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	PushID( label );
	BeginGroup();
	PushMultiItemsWidths( 2, CalcItemWidth() );

	bool value_changed = DragInt( SECURE("##min"), v_current_min, v_speed, ( v_min >= v_max ) ? INT_MIN : v_min, ( v_min >= v_max ) ? *v_current_max : ImMin( v_max, *v_current_max ), format );
	PopItemWidth();
	SameLine( 0, g.Style.ItemInnerSpacing.x );
	value_changed |= DragInt( SECURE("##max"), v_current_max, v_speed, ( v_min >= v_max ) ? *v_current_min : ImMax( v_min, *v_current_min ), ( v_min >= v_max ) ? INT_MAX : v_max, format_max ? format_max : format );
	PopItemWidth();
	SameLine( 0, g.Style.ItemInnerSpacing.x );

	TextEx( label, FindRenderedTextEnd( label ) );
	EndGroup();
	PopID();

	return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.
//-------------------------------------------------------------------------
// - SliderBehaviorT<>() [Internal]
// - SliderBehavior() [Internal]
// - SliderScalar()
// - SliderScalarN()
// - SliderFloat()
// - SliderFloat2()
// - SliderFloat3()
// - SliderFloat4()
// - SliderAngle()
// - SliderInt()
// - SliderInt2()
// - SliderInt3()
// - SliderInt4()
// - VSliderScalar()
// - VSliderFloat()
// - VSliderInt()
//-------------------------------------------------------------------------

template<typename TYPE, typename FLOATTYPE>
float ImGui::SliderCalcRatioFromValueT( ImGuiDataType data_type, TYPE v, TYPE v_min, TYPE v_max, float power, float linear_zero_pos )
{
	if( v_min == v_max )
		return 0.0f;

	const bool is_power = ( power != 1.0f ) && ( data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double );
	const TYPE v_clamped = ( v_min < v_max ) ? ImClamp( v, v_min, v_max ) : ImClamp( v, v_max, v_min );
	if( is_power )
	{
		if( v_clamped < 0.0f )
		{
			const float f = 1.0f - ( float )( ( v_clamped - v_min ) / ( ImMin( ( TYPE )0, v_max ) - v_min ) );
			return ( 1.0f - ImPow( f, 1.0f / power ) ) * linear_zero_pos;
		}
		else
		{
			const float f = ( float )( ( v_clamped - ImMax( ( TYPE )0, v_min ) ) / ( v_max - ImMax( ( TYPE )0, v_min ) ) );
			return linear_zero_pos + ImPow( f, 1.0f / power ) * ( 1.0f - linear_zero_pos );
		}
	}

	// Linear slider
	return ( float )( ( FLOATTYPE )( v_clamped - v_min ) / ( FLOATTYPE )( v_max - v_min ) );
}

// FIXME: Move some of the code into SliderBehavior(). Current responsibility is larger than what the equivalent DragBehaviorT<> does, we also do some rendering, etc.
template<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
bool ImGui::SliderBehaviorT( const ImRect& bb, ImGuiID id, ImGuiDataType data_type, TYPE* v, const TYPE v_min, const TYPE v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb )
{
	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;

	const ImGuiAxis axis = ( flags & ImGuiSliderFlags_Vertical ) ? ImGuiAxis_Y : ImGuiAxis_X;
	const bool is_decimal = ( data_type == ImGuiDataType_Float ) || ( data_type == ImGuiDataType_Double );
	const bool is_power = ( power != 1.0f ) && is_decimal;

	const float grab_padding = 2.0f;
	const float slider_sz = ( bb.Max[ axis ] - bb.Min[ axis ] ) - grab_padding * 2.0f;
	float grab_sz = style.GrabMinSize;
	SIGNEDTYPE v_range = ( v_min < v_max ? v_max - v_min : v_min - v_max );
	if( !is_decimal && v_range >= 0 )                                             // v_range < 0 may happen on integer overflows
		grab_sz = ImMax( ( float )( slider_sz / ( v_range + 1 ) ), style.GrabMinSize );  // For integer sliders: if possible have the grab size represent 1 unit
	grab_sz = ImMin( grab_sz, slider_sz );
	const float slider_usable_sz = slider_sz - grab_sz;
	const float slider_usable_pos_min = bb.Min[ axis ] + grab_padding + grab_sz * 0.5f;
	const float slider_usable_pos_max = bb.Max[ axis ] - grab_padding - grab_sz * 0.5f;

	// For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f
	float linear_zero_pos;   // 0.0->1.0f
	if( is_power && v_min * v_max < 0.0f )
	{
		// Different sign
		const FLOATTYPE linear_dist_min_to_0 = ImPow( v_min >= 0 ? ( FLOATTYPE )v_min : -( FLOATTYPE )v_min, ( FLOATTYPE )1.0f / power );
		const FLOATTYPE linear_dist_max_to_0 = ImPow( v_max >= 0 ? ( FLOATTYPE )v_max : -( FLOATTYPE )v_max, ( FLOATTYPE )1.0f / power );
		linear_zero_pos = ( float )( linear_dist_min_to_0 / ( linear_dist_min_to_0 + linear_dist_max_to_0 ) );
	}
	else
	{
		// Same sign
		linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;
	}

	// Process interacting with the slider
	bool value_changed = false;
	if( g.ActiveId == id )
	{
		bool set_new_value = false;
		float clicked_t = 0.0f;
		if( g.ActiveIdSource == ImGuiInputSource_Mouse )
		{
			if( !g.IO.MouseDown[ 0 ] )
			{
				ClearActiveID();
			}
			else
			{
				const float mouse_abs_pos = g.IO.MousePos[ axis ];
				clicked_t = ( slider_usable_sz > 0.0f ) ? ImClamp( ( mouse_abs_pos - slider_usable_pos_min ) / slider_usable_sz, 0.0f, 1.0f ) : 0.0f;
				if( axis == ImGuiAxis_Y )
					clicked_t = 1.0f - clicked_t;
				set_new_value = true;
			}
		}
		else if( g.ActiveIdSource == ImGuiInputSource_Nav )
		{
			const ImVec2 delta2 = GetNavInputAmount2d( ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f );
			float delta = ( axis == ImGuiAxis_X ) ? delta2.x : -delta2.y;
			if( g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated )
			{
				ClearActiveID();
			}
			else if( delta != 0.0f )
			{
				clicked_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>( data_type, *v, v_min, v_max, power, linear_zero_pos );
				const int decimal_precision = is_decimal ? ImParseFormatPrecision( format, 3 ) : 0;
				if( ( decimal_precision > 0 ) || is_power )
				{
					delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds
					if( IsNavInputDown( ImGuiNavInput_TweakSlow ) )
						delta /= 10.0f;
				}
				else
				{
					if( ( v_range >= -100.0f && v_range <= 100.0f ) || IsNavInputDown( ImGuiNavInput_TweakSlow ) )
						delta = ( ( delta < 0.0f ) ? -1.0f : +1.0f ) / ( float )v_range; // Gamepad/keyboard tweak speeds in integer steps
					else
						delta /= 100.0f;
				}
				if( IsNavInputDown( ImGuiNavInput_TweakFast ) )
					delta *= 10.0f;
				set_new_value = true;
				if( ( clicked_t >= 1.0f && delta > 0.0f ) || ( clicked_t <= 0.0f && delta < 0.0f ) ) // This is to avoid applying the saturation when already past the limits
					set_new_value = false;
				else
					clicked_t = ImSaturate( clicked_t + delta );
			}
		}

		if( set_new_value )
		{
			TYPE v_new;
			if( is_power )
			{
				// Account for power curve scale on both sides of the zero
				if( clicked_t < linear_zero_pos )
				{
					// Negative: rescale to the negative range before powering
					float a = 1.0f - ( clicked_t / linear_zero_pos );
					a = ImPow( a, power );
					v_new = ImLerp( ImMin( v_max, ( TYPE )0 ), v_min, a );
				}
				else
				{
					// Positive: rescale to the positive range before powering
					float a;
					if( ImFabs( linear_zero_pos - 1.0f ) > 1.e-6f )
						a = ( clicked_t - linear_zero_pos ) / ( 1.0f - linear_zero_pos );
					else
						a = clicked_t;
					a = ImPow( a, power );
					v_new = ImLerp( ImMax( v_min, ( TYPE )0 ), v_max, a );
				}
			}
			else
			{
				// Linear slider
				if( is_decimal )
				{
					v_new = ImLerp( v_min, v_max, clicked_t );
				}
				else
				{
					// For integer values we want the clicking position to match the grab box so we round above
					// This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
					FLOATTYPE v_new_off_f = ( v_max - v_min ) * clicked_t;
					TYPE v_new_off_floor = ( TYPE )( v_new_off_f );
					TYPE v_new_off_round = ( TYPE )( v_new_off_f + ( FLOATTYPE )0.5 );
					if( v_new_off_floor < v_new_off_round )
						v_new = v_min + v_new_off_round;
					else
						v_new = v_min + v_new_off_floor;
				}
			}

			// Round to user desired precision based on format string
			v_new = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>( format, data_type, v_new );

			// Apply result
			if( *v != v_new )
			{
				*v = v_new;
				value_changed = true;
			}
		}
	}

	if( slider_sz < 1.0f )
	{
		*out_grab_bb = ImRect( bb.Min, bb.Min );
	}
	else
	{
		// Output grab position so it can be displayed by the caller
		float grab_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>( data_type, *v, v_min, v_max, power, linear_zero_pos );
		if( axis == ImGuiAxis_Y )
			grab_t = 1.0f - grab_t;
		const float grab_pos = ImLerp( slider_usable_pos_min, slider_usable_pos_max, grab_t );
		if( axis == ImGuiAxis_X )
			*out_grab_bb = ImRect( grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding );
		else
			*out_grab_bb = ImRect( bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f );
	}

	return value_changed;
}

// For 32-bit and larger types, slider bounds are limited to half the natural type range.
// So e.g. an integer Slider between INT_MAX-10 and INT_MAX will fail, but an integer Slider between INT_MAX/2-10 and INT_MAX/2 will be ok.
// It would be possible to lift that limitation with some work but it doesn't seem to be worth it for sliders.
bool ImGui::SliderBehavior( const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* p_v, const void* p_min, const void* p_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb )
{
	switch( data_type )
	{
		case ImGuiDataType_S8:
		{
			ImS32 v32 = ( ImS32 ) * ( ImS8* )p_v;  bool r = SliderBehaviorT<ImS32, ImS32, float>( bb, id, ImGuiDataType_S32, &v32, *( const ImS8* )p_min, *( const ImS8* )p_max, format, power, flags, out_grab_bb ); if( r ) *( ImS8* )p_v = ( ImS8 )v32;  return r;
		}
		case ImGuiDataType_U8:
		{
			ImU32 v32 = ( ImU32 ) * ( ImU8* )p_v;  bool r = SliderBehaviorT<ImU32, ImS32, float>( bb, id, ImGuiDataType_U32, &v32, *( const ImU8* )p_min, *( const ImU8* )p_max, format, power, flags, out_grab_bb ); if( r ) *( ImU8* )p_v = ( ImU8 )v32;  return r;
		}
		case ImGuiDataType_S16:
		{
			ImS32 v32 = ( ImS32 ) * ( ImS16* )p_v; bool r = SliderBehaviorT<ImS32, ImS32, float>( bb, id, ImGuiDataType_S32, &v32, *( const ImS16* )p_min, *( const ImS16* )p_max, format, power, flags, out_grab_bb ); if( r ) *( ImS16* )p_v = ( ImS16 )v32; return r;
		}
		case ImGuiDataType_U16:
		{
			ImU32 v32 = ( ImU32 ) * ( ImU16* )p_v; bool r = SliderBehaviorT<ImU32, ImS32, float>( bb, id, ImGuiDataType_U32, &v32, *( const ImU16* )p_min, *( const ImU16* )p_max, format, power, flags, out_grab_bb ); if( r ) *( ImU16* )p_v = ( ImU16 )v32; return r;
		}
		case ImGuiDataType_S32:
			IM_ASSERT( *( const ImS32* )p_min >= IM_S32_MIN / 2 && *( const ImS32* )p_max <= IM_S32_MAX / 2 );
			return SliderBehaviorT<ImS32, ImS32, float >( bb, id, data_type, ( ImS32* )p_v, *( const ImS32* )p_min, *( const ImS32* )p_max, format, power, flags, out_grab_bb );
		case ImGuiDataType_U32:
			IM_ASSERT( *( const ImU32* )p_max <= IM_U32_MAX / 2 );
			return SliderBehaviorT<ImU32, ImS32, float >( bb, id, data_type, ( ImU32* )p_v, *( const ImU32* )p_min, *( const ImU32* )p_max, format, power, flags, out_grab_bb );
		case ImGuiDataType_S64:
			IM_ASSERT( *( const ImS64* )p_min >= IM_S64_MIN / 2 && *( const ImS64* )p_max <= IM_S64_MAX / 2 );
			return SliderBehaviorT<ImS64, ImS64, double>( bb, id, data_type, ( ImS64* )p_v, *( const ImS64* )p_min, *( const ImS64* )p_max, format, power, flags, out_grab_bb );
		case ImGuiDataType_U64:
			IM_ASSERT( *( const ImU64* )p_max <= IM_U64_MAX / 2 );
			return SliderBehaviorT<ImU64, ImS64, double>( bb, id, data_type, ( ImU64* )p_v, *( const ImU64* )p_min, *( const ImU64* )p_max, format, power, flags, out_grab_bb );
		case ImGuiDataType_Float:
			IM_ASSERT( *( const float* )p_min >= -FLT_MAX / 2.0f && *( const float* )p_max <= FLT_MAX / 2.0f );
			return SliderBehaviorT<float, float, float >( bb, id, data_type, ( float* )p_v, *( const float* )p_min, *( const float* )p_max, format, power, flags, out_grab_bb );
		case ImGuiDataType_Double:
			IM_ASSERT( *( const double* )p_min >= -DBL_MAX / 2.0f && *( const double* )p_max <= DBL_MAX / 2.0f );
			return SliderBehaviorT<double, double, double>( bb, id, data_type, ( double* )p_v, *( const double* )p_min, *( const double* )p_max, format, power, flags, out_grab_bb );
		case ImGuiDataType_COUNT: break;
	}
	IM_ASSERT( 0 );
	return false;
}

// Note: p_data, p_min and p_max are _pointers_ to a memory address holding the data. For a slider, they are all required.
// Read code of e.g. SliderFloat(), SliderInt() etc. or examples in 'Demo->Widgets->Data Types' to understand how to use this function directly.
bool ImGui::SliderScalar( const char* label, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format, float power )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID( label );
	const float w = CalcItemWidth();

	const ImVec2 label_size = CalcTextSize( label, NULL, true );
	const ImRect frame_bb( window->DC.CursorPos, window->DC.CursorPos + ImVec2( w, label_size.y + style.FramePadding.y * 2.0f ) );
	const ImRect total_bb( frame_bb.Min, frame_bb.Max + ImVec2( label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f ) );

	ItemSize( total_bb, style.FramePadding.y );
	if( !ItemAdd( total_bb, id, &frame_bb ) )
		return false;

	// Default format string when passing NULL
	if( format == NULL )
		GetDataTypeFormat( data_type );
	else if( data_type == ImGuiDataType_S32 && strcmp( format, SECURE("%d") ) != 0 ) // (FIXME-LEGACY: Patch old "%.0f" format string to use "%d", read function more details.)
		format = PatchFormatStringFloatToInt( format );

	// Tabbing or CTRL-clicking on Slider turns it into an input box
	const bool hovered = ItemHoverable( frame_bb, id );
	bool temp_input_is_active = TempInputIsActive( id );
	bool temp_input_start = false;
	if( !temp_input_is_active )
	{
		const bool focus_requested = FocusableItemRegister( window, id );
		const bool clicked = ( hovered && g.IO.MouseClicked[ 0 ] );
		if( focus_requested || clicked || g.NavActivateId == id || g.NavInputId == id )
		{
			SetActiveID( id, window );
			SetFocusID( id, window );
			FocusWindow( window );
			g.ActiveIdUsingNavDirMask |= ( 1 << ImGuiDir_Left ) | ( 1 << ImGuiDir_Right );
			if( focus_requested || ( clicked && g.IO.KeyCtrl ) || g.NavInputId == id )
			{
				temp_input_start = true;
				FocusableItemUnregister( window );
			}
		}
	}
	if( temp_input_is_active || temp_input_start )
		return TempInputScalar( frame_bb, id, label, data_type, p_data, format );

	// Draw frame
	const ImU32 frame_col = GetColorU32( g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg );
	RenderNavHighlight( frame_bb, id );
	RenderFrame( frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding );

	// Slider behavior
	ImRect grab_bb;
	const bool value_changed = SliderBehavior( frame_bb, id, data_type, p_data, p_min, p_max, format, power, ImGuiSliderFlags_None, &grab_bb );
	if( value_changed )
		MarkItemEdited( id );

	// Render grab
	if( grab_bb.Max.x > grab_bb.Min.x )
		window->DrawList->AddRectFilled( grab_bb.Min, grab_bb.Max, GetColorU32( g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab ), style.GrabRounding );

	// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
	char value_buf[ 64 ];
	const char* value_buf_end = value_buf + DataTypeFormatString( value_buf, IM_ARRAYSIZE( value_buf ), data_type, p_data, format );
	RenderTextClipped( frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2( 0.5f, 0.5f ) );

	if( label_size.x > 0.0f )
		RenderText( ImVec2( frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y ), label );

	IMGUI_TEST_ENGINE_ITEM_INFO( id, label, window->DC.ItemFlags );
	return value_changed;
}

// Add multiple sliders on 1 line for compact edition of multiple components
bool ImGui::SliderScalarN( const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format, float power )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	bool value_changed = false;
	BeginGroup();
	PushID( label );
	PushMultiItemsWidths( components, CalcItemWidth() );
	size_t type_size = GDataTypeInfo[ data_type ].Size;
	for( int i = 0; i < components; i++ )
	{
		PushID( i );
		if( i > 0 )
			SameLine( 0, g.Style.ItemInnerSpacing.x );
		value_changed |= SliderScalar( "", data_type, v, v_min, v_max, format, power );
		PopID();
		PopItemWidth();
		v = ( void* )( ( char* )v + type_size );
	}
	PopID();

	const char* label_end = FindRenderedTextEnd( label );
	if( label != label_end )
	{
		SameLine( 0, g.Style.ItemInnerSpacing.x );
		TextEx( label, label_end );
	}

	EndGroup();
	return value_changed;
}

bool ImGui::SliderFloat( const char* label, float* v, float v_min, float v_max, const char* format, float power )
{
	return SliderScalar( label, ImGuiDataType_Float, v, &v_min, &v_max, format, power );
}

bool ImGui::SliderFloat2( const char* label, float v[ 2 ], float v_min, float v_max, const char* format, float power )
{
	return SliderScalarN( label, ImGuiDataType_Float, v, 2, &v_min, &v_max, format, power );
}

bool ImGui::SliderFloat3( const char* label, float v[ 3 ], float v_min, float v_max, const char* format, float power )
{
	return SliderScalarN( label, ImGuiDataType_Float, v, 3, &v_min, &v_max, format, power );
}

bool ImGui::SliderFloat4( const char* label, float v[ 4 ], float v_min, float v_max, const char* format, float power )
{
	return SliderScalarN( label, ImGuiDataType_Float, v, 4, &v_min, &v_max, format, power );
}

bool ImGui::SliderAngle( const char* label, float* v_rad, float v_degrees_min, float v_degrees_max, const char* format )
{
	if( format == NULL )
		format = SECURE("%.0f deg");
	float v_deg = ( *v_rad ) * 360.0f / ( 2 * IM_PI );
	bool value_changed = SliderFloat( label, &v_deg, v_degrees_min, v_degrees_max, format, 1.0f );
	*v_rad = v_deg * ( 2 * IM_PI ) / 360.0f;
	return value_changed;
}

bool ImGui::SliderInt( const char* label, int* v, int v_min, int v_max, const char* format )
{
	return SliderScalar( label, ImGuiDataType_S32, v, &v_min, &v_max, format );
}

bool ImGui::SliderInt2( const char* label, int v[ 2 ], int v_min, int v_max, const char* format )
{
	return SliderScalarN( label, ImGuiDataType_S32, v, 2, &v_min, &v_max, format );
}

bool ImGui::SliderInt3( const char* label, int v[ 3 ], int v_min, int v_max, const char* format )
{
	return SliderScalarN( label, ImGuiDataType_S32, v, 3, &v_min, &v_max, format );
}

bool ImGui::SliderInt4( const char* label, int v[ 4 ], int v_min, int v_max, const char* format )
{
	return SliderScalarN( label, ImGuiDataType_S32, v, 4, &v_min, &v_max, format );
}

bool ImGui::VSliderScalar( const char* label, const ImVec2& size, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format, float power )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID( label );

	const ImVec2 label_size = CalcTextSize( label, NULL, true );
	const ImRect frame_bb( window->DC.CursorPos, window->DC.CursorPos + size );
	const ImRect bb( frame_bb.Min, frame_bb.Max + ImVec2( label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f ) );

	ItemSize( bb, style.FramePadding.y );
	if( !ItemAdd( frame_bb, id ) )
		return false;

	// Default format string when passing NULL
	if( format == NULL )
		GetDataTypeFormat( data_type );
	else if( data_type == ImGuiDataType_S32 && strcmp( format, SECURE("%d") ) != 0 ) // (FIXME-LEGACY: Patch old "%.0f" format string to use "%d", read function more details.)
		format = PatchFormatStringFloatToInt( format );

	const bool hovered = ItemHoverable( frame_bb, id );
	if( ( hovered && g.IO.MouseClicked[ 0 ] ) || g.NavActivateId == id || g.NavInputId == id )
	{
		SetActiveID( id, window );
		SetFocusID( id, window );
		FocusWindow( window );
		g.ActiveIdUsingNavDirMask |= ( 1 << ImGuiDir_Up ) | ( 1 << ImGuiDir_Down );
	}

	// Draw frame
	const ImU32 frame_col = GetColorU32( g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg );
	RenderNavHighlight( frame_bb, id );
	RenderFrame( frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding );

	// Slider behavior
	ImRect grab_bb;
	const bool value_changed = SliderBehavior( frame_bb, id, data_type, p_data, p_min, p_max, format, power, ImGuiSliderFlags_Vertical, &grab_bb );
	if( value_changed )
		MarkItemEdited( id );

	// Render grab
	if( grab_bb.Max.y > grab_bb.Min.y )
		window->DrawList->AddRectFilled( grab_bb.Min, grab_bb.Max, GetColorU32( g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab ), style.GrabRounding );

	// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
	// For the vertical slider we allow centered text to overlap the frame padding
	char value_buf[ 64 ];
	const char* value_buf_end = value_buf + DataTypeFormatString( value_buf, IM_ARRAYSIZE( value_buf ), data_type, p_data, format );
	RenderTextClipped( ImVec2( frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y ), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2( 0.5f, 0.0f ) );
	if( label_size.x > 0.0f )
		RenderText( ImVec2( frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y ), label );

	return value_changed;
}

bool ImGui::VSliderFloat( const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format, float power )
{
	return VSliderScalar( label, size, ImGuiDataType_Float, v, &v_min, &v_max, format, power );
}

bool ImGui::VSliderInt( const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format )
{
	return VSliderScalar( label, size, ImGuiDataType_S32, v, &v_min, &v_max, format );
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.
//-------------------------------------------------------------------------
// - ImParseFormatFindStart() [Internal]
// - ImParseFormatFindEnd() [Internal]
// - ImParseFormatTrimDecorations() [Internal]
// - ImParseFormatPrecision() [Internal]
// - TempInputTextScalar() [Internal]
// - InputScalar()
// - InputScalarN()
// - InputFloat()
// - InputFloat2()
// - InputFloat3()
// - InputFloat4()
// - InputInt()
// - InputInt2()
// - InputInt3()
// - InputInt4()
// - InputDouble()
//-------------------------------------------------------------------------

// We don't use strchr() because our strings are usually very short and often start with '%'
const char* ImParseFormatFindStart( const char* fmt )
{
	while( char c = fmt[ 0 ] )
	{
		if( c == '%' && fmt[ 1 ] != '%' )
			return fmt;
		else if( c == '%' )
			fmt++;
		fmt++;
	}
	return fmt;
}

const char* ImParseFormatFindEnd( const char* fmt )
{
	// Printf/scanf types modifiers: I/L/h/j/l/t/w/z. Other uppercase letters qualify as types aka end of the format.
	if( fmt[ 0 ] != '%' )
		return fmt;
	const unsigned int ignored_uppercase_mask = ( 1 << ( 'I' - 'A' ) ) | ( 1 << ( 'L' - 'A' ) );
	const unsigned int ignored_lowercase_mask = ( 1 << ( 'h' - 'a' ) ) | ( 1 << ( 'j' - 'a' ) ) | ( 1 << ( 'l' - 'a' ) ) | ( 1 << ( 't' - 'a' ) ) | ( 1 << ( 'w' - 'a' ) ) | ( 1 << ( 'z' - 'a' ) );
	for( char c; ( c = *fmt ) != 0; fmt++ )
	{
		if( c >= 'A' && c <= 'Z' && ( ( 1 << ( c - 'A' ) ) & ignored_uppercase_mask ) == 0 )
			return fmt + 1;
		if( c >= 'a' && c <= 'z' && ( ( 1 << ( c - 'a' ) ) & ignored_lowercase_mask ) == 0 )
			return fmt + 1;
	}
	return fmt;
}

// Extract the format out of a format string with leading or trailing decorations
//  fmt = "blah blah"  -> return fmt
//  fmt = "%.3f"       -> return fmt
//  fmt = "hello %.3f" -> return fmt + 6
//  fmt = "%.3f hello" -> return buf written with "%.3f"
const char* ImParseFormatTrimDecorations( const char* fmt, char* buf, size_t buf_size )
{
	const char* fmt_start = ImParseFormatFindStart( fmt );
	if( fmt_start[ 0 ] != '%' )
		return fmt;
	const char* fmt_end = ImParseFormatFindEnd( fmt_start );
	if( fmt_end[ 0 ] == 0 ) // If we only have leading decoration, we don't need to copy the data.
		return fmt_start;
	ImStrncpy( buf, fmt_start, ImMin( ( size_t )( fmt_end - fmt_start ) + 1, buf_size ) );
	return buf;
}

// Parse display precision back from the display format string
// FIXME: This is still used by some navigation code path to infer a minimum tweak step, but we should aim to rework widgets so it isn't needed.
int ImParseFormatPrecision( const char* fmt, int default_precision )
{
	fmt = ImParseFormatFindStart( fmt );
	if( fmt[ 0 ] != '%' )
		return default_precision;
	fmt++;
	while( *fmt >= '0' && *fmt <= '9' )
		fmt++;
	int precision = INT_MAX;
	if( *fmt == '.' )
	{
		fmt = ImAtoi<int>( fmt + 1, &precision );
		if( precision < 0 || precision > 99 )
			precision = default_precision;
	}
	if( *fmt == 'e' || *fmt == 'E' ) // Maximum precision with scientific notation
		precision = -1;
	if( ( *fmt == 'g' || *fmt == 'G' ) && precision == INT_MAX )
		precision = -1;
	return ( precision == INT_MAX ) ? default_precision : precision;
}

// Create text input in place of another active widget (e.g. used when doing a CTRL+Click on drag/slider widgets)
// FIXME: Facilitate using this in variety of other situations.
bool ImGui::TempInputText( const ImRect& bb, ImGuiID id, const char* label, char* buf, int buf_size, ImGuiInputTextFlags flags )
{
	// On the first frame, g.TempInputTextId == 0, then on subsequent frames it becomes == id.
	// We clear ActiveID on the first frame to allow the InputText() taking it back.
	ImGuiContext& g = *GImGui;
	const bool init = ( g.TempInputId != id );
	if( init )
		ClearActiveID();

	g.CurrentWindow->DC.CursorPos = bb.Min;
	bool value_changed = InputTextEx( label, NULL, buf, buf_size, bb.GetSize(), flags );
	if( init )
	{
		// First frame we started displaying the InputText widget, we expect it to take the active id.
		IM_ASSERT( g.ActiveId == id );
		g.TempInputId = g.ActiveId;
	}
	return value_changed;
}

bool ImGui::TempInputScalar( const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* p_data, const char* format )
{
	ImGuiContext& g = *GImGui;

	char fmt_buf[ 32 ];
	char data_buf[ 32 ];
	format = ImParseFormatTrimDecorations( format, fmt_buf, IM_ARRAYSIZE( fmt_buf ) );
	DataTypeFormatString( data_buf, IM_ARRAYSIZE( data_buf ), data_type, p_data, format );
	ImStrTrimBlanks( data_buf );

	ImGuiInputTextFlags flags = ImGuiInputTextFlags_AutoSelectAll | ImGuiInputTextFlags_NoMarkEdited;
	flags |= ( ( data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double ) ? ImGuiInputTextFlags_CharsScientific : ImGuiInputTextFlags_CharsDecimal );
	bool value_changed = TempInputText( bb, id, label, data_buf, IM_ARRAYSIZE( data_buf ), flags );
	if( value_changed )
	{
		value_changed = DataTypeApplyOpFromText( data_buf, g.InputTextState.InitialTextA.Data, data_type, p_data, NULL );
		if( value_changed )
			MarkItemEdited( id );
	}
	return value_changed;
}

// Note: p_data, p_step, p_step_fast are _pointers_ to a memory address holding the data. For an Input widget, p_step and p_step_fast are optional.
// Read code of e.g. InputFloat(), InputInt() etc. or examples in 'Demo->Widgets->Data Types' to understand how to use this function directly.
bool ImGui::InputScalar( const char* label, ImGuiDataType data_type, void* p_data, const void* p_step, const void* p_step_fast, const char* format, ImGuiInputTextFlags flags )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	ImGuiStyle& style = g.Style;

	if( format == NULL )
		GetDataTypeFormat( data_type );

	char buf[ 64 ];
	DataTypeFormatString( buf, IM_ARRAYSIZE( buf ), data_type, p_data, format );

	bool value_changed = false;
	if( ( flags & ( ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsScientific ) ) == 0 )
		flags |= ImGuiInputTextFlags_CharsDecimal;
	flags |= ImGuiInputTextFlags_AutoSelectAll;
	flags |= ImGuiInputTextFlags_NoMarkEdited;  // We call MarkItemEdited() ourselves by comparing the actual data rather than the string.

	if( p_step != NULL )
	{
		const float button_size = GetFrameHeight();

		BeginGroup(); // The only purpose of the group here is to allow the caller to query item data e.g. IsItemActive()
		PushID( label );
		SetNextItemWidth( ImMax( 1.0f, CalcItemWidth() - ( button_size + style.ItemInnerSpacing.x ) * 2 ) );
		if( InputText( "", buf, IM_ARRAYSIZE( buf ), flags ) ) // PushId(label) + "" gives us the expected ID from outside point of view
			value_changed = DataTypeApplyOpFromText( buf, g.InputTextState.InitialTextA.Data, data_type, p_data, format );

		// Step buttons
		const ImVec2 backup_frame_padding = style.FramePadding;
		style.FramePadding.x = style.FramePadding.y;
		ImGuiButtonFlags button_flags = ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups;
		if( flags & ImGuiInputTextFlags_ReadOnly )
			button_flags |= ImGuiButtonFlags_Disabled;
		SameLine( 0, style.ItemInnerSpacing.x );
		if( ButtonEx( SECURE("-"), ImVec2( button_size, button_size ), button_flags ) )
		{
			DataTypeApplyOp( data_type, '-', p_data, p_data, g.IO.KeyCtrl && p_step_fast ? p_step_fast : p_step );
			value_changed = true;
		}
		SameLine( 0, style.ItemInnerSpacing.x );
		if( ButtonEx( SECURE("+"), ImVec2( button_size, button_size ), button_flags ) )
		{
			DataTypeApplyOp( data_type, '+', p_data, p_data, g.IO.KeyCtrl && p_step_fast ? p_step_fast : p_step );
			value_changed = true;
		}

		const char* label_end = FindRenderedTextEnd( label );
		if( label != label_end )
		{
			SameLine( 0, style.ItemInnerSpacing.x );
			TextEx( label, label_end );
		}
		style.FramePadding = backup_frame_padding;

		PopID();
		EndGroup();
	}
	else
	{
		if( InputText( label, buf, IM_ARRAYSIZE( buf ), flags ) )
			value_changed = DataTypeApplyOpFromText( buf, g.InputTextState.InitialTextA.Data, data_type, p_data, format );
	}
	if( value_changed )
		MarkItemEdited( window->DC.LastItemId );

	return value_changed;
}

bool ImGui::InputScalarN( const char* label, ImGuiDataType data_type, void* p_data, int components, const void* p_step, const void* p_step_fast, const char* format, ImGuiInputTextFlags flags )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	bool value_changed = false;
	BeginGroup();
	PushID( label );
	PushMultiItemsWidths( components, CalcItemWidth() );
	size_t type_size = GDataTypeInfo[ data_type ].Size;
	for( int i = 0; i < components; i++ )
	{
		PushID( i );
		if( i > 0 )
			SameLine( 0, g.Style.ItemInnerSpacing.x );
		value_changed |= InputScalar( "", data_type, p_data, p_step, p_step_fast, format, flags );
		PopID();
		PopItemWidth();
		p_data = ( void* )( ( char* )p_data + type_size );
	}
	PopID();

	const char* label_end = FindRenderedTextEnd( label );
	if( label != label_end )
	{
		SameLine( 0.0f, g.Style.ItemInnerSpacing.x );
		TextEx( label, label_end );
	}

	EndGroup();
	return value_changed;
}

bool ImGui::InputFloat( const char* label, float* v, float step, float step_fast, const char* format, ImGuiInputTextFlags flags )
{
	flags |= ImGuiInputTextFlags_CharsScientific;
	return InputScalar( label, ImGuiDataType_Float, ( void* )v, ( void* )( step > 0.0f ? &step : NULL ), ( void* )( step_fast > 0.0f ? &step_fast : NULL ), format, flags );
}

bool ImGui::InputFloat2( const char* label, float v[ 2 ], const char* format, ImGuiInputTextFlags flags )
{
	return InputScalarN( label, ImGuiDataType_Float, v, 2, NULL, NULL, format, flags );
}

bool ImGui::InputFloat3( const char* label, float v[ 3 ], const char* format, ImGuiInputTextFlags flags )
{
	return InputScalarN( label, ImGuiDataType_Float, v, 3, NULL, NULL, format, flags );
}

bool ImGui::InputFloat4( const char* label, float v[ 4 ], const char* format, ImGuiInputTextFlags flags )
{
	return InputScalarN( label, ImGuiDataType_Float, v, 4, NULL, NULL, format, flags );
}

// Prefer using "const char* format" directly, which is more flexible and consistent with other API.
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
bool ImGui::InputFloat( const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags flags )
{
	char format[ 16 ] = "%f";
	if( decimal_precision >= 0 )
		ImFormatString( format, IM_ARRAYSIZE( format ), SECURE("%%.%df"), decimal_precision );
	return InputFloat( label, v, step, step_fast, format, flags );
}

bool ImGui::InputFloat2( const char* label, float v[ 2 ], int decimal_precision, ImGuiInputTextFlags flags )
{
	char format[ 16 ] = "%f";
	if( decimal_precision >= 0 )
		ImFormatString( format, IM_ARRAYSIZE( format ), SECURE("%%.%df"), decimal_precision );
	return InputScalarN( label, ImGuiDataType_Float, v, 2, NULL, NULL, format, flags );
}

bool ImGui::InputFloat3( const char* label, float v[ 3 ], int decimal_precision, ImGuiInputTextFlags flags )
{
	char format[ 16 ] = "%f";
	if( decimal_precision >= 0 )
		ImFormatString( format, IM_ARRAYSIZE( format ), SECURE("%%.%df"), decimal_precision );
	return InputScalarN( label, ImGuiDataType_Float, v, 3, NULL, NULL, format, flags );
}

bool ImGui::InputFloat4( const char* label, float v[ 4 ], int decimal_precision, ImGuiInputTextFlags flags )
{
	char format[ 16 ] = "%f";
	if( decimal_precision >= 0 )
		ImFormatString( format, IM_ARRAYSIZE( format ), SECURE("%%.%df"), decimal_precision );
	return InputScalarN( label, ImGuiDataType_Float, v, 4, NULL, NULL, format, flags );
}
#endif // IMGUI_DISABLE_OBSOLETE_FUNCTIONS

bool ImGui::InputInt( const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags flags )
{
	// Hexadecimal input provided as a convenience but the flag name is awkward. Typically you'd use InputText() to parse your own data, if you want to handle prefixes.
	const char* format = ( flags & ImGuiInputTextFlags_CharsHexadecimal ) ? SECURE("%08X") : SECURE("%d");
	return InputScalar( label, ImGuiDataType_S32, ( void* )v, ( void* )( step > 0 ? &step : NULL ), ( void* )( step_fast > 0 ? &step_fast : NULL ), format, flags );
}

bool ImGui::InputInt2( const char* label, int v[ 2 ], ImGuiInputTextFlags flags )
{
	return InputScalarN( label, ImGuiDataType_S32, v, 2, NULL, NULL, SECURE("%d"), flags );
}

bool ImGui::InputInt3( const char* label, int v[ 3 ], ImGuiInputTextFlags flags )
{
	return InputScalarN( label, ImGuiDataType_S32, v, 3, NULL, NULL, SECURE("%d"), flags );
}

bool ImGui::InputInt4( const char* label, int v[ 4 ], ImGuiInputTextFlags flags )
{
	return InputScalarN( label, ImGuiDataType_S32, v, 4, NULL, NULL, SECURE("%d"), flags );
}

bool ImGui::InputDouble( const char* label, double* v, double step, double step_fast, const char* format, ImGuiInputTextFlags flags )
{
	flags |= ImGuiInputTextFlags_CharsScientific;
	return InputScalar( label, ImGuiDataType_Double, ( void* )v, ( void* )( step > 0.0 ? &step : NULL ), ( void* )( step_fast > 0.0 ? &step_fast : NULL ), format, flags );
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: InputText, InputTextMultiline, InputTextWithHint
//-------------------------------------------------------------------------
// - InputText()
// - InputTextWithHint()
// - InputTextMultiline()
// - InputTextEx() [Internal]
//-------------------------------------------------------------------------

bool ImGui::InputText( const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data )
{
	IM_ASSERT( !( flags & ImGuiInputTextFlags_Multiline ) ); // call InputTextMultiline()
	return InputTextEx( label, NULL, buf, ( int )buf_size, ImVec2( 0, 0 ), flags, callback, user_data );
}

bool ImGui::InputTextMultiline( const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data )
{
	return InputTextEx( label, NULL, buf, ( int )buf_size, size, flags | ImGuiInputTextFlags_Multiline, callback, user_data );
}

bool ImGui::InputTextWithHint( const char* label, const char* hint, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data )
{
	IM_ASSERT( !( flags & ImGuiInputTextFlags_Multiline ) ); // call InputTextMultiline()
	return InputTextEx( label, hint, buf, ( int )buf_size, ImVec2( 0, 0 ), flags, callback, user_data );
}

static int InputTextCalcTextLenAndLineCount( const char* text_begin, const char** out_text_end )
{
	int line_count = 0;
	const char* s = text_begin;
	while( char c = *s++ ) // We are only matching for \n so we can ignore UTF-8 decoding
		if( c == '\n' )
			line_count++;
	s--;
	if( s[ 0 ] != '\n' && s[ 0 ] != '\r' )
		line_count++;
	*out_text_end = s;
	return line_count;
}

static ImVec2 InputTextCalcTextSizeW( const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining, ImVec2* out_offset, bool stop_on_new_line )
{
	ImGuiContext& g = *GImGui;
	ImFont* font = g.Font;
	const float line_height = g.FontSize;
	const float scale = line_height / font->FontSize;

	ImVec2 text_size = ImVec2( 0, 0 );
	float line_width = 0.0f;

	const ImWchar* s = text_begin;
	while( s < text_end )
	{
		unsigned int c = ( unsigned int )( *s++ );
		if( c == '\n' )
		{
			text_size.x = ImMax( text_size.x, line_width );
			text_size.y += line_height;
			line_width = 0.0f;
			if( stop_on_new_line )
				break;
			continue;
		}
		if( c == '\r' )
			continue;

		const float char_width = font->GetCharAdvance( ( ImWchar )c ) * scale;
		line_width += char_width;
	}

	if( text_size.x < line_width )
		text_size.x = line_width;

	if( out_offset )
		*out_offset = ImVec2( line_width, text_size.y + line_height );  // offset allow for the possibility of sitting after a trailing \n

	if( line_width > 0 || text_size.y == 0.0f )                        // whereas size.y will ignore the trailing \n
		text_size.y += line_height;

	if( remaining )
		*remaining = s;

	return text_size;
}

// Wrapper for stb_textedit.h to edit text (our wrapper is for: statically sized buffer, single-line, wchar characters. InputText converts between UTF-8 and wchar)
namespace ImStb
{

static int     STB_TEXTEDIT_STRINGLEN( const STB_TEXTEDIT_STRING* obj )
{
	return obj->CurLenW;
}
static ImWchar STB_TEXTEDIT_GETCHAR( const STB_TEXTEDIT_STRING* obj, int idx )
{
	return obj->TextW[ idx ];
}
static float   STB_TEXTEDIT_GETWIDTH( STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx )
{
	ImWchar c = obj->TextW[ line_start_idx + char_idx ]; if( c == '\n' ) return STB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext& g = *GImGui; return g.Font->GetCharAdvance( c ) * ( g.FontSize / g.Font->FontSize );
}
static int     STB_TEXTEDIT_KEYTOTEXT( int key )
{
	return key >= 0x200000 ? 0 : key;
}
static ImWchar STB_TEXTEDIT_NEWLINE = '\n';
static void    STB_TEXTEDIT_LAYOUTROW( StbTexteditRow* r, STB_TEXTEDIT_STRING* obj, int line_start_idx )
{
	const ImWchar* text = obj->TextW.Data;
	const ImWchar* text_remaining = NULL;
	const ImVec2 size = InputTextCalcTextSizeW( text + line_start_idx, text + obj->CurLenW, &text_remaining, NULL, true );
	r->x0 = 0.0f;
	r->x1 = size.x;
	r->baseline_y_delta = size.y;
	r->ymin = 0.0f;
	r->ymax = size.y;
	r->num_chars = ( int )( text_remaining - ( text + line_start_idx ) );
}

static bool is_separator( unsigned int c )
{
	return ImCharIsBlankW( c ) || c == ',' || c == ';' || c == '(' || c == ')' || c == '{' || c == '}' || c == '[' || c == ']' || c == '|';
}
static int  is_word_boundary_from_right( STB_TEXTEDIT_STRING* obj, int idx )
{
	return idx > 0 ? ( is_separator( obj->TextW[ idx - 1 ] ) && !is_separator( obj->TextW[ idx ] ) ) : 1;
}
static int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL( STB_TEXTEDIT_STRING* obj, int idx )
{
	idx--; while( idx >= 0 && !is_word_boundary_from_right( obj, idx ) ) idx--; return idx < 0 ? 0 : idx;
}
#ifdef __APPLE__    // FIXME: Move setting to IO structure
static int  is_word_boundary_from_left( STB_TEXTEDIT_STRING* obj, int idx )
{
	return idx > 0 ? ( !is_separator( obj->TextW[ idx - 1 ] ) && is_separator( obj->TextW[ idx ] ) ) : 1;
}
static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL( STB_TEXTEDIT_STRING* obj, int idx )
{
	idx++; int len = obj->CurLenW; while( idx < len && !is_word_boundary_from_left( obj, idx ) ) idx++; return idx > len ? len : idx;
}
#else
static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL( STB_TEXTEDIT_STRING* obj, int idx )
{
	idx++; int len = obj->CurLenW; while( idx < len && !is_word_boundary_from_right( obj, idx ) ) idx++; return idx > len ? len : idx;
}
#endif
#define STB_TEXTEDIT_MOVEWORDLEFT   STB_TEXTEDIT_MOVEWORDLEFT_IMPL    // They need to be #define for stb_textedit.h
#define STB_TEXTEDIT_MOVEWORDRIGHT  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL

static void STB_TEXTEDIT_DELETECHARS( STB_TEXTEDIT_STRING* obj, int pos, int n )
{
	ImWchar* dst = obj->TextW.Data + pos;

	// We maintain our buffer length in both UTF-8 and wchar formats
	obj->CurLenA -= ImTextCountUtf8BytesFromStr( dst, dst + n );
	obj->CurLenW -= n;

	// Offset remaining text (FIXME-OPT: Use memmove)
	const ImWchar* src = obj->TextW.Data + pos + n;
	while( ImWchar c = *src++ )
		*dst++ = c;
	*dst = '\0';
}

static bool STB_TEXTEDIT_INSERTCHARS( STB_TEXTEDIT_STRING* obj, int pos, const ImWchar* new_text, int new_text_len )
{
	const bool is_resizable = ( obj->UserFlags & ImGuiInputTextFlags_CallbackResize ) != 0;
	const int text_len = obj->CurLenW;
	IM_ASSERT( pos <= text_len );

	const int new_text_len_utf8 = ImTextCountUtf8BytesFromStr( new_text, new_text + new_text_len );
	if( !is_resizable && ( new_text_len_utf8 + obj->CurLenA + 1 > obj->BufCapacityA ) )
		return false;

	// Grow internal buffer if needed
	if( new_text_len + text_len + 1 > obj->TextW.Size )
	{
		if( !is_resizable )
			return false;
		IM_ASSERT( text_len < obj->TextW.Size );
		obj->TextW.resize( text_len + ImClamp( new_text_len * 4, 32, ImMax( 256, new_text_len ) ) + 1 );
	}

	ImWchar* text = obj->TextW.Data;
	if( pos != text_len )
	{
		const auto len = size_t( text_len ) - size_t( pos );
		const auto temp = std::make_unique< ImWchar[] >( len );
		std::memcpy( temp.get(), text + pos, len * sizeof( ImWchar ) );
		std::memcpy( text + pos + new_text_len, temp.get(), len * sizeof( ImWchar ) );
		// std::memmove( text + pos + new_text_len, text + pos, ( size_t )( text_len - pos ) * sizeof( ImWchar ) );
	}

	std::memcpy( text + pos, new_text, ( size_t )new_text_len * sizeof( ImWchar ) );

	obj->CurLenW += new_text_len;
	obj->CurLenA += new_text_len_utf8;
	obj->TextW[ obj->CurLenW ] = '\0';

	return true;
}

// We don't use an enum so we can build even with conflicting symbols (if another user of stb_textedit.h leak their STB_TEXTEDIT_K_* symbols)
#define STB_TEXTEDIT_K_LEFT         0x200000 // keyboard input to move cursor left
#define STB_TEXTEDIT_K_RIGHT        0x200001 // keyboard input to move cursor right
#define STB_TEXTEDIT_K_UP           0x200002 // keyboard input to move cursor up
#define STB_TEXTEDIT_K_DOWN         0x200003 // keyboard input to move cursor down
#define STB_TEXTEDIT_K_LINESTART    0x200004 // keyboard input to move cursor to start of line
#define STB_TEXTEDIT_K_LINEEND      0x200005 // keyboard input to move cursor to end of line
#define STB_TEXTEDIT_K_TEXTSTART    0x200006 // keyboard input to move cursor to start of text
#define STB_TEXTEDIT_K_TEXTEND      0x200007 // keyboard input to move cursor to end of text
#define STB_TEXTEDIT_K_DELETE       0x200008 // keyboard input to delete selection or character under cursor
#define STB_TEXTEDIT_K_BACKSPACE    0x200009 // keyboard input to delete selection or character left of cursor
#define STB_TEXTEDIT_K_UNDO         0x20000A // keyboard input to perform undo
#define STB_TEXTEDIT_K_REDO         0x20000B // keyboard input to perform redo
#define STB_TEXTEDIT_K_WORDLEFT     0x20000C // keyboard input to move cursor left one word
#define STB_TEXTEDIT_K_WORDRIGHT    0x20000D // keyboard input to move cursor right one word
#define STB_TEXTEDIT_K_SHIFT        0x400000

#define STB_TEXTEDIT_IMPLEMENTATION
#include "imstb_textedit.hpp"

// stb_textedit internally allows for a single undo record to do addition and deletion, but somehow, calling
// the stb_textedit_paste() function creates two separate records, so we perform it manually. (FIXME: Report to nothings/stb?)
static void stb_textedit_replace( STB_TEXTEDIT_STRING* str, STB_TexteditState* state, const STB_TEXTEDIT_CHARTYPE* text, int text_len )
{
	stb_text_makeundo_replace( str, state, 0, str->CurLenW, text_len );
	ImStb::STB_TEXTEDIT_DELETECHARS( str, 0, str->CurLenW );
	if( text_len <= 0 )
		return;
	if( ImStb::STB_TEXTEDIT_INSERTCHARS( str, 0, text, text_len ) )
	{
		state->cursor = text_len;
		state->has_preferred_x = 0;
		return;
	}
	IM_ASSERT( 0 ); // Failed to insert character, normally shouldn't happen because of how we currently use stb_textedit_replace()
}

} // namespace ImStb

void ImGuiInputTextState::OnKeyPressed( int key )
{
	stb_textedit_key( this, &Stb, key );
	CursorFollow = true;
	CursorAnimReset();
}

ImGuiInputTextCallbackData::ImGuiInputTextCallbackData()
{
	memset( this, 0, sizeof( *this ) );
}

// Public API to manipulate UTF-8 text
// We expose UTF-8 to the user (unlike the STB_TEXTEDIT_* functions which are manipulating wchar)
// FIXME: The existence of this rarely exercised code path is a bit of a nuisance.
void ImGuiInputTextCallbackData::DeleteChars( int pos, int bytes_count )
{
	IM_ASSERT( pos + bytes_count <= BufTextLen );
	char* dst = Buf + pos;
	const char* src = Buf + pos + bytes_count;
	while( char c = *src++ )
		*dst++ = c;
	*dst = '\0';

	if( CursorPos + bytes_count >= pos )
		CursorPos -= bytes_count;
	else if( CursorPos >= pos )
		CursorPos = pos;
	SelectionStart = SelectionEnd = CursorPos;
	BufDirty = true;
	BufTextLen -= bytes_count;
}

void ImGuiInputTextCallbackData::InsertChars( int pos, const char* new_text, const char* new_text_end )
{
	const bool is_resizable = ( Flags & ImGuiInputTextFlags_CallbackResize ) != 0;
	const int new_text_len = new_text_end ? ( int )( new_text_end - new_text ) : ( int )strlen( new_text );
	if( new_text_len + BufTextLen >= BufSize )
	{
		if( !is_resizable )
			return;

		// Contrary to STB_TEXTEDIT_INSERTCHARS() this is working in the UTF8 buffer, hence the mildly similar code (until we remove the U16 buffer altogether!)
		ImGuiContext& g = *GImGui;
		ImGuiInputTextState* edit_state = &g.InputTextState;
		IM_ASSERT( edit_state->ID != 0 && g.ActiveId == edit_state->ID );
		IM_ASSERT( Buf == edit_state->TextA.Data );
		int new_buf_size = BufTextLen + ImClamp( new_text_len * 4, 32, ImMax( 256, new_text_len ) ) + 1;
		edit_state->TextA.reserve( new_buf_size + 1 );
		Buf = edit_state->TextA.Data;
		BufSize = edit_state->BufCapacityA = new_buf_size;
	}

	if( BufTextLen != pos )
		memmove( Buf + pos + new_text_len, Buf + pos, ( size_t )( BufTextLen - pos ) );
	memcpy( Buf + pos, new_text, ( size_t )new_text_len * sizeof( char ) );
	Buf[ BufTextLen + new_text_len ] = '\0';

	if( CursorPos >= pos )
		CursorPos += new_text_len;
	SelectionStart = SelectionEnd = CursorPos;
	BufDirty = true;
	BufTextLen += new_text_len;
}

// Return false to discard a character.
static bool InputTextFilterCharacter( unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data )
{
	unsigned int c = *p_char;

	// Filter non-printable (NB: isprint is unreliable! see #2467)
	if( c < 0x20 )
	{
		bool pass = false;
		pass |= ( c == '\n' && ( flags & ImGuiInputTextFlags_Multiline ) );
		pass |= ( c == '\t' && ( flags & ImGuiInputTextFlags_AllowTabInput ) );
		if( !pass )
			return false;
	}

	// We ignore Ascii representation of delete (emitted from Backspace on OSX, see #2578, #2817)
	if( c == 127 )
		return false;

	// Filter private Unicode range. GLFW on OSX seems to send private characters for special keys like arrow keys (FIXME)
	if( c >= 0xE000 && c <= 0xF8FF )
		return false;

	// Filter Unicode ranges we are not handling in this build.
	if( c > IM_UNICODE_CODEPOINT_MAX )
		return false;

	// Generic named filters
	if( flags & ( ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase | ImGuiInputTextFlags_CharsNoBlank | ImGuiInputTextFlags_CharsScientific ) )
	{
		if( flags & ImGuiInputTextFlags_CharsDecimal )
			if( !( c >= '0' && c <= '9' ) && ( c != '.' ) && ( c != '-' ) && ( c != '+' ) && ( c != '*' ) && ( c != '/' ) )
				return false;

		if( flags & ImGuiInputTextFlags_CharsScientific )
			if( !( c >= '0' && c <= '9' ) && ( c != '.' ) && ( c != '-' ) && ( c != '+' ) && ( c != '*' ) && ( c != '/' ) && ( c != 'e' ) && ( c != 'E' ) )
				return false;

		if( flags & ImGuiInputTextFlags_CharsHexadecimal )
			if( !( c >= '0' && c <= '9' ) && !( c >= 'a' && c <= 'f' ) && !( c >= 'A' && c <= 'F' ) )
				return false;

		if( flags & ImGuiInputTextFlags_CharsUppercase )
			if( c >= 'a' && c <= 'z' )
				*p_char = ( c += ( unsigned int )( 'A' - 'a' ) );

		if( flags & ImGuiInputTextFlags_CharsNoBlank )
			if( ImCharIsBlankW( c ) )
				return false;
	}

	// Custom callback filter
	if( flags & ImGuiInputTextFlags_CallbackCharFilter )
	{
		ImGuiInputTextCallbackData callback_data;
		memset( &callback_data, 0, sizeof( ImGuiInputTextCallbackData ) );
		callback_data.EventFlag = ImGuiInputTextFlags_CallbackCharFilter;
		callback_data.EventChar = ( ImWchar )c;
		callback_data.Flags = flags;
		callback_data.UserData = user_data;
		if( callback( &callback_data ) != 0 )
			return false;
		*p_char = callback_data.EventChar;
		if( !callback_data.EventChar )
			return false;
	}

	return true;
}

// Edit a string of text
// - buf_size account for the zero-terminator, so a buf_size of 6 can hold "Hello" but not "Hello!".
//   This is so we can easily call InputText() on static arrays using ARRAYSIZE() and to match
//   Note that in std::string world, capacity() would omit 1 byte used by the zero-terminator.
// - When active, hold on a privately held copy of the text (and apply back to 'buf'). So changing 'buf' while the InputText is active has no effect.
// - If you want to use ImGui::InputText() with std::string, see misc/cpp/imgui_stdlib.h
// (FIXME: Rather confusing and messy function, among the worse part of our codebase, expecting to rewrite a V2 at some point.. Partly because we are
//  doing UTF8 > U16 > UTF8 conversions on the go to easily interface with stb_textedit. Ideally should stay in UTF-8 all the time. See https://github.com/nothings/stb/issues/188)
bool ImGui::InputTextEx( const char* label, const char* hint, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* callback_user_data )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	IM_ASSERT( !( ( flags & ImGuiInputTextFlags_CallbackHistory ) && ( flags & ImGuiInputTextFlags_Multiline ) ) );        // Can't use both together (they both use up/down keys)
	IM_ASSERT( !( ( flags & ImGuiInputTextFlags_CallbackCompletion ) && ( flags & ImGuiInputTextFlags_AllowTabInput ) ) ); // Can't use both together (they both use tab key)

	ImGuiContext& g = *GImGui;
	ImGuiIO& io = g.IO;
	const ImGuiStyle& style = g.Style;

	const bool RENDER_SELECTION_WHEN_INACTIVE = false;
	const bool is_multiline = ( flags & ImGuiInputTextFlags_Multiline ) != 0;
	const bool is_readonly = ( flags & ImGuiInputTextFlags_ReadOnly ) != 0;
	const bool is_password = ( flags & ImGuiInputTextFlags_Password ) != 0;
	const bool is_undoable = ( flags & ImGuiInputTextFlags_NoUndoRedo ) == 0;
	const bool is_resizable = ( flags & ImGuiInputTextFlags_CallbackResize ) != 0;
	if( is_resizable )
		IM_ASSERT( callback != NULL ); // Must provide a callback if you set the ImGuiInputTextFlags_CallbackResize flag!

	if( is_multiline ) // Open group before calling GetID() because groups tracks id created within their scope,
		BeginGroup();
	const ImGuiID id = window->GetID( label );
	const ImVec2 label_size = CalcTextSize( label, NULL, true );
	const ImVec2 frame_size = CalcItemSize( size_arg, CalcItemWidth(), ( is_multiline ? g.FontSize * 8.0f : label_size.y ) + style.FramePadding.y * 2.0f ); // Arbitrary default of 8 lines high for multi-line
	const ImVec2 total_size = ImVec2( frame_size.x + ( label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f ), frame_size.y );

	const ImRect frame_bb( window->DC.CursorPos, window->DC.CursorPos + frame_size );
	const ImRect total_bb( frame_bb.Min, frame_bb.Min + total_size );

	ImGuiWindow* draw_window = window;
	ImVec2 inner_size = frame_size;
	if( is_multiline )
	{
		if( !ItemAdd( total_bb, id, &frame_bb ) )
		{
			ItemSize( total_bb, style.FramePadding.y );
			EndGroup();
			return false;
		}

		// We reproduce the contents of BeginChildFrame() in order to provide 'label' so our window internal data are easier to read/debug.
		PushStyleColor( ImGuiCol_ChildBg, style.Colors[ ImGuiCol_FrameBg ] );
		PushStyleVar( ImGuiStyleVar_ChildRounding, style.FrameRounding );
		PushStyleVar( ImGuiStyleVar_ChildBorderSize, style.FrameBorderSize );
		PushStyleVar( ImGuiStyleVar_WindowPadding, style.FramePadding );
		bool child_visible = BeginChildEx( label, id, frame_bb.GetSize(), true, ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysUseWindowPadding );
		PopStyleVar( 3 );
		PopStyleColor();
		if( !child_visible )
		{
			EndChild();
			EndGroup();
			return false;
		}
		draw_window = g.CurrentWindow; // Child window
		draw_window->DC.NavLayerActiveMaskNext |= draw_window->DC.NavLayerCurrentMask; // This is to ensure that EndChild() will display a navigation highlight so we can "enter" into it.
		inner_size.x -= draw_window->ScrollbarSizes.x;
	}
	else
	{
		ItemSize( total_bb, style.FramePadding.y );
		if( !ItemAdd( total_bb, id, &frame_bb ) )
			return false;
	}
	const bool hovered = ItemHoverable( frame_bb, id );
	if( hovered )
		g.MouseCursor = ImGuiMouseCursor_TextInput;

	// We are only allowed to access the state if we are already the active widget.
	ImGuiInputTextState* state = GetInputTextState( id );

	const bool focus_requested = FocusableItemRegister( window, id );
	const bool focus_requested_by_code = focus_requested && ( g.FocusRequestCurrWindow == window && g.FocusRequestCurrCounterRegular == window->DC.FocusCounterRegular );
	const bool focus_requested_by_tab = focus_requested && !focus_requested_by_code;

	const bool user_clicked = hovered && io.MouseClicked[ 0 ];
	const bool user_nav_input_start = ( g.ActiveId != id ) && ( ( g.NavInputId == id ) || ( g.NavActivateId == id && g.NavInputSource == ImGuiInputSource_NavKeyboard ) );
	const bool user_scroll_finish = is_multiline && state != NULL && g.ActiveId == 0 && g.ActiveIdPreviousFrame == GetWindowScrollbarID( draw_window, ImGuiAxis_Y );
	const bool user_scroll_active = is_multiline && state != NULL && g.ActiveId == GetWindowScrollbarID( draw_window, ImGuiAxis_Y );

	bool clear_active_id = false;
	bool select_all = ( g.ActiveId != id ) && ( ( flags & ImGuiInputTextFlags_AutoSelectAll ) != 0 || user_nav_input_start ) && ( !is_multiline );

	const bool init_make_active = ( focus_requested || user_clicked || user_scroll_finish || user_nav_input_start );
	const bool init_state = ( init_make_active || user_scroll_active );
	if( init_state && g.ActiveId != id )
	{
		// Access state even if we don't own it yet.
		state = &g.InputTextState;
		state->CursorAnimReset();

		// Take a copy of the initial buffer value (both in original UTF-8 format and converted to wchar)
		// From the moment we focused we are ignoring the content of 'buf' (unless we are in read-only mode)
		const int buf_len = ( int )win32::strlen( buf );
		state->InitialTextA.resize( buf_len + 1 );    // UTF-8. we use +1 to make sure that .Data is always pointing to at least an empty string.
		std::memcpy( state->InitialTextA.Data, buf, static_cast< std::size_t >( buf_len + 1 ) );

		// Start edition
		const char* buf_end = NULL;
		state->TextW.resize( buf_size + 1 );          // wchar count <= UTF-8 count. we use +1 to make sure that .Data is always pointing to at least an empty string.
		state->TextA.resize( 0 );
		state->TextAIsValid = false;                // TextA is not valid yet (we will display buf until then)
		state->CurLenW = ImTextStrFromUtf8( state->TextW.Data, buf_size, buf, NULL, &buf_end );
		state->CurLenA = ( int )( buf_end - buf );      // We can't get the result from ImStrncpy() above because it is not UTF-8 aware. Here we'll cut off malformed UTF-8.

		// Preserve cursor position and undo/redo stack if we come back to same widget
		// FIXME: For non-readonly widgets we might be able to require that TextAIsValid && TextA == buf ? (untested) and discard undo stack if user buffer has changed.
		const bool recycle_state = ( state->ID == id );
		if( recycle_state )
		{
			// Recycle existing cursor/selection/undo stack but clamp position
			// Note a single mouse click will override the cursor/position immediately by calling stb_textedit_click handler.
			state->CursorClamp();
		}
		else
		{
			state->ID = id;
			state->ScrollX = 0.0f;
			stb_textedit_initialize_state( &state->Stb, !is_multiline );
			if( !is_multiline && focus_requested_by_code )
				select_all = true;
		}
		if( flags & ImGuiInputTextFlags_AlwaysInsertMode )
			state->Stb.insert_mode = 1;
		if( !is_multiline && ( focus_requested_by_tab || ( user_clicked && io.KeyCtrl ) ) )
			select_all = true;
	}

	if( g.ActiveId != id && init_make_active )
	{
		IM_ASSERT( state && state->ID == id );
		SetActiveID( id, window );
		SetFocusID( id, window );
		FocusWindow( window );

		// Declare our inputs
		IM_ASSERT( ImGuiNavInput_COUNT < 32 );
		g.ActiveIdUsingNavDirMask |= ( 1 << ImGuiDir_Left ) | ( 1 << ImGuiDir_Right );
		if( is_multiline || ( flags & ImGuiInputTextFlags_CallbackHistory ) )
			g.ActiveIdUsingNavDirMask |= ( 1 << ImGuiDir_Up ) | ( 1 << ImGuiDir_Down );
		g.ActiveIdUsingNavInputMask |= ( 1 << ImGuiNavInput_Cancel );
		g.ActiveIdUsingKeyInputMask |= ( ( ImU64 )1 << ImGuiKey_Home ) | ( ( ImU64 )1 << ImGuiKey_End );
		if( is_multiline )
			g.ActiveIdUsingKeyInputMask |= ( ( ImU64 )1 << ImGuiKey_PageUp ) | ( ( ImU64 )1 << ImGuiKey_PageDown ); // FIXME-NAV: Page up/down actually not supported yet by widget, but claim them ahead.
		if( flags & ( ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_AllowTabInput ) )  // Disable keyboard tabbing out as we will use the \t character.
			g.ActiveIdUsingKeyInputMask |= ( ( ImU64 )1 << ImGuiKey_Tab );
	}

	// We have an edge case if ActiveId was set through another widget (e.g. widget being swapped), clear id immediately (don't wait until the end of the function)
	if( g.ActiveId == id && state == NULL )
		ClearActiveID();

	// Release focus when we click outside
	if( g.ActiveId == id && io.MouseClicked[ 0 ] && !init_state && !init_make_active ) //-V560
		clear_active_id = true;

	// Lock the decision of whether we are going to take the path displaying the cursor or selection
	const bool render_cursor = ( g.ActiveId == id ) || ( state && user_scroll_active );
	bool render_selection = state && state->HasSelection() && ( RENDER_SELECTION_WHEN_INACTIVE || render_cursor );
	bool value_changed = false;
	bool enter_pressed = false;

	// When read-only we always use the live data passed to the function
	// FIXME-OPT: Because our selection/cursor code currently needs the wide text we need to convert it when active, which is not ideal :(
	if( is_readonly && state != NULL && ( render_cursor || render_selection ) )
	{
		const char* buf_end = NULL;
		state->TextW.resize( buf_size + 1 );
		state->CurLenW = ImTextStrFromUtf8( state->TextW.Data, state->TextW.Size, buf, NULL, &buf_end );
		state->CurLenA = ( int )( buf_end - buf );
		state->CursorClamp();
		render_selection &= state->HasSelection();
	}

	// Select the buffer to render.
	const bool buf_display_from_state = ( render_cursor || render_selection || g.ActiveId == id ) && !is_readonly && state && state->TextAIsValid;
	const bool is_displaying_hint = ( hint != NULL && ( buf_display_from_state ? state->TextA.Data : buf )[ 0 ] == 0 );

	// Password pushes a temporary font with only a fallback glyph
	if( is_password && !is_displaying_hint )
	{
		const ImFontGlyph* glyph = g.Font->FindGlyph( '*' );
		ImFont* password_font = &g.InputTextPasswordFont;
		password_font->FontSize = g.Font->FontSize;
		password_font->Scale = g.Font->Scale;
		password_font->DisplayOffset = g.Font->DisplayOffset;
		password_font->Ascent = g.Font->Ascent;
		password_font->Descent = g.Font->Descent;
		password_font->ContainerAtlas = g.Font->ContainerAtlas;
		password_font->FallbackGlyph = glyph;
		password_font->FallbackAdvanceX = glyph->AdvanceX;
		IM_ASSERT( password_font->Glyphs.empty() && password_font->IndexAdvanceX.empty() && password_font->IndexLookup.empty() );
		PushFont( password_font );
	}

	// Process mouse inputs and character inputs
	int backup_current_text_length = 0;
	if( g.ActiveId == id )
	{
		IM_ASSERT( state != NULL );
		backup_current_text_length = state->CurLenA;
		state->BufCapacityA = buf_size;
		state->UserFlags = flags;
		state->UserCallback = callback;
		state->UserCallbackData = callback_user_data;

		// Although we are active we don't prevent mouse from hovering other elements unless we are interacting right now with the widget.
		// Down the line we should have a cleaner library-wide concept of Selected vs Active.
		g.ActiveIdAllowOverlap = !io.MouseDown[ 0 ];
		g.WantTextInputNextFrame = 1;

		// Edit in progress
		const float mouse_x = ( io.MousePos.x - frame_bb.Min.x - style.FramePadding.x ) + state->ScrollX;
		const float mouse_y = ( is_multiline ? ( io.MousePos.y - draw_window->DC.CursorPos.y - style.FramePadding.y ) : ( g.FontSize * 0.5f ) );

		const bool is_osx = io.ConfigMacOSXBehaviors;
		if( select_all || ( hovered && !is_osx && io.MouseDoubleClicked[ 0 ] ) )
		{
			state->SelectAll();
			state->SelectedAllMouseLock = true;
		}
		else if( hovered && is_osx && io.MouseDoubleClicked[ 0 ] )
		{
			// Double-click select a word only, OS X style (by simulating keystrokes)
			state->OnKeyPressed( STB_TEXTEDIT_K_WORDLEFT );
			state->OnKeyPressed( STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT );
		}
		else if( io.MouseClicked[ 0 ] && !state->SelectedAllMouseLock )
		{
			if( hovered )
			{
				stb_textedit_click( state, &state->Stb, mouse_x, mouse_y );
				state->CursorAnimReset();
			}
		}
		else if( io.MouseDown[ 0 ] && !state->SelectedAllMouseLock && ( io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f ) )
		{
			stb_textedit_drag( state, &state->Stb, mouse_x, mouse_y );
			state->CursorAnimReset();
			state->CursorFollow = true;
		}
		if( state->SelectedAllMouseLock && !io.MouseDown[ 0 ] )
			state->SelectedAllMouseLock = false;

		// It is ill-defined whether the back-end needs to send a \t character when pressing the TAB keys.
		// Win32 and GLFW naturally do it but not SDL.
		const bool ignore_char_inputs = ( io.KeyCtrl && !io.KeyAlt ) || ( is_osx && io.KeySuper );
		if( ( flags & ImGuiInputTextFlags_AllowTabInput ) && IsKeyPressedMap( ImGuiKey_Tab ) && !ignore_char_inputs && !io.KeyShift && !is_readonly )
			if( !io.InputQueueCharacters.contains( '\t' ) )
			{
				unsigned int c = '\t'; // Insert TAB
				if( InputTextFilterCharacter( &c, flags, callback, callback_user_data ) )
					state->OnKeyPressed( ( int )c );
			}

		// Process regular text input (before we check for Return because using some IME will effectively send a Return?)
		// We ignore CTRL inputs, but need to allow ALT+CTRL as some keyboards (e.g. German) use AltGR (which _is_ Alt+Ctrl) to input certain characters.
		if( io.InputQueueCharacters.Size > 0 )
		{
			if( !ignore_char_inputs && !is_readonly && !user_nav_input_start )
				for( int n = 0; n < io.InputQueueCharacters.Size; n++ )
				{
					// Insert character if they pass filtering
					unsigned int c = ( unsigned int )io.InputQueueCharacters[ n ];
					if( c == '\t' && io.KeyShift )
						continue;
					if( InputTextFilterCharacter( &c, flags, callback, callback_user_data ) )
						state->OnKeyPressed( ( int )c );
				}

			// Consume characters
			io.InputQueueCharacters.resize( 0 );
		}
	}

	// Process other shortcuts/key-presses
	bool cancel_edit = false;
	if( g.ActiveId == id && !g.ActiveIdIsJustActivated && !clear_active_id )
	{
		IM_ASSERT( state != NULL );
		IM_ASSERT( io.KeyMods == GetMergedKeyModFlags() && "Mismatching io.KeyCtrl/io.KeyShift/io.KeyAlt/io.KeySuper vs io.KeyMods" ); // We rarely do this check, but if anything let's do it here.

		const int k_mask = ( io.KeyShift ? STB_TEXTEDIT_K_SHIFT : 0 );
		const bool is_osx = io.ConfigMacOSXBehaviors;
		const bool is_osx_shift_shortcut = is_osx && ( io.KeyMods == ( ImGuiKeyModFlags_Super | ImGuiKeyModFlags_Shift ) );
		const bool is_wordmove_key_down = is_osx ? io.KeyAlt : io.KeyCtrl;                     // OS X style: Text editing cursor movement using Alt instead of Ctrl
		const bool is_startend_key_down = is_osx && io.KeySuper && !io.KeyCtrl && !io.KeyAlt;  // OS X style: Line/Text Start and End using Cmd+Arrows instead of Home/End
		const bool is_ctrl_key_only = ( io.KeyMods == ImGuiKeyModFlags_Ctrl );
		const bool is_shift_key_only = ( io.KeyMods == ImGuiKeyModFlags_Shift );
		const bool is_shortcut_key = g.IO.ConfigMacOSXBehaviors ? ( io.KeyMods == ImGuiKeyModFlags_Super ) : ( io.KeyMods == ImGuiKeyModFlags_Ctrl );

		const bool is_cut = ( ( is_shortcut_key && IsKeyPressedMap( ImGuiKey_X ) ) || ( is_shift_key_only && IsKeyPressedMap( ImGuiKey_Delete ) ) ) && !is_readonly && !is_password && ( !is_multiline || state->HasSelection() );
		const bool is_copy = ( ( is_shortcut_key && IsKeyPressedMap( ImGuiKey_C ) ) || ( is_ctrl_key_only && IsKeyPressedMap( ImGuiKey_Insert ) ) ) && !is_password && ( !is_multiline || state->HasSelection() );
		const bool is_paste = ( ( is_shortcut_key && IsKeyPressedMap( ImGuiKey_V ) ) || ( is_shift_key_only && IsKeyPressedMap( ImGuiKey_Insert ) ) ) && !is_readonly;
		const bool is_undo = ( ( is_shortcut_key && IsKeyPressedMap( ImGuiKey_Z ) ) && !is_readonly && is_undoable );
		const bool is_redo = ( ( is_shortcut_key && IsKeyPressedMap( ImGuiKey_Y ) ) || ( is_osx_shift_shortcut && IsKeyPressedMap( ImGuiKey_Z ) ) ) && !is_readonly && is_undoable;

		if( IsKeyPressedMap( ImGuiKey_LeftArrow ) )
		{
			state->OnKeyPressed( ( is_startend_key_down ? STB_TEXTEDIT_K_LINESTART : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT : STB_TEXTEDIT_K_LEFT ) | k_mask );
		}
		else if( IsKeyPressedMap( ImGuiKey_RightArrow ) )
		{
			state->OnKeyPressed( ( is_startend_key_down ? STB_TEXTEDIT_K_LINEEND : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT : STB_TEXTEDIT_K_RIGHT ) | k_mask );
		}
		else if( IsKeyPressedMap( ImGuiKey_UpArrow ) && is_multiline )
		{
			if( io.KeyCtrl ) SetScrollY( draw_window, ImMax( draw_window->Scroll.y - g.FontSize, 0.0f ) ); else state->OnKeyPressed( ( is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART : STB_TEXTEDIT_K_UP ) | k_mask );
		}
		else if( IsKeyPressedMap( ImGuiKey_DownArrow ) && is_multiline )
		{
			if( io.KeyCtrl ) SetScrollY( draw_window, ImMin( draw_window->Scroll.y + g.FontSize, GetScrollMaxY() ) ); else state->OnKeyPressed( ( is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN ) | k_mask );
		}
		else if( IsKeyPressedMap( ImGuiKey_Home ) )
		{
			state->OnKeyPressed( io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask : STB_TEXTEDIT_K_LINESTART | k_mask );
		}
		else if( IsKeyPressedMap( ImGuiKey_End ) )
		{
			state->OnKeyPressed( io.KeyCtrl ? STB_TEXTEDIT_K_TEXTEND | k_mask : STB_TEXTEDIT_K_LINEEND | k_mask );
		}
		else if( IsKeyPressedMap( ImGuiKey_Delete ) && !is_readonly )
		{
			state->OnKeyPressed( STB_TEXTEDIT_K_DELETE | k_mask );
		}
		else if( IsKeyPressedMap( ImGuiKey_Backspace ) && !is_readonly )
		{
			if( !state->HasSelection() )
			{
				if( is_wordmove_key_down )
					state->OnKeyPressed( STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT );
				else if( is_osx && io.KeySuper && !io.KeyAlt && !io.KeyCtrl )
					state->OnKeyPressed( STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT );
			}
			state->OnKeyPressed( STB_TEXTEDIT_K_BACKSPACE | k_mask );
		}
		else if( IsKeyPressedMap( ImGuiKey_Enter ) || IsKeyPressedMap( ImGuiKey_KeyPadEnter ) )
		{
			bool ctrl_enter_for_new_line = ( flags & ImGuiInputTextFlags_CtrlEnterForNewLine ) != 0;
			if( !is_multiline || ( ctrl_enter_for_new_line && !io.KeyCtrl ) || ( !ctrl_enter_for_new_line && io.KeyCtrl ) )
			{
				enter_pressed = clear_active_id = true;
			}
			else if( !is_readonly )
			{
				unsigned int c = '\n'; // Insert new line
				if( InputTextFilterCharacter( &c, flags, callback, callback_user_data ) )
					state->OnKeyPressed( ( int )c );
			}
		}
		else if( IsKeyPressedMap( ImGuiKey_Escape ) )
		{
			clear_active_id = cancel_edit = true;
		}
		else if( is_undo || is_redo )
		{
			state->OnKeyPressed( is_undo ? STB_TEXTEDIT_K_UNDO : STB_TEXTEDIT_K_REDO );
			state->ClearSelection();
		}
		else if( is_shortcut_key && IsKeyPressedMap( ImGuiKey_A ) )
		{
			state->SelectAll();
			state->CursorFollow = true;
		}
		else if( is_cut || is_copy )
		{
			// Cut, Copy
			if( io.SetClipboardTextFn )
			{
				const int ib = state->HasSelection() ? ImMin( state->Stb.select_start, state->Stb.select_end ) : 0;
				const int ie = state->HasSelection() ? ImMax( state->Stb.select_start, state->Stb.select_end ) : state->CurLenW;
				const int clipboard_data_len = ImTextCountUtf8BytesFromStr( state->TextW.Data + ib, state->TextW.Data + ie ) + 1;
				char* clipboard_data = ( char* )IM_ALLOC( clipboard_data_len * sizeof( char ) );
				ImTextStrToUtf8( clipboard_data, clipboard_data_len, state->TextW.Data + ib, state->TextW.Data + ie );
				SetClipboardText( clipboard_data );
				MemFree( clipboard_data );
			}
			if( is_cut )
			{
				if( !state->HasSelection() )
					state->SelectAll();
				state->CursorFollow = true;
				stb_textedit_cut( state, &state->Stb );
			}
		}
		else if( is_paste )
		{
			if( const char* clipboard = GetClipboardText() )
			{
				// Filter pasted buffer
				const int clipboard_len = ( int )strlen( clipboard );
				ImWchar* clipboard_filtered = ( ImWchar* )IM_ALLOC( ( clipboard_len + 1 ) * sizeof( ImWchar ) );
				int clipboard_filtered_len = 0;
				for( const char* s = clipboard; *s; )
				{
					unsigned int c;
					s += ImTextCharFromUtf8( &c, s, NULL );
					if( c == 0 )
						break;
					if( !InputTextFilterCharacter( &c, flags, callback, callback_user_data ) )
						continue;
					clipboard_filtered[ clipboard_filtered_len++ ] = ( ImWchar )c;
				}
				clipboard_filtered[ clipboard_filtered_len ] = 0;
				if( clipboard_filtered_len > 0 ) // If everything was filtered, ignore the pasting operation
				{
					stb_textedit_paste( state, &state->Stb, clipboard_filtered, clipboard_filtered_len );
					state->CursorFollow = true;
				}
				MemFree( clipboard_filtered );
			}
		}

		// Update render selection flag after events have been handled, so selection highlight can be displayed during the same frame.
		render_selection |= state->HasSelection() && ( RENDER_SELECTION_WHEN_INACTIVE || render_cursor );
	}

	// Process callbacks and apply result back to user's buffer.
	if( g.ActiveId == id )
	{
		IM_ASSERT( state != NULL );
		const char* apply_new_text = NULL;
		int apply_new_text_length = 0;
		if( cancel_edit )
		{
			// Restore initial value. Only return true if restoring to the initial value changes the current buffer contents.
			if( !is_readonly && strcmp( buf, state->InitialTextA.Data ) != 0 )
			{
				// Push records into the undo stack so we can CTRL+Z the revert operation itself
				apply_new_text = state->InitialTextA.Data;
				apply_new_text_length = state->InitialTextA.Size - 1;
				ImVector<ImWchar> w_text;
				if( apply_new_text_length > 0 )
				{
					w_text.resize( ImTextCountCharsFromUtf8( apply_new_text, apply_new_text + apply_new_text_length ) + 1 );
					ImTextStrFromUtf8( w_text.Data, w_text.Size, apply_new_text, apply_new_text + apply_new_text_length );
				}
				stb_textedit_replace( state, &state->Stb, w_text.Data, ( apply_new_text_length > 0 ) ? ( w_text.Size - 1 ) : 0 );
			}
		}

		// When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special case we reapply the live buffer back to the input buffer before clearing ActiveId, even though strictly speaking it wasn't modified on this frame.
		// If we didn't do that, code like InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail.
		// This also allows the user to use InputText() with ImGuiInputTextFlags_EnterReturnsTrue without maintaining any user-side storage (please note that if you use this property along ImGuiInputTextFlags_CallbackResize you can end up with your temporary string object unnecessarily allocating once a frame, either store your string data, either if you don't then don't use ImGuiInputTextFlags_CallbackResize).
		bool apply_edit_back_to_user_buffer = !cancel_edit || ( enter_pressed && ( flags & ImGuiInputTextFlags_EnterReturnsTrue ) != 0 );
		if( apply_edit_back_to_user_buffer )
		{
			// Apply new value immediately - copy modified buffer back
			// Note that as soon as the input box is active, the in-widget value gets priority over any underlying modification of the input buffer
			// FIXME: We actually always render 'buf' when calling DrawList->AddText, making the comment above incorrect.
			// FIXME-OPT: CPU waste to do this every time the widget is active, should mark dirty state from the stb_textedit callbacks.
			if( !is_readonly )
			{
				state->TextAIsValid = true;
				state->TextA.resize( state->TextW.Size * 4 + 1 );
				ImTextStrToUtf8( state->TextA.Data, state->TextA.Size, state->TextW.Data, NULL );
			}

			// User callback
			if( ( flags & ( ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory | ImGuiInputTextFlags_CallbackAlways ) ) != 0 )
			{
				IM_ASSERT( callback != NULL );

				// The reason we specify the usage semantic (Completion/History) is that Completion needs to disable keyboard TABBING at the moment.
				ImGuiInputTextFlags event_flag = 0;
				ImGuiKey event_key = ImGuiKey_COUNT;
				if( ( flags & ImGuiInputTextFlags_CallbackCompletion ) != 0 && IsKeyPressedMap( ImGuiKey_Tab ) )
				{
					event_flag = ImGuiInputTextFlags_CallbackCompletion;
					event_key = ImGuiKey_Tab;
				}
				else if( ( flags & ImGuiInputTextFlags_CallbackHistory ) != 0 && IsKeyPressedMap( ImGuiKey_UpArrow ) )
				{
					event_flag = ImGuiInputTextFlags_CallbackHistory;
					event_key = ImGuiKey_UpArrow;
				}
				else if( ( flags & ImGuiInputTextFlags_CallbackHistory ) != 0 && IsKeyPressedMap( ImGuiKey_DownArrow ) )
				{
					event_flag = ImGuiInputTextFlags_CallbackHistory;
					event_key = ImGuiKey_DownArrow;
				}
				else if( flags & ImGuiInputTextFlags_CallbackAlways )
					event_flag = ImGuiInputTextFlags_CallbackAlways;

				if( event_flag )
				{
					ImGuiInputTextCallbackData callback_data;
					memset( &callback_data, 0, sizeof( ImGuiInputTextCallbackData ) );
					callback_data.EventFlag = event_flag;
					callback_data.Flags = flags;
					callback_data.UserData = callback_user_data;

					callback_data.EventKey = event_key;
					callback_data.Buf = state->TextA.Data;
					callback_data.BufTextLen = state->CurLenA;
					callback_data.BufSize = state->BufCapacityA;
					callback_data.BufDirty = false;

					// We have to convert from wchar-positions to UTF-8-positions, which can be pretty slow (an incentive to ditch the ImWchar buffer, see https://github.com/nothings/stb/issues/188)
					ImWchar* text = state->TextW.Data;
					const int utf8_cursor_pos = callback_data.CursorPos = ImTextCountUtf8BytesFromStr( text, text + state->Stb.cursor );
					const int utf8_selection_start = callback_data.SelectionStart = ImTextCountUtf8BytesFromStr( text, text + state->Stb.select_start );
					const int utf8_selection_end = callback_data.SelectionEnd = ImTextCountUtf8BytesFromStr( text, text + state->Stb.select_end );

					// Call user code
					callback( &callback_data );

					// Read back what user may have modified
					IM_ASSERT( callback_data.Buf == state->TextA.Data );  // Invalid to modify those fields
					IM_ASSERT( callback_data.BufSize == state->BufCapacityA );
					IM_ASSERT( callback_data.Flags == flags );
					if( callback_data.CursorPos != utf8_cursor_pos )
					{
						state->Stb.cursor = ImTextCountCharsFromUtf8( callback_data.Buf, callback_data.Buf + callback_data.CursorPos ); state->CursorFollow = true;
					}
					if( callback_data.SelectionStart != utf8_selection_start )
					{
						state->Stb.select_start = ImTextCountCharsFromUtf8( callback_data.Buf, callback_data.Buf + callback_data.SelectionStart );
					}
					if( callback_data.SelectionEnd != utf8_selection_end )
					{
						state->Stb.select_end = ImTextCountCharsFromUtf8( callback_data.Buf, callback_data.Buf + callback_data.SelectionEnd );
					}
					if( callback_data.BufDirty )
					{
						IM_ASSERT( callback_data.BufTextLen == ( int )strlen( callback_data.Buf ) ); // You need to maintain BufTextLen if you change the text!
						if( callback_data.BufTextLen > backup_current_text_length && is_resizable )
							state->TextW.resize( state->TextW.Size + ( callback_data.BufTextLen - backup_current_text_length ) );
						state->CurLenW = ImTextStrFromUtf8( state->TextW.Data, state->TextW.Size, callback_data.Buf, NULL );
						state->CurLenA = callback_data.BufTextLen;  // Assume correct length and valid UTF-8 from user, saves us an extra strlen()
						state->CursorAnimReset();
					}
				}
			}

			// Will copy result string if modified
			if( !is_readonly && strcmp( state->TextA.Data, buf ) != 0 )
			{
				apply_new_text = state->TextA.Data;
				apply_new_text_length = state->CurLenA;
			}
		}

		// Copy result to user buffer
		if( apply_new_text )
		{
			// We cannot test for 'backup_current_text_length != apply_new_text_length' here because we have no guarantee that the size
			// of our owned buffer matches the size of the string object held by the user, and by design we allow InputText() to be used
			// without any storage on user's side.
			IM_ASSERT( apply_new_text_length >= 0 );
			if( is_resizable )
			{
				ImGuiInputTextCallbackData callback_data;
				callback_data.EventFlag = ImGuiInputTextFlags_CallbackResize;
				callback_data.Flags = flags;
				callback_data.Buf = buf;
				callback_data.BufTextLen = apply_new_text_length;
				callback_data.BufSize = ImMax( buf_size, apply_new_text_length + 1 );
				callback_data.UserData = callback_user_data;
				callback( &callback_data );
				buf = callback_data.Buf;
				buf_size = callback_data.BufSize;
				apply_new_text_length = ImMin( callback_data.BufTextLen, buf_size - 1 );
				IM_ASSERT( apply_new_text_length <= buf_size );
			}
			//IMGUI_DEBUG_LOG("InputText(\"%s\"): apply_new_text length %d\n", label, apply_new_text_length);

			// If the underlying buffer resize was denied or not carried to the next frame, apply_new_text_length+1 may be >= buf_size.
			ImStrncpy( buf, apply_new_text, ImMin( apply_new_text_length + 1, buf_size ) );
			value_changed = true;
		}

		// Clear temporary user storage
		state->UserFlags = 0;
		state->UserCallback = NULL;
		state->UserCallbackData = NULL;
	}

	// Release active ID at the end of the function (so e.g. pressing Return still does a final application of the value)
	if( clear_active_id && g.ActiveId == id )
		ClearActiveID();

	// Render frame
	if( !is_multiline )
	{
		RenderNavHighlight( frame_bb, id );
		RenderFrame( frame_bb.Min, frame_bb.Max, GetColorU32( ImGuiCol_FrameBg ), true, style.FrameRounding );
	}

	const ImVec4 clip_rect( frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + inner_size.x, frame_bb.Min.y + inner_size.y ); // Not using frame_bb.Max because we have adjusted size
	ImVec2 draw_pos = is_multiline ? draw_window->DC.CursorPos : frame_bb.Min + style.FramePadding;
	ImVec2 text_size( 0.0f, 0.0f );

	// Set upper limit of single-line InputTextEx() at 2 million characters strings. The current pathological worst case is a long line
	// without any carriage return, which would makes ImFont::RenderText() reserve too many vertices and probably crash. Avoid it altogether.
	// Note that we only use this limit on single-line InputText(), so a pathologically large line on a InputTextMultiline() would still crash.
	const int buf_display_max_length = 2 * 1024 * 1024;
	const char* buf_display = buf_display_from_state ? state->TextA.Data : buf; //-V595
	const char* buf_display_end = NULL; // We have specialized paths below for setting the length
	if( is_displaying_hint )
	{
		buf_display = hint;
		buf_display_end = hint + strlen( hint );
	}

	// Render text. We currently only render selection when the widget is active or while scrolling.
	// FIXME: We could remove the '&& render_cursor' to keep rendering selection when inactive.
	if( render_cursor || render_selection )
	{
		IM_ASSERT( state != NULL );
		if( !is_displaying_hint )
			buf_display_end = buf_display + state->CurLenA;

		// Render text (with cursor and selection)
		// This is going to be messy. We need to:
		// - Display the text (this alone can be more easily clipped)
		// - Handle scrolling, highlight selection, display cursor (those all requires some form of 1d->2d cursor position calculation)
		// - Measure text height (for scrollbar)
		// We are attempting to do most of that in **one main pass** to minimize the computation cost (non-negligible for large amount of text) + 2nd pass for selection rendering (we could merge them by an extra refactoring effort)
		// FIXME: This should occur on buf_display but we'd need to maintain cursor/select_start/select_end for UTF-8.
		const ImWchar* text_begin = state->TextW.Data;
		ImVec2 cursor_offset, select_start_offset;

		{
			// Find lines numbers straddling 'cursor' (slot 0) and 'select_start' (slot 1) positions.
			const ImWchar* searches_input_ptr[ 2 ] = { NULL, NULL };
			int searches_result_line_no[ 2 ] = { -1000, -1000 };
			int searches_remaining = 0;
			if( render_cursor )
			{
				searches_input_ptr[ 0 ] = text_begin + state->Stb.cursor;
				searches_result_line_no[ 0 ] = -1;
				searches_remaining++;
			}
			if( render_selection )
			{
				searches_input_ptr[ 1 ] = text_begin + ImMin( state->Stb.select_start, state->Stb.select_end );
				searches_result_line_no[ 1 ] = -1;
				searches_remaining++;
			}

			// Iterate all lines to find our line numbers
			// In multi-line mode, we never exit the loop until all lines are counted, so add one extra to the searches_remaining counter.
			searches_remaining += is_multiline ? 1 : 0;
			int line_count = 0;
			//for (const ImWchar* s = text_begin; (s = (const ImWchar*)wcschr((const wchar_t*)s, (wchar_t)'\n')) != NULL; s++)  // FIXME-OPT: Could use this when wchar_t are 16-bit
			for( const ImWchar* s = text_begin; *s != 0; s++ )
				if( *s == '\n' )
				{
					line_count++;
					if( searches_result_line_no[ 0 ] == -1 && s >= searches_input_ptr[ 0 ] )
					{
						searches_result_line_no[ 0 ] = line_count; if( --searches_remaining <= 0 ) break;
					}
					if( searches_result_line_no[ 1 ] == -1 && s >= searches_input_ptr[ 1 ] )
					{
						searches_result_line_no[ 1 ] = line_count; if( --searches_remaining <= 0 ) break;
					}
				}
			line_count++;
			if( searches_result_line_no[ 0 ] == -1 )
				searches_result_line_no[ 0 ] = line_count;
			if( searches_result_line_no[ 1 ] == -1 )
				searches_result_line_no[ 1 ] = line_count;

			// Calculate 2d position by finding the beginning of the line and measuring distance
			cursor_offset.x = InputTextCalcTextSizeW( ImStrbolW( searches_input_ptr[ 0 ], text_begin ), searches_input_ptr[ 0 ] ).x;
			cursor_offset.y = searches_result_line_no[ 0 ] * g.FontSize;
			if( searches_result_line_no[ 1 ] >= 0 )
			{
				select_start_offset.x = InputTextCalcTextSizeW( ImStrbolW( searches_input_ptr[ 1 ], text_begin ), searches_input_ptr[ 1 ] ).x;
				select_start_offset.y = searches_result_line_no[ 1 ] * g.FontSize;
			}

			// Store text height (note that we haven't calculated text width at all, see GitHub issues #383, #1224)
			if( is_multiline )
				text_size = ImVec2( inner_size.x, line_count * g.FontSize );
		}

		// Scroll
		if( render_cursor && state->CursorFollow )
		{
			// Horizontal scroll in chunks of quarter width
			if( !( flags & ImGuiInputTextFlags_NoHorizontalScroll ) )
			{
				const float scroll_increment_x = inner_size.x * 0.25f;
				if( cursor_offset.x < state->ScrollX )
					state->ScrollX = IM_FLOOR( ImMax( 0.0f, cursor_offset.x - scroll_increment_x ) );
				else if( cursor_offset.x - inner_size.x >= state->ScrollX )
					state->ScrollX = IM_FLOOR( cursor_offset.x - inner_size.x + scroll_increment_x );
			}
			else
			{
				state->ScrollX = 0.0f;
			}

			// Vertical scroll
			if( is_multiline )
			{
				float scroll_y = draw_window->Scroll.y;
				if( cursor_offset.y - g.FontSize < scroll_y )
					scroll_y = ImMax( 0.0f, cursor_offset.y - g.FontSize );
				else if( cursor_offset.y - inner_size.y >= scroll_y )
					scroll_y = cursor_offset.y - inner_size.y;
				draw_pos.y += ( draw_window->Scroll.y - scroll_y );   // Manipulate cursor pos immediately avoid a frame of lag
				draw_window->Scroll.y = scroll_y;
			}

			state->CursorFollow = false;
		}

		// Draw selection
		const ImVec2 draw_scroll = ImVec2( state->ScrollX, 0.0f );
		if( render_selection )
		{
			const ImWchar* text_selected_begin = text_begin + ImMin( state->Stb.select_start, state->Stb.select_end );
			const ImWchar* text_selected_end = text_begin + ImMax( state->Stb.select_start, state->Stb.select_end );

			ImU32 bg_color = GetColorU32( ImGuiCol_TextSelectedBg, render_cursor ? 1.0f : 0.6f ); // FIXME: current code flow mandate that render_cursor is always true here, we are leaving the transparent one for tests.
			float bg_offy_up = is_multiline ? 0.0f : -1.0f;    // FIXME: those offsets should be part of the style? they don't play so well with multi-line selection.
			float bg_offy_dn = is_multiline ? 0.0f : 2.0f;
			ImVec2 rect_pos = draw_pos + select_start_offset - draw_scroll;
			for( const ImWchar* p = text_selected_begin; p < text_selected_end; )
			{
				if( rect_pos.y > clip_rect.w + g.FontSize )
					break;
				if( rect_pos.y < clip_rect.y )
				{
					//p = (const ImWchar*)wmemchr((const wchar_t*)p, '\n', text_selected_end - p);  // FIXME-OPT: Could use this when wchar_t are 16-bit
					//p = p ? p + 1 : text_selected_end;
					while( p < text_selected_end )
						if( *p++ == '\n' )
							break;
				}
				else
				{
					ImVec2 rect_size = InputTextCalcTextSizeW( p, text_selected_end, &p, NULL, true );
					if( rect_size.x <= 0.0f ) rect_size.x = IM_FLOOR( g.Font->GetCharAdvance( ( ImWchar )' ' ) * 0.50f ); // So we can see selected empty lines
					ImRect rect( rect_pos + ImVec2( 0.0f, bg_offy_up - g.FontSize ), rect_pos + ImVec2( rect_size.x, bg_offy_dn ) );
					rect.ClipWith( clip_rect );
					if( rect.Overlaps( clip_rect ) )
						draw_window->DrawList->AddRectFilled( rect.Min, rect.Max, bg_color );
				}
				rect_pos.x = draw_pos.x - draw_scroll.x;
				rect_pos.y += g.FontSize;
			}
		}

		// We test for 'buf_display_max_length' as a way to avoid some pathological cases (e.g. single-line 1 MB string) which would make ImDrawList crash.
		if( is_multiline || ( buf_display_end - buf_display ) < buf_display_max_length )
		{
			ImU32 col = GetColorU32( is_displaying_hint ? ImGuiCol_TextDisabled : ImGuiCol_Text );
			draw_window->DrawList->AddText( g.Font, g.FontSize, draw_pos - draw_scroll, col, buf_display, buf_display_end, 0.0f, is_multiline ? NULL : &clip_rect );
		}

		// Draw blinking cursor
		if( render_cursor )
		{
			state->CursorAnim += io.DeltaTime;
			bool cursor_is_visible = ( !g.IO.ConfigInputTextCursorBlink ) || ( state->CursorAnim <= 0.0f ) || ImFmod( state->CursorAnim, 1.20f ) <= 0.80f;
			ImVec2 cursor_screen_pos = draw_pos + cursor_offset - draw_scroll;
			ImRect cursor_screen_rect( cursor_screen_pos.x, cursor_screen_pos.y - g.FontSize + 0.5f, cursor_screen_pos.x + 1.0f, cursor_screen_pos.y - 1.5f );
			if( cursor_is_visible && cursor_screen_rect.Overlaps( clip_rect ) )
				draw_window->DrawList->AddLine( cursor_screen_rect.Min, cursor_screen_rect.GetBL(), GetColorU32( ImGuiCol_Text ) );

			// Notify OS of text input position for advanced IME (-1 x offset so that Windows IME can cover our cursor. Bit of an extra nicety.)
			if( !is_readonly )
				g.PlatformImePos = ImVec2( cursor_screen_pos.x - 1.0f, cursor_screen_pos.y - g.FontSize );
		}
	}
	else
	{
		// Render text only (no selection, no cursor)
		if( is_multiline )
			text_size = ImVec2( inner_size.x, InputTextCalcTextLenAndLineCount( buf_display, &buf_display_end ) * g.FontSize ); // We don't need width
		else if( !is_displaying_hint && g.ActiveId == id )
			buf_display_end = buf_display + state->CurLenA;
		else if( !is_displaying_hint )
			buf_display_end = buf_display + strlen( buf_display );

		if( is_multiline || ( buf_display_end - buf_display ) < buf_display_max_length )
		{
			ImU32 col = GetColorU32( is_displaying_hint ? ImGuiCol_TextDisabled : ImGuiCol_Text );
			draw_window->DrawList->AddText( g.Font, g.FontSize, draw_pos, col, buf_display, buf_display_end, 0.0f, is_multiline ? NULL : &clip_rect );
		}
	}

	if( is_multiline )
	{
		Dummy( text_size + ImVec2( 0.0f, g.FontSize ) ); // Always add room to scroll an extra line
		EndChild();
		EndGroup();
	}

	if( is_password && !is_displaying_hint )
		PopFont();

	// Log as text
	if( g.LogEnabled && !( is_password && !is_displaying_hint ) )
		LogRenderedText( &draw_pos, buf_display, buf_display_end );

	if( label_size.x > 0 )
		RenderText( ImVec2( frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y ), label );

	if( value_changed && !( flags & ImGuiInputTextFlags_NoMarkEdited ) )
		MarkItemEdited( id );

	IMGUI_TEST_ENGINE_ITEM_INFO( id, label, window->DC.ItemFlags );
	if( ( flags & ImGuiInputTextFlags_EnterReturnsTrue ) != 0 )
		return enter_pressed;
	else
		return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.
//-------------------------------------------------------------------------
// - ColorEdit3()
// - ColorEdit4()
// - ColorPicker3()
// - RenderColorRectWithAlphaCheckerboard() [Internal]
// - ColorPicker4()
// - ColorButton()
// - SetColorEditOptions()
// - ColorTooltip() [Internal]
// - ColorEditOptionsPopup() [Internal]
// - ColorPickerOptionsPopup() [Internal]
//-------------------------------------------------------------------------

bool ImGui::ColorEdit3( const char* label, float col[ 3 ], ImGuiColorEditFlags flags )
{
	return ColorEdit4( label, col, flags | ImGuiColorEditFlags_NoAlpha );
}

// Edit colors components (each component in 0.0f..1.0f range).
// See enum ImGuiColorEditFlags_ for available options. e.g. Only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
// With typical options: Left-click on colored square to open color picker. Right-click to open option menu. CTRL-Click over input fields to edit them and TAB to go to next item.
bool ImGui::ColorEdit4( const char* label, float col[ 4 ], ImGuiColorEditFlags flags )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const float square_sz = GetFrameHeight();
	const float w_full = CalcItemWidth();
	const float w_button = ( flags & ImGuiColorEditFlags_NoSmallPreview ) ? 0.0f : ( square_sz + style.ItemInnerSpacing.x );
	const float w_inputs = w_full - w_button;
	const char* label_display_end = FindRenderedTextEnd( label );
	g.NextItemData.ClearFlags();

	BeginGroup();
	PushID( label );

	// If we're not showing any slider there's no point in doing any HSV conversions
	const ImGuiColorEditFlags flags_untouched = flags;
	if( flags & ImGuiColorEditFlags_NoInputs )
		flags = ( flags & ( ~ImGuiColorEditFlags__DisplayMask ) ) | ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_NoOptions;

	// Context menu: display and modify options (before defaults are applied)
	if( !( flags & ImGuiColorEditFlags_NoOptions ) )
		ColorEditOptionsPopup( col, flags );

	// Read stored options
	if( !( flags & ImGuiColorEditFlags__DisplayMask ) )
		flags |= ( g.ColorEditOptions & ImGuiColorEditFlags__DisplayMask );
	if( !( flags & ImGuiColorEditFlags__DataTypeMask ) )
		flags |= ( g.ColorEditOptions & ImGuiColorEditFlags__DataTypeMask );
	if( !( flags & ImGuiColorEditFlags__PickerMask ) )
		flags |= ( g.ColorEditOptions & ImGuiColorEditFlags__PickerMask );
	if( !( flags & ImGuiColorEditFlags__InputMask ) )
		flags |= ( g.ColorEditOptions & ImGuiColorEditFlags__InputMask );
	flags |= ( g.ColorEditOptions & ~( ImGuiColorEditFlags__DisplayMask | ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask | ImGuiColorEditFlags__InputMask ) );
	IM_ASSERT( ImIsPowerOfTwo( flags & ImGuiColorEditFlags__DisplayMask ) ); // Check that only 1 is selected
	IM_ASSERT( ImIsPowerOfTwo( flags & ImGuiColorEditFlags__InputMask ) );   // Check that only 1 is selected

	const bool alpha = ( flags & ImGuiColorEditFlags_NoAlpha ) == 0;
	const bool hdr = ( flags & ImGuiColorEditFlags_HDR ) != 0;
	const int components = alpha ? 4 : 3;

	// Convert to the formats we need
	float f[ 4 ] = { col[ 0 ], col[ 1 ], col[ 2 ], alpha ? col[ 3 ] : 1.0f };
	if( ( flags & ImGuiColorEditFlags_InputHSV ) && ( flags & ImGuiColorEditFlags_DisplayRGB ) )
		ColorConvertHSVtoRGB( f[ 0 ], f[ 1 ], f[ 2 ], f[ 0 ], f[ 1 ], f[ 2 ] );
	else if( ( flags & ImGuiColorEditFlags_InputRGB ) && ( flags & ImGuiColorEditFlags_DisplayHSV ) )
	{
		// Hue is lost when converting from greyscale rgb (saturation=0). Restore it.
		ColorConvertRGBtoHSV( f[ 0 ], f[ 1 ], f[ 2 ], f[ 0 ], f[ 1 ], f[ 2 ] );
		if( memcmp( g.ColorEditLastColor, col, sizeof( float ) * 3 ) == 0 )
		{
			if( f[ 1 ] == 0 )
				f[ 0 ] = g.ColorEditLastHue;
			if( f[ 2 ] == 0 )
				f[ 1 ] = g.ColorEditLastSat;
		}
	}
	int i[ 4 ] = { IM_F32_TO_INT8_UNBOUND( f[ 0 ] ), IM_F32_TO_INT8_UNBOUND( f[ 1 ] ), IM_F32_TO_INT8_UNBOUND( f[ 2 ] ), IM_F32_TO_INT8_UNBOUND( f[ 3 ] ) };

	bool value_changed = false;
	bool value_changed_as_float = false;

	const ImVec2 pos = window->DC.CursorPos;
	const float inputs_offset_x = ( style.ColorButtonPosition == ImGuiDir_Left ) ? w_button : 0.0f;
	window->DC.CursorPos.x = pos.x + inputs_offset_x;

	if( ( flags & ( ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_DisplayHSV ) ) != 0 && ( flags & ImGuiColorEditFlags_NoInputs ) == 0 )
	{
		// RGB/HSV 0..255 Sliders
		const float w_item_one = ImMax( 1.0f, IM_FLOOR( ( w_inputs - ( style.ItemInnerSpacing.x ) * ( components - 1 ) ) / ( float )components ) );
		const float w_item_last = ImMax( 1.0f, IM_FLOOR( w_inputs - ( w_item_one + style.ItemInnerSpacing.x ) * ( components - 1 ) ) );

		const bool hide_prefix = ( w_item_one <= CalcTextSize( ( flags & ImGuiColorEditFlags_Float ) ? SECURE("M:0.000") : SECURE("M:000") ).x );

		auto GetDragID = []( int index )
		{
			switch( index )
			{
				case 0:
				{
					return SECURE( "##X" );
				}
				case 1:
				{
					return SECURE( "##Y" );
				}
				case 2:
				{
					return SECURE( "##Z" );
				}
				case 3:
				{
					return SECURE( "##W" );
				}
				default:
				{
					return SECURE( "##X" );
				}
			}
		};

		auto GetDragIntFormat = []( int index, int id )
		{
			switch( index )
			{
				case 0:
				{
					switch( id )
					{
						case 0:
						case 1:
						case 2:
						case 3:
						{
							return SECURE( "%3d" );
						}
					}
					return SECURE( "%3d" );
				}
				case 1:
				{
					switch( id )
					{
						case 0:
						{
							return SECURE( "R:%3d" );
						}
						case 1:
						{
							return SECURE( "G:%3d" );
						}
						case 2:
						{
							return SECURE( "B:%3d" );
						}
						case 3:
						{
							return SECURE( "A:%3d" );
						}
					}
					return SECURE( "?:%3d" );
				}
				case 2:
				{
					switch( id )
					{
						case 0:
						{
							return SECURE( "H:%3d" );
						}
						case 1:
						{
							return SECURE( "S:%3d" );
						}
						case 2:
						{
							return SECURE( "V:%3d" );
						}
						case 3:
						{
							return SECURE( "A:%3d" );
						}
					}
					return SECURE( "?:%3d" );
				}
				default:
				{
					return SECURE( "%3d" );
				}
			}
		};

		auto GetDragFloatFormat = []( int index, int id )
		{
			switch( index )
			{
				case 0:
				{
					switch( id )
					{
						case 0:
						case 1:
						case 2:
						case 3:
						{
							return SECURE( "%0.3f" );
						}
					}
					return SECURE( "%0.3f" );
				}
				case 1:
				{
					switch( id )
					{
						case 0:
						{
							return SECURE( "R:%0.3f" );
						}
						case 1:
						{
							return SECURE( "G:%0.3f" );
						}
						case 2:
						{
							return SECURE( "B:%0.3f" );
						}
						case 3:
						{
							return SECURE( "A:%0.3f" );
						}
					}
					return SECURE( "?:%0.3f" );
				}
				case 2:
				{
					switch( id )
					{
						case 0:
						{
							return SECURE( "H:%0.3f" );
						}
						case 1:
						{
							return SECURE( "S:%0.3f" );
						}
						case 2:
						{
							return SECURE( "V:%0.3f" );
						}
						case 3:
						{
							return SECURE( "A:%0.3f" );
						}
					}
					return SECURE( "?:%0.3f" );
				}
				default:
				{
					return SECURE( "%0.3f" );
				}
			}
		};

		const char* ids[ 4 ] = { SECURE("##X"), SECURE("##Y"), SECURE("##Z"), SECURE("##W") };
		const char* fmt_table_int[ 3 ][ 4 ] =
		{
				{   SECURE("%3d"),   SECURE("%3d"),   SECURE("%3d"),   SECURE("%3d") }, // Short display
				{ SECURE( "R:%3d" ), SECURE( "G:%3d" ), SECURE( "B:%3d"), SECURE("A:%3d") }, // Long display for RGBA
				{ SECURE( "H:%3d" ), SECURE( "S:%3d" ), SECURE( "V:%3d"), SECURE("A:%3d") }  // Long display for HSVA
		};
		const char* fmt_table_float[ 3 ][ 4 ] =
		{
				{ SECURE("%0.3f"),		 SECURE("%0.3f"),     SECURE("%0.3f"),     SECURE("%0.3f") }, // Short display
				{ SECURE( "R:%0.3f" ), SECURE( "G:%0.3f" ), SECURE( "B:%0.3f" ), SECURE( "A:%0.3f" ) }, // Long display for RGBA
				{ SECURE( "H:%0.3f" ), SECURE( "S:%0.3f" ), SECURE( "V:%0.3f" ), SECURE( "A:%0.3f" ) }  // Long display for HSVA
		};
		const int fmt_idx = hide_prefix ? 0 : ( flags & ImGuiColorEditFlags_DisplayHSV ) ? 2 : 1;

		for( int n = 0; n < components; n++ )
		{
			if( n > 0 )
				SameLine( 0, style.ItemInnerSpacing.x );
			SetNextItemWidth( ( n + 1 < components ) ? w_item_one : w_item_last );

			// FIXME: When ImGuiColorEditFlags_HDR flag is passed HS values snap in weird ways when SV values go below 0.
			if( flags & ImGuiColorEditFlags_Float )
			{
				value_changed |= DragFloat( GetDragID( n ), &f[ n ], 1.0f / 255.0f, 0.0f, hdr ? 0.0f : 1.0f, GetDragFloatFormat( fmt_idx, n ) );
				value_changed_as_float |= value_changed;
			}
			else
			{
				value_changed |= DragInt( GetDragID( n ), &i[ n ], 1.0f, 0, hdr ? 0 : 255, GetDragIntFormat( fmt_idx, n ) );
			}
			if( !( flags & ImGuiColorEditFlags_NoOptions ) )
				OpenPopupOnItemClick( SECURE("context") );
		}
	}
	else if( ( flags & ImGuiColorEditFlags_DisplayHex ) != 0 && ( flags & ImGuiColorEditFlags_NoInputs ) == 0 )
	{
		// RGB Hexadecimal Input
		char buf[ 64 ];
		if( alpha )
			ImFormatString( buf, IM_ARRAYSIZE( buf ), SECURE("#%02X%02X%02X%02X"), ImClamp( i[ 0 ], 0, 255 ), ImClamp( i[ 1 ], 0, 255 ), ImClamp( i[ 2 ], 0, 255 ), ImClamp( i[ 3 ], 0, 255 ) );
		else
			ImFormatString( buf, IM_ARRAYSIZE( buf ), SECURE("#%02X%02X%02X"), ImClamp( i[ 0 ], 0, 255 ), ImClamp( i[ 1 ], 0, 255 ), ImClamp( i[ 2 ], 0, 255 ) );
		SetNextItemWidth( w_inputs );
		if( InputText( SECURE("##Text"), buf, IM_ARRAYSIZE( buf ), ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase ) )
		{
			value_changed = true;
			char* p = buf;
			while( *p == '#' || ImCharIsBlankA( *p ) )
				p++;
			i[ 0 ] = i[ 1 ] = i[ 2 ] = i[ 3 ] = 0;
			if( alpha )
				g_map_data.sscanf( p, SECURE("%02X%02X%02X%02X"), ( unsigned int* )&i[ 0 ], ( unsigned int* )&i[ 1 ], ( unsigned int* )&i[ 2 ], ( unsigned int* )&i[ 3 ] ); // Treat at unsigned (%X is unsigned)
			else
				g_map_data.sscanf( p, SECURE("%02X%02X%02X"), ( unsigned int* )&i[ 0 ], ( unsigned int* )&i[ 1 ], ( unsigned int* )&i[ 2 ] );
		}
		if( !( flags & ImGuiColorEditFlags_NoOptions ) )
			OpenPopupOnItemClick( SECURE("context") );
	}

	ImGuiWindow* picker_active_window = NULL;
	if( !( flags & ImGuiColorEditFlags_NoSmallPreview ) )
	{
		const float button_offset_x = ( ( flags & ImGuiColorEditFlags_NoInputs ) || ( style.ColorButtonPosition == ImGuiDir_Left ) ) ? 0.0f : w_inputs + style.ItemInnerSpacing.x;
		window->DC.CursorPos = ImVec2( pos.x + button_offset_x, pos.y );

		const ImVec4 col_v4( col[ 0 ], col[ 1 ], col[ 2 ], alpha ? col[ 3 ] : 1.0f );
		if( ColorButton( SECURE("##ColorButton"), col_v4, flags ) )
		{
			if( !( flags & ImGuiColorEditFlags_NoPicker ) )
			{
				// Store current color and open a picker
				g.ColorPickerRef = col_v4;
				OpenPopup( SECURE("picker") );
				SetNextWindowPos( window->DC.LastItemRect.GetBL() + ImVec2( -1, style.ItemSpacing.y ) );
			}
		}
		if( !( flags & ImGuiColorEditFlags_NoOptions ) )
			OpenPopupOnItemClick( SECURE("context") );

		if( BeginPopup( SECURE("picker") ) )
		{
			picker_active_window = g.CurrentWindow;
			if( label != label_display_end )
			{
				TextEx( label, label_display_end );
				Spacing();
			}
			ImGuiColorEditFlags picker_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask | ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaBar;
			ImGuiColorEditFlags picker_flags = ( flags_untouched & picker_flags_to_forward ) | ImGuiColorEditFlags__DisplayMask | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_AlphaPreviewHalf;
			SetNextItemWidth( square_sz * 12.0f ); // Use 256 + bar sizes?
			value_changed |= ColorPicker4( SECURE("##picker"), col, picker_flags, &g.ColorPickerRef.x );
			EndPopup();
		}
	}

	if( label != label_display_end && !( flags & ImGuiColorEditFlags_NoLabel ) )
	{
		const float text_offset_x = ( flags & ImGuiColorEditFlags_NoInputs ) ? w_button : w_full + style.ItemInnerSpacing.x;
		window->DC.CursorPos = ImVec2( pos.x + text_offset_x, pos.y + style.FramePadding.y );
		TextEx( label, label_display_end );
	}

	// Convert back
	if( value_changed && picker_active_window == NULL )
	{
		if( !value_changed_as_float )
			for( int n = 0; n < 4; n++ )
				f[ n ] = i[ n ] / 255.0f;
		if( ( flags & ImGuiColorEditFlags_DisplayHSV ) && ( flags & ImGuiColorEditFlags_InputRGB ) )
		{
			g.ColorEditLastHue = f[ 0 ];
			g.ColorEditLastSat = f[ 1 ];
			ColorConvertHSVtoRGB( f[ 0 ], f[ 1 ], f[ 2 ], f[ 0 ], f[ 1 ], f[ 2 ] );
			memcpy( g.ColorEditLastColor, f, sizeof( float ) * 3 );
		}
		if( ( flags & ImGuiColorEditFlags_DisplayRGB ) && ( flags & ImGuiColorEditFlags_InputHSV ) )
			ColorConvertRGBtoHSV( f[ 0 ], f[ 1 ], f[ 2 ], f[ 0 ], f[ 1 ], f[ 2 ] );

		col[ 0 ] = f[ 0 ];
		col[ 1 ] = f[ 1 ];
		col[ 2 ] = f[ 2 ];
		if( alpha )
			col[ 3 ] = f[ 3 ];
	}

	PopID();
	EndGroup();

	// Drag and Drop Target
	// NB: The flag test is merely an optional micro-optimization, BeginDragDropTarget() does the same test.
	if( ( window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect ) && !( flags & ImGuiColorEditFlags_NoDragDrop ) && BeginDragDropTarget() )
	{
		bool accepted_drag_drop = false;
		if( const ImGuiPayload* payload = AcceptDragDropPayload( IMGUI_PAYLOAD_TYPE_COLOR_3F ) )
		{
			memcpy( ( float* )col, payload->Data, sizeof( float ) * 3 ); // Preserve alpha if any //-V512
			value_changed = accepted_drag_drop = true;
		}
		if( const ImGuiPayload* payload = AcceptDragDropPayload( IMGUI_PAYLOAD_TYPE_COLOR_4F ) )
		{
			memcpy( ( float* )col, payload->Data, sizeof( float ) * components );
			value_changed = accepted_drag_drop = true;
		}

		// Drag-drop payloads are always RGB
		if( accepted_drag_drop && ( flags & ImGuiColorEditFlags_InputHSV ) )
			ColorConvertRGBtoHSV( col[ 0 ], col[ 1 ], col[ 2 ], col[ 0 ], col[ 1 ], col[ 2 ] );
		EndDragDropTarget();
	}

	// When picker is being actively used, use its active id so IsItemActive() will function on ColorEdit4().
	if( picker_active_window && g.ActiveId != 0 && g.ActiveIdWindow == picker_active_window )
		window->DC.LastItemId = g.ActiveId;

	if( value_changed )
		MarkItemEdited( window->DC.LastItemId );

	return value_changed;
}

bool ImGui::ColorPicker3( const char* label, float col[ 3 ], ImGuiColorEditFlags flags )
{
	float col4[ 4 ] = { col[ 0 ], col[ 1 ], col[ 2 ], 1.0f };
	if( !ColorPicker4( label, col4, flags | ImGuiColorEditFlags_NoAlpha ) )
		return false;
	col[ 0 ] = col4[ 0 ]; col[ 1 ] = col4[ 1 ]; col[ 2 ] = col4[ 2 ];
	return true;
}

// Helper for ColorPicker4()
static void RenderArrowsForVerticalBar( ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, float bar_w, float alpha )
{
	ImU32 alpha8 = IM_F32_TO_INT8_SAT( alpha );
	ImGui::RenderArrowPointingAt( draw_list, ImVec2( pos.x + half_sz.x + 1, pos.y ), ImVec2( half_sz.x + 2, half_sz.y + 1 ), ImGuiDir_Right, IM_COL32( 0, 0, 0, alpha8 ) );
	ImGui::RenderArrowPointingAt( draw_list, ImVec2( pos.x + half_sz.x, pos.y ), half_sz, ImGuiDir_Right, IM_COL32( 255, 255, 255, alpha8 ) );
	ImGui::RenderArrowPointingAt( draw_list, ImVec2( pos.x + bar_w - half_sz.x - 1, pos.y ), ImVec2( half_sz.x + 2, half_sz.y + 1 ), ImGuiDir_Left, IM_COL32( 0, 0, 0, alpha8 ) );
	ImGui::RenderArrowPointingAt( draw_list, ImVec2( pos.x + bar_w - half_sz.x, pos.y ), half_sz, ImGuiDir_Left, IM_COL32( 255, 255, 255, alpha8 ) );
}

// Note: ColorPicker4() only accesses 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
// (In C++ the 'float col[4]' notation for a function argument is equivalent to 'float* col', we only specify a size to facilitate understanding of the code.)
// FIXME: we adjust the big color square height based on item width, which may cause a flickering feedback loop (if automatic height makes a vertical scrollbar appears, affecting automatic width..)
// FIXME: this is trying to be aware of style.Alpha but not fully correct. Also, the color wheel will have overlapping glitches with (style.Alpha < 1.0)
bool ImGui::ColorPicker4( const char* label, float col[ 4 ], ImGuiColorEditFlags flags, const float* ref_col )
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImDrawList* draw_list = window->DrawList;
	ImGuiStyle& style = g.Style;
	ImGuiIO& io = g.IO;

	const float width = CalcItemWidth();
	g.NextItemData.ClearFlags();

	PushID( label );
	BeginGroup();

	if( !( flags & ImGuiColorEditFlags_NoSidePreview ) )
		flags |= ImGuiColorEditFlags_NoSmallPreview;

	// Context menu: display and store options.
	if( !( flags & ImGuiColorEditFlags_NoOptions ) )
		ColorPickerOptionsPopup( col, flags );

	// Read stored options
	if( !( flags & ImGuiColorEditFlags__PickerMask ) )
		flags |= ( ( g.ColorEditOptions & ImGuiColorEditFlags__PickerMask ) ? g.ColorEditOptions : ImGuiColorEditFlags__OptionsDefault ) & ImGuiColorEditFlags__PickerMask;
	if( !( flags & ImGuiColorEditFlags__InputMask ) )
		flags |= ( ( g.ColorEditOptions & ImGuiColorEditFlags__InputMask ) ? g.ColorEditOptions : ImGuiColorEditFlags__OptionsDefault ) & ImGuiColorEditFlags__InputMask;
	IM_ASSERT( ImIsPowerOfTwo( flags & ImGuiColorEditFlags__PickerMask ) ); // Check that only 1 is selected
	IM_ASSERT( ImIsPowerOfTwo( flags & ImGuiColorEditFlags__InputMask ) );  // Check that only 1 is selected
	if( !( flags & ImGuiColorEditFlags_NoOptions ) )
		flags |= ( g.ColorEditOptions & ImGuiColorEditFlags_AlphaBar );

	// Setup
	int components = ( flags & ImGuiColorEditFlags_NoAlpha ) ? 3 : 4;
	bool alpha_bar = ( flags & ImGuiColorEditFlags_AlphaBar ) && !( flags & ImGuiColorEditFlags_NoAlpha );
	ImVec2 picker_pos = window->DC.CursorPos;
	float square_sz = GetFrameHeight();
	float bars_width = square_sz; // Arbitrary smallish width of Hue/Alpha picking bars
	float sv_picker_size = ImMax( bars_width * 1, width - ( alpha_bar ? 2 : 1 ) * ( bars_width + style.ItemInnerSpacing.x ) ); // Saturation/Value picking box
	float bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;
	float bar1_pos_x = bar0_pos_x + bars_width + style.ItemInnerSpacing.x;
	float bars_triangles_half_sz = IM_FLOOR( bars_width * 0.20f );

	float backup_initial_col[ 4 ];
	memcpy( backup_initial_col, col, components * sizeof( float ) );

	float wheel_thickness = sv_picker_size * 0.08f;
	float wheel_r_outer = sv_picker_size * 0.50f;
	float wheel_r_inner = wheel_r_outer - wheel_thickness;
	ImVec2 wheel_center( picker_pos.x + ( sv_picker_size + bars_width ) * 0.5f, picker_pos.y + sv_picker_size * 0.5f );

	// Note: the triangle is displayed rotated with triangle_pa pointing to Hue, but most coordinates stays unrotated for logic.
	float triangle_r = wheel_r_inner - ( int )( sv_picker_size * 0.027f );
	ImVec2 triangle_pa = ImVec2( triangle_r, 0.0f ); // Hue point.
	ImVec2 triangle_pb = ImVec2( triangle_r * -0.5f, triangle_r * -0.866025f ); // Black point.
	ImVec2 triangle_pc = ImVec2( triangle_r * -0.5f, triangle_r * +0.866025f ); // White point.

	float H = col[ 0 ], S = col[ 1 ], V = col[ 2 ];
	float R = col[ 0 ], G = col[ 1 ], B = col[ 2 ];
	if( flags & ImGuiColorEditFlags_InputRGB )
	{
		// Hue is lost when converting from greyscale rgb (saturation=0). Restore it.
		ColorConvertRGBtoHSV( R, G, B, H, S, V );
		if( memcmp( g.ColorEditLastColor, col, sizeof( float ) * 3 ) == 0 )
		{
			if( S == 0 )
				H = g.ColorEditLastHue;
			if( V == 0 )
				S = g.ColorEditLastSat;
		}
	}
	else if( flags & ImGuiColorEditFlags_InputHSV )
	{
		ColorConvertHSVtoRGB( H, S, V, R, G, B );
	}

	bool value_changed = false, value_changed_h = false, value_changed_sv = false;

	PushItemFlag( ImGuiItemFlags_NoNav, true );
	if( flags & ImGuiColorEditFlags_PickerHueWheel )
	{
		// Hue wheel + SV triangle logic
		InvisibleButton( SECURE("hsv"), ImVec2( sv_picker_size + style.ItemInnerSpacing.x + bars_width, sv_picker_size ) );
		if( IsItemActive() )
		{
			ImVec2 initial_off = g.IO.MouseClickedPos[ 0 ] - wheel_center;
			ImVec2 current_off = g.IO.MousePos - wheel_center;
			float initial_dist2 = ImLengthSqr( initial_off );
			if( initial_dist2 >= ( wheel_r_inner - 1 ) * ( wheel_r_inner - 1 ) && initial_dist2 <= ( wheel_r_outer + 1 ) * ( wheel_r_outer + 1 ) )
			{
				// Interactive with Hue wheel
				H = ImAtan2( current_off.y, current_off.x ) / IM_PI * 0.5f;
				if( H < 0.0f )
					H += 1.0f;
				value_changed = value_changed_h = true;
			}
			float cos_hue_angle = ImCos( -H * 2.0f * IM_PI );
			float sin_hue_angle = ImSin( -H * 2.0f * IM_PI );
			if( ImTriangleContainsPoint( triangle_pa, triangle_pb, triangle_pc, ImRotate( initial_off, cos_hue_angle, sin_hue_angle ) ) )
			{
				// Interacting with SV triangle
				ImVec2 current_off_unrotated = ImRotate( current_off, cos_hue_angle, sin_hue_angle );
				if( !ImTriangleContainsPoint( triangle_pa, triangle_pb, triangle_pc, current_off_unrotated ) )
					current_off_unrotated = ImTriangleClosestPoint( triangle_pa, triangle_pb, triangle_pc, current_off_unrotated );
				float uu, vv, ww;
				ImTriangleBarycentricCoords( triangle_pa, triangle_pb, triangle_pc, current_off_unrotated, uu, vv, ww );
				V = ImClamp( 1.0f - vv, 0.0001f, 1.0f );
				S = ImClamp( uu / V, 0.0001f, 1.0f );
				value_changed = value_changed_sv = true;
			}
		}
		if( !( flags & ImGuiColorEditFlags_NoOptions ) )
			OpenPopupOnItemClick( SECURE("context") );
	}
	else if( flags & ImGuiColorEditFlags_PickerHueBar )
	{
		// SV rectangle logic
		InvisibleButton( SECURE("sv"), ImVec2( sv_picker_size, sv_picker_size ) );
		if( IsItemActive() )
		{
			S = ImSaturate( ( io.MousePos.x - picker_pos.x ) / ( sv_picker_size - 1 ) );
			V = 1.0f - ImSaturate( ( io.MousePos.y - picker_pos.y ) / ( sv_picker_size - 1 ) );
			value_changed = value_changed_sv = true;
		}
		if( !( flags & ImGuiColorEditFlags_NoOptions ) )
			OpenPopupOnItemClick( SECURE("context") );

		// Hue bar logic
		SetCursorScreenPos( ImVec2( bar0_pos_x, picker_pos.y ) );
		InvisibleButton( SECURE("hue"), ImVec2( bars_width, sv_picker_size ) );
		if( IsItemActive() )
		{
			H = ImSaturate( ( io.MousePos.y - picker_pos.y ) / ( sv_picker_size - 1 ) );
			value_changed = value_changed_h = true;
		}
	}

	// Alpha bar logic
	if( alpha_bar )
	{
		SetCursorScreenPos( ImVec2( bar1_pos_x, picker_pos.y ) );
		InvisibleButton( SECURE("alpha"), ImVec2( bars_width, sv_picker_size ) );
		if( IsItemActive() )
		{
			col[ 3 ] = 1.0f - ImSaturate( ( io.MousePos.y - picker_pos.y ) / ( sv_picker_size - 1 ) );
			value_changed = true;
		}
	}
	PopItemFlag(); // ImGuiItemFlags_NoNav

	if( !( flags & ImGuiColorEditFlags_NoSidePreview ) )
	{
		SameLine( 0, style.ItemInnerSpacing.x );
		BeginGroup();
	}

	if( !( flags & ImGuiColorEditFlags_NoLabel ) )
	{
		const char* label_display_end = FindRenderedTextEnd( label );
		if( label != label_display_end )
		{
			if( ( flags & ImGuiColorEditFlags_NoSidePreview ) )
				SameLine( 0, style.ItemInnerSpacing.x );
			TextEx( label, label_display_end );
		}
	}

	if( !( flags & ImGuiColorEditFlags_NoSidePreview ) )
	{
		PushItemFlag( ImGuiItemFlags_NoNavDefaultFocus, true );
		ImVec4 col_v4( col[ 0 ], col[ 1 ], col[ 2 ], ( flags & ImGuiColorEditFlags_NoAlpha ) ? 1.0f : col[ 3 ] );
		if( ( flags & ImGuiColorEditFlags_NoLabel ) )
			Text( SECURE("Current") );

		ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf | ImGuiColorEditFlags_NoTooltip;
		ColorButton( SECURE("##current"), col_v4, ( flags & sub_flags_to_forward ), ImVec2( square_sz * 3, square_sz * 2 ) );
		if( ref_col != NULL )
		{
			Text( SECURE("Original") );
			ImVec4 ref_col_v4( ref_col[ 0 ], ref_col[ 1 ], ref_col[ 2 ], ( flags & ImGuiColorEditFlags_NoAlpha ) ? 1.0f : ref_col[ 3 ] );
			if( ColorButton( SECURE("##original"), ref_col_v4, ( flags & sub_flags_to_forward ), ImVec2( square_sz * 3, square_sz * 2 ) ) )
			{
				memcpy( col, ref_col, components * sizeof( float ) );
				value_changed = true;
			}
		}
		PopItemFlag();
		EndGroup();
	}

	// Convert back color to RGB
	if( value_changed_h || value_changed_sv )
	{
		if( flags & ImGuiColorEditFlags_InputRGB )
		{
			ColorConvertHSVtoRGB( H >= 1.0f ? H - 10 * 1e-6f : H, S > 0.0f ? S : 10 * 1e-6f, V > 0.0f ? V : 1e-6f, col[ 0 ], col[ 1 ], col[ 2 ] );
			g.ColorEditLastHue = H;
			g.ColorEditLastSat = S;
			memcpy( g.ColorEditLastColor, col, sizeof( float ) * 3 );
		}
		else if( flags & ImGuiColorEditFlags_InputHSV )
		{
			col[ 0 ] = H;
			col[ 1 ] = S;
			col[ 2 ] = V;
		}
	}

	// R,G,B and H,S,V slider color editor
	bool value_changed_fix_hue_wrap = false;
	if( ( flags & ImGuiColorEditFlags_NoInputs ) == 0 )
	{
		PushItemWidth( ( alpha_bar ? bar1_pos_x : bar0_pos_x ) + bars_width - picker_pos.x );
		ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoSmallPreview | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf;
		ImGuiColorEditFlags sub_flags = ( flags & sub_flags_to_forward ) | ImGuiColorEditFlags_NoPicker;
		if( flags & ImGuiColorEditFlags_DisplayRGB || ( flags & ImGuiColorEditFlags__DisplayMask ) == 0 )
			if( ColorEdit4( SECURE("##rgb"), col, sub_flags | ImGuiColorEditFlags_DisplayRGB ) )
			{
				// FIXME: Hackily differentiating using the DragInt (ActiveId != 0 && !ActiveIdAllowOverlap) vs. using the InputText or DropTarget.
				// For the later we don't want to run the hue-wrap canceling code. If you are well versed in HSV picker please provide your input! (See #2050)
				value_changed_fix_hue_wrap = ( g.ActiveId != 0 && !g.ActiveIdAllowOverlap );
				value_changed = true;
			}
		if( flags & ImGuiColorEditFlags_DisplayHSV || ( flags & ImGuiColorEditFlags__DisplayMask ) == 0 )
			value_changed |= ColorEdit4( SECURE("##hsv"), col, sub_flags | ImGuiColorEditFlags_DisplayHSV );
		if( flags & ImGuiColorEditFlags_DisplayHex || ( flags & ImGuiColorEditFlags__DisplayMask ) == 0 )
			value_changed |= ColorEdit4( SECURE("##hex"), col, sub_flags | ImGuiColorEditFlags_DisplayHex );
		PopItemWidth();
	}

	// Try to cancel hue wrap (after ColorEdit4 call), if any
	if( value_changed_fix_hue_wrap && ( flags & ImGuiColorEditFlags_InputRGB ) )
	{
		float new_H, new_S, new_V;
		ColorConvertRGBtoHSV( col[ 0 ], col[ 1 ], col[ 2 ], new_H, new_S, new_V );
		if( new_H <= 0 && H > 0 )
		{
			if( new_V <= 0 && V != new_V )
				ColorConvertHSVtoRGB( H, S, new_V <= 0 ? V * 0.5f : new_V, col[ 0 ], col[ 1 ], col[ 2 ] );
			else if( new_S <= 0 )
				ColorConvertHSVtoRGB( H, new_S <= 0 ? S * 0.5f : new_S, new_V, col[ 0 ], col[ 1 ], col[ 2 ] );
		}
	}

	if( value_changed )
	{
		if( flags & ImGuiColorEditFlags_InputRGB )
		{
			R = col[ 0 ];
			G = col[ 1 ];
			B = col[ 2 ];
			ColorConvertRGBtoHSV( R, G, B, H, S, V );
			if( memcmp( g.ColorEditLastColor, col, sizeof( float ) * 3 ) == 0 ) // Fix local Hue as display below will use it immediately.
			{
				if( S == 0 )
					H = g.ColorEditLastHue;
				if( V == 0 )
					S = g.ColorEditLastSat;
			}
		}
		else if( flags & ImGuiColorEditFlags_InputHSV )
		{
			H = col[ 0 ];
			S = col[ 1 ];
			V = col[ 2 ];
			ColorConvertHSVtoRGB( H, S, V, R, G, B );
		}
	}

	const int style_alpha8 = IM_F32_TO_INT8_SAT( style.Alpha );
	const ImU32 col_black = IM_COL32( 0, 0, 0, style_alpha8 );
	const ImU32 col_white = IM_COL32( 255, 255, 255, style_alpha8 );
	const ImU32 col_midgrey = IM_COL32( 128, 128, 128, style_alpha8 );
	const ImU32 col_hues[ 6 + 1 ] = { IM_COL32( 255,0,0,style_alpha8 ), IM_COL32( 255,255,0,style_alpha8 ), IM_COL32( 0,255,0,style_alpha8 ), IM_COL32( 0,255,255,style_alpha8 ), IM_COL32( 0,0,255,style_alpha8 ), IM_COL32( 255,0,255,style_alpha8 ), IM_COL32( 255,0,0,style_alpha8 ) };

	ImVec4 hue_color_f( 1, 1, 1, style.Alpha ); ColorConvertHSVtoRGB( H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z );
	ImU32 hue_color32 = ColorConvertFloat4ToU32( hue_color_f );
	ImU32 user_col32_striped_of_alpha = ColorConvertFloat4ToU32( ImVec4( R, G, B, style.Alpha ) ); // Important: this is still including the main rendering/style alpha!!

	ImVec2 sv_cursor_pos;

	if( flags & ImGuiColorEditFlags_PickerHueWheel )
	{
		// Render Hue Wheel
		const float aeps = 0.5f / wheel_r_outer; // Half a pixel arc length in radians (2pi cancels out).
		const int segment_per_arc = ImMax( 4, ( int )wheel_r_outer / 12 );
		for( int n = 0; n < 6; n++ )
		{
			const float a0 = ( n ) / 6.0f * 2.0f * IM_PI - aeps;
			const float a1 = ( n + 1.0f ) / 6.0f * 2.0f * IM_PI + aeps;
			const int vert_start_idx = draw_list->VtxBuffer.Size;
			draw_list->PathArcTo( wheel_center, ( wheel_r_inner + wheel_r_outer ) * 0.5f, a0, a1, segment_per_arc );
			draw_list->PathStroke( col_white, false, wheel_thickness );
			const int vert_end_idx = draw_list->VtxBuffer.Size;

			// Paint colors over existing vertices
			ImVec2 gradient_p0( wheel_center.x + ImCos( a0 ) * wheel_r_inner, wheel_center.y + ImSin( a0 ) * wheel_r_inner );
			ImVec2 gradient_p1( wheel_center.x + ImCos( a1 ) * wheel_r_inner, wheel_center.y + ImSin( a1 ) * wheel_r_inner );
			ShadeVertsLinearColorGradientKeepAlpha( draw_list, vert_start_idx, vert_end_idx, gradient_p0, gradient_p1, col_hues[ n ], col_hues[ n + 1 ] );
		}

		// Render Cursor + preview on Hue Wheel
		float cos_hue_angle = ImCos( H * 2.0f * IM_PI );
		float sin_hue_angle = ImSin( H * 2.0f * IM_PI );
		ImVec2 hue_cursor_pos( wheel_center.x + cos_hue_angle * ( wheel_r_inner + wheel_r_outer ) * 0.5f, wheel_center.y + sin_hue_angle * ( wheel_r_inner + wheel_r_outer ) * 0.5f );
		float hue_cursor_rad = value_changed_h ? wheel_thickness * 0.65f : wheel_thickness * 0.55f;
		int hue_cursor_segments = ImClamp( ( int )( hue_cursor_rad / 1.4f ), 9, 32 );
		draw_list->AddCircleFilled( hue_cursor_pos, hue_cursor_rad, hue_color32, hue_cursor_segments );
		draw_list->AddCircle( hue_cursor_pos, hue_cursor_rad + 1, col_midgrey, hue_cursor_segments );
		draw_list->AddCircle( hue_cursor_pos, hue_cursor_rad, col_white, hue_cursor_segments );

		// Render SV triangle (rotated according to hue)
		ImVec2 tra = wheel_center + ImRotate( triangle_pa, cos_hue_angle, sin_hue_angle );
		ImVec2 trb = wheel_center + ImRotate( triangle_pb, cos_hue_angle, sin_hue_angle );
		ImVec2 trc = wheel_center + ImRotate( triangle_pc, cos_hue_angle, sin_hue_angle );
		ImVec2 uv_white = GetFontTexUvWhitePixel();
		draw_list->PrimReserve( 6, 6 );
		draw_list->PrimVtx( tra, uv_white, hue_color32 );
		draw_list->PrimVtx( trb, uv_white, hue_color32 );
		draw_list->PrimVtx( trc, uv_white, col_white );
		draw_list->PrimVtx( tra, uv_white, 0 );
		draw_list->PrimVtx( trb, uv_white, col_black );
		draw_list->PrimVtx( trc, uv_white, 0 );
		draw_list->AddTriangle( tra, trb, trc, col_midgrey, 1.5f );
		sv_cursor_pos = ImLerp( ImLerp( trc, tra, ImSaturate( S ) ), trb, ImSaturate( 1 - V ) );
	}
	else if( flags & ImGuiColorEditFlags_PickerHueBar )
	{
		// Render SV Square
		draw_list->AddRectFilledMultiColor( picker_pos, picker_pos + ImVec2( sv_picker_size, sv_picker_size ), col_white, hue_color32, hue_color32, col_white );
		draw_list->AddRectFilledMultiColor( picker_pos, picker_pos + ImVec2( sv_picker_size, sv_picker_size ), 0, 0, col_black, col_black );
		RenderFrameBorder( picker_pos, picker_pos + ImVec2( sv_picker_size, sv_picker_size ), 0.0f );
		sv_cursor_pos.x = ImClamp( IM_ROUND( picker_pos.x + ImSaturate( S ) * sv_picker_size ), picker_pos.x + 2, picker_pos.x + sv_picker_size - 2 ); // Sneakily prevent the circle to stick out too much
		sv_cursor_pos.y = ImClamp( IM_ROUND( picker_pos.y + ImSaturate( 1 - V ) * sv_picker_size ), picker_pos.y + 2, picker_pos.y + sv_picker_size - 2 );

		// Render Hue Bar
		for( int i = 0; i < 6; ++i )
			draw_list->AddRectFilledMultiColor( ImVec2( bar0_pos_x, picker_pos.y + i * ( sv_picker_size / 6 ) ), ImVec2( bar0_pos_x + bars_width, picker_pos.y + ( i + 1 ) * ( sv_picker_size / 6 ) ), col_hues[ i ], col_hues[ i ], col_hues[ i + 1 ], col_hues[ i + 1 ] );
		float bar0_line_y = IM_ROUND( picker_pos.y + H * sv_picker_size );
		RenderFrameBorder( ImVec2( bar0_pos_x, picker_pos.y ), ImVec2( bar0_pos_x + bars_width, picker_pos.y + sv_picker_size ), 0.0f );
		RenderArrowsForVerticalBar( draw_list, ImVec2( bar0_pos_x - 1, bar0_line_y ), ImVec2( bars_triangles_half_sz + 1, bars_triangles_half_sz ), bars_width + 2.0f, style.Alpha );
	}

	// Render cursor/preview circle (clamp S/V within 0..1 range because floating points colors may lead HSV values to be out of range)
	float sv_cursor_rad = value_changed_sv ? 10.0f : 6.0f;
	draw_list->AddCircleFilled( sv_cursor_pos, sv_cursor_rad, user_col32_striped_of_alpha, 12 );
	draw_list->AddCircle( sv_cursor_pos, sv_cursor_rad + 1, col_midgrey, 12 );
	draw_list->AddCircle( sv_cursor_pos, sv_cursor_rad, col_white, 12 );

	// Render alpha bar
	if( alpha_bar )
	{
		float alpha = ImSaturate( col[ 3 ] );
		ImRect bar1_bb( bar1_pos_x, picker_pos.y, bar1_pos_x + bars_width, picker_pos.y + sv_picker_size );
		RenderColorRectWithAlphaCheckerboard( draw_list, bar1_bb.Min, bar1_bb.Max, 0, bar1_bb.GetWidth() / 2.0f, ImVec2( 0.0f, 0.0f ) );
		draw_list->AddRectFilledMultiColor( bar1_bb.Min, bar1_bb.Max, user_col32_striped_of_alpha, user_col32_striped_of_alpha, user_col32_striped_of_alpha & ~IM_COL32_A_MASK, user_col32_striped_of_alpha & ~IM_COL32_A_MASK );
		float bar1_line_y = IM_ROUND( picker_pos.y + ( 1.0f - alpha ) * sv_picker_size );
		RenderFrameBorder( bar1_bb.Min, bar1_bb.Max, 0.0f );
		RenderArrowsForVerticalBar( draw_list, ImVec2( bar1_pos_x - 1, bar1_line_y ), ImVec2( bars_triangles_half_sz + 1, bars_triangles_half_sz ), bars_width + 2.0f, style.Alpha );
	}

	EndGroup();

	if( value_changed && memcmp( backup_initial_col, col, components * sizeof( float ) ) == 0 )
		value_changed = false;
	if( value_changed )
		MarkItemEdited( window->DC.LastItemId );

	PopID();

	return value_changed;
}

// A little colored square. Return true when clicked.
// FIXME: May want to display/ignore the alpha component in the color display? Yet show it in the tooltip.
// 'desc_id' is not called 'label' because we don't display it next to the button, but only in the tooltip.
// Note that 'col' may be encoded in HSV if ImGuiColorEditFlags_InputHSV is set.
bool ImGui::ColorButton( const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags, ImVec2 size )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiID id = window->GetID( desc_id );
	float default_size = GetFrameHeight();
	if( size.x == 0.0f )
		size.x = default_size;
	if( size.y == 0.0f )
		size.y = default_size;
	const ImRect bb( window->DC.CursorPos, window->DC.CursorPos + size );
	ItemSize( bb, ( size.y >= default_size ) ? g.Style.FramePadding.y : 0.0f );
	if( !ItemAdd( bb, id ) )
		return false;

	bool hovered, held;
	bool pressed = ButtonBehavior( bb, id, &hovered, &held );

	if( flags & ImGuiColorEditFlags_NoAlpha )
		flags &= ~( ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf );

	ImVec4 col_rgb = col;
	if( flags & ImGuiColorEditFlags_InputHSV )
		ColorConvertHSVtoRGB( col_rgb.x, col_rgb.y, col_rgb.z, col_rgb.x, col_rgb.y, col_rgb.z );

	ImVec4 col_rgb_without_alpha( col_rgb.x, col_rgb.y, col_rgb.z, 1.0f );
	float grid_step = ImMin( size.x, size.y ) / 2.99f;
	float rounding = ImMin( g.Style.FrameRounding, grid_step * 0.5f );
	ImRect bb_inner = bb;
	float off = 0.0f;
	if( ( flags & ImGuiColorEditFlags_NoBorder ) == 0 )
	{
		off = -0.75f; // The border (using Col_FrameBg) tends to look off when color is near-opaque and rounding is enabled. This offset seemed like a good middle ground to reduce those artifacts.
		bb_inner.Expand( off );
	}
	if( ( flags & ImGuiColorEditFlags_AlphaPreviewHalf ) && col_rgb.w < 1.0f )
	{
		float mid_x = IM_ROUND( ( bb_inner.Min.x + bb_inner.Max.x ) * 0.5f );
		RenderColorRectWithAlphaCheckerboard( window->DrawList, ImVec2( bb_inner.Min.x + grid_step, bb_inner.Min.y ), bb_inner.Max, GetColorU32( col_rgb ), grid_step, ImVec2( -grid_step + off, off ), rounding, ImDrawCornerFlags_TopRight | ImDrawCornerFlags_BotRight );
		window->DrawList->AddRectFilled( bb_inner.Min, ImVec2( mid_x, bb_inner.Max.y ), GetColorU32( col_rgb_without_alpha ), rounding, ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotLeft );
	}
	else
	{
		// Because GetColorU32() multiplies by the global style Alpha and we don't want to display a checkerboard if the source code had no alpha
		ImVec4 col_source = ( flags & ImGuiColorEditFlags_AlphaPreview ) ? col_rgb : col_rgb_without_alpha;
		if( col_source.w < 1.0f )
			RenderColorRectWithAlphaCheckerboard( window->DrawList, bb_inner.Min, bb_inner.Max, GetColorU32( col_source ), grid_step, ImVec2( off, off ), rounding );
		else
			window->DrawList->AddRectFilled( bb_inner.Min, bb_inner.Max, GetColorU32( col_source ), rounding, ImDrawCornerFlags_All );
	}
	RenderNavHighlight( bb, id );
	if( ( flags & ImGuiColorEditFlags_NoBorder ) == 0 )
	{
		if( g.Style.FrameBorderSize > 0.0f )
			RenderFrameBorder( bb.Min, bb.Max, rounding );
		else
			window->DrawList->AddRect( bb.Min, bb.Max, GetColorU32( ImGuiCol_FrameBg ), rounding ); // Color button are often in need of some sort of border
	}

	// Drag and Drop Source
	// NB: The ActiveId test is merely an optional micro-optimization, BeginDragDropSource() does the same test.
	if( g.ActiveId == id && !( flags & ImGuiColorEditFlags_NoDragDrop ) && BeginDragDropSource() )
	{
		if( flags & ImGuiColorEditFlags_NoAlpha )
			SetDragDropPayload( IMGUI_PAYLOAD_TYPE_COLOR_3F, &col_rgb, sizeof( float ) * 3, ImGuiCond_Once );
		else
			SetDragDropPayload( IMGUI_PAYLOAD_TYPE_COLOR_4F, &col_rgb, sizeof( float ) * 4, ImGuiCond_Once );
		ColorButton( desc_id, col, flags );
		SameLine();
		TextEx( SECURE("Color") );
		EndDragDropSource();
	}

	// Tooltip
	if( !( flags & ImGuiColorEditFlags_NoTooltip ) && hovered )
		ColorTooltip( desc_id, &col.x, flags & ( ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf ) );

	return pressed;
}

// Initialize/override default color options
void ImGui::SetColorEditOptions( ImGuiColorEditFlags flags )
{
	ImGuiContext& g = *GImGui;
	if( ( flags & ImGuiColorEditFlags__DisplayMask ) == 0 )
		flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__DisplayMask;
	if( ( flags & ImGuiColorEditFlags__DataTypeMask ) == 0 )
		flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__DataTypeMask;
	if( ( flags & ImGuiColorEditFlags__PickerMask ) == 0 )
		flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__PickerMask;
	if( ( flags & ImGuiColorEditFlags__InputMask ) == 0 )
		flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__InputMask;
	IM_ASSERT( ImIsPowerOfTwo( flags & ImGuiColorEditFlags__DisplayMask ) );    // Check only 1 option is selected
	IM_ASSERT( ImIsPowerOfTwo( flags & ImGuiColorEditFlags__DataTypeMask ) );   // Check only 1 option is selected
	IM_ASSERT( ImIsPowerOfTwo( flags & ImGuiColorEditFlags__PickerMask ) );     // Check only 1 option is selected
	IM_ASSERT( ImIsPowerOfTwo( flags & ImGuiColorEditFlags__InputMask ) );      // Check only 1 option is selected
	g.ColorEditOptions = flags;
}

// Note: only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
void ImGui::ColorTooltip( const char* text, const float* col, ImGuiColorEditFlags flags )
{
	ImGuiContext& g = *GImGui;

	BeginTooltipEx( 0, ImGuiTooltipFlags_OverridePreviousTooltip );
	const char* text_end = text ? FindRenderedTextEnd( text, NULL ) : text;
	if( text_end > text )
	{
		TextEx( text, text_end );
		Separator();
	}

	ImVec2 sz( g.FontSize * 3 + g.Style.FramePadding.y * 2, g.FontSize * 3 + g.Style.FramePadding.y * 2 );
	ImVec4 cf( col[ 0 ], col[ 1 ], col[ 2 ], ( flags & ImGuiColorEditFlags_NoAlpha ) ? 1.0f : col[ 3 ] );
	int cr = IM_F32_TO_INT8_SAT( col[ 0 ] ), cg = IM_F32_TO_INT8_SAT( col[ 1 ] ), cb = IM_F32_TO_INT8_SAT( col[ 2 ] ), ca = ( flags & ImGuiColorEditFlags_NoAlpha ) ? 255 : IM_F32_TO_INT8_SAT( col[ 3 ] );
	ColorButton( SECURE("##preview"), cf, ( flags & ( ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf ) ) | ImGuiColorEditFlags_NoTooltip, sz );
	SameLine();
	if( ( flags & ImGuiColorEditFlags_InputRGB ) || !( flags & ImGuiColorEditFlags__InputMask ) )
	{
		if( flags & ImGuiColorEditFlags_NoAlpha )
			Text( SECURE("#%02X%02X%02X\nR: %d, G: %d, B: %d\n(%.3f, %.3f, %.3f)"), cr, cg, cb, cr, cg, cb, col[ 0 ], col[ 1 ], col[ 2 ] );
		else
			Text( SECURE("#%02X%02X%02X%02X\nR:%d, G:%d, B:%d, A:%d\n(%.3f, %.3f, %.3f, %.3f)"), cr, cg, cb, ca, cr, cg, cb, ca, col[ 0 ], col[ 1 ], col[ 2 ], col[ 3 ] );
	}
	else if( flags & ImGuiColorEditFlags_InputHSV )
	{
		if( flags & ImGuiColorEditFlags_NoAlpha )
			Text( SECURE("H: %.3f, S: %.3f, V: %.3f"), col[ 0 ], col[ 1 ], col[ 2 ] );
		else
			Text( SECURE("H: %.3f, S: %.3f, V: %.3f, A: %.3f"), col[ 0 ], col[ 1 ], col[ 2 ], col[ 3 ] );
	}
	EndTooltip();
}

void ImGui::ColorEditOptionsPopup( const float* col, ImGuiColorEditFlags flags )
{
	bool allow_opt_inputs = !( flags & ImGuiColorEditFlags__DisplayMask );
	bool allow_opt_datatype = !( flags & ImGuiColorEditFlags__DataTypeMask );
	if( ( !allow_opt_inputs && !allow_opt_datatype ) || !BeginPopup( SECURE("context") ) )
		return;
	ImGuiContext& g = *GImGui;
	ImGuiColorEditFlags opts = g.ColorEditOptions;
	if( allow_opt_inputs )
	{
		if( RadioButton( SECURE("RGB"), ( opts & ImGuiColorEditFlags_DisplayRGB ) != 0 ) ) opts = ( opts & ~ImGuiColorEditFlags__DisplayMask ) | ImGuiColorEditFlags_DisplayRGB;
		if( RadioButton( SECURE("HSV"), ( opts & ImGuiColorEditFlags_DisplayHSV ) != 0 ) ) opts = ( opts & ~ImGuiColorEditFlags__DisplayMask ) | ImGuiColorEditFlags_DisplayHSV;
		if( RadioButton( SECURE("Hex"), ( opts & ImGuiColorEditFlags_DisplayHex ) != 0 ) ) opts = ( opts & ~ImGuiColorEditFlags__DisplayMask ) | ImGuiColorEditFlags_DisplayHex;
	}
	if( allow_opt_datatype )
	{
		if( allow_opt_inputs ) Separator();
		if( RadioButton( SECURE("0..255"), ( opts & ImGuiColorEditFlags_Uint8 ) != 0 ) ) opts = ( opts & ~ImGuiColorEditFlags__DataTypeMask ) | ImGuiColorEditFlags_Uint8;
		if( RadioButton( SECURE("0.00..1.00"), ( opts & ImGuiColorEditFlags_Float ) != 0 ) ) opts = ( opts & ~ImGuiColorEditFlags__DataTypeMask ) | ImGuiColorEditFlags_Float;
	}

	if( allow_opt_inputs || allow_opt_datatype )
		Separator();
	if( Button( SECURE("Copy as.."), ImVec2( -1, 0 ) ) )
		OpenPopup( SECURE("Copy") );
	if( BeginPopup( SECURE("Copy") ) )
	{
		int cr = IM_F32_TO_INT8_SAT( col[ 0 ] ), cg = IM_F32_TO_INT8_SAT( col[ 1 ] ), cb = IM_F32_TO_INT8_SAT( col[ 2 ] ), ca = ( flags & ImGuiColorEditFlags_NoAlpha ) ? 255 : IM_F32_TO_INT8_SAT( col[ 3 ] );
		char buf[ 64 ];
		ImFormatString( buf, IM_ARRAYSIZE( buf ), SECURE("(%.3ff, %.3ff, %.3ff, %.3ff)"), col[ 0 ], col[ 1 ], col[ 2 ], ( flags & ImGuiColorEditFlags_NoAlpha ) ? 1.0f : col[ 3 ] );
		if( Selectable( buf ) )
			SetClipboardText( buf );
		ImFormatString( buf, IM_ARRAYSIZE( buf ), SECURE("(%d,%d,%d,%d)"), cr, cg, cb, ca );
		if( Selectable( buf ) )
			SetClipboardText( buf );
		ImFormatString( buf, IM_ARRAYSIZE( buf ), SECURE("#%02X%02X%02X"), cr, cg, cb );
		if( Selectable( buf ) )
			SetClipboardText( buf );
		if( !( flags & ImGuiColorEditFlags_NoAlpha ) )
		{
			ImFormatString( buf, IM_ARRAYSIZE( buf ), SECURE("#%02X%02X%02X%02X"), cr, cg, cb, ca );
			if( Selectable( buf ) )
				SetClipboardText( buf );
		}
		EndPopup();
	}

	g.ColorEditOptions = opts;
	EndPopup();
}

void ImGui::ColorPickerOptionsPopup( const float* ref_col, ImGuiColorEditFlags flags )
{
	bool allow_opt_picker = !( flags & ImGuiColorEditFlags__PickerMask );
	bool allow_opt_alpha_bar = !( flags & ImGuiColorEditFlags_NoAlpha ) && !( flags & ImGuiColorEditFlags_AlphaBar );
	if( ( !allow_opt_picker && !allow_opt_alpha_bar ) || !BeginPopup( SECURE("context") ) )
		return;
	ImGuiContext& g = *GImGui;
	if( allow_opt_picker )
	{
		ImVec2 picker_size( g.FontSize * 8, ImMax( g.FontSize * 8 - ( GetFrameHeight() + g.Style.ItemInnerSpacing.x ), 1.0f ) ); // FIXME: Picker size copied from main picker function
		PushItemWidth( picker_size.x );
		for( int picker_type = 0; picker_type < 2; picker_type++ )
		{
			// Draw small/thumbnail version of each picker type (over an invisible button for selection)
			if( picker_type > 0 ) Separator();
			PushID( picker_type );
			ImGuiColorEditFlags picker_flags = ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_NoSidePreview | ( flags & ImGuiColorEditFlags_NoAlpha );
			if( picker_type == 0 ) picker_flags |= ImGuiColorEditFlags_PickerHueBar;
			if( picker_type == 1 ) picker_flags |= ImGuiColorEditFlags_PickerHueWheel;
			ImVec2 backup_pos = GetCursorScreenPos();
			if( Selectable( SECURE("##selectable"), false, 0, picker_size ) ) // By default, Selectable() is closing popup
				g.ColorEditOptions = ( g.ColorEditOptions & ~ImGuiColorEditFlags__PickerMask ) | ( picker_flags & ImGuiColorEditFlags__PickerMask );
			SetCursorScreenPos( backup_pos );
			ImVec4 dummy_ref_col;
			memcpy( &dummy_ref_col, ref_col, sizeof( float ) * ( ( picker_flags & ImGuiColorEditFlags_NoAlpha ) ? 3 : 4 ) );
			ColorPicker4( SECURE("##dummypicker"), &dummy_ref_col.x, picker_flags );
			PopID();
		}
		PopItemWidth();
	}
	if( allow_opt_alpha_bar )
	{
		if( allow_opt_picker ) Separator();
		CheckboxFlags( SECURE("Alpha Bar"), ( unsigned int* )&g.ColorEditOptions, ImGuiColorEditFlags_AlphaBar );
	}
	EndPopup();
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.
//-------------------------------------------------------------------------
// - TreeNode()
// - TreeNodeV()
// - TreeNodeEx()
// - TreeNodeExV()
// - TreeNodeBehavior() [Internal]
// - TreePush()
// - TreePop()
// - GetTreeNodeToLabelSpacing()
// - SetNextItemOpen()
// - CollapsingHeader()
//-------------------------------------------------------------------------

bool ImGui::TreeNode( const char* str_id, const char* fmt, ... )
{
	va_list args;
	va_start( args, fmt );
	bool is_open = TreeNodeExV( str_id, 0, fmt, args );
	va_end( args );
	return is_open;
}

bool ImGui::TreeNode( const void* ptr_id, const char* fmt, ... )
{
	va_list args;
	va_start( args, fmt );
	bool is_open = TreeNodeExV( ptr_id, 0, fmt, args );
	va_end( args );
	return is_open;
}

bool ImGui::TreeNode( const char* label )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;
	return TreeNodeBehavior( window->GetID( label ), 0, label, NULL );
}

bool ImGui::TreeNodeV( const char* str_id, const char* fmt, va_list args )
{
	return TreeNodeExV( str_id, 0, fmt, args );
}

bool ImGui::TreeNodeV( const void* ptr_id, const char* fmt, va_list args )
{
	return TreeNodeExV( ptr_id, 0, fmt, args );
}

bool ImGui::TreeNodeEx( const char* label, ImGuiTreeNodeFlags flags )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	return TreeNodeBehavior( window->GetID( label ), flags, label, NULL );
}

bool ImGui::TreeNodeEx( const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ... )
{
	va_list args;
	va_start( args, fmt );
	bool is_open = TreeNodeExV( str_id, flags, fmt, args );
	va_end( args );
	return is_open;
}

bool ImGui::TreeNodeEx( const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ... )
{
	va_list args;
	va_start( args, fmt );
	bool is_open = TreeNodeExV( ptr_id, flags, fmt, args );
	va_end( args );
	return is_open;
}

bool ImGui::TreeNodeExV( const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	const char* label_end = g.TempBuffer + ImFormatStringV( g.TempBuffer, IM_ARRAYSIZE( g.TempBuffer ), fmt, args );
	return TreeNodeBehavior( window->GetID( str_id ), flags, g.TempBuffer, label_end );
}

bool ImGui::TreeNodeExV( const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	const char* label_end = g.TempBuffer + ImFormatStringV( g.TempBuffer, IM_ARRAYSIZE( g.TempBuffer ), fmt, args );
	return TreeNodeBehavior( window->GetID( ptr_id ), flags, g.TempBuffer, label_end );
}

bool ImGui::TreeNodeBehaviorIsOpen( ImGuiID id, ImGuiTreeNodeFlags flags )
{
	if( flags & ImGuiTreeNodeFlags_Leaf )
		return true;

	// We only write to the tree storage if the user clicks (or explicitly use the SetNextItemOpen function)
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	ImGuiStorage* storage = window->DC.StateStorage;

	bool is_open;
	if( g.NextItemData.Flags & ImGuiNextItemDataFlags_HasOpen )
	{
		if( g.NextItemData.OpenCond & ImGuiCond_Always )
		{
			is_open = g.NextItemData.OpenVal;
			storage->SetInt( id, is_open );
		}
		else
		{
			// We treat ImGuiCond_Once and ImGuiCond_FirstUseEver the same because tree node state are not saved persistently.
			const int stored_value = storage->GetInt( id, -1 );
			if( stored_value == -1 )
			{
				is_open = g.NextItemData.OpenVal;
				storage->SetInt( id, is_open );
			}
			else
			{
				is_open = stored_value != 0;
			}
		}
	}
	else
	{
		is_open = storage->GetInt( id, ( flags & ImGuiTreeNodeFlags_DefaultOpen ) ? 1 : 0 ) != 0;
	}

	// When logging is enabled, we automatically expand tree nodes (but *NOT* collapsing headers.. seems like sensible behavior).
	// NB- If we are above max depth we still allow manually opened nodes to be logged.
	if( g.LogEnabled && !( flags & ImGuiTreeNodeFlags_NoAutoOpenOnLog ) && ( window->DC.TreeDepth - g.LogDepthRef ) < g.LogDepthToExpand )
		is_open = true;

	return is_open;
}

bool ImGui::TreeNodeBehavior( ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const bool display_frame = ( flags & ImGuiTreeNodeFlags_Framed ) != 0;
	const ImVec2 padding = ( display_frame || ( flags & ImGuiTreeNodeFlags_FramePadding ) ) ? style.FramePadding : ImVec2( style.FramePadding.x, ImMin( window->DC.CurrLineTextBaseOffset, style.FramePadding.y ) );

	if( !label_end )
		label_end = FindRenderedTextEnd( label );
	const ImVec2 label_size = CalcTextSize( label, label_end, false );

	// We vertically grow up to current line height up the typical widget height.
	const float frame_height = ImMax( ImMin( window->DC.CurrLineSize.y, g.FontSize + style.FramePadding.y * 2 ), label_size.y + padding.y * 2 );
	ImRect frame_bb;
	frame_bb.Min.x = ( flags & ImGuiTreeNodeFlags_SpanFullWidth ) ? window->WorkRect.Min.x : window->DC.CursorPos.x;
	frame_bb.Min.y = window->DC.CursorPos.y;
	frame_bb.Max.x = window->WorkRect.Max.x;
	frame_bb.Max.y = window->DC.CursorPos.y + frame_height;
	if( display_frame )
	{
		// Framed header expand a little outside the default padding, to the edge of InnerClipRect
		// (FIXME: May remove this at some point and make InnerClipRect align with WindowPadding.x instead of WindowPadding.x*0.5f)
		frame_bb.Min.x -= IM_FLOOR( window->WindowPadding.x * 0.5f - 1.0f );
		frame_bb.Max.x += IM_FLOOR( window->WindowPadding.x * 0.5f );
	}

	const float text_offset_x = g.FontSize + ( display_frame ? padding.x * 3 : padding.x * 2 );               // Collapser arrow width + Spacing
	const float text_offset_y = ImMax( padding.y, window->DC.CurrLineTextBaseOffset );                    // Latch before ItemSize changes it
	const float text_width = g.FontSize + ( label_size.x > 0.0f ? label_size.x + padding.x * 2 : 0.0f );    // Include collapser
	ImVec2 text_pos( window->DC.CursorPos.x + text_offset_x, window->DC.CursorPos.y + text_offset_y );
	ItemSize( ImVec2( text_width, frame_height ), padding.y );

	// For regular tree nodes, we arbitrary allow to click past 2 worth of ItemSpacing
	ImRect interact_bb = frame_bb;
	if( !display_frame && ( flags & ( ImGuiTreeNodeFlags_SpanAvailWidth | ImGuiTreeNodeFlags_SpanFullWidth ) ) == 0 )
		interact_bb.Max.x = frame_bb.Min.x + text_width + style.ItemSpacing.x * 2.0f;

	// Store a flag for the current depth to tell if we will allow closing this node when navigating one of its child.
	// For this purpose we essentially compare if g.NavIdIsAlive went from 0 to 1 between TreeNode() and TreePop().
	// This is currently only support 32 level deep and we are fine with (1 << Depth) overflowing into a zero.
	const bool is_leaf = ( flags & ImGuiTreeNodeFlags_Leaf ) != 0;
	bool is_open = TreeNodeBehaviorIsOpen( id, flags );
	if( is_open && !g.NavIdIsAlive && ( flags & ImGuiTreeNodeFlags_NavLeftJumpsBackHere ) && !( flags & ImGuiTreeNodeFlags_NoTreePushOnOpen ) )
		window->DC.TreeJumpToParentOnPopMask |= ( 1 << window->DC.TreeDepth );

	bool item_add = ItemAdd( interact_bb, id );
	window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HasDisplayRect;
	window->DC.LastItemDisplayRect = frame_bb;

	if( !item_add )
	{
		if( is_open && !( flags & ImGuiTreeNodeFlags_NoTreePushOnOpen ) )
			TreePushOverrideID( id );
		IMGUI_TEST_ENGINE_ITEM_INFO( window->DC.LastItemId, label, window->DC.ItemFlags | ( is_leaf ? 0 : ImGuiItemStatusFlags_Openable ) | ( is_open ? ImGuiItemStatusFlags_Opened : 0 ) );
		return is_open;
	}

	ImGuiButtonFlags button_flags = ImGuiTreeNodeFlags_None;
	if( flags & ImGuiTreeNodeFlags_AllowItemOverlap )
		button_flags |= ImGuiButtonFlags_AllowItemOverlap;
	if( !is_leaf )
		button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;

	// We allow clicking on the arrow section with keyboard modifiers held, in order to easily
	// allow browsing a tree while preserving selection with code implementing multi-selection patterns.
	// When clicking on the rest of the tree node we always disallow keyboard modifiers.
	const float arrow_hit_x1 = ( text_pos.x - text_offset_x ) - style.TouchExtraPadding.x;
	const float arrow_hit_x2 = ( text_pos.x - text_offset_x ) + ( g.FontSize + padding.x * 2.0f ) + style.TouchExtraPadding.x;
	const bool is_mouse_x_over_arrow = ( g.IO.MousePos.x >= arrow_hit_x1 && g.IO.MousePos.x < arrow_hit_x2 );
	if( window != g.HoveredWindow || !is_mouse_x_over_arrow )
		button_flags |= ImGuiButtonFlags_NoKeyModifiers;

	// Open behaviors can be altered with the _OpenOnArrow and _OnOnDoubleClick flags.
	// Some alteration have subtle effects (e.g. toggle on MouseUp vs MouseDown events) due to requirements for multi-selection and drag and drop support.
	// - Single-click on label = Toggle on MouseUp (default)
	// - Single-click on arrow = Toggle on MouseUp (when _OpenOnArrow=0)
	// - Single-click on arrow = Toggle on MouseDown (when _OpenOnArrow=1)
	// - Double-click on label = Toggle on MouseDoubleClick (when _OpenOnDoubleClick=1)
	// - Double-click on arrow = Toggle on MouseDoubleClick (when _OpenOnDoubleClick=1 and _OpenOnArrow=0)
	// This makes _OpenOnArrow have a subtle effect on _OpenOnDoubleClick: arrow click reacts on Down rather than Up.
	// It is rather standard that arrow click react on Down rather than Up and we'd be tempted to make it the default
	// (by removing the _OpenOnArrow test below), however this would have a perhaps surprising effect on CollapsingHeader()?
	// So right now we are making this optional. May evolve later.
	// We set ImGuiButtonFlags_PressedOnClickRelease on OpenOnDoubleClick because we want the item to be active on the initial MouseDown in order for drag and drop to work.
	if( is_mouse_x_over_arrow && ( flags & ImGuiTreeNodeFlags_OpenOnArrow ) )
		button_flags |= ImGuiButtonFlags_PressedOnClick;
	else if( flags & ImGuiTreeNodeFlags_OpenOnDoubleClick )
		button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick;
	else
		button_flags |= ImGuiButtonFlags_PressedOnClickRelease;

	bool selected = ( flags & ImGuiTreeNodeFlags_Selected ) != 0;
	const bool was_selected = selected;

	bool hovered, held;
	bool pressed = ButtonBehavior( interact_bb, id, &hovered, &held, button_flags );
	bool toggled = false;
	if( !is_leaf )
	{
		if( pressed && g.DragDropHoldJustPressedId != id )
		{
			if( ( flags & ( ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick ) ) == 0 || ( g.NavActivateId == id ) )
				toggled = true;
			if( flags & ImGuiTreeNodeFlags_OpenOnArrow )
				toggled |= is_mouse_x_over_arrow && !g.NavDisableMouseHover; // Lightweight equivalent of IsMouseHoveringRect() since ButtonBehavior() already did the job
			if( ( flags & ImGuiTreeNodeFlags_OpenOnDoubleClick ) && g.IO.MouseDoubleClicked[ 0 ] )
				toggled = true;
		}
		else if( pressed && g.DragDropHoldJustPressedId == id )
		{
			IM_ASSERT( button_flags & ImGuiButtonFlags_PressedOnDragDropHold );
			if( !is_open ) // When using Drag and Drop "hold to open" we keep the node highlighted after opening, but never close it again.
				toggled = true;
		}

		if( g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Left && is_open )
		{
			toggled = true;
			NavMoveRequestCancel();
		}
		if( g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right && !is_open ) // If there's something upcoming on the line we may want to give it the priority?
		{
			toggled = true;
			NavMoveRequestCancel();
		}

		if( toggled )
		{
			is_open = !is_open;
			window->DC.StateStorage->SetInt( id, is_open );
			window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_ToggledOpen;
		}
	}
	if( flags & ImGuiTreeNodeFlags_AllowItemOverlap )
		SetItemAllowOverlap();

	// In this branch, TreeNodeBehavior() cannot toggle the selection so this will never trigger.
	if( selected != was_selected ) //-V547
		window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_ToggledSelection;

	// Render
	const ImU32 text_col = GetColorU32( ImGuiCol_Text );
	ImGuiNavHighlightFlags nav_highlight_flags = ImGuiNavHighlightFlags_TypeThin;
	if( display_frame )
	{
		// Framed type
		const ImU32 bg_col = GetColorU32( ( held && hovered ) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header );
		RenderFrame( frame_bb.Min, frame_bb.Max, bg_col, true, style.FrameRounding );
		RenderNavHighlight( frame_bb, id, nav_highlight_flags );
		if( flags & ImGuiTreeNodeFlags_Bullet )
			RenderBullet( window->DrawList, ImVec2( text_pos.x - text_offset_x * 0.60f, text_pos.y + g.FontSize * 0.5f ), text_col );
		else if( !is_leaf )
			RenderArrow( window->DrawList, ImVec2( text_pos.x - text_offset_x + padding.x, text_pos.y ), text_col, is_open ? ImGuiDir_Down : ImGuiDir_Right, 1.0f );
		else // Leaf without bullet, left-adjusted text
			text_pos.x -= text_offset_x;
		if( flags & ImGuiTreeNodeFlags_ClipLabelForTrailingButton )
			frame_bb.Max.x -= g.FontSize + style.FramePadding.x;
		if( g.LogEnabled )
		{
			// NB: '##' is normally used to hide text (as a library-wide feature), so we need to specify the text range to make sure the ## aren't stripped out here.
			const char log_prefix[] = "\n##";
			const char log_suffix[] = "##";
			LogRenderedText( &text_pos, log_prefix, log_prefix + 3 );
			RenderTextClipped( text_pos, frame_bb.Max, label, label_end, &label_size );
			LogRenderedText( &text_pos, log_suffix, log_suffix + 2 );
		}
		else
		{
			RenderTextClipped( text_pos, frame_bb.Max, label, label_end, &label_size );
		}
	}
	else
	{
		// Unframed typed for tree nodes
		if( hovered || selected )
		{
			const ImU32 bg_col = GetColorU32( ( held && hovered ) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header );
			RenderFrame( frame_bb.Min, frame_bb.Max, bg_col, false );
			RenderNavHighlight( frame_bb, id, nav_highlight_flags );
		}
		if( flags & ImGuiTreeNodeFlags_Bullet )
			RenderBullet( window->DrawList, ImVec2( text_pos.x - text_offset_x * 0.5f, text_pos.y + g.FontSize * 0.5f ), text_col );
		else if( !is_leaf )
			RenderArrow( window->DrawList, ImVec2( text_pos.x - text_offset_x + padding.x, text_pos.y + g.FontSize * 0.15f ), text_col, is_open ? ImGuiDir_Down : ImGuiDir_Right, 0.70f );
		if( g.LogEnabled )
			LogRenderedText( &text_pos, SECURE(">") );
		RenderText( text_pos, label, label_end, false );
	}

	if( is_open && !( flags & ImGuiTreeNodeFlags_NoTreePushOnOpen ) )
		TreePushOverrideID( id );
	IMGUI_TEST_ENGINE_ITEM_INFO( id, label, window->DC.ItemFlags | ( is_leaf ? 0 : ImGuiItemStatusFlags_Openable ) | ( is_open ? ImGuiItemStatusFlags_Opened : 0 ) );
	return is_open;
}

void ImGui::TreePush( const char* str_id )
{
	ImGuiWindow* window = GetCurrentWindow();
	Indent();
	window->DC.TreeDepth++;
	PushID( str_id ? str_id : SECURE("#TreePush") );
}

void ImGui::TreePush( const void* ptr_id )
{
	ImGuiWindow* window = GetCurrentWindow();
	Indent();
	window->DC.TreeDepth++;
	PushID( ptr_id ? ptr_id : ( const void* )SECURE("#TreePush") );
}

void ImGui::TreePushOverrideID( ImGuiID id )
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	Indent();
	window->DC.TreeDepth++;
	window->IDStack.push_back( id );
}

void ImGui::TreePop()
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	Unindent();

	window->DC.TreeDepth--;
	ImU32 tree_depth_mask = ( 1 << window->DC.TreeDepth );

	// Handle Left arrow to move to parent tree node (when ImGuiTreeNodeFlags_NavLeftJumpsBackHere is enabled)
	if( g.NavMoveDir == ImGuiDir_Left && g.NavWindow == window && NavMoveRequestButNoResultYet() )
		if( g.NavIdIsAlive && ( window->DC.TreeJumpToParentOnPopMask & tree_depth_mask ) )
		{
			SetNavID( window->IDStack.back(), g.NavLayer, 0 );
			NavMoveRequestCancel();
		}
	window->DC.TreeJumpToParentOnPopMask &= tree_depth_mask - 1;

	IM_ASSERT( window->IDStack.Size > 1 ); // There should always be 1 element in the IDStack (pushed during window creation). If this triggers you called TreePop/PopID too much.
	PopID();
}

// Horizontal distance preceding label when using TreeNode() or Bullet()
float ImGui::GetTreeNodeToLabelSpacing()
{
	ImGuiContext& g = *GImGui;
	return g.FontSize + ( g.Style.FramePadding.x * 2.0f );
}

// Set next TreeNode/CollapsingHeader open state.
void ImGui::SetNextItemOpen( bool is_open, ImGuiCond cond )
{
	ImGuiContext& g = *GImGui;
	if( g.CurrentWindow->SkipItems )
		return;
	g.NextItemData.Flags |= ImGuiNextItemDataFlags_HasOpen;
	g.NextItemData.OpenVal = is_open;
	g.NextItemData.OpenCond = cond ? cond : ImGuiCond_Always;
}

// CollapsingHeader returns true when opened but do not indent nor push into the ID stack (because of the ImGuiTreeNodeFlags_NoTreePushOnOpen flag).
// This is basically the same as calling TreeNodeEx(label, ImGuiTreeNodeFlags_CollapsingHeader). You can remove the _NoTreePushOnOpen flag if you want behavior closer to normal TreeNode().
bool ImGui::CollapsingHeader( const char* label, ImGuiTreeNodeFlags flags )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	return TreeNodeBehavior( window->GetID( label ), flags | ImGuiTreeNodeFlags_CollapsingHeader, label );
}

bool ImGui::CollapsingHeader( const char* label, bool* p_open, ImGuiTreeNodeFlags flags )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	if( p_open && !*p_open )
		return false;

	ImGuiID id = window->GetID( label );
	flags |= ImGuiTreeNodeFlags_CollapsingHeader;
	if( p_open )
		flags |= ImGuiTreeNodeFlags_AllowItemOverlap | ImGuiTreeNodeFlags_ClipLabelForTrailingButton;
	bool is_open = TreeNodeBehavior( id, flags, label );
	if( p_open )
	{
		// Create a small overlapping close button
		// FIXME: We can evolve this into user accessible helpers to add extra buttons on title bars, headers, etc.
		// FIXME: CloseButton can overlap into text, need find a way to clip the text somehow.
		ImGuiContext& g = *GImGui;
		ImGuiItemHoveredDataBackup last_item_backup;
		float button_size = g.FontSize;
		float button_x = ImMax( window->DC.LastItemRect.Min.x, window->DC.LastItemRect.Max.x - g.Style.FramePadding.x * 2.0f - button_size );
		float button_y = window->DC.LastItemRect.Min.y;
		if( CloseButton( window->GetID( ( void* )( ( intptr_t )id + 1 ) ), ImVec2( button_x, button_y ) ) )
			*p_open = false;
		last_item_backup.Restore();
	}

	return is_open;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Selectable
//-------------------------------------------------------------------------
// - Selectable()
//-------------------------------------------------------------------------

// Tip: pass a non-visible label (e.g. "##dummy") then you can use the space to draw other text or image.
// But you need to make sure the ID is unique, e.g. enclose calls in PushID/PopID or use ##unique_id.
// With this scheme, ImGuiSelectableFlags_SpanAllColumns and ImGuiSelectableFlags_AllowItemOverlap are also frequently used flags.
// FIXME: Selectable() with (size.x == 0.0f) and (SelectableTextAlign.x > 0.0f) followed by SameLine() is currently not supported.
bool ImGui::Selectable( const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;

	if( ( flags & ImGuiSelectableFlags_SpanAllColumns ) && window->DC.CurrentColumns ) // FIXME-OPT: Avoid if vertically clipped.
		PushColumnsBackground();

	// Submit label or explicit size to ItemSize(), whereas ItemAdd() will submit a larger/spanning rectangle.
	ImGuiID id = window->GetID( label );
	ImVec2 label_size = CalcTextSize( label, NULL, true );
	ImVec2 size( size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y );
	ImVec2 pos = window->DC.CursorPos;
	pos.y += window->DC.CurrLineTextBaseOffset;
	ItemSize( size, 0.0f );

	// Fill horizontal space
	const float min_x = ( flags & ImGuiSelectableFlags_SpanAllColumns ) ? window->ContentRegionRect.Min.x : pos.x;
	const float max_x = ( flags & ImGuiSelectableFlags_SpanAllColumns ) ? window->ContentRegionRect.Max.x : GetContentRegionMaxAbs().x;
	if( size_arg.x == 0.0f || ( flags & ImGuiSelectableFlags_SpanAvailWidth ) )
		size.x = ImMax( label_size.x, max_x - min_x );

	// Text stays at the submission position, but bounding box may be extended on both sides
	const ImVec2 text_min = pos;
	const ImVec2 text_max( min_x + size.x, pos.y + size.y );

	// Selectables are meant to be tightly packed together with no click-gap, so we extend their box to cover spacing between selectable.
	ImRect bb_enlarged( min_x, pos.y, text_max.x, text_max.y );
	const float spacing_x = style.ItemSpacing.x;
	const float spacing_y = style.ItemSpacing.y;
	const float spacing_L = IM_FLOOR( spacing_x * 0.50f );
	const float spacing_U = IM_FLOOR( spacing_y * 0.50f );
	bb_enlarged.Min.x -= spacing_L;
	bb_enlarged.Min.y -= spacing_U;
	bb_enlarged.Max.x += ( spacing_x - spacing_L );
	bb_enlarged.Max.y += ( spacing_y - spacing_U );
	//if (g.IO.KeyCtrl) { GetForegroundDrawList()->AddRect(bb_align.Min, bb_align.Max, IM_COL32(255, 0, 0, 255)); }
	//if (g.IO.KeyCtrl) { GetForegroundDrawList()->AddRect(bb_enlarged.Min, bb_enlarged.Max, IM_COL32(0, 255, 0, 255)); }

	bool item_add;
	if( flags & ImGuiSelectableFlags_Disabled )
	{
		ImGuiItemFlags backup_item_flags = window->DC.ItemFlags;
		window->DC.ItemFlags |= ImGuiItemFlags_Disabled | ImGuiItemFlags_NoNavDefaultFocus;
		item_add = ItemAdd( bb_enlarged, id );
		window->DC.ItemFlags = backup_item_flags;
	}
	else
	{
		item_add = ItemAdd( bb_enlarged, id );
	}
	if( !item_add )
	{
		if( ( flags & ImGuiSelectableFlags_SpanAllColumns ) && window->DC.CurrentColumns )
			PopColumnsBackground();
		return false;
	}

	// We use NoHoldingActiveID on menus so user can click and _hold_ on a menu then drag to browse child entries
	ImGuiButtonFlags button_flags = 0;
	if( flags & ImGuiSelectableFlags_NoHoldingActiveID )
	{
		button_flags |= ImGuiButtonFlags_NoHoldingActiveId;
	}
	if( flags & ImGuiSelectableFlags_SelectOnClick )
	{
		button_flags |= ImGuiButtonFlags_PressedOnClick;
	}
	if( flags & ImGuiSelectableFlags_SelectOnRelease )
	{
		button_flags |= ImGuiButtonFlags_PressedOnRelease;
	}
	if( flags & ImGuiSelectableFlags_Disabled )
	{
		button_flags |= ImGuiButtonFlags_Disabled;
	}
	if( flags & ImGuiSelectableFlags_AllowDoubleClick )
	{
		button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick;
	}
	if( flags & ImGuiSelectableFlags_AllowItemOverlap )
	{
		button_flags |= ImGuiButtonFlags_AllowItemOverlap;
	}

	if( flags & ImGuiSelectableFlags_Disabled )
		selected = false;

	const bool was_selected = selected;
	bool hovered, held;
	bool pressed = ButtonBehavior( bb_enlarged, id, &hovered, &held, button_flags );

	// Update NavId when clicking or when Hovering (this doesn't happen on most widgets), so navigation can be resumed with gamepad/keyboard
	if( pressed || ( hovered && ( flags & ImGuiSelectableFlags_SetNavIdOnHover ) ) )
	{
		if( !g.NavDisableMouseHover && g.NavWindow == window && g.NavLayer == window->DC.NavLayerCurrent )
		{
			g.NavDisableHighlight = true;
			SetNavID( id, window->DC.NavLayerCurrent, window->DC.NavFocusScopeIdCurrent );
		}
	}
	if( pressed )
		MarkItemEdited( id );

	if( flags & ImGuiSelectableFlags_AllowItemOverlap )
		SetItemAllowOverlap();

	// In this branch, Selectable() cannot toggle the selection so this will never trigger.
	if( selected != was_selected ) //-V547
		window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_ToggledSelection;

	// Render
	if( held && ( flags & ImGuiSelectableFlags_DrawHoveredWhenHeld ) )
		hovered = true;
	if( hovered || selected )
	{
		const ImU32 col = GetColorU32( hovered ? ImGuiCol_HeaderHovered : ( selected ? ImGuiCol_HeaderActive : ImGuiCol_Header ) );
		RenderFrame( bb_enlarged.Min, bb_enlarged.Max, col, false, 0.0f );
		RenderNavHighlight( bb_enlarged, id, ImGuiNavHighlightFlags_TypeThin | ImGuiNavHighlightFlags_NoRounding );
	}

	if( ( flags & ImGuiSelectableFlags_SpanAllColumns ) && window->DC.CurrentColumns )
		PopColumnsBackground();

	if( flags & ImGuiSelectableFlags_Disabled ) PushStyleColor( ImGuiCol_Text, style.Colors[ ImGuiCol_TextDisabled ] );
	RenderTextClipped( text_min, text_max, label, NULL, &label_size, style.SelectableTextAlign, &bb_enlarged );
	if( flags & ImGuiSelectableFlags_Disabled ) PopStyleColor();

	// Automatically close popups
	if( pressed && ( window->Flags & ImGuiWindowFlags_Popup ) && !( flags & ImGuiSelectableFlags_DontClosePopups ) && !( window->DC.ItemFlags & ImGuiItemFlags_SelectableDontClosePopup ) )
		CloseCurrentPopup();

	IMGUI_TEST_ENGINE_ITEM_INFO( id, label, window->DC.ItemFlags );
	return pressed;
}

bool ImGui::Selectable( const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg )
{
	if( Selectable( label, *p_selected, flags, size_arg ) )
	{
		*p_selected = !*p_selected;
		return true;
	}
	return false;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ListBox
//-------------------------------------------------------------------------
// - ListBox()
// - ListBoxHeader()
// - ListBoxFooter()
//-------------------------------------------------------------------------
// FIXME: This is an old API. We should redesign some of it, rename ListBoxHeader->BeginListBox, ListBoxFooter->EndListBox
// and promote using them over existing ListBox() functions, similarly to change with combo boxes.
//-------------------------------------------------------------------------

// FIXME: In principle this function should be called BeginListBox(). We should rename it after re-evaluating if we want to keep the same signature.
// Helper to calculate the size of a listbox and display a label on the right.
// Tip: To have a list filling the entire window width, PushItemWidth(-1) and pass an non-visible label e.g. "##empty"
bool ImGui::ListBoxHeader( const char* label, const ImVec2& size_arg )
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	const ImGuiStyle& style = g.Style;
	const ImGuiID id = GetID( label );
	const ImVec2 label_size = CalcTextSize( label, NULL, true );

	// Size default to hold ~7 items. Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.
	ImVec2 size = CalcItemSize( size_arg, CalcItemWidth(), GetTextLineHeightWithSpacing() * 7.4f + style.ItemSpacing.y );
	ImVec2 frame_size = ImVec2( size.x, ImMax( size.y, label_size.y ) );
	ImRect frame_bb( window->DC.CursorPos, window->DC.CursorPos + frame_size );
	ImRect bb( frame_bb.Min, frame_bb.Max + ImVec2( label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f ) );
	window->DC.LastItemRect = bb; // Forward storage for ListBoxFooter.. dodgy.
	g.NextItemData.ClearFlags();

	if( !IsRectVisible( bb.Min, bb.Max ) )
	{
		ItemSize( bb.GetSize(), style.FramePadding.y );
		ItemAdd( bb, 0, &frame_bb );
		return false;
	}

	BeginGroup();
	if( label_size.x > 0 )
		RenderText( ImVec2( frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y ), label );

	BeginChildFrame( id, frame_bb.GetSize() );
	return true;
}

// FIXME: In principle this function should be called EndListBox(). We should rename it after re-evaluating if we want to keep the same signature.
bool ImGui::ListBoxHeader( const char* label, int items_count, int height_in_items )
{
	// Size default to hold ~7.25 items.
	// We add +25% worth of item height to allow the user to see at a glance if there are more items up/down, without looking at the scrollbar.
	// We don't add this extra bit if items_count <= height_in_items. It is slightly dodgy, because it means a dynamic list of items will make the widget resize occasionally when it crosses that size.
	// I am expecting that someone will come and complain about this behavior in a remote future, then we can advise on a better solution.
	if( height_in_items < 0 )
		height_in_items = ImMin( items_count, 7 );
	const ImGuiStyle& style = GetStyle();
	float height_in_items_f = ( height_in_items < items_count ) ? ( height_in_items + 0.25f ) : ( height_in_items + 0.00f );

	// We include ItemSpacing.y so that a list sized for the exact number of items doesn't make a scrollbar appears. We could also enforce that by passing a flag to BeginChild().
	ImVec2 size;
	size.x = 0.0f;
	size.y = ImFloor( GetTextLineHeightWithSpacing() * height_in_items_f + style.FramePadding.y * 2.0f );
	return ListBoxHeader( label, size );
}

// FIXME: In principle this function should be called EndListBox(). We should rename it after re-evaluating if we want to keep the same signature.
void ImGui::ListBoxFooter()
{
	ImGuiWindow* parent_window = GetCurrentWindow()->ParentWindow;
	const ImRect bb = parent_window->DC.LastItemRect;
	const ImGuiStyle& style = GetStyle();

	EndChildFrame();

	// Redeclare item size so that it includes the label (we have stored the full size in LastItemRect)
	// We call SameLine() to restore DC.CurrentLine* data
	SameLine();
	parent_window->DC.CursorPos = bb.Min;
	ItemSize( bb, style.FramePadding.y );
	EndGroup();
}

bool ImGui::ListBox( const char* label, int* current_item, const char* const items[], int items_count, int height_items )
{
	const bool value_changed = ListBox( label, current_item, Items_ArrayGetter, ( void* )items, items_count, height_items );
	return value_changed;
}

bool ImGui::ListBox( const char* label, int* current_item, bool ( *items_getter )( void*, int, const char** ), void* data, int items_count, int height_in_items )
{
	if( !ListBoxHeader( label, items_count, height_in_items ) )
		return false;

	// Assume all items have even height (= 1 line of text). If you need items of different or variable sizes you can create a custom version of ListBox() in your code without using the clipper.
	ImGuiContext& g = *GImGui;
	bool value_changed = false;
	ImGuiListClipper clipper( items_count, GetTextLineHeightWithSpacing() ); // We know exactly our line height here so we pass it as a minor optimization, but generally you don't need to.
	while( clipper.Step() )
		for( int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++ )
		{
			const bool item_selected = ( i == *current_item );
			const char* item_text;
			if( !items_getter( data, i, &item_text ) )
				item_text = SECURE("*Unknown item*");

			PushID( i );
			if( Selectable( item_text, item_selected ) )
			{
				*current_item = i;
				value_changed = true;
			}
			if( item_selected )
				SetItemDefaultFocus();
			PopID();
		}
	ListBoxFooter();
	if( value_changed )
		MarkItemEdited( g.CurrentWindow->DC.LastItemId );

	return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: PlotLines, PlotHistogram
//-------------------------------------------------------------------------
// - PlotEx() [Internal]
// - PlotLines()
// - PlotHistogram()
//-------------------------------------------------------------------------

int ImGui::PlotEx( ImGuiPlotType plot_type, const char* label, float ( *values_getter )( void* data, int idx ), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 frame_size )
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return -1;

	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID( label );

	const ImVec2 label_size = CalcTextSize( label, NULL, true );
	if( frame_size.x == 0.0f )
		frame_size.x = CalcItemWidth();
	if( frame_size.y == 0.0f )
		frame_size.y = label_size.y + ( style.FramePadding.y * 2 );

	const ImRect frame_bb( window->DC.CursorPos, window->DC.CursorPos + frame_size );
	const ImRect inner_bb( frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding );
	const ImRect total_bb( frame_bb.Min, frame_bb.Max + ImVec2( label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0 ) );
	ItemSize( total_bb, style.FramePadding.y );
	if( !ItemAdd( total_bb, 0, &frame_bb ) )
		return -1;
	const bool hovered = ItemHoverable( frame_bb, id );

	// Determine scale from values if not specified
	if( scale_min == FLT_MAX || scale_max == FLT_MAX )
	{
		float v_min = FLT_MAX;
		float v_max = -FLT_MAX;
		for( int i = 0; i < values_count; i++ )
		{
			const float v = values_getter( data, i );
			if( v != v ) // Ignore NaN values
				continue;
			v_min = ImMin( v_min, v );
			v_max = ImMax( v_max, v );
		}
		if( scale_min == FLT_MAX )
			scale_min = v_min;
		if( scale_max == FLT_MAX )
			scale_max = v_max;
	}

	RenderFrame( frame_bb.Min, frame_bb.Max, GetColorU32( ImGuiCol_FrameBg ), true, style.FrameRounding );

	const int values_count_min = ( plot_type == ImGuiPlotType_Lines ) ? 2 : 1;
	int idx_hovered = -1;
	if( values_count >= values_count_min )
	{
		int res_w = ImMin( ( int )frame_size.x, values_count ) + ( ( plot_type == ImGuiPlotType_Lines ) ? -1 : 0 );
		int item_count = values_count + ( ( plot_type == ImGuiPlotType_Lines ) ? -1 : 0 );

		// Tooltip on hover
		if( hovered && inner_bb.Contains( g.IO.MousePos ) )
		{
			const float t = ImClamp( ( g.IO.MousePos.x - inner_bb.Min.x ) / ( inner_bb.Max.x - inner_bb.Min.x ), 0.0f, 0.9999f );
			const int v_idx = ( int )( t * item_count );
			IM_ASSERT( v_idx >= 0 && v_idx < values_count );

			const float v0 = values_getter( data, ( v_idx + values_offset ) % values_count );
			const float v1 = values_getter( data, ( v_idx + 1 + values_offset ) % values_count );
			if( plot_type == ImGuiPlotType_Lines )
				SetTooltip( SECURE("%d: %8.4g\n%d: %8.4g"), v_idx, v0, v_idx + 1, v1 );
			else if( plot_type == ImGuiPlotType_Histogram )
				SetTooltip( SECURE("%d: %8.4g"), v_idx, v0 );
			idx_hovered = v_idx;
		}

		const float t_step = 1.0f / ( float )res_w;
		const float inv_scale = ( scale_min == scale_max ) ? 0.0f : ( 1.0f / ( scale_max - scale_min ) );

		float v0 = values_getter( data, ( 0 + values_offset ) % values_count );
		float t0 = 0.0f;
		ImVec2 tp0 = ImVec2( t0, 1.0f - ImSaturate( ( v0 - scale_min ) * inv_scale ) );                       // Point in the normalized space of our target rectangle
		float histogram_zero_line_t = ( scale_min * scale_max < 0.0f ) ? ( -scale_min * inv_scale ) : ( scale_min < 0.0f ? 0.0f : 1.0f );   // Where does the zero line stands

		const ImU32 col_base = GetColorU32( ( plot_type == ImGuiPlotType_Lines ) ? ImGuiCol_PlotLines : ImGuiCol_PlotHistogram );
		const ImU32 col_hovered = GetColorU32( ( plot_type == ImGuiPlotType_Lines ) ? ImGuiCol_PlotLinesHovered : ImGuiCol_PlotHistogramHovered );

		for( int n = 0; n < res_w; n++ )
		{
			const float t1 = t0 + t_step;
			const int v1_idx = ( int )( t0 * item_count + 0.5f );
			IM_ASSERT( v1_idx >= 0 && v1_idx < values_count );
			const float v1 = values_getter( data, ( v1_idx + values_offset + 1 ) % values_count );
			const ImVec2 tp1 = ImVec2( t1, 1.0f - ImSaturate( ( v1 - scale_min ) * inv_scale ) );

			// NB: Draw calls are merged together by the DrawList system. Still, we should render our batch are lower level to save a bit of CPU.
			ImVec2 pos0 = ImLerp( inner_bb.Min, inner_bb.Max, tp0 );
			ImVec2 pos1 = ImLerp( inner_bb.Min, inner_bb.Max, ( plot_type == ImGuiPlotType_Lines ) ? tp1 : ImVec2( tp1.x, histogram_zero_line_t ) );
			if( plot_type == ImGuiPlotType_Lines )
			{
				window->DrawList->AddLine( pos0, pos1, idx_hovered == v1_idx ? col_hovered : col_base );
			}
			else if( plot_type == ImGuiPlotType_Histogram )
			{
				if( pos1.x >= pos0.x + 2.0f )
					pos1.x -= 1.0f;
				window->DrawList->AddRectFilled( pos0, pos1, idx_hovered == v1_idx ? col_hovered : col_base );
			}

			t0 = t1;
			tp0 = tp1;
		}
	}

	// Text overlay
	if( overlay_text )
		RenderTextClipped( ImVec2( frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y ), frame_bb.Max, overlay_text, NULL, NULL, ImVec2( 0.5f, 0.0f ) );

	if( label_size.x > 0.0f )
		RenderText( ImVec2( frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y ), label );

	// Return hovered index or -1 if none are hovered.
	// This is currently not exposed in the public API because we need a larger redesign of the whole thing, but in the short-term we are making it available in PlotEx().
	return idx_hovered;
}

struct ImGuiPlotArrayGetterData
{
	const float* Values;
	int Stride;

	ImGuiPlotArrayGetterData( const float* values, int stride )
	{
		Values = values; Stride = stride;
	}
};

static float Plot_ArrayGetter( void* data, int idx )
{
	ImGuiPlotArrayGetterData* plot_data = ( ImGuiPlotArrayGetterData* )data;
	const float v = *( const float* )( const void* )( ( const unsigned char* )plot_data->Values + ( size_t )idx * plot_data->Stride );
	return v;
}

void ImGui::PlotLines( const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride )
{
	ImGuiPlotArrayGetterData data( values, stride );
	PlotEx( ImGuiPlotType_Lines, label, &Plot_ArrayGetter, ( void* )&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size );
}

void ImGui::PlotLines( const char* label, float ( *values_getter )( void* data, int idx ), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size )
{
	PlotEx( ImGuiPlotType_Lines, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size );
}

void ImGui::PlotHistogram( const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride )
{
	ImGuiPlotArrayGetterData data( values, stride );
	PlotEx( ImGuiPlotType_Histogram, label, &Plot_ArrayGetter, ( void* )&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size );
}

void ImGui::PlotHistogram( const char* label, float ( *values_getter )( void* data, int idx ), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size )
{
	PlotEx( ImGuiPlotType_Histogram, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size );
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Value helpers
// Those is not very useful, legacy API.
//-------------------------------------------------------------------------
// - Value()
//-------------------------------------------------------------------------

void ImGui::Value( const char* prefix, bool b )
{
	Text( SECURE("%s: %s"), prefix, ( b ? SECURE("true") : SECURE("false") ) );
}

void ImGui::Value( const char* prefix, int v )
{
	Text( SECURE("%s: %d"), prefix, v );
}

void ImGui::Value( const char* prefix, unsigned int v )
{
	Text( SECURE("%s: %d"), prefix, v );
}

void ImGui::Value( const char* prefix, float v, const char* float_format )
{
	if( float_format )
	{
		char fmt[ 64 ];
		ImFormatString( fmt, IM_ARRAYSIZE( fmt ), SECURE("%%s: %s"), float_format );
		Text( fmt, prefix, v );
	}
	else
	{
		Text( SECURE("%s: %.3f"), prefix, v );
	}
}

//-------------------------------------------------------------------------
// [SECTION] MenuItem, BeginMenu, EndMenu, etc.
//-------------------------------------------------------------------------
// - ImGuiMenuColumns [Internal]
// - BeginMenuBar()
// - EndMenuBar()
// - BeginMainMenuBar()
// - EndMainMenuBar()
// - BeginMenu()
// - EndMenu()
// - MenuItem()
//-------------------------------------------------------------------------

// Helpers for internal use
ImGuiMenuColumns::ImGuiMenuColumns()
{
	Spacing = Width = NextWidth = 0.0f;
	memset( Pos, 0, sizeof( Pos ) );
	memset( NextWidths, 0, sizeof( NextWidths ) );
}

void ImGuiMenuColumns::Update( int count, float spacing, bool clear )
{
	IM_ASSERT( count == IM_ARRAYSIZE( Pos ) );
	IM_UNUSED( count );
	Width = NextWidth = 0.0f;
	Spacing = spacing;
	if( clear )
		memset( NextWidths, 0, sizeof( NextWidths ) );
	for( int i = 0; i < IM_ARRAYSIZE( Pos ); i++ )
	{
		if( i > 0 && NextWidths[ i ] > 0.0f )
			Width += Spacing;
		Pos[ i ] = IM_FLOOR( Width );
		Width += NextWidths[ i ];
		NextWidths[ i ] = 0.0f;
	}
}

float ImGuiMenuColumns::DeclColumns( float w0, float w1, float w2 ) // not using va_arg because they promote float to double
{
	NextWidth = 0.0f;
	NextWidths[ 0 ] = ImMax( NextWidths[ 0 ], w0 );
	NextWidths[ 1 ] = ImMax( NextWidths[ 1 ], w1 );
	NextWidths[ 2 ] = ImMax( NextWidths[ 2 ], w2 );
	for( int i = 0; i < IM_ARRAYSIZE( Pos ); i++ )
		NextWidth += NextWidths[ i ] + ( ( i > 0 && NextWidths[ i ] > 0.0f ) ? Spacing : 0.0f );
	return ImMax( Width, NextWidth );
}

float ImGuiMenuColumns::CalcExtraSpace( float avail_w ) const
{
	return ImMax( 0.0f, avail_w - Width );
}

// FIXME: Provided a rectangle perhaps e.g. a BeginMenuBarEx() could be used anywhere..
// Currently the main responsibility of this function being to setup clip-rect + horizontal layout + menu navigation layer.
// Ideally we also want this to be responsible for claiming space out of the main window scrolling rectangle, in which case ImGuiWindowFlags_MenuBar will become unnecessary.
// Then later the same system could be used for multiple menu-bars, scrollbars, side-bars.
bool ImGui::BeginMenuBar()
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;
	if( !( window->Flags & ImGuiWindowFlags_MenuBar ) )
		return false;

	IM_ASSERT( !window->DC.MenuBarAppending );
	BeginGroup(); // Backup position on layer 0 // FIXME: Misleading to use a group for that backup/restore
	PushID( SECURE("##menubar") );

	// We don't clip with current window clipping rectangle as it is already set to the area below. However we clip with window full rect.
	// We remove 1 worth of rounding to Max.x to that text in long menus and small windows don't tend to display over the lower-right rounded area, which looks particularly glitchy.
	ImRect bar_rect = window->MenuBarRect();
	ImRect clip_rect( IM_ROUND( bar_rect.Min.x + window->WindowBorderSize ), IM_ROUND( bar_rect.Min.y + window->WindowBorderSize ), IM_ROUND( ImMax( bar_rect.Min.x, bar_rect.Max.x - ImMax( window->WindowRounding, window->WindowBorderSize ) ) ), IM_ROUND( bar_rect.Max.y ) );
	clip_rect.ClipWith( window->OuterRectClipped );
	PushClipRect( clip_rect.Min, clip_rect.Max, false );

	window->DC.CursorPos = ImVec2( bar_rect.Min.x + window->DC.MenuBarOffset.x, bar_rect.Min.y + window->DC.MenuBarOffset.y );
	window->DC.LayoutType = ImGuiLayoutType_Horizontal;
	window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
	window->DC.NavLayerCurrentMask = ( 1 << ImGuiNavLayer_Menu );
	window->DC.MenuBarAppending = true;
	AlignTextToFramePadding();
	return true;
}

void ImGui::EndMenuBar()
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return;
	ImGuiContext& g = *GImGui;

	// Nav: When a move request within one of our child menu failed, capture the request to navigate among our siblings.
	if( NavMoveRequestButNoResultYet() && ( g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right ) && ( g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu ) )
	{
		ImGuiWindow* nav_earliest_child = g.NavWindow;
		while( nav_earliest_child->ParentWindow && ( nav_earliest_child->ParentWindow->Flags & ImGuiWindowFlags_ChildMenu ) )
			nav_earliest_child = nav_earliest_child->ParentWindow;
		if( nav_earliest_child->ParentWindow == window && nav_earliest_child->DC.ParentLayoutType == ImGuiLayoutType_Horizontal && g.NavMoveRequestForward == ImGuiNavForward_None )
		{
			// To do so we claim focus back, restore NavId and then process the movement request for yet another frame.
			// This involve a one-frame delay which isn't very problematic in this situation. We could remove it by scoring in advance for multiple window (probably not worth the hassle/cost)
			const ImGuiNavLayer layer = ImGuiNavLayer_Menu;
			IM_ASSERT( window->DC.NavLayerActiveMaskNext & ( 1 << layer ) ); // Sanity check
			FocusWindow( window );
			SetNavIDWithRectRel( window->NavLastIds[ layer ], layer, 0, window->NavRectRel[ layer ] );
			g.NavLayer = layer;
			g.NavDisableHighlight = true; // Hide highlight for the current frame so we don't see the intermediary selection.
			g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;
			NavMoveRequestCancel();
		}
	}

	IM_ASSERT( window->Flags & ImGuiWindowFlags_MenuBar );
	IM_ASSERT( window->DC.MenuBarAppending );
	PopClipRect();
	PopID();
	window->DC.MenuBarOffset.x = window->DC.CursorPos.x - window->MenuBarRect().Min.x; // Save horizontal position so next append can reuse it. This is kinda equivalent to a per-layer CursorPos.
	window->DC.GroupStack.back().EmitItem = false;
	EndGroup(); // Restore position on layer 0
	window->DC.LayoutType = ImGuiLayoutType_Vertical;
	window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
	window->DC.NavLayerCurrentMask = ( 1 << ImGuiNavLayer_Main );
	window->DC.MenuBarAppending = false;
}

// For the main menu bar, which cannot be moved, we honor g.Style.DisplaySafeAreaPadding to ensure text can be visible on a TV set.
bool ImGui::BeginMainMenuBar()
{
	ImGuiContext& g = *GImGui;
	g.NextWindowData.MenuBarOffsetMinVal = ImVec2( g.Style.DisplaySafeAreaPadding.x, ImMax( g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0.0f ) );
	SetNextWindowPos( ImVec2( 0.0f, 0.0f ) );
	SetNextWindowSize( ImVec2( g.IO.DisplaySize.x, g.NextWindowData.MenuBarOffsetMinVal.y + g.FontBaseSize + g.Style.FramePadding.y ) );
	PushStyleVar( ImGuiStyleVar_WindowRounding, 0.0f );
	PushStyleVar( ImGuiStyleVar_WindowMinSize, ImVec2( 0, 0 ) );
	ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_MenuBar;
	bool is_open = Begin( SECURE("##MainMenuBar"), NULL, window_flags ) && BeginMenuBar();
	PopStyleVar( 2 );
	g.NextWindowData.MenuBarOffsetMinVal = ImVec2( 0.0f, 0.0f );
	if( !is_open )
	{
		End();
		return false;
	}
	return true; //-V1020
}

void ImGui::EndMainMenuBar()
{
	EndMenuBar();

	// When the user has left the menu layer (typically: closed menus through activation of an item), we restore focus to the previous window
	// FIXME: With this strategy we won't be able to restore a NULL focus.
	ImGuiContext& g = *GImGui;
	if( g.CurrentWindow == g.NavWindow && g.NavLayer == ImGuiNavLayer_Main && !g.NavAnyRequest )
		FocusTopMostWindowUnderOne( g.NavWindow, NULL );

	End();
}

bool ImGui::BeginMenu( const char* label, bool enabled )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID( label );
	bool menu_is_open = IsPopupOpen( id );

	// Sub-menus are ChildWindow so that mouse can be hovering across them (otherwise top-most popup menu would steal focus and not allow hovering on parent menu)
	ImGuiWindowFlags flags = ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoNavFocus;
	if( window->Flags & ( ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu ) )
		flags |= ImGuiWindowFlags_ChildWindow;

	// If a menu with same the ID was already submitted, we will append to it, matching the behavior of Begin().
	// We are relying on a O(N) search - so O(N log N) over the frame - which seems like the most efficient for the expected small amount of BeginMenu() calls per frame.
	// If somehow this is ever becoming a problem we can switch to use e.g. a ImGuiStorager mapping key to last frame used.
	if( g.MenusIdSubmittedThisFrame.contains( id ) )
	{
		if( menu_is_open )
			menu_is_open = BeginPopupEx( id, flags ); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
		else
			g.NextWindowData.ClearFlags();          // we behave like Begin() and need to consume those values
		return menu_is_open;
	}

	// Tag menu as used. Next time BeginMenu() with same ID is called it will append to existing menu
	g.MenusIdSubmittedThisFrame.push_back( id );

	ImVec2 label_size = CalcTextSize( label, NULL, true );
	bool pressed;
	bool menuset_is_open = !( window->Flags & ImGuiWindowFlags_Popup ) && ( g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[ g.BeginPopupStack.Size ].OpenParentId == window->IDStack.back() );
	ImGuiWindow* backed_nav_window = g.NavWindow;
	if( menuset_is_open )
		g.NavWindow = window;  // Odd hack to allow hovering across menus of a same menu-set (otherwise we wouldn't be able to hover parent)

// The reference position stored in popup_pos will be used by Begin() to find a suitable position for the child menu,
// However the final position is going to be different! It is chosen by FindBestWindowPosForPopup().
// e.g. Menus tend to overlap each other horizontally to amplify relative Z-ordering.
	ImVec2 popup_pos, pos = window->DC.CursorPos;
	if( window->DC.LayoutType == ImGuiLayoutType_Horizontal )
	{
		// Menu inside an horizontal menu bar
		// Selectable extend their highlight by half ItemSpacing in each direction.
		// For ChildMenu, the popup position will be overwritten by the call to FindBestWindowPosForPopup() in Begin()
		popup_pos = ImVec2( pos.x - 1.0f - IM_FLOOR( style.ItemSpacing.x * 0.5f ), pos.y - style.FramePadding.y + window->MenuBarHeight() );
		window->DC.CursorPos.x += IM_FLOOR( style.ItemSpacing.x * 0.5f );
		PushStyleVar( ImGuiStyleVar_ItemSpacing, ImVec2( style.ItemSpacing.x * 2.0f, style.ItemSpacing.y ) );
		float w = label_size.x;
		pressed = Selectable( label, menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_SelectOnClick | ImGuiSelectableFlags_DontClosePopups | ( !enabled ? ImGuiSelectableFlags_Disabled : 0 ), ImVec2( w, 0.0f ) );
		PopStyleVar();
		window->DC.CursorPos.x += IM_FLOOR( style.ItemSpacing.x * ( -1.0f + 0.5f ) ); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
	}
	else
	{
		// Menu inside a menu
		// (In a typical menu window where all items are BeginMenu() or MenuItem() calls, extra_w will always be 0.0f.
		//  Only when they are other items sticking out we're going to add spacing, yet only register minimum width into the layout system.
		popup_pos = ImVec2( pos.x, pos.y - style.WindowPadding.y );
		float min_w = window->DC.MenuColumns.DeclColumns( label_size.x, 0.0f, IM_FLOOR( g.FontSize * 1.20f ) ); // Feedback to next frame
		float extra_w = ImMax( 0.0f, GetContentRegionAvail().x - min_w );
		pressed = Selectable( label, menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_SelectOnClick | ImGuiSelectableFlags_DontClosePopups | ImGuiSelectableFlags_SpanAvailWidth | ( !enabled ? ImGuiSelectableFlags_Disabled : 0 ), ImVec2( min_w, 0.0f ) );
		ImU32 text_col = GetColorU32( enabled ? ImGuiCol_Text : ImGuiCol_TextDisabled );
		RenderArrow( window->DrawList, pos + ImVec2( window->DC.MenuColumns.Pos[ 2 ] + extra_w + g.FontSize * 0.30f, 0.0f ), text_col, ImGuiDir_Right );
	}

	const bool hovered = enabled && ItemHoverable( window->DC.LastItemRect, id );
	if( menuset_is_open )
		g.NavWindow = backed_nav_window;

	bool want_open = false;
	bool want_close = false;
	if( window->DC.LayoutType == ImGuiLayoutType_Vertical ) // (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))
	{
		// Close menu when not hovering it anymore unless we are moving roughly in the direction of the menu
		// Implement http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown to avoid using timers, so menus feels more reactive.
		bool moving_toward_other_child_menu = false;

		ImGuiWindow* child_menu_window = ( g.BeginPopupStack.Size < g.OpenPopupStack.Size&& g.OpenPopupStack[ g.BeginPopupStack.Size ].SourceWindow == window ) ? g.OpenPopupStack[ g.BeginPopupStack.Size ].Window : NULL;
		if( g.HoveredWindow == window && child_menu_window != NULL && !( window->Flags & ImGuiWindowFlags_MenuBar ) )
		{
			// FIXME-DPI: Values should be derived from a master "scale" factor.
			ImRect next_window_rect = child_menu_window->Rect();
			ImVec2 ta = g.IO.MousePos - g.IO.MouseDelta;
			ImVec2 tb = ( window->Pos.x < child_menu_window->Pos.x ) ? next_window_rect.GetTL() : next_window_rect.GetTR();
			ImVec2 tc = ( window->Pos.x < child_menu_window->Pos.x ) ? next_window_rect.GetBL() : next_window_rect.GetBR();
			float extra = ImClamp( ImFabs( ta.x - tb.x ) * 0.30f, 5.0f, 30.0f );    // add a bit of extra slack.
			ta.x += ( window->Pos.x < child_menu_window->Pos.x ) ? -0.5f : +0.5f; // to avoid numerical issues
			tb.y = ta.y + ImMax( ( tb.y - extra ) - ta.y, -100.0f );                // triangle is maximum 200 high to limit the slope and the bias toward large sub-menus // FIXME: Multiply by fb_scale?
			tc.y = ta.y + ImMin( ( tc.y + extra ) - ta.y, +100.0f );
			moving_toward_other_child_menu = ImTriangleContainsPoint( ta, tb, tc, g.IO.MousePos );
			//GetForegroundDrawList()->AddTriangleFilled(ta, tb, tc, moving_within_opened_triangle ? IM_COL32(0,128,0,128) : IM_COL32(128,0,0,128)); // [DEBUG]
		}
		if( menu_is_open && !hovered && g.HoveredWindow == window && g.HoveredIdPreviousFrame != 0 && g.HoveredIdPreviousFrame != id && !moving_toward_other_child_menu )
			want_close = true;

		if( !menu_is_open && hovered && pressed ) // Click to open
			want_open = true;
		else if( !menu_is_open && hovered && !moving_toward_other_child_menu ) // Hover to open
			want_open = true;

		if( g.NavActivateId == id )
		{
			want_close = menu_is_open;
			want_open = !menu_is_open;
		}
		if( g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right ) // Nav-Right to open
		{
			want_open = true;
			NavMoveRequestCancel();
		}
	}
	else
	{
		// Menu bar
		if( menu_is_open && pressed && menuset_is_open ) // Click an open menu again to close it
		{
			want_close = true;
			want_open = menu_is_open = false;
		}
		else if( pressed || ( hovered && menuset_is_open && !menu_is_open ) ) // First click to open, then hover to open others
		{
			want_open = true;
		}
		else if( g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Down ) // Nav-Down to open
		{
			want_open = true;
			NavMoveRequestCancel();
		}
	}

	if( !enabled ) // explicitly close if an open menu becomes disabled, facilitate users code a lot in pattern such as 'if (BeginMenu("options", has_object)) { ..use object.. }'
		want_close = true;
	if( want_close && IsPopupOpen( id ) )
		ClosePopupToLevel( g.BeginPopupStack.Size, true );

	IMGUI_TEST_ENGINE_ITEM_INFO( id, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Openable | ( menu_is_open ? ImGuiItemStatusFlags_Opened : 0 ) );

	if( !menu_is_open && want_open && g.OpenPopupStack.Size > g.BeginPopupStack.Size )
	{
		// Don't recycle same menu level in the same frame, first close the other menu and yield for a frame.
		OpenPopup( label );
		return false;
	}

	menu_is_open |= want_open;
	if( want_open )
		OpenPopup( label );

	if( menu_is_open )
	{
		SetNextWindowPos( popup_pos, ImGuiCond_Always );
		menu_is_open = BeginPopupEx( id, flags ); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
	}
	else
	{
		g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
	}

	return menu_is_open;
}

void ImGui::EndMenu()
{
	// Nav: When a left move request _within our child menu_ failed, close ourselves (the _parent_ menu).
	// A menu doesn't close itself because EndMenuBar() wants the catch the last Left<>Right inputs.
	// However, it means that with the current code, a BeginMenu() from outside another menu or a menu-bar won't be closable with the Left direction.
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	if( g.NavWindow && g.NavWindow->ParentWindow == window && g.NavMoveDir == ImGuiDir_Left && NavMoveRequestButNoResultYet() && window->DC.LayoutType == ImGuiLayoutType_Vertical )
	{
		ClosePopupToLevel( g.BeginPopupStack.Size, true );
		NavMoveRequestCancel();
	}

	EndPopup();
}

bool ImGui::MenuItem( const char* label, const char* shortcut, bool selected, bool enabled )
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems )
		return false;

	ImGuiContext& g = *GImGui;
	ImGuiStyle& style = g.Style;
	ImVec2 pos = window->DC.CursorPos;
	ImVec2 label_size = CalcTextSize( label, NULL, true );

	// We've been using the equivalent of ImGuiSelectableFlags_SetNavIdOnHover on all Selectable() since early Nav system days (commit 43ee5d73),
	// but I am unsure whether this should be kept at all. For now moved it to be an opt-in feature used by menus only.
	ImGuiSelectableFlags flags = ImGuiSelectableFlags_SelectOnRelease | ImGuiSelectableFlags_SetNavIdOnHover | ( enabled ? 0 : ImGuiSelectableFlags_Disabled );
	bool pressed;
	if( window->DC.LayoutType == ImGuiLayoutType_Horizontal )
	{
		// Mimic the exact layout spacing of BeginMenu() to allow MenuItem() inside a menu bar, which is a little misleading but may be useful
		// Note that in this situation we render neither the shortcut neither the selected tick mark
		float w = label_size.x;
		window->DC.CursorPos.x += IM_FLOOR( style.ItemSpacing.x * 0.5f );
		PushStyleVar( ImGuiStyleVar_ItemSpacing, ImVec2( style.ItemSpacing.x * 2.0f, style.ItemSpacing.y ) );
		pressed = Selectable( label, false, flags, ImVec2( w, 0.0f ) );
		PopStyleVar();
		window->DC.CursorPos.x += IM_FLOOR( style.ItemSpacing.x * ( -1.0f + 0.5f ) ); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
	}
	else
	{
		// Menu item inside a vertical menu
		// (In a typical menu window where all items are BeginMenu() or MenuItem() calls, extra_w will always be 0.0f.
		//  Only when they are other items sticking out we're going to add spacing, yet only register minimum width into the layout system.
		float shortcut_w = shortcut ? CalcTextSize( shortcut, NULL ).x : 0.0f;
		float min_w = window->DC.MenuColumns.DeclColumns( label_size.x, shortcut_w, IM_FLOOR( g.FontSize * 1.20f ) ); // Feedback for next frame
		float extra_w = ImMax( 0.0f, GetContentRegionAvail().x - min_w );
		pressed = Selectable( label, false, flags | ImGuiSelectableFlags_SpanAvailWidth, ImVec2( min_w, 0.0f ) );
		if( shortcut_w > 0.0f )
		{
			PushStyleColor( ImGuiCol_Text, g.Style.Colors[ ImGuiCol_TextDisabled ] );
			RenderText( pos + ImVec2( window->DC.MenuColumns.Pos[ 1 ] + extra_w, 0.0f ), shortcut, NULL, false );
			PopStyleColor();
		}
		if( selected )
			RenderCheckMark( window->DrawList, pos + ImVec2( window->DC.MenuColumns.Pos[ 2 ] + extra_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f ), GetColorU32( enabled ? ImGuiCol_Text : ImGuiCol_TextDisabled ), g.FontSize * 0.866f );
	}

	IMGUI_TEST_ENGINE_ITEM_INFO( window->DC.LastItemId, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Checkable | ( selected ? ImGuiItemStatusFlags_Checked : 0 ) );
	return pressed;
}

bool ImGui::MenuItem( const char* label, const char* shortcut, bool* p_selected, bool enabled )
{
	if( MenuItem( label, shortcut, p_selected ? *p_selected : false, enabled ) )
	{
		if( p_selected )
			*p_selected = !*p_selected;
		return true;
	}
	return false;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.
//-------------------------------------------------------------------------
// - BeginTabBar()
// - BeginTabBarEx() [Internal]
// - EndTabBar()
// - TabBarLayout() [Internal]
// - TabBarCalcTabID() [Internal]
// - TabBarCalcMaxTabWidth() [Internal]
// - TabBarFindTabById() [Internal]
// - TabBarRemoveTab() [Internal]
// - TabBarCloseTab() [Internal]
// - TabBarScrollClamp()v
// - TabBarScrollToTab() [Internal]
// - TabBarQueueChangeTabOrder() [Internal]
// - TabBarScrollingButtons() [Internal]
// - TabBarTabListPopupButton() [Internal]
//-------------------------------------------------------------------------

namespace ImGui
{
static void             TabBarLayout( ImGuiTabBar* tab_bar );
static ImU32            TabBarCalcTabID( ImGuiTabBar* tab_bar, const char* label );
static float            TabBarCalcMaxTabWidth();
static float            TabBarScrollClamp( ImGuiTabBar* tab_bar, float scrolling );
static void             TabBarScrollToTab( ImGuiTabBar* tab_bar, ImGuiTabItem* tab );
static ImGuiTabItem* TabBarScrollingButtons( ImGuiTabBar* tab_bar );
static ImGuiTabItem* TabBarTabListPopupButton( ImGuiTabBar* tab_bar );
}

ImGuiTabBar::ImGuiTabBar()
{
	ID = 0;
	SelectedTabId = NextSelectedTabId = VisibleTabId = 0;
	CurrFrameVisible = PrevFrameVisible = -1;
	LastTabContentHeight = 0.0f;
	OffsetMax = OffsetMaxIdeal = OffsetNextTab = 0.0f;
	ScrollingAnim = ScrollingTarget = ScrollingTargetDistToVisibility = ScrollingSpeed = 0.0f;
	Flags = ImGuiTabBarFlags_None;
	ReorderRequestTabId = 0;
	ReorderRequestDir = 0;
	WantLayout = VisibleTabWasSubmitted = false;
	LastTabItemIdx = -1;
}

static int IMGUI_CDECL TabItemComparerByVisibleOffset( const void* lhs, const void* rhs )
{
	const ImGuiTabItem* a = ( const ImGuiTabItem* )lhs;
	const ImGuiTabItem* b = ( const ImGuiTabItem* )rhs;
	return ( int )( a->Offset - b->Offset );
}

static ImGuiTabBar* GetTabBarFromTabBarRef( const ImGuiPtrOrIndex& ref )
{
	ImGuiContext& g = *GImGui;
	return ref.Ptr ? ( ImGuiTabBar* )ref.Ptr : g.TabBars.GetByIndex( ref.Index );
}

static ImGuiPtrOrIndex GetTabBarRefFromTabBar( ImGuiTabBar* tab_bar )
{
	ImGuiContext& g = *GImGui;
	if( g.TabBars.Contains( tab_bar ) )
		return ImGuiPtrOrIndex( g.TabBars.GetIndex( tab_bar ) );
	return ImGuiPtrOrIndex( tab_bar );
}

bool    ImGui::BeginTabBar( const char* str_id, ImGuiTabBarFlags flags )
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	if( window->SkipItems )
		return false;

	ImGuiID id = window->GetID( str_id );
	ImGuiTabBar* tab_bar = g.TabBars.GetOrAddByKey( id );
	ImRect tab_bar_bb = ImRect( window->DC.CursorPos.x, window->DC.CursorPos.y, window->WorkRect.Max.x, window->DC.CursorPos.y + g.FontSize + g.Style.FramePadding.y * 2 );
	tab_bar->ID = id;
	return BeginTabBarEx( tab_bar, tab_bar_bb, flags | ImGuiTabBarFlags_IsFocused );
}

bool    ImGui::BeginTabBarEx( ImGuiTabBar* tab_bar, const ImRect& tab_bar_bb, ImGuiTabBarFlags flags )
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	if( window->SkipItems )
		return false;

	if( ( flags & ImGuiTabBarFlags_DockNode ) == 0 )
		PushOverrideID( tab_bar->ID );

	// Add to stack
	g.CurrentTabBarStack.push_back( GetTabBarRefFromTabBar( tab_bar ) );
	g.CurrentTabBar = tab_bar;

	if( tab_bar->CurrFrameVisible == g.FrameCount )
	{
		//IMGUI_DEBUG_LOG("BeginTabBarEx already called this frame\n", g.FrameCount);
		IM_ASSERT( 0 );
		return true;
	}

	// When toggling back from ordered to manually-reorderable, shuffle tabs to enforce the last visible order.
	// Otherwise, the most recently inserted tabs would move at the end of visible list which can be a little too confusing or magic for the user.
	if( ( flags & ImGuiTabBarFlags_Reorderable ) && !( tab_bar->Flags & ImGuiTabBarFlags_Reorderable ) && tab_bar->Tabs.Size > 1 && tab_bar->PrevFrameVisible != -1 )
		ImQsort( tab_bar->Tabs.Data, tab_bar->Tabs.Size, sizeof( ImGuiTabItem ), TabItemComparerByVisibleOffset );

	// Flags
	if( ( flags & ImGuiTabBarFlags_FittingPolicyMask_ ) == 0 )
		flags |= ImGuiTabBarFlags_FittingPolicyDefault_;

	tab_bar->Flags = flags;
	tab_bar->BarRect = tab_bar_bb;
	tab_bar->WantLayout = true; // Layout will be done on the first call to ItemTab()
	tab_bar->PrevFrameVisible = tab_bar->CurrFrameVisible;
	tab_bar->CurrFrameVisible = g.FrameCount;
	tab_bar->FramePadding = g.Style.FramePadding;

	// Layout
	ItemSize( ImVec2( tab_bar->OffsetMaxIdeal, tab_bar->BarRect.GetHeight() ), tab_bar->FramePadding.y );
	window->DC.CursorPos.x = tab_bar->BarRect.Min.x;

	// Draw separator
	const ImU32 col = GetColorU32( ( flags & ImGuiTabBarFlags_IsFocused ) ? ImGuiCol_TabActive : ImGuiCol_TabUnfocusedActive );
	const float y = tab_bar->BarRect.Max.y - 1.0f;
	{
		const float separator_min_x = tab_bar->BarRect.Min.x - IM_FLOOR( window->WindowPadding.x * 0.5f );
		const float separator_max_x = tab_bar->BarRect.Max.x + IM_FLOOR( window->WindowPadding.x * 0.5f );
		window->DrawList->AddLine( ImVec2( separator_min_x, y ), ImVec2( separator_max_x, y ), col, 1.0f );
	}
	return true;
}

void    ImGui::EndTabBar()
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	if( window->SkipItems )
		return;

	ImGuiTabBar* tab_bar = g.CurrentTabBar;
	if( tab_bar == NULL )
	{
		IM_ASSERT_USER_ERROR( tab_bar != NULL, "Mismatched BeginTabBar()/EndTabBar()!" );
		return;
	}
	if( tab_bar->WantLayout )
		TabBarLayout( tab_bar );

	// Restore the last visible height if no tab is visible, this reduce vertical flicker/movement when a tabs gets removed without calling SetTabItemClosed().
	const bool tab_bar_appearing = ( tab_bar->PrevFrameVisible + 1 < g.FrameCount );
	if( tab_bar->VisibleTabWasSubmitted || tab_bar->VisibleTabId == 0 || tab_bar_appearing )
		tab_bar->LastTabContentHeight = ImMax( window->DC.CursorPos.y - tab_bar->BarRect.Max.y, 0.0f );
	else
		window->DC.CursorPos.y = tab_bar->BarRect.Max.y + tab_bar->LastTabContentHeight;

	if( ( tab_bar->Flags & ImGuiTabBarFlags_DockNode ) == 0 )
		PopID();

	g.CurrentTabBarStack.pop_back();
	g.CurrentTabBar = g.CurrentTabBarStack.empty() ? NULL : GetTabBarFromTabBarRef( g.CurrentTabBarStack.back() );
}

// This is called only once a frame before by the first call to ItemTab()
// The reason we're not calling it in BeginTabBar() is to leave a chance to the user to call the SetTabItemClosed() functions.
static void ImGui::TabBarLayout( ImGuiTabBar* tab_bar )
{
	ImGuiContext& g = *GImGui;
	tab_bar->WantLayout = false;

	// Garbage collect
	int tab_dst_n = 0;
	for( int tab_src_n = 0; tab_src_n < tab_bar->Tabs.Size; tab_src_n++ )
	{
		ImGuiTabItem* tab = &tab_bar->Tabs[ tab_src_n ];
		if( tab->LastFrameVisible < tab_bar->PrevFrameVisible )
		{
			if( tab->ID == tab_bar->SelectedTabId )
				tab_bar->SelectedTabId = 0;
			continue;
		}
		if( tab_dst_n != tab_src_n )
			tab_bar->Tabs[ tab_dst_n ] = tab_bar->Tabs[ tab_src_n ];
		tab_dst_n++;
	}
	if( tab_bar->Tabs.Size != tab_dst_n )
		tab_bar->Tabs.resize( tab_dst_n );

	// Setup next selected tab
	ImGuiID scroll_track_selected_tab_id = 0;
	if( tab_bar->NextSelectedTabId )
	{
		tab_bar->SelectedTabId = tab_bar->NextSelectedTabId;
		tab_bar->NextSelectedTabId = 0;
		scroll_track_selected_tab_id = tab_bar->SelectedTabId;
	}

	// Process order change request (we could probably process it when requested but it's just saner to do it in a single spot).
	if( tab_bar->ReorderRequestTabId != 0 )
	{
		if( ImGuiTabItem* tab1 = TabBarFindTabByID( tab_bar, tab_bar->ReorderRequestTabId ) )
		{
			//IM_ASSERT(tab_bar->Flags & ImGuiTabBarFlags_Reorderable); // <- this may happen when using debug tools
			int tab2_order = tab_bar->GetTabOrder( tab1 ) + tab_bar->ReorderRequestDir;
			if( tab2_order >= 0 && tab2_order < tab_bar->Tabs.Size )
			{
				ImGuiTabItem* tab2 = &tab_bar->Tabs[ tab2_order ];
				ImGuiTabItem item_tmp = *tab1;
				*tab1 = *tab2;
				*tab2 = item_tmp;
				if( tab2->ID == tab_bar->SelectedTabId )
					scroll_track_selected_tab_id = tab2->ID;
				tab1 = tab2 = NULL;
			}
			if( tab_bar->Flags & ImGuiTabBarFlags_SaveSettings )
				MarkIniSettingsDirty();
		}
		tab_bar->ReorderRequestTabId = 0;
	}

	// Tab List Popup (will alter tab_bar->BarRect and therefore the available width!)
	const bool tab_list_popup_button = ( tab_bar->Flags & ImGuiTabBarFlags_TabListPopupButton ) != 0;
	if( tab_list_popup_button )
		if( ImGuiTabItem* tab_to_select = TabBarTabListPopupButton( tab_bar ) ) // NB: Will alter BarRect.Max.x!
			scroll_track_selected_tab_id = tab_bar->SelectedTabId = tab_to_select->ID;

	// Compute ideal widths
	g.ShrinkWidthBuffer.resize( tab_bar->Tabs.Size );
	float width_total_contents = 0.0f;
	ImGuiTabItem* most_recently_selected_tab = NULL;
	bool found_selected_tab_id = false;
	for( int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++ )
	{
		ImGuiTabItem* tab = &tab_bar->Tabs[ tab_n ];
		IM_ASSERT( tab->LastFrameVisible >= tab_bar->PrevFrameVisible );

		if( most_recently_selected_tab == NULL || most_recently_selected_tab->LastFrameSelected < tab->LastFrameSelected )
			most_recently_selected_tab = tab;
		if( tab->ID == tab_bar->SelectedTabId )
			found_selected_tab_id = true;

		// Refresh tab width immediately, otherwise changes of style e.g. style.FramePadding.x would noticeably lag in the tab bar.
		// Additionally, when using TabBarAddTab() to manipulate tab bar order we occasionally insert new tabs that don't have a width yet,
		// and we cannot wait for the next BeginTabItem() call. We cannot compute this width within TabBarAddTab() because font size depends on the active window.
		const char* tab_name = tab_bar->GetTabName( tab );
		const bool has_close_button = ( tab->Flags & ImGuiTabItemFlags_NoCloseButton ) ? false : true;
		tab->ContentWidth = TabItemCalcSize( tab_name, has_close_button ).x;

		width_total_contents += ( tab_n > 0 ? g.Style.ItemInnerSpacing.x : 0.0f ) + tab->ContentWidth;

		// Store data so we can build an array sorted by width if we need to shrink tabs down
		g.ShrinkWidthBuffer[ tab_n ].Index = tab_n;
		g.ShrinkWidthBuffer[ tab_n ].Width = tab->ContentWidth;
	}

	// Compute width
	const float initial_offset_x = 0.0f; // g.Style.ItemInnerSpacing.x;
	const float width_avail = ImMax( tab_bar->BarRect.GetWidth() - initial_offset_x, 0.0f );
	float width_excess = ( width_avail < width_total_contents ) ? ( width_total_contents - width_avail ) : 0.0f;
	if( width_excess > 0.0f && ( tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyResizeDown ) )
	{
		// If we don't have enough room, resize down the largest tabs first
		ShrinkWidths( g.ShrinkWidthBuffer.Data, g.ShrinkWidthBuffer.Size, width_excess );
		for( int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++ )
			tab_bar->Tabs[ g.ShrinkWidthBuffer[ tab_n ].Index ].Width = IM_FLOOR( g.ShrinkWidthBuffer[ tab_n ].Width );
	}
	else
	{
		const float tab_max_width = TabBarCalcMaxTabWidth();
		for( int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++ )
		{
			ImGuiTabItem* tab = &tab_bar->Tabs[ tab_n ];
			tab->Width = ImMin( tab->ContentWidth, tab_max_width );
			IM_ASSERT( tab->Width > 0.0f );
		}
	}

	// Layout all active tabs
	float offset_x = initial_offset_x;
	float offset_x_ideal = offset_x;
	tab_bar->OffsetNextTab = offset_x; // This is used by non-reorderable tab bar where the submission order is always honored.
	for( int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++ )
	{
		ImGuiTabItem* tab = &tab_bar->Tabs[ tab_n ];
		tab->Offset = offset_x;
		if( scroll_track_selected_tab_id == 0 && g.NavJustMovedToId == tab->ID )
			scroll_track_selected_tab_id = tab->ID;
		offset_x += tab->Width + g.Style.ItemInnerSpacing.x;
		offset_x_ideal += tab->ContentWidth + g.Style.ItemInnerSpacing.x;
	}
	tab_bar->OffsetMax = ImMax( offset_x - g.Style.ItemInnerSpacing.x, 0.0f );
	tab_bar->OffsetMaxIdeal = ImMax( offset_x_ideal - g.Style.ItemInnerSpacing.x, 0.0f );

	// Horizontal scrolling buttons
	const bool scrolling_buttons = ( tab_bar->OffsetMax > tab_bar->BarRect.GetWidth() && tab_bar->Tabs.Size > 1 ) && !( tab_bar->Flags & ImGuiTabBarFlags_NoTabListScrollingButtons ) && ( tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyScroll );
	if( scrolling_buttons )
		if( ImGuiTabItem* tab_to_select = TabBarScrollingButtons( tab_bar ) ) // NB: Will alter BarRect.Max.x!
			scroll_track_selected_tab_id = tab_bar->SelectedTabId = tab_to_select->ID;

	// If we have lost the selected tab, select the next most recently active one
	if( found_selected_tab_id == false )
		tab_bar->SelectedTabId = 0;
	if( tab_bar->SelectedTabId == 0 && tab_bar->NextSelectedTabId == 0 && most_recently_selected_tab != NULL )
		scroll_track_selected_tab_id = tab_bar->SelectedTabId = most_recently_selected_tab->ID;

	// Lock in visible tab
	tab_bar->VisibleTabId = tab_bar->SelectedTabId;
	tab_bar->VisibleTabWasSubmitted = false;

	// Update scrolling
	if( scroll_track_selected_tab_id )
		if( ImGuiTabItem* scroll_track_selected_tab = TabBarFindTabByID( tab_bar, scroll_track_selected_tab_id ) )
			TabBarScrollToTab( tab_bar, scroll_track_selected_tab );
	tab_bar->ScrollingAnim = TabBarScrollClamp( tab_bar, tab_bar->ScrollingAnim );
	tab_bar->ScrollingTarget = TabBarScrollClamp( tab_bar, tab_bar->ScrollingTarget );
	if( tab_bar->ScrollingAnim != tab_bar->ScrollingTarget )
	{
		// Scrolling speed adjust itself so we can always reach our target in 1/3 seconds.
		// Teleport if we are aiming far off the visible line
		tab_bar->ScrollingSpeed = ImMax( tab_bar->ScrollingSpeed, 70.0f * g.FontSize );
		tab_bar->ScrollingSpeed = ImMax( tab_bar->ScrollingSpeed, ImFabs( tab_bar->ScrollingTarget - tab_bar->ScrollingAnim ) / 0.3f );
		const bool teleport = ( tab_bar->PrevFrameVisible + 1 < g.FrameCount ) || ( tab_bar->ScrollingTargetDistToVisibility > 10.0f * g.FontSize );
		tab_bar->ScrollingAnim = teleport ? tab_bar->ScrollingTarget : ImLinearSweep( tab_bar->ScrollingAnim, tab_bar->ScrollingTarget, g.IO.DeltaTime * tab_bar->ScrollingSpeed );
	}
	else
	{
		tab_bar->ScrollingSpeed = 0.0f;
	}

	// Clear name buffers
	if( ( tab_bar->Flags & ImGuiTabBarFlags_DockNode ) == 0 )
		tab_bar->TabsNames.Buf.resize( 0 );
}

// Dockables uses Name/ID in the global namespace. Non-dockable items use the ID stack.
static ImU32   ImGui::TabBarCalcTabID( ImGuiTabBar* tab_bar, const char* label )
{
	if( tab_bar->Flags & ImGuiTabBarFlags_DockNode )
	{
		ImGuiID id = ImHashStr( label );
		KeepAliveID( id );
		return id;
	}
	else
	{
		ImGuiWindow* window = GImGui->CurrentWindow;
		return window->GetID( label );
	}
}

static float ImGui::TabBarCalcMaxTabWidth()
{
	ImGuiContext& g = *GImGui;
	return g.FontSize * 20.0f;
}

ImGuiTabItem* ImGui::TabBarFindTabByID( ImGuiTabBar* tab_bar, ImGuiID tab_id )
{
	if( tab_id != 0 )
		for( int n = 0; n < tab_bar->Tabs.Size; n++ )
			if( tab_bar->Tabs[ n ].ID == tab_id )
				return &tab_bar->Tabs[ n ];
	return NULL;
}

// The *TabId fields be already set by the docking system _before_ the actual TabItem was created, so we clear them regardless.
void ImGui::TabBarRemoveTab( ImGuiTabBar* tab_bar, ImGuiID tab_id )
{
	if( ImGuiTabItem* tab = TabBarFindTabByID( tab_bar, tab_id ) )
		tab_bar->Tabs.erase( tab );
	if( tab_bar->VisibleTabId == tab_id )
	{
		tab_bar->VisibleTabId = 0;
	}
	if( tab_bar->SelectedTabId == tab_id )
	{
		tab_bar->SelectedTabId = 0;
	}
	if( tab_bar->NextSelectedTabId == tab_id )
	{
		tab_bar->NextSelectedTabId = 0;
	}
}

// Called on manual closure attempt
void ImGui::TabBarCloseTab( ImGuiTabBar* tab_bar, ImGuiTabItem* tab )
{
	if( ( tab_bar->VisibleTabId == tab->ID ) && !( tab->Flags & ImGuiTabItemFlags_UnsavedDocument ) )
	{
		// This will remove a frame of lag for selecting another tab on closure.
		// However we don't run it in the case where the 'Unsaved' flag is set, so user gets a chance to fully undo the closure
		tab->LastFrameVisible = -1;
		tab_bar->SelectedTabId = tab_bar->NextSelectedTabId = 0;
	}
	else if( ( tab_bar->VisibleTabId != tab->ID ) && ( tab->Flags & ImGuiTabItemFlags_UnsavedDocument ) )
	{
		// Actually select before expecting closure
		tab_bar->NextSelectedTabId = tab->ID;
	}
}

static float ImGui::TabBarScrollClamp( ImGuiTabBar* tab_bar, float scrolling )
{
	scrolling = ImMin( scrolling, tab_bar->OffsetMax - tab_bar->BarRect.GetWidth() );
	return ImMax( scrolling, 0.0f );
}

static void ImGui::TabBarScrollToTab( ImGuiTabBar* tab_bar, ImGuiTabItem* tab )
{
	ImGuiContext& g = *GImGui;
	float margin = g.FontSize * 1.0f; // When to scroll to make Tab N+1 visible always make a bit of N visible to suggest more scrolling area (since we don't have a scrollbar)
	int order = tab_bar->GetTabOrder( tab );
	float tab_x1 = tab->Offset + ( order > 0 ? -margin : 0.0f );
	float tab_x2 = tab->Offset + tab->Width + ( order + 1 < tab_bar->Tabs.Size ? margin : 1.0f );
	tab_bar->ScrollingTargetDistToVisibility = 0.0f;
	if( tab_bar->ScrollingTarget > tab_x1 || ( tab_x2 - tab_x1 >= tab_bar->BarRect.GetWidth() ) )
	{
		tab_bar->ScrollingTargetDistToVisibility = ImMax( tab_bar->ScrollingAnim - tab_x2, 0.0f );
		tab_bar->ScrollingTarget = tab_x1;
	}
	else if( tab_bar->ScrollingTarget < tab_x2 - tab_bar->BarRect.GetWidth() )
	{
		tab_bar->ScrollingTargetDistToVisibility = ImMax( ( tab_x1 - tab_bar->BarRect.GetWidth() ) - tab_bar->ScrollingAnim, 0.0f );
		tab_bar->ScrollingTarget = tab_x2 - tab_bar->BarRect.GetWidth();
	}
}

void ImGui::TabBarQueueChangeTabOrder( ImGuiTabBar* tab_bar, const ImGuiTabItem* tab, int dir )
{
	IM_ASSERT( dir == -1 || dir == +1 );
	IM_ASSERT( tab_bar->ReorderRequestTabId == 0 );
	tab_bar->ReorderRequestTabId = tab->ID;
	tab_bar->ReorderRequestDir = ( ImS8 )dir;
}

static ImGuiTabItem* ImGui::TabBarScrollingButtons( ImGuiTabBar* tab_bar )
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	const ImVec2 arrow_button_size( g.FontSize - 2.0f, g.FontSize + g.Style.FramePadding.y * 2.0f );
	const float scrolling_buttons_width = arrow_button_size.x * 2.0f;

	const ImVec2 backup_cursor_pos = window->DC.CursorPos;
	//window->DrawList->AddRect(ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y), ImVec2(tab_bar->BarRect.Max.x, tab_bar->BarRect.Max.y), IM_COL32(255,0,0,255));

	const ImRect avail_bar_rect = tab_bar->BarRect;
	bool want_clip_rect = !avail_bar_rect.Contains( ImRect( window->DC.CursorPos, window->DC.CursorPos + ImVec2( scrolling_buttons_width, 0.0f ) ) );
	if( want_clip_rect )
		PushClipRect( tab_bar->BarRect.Min, tab_bar->BarRect.Max + ImVec2( g.Style.ItemInnerSpacing.x, 0.0f ), true );

	ImGuiTabItem* tab_to_select = NULL;

	int select_dir = 0;
	ImVec4 arrow_col = g.Style.Colors[ ImGuiCol_Text ];
	arrow_col.w *= 0.5f;

	PushStyleColor( ImGuiCol_Text, arrow_col );
	PushStyleColor( ImGuiCol_Button, ImVec4( 0, 0, 0, 0 ) );
	const float backup_repeat_delay = g.IO.KeyRepeatDelay;
	const float backup_repeat_rate = g.IO.KeyRepeatRate;
	g.IO.KeyRepeatDelay = 0.250f;
	g.IO.KeyRepeatRate = 0.200f;
	window->DC.CursorPos = ImVec2( tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y );
	if( ArrowButtonEx( SECURE("##<"), ImGuiDir_Left, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat ) )
		select_dir = -1;
	window->DC.CursorPos = ImVec2( tab_bar->BarRect.Max.x - scrolling_buttons_width + arrow_button_size.x, tab_bar->BarRect.Min.y );
	if( ArrowButtonEx( SECURE("##>"), ImGuiDir_Right, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat ) )
		select_dir = +1;
	PopStyleColor( 2 );
	g.IO.KeyRepeatRate = backup_repeat_rate;
	g.IO.KeyRepeatDelay = backup_repeat_delay;

	if( want_clip_rect )
		PopClipRect();

	if( select_dir != 0 )
		if( ImGuiTabItem* tab_item = TabBarFindTabByID( tab_bar, tab_bar->SelectedTabId ) )
		{
			int selected_order = tab_bar->GetTabOrder( tab_item );
			int target_order = selected_order + select_dir;
			tab_to_select = &tab_bar->Tabs[ ( target_order >= 0 && target_order < tab_bar->Tabs.Size ) ? target_order : selected_order ]; // If we are at the end of the list, still scroll to make our tab visible
		}
	window->DC.CursorPos = backup_cursor_pos;
	tab_bar->BarRect.Max.x -= scrolling_buttons_width + 1.0f;

	return tab_to_select;
}

static ImGuiTabItem* ImGui::TabBarTabListPopupButton( ImGuiTabBar* tab_bar )
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	// We use g.Style.FramePadding.y to match the square ArrowButton size
	const float tab_list_popup_button_width = g.FontSize + g.Style.FramePadding.y;
	const ImVec2 backup_cursor_pos = window->DC.CursorPos;
	window->DC.CursorPos = ImVec2( tab_bar->BarRect.Min.x - g.Style.FramePadding.y, tab_bar->BarRect.Min.y );
	tab_bar->BarRect.Min.x += tab_list_popup_button_width;

	ImVec4 arrow_col = g.Style.Colors[ ImGuiCol_Text ];
	arrow_col.w *= 0.5f;
	PushStyleColor( ImGuiCol_Text, arrow_col );
	PushStyleColor( ImGuiCol_Button, ImVec4( 0, 0, 0, 0 ) );
	bool open = BeginCombo( SECURE("##v"), NULL, ImGuiComboFlags_NoPreview );
	PopStyleColor( 2 );

	ImGuiTabItem* tab_to_select = NULL;
	if( open )
	{
		for( int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++ )
		{
			ImGuiTabItem* tab = &tab_bar->Tabs[ tab_n ];
			const char* tab_name = tab_bar->GetTabName( tab );
			if( Selectable( tab_name, tab_bar->SelectedTabId == tab->ID ) )
				tab_to_select = tab;
		}
		EndCombo();
	}

	window->DC.CursorPos = backup_cursor_pos;
	return tab_to_select;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.
//-------------------------------------------------------------------------
// - BeginTabItem()
// - EndTabItem()
// - TabItemEx() [Internal]
// - SetTabItemClosed()
// - TabItemCalcSize() [Internal]
// - TabItemBackground() [Internal]
// - TabItemLabelAndCloseButton() [Internal]
//-------------------------------------------------------------------------

bool    ImGui::BeginTabItem( const char* label, bool* p_open, ImGuiTabItemFlags flags )
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	if( window->SkipItems )
		return false;

	ImGuiTabBar* tab_bar = g.CurrentTabBar;
	if( tab_bar == NULL )
	{
		IM_ASSERT_USER_ERROR( tab_bar, "BeginTabItem() Needs to be called between BeginTabBar() and EndTabBar()!" );
		return false;
	}
	bool ret = TabItemEx( tab_bar, label, p_open, flags );
	if( ret && !( flags & ImGuiTabItemFlags_NoPushId ) )
	{
		ImGuiTabItem* tab = &tab_bar->Tabs[ tab_bar->LastTabItemIdx ];
		PushOverrideID( tab->ID ); // We already hashed 'label' so push into the ID stack directly instead of doing another hash through PushID(label)
	}
	return ret;
}

void    ImGui::EndTabItem()
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	if( window->SkipItems )
		return;

	ImGuiTabBar* tab_bar = g.CurrentTabBar;
	if( tab_bar == NULL )
	{
		IM_ASSERT( tab_bar != NULL && "Needs to be called between BeginTabBar() and EndTabBar()!" );
		return;
	}
	IM_ASSERT( tab_bar->LastTabItemIdx >= 0 );
	ImGuiTabItem* tab = &tab_bar->Tabs[ tab_bar->LastTabItemIdx ];
	if( !( tab->Flags & ImGuiTabItemFlags_NoPushId ) )
		window->IDStack.pop_back();
}

bool    ImGui::TabItemEx( ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags )
{
	// Layout whole tab bar if not already done
	if( tab_bar->WantLayout )
		TabBarLayout( tab_bar );

	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	if( window->SkipItems )
		return false;

	const ImGuiStyle& style = g.Style;
	const ImGuiID id = TabBarCalcTabID( tab_bar, label );

	// If the user called us with *p_open == false, we early out and don't render. We make a dummy call to ItemAdd() so that attempts to use a contextual popup menu with an implicit ID won't use an older ID.
	IMGUI_TEST_ENGINE_ITEM_INFO( id, label, window->DC.LastItemStatusFlags );
	if( p_open && !*p_open )
	{
		PushItemFlag( ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus, true );
		ItemAdd( ImRect(), id );
		PopItemFlag();
		return false;
	}

	// Store into ImGuiTabItemFlags_NoCloseButton, also honor ImGuiTabItemFlags_NoCloseButton passed by user (although not documented)
	if( flags & ImGuiTabItemFlags_NoCloseButton )
		p_open = NULL;
	else if( p_open == NULL )
		flags |= ImGuiTabItemFlags_NoCloseButton;

	// Calculate tab contents size
	ImVec2 size = TabItemCalcSize( label, p_open != NULL );

	// Acquire tab data
	ImGuiTabItem* tab = TabBarFindTabByID( tab_bar, id );
	bool tab_is_new = false;
	if( tab == NULL )
	{
		tab_bar->Tabs.push_back( ImGuiTabItem() );
		tab = &tab_bar->Tabs.back();
		tab->ID = id;
		tab->Width = size.x;
		tab_is_new = true;
	}
	tab_bar->LastTabItemIdx = ( short )tab_bar->Tabs.index_from_ptr( tab );
	tab->ContentWidth = size.x;

	const bool tab_bar_appearing = ( tab_bar->PrevFrameVisible + 1 < g.FrameCount );
	const bool tab_bar_focused = ( tab_bar->Flags & ImGuiTabBarFlags_IsFocused ) != 0;
	const bool tab_appearing = ( tab->LastFrameVisible + 1 < g.FrameCount );
	tab->LastFrameVisible = g.FrameCount;
	tab->Flags = flags;

	// Append name with zero-terminator
	tab->NameOffset = tab_bar->TabsNames.size();
	tab_bar->TabsNames.append( label, label + strlen( label ) + 1 );

	// If we are not reorderable, always reset offset based on submission order.
	// (We already handled layout and sizing using the previous known order, but sizing is not affected by order!)
	if( !tab_appearing && !( tab_bar->Flags & ImGuiTabBarFlags_Reorderable ) )
	{
		tab->Offset = tab_bar->OffsetNextTab;
		tab_bar->OffsetNextTab += tab->Width + g.Style.ItemInnerSpacing.x;
	}

	// Update selected tab
	if( tab_appearing && ( tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs ) && tab_bar->NextSelectedTabId == 0 )
		if( !tab_bar_appearing || tab_bar->SelectedTabId == 0 )
			tab_bar->NextSelectedTabId = id;  // New tabs gets activated
	if( ( flags & ImGuiTabItemFlags_SetSelected ) && ( tab_bar->SelectedTabId != id ) ) // SetSelected can only be passed on explicit tab bar
		tab_bar->NextSelectedTabId = id;

	// Lock visibility
	bool tab_contents_visible = ( tab_bar->VisibleTabId == id );
	if( tab_contents_visible )
		tab_bar->VisibleTabWasSubmitted = true;

	// On the very first frame of a tab bar we let first tab contents be visible to minimize appearing glitches
	if( !tab_contents_visible && tab_bar->SelectedTabId == 0 && tab_bar_appearing )
		if( tab_bar->Tabs.Size == 1 && !( tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs ) )
			tab_contents_visible = true;

	if( tab_appearing && !( tab_bar_appearing && !tab_is_new ) )
	{
		PushItemFlag( ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus, true );
		ItemAdd( ImRect(), id );
		PopItemFlag();
		return tab_contents_visible;
	}

	if( tab_bar->SelectedTabId == id )
		tab->LastFrameSelected = g.FrameCount;

	// Backup current layout position
	const ImVec2 backup_main_cursor_pos = window->DC.CursorPos;

	// Layout
	size.x = tab->Width;
	window->DC.CursorPos = tab_bar->BarRect.Min + ImVec2( IM_FLOOR( tab->Offset - tab_bar->ScrollingAnim ), 0.0f );
	ImVec2 pos = window->DC.CursorPos;
	ImRect bb( pos, pos + size );

	// We don't have CPU clipping primitives to clip the CloseButton (until it becomes a texture), so need to add an extra draw call (temporary in the case of vertical animation)
	bool want_clip_rect = ( bb.Min.x < tab_bar->BarRect.Min.x ) || ( bb.Max.x > tab_bar->BarRect.Max.x );
	if( want_clip_rect )
		PushClipRect( ImVec2( ImMax( bb.Min.x, tab_bar->BarRect.Min.x ), bb.Min.y - 1 ), ImVec2( tab_bar->BarRect.Max.x, bb.Max.y ), true );

	ImVec2 backup_cursor_max_pos = window->DC.CursorMaxPos;
	ItemSize( bb.GetSize(), style.FramePadding.y );
	window->DC.CursorMaxPos = backup_cursor_max_pos;

	if( !ItemAdd( bb, id ) )
	{
		if( want_clip_rect )
			PopClipRect();
		window->DC.CursorPos = backup_main_cursor_pos;
		return tab_contents_visible;
	}

	// Click to Select a tab
	ImGuiButtonFlags button_flags = ( ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_AllowItemOverlap );
	if( g.DragDropActive )
		button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;
	bool hovered, held;
	bool pressed = ButtonBehavior( bb, id, &hovered, &held, button_flags );
	if( pressed )
		tab_bar->NextSelectedTabId = id;
	hovered |= ( g.HoveredId == id );

	// Allow the close button to overlap unless we are dragging (in which case we don't want any overlapping tabs to be hovered)
	if( !held )
		SetItemAllowOverlap();

	// Drag and drop: re-order tabs
	if( held && !tab_appearing && IsMouseDragging( 0 ) )
	{
		if( !g.DragDropActive && ( tab_bar->Flags & ImGuiTabBarFlags_Reorderable ) )
		{
			// While moving a tab it will jump on the other side of the mouse, so we also test for MouseDelta.x
			if( g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < bb.Min.x )
			{
				if( tab_bar->Flags & ImGuiTabBarFlags_Reorderable )
					TabBarQueueChangeTabOrder( tab_bar, tab, -1 );
			}
			else if( g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > bb.Max.x )
			{
				if( tab_bar->Flags & ImGuiTabBarFlags_Reorderable )
					TabBarQueueChangeTabOrder( tab_bar, tab, +1 );
			}
		}
	}

#if 0
	if( hovered && g.HoveredIdNotActiveTimer > 0.50f && bb.GetWidth() < tab->ContentWidth )
	{
		// Enlarge tab display when hovering
		bb.Max.x = bb.Min.x + IM_FLOOR( ImLerp( bb.GetWidth(), tab->ContentWidth, ImSaturate( ( g.HoveredIdNotActiveTimer - 0.40f ) * 6.0f ) ) );
		display_draw_list = GetForegroundDrawList( window );
		TabItemBackground( display_draw_list, bb, flags, GetColorU32( ImGuiCol_TitleBgActive ) );
	}
#endif

	// Render tab shape
	ImDrawList* display_draw_list = window->DrawList;
	const ImU32 tab_col = GetColorU32( ( held || hovered ) ? ImGuiCol_TabHovered : tab_contents_visible ? ( tab_bar_focused ? ImGuiCol_TabActive : ImGuiCol_TabUnfocusedActive ) : ( tab_bar_focused ? ImGuiCol_Tab : ImGuiCol_TabUnfocused ) );
	TabItemBackground( display_draw_list, bb, flags, tab_col );
	RenderNavHighlight( bb, id );

	// Select with right mouse button. This is so the common idiom for context menu automatically highlight the current widget.
	const bool hovered_unblocked = IsItemHovered( ImGuiHoveredFlags_AllowWhenBlockedByPopup );
	if( hovered_unblocked && ( IsMouseClicked( 1 ) || IsMouseReleased( 1 ) ) )
		tab_bar->NextSelectedTabId = id;

	if( tab_bar->Flags & ImGuiTabBarFlags_NoCloseWithMiddleMouseButton )
		flags |= ImGuiTabItemFlags_NoCloseWithMiddleMouseButton;

	// Render tab label, process close button
	const ImGuiID close_button_id = p_open ? window->GetID( ( void* )( ( intptr_t )id + 1 ) ) : 0;
	bool just_closed = TabItemLabelAndCloseButton( display_draw_list, bb, flags, tab_bar->FramePadding, label, id, close_button_id );
	if( just_closed && p_open != NULL )
	{
		*p_open = false;
		TabBarCloseTab( tab_bar, tab );
	}

	// Restore main window position so user can draw there
	if( want_clip_rect )
		PopClipRect();
	window->DC.CursorPos = backup_main_cursor_pos;

	// Tooltip (FIXME: Won't work over the close button because ItemOverlap systems messes up with HoveredIdTimer)
	// We test IsItemHovered() to discard e.g. when another item is active or drag and drop over the tab bar (which g.HoveredId ignores)
	if( g.HoveredId == id && !held && g.HoveredIdNotActiveTimer > 0.50f && IsItemHovered() )
		if( !( tab_bar->Flags & ImGuiTabBarFlags_NoTooltip ) )
			SetTooltip( SECURE("%.*s"), ( int )( FindRenderedTextEnd( label ) - label ), label );

	return tab_contents_visible;
}

// [Public] This is call is 100% optional but it allows to remove some one-frame glitches when a tab has been unexpectedly removed.
// To use it to need to call the function SetTabItemClosed() after BeginTabBar() and before any call to BeginTabItem()
void    ImGui::SetTabItemClosed( const char* label )
{
	ImGuiContext& g = *GImGui;
	bool is_within_manual_tab_bar = g.CurrentTabBar && !( g.CurrentTabBar->Flags & ImGuiTabBarFlags_DockNode );
	if( is_within_manual_tab_bar )
	{
		ImGuiTabBar* tab_bar = g.CurrentTabBar;
		IM_ASSERT( tab_bar->WantLayout );         // Needs to be called AFTER BeginTabBar() and BEFORE the first call to BeginTabItem()
		ImGuiID tab_id = TabBarCalcTabID( tab_bar, label );
		TabBarRemoveTab( tab_bar, tab_id );
	}
}

ImVec2 ImGui::TabItemCalcSize( const char* label, bool has_close_button )
{
	ImGuiContext& g = *GImGui;
	ImVec2 label_size = CalcTextSize( label, NULL, true );
	ImVec2 size = ImVec2( label_size.x + g.Style.FramePadding.x, label_size.y + g.Style.FramePadding.y * 2.0f );
	if( has_close_button )
		size.x += g.Style.FramePadding.x + ( g.Style.ItemInnerSpacing.x + g.FontSize ); // We use Y intentionally to fit the close button circle.
	else
		size.x += g.Style.FramePadding.x + 1.0f;
	return ImVec2( ImMin( size.x, TabBarCalcMaxTabWidth() ), size.y );
}

void ImGui::TabItemBackground( ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImU32 col )
{
	// While rendering tabs, we trim 1 pixel off the top of our bounding box so they can fit within a regular frame height while looking "detached" from it.
	ImGuiContext& g = *GImGui;
	const float width = bb.GetWidth();
	IM_UNUSED( flags );
	IM_ASSERT( width > 0.0f );
	const float rounding = ImMax( 0.0f, ImMin( g.Style.TabRounding, width * 0.5f - 1.0f ) );
	const float y1 = bb.Min.y + 1.0f;
	const float y2 = bb.Max.y - 1.0f;
	draw_list->PathLineTo( ImVec2( bb.Min.x, y2 ) );
	draw_list->PathArcToFast( ImVec2( bb.Min.x + rounding, y1 + rounding ), rounding, 6, 9 );
	draw_list->PathArcToFast( ImVec2( bb.Max.x - rounding, y1 + rounding ), rounding, 9, 12 );
	draw_list->PathLineTo( ImVec2( bb.Max.x, y2 ) );
	draw_list->PathFillConvex( col );
	if( g.Style.TabBorderSize > 0.0f )
	{
		draw_list->PathLineTo( ImVec2( bb.Min.x + 0.5f, y2 ) );
		draw_list->PathArcToFast( ImVec2( bb.Min.x + rounding + 0.5f, y1 + rounding + 0.5f ), rounding, 6, 9 );
		draw_list->PathArcToFast( ImVec2( bb.Max.x - rounding - 0.5f, y1 + rounding + 0.5f ), rounding, 9, 12 );
		draw_list->PathLineTo( ImVec2( bb.Max.x - 0.5f, y2 ) );
		draw_list->PathStroke( GetColorU32( ImGuiCol_Border ), false, g.Style.TabBorderSize );
	}
}

// Render text label (with custom clipping) + Unsaved Document marker + Close Button logic
// We tend to lock style.FramePadding for a given tab-bar, hence the 'frame_padding' parameter.
bool ImGui::TabItemLabelAndCloseButton( ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char* label, ImGuiID tab_id, ImGuiID close_button_id )
{
	ImGuiContext& g = *GImGui;
	ImVec2 label_size = CalcTextSize( label, NULL, true );
	if( bb.GetWidth() <= 1.0f )
		return false;

	// Render text label (with clipping + alpha gradient) + unsaved marker
	const char* TAB_UNSAVED_MARKER = SECURE("*");
	ImRect text_pixel_clip_bb( bb.Min.x + frame_padding.x, bb.Min.y + frame_padding.y, bb.Max.x - frame_padding.x, bb.Max.y );
	if( flags & ImGuiTabItemFlags_UnsavedDocument )
	{
		text_pixel_clip_bb.Max.x -= CalcTextSize( TAB_UNSAVED_MARKER, NULL, false ).x;
		ImVec2 unsaved_marker_pos( ImMin( bb.Min.x + frame_padding.x + label_size.x + 2, text_pixel_clip_bb.Max.x ), bb.Min.y + frame_padding.y + IM_FLOOR( -g.FontSize * 0.25f ) );
		RenderTextClippedEx( draw_list, unsaved_marker_pos, bb.Max - frame_padding, TAB_UNSAVED_MARKER, NULL, NULL );
	}
	ImRect text_ellipsis_clip_bb = text_pixel_clip_bb;

	// Close Button
	// We are relying on a subtle and confusing distinction between 'hovered' and 'g.HoveredId' which happens because we are using ImGuiButtonFlags_AllowOverlapMode + SetItemAllowOverlap()
	//  'hovered' will be true when hovering the Tab but NOT when hovering the close button
	//  'g.HoveredId==id' will be true when hovering the Tab including when hovering the close button
	//  'g.ActiveId==close_button_id' will be true when we are holding on the close button, in which case both hovered booleans are false
	bool close_button_pressed = false;
	bool close_button_visible = false;
	if( close_button_id != 0 )
		if( g.HoveredId == tab_id || g.HoveredId == close_button_id || g.ActiveId == close_button_id )
			close_button_visible = true;
	if( close_button_visible )
	{
		ImGuiItemHoveredDataBackup last_item_backup;
		const float close_button_sz = g.FontSize;
		PushStyleVar( ImGuiStyleVar_FramePadding, frame_padding );
		if( CloseButton( close_button_id, ImVec2( bb.Max.x - frame_padding.x * 2.0f - close_button_sz, bb.Min.y ) ) )
			close_button_pressed = true;
		PopStyleVar();
		last_item_backup.Restore();

		// Close with middle mouse button
		if( !( flags & ImGuiTabItemFlags_NoCloseWithMiddleMouseButton ) && IsMouseClicked( 2 ) )
			close_button_pressed = true;

		text_pixel_clip_bb.Max.x -= close_button_sz;
	}

	float ellipsis_max_x = close_button_visible ? text_pixel_clip_bb.Max.x : bb.Max.x - 1.0f;
	RenderTextEllipsis( draw_list, text_ellipsis_clip_bb.Min, text_ellipsis_clip_bb.Max, text_pixel_clip_bb.Max.x, ellipsis_max_x, label, NULL, &label_size );

	return close_button_pressed;
}


//-------------------------------------------------------------------------
// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.
// In the current version, Columns are very weak. Needs to be replaced with a more full-featured system.
//-------------------------------------------------------------------------
// - GetColumnIndex()
// - GetColumnCount()
// - GetColumnOffset()
// - GetColumnWidth()
// - SetColumnOffset()
// - SetColumnWidth()
// - PushColumnClipRect() [Internal]
// - PushColumnsBackground() [Internal]
// - PopColumnsBackground() [Internal]
// - FindOrCreateColumns() [Internal]
// - GetColumnsID() [Internal]
// - BeginColumns()
// - NextColumn()
// - EndColumns()
// - Columns()
//-------------------------------------------------------------------------

int ImGui::GetColumnIndex()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->DC.CurrentColumns ? window->DC.CurrentColumns->Current : 0;
}

int ImGui::GetColumnsCount()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->DC.CurrentColumns ? window->DC.CurrentColumns->Count : 1;
}

float ImGui::GetColumnOffsetFromNorm( const ImGuiColumns* columns, float offset_norm )
{
	return offset_norm * ( columns->OffMaxX - columns->OffMinX );
}

float ImGui::GetColumnNormFromOffset( const ImGuiColumns* columns, float offset )
{
	return offset / ( columns->OffMaxX - columns->OffMinX );
}

static const float COLUMNS_HIT_RECT_HALF_WIDTH = 4.0f;

static float GetDraggedColumnOffset( ImGuiColumns* columns, int column_index )
{
	// Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing
	// window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	IM_ASSERT( column_index > 0 ); // We are not supposed to drag column 0.
	IM_ASSERT( g.ActiveId == columns->ID + ImGuiID( column_index ) );

	float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + COLUMNS_HIT_RECT_HALF_WIDTH - window->Pos.x;
	x = ImMax( x, ImGui::GetColumnOffset( column_index - 1 ) + g.Style.ColumnsMinSpacing );
	if( ( columns->Flags & ImGuiColumnsFlags_NoPreserveWidths ) )
		x = ImMin( x, ImGui::GetColumnOffset( column_index + 1 ) - g.Style.ColumnsMinSpacing );

	return x;
}

float ImGui::GetColumnOffset( int column_index )
{
	ImGuiWindow* window = GetCurrentWindowRead();
	ImGuiColumns* columns = window->DC.CurrentColumns;
	if( columns == NULL )
		return 0.0f;

	if( column_index < 0 )
		column_index = columns->Current;
	IM_ASSERT( column_index < columns->Columns.Size );

	const float t = columns->Columns[ column_index ].OffsetNorm;
	const float x_offset = ImLerp( columns->OffMinX, columns->OffMaxX, t );
	return x_offset;
}

static float GetColumnWidthEx( ImGuiColumns* columns, int column_index, bool before_resize = false )
{
	if( column_index < 0 )
		column_index = columns->Current;

	float offset_norm;
	if( before_resize )
		offset_norm = columns->Columns[ column_index + 1 ].OffsetNormBeforeResize - columns->Columns[ column_index ].OffsetNormBeforeResize;
	else
		offset_norm = columns->Columns[ column_index + 1 ].OffsetNorm - columns->Columns[ column_index ].OffsetNorm;
	return ImGui::GetColumnOffsetFromNorm( columns, offset_norm );
}

float ImGui::GetColumnWidth( int column_index )
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	ImGuiColumns* columns = window->DC.CurrentColumns;
	if( columns == NULL )
		return GetContentRegionAvail().x;

	if( column_index < 0 )
		column_index = columns->Current;
	return GetColumnOffsetFromNorm( columns, columns->Columns[ column_index + 1 ].OffsetNorm - columns->Columns[ column_index ].OffsetNorm );
}

void ImGui::SetColumnOffset( int column_index, float offset )
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	ImGuiColumns* columns = window->DC.CurrentColumns;
	IM_ASSERT( columns != NULL );

	if( column_index < 0 )
		column_index = columns->Current;
	IM_ASSERT( column_index < columns->Columns.Size );

	const bool preserve_width = !( columns->Flags & ImGuiColumnsFlags_NoPreserveWidths ) && ( column_index < columns->Count - 1 );
	const float width = preserve_width ? GetColumnWidthEx( columns, column_index, columns->IsBeingResized ) : 0.0f;

	if( !( columns->Flags & ImGuiColumnsFlags_NoForceWithinWindow ) )
		offset = ImMin( offset, columns->OffMaxX - g.Style.ColumnsMinSpacing * ( columns->Count - column_index ) );
	columns->Columns[ column_index ].OffsetNorm = GetColumnNormFromOffset( columns, offset - columns->OffMinX );

	if( preserve_width )
		SetColumnOffset( column_index + 1, offset + ImMax( g.Style.ColumnsMinSpacing, width ) );
}

void ImGui::SetColumnWidth( int column_index, float width )
{
	ImGuiWindow* window = GetCurrentWindowRead();
	ImGuiColumns* columns = window->DC.CurrentColumns;
	IM_ASSERT( columns != NULL );

	if( column_index < 0 )
		column_index = columns->Current;
	SetColumnOffset( column_index + 1, GetColumnOffset( column_index ) + width );
}

void ImGui::PushColumnClipRect( int column_index )
{
	ImGuiWindow* window = GetCurrentWindowRead();
	ImGuiColumns* columns = window->DC.CurrentColumns;
	if( column_index < 0 )
		column_index = columns->Current;

	ImGuiColumnData* column = &columns->Columns[ column_index ];
	PushClipRect( column->ClipRect.Min, column->ClipRect.Max, false );
}

// Get into the columns background draw command (which is generally the same draw command as before we called BeginColumns)
void ImGui::PushColumnsBackground()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	ImGuiColumns* columns = window->DC.CurrentColumns;
	if( columns->Count == 1 )
		return;
	columns->Splitter.SetCurrentChannel( window->DrawList, 0 );
	int cmd_size = window->DrawList->CmdBuffer.Size;
	PushClipRect( columns->HostClipRect.Min, columns->HostClipRect.Max, false );
	IM_UNUSED( cmd_size );
	IM_ASSERT( cmd_size == window->DrawList->CmdBuffer.Size ); // Being in channel 0 this should not have created an ImDrawCmd
}

void ImGui::PopColumnsBackground()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	ImGuiColumns* columns = window->DC.CurrentColumns;
	if( columns->Count == 1 )
		return;
	columns->Splitter.SetCurrentChannel( window->DrawList, columns->Current + 1 );
	PopClipRect();
}

ImGuiColumns* ImGui::FindOrCreateColumns( ImGuiWindow* window, ImGuiID id )
{
	// We have few columns per window so for now we don't need bother much with turning this into a faster lookup.
	for( int n = 0; n < window->ColumnsStorage.Size; n++ )
		if( window->ColumnsStorage[ n ].ID == id )
			return &window->ColumnsStorage[ n ];

	window->ColumnsStorage.push_back( ImGuiColumns() );
	ImGuiColumns* columns = &window->ColumnsStorage.back();
	columns->ID = id;
	return columns;
}

ImGuiID ImGui::GetColumnsID( const char* str_id, int columns_count )
{
	ImGuiWindow* window = GetCurrentWindow();

	// Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.
	// In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.
	PushID( 0x11223347 + ( str_id ? 0 : columns_count ) );
	ImGuiID id = window->GetID( str_id ? str_id : SECURE("columns") );
	PopID();

	return id;
}

void ImGui::BeginColumns( const char* str_id, int columns_count, ImGuiColumnsFlags flags )
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = GetCurrentWindow();

	IM_ASSERT( columns_count >= 1 );
	IM_ASSERT( window->DC.CurrentColumns == NULL );   // Nested columns are currently not supported

	// Acquire storage for the columns set
	ImGuiID id = GetColumnsID( str_id, columns_count );
	ImGuiColumns* columns = FindOrCreateColumns( window, id );
	IM_ASSERT( columns->ID == id );
	columns->Current = 0;
	columns->Count = columns_count;
	columns->Flags = flags;
	window->DC.CurrentColumns = columns;

	columns->HostCursorPosY = window->DC.CursorPos.y;
	columns->HostCursorMaxPosX = window->DC.CursorMaxPos.x;
	columns->HostClipRect = window->ClipRect;
	columns->HostWorkRect = window->WorkRect;

	// Set state for first column
	// We aim so that the right-most column will have the same clipping width as other after being clipped by parent ClipRect
	const float column_padding = g.Style.ItemSpacing.x;
	const float half_clip_extend_x = ImFloor( ImMax( window->WindowPadding.x * 0.5f, window->WindowBorderSize ) );
	const float max_1 = window->WorkRect.Max.x + column_padding - ImMax( column_padding - window->WindowPadding.x, 0.0f );
	const float max_2 = window->WorkRect.Max.x + half_clip_extend_x;
	columns->OffMinX = window->DC.Indent.x - column_padding + ImMax( column_padding - window->WindowPadding.x, 0.0f );
	columns->OffMaxX = ImMax( ImMin( max_1, max_2 ) - window->Pos.x, columns->OffMinX + 1.0f );
	columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;

	// Clear data if columns count changed
	if( columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1 )
		columns->Columns.resize( 0 );

	// Initialize default widths
	columns->IsFirstFrame = ( columns->Columns.Size == 0 );
	if( columns->Columns.Size == 0 )
	{
		columns->Columns.reserve( columns_count + 1 );
		for( int n = 0; n < columns_count + 1; n++ )
		{
			ImGuiColumnData column;
			column.OffsetNorm = n / ( float )columns_count;
			columns->Columns.push_back( column );
		}
	}

	for( int n = 0; n < columns_count; n++ )
	{
		// Compute clipping rectangle
		ImGuiColumnData* column = &columns->Columns[ n ];
		float clip_x1 = IM_ROUND( window->Pos.x + GetColumnOffset( n ) );
		float clip_x2 = IM_ROUND( window->Pos.x + GetColumnOffset( n + 1 ) - 1.0f );
		column->ClipRect = ImRect( clip_x1, -FLT_MAX, clip_x2, +FLT_MAX );
		column->ClipRect.ClipWith( window->ClipRect );
	}

	if( columns->Count > 1 )
	{
		columns->Splitter.Split( window->DrawList, 1 + columns->Count );
		columns->Splitter.SetCurrentChannel( window->DrawList, 1 );
		PushColumnClipRect( 0 );
	}

	// We don't generally store Indent.x inside ColumnsOffset because it may be manipulated by the user.
	float offset_0 = GetColumnOffset( columns->Current );
	float offset_1 = GetColumnOffset( columns->Current + 1 );
	float width = offset_1 - offset_0;
	PushItemWidth( width * 0.65f );
	window->DC.ColumnsOffset.x = ImMax( column_padding - window->WindowPadding.x, 0.0f );
	window->DC.CursorPos.x = IM_FLOOR( window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x );
	window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;
}

void ImGui::NextColumn()
{
	ImGuiWindow* window = GetCurrentWindow();
	if( window->SkipItems || window->DC.CurrentColumns == NULL )
		return;

	ImGuiContext& g = *GImGui;
	ImGuiColumns* columns = window->DC.CurrentColumns;

	if( columns->Count == 1 )
	{
		window->DC.CursorPos.x = IM_FLOOR( window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x );
		IM_ASSERT( columns->Current == 0 );
		return;
	}
	PopItemWidth();
	PopClipRect();

	const float column_padding = g.Style.ItemSpacing.x;
	columns->LineMaxY = ImMax( columns->LineMaxY, window->DC.CursorPos.y );
	if( ++columns->Current < columns->Count )
	{
		// Columns 1+ ignore IndentX (by canceling it out)
		// FIXME-COLUMNS: Unnecessary, could be locked?
		window->DC.ColumnsOffset.x = GetColumnOffset( columns->Current ) - window->DC.Indent.x + column_padding;
		columns->Splitter.SetCurrentChannel( window->DrawList, columns->Current + 1 );
	}
	else
	{
		// New row/line
		// Column 0 honor IndentX
		window->DC.ColumnsOffset.x = ImMax( column_padding - window->WindowPadding.x, 0.0f );
		columns->Splitter.SetCurrentChannel( window->DrawList, 1 );
		columns->Current = 0;
		columns->LineMinY = columns->LineMaxY;
	}
	window->DC.CursorPos.x = IM_FLOOR( window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x );
	window->DC.CursorPos.y = columns->LineMinY;
	window->DC.CurrLineSize = ImVec2( 0.0f, 0.0f );
	window->DC.CurrLineTextBaseOffset = 0.0f;

	PushColumnClipRect( columns->Current );     // FIXME-COLUMNS: Could it be an overwrite?

	// FIXME-COLUMNS: Share code with BeginColumns() - move code on columns setup.
	float offset_0 = GetColumnOffset( columns->Current );
	float offset_1 = GetColumnOffset( columns->Current + 1 );
	float width = offset_1 - offset_0;
	PushItemWidth( width * 0.65f );
	window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;
}

void ImGui::EndColumns()
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = GetCurrentWindow();
	ImGuiColumns* columns = window->DC.CurrentColumns;
	IM_ASSERT( columns != NULL );

	PopItemWidth();
	if( columns->Count > 1 )
	{
		PopClipRect();
		columns->Splitter.Merge( window->DrawList );
	}

	const ImGuiColumnsFlags flags = columns->Flags;
	columns->LineMaxY = ImMax( columns->LineMaxY, window->DC.CursorPos.y );
	window->DC.CursorPos.y = columns->LineMaxY;
	if( !( flags & ImGuiColumnsFlags_GrowParentContentsSize ) )
		window->DC.CursorMaxPos.x = columns->HostCursorMaxPosX;  // Restore cursor max pos, as columns don't grow parent

// Draw columns borders and handle resize
// The IsBeingResized flag ensure we preserve pre-resize columns width so back-and-forth are not lossy
	bool is_being_resized = false;
	if( !( flags & ImGuiColumnsFlags_NoBorder ) && !window->SkipItems )
	{
		// We clip Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.
		const float y1 = ImMax( columns->HostCursorPosY, window->ClipRect.Min.y );
		const float y2 = ImMin( window->DC.CursorPos.y, window->ClipRect.Max.y );
		int dragging_column = -1;
		for( int n = 1; n < columns->Count; n++ )
		{
			ImGuiColumnData* column = &columns->Columns[ n ];
			float x = window->Pos.x + GetColumnOffset( n );
			const ImGuiID column_id = columns->ID + ImGuiID( n );
			const float column_hit_hw = COLUMNS_HIT_RECT_HALF_WIDTH;
			const ImRect column_hit_rect( ImVec2( x - column_hit_hw, y1 ), ImVec2( x + column_hit_hw, y2 ) );
			KeepAliveID( column_id );
			if( IsClippedEx( column_hit_rect, column_id, false ) )
				continue;

			bool hovered = false, held = false;
			if( !( flags & ImGuiColumnsFlags_NoResize ) )
			{
				ButtonBehavior( column_hit_rect, column_id, &hovered, &held );
				if( hovered || held )
					g.MouseCursor = ImGuiMouseCursor_ResizeEW;
				if( held && !( column->Flags & ImGuiColumnsFlags_NoResize ) )
					dragging_column = n;
			}

			// Draw column
			const ImU32 col = GetColorU32( held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator );
			const float xi = IM_FLOOR( x );
			window->DrawList->AddLine( ImVec2( xi, y1 + 1.0f ), ImVec2( xi, y2 ), col );
		}

		// Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.
		if( dragging_column != -1 )
		{
			if( !columns->IsBeingResized )
				for( int n = 0; n < columns->Count + 1; n++ )
					columns->Columns[ n ].OffsetNormBeforeResize = columns->Columns[ n ].OffsetNorm;
			columns->IsBeingResized = is_being_resized = true;
			float x = GetDraggedColumnOffset( columns, dragging_column );
			SetColumnOffset( dragging_column, x );
		}
	}
	columns->IsBeingResized = is_being_resized;

	window->WorkRect = columns->HostWorkRect;
	window->DC.CurrentColumns = NULL;
	window->DC.ColumnsOffset.x = 0.0f;
	window->DC.CursorPos.x = IM_FLOOR( window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x );
}

// [2018-03: This is currently the only public API, while we are working on making BeginColumns/EndColumns user-facing]
void ImGui::Columns( int columns_count, const char* id, bool border )
{
	ImGuiWindow* window = GetCurrentWindow();
	IM_ASSERT( columns_count >= 1 );

	ImGuiColumnsFlags flags = ( border ? 0 : ImGuiColumnsFlags_NoBorder );
	//flags |= ImGuiColumnsFlags_NoPreserveWidths; // NB: Legacy behavior
	ImGuiColumns* columns = window->DC.CurrentColumns;
	if( columns != NULL && columns->Count == columns_count && columns->Flags == flags )
		return;

	if( columns != NULL )
		EndColumns();

	if( columns_count != 1 )
		BeginColumns( id, columns_count, flags );
}

//-------------------------------------------------------------------------

#endif // #ifndef IMGUI_DISABLE
```

`horizon/imgui/imstb_rectpack.hpp`:

```hpp
// [DEAR IMGUI]
// This is a slightly modified version of stb_rect_pack.h 1.00.
// Those changes would need to be pushed into nothings/stb:
// - Added STBRP__CDECL
// Grep for [DEAR IMGUI] to find the changes.

// stb_rect_pack.h - v1.00 - public domain - rectangle packing
// Sean Barrett 2014
//
// Useful for e.g. packing rectangular textures into an atlas.
// Does not do rotation.
//
// Not necessarily the awesomest packing method, but better than
// the totally naive one in stb_truetype (which is primarily what
// this is meant to replace).
//
// Has only had a few tests run, may have issues.
//
// More docs to come.
//
// No memory allocations; uses qsort() and assert() from stdlib.
// Can override those by defining STBRP_SORT and STBRP_ASSERT.
//
// This library currently uses the Skyline Bottom-Left algorithm.
//
// Please note: better rectangle packers are welcome! Please
// implement them to the same API, but with a different init
// function.
//
// Credits
//
//  Library
//    Sean Barrett
//  Minor features
//    Martins Mozeiko
//    github:IntellectualKitty
//    
//  Bugfixes / warning fixes
//    Jeremy Jaussaud
//    Fabian Giesen
//
// Version history:
//
//     1.00  (2019-02-25)  avoid small space waste; gracefully fail too-wide rectangles
//     0.99  (2019-02-07)  warning fixes
//     0.11  (2017-03-03)  return packing success/fail result
//     0.10  (2016-10-25)  remove cast-away-const to avoid warnings
//     0.09  (2016-08-27)  fix compiler warnings
//     0.08  (2015-09-13)  really fix bug with empty rects (w=0 or h=0)
//     0.07  (2015-09-13)  fix bug with empty rects (w=0 or h=0)
//     0.06  (2015-04-15)  added STBRP_SORT to allow replacing qsort
//     0.05:  added STBRP_ASSERT to allow replacing assert
//     0.04:  fixed minor bug in STBRP_LARGE_RECTS support
//     0.01:  initial release
//
// LICENSE
//
//   See end of file for license information.

//////////////////////////////////////////////////////////////////////////////
//
//       INCLUDE SECTION
//

#ifndef STB_INCLUDE_STB_RECT_PACK_H
#define STB_INCLUDE_STB_RECT_PACK_H

#define STB_RECT_PACK_VERSION  1

#ifdef STBRP_STATIC
#define STBRP_DEF static
#else
#define STBRP_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

	typedef struct stbrp_context stbrp_context;
	typedef struct stbrp_node    stbrp_node;
	typedef struct stbrp_rect    stbrp_rect;

#ifdef STBRP_LARGE_RECTS
	typedef int            stbrp_coord;
#else
	typedef unsigned short stbrp_coord;
#endif

	STBRP_DEF int stbrp_pack_rects( stbrp_context* context, stbrp_rect* rects, int num_rects );
	// Assign packed locations to rectangles. The rectangles are of type
	// 'stbrp_rect' defined below, stored in the array 'rects', and there
	// are 'num_rects' many of them.
	//
	// Rectangles which are successfully packed have the 'was_packed' flag
	// set to a non-zero value and 'x' and 'y' store the minimum location
	// on each axis (i.e. bottom-left in cartesian coordinates, top-left
	// if you imagine y increasing downwards). Rectangles which do not fit
	// have the 'was_packed' flag set to 0.
	//
	// You should not try to access the 'rects' array from another thread
	// while this function is running, as the function temporarily reorders
	// the array while it executes.
	//
	// To pack into another rectangle, you need to call stbrp_init_target
	// again. To continue packing into the same rectangle, you can call
	// this function again. Calling this multiple times with multiple rect
	// arrays will probably produce worse packing results than calling it
	// a single time with the full rectangle array, but the option is
	// available.
	//
	// The function returns 1 if all of the rectangles were successfully
	// packed and 0 otherwise.

	struct stbrp_rect
	{
		// reserved for your use:
		int            id;

		// input:
		stbrp_coord    w, h;

		// output:
		stbrp_coord    x, y;
		int            was_packed;  // non-zero if valid packing

	}; // 16 bytes, nominally


	STBRP_DEF void stbrp_init_target( stbrp_context* context, int width, int height, stbrp_node* nodes, int num_nodes );
	// Initialize a rectangle packer to:
	//    pack a rectangle that is 'width' by 'height' in dimensions
	//    using temporary storage provided by the array 'nodes', which is 'num_nodes' long
	//
	// You must call this function every time you start packing into a new target.
	//
	// There is no "shutdown" function. The 'nodes' memory must stay valid for
	// the following stbrp_pack_rects() call (or calls), but can be freed after
	// the call (or calls) finish.
	//
	// Note: to guarantee best results, either:
	//       1. make sure 'num_nodes' >= 'width'
	//   or  2. call stbrp_allow_out_of_mem() defined below with 'allow_out_of_mem = 1'
	//
	// If you don't do either of the above things, widths will be quantized to multiples
	// of small integers to guarantee the algorithm doesn't run out of temporary storage.
	//
	// If you do #2, then the non-quantized algorithm will be used, but the algorithm
	// may run out of temporary storage and be unable to pack some rectangles.

	STBRP_DEF void stbrp_setup_allow_out_of_mem( stbrp_context* context, int allow_out_of_mem );
	// Optionally call this function after init but before doing any packing to
	// change the handling of the out-of-temp-memory scenario, described above.
	// If you call init again, this will be reset to the default (false).


	STBRP_DEF void stbrp_setup_heuristic( stbrp_context* context, int heuristic );
	// Optionally select which packing heuristic the library should use. Different
	// heuristics will produce better/worse results for different data sets.
	// If you call init again, this will be reset to the default.

	enum
	{
		STBRP_HEURISTIC_Skyline_default = 0,
		STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,
		STBRP_HEURISTIC_Skyline_BF_sortHeight
	};


	//////////////////////////////////////////////////////////////////////////////
	//
	// the details of the following structures don't matter to you, but they must
	// be visible so you can handle the memory allocations for them

	struct stbrp_node
	{
		stbrp_coord  x, y;
		stbrp_node* next;
	};

	struct stbrp_context
	{
		int width;
		int height;
		int align;
		int init_mode;
		int heuristic;
		int num_nodes;
		stbrp_node* active_head;
		stbrp_node* free_head;
		stbrp_node extra[ 2 ]; // we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'
	};

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////
//
//     IMPLEMENTATION SECTION
//

#ifdef STB_RECT_PACK_IMPLEMENTATION
#ifndef STBRP_SORT
#include <stdlib.h>
#define STBRP_SORT qsort
#endif

#ifndef STBRP_ASSERT
#include <assert.h>
#define STBRP_ASSERT assert
#endif

// [DEAR IMGUI] Added STBRP__CDECL
#ifdef _MSC_VER
#define STBRP__NOTUSED(v)  (void)(v)
#define STBRP__CDECL __cdecl
#else
#define STBRP__NOTUSED(v)  (void)sizeof(v)
#define STBRP__CDECL
#endif

enum
{
	STBRP__INIT_skyline = 1
};

STBRP_DEF void stbrp_setup_heuristic( stbrp_context* context, int heuristic )
{
	switch( context->init_mode )
	{
		case STBRP__INIT_skyline:
			STBRP_ASSERT( heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight || heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight );
			context->heuristic = heuristic;
			break;
		default:
			STBRP_ASSERT( 0 );
	}
}

STBRP_DEF void stbrp_setup_allow_out_of_mem( stbrp_context* context, int allow_out_of_mem )
{
	if( allow_out_of_mem )
		// if it's ok to run out of memory, then don't bother aligning them;
		// this gives better packing, but may fail due to OOM (even though
		// the rectangles easily fit). @TODO a smarter approach would be to only
		// quantize once we've hit OOM, then we could get rid of this parameter.
		context->align = 1;
	else
	{
		// if it's not ok to run out of memory, then quantize the widths
		// so that num_nodes is always enough nodes.
		//
		// I.e. num_nodes * align >= width
		//                  align >= width / num_nodes
		//                  align = ceil(width/num_nodes)

		context->align = ( context->width + context->num_nodes - 1 ) / context->num_nodes;
	}
}

STBRP_DEF void stbrp_init_target( stbrp_context* context, int width, int height, stbrp_node* nodes, int num_nodes )
{
	int i;
#ifndef STBRP_LARGE_RECTS
	STBRP_ASSERT( width <= 0xffff && height <= 0xffff );
#endif

	for( i = 0; i < num_nodes - 1; ++i )
		nodes[ i ].next = &nodes[ i + 1 ];
	nodes[ i ].next = NULL;
	context->init_mode = STBRP__INIT_skyline;
	context->heuristic = STBRP_HEURISTIC_Skyline_default;
	context->free_head = &nodes[ 0 ];
	context->active_head = &context->extra[ 0 ];
	context->width = width;
	context->height = height;
	context->num_nodes = num_nodes;
	stbrp_setup_allow_out_of_mem( context, 0 );

	// node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
	context->extra[ 0 ].x = 0;
	context->extra[ 0 ].y = 0;
	context->extra[ 0 ].next = &context->extra[ 1 ];
	context->extra[ 1 ].x = ( stbrp_coord )width;
#ifdef STBRP_LARGE_RECTS
	context->extra[ 1 ].y = ( 1 << 30 );
#else
	context->extra[ 1 ].y = 65535;
#endif
	context->extra[ 1 ].next = NULL;
}

// find minimum y position if it starts at x1
static int stbrp__skyline_find_min_y( stbrp_context* c, stbrp_node* first, int x0, int width, int* pwaste )
{
	stbrp_node* node = first;
	int x1 = x0 + width;
	int min_y, visited_width, waste_area;

	STBRP__NOTUSED( c );

	STBRP_ASSERT( first->x <= x0 );

#if 0
	// skip in case we're past the node
	while( node->next->x <= x0 )
		++node;
#else
	STBRP_ASSERT( node->next->x > x0 ); // we ended up handling this in the caller for efficiency
#endif

	STBRP_ASSERT( node->x <= x0 );

	min_y = 0;
	waste_area = 0;
	visited_width = 0;
	while( node->x < x1 )
	{
		if( node->y > min_y )
		{
			// raise min_y higher.
			// we've accounted for all waste up to min_y,
			// but we'll now add more waste for everything we've visted
			waste_area += visited_width * ( node->y - min_y );
			min_y = node->y;
			// the first time through, visited_width might be reduced
			if( node->x < x0 )
				visited_width += node->next->x - x0;
			else
				visited_width += node->next->x - node->x;
		}
		else
		{
			// add waste area
			int under_width = node->next->x - node->x;
			if( under_width + visited_width > width )
				under_width = width - visited_width;
			waste_area += under_width * ( min_y - node->y );
			visited_width += under_width;
		}
		node = node->next;
	}

	*pwaste = waste_area;
	return min_y;
}

typedef struct
{
	int x, y;
	stbrp_node** prev_link;
} stbrp__findresult;

static stbrp__findresult stbrp__skyline_find_best_pos( stbrp_context* c, int width, int height )
{
	int best_waste = ( 1 << 30 ), best_x, best_y = ( 1 << 30 );
	stbrp__findresult fr;
	stbrp_node** prev, * node, * tail, ** best = NULL;

	// align to multiple of c->align
	width = ( width + c->align - 1 );
	width -= width % c->align;
	STBRP_ASSERT( width % c->align == 0 );

	// if it can't possibly fit, bail immediately
	if( width > c->width || height > c->height )
	{
		fr.prev_link = NULL;
		fr.x = fr.y = 0;
		return fr;
	}

	node = c->active_head;
	prev = &c->active_head;
	while( node->x + width <= c->width )
	{
		int y, waste;
		y = stbrp__skyline_find_min_y( c, node, node->x, width, &waste );
		if( c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight )
		{ // actually just want to test BL
// bottom left
			if( y < best_y )
			{
				best_y = y;
				best = prev;
			}
		}
		else
		{
			// best-fit
			if( y + height <= c->height )
			{
				// can only use it if it first vertically
				if( y < best_y || ( y == best_y && waste < best_waste ) )
				{
					best_y = y;
					best_waste = waste;
					best = prev;
				}
			}
		}
		prev = &node->next;
		node = node->next;
	}

	best_x = ( best == NULL ) ? 0 : ( *best )->x;

	// if doing best-fit (BF), we also have to try aligning right edge to each node position
	//
	// e.g, if fitting
	//
	//     ____________________
	//    |____________________|
	//
	//            into
	//
	//   |                         |
	//   |             ____________|
	//   |____________|
	//
	// then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
	//
	// This makes BF take about 2x the time

	if( c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight )
	{
		tail = c->active_head;
		node = c->active_head;
		prev = &c->active_head;
		// find first node that's admissible
		while( tail->x < width )
			tail = tail->next;
		while( tail )
		{
			int xpos = tail->x - width;
			int y, waste;
			STBRP_ASSERT( xpos >= 0 );
			// find the left position that matches this
			while( node->next->x <= xpos )
			{
				prev = &node->next;
				node = node->next;
			}
			STBRP_ASSERT( node->next->x > xpos && node->x <= xpos );
			y = stbrp__skyline_find_min_y( c, node, xpos, width, &waste );
			if( y + height <= c->height )
			{
				if( y <= best_y )
				{
					if( y < best_y || waste < best_waste || ( waste == best_waste && xpos < best_x ) )
					{
						best_x = xpos;
						STBRP_ASSERT( y <= best_y );
						best_y = y;
						best_waste = waste;
						best = prev;
					}
				}
			}
			tail = tail->next;
		}
	}

	fr.prev_link = best;
	fr.x = best_x;
	fr.y = best_y;
	return fr;
}

static stbrp__findresult stbrp__skyline_pack_rectangle( stbrp_context* context, int width, int height )
{
	// find best position according to heuristic
	stbrp__findresult res = stbrp__skyline_find_best_pos( context, width, height );
	stbrp_node* node, * cur;

	// bail if:
	//    1. it failed
	//    2. the best node doesn't fit (we don't always check this)
	//    3. we're out of memory
	if( res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL )
	{
		res.prev_link = NULL;
		return res;
	}

	// on success, create new node
	node = context->free_head;
	node->x = ( stbrp_coord )res.x;
	node->y = ( stbrp_coord )( res.y + height );

	context->free_head = node->next;

	// insert the new node into the right starting point, and
	// let 'cur' point to the remaining nodes needing to be
	// stiched back in

	cur = *res.prev_link;
	if( cur->x < res.x )
	{
		// preserve the existing one, so start testing with the next one
		stbrp_node* next = cur->next;
		cur->next = node;
		cur = next;
	}
	else
	{
		*res.prev_link = node;
	}

	// from here, traverse cur and free the nodes, until we get to one
	// that shouldn't be freed
	while( cur->next && cur->next->x <= res.x + width )
	{
		stbrp_node* next = cur->next;
		// move the current node to the free list
		cur->next = context->free_head;
		context->free_head = cur;
		cur = next;
	}

	// stitch the list back in
	node->next = cur;

	if( cur->x < res.x + width )
		cur->x = ( stbrp_coord )( res.x + width );

#ifdef _DEBUG
	cur = context->active_head;
	while( cur->x < context->width )
	{
		STBRP_ASSERT( cur->x < cur->next->x );
		cur = cur->next;
	}
	STBRP_ASSERT( cur->next == NULL );

	{
		int count = 0;
		cur = context->active_head;
		while( cur )
		{
			cur = cur->next;
			++count;
		}
		cur = context->free_head;
		while( cur )
		{
			cur = cur->next;
			++count;
		}
		STBRP_ASSERT( count == context->num_nodes + 2 );
	}
#endif

	return res;
}

// [DEAR IMGUI] Added STBRP__CDECL
static int STBRP__CDECL rect_height_compare( const void* a, const void* b )
{
	const stbrp_rect* p = ( const stbrp_rect* )a;
	const stbrp_rect* q = ( const stbrp_rect* )b;
	if( p->h > q->h )
		return -1;
	if( p->h < q->h )
		return  1;
	return ( p->w > q->w ) ? -1 : ( p->w < q->w );
}

// [DEAR IMGUI] Added STBRP__CDECL
static int STBRP__CDECL rect_original_order( const void* a, const void* b )
{
	const stbrp_rect* p = ( const stbrp_rect* )a;
	const stbrp_rect* q = ( const stbrp_rect* )b;
	return ( p->was_packed < q->was_packed ) ? -1 : ( p->was_packed > q->was_packed );
}

#ifdef STBRP_LARGE_RECTS
#define STBRP__MAXVAL  0xffffffff
#else
#define STBRP__MAXVAL  0xffff
#endif

STBRP_DEF int stbrp_pack_rects( stbrp_context* context, stbrp_rect* rects, int num_rects )
{
	int i, all_rects_packed = 1;

	// we use the 'was_packed' field internally to allow sorting/unsorting
	for( i = 0; i < num_rects; ++i )
	{
		rects[ i ].was_packed = i;
	}

	// sort according to heuristic
	STBRP_SORT( rects, num_rects, sizeof( rects[ 0 ] ), rect_height_compare );

	for( i = 0; i < num_rects; ++i )
	{
		if( rects[ i ].w == 0 || rects[ i ].h == 0 )
		{
			rects[ i ].x = rects[ i ].y = 0;  // empty rect needs no space
		}
		else
		{
			stbrp__findresult fr = stbrp__skyline_pack_rectangle( context, rects[ i ].w, rects[ i ].h );
			if( fr.prev_link )
			{
				rects[ i ].x = ( stbrp_coord )fr.x;
				rects[ i ].y = ( stbrp_coord )fr.y;
			}
			else
			{
				rects[ i ].x = rects[ i ].y = STBRP__MAXVAL;
			}
		}
	}

	// unsort
	STBRP_SORT( rects, num_rects, sizeof( rects[ 0 ] ), rect_original_order );

	// set was_packed flags and all_rects_packed status
	for( i = 0; i < num_rects; ++i )
	{
		rects[ i ].was_packed = !( rects[ i ].x == STBRP__MAXVAL && rects[ i ].y == STBRP__MAXVAL );
		if( !rects[ i ].was_packed )
			all_rects_packed = 0;
	}

	// return the all_rects_packed status
	return all_rects_packed;
}
#endif

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/
```

`horizon/imgui/imstb_textedit.hpp`:

```hpp
// [DEAR IMGUI]
// This is a slightly modified version of stb_textedit.h 1.13. 
// Those changes would need to be pushed into nothings/stb:
// - Fix in stb_textedit_discard_redo (see https://github.com/nothings/stb/issues/321)
// Grep for [DEAR IMGUI] to find the changes.

// stb_textedit.h - v1.13  - public domain - Sean Barrett
// Development of this library was sponsored by RAD Game Tools
//
// This C header file implements the guts of a multi-line text-editing
// widget; you implement display, word-wrapping, and low-level string
// insertion/deletion, and stb_textedit will map user inputs into
// insertions & deletions, plus updates to the cursor position,
// selection state, and undo state.
//
// It is intended for use in games and other systems that need to build
// their own custom widgets and which do not have heavy text-editing
// requirements (this library is not recommended for use for editing large
// texts, as its performance does not scale and it has limited undo).
//
// Non-trivial behaviors are modelled after Windows text controls.
// 
//
// LICENSE
//
// See end of file for license information.
//
//
// DEPENDENCIES
//
// Uses the C runtime function 'memmove', which you can override
// by defining STB_TEXTEDIT_memmove before the implementation.
// Uses no other functions. Performs no runtime allocations.
//
//
// VERSION HISTORY
//
//   1.13 (2019-02-07) fix bug in undo size management
//   1.12 (2018-01-29) user can change STB_TEXTEDIT_KEYTYPE, fix redo to avoid crash
//   1.11 (2017-03-03) fix HOME on last line, dragging off single-line textfield
//   1.10 (2016-10-25) supress warnings about casting away const with -Wcast-qual
//   1.9  (2016-08-27) customizable move-by-word
//   1.8  (2016-04-02) better keyboard handling when mouse button is down
//   1.7  (2015-09-13) change y range handling in case baseline is non-0
//   1.6  (2015-04-15) allow STB_TEXTEDIT_memmove
//   1.5  (2014-09-10) add support for secondary keys for OS X
//   1.4  (2014-08-17) fix signed/unsigned warnings
//   1.3  (2014-06-19) fix mouse clicking to round to nearest char boundary
//   1.2  (2014-05-27) fix some RAD types that had crept into the new code
//   1.1  (2013-12-15) move-by-word (requires STB_TEXTEDIT_IS_SPACE )
//   1.0  (2012-07-26) improve documentation, initial public release
//   0.3  (2012-02-24) bugfixes, single-line mode; insert mode
//   0.2  (2011-11-28) fixes to undo/redo
//   0.1  (2010-07-08) initial version
//
// ADDITIONAL CONTRIBUTORS
//
//   Ulf Winklemann: move-by-word in 1.1
//   Fabian Giesen: secondary key inputs in 1.5
//   Martins Mozeiko: STB_TEXTEDIT_memmove in 1.6
//
//   Bugfixes:
//      Scott Graham
//      Daniel Keller
//      Omar Cornut
//      Dan Thompson
//
// USAGE
//
// This file behaves differently depending on what symbols you define
// before including it.
//
//
// Header-file mode:
//
//   If you do not define STB_TEXTEDIT_IMPLEMENTATION before including this,
//   it will operate in "header file" mode. In this mode, it declares a
//   single public symbol, STB_TexteditState, which encapsulates the current
//   state of a text widget (except for the string, which you will store
//   separately).
//
//   To compile in this mode, you must define STB_TEXTEDIT_CHARTYPE to a
//   primitive type that defines a single character (e.g. char, wchar_t, etc).
//
//   To save space or increase undo-ability, you can optionally define the
//   following things that are used by the undo system:
//
//      STB_TEXTEDIT_POSITIONTYPE         small int type encoding a valid cursor position
//      STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//      STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
//   If you don't define these, they are set to permissive types and
//   moderate sizes. The undo system does no memory allocations, so
//   it grows STB_TexteditState by the worst-case storage which is (in bytes):
//
//        [4 + 3 * sizeof(STB_TEXTEDIT_POSITIONTYPE)] * STB_TEXTEDIT_UNDOSTATE_COUNT
//      +          sizeof(STB_TEXTEDIT_CHARTYPE)      * STB_TEXTEDIT_UNDOCHAR_COUNT
//
//
// Implementation mode:
//
//   If you define STB_TEXTEDIT_IMPLEMENTATION before including this, it
//   will compile the implementation of the text edit widget, depending
//   on a large number of symbols which must be defined before the include.
//
//   The implementation is defined only as static functions. You will then
//   need to provide your own APIs in the same file which will access the
//   static functions.
//
//   The basic concept is that you provide a "string" object which
//   behaves like an array of characters. stb_textedit uses indices to
//   refer to positions in the string, implicitly representing positions
//   in the displayed textedit. This is true for both plain text and
//   rich text; even with rich text stb_truetype interacts with your
//   code as if there was an array of all the displayed characters.
//
// Symbols that must be the same in header-file and implementation mode:
//
//     STB_TEXTEDIT_CHARTYPE             the character type
//     STB_TEXTEDIT_POSITIONTYPE         small type that is a valid cursor position
//     STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//     STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
// Symbols you must define for implementation mode:
//
//    STB_TEXTEDIT_STRING               the type of object representing a string being edited,
//                                      typically this is a wrapper object with other data you need
//
//    STB_TEXTEDIT_STRINGLEN(obj)       the length of the string (ideally O(1))
//    STB_TEXTEDIT_LAYOUTROW(&r,obj,n)  returns the results of laying out a line of characters
//                                        starting from character #n (see discussion below)
//    STB_TEXTEDIT_GETWIDTH(obj,n,i)    returns the pixel delta from the xpos of the i'th character
//                                        to the xpos of the i+1'th char for a line of characters
//                                        starting at character #n (i.e. accounts for kerning
//                                        with previous char)
//    STB_TEXTEDIT_KEYTOTEXT(k)         maps a keyboard input to an insertable character
//                                        (return type is int, -1 means not valid to insert)
//    STB_TEXTEDIT_GETCHAR(obj,i)       returns the i'th character of obj, 0-based
//    STB_TEXTEDIT_NEWLINE              the character returned by _GETCHAR() we recognize
//                                        as manually wordwrapping for end-of-line positioning
//
//    STB_TEXTEDIT_DELETECHARS(obj,i,n)      delete n characters starting at i
//    STB_TEXTEDIT_INSERTCHARS(obj,i,c*,n)   insert n characters at i (pointed to by STB_TEXTEDIT_CHARTYPE*)
//
//    STB_TEXTEDIT_K_SHIFT       a power of two that is or'd in to a keyboard input to represent the shift key
//
//    STB_TEXTEDIT_K_LEFT        keyboard input to move cursor left
//    STB_TEXTEDIT_K_RIGHT       keyboard input to move cursor right
//    STB_TEXTEDIT_K_UP          keyboard input to move cursor up
//    STB_TEXTEDIT_K_DOWN        keyboard input to move cursor down
//    STB_TEXTEDIT_K_LINESTART   keyboard input to move cursor to start of line  // e.g. HOME
//    STB_TEXTEDIT_K_LINEEND     keyboard input to move cursor to end of line    // e.g. END
//    STB_TEXTEDIT_K_TEXTSTART   keyboard input to move cursor to start of text  // e.g. ctrl-HOME
//    STB_TEXTEDIT_K_TEXTEND     keyboard input to move cursor to end of text    // e.g. ctrl-END
//    STB_TEXTEDIT_K_DELETE      keyboard input to delete selection or character under cursor
//    STB_TEXTEDIT_K_BACKSPACE   keyboard input to delete selection or character left of cursor
//    STB_TEXTEDIT_K_UNDO        keyboard input to perform undo
//    STB_TEXTEDIT_K_REDO        keyboard input to perform redo
//
// Optional:
//    STB_TEXTEDIT_K_INSERT              keyboard input to toggle insert mode
//    STB_TEXTEDIT_IS_SPACE(ch)          true if character is whitespace (e.g. 'isspace'),
//                                          required for default WORDLEFT/WORDRIGHT handlers
//    STB_TEXTEDIT_MOVEWORDLEFT(obj,i)   custom handler for WORDLEFT, returns index to move cursor to
//    STB_TEXTEDIT_MOVEWORDRIGHT(obj,i)  custom handler for WORDRIGHT, returns index to move cursor to
//    STB_TEXTEDIT_K_WORDLEFT            keyboard input to move cursor left one word // e.g. ctrl-LEFT
//    STB_TEXTEDIT_K_WORDRIGHT           keyboard input to move cursor right one word // e.g. ctrl-RIGHT
//    STB_TEXTEDIT_K_LINESTART2          secondary keyboard input to move cursor to start of line
//    STB_TEXTEDIT_K_LINEEND2            secondary keyboard input to move cursor to end of line
//    STB_TEXTEDIT_K_TEXTSTART2          secondary keyboard input to move cursor to start of text
//    STB_TEXTEDIT_K_TEXTEND2            secondary keyboard input to move cursor to end of text
//
// Todo:
//    STB_TEXTEDIT_K_PGUP        keyboard input to move cursor up a page
//    STB_TEXTEDIT_K_PGDOWN      keyboard input to move cursor down a page
//
// Keyboard input must be encoded as a single integer value; e.g. a character code
// and some bitflags that represent shift states. to simplify the interface, SHIFT must
// be a bitflag, so we can test the shifted state of cursor movements to allow selection,
// i.e. (STB_TEXTED_K_RIGHT|STB_TEXTEDIT_K_SHIFT) should be shifted right-arrow.
//
// You can encode other things, such as CONTROL or ALT, in additional bits, and
// then test for their presence in e.g. STB_TEXTEDIT_K_WORDLEFT. For example,
// my Windows implementations add an additional CONTROL bit, and an additional KEYDOWN
// bit. Then all of the STB_TEXTEDIT_K_ values bitwise-or in the KEYDOWN bit,
// and I pass both WM_KEYDOWN and WM_CHAR events to the "key" function in the
// API below. The control keys will only match WM_KEYDOWN events because of the
// keydown bit I add, and STB_TEXTEDIT_KEYTOTEXT only tests for the KEYDOWN
// bit so it only decodes WM_CHAR events.
//
// STB_TEXTEDIT_LAYOUTROW returns information about the shape of one displayed
// row of characters assuming they start on the i'th character--the width and
// the height and the number of characters consumed. This allows this library
// to traverse the entire layout incrementally. You need to compute word-wrapping
// here.
//
// Each textfield keeps its own insert mode state, which is not how normal
// applications work. To keep an app-wide insert mode, update/copy the
// "insert_mode" field of STB_TexteditState before/after calling API functions.
//
// API
//
//    void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)
//
//    void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    int  stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
//    int  stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)
//    void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXEDIT_KEYTYPE key)
//
//    Each of these functions potentially updates the string and updates the
//    state.
//
//      initialize_state:
//          set the textedit state to a known good default state when initially
//          constructing the textedit.
//
//      click:
//          call this with the mouse x,y on a mouse down; it will update the cursor
//          and reset the selection start/end to the cursor point. the x,y must
//          be relative to the text widget, with (0,0) being the top left.
//     
//      drag:
//          call this with the mouse x,y on a mouse drag/up; it will update the
//          cursor and the selection end point
//     
//      cut:
//          call this to delete the current selection; returns true if there was
//          one. you should FIRST copy the current selection to the system paste buffer.
//          (To copy, just copy the current selection out of the string yourself.)
//     
//      paste:
//          call this to paste text at the current cursor point or over the current
//          selection if there is one.
//     
//      key:
//          call this for keyboard inputs sent to the textfield. you can use it
//          for "key down" events or for "translated" key events. if you need to
//          do both (as in Win32), or distinguish Unicode characters from control
//          inputs, set a high bit to distinguish the two; then you can define the
//          various definitions like STB_TEXTEDIT_K_LEFT have the is-key-event bit
//          set, and make STB_TEXTEDIT_KEYTOCHAR check that the is-key-event bit is
//          clear. STB_TEXTEDIT_KEYTYPE defaults to int, but you can #define it to
//          anything other type you wante before including.
//
//     
//   When rendering, you can read the cursor position and selection state from
//   the STB_TexteditState.
//
//
// Notes:
//
// This is designed to be usable in IMGUI, so it allows for the possibility of
// running in an IMGUI that has NOT cached the multi-line layout. For this
// reason, it provides an interface that is compatible with computing the
// layout incrementally--we try to make sure we make as few passes through
// as possible. (For example, to locate the mouse pointer in the text, we
// could define functions that return the X and Y positions of characters
// and binary search Y and then X, but if we're doing dynamic layout this
// will run the layout algorithm many times, so instead we manually search
// forward in one pass. Similar logic applies to e.g. up-arrow and
// down-arrow movement.)
//
// If it's run in a widget that *has* cached the layout, then this is less
// efficient, but it's not horrible on modern computers. But you wouldn't
// want to edit million-line files with it.


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Header-file mode
////
////

#ifndef INCLUDE_STB_TEXTEDIT_H
#define INCLUDE_STB_TEXTEDIT_H

////////////////////////////////////////////////////////////////////////
//
//     STB_TexteditState
//
// Definition of STB_TexteditState which you should store
// per-textfield; it includes cursor position, selection state,
// and undo state.
//

#ifndef STB_TEXTEDIT_UNDOSTATECOUNT
#define STB_TEXTEDIT_UNDOSTATECOUNT   99
#endif
#ifndef STB_TEXTEDIT_UNDOCHARCOUNT
#define STB_TEXTEDIT_UNDOCHARCOUNT   999
#endif
#ifndef STB_TEXTEDIT_CHARTYPE
#define STB_TEXTEDIT_CHARTYPE        int
#endif
#ifndef STB_TEXTEDIT_POSITIONTYPE
#define STB_TEXTEDIT_POSITIONTYPE    int
#endif

typedef struct
{
	// private data
	STB_TEXTEDIT_POSITIONTYPE  where;
	STB_TEXTEDIT_POSITIONTYPE  insert_length;
	STB_TEXTEDIT_POSITIONTYPE  delete_length;
	int                        char_storage;
} StbUndoRecord;

typedef struct
{
	// private data
	StbUndoRecord          undo_rec[ STB_TEXTEDIT_UNDOSTATECOUNT ];
	STB_TEXTEDIT_CHARTYPE  undo_char[ STB_TEXTEDIT_UNDOCHARCOUNT ];
	short undo_point, redo_point;
	int undo_char_point, redo_char_point;
} StbUndoState;

typedef struct
{
	/////////////////////
	//
	// public data
	//

	int cursor;
	// position of the text cursor within the string

	int select_start;          // selection start point
	int select_end;
	// selection start and end point in characters; if equal, no selection.
	// note that start may be less than or greater than end (e.g. when
	// dragging the mouse, start is where the initial click was, and you
	// can drag in either direction)

	unsigned char insert_mode;
	// each textfield keeps its own insert mode state. to keep an app-wide
	// insert mode, copy this value in/out of the app state

	/////////////////////
	//
	// private data
	//
	unsigned char cursor_at_end_of_line; // not implemented yet
	unsigned char initialized;
	unsigned char has_preferred_x;
	unsigned char single_line;
	unsigned char padding1, padding2, padding3;
	float preferred_x; // this determines where the cursor up/down tries to seek to along x
	StbUndoState undostate;
} STB_TexteditState;


////////////////////////////////////////////////////////////////////////
//
//     StbTexteditRow
//
// Result of layout query, used by stb_textedit to determine where
// the text in each row is.

// result of layout query
typedef struct
{
	float x0, x1;             // starting x location, end x location (allows for align=right, etc)
	float baseline_y_delta;  // position of baseline relative to previous row's baseline
	float ymin, ymax;         // height of row above and below baseline
	int num_chars;
} StbTexteditRow;
#endif //INCLUDE_STB_TEXTEDIT_H


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Implementation mode
////
////


// implementation isn't include-guarded, since it might have indirectly
// included just the "header" portion
#ifdef STB_TEXTEDIT_IMPLEMENTATION

#ifndef STB_TEXTEDIT_memmove
#include <string.h>
#define STB_TEXTEDIT_memmove memmove
#endif


/////////////////////////////////////////////////////////////////////////////
//
//      Mouse input handling
//

// traverse the layout to locate the nearest character to a display position
static int stb_text_locate_coord( STB_TEXTEDIT_STRING* str, float x, float y )
{
	StbTexteditRow r;
	int n = STB_TEXTEDIT_STRINGLEN( str );
	float base_y = 0, prev_x;
	int i = 0, k;

	r.x0 = r.x1 = 0;
	r.ymin = r.ymax = 0;
	r.num_chars = 0;

	// search rows to find one that straddles 'y'
	while( i < n )
	{
		STB_TEXTEDIT_LAYOUTROW( &r, str, i );
		if( r.num_chars <= 0 )
			return n;

		if( i == 0 && y < base_y + r.ymin )
			return 0;

		if( y < base_y + r.ymax )
			break;

		i += r.num_chars;
		base_y += r.baseline_y_delta;
	}

	// below all text, return 'after' last character
	if( i >= n )
		return n;

	// check if it's before the beginning of the line
	if( x < r.x0 )
		return i;

	// check if it's before the end of the line
	if( x < r.x1 )
	{
		// search characters in row for one that straddles 'x'
		prev_x = r.x0;
		for( k = 0; k < r.num_chars; ++k )
		{
			float w = STB_TEXTEDIT_GETWIDTH( str, i, k );
			if( x < prev_x + w )
			{
				if( x < prev_x + w / 2 )
					return k + i;
				else
					return k + i + 1;
			}
			prev_x += w;
		}
		// shouldn't happen, but if it does, fall through to end-of-line case
	}

	// if the last character is a newline, return that. otherwise return 'after' the last character
	if( STB_TEXTEDIT_GETCHAR( str, i + r.num_chars - 1 ) == STB_TEXTEDIT_NEWLINE )
		return i + r.num_chars - 1;
	else
		return i + r.num_chars;
}

// API click: on mouse down, move the cursor to the clicked location, and reset the selection
static void stb_textedit_click( STB_TEXTEDIT_STRING* str, STB_TexteditState* state, float x, float y )
{
	// In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
	// goes off the top or bottom of the text
	if( state->single_line )
	{
		StbTexteditRow r;
		STB_TEXTEDIT_LAYOUTROW( &r, str, 0 );
		y = r.ymin;
	}

	state->cursor = stb_text_locate_coord( str, x, y );
	state->select_start = state->cursor;
	state->select_end = state->cursor;
	state->has_preferred_x = 0;
}

// API drag: on mouse drag, move the cursor and selection endpoint to the clicked location
static void stb_textedit_drag( STB_TEXTEDIT_STRING* str, STB_TexteditState* state, float x, float y )
{
	int p = 0;

	// In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
	// goes off the top or bottom of the text
	if( state->single_line )
	{
		StbTexteditRow r;
		STB_TEXTEDIT_LAYOUTROW( &r, str, 0 );
		y = r.ymin;
	}

	if( state->select_start == state->select_end )
		state->select_start = state->cursor;

	p = stb_text_locate_coord( str, x, y );
	state->cursor = state->select_end = p;
}

/////////////////////////////////////////////////////////////////////////////
//
//      Keyboard input handling
//

// forward declarations
static void stb_text_undo( STB_TEXTEDIT_STRING* str, STB_TexteditState* state );
static void stb_text_redo( STB_TEXTEDIT_STRING* str, STB_TexteditState* state );
static void stb_text_makeundo_delete( STB_TEXTEDIT_STRING* str, STB_TexteditState* state, int where, int length );
static void stb_text_makeundo_insert( STB_TexteditState* state, int where, int length );
static void stb_text_makeundo_replace( STB_TEXTEDIT_STRING* str, STB_TexteditState* state, int where, int old_length, int new_length );

typedef struct
{
	float x, y;    // position of n'th character
	float height; // height of line
	int first_char, length; // first char of row, and length
	int prev_first;  // first char of previous row
} StbFindState;

// find the x/y location of a character, and remember info about the previous row in
// case we get a move-up event (for page up, we'll have to rescan)
static void stb_textedit_find_charpos( StbFindState* find, STB_TEXTEDIT_STRING* str, int n, int single_line )
{
	StbTexteditRow r;
	int prev_start = 0;
	int z = STB_TEXTEDIT_STRINGLEN( str );
	int i = 0, first;

	if( n == z )
	{
		// if it's at the end, then find the last line -- simpler than trying to
		// explicitly handle this case in the regular code
		if( single_line )
		{
			STB_TEXTEDIT_LAYOUTROW( &r, str, 0 );
			find->y = 0;
			find->first_char = 0;
			find->length = z;
			find->height = r.ymax - r.ymin;
			find->x = r.x1;
		}
		else
		{
			find->y = 0;
			find->x = 0;
			find->height = 1;
			while( i < z )
			{
				STB_TEXTEDIT_LAYOUTROW( &r, str, i );
				prev_start = i;
				i += r.num_chars;
			}
			find->first_char = i;
			find->length = 0;
			find->prev_first = prev_start;
		}
		return;
	}

	// search rows to find the one that straddles character n
	find->y = 0;

	for( ;;)
	{
		STB_TEXTEDIT_LAYOUTROW( &r, str, i );
		if( n < i + r.num_chars )
			break;
		prev_start = i;
		i += r.num_chars;
		find->y += r.baseline_y_delta;
	}

	find->first_char = first = i;
	find->length = r.num_chars;
	find->height = r.ymax - r.ymin;
	find->prev_first = prev_start;

	// now scan to find xpos
	find->x = r.x0;
	for( i = 0; first + i < n; ++i )
		find->x += STB_TEXTEDIT_GETWIDTH( str, first, i );
}

#define STB_TEXT_HAS_SELECTION(s)   ((s)->select_start != (s)->select_end)

// make the selection/cursor state valid if client altered the string
static void stb_textedit_clamp( STB_TEXTEDIT_STRING* str, STB_TexteditState* state )
{
	int n = STB_TEXTEDIT_STRINGLEN( str );
	if( STB_TEXT_HAS_SELECTION( state ) )
	{
		if( state->select_start > n ) state->select_start = n;
		if( state->select_end > n ) state->select_end = n;
		// if clamping forced them to be equal, move the cursor to match
		if( state->select_start == state->select_end )
			state->cursor = state->select_start;
	}
	if( state->cursor > n ) state->cursor = n;
}

// delete characters while updating undo
static void stb_textedit_delete( STB_TEXTEDIT_STRING* str, STB_TexteditState* state, int where, int len )
{
	stb_text_makeundo_delete( str, state, where, len );
	STB_TEXTEDIT_DELETECHARS( str, where, len );
	state->has_preferred_x = 0;
}

// delete the section
static void stb_textedit_delete_selection( STB_TEXTEDIT_STRING* str, STB_TexteditState* state )
{
	stb_textedit_clamp( str, state );
	if( STB_TEXT_HAS_SELECTION( state ) )
	{
		if( state->select_start < state->select_end )
		{
			stb_textedit_delete( str, state, state->select_start, state->select_end - state->select_start );
			state->select_end = state->cursor = state->select_start;
		}
		else
		{
			stb_textedit_delete( str, state, state->select_end, state->select_start - state->select_end );
			state->select_start = state->cursor = state->select_end;
		}
		state->has_preferred_x = 0;
	}
}

// canoncialize the selection so start <= end
static void stb_textedit_sortselection( STB_TexteditState* state )
{
	if( state->select_end < state->select_start )
	{
		int temp = state->select_end;
		state->select_end = state->select_start;
		state->select_start = temp;
	}
}

// move cursor to first character of selection
static void stb_textedit_move_to_first( STB_TexteditState* state )
{
	if( STB_TEXT_HAS_SELECTION( state ) )
	{
		stb_textedit_sortselection( state );
		state->cursor = state->select_start;
		state->select_end = state->select_start;
		state->has_preferred_x = 0;
	}
}

// move cursor to last character of selection
static void stb_textedit_move_to_last( STB_TEXTEDIT_STRING* str, STB_TexteditState* state )
{
	if( STB_TEXT_HAS_SELECTION( state ) )
	{
		stb_textedit_sortselection( state );
		stb_textedit_clamp( str, state );
		state->cursor = state->select_end;
		state->select_start = state->select_end;
		state->has_preferred_x = 0;
	}
}

#ifdef STB_TEXTEDIT_IS_SPACE
static int is_word_boundary( STB_TEXTEDIT_STRING* str, int idx )
{
	return idx > 0 ? ( STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR( str, idx - 1 ) ) && !STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR( str, idx ) ) ) : 1;
}

#ifndef STB_TEXTEDIT_MOVEWORDLEFT
static int stb_textedit_move_to_word_previous( STB_TEXTEDIT_STRING* str, int c )
{
	--c; // always move at least one character
	while( c >= 0 && !is_word_boundary( str, c ) )
		--c;

	if( c < 0 )
		c = 0;

	return c;
}
#define STB_TEXTEDIT_MOVEWORDLEFT stb_textedit_move_to_word_previous
#endif

#ifndef STB_TEXTEDIT_MOVEWORDRIGHT
static int stb_textedit_move_to_word_next( STB_TEXTEDIT_STRING* str, int c )
{
	const int len = STB_TEXTEDIT_STRINGLEN( str );
	++c; // always move at least one character
	while( c < len && !is_word_boundary( str, c ) )
		++c;

	if( c > len )
		c = len;

	return c;
}
#define STB_TEXTEDIT_MOVEWORDRIGHT stb_textedit_move_to_word_next
#endif

#endif

// update selection and cursor to match each other
static void stb_textedit_prep_selection_at_cursor( STB_TexteditState* state )
{
	if( !STB_TEXT_HAS_SELECTION( state ) )
		state->select_start = state->select_end = state->cursor;
	else
		state->cursor = state->select_end;
}

// API cut: delete selection
static int stb_textedit_cut( STB_TEXTEDIT_STRING* str, STB_TexteditState* state )
{
	if( STB_TEXT_HAS_SELECTION( state ) )
	{
		stb_textedit_delete_selection( str, state ); // implicitly clamps
		state->has_preferred_x = 0;
		return 1;
	}
	return 0;
}

// API paste: replace existing selection with passed-in text
static int stb_textedit_paste_internal( STB_TEXTEDIT_STRING* str, STB_TexteditState* state, STB_TEXTEDIT_CHARTYPE* text, int len )
{
	// if there's a selection, the paste should delete it
	stb_textedit_clamp( str, state );
	stb_textedit_delete_selection( str, state );
	// try to insert the characters
	if( STB_TEXTEDIT_INSERTCHARS( str, state->cursor, text, len ) )
	{
		stb_text_makeundo_insert( state, state->cursor, len );
		state->cursor += len;
		state->has_preferred_x = 0;
		return 1;
	}
	// remove the undo since we didn't actually insert the characters
	if( state->undostate.undo_point )
		--state->undostate.undo_point;
	return 0;
}

#ifndef STB_TEXTEDIT_KEYTYPE
#define STB_TEXTEDIT_KEYTYPE int
#endif

// API key: process a keyboard input
static void stb_textedit_key( STB_TEXTEDIT_STRING* str, STB_TexteditState* state, STB_TEXTEDIT_KEYTYPE key )
{
retry:
	switch( key )
	{
		default:
		{
			int c = STB_TEXTEDIT_KEYTOTEXT( key );
			if( c > 0 )
			{
				STB_TEXTEDIT_CHARTYPE ch = ( STB_TEXTEDIT_CHARTYPE )c;

				// can't add newline in single-line mode
				if( c == '\n' && state->single_line )
					break;

				if( state->insert_mode && !STB_TEXT_HAS_SELECTION( state ) && state->cursor < STB_TEXTEDIT_STRINGLEN( str ) )
				{
					stb_text_makeundo_replace( str, state, state->cursor, 1, 1 );
					STB_TEXTEDIT_DELETECHARS( str, state->cursor, 1 );
					if( STB_TEXTEDIT_INSERTCHARS( str, state->cursor, &ch, 1 ) )
					{
						++state->cursor;
						state->has_preferred_x = 0;
					}
				}
				else
				{
					stb_textedit_delete_selection( str, state ); // implicitly clamps
					if( STB_TEXTEDIT_INSERTCHARS( str, state->cursor, &ch, 1 ) )
					{
						stb_text_makeundo_insert( state, state->cursor, 1 );
						++state->cursor;
						state->has_preferred_x = 0;
					}
				}
			}
			break;
		}

#ifdef STB_TEXTEDIT_K_INSERT
		case STB_TEXTEDIT_K_INSERT:
			state->insert_mode = !state->insert_mode;
			break;
#endif

		case STB_TEXTEDIT_K_UNDO:
			stb_text_undo( str, state );
			state->has_preferred_x = 0;
			break;

		case STB_TEXTEDIT_K_REDO:
			stb_text_redo( str, state );
			state->has_preferred_x = 0;
			break;

		case STB_TEXTEDIT_K_LEFT:
			// if currently there's a selection, move cursor to start of selection
			if( STB_TEXT_HAS_SELECTION( state ) )
				stb_textedit_move_to_first( state );
			else
				if( state->cursor > 0 )
					--state->cursor;
			state->has_preferred_x = 0;
			break;

		case STB_TEXTEDIT_K_RIGHT:
			// if currently there's a selection, move cursor to end of selection
			if( STB_TEXT_HAS_SELECTION( state ) )
				stb_textedit_move_to_last( str, state );
			else
				++state->cursor;
			stb_textedit_clamp( str, state );
			state->has_preferred_x = 0;
			break;

		case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:
			stb_textedit_clamp( str, state );
			stb_textedit_prep_selection_at_cursor( state );
			// move selection left
			if( state->select_end > 0 )
				--state->select_end;
			state->cursor = state->select_end;
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_MOVEWORDLEFT
		case STB_TEXTEDIT_K_WORDLEFT:
			if( STB_TEXT_HAS_SELECTION( state ) )
				stb_textedit_move_to_first( state );
			else
			{
				state->cursor = STB_TEXTEDIT_MOVEWORDLEFT( str, state->cursor );
				stb_textedit_clamp( str, state );
			}
			break;

		case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:
			if( !STB_TEXT_HAS_SELECTION( state ) )
				stb_textedit_prep_selection_at_cursor( state );

			state->cursor = STB_TEXTEDIT_MOVEWORDLEFT( str, state->cursor );
			state->select_end = state->cursor;

			stb_textedit_clamp( str, state );
			break;
#endif

#ifdef STB_TEXTEDIT_MOVEWORDRIGHT
		case STB_TEXTEDIT_K_WORDRIGHT:
			if( STB_TEXT_HAS_SELECTION( state ) )
				stb_textedit_move_to_last( str, state );
			else
			{
				state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT( str, state->cursor );
				stb_textedit_clamp( str, state );
			}
			break;

		case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:
			if( !STB_TEXT_HAS_SELECTION( state ) )
				stb_textedit_prep_selection_at_cursor( state );

			state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT( str, state->cursor );
			state->select_end = state->cursor;

			stb_textedit_clamp( str, state );
			break;
#endif

		case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:
			stb_textedit_prep_selection_at_cursor( state );
			// move selection right
			++state->select_end;
			stb_textedit_clamp( str, state );
			state->cursor = state->select_end;
			state->has_preferred_x = 0;
			break;

		case STB_TEXTEDIT_K_DOWN:
		case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT:
		{
			StbFindState find;
			StbTexteditRow row;
			int i, sel = ( key & STB_TEXTEDIT_K_SHIFT ) != 0;

			if( state->single_line )
			{
				// on windows, up&down in single-line behave like left&right
				key = STB_TEXTEDIT_K_RIGHT | ( key & STB_TEXTEDIT_K_SHIFT );
				goto retry;
			}

			if( sel )
				stb_textedit_prep_selection_at_cursor( state );
			else if( STB_TEXT_HAS_SELECTION( state ) )
				stb_textedit_move_to_last( str, state );

			// compute current position of cursor point
			stb_textedit_clamp( str, state );
			stb_textedit_find_charpos( &find, str, state->cursor, state->single_line );

			// now find character position down a row
			if( find.length )
			{
				float goal_x = state->has_preferred_x ? state->preferred_x : find.x;
				float x;
				int start = find.first_char + find.length;
				state->cursor = start;
				STB_TEXTEDIT_LAYOUTROW( &row, str, state->cursor );
				x = row.x0;
				for( i = 0; i < row.num_chars; ++i )
				{
					float dx = STB_TEXTEDIT_GETWIDTH( str, start, i );
#ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
					if( dx == STB_TEXTEDIT_GETWIDTH_NEWLINE )
						break;
#endif
					x += dx;
					if( x > goal_x )
						break;
					++state->cursor;
				}
				stb_textedit_clamp( str, state );

				state->has_preferred_x = 1;
				state->preferred_x = goal_x;

				if( sel )
					state->select_end = state->cursor;
			}
			break;
		}

		case STB_TEXTEDIT_K_UP:
		case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT:
		{
			StbFindState find;
			StbTexteditRow row;
			int i, sel = ( key & STB_TEXTEDIT_K_SHIFT ) != 0;

			if( state->single_line )
			{
				// on windows, up&down become left&right
				key = STB_TEXTEDIT_K_LEFT | ( key & STB_TEXTEDIT_K_SHIFT );
				goto retry;
			}

			if( sel )
				stb_textedit_prep_selection_at_cursor( state );
			else if( STB_TEXT_HAS_SELECTION( state ) )
				stb_textedit_move_to_first( state );

			// compute current position of cursor point
			stb_textedit_clamp( str, state );
			stb_textedit_find_charpos( &find, str, state->cursor, state->single_line );

			// can only go up if there's a previous row
			if( find.prev_first != find.first_char )
			{
				// now find character position up a row
				float goal_x = state->has_preferred_x ? state->preferred_x : find.x;
				float x;
				state->cursor = find.prev_first;
				STB_TEXTEDIT_LAYOUTROW( &row, str, state->cursor );
				x = row.x0;
				for( i = 0; i < row.num_chars; ++i )
				{
					float dx = STB_TEXTEDIT_GETWIDTH( str, find.prev_first, i );
#ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
					if( dx == STB_TEXTEDIT_GETWIDTH_NEWLINE )
						break;
#endif
					x += dx;
					if( x > goal_x )
						break;
					++state->cursor;
				}
				stb_textedit_clamp( str, state );

				state->has_preferred_x = 1;
				state->preferred_x = goal_x;

				if( sel )
					state->select_end = state->cursor;
			}
			break;
		}

		case STB_TEXTEDIT_K_DELETE:
		case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:
			if( STB_TEXT_HAS_SELECTION( state ) )
				stb_textedit_delete_selection( str, state );
			else
			{
				int n = STB_TEXTEDIT_STRINGLEN( str );
				if( state->cursor < n )
					stb_textedit_delete( str, state, state->cursor, 1 );
			}
			state->has_preferred_x = 0;
			break;

		case STB_TEXTEDIT_K_BACKSPACE:
		case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:
			if( STB_TEXT_HAS_SELECTION( state ) )
				stb_textedit_delete_selection( str, state );
			else
			{
				stb_textedit_clamp( str, state );
				if( state->cursor > 0 )
				{
					stb_textedit_delete( str, state, state->cursor - 1, 1 );
					--state->cursor;
				}
			}
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_TEXTSTART2
		case STB_TEXTEDIT_K_TEXTSTART2:
#endif
		case STB_TEXTEDIT_K_TEXTSTART:
			state->cursor = state->select_start = state->select_end = 0;
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
		case STB_TEXTEDIT_K_TEXTEND2:
#endif
		case STB_TEXTEDIT_K_TEXTEND:
			state->cursor = STB_TEXTEDIT_STRINGLEN( str );
			state->select_start = state->select_end = 0;
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_TEXTSTART2
		case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
		case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:
			stb_textedit_prep_selection_at_cursor( state );
			state->cursor = state->select_end = 0;
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
		case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
		case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:
			stb_textedit_prep_selection_at_cursor( state );
			state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN( str );
			state->has_preferred_x = 0;
			break;


#ifdef STB_TEXTEDIT_K_LINESTART2
		case STB_TEXTEDIT_K_LINESTART2:
#endif
		case STB_TEXTEDIT_K_LINESTART:
			stb_textedit_clamp( str, state );
			stb_textedit_move_to_first( state );
			if( state->single_line )
				state->cursor = 0;
			else while( state->cursor > 0 && STB_TEXTEDIT_GETCHAR( str, state->cursor - 1 ) != STB_TEXTEDIT_NEWLINE )
				--state->cursor;
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_LINEEND2
		case STB_TEXTEDIT_K_LINEEND2:
#endif
		case STB_TEXTEDIT_K_LINEEND:
		{
			int n = STB_TEXTEDIT_STRINGLEN( str );
			stb_textedit_clamp( str, state );
			stb_textedit_move_to_first( state );
			if( state->single_line )
				state->cursor = n;
			else while( state->cursor < n && STB_TEXTEDIT_GETCHAR( str, state->cursor ) != STB_TEXTEDIT_NEWLINE )
				++state->cursor;
			state->has_preferred_x = 0;
			break;
		}

#ifdef STB_TEXTEDIT_K_LINESTART2
		case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
		case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:
			stb_textedit_clamp( str, state );
			stb_textedit_prep_selection_at_cursor( state );
			if( state->single_line )
				state->cursor = 0;
			else while( state->cursor > 0 && STB_TEXTEDIT_GETCHAR( str, state->cursor - 1 ) != STB_TEXTEDIT_NEWLINE )
				--state->cursor;
			state->select_end = state->cursor;
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_LINEEND2
		case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
		case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT:
		{
			int n = STB_TEXTEDIT_STRINGLEN( str );
			stb_textedit_clamp( str, state );
			stb_textedit_prep_selection_at_cursor( state );
			if( state->single_line )
				state->cursor = n;
			else while( state->cursor < n && STB_TEXTEDIT_GETCHAR( str, state->cursor ) != STB_TEXTEDIT_NEWLINE )
				++state->cursor;
			state->select_end = state->cursor;
			state->has_preferred_x = 0;
			break;
		}

		// @TODO:
		//    STB_TEXTEDIT_K_PGUP      - move cursor up a page
		//    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
	}
}

/////////////////////////////////////////////////////////////////////////////
//
//      Undo processing
//
// @OPTIMIZE: the undo/redo buffer should be circular

static void stb_textedit_flush_redo( StbUndoState* state )
{
	state->redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
	state->redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;
}

// discard the oldest entry in the undo list
static void stb_textedit_discard_undo( StbUndoState* state )
{
	if( state->undo_point > 0 )
	{
		// if the 0th undo state has characters, clean those up
		if( state->undo_rec[ 0 ].char_storage >= 0 )
		{
			int n = state->undo_rec[ 0 ].insert_length, i;
			// delete n characters from all other records
			state->undo_char_point -= n;
			STB_TEXTEDIT_memmove( state->undo_char, state->undo_char + n, ( size_t )( state->undo_char_point * sizeof( STB_TEXTEDIT_CHARTYPE ) ) );
			for( i = 0; i < state->undo_point; ++i )
				if( state->undo_rec[ i ].char_storage >= 0 )
					state->undo_rec[ i ].char_storage -= n; // @OPTIMIZE: get rid of char_storage and infer it
		}
		--state->undo_point;
		STB_TEXTEDIT_memmove( state->undo_rec, state->undo_rec + 1, ( size_t )( state->undo_point * sizeof( state->undo_rec[ 0 ] ) ) );
	}
}

// discard the oldest entry in the redo list--it's bad if this
// ever happens, but because undo & redo have to store the actual
// characters in different cases, the redo character buffer can
// fill up even though the undo buffer didn't
static void stb_textedit_discard_redo( StbUndoState* state )
{
	int k = STB_TEXTEDIT_UNDOSTATECOUNT - 1;

	if( state->redo_point <= k )
	{
		// if the k'th undo state has characters, clean those up
		if( state->undo_rec[ k ].char_storage >= 0 )
		{
			int n = state->undo_rec[ k ].insert_length, i;
			// move the remaining redo character data to the end of the buffer
			state->redo_char_point += n;
			STB_TEXTEDIT_memmove( state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point - n, ( size_t )( ( STB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point ) * sizeof( STB_TEXTEDIT_CHARTYPE ) ) );
			// adjust the position of all the other records to account for above memmove
			for( i = state->redo_point; i < k; ++i )
				if( state->undo_rec[ i ].char_storage >= 0 )
					state->undo_rec[ i ].char_storage += n;
		}
		// now move all the redo records towards the end of the buffer; the first one is at 'redo_point'
		// {DEAR IMGUI]
		size_t move_size = ( size_t )( ( STB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point - 1 ) * sizeof( state->undo_rec[ 0 ] ) );
		const char* buf_begin = ( char* )state->undo_rec; ( void )buf_begin;
		const char* buf_end = ( char* )state->undo_rec + sizeof( state->undo_rec ); ( void )buf_end;
		IM_ASSERT( ( ( char* )( state->undo_rec + state->redo_point ) ) >= buf_begin );
		IM_ASSERT( ( ( char* )( state->undo_rec + state->redo_point + 1 ) + move_size ) <= buf_end );
		STB_TEXTEDIT_memmove( state->undo_rec + state->redo_point + 1, state->undo_rec + state->redo_point, move_size );

		// now move redo_point to point to the new one
		++state->redo_point;
	}
}

static StbUndoRecord* stb_text_create_undo_record( StbUndoState* state, int numchars )
{
	// any time we create a new undo record, we discard redo
	stb_textedit_flush_redo( state );

	// if we have no free records, we have to make room, by sliding the
	// existing records down
	if( state->undo_point == STB_TEXTEDIT_UNDOSTATECOUNT )
		stb_textedit_discard_undo( state );

	// if the characters to store won't possibly fit in the buffer, we can't undo
	if( numchars > STB_TEXTEDIT_UNDOCHARCOUNT )
	{
		state->undo_point = 0;
		state->undo_char_point = 0;
		return NULL;
	}

	// if we don't have enough free characters in the buffer, we have to make room
	while( state->undo_char_point + numchars > STB_TEXTEDIT_UNDOCHARCOUNT )
		stb_textedit_discard_undo( state );

	return &state->undo_rec[ state->undo_point++ ];
}

static STB_TEXTEDIT_CHARTYPE* stb_text_createundo( StbUndoState* state, int pos, int insert_len, int delete_len )
{
	StbUndoRecord* r = stb_text_create_undo_record( state, insert_len );
	if( r == NULL )
		return NULL;

	r->where = pos;
	r->insert_length = ( STB_TEXTEDIT_POSITIONTYPE )insert_len;
	r->delete_length = ( STB_TEXTEDIT_POSITIONTYPE )delete_len;

	if( insert_len == 0 )
	{
		r->char_storage = -1;
		return NULL;
	}
	else
	{
		r->char_storage = state->undo_char_point;
		state->undo_char_point += insert_len;
		return &state->undo_char[ r->char_storage ];
	}
}

static void stb_text_undo( STB_TEXTEDIT_STRING* str, STB_TexteditState* state )
{
	StbUndoState* s = &state->undostate;
	StbUndoRecord u, * r;
	if( s->undo_point == 0 )
		return;

	// we need to do two things: apply the undo record, and create a redo record
	u = s->undo_rec[ s->undo_point - 1 ];
	r = &s->undo_rec[ s->redo_point - 1 ];
	r->char_storage = -1;

	r->insert_length = u.delete_length;
	r->delete_length = u.insert_length;
	r->where = u.where;

	if( u.delete_length )
	{
		// if the undo record says to delete characters, then the redo record will
		// need to re-insert the characters that get deleted, so we need to store
		// them.

		// there are three cases:
		//    there's enough room to store the characters
		//    characters stored for *redoing* don't leave room for redo
		//    characters stored for *undoing* don't leave room for redo
		// if the last is true, we have to bail

		if( s->undo_char_point + u.delete_length >= STB_TEXTEDIT_UNDOCHARCOUNT )
		{
			// the undo records take up too much character space; there's no space to store the redo characters
			r->insert_length = 0;
		}
		else
		{
			int i;

			// there's definitely room to store the characters eventually
			while( s->undo_char_point + u.delete_length > s->redo_char_point )
			{
				// should never happen:
				if( s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT )
					return;
				// there's currently not enough room, so discard a redo record
				stb_textedit_discard_redo( s );
			}
			r = &s->undo_rec[ s->redo_point - 1 ];

			r->char_storage = s->redo_char_point - u.delete_length;
			s->redo_char_point = s->redo_char_point - u.delete_length;

			// now save the characters
			for( i = 0; i < u.delete_length; ++i )
				s->undo_char[ r->char_storage + i ] = STB_TEXTEDIT_GETCHAR( str, u.where + i );
		}

		// now we can carry out the deletion
		STB_TEXTEDIT_DELETECHARS( str, u.where, u.delete_length );
	}

	// check type of recorded action:
	if( u.insert_length )
	{
		// easy case: was a deletion, so we need to insert n characters
		STB_TEXTEDIT_INSERTCHARS( str, u.where, &s->undo_char[ u.char_storage ], u.insert_length );
		s->undo_char_point -= u.insert_length;
	}

	state->cursor = u.where + u.insert_length;

	s->undo_point--;
	s->redo_point--;
}

static void stb_text_redo( STB_TEXTEDIT_STRING* str, STB_TexteditState* state )
{
	StbUndoState* s = &state->undostate;
	StbUndoRecord* u, r;
	if( s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT )
		return;

	// we need to do two things: apply the redo record, and create an undo record
	u = &s->undo_rec[ s->undo_point ];
	r = s->undo_rec[ s->redo_point ];

	// we KNOW there must be room for the undo record, because the redo record
	// was derived from an undo record

	u->delete_length = r.insert_length;
	u->insert_length = r.delete_length;
	u->where = r.where;
	u->char_storage = -1;

	if( r.delete_length )
	{
		// the redo record requires us to delete characters, so the undo record
		// needs to store the characters

		if( s->undo_char_point + u->insert_length > s->redo_char_point )
		{
			u->insert_length = 0;
			u->delete_length = 0;
		}
		else
		{
			int i;
			u->char_storage = s->undo_char_point;
			s->undo_char_point = s->undo_char_point + u->insert_length;

			// now save the characters
			for( i = 0; i < u->insert_length; ++i )
				s->undo_char[ u->char_storage + i ] = STB_TEXTEDIT_GETCHAR( str, u->where + i );
		}

		STB_TEXTEDIT_DELETECHARS( str, r.where, r.delete_length );
	}

	if( r.insert_length )
	{
		// easy case: need to insert n characters
		STB_TEXTEDIT_INSERTCHARS( str, r.where, &s->undo_char[ r.char_storage ], r.insert_length );
		s->redo_char_point += r.insert_length;
	}

	state->cursor = r.where + r.insert_length;

	s->undo_point++;
	s->redo_point++;
}

static void stb_text_makeundo_insert( STB_TexteditState* state, int where, int length )
{
	stb_text_createundo( &state->undostate, where, 0, length );
}

static void stb_text_makeundo_delete( STB_TEXTEDIT_STRING* str, STB_TexteditState* state, int where, int length )
{
	int i;
	STB_TEXTEDIT_CHARTYPE* p = stb_text_createundo( &state->undostate, where, length, 0 );
	if( p )
	{
		for( i = 0; i < length; ++i )
			p[ i ] = STB_TEXTEDIT_GETCHAR( str, where + i );
	}
}

static void stb_text_makeundo_replace( STB_TEXTEDIT_STRING* str, STB_TexteditState* state, int where, int old_length, int new_length )
{
	int i;
	STB_TEXTEDIT_CHARTYPE* p = stb_text_createundo( &state->undostate, where, old_length, new_length );
	if( p )
	{
		for( i = 0; i < old_length; ++i )
			p[ i ] = STB_TEXTEDIT_GETCHAR( str, where + i );
	}
}

// reset the state to default
static void stb_textedit_clear_state( STB_TexteditState* state, int is_single_line )
{
	state->undostate.undo_point = 0;
	state->undostate.undo_char_point = 0;
	state->undostate.redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
	state->undostate.redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;
	state->select_end = state->select_start = 0;
	state->cursor = 0;
	state->has_preferred_x = 0;
	state->preferred_x = 0;
	state->cursor_at_end_of_line = 0;
	state->initialized = 1;
	state->single_line = ( unsigned char )is_single_line;
	state->insert_mode = 0;
}

// API initialize
static void stb_textedit_initialize_state( STB_TexteditState* state, int is_single_line )
{
	stb_textedit_clear_state( state, is_single_line );
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

static int stb_textedit_paste( STB_TEXTEDIT_STRING* str, STB_TexteditState* state, STB_TEXTEDIT_CHARTYPE const* ctext, int len )
{
	return stb_textedit_paste_internal( str, state, ( STB_TEXTEDIT_CHARTYPE* )ctext, len );
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif//STB_TEXTEDIT_IMPLEMENTATION

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/
```

`horizon/imgui/imstb_truetype.hpp`:

```hpp
// [DEAR IMGUI]
// This is a slightly modified version of stb_truetype.h 1.20.
// Mostly fixing for compiler and static analyzer warnings.
// Grep for [DEAR IMGUI] to find the changes.

// stb_truetype.h - v1.20 - public domain
// authored from 2009-2016 by Sean Barrett / RAD Game Tools
//
//   This library processes TrueType files:
//        parse files
//        extract glyph metrics
//        extract glyph shapes
//        render glyphs to one-channel bitmaps with antialiasing (box filter)
//        render glyphs to one-channel SDF bitmaps (signed-distance field/function)
//
//   Todo:
//        non-MS cmaps
//        crashproof on bad data
//        hinting? (no longer patented)
//        cleartype-style AA?
//        optimize: use simple memory allocator for intermediates
//        optimize: build edge-list directly from curves
//        optimize: rasterize directly from curves?
//
// ADDITIONAL CONTRIBUTORS
//
//   Mikko Mononen: compound shape support, more cmap formats
//   Tor Andersson: kerning, subpixel rendering
//   Dougall Johnson: OpenType / Type 2 font handling
//   Daniel Ribeiro Maciel: basic GPOS-based kerning
//
//   Misc other:
//       Ryan Gordon
//       Simon Glass
//       github:IntellectualKitty
//       Imanol Celaya
//       Daniel Ribeiro Maciel
//
//   Bug/warning reports/fixes:
//       "Zer" on mollyrocket       Fabian "ryg" Giesen
//       Cass Everitt               Martins Mozeiko
//       stoiko (Haemimont Games)   Cap Petschulat
//       Brian Hook                 Omar Cornut
//       Walter van Niftrik         github:aloucks
//       David Gow                  Peter LaValle
//       David Given                Sergey Popov
//       Ivan-Assen Ivanov          Giumo X. Clanjor
//       Anthony Pesch              Higor Euripedes
//       Johan Duparc               Thomas Fields
//       Hou Qiming                 Derek Vinyard
//       Rob Loach                  Cort Stratton
//       Kenney Phillis Jr.         github:oyvindjam
//       Brian Costabile            github:vassvik
//       
// VERSION HISTORY
//
//   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()
//   1.19 (2018-02-11) GPOS kerning, STBTT_fmod
//   1.18 (2018-01-29) add missing function
//   1.17 (2017-07-23) make more arguments const; doc fix
//   1.16 (2017-07-12) SDF support
//   1.15 (2017-03-03) make more arguments const
//   1.14 (2017-01-16) num-fonts-in-TTC function
//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     variant PackFontRanges to pack and render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//
//   Full history can be found at the end of this file.
//
// LICENSE
//
//   See end of file for license information.
//
// USAGE
//
//   Include this file in whatever places need to refer to it. In ONE C/C++
//   file, write:
//      #define STB_TRUETYPE_IMPLEMENTATION
//   before the #include of this file. This expands out the actual
//   implementation into that C/C++ file.
//
//   To make the implementation private to the file that generates the implementation,
//      #define STBTT_STATIC
//
//   Simple 3D API (don't ship this, but it's fine for tools and quick start)
//           stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture
//           stbtt_GetBakedQuad()                 -- compute quad to draw for a given char
//
//   Improved 3D API (more shippable):
//           #include "stb_rect_pack.h"           -- optional, but you really want it
//           stbtt_PackBegin()
//           stbtt_PackSetOversampling()          -- for improved quality on small fonts
//           stbtt_PackFontRanges()               -- pack and renders
//           stbtt_PackEnd()
//           stbtt_GetPackedQuad()
//
//   "Load" a font file from a memory buffer (you have to keep the buffer loaded)
//           stbtt_InitFont()
//           stbtt_GetFontOffsetForIndex()        -- indexing for TTC font collections
//           stbtt_GetNumberOfFonts()             -- number of fonts for TTC font collections
//
//   Render a unicode codepoint to a bitmap
//           stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap
//           stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide
//           stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be
//
//   Character advance/positioning
//           stbtt_GetCodepointHMetrics()
//           stbtt_GetFontVMetrics()
//           stbtt_GetFontVMetricsOS2()
//           stbtt_GetCodepointKernAdvance()
//
//   Starting with version 1.06, the rasterizer was replaced with a new,
//   faster and generally-more-precise rasterizer. The new rasterizer more
//   accurately measures pixel coverage for anti-aliasing, except in the case
//   where multiple shapes overlap, in which case it overestimates the AA pixel
//   coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If
//   this turns out to be a problem, you can re-enable the old rasterizer with
//        #define STBTT_RASTERIZER_VERSION 1
//   which will incur about a 15% speed hit.
//
// ADDITIONAL DOCUMENTATION
//
//   Immediately after this block comment are a series of sample programs.
//
//   After the sample programs is the "header file" section. This section
//   includes documentation for each API function.
//
//   Some important concepts to understand to use this library:
//
//      Codepoint
//         Characters are defined by unicode codepoints, e.g. 65 is
//         uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is
//         the hiragana for "ma".
//
//      Glyph
//         A visual character shape (every codepoint is rendered as
//         some glyph)
//
//      Glyph index
//         A font-specific integer ID representing a glyph
//
//      Baseline
//         Glyph shapes are defined relative to a baseline, which is the
//         bottom of uppercase characters. Characters extend both above
//         and below the baseline.
//
//      Current Point
//         As you draw text to the screen, you keep track of a "current point"
//         which is the origin of each character. The current point's vertical
//         position is the baseline. Even "baked fonts" use this model.
//
//      Vertical Font Metrics
//         The vertical qualities of the font, used to vertically position
//         and space the characters. See docs for stbtt_GetFontVMetrics.
//
//      Font Size in Pixels or Points
//         The preferred interface for specifying font sizes in stb_truetype
//         is to specify how tall the font's vertical extent should be in pixels.
//         If that sounds good enough, skip the next paragraph.
//
//         Most font APIs instead use "points", which are a common typographic
//         measurement for describing font size, defined as 72 points per inch.
//         stb_truetype provides a point API for compatibility. However, true
//         "per inch" conventions don't make much sense on computer displays
//         since different monitors have different number of pixels per
//         inch. For example, Windows traditionally uses a convention that
//         there are 96 pixels per inch, thus making 'inch' measurements have
//         nothing to do with inches, and thus effectively defining a point to
//         be 1.333 pixels. Additionally, the TrueType font data provides
//         an explicit scale factor to scale a given font's glyphs to points,
//         but the author has observed that this scale factor is often wrong
//         for non-commercial fonts, thus making fonts scaled in points
//         according to the TrueType spec incoherently sized in practice.
//
// DETAILED USAGE:
//
//  Scale:
//    Select how high you want the font to be, in points or pixels.
//    Call ScaleForPixelHeight or ScaleForMappingEmToPixels to compute
//    a scale factor SF that will be used by all other functions.
//
//  Baseline:
//    You need to select a y-coordinate that is the baseline of where
//    your text will appear. Call GetFontBoundingBox to get the baseline-relative
//    bounding box for all characters. SF*-y0 will be the distance in pixels
//    that the worst-case character could extend above the baseline, so if
//    you want the top edge of characters to appear at the top of the
//    screen where y=0, then you would set the baseline to SF*-y0.
//
//  Current point:
//    Set the current point where the first character will appear. The
//    first character could extend left of the current point; this is font
//    dependent. You can either choose a current point that is the leftmost
//    point and hope, or add some padding, or check the bounding box or
//    left-side-bearing of the first character to be displayed and set
//    the current point based on that.
//
//  Displaying a character:
//    Compute the bounding box of the character. It will contain signed values
//    relative to <current_point, baseline>. I.e. if it returns x0,y0,x1,y1,
//    then the character should be displayed in the rectangle from
//    <current_point+SF*x0, baseline+SF*y0> to <current_point+SF*x1,baseline+SF*y1).
//
//  Advancing for the next character:
//    Call GlyphHMetrics, and compute 'current_point += SF * advance'.
// 
//
// ADVANCED USAGE
//
//   Quality:
//
//    - Use the functions with Subpixel at the end to allow your characters
//      to have subpixel positioning. Since the font is anti-aliased, not
//      hinted, this is very import for quality. (This is not possible with
//      baked fonts.)
//
//    - Kerning is now supported, and if you're supporting subpixel rendering
//      then kerning is worth using to give your text a polished look.
//
//   Performance:
//
//    - Convert Unicode codepoints to glyph indexes and operate on the glyphs;
//      if you don't do this, stb_truetype is forced to do the conversion on
//      every call.
//
//    - There are a lot of memory allocations. We should modify it to take
//      a temp buffer and allocate from the temp buffer (without freeing),
//      should help performance a lot.
//
// NOTES
//
//   The system uses the raw data found in the .ttf file without changing it
//   and without building auxiliary data structures. This is a bit inefficient
//   on little-endian systems (the data is big-endian), but assuming you're
//   caching the bitmaps or glyph shapes this shouldn't be a big deal.
//
//   It appears to be very hard to programmatically determine what font a
//   given file is in a general way. I provide an API for this, but I don't
//   recommend it.
//
//
// SOURCE STATISTICS (based on v0.6c, 2050 LOC)
//
//   Documentation & header file        520 LOC  \___ 660 LOC documentation
//   Sample code                        140 LOC  /
//   Truetype parsing                   620 LOC  ---- 620 LOC TrueType
//   Software rasterization             240 LOC  \.
//   Curve tessellation                 120 LOC   \__ 550 LOC Bitmap creation
//   Bitmap management                  100 LOC   /
//   Baked bitmap interface              70 LOC  /
//   Font name matching & access        150 LOC  ---- 150 
//   C runtime library abstraction       60 LOC  ----  60
//
//
// PERFORMANCE MEASUREMENTS FOR 1.06:
//
//                      32-bit     64-bit
//   Previous release:  8.83 s     7.68 s
//   Pool allocations:  7.72 s     6.34 s
//   Inline sort     :  6.54 s     5.65 s
//   New rasterizer  :  5.63 s     5.00 s

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////  SAMPLE PROGRAMS
////
//
//  Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless
//
#if 0
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

unsigned char ttf_buffer[ 1 << 20 ];
unsigned char temp_bitmap[ 512 * 512 ];

stbtt_bakedchar cdata[ 96 ]; // ASCII 32..126 is 95 glyphs
GLuint ftex;

void my_stbtt_initfont( void )
{
	fread( ttf_buffer, 1, 1 << 20, fopen( "c:/windows/fonts/times.ttf", "rb" ) );
	stbtt_BakeFontBitmap( ttf_buffer, 0, 32.0, temp_bitmap, 512, 512, 32, 96, cdata ); // no guarantee this fits!
	// can free ttf_buffer at this point
	glGenTextures( 1, &ftex );
	glBindTexture( GL_TEXTURE_2D, ftex );
	glTexImage2D( GL_TEXTURE_2D, 0, GL_ALPHA, 512, 512, 0, GL_ALPHA, GL_UNSIGNED_BYTE, temp_bitmap );
	// can free temp_bitmap at this point
	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
}

void my_stbtt_print( float x, float y, char* text )
{
	// assume orthographic projection with units = screen pixels, origin at top left
	glEnable( GL_TEXTURE_2D );
	glBindTexture( GL_TEXTURE_2D, ftex );
	glBegin( GL_QUADS );
	while( *text )
	{
		if( *text >= 32 && *text < 128 )
		{
			stbtt_aligned_quad q;
			stbtt_GetBakedQuad( cdata, 512, 512, *text - 32, &x, &y, &q, 1 );//1=opengl & d3d10+,0=d3d9
			glTexCoord2f( q.s0, q.t1 ); glVertex2f( q.x0, q.y0 );
			glTexCoord2f( q.s1, q.t1 ); glVertex2f( q.x1, q.y0 );
			glTexCoord2f( q.s1, q.t0 ); glVertex2f( q.x1, q.y1 );
			glTexCoord2f( q.s0, q.t0 ); glVertex2f( q.x0, q.y1 );
		}
		++text;
	}
	glEnd();
}
#endif
//
//
//////////////////////////////////////////////////////////////////////////////
//
// Complete program (this compiles): get a single bitmap, print as ASCII art
//
#if 0
#include <stdio.h>
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

char ttf_buffer[ 1 << 25 ];

int main( int argc, char** argv )
{
	stbtt_fontinfo font;
	unsigned char* bitmap;
	int w, h, i, j, c = ( argc > 1 ? atoi( argv[ 1 ] ) : 'a' ), s = ( argc > 2 ? atoi( argv[ 2 ] ) : 20 );

	fread( ttf_buffer, 1, 1 << 25, fopen( argc > 3 ? argv[ 3 ] : "c:/windows/fonts/arialbd.ttf", "rb" ) );

	stbtt_InitFont( &font, ttf_buffer, stbtt_GetFontOffsetForIndex( ttf_buffer, 0 ) );
	bitmap = stbtt_GetCodepointBitmap( &font, 0, stbtt_ScaleForPixelHeight( &font, s ), c, &w, &h, 0, 0 );

	for( j = 0; j < h; ++j )
	{
		for( i = 0; i < w; ++i )
			putchar( " .:ioVM@"[ bitmap[ j * w + i ] >> 5 ] );
		putchar( '\n' );
	}
	return 0;
}
#endif 
//
// Output:
//
//     .ii.
//    @@@@@@.
//   V@Mio@@o
//   :i.  V@V
//     :oM@@M
//   :@@@MM@M
//   @@o  o@M
//  :@@.  M@M
//   @@@o@@@@
//   :M@@V:@@.
//  
//////////////////////////////////////////////////////////////////////////////
// 
// Complete program: print "Hello World!" banner, with bugs
//
#if 0
char buffer[ 24 << 20 ];
unsigned char screen[ 20 ][ 79 ];

int main( int arg, char** argv )
{
	stbtt_fontinfo font;
	int i, j, ascent, baseline, ch = 0;
	float scale, xpos = 2; // leave a little padding in case the character extends left
	char* text = "Heljo World!"; // intentionally misspelled to show 'lj' brokenness

	fread( buffer, 1, 1000000, fopen( "c:/windows/fonts/arialbd.ttf", "rb" ) );
	stbtt_InitFont( &font, buffer, 0 );

	scale = stbtt_ScaleForPixelHeight( &font, 15 );
	stbtt_GetFontVMetrics( &font, &ascent, 0, 0 );
	baseline = ( int )( ascent * scale );

	while( text[ ch ] )
	{
		int advance, lsb, x0, y0, x1, y1;
		float x_shift = xpos - ( float )floor( xpos );
		stbtt_GetCodepointHMetrics( &font, text[ ch ], &advance, &lsb );
		stbtt_GetCodepointBitmapBoxSubpixel( &font, text[ ch ], scale, scale, x_shift, 0, &x0, &y0, &x1, &y1 );
		stbtt_MakeCodepointBitmapSubpixel( &font, &screen[ baseline + y0 ][ ( int )xpos + x0 ], x1 - x0, y1 - y0, 79, scale, scale, x_shift, 0, text[ ch ] );
		// note that this stomps the old data, so where character boxes overlap (e.g. 'lj') it's wrong
		// because this API is really for baking character bitmaps into textures. if you want to render
		// a sequence of characters, you really need to render each bitmap to a temp buffer, then
		// "alpha blend" that into the working buffer
		xpos += ( advance * scale );
		if( text[ ch + 1 ] )
			xpos += scale * stbtt_GetCodepointKernAdvance( &font, text[ ch ], text[ ch + 1 ] );
		++ch;
	}

	for( j = 0; j < 20; ++j )
	{
		for( i = 0; i < 78; ++i )
			putchar( " .:ioVM@"[ screen[ j ][ i ] >> 5 ] );
		putchar( '\n' );
	}

	return 0;
}
#endif


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////   INTEGRATION WITH YOUR CODEBASE
////
////   The following sections allow you to supply alternate definitions
////   of C library functions used by stb_truetype, e.g. if you don't
////   link with the C runtime library.

#ifdef STB_TRUETYPE_IMPLEMENTATION
	 // #define your own (u)stbtt_int8/16/32 before including to override this
#ifndef stbtt_uint8
typedef unsigned char   stbtt_uint8;
typedef signed   char   stbtt_int8;
typedef unsigned short  stbtt_uint16;
typedef signed   short  stbtt_int16;
typedef unsigned int    stbtt_uint32;
typedef signed   int    stbtt_int32;
#endif

typedef char stbtt__check_size32[ sizeof( stbtt_int32 ) == 4 ? 1 : -1 ];
typedef char stbtt__check_size16[ sizeof( stbtt_int16 ) == 2 ? 1 : -1 ];

// e.g. #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h
#ifndef STBTT_ifloor
#include <math.h>
#define STBTT_ifloor(x)   ((int) floor(x))
#define STBTT_iceil(x)    ((int) ceil(x))
#endif

#ifndef STBTT_sqrt
#include <math.h>
#define STBTT_sqrt(x)      sqrt(x)
#define STBTT_pow(x,y)     pow(x,y)
#endif

#ifndef STBTT_fmod
#include <math.h>
#define STBTT_fmod(x,y)    fmod(x,y)
#endif

#ifndef STBTT_cos
#include <math.h>
#define STBTT_cos(x)       cos(x)
#define STBTT_acos(x)      acos(x)
#endif

#ifndef STBTT_fabs
#include <math.h>
#define STBTT_fabs(x)      fabs(x)
#endif

// #define your own functions "STBTT_malloc" / "STBTT_free" to avoid malloc.h
#ifndef STBTT_malloc
#include <stdlib.h>
#define STBTT_malloc(x,u)  ((void)(u),malloc(x))
#define STBTT_free(x,u)    ((void)(u),free(x))
#endif

#ifndef STBTT_assert
#include <assert.h>
#define STBTT_assert(x)    assert(x)
#endif

#ifndef STBTT_strlen
#include <string.h>
#define STBTT_strlen(x)    strlen(x)
#endif

#ifndef STBTT_memcpy
#include <string.h>
#define STBTT_memcpy       memcpy
#define STBTT_memset       memset
#endif
#endif

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   INTERFACE
////
////

#ifndef __STB_INCLUDE_STB_TRUETYPE_H__
#define __STB_INCLUDE_STB_TRUETYPE_H__

#ifdef STBTT_STATIC
#define STBTT_DEF static
#else
#define STBTT_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

	// private structure
	typedef struct
	{
		unsigned char* data;
		int cursor;
		int size;
	} stbtt__buf;

	//////////////////////////////////////////////////////////////////////////////
	//
	// TEXTURE BAKING API
	//
	// If you use this API, you only have to call two functions ever.
	//

	typedef struct
	{
		unsigned short x0, y0, x1, y1; // coordinates of bbox in bitmap
		float xoff, yoff, xadvance;
	} stbtt_bakedchar;

	STBTT_DEF int stbtt_BakeFontBitmap( const unsigned char* data, int offset,  // font location (use offset=0 for plain .ttf)
																			float pixel_height,                     // height of font in pixels
																			unsigned char* pixels, int pw, int ph,  // bitmap to be filled in
																			int first_char, int num_chars,          // characters to bake
																			stbtt_bakedchar* chardata );             // you allocate this, it's num_chars long
			// if return is positive, the first unused row of the bitmap
			// if return is negative, returns the negative of the number of characters that fit
			// if return is 0, no characters fit and no rows were used
			// This uses a very crappy packing.

	typedef struct
	{
		float x0, y0, s0, t0; // top-left
		float x1, y1, s1, t1; // bottom-right
	} stbtt_aligned_quad;

	STBTT_DEF void stbtt_GetBakedQuad( const stbtt_bakedchar* chardata, int pw, int ph,  // same data as above
																		 int char_index,             // character to display
																		 float* xpos, float* ypos,   // pointers to current position in screen pixel space
																		 stbtt_aligned_quad* q,      // output: quad to draw
																		 int opengl_fillrule );       // true if opengl fill rule; false if DX9 or earlier
			// Call GetBakedQuad with char_index = 'character - first_char', and it
			// creates the quad you need to draw and advances the current position.
			//
			// The coordinate system used assumes y increases downwards.
			//
			// Characters will extend both above and below the current position;
			// see discussion of "BASELINE" above.
			//
			// It's inefficient; you might want to c&p it and optimize it.

	STBTT_DEF void stbtt_GetScaledFontVMetrics( const unsigned char* fontdata, int index, float size, float* ascent, float* descent, float* lineGap );
	// Query the font vertical metrics without having to create a font first.


	//////////////////////////////////////////////////////////////////////////////
	//
	// NEW TEXTURE BAKING API
	//
	// This provides options for packing multiple fonts into one atlas, not
	// perfectly but better than nothing.

	typedef struct
	{
		unsigned short x0, y0, x1, y1; // coordinates of bbox in bitmap
		float xoff, yoff, xadvance;
		float xoff2, yoff2;
	} stbtt_packedchar;

	typedef struct stbtt_pack_context stbtt_pack_context;
	typedef struct stbtt_fontinfo stbtt_fontinfo;
#ifndef STB_RECT_PACK_VERSION
	typedef struct stbrp_rect stbrp_rect;
#endif

	STBTT_DEF int  stbtt_PackBegin( stbtt_pack_context* spc, unsigned char* pixels, int width, int height, int stride_in_bytes, int padding, void* alloc_context );
	// Initializes a packing context stored in the passed-in stbtt_pack_context.
	// Future calls using this context will pack characters into the bitmap passed
	// in here: a 1-channel bitmap that is width * height. stride_in_bytes is
	// the distance from one row to the next (or 0 to mean they are packed tightly
	// together). "padding" is the amount of padding to leave between each
	// character (normally you want '1' for bitmaps you'll use as textures with
	// bilinear filtering).
	//
	// Returns 0 on failure, 1 on success.

	STBTT_DEF void stbtt_PackEnd( stbtt_pack_context* spc );
	// Cleans up the packing context and frees all memory.

#define STBTT_POINT_SIZE(x)   (-(x))

	STBTT_DEF int  stbtt_PackFontRange( stbtt_pack_context* spc, const unsigned char* fontdata, int font_index, float font_size,
																			int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar* chardata_for_range );
	// Creates character bitmaps from the font_index'th font found in fontdata (use
	// font_index=0 if you don't know what that is). It creates num_chars_in_range
	// bitmaps for characters with unicode values starting at first_unicode_char_in_range
	// and increasing. Data for how to render them is stored in chardata_for_range;
	// pass these to stbtt_GetPackedQuad to get back renderable quads.
	//
	// font_size is the full height of the character from ascender to descender,
	// as computed by stbtt_ScaleForPixelHeight. To use a point size as computed
	// by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE()
	// and pass that result as 'font_size':
	//       ...,                  20 , ... // font max minus min y is 20 pixels tall
	//       ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall

	typedef struct
	{
		float font_size;
		int first_unicode_codepoint_in_range;  // if non-zero, then the chars are continuous, and this is the first codepoint
		int* array_of_unicode_codepoints;       // if non-zero, then this is an array of unicode codepoints
		int num_chars;
		stbtt_packedchar* chardata_for_range; // output
		unsigned char h_oversample, v_oversample; // don't set these, they're used internally
	} stbtt_pack_range;

	STBTT_DEF int  stbtt_PackFontRanges( stbtt_pack_context* spc, const unsigned char* fontdata, int font_index, stbtt_pack_range* ranges, int num_ranges );
	// Creates character bitmaps from multiple ranges of characters stored in
	// ranges. This will usually create a better-packed bitmap than multiple
	// calls to stbtt_PackFontRange. Note that you can call this multiple
	// times within a single PackBegin/PackEnd.

	STBTT_DEF void stbtt_PackSetOversampling( stbtt_pack_context* spc, unsigned int h_oversample, unsigned int v_oversample );
	// Oversampling a font increases the quality by allowing higher-quality subpixel
	// positioning, and is especially valuable at smaller text sizes.
	//
	// This function sets the amount of oversampling for all following calls to
	// stbtt_PackFontRange(s) or stbtt_PackFontRangesGatherRects for a given
	// pack context. The default (no oversampling) is achieved by h_oversample=1
	// and v_oversample=1. The total number of pixels required is
	// h_oversample*v_oversample larger than the default; for example, 2x2
	// oversampling requires 4x the storage of 1x1. For best results, render
	// oversampled textures with bilinear filtering. Look at the readme in
	// stb/tests/oversample for information about oversampled fonts
	//
	// To use with PackFontRangesGather etc., you must set it before calls
	// call to PackFontRangesGatherRects.

	STBTT_DEF void stbtt_PackSetSkipMissingCodepoints( stbtt_pack_context* spc, int skip );
	// If skip != 0, this tells stb_truetype to skip any codepoints for which
	// there is no corresponding glyph. If skip=0, which is the default, then
	// codepoints without a glyph recived the font's "missing character" glyph,
	// typically an empty box by convention.

	STBTT_DEF void stbtt_GetPackedQuad( const stbtt_packedchar* chardata, int pw, int ph,  // same data as above
																			int char_index,             // character to display
																			float* xpos, float* ypos,   // pointers to current position in screen pixel space
																			stbtt_aligned_quad* q,      // output: quad to draw
																			int align_to_integer );

	STBTT_DEF int  stbtt_PackFontRangesGatherRects( stbtt_pack_context* spc, const stbtt_fontinfo* info, stbtt_pack_range* ranges, int num_ranges, stbrp_rect* rects );
	STBTT_DEF void stbtt_PackFontRangesPackRects( stbtt_pack_context* spc, stbrp_rect* rects, int num_rects );
	STBTT_DEF int  stbtt_PackFontRangesRenderIntoRects( stbtt_pack_context* spc, const stbtt_fontinfo* info, stbtt_pack_range* ranges, int num_ranges, stbrp_rect* rects );
	// Calling these functions in sequence is roughly equivalent to calling
	// stbtt_PackFontRanges(). If you more control over the packing of multiple
	// fonts, or if you want to pack custom data into a font texture, take a look
	// at the source to of stbtt_PackFontRanges() and create a custom version 
	// using these functions, e.g. call GatherRects multiple times,
	// building up a single array of rects, then call PackRects once,
	// then call RenderIntoRects repeatedly. This may result in a
	// better packing than calling PackFontRanges multiple times
	// (or it may not).

	// this is an opaque structure that you shouldn't mess with which holds
	// all the context needed from PackBegin to PackEnd.
	struct stbtt_pack_context
	{
		void* user_allocator_context;
		void* pack_info;
		int   width;
		int   height;
		int   stride_in_bytes;
		int   padding;
		int   skip_missing;
		unsigned int   h_oversample, v_oversample;
		unsigned char* pixels;
		void* nodes;
	};

	//////////////////////////////////////////////////////////////////////////////
	//
	// FONT LOADING
	//
	//

	STBTT_DEF int stbtt_GetNumberOfFonts( const unsigned char* data );
	// This function will determine the number of fonts in a font file.  TrueType
	// collection (.ttc) files may contain multiple fonts, while TrueType font
	// (.ttf) files only contain one font. The number of fonts can be used for
	// indexing with the previous function where the index is between zero and one
	// less than the total fonts. If an error occurs, -1 is returned.

	STBTT_DEF int stbtt_GetFontOffsetForIndex( const unsigned char* data, int index );
	// Each .ttf/.ttc file may have more than one font. Each font has a sequential
	// index number starting from 0. Call this function to get the font offset for
	// a given index; it returns -1 if the index is out of range. A regular .ttf
	// file will only define one font and it always be at offset 0, so it will
	// return '0' for index 0, and -1 for all other indices.

	// The following structure is defined publicly so you can declare one on
	// the stack or as a global or etc, but you should treat it as opaque.
	struct stbtt_fontinfo
	{
		void* userdata;
		unsigned char* data;              // pointer to .ttf file
		int              fontstart;         // offset of start of font

		int numGlyphs;                     // number of glyphs, needed for range checking

		int loca, head, glyf, hhea, hmtx, kern, gpos; // table locations as offset from start of .ttf
		int index_map;                     // a cmap mapping for our chosen character encoding
		int indexToLocFormat;              // format needed to map from glyph index to glyph

		stbtt__buf cff;                    // cff font data
		stbtt__buf charstrings;            // the charstring index
		stbtt__buf gsubrs;                 // global charstring subroutines index
		stbtt__buf subrs;                  // private charstring subroutines index
		stbtt__buf fontdicts;              // array of font dicts
		stbtt__buf fdselect;               // map from glyph to fontdict
	};

	STBTT_DEF int stbtt_InitFont( stbtt_fontinfo* info, const unsigned char* data, int offset );
	// Given an offset into the file that defines a font, this function builds
	// the necessary cached info for the rest of the system. You must allocate
	// the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't
	// need to do anything special to free it, because the contents are pure
	// value data with no additional data structures. Returns 0 on failure.


	//////////////////////////////////////////////////////////////////////////////
	//
	// CHARACTER TO GLYPH-INDEX CONVERSIOn

	STBTT_DEF int stbtt_FindGlyphIndex( const stbtt_fontinfo* info, int unicode_codepoint );
	// If you're going to perform multiple operations on the same character
	// and you want a speed-up, call this function with the character you're
	// going to process, then use glyph-based functions instead of the
	// codepoint-based functions.
	// Returns 0 if the character codepoint is not defined in the font.


	//////////////////////////////////////////////////////////////////////////////
	//
	// CHARACTER PROPERTIES
	//

	STBTT_DEF float stbtt_ScaleForPixelHeight( const stbtt_fontinfo* info, float pixels );
	// computes a scale factor to produce a font whose "height" is 'pixels' tall.
	// Height is measured as the distance from the highest ascender to the lowest
	// descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics
	// and computing:
	//       scale = pixels / (ascent - descent)
	// so if you prefer to measure height by the ascent only, use a similar calculation.

	STBTT_DEF float stbtt_ScaleForMappingEmToPixels( const stbtt_fontinfo* info, float pixels );
	// computes a scale factor to produce a font whose EM size is mapped to
	// 'pixels' tall. This is probably what traditional APIs compute, but
	// I'm not positive.

	STBTT_DEF void stbtt_GetFontVMetrics( const stbtt_fontinfo* info, int* ascent, int* descent, int* lineGap );
	// ascent is the coordinate above the baseline the font extends; descent
	// is the coordinate below the baseline the font extends (i.e. it is typically negative)
	// lineGap is the spacing between one row's descent and the next row's ascent...
	// so you should advance the vertical position by "*ascent - *descent + *lineGap"
	//   these are expressed in unscaled coordinates, so you must multiply by
	//   the scale factor for a given size

	STBTT_DEF int  stbtt_GetFontVMetricsOS2( const stbtt_fontinfo* info, int* typoAscent, int* typoDescent, int* typoLineGap );
	// analogous to GetFontVMetrics, but returns the "typographic" values from the OS/2
	// table (specific to MS/Windows TTF files).
	//
	// Returns 1 on success (table present), 0 on failure.

	STBTT_DEF void stbtt_GetFontBoundingBox( const stbtt_fontinfo* info, int* x0, int* y0, int* x1, int* y1 );
	// the bounding box around all possible characters

	STBTT_DEF void stbtt_GetCodepointHMetrics( const stbtt_fontinfo* info, int codepoint, int* advanceWidth, int* leftSideBearing );
	// leftSideBearing is the offset from the current horizontal position to the left edge of the character
	// advanceWidth is the offset from the current horizontal position to the next horizontal position
	//   these are expressed in unscaled coordinates

	STBTT_DEF int  stbtt_GetCodepointKernAdvance( const stbtt_fontinfo* info, int ch1, int ch2 );
	// an additional amount to add to the 'advance' value between ch1 and ch2

	STBTT_DEF int stbtt_GetCodepointBox( const stbtt_fontinfo* info, int codepoint, int* x0, int* y0, int* x1, int* y1 );
	// Gets the bounding box of the visible part of the glyph, in unscaled coordinates

	STBTT_DEF void stbtt_GetGlyphHMetrics( const stbtt_fontinfo* info, int glyph_index, int* advanceWidth, int* leftSideBearing );
	STBTT_DEF int  stbtt_GetGlyphKernAdvance( const stbtt_fontinfo* info, int glyph1, int glyph2 );
	STBTT_DEF int  stbtt_GetGlyphBox( const stbtt_fontinfo* info, int glyph_index, int* x0, int* y0, int* x1, int* y1 );
	// as above, but takes one or more glyph indices for greater efficiency


	//////////////////////////////////////////////////////////////////////////////
	//
	// GLYPH SHAPES (you probably don't need these, but they have to go before
	// the bitmaps for C declaration-order reasons)
	//

#ifndef STBTT_vmove // you can predefine these to use different values (but why?)
	enum
	{
		STBTT_vmove = 1,
		STBTT_vline,
		STBTT_vcurve,
		STBTT_vcubic
	};
#endif

#ifndef stbtt_vertex // you can predefine this to use different values
	// (we share this with other code at RAD)
#define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file
	typedef struct
	{
		stbtt_vertex_type x, y, cx, cy, cx1, cy1;
		unsigned char type, padding;
	} stbtt_vertex;
#endif

	STBTT_DEF int stbtt_IsGlyphEmpty( const stbtt_fontinfo* info, int glyph_index );
	// returns non-zero if nothing is drawn for this glyph

	STBTT_DEF int stbtt_GetCodepointShape( const stbtt_fontinfo* info, int unicode_codepoint, stbtt_vertex** vertices );
	STBTT_DEF int stbtt_GetGlyphShape( const stbtt_fontinfo* info, int glyph_index, stbtt_vertex** vertices );
	// returns # of vertices and fills *vertices with the pointer to them
	//   these are expressed in "unscaled" coordinates
	//
	// The shape is a series of contours. Each one starts with
	// a STBTT_moveto, then consists of a series of mixed
	// STBTT_lineto and STBTT_curveto segments. A lineto
	// draws a line from previous endpoint to its x,y; a curveto
	// draws a quadratic bezier from previous endpoint to
	// its x,y, using cx,cy as the bezier control point.

	STBTT_DEF void stbtt_FreeShape( const stbtt_fontinfo* info, stbtt_vertex* vertices );
	// frees the data allocated above

	//////////////////////////////////////////////////////////////////////////////
	//
	// BITMAP RENDERING
	//

	STBTT_DEF void stbtt_FreeBitmap( unsigned char* bitmap, void* userdata );
	// frees the bitmap allocated below

	STBTT_DEF unsigned char* stbtt_GetCodepointBitmap( const stbtt_fontinfo* info, float scale_x, float scale_y, int codepoint, int* width, int* height, int* xoff, int* yoff );
	// allocates a large-enough single-channel 8bpp bitmap and renders the
	// specified character/glyph at the specified scale into it, with
	// antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque).
	// *width & *height are filled out with the width & height of the bitmap,
	// which is stored left-to-right, top-to-bottom.
	//
	// xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap

	STBTT_DEF unsigned char* stbtt_GetCodepointBitmapSubpixel( const stbtt_fontinfo* info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int* width, int* height, int* xoff, int* yoff );
	// the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel
	// shift for the character

	STBTT_DEF void stbtt_MakeCodepointBitmap( const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint );
	// the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap
	// in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap
	// is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to get the
	// width and height and positioning info for it first.

	STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel( const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint );
	// same as stbtt_MakeCodepointBitmap, but you can specify a subpixel
	// shift for the character

	STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter( const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float* sub_x, float* sub_y, int codepoint );
	// same as stbtt_MakeCodepointBitmapSubpixel, but prefiltering
	// is performed (see stbtt_PackSetOversampling)

	STBTT_DEF void stbtt_GetCodepointBitmapBox( const stbtt_fontinfo* font, int codepoint, float scale_x, float scale_y, int* ix0, int* iy0, int* ix1, int* iy1 );
	// get the bbox of the bitmap centered around the glyph origin; so the
	// bitmap width is ix1-ix0, height is iy1-iy0, and location to place
	// the bitmap top left is (leftSideBearing*scale,iy0).
	// (Note that the bitmap uses y-increases-down, but the shape uses
	// y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.)

	STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel( const stbtt_fontinfo* font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int* ix0, int* iy0, int* ix1, int* iy1 );
	// same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel
	// shift for the character

	// the following functions are equivalent to the above functions, but operate
	// on glyph indices instead of Unicode codepoints (for efficiency)
	STBTT_DEF unsigned char* stbtt_GetGlyphBitmap( const stbtt_fontinfo* info, float scale_x, float scale_y, int glyph, int* width, int* height, int* xoff, int* yoff );
	STBTT_DEF unsigned char* stbtt_GetGlyphBitmapSubpixel( const stbtt_fontinfo* info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int* width, int* height, int* xoff, int* yoff );
	STBTT_DEF void stbtt_MakeGlyphBitmap( const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph );
	STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel( const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph );
	STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter( const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float* sub_x, float* sub_y, int glyph );
	STBTT_DEF void stbtt_GetGlyphBitmapBox( const stbtt_fontinfo* font, int glyph, float scale_x, float scale_y, int* ix0, int* iy0, int* ix1, int* iy1 );
	STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel( const stbtt_fontinfo* font, int glyph, float scale_x, float scale_y, float shift_x, float shift_y, int* ix0, int* iy0, int* ix1, int* iy1 );


	// @TODO: don't expose this structure
	typedef struct
	{
		int w, h, stride;
		unsigned char* pixels;
	} stbtt__bitmap;

	// rasterize a shape with quadratic beziers into a bitmap
	STBTT_DEF void stbtt_Rasterize( stbtt__bitmap* result,        // 1-channel bitmap to draw into
																	float flatness_in_pixels,     // allowable error of curve in pixels
																	stbtt_vertex* vertices,       // array of vertices defining shape
																	int num_verts,                // number of vertices in above array
																	float scale_x, float scale_y, // scale applied to input vertices
																	float shift_x, float shift_y, // translation applied to input vertices
																	int x_off, int y_off,         // another translation applied to input
																	int invert,                   // if non-zero, vertically flip shape
																	void* userdata );              // context for to STBTT_MALLOC

	 //////////////////////////////////////////////////////////////////////////////
	 //
	 // Signed Distance Function (or Field) rendering

	STBTT_DEF void stbtt_FreeSDF( unsigned char* bitmap, void* userdata );
	// frees the SDF bitmap allocated below

	STBTT_DEF unsigned char* stbtt_GetGlyphSDF( const stbtt_fontinfo* info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int* width, int* height, int* xoff, int* yoff );
	STBTT_DEF unsigned char* stbtt_GetCodepointSDF( const stbtt_fontinfo* info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int* width, int* height, int* xoff, int* yoff );
	// These functions compute a discretized SDF field for a single character, suitable for storing
	// in a single-channel texture, sampling with bilinear filtering, and testing against
	// larger than some threshold to produce scalable fonts.
	//        info              --  the font
	//        scale             --  controls the size of the resulting SDF bitmap, same as it would be creating a regular bitmap
	//        glyph/codepoint   --  the character to generate the SDF for
	//        padding           --  extra "pixels" around the character which are filled with the distance to the character (not 0),
	//                                 which allows effects like bit outlines
	//        onedge_value      --  value 0-255 to test the SDF against to reconstruct the character (i.e. the isocontour of the character)
	//        pixel_dist_scale  --  what value the SDF should increase by when moving one SDF "pixel" away from the edge (on the 0..255 scale)
	//                                 if positive, > onedge_value is inside; if negative, < onedge_value is inside
	//        width,height      --  output height & width of the SDF bitmap (including padding)
	//        xoff,yoff         --  output origin of the character
	//        return value      --  a 2D array of bytes 0..255, width*height in size
	//
	// pixel_dist_scale & onedge_value are a scale & bias that allows you to make
	// optimal use of the limited 0..255 for your application, trading off precision
	// and special effects. SDF values outside the range 0..255 are clamped to 0..255.
	//
	// Example:
	//      scale = stbtt_ScaleForPixelHeight(22)
	//      padding = 5
	//      onedge_value = 180
	//      pixel_dist_scale = 180/5.0 = 36.0
	//
	//      This will create an SDF bitmap in which the character is about 22 pixels
	//      high but the whole bitmap is about 22+5+5=32 pixels high. To produce a filled
	//      shape, sample the SDF at each pixel and fill the pixel if the SDF value
	//      is greater than or equal to 180/255. (You'll actually want to antialias,
	//      which is beyond the scope of this example.) Additionally, you can compute
	//      offset outlines (e.g. to stroke the character border inside & outside,
	//      or only outside). For example, to fill outside the character up to 3 SDF
	//      pixels, you would compare against (180-36.0*3)/255 = 72/255. The above
	//      choice of variables maps a range from 5 pixels outside the shape to
	//      2 pixels inside the shape to 0..255; this is intended primarily for apply
	//      outside effects only (the interior range is needed to allow proper
	//      antialiasing of the font at *smaller* sizes)
	//
	// The function computes the SDF analytically at each SDF pixel, not by e.g.
	// building a higher-res bitmap and approximating it. In theory the quality
	// should be as high as possible for an SDF of this size & representation, but
	// unclear if this is true in practice (perhaps building a higher-res bitmap
	// and computing from that can allow drop-out prevention).
	//
	// The algorithm has not been optimized at all, so expect it to be slow
	// if computing lots of characters or very large sizes. 



	//////////////////////////////////////////////////////////////////////////////
	//
	// Finding the right font...
	//
	// You should really just solve this offline, keep your own tables
	// of what font is what, and don't try to get it out of the .ttf file.
	// That's because getting it out of the .ttf file is really hard, because
	// the names in the file can appear in many possible encodings, in many
	// possible languages, and e.g. if you need a case-insensitive comparison,
	// the details of that depend on the encoding & language in a complex way
	// (actually underspecified in truetype, but also gigantic).
	//
	// But you can use the provided functions in two possible ways:
	//     stbtt_FindMatchingFont() will use *case-sensitive* comparisons on
	//             unicode-encoded names to try to find the font you want;
	//             you can run this before calling stbtt_InitFont()
	//
	//     stbtt_GetFontNameString() lets you get any of the various strings
	//             from the file yourself and do your own comparisons on them.
	//             You have to have called stbtt_InitFont() first.


	STBTT_DEF int stbtt_FindMatchingFont( const unsigned char* fontdata, const char* name, int flags );
	// returns the offset (not index) of the font that matches, or -1 if none
	//   if you use STBTT_MACSTYLE_DONTCARE, use a font name like "Arial Bold".
	//   if you use any other flag, use a font name like "Arial"; this checks
	//     the 'macStyle' header field; i don't know if fonts set this consistently
#define STBTT_MACSTYLE_DONTCARE     0
#define STBTT_MACSTYLE_BOLD         1
#define STBTT_MACSTYLE_ITALIC       2
#define STBTT_MACSTYLE_UNDERSCORE   4
#define STBTT_MACSTYLE_NONE         8   // <= not same as 0, this makes us check the bitfield is 0

	STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian( const char* s1, int len1, const char* s2, int len2 );
	// returns 1/0 whether the first string interpreted as utf8 is identical to
	// the second string interpreted as big-endian utf16... useful for strings from next func

	STBTT_DEF const char* stbtt_GetFontNameString( const stbtt_fontinfo* font, int* length, int platformID, int encodingID, int languageID, int nameID );
	// returns the string (which may be big-endian double byte, e.g. for unicode)
	// and puts the length in bytes in *length.
	//
	// some of the values for the IDs are below; for more see the truetype spec:
	//     http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html
	//     http://www.microsoft.com/typography/otspec/name.htm

	enum
	{ // platformID
		STBTT_PLATFORM_ID_UNICODE = 0,
		STBTT_PLATFORM_ID_MAC = 1,
		STBTT_PLATFORM_ID_ISO = 2,
		STBTT_PLATFORM_ID_MICROSOFT = 3
	};

	enum
	{ // encodingID for STBTT_PLATFORM_ID_UNICODE
		STBTT_UNICODE_EID_UNICODE_1_0 = 0,
		STBTT_UNICODE_EID_UNICODE_1_1 = 1,
		STBTT_UNICODE_EID_ISO_10646 = 2,
		STBTT_UNICODE_EID_UNICODE_2_0_BMP = 3,
		STBTT_UNICODE_EID_UNICODE_2_0_FULL = 4
	};

	enum
	{ // encodingID for STBTT_PLATFORM_ID_MICROSOFT
		STBTT_MS_EID_SYMBOL = 0,
		STBTT_MS_EID_UNICODE_BMP = 1,
		STBTT_MS_EID_SHIFTJIS = 2,
		STBTT_MS_EID_UNICODE_FULL = 10
	};

	enum
	{ // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes
		STBTT_MAC_EID_ROMAN = 0, STBTT_MAC_EID_ARABIC = 4,
		STBTT_MAC_EID_JAPANESE = 1, STBTT_MAC_EID_HEBREW = 5,
		STBTT_MAC_EID_CHINESE_TRAD = 2, STBTT_MAC_EID_GREEK = 6,
		STBTT_MAC_EID_KOREAN = 3, STBTT_MAC_EID_RUSSIAN = 7
	};

	enum
	{ // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...
	 // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs
		STBTT_MS_LANG_ENGLISH = 0x0409, STBTT_MS_LANG_ITALIAN = 0x0410,
		STBTT_MS_LANG_CHINESE = 0x0804, STBTT_MS_LANG_JAPANESE = 0x0411,
		STBTT_MS_LANG_DUTCH = 0x0413, STBTT_MS_LANG_KOREAN = 0x0412,
		STBTT_MS_LANG_FRENCH = 0x040c, STBTT_MS_LANG_RUSSIAN = 0x0419,
		STBTT_MS_LANG_GERMAN = 0x0407, STBTT_MS_LANG_SPANISH = 0x0409,
		STBTT_MS_LANG_HEBREW = 0x040d, STBTT_MS_LANG_SWEDISH = 0x041D
	};

	enum
	{ // languageID for STBTT_PLATFORM_ID_MAC
		STBTT_MAC_LANG_ENGLISH = 0, STBTT_MAC_LANG_JAPANESE = 11,
		STBTT_MAC_LANG_ARABIC = 12, STBTT_MAC_LANG_KOREAN = 23,
		STBTT_MAC_LANG_DUTCH = 4, STBTT_MAC_LANG_RUSSIAN = 32,
		STBTT_MAC_LANG_FRENCH = 1, STBTT_MAC_LANG_SPANISH = 6,
		STBTT_MAC_LANG_GERMAN = 2, STBTT_MAC_LANG_SWEDISH = 5,
		STBTT_MAC_LANG_HEBREW = 10, STBTT_MAC_LANG_CHINESE_SIMPLIFIED = 33,
		STBTT_MAC_LANG_ITALIAN = 3, STBTT_MAC_LANG_CHINESE_TRAD = 19
	};

#ifdef __cplusplus
}
#endif

#endif // __STB_INCLUDE_STB_TRUETYPE_H__

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   IMPLEMENTATION
////
////

#ifdef STB_TRUETYPE_IMPLEMENTATION

#ifndef STBTT_MAX_OVERSAMPLE
#define STBTT_MAX_OVERSAMPLE   8
#endif

#if STBTT_MAX_OVERSAMPLE > 255
#error "STBTT_MAX_OVERSAMPLE cannot be > 255"
#endif

typedef int stbtt__test_oversample_pow2[ ( STBTT_MAX_OVERSAMPLE & ( STBTT_MAX_OVERSAMPLE - 1 ) ) == 0 ? 1 : -1 ];

#ifndef STBTT_RASTERIZER_VERSION
#define STBTT_RASTERIZER_VERSION 2
#endif

#ifdef _MSC_VER
#define STBTT__NOTUSED(v)  (void)(v)
#else
#define STBTT__NOTUSED(v)  (void)sizeof(v)
#endif

//////////////////////////////////////////////////////////////////////////
//
// stbtt__buf helpers to parse data from file
//

static stbtt_uint8 stbtt__buf_get8( stbtt__buf* b )
{
	if( b->cursor >= b->size )
		return 0;
	return b->data[ b->cursor++ ];
}

static stbtt_uint8 stbtt__buf_peek8( stbtt__buf* b )
{
	if( b->cursor >= b->size )
		return 0;
	return b->data[ b->cursor ];
}

static void stbtt__buf_seek( stbtt__buf* b, int o )
{
	STBTT_assert( !( o > b->size || o < 0 ) );
	b->cursor = ( o > b->size || o < 0 ) ? b->size : o;
}

static void stbtt__buf_skip( stbtt__buf* b, int o )
{
	stbtt__buf_seek( b, b->cursor + o );
}

static stbtt_uint32 stbtt__buf_get( stbtt__buf* b, int n )
{
	stbtt_uint32 v = 0;
	int i;
	STBTT_assert( n >= 1 && n <= 4 );
	for( i = 0; i < n; i++ )
		v = ( v << 8 ) | stbtt__buf_get8( b );
	return v;
}

static stbtt__buf stbtt__new_buf( const void* p, size_t size )
{
	stbtt__buf r;
	STBTT_assert( size < 0x40000000 );
	r.data = ( stbtt_uint8* )p;
	r.size = ( int )size;
	r.cursor = 0;
	return r;
}

#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)
#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)

static stbtt__buf stbtt__buf_range( const stbtt__buf* b, int o, int s )
{
	stbtt__buf r = stbtt__new_buf( NULL, 0 );
	if( o < 0 || s < 0 || o > b->size || s > b->size - o ) return r;
	r.data = b->data + o;
	r.size = s;
	return r;
}

static stbtt__buf stbtt__cff_get_index( stbtt__buf* b )
{
	int count, start, offsize;
	start = b->cursor;
	count = stbtt__buf_get16( b );
	if( count )
	{
		offsize = stbtt__buf_get8( b );
		STBTT_assert( offsize >= 1 && offsize <= 4 );
		stbtt__buf_skip( b, offsize * count );
		stbtt__buf_skip( b, stbtt__buf_get( b, offsize ) - 1 );
	}
	return stbtt__buf_range( b, start, b->cursor - start );
}

static stbtt_uint32 stbtt__cff_int( stbtt__buf* b )
{
	int b0 = stbtt__buf_get8( b );
	if( b0 >= 32 && b0 <= 246 )       return b0 - 139;
	else if( b0 >= 247 && b0 <= 250 ) return ( b0 - 247 ) * 256 + stbtt__buf_get8( b ) + 108;
	else if( b0 >= 251 && b0 <= 254 ) return -( b0 - 251 ) * 256 - stbtt__buf_get8( b ) - 108;
	else if( b0 == 28 )               return stbtt__buf_get16( b );
	else if( b0 == 29 )               return stbtt__buf_get32( b );
	STBTT_assert( 0 );
	return 0;
}

static void stbtt__cff_skip_operand( stbtt__buf* b )
{
	int v, b0 = stbtt__buf_peek8( b );
	STBTT_assert( b0 >= 28 );
	if( b0 == 30 )
	{
		stbtt__buf_skip( b, 1 );
		while( b->cursor < b->size )
		{
			v = stbtt__buf_get8( b );
			if( ( v & 0xF ) == 0xF || ( v >> 4 ) == 0xF )
				break;
		}
	}
	else
	{
		stbtt__cff_int( b );
	}
}

static stbtt__buf stbtt__dict_get( stbtt__buf* b, int key )
{
	stbtt__buf_seek( b, 0 );
	while( b->cursor < b->size )
	{
		int start = b->cursor, end, op;
		while( stbtt__buf_peek8( b ) >= 28 )
			stbtt__cff_skip_operand( b );
		end = b->cursor;
		op = stbtt__buf_get8( b );
		if( op == 12 )  op = stbtt__buf_get8( b ) | 0x100;
		if( op == key ) return stbtt__buf_range( b, start, end - start );
	}
	return stbtt__buf_range( b, 0, 0 );
}

static void stbtt__dict_get_ints( stbtt__buf* b, int key, int outcount, stbtt_uint32* out )
{
	int i;
	stbtt__buf operands = stbtt__dict_get( b, key );
	for( i = 0; i < outcount && operands.cursor < operands.size; i++ )
		out[ i ] = stbtt__cff_int( &operands );
}

static int stbtt__cff_index_count( stbtt__buf* b )
{
	stbtt__buf_seek( b, 0 );
	return stbtt__buf_get16( b );
}

static stbtt__buf stbtt__cff_index_get( stbtt__buf b, int i )
{
	int count, offsize, start, end;
	stbtt__buf_seek( &b, 0 );
	count = stbtt__buf_get16( &b );
	offsize = stbtt__buf_get8( &b );
	STBTT_assert( i >= 0 && i < count );
	STBTT_assert( offsize >= 1 && offsize <= 4 );
	stbtt__buf_skip( &b, i * offsize );
	start = stbtt__buf_get( &b, offsize );
	end = stbtt__buf_get( &b, offsize );
	return stbtt__buf_range( &b, 2 + ( count + 1 ) * offsize + start, end - start );
}

//////////////////////////////////////////////////////////////////////////
//
// accessors to parse data from file
//

// on platforms that don't allow misaligned reads, if we want to allow
// truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE

#define ttBYTE(p)     (* (stbtt_uint8 *) (p))
#define ttCHAR(p)     (* (stbtt_int8 *) (p))
#define ttFixed(p)    ttLONG(p)

static stbtt_uint16 ttUSHORT( stbtt_uint8* p )
{
	return p[ 0 ] * 256 + p[ 1 ];
}
static stbtt_int16 ttSHORT( stbtt_uint8* p )
{
	return p[ 0 ] * 256 + p[ 1 ];
}
static stbtt_uint32 ttULONG( stbtt_uint8* p )
{
	return ( p[ 0 ] << 24 ) + ( p[ 1 ] << 16 ) + ( p[ 2 ] << 8 ) + p[ 3 ];
}
static stbtt_int32 ttLONG( stbtt_uint8* p )
{
	return ( p[ 0 ] << 24 ) + ( p[ 1 ] << 16 ) + ( p[ 2 ] << 8 ) + p[ 3 ];
}

#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])

static int stbtt__isfont( stbtt_uint8* font )
{
	// check the version number
	if( stbtt_tag4( font, '1', 0, 0, 0 ) )  return 1; // TrueType 1
	if( stbtt_tag( font, "typ1" ) )   return 1; // TrueType with type 1 font -- we don't support this!
	if( stbtt_tag( font, "OTTO" ) )   return 1; // OpenType with CFF
	if( stbtt_tag4( font, 0, 1, 0, 0 ) ) return 1; // OpenType 1.0
	if( stbtt_tag( font, "true" ) )   return 1; // Apple specification for TrueType fonts
	return 0;
}

// @OPTIMIZE: binary search
static stbtt_uint32 stbtt__find_table( stbtt_uint8* data, stbtt_uint32 fontstart, const char* tag )
{
	stbtt_int32 num_tables = ttUSHORT( data + fontstart + 4 );
	stbtt_uint32 tabledir = fontstart + 12;
	stbtt_int32 i;
	for( i = 0; i < num_tables; ++i )
	{
		stbtt_uint32 loc = tabledir + 16 * i;
		if( stbtt_tag( data + loc + 0, tag ) )
			return ttULONG( data + loc + 8 );
	}
	return 0;
}

static int stbtt_GetFontOffsetForIndex_internal( unsigned char* font_collection, int index )
{
	// if it's just a font, there's only one valid index
	if( stbtt__isfont( font_collection ) )
		return index == 0 ? 0 : -1;

	// check if it's a TTC
	if( stbtt_tag( font_collection, "ttcf" ) )
	{
		// version 1?
		if( ttULONG( font_collection + 4 ) == 0x00010000 || ttULONG( font_collection + 4 ) == 0x00020000 )
		{
			stbtt_int32 n = ttLONG( font_collection + 8 );
			if( index >= n )
				return -1;
			return ttULONG( font_collection + 12 + index * 4 );
		}
	}
	return -1;
}

static int stbtt_GetNumberOfFonts_internal( unsigned char* font_collection )
{
	// if it's just a font, there's only one valid font
	if( stbtt__isfont( font_collection ) )
		return 1;

	// check if it's a TTC
	if( stbtt_tag( font_collection, "ttcf" ) )
	{
		// version 1?
		if( ttULONG( font_collection + 4 ) == 0x00010000 || ttULONG( font_collection + 4 ) == 0x00020000 )
		{
			return ttLONG( font_collection + 8 );
		}
	}
	return 0;
}

static stbtt__buf stbtt__get_subrs( stbtt__buf cff, stbtt__buf fontdict )
{
	stbtt_uint32 subrsoff = 0, private_loc[ 2 ] = { 0, 0 };
	stbtt__buf pdict;
	stbtt__dict_get_ints( &fontdict, 18, 2, private_loc );
	if( !private_loc[ 1 ] || !private_loc[ 0 ] ) return stbtt__new_buf( NULL, 0 );
	pdict = stbtt__buf_range( &cff, private_loc[ 1 ], private_loc[ 0 ] );
	stbtt__dict_get_ints( &pdict, 19, 1, &subrsoff );
	if( !subrsoff ) return stbtt__new_buf( NULL, 0 );
	stbtt__buf_seek( &cff, private_loc[ 1 ] + subrsoff );
	return stbtt__cff_get_index( &cff );
}

static int stbtt_InitFont_internal( stbtt_fontinfo* info, unsigned char* data, int fontstart )
{
	stbtt_uint32 cmap, t;
	stbtt_int32 i, numTables;

	info->data = data;
	info->fontstart = fontstart;
	info->cff = stbtt__new_buf( NULL, 0 );

	cmap = stbtt__find_table( data, fontstart, SECURE("cmap") );       // required
	info->loca = stbtt__find_table( data, fontstart, SECURE("loca") ); // required
	info->head = stbtt__find_table( data, fontstart, SECURE("head") ); // required
	info->glyf = stbtt__find_table( data, fontstart, SECURE("glyf") ); // required
	info->hhea = stbtt__find_table( data, fontstart, SECURE("hhea") ); // required
	info->hmtx = stbtt__find_table( data, fontstart, SECURE("hmtx") ); // required
	info->kern = stbtt__find_table( data, fontstart, SECURE("kern") ); // not required
	info->gpos = stbtt__find_table( data, fontstart, SECURE("GPOS") ); // not required

	if( !cmap || !info->head || !info->hhea || !info->hmtx )
		return 0;
	if( info->glyf )
	{
		// required for truetype
		if( !info->loca ) return 0;
	}
	else
	{
		// initialization for CFF / Type2 fonts (OTF)
		stbtt__buf b, topdict, topdictidx;
		stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
		stbtt_uint32 cff;

		cff = stbtt__find_table( data, fontstart, SECURE("CFF ") );
		if( !cff ) return 0;

		info->fontdicts = stbtt__new_buf( NULL, 0 );
		info->fdselect = stbtt__new_buf( NULL, 0 );

		// @TODO this should use size from table (not 512MB)
		info->cff = stbtt__new_buf( data + cff, 512 * 1024 * 1024 );
		b = info->cff;

		// read the header
		stbtt__buf_skip( &b, 2 );
		stbtt__buf_seek( &b, stbtt__buf_get8( &b ) ); // hdrsize

		// @TODO the name INDEX could list multiple fonts,
		// but we just use the first one.
		stbtt__cff_get_index( &b );  // name INDEX
		topdictidx = stbtt__cff_get_index( &b );
		topdict = stbtt__cff_index_get( topdictidx, 0 );
		stbtt__cff_get_index( &b );  // string INDEX
		info->gsubrs = stbtt__cff_get_index( &b );

		stbtt__dict_get_ints( &topdict, 17, 1, &charstrings );
		stbtt__dict_get_ints( &topdict, 0x100 | 6, 1, &cstype );
		stbtt__dict_get_ints( &topdict, 0x100 | 36, 1, &fdarrayoff );
		stbtt__dict_get_ints( &topdict, 0x100 | 37, 1, &fdselectoff );
		info->subrs = stbtt__get_subrs( b, topdict );

		// we only support Type 2 charstrings
		if( cstype != 2 ) return 0;
		if( charstrings == 0 ) return 0;

		if( fdarrayoff )
		{
			// looks like a CID font
			if( !fdselectoff ) return 0;
			stbtt__buf_seek( &b, fdarrayoff );
			info->fontdicts = stbtt__cff_get_index( &b );
			info->fdselect = stbtt__buf_range( &b, fdselectoff, b.size - fdselectoff );
		}

		stbtt__buf_seek( &b, charstrings );
		info->charstrings = stbtt__cff_get_index( &b );
	}

	t = stbtt__find_table( data, fontstart, SECURE("maxp") );
	if( t )
		info->numGlyphs = ttUSHORT( data + t + 4 );
	else
		info->numGlyphs = 0xffff;

	// find a cmap encoding table we understand *now* to avoid searching
	// later. (todo: could make this installable)
	// the same regardless of glyph.
	numTables = ttUSHORT( data + cmap + 2 );
	info->index_map = 0;
	for( i = 0; i < numTables; ++i )
	{
		stbtt_uint32 encoding_record = cmap + 4 + 8 * i;
		// find an encoding we understand:
		switch( ttUSHORT( data + encoding_record ) )
		{
			case STBTT_PLATFORM_ID_MICROSOFT:
				switch( ttUSHORT( data + encoding_record + 2 ) )
				{
					case STBTT_MS_EID_UNICODE_BMP:
					case STBTT_MS_EID_UNICODE_FULL:
						// MS/Unicode
						info->index_map = cmap + ttULONG( data + encoding_record + 4 );
						break;
				}
				break;
			case STBTT_PLATFORM_ID_UNICODE:
				// Mac/iOS has these
				// all the encodingIDs are unicode, so we don't bother to check it
				info->index_map = cmap + ttULONG( data + encoding_record + 4 );
				break;
		}
	}
	if( info->index_map == 0 )
		return 0;

	info->indexToLocFormat = ttUSHORT( data + info->head + 50 );
	return 1;
}

STBTT_DEF int stbtt_FindGlyphIndex( const stbtt_fontinfo* info, int unicode_codepoint )
{
	stbtt_uint8* data = info->data;
	stbtt_uint32 index_map = info->index_map;

	stbtt_uint16 format = ttUSHORT( data + index_map + 0 );
	if( format == 0 )
	{ // apple byte encoding
		stbtt_int32 bytes = ttUSHORT( data + index_map + 2 );
		if( unicode_codepoint < bytes - 6 )
			return ttBYTE( data + index_map + 6 + unicode_codepoint );
		return 0;
	}
	else if( format == 6 )
	{
		stbtt_uint32 first = ttUSHORT( data + index_map + 6 );
		stbtt_uint32 count = ttUSHORT( data + index_map + 8 );
		if( ( stbtt_uint32 )unicode_codepoint >= first && ( stbtt_uint32 )unicode_codepoint < first + count )
			return ttUSHORT( data + index_map + 10 + ( unicode_codepoint - first ) * 2 );
		return 0;
	}
	else if( format == 2 )
	{
		STBTT_assert( 0 ); // @TODO: high-byte mapping for japanese/chinese/korean
		return 0;
	}
	else if( format == 4 )
	{ // standard mapping for windows fonts: binary search collection of ranges
		stbtt_uint16 segcount = ttUSHORT( data + index_map + 6 ) >> 1;
		stbtt_uint16 searchRange = ttUSHORT( data + index_map + 8 ) >> 1;
		stbtt_uint16 entrySelector = ttUSHORT( data + index_map + 10 );
		stbtt_uint16 rangeShift = ttUSHORT( data + index_map + 12 ) >> 1;

		// do a binary search of the segments
		stbtt_uint32 endCount = index_map + 14;
		stbtt_uint32 search = endCount;

		if( unicode_codepoint > 0xffff )
			return 0;

		// they lie from endCount .. endCount + segCount
		// but searchRange is the nearest power of two, so...
		if( unicode_codepoint >= ttUSHORT( data + search + rangeShift * 2 ) )
			search += rangeShift * 2;

		// now decrement to bias correctly to find smallest
		search -= 2;
		while( entrySelector )
		{
			stbtt_uint16 end;
			searchRange >>= 1;
			end = ttUSHORT( data + search + searchRange * 2 );
			if( unicode_codepoint > end )
				search += searchRange * 2;
			--entrySelector;
		}
		search += 2;

		{
			stbtt_uint16 offset, start;
			stbtt_uint16 item = ( stbtt_uint16 )( ( search - endCount ) >> 1 );

			STBTT_assert( unicode_codepoint <= ttUSHORT( data + endCount + 2 * item ) );
			start = ttUSHORT( data + index_map + 14 + segcount * 2 + 2 + 2 * item );
			if( unicode_codepoint < start )
				return 0;

			offset = ttUSHORT( data + index_map + 14 + segcount * 6 + 2 + 2 * item );
			if( offset == 0 )
				return ( stbtt_uint16 )( unicode_codepoint + ttSHORT( data + index_map + 14 + segcount * 4 + 2 + 2 * item ) );

			return ttUSHORT( data + offset + ( unicode_codepoint - start ) * 2 + index_map + 14 + segcount * 6 + 2 + 2 * item );
		}
	}
	else if( format == 12 || format == 13 )
	{
		stbtt_uint32 ngroups = ttULONG( data + index_map + 12 );
		stbtt_int32 low, high;
		low = 0; high = ( stbtt_int32 )ngroups;
		// Binary search the right group.
		while( low < high )
		{
			stbtt_int32 mid = low + ( ( high - low ) >> 1 ); // rounds down, so low <= mid < high
			stbtt_uint32 start_char = ttULONG( data + index_map + 16 + mid * 12 );
			stbtt_uint32 end_char = ttULONG( data + index_map + 16 + mid * 12 + 4 );
			if( ( stbtt_uint32 )unicode_codepoint < start_char )
				high = mid;
			else if( ( stbtt_uint32 )unicode_codepoint > end_char )
				low = mid + 1;
			else
			{
				stbtt_uint32 start_glyph = ttULONG( data + index_map + 16 + mid * 12 + 8 );
				if( format == 12 )
					return start_glyph + unicode_codepoint - start_char;
				else // format == 13
					return start_glyph;
			}
		}
		return 0; // not found
	}
	// @TODO
	STBTT_assert( 0 );
	return 0;
}

STBTT_DEF int stbtt_GetCodepointShape( const stbtt_fontinfo* info, int unicode_codepoint, stbtt_vertex** vertices )
{
	return stbtt_GetGlyphShape( info, stbtt_FindGlyphIndex( info, unicode_codepoint ), vertices );
}

static void stbtt_setvertex( stbtt_vertex* v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy )
{
	v->type = type;
	v->x = ( stbtt_int16 )x;
	v->y = ( stbtt_int16 )y;
	v->cx = ( stbtt_int16 )cx;
	v->cy = ( stbtt_int16 )cy;
}

static int stbtt__GetGlyfOffset( const stbtt_fontinfo* info, int glyph_index )
{
	int g1, g2;

	STBTT_assert( !info->cff.size );

	if( glyph_index >= info->numGlyphs ) return -1; // glyph index out of range
	if( info->indexToLocFormat >= 2 )    return -1; // unknown index->glyph map format

	if( info->indexToLocFormat == 0 )
	{
		g1 = info->glyf + ttUSHORT( info->data + info->loca + glyph_index * 2 ) * 2;
		g2 = info->glyf + ttUSHORT( info->data + info->loca + glyph_index * 2 + 2 ) * 2;
	}
	else
	{
		g1 = info->glyf + ttULONG( info->data + info->loca + glyph_index * 4 );
		g2 = info->glyf + ttULONG( info->data + info->loca + glyph_index * 4 + 4 );
	}

	return g1 == g2 ? -1 : g1; // if length is 0, return -1
}

static int stbtt__GetGlyphInfoT2( const stbtt_fontinfo* info, int glyph_index, int* x0, int* y0, int* x1, int* y1 );

STBTT_DEF int stbtt_GetGlyphBox( const stbtt_fontinfo* info, int glyph_index, int* x0, int* y0, int* x1, int* y1 )
{
	if( info->cff.size )
	{
		stbtt__GetGlyphInfoT2( info, glyph_index, x0, y0, x1, y1 );
	}
	else
	{
		int g = stbtt__GetGlyfOffset( info, glyph_index );
		if( g < 0 ) return 0;

		if( x0 ) *x0 = ttSHORT( info->data + g + 2 );
		if( y0 ) *y0 = ttSHORT( info->data + g + 4 );
		if( x1 ) *x1 = ttSHORT( info->data + g + 6 );
		if( y1 ) *y1 = ttSHORT( info->data + g + 8 );
	}
	return 1;
}

STBTT_DEF int stbtt_GetCodepointBox( const stbtt_fontinfo* info, int codepoint, int* x0, int* y0, int* x1, int* y1 )
{
	return stbtt_GetGlyphBox( info, stbtt_FindGlyphIndex( info, codepoint ), x0, y0, x1, y1 );
}

STBTT_DEF int stbtt_IsGlyphEmpty( const stbtt_fontinfo* info, int glyph_index )
{
	stbtt_int16 numberOfContours;
	int g;
	if( info->cff.size )
		return stbtt__GetGlyphInfoT2( info, glyph_index, NULL, NULL, NULL, NULL ) == 0;
	g = stbtt__GetGlyfOffset( info, glyph_index );
	if( g < 0 ) return 1;
	numberOfContours = ttSHORT( info->data + g );
	return numberOfContours == 0;
}

static int stbtt__close_shape( stbtt_vertex* vertices, int num_vertices, int was_off, int start_off,
															 stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy )
{
	if( start_off )
	{
		if( was_off )
			stbtt_setvertex( &vertices[ num_vertices++ ], STBTT_vcurve, ( cx + scx ) >> 1, ( cy + scy ) >> 1, cx, cy );
		stbtt_setvertex( &vertices[ num_vertices++ ], STBTT_vcurve, sx, sy, scx, scy );
	}
	else
	{
		if( was_off )
			stbtt_setvertex( &vertices[ num_vertices++ ], STBTT_vcurve, sx, sy, cx, cy );
		else
			stbtt_setvertex( &vertices[ num_vertices++ ], STBTT_vline, sx, sy, 0, 0 );
	}
	return num_vertices;
}

static int stbtt__GetGlyphShapeTT( const stbtt_fontinfo* info, int glyph_index, stbtt_vertex** pvertices )
{
	stbtt_int16 numberOfContours;
	stbtt_uint8* endPtsOfContours;
	stbtt_uint8* data = info->data;
	stbtt_vertex* vertices = 0;
	int num_vertices = 0;
	int g = stbtt__GetGlyfOffset( info, glyph_index );

	*pvertices = NULL;

	if( g < 0 ) return 0;

	numberOfContours = ttSHORT( data + g );

	if( numberOfContours > 0 )
	{
		stbtt_uint8 flags = 0, flagcount;
		stbtt_int32 ins, i, j = 0, m, n, next_move, was_off = 0, off, start_off = 0;
		stbtt_int32 x, y, cx, cy, sx, sy, scx, scy;
		stbtt_uint8* points;
		endPtsOfContours = ( data + g + 10 );
		ins = ttUSHORT( data + g + 10 + numberOfContours * 2 );
		points = data + g + 10 + numberOfContours * 2 + 2 + ins;

		n = 1 + ttUSHORT( endPtsOfContours + numberOfContours * 2 - 2 );

		m = n + 2 * numberOfContours;  // a loose bound on how many vertices we might need
		vertices = ( stbtt_vertex* )STBTT_malloc( m * sizeof( vertices[ 0 ] ), info->userdata );
		if( vertices == 0 )
			return 0;

		next_move = 0;
		flagcount = 0;

		// in first pass, we load uninterpreted data into the allocated array
		// above, shifted to the end of the array so we won't overwrite it when
		// we create our final data starting from the front

		off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated

		// first load flags

		for( i = 0; i < n; ++i )
		{
			if( flagcount == 0 )
			{
				flags = *points++;
				if( flags & 8 )
					flagcount = *points++;
			}
			else
				--flagcount;
			vertices[ off + i ].type = flags;
		}

		// now load x coordinates
		x = 0;
		for( i = 0; i < n; ++i )
		{
			flags = vertices[ off + i ].type;
			if( flags & 2 )
			{
				stbtt_int16 dx = *points++;
				x += ( flags & 16 ) ? dx : -dx; // ???
			}
			else
			{
				if( !( flags & 16 ) )
				{
					x = x + ( stbtt_int16 )( points[ 0 ] * 256 + points[ 1 ] );
					points += 2;
				}
			}
			vertices[ off + i ].x = ( stbtt_int16 )x;
		}

		// now load y coordinates
		y = 0;
		for( i = 0; i < n; ++i )
		{
			flags = vertices[ off + i ].type;
			if( flags & 4 )
			{
				stbtt_int16 dy = *points++;
				y += ( flags & 32 ) ? dy : -dy; // ???
			}
			else
			{
				if( !( flags & 32 ) )
				{
					y = y + ( stbtt_int16 )( points[ 0 ] * 256 + points[ 1 ] );
					points += 2;
				}
			}
			vertices[ off + i ].y = ( stbtt_int16 )y;
		}

		// now convert them to our format
		num_vertices = 0;
		sx = sy = cx = cy = scx = scy = 0;
		for( i = 0; i < n; ++i )
		{
			flags = vertices[ off + i ].type;
			x = ( stbtt_int16 )vertices[ off + i ].x;
			y = ( stbtt_int16 )vertices[ off + i ].y;

			if( next_move == i )
			{
				if( i != 0 )
					num_vertices = stbtt__close_shape( vertices, num_vertices, was_off, start_off, sx, sy, scx, scy, cx, cy );

				// now start the new one               
				start_off = !( flags & 1 );
				if( start_off )
				{
					// if we start off with an off-curve point, then when we need to find a point on the curve
					// where we can start, and we need to save some state for when we wraparound.
					scx = x;
					scy = y;
					if( !( vertices[ off + i + 1 ].type & 1 ) )
					{
						// next point is also a curve point, so interpolate an on-point curve
						sx = ( x + ( stbtt_int32 )vertices[ off + i + 1 ].x ) >> 1;
						sy = ( y + ( stbtt_int32 )vertices[ off + i + 1 ].y ) >> 1;
					}
					else
					{
						// otherwise just use the next point as our start point
						sx = ( stbtt_int32 )vertices[ off + i + 1 ].x;
						sy = ( stbtt_int32 )vertices[ off + i + 1 ].y;
						++i; // we're using point i+1 as the starting point, so skip it
					}
				}
				else
				{
					sx = x;
					sy = y;
				}
				stbtt_setvertex( &vertices[ num_vertices++ ], STBTT_vmove, sx, sy, 0, 0 );
				was_off = 0;
				next_move = 1 + ttUSHORT( endPtsOfContours + j * 2 );
				++j;
			}
			else
			{
				if( !( flags & 1 ) )
				{ // if it's a curve
					if( was_off ) // two off-curve control points in a row means interpolate an on-curve midpoint
						stbtt_setvertex( &vertices[ num_vertices++ ], STBTT_vcurve, ( cx + x ) >> 1, ( cy + y ) >> 1, cx, cy );
					cx = x;
					cy = y;
					was_off = 1;
				}
				else
				{
					if( was_off )
						stbtt_setvertex( &vertices[ num_vertices++ ], STBTT_vcurve, x, y, cx, cy );
					else
						stbtt_setvertex( &vertices[ num_vertices++ ], STBTT_vline, x, y, 0, 0 );
					was_off = 0;
				}
			}
		}
		num_vertices = stbtt__close_shape( vertices, num_vertices, was_off, start_off, sx, sy, scx, scy, cx, cy );
	}
	else if( numberOfContours == -1 )
	{
		// Compound shapes.
		int more = 1;
		stbtt_uint8* comp = data + g + 10;
		num_vertices = 0;
		vertices = 0;
		while( more )
		{
			stbtt_uint16 flags, gidx;
			int comp_num_verts = 0, i;
			stbtt_vertex* comp_verts = 0, * tmp = 0;
			float mtx[ 6 ] = { 1,0,0,1,0,0 }, m, n;

			flags = ttSHORT( comp ); comp += 2;
			gidx = ttSHORT( comp ); comp += 2;

			if( flags & 2 )
			{ // XY values
				if( flags & 1 )
				{ // shorts
					mtx[ 4 ] = ttSHORT( comp ); comp += 2;
					mtx[ 5 ] = ttSHORT( comp ); comp += 2;
				}
				else
				{
					mtx[ 4 ] = ttCHAR( comp ); comp += 1;
					mtx[ 5 ] = ttCHAR( comp ); comp += 1;
				}
			}
			else
			{
				// @TODO handle matching point
				STBTT_assert( 0 );
			}
			if( flags & ( 1 << 3 ) )
			{ // WE_HAVE_A_SCALE
				mtx[ 0 ] = mtx[ 3 ] = ttSHORT( comp ) / 16384.0f; comp += 2;
				mtx[ 1 ] = mtx[ 2 ] = 0;
			}
			else if( flags & ( 1 << 6 ) )
			{ // WE_HAVE_AN_X_AND_YSCALE
				mtx[ 0 ] = ttSHORT( comp ) / 16384.0f; comp += 2;
				mtx[ 1 ] = mtx[ 2 ] = 0;
				mtx[ 3 ] = ttSHORT( comp ) / 16384.0f; comp += 2;
			}
			else if( flags & ( 1 << 7 ) )
			{ // WE_HAVE_A_TWO_BY_TWO
				mtx[ 0 ] = ttSHORT( comp ) / 16384.0f; comp += 2;
				mtx[ 1 ] = ttSHORT( comp ) / 16384.0f; comp += 2;
				mtx[ 2 ] = ttSHORT( comp ) / 16384.0f; comp += 2;
				mtx[ 3 ] = ttSHORT( comp ) / 16384.0f; comp += 2;
			}

			// Find transformation scales.
			m = ( float )STBTT_sqrt( mtx[ 0 ] * mtx[ 0 ] + mtx[ 1 ] * mtx[ 1 ] );
			n = ( float )STBTT_sqrt( mtx[ 2 ] * mtx[ 2 ] + mtx[ 3 ] * mtx[ 3 ] );

			// Get indexed glyph.
			comp_num_verts = stbtt_GetGlyphShape( info, gidx, &comp_verts );
			if( comp_num_verts > 0 )
			{
				// Transform vertices.
				for( i = 0; i < comp_num_verts; ++i )
				{
					stbtt_vertex* v = &comp_verts[ i ];
					stbtt_vertex_type x, y;
					x = v->x; y = v->y;
					v->x = ( stbtt_vertex_type )( m * ( mtx[ 0 ] * x + mtx[ 2 ] * y + mtx[ 4 ] ) );
					v->y = ( stbtt_vertex_type )( n * ( mtx[ 1 ] * x + mtx[ 3 ] * y + mtx[ 5 ] ) );
					x = v->cx; y = v->cy;
					v->cx = ( stbtt_vertex_type )( m * ( mtx[ 0 ] * x + mtx[ 2 ] * y + mtx[ 4 ] ) );
					v->cy = ( stbtt_vertex_type )( n * ( mtx[ 1 ] * x + mtx[ 3 ] * y + mtx[ 5 ] ) );
				}
				// Append vertices.
				tmp = ( stbtt_vertex* )STBTT_malloc( ( num_vertices + comp_num_verts ) * sizeof( stbtt_vertex ), info->userdata );
				if( !tmp )
				{
					if( vertices ) STBTT_free( vertices, info->userdata );
					if( comp_verts ) STBTT_free( comp_verts, info->userdata );
					return 0;
				}
				if( num_vertices > 0 ) STBTT_memcpy( tmp, vertices, num_vertices * sizeof( stbtt_vertex ) ); //-V595
				STBTT_memcpy( tmp + num_vertices, comp_verts, comp_num_verts * sizeof( stbtt_vertex ) );
				if( vertices ) STBTT_free( vertices, info->userdata );
				vertices = tmp;
				STBTT_free( comp_verts, info->userdata );
				num_vertices += comp_num_verts;
			}
			// More components ?
			more = flags & ( 1 << 5 );
		}
	}
	else if( numberOfContours < 0 )
	{
		// @TODO other compound variations?
		STBTT_assert( 0 );
	}
	else
	{
		// numberOfCounters == 0, do nothing
	}

	*pvertices = vertices;
	return num_vertices;
}

typedef struct
{
	int bounds;
	int started;
	float first_x, first_y;
	float x, y;
	stbtt_int32 min_x, max_x, min_y, max_y;

	stbtt_vertex* pvertices;
	int num_vertices;
} stbtt__csctx;

#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, NULL, 0}

static void stbtt__track_vertex( stbtt__csctx* c, stbtt_int32 x, stbtt_int32 y )
{
	if( x > c->max_x || !c->started ) c->max_x = x;
	if( y > c->max_y || !c->started ) c->max_y = y;
	if( x < c->min_x || !c->started ) c->min_x = x;
	if( y < c->min_y || !c->started ) c->min_y = y;
	c->started = 1;
}

static void stbtt__csctx_v( stbtt__csctx* c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1 )
{
	if( c->bounds )
	{
		stbtt__track_vertex( c, x, y );
		if( type == STBTT_vcubic )
		{
			stbtt__track_vertex( c, cx, cy );
			stbtt__track_vertex( c, cx1, cy1 );
		}
	}
	else
	{
		stbtt_setvertex( &c->pvertices[ c->num_vertices ], type, x, y, cx, cy );
		c->pvertices[ c->num_vertices ].cx1 = ( stbtt_int16 )cx1;
		c->pvertices[ c->num_vertices ].cy1 = ( stbtt_int16 )cy1;
	}
	c->num_vertices++;
}

static void stbtt__csctx_close_shape( stbtt__csctx* ctx )
{
	if( ctx->first_x != ctx->x || ctx->first_y != ctx->y )
		stbtt__csctx_v( ctx, STBTT_vline, ( int )ctx->first_x, ( int )ctx->first_y, 0, 0, 0, 0 );
}

static void stbtt__csctx_rmove_to( stbtt__csctx* ctx, float dx, float dy )
{
	stbtt__csctx_close_shape( ctx );
	ctx->first_x = ctx->x = ctx->x + dx;
	ctx->first_y = ctx->y = ctx->y + dy;
	stbtt__csctx_v( ctx, STBTT_vmove, ( int )ctx->x, ( int )ctx->y, 0, 0, 0, 0 );
}

static void stbtt__csctx_rline_to( stbtt__csctx* ctx, float dx, float dy )
{
	ctx->x += dx;
	ctx->y += dy;
	stbtt__csctx_v( ctx, STBTT_vline, ( int )ctx->x, ( int )ctx->y, 0, 0, 0, 0 );
}

static void stbtt__csctx_rccurve_to( stbtt__csctx* ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3 )
{
	float cx1 = ctx->x + dx1;
	float cy1 = ctx->y + dy1;
	float cx2 = cx1 + dx2;
	float cy2 = cy1 + dy2;
	ctx->x = cx2 + dx3;
	ctx->y = cy2 + dy3;
	stbtt__csctx_v( ctx, STBTT_vcubic, ( int )ctx->x, ( int )ctx->y, ( int )cx1, ( int )cy1, ( int )cx2, ( int )cy2 );
}

static stbtt__buf stbtt__get_subr( stbtt__buf idx, int n )
{
	int count = stbtt__cff_index_count( &idx );
	int bias = 107;
	if( count >= 33900 )
		bias = 32768;
	else if( count >= 1240 )
		bias = 1131;
	n += bias;
	if( n < 0 || n >= count )
		return stbtt__new_buf( NULL, 0 );
	return stbtt__cff_index_get( idx, n );
}

static stbtt__buf stbtt__cid_get_glyph_subrs( const stbtt_fontinfo* info, int glyph_index )
{
	stbtt__buf fdselect = info->fdselect;
	int nranges, start, end, v, fmt, fdselector = -1, i;

	stbtt__buf_seek( &fdselect, 0 );
	fmt = stbtt__buf_get8( &fdselect );
	if( fmt == 0 )
	{
		// untested
		stbtt__buf_skip( &fdselect, glyph_index );
		fdselector = stbtt__buf_get8( &fdselect );
	}
	else if( fmt == 3 )
	{
		nranges = stbtt__buf_get16( &fdselect );
		start = stbtt__buf_get16( &fdselect );
		for( i = 0; i < nranges; i++ )
		{
			v = stbtt__buf_get8( &fdselect );
			end = stbtt__buf_get16( &fdselect );
			if( glyph_index >= start && glyph_index < end )
			{
				fdselector = v;
				break;
			}
			start = end;
		}
	}
	if( fdselector == -1 ) stbtt__new_buf( NULL, 0 );
	return stbtt__get_subrs( info->cff, stbtt__cff_index_get( info->fontdicts, fdselector ) );
}

static int stbtt__run_charstring( const stbtt_fontinfo* info, int glyph_index, stbtt__csctx* c )
{
	int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;
	int has_subrs = 0, clear_stack;
	float s[ 48 ];
	stbtt__buf subr_stack[ 10 ], subrs = info->subrs, b;
	float f;

#define STBTT__CSERR(s) (0)

	// this currently ignores the initial width value, which isn't needed if we have hmtx
	b = stbtt__cff_index_get( info->charstrings, glyph_index );
	while( b.cursor < b.size )
	{
		i = 0;
		clear_stack = 1;
		b0 = stbtt__buf_get8( &b );
		switch( b0 )
		{
			// @TODO implement hinting
			case 0x13: // hintmask
			case 0x14: // cntrmask
				if( in_header )
					maskbits += ( sp / 2 ); // implicit "vstem"
				in_header = 0;
				stbtt__buf_skip( &b, ( maskbits + 7 ) / 8 );
				break;

			case 0x01: // hstem
			case 0x03: // vstem
			case 0x12: // hstemhm
			case 0x17: // vstemhm
				maskbits += ( sp / 2 );
				break;

			case 0x15: // rmoveto
				in_header = 0;
				if( sp < 2 ) return STBTT__CSERR( "rmoveto stack" );
				stbtt__csctx_rmove_to( c, s[ sp - 2 ], s[ sp - 1 ] );
				break;
			case 0x04: // vmoveto
				in_header = 0;
				if( sp < 1 ) return STBTT__CSERR( "vmoveto stack" );
				stbtt__csctx_rmove_to( c, 0, s[ sp - 1 ] );
				break;
			case 0x16: // hmoveto
				in_header = 0;
				if( sp < 1 ) return STBTT__CSERR( "hmoveto stack" );
				stbtt__csctx_rmove_to( c, s[ sp - 1 ], 0 );
				break;

			case 0x05: // rlineto
				if( sp < 2 ) return STBTT__CSERR( "rlineto stack" );
				for( ; i + 1 < sp; i += 2 )
					stbtt__csctx_rline_to( c, s[ i ], s[ i + 1 ] );
				break;

				// hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
				// starting from a different place.

			case 0x07: // vlineto
				if( sp < 1 ) return STBTT__CSERR( "vlineto stack" );
				goto vlineto;
			case 0x06: // hlineto
				if( sp < 1 ) return STBTT__CSERR( "hlineto stack" );
				for( ;;)
				{
					if( i >= sp ) break;
					stbtt__csctx_rline_to( c, s[ i ], 0 );
					i++;
				vlineto:
					if( i >= sp ) break;
					stbtt__csctx_rline_to( c, 0, s[ i ] );
					i++;
				}
				break;

			case 0x1F: // hvcurveto
				if( sp < 4 ) return STBTT__CSERR( "hvcurveto stack" );
				goto hvcurveto;
			case 0x1E: // vhcurveto
				if( sp < 4 ) return STBTT__CSERR( "vhcurveto stack" );
				for( ;;)
				{
					if( i + 3 >= sp ) break;
					stbtt__csctx_rccurve_to( c, 0, s[ i ], s[ i + 1 ], s[ i + 2 ], s[ i + 3 ], ( sp - i == 5 ) ? s[ i + 4 ] : 0.0f );
					i += 4;
				hvcurveto:
					if( i + 3 >= sp ) break;
					stbtt__csctx_rccurve_to( c, s[ i ], 0, s[ i + 1 ], s[ i + 2 ], ( sp - i == 5 ) ? s[ i + 4 ] : 0.0f, s[ i + 3 ] );
					i += 4;
				}
				break;

			case 0x08: // rrcurveto
				if( sp < 6 ) return STBTT__CSERR( "rcurveline stack" );
				for( ; i + 5 < sp; i += 6 )
					stbtt__csctx_rccurve_to( c, s[ i ], s[ i + 1 ], s[ i + 2 ], s[ i + 3 ], s[ i + 4 ], s[ i + 5 ] );
				break;

			case 0x18: // rcurveline
				if( sp < 8 ) return STBTT__CSERR( "rcurveline stack" );
				for( ; i + 5 < sp - 2; i += 6 )
					stbtt__csctx_rccurve_to( c, s[ i ], s[ i + 1 ], s[ i + 2 ], s[ i + 3 ], s[ i + 4 ], s[ i + 5 ] );
				if( i + 1 >= sp ) return STBTT__CSERR( "rcurveline stack" );
				stbtt__csctx_rline_to( c, s[ i ], s[ i + 1 ] );
				break;

			case 0x19: // rlinecurve
				if( sp < 8 ) return STBTT__CSERR( "rlinecurve stack" );
				for( ; i + 1 < sp - 6; i += 2 )
					stbtt__csctx_rline_to( c, s[ i ], s[ i + 1 ] );
				if( i + 5 >= sp ) return STBTT__CSERR( "rlinecurve stack" );
				stbtt__csctx_rccurve_to( c, s[ i ], s[ i + 1 ], s[ i + 2 ], s[ i + 3 ], s[ i + 4 ], s[ i + 5 ] );
				break;

			case 0x1A: // vvcurveto
			case 0x1B: // hhcurveto
				if( sp < 4 ) return STBTT__CSERR( "(vv|hh)curveto stack" );
				f = 0.0;
				if( sp & 1 )
				{
					f = s[ i ]; i++;
				}
				for( ; i + 3 < sp; i += 4 )
				{
					if( b0 == 0x1B )
						stbtt__csctx_rccurve_to( c, s[ i ], f, s[ i + 1 ], s[ i + 2 ], s[ i + 3 ], 0.0 );
					else
						stbtt__csctx_rccurve_to( c, f, s[ i ], s[ i + 1 ], s[ i + 2 ], 0.0, s[ i + 3 ] );
					f = 0.0;
				}
				break;

			case 0x0A: // callsubr
				if( !has_subrs )
				{
					if( info->fdselect.size )
						subrs = stbtt__cid_get_glyph_subrs( info, glyph_index );
					has_subrs = 1;
				}
				// fallthrough
			case 0x1D: // callgsubr
				if( sp < 1 ) return STBTT__CSERR( "call(g|)subr stack" );
				v = ( int )s[ --sp ];
				if( subr_stack_height >= 10 ) return STBTT__CSERR( "recursion limit" );
				subr_stack[ subr_stack_height++ ] = b;
				b = stbtt__get_subr( b0 == 0x0A ? subrs : info->gsubrs, v );
				if( b.size == 0 ) return STBTT__CSERR( "subr not found" );
				b.cursor = 0;
				clear_stack = 0;
				break;

			case 0x0B: // return
				if( subr_stack_height <= 0 ) return STBTT__CSERR( "return outside subr" );
				b = subr_stack[ --subr_stack_height ];
				clear_stack = 0;
				break;

			case 0x0E: // endchar
				stbtt__csctx_close_shape( c );
				return 1;

			case 0x0C:
			{ // two-byte escape
				float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
				float dx, dy;
				int b1 = stbtt__buf_get8( &b );
				switch( b1 )
				{
					// @TODO These "flex" implementations ignore the flex-depth and resolution,
					// and always draw beziers.
					case 0x22: // hflex
						if( sp < 7 ) return STBTT__CSERR( "hflex stack" );
						dx1 = s[ 0 ];
						dx2 = s[ 1 ];
						dy2 = s[ 2 ];
						dx3 = s[ 3 ];
						dx4 = s[ 4 ];
						dx5 = s[ 5 ];
						dx6 = s[ 6 ];
						stbtt__csctx_rccurve_to( c, dx1, 0, dx2, dy2, dx3, 0 );
						stbtt__csctx_rccurve_to( c, dx4, 0, dx5, -dy2, dx6, 0 );
						break;

					case 0x23: // flex
						if( sp < 13 ) return STBTT__CSERR( "flex stack" );
						dx1 = s[ 0 ];
						dy1 = s[ 1 ];
						dx2 = s[ 2 ];
						dy2 = s[ 3 ];
						dx3 = s[ 4 ];
						dy3 = s[ 5 ];
						dx4 = s[ 6 ];
						dy4 = s[ 7 ];
						dx5 = s[ 8 ];
						dy5 = s[ 9 ];
						dx6 = s[ 10 ];
						dy6 = s[ 11 ];
						//fd is s[12]
						stbtt__csctx_rccurve_to( c, dx1, dy1, dx2, dy2, dx3, dy3 );
						stbtt__csctx_rccurve_to( c, dx4, dy4, dx5, dy5, dx6, dy6 );
						break;

					case 0x24: // hflex1
						if( sp < 9 ) return STBTT__CSERR( "hflex1 stack" );
						dx1 = s[ 0 ];
						dy1 = s[ 1 ];
						dx2 = s[ 2 ];
						dy2 = s[ 3 ];
						dx3 = s[ 4 ];
						dx4 = s[ 5 ];
						dx5 = s[ 6 ];
						dy5 = s[ 7 ];
						dx6 = s[ 8 ];
						stbtt__csctx_rccurve_to( c, dx1, dy1, dx2, dy2, dx3, 0 );
						stbtt__csctx_rccurve_to( c, dx4, 0, dx5, dy5, dx6, -( dy1 + dy2 + dy5 ) );
						break;

					case 0x25: // flex1
						if( sp < 11 ) return STBTT__CSERR( "flex1 stack" );
						dx1 = s[ 0 ];
						dy1 = s[ 1 ];
						dx2 = s[ 2 ];
						dy2 = s[ 3 ];
						dx3 = s[ 4 ];
						dy3 = s[ 5 ];
						dx4 = s[ 6 ];
						dy4 = s[ 7 ];
						dx5 = s[ 8 ];
						dy5 = s[ 9 ];
						dx6 = dy6 = s[ 10 ];
						dx = dx1 + dx2 + dx3 + dx4 + dx5;
						dy = dy1 + dy2 + dy3 + dy4 + dy5;
						if( STBTT_fabs( dx ) > STBTT_fabs( dy ) )
							dy6 = -dy;
						else
							dx6 = -dx;
						stbtt__csctx_rccurve_to( c, dx1, dy1, dx2, dy2, dx3, dy3 );
						stbtt__csctx_rccurve_to( c, dx4, dy4, dx5, dy5, dx6, dy6 );
						break;

					default:
						return STBTT__CSERR( "unimplemented" );
				}
			} break;

			default:
				if( b0 != 255 && b0 != 28 && ( b0 < 32 || b0 > 254 ) ) //-V560
					return STBTT__CSERR( "reserved operator" );

				// push immediate
				if( b0 == 255 )
				{
					f = ( float )( stbtt_int32 )stbtt__buf_get32( &b ) / 0x10000;
				}
				else
				{
					stbtt__buf_skip( &b, -1 );
					f = ( float )( stbtt_int16 )stbtt__cff_int( &b );
				}
				if( sp >= 48 ) return STBTT__CSERR( "push stack overflow" );
				s[ sp++ ] = f;
				clear_stack = 0;
				break;
		}
		if( clear_stack ) sp = 0;
	}
	return STBTT__CSERR( "no endchar" );

#undef STBTT__CSERR
}

static int stbtt__GetGlyphShapeT2( const stbtt_fontinfo* info, int glyph_index, stbtt_vertex** pvertices )
{
	// runs the charstring twice, once to count and once to output (to avoid realloc)
	stbtt__csctx count_ctx = STBTT__CSCTX_INIT( 1 );
	stbtt__csctx output_ctx = STBTT__CSCTX_INIT( 0 );
	if( stbtt__run_charstring( info, glyph_index, &count_ctx ) )
	{
		*pvertices = ( stbtt_vertex* )STBTT_malloc( count_ctx.num_vertices * sizeof( stbtt_vertex ), info->userdata );
		output_ctx.pvertices = *pvertices;
		if( stbtt__run_charstring( info, glyph_index, &output_ctx ) )
		{
			STBTT_assert( output_ctx.num_vertices == count_ctx.num_vertices );
			return output_ctx.num_vertices;
		}
	}
	*pvertices = NULL;
	return 0;
}

static int stbtt__GetGlyphInfoT2( const stbtt_fontinfo* info, int glyph_index, int* x0, int* y0, int* x1, int* y1 )
{
	stbtt__csctx c = STBTT__CSCTX_INIT( 1 );
	int r = stbtt__run_charstring( info, glyph_index, &c );
	if( x0 )  *x0 = r ? c.min_x : 0;
	if( y0 )  *y0 = r ? c.min_y : 0;
	if( x1 )  *x1 = r ? c.max_x : 0;
	if( y1 )  *y1 = r ? c.max_y : 0;
	return r ? c.num_vertices : 0;
}

STBTT_DEF int stbtt_GetGlyphShape( const stbtt_fontinfo* info, int glyph_index, stbtt_vertex** pvertices )
{
	if( !info->cff.size )
		return stbtt__GetGlyphShapeTT( info, glyph_index, pvertices );
	else
		return stbtt__GetGlyphShapeT2( info, glyph_index, pvertices );
}

STBTT_DEF void stbtt_GetGlyphHMetrics( const stbtt_fontinfo* info, int glyph_index, int* advanceWidth, int* leftSideBearing )
{
	stbtt_uint16 numOfLongHorMetrics = ttUSHORT( info->data + info->hhea + 34 );
	if( glyph_index < numOfLongHorMetrics )
	{
		if( advanceWidth )     *advanceWidth = ttSHORT( info->data + info->hmtx + 4 * glyph_index );
		if( leftSideBearing )  *leftSideBearing = ttSHORT( info->data + info->hmtx + 4 * glyph_index + 2 );
	}
	else
	{
		if( advanceWidth )     *advanceWidth = ttSHORT( info->data + info->hmtx + 4 * ( numOfLongHorMetrics - 1 ) );
		if( leftSideBearing )  *leftSideBearing = ttSHORT( info->data + info->hmtx + 4 * numOfLongHorMetrics + 2 * ( glyph_index - numOfLongHorMetrics ) );
	}
}

static int  stbtt__GetGlyphKernInfoAdvance( const stbtt_fontinfo* info, int glyph1, int glyph2 )
{
	stbtt_uint8* data = info->data + info->kern;
	stbtt_uint32 needle, straw;
	int l, r, m;

	// we only look at the first table. it must be 'horizontal' and format 0.
	if( !info->kern )
		return 0;
	if( ttUSHORT( data + 2 ) < 1 ) // number of tables, need at least 1
		return 0;
	if( ttUSHORT( data + 8 ) != 1 ) // horizontal flag must be set in format
		return 0;

	l = 0;
	r = ttUSHORT( data + 10 ) - 1;
	needle = glyph1 << 16 | glyph2;
	while( l <= r )
	{
		m = ( l + r ) >> 1;
		straw = ttULONG( data + 18 + ( m * 6 ) ); // note: unaligned read
		if( needle < straw )
			r = m - 1;
		else if( needle > straw )
			l = m + 1;
		else
			return ttSHORT( data + 22 + ( m * 6 ) );
	}
	return 0;
}

static stbtt_int32  stbtt__GetCoverageIndex( stbtt_uint8* coverageTable, int glyph )
{
	stbtt_uint16 coverageFormat = ttUSHORT( coverageTable );
	switch( coverageFormat )
	{
		case 1:
		{
			stbtt_uint16 glyphCount = ttUSHORT( coverageTable + 2 );

			// Binary search.
			stbtt_int32 l = 0, r = glyphCount - 1, m;
			int straw, needle = glyph;
			while( l <= r )
			{
				stbtt_uint8* glyphArray = coverageTable + 4;
				stbtt_uint16 glyphID;
				m = ( l + r ) >> 1;
				glyphID = ttUSHORT( glyphArray + 2 * m );
				straw = glyphID;
				if( needle < straw )
					r = m - 1;
				else if( needle > straw )
					l = m + 1;
				else
				{
					return m;
				}
			}
		} break;

		case 2:
		{
			stbtt_uint16 rangeCount = ttUSHORT( coverageTable + 2 );
			stbtt_uint8* rangeArray = coverageTable + 4;

			// Binary search.
			stbtt_int32 l = 0, r = rangeCount - 1, m;
			int strawStart, strawEnd, needle = glyph;
			while( l <= r )
			{
				stbtt_uint8* rangeRecord;
				m = ( l + r ) >> 1;
				rangeRecord = rangeArray + 6 * m;
				strawStart = ttUSHORT( rangeRecord );
				strawEnd = ttUSHORT( rangeRecord + 2 );
				if( needle < strawStart )
					r = m - 1;
				else if( needle > strawEnd )
					l = m + 1;
				else
				{
					stbtt_uint16 startCoverageIndex = ttUSHORT( rangeRecord + 4 );
					return startCoverageIndex + glyph - strawStart;
				}
			}
		} break;

		default:
		{
			// There are no other cases.
			STBTT_assert( 0 );
		} break;
	}

	return -1;
}

static stbtt_int32  stbtt__GetGlyphClass( stbtt_uint8* classDefTable, int glyph )
{
	stbtt_uint16 classDefFormat = ttUSHORT( classDefTable );
	switch( classDefFormat )
	{
		case 1:
		{
			stbtt_uint16 startGlyphID = ttUSHORT( classDefTable + 2 );
			stbtt_uint16 glyphCount = ttUSHORT( classDefTable + 4 );
			stbtt_uint8* classDef1ValueArray = classDefTable + 6;

			if( glyph >= startGlyphID && glyph < startGlyphID + glyphCount )
				return ( stbtt_int32 )ttUSHORT( classDef1ValueArray + 2 * ( glyph - startGlyphID ) );

			// [DEAR IMGUI] Commented to fix static analyzer warning
			//classDefTable = classDef1ValueArray + 2 * glyphCount;
		} break;

		case 2:
		{
			stbtt_uint16 classRangeCount = ttUSHORT( classDefTable + 2 );
			stbtt_uint8* classRangeRecords = classDefTable + 4;

			// Binary search.
			stbtt_int32 l = 0, r = classRangeCount - 1, m;
			int strawStart, strawEnd, needle = glyph;
			while( l <= r )
			{
				stbtt_uint8* classRangeRecord;
				m = ( l + r ) >> 1;
				classRangeRecord = classRangeRecords + 6 * m;
				strawStart = ttUSHORT( classRangeRecord );
				strawEnd = ttUSHORT( classRangeRecord + 2 );
				if( needle < strawStart )
					r = m - 1;
				else if( needle > strawEnd )
					l = m + 1;
				else
					return ( stbtt_int32 )ttUSHORT( classRangeRecord + 4 );
			}

			// [DEAR IMGUI] Commented to fix static analyzer warning
			//classDefTable = classRangeRecords + 6 * classRangeCount;
		} break;

		default:
		{
			// There are no other cases.
			STBTT_assert( 0 );
		} break;
	}

	return -1;
}

// Define to STBTT_assert(x) if you want to break on unimplemented formats.
#define STBTT_GPOS_TODO_assert(x)

static stbtt_int32  stbtt__GetGlyphGPOSInfoAdvance( const stbtt_fontinfo* info, int glyph1, int glyph2 )
{
	stbtt_uint16 lookupListOffset;
	stbtt_uint8* lookupList;
	stbtt_uint16 lookupCount;
	stbtt_uint8* data;
	stbtt_int32 i;

	if( !info->gpos ) return 0;

	data = info->data + info->gpos;

	if( ttUSHORT( data + 0 ) != 1 ) return 0; // Major version 1
	if( ttUSHORT( data + 2 ) != 0 ) return 0; // Minor version 0

	lookupListOffset = ttUSHORT( data + 8 );
	lookupList = data + lookupListOffset;
	lookupCount = ttUSHORT( lookupList );

	for( i = 0; i < lookupCount; ++i )
	{
		stbtt_uint16 lookupOffset = ttUSHORT( lookupList + 2 + 2 * i );
		stbtt_uint8* lookupTable = lookupList + lookupOffset;

		stbtt_uint16 lookupType = ttUSHORT( lookupTable );
		stbtt_uint16 subTableCount = ttUSHORT( lookupTable + 4 );
		stbtt_uint8* subTableOffsets = lookupTable + 6;
		switch( lookupType )
		{
			case 2:
			{ // Pair Adjustment Positioning Subtable
				stbtt_int32 sti;
				for( sti = 0; sti < subTableCount; sti++ )
				{
					stbtt_uint16 subtableOffset = ttUSHORT( subTableOffsets + 2 * sti );
					stbtt_uint8* table = lookupTable + subtableOffset;
					stbtt_uint16 posFormat = ttUSHORT( table );
					stbtt_uint16 coverageOffset = ttUSHORT( table + 2 );
					stbtt_int32 coverageIndex = stbtt__GetCoverageIndex( table + coverageOffset, glyph1 );
					if( coverageIndex == -1 ) continue;

					switch( posFormat )
					{
						case 1:
						{
							stbtt_int32 l, r, m;
							int straw, needle;
							stbtt_uint16 valueFormat1 = ttUSHORT( table + 4 );
							stbtt_uint16 valueFormat2 = ttUSHORT( table + 6 );
							stbtt_int32 valueRecordPairSizeInBytes = 2;
							stbtt_uint16 pairSetCount = ttUSHORT( table + 8 );
							stbtt_uint16 pairPosOffset = ttUSHORT( table + 10 + 2 * coverageIndex );
							stbtt_uint8* pairValueTable = table + pairPosOffset;
							stbtt_uint16 pairValueCount = ttUSHORT( pairValueTable );
							stbtt_uint8* pairValueArray = pairValueTable + 2;
							// TODO: Support more formats.
							STBTT_GPOS_TODO_assert( valueFormat1 == 4 );
							if( valueFormat1 != 4 ) return 0;
							STBTT_GPOS_TODO_assert( valueFormat2 == 0 );
							if( valueFormat2 != 0 ) return 0;

							STBTT_assert( coverageIndex < pairSetCount );
							STBTT__NOTUSED( pairSetCount );

							needle = glyph2;
							r = pairValueCount - 1;
							l = 0;

							// Binary search.
							while( l <= r )
							{
								stbtt_uint16 secondGlyph;
								stbtt_uint8* pairValue;
								m = ( l + r ) >> 1;
								pairValue = pairValueArray + ( 2 + valueRecordPairSizeInBytes ) * m;
								secondGlyph = ttUSHORT( pairValue );
								straw = secondGlyph;
								if( needle < straw )
									r = m - 1;
								else if( needle > straw )
									l = m + 1;
								else
								{
									stbtt_int16 xAdvance = ttSHORT( pairValue + 2 );
									return xAdvance;
								}
							}
						} break;

						case 2:
						{
							stbtt_uint16 valueFormat1 = ttUSHORT( table + 4 );
							stbtt_uint16 valueFormat2 = ttUSHORT( table + 6 );

							stbtt_uint16 classDef1Offset = ttUSHORT( table + 8 );
							stbtt_uint16 classDef2Offset = ttUSHORT( table + 10 );
							int glyph1class = stbtt__GetGlyphClass( table + classDef1Offset, glyph1 );
							int glyph2class = stbtt__GetGlyphClass( table + classDef2Offset, glyph2 );

							stbtt_uint16 class1Count = ttUSHORT( table + 12 );
							stbtt_uint16 class2Count = ttUSHORT( table + 14 );
							STBTT_assert( glyph1class < class1Count );
							STBTT_assert( glyph2class < class2Count );

							// TODO: Support more formats.
							STBTT_GPOS_TODO_assert( valueFormat1 == 4 );
							if( valueFormat1 != 4 ) return 0;
							STBTT_GPOS_TODO_assert( valueFormat2 == 0 );
							if( valueFormat2 != 0 ) return 0;

							if( glyph1class >= 0 && glyph1class < class1Count && glyph2class >= 0 && glyph2class < class2Count )
							{
								stbtt_uint8* class1Records = table + 16;
								stbtt_uint8* class2Records = class1Records + 2 * ( glyph1class * class2Count );
								stbtt_int16 xAdvance = ttSHORT( class2Records + 2 * glyph2class );
								return xAdvance;
							}
						} break;

						default:
						{
							// There are no other cases.
							STBTT_assert( 0 );
							break;
						} // [DEAR IMGUI] removed ;
					}
				}
				break;
			} // [DEAR IMGUI] removed ;

			default:
				// TODO: Implement other stuff.
				break;
		}
	}

	return 0;
}

STBTT_DEF int  stbtt_GetGlyphKernAdvance( const stbtt_fontinfo* info, int g1, int g2 )
{
	int xAdvance = 0;

	if( info->gpos )
		xAdvance += stbtt__GetGlyphGPOSInfoAdvance( info, g1, g2 );

	if( info->kern )
		xAdvance += stbtt__GetGlyphKernInfoAdvance( info, g1, g2 );

	return xAdvance;
}

STBTT_DEF int  stbtt_GetCodepointKernAdvance( const stbtt_fontinfo* info, int ch1, int ch2 )
{
	if( !info->kern && !info->gpos ) // if no kerning table, don't waste time looking up both codepoint->glyphs
		return 0;
	return stbtt_GetGlyphKernAdvance( info, stbtt_FindGlyphIndex( info, ch1 ), stbtt_FindGlyphIndex( info, ch2 ) );
}

STBTT_DEF void stbtt_GetCodepointHMetrics( const stbtt_fontinfo* info, int codepoint, int* advanceWidth, int* leftSideBearing )
{
	stbtt_GetGlyphHMetrics( info, stbtt_FindGlyphIndex( info, codepoint ), advanceWidth, leftSideBearing );
}

STBTT_DEF void stbtt_GetFontVMetrics( const stbtt_fontinfo* info, int* ascent, int* descent, int* lineGap )
{
	if( ascent ) *ascent = ttSHORT( info->data + info->hhea + 4 );
	if( descent ) *descent = ttSHORT( info->data + info->hhea + 6 );
	if( lineGap ) *lineGap = ttSHORT( info->data + info->hhea + 8 );
}

STBTT_DEF int  stbtt_GetFontVMetricsOS2( const stbtt_fontinfo* info, int* typoAscent, int* typoDescent, int* typoLineGap )
{
	int tab = stbtt__find_table( info->data, info->fontstart, "OS/2" );
	if( !tab )
		return 0;
	if( typoAscent ) *typoAscent = ttSHORT( info->data + tab + 68 );
	if( typoDescent ) *typoDescent = ttSHORT( info->data + tab + 70 );
	if( typoLineGap ) *typoLineGap = ttSHORT( info->data + tab + 72 );
	return 1;
}

STBTT_DEF void stbtt_GetFontBoundingBox( const stbtt_fontinfo* info, int* x0, int* y0, int* x1, int* y1 )
{
	*x0 = ttSHORT( info->data + info->head + 36 );
	*y0 = ttSHORT( info->data + info->head + 38 );
	*x1 = ttSHORT( info->data + info->head + 40 );
	*y1 = ttSHORT( info->data + info->head + 42 );
}

STBTT_DEF float stbtt_ScaleForPixelHeight( const stbtt_fontinfo* info, float height )
{
	int fheight = ttSHORT( info->data + info->hhea + 4 ) - ttSHORT( info->data + info->hhea + 6 );
	return ( float )height / fheight;
}

STBTT_DEF float stbtt_ScaleForMappingEmToPixels( const stbtt_fontinfo* info, float pixels )
{
	int unitsPerEm = ttUSHORT( info->data + info->head + 18 );
	return pixels / unitsPerEm;
}

STBTT_DEF void stbtt_FreeShape( const stbtt_fontinfo* info, stbtt_vertex* v )
{
	STBTT_free( v, info->userdata );
}

//////////////////////////////////////////////////////////////////////////////
//
// antialiasing software rasterizer
//

STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel( const stbtt_fontinfo* font, int glyph, float scale_x, float scale_y, float shift_x, float shift_y, int* ix0, int* iy0, int* ix1, int* iy1 )
{
	int x0 = 0, y0 = 0, x1, y1; // =0 suppresses compiler warning
	if( !stbtt_GetGlyphBox( font, glyph, &x0, &y0, &x1, &y1 ) )
	{
		// e.g. space character
		if( ix0 ) *ix0 = 0;
		if( iy0 ) *iy0 = 0;
		if( ix1 ) *ix1 = 0;
		if( iy1 ) *iy1 = 0;
	}
	else
	{
		// move to integral bboxes (treating pixels as little squares, what pixels get touched)?
		if( ix0 ) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x );
		if( iy0 ) *iy0 = STBTT_ifloor( -y1 * scale_y + shift_y );
		if( ix1 ) *ix1 = STBTT_iceil( x1 * scale_x + shift_x );
		if( iy1 ) *iy1 = STBTT_iceil( -y0 * scale_y + shift_y );
	}
}

STBTT_DEF void stbtt_GetGlyphBitmapBox( const stbtt_fontinfo* font, int glyph, float scale_x, float scale_y, int* ix0, int* iy0, int* ix1, int* iy1 )
{
	stbtt_GetGlyphBitmapBoxSubpixel( font, glyph, scale_x, scale_y, 0.0f, 0.0f, ix0, iy0, ix1, iy1 );
}

STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel( const stbtt_fontinfo* font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int* ix0, int* iy0, int* ix1, int* iy1 )
{
	stbtt_GetGlyphBitmapBoxSubpixel( font, stbtt_FindGlyphIndex( font, codepoint ), scale_x, scale_y, shift_x, shift_y, ix0, iy0, ix1, iy1 );
}

STBTT_DEF void stbtt_GetCodepointBitmapBox( const stbtt_fontinfo* font, int codepoint, float scale_x, float scale_y, int* ix0, int* iy0, int* ix1, int* iy1 )
{
	stbtt_GetCodepointBitmapBoxSubpixel( font, codepoint, scale_x, scale_y, 0.0f, 0.0f, ix0, iy0, ix1, iy1 );
}

//////////////////////////////////////////////////////////////////////////////
//
//  Rasterizer

typedef struct stbtt__hheap_chunk
{
	struct stbtt__hheap_chunk* next;
} stbtt__hheap_chunk;

typedef struct stbtt__hheap
{
	struct stbtt__hheap_chunk* head;
	void* first_free;
	int    num_remaining_in_head_chunk;
} stbtt__hheap;

static void* stbtt__hheap_alloc( stbtt__hheap* hh, size_t size, void* userdata )
{
	if( hh->first_free )
	{
		void* p = hh->first_free;
		hh->first_free = *( void** )p;
		return p;
	}
	else
	{
		if( hh->num_remaining_in_head_chunk == 0 )
		{
			int count = ( size < 32 ? 2000 : size < 128 ? 800 : 100 );
			stbtt__hheap_chunk* c = ( stbtt__hheap_chunk* )STBTT_malloc( sizeof( stbtt__hheap_chunk ) + size * count, userdata );
			if( c == NULL )
				return NULL;
			c->next = hh->head;
			hh->head = c;
			hh->num_remaining_in_head_chunk = count;
		}
		--hh->num_remaining_in_head_chunk;
		return ( char* )( hh->head ) + sizeof( stbtt__hheap_chunk ) + size * hh->num_remaining_in_head_chunk;
	}
}

static void stbtt__hheap_free( stbtt__hheap* hh, void* p )
{
	*( void** )p = hh->first_free;
	hh->first_free = p;
}

static void stbtt__hheap_cleanup( stbtt__hheap* hh, void* userdata )
{
	stbtt__hheap_chunk* c = hh->head;
	while( c )
	{
		stbtt__hheap_chunk* n = c->next;
		STBTT_free( c, userdata );
		c = n;
	}
}

typedef struct stbtt__edge
{
	float x0, y0, x1, y1;
	int invert;
} stbtt__edge;


typedef struct stbtt__active_edge
{
	struct stbtt__active_edge* next;
#if STBTT_RASTERIZER_VERSION==1
	int x, dx;
	float ey;
	int direction;
#elif STBTT_RASTERIZER_VERSION==2
	float fx, fdx, fdy;
	float direction;
	float sy;
	float ey;
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif
} stbtt__active_edge;

#if STBTT_RASTERIZER_VERSION == 1
#define STBTT_FIXSHIFT   10
#define STBTT_FIX        (1 << STBTT_FIXSHIFT)
#define STBTT_FIXMASK    (STBTT_FIX-1)

static stbtt__active_edge* stbtt__new_active( stbtt__hheap* hh, stbtt__edge* e, int off_x, float start_point, void* userdata )
{
	stbtt__active_edge* z = ( stbtt__active_edge* )stbtt__hheap_alloc( hh, sizeof( *z ), userdata );
	float dxdy = ( e->x1 - e->x0 ) / ( e->y1 - e->y0 );
	STBTT_assert( z != NULL );
	if( !z ) return z;

	// round dx down to avoid overshooting
	if( dxdy < 0 )
		z->dx = -STBTT_ifloor( STBTT_FIX * -dxdy );
	else
		z->dx = STBTT_ifloor( STBTT_FIX * dxdy );

	z->x = STBTT_ifloor( STBTT_FIX * e->x0 + z->dx * ( start_point - e->y0 ) ); // use z->dx so when we offset later it's by the same amount
	z->x -= off_x * STBTT_FIX;

	z->ey = e->y1;
	z->next = 0;
	z->direction = e->invert ? 1 : -1;
	return z;
}
#elif STBTT_RASTERIZER_VERSION == 2
static stbtt__active_edge* stbtt__new_active( stbtt__hheap* hh, stbtt__edge* e, int off_x, float start_point, void* userdata )
{
	stbtt__active_edge* z = ( stbtt__active_edge* )stbtt__hheap_alloc( hh, sizeof( *z ), userdata );
	float dxdy = ( e->x1 - e->x0 ) / ( e->y1 - e->y0 );
	STBTT_assert( z != NULL );
	//STBTT_assert(e->y0 <= start_point);
	if( !z ) return z;
	z->fdx = dxdy;
	z->fdy = dxdy != 0.0f ? ( 1.0f / dxdy ) : 0.0f;
	z->fx = e->x0 + dxdy * ( start_point - e->y0 );
	z->fx -= off_x;
	z->direction = e->invert ? 1.0f : -1.0f;
	z->sy = e->y0;
	z->ey = e->y1;
	z->next = 0;
	return z;
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#if STBTT_RASTERIZER_VERSION == 1
// note: this routine clips fills that extend off the edges... ideally this
// wouldn't happen, but it could happen if the truetype glyph bounding boxes
// are wrong, or if the user supplies a too-small bitmap
static void stbtt__fill_active_edges( unsigned char* scanline, int len, stbtt__active_edge* e, int max_weight )
{
	// non-zero winding fill
	int x0 = 0, w = 0;

	while( e )
	{
		if( w == 0 )
		{
			// if we're currently at zero, we need to record the edge start point
			x0 = e->x; w += e->direction;
		}
		else
		{
			int x1 = e->x; w += e->direction;
			// if we went to zero, we need to draw
			if( w == 0 )
			{
				int i = x0 >> STBTT_FIXSHIFT;
				int j = x1 >> STBTT_FIXSHIFT;

				if( i < len && j >= 0 )
				{
					if( i == j )
					{
						// x0,x1 are the same pixel, so compute combined coverage
						scanline[ i ] = scanline[ i ] + ( stbtt_uint8 )( ( x1 - x0 ) * max_weight >> STBTT_FIXSHIFT );
					}
					else
					{
						if( i >= 0 ) // add antialiasing for x0
							scanline[ i ] = scanline[ i ] + ( stbtt_uint8 )( ( ( STBTT_FIX - ( x0 & STBTT_FIXMASK ) ) * max_weight ) >> STBTT_FIXSHIFT );
						else
							i = -1; // clip

						if( j < len ) // add antialiasing for x1
							scanline[ j ] = scanline[ j ] + ( stbtt_uint8 )( ( ( x1 & STBTT_FIXMASK ) * max_weight ) >> STBTT_FIXSHIFT );
						else
							j = len; // clip

						for( ++i; i < j; ++i ) // fill pixels between x0 and x1
							scanline[ i ] = scanline[ i ] + ( stbtt_uint8 )max_weight;
					}
				}
			}
		}

		e = e->next;
	}
}

static void stbtt__rasterize_sorted_edges( stbtt__bitmap* result, stbtt__edge* e, int n, int vsubsample, int off_x, int off_y, void* userdata )
{
	stbtt__hheap hh = { 0, 0, 0 };
	stbtt__active_edge* active = NULL;
	int y, j = 0;
	int max_weight = ( 255 / vsubsample );  // weight per vertical scanline
	int s; // vertical subsample index
	unsigned char scanline_data[ 512 ], * scanline;

	if( result->w > 512 )
		scanline = ( unsigned char* )STBTT_malloc( result->w, userdata );
	else
		scanline = scanline_data;

	y = off_y * vsubsample;
	e[ n ].y0 = ( off_y + result->h ) * ( float )vsubsample + 1;

	while( j < result->h )
	{
		STBTT_memset( scanline, 0, result->w );
		for( s = 0; s < vsubsample; ++s )
		{
			// find center of pixel for this scanline
			float scan_y = y + 0.5f;
			stbtt__active_edge** step = &active;

			// update all active edges;
			// remove all active edges that terminate before the center of this scanline
			while( *step )
			{
				stbtt__active_edge* z = *step;
				if( z->ey <= scan_y )
				{
					*step = z->next; // delete from list
					STBTT_assert( z->direction );
					z->direction = 0;
					stbtt__hheap_free( &hh, z );
				}
				else
				{
					z->x += z->dx; // advance to position for current scanline
					step = &( ( *step )->next ); // advance through list
				}
			}

			// resort the list if needed
			for( ;;)
			{
				int changed = 0;
				step = &active;
				while( *step && ( *step )->next )
				{
					if( ( *step )->x > ( *step )->next->x )
					{
						stbtt__active_edge* t = *step;
						stbtt__active_edge* q = t->next;

						t->next = q->next;
						q->next = t;
						*step = q;
						changed = 1;
					}
					step = &( *step )->next;
				}
				if( !changed ) break;
			}

			// insert all edges that start before the center of this scanline -- omit ones that also end on this scanline
			while( e->y0 <= scan_y )
			{
				if( e->y1 > scan_y )
				{
					stbtt__active_edge* z = stbtt__new_active( &hh, e, off_x, scan_y, userdata );
					if( z != NULL )
					{
						// find insertion point
						if( active == NULL )
							active = z;
						else if( z->x < active->x )
						{
							// insert at front
							z->next = active;
							active = z;
						}
						else
						{
							// find thing to insert AFTER
							stbtt__active_edge* p = active;
							while( p->next && p->next->x < z->x )
								p = p->next;
							// at this point, p->next->x is NOT < z->x
							z->next = p->next;
							p->next = z;
						}
					}
				}
				++e;
			}

			// now process all active edges in XOR fashion
			if( active )
				stbtt__fill_active_edges( scanline, result->w, active, max_weight );

			++y;
		}
		STBTT_memcpy( result->pixels + j * result->stride, scanline, result->w );
		++j;
	}

	stbtt__hheap_cleanup( &hh, userdata );

	if( scanline != scanline_data )
		STBTT_free( scanline, userdata );
}

#elif STBTT_RASTERIZER_VERSION == 2

// the edge passed in here does not cross the vertical line at x or the vertical line at x+1
// (i.e. it has already been clipped to those)
static void stbtt__handle_clipped_edge( float* scanline, int x, stbtt__active_edge* e, float x0, float y0, float x1, float y1 )
{
	if( y0 == y1 ) return;
	STBTT_assert( y0 < y1 );
	STBTT_assert( e->sy <= e->ey );
	if( y0 > e->ey ) return;
	if( y1 < e->sy ) return;
	if( y0 < e->sy )
	{
		x0 += ( x1 - x0 ) * ( e->sy - y0 ) / ( y1 - y0 );
		y0 = e->sy;
	}
	if( y1 > e->ey )
	{
		x1 += ( x1 - x0 ) * ( e->ey - y1 ) / ( y1 - y0 );
		y1 = e->ey;
	}

	if( x0 == x )
		STBTT_assert( x1 <= x + 1 );
	else if( x0 == x + 1 )
		STBTT_assert( x1 >= x );
	else if( x0 <= x )
		STBTT_assert( x1 <= x );
	else if( x0 >= x + 1 )
		STBTT_assert( x1 >= x + 1 );
	else
		STBTT_assert( x1 >= x && x1 <= x + 1 );

	if( x0 <= x && x1 <= x )
		scanline[ x ] += e->direction * ( y1 - y0 );
	else if( x0 >= x + 1 && x1 >= x + 1 )
		;
	else
	{
		STBTT_assert( x0 >= x && x0 <= x + 1 && x1 >= x && x1 <= x + 1 );
		scanline[ x ] += e->direction * ( y1 - y0 ) * ( 1 - ( ( x0 - x ) + ( x1 - x ) ) / 2 ); // coverage = 1 - average x position
	}
}

static void stbtt__fill_active_edges_new( float* scanline, float* scanline_fill, int len, stbtt__active_edge* e, float y_top )
{
	float y_bottom = y_top + 1;

	while( e )
	{
		// brute force every pixel

		// compute intersection points with top & bottom
		STBTT_assert( e->ey >= y_top );

		if( e->fdx == 0 )
		{
			float x0 = e->fx;
			if( x0 < len )
			{
				if( x0 >= 0 )
				{
					stbtt__handle_clipped_edge( scanline, ( int )x0, e, x0, y_top, x0, y_bottom );
					stbtt__handle_clipped_edge( scanline_fill - 1, ( int )x0 + 1, e, x0, y_top, x0, y_bottom );
				}
				else
				{
					stbtt__handle_clipped_edge( scanline_fill - 1, 0, e, x0, y_top, x0, y_bottom );
				}
			}
		}
		else
		{
			float x0 = e->fx;
			float dx = e->fdx;
			float xb = x0 + dx;
			float x_top, x_bottom;
			float sy0, sy1;
			float dy = e->fdy;
			STBTT_assert( e->sy <= y_bottom && e->ey >= y_top );

			// compute endpoints of line segment clipped to this scanline (if the
			// line segment starts on this scanline. x0 is the intersection of the
			// line with y_top, but that may be off the line segment.
			if( e->sy > y_top )
			{
				x_top = x0 + dx * ( e->sy - y_top );
				sy0 = e->sy;
			}
			else
			{
				x_top = x0;
				sy0 = y_top;
			}
			if( e->ey < y_bottom )
			{
				x_bottom = x0 + dx * ( e->ey - y_top );
				sy1 = e->ey;
			}
			else
			{
				x_bottom = xb;
				sy1 = y_bottom;
			}

			if( x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len )
			{
				// from here on, we don't have to range check x values

				if( ( int )x_top == ( int )x_bottom )
				{
					float height;
					// simple case, only spans one pixel
					int x = ( int )x_top;
					height = sy1 - sy0;
					STBTT_assert( x >= 0 && x < len );
					scanline[ x ] += e->direction * ( 1 - ( ( x_top - x ) + ( x_bottom - x ) ) / 2 ) * height;
					scanline_fill[ x ] += e->direction * height; // everything right of this pixel is filled
				}
				else
				{
					int x, x1, x2;
					float y_crossing, step, sign, area;
					// covers 2+ pixels
					if( x_top > x_bottom )
					{
						// flip scanline vertically; signed area is the same
						float t;
						sy0 = y_bottom - ( sy0 - y_top );
						sy1 = y_bottom - ( sy1 - y_top );
						t = sy0, sy0 = sy1, sy1 = t;
						t = x_bottom, x_bottom = x_top, x_top = t;
						dx = -dx;
						dy = -dy;
						t = x0, x0 = xb, xb = t;
						// [DEAR IMGUI] Fix static analyzer warning
						( void )dx; // [ImGui: fix static analyzer warning]
					}

					x1 = ( int )x_top;
					x2 = ( int )x_bottom;
					// compute intersection with y axis at x1+1
					y_crossing = ( x1 + 1 - x0 ) * dy + y_top;

					sign = e->direction;
					// area of the rectangle covered from y0..y_crossing
					area = sign * ( y_crossing - sy0 );
					// area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing)
					scanline[ x1 ] += area * ( 1 - ( ( x_top - x1 ) + ( x1 + 1 - x1 ) ) / 2 );

					step = sign * dy;
					for( x = x1 + 1; x < x2; ++x )
					{
						scanline[ x ] += area + step / 2;
						area += step;
					}
					y_crossing += dy * ( x2 - ( x1 + 1 ) );

					STBTT_assert( STBTT_fabs( area ) <= 1.01f );

					scanline[ x2 ] += area + sign * ( 1 - ( ( x2 - x2 ) + ( x_bottom - x2 ) ) / 2 ) * ( sy1 - y_crossing );

					scanline_fill[ x2 ] += sign * ( sy1 - sy0 );
				}
			}
			else
			{
				// if edge goes outside of box we're drawing, we require
				// clipping logic. since this does not match the intended use
				// of this library, we use a different, very slow brute
				// force implementation
				int x;
				for( x = 0; x < len; ++x )
				{
					// cases:
					//
					// there can be up to two intersections with the pixel. any intersection
					// with left or right edges can be handled by splitting into two (or three)
					// regions. intersections with top & bottom do not necessitate case-wise logic.
					//
					// the old way of doing this found the intersections with the left & right edges,
					// then used some simple logic to produce up to three segments in sorted order
					// from top-to-bottom. however, this had a problem: if an x edge was epsilon
					// across the x border, then the corresponding y position might not be distinct
					// from the other y segment, and it might ignored as an empty segment. to avoid
					// that, we need to explicitly produce segments based on x positions.

					// rename variables to clearly-defined pairs
					float y0 = y_top;
					float x1 = ( float )( x );
					float x2 = ( float )( x + 1 );
					float x3 = xb;
					float y3 = y_bottom;

					// x = e->x + e->dx * (y-y_top)
					// (y-y_top) = (x - e->x) / e->dx
					// y = (x - e->x) / e->dx + y_top
					float y1 = ( x - x0 ) / dx + y_top;
					float y2 = ( x + 1 - x0 ) / dx + y_top;

					if( x0 < x1 && x3 > x2 )
					{         // three segments descending down-right
						stbtt__handle_clipped_edge( scanline, x, e, x0, y0, x1, y1 );
						stbtt__handle_clipped_edge( scanline, x, e, x1, y1, x2, y2 );
						stbtt__handle_clipped_edge( scanline, x, e, x2, y2, x3, y3 );
					}
					else if( x3 < x1 && x0 > x2 )
					{  // three segments descending down-left
						stbtt__handle_clipped_edge( scanline, x, e, x0, y0, x2, y2 );
						stbtt__handle_clipped_edge( scanline, x, e, x2, y2, x1, y1 );
						stbtt__handle_clipped_edge( scanline, x, e, x1, y1, x3, y3 );
					}
					else if( x0 < x1 && x3 > x1 )
					{  // two segments across x, down-right
						stbtt__handle_clipped_edge( scanline, x, e, x0, y0, x1, y1 );
						stbtt__handle_clipped_edge( scanline, x, e, x1, y1, x3, y3 );
					}
					else if( x3 < x1 && x0 > x1 )
					{  // two segments across x, down-left
						stbtt__handle_clipped_edge( scanline, x, e, x0, y0, x1, y1 );
						stbtt__handle_clipped_edge( scanline, x, e, x1, y1, x3, y3 );
					}
					else if( x0 < x2 && x3 > x2 )
					{  // two segments across x+1, down-right
						stbtt__handle_clipped_edge( scanline, x, e, x0, y0, x2, y2 );
						stbtt__handle_clipped_edge( scanline, x, e, x2, y2, x3, y3 );
					}
					else if( x3 < x2 && x0 > x2 )
					{  // two segments across x+1, down-left
						stbtt__handle_clipped_edge( scanline, x, e, x0, y0, x2, y2 );
						stbtt__handle_clipped_edge( scanline, x, e, x2, y2, x3, y3 );
					}
					else
					{  // one segment
						stbtt__handle_clipped_edge( scanline, x, e, x0, y0, x3, y3 );
					}
				}
			}
		}
		e = e->next;
	}
}

// directly AA rasterize edges w/o supersampling
static void stbtt__rasterize_sorted_edges( stbtt__bitmap* result, stbtt__edge* e, int n, int vsubsample, int off_x, int off_y, void* userdata )
{
	stbtt__hheap hh = { 0, 0, 0 };
	stbtt__active_edge* active = NULL;
	int y, j = 0, i;
	float scanline_data[ 129 ], * scanline, * scanline2;

	STBTT__NOTUSED( vsubsample );

	if( result->w > 64 )
		scanline = ( float* )STBTT_malloc( ( result->w * 2 + 1 ) * sizeof( float ), userdata );
	else
		scanline = scanline_data;

	scanline2 = scanline + result->w;

	y = off_y;
	e[ n ].y0 = ( float )( off_y + result->h ) + 1;

	while( j < result->h )
	{
		// find center of pixel for this scanline
		float scan_y_top = y + 0.0f;
		float scan_y_bottom = y + 1.0f;
		stbtt__active_edge** step = &active;

		STBTT_memset( scanline, 0, result->w * sizeof( scanline[ 0 ] ) );
		STBTT_memset( scanline2, 0, ( result->w + 1 ) * sizeof( scanline[ 0 ] ) );

		// update all active edges;
		// remove all active edges that terminate before the top of this scanline
		while( *step )
		{
			stbtt__active_edge* z = *step;
			if( z->ey <= scan_y_top )
			{
				*step = z->next; // delete from list
				STBTT_assert( z->direction );
				z->direction = 0;
				stbtt__hheap_free( &hh, z );
			}
			else
			{
				step = &( ( *step )->next ); // advance through list
			}
		}

		// insert all edges that start before the bottom of this scanline
		while( e->y0 <= scan_y_bottom )
		{
			if( e->y0 != e->y1 )
			{
				stbtt__active_edge* z = stbtt__new_active( &hh, e, off_x, scan_y_top, userdata );
				if( z != NULL )
				{
					if( j == 0 && off_y != 0 )
					{
						if( z->ey < scan_y_top )
						{
							// this can happen due to subpixel positioning and some kind of fp rounding error i think
							z->ey = scan_y_top;
						}
					}
					STBTT_assert( z->ey >= scan_y_top ); // if we get really unlucky a tiny bit of an edge can be out of bounds
					// insert at front
					z->next = active;
					active = z;
				}
			}
			++e;
		}

		// now process all active edges
		if( active )
			stbtt__fill_active_edges_new( scanline, scanline2 + 1, result->w, active, scan_y_top );

		{
			float sum = 0;
			for( i = 0; i < result->w; ++i )
			{
				float k;
				int m;
				sum += scanline2[ i ];
				k = scanline[ i ] + sum;
				k = ( float )STBTT_fabs( k ) * 255 + 0.5f;
				m = ( int )k;
				if( m > 255 ) m = 255;
				result->pixels[ j * result->stride + i ] = ( unsigned char )m;
			}
		}
		// advance all the edges
		step = &active;
		while( *step )
		{
			stbtt__active_edge* z = *step;
			z->fx += z->fdx; // advance to position for current scanline
			step = &( ( *step )->next ); // advance through list
		}

		++y;
		++j;
	}

	stbtt__hheap_cleanup( &hh, userdata );

	if( scanline != scanline_data )
		STBTT_free( scanline, userdata );
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)

static void stbtt__sort_edges_ins_sort( stbtt__edge* p, int n )
{
	int i, j;
	for( i = 1; i < n; ++i )
	{
		stbtt__edge t = p[ i ], * a = &t;
		j = i;
		while( j > 0 )
		{
			stbtt__edge* b = &p[ j - 1 ];
			int c = STBTT__COMPARE( a, b );
			if( !c ) break;
			p[ j ] = p[ j - 1 ];
			--j;
		}
		if( i != j )
			p[ j ] = t;
	}
}

static void stbtt__sort_edges_quicksort( stbtt__edge* p, int n )
{
	/* threshold for transitioning to insertion sort */
	while( n > 12 )
	{
		stbtt__edge t;
		int c01, c12, c, m, i, j;

		/* compute median of three */
		m = n >> 1;
		c01 = STBTT__COMPARE( &p[ 0 ], &p[ m ] );
		c12 = STBTT__COMPARE( &p[ m ], &p[ n - 1 ] );
		/* if 0 >= mid >= end, or 0 < mid < end, then use mid */
		if( c01 != c12 )
		{
			/* otherwise, we'll need to swap something else to middle */
			int z;
			c = STBTT__COMPARE( &p[ 0 ], &p[ n - 1 ] );
			/* 0>mid && mid<n:  0>n => n; 0<n => 0 */
			/* 0<mid && mid>n:  0>n => 0; 0<n => n */
			z = ( c == c12 ) ? 0 : n - 1;
			t = p[ z ];
			p[ z ] = p[ m ];
			p[ m ] = t;
		}
		/* now p[m] is the median-of-three */
		/* swap it to the beginning so it won't move around */
		t = p[ 0 ];
		p[ 0 ] = p[ m ];
		p[ m ] = t;

		/* partition loop */
		i = 1;
		j = n - 1;
		for( ;;)
		{
			/* handling of equality is crucial here */
			/* for sentinels & efficiency with duplicates */
			for( ;; ++i )
			{
				if( !STBTT__COMPARE( &p[ i ], &p[ 0 ] ) ) break;
			}
			for( ;; --j )
			{
				if( !STBTT__COMPARE( &p[ 0 ], &p[ j ] ) ) break;
			}
			/* make sure we haven't crossed */
			if( i >= j ) break;
			t = p[ i ];
			p[ i ] = p[ j ];
			p[ j ] = t;

			++i;
			--j;
		}
		/* recurse on smaller side, iterate on larger */
		if( j < ( n - i ) )
		{
			stbtt__sort_edges_quicksort( p, j );
			p = p + i;
			n = n - i;
		}
		else
		{
			stbtt__sort_edges_quicksort( p + i, n - i );
			n = j;
		}
	}
}

static void stbtt__sort_edges( stbtt__edge* p, int n )
{
	stbtt__sort_edges_quicksort( p, n );
	stbtt__sort_edges_ins_sort( p, n );
}

typedef struct
{
	float x, y;
} stbtt__point;

static void stbtt__rasterize( stbtt__bitmap* result, stbtt__point* pts, int* wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void* userdata )
{
	float y_scale_inv = invert ? -scale_y : scale_y;
	stbtt__edge* e;
	int n, i, j, k, m;
#if STBTT_RASTERIZER_VERSION == 1
	int vsubsample = result->h < 8 ? 15 : 5;
#elif STBTT_RASTERIZER_VERSION == 2
	int vsubsample = 1;
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif
	// vsubsample should divide 255 evenly; otherwise we won't reach full opacity

	// now we have to blow out the windings into explicit edge lists
	n = 0;
	for( i = 0; i < windings; ++i )
		n += wcount[ i ];

	e = ( stbtt__edge* )STBTT_malloc( sizeof( *e ) * ( n + 1 ), userdata ); // add an extra one as a sentinel
	if( e == 0 ) return;
	n = 0;

	m = 0;
	for( i = 0; i < windings; ++i )
	{
		stbtt__point* p = pts + m;
		m += wcount[ i ];
		j = wcount[ i ] - 1;
		for( k = 0; k < wcount[ i ]; j = k++ )
		{
			int a = k, b = j;
			// skip the edge if horizontal
			if( p[ j ].y == p[ k ].y )
				continue;
			// add edge from j to k to the list
			e[ n ].invert = 0;
			if( invert ? p[ j ].y > p[ k ].y : p[ j ].y < p[ k ].y )
			{
				e[ n ].invert = 1;
				a = j, b = k;
			}
			e[ n ].x0 = p[ a ].x * scale_x + shift_x;
			e[ n ].y0 = ( p[ a ].y * y_scale_inv + shift_y ) * vsubsample;
			e[ n ].x1 = p[ b ].x * scale_x + shift_x;
			e[ n ].y1 = ( p[ b ].y * y_scale_inv + shift_y ) * vsubsample;
			++n;
		}
	}

	// now sort the edges by their highest point (should snap to integer, and then by x)
	//STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
	stbtt__sort_edges( e, n );

	// now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
	stbtt__rasterize_sorted_edges( result, e, n, vsubsample, off_x, off_y, userdata );

	STBTT_free( e, userdata );
}

static void stbtt__add_point( stbtt__point* points, int n, float x, float y )
{
	if( !points ) return; // during first pass, it's unallocated
	points[ n ].x = x;
	points[ n ].y = y;
}

// tessellate until threshold p is happy... @TODO warped to compensate for non-linear stretching
static int stbtt__tesselate_curve( stbtt__point* points, int* num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n )
{
	// midpoint
	float mx = ( x0 + 2 * x1 + x2 ) / 4;
	float my = ( y0 + 2 * y1 + y2 ) / 4;
	// versus directly drawn line
	float dx = ( x0 + x2 ) / 2 - mx;
	float dy = ( y0 + y2 ) / 2 - my;
	if( n > 16 ) // 65536 segments on one curve better be enough!
		return 1;
	if( dx * dx + dy * dy > objspace_flatness_squared )
	{ // half-pixel error allowed... need to be smaller if AA
		stbtt__tesselate_curve( points, num_points, x0, y0, ( x0 + x1 ) / 2.0f, ( y0 + y1 ) / 2.0f, mx, my, objspace_flatness_squared, n + 1 );
		stbtt__tesselate_curve( points, num_points, mx, my, ( x1 + x2 ) / 2.0f, ( y1 + y2 ) / 2.0f, x2, y2, objspace_flatness_squared, n + 1 );
	}
	else
	{
		stbtt__add_point( points, *num_points, x2, y2 );
		*num_points = *num_points + 1;
	}
	return 1;
}

static void stbtt__tesselate_cubic( stbtt__point* points, int* num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n )
{
	// @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
	float dx0 = x1 - x0;
	float dy0 = y1 - y0;
	float dx1 = x2 - x1;
	float dy1 = y2 - y1;
	float dx2 = x3 - x2;
	float dy2 = y3 - y2;
	float dx = x3 - x0;
	float dy = y3 - y0;
	float longlen = ( float )( STBTT_sqrt( dx0 * dx0 + dy0 * dy0 ) + STBTT_sqrt( dx1 * dx1 + dy1 * dy1 ) + STBTT_sqrt( dx2 * dx2 + dy2 * dy2 ) );
	float shortlen = ( float )STBTT_sqrt( dx * dx + dy * dy );
	float flatness_squared = longlen * longlen - shortlen * shortlen;

	if( n > 16 ) // 65536 segments on one curve better be enough!
		return;

	if( flatness_squared > objspace_flatness_squared )
	{
		float x01 = ( x0 + x1 ) / 2;
		float y01 = ( y0 + y1 ) / 2;
		float x12 = ( x1 + x2 ) / 2;
		float y12 = ( y1 + y2 ) / 2;
		float x23 = ( x2 + x3 ) / 2;
		float y23 = ( y2 + y3 ) / 2;

		float xa = ( x01 + x12 ) / 2;
		float ya = ( y01 + y12 ) / 2;
		float xb = ( x12 + x23 ) / 2;
		float yb = ( y12 + y23 ) / 2;

		float mx = ( xa + xb ) / 2;
		float my = ( ya + yb ) / 2;

		stbtt__tesselate_cubic( points, num_points, x0, y0, x01, y01, xa, ya, mx, my, objspace_flatness_squared, n + 1 );
		stbtt__tesselate_cubic( points, num_points, mx, my, xb, yb, x23, y23, x3, y3, objspace_flatness_squared, n + 1 );
	}
	else
	{
		stbtt__add_point( points, *num_points, x3, y3 );
		*num_points = *num_points + 1;
	}
}

// returns number of contours
static stbtt__point* stbtt_FlattenCurves( stbtt_vertex* vertices, int num_verts, float objspace_flatness, int** contour_lengths, int* num_contours, void* userdata )
{
	stbtt__point* points = 0;
	int num_points = 0;

	float objspace_flatness_squared = objspace_flatness * objspace_flatness;
	int i, n = 0, start = 0, pass;

	// count how many "moves" there are to get the contour count
	for( i = 0; i < num_verts; ++i )
		if( vertices[ i ].type == STBTT_vmove )
			++n;

	*num_contours = n;
	if( n == 0 ) return 0;

	*contour_lengths = ( int* )STBTT_malloc( sizeof( **contour_lengths ) * n, userdata );

	if( *contour_lengths == 0 )
	{
		*num_contours = 0;
		return 0;
	}

	// make two passes through the points so we don't need to realloc
	for( pass = 0; pass < 2; ++pass )
	{
		float x = 0, y = 0;
		if( pass == 1 )
		{
			points = ( stbtt__point* )STBTT_malloc( num_points * sizeof( points[ 0 ] ), userdata );
			if( points == NULL ) goto error;
		}
		num_points = 0;
		n = -1;
		for( i = 0; i < num_verts; ++i )
		{
			switch( vertices[ i ].type )
			{
				case STBTT_vmove:
					// start the next contour
					if( n >= 0 )
						( *contour_lengths )[ n ] = num_points - start;
					++n;
					start = num_points;

					x = vertices[ i ].x, y = vertices[ i ].y;
					stbtt__add_point( points, num_points++, x, y );
					break;
				case STBTT_vline:
					x = vertices[ i ].x, y = vertices[ i ].y;
					stbtt__add_point( points, num_points++, x, y );
					break;
				case STBTT_vcurve:
					stbtt__tesselate_curve( points, &num_points, x, y,
																	vertices[ i ].cx, vertices[ i ].cy,
																	vertices[ i ].x, vertices[ i ].y,
																	objspace_flatness_squared, 0 );
					x = vertices[ i ].x, y = vertices[ i ].y;
					break;
				case STBTT_vcubic:
					stbtt__tesselate_cubic( points, &num_points, x, y,
																	vertices[ i ].cx, vertices[ i ].cy,
																	vertices[ i ].cx1, vertices[ i ].cy1,
																	vertices[ i ].x, vertices[ i ].y,
																	objspace_flatness_squared, 0 );
					x = vertices[ i ].x, y = vertices[ i ].y;
					break;
			}
		}
		( *contour_lengths )[ n ] = num_points - start;
	}

	return points;
error:
	STBTT_free( points, userdata );
	STBTT_free( *contour_lengths, userdata );
	*contour_lengths = 0;
	*num_contours = 0;
	return NULL;
}

STBTT_DEF void stbtt_Rasterize( stbtt__bitmap* result, float flatness_in_pixels, stbtt_vertex* vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void* userdata )
{
	float scale = scale_x > scale_y ? scale_y : scale_x;
	int winding_count = 0;
	int* winding_lengths = NULL;
	stbtt__point* windings = stbtt_FlattenCurves( vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata );
	if( windings )
	{
		stbtt__rasterize( result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata );
		STBTT_free( winding_lengths, userdata );
		STBTT_free( windings, userdata );
	}
}

STBTT_DEF void stbtt_FreeBitmap( unsigned char* bitmap, void* userdata )
{
	STBTT_free( bitmap, userdata );
}

STBTT_DEF unsigned char* stbtt_GetGlyphBitmapSubpixel( const stbtt_fontinfo* info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int* width, int* height, int* xoff, int* yoff )
{
	int ix0, iy0, ix1, iy1;
	stbtt__bitmap gbm;
	stbtt_vertex* vertices;
	int num_verts = stbtt_GetGlyphShape( info, glyph, &vertices );

	if( scale_x == 0 ) scale_x = scale_y;
	if( scale_y == 0 )
	{
		if( scale_x == 0 )
		{
			STBTT_free( vertices, info->userdata );
			return NULL;
		}
		scale_y = scale_x;
	}

	stbtt_GetGlyphBitmapBoxSubpixel( info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0, &iy0, &ix1, &iy1 );

	// now we get the size
	gbm.w = ( ix1 - ix0 );
	gbm.h = ( iy1 - iy0 );
	gbm.pixels = NULL; // in case we error

	if( width ) *width = gbm.w;
	if( height ) *height = gbm.h;
	if( xoff ) *xoff = ix0;
	if( yoff ) *yoff = iy0;

	if( gbm.w && gbm.h )
	{
		gbm.pixels = ( unsigned char* )STBTT_malloc( gbm.w * gbm.h, info->userdata );
		if( gbm.pixels )
		{
			gbm.stride = gbm.w;

			stbtt_Rasterize( &gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata );
		}
	}
	STBTT_free( vertices, info->userdata );
	return gbm.pixels;
}

STBTT_DEF unsigned char* stbtt_GetGlyphBitmap( const stbtt_fontinfo* info, float scale_x, float scale_y, int glyph, int* width, int* height, int* xoff, int* yoff )
{
	return stbtt_GetGlyphBitmapSubpixel( info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff );
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel( const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph )
{
	int ix0, iy0;
	stbtt_vertex* vertices;
	int num_verts = stbtt_GetGlyphShape( info, glyph, &vertices );
	stbtt__bitmap gbm;

	stbtt_GetGlyphBitmapBoxSubpixel( info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0, &iy0, 0, 0 );
	gbm.pixels = output;
	gbm.w = out_w;
	gbm.h = out_h;
	gbm.stride = out_stride;

	if( gbm.w && gbm.h )
		stbtt_Rasterize( &gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata );

	STBTT_free( vertices, info->userdata );
}

STBTT_DEF void stbtt_MakeGlyphBitmap( const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph )
{
	stbtt_MakeGlyphBitmapSubpixel( info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f, 0.0f, glyph );
}

STBTT_DEF unsigned char* stbtt_GetCodepointBitmapSubpixel( const stbtt_fontinfo* info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int* width, int* height, int* xoff, int* yoff )
{
	return stbtt_GetGlyphBitmapSubpixel( info, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex( info, codepoint ), width, height, xoff, yoff );
}

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter( const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float* sub_x, float* sub_y, int codepoint )
{
	stbtt_MakeGlyphBitmapSubpixelPrefilter( info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, sub_x, sub_y, stbtt_FindGlyphIndex( info, codepoint ) );
}

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel( const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint )
{
	stbtt_MakeGlyphBitmapSubpixel( info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex( info, codepoint ) );
}

STBTT_DEF unsigned char* stbtt_GetCodepointBitmap( const stbtt_fontinfo* info, float scale_x, float scale_y, int codepoint, int* width, int* height, int* xoff, int* yoff )
{
	return stbtt_GetCodepointBitmapSubpixel( info, scale_x, scale_y, 0.0f, 0.0f, codepoint, width, height, xoff, yoff );
}

STBTT_DEF void stbtt_MakeCodepointBitmap( const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint )
{
	stbtt_MakeCodepointBitmapSubpixel( info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f, 0.0f, codepoint );
}

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-CRAPPY packing to keep source code small

static int stbtt_BakeFontBitmap_internal( unsigned char* data, int offset,  // font location (use offset=0 for plain .ttf)
																					float pixel_height,                     // height of font in pixels
																					unsigned char* pixels, int pw, int ph,  // bitmap to be filled in
																					int first_char, int num_chars,          // characters to bake
																					stbtt_bakedchar* chardata )
{
	float scale;
	int x, y, bottom_y, i;
	stbtt_fontinfo f;
	f.userdata = NULL;
	if( !stbtt_InitFont( &f, data, offset ) )
		return -1;
	STBTT_memset( pixels, 0, pw * ph ); // background of 0 around pixels
	x = y = 1;
	bottom_y = 1;

	scale = stbtt_ScaleForPixelHeight( &f, pixel_height );

	for( i = 0; i < num_chars; ++i )
	{
		int advance, lsb, x0, y0, x1, y1, gw, gh;
		int g = stbtt_FindGlyphIndex( &f, first_char + i );
		stbtt_GetGlyphHMetrics( &f, g, &advance, &lsb );
		stbtt_GetGlyphBitmapBox( &f, g, scale, scale, &x0, &y0, &x1, &y1 );
		gw = x1 - x0;
		gh = y1 - y0;
		if( x + gw + 1 >= pw )
			y = bottom_y, x = 1; // advance to next row
		if( y + gh + 1 >= ph ) // check if it fits vertically AFTER potentially moving to next row
			return -i;
		STBTT_assert( x + gw < pw );
		STBTT_assert( y + gh < ph );
		stbtt_MakeGlyphBitmap( &f, pixels + x + y * pw, gw, gh, pw, scale, scale, g );
		chardata[ i ].x0 = ( stbtt_int16 )x;
		chardata[ i ].y0 = ( stbtt_int16 )y;
		chardata[ i ].x1 = ( stbtt_int16 )( x + gw );
		chardata[ i ].y1 = ( stbtt_int16 )( y + gh );
		chardata[ i ].xadvance = scale * advance;
		chardata[ i ].xoff = ( float )x0;
		chardata[ i ].yoff = ( float )y0;
		x = x + gw + 1;
		if( y + gh + 1 > bottom_y )
			bottom_y = y + gh + 1;
	}
	return bottom_y;
}

STBTT_DEF void stbtt_GetBakedQuad( const stbtt_bakedchar* chardata, int pw, int ph, int char_index, float* xpos, float* ypos, stbtt_aligned_quad* q, int opengl_fillrule )
{
	float d3d_bias = opengl_fillrule ? 0 : -0.5f;
	float ipw = 1.0f / pw, iph = 1.0f / ph;
	const stbtt_bakedchar* b = chardata + char_index;
	int round_x = STBTT_ifloor( ( *xpos + b->xoff ) + 0.5f );
	int round_y = STBTT_ifloor( ( *ypos + b->yoff ) + 0.5f );

	q->x0 = round_x + d3d_bias;
	q->y0 = round_y + d3d_bias;
	q->x1 = round_x + b->x1 - b->x0 + d3d_bias;
	q->y1 = round_y + b->y1 - b->y0 + d3d_bias;

	q->s0 = b->x0 * ipw;
	q->t0 = b->y0 * iph;
	q->s1 = b->x1 * ipw;
	q->t1 = b->y1 * iph;

	*xpos += b->xadvance;
}

//////////////////////////////////////////////////////////////////////////////
//
// rectangle packing replacement routines if you don't have stb_rect_pack.h
//

#ifndef STB_RECT_PACK_VERSION

typedef int stbrp_coord;

////////////////////////////////////////////////////////////////////////////////////
//                                                                                //
//                                                                                //
// COMPILER WARNING ?!?!?                                                         //
//                                                                                //
//                                                                                //
// if you get a compile warning due to these symbols being defined more than      //
// once, move #include "stb_rect_pack.h" before #include "stb_truetype.h"         //
//                                                                                //
////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
	int width, height;
	int x, y, bottom_y;
} stbrp_context;

typedef struct
{
	unsigned char x;
} stbrp_node;

struct stbrp_rect
{
	stbrp_coord x, y;
	int id, w, h, was_packed;
};

static void stbrp_init_target( stbrp_context* con, int pw, int ph, stbrp_node* nodes, int num_nodes )
{
	con->width = pw;
	con->height = ph;
	con->x = 0;
	con->y = 0;
	con->bottom_y = 0;
	STBTT__NOTUSED( nodes );
	STBTT__NOTUSED( num_nodes );
}

static void stbrp_pack_rects( stbrp_context* con, stbrp_rect* rects, int num_rects )
{
	int i;
	for( i = 0; i < num_rects; ++i )
	{
		if( con->x + rects[ i ].w > con->width )
		{
			con->x = 0;
			con->y = con->bottom_y;
		}
		if( con->y + rects[ i ].h > con->height )
			break;
		rects[ i ].x = con->x;
		rects[ i ].y = con->y;
		rects[ i ].was_packed = 1;
		con->x += rects[ i ].w;
		if( con->y + rects[ i ].h > con->bottom_y )
			con->bottom_y = con->y + rects[ i ].h;
	}
	for( ; i < num_rects; ++i )
		rects[ i ].was_packed = 0;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If
// stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.

STBTT_DEF int stbtt_PackBegin( stbtt_pack_context* spc, unsigned char* pixels, int pw, int ph, int stride_in_bytes, int padding, void* alloc_context )
{
	stbrp_context* context = ( stbrp_context* )STBTT_malloc( sizeof( *context ), alloc_context );
	int            num_nodes = pw - padding;
	stbrp_node* nodes = ( stbrp_node* )STBTT_malloc( sizeof( *nodes ) * num_nodes, alloc_context );

	if( context == NULL || nodes == NULL )
	{
		if( context != NULL ) STBTT_free( context, alloc_context );
		if( nodes != NULL ) STBTT_free( nodes, alloc_context );
		return 0;
	}

	spc->user_allocator_context = alloc_context;
	spc->width = pw;
	spc->height = ph;
	spc->pixels = pixels;
	spc->pack_info = context;
	spc->nodes = nodes;
	spc->padding = padding;
	spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
	spc->h_oversample = 1;
	spc->v_oversample = 1;
	spc->skip_missing = 0;

	stbrp_init_target( context, pw - padding, ph - padding, nodes, num_nodes );

	if( pixels )
		STBTT_memset( pixels, 0, pw * ph ); // background of 0 around pixels

	return 1;
}

STBTT_DEF void stbtt_PackEnd( stbtt_pack_context* spc )
{
	STBTT_free( spc->nodes, spc->user_allocator_context );
	STBTT_free( spc->pack_info, spc->user_allocator_context );
}

STBTT_DEF void stbtt_PackSetOversampling( stbtt_pack_context* spc, unsigned int h_oversample, unsigned int v_oversample )
{
	STBTT_assert( h_oversample <= STBTT_MAX_OVERSAMPLE );
	STBTT_assert( v_oversample <= STBTT_MAX_OVERSAMPLE );
	if( h_oversample <= STBTT_MAX_OVERSAMPLE )
		spc->h_oversample = h_oversample;
	if( v_oversample <= STBTT_MAX_OVERSAMPLE )
		spc->v_oversample = v_oversample;
}

STBTT_DEF void stbtt_PackSetSkipMissingCodepoints( stbtt_pack_context* spc, int skip )
{
	spc->skip_missing = skip;
}

#define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)

static void stbtt__h_prefilter( unsigned char* pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width )
{
	unsigned char buffer[ STBTT_MAX_OVERSAMPLE ];
	int safe_w = w - kernel_width;
	int j;
	STBTT_memset( buffer, 0, STBTT_MAX_OVERSAMPLE ); // suppress bogus warning from VS2013 -analyze
	for( j = 0; j < h; ++j )
	{
		int i;
		unsigned int total;
		STBTT_memset( buffer, 0, kernel_width );

		total = 0;

		// make kernel_width a constant in common cases so compiler can optimize out the divide
		switch( kernel_width )
		{
			case 2:
				for( i = 0; i <= safe_w; ++i )
				{
					total += pixels[ i ] - buffer[ i & STBTT__OVER_MASK ];
					buffer[ ( i + kernel_width ) & STBTT__OVER_MASK ] = pixels[ i ];
					pixels[ i ] = ( unsigned char )( total / 2 );
				}
				break;
			case 3:
				for( i = 0; i <= safe_w; ++i )
				{
					total += pixels[ i ] - buffer[ i & STBTT__OVER_MASK ];
					buffer[ ( i + kernel_width ) & STBTT__OVER_MASK ] = pixels[ i ];
					pixels[ i ] = ( unsigned char )( total / 3 );
				}
				break;
			case 4:
				for( i = 0; i <= safe_w; ++i )
				{
					total += pixels[ i ] - buffer[ i & STBTT__OVER_MASK ];
					buffer[ ( i + kernel_width ) & STBTT__OVER_MASK ] = pixels[ i ];
					pixels[ i ] = ( unsigned char )( total / 4 );
				}
				break;
			case 5:
				for( i = 0; i <= safe_w; ++i )
				{
					total += pixels[ i ] - buffer[ i & STBTT__OVER_MASK ];
					buffer[ ( i + kernel_width ) & STBTT__OVER_MASK ] = pixels[ i ];
					pixels[ i ] = ( unsigned char )( total / 5 );
				}
				break;
			default:
				for( i = 0; i <= safe_w; ++i )
				{
					total += pixels[ i ] - buffer[ i & STBTT__OVER_MASK ];
					buffer[ ( i + kernel_width ) & STBTT__OVER_MASK ] = pixels[ i ];
					pixels[ i ] = ( unsigned char )( total / kernel_width );
				}
				break;
		}

		for( ; i < w; ++i )
		{
			STBTT_assert( pixels[ i ] == 0 );
			total -= buffer[ i & STBTT__OVER_MASK ];
			pixels[ i ] = ( unsigned char )( total / kernel_width );
		}

		pixels += stride_in_bytes;
	}
}

static void stbtt__v_prefilter( unsigned char* pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width )
{
	unsigned char buffer[ STBTT_MAX_OVERSAMPLE ];
	int safe_h = h - kernel_width;
	int j;
	STBTT_memset( buffer, 0, STBTT_MAX_OVERSAMPLE ); // suppress bogus warning from VS2013 -analyze
	for( j = 0; j < w; ++j )
	{
		int i;
		unsigned int total;
		STBTT_memset( buffer, 0, kernel_width );

		total = 0;

		// make kernel_width a constant in common cases so compiler can optimize out the divide
		switch( kernel_width )
		{
			case 2:
				for( i = 0; i <= safe_h; ++i )
				{
					total += pixels[ i * stride_in_bytes ] - buffer[ i & STBTT__OVER_MASK ];
					buffer[ ( i + kernel_width ) & STBTT__OVER_MASK ] = pixels[ i * stride_in_bytes ];
					pixels[ i * stride_in_bytes ] = ( unsigned char )( total / 2 );
				}
				break;
			case 3:
				for( i = 0; i <= safe_h; ++i )
				{
					total += pixels[ i * stride_in_bytes ] - buffer[ i & STBTT__OVER_MASK ];
					buffer[ ( i + kernel_width ) & STBTT__OVER_MASK ] = pixels[ i * stride_in_bytes ];
					pixels[ i * stride_in_bytes ] = ( unsigned char )( total / 3 );
				}
				break;
			case 4:
				for( i = 0; i <= safe_h; ++i )
				{
					total += pixels[ i * stride_in_bytes ] - buffer[ i & STBTT__OVER_MASK ];
					buffer[ ( i + kernel_width ) & STBTT__OVER_MASK ] = pixels[ i * stride_in_bytes ];
					pixels[ i * stride_in_bytes ] = ( unsigned char )( total / 4 );
				}
				break;
			case 5:
				for( i = 0; i <= safe_h; ++i )
				{
					total += pixels[ i * stride_in_bytes ] - buffer[ i & STBTT__OVER_MASK ];
					buffer[ ( i + kernel_width ) & STBTT__OVER_MASK ] = pixels[ i * stride_in_bytes ];
					pixels[ i * stride_in_bytes ] = ( unsigned char )( total / 5 );
				}
				break;
			default:
				for( i = 0; i <= safe_h; ++i )
				{
					total += pixels[ i * stride_in_bytes ] - buffer[ i & STBTT__OVER_MASK ];
					buffer[ ( i + kernel_width ) & STBTT__OVER_MASK ] = pixels[ i * stride_in_bytes ];
					pixels[ i * stride_in_bytes ] = ( unsigned char )( total / kernel_width );
				}
				break;
		}

		for( ; i < h; ++i )
		{
			STBTT_assert( pixels[ i * stride_in_bytes ] == 0 );
			total -= buffer[ i & STBTT__OVER_MASK ];
			pixels[ i * stride_in_bytes ] = ( unsigned char )( total / kernel_width );
		}

		pixels += 1;
	}
}

static float stbtt__oversample_shift( int oversample )
{
	if( !oversample )
		return 0.0f;

	// The prefilter is a box filter of width "oversample",
	// which shifts phase by (oversample - 1)/2 pixels in
	// oversampled space. We want to shift in the opposite
	// direction to counter this.
	return ( float )-( oversample - 1 ) / ( 2.0f * ( float )oversample );
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesGatherRects( stbtt_pack_context* spc, const stbtt_fontinfo* info, stbtt_pack_range* ranges, int num_ranges, stbrp_rect* rects )
{
	int i, j, k;

	k = 0;
	for( i = 0; i < num_ranges; ++i )
	{
		float fh = ranges[ i ].font_size;
		float scale = fh > 0 ? stbtt_ScaleForPixelHeight( info, fh ) : stbtt_ScaleForMappingEmToPixels( info, -fh );
		ranges[ i ].h_oversample = ( unsigned char )spc->h_oversample;
		ranges[ i ].v_oversample = ( unsigned char )spc->v_oversample;
		for( j = 0; j < ranges[ i ].num_chars; ++j )
		{
			int x0, y0, x1, y1;
			int codepoint = ranges[ i ].array_of_unicode_codepoints == NULL ? ranges[ i ].first_unicode_codepoint_in_range + j : ranges[ i ].array_of_unicode_codepoints[ j ];
			int glyph = stbtt_FindGlyphIndex( info, codepoint );
			if( glyph == 0 && spc->skip_missing )
			{
				rects[ k ].w = rects[ k ].h = 0;
			}
			else
			{
				stbtt_GetGlyphBitmapBoxSubpixel( info, glyph,
																				 scale * spc->h_oversample,
																				 scale * spc->v_oversample,
																				 0, 0,
																				 &x0, &y0, &x1, &y1 );
				rects[ k ].w = ( stbrp_coord )( x1 - x0 + spc->padding + spc->h_oversample - 1 );
				rects[ k ].h = ( stbrp_coord )( y1 - y0 + spc->padding + spc->v_oversample - 1 );
			}
			++k;
		}
	}

	return k;
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter( const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int prefilter_x, int prefilter_y, float* sub_x, float* sub_y, int glyph )
{
	stbtt_MakeGlyphBitmapSubpixel( info,
																 output,
																 out_w - ( prefilter_x - 1 ),
																 out_h - ( prefilter_y - 1 ),
																 out_stride,
																 scale_x,
																 scale_y,
																 shift_x,
																 shift_y,
																 glyph );

	if( prefilter_x > 1 )
		stbtt__h_prefilter( output, out_w, out_h, out_stride, prefilter_x );

	if( prefilter_y > 1 )
		stbtt__v_prefilter( output, out_w, out_h, out_stride, prefilter_y );

	*sub_x = stbtt__oversample_shift( prefilter_x );
	*sub_y = stbtt__oversample_shift( prefilter_y );
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesRenderIntoRects( stbtt_pack_context* spc, const stbtt_fontinfo* info, stbtt_pack_range* ranges, int num_ranges, stbrp_rect* rects )
{
	int i, j, k, return_value = 1;

	// save current values
	int old_h_over = spc->h_oversample;
	int old_v_over = spc->v_oversample;

	k = 0;
	for( i = 0; i < num_ranges; ++i )
	{
		float fh = ranges[ i ].font_size;
		float scale = fh > 0 ? stbtt_ScaleForPixelHeight( info, fh ) : stbtt_ScaleForMappingEmToPixels( info, -fh );
		float recip_h, recip_v, sub_x, sub_y;
		spc->h_oversample = ranges[ i ].h_oversample;
		spc->v_oversample = ranges[ i ].v_oversample;
		recip_h = 1.0f / spc->h_oversample;
		recip_v = 1.0f / spc->v_oversample;
		sub_x = stbtt__oversample_shift( spc->h_oversample );
		sub_y = stbtt__oversample_shift( spc->v_oversample );
		for( j = 0; j < ranges[ i ].num_chars; ++j )
		{
			stbrp_rect* r = &rects[ k ];
			if( r->was_packed && r->w != 0 && r->h != 0 )
			{
				stbtt_packedchar* bc = &ranges[ i ].chardata_for_range[ j ];
				int advance, lsb, x0, y0, x1, y1;
				int codepoint = ranges[ i ].array_of_unicode_codepoints == NULL ? ranges[ i ].first_unicode_codepoint_in_range + j : ranges[ i ].array_of_unicode_codepoints[ j ];
				int glyph = stbtt_FindGlyphIndex( info, codepoint );
				stbrp_coord pad = ( stbrp_coord )spc->padding;

				// pad on left and top
				r->x += pad;
				r->y += pad;
				r->w -= pad;
				r->h -= pad;
				stbtt_GetGlyphHMetrics( info, glyph, &advance, &lsb );
				stbtt_GetGlyphBitmapBox( info, glyph,
																 scale * spc->h_oversample,
																 scale * spc->v_oversample,
																 &x0, &y0, &x1, &y1 );
				stbtt_MakeGlyphBitmapSubpixel( info,
																			 spc->pixels + r->x + r->y * spc->stride_in_bytes,
																			 r->w - spc->h_oversample + 1,
																			 r->h - spc->v_oversample + 1,
																			 spc->stride_in_bytes,
																			 scale * spc->h_oversample,
																			 scale * spc->v_oversample,
																			 0, 0,
																			 glyph );

				if( spc->h_oversample > 1 )
					stbtt__h_prefilter( spc->pixels + r->x + r->y * spc->stride_in_bytes,
															r->w, r->h, spc->stride_in_bytes,
															spc->h_oversample );

				if( spc->v_oversample > 1 )
					stbtt__v_prefilter( spc->pixels + r->x + r->y * spc->stride_in_bytes,
															r->w, r->h, spc->stride_in_bytes,
															spc->v_oversample );

				bc->x0 = ( stbtt_int16 )r->x;
				bc->y0 = ( stbtt_int16 )r->y;
				bc->x1 = ( stbtt_int16 )( r->x + r->w );
				bc->y1 = ( stbtt_int16 )( r->y + r->h );
				bc->xadvance = scale * advance;
				bc->xoff = ( float )x0 * recip_h + sub_x;
				bc->yoff = ( float )y0 * recip_v + sub_y;
				bc->xoff2 = ( x0 + r->w ) * recip_h + sub_x;
				bc->yoff2 = ( y0 + r->h ) * recip_v + sub_y;
			}
			else
			{
				return_value = 0; // if any fail, report failure
			}

			++k;
		}
	}

	// restore original values
	spc->h_oversample = old_h_over;
	spc->v_oversample = old_v_over;

	return return_value;
}

STBTT_DEF void stbtt_PackFontRangesPackRects( stbtt_pack_context* spc, stbrp_rect* rects, int num_rects )
{
	stbrp_pack_rects( ( stbrp_context* )spc->pack_info, rects, num_rects );
}

STBTT_DEF int stbtt_PackFontRanges( stbtt_pack_context* spc, const unsigned char* fontdata, int font_index, stbtt_pack_range* ranges, int num_ranges )
{
	stbtt_fontinfo info;
	int i, j, n, return_value; // [DEAR IMGUI] removed = 1
	//stbrp_context *context = (stbrp_context *) spc->pack_info;
	stbrp_rect* rects;

	// flag all characters as NOT packed
	for( i = 0; i < num_ranges; ++i )
		for( j = 0; j < ranges[ i ].num_chars; ++j )
			ranges[ i ].chardata_for_range[ j ].x0 =
			ranges[ i ].chardata_for_range[ j ].y0 =
			ranges[ i ].chardata_for_range[ j ].x1 =
			ranges[ i ].chardata_for_range[ j ].y1 = 0;

	n = 0;
	for( i = 0; i < num_ranges; ++i )
		n += ranges[ i ].num_chars;

	rects = ( stbrp_rect* )STBTT_malloc( sizeof( *rects ) * n, spc->user_allocator_context );
	if( rects == NULL )
		return 0;

	info.userdata = spc->user_allocator_context;
	stbtt_InitFont( &info, fontdata, stbtt_GetFontOffsetForIndex( fontdata, font_index ) );

	n = stbtt_PackFontRangesGatherRects( spc, &info, ranges, num_ranges, rects );

	stbtt_PackFontRangesPackRects( spc, rects, n );

	return_value = stbtt_PackFontRangesRenderIntoRects( spc, &info, ranges, num_ranges, rects );

	STBTT_free( rects, spc->user_allocator_context );
	return return_value;
}

STBTT_DEF int stbtt_PackFontRange( stbtt_pack_context* spc, const unsigned char* fontdata, int font_index, float font_size,
																	 int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar* chardata_for_range )
{
	stbtt_pack_range range;
	range.first_unicode_codepoint_in_range = first_unicode_codepoint_in_range;
	range.array_of_unicode_codepoints = NULL;
	range.num_chars = num_chars_in_range;
	range.chardata_for_range = chardata_for_range;
	range.font_size = font_size;
	return stbtt_PackFontRanges( spc, fontdata, font_index, &range, 1 );
}

STBTT_DEF void stbtt_GetScaledFontVMetrics( const unsigned char* fontdata, int index, float size, float* ascent, float* descent, float* lineGap )
{
	int i_ascent, i_descent, i_lineGap;
	float scale;
	stbtt_fontinfo info;
	stbtt_InitFont( &info, fontdata, stbtt_GetFontOffsetForIndex( fontdata, index ) );
	scale = size > 0 ? stbtt_ScaleForPixelHeight( &info, size ) : stbtt_ScaleForMappingEmToPixels( &info, -size );
	stbtt_GetFontVMetrics( &info, &i_ascent, &i_descent, &i_lineGap );
	*ascent = ( float )i_ascent * scale;
	*descent = ( float )i_descent * scale;
	*lineGap = ( float )i_lineGap * scale;
}

STBTT_DEF void stbtt_GetPackedQuad( const stbtt_packedchar* chardata, int pw, int ph, int char_index, float* xpos, float* ypos, stbtt_aligned_quad* q, int align_to_integer )
{
	float ipw = 1.0f / pw, iph = 1.0f / ph;
	const stbtt_packedchar* b = chardata + char_index;

	if( align_to_integer )
	{
		float x = ( float )STBTT_ifloor( ( *xpos + b->xoff ) + 0.5f );
		float y = ( float )STBTT_ifloor( ( *ypos + b->yoff ) + 0.5f );
		q->x0 = x;
		q->y0 = y;
		q->x1 = x + b->xoff2 - b->xoff;
		q->y1 = y + b->yoff2 - b->yoff;
	}
	else
	{
		q->x0 = *xpos + b->xoff;
		q->y0 = *ypos + b->yoff;
		q->x1 = *xpos + b->xoff2;
		q->y1 = *ypos + b->yoff2;
	}

	q->s0 = b->x0 * ipw;
	q->t0 = b->y0 * iph;
	q->s1 = b->x1 * ipw;
	q->t1 = b->y1 * iph;

	*xpos += b->xadvance;
}

//////////////////////////////////////////////////////////////////////////////
//
// sdf computation
//

#define STBTT_min(a,b)  ((a) < (b) ? (a) : (b))
#define STBTT_max(a,b)  ((a) < (b) ? (b) : (a))

static int stbtt__ray_intersect_bezier( float orig[ 2 ], float ray[ 2 ], float q0[ 2 ], float q1[ 2 ], float q2[ 2 ], float hits[ 2 ][ 2 ] )
{
	float q0perp = q0[ 1 ] * ray[ 0 ] - q0[ 0 ] * ray[ 1 ];
	float q1perp = q1[ 1 ] * ray[ 0 ] - q1[ 0 ] * ray[ 1 ];
	float q2perp = q2[ 1 ] * ray[ 0 ] - q2[ 0 ] * ray[ 1 ];
	float roperp = orig[ 1 ] * ray[ 0 ] - orig[ 0 ] * ray[ 1 ];

	float a = q0perp - 2 * q1perp + q2perp;
	float b = q1perp - q0perp;
	float c = q0perp - roperp;

	float s0 = 0., s1 = 0.;
	int num_s = 0;

	if( a != 0.0 )
	{
		float discr = b * b - a * c;
		if( discr > 0.0 )
		{
			float rcpna = -1 / a;
			float d = ( float )STBTT_sqrt( discr );
			s0 = ( b + d ) * rcpna;
			s1 = ( b - d ) * rcpna;
			if( s0 >= 0.0 && s0 <= 1.0 )
				num_s = 1;
			if( d > 0.0 && s1 >= 0.0 && s1 <= 1.0 )
			{
				if( num_s == 0 ) s0 = s1;
				++num_s;
			}
		}
	}
	else
	{
		// 2*b*s + c = 0
		// s = -c / (2*b)
		s0 = c / ( -2 * b );
		if( s0 >= 0.0 && s0 <= 1.0 )
			num_s = 1;
	}

	if( num_s == 0 )
		return 0;
	else
	{
		float rcp_len2 = 1 / ( ray[ 0 ] * ray[ 0 ] + ray[ 1 ] * ray[ 1 ] );
		float rayn_x = ray[ 0 ] * rcp_len2, rayn_y = ray[ 1 ] * rcp_len2;

		float q0d = q0[ 0 ] * rayn_x + q0[ 1 ] * rayn_y;
		float q1d = q1[ 0 ] * rayn_x + q1[ 1 ] * rayn_y;
		float q2d = q2[ 0 ] * rayn_x + q2[ 1 ] * rayn_y;
		float rod = orig[ 0 ] * rayn_x + orig[ 1 ] * rayn_y;

		float q10d = q1d - q0d;
		float q20d = q2d - q0d;
		float q0rd = q0d - rod;

		hits[ 0 ][ 0 ] = q0rd + s0 * ( 2.0f - 2.0f * s0 ) * q10d + s0 * s0 * q20d;
		hits[ 0 ][ 1 ] = a * s0 + b;

		if( num_s > 1 )
		{
			hits[ 1 ][ 0 ] = q0rd + s1 * ( 2.0f - 2.0f * s1 ) * q10d + s1 * s1 * q20d;
			hits[ 1 ][ 1 ] = a * s1 + b;
			return 2;
		}
		else
		{
			return 1;
		}
	}
}

static int equal( float* a, float* b )
{
	return ( a[ 0 ] == b[ 0 ] && a[ 1 ] == b[ 1 ] );
}

static int stbtt__compute_crossings_x( float x, float y, int nverts, stbtt_vertex* verts )
{
	int i;
	float orig[ 2 ], ray[ 2 ] = { 1, 0 };
	float y_frac;
	int winding = 0;

	orig[ 0 ] = x;
	//orig[1] = y; // [DEAR IMGUI] commmented double assignment

	// make sure y never passes through a vertex of the shape
	y_frac = ( float )STBTT_fmod( y, 1.0f );
	if( y_frac < 0.01f )
		y += 0.01f;
	else if( y_frac > 0.99f )
		y -= 0.01f;
	orig[ 1 ] = y;

	// test a ray from (-infinity,y) to (x,y)
	for( i = 0; i < nverts; ++i )
	{
		if( verts[ i ].type == STBTT_vline )
		{
			int x0 = ( int )verts[ i - 1 ].x, y0 = ( int )verts[ i - 1 ].y;
			int x1 = ( int )verts[ i ].x, y1 = ( int )verts[ i ].y;
			if( y > STBTT_min( y0, y1 ) && y < STBTT_max( y0, y1 ) && x > STBTT_min( x0, x1 ) )
			{
				float x_inter = ( y - y0 ) / ( y1 - y0 ) * ( x1 - x0 ) + x0;
				if( x_inter < x )
					winding += ( y0 < y1 ) ? 1 : -1;
			}
		}
		if( verts[ i ].type == STBTT_vcurve )
		{
			int x0 = ( int )verts[ i - 1 ].x, y0 = ( int )verts[ i - 1 ].y;
			int x1 = ( int )verts[ i ].cx, y1 = ( int )verts[ i ].cy;
			int x2 = ( int )verts[ i ].x, y2 = ( int )verts[ i ].y;
			int ax = STBTT_min( x0, STBTT_min( x1, x2 ) ), ay = STBTT_min( y0, STBTT_min( y1, y2 ) );
			int by = STBTT_max( y0, STBTT_max( y1, y2 ) );
			if( y > ay && y < by && x > ax )
			{
				float q0[ 2 ], q1[ 2 ], q2[ 2 ];
				float hits[ 2 ][ 2 ];
				q0[ 0 ] = ( float )x0;
				q0[ 1 ] = ( float )y0;
				q1[ 0 ] = ( float )x1;
				q1[ 1 ] = ( float )y1;
				q2[ 0 ] = ( float )x2;
				q2[ 1 ] = ( float )y2;
				if( equal( q0, q1 ) || equal( q1, q2 ) )
				{
					x0 = ( int )verts[ i - 1 ].x;
					y0 = ( int )verts[ i - 1 ].y;
					x1 = ( int )verts[ i ].x;
					y1 = ( int )verts[ i ].y;
					if( y > STBTT_min( y0, y1 ) && y < STBTT_max( y0, y1 ) && x > STBTT_min( x0, x1 ) )
					{
						float x_inter = ( y - y0 ) / ( y1 - y0 ) * ( x1 - x0 ) + x0;
						if( x_inter < x )
							winding += ( y0 < y1 ) ? 1 : -1;
					}
				}
				else
				{
					int num_hits = stbtt__ray_intersect_bezier( orig, ray, q0, q1, q2, hits );
					if( num_hits >= 1 )
						if( hits[ 0 ][ 0 ] < 0 )
							winding += ( hits[ 0 ][ 1 ] < 0 ? -1 : 1 );
					if( num_hits >= 2 )
						if( hits[ 1 ][ 0 ] < 0 )
							winding += ( hits[ 1 ][ 1 ] < 0 ? -1 : 1 );
				}
			}
		}
	}
	return winding;
}

static float stbtt__cuberoot( float x )
{
	if( x < 0 )
		return -( float )STBTT_pow( -x, 1.0f / 3.0f );
	else
		return  ( float )STBTT_pow( x, 1.0f / 3.0f );
}

// x^3 + c*x^2 + b*x + a = 0
static int stbtt__solve_cubic( float a, float b, float c, float* r )
{
	float s = -a / 3;
	float p = b - a * a / 3;
	float q = a * ( 2 * a * a - 9 * b ) / 27 + c;
	float p3 = p * p * p;
	float d = q * q + 4 * p3 / 27;
	if( d >= 0 )
	{
		float z = ( float )STBTT_sqrt( d );
		float u = ( -q + z ) / 2;
		float v = ( -q - z ) / 2;
		u = stbtt__cuberoot( u );
		v = stbtt__cuberoot( v );
		r[ 0 ] = s + u + v;
		return 1;
	}
	else
	{
		float u = ( float )STBTT_sqrt( -p / 3 );
		float v = ( float )STBTT_acos( -STBTT_sqrt( -27 / p3 ) * q / 2 ) / 3; // p3 must be negative, since d is negative
		float m = ( float )STBTT_cos( v );
		float n = ( float )STBTT_cos( v - 3.141592 / 2 ) * 1.732050808f;
		r[ 0 ] = s + u * 2 * m;
		r[ 1 ] = s - u * ( m + n );
		r[ 2 ] = s - u * ( m - n );

		//STBTT_assert( STBTT_fabs(((r[0]+a)*r[0]+b)*r[0]+c) < 0.05f);  // these asserts may not be safe at all scales, though they're in bezier t parameter units so maybe?
		//STBTT_assert( STBTT_fabs(((r[1]+a)*r[1]+b)*r[1]+c) < 0.05f);
		//STBTT_assert( STBTT_fabs(((r[2]+a)*r[2]+b)*r[2]+c) < 0.05f);
		return 3;
	}
}

STBTT_DEF unsigned char* stbtt_GetGlyphSDF( const stbtt_fontinfo* info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int* width, int* height, int* xoff, int* yoff )
{
	float scale_x = scale, scale_y = scale;
	int ix0, iy0, ix1, iy1;
	int w, h;
	unsigned char* data;

	// if one scale is 0, use same scale for both
	if( scale_x == 0 ) scale_x = scale_y;
	if( scale_y == 0 )
	{
		if( scale_x == 0 ) return NULL;  // if both scales are 0, return NULL
		scale_y = scale_x;
	}

	stbtt_GetGlyphBitmapBoxSubpixel( info, glyph, scale, scale, 0.0f, 0.0f, &ix0, &iy0, &ix1, &iy1 );

	// if empty, return NULL
	if( ix0 == ix1 || iy0 == iy1 )
		return NULL;

	ix0 -= padding;
	iy0 -= padding;
	ix1 += padding;
	iy1 += padding;

	w = ( ix1 - ix0 );
	h = ( iy1 - iy0 );

	if( width ) *width = w;
	if( height ) *height = h;
	if( xoff ) *xoff = ix0;
	if( yoff ) *yoff = iy0;

	// invert for y-downwards bitmaps
	scale_y = -scale_y;

	{
		int x, y, i, j;
		float* precompute;
		stbtt_vertex* verts;
		int num_verts = stbtt_GetGlyphShape( info, glyph, &verts );
		data = ( unsigned char* )STBTT_malloc( w * h, info->userdata );
		precompute = ( float* )STBTT_malloc( num_verts * sizeof( float ), info->userdata );

		for( i = 0, j = num_verts - 1; i < num_verts; j = i++ )
		{
			if( verts[ i ].type == STBTT_vline )
			{
				float x0 = verts[ i ].x * scale_x, y0 = verts[ i ].y * scale_y;
				float x1 = verts[ j ].x * scale_x, y1 = verts[ j ].y * scale_y;
				float dist = ( float )STBTT_sqrt( ( x1 - x0 ) * ( x1 - x0 ) + ( y1 - y0 ) * ( y1 - y0 ) );
				precompute[ i ] = ( dist == 0 ) ? 0.0f : 1.0f / dist;
			}
			else if( verts[ i ].type == STBTT_vcurve )
			{
				float x2 = verts[ j ].x * scale_x, y2 = verts[ j ].y * scale_y;
				float x1 = verts[ i ].cx * scale_x, y1 = verts[ i ].cy * scale_y;
				float x0 = verts[ i ].x * scale_x, y0 = verts[ i ].y * scale_y;
				float bx = x0 - 2 * x1 + x2, by = y0 - 2 * y1 + y2;
				float len2 = bx * bx + by * by;
				if( len2 != 0.0f )
					precompute[ i ] = 1.0f / ( bx * bx + by * by );
				else
					precompute[ i ] = 0.0f;
			}
			else
				precompute[ i ] = 0.0f;
		}

		for( y = iy0; y < iy1; ++y )
		{
			for( x = ix0; x < ix1; ++x )
			{
				float val;
				float min_dist = 999999.0f;
				float sx = ( float )x + 0.5f;
				float sy = ( float )y + 0.5f;
				float x_gspace = ( sx / scale_x );
				float y_gspace = ( sy / scale_y );

				int winding = stbtt__compute_crossings_x( x_gspace, y_gspace, num_verts, verts ); // @OPTIMIZE: this could just be a rasterization, but needs to be line vs. non-tesselated curves so a new path

				for( i = 0; i < num_verts; ++i )
				{
					float x0 = verts[ i ].x * scale_x, y0 = verts[ i ].y * scale_y;

					// check against every point here rather than inside line/curve primitives -- @TODO: wrong if multiple 'moves' in a row produce a garbage point, and given culling, probably more efficient to do within line/curve
					float dist2 = ( x0 - sx ) * ( x0 - sx ) + ( y0 - sy ) * ( y0 - sy );
					if( dist2 < min_dist * min_dist )
						min_dist = ( float )STBTT_sqrt( dist2 );

					if( verts[ i ].type == STBTT_vline )
					{
						float x1 = verts[ i - 1 ].x * scale_x, y1 = verts[ i - 1 ].y * scale_y;

						// coarse culling against bbox
						//if (sx > STBTT_min(x0,x1)-min_dist && sx < STBTT_max(x0,x1)+min_dist &&
						//    sy > STBTT_min(y0,y1)-min_dist && sy < STBTT_max(y0,y1)+min_dist)
						float dist = ( float )STBTT_fabs( ( x1 - x0 ) * ( y0 - sy ) - ( y1 - y0 ) * ( x0 - sx ) ) * precompute[ i ];
						STBTT_assert( i != 0 );
						if( dist < min_dist )
						{
							// check position along line
							// x' = x0 + t*(x1-x0), y' = y0 + t*(y1-y0)
							// minimize (x'-sx)*(x'-sx)+(y'-sy)*(y'-sy)
							float dx = x1 - x0, dy = y1 - y0;
							float px = x0 - sx, py = y0 - sy;
							// minimize (px+t*dx)^2 + (py+t*dy)^2 = px*px + 2*px*dx*t + t^2*dx*dx + py*py + 2*py*dy*t + t^2*dy*dy
							// derivative: 2*px*dx + 2*py*dy + (2*dx*dx+2*dy*dy)*t, set to 0 and solve
							float t = -( px * dx + py * dy ) / ( dx * dx + dy * dy );
							if( t >= 0.0f && t <= 1.0f )
								min_dist = dist;
						}
					}
					else if( verts[ i ].type == STBTT_vcurve )
					{
						float x2 = verts[ i - 1 ].x * scale_x, y2 = verts[ i - 1 ].y * scale_y;
						float x1 = verts[ i ].cx * scale_x, y1 = verts[ i ].cy * scale_y;
						float box_x0 = STBTT_min( STBTT_min( x0, x1 ), x2 );
						float box_y0 = STBTT_min( STBTT_min( y0, y1 ), y2 );
						float box_x1 = STBTT_max( STBTT_max( x0, x1 ), x2 );
						float box_y1 = STBTT_max( STBTT_max( y0, y1 ), y2 );
						// coarse culling against bbox to avoid computing cubic unnecessarily
						if( sx > box_x0 - min_dist && sx < box_x1 + min_dist && sy > box_y0 - min_dist && sy < box_y1 + min_dist )
						{
							int num = 0;
							float ax = x1 - x0, ay = y1 - y0;
							float bx = x0 - 2 * x1 + x2, by = y0 - 2 * y1 + y2;
							float mx = x0 - sx, my = y0 - sy;
							float res[ 3 ], px, py, t, it;
							float a_inv = precompute[ i ];
							if( a_inv == 0.0 )
							{ // if a_inv is 0, it's 2nd degree so use quadratic formula
								float a = 3 * ( ax * bx + ay * by );
								float b = 2 * ( ax * ax + ay * ay ) + ( mx * bx + my * by );
								float c = mx * ax + my * ay;
								if( a == 0.0 )
								{ // if a is 0, it's linear
									if( b != 0.0 )
									{
										res[ num++ ] = -c / b;
									}
								}
								else
								{
									float discriminant = b * b - 4 * a * c;
									if( discriminant < 0 )
										num = 0;
									else
									{
										float root = ( float )STBTT_sqrt( discriminant );
										res[ 0 ] = ( -b - root ) / ( 2 * a );
										res[ 1 ] = ( -b + root ) / ( 2 * a );
										num = 2; // don't bother distinguishing 1-solution case, as code below will still work
									}
								}
							}
							else
							{
								float b = 3 * ( ax * bx + ay * by ) * a_inv; // could precompute this as it doesn't depend on sample point
								float c = ( 2 * ( ax * ax + ay * ay ) + ( mx * bx + my * by ) ) * a_inv;
								float d = ( mx * ax + my * ay ) * a_inv;
								num = stbtt__solve_cubic( b, c, d, res );
							}
							if( num >= 1 && res[ 0 ] >= 0.0f && res[ 0 ] <= 1.0f )
							{
								t = res[ 0 ], it = 1.0f - t;
								px = it * it * x0 + 2 * t * it * x1 + t * t * x2;
								py = it * it * y0 + 2 * t * it * y1 + t * t * y2;
								dist2 = ( px - sx ) * ( px - sx ) + ( py - sy ) * ( py - sy );
								if( dist2 < min_dist * min_dist )
									min_dist = ( float )STBTT_sqrt( dist2 );
							}
							if( num >= 2 && res[ 1 ] >= 0.0f && res[ 1 ] <= 1.0f )
							{
								t = res[ 1 ], it = 1.0f - t;
								px = it * it * x0 + 2 * t * it * x1 + t * t * x2;
								py = it * it * y0 + 2 * t * it * y1 + t * t * y2;
								dist2 = ( px - sx ) * ( px - sx ) + ( py - sy ) * ( py - sy );
								if( dist2 < min_dist * min_dist )
									min_dist = ( float )STBTT_sqrt( dist2 );
							}
							if( num >= 3 && res[ 2 ] >= 0.0f && res[ 2 ] <= 1.0f )
							{
								t = res[ 2 ], it = 1.0f - t;
								px = it * it * x0 + 2 * t * it * x1 + t * t * x2;
								py = it * it * y0 + 2 * t * it * y1 + t * t * y2;
								dist2 = ( px - sx ) * ( px - sx ) + ( py - sy ) * ( py - sy );
								if( dist2 < min_dist * min_dist )
									min_dist = ( float )STBTT_sqrt( dist2 );
							}
						}
					}
				}
				if( winding == 0 )
					min_dist = -min_dist;  // if outside the shape, value is negative
				val = onedge_value + pixel_dist_scale * min_dist;
				if( val < 0 )
					val = 0;
				else if( val > 255 )
					val = 255;
				data[ ( y - iy0 ) * w + ( x - ix0 ) ] = ( unsigned char )val;
			}
		}
		STBTT_free( precompute, info->userdata );
		STBTT_free( verts, info->userdata );
	}
	return data;
}

STBTT_DEF unsigned char* stbtt_GetCodepointSDF( const stbtt_fontinfo* info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int* width, int* height, int* xoff, int* yoff )
{
	return stbtt_GetGlyphSDF( info, scale, stbtt_FindGlyphIndex( info, codepoint ), padding, onedge_value, pixel_dist_scale, width, height, xoff, yoff );
}

STBTT_DEF void stbtt_FreeSDF( unsigned char* bitmap, void* userdata )
{
	STBTT_free( bitmap, userdata );
}

//////////////////////////////////////////////////////////////////////////////
//
// font name matching -- recommended not to use this
//

// check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string
static stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix( stbtt_uint8* s1, stbtt_int32 len1, stbtt_uint8* s2, stbtt_int32 len2 )
{
	stbtt_int32 i = 0;

	// convert utf16 to utf8 and compare the results while converting
	while( len2 )
	{
		stbtt_uint16 ch = s2[ 0 ] * 256 + s2[ 1 ];
		if( ch < 0x80 )
		{
			if( i >= len1 ) return -1;
			if( s1[ i++ ] != ch ) return -1;
		}
		else if( ch < 0x800 )
		{
			if( i + 1 >= len1 ) return -1;
			if( s1[ i++ ] != 0xc0 + ( ch >> 6 ) ) return -1;
			if( s1[ i++ ] != 0x80 + ( ch & 0x3f ) ) return -1;
		}
		else if( ch >= 0xd800 && ch < 0xdc00 )
		{
			stbtt_uint32 c;
			stbtt_uint16 ch2 = s2[ 2 ] * 256 + s2[ 3 ];
			if( i + 3 >= len1 ) return -1;
			c = ( ( ch - 0xd800 ) << 10 ) + ( ch2 - 0xdc00 ) + 0x10000;
			if( s1[ i++ ] != 0xf0 + ( c >> 18 ) ) return -1;
			if( s1[ i++ ] != 0x80 + ( ( c >> 12 ) & 0x3f ) ) return -1;
			if( s1[ i++ ] != 0x80 + ( ( c >> 6 ) & 0x3f ) ) return -1;
			if( s1[ i++ ] != 0x80 + ( ( c ) & 0x3f ) ) return -1;
			s2 += 2; // plus another 2 below
			len2 -= 2;
		}
		else if( ch >= 0xdc00 && ch < 0xe000 )
		{
			return -1;
		}
		else
		{
			if( i + 2 >= len1 ) return -1;
			if( s1[ i++ ] != 0xe0 + ( ch >> 12 ) ) return -1;
			if( s1[ i++ ] != 0x80 + ( ( ch >> 6 ) & 0x3f ) ) return -1;
			if( s1[ i++ ] != 0x80 + ( ( ch ) & 0x3f ) ) return -1;
		}
		s2 += 2;
		len2 -= 2;
	}
	return i;
}

static int stbtt_CompareUTF8toUTF16_bigendian_internal( char* s1, int len1, char* s2, int len2 )
{
	return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix( ( stbtt_uint8* )s1, len1, ( stbtt_uint8* )s2, len2 );
}

// returns results in whatever encoding you request... but note that 2-byte encodings
// will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare
STBTT_DEF const char* stbtt_GetFontNameString( const stbtt_fontinfo* font, int* length, int platformID, int encodingID, int languageID, int nameID )
{
	stbtt_int32 i, count, stringOffset;
	stbtt_uint8* fc = font->data;
	stbtt_uint32 offset = font->fontstart;
	stbtt_uint32 nm = stbtt__find_table( fc, offset, "name" );
	if( !nm ) return NULL;

	count = ttUSHORT( fc + nm + 2 );
	stringOffset = nm + ttUSHORT( fc + nm + 4 );
	for( i = 0; i < count; ++i )
	{
		stbtt_uint32 loc = nm + 6 + 12 * i;
		if( platformID == ttUSHORT( fc + loc + 0 ) && encodingID == ttUSHORT( fc + loc + 2 )
				&& languageID == ttUSHORT( fc + loc + 4 ) && nameID == ttUSHORT( fc + loc + 6 ) )
		{
			*length = ttUSHORT( fc + loc + 8 );
			return ( const char* )( fc + stringOffset + ttUSHORT( fc + loc + 10 ) );
		}
	}
	return NULL;
}

static int stbtt__matchpair( stbtt_uint8* fc, stbtt_uint32 nm, stbtt_uint8* name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id )
{
	stbtt_int32 i;
	stbtt_int32 count = ttUSHORT( fc + nm + 2 );
	stbtt_int32 stringOffset = nm + ttUSHORT( fc + nm + 4 );

	for( i = 0; i < count; ++i )
	{
		stbtt_uint32 loc = nm + 6 + 12 * i;
		stbtt_int32 id = ttUSHORT( fc + loc + 6 );
		if( id == target_id )
		{
			// find the encoding
			stbtt_int32 platform = ttUSHORT( fc + loc + 0 ), encoding = ttUSHORT( fc + loc + 2 ), language = ttUSHORT( fc + loc + 4 );

			// is this a Unicode encoding?
			if( platform == 0 || ( platform == 3 && encoding == 1 ) || ( platform == 3 && encoding == 10 ) )
			{
				stbtt_int32 slen = ttUSHORT( fc + loc + 8 );
				stbtt_int32 off = ttUSHORT( fc + loc + 10 );

				// check if there's a prefix match
				stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix( name, nlen, fc + stringOffset + off, slen );
				if( matchlen >= 0 )
				{
					// check for target_id+1 immediately following, with same encoding & language
					if( i + 1 < count && ttUSHORT( fc + loc + 12 + 6 ) == next_id && ttUSHORT( fc + loc + 12 ) == platform && ttUSHORT( fc + loc + 12 + 2 ) == encoding && ttUSHORT( fc + loc + 12 + 4 ) == language )
					{
						slen = ttUSHORT( fc + loc + 12 + 8 );
						off = ttUSHORT( fc + loc + 12 + 10 );
						if( slen == 0 )
						{
							if( matchlen == nlen )
								return 1;
						}
						else if( matchlen < nlen && name[ matchlen ] == ' ' )
						{
							++matchlen;
							if( stbtt_CompareUTF8toUTF16_bigendian_internal( ( char* )( name + matchlen ), nlen - matchlen, ( char* )( fc + stringOffset + off ), slen ) )
								return 1;
						}
					}
					else
					{
						// if nothing immediately following
						if( matchlen == nlen )
							return 1;
					}
				}
			}

			// @TODO handle other encodings
		}
	}
	return 0;
}

static int stbtt__matches( stbtt_uint8* fc, stbtt_uint32 offset, stbtt_uint8* name, stbtt_int32 flags )
{
	stbtt_int32 nlen = ( stbtt_int32 )STBTT_strlen( ( char* )name );
	stbtt_uint32 nm, hd;
	if( !stbtt__isfont( fc + offset ) ) return 0;

	// check italics/bold/underline flags in macStyle...
	if( flags )
	{
		hd = stbtt__find_table( fc, offset, "head" );
		if( ( ttUSHORT( fc + hd + 44 ) & 7 ) != ( flags & 7 ) ) return 0;
	}

	nm = stbtt__find_table( fc, offset, "name" );
	if( !nm ) return 0;

	if( flags )
	{
		// if we checked the macStyle flags, then just check the family and ignore the subfamily
		if( stbtt__matchpair( fc, nm, name, nlen, 16, -1 ) )  return 1;
		if( stbtt__matchpair( fc, nm, name, nlen, 1, -1 ) )  return 1;
		if( stbtt__matchpair( fc, nm, name, nlen, 3, -1 ) )  return 1;
	}
	else
	{
		if( stbtt__matchpair( fc, nm, name, nlen, 16, 17 ) )  return 1;
		if( stbtt__matchpair( fc, nm, name, nlen, 1, 2 ) )  return 1;
		if( stbtt__matchpair( fc, nm, name, nlen, 3, -1 ) )  return 1;
	}

	return 0;
}

static int stbtt_FindMatchingFont_internal( unsigned char* font_collection, char* name_utf8, stbtt_int32 flags )
{
	stbtt_int32 i;
	for( i = 0;; ++i )
	{
		stbtt_int32 off = stbtt_GetFontOffsetForIndex( font_collection, i );
		if( off < 0 ) return off;
		if( stbtt__matches( ( stbtt_uint8* )font_collection, off, ( stbtt_uint8* )name_utf8, flags ) )
			return off;
	}
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

STBTT_DEF int stbtt_BakeFontBitmap( const unsigned char* data, int offset,
																		float pixel_height, unsigned char* pixels, int pw, int ph,
																		int first_char, int num_chars, stbtt_bakedchar* chardata )
{
	return stbtt_BakeFontBitmap_internal( ( unsigned char* )data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata );
}

STBTT_DEF int stbtt_GetFontOffsetForIndex( const unsigned char* data, int index )
{
	return stbtt_GetFontOffsetForIndex_internal( ( unsigned char* )data, index );
}

STBTT_DEF int stbtt_GetNumberOfFonts( const unsigned char* data )
{
	return stbtt_GetNumberOfFonts_internal( ( unsigned char* )data );
}

STBTT_DEF int stbtt_InitFont( stbtt_fontinfo* info, const unsigned char* data, int offset )
{
	return stbtt_InitFont_internal( info, ( unsigned char* )data, offset );
}

STBTT_DEF int stbtt_FindMatchingFont( const unsigned char* fontdata, const char* name, int flags )
{
	return stbtt_FindMatchingFont_internal( ( unsigned char* )fontdata, ( char* )name, flags );
}

STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian( const char* s1, int len1, const char* s2, int len2 )
{
	return stbtt_CompareUTF8toUTF16_bigendian_internal( ( char* )s1, len1, ( char* )s2, len2 );
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif // STB_TRUETYPE_IMPLEMENTATION


// FULL VERSION HISTORY
//
//   1.19 (2018-02-11) OpenType GPOS kerning (horizontal only), STBTT_fmod
//   1.18 (2018-01-29) add missing function
//   1.17 (2017-07-23) make more arguments const; doc fix
//   1.16 (2017-07-12) SDF support
//   1.15 (2017-03-03) make more arguments const
//   1.14 (2017-01-16) num-fonts-in-TTC function
//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) allow user-defined fabs() replacement
//                     fix memory leak if fontsize=0.0
//                     fix warning from duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     allow PackFontRanges to pack and render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//   1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine)
//                     also more precise AA rasterizer, except if shapes overlap
//                     remove need for STBTT_sort
//   1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC
//   1.04 (2015-04-15) typo in example
//   1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes
//   1.02 (2014-12-10) fix various warnings & compile issues w/ stb_rect_pack, C++
//   1.01 (2014-12-08) fix subpixel position when oversampling to exactly match
//                        non-oversampled; STBTT_POINT_SIZE for packed case only
//   1.00 (2014-12-06) add new PackBegin etc. API, w/ support for oversampling
//   0.99 (2014-09-18) fix multiple bugs with subpixel rendering (ryg)
//   0.9  (2014-08-07) support certain mac/iOS fonts without an MS platformID
//   0.8b (2014-07-07) fix a warning
//   0.8  (2014-05-25) fix a few more warnings
//   0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back
//   0.6c (2012-07-24) improve documentation
//   0.6b (2012-07-20) fix a few more warnings
//   0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels,
//                        stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty
//   0.5  (2011-12-09) bugfixes:
//                        subpixel glyph renderer computed wrong bounding box
//                        first vertex of shape can be off-curve (FreeSans)
//   0.4b (2011-12-03) fixed an error in the font baking example
//   0.4  (2011-12-01) kerning, subpixel rendering (tor)
//                    bugfixes for:
//                        codepoint-to-glyph conversion using table fmt=12
//                        codepoint-to-glyph conversion using table fmt=4
//                        stbtt_GetBakedQuad with non-square texture (Zer)
//                    updated Hello World! sample to use kerning and subpixel
//                    fixed some warnings
//   0.3  (2009-06-24) cmap fmt=12, compound shapes (MM)
//                    userdata, malloc-from-userdata, non-zero fill (stb)
//   0.2  (2009-03-11) Fix unsigned/signed char warnings
//   0.1  (2009-03-09) First public release
//

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/
```

`horizon/include/auto.hpp`:

```hpp
#pragma once

#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif // !_CRT_SECURE_NO_WARNINGS

#ifndef _NO_CRT_STDIO_INLINE
#define _NO_CRT_STDIO_INLINE
#endif // !_NO_CRT_STDIO_INLINE

#pragma warning( push )
#pragma warning( disable : 4530 )

#include <memory>
#include <chrono>
#include <thread>
#include <limits>
#include <string>
#include <vector>
#include <algorithm>

#pragma warning( pop )

#pragma warning( disable : 26812 )
```

`horizon/include/base.hpp`:

```hpp
#pragma once

#if defined( _M_IX86 )
	#define HORIZON_X86
#elif defined( _M_X64 )
	#define HORIZON_X64
#else
	#error "Not supported architecture!"
#endif // _M_IX86

#if defined( _DEBUG )
	#define HORIZON_DEBUG
#elif defined( NDEBUG )
	#define HORIZON_RELEASE
#else
	#error "Not supported configuration!"
#endif // _DEBUG

#define API_CDECL										__cdecl
#define API_STDCALL									__stdcall
#define API_THISCALL								__thiscall
#define API_FASTCALL								__fastcall
#define API_VECTORCALL							__vectorcall

#define API_NT											API_STDCALL
#define API_WIN32										API_STDCALL
#define API_D3D											API_STDCALL

#define JOIN_IMPL( A, B )						A ## B
#define JOIN( A, B )								JOIN_IMPL( A, B )

#define FIELD_PAD( Size )						std::uint8_t JOIN( __pad, __COUNTER__ )[ Size ] = { }

#define ATOM_THREAD									__declspec( thread )
#define ATOM_ALLOCATE( Section )		__declspec( allocate( Section ) )

#define FUNCTION										SECURE( __FUNCTION__ )
#define FN													SECURE( __FUNCTION__ )

#define ATOM_FUNCTION								SECURE( __FUNCTION__ )
```

`horizon/include/win32.hpp`:

```hpp
#pragma once

#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#ifndef _NO_CRT_STDIO_INLINE
#define _NO_CRT_STDIO_INLINE
#endif

#ifndef NOMINMAX
#define NOMINMAX
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <winternl.h>
#include <winioctl.h>

#pragma warning( push )
#pragma warning( disable : 4005 )
#include <ntstatus.h>

// #include <xnamath.h>

#include <d3d.h>
#include <d3d11.h>
#pragma warning( pop )
// #include <d3dx11.h>

#undef LOBYTE
#undef HIBYTE
#undef LOWORD
#undef HIWORD
#undef LODWORD
#undef HIDWORD

#undef BYTE1
#undef BYTE2
#undef WORD1
#undef WORD2

#define BYTE_ELEMENT( Data, Index )		( *( ( BYTE* )&( Data ) + Index ) )
#define WORD_ELEMENT( Data, Index )		( *( ( WORD* )&( Data ) + Index ) )
#define DWORD_ELEMENT( Data, Index )	( *( ( DWORD* )&( Data ) + Index ) )

#define LOBYTE( Data )					BYTE_ELEMENT( Data, 0 )
#define HIBYTE( Data )					BYTE_ELEMENT( Data, 1 )

#define LOWORD( Data )					WORD_ELEMENT( Data, 0 )
#define HIWORD( Data )					WORD_ELEMENT( Data, 1 )

#define LODWORD( Data )					DWORD_ELEMENT( Data, 0 )
#define HIDWORD( Data )					DWORD_ELEMENT( Data, 1 )

#define BYTE1( Data )					BYTE_ELEMENT( Data, 1 )
#define BYTE2( Data )					BYTE_ELEMENT( Data, 2 )

#define WORD1( Data )					WORD_ELEMENT( Data, 1 )
#define WORD2( Data )					WORD_ELEMENT( Data, 2 )

#define DWORD1( Data )					DWORD_ELEMENT( Data, 1 )
#define DWORD2( Data )					DWORD_ELEMENT( Data, 2 )

```

`horizon/memory/arg_stack.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

namespace horizon::memory
{

template< typename ReturnType, typename... ArgPack >
ReturnType ExecuteCall( const void* const code, ArgPack... arg_pack )
{
	const auto procedure = static_cast< ReturnType( * )( ArgPack... ) >( code );
	return procedure( arg_pack... );
}

template< std::size_t ArgCount, typename >
struct ArgStack
{
	template< typename T1, typename T2, typename T3, typename T4, typename... ArgPack >
	static std::uintptr_t SystemCall( const void* const code,
																		std::uint32_t system_number,
																		T1 arg1, T2 arg2, T3 arg3, T4 arg4,
																		ArgPack... arg_pack )
	{
		return ExecuteCall< std::uintptr_t >( code, arg1, arg2, arg3, arg4, system_number, nullptr, arg_pack... );
	}

	template< typename ReturnType, typename T1, typename T2, typename T3, typename T4, typename... ArgPack >
	static ReturnType Call( const void* const code,
													void* const arg_data,
													T1 arg1, T2 arg2, T3 arg3, T4 arg4,
													ArgPack... arg_pack )
	{
		return ExecuteCall< ReturnType >( code, arg1, arg2, arg3, arg4, arg_data, nullptr, arg_pack... );
	}
};

template< std::size_t ArgCount >
struct ArgStack< ArgCount, std::enable_if_t< ArgCount <= 4 > >
{
	template< typename T1 = void*, typename T2 = void*, typename T3 = void*, typename T4 = void* >
	static std::uintptr_t SystemCall( const void* const code,
																		std::uint32_t system_number,
																		T1 arg1 = { }, T2 arg2 = { }, T3 arg3 = { }, T4 arg4 = { } )
	{
		return ExecuteCall< std::uintptr_t >( code, arg1, arg2, arg3, arg4, system_number, nullptr );
	}

	template< typename ReturnType, typename T1 = void*, typename T2 = void*, typename T3 = void*, typename T4 = void* >
	static ReturnType Call( const void* const code,
													void* const arg_data,
													T1 arg1 = { }, T2 arg2 = { }, T3 arg3 = { }, T4 arg4 = { } )
	{
		return ExecuteCall< ReturnType >( code, arg1, arg2, arg3, arg4, arg_data, nullptr );
	}
};

} // namespace horizon::memory
```

`horizon/memory/detour_hook.cpp`:

```cpp
#include "detour_hook.hpp"

#include "../core/map_data.hpp"

#include "../win32/trace.hpp"
#include "../win32/image.hpp"
#include "../win32/process.hpp"

namespace horizon::memory
{

constexpr std::uint8_t jmp_code_x64[] =
{
	0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	// mov rax, imm64
	0xFF, 0xE0,																									// jmp rax
};

DetourHook::DetourHook( std::uint8_t* const destination, const std::uint8_t* const source, std::size_t size /*= 12*/ )
{
	if( !Create( destination, source, size ) )
	{
		TRACE( "%s: Create( 0x%016llX, 0x%016llX, 0x%016llX ) error!", FN, memory::ToAddress( destination ), memory::ToAddress( source ), size );
	}
}

DetourHook::~DetourHook()
{
	Destroy();
}

bool DetourHook::Create( std::uint8_t* const destination, const std::uint8_t* const source, std::size_t size /*= 12*/ )
{
	m_destination = destination;

	if( !memory::IsAddressValid( m_destination ) )
	{
		TRACE( "%s: m_destination is not valid!", FN );
		return false;
	}

	m_source = source;

	if( !memory::IsAddressValid( m_source ) )
	{
		TRACE( "%s: m_source is not valid!", FN );
		return false;
	}

	m_size = size;

	if( m_size < sizeof( jmp_code_x64 ) )
	{
		TRACE( "%s: m_size is not valid! (%llu)", FN, m_size );
		return false;
	}

	const auto process = win32::NtCurrentProcess();

	void* jmp_back_base = nullptr;
	auto jmp_back_size = m_size + sizeof( jmp_code_x64 );
	
	auto status = g_map_data.NtAllocateVirtualMemory( process, &jmp_back_base, 0, &jmp_back_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE );

	if( NT_SUCCESS( status ) )
	{
		m_jmp_back = static_cast< std::uint8_t* >( jmp_back_base );

		auto destination_base = static_cast< void* >( m_destination );
		auto destination_size = m_size;
		
		auto destination_protection = static_cast< std::uint32_t >( PAGE_NOACCESS );

		// 
		// make memory writeable
		// 
		status = g_map_data.NtProtectVirtualMemory( process, &destination_base, &destination_size, PAGE_EXECUTE_READWRITE, &destination_protection );

		if( NT_SUCCESS( status ) )
		{
			// save bytes
			std::memcpy( m_jmp_back, m_destination, m_size );

			// append jmp back code
			std::memcpy( m_jmp_back + m_size + 0, jmp_code_x64, sizeof( jmp_code_x64 ) );

			// set jmp back (rax) address
			std::memcpy( m_jmp_back + m_size + 2, &destination_base, sizeof( destination_base ) );

			void* jmp_hook_base = nullptr;
			auto jmp_hook_size = m_size;

			status = g_map_data.NtAllocateVirtualMemory( process, &jmp_hook_base, 0, &jmp_hook_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE );

			if( NT_SUCCESS( status ) )
			{
				m_jmp_hook = static_cast< std::uint8_t* >( jmp_hook_base );

				// make jmp hook code
				std::memcpy( m_jmp_hook + 0, jmp_code_x64, sizeof( jmp_code_x64 ) );

				// set jmp hook (rax) address
				std::memcpy( m_jmp_hook + 2, &m_source, sizeof( m_source ) );

				// is resize required
				if( m_size > sizeof( jmp_code_x64 ) )
				{
					// change spare bytes to 'nop'
					std::memset( m_jmp_hook + sizeof( jmp_code_x64 ), 0x90, m_size - sizeof( jmp_code_x64 ) );
				}

				// change destination bytes to jmp hook code
				std::memcpy( m_destination, m_jmp_hook, sizeof( jmp_code_x64 ) );

				// set internal state
				m_hooked = true;
				return true;
			}
			else
			{
				TRACE( "%s: win32::AllocateVirtualMemory( ... ) error!", FN );
			}
		}
		else
		{
			TRACE( "%s: win32::ProtectVirtualMemory( ... ) error!", FN );
		}
	}
	else
	{
		TRACE( "%s: win32::AllocateVirtualMemory( ... ) error!", FN );
	}

	return false;
}

void DetourHook::Destroy()
{
	if( m_hooked )
	{

	}
}

} // namespace horizon::memory
```

`horizon/memory/detour_hook.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "operation.hpp"

namespace horizon::memory
{

class DetourHook
{
public:
	using Shared = std::shared_ptr< DetourHook >;

public:
	DetourHook( std::uint8_t* const destination, const std::uint8_t* const source, std::size_t size = 12 );
	~DetourHook();

public:
	bool Create( std::uint8_t* const destination, const std::uint8_t* const source, std::size_t size = 12 );
	void Destroy();

public:
	template< typename Type, typename... ArgPack >
	inline Type Call( ArgPack... arg_pack )
	{
		using Fn = Type( API_STDCALL* )( ArgPack... );
		const auto procedure = reinterpret_cast< Fn >( m_hooked ? m_jmp_back : m_destination );

		if( !memory::IsAddressValid( procedure ) )
		{
			return std::invoke_result_t< Fn, ArgPack... >();
		}

		return procedure( arg_pack... );
	}

	inline std::uint8_t* GetDestination() const
	{
		return m_destination;
	}
	
	inline const std::uint8_t* GetSource() const
	{
		return m_source;
	}
	
	inline std::size_t GetSize() const
	{
		return m_size;
	}

	inline std::uint8_t* GetJmpBack() const
	{
		return m_jmp_back;
	}

	inline std::uint8_t* GetJmpHook() const
	{
		return m_jmp_hook;
	}

	inline bool IsHooked() const
	{
		return m_hooked;
	}

protected:
	std::uint8_t* m_destination = nullptr;
	const std::uint8_t* m_source = nullptr;
	std::size_t m_size = 0;

	std::uint8_t* m_jmp_back = nullptr;
	std::uint8_t* m_jmp_hook = nullptr;

	bool m_hooked = false;
};

} // namespace horizon::memory
```

`horizon/memory/macro.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#define PAGE_SIZE						( 4096 )

#define FIELD_PAD( Size )		std::uint8_t JOIN( __pad, __COUNTER__ )[ Size ] = { }
```

`horizon/memory/operation.cpp`:

```cpp
#include "operation.hpp"

namespace horizon::memory
{ } // namespace horizon::memory
```

`horizon/memory/operation.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#define PAGE_SIZE		( 4096 )

namespace horizon::memory
{

constexpr std::uintptr_t MinimumUserAddress = 0x0000000000010000;
constexpr std::uintptr_t MaximumUserAddress = 0x00007FFFFFFFFFFF;

constexpr std::uintptr_t MinimumSystemAddress = 0x8000000000000000;

inline std::uintptr_t ToAddress( const void* pointer )
{
	return reinterpret_cast< std::uintptr_t >( pointer );
}

inline void* ToPointer( std::uintptr_t address )
{
	return reinterpret_cast< void* >( address );
}

inline const void* ToConstantPointer( std::uintptr_t address )
{
	return reinterpret_cast< const void* >( address );
}

inline bool IsUserAddress( std::uintptr_t address )
{
	return ( address >= MinimumUserAddress &&
					 address <= MaximumUserAddress );
}

inline bool IsUserAddress( const void* pointer )
{
	const auto address = ToAddress( pointer );
	return IsUserAddress( address );
}

inline bool IsSystemAddress( std::uintptr_t address )
{
	return ( address >= MinimumSystemAddress );
}

inline bool IsSystemAddress( const void* pointer )
{
	const auto address = ToAddress( pointer );
	return IsSystemAddress( address );
}

inline bool IsAddressValid( std::uintptr_t address )
{
	return IsUserAddress( address );
}

inline bool IsAddressValid( const void* pointer )
{
	const auto address = ToAddress( pointer );
	return IsAddressValid( address );
}

template< typename Type, typename PointerType >
inline Type& Dereference( const PointerType address )
{
	return *( Type* )( address );
}

template< typename Type, typename PointerType >
inline Type Read( const PointerType address )
{
	return Dereference< Type, PointerType >( address );
}

template< typename Type, typename PointerType >
inline Type& Write( const PointerType address, const Type& data )
{
	return Dereference< Type, PointerType >( address ) = data;
}

template< std::size_t N, typename T = std::uintptr_t >
FORCEINLINE T GetVirtualAddress( void* object )
{
	if( !IsAddressValid( object ) )
		return { };

	const auto procedure_array = *reinterpret_cast< std::uintptr_t** >( object );

	if( !IsAddressValid( procedure_array ) )
		return { };

	return T( procedure_array[ N ] );
}

template< std::size_t N, typename T, typename... ArgPack >
FORCEINLINE T CallVirtual( void* object, ArgPack... arg_pack )
{
	using Fn = T( API_THISCALL* )( void*, ArgPack... );

	const auto procedure = GetVirtualAddress< N, Fn >( object );

	if( !procedure )
	{
		return std::invoke_result_t< Fn, void*, ArgPack... >();
	}

	return procedure( object, arg_pack... );
}

template< typename T, typename... ArgPack >
FORCEINLINE T Call( std::uintptr_t address, ArgPack... arg_pack )
{
	using Fn = T( * )( ArgPack... );
	const auto procedure = reinterpret_cast< Fn >( address );

	if( !IsAddressValid( procedure ) )
	{
		return std::invoke_result_t< Fn, ArgPack... >();
	}

	return procedure( arg_pack... );
}

template< typename Type >
inline void SafeDelete( Type& object )
{
	if( IsAddressValid( object ) )
	{
		delete object;
		object = nullptr;
	}
}

template< typename Type >
inline void SafeDeleteArray( Type& object )
{
	if( IsAddressValid( object ) )
	{
		delete[] object;
		object = nullptr;
	}
}

template< typename Type >
inline void SafeRelease( Type& object )
{
	if( IsAddressValid( object ) )
	{
		object->Release();
		object = nullptr;
	}
}

} // namespace horizon::memory
```

`horizon/memory/scan.cpp`:

```cpp
#include "scan.hpp"
#include "operation.hpp"

#include "../constant/hash.hpp"
#include "../constant/string.hpp"

#include "../win32/trace.hpp"
#include "../win32/image.hpp"

#define IN_RANGE( x, a, b )	( x >= a && x <= b )
#define GET_BITS( x )		( IN_RANGE( x, '0', '9' ) ? ( x - '0' ) : ( ( x & ( ~0x20 ) ) - 'A' + 0x0A ) )
#define GET_BYTE( x )		( GET_BITS( x[ 0 ] ) << 4 | GET_BITS( x[ 1 ] ) )

namespace horizon::memory
{

std::uintptr_t ScanRegionInternal( const std::uint8_t* region_begin, const std::uint8_t* region_end, const char* signature )
{
	if( !IsAddressValid( region_begin ) )
	{
		return 0;
	}
	
	if( !IsAddressValid( region_end ) )
	{
		return 0;
	}
	
	if( !IsAddressValid( signature ) )
	{
		return 0;
	}

	auto scan_result = static_cast< std::uintptr_t >( 0 );
	auto scan_compare = reinterpret_cast< const std::uint8_t* >( signature );

	const auto scan_begin = region_begin;
	const auto scan_end = region_end;

	for( auto scan_current = scan_begin; scan_current < scan_end; scan_current++ )
	{
		if( constant::IsTerminator( scan_compare[ 0 ] ) )
		{
			return scan_result;
		}

		if( IsAddressValid( const_cast< std::uint8_t* >( scan_current ) ) )
		{
			if( constant::IsQuestion( scan_compare[ 0 ] ) || scan_current[ 0 ] == GET_BYTE( scan_compare ) )
			{
				if( !memory::IsAddressValid( scan_result ) )
				{
					scan_result = ToAddress( scan_current );
				}

				if( constant::IsTerminator( scan_compare[ 2 ] ) )
				{
					return scan_result;
				}

				const bool question[ 2 ] =
				{
					constant::IsQuestion( scan_compare[ 0 ] ),
					constant::IsQuestion( scan_compare[ 1 ] ),
				};

				if( ( question[ 0 ] && question[ 1 ] ) || ( !question[ 0 ] ) )
				{
					scan_compare = ( scan_compare + 3 );
				}
				else
				{
					scan_compare = ( scan_compare + 2 );
				}
			}
			else
			{
				scan_compare = reinterpret_cast< const std::uint8_t* >( signature );
				scan_result = 0;
			}
		}
	}

	return 0;
}

std::uintptr_t ScanImageSectionInternal( std::uintptr_t image, const char* const name, const char* const signature )
{
	if( memory::IsAddressValid( name ) )
	{
		std::size_t section_size = 0;
		const auto section_begin = win32::GetImageSection< const std::uint8_t* >( image, name, &section_size );

		if( memory::IsAddressValid( section_begin ) )
		{
			const auto section_end = ( section_begin + section_size );
			return ScanRegionInternal( section_begin, section_end, signature );
		}
	}

	return 0;
}

std::uintptr_t ScanImageSectionInternal( std::uintptr_t image, std::uint64_t hash, const char* const signature )
{
	if( hash )
	{
		std::size_t section_size = 0;
		const auto section_begin = win32::GetImageSection< const std::uint8_t* >( image, hash, &section_size );

		if( memory::IsAddressValid( section_begin ) )
		{
			const auto section_end = ( section_begin + section_size );
			return ScanRegionInternal( section_begin, section_end, signature );
		}
	}

	return 0;
}

std::uintptr_t ScanImageInternal( std::uintptr_t image, const char* signature )
{
	const auto image_nt_headers = win32::GetImageNtHeaders( image );

	if( !IsAddressValid( image_nt_headers ) )
	{
		return 0;
	}

	const auto region_begin = reinterpret_cast< const std::uint8_t* >( image );
	const auto region_end = reinterpret_cast< const std::uint8_t* >( image + image_nt_headers->OptionalHeader.SizeOfImage );

	return ScanRegionInternal( region_begin, region_end, signature );
}

std::uintptr_t ScanSectionInternal( std::uint64_t name_hash, const char* signature )
{
	const auto image = win32::GetImage( nullptr );

	if( memory::IsAddressValid( image ) )
	{
		return ScanImageSectionInternal( image, name_hash, signature );
	}

	return 0;
}

std::uintptr_t ScanInternal( const char* signature )
{
	const auto image = win32::GetImage( nullptr );

	if( !IsAddressValid( image ) )
	{
		return 0;
	}

	return ScanImageInternal( image, signature );
}

std::uintptr_t GetAbsoluteAddressInternal( std::uintptr_t address, std::size_t opcode_count )
{
	if( !IsAddressValid( address ) )
	{
		return 0;
	}

	const auto disp = *reinterpret_cast< std::int32_t* >( address + opcode_count );

	if( disp == 0 )
	{
		return 0;
	}

	return ( address + opcode_count + disp + sizeof( disp ) );
}

}
```

`horizon/memory/scan.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

namespace horizon::memory
{

std::uintptr_t ScanRegionInternal( const std::uint8_t* region_begin, const std::uint8_t* region_end, const char* signature );
std::uintptr_t ScanImageSectionInternal( std::uintptr_t image, const char* const section_name, const char* const signature );
std::uintptr_t ScanImageSectionInternal( std::uintptr_t image, std::uint64_t section_name_hash, const char* const signature );
std::uintptr_t ScanImageInternal( std::uintptr_t image, const char* signature );
std::uintptr_t ScanSectionInternal( std::uint64_t name_hash, const char* signature );
std::uintptr_t ScanInternal( const char* signature );

std::uintptr_t GetAbsoluteAddressInternal( std::uintptr_t address, std::size_t opcode_count );

template< typename Type = std::uintptr_t >
FORCEINLINE Type ScanRegion( const std::uint8_t* region_begin, const std::uint8_t* region_end, const char* signature )
{
	return Type( ScanRegionInternal( region_begin, region_end, signature ) );
}

template< typename Type = std::uintptr_t >
FORCEINLINE Type ScanImageSection( std::uintptr_t image, const char* const section_name, const char* const signature )
{
	return Type( ScanImageSectionInternal( image, section_name, signature ) );
}

template< typename Type = std::uintptr_t >
FORCEINLINE Type ScanImageSection( std::uintptr_t image, std::uint64_t section_name_hash, const char* const signature )
{
	return Type( ScanImageSectionInternal( image, section_name_hash, signature ) );
}

template< typename Type = std::uintptr_t >
FORCEINLINE Type ScanImage( std::uintptr_t image, const char* signature )
{
	return Type( ScanImageInternal( image, signature ) );
}

template< typename Type = std::uintptr_t >
FORCEINLINE Type ScanSection( std::uint64_t name_hash, const char* const signature )
{
	return Type( ScanSectionInternal( name_hash, signature ) );
}

template< typename Type = std::uintptr_t >
FORCEINLINE Type Scan( const char* signature )
{
	return Type( ScanInternal( signature ) );
}

template< typename Type = std::uintptr_t >
FORCEINLINE Type GetAbsoluteAddress( std::uintptr_t address, std::size_t opcode_count )
{
	return Type( GetAbsoluteAddressInternal( address, opcode_count ) );
}

} // namespace horizon::memory
```

`horizon/memory/secure_call.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "../constant/character.hpp"
#include "../constant/hash.hpp"
#include "../constant/secure_string.hpp"
#include "../constant/string.hpp"

#include "../win32/image.hpp"

#include "arg_stack.hpp"
#include "operation.hpp"
#include "scan.hpp"

// FF 23				| jmp qword ptr [rbx]
// FF 26				| jmp qword ptr [rsi]
// FF 27				| jmp qword ptr [rdi]
// FF 65 00			| jmp qword ptr [rbp + 0]
// 41 FF 24 24	| jmp qword ptr [r12]
// 41 FF 65 00	| jmp qword ptr [r13 + 0]
// 41 FF 26			| jmp qword ptr [r14]
// 41 FF 27			| jmp qword ptr [r15]

namespace horizon::memory
{

extern "C"
{

	// 
	// secure call assembly code
	// 
	void* code_secure_call();

}; // extern "C"

struct ArgData
{
	ArgData( std::uintptr_t jmp, std::uintptr_t procedure )
		: m_jmp( jmp )
		, m_procedure( procedure )
		, m_register( 0 )
	{ }

	std::uintptr_t m_jmp = 0;				// address of jump gadget
	std::uintptr_t m_procedure = 0;	// address of function
	std::uintptr_t m_register = 0;	// value of gadget register
};

template< typename ReturnType, typename... ArgPack >
ReturnType SecureCall( std::uintptr_t gadget, std::uintptr_t procedure, ArgPack... arg_pack )
{
	ArgData arg_data( gadget, procedure );

	using ArgMap = ArgStack< sizeof...( ArgPack ), void >;
	return ArgMap::template Call< ReturnType >( &code_secure_call, &arg_data, arg_pack... );
}

template< typename ReturnType, typename... ArgPack >
ReturnType SecureCall( std::uintptr_t procedure, ArgPack... arg_pack )
{
	static std::uintptr_t gadget = 0;

	if( !memory::IsAddressValid( gadget ) )
	{
		const auto game_assembly = win32::GetImage( HASH( L"GameAssembly.dll" ) );

		if( memory::IsAddressValid( game_assembly ) )
		{
			gadget = memory::ScanImageSection( game_assembly, HASH( ".text" ), SECURE( "FF E7" ) );
		}
		else
		{
			gadget = memory::ScanSection( HASH( ".text" ), SECURE( "FF E7" ) );
		}
	}

	return SecureCall< ReturnType, ArgPack... >( gadget, procedure, arg_pack... );
}

template< std::size_t Index, typename ReturnType, typename... ArgPack >
ReturnType SecureCallVirtual( void* instance, ArgPack... arg_pack )
{
	const auto procedure_array = Dereference< std::uintptr_t* >( instance );
	return SecureCall< ReturnType >( procedure_array[ Index ], instance, arg_pack... );
}

template< typename Type, typename... ArgPack >
class WrapSecureCall
{
public:
	FORCEINLINE WrapSecureCall( std::uintptr_t address = 0 )
		: m_address( address )
	{ }

public:
	FORCEINLINE bool IsValid() const
	{
		return ( m_address != 0 );
	}

	FORCEINLINE std::uintptr_t Get() const
	{
		return m_address;
	}

	FORCEINLINE void Set( std::uintptr_t base )
	{
		m_address += base;
	}

public:
	FORCEINLINE Type operator()( ArgPack... arg_pack )
	{
		return SecureCall< Type >( m_address, arg_pack... );
	}

public:
	FORCEINLINE explicit operator std::uintptr_t() const
	{
		return m_address;
	}

protected:
	std::uintptr_t m_address = 0;		// 0x0000
};
// sizeof( WrapSecureCall ) = 0x0008

} // namespace horizon::memory
```

`horizon/memory/system_call.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "secure_call.hpp"

namespace horizon::memory
{

extern "C"
{

	void* code_system_call();

}; // extern "C"

constexpr std::uint32_t BadSystemNumber = std::numeric_limits< std::uint32_t >::max();

template< typename ReturnType, typename... ArgPack >
ReturnType SystemCall( std::uint32_t system_number, ArgPack... arg_pack )
{
	using ArgMap = ArgStack< sizeof...( ArgPack ), void >;
	const auto return_value = ArgMap::template SystemCall( &code_system_call, system_number, arg_pack... );
	return static_cast< ReturnType >( return_value );
}

template< typename Type, typename... ArgPack >
class WrapSystemCall
{
public:
	FORCEINLINE WrapSystemCall( std::uint32_t number = BadSystemNumber )
		: m_number( number )
	{ }

public:
	FORCEINLINE bool IsValid() const
	{
		return ( m_number != BadSystemNumber );
	}

	FORCEINLINE std::uint32_t GetNumber() const
	{
		return m_number;
	}

	FORCEINLINE void SetNumber( std::uint32_t number )
	{
		m_number = number;
	}

public:
	FORCEINLINE Type operator()( ArgPack... arg_pack ) const
	{
		return SystemCall< Type >( m_number, arg_pack... );
	}

protected:
	std::uint32_t m_number = BadSystemNumber;	// 0x0000
};
// sizeof( WrapSystemCall ) = 0x0004

} // namespace horizon::memory
```

`horizon/memory/vftable_hook.cpp`:

```cpp
#include "vftable_hook.hpp"

#include "../memory/operation.hpp"

#include "../win32/trace.hpp"
#include "../win32/image.hpp"
#include "../win32/process.hpp"

namespace horizon::memory
{

VFTableHook::VFTableHook( void* instance )
{
	if( !Create( instance ) )
	{
		TRACE( "%s: Create( 0x%016llX ) error!", FN, ToAddress( instance ) );
	}
}

VFTableHook::~VFTableHook()
{
	Destroy();
}

bool VFTableHook::Create( void* instance )
{
	Destroy();

	m_instance = reinterpret_cast< std::uintptr_t** >( instance );

	if( !IsAddressValid( m_instance ) )
		return false;

	m_restore = *m_instance;

	if( !IsAddressValid( m_restore ) )
		return false;

	while( IsAddressValid( m_restore[ m_size ] ) )
	{
		m_size++;
	}

	if( !m_size )
	{
		return false;
	}

	m_replace = new std::uintptr_t[ m_size ];
	std::memcpy( m_replace, m_restore, m_size * sizeof( std::uintptr_t ) );

	*m_instance = m_replace;
	
	return true;
}

void VFTableHook::Destroy()
{
	if( IsAddressValid( m_instance ) )
	{
		if( IsAddressValid( m_restore ) )
		{
			*m_instance = m_restore;
		}
	}

	SafeDeleteArray( m_replace );

	m_instance = nullptr;
	m_restore = nullptr;
	m_replace = nullptr;
	m_size = 0;
}

void* VFTableHook::GetInstance() const
{
	return m_instance;
}

void VFTableHook::Hook( void* procedure, std::size_t index )
{
	if( !m_replace || index >= m_size )
	{
		return;
	}

	m_replace[ index ] = reinterpret_cast< std::uintptr_t >( procedure );
}

void VFTableHook::Unhook( std::size_t index )
{
	if( !m_replace || index >= m_size )
	{
		return;
	}

	m_replace[ index ] = m_restore[ index ];
}

}
```

`horizon/memory/vftable_hook.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "secure_call.hpp"

namespace horizon::memory
{

class VFTableHook
{
public:
	using Unique = std::unique_ptr< VFTableHook >;
	using Shared = std::shared_ptr< VFTableHook >;

public:
	VFTableHook( void* instance );
	~VFTableHook();

public:
	bool Create( void* instance );
	void Destroy();

public:
	void* GetInstance() const;

public:
	void Hook( void* procedure, std::size_t index );
	void Unhook( std::size_t index );

public:
	template< std::size_t N, typename T = std::uintptr_t >
	T Get()
	{
		return T( m_restore[ N ] );
	}

	template< std::size_t N, typename T, typename... ArgPack >
	T Call( void* instance, ArgPack... arg_pack )
	{
		using Fn = T( __thiscall* )( void*, ArgPack... );

		const auto procedure = Get< N, Fn >();
		return procedure( instance, arg_pack... );
	}

	template< std::size_t Index, typename Type, typename... ArgPack >
	inline Type SecureCall( void* instance, ArgPack... arg_pack )
	{
		const auto procedure = Get< Index >();
		return memory::SecureCall< Type, void*, ArgPack... >( procedure, instance, arg_pack... );
	}

protected:
	std::uintptr_t** m_instance = nullptr;
	std::uintptr_t* m_restore = nullptr;
	std::uintptr_t* m_replace = nullptr;
	std::size_t m_size = 0;
};

}
```

`horizon/memory/x64/code_secure_call.asm`:

```asm
.DATA
	g_arg_data	dq 0

.CODE

	code_secure_call PROC PUBLIC
		pop r11									; store return address in r11
		add rsp, 8							; skip reserved stack space
		mov rax, [rsp + 24]			; store arg_data in rax
		mov r10, [rax]					; store arg_data.m_jmp in r10
		mov [rsp], r10					; store gadget as return address
		mov r10, [rax + 8]			; store arg_data.m_procedure in r10
		mov [rax + 8], r11			; store return address in arg_data.m_procedure
		mov [rax + 16], rdi			; store rdi in arg_data.m_register
		mov g_arg_data, rax			; store rax in g_arg_data
		lea rdi, quit						; store address of quit in rdi
		; mov [rax], rdi					; store quit in arg_data.m_jmp
		; mov rdi, rax						; store rax in rdi
		jmp r10									; jump to arg_data.m_procedure
	quit:
		sub rsp, 16							; 
		; mov rcx, rdi						; restore arg_data
		mov rcx, g_arg_data			; restore arg_data
		; mov rcx, [rsp + 24]			; restore arg_data
		mov rdi, [rcx + 16]			; restore rdi from arg_data.m_register
		jmp qword ptr [rcx + 8]	; jump to arg_data.m_procedure
	code_secure_call ENDP

END
```

`horizon/memory/x64/code_system_call.asm`:

```asm
.CODE

	code_system_call PROC PUBLIC
		mov r10, rcx							; 
		pop rcx										; 
		pop rax										; 
		mov qword ptr [rsp], rcx	; 
		mov eax, [rsp + 24]				; store system number in eax
		syscall										; execute system call instruction
		sub rsp, 08h							; 
		jmp qword ptr [rsp + 8]		; 
	code_system_call ENDP

END
```

`horizon/vcruntime/dll_dllmain.cpp`:

```cpp
#include "dll_dllmain.hpp"
#include "security_cookie.hpp"
#include "thread_safe_statics.hpp"
#include "initializers.hpp"

#include "../core/map_data.hpp"

#include "../win32/trace.hpp"
#include "../win32/image.hpp"
#include "../win32/process.hpp"

namespace horizon::vcruntime
{

bool DllMainCRTProcessAttach( void* instance, void* reserved )
{
	return true;
}

bool DllMainCRTProcessDetach( void* reserved )
{
	return true;
}

bool DllMainCRTDispatch( void* instance, std::uint32_t reason, void* reserved )
{
	switch( reason )
	{
		case DLL_PROCESS_ATTACH:
		{
			return DllMainCRTProcessAttach( instance, reserved );
		}
		case DLL_PROCESS_DETACH:
		{
			return DllMainCRTProcessDetach( reserved );
		}
	}

	return true;
}

int DllMainDispatch( void* instance, std::uint32_t reason, void* reserved )
{
	return DllMain( instance, reason, reserved );
}

bool InitializeMapData( core::MapData* map_data )
{
	if( memory::IsAddressValid( map_data ) )
	{
		if( map_data->IsValid() )
		{
			if( map_data->Create() )
			{
				std::memcpy( &g_map_data, map_data, sizeof( core::MapData ) );
				return true;
			}
		}
	}

	return false;
}

void UninitializeMapData()
{
	std::memset( &g_map_data, 0, sizeof( g_map_data ) );
}

bool InitializeExceptionSupport( std::uintptr_t image )
{
	const auto image_data_directory = win32::GetImageDataDirectory( image, win32::ImageDirectoryEntryException );

	if( memory::IsAddressValid( image_data_directory ) )
	{
		const auto function_table = reinterpret_cast< win32::IMAGE_RUNTIME_FUNCTION_ENTRY* >( image + image_data_directory->VirtualAddress );
		const auto entry_count = static_cast< std::uint32_t >( image_data_directory->Size / sizeof( win32::IMAGE_RUNTIME_FUNCTION_ENTRY ) );

		if( g_map_data.RtlAddFunctionTable( function_table, entry_count, image ) )
		{
			return true;
		}
		else
		{
			TRACE( "%s: RtlAddFunctionTable( '0x%016llX', '0x%08X', '0x%016llX' ) error!", FN, memory::ToAddress( function_table ), entry_count, image );
		}
	}
	else
	{
		TRACE( "%s: win32::GetImageDataDirectory( '0x%016llX', '0x%02X' ) error!", FN, image, win32::ImageDirectoryEntryException );
	}

	return false;
}

void UninitializeExceptionSupport()
{
	const auto image = g_map_data.m_base;
	const auto image_data_directory = win32::GetImageDataDirectory( image, win32::ImageDirectoryEntryException );

	if( memory::IsAddressValid( image_data_directory ) )
	{
		const auto function_table = reinterpret_cast< win32::IMAGE_RUNTIME_FUNCTION_ENTRY* >( image + image_data_directory->VirtualAddress );
		const auto entry_count = static_cast< std::uint32_t >( image_data_directory->Size / sizeof( win32::IMAGE_RUNTIME_FUNCTION_ENTRY ) );

		if( !g_map_data.RtlDeleteFunctionTable( function_table ) )
		{
			TRACE( "%s: RtlDeleteFunctionTable( '0x%016llX' ) error!", FN, memory::ToAddress( function_table ) );
		}
	}
	else
	{
		TRACE( "%s: win32::GetImageDataDirectory( '0x%016llX', '0x%02X' ) error!", FN, image, win32::ImageDirectoryEntryException );
	}
}

bool InitializeRuntimeData()
{
	__try
	{
		g_security_cookie = new SecurityCookie();
		g_thread_safe_statics = new ThreadSafeStatics();

		if( memory::IsAddressValid( g_security_cookie ) &&
				memory::IsAddressValid( g_thread_safe_statics ) )
		{
			return ( g_security_cookie->Initialize() &&
							 g_thread_safe_statics->Initialize() );
		}
		else
		{
			TRACE( "%s: Runtime data allocation error!", FN );
		}
	}
	__except( EXCEPTION_EXECUTE_HANDLER )
	{
		TRACE( "%s: Exception occured = '0x%08X'!", FN, GetExceptionCode() );
	}

	return false;
}

void UninitializeRuntimeData()
{
	__try
	{
		if( memory::IsAddressValid( g_thread_safe_statics ) )
		{
			g_thread_safe_statics->Uninitialize();
		}

		if( memory::IsAddressValid( g_security_cookie ) )
		{
			g_security_cookie->Uninitialize();
		}

		memory::SafeDelete( g_thread_safe_statics );
		memory::SafeDelete( g_security_cookie );
	}
	__except( EXCEPTION_EXECUTE_HANDLER )
	{
		TRACE( "%s: Exception occured = '0x%08X'!", FN, GetExceptionCode() );
	}
}

bool InitializeImageInstance( void* instance, void* reserved )
{
	const auto map_data = static_cast< core::MapData* >( reserved );

	if( InitializeMapData( map_data ) )
	{
		win32::LARGE_INTEGER time = { };
		win32::RtlQueryPerformanceCounter( &time );

		// g_map_data.OutputDebugStringA( SECURE( "win32::RtlQueryPerformanceCounter()" ) );

		// char output[ 1024 ] = { };
		// win32::sprintf_s( output, ARRAYSIZE( output ), SECURE( "[horizon] time.QuadPart = '%lld'" ), time.QuadPart );
		// g_map_data.OutputDebugStringA( output );

		// TRACE( "time.QuadPart = '%lld'", time.QuadPart );
		// TRACE( "g_map_data.m_time.QuadPart = '%lld'", g_map_data.m_time.QuadPart );

		const auto code = crt_init();

		if( code == 0 )
		{
			const auto image = memory::ToAddress( instance );

			if( InitializeExceptionSupport( image ) )
			{
				if( InitializeRuntimeData() )
				{
					return true;
				}
				else
				{
					TRACE( "%s: InitializeRuntimeData() error!", ATOM_FUNCTION );
				}
			}
			else
			{
				TRACE( "%s: InitializeExceptionSupport( '0x%016llX' ) error!", ATOM_FUNCTION, image );
			}
		}
	}

	return false;
}

void UninitializeImageInstance( void* reserved )
{
	atom::vcruntime::ExecuteTerminators();

	UninitializeRuntimeData();
	UninitializeExceptionSupport();
	UninitializeMapData();
}

} // namespace horizon::vcruntime

extern "C"
{

	BOOL API_STDCALL _CRT_INIT( void* instance, unsigned long reason, void* reserved )
	{
		return horizon::vcruntime::DllMainDispatch( instance, reason, reserved );
	}

	BOOL API_STDCALL _DllMainCRTStartup( void* instance, unsigned long reason, void* reserved )
	{
		if( reason == DLL_PROCESS_ATTACH )
		{
			horizon::vcruntime::InitializeImageInstance( instance, reserved );
		}

		const auto result = horizon::vcruntime::DllMainDispatch( instance, reason, reserved );

		if( reason == DLL_PROCESS_DETACH )
		{
			horizon::vcruntime::UninitializeImageInstance( reserved );
		}

		return result;
	}

} // extern "C"
```

`horizon/vcruntime/dll_dllmain.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

namespace horizon::vcruntime
{

bool DllMainCRTProcessAttach( void* instance, void* reserved );
bool DllMainCRTProcessDetach( void* reserved );

bool DllMainCRTDispatch( void* instance, std::uint32_t reason, void* reserved );

}

extern "C"
{
	
	BOOL API_WIN32 DllMain( void* instance, unsigned long reason, void* reserved );

	BOOL API_WIN32 _CRT_INIT( void* instance, unsigned long reason, void* reserved );
	BOOL API_WIN32 _DllMainCRTStartup( void* instance, unsigned long reason, void* reserved );

}; // extern "C"
```

`horizon/vcruntime/initializers.cpp`:

```cpp
#include "initializers.hpp"
#include "internal_shared.hpp"

#include "../memory/operation.hpp"
#include "../win32/trace.hpp"
#include "../win32/process.hpp"

#pragma comment( linker, "/merge:.CRT=.rdata" )

using namespace horizon;

// 
// Initializer and Terminator Support
// 
using PVFV = void( * )();
using PIFV = int( * )();
using PVFI = void( * )( int );

namespace atom::vcruntime
{

extern "C" ATOM_COMMIT( ".CRT$XIA" ) PIFV __xi_a[] = { nullptr };	// C initializers (first)
extern "C" ATOM_COMMIT( ".CRT$XIZ" ) PIFV __xi_z[] = { nullptr };	// C initializers (last)

extern "C" ATOM_COMMIT( ".CRT$XCA" ) PVFV __xc_a[] = { nullptr };	// C++ initializers (first)
extern "C" ATOM_COMMIT( ".CRT$XCZ" ) PVFV __xc_z[] = { nullptr };	// C++ initializers (last)

extern "C" ATOM_COMMIT( ".CRT$XPA" ) PVFV __xp_a[] = { nullptr };	// C pre-terminators (first)
extern "C" ATOM_COMMIT( ".CRT$XPZ" ) PVFV __xp_z[] = { nullptr };	// C pre-terminators (last)

extern "C" ATOM_COMMIT( ".CRT$XTA" ) PVFV __xt_a[] = { nullptr };	// C terminators (first)
extern "C" ATOM_COMMIT( ".CRT$XTZ" ) PVFV __xt_z[] = { nullptr };	// C terminators (last)

} // namespace atom::vcruntime

constexpr auto MaximumTerminatorCount = 512;

PVFV g_on_exit_array[ MaximumTerminatorCount ] = { };

PVFV* g_on_exit_begin = nullptr;
PVFV* g_on_exit_end = nullptr;

namespace atom::vcruntime
{

Initializers::~Initializers()
{
	Destroy();
}

bool Initializers::Create()
{
	m_end = m_begin = m_array;
	*m_begin = nullptr;

	int code = ExecuteConstructorArray( __xi_a, __xi_z );

	if( code )
	{
		TRACE( "%s: ExecuteConstructorArray(...) error!", ATOM_FUNCTION );
		return false;
	}

	ExecuteConstructorArray( __xc_a, __xc_z );
	return true;
}

void Initializers::Destroy()
{
	if( m_end )
	{
		while( m_end-- >= m_begin )
		{
			if( *m_end )
			{
				( *m_end )();
			}
		}
	}

	ExecuteConstructorArray( __xp_a, __xp_z );
	ExecuteConstructorArray( __xt_a, __xt_z );
}

int Initializers::ExecuteConstructorArray( PIFV* begin, PIFV* end )
{
	auto constructor = begin;

	while( constructor != end )
	{
		if( *constructor )
		{
			int code = ( *constructor )();
			
			if( code )
			{
				return code;
			}
		}

		constructor++;
	}

	return 0;
}

void Initializers::ExecuteConstructorArray( PVFV* begin, PVFV* end )
{
	auto constructor = begin;

	while( constructor != end )
	{
		if( *constructor )
		{
			( *constructor )();
		}

		constructor++;
	}
}

void init_on_exit_array()
{
	g_on_exit_begin = g_on_exit_array;
	g_on_exit_end = g_on_exit_array;

	( *g_on_exit_begin ) = nullptr;
}

int execute_pifv_array( PIFV* begin, PIFV* end )
{
	auto procedure = begin;

	while( procedure != end )
	{
		if( *procedure )
		{
			int code = ( *procedure )();
			TRACE( "pifv @ 0x%016llX returned %d", memory::ToAddress( *procedure ), code );

			if( code )
			{
				return code;
			}
		}

		procedure++;
	}

	return 0;
}

void execute_pvfv_array( PVFV* begin, PVFV* end )
{
	auto procedure = begin;

	while( procedure != end )
	{
		if( *procedure )
		{
			( *procedure )();
			TRACE( "pvfv @ 0x%016llX", memory::ToAddress( *procedure ) );
		}

		procedure++;
	}
}

int ExecuteArray( PIFV* begin, PIFV* end )
{
	auto procedure = begin;

	while( procedure != end )
	{
		if( *procedure )
		{
			const auto code = ( **procedure )();
			TRACE( "%s: 'PIFV' @ '0x%016llX' returned '%d'", ATOM_FUNCTION, memory::ToAddress( *procedure ), code );

			if( code )
			{
				return code;
			}
		}

		procedure++;
	}

	return 0;
}

void ExecuteArray( PVFV* begin, PVFV* end )
{
	auto procedure = begin;

	while( procedure != end )
	{
		if( *procedure )
		{
			( **procedure )();
			TRACE( "%s: 'procedure' @ '0x%016llX'", ATOM_FUNCTION, memory::ToAddress( *procedure ) );
		}

		procedure++;
	}
}

int ExecuteInitializers()
{
	g_on_exit_begin = g_on_exit_array;
	g_on_exit_end = g_on_exit_array;

	( *g_on_exit_begin ) = nullptr;

	// 
	// try execute C constructors
	// 
	const auto code = ExecuteArray( __xi_a, __xi_z );

	if( code )
	{
		return code;
	}

	// 
	// execute C++ constructors
	// 
	ExecuteArray( __xc_a, __xc_z );
	return 0;
}

void ExecuteTerminators()
{
	if( memory::IsAddressValid( g_on_exit_begin ) )
	{
		// 
		// execute 'atexit' terminators
		// 
		for( auto procedure = g_on_exit_end; procedure >= g_on_exit_begin; procedure-- )
		{
			if( *procedure )
			{
				( **procedure )();
			}
		}
	}

	// 
	// execute C pre-terminators & terminators
	// 
	ExecuteArray( __xp_a, __xp_z );
	ExecuteArray( __xt_a, __xt_z );
}

} // namespace atom::vcruntime

int crt_init()
{
	atom::vcruntime::init_on_exit_array();
	int code = atom::vcruntime::execute_pifv_array( atom::vcruntime::__xi_a, atom::vcruntime::__xi_z );
	if( code )
	{
		return code;
	}
	atom::vcruntime::execute_pvfv_array( atom::vcruntime::__xc_a, atom::vcruntime::__xc_z );
	return 0;
}

void crt_uninit()
{
	if( g_on_exit_begin )
	{
		for( auto fn = g_on_exit_end; fn >= g_on_exit_begin; fn-- )
		{
			if( *fn )
			{
				( **fn )();
			}
		}
	}
	atom::vcruntime::execute_pvfv_array( atom::vcruntime::__xp_a, atom::vcruntime::__xp_z );
	atom::vcruntime::execute_pvfv_array( atom::vcruntime::__xt_a, atom::vcruntime::__xt_z );
}

extern "C"
{

	int atexit( PVFV procedure )
	{
		// 
		// is 'g_on_exit_array' overflow
		// 
		if( g_on_exit_end > &g_on_exit_array[ MaximumTerminatorCount - 1 ] )
		{
			TRACE( "%s: 'g_on_exit_array' overflow!", ATOM_FUNCTION );
			return 1;
		}

		// 
		// emplace procedure at the end of array
		// 
		( *g_on_exit_end ) = procedure;
		TRACE( "%s: 'procedure' @ '0x%016llX'", ATOM_FUNCTION, memory::ToAddress( procedure ) );

		// 
		// increment end pointer
		// 
		g_on_exit_end++;
		return 0;
	}

}; // extern "C"
```

`horizon/vcruntime/initializers.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "../core/singleton.hpp"

using PIFV = int( * )();
using PVFV = void( * )();

namespace atom::vcruntime
{

class Initializers : public horizon::core::Singleton< Initializers >
{
public:
	~Initializers();

public:
	bool Create();
	void Destroy();

protected:
	int ExecuteConstructorArray( PIFV* begin, PIFV* end );
	void ExecuteConstructorArray( PVFV* begin, PVFV* end );

protected:
	PVFV m_array[ 64 ] = { };
	
	PVFV* m_begin = nullptr;
	PVFV* m_end = nullptr;
};

void init_on_exit_array();

int execute_pifv_array( PIFV* begin, PIFV* end );
void execute_pvfv_array( PVFV* begin, PVFV* end );

int ExecuteInitializers();
void ExecuteTerminators();

} // namespace atom::vcruntime

int crt_init();
void crt_uninit();
```

`horizon/vcruntime/internal_shared.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

extern "C" {

	namespace atom::vcruntime
	{

	#pragma section( ".CRT$XCA", long, read )				// First C++ Initializer
	#pragma section( ".CRT$XCZ", long, read )				// Last C++ Initializer
	#pragma section( ".CRT$XDA", long, read )				// First Dynamic TLS Initializer
	#pragma section( ".CRT$XDZ", long, read )				// Last Dynamic TLS Initializer
	#pragma section( ".CRT$XIA", long, read )				// First C Initializer
	#pragma section( ".CRT$XIZ", long, read )				// Last C Initializer
	#pragma section( ".CRT$XLA", long, read )				// First Loader TLS Callback
	#pragma section( ".CRT$XLZ", long, read )				// Last Loader TLS Callback
	#pragma section( ".CRT$XPA", long, read )				// First Pre-Terminator
	#pragma section( ".CRT$XPZ", long, read )				// Last Pre-Terminator
	#pragma section( ".CRT$XTA", long, read )				// First Terminator
	#pragma section( ".CRT$XTZ", long, read )				// Last Terminator
	#pragma section( ".rdata$T", long, read )
	#pragma section( ".rtc$IAA", long, read )				// First RTC Initializer
	#pragma section( ".rtc$IZZ", long, read )				// Last RTC Initializer
	#pragma section( ".rtc$TAA", long, read )				// First RTC Terminator
	#pragma section( ".rtc$TZZ", long, read )				// Last RTC Terminator

	#define ATOM_COMMIT( name )											__declspec( allocate( name ) )

	using PVFV = void( * )( );
	using PIFV = int( * )( );

	extern ATOM_COMMIT( ".CRT$XIA" ) PIFV __xi_a[];	// First C Initializer
	extern ATOM_COMMIT( ".CRT$XIZ" ) PIFV __xi_z[];	// Last C Initializer
	extern ATOM_COMMIT( ".CRT$XCA" ) PVFV __xc_a[];	// First C++ Initializer
	extern ATOM_COMMIT( ".CRT$XCZ" ) PVFV __xc_z[];	// Last C++ Initializer
	extern ATOM_COMMIT( ".CRT$XPA" ) PVFV __xp_a[];	// First Pre-Terminator
	extern ATOM_COMMIT( ".CRT$XPZ" ) PVFV __xp_z[];	// Last Pre-Terminator
	extern ATOM_COMMIT( ".CRT$XTA" ) PVFV __xt_a[];	// First Terminator
	extern ATOM_COMMIT( ".CRT$XTZ" ) PVFV __xt_z[];	// Last Terminator


	} // namespace atom::vcruntime

}; // extern "C"
```

`horizon/vcruntime/memory.cpp`:

```cpp
#include "memory.hpp"

#pragma function( memchr )
const void* memchr( const void* destination, int value, std::size_t size )
{
	auto data = static_cast< const std::uint8_t* >( destination );

	for( std::size_t index = 0; index < size; index++ )
	{
		if( data[ index ] == static_cast< const std::uint8_t >( value ) )
		{
			return static_cast< const void* >( data );
		}
	}

	return nullptr;
}

#pragma function( memcmp )
int memcmp( const void* source, const void* destination, std::size_t size )
{
	auto data_source = static_cast< const std::uint8_t* >( source );
	auto data_destination = static_cast< const std::uint8_t* >( destination );

	for( std::size_t index = 0; index < size; index++ )
	{
		if( data_source[ index ] != data_destination[ index ] )
		{
			return ( data_source[ index ] - data_destination[ index ] );
		}
	}

	return 0;
}

#pragma function( memcpy )
void* memcpy( void* destination, const void* source, std::size_t size )
{
	auto data_source = static_cast< const std::uint8_t* >( source );
	auto data_destination = static_cast< std::uint8_t* >( destination );

	__movsb( data_destination, data_source, size );
	return static_cast< void* >( data_destination );
}

#pragma function( memmove )
void* memmove( void* destination, const void* source, std::size_t size )
{
	auto data_source = static_cast< const std::uint8_t* >( source );
	auto data_destination = static_cast< std::uint8_t* >( destination );

	__movsb( data_destination, data_source, size );
	return static_cast< void* >( data_destination );
}

#pragma function( memset )
void* memset( void* destination, int value, std::size_t size )
{
	auto data = static_cast< std::uint8_t* >( destination );

	__stosb( data, static_cast< std::uint8_t >( value ), size );
	return static_cast< void* >( data );
}
```

`horizon/vcruntime/memory.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

namespace horizon::vcruntime
{ } // namespace horizon::vcruntime

const void* memchr( const void* data, int value, std::size_t size );
int memcmp( const void* source, const void* destination, std::size_t size );
void* memcpy( void* destination, const void* source, std::size_t size );
void* memmove( void* destination, const void* source, std::size_t size );
void* memset( void* destination, int value, std::size_t size );
```

`horizon/vcruntime/operator.cpp`:

```cpp
#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "../win32/trace.hpp"
#include "../win32/image.hpp"
#include "../win32/process.hpp"

using namespace horizon;

#pragma warning( push )
#pragma warning( disable : 28251 )

void* operator new( std::size_t size )
{
	const auto process_heap = win32::GetProcessHeap();
	return win32::RtlAllocateHeap( process_heap, 0, size );
}

void* operator new[]( std::size_t size )
{
	const auto process_heap = win32::GetProcessHeap();
	return win32::RtlAllocateHeap( process_heap, 0, size );
}

void operator delete( void* data ) noexcept
{
	const auto process_heap = win32::GetProcessHeap();
	win32::RtlFreeHeap( process_heap, 0, data );
}

void operator delete( void* data, std::size_t size ) noexcept
{
	const auto process_heap = win32::GetProcessHeap();
	win32::RtlFreeHeap( process_heap, 0, data );
}

void operator delete[]( void* data ) noexcept
{
	const auto process_heap = win32::GetProcessHeap();
	win32::RtlFreeHeap( process_heap, 0, data );
}

void operator delete[]( void* data, std::size_t size ) noexcept
{
	const auto process_heap = win32::GetProcessHeap();
	win32::RtlFreeHeap( process_heap, 0, data );
}

#pragma warning( pop )
```

`horizon/vcruntime/security_cookie.cpp`:

```cpp
#include "security_cookie.hpp"

#include "../core/map_data.hpp"

#include "../win32/trace.hpp"
#include "../win32/process.hpp"
#include "../win32/time.hpp"

using namespace horizon;

#if defined( HORIZON_X86 )
	#define DEFAULT_SECURITY_COOKIE		( static_cast< std::uintptr_t >( 0xBB40E64E ) )
#elif defined( HORIZON_X64 )
	#define DEFAULT_SECURITY_COOKIE		( static_cast< std::uintptr_t >( 0x00002B992DDFA232 ) )
#endif // HORIZON_X86

vcruntime::SecurityCookie* g_security_cookie = nullptr;

extern "C"
{
	std::uintptr_t __security_cookie = DEFAULT_SECURITY_COOKIE;
	std::uintptr_t __security_cookie_complement = ~DEFAULT_SECURITY_COOKIE;
}; // extern "C"

union FT
{
	std::uint64_t value = 0;
	FILETIME data;
};
// sizeof( FT ) = 0x0008

namespace horizon::vcruntime
{

// 
// [ SecurityCookie ] implementation
// 
SecurityCookie::SecurityCookie() noexcept
	: m_cookie( nullptr )
	, m_cookie_complement( nullptr )
{ }

bool SecurityCookie::Initialize() noexcept
{
	m_cookie = std::addressof( __security_cookie );

	if( !m_cookie )
	{
		TRACE( "%s: m_cookie is nullptr!", ATOM_FUNCTION );
		return false;
	}

	m_cookie_complement = std::addressof( __security_cookie_complement );

	if( !m_cookie_complement )
	{
		TRACE( "%s: m_cookie_complement is nullptr!", ATOM_FUNCTION );
		return false;
	}

	SetCookie( DEFAULT_SECURITY_COOKIE );
	SetCookieComplement( ~DEFAULT_SECURITY_COOKIE );

	auto cookie = GetCookie();

	if( ( cookie != DEFAULT_SECURITY_COOKIE )
#if defined( HORIZON_X86 )
		&& ( cookie & 0xFFFF0000 ) != 0
#endif
		)
	{
		SetCookieComplement( ~cookie );
		return true;
	}

	cookie = ComputeCookie();

	if( cookie == DEFAULT_SECURITY_COOKIE )
	{
		cookie = DEFAULT_SECURITY_COOKIE + 1;
	}
#if defined( HORIZON_X86 )
	else if( ( cookie & 0xFFFF0000 ) == 0 )
	{
		cookie |= ( ( cookie | 0x4711 ) << 16 );
	}
#endif // HORIZON_X86

	SetCookie( cookie );
	SetCookieComplement( ~cookie );

	return true;
}

void SecurityCookie::SetCookie( std::uintptr_t cookie ) noexcept
{
	*m_cookie = cookie;
}

void SecurityCookie::SetCookieComplement( std::uintptr_t cookie_complement ) noexcept
{
	*m_cookie_complement = cookie_complement;
}

std::uintptr_t SecurityCookie::GetCookie() const noexcept
{
	return *m_cookie;
}

std::uintptr_t SecurityCookie::GetCookieComplement() const noexcept
{
	return *m_cookie_complement;
}

void SecurityCookie::Uninitialize() noexcept
{ }

std::uintptr_t SecurityCookie::ComputeCookie() const noexcept
{
	FT system_time = { };
	win32::GetSystemTimeAsFileTime( &system_time.data );

#if defined( HORIZON_X86 )
	auto cookie = system_time.data.dwLowDateTime;
	cookie ^= system_time.data.dwHighDateTime;
#elif defined( HORIZON_X64 )
	auto cookie = system_time.value;
#endif // HORIZON_X86

	cookie ^= win32::NtCurrentProcessId();
	cookie ^= win32::NtCurrentThreadId();

#if defined( HORIZON_X86 )
	cookie ^= static_cast< std::uintptr_t >( win32::GetTickCount64() );
#elif defined( HORIZON_X64 )
	cookie ^= win32::GetTickCount64() << 56;
	cookie ^= win32::GetTickCount64();
#endif // HORIZON_X86

	win32::LARGE_INTEGER performance_counter = { };

	if( !g_map_data.RtlQueryPerformanceCounter( &performance_counter ) )
	{
		TRACE( "%s: win32::QueryPerformanceCounter( ... ) error! (0x%08X)", ATOM_FUNCTION, win32::GetLastError() );
	}

#if defined( HORIZON_X86 )
	cookie ^= performance_counter.LowPart;
	cookie ^= static_cast< std::uintptr_t >( performance_counter.HighPart );
#elif defined( HORIZON_X64 )
	cookie ^= ( ( static_cast< std::uintptr_t >( performance_counter.LowPart ) << 32 ) ^ static_cast< std::uintptr_t >( performance_counter.HighPart ) );
	cookie &= 0xFFFFFFFFFFFF;
#endif // HORIZON_X86

	return cookie;
}

}

#pragma warning( push )
#pragma warning( disable : 28251 )

extern "C"
{

	void __security_check_cookie( std::uintptr_t )
	{ }

	void __chkstk()
	{ }

	void __GSHandlerCheck()
	{ }

}; // extern "C"

#pragma warning( pop )
```

`horizon/vcruntime/security_cookie.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

namespace horizon::vcruntime
{

// 
// [ class ]
// 
class SecurityCookie;

// 
// [ class ] implementation
// 
class SecurityCookie
{
public:
	SecurityCookie() noexcept;

public:
	bool Initialize() noexcept;
	void Uninitialize() noexcept;

public:
	void SetCookie( std::uintptr_t cookie ) noexcept;
	void SetCookieComplement( std::uintptr_t cookie_complement ) noexcept;

	std::uintptr_t GetCookie() const noexcept;
	std::uintptr_t GetCookieComplement() const noexcept;

protected:
	std::uintptr_t ComputeCookie() const noexcept;

protected:
	std::uintptr_t* m_cookie = nullptr;
	std::uintptr_t* m_cookie_complement = nullptr;
};

}

extern horizon::vcruntime::SecurityCookie* g_security_cookie;
```

`horizon/vcruntime/thread_local_storage.cpp`:

```cpp
#include "thread_local_storage.hpp"

#include "../memory/operation.hpp"

#include "../win32/image.hpp"
#include "../win32/process.hpp"

extern "C"
{

	std::uint32_t _tls_index = 0;

}; // extern "C"

namespace horizon::vcruntime
{ } // namespace horizon::vcruntime

extern "C"
{

	void __dyn_tls_init( void*, unsigned long reason, void* ) noexcept
	{ }

}; // extern "C"
```

`horizon/vcruntime/thread_local_storage.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

namespace horizon::vcruntime
{

class ThreadLocalStorage
{
public:
	ThreadLocalStorage();

public:
	bool Create();
	void Destroy();

protected:

};

} // namespace horizon::vcruntime
```

`horizon/vcruntime/thread_safe_statics.cpp`:

```cpp
#include "thread_safe_statics.hpp"

#include "../memory/operation.hpp"

#include "../win32/trace.hpp"

using namespace horizon;

vcruntime::ThreadSafeStatics* g_thread_safe_statics = nullptr;

extern "C"
{

	std::int32_t _Init_global_epoch = std::numeric_limits< std::int32_t >::min();
	ATOM_THREAD std::int32_t _Init_thread_epoch = std::numeric_limits< std::int32_t >::min();

}; // extern "C"

namespace horizon::vcruntime
{

namespace constant
{
constexpr auto BeingInitialized = static_cast< std::int32_t >( -1 );
constexpr auto Uninitialized = static_cast< std::int32_t >( 0 );
}

ThreadSafeStatics::ThreadSafeStatics() noexcept
	: m_epoch( nullptr )
	, m_epoch_thread( nullptr )
	, m_mutex( 4000 )
	, m_condition_variable()
{ }

bool ThreadSafeStatics::Initialize() noexcept
{
	m_epoch = std::addressof( _Init_global_epoch );

	if( !memory::IsAddressValid( m_epoch ) )
	{
		TRACE( "%s: m_epoch is not valid!", ATOM_FUNCTION );
		return false;
	}

	m_epoch_thread = std::addressof( _Init_thread_epoch );
	
	if( !memory::IsAddressValid( m_epoch_thread ) )
	{
		TRACE( "%s: m_epoch_thread is not valid!", ATOM_FUNCTION );
		return false;
	}

	SetEpoch( std::numeric_limits< std::int32_t >::min() );
	SetEpochThread( std::numeric_limits< std::int32_t >::min() );
	return true;
}

void ThreadSafeStatics::Uninitialize() noexcept
{ }

void ThreadSafeStatics::OnThreadHeader( std::int32_t& initializer ) noexcept
{
	core::ScopedLock lock( m_mutex );

	if( initializer == constant::Uninitialized )
	{
		initializer = constant::BeingInitialized;
	}
	else
	{
		while( initializer == constant::BeingInitialized )
		{
			m_condition_variable.wait_for( m_mutex, 100 );

			if( initializer == constant::Uninitialized )
			{
				initializer = constant::BeingInitialized;
				return;
			}
		}

		UpdateThread();
	}
}

void ThreadSafeStatics::OnThreadAbort( std::int32_t& initializer ) noexcept
{
	// guard
	{
		core::ScopedLock lock( m_mutex );
		initializer = constant::Uninitialized;
	}

	m_condition_variable.notify();
}

void ThreadSafeStatics::OnThreadFooter( std::int32_t& initializer ) noexcept
{
	// guard
	{
		core::ScopedLock lock( m_mutex );

		Update();
		initializer = GetEpoch();
		UpdateThread();
	}

	m_condition_variable.notify();
}

void ThreadSafeStatics::Update() noexcept
{
	const auto epoch = GetEpoch();
	SetEpoch( epoch + 1 );
}

void ThreadSafeStatics::UpdateThread() noexcept
{
	const auto epoch = GetEpoch();
	SetEpochThread( epoch );
}

void ThreadSafeStatics::SetEpoch( std::int32_t epoch ) noexcept
{
	*m_epoch = epoch;
}

void ThreadSafeStatics::SetEpochThread( std::int32_t epoch_thread ) noexcept
{
	*m_epoch_thread = epoch_thread;
}

std::int32_t ThreadSafeStatics::GetEpoch() const noexcept
{
	return *m_epoch;
}

std::int32_t ThreadSafeStatics::GetEpochThread() const noexcept
{
	return *m_epoch_thread;
}

} // namespace horizon::vcruntime

extern "C"
{

	void _Init_thread_header( std::int32_t* const parameter ) noexcept
	{
		if( !memory::IsAddressValid( parameter ) )
		{
			return;
		}

		if( !memory::IsAddressValid( g_thread_safe_statics ) )
		{
			return;
		}

		g_thread_safe_statics->OnThreadHeader( *parameter );
	}

	void _Init_thread_abort( std::int32_t* const parameter ) noexcept
	{
		if( !memory::IsAddressValid( parameter ) )
		{
			return;
		}

		if( !memory::IsAddressValid( g_thread_safe_statics ) )
		{
			return;
		}

		g_thread_safe_statics->OnThreadAbort( *parameter );
	}

	void _Init_thread_footer( std::int32_t* const parameter ) noexcept
	{
		if( !memory::IsAddressValid( parameter ) )
		{
			return;
		}

		if( !memory::IsAddressValid( g_thread_safe_statics ) )
		{
			return;
		}

		g_thread_safe_statics->OnThreadFooter( *parameter );
	}

}; // extern "C"
```

`horizon/vcruntime/thread_safe_statics.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "../core/mutex.hpp"

namespace horizon::vcruntime
{

// 
// [ class ]
// 
class ThreadSafeStatics;

// 
// [ class ] implementation
// 
class ThreadSafeStatics
{
public:
	ThreadSafeStatics() noexcept;

public:
	bool Initialize() noexcept;
	void Uninitialize() noexcept;

public:
	void OnThreadHeader( std::int32_t& parameter ) noexcept;
	void OnThreadAbort( std::int32_t& parameter ) noexcept;
	void OnThreadFooter( std::int32_t& parameter ) noexcept;

protected:
	void Update() noexcept;
	void UpdateThread() noexcept;

protected:
	void SetEpoch( std::int32_t epoch ) noexcept;
	void SetEpochThread( std::int32_t epoch_thread ) noexcept;

	std::int32_t GetEpoch() const noexcept;
	std::int32_t GetEpochThread() const noexcept;

protected:
	std::int32_t* m_epoch = nullptr;
	std::int32_t* m_epoch_thread = nullptr;

	core::Mutex m_mutex = { 4000 };
	core::ConditionVariable m_condition_variable = { };
};

}

extern horizon::vcruntime::ThreadSafeStatics* g_thread_safe_statics;
```

`horizon/win32/basic.cpp`:

```cpp
#include "basic.hpp"
#include "process.hpp"
#include "trace.hpp"

#include "../constant/character.hpp"
#include "../constant/hash.hpp"
#include "../constant/secure_string.hpp"
#include "../constant/string.hpp"

#include "../core/map_data.hpp"

#include "../memory/operation.hpp"

#include "sdk/list_entry.hpp"
#include "sdk/large_integer.hpp"
#include "sdk/rtl_critical_section.hpp"
#include "sdk/rtl_critical_section_debug.hpp"

namespace horizon::win32
{

constexpr std::uint32_t UserSharedData32 = 0x7FFE0000;
constexpr std::uint64_t UserSharedData64 = 0x000000007FFE0000;

#if defined( HORIZON_X32 )
constexpr std::uintptr_t UserSharedData = UserSharedData32;
#elif defined( HORIZON_X64 )
constexpr std::uintptr_t UserSharedData = UserSharedData64;
#endif // HORIZON_X32

KUSER_SHARED_DATA* GetUserSharedData()
{
	const auto user_shared_data = memory::ToPointer( UserSharedData );
	return static_cast< KUSER_SHARED_DATA* >( user_shared_data );
}

void InitializeString( STRING* destination, const char* const source )
{
	if( memory::IsAddressValid( destination ) )
	{
		if( memory::IsAddressValid( source ) )
		{
			const auto length = constant::GetLength( source );

			destination->Length = static_cast< std::uint16_t >( length * sizeof( char ) );
			destination->MaximumLength = destination->Length + sizeof( char );
		}
		else
		{
			destination->Length = 0;
			destination->MaximumLength = 0;
		}

		destination->Buffer = const_cast< char* >( source );
	}
}

void InitializeAnsiString( ANSI_STRING* destination, const char* const source )
{
	if( memory::IsAddressValid( destination ) )
	{
		if( memory::IsAddressValid( source ) )
		{
			const auto length = constant::GetLength( source );

			destination->Length = static_cast< std::uint16_t >( length * sizeof( char ) );
			destination->MaximumLength = destination->Length + sizeof( char );
		}
		else
		{
			destination->Length = 0;
			destination->MaximumLength = 0;
		}

		destination->Buffer = const_cast< char* >( source );
	}
}

void InitializeUnicodeString( UNICODE_STRING* destination, const wchar_t* const source )
{
	if( memory::IsAddressValid( destination ) )
	{
		if( memory::IsAddressValid( source ) )
		{
			const auto length = constant::GetLength( source );

			destination->Length = static_cast< std::uint16_t >( length * sizeof( wchar_t ) );
			destination->MaximumLength = destination->Length + sizeof( wchar_t );
		}
		else
		{
			destination->Length = 0;
			destination->MaximumLength = 0;
		}

		destination->Buffer = const_cast< wchar_t* >( source );
	}
}

void InitializeObjectAttributes( OBJECT_ATTRIBUTES* object_attributes, UNICODE_STRING* object_name /*= nullptr*/, std::uint32_t attributes /*= 0*/, void* security_descriptor /*= nullptr*/, void* security_quality_of_service /*= nullptr*/ )
{
	if( memory::IsAddressValid( object_attributes ) )
	{
		object_attributes->Length = sizeof( OBJECT_ATTRIBUTES );
		object_attributes->RootDirectory = nullptr;
		object_attributes->ObjectName = object_name;
		object_attributes->Attributes = attributes;
		object_attributes->SecurityDescriptor = security_descriptor;
		object_attributes->SecurityQualityOfService = security_quality_of_service;
	}
}

bool RtlAddFunctionTable( IMAGE_RUNTIME_FUNCTION_ENTRY* image_runtime_function_entry, std::uint32_t count, std::uintptr_t image )
{
	return g_map_data.RtlAddFunctionTable( image_runtime_function_entry, count, image );
}

bool RtlDeleteFunctionTable( IMAGE_RUNTIME_FUNCTION_ENTRY* image_runtime_function_entry )
{
	return g_map_data.RtlDeleteFunctionTable( image_runtime_function_entry );
}

bool RtlQueryPerformanceCounter( LARGE_INTEGER* counter )
{
	return g_map_data.RtlQueryPerformanceCounter( counter );
}

bool RtlQueryPerformanceFrequency( LARGE_INTEGER* frequency )
{
	return g_map_data.RtlQueryPerformanceFrequency( frequency );
}

bool RtlInitializeCriticalSection( RTL_CRITICAL_SECTION* section )
{
	return NT_SUCCESS( g_map_data.RtlInitializeCriticalSection( section ) );
}

bool RtlInitializeCriticalSectionEx( RTL_CRITICAL_SECTION* section, std::int32_t spin_count, std::uint32_t flags )
{
	return NT_SUCCESS( g_map_data.RtlInitializeCriticalSectionEx( section, spin_count, flags ) );
}

bool RtlEnterCriticalSection( RTL_CRITICAL_SECTION* section )
{
	return NT_SUCCESS( g_map_data.RtlEnterCriticalSection( section ) );
}

bool RtlTryEnterCriticalSection( RTL_CRITICAL_SECTION* section )
{
	return g_map_data.RtlTryEnterCriticalSection( section );
}

bool RtlLeaveCriticalSection( RTL_CRITICAL_SECTION* section )
{
	return NT_SUCCESS( g_map_data.RtlLeaveCriticalSection( section ) );
}

bool RtlDeleteCriticalSection( RTL_CRITICAL_SECTION* section )
{
	return NT_SUCCESS( g_map_data.RtlDeleteCriticalSection( section ) );
}

void RtlInitializeConditionVariable( RTL_CONDITION_VARIABLE* cv )
{
	return g_map_data.RtlInitializeConditionVariable( cv );
}

bool RtlSleepConditionVariableCS( RTL_CONDITION_VARIABLE* cv, RTL_CRITICAL_SECTION* section, LARGE_INTEGER* time )
{
	return NT_SUCCESS( g_map_data.RtlSleepConditionVariableCS( cv, section, time ) );
}

void RtlWakeConditionVariable( RTL_CONDITION_VARIABLE* cv )
{
	return g_map_data.RtlWakeConditionVariable( cv );
}

void RtlWakeAllConditionVariable( RTL_CONDITION_VARIABLE* cv )
{
	return g_map_data.RtlWakeAllConditionVariable( cv );
}

} // namespace horizon::win32
```

`horizon/win32/basic.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "sdk/kuser_shared_data.hpp"

#include "sdk/image_runtime_function_entry.hpp"

#include "sdk/object_attributes.hpp"

#include "sdk/rtl_critical_section.hpp"
#include "sdk/rtl_condition_variable.hpp"

#include "sdk/string.hpp"
#include "sdk/unicode_string.hpp"

#include "sdk/large_integer.hpp"

#if defined( InitializeObjectAttributes )
#undef InitializeObjectAttributes
#endif // InitializeObjectAttributes

namespace horizon::win32
{

KUSER_SHARED_DATA* GetUserSharedData();

void InitializeString( STRING* destination, const char* const source );
void InitializeAnsiString( ANSI_STRING* destination, const char* const source );
void InitializeUnicodeString( UNICODE_STRING* destination, const wchar_t* const source );

void InitializeObjectAttributes( OBJECT_ATTRIBUTES* object_attributes, UNICODE_STRING* object_name = nullptr, std::uint32_t attributes = 0, void* security_descriptor = nullptr, void* security_quality_of_service = nullptr );

bool RtlAddFunctionTable( IMAGE_RUNTIME_FUNCTION_ENTRY* image_runtime_function_entry, std::uint32_t count, std::uintptr_t image );
bool RtlDeleteFunctionTable( IMAGE_RUNTIME_FUNCTION_ENTRY* image_runtime_function_entry );

bool RtlQueryPerformanceCounter( LARGE_INTEGER* counter );
bool RtlQueryPerformanceFrequency( LARGE_INTEGER* frequency );

bool RtlInitializeCriticalSection( RTL_CRITICAL_SECTION* section );
bool RtlInitializeCriticalSectionEx( RTL_CRITICAL_SECTION* section, std::int32_t spin_count, std::uint32_t flags );
bool RtlEnterCriticalSection( RTL_CRITICAL_SECTION* section );
bool RtlTryEnterCriticalSection( RTL_CRITICAL_SECTION* section );
bool RtlLeaveCriticalSection( RTL_CRITICAL_SECTION* section );
bool RtlDeleteCriticalSection( RTL_CRITICAL_SECTION* section );

void RtlInitializeConditionVariable( RTL_CONDITION_VARIABLE* cv );
bool RtlSleepConditionVariableCS( RTL_CONDITION_VARIABLE* cv, RTL_CRITICAL_SECTION* section, LARGE_INTEGER* time );
void RtlWakeConditionVariable( RTL_CONDITION_VARIABLE* cv );
void RtlWakeAllConditionVariable( RTL_CONDITION_VARIABLE* cv );

} // namespace horizon::win32
```

`horizon/win32/core_types.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "sdk/access_mask.hpp"

#include "sdk/event_type.hpp"

#include "sdk/file_basic_information.hpp"
#include "sdk/file_id_both_dir_information.hpp"
#include "sdk/file_information_class.hpp"
#include "sdk/file_standard_information.hpp"

#include "sdk/image_base_relocation.hpp"
#include "sdk/image_data_directory.hpp"
#include "sdk/image_dos_header.hpp"
#include "sdk/image_export_directory.hpp"
#include "sdk/image_file_header.hpp"
#include "sdk/image_import_by_name.hpp"
#include "sdk/image_import_descriptor.hpp"
#include "sdk/image_nt_headers.hpp"
#include "sdk/image_optional_header.hpp"
#include "sdk/image_relocation.hpp"
#include "sdk/image_runtime_function_entry.hpp"
#include "sdk/image_section_header.hpp"
#include "sdk/image_thunk_data.hpp"

#include "sdk/io_apc_routine.hpp"
#include "sdk/io_status_block.hpp"

#include "sdk/object_attributes.hpp"
#include "sdk/object_information_class.hpp"
#include "sdk/object_wait_type.hpp"

#include "sdk/memory_information_class.hpp"

#include "sdk/large_integer.hpp"
#include "sdk/ularge_integer.hpp"

#include "sdk/rtl_critical_section.hpp"
#include "sdk/rtl_condition_variable.hpp"

namespace horizon::win32
{

// 
// exception routines
// 
using RtlAddFunctionTableType = bool( API_STDCALL* )( IMAGE_RUNTIME_FUNCTION_ENTRY* FunctionTable, std::uint32_t EntryCount, std::uintptr_t BaseAddress );
using RtlDeleteFunctionTableType = bool( API_STDCALL* )( IMAGE_RUNTIME_FUNCTION_ENTRY* FunctionTable );

// 
// heap routines
// 
using RtlAllocateHeapType = void*( API_STDCALL* )( void* HeapHandle, std::uint32_t Flags, std::size_t Size );
using RtlFreeHeapType = bool( API_STDCALL* )( void* HeapHandle, std::uint32_t Flags, void* BaseAddress );

// 
// performance routines
// 
using RtlQueryPerformanceCounterType = bool( API_STDCALL* )( LARGE_INTEGER* PerformanceCounter );
using RtlQueryPerformanceFrequencyType = bool( API_STDCALL* )( LARGE_INTEGER* PerformanceFrequency );

// 
// critical section routines
// 
using RtlInitializeCriticalSectionType = NTSTATUS( API_STDCALL* )( RTL_CRITICAL_SECTION* CriticalSection );
using RtlInitializeCriticalSectionExType = NTSTATUS( API_STDCALL* )( RTL_CRITICAL_SECTION* CriticalSection, std::uint32_t SpinCount, std::uint32_t Flags );
using RtlEnterCriticalSectionType = NTSTATUS( API_STDCALL* )( RTL_CRITICAL_SECTION* CriticalSection );
using RtlTryEnterCriticalSectionType = bool( API_STDCALL* )( RTL_CRITICAL_SECTION* CriticalSection );
using RtlLeaveCriticalSectionType = NTSTATUS( API_STDCALL* )( RTL_CRITICAL_SECTION* CriticalSection );
using RtlDeleteCriticalSectionType = NTSTATUS( API_STDCALL* )( RTL_CRITICAL_SECTION* CriticalSection );

// 
// condition variable routines
// 
using RtlInitializeConditionVariableType = void( API_STDCALL* )( RTL_CONDITION_VARIABLE* ConditionVariable );
using RtlSleepConditionVariableCSType = NTSTATUS( API_STDCALL* )( RTL_CONDITION_VARIABLE* ConditionVariable, RTL_CRITICAL_SECTION* CriticalSection, LARGE_INTEGER* TimeOut );
using RtlWakeConditionVariableType = void( API_STDCALL* )( RTL_CONDITION_VARIABLE* ConditionVariable );
using RtlWakeAllConditionVariableType = void( API_STDCALL* )( RTL_CONDITION_VARIABLE* ConditionVariable );

// 
// object routines
// 
using NtCloseType = NTSTATUS( API_STDCALL* )( HANDLE ObjectHandle );
using NtDuplicateObjectType = NTSTATUS( API_STDCALL* )( HANDLE SourceProcessHandle, HANDLE* SourceHandle, HANDLE TargetProcessHandle, HANDLE* TargetHandle, ACCESS_MASK DesiredAccess, bool InheritHandle, std::uint32_t Options );
using NtMakeTemporaryObjectType = NTSTATUS( API_STDCALL* )( HANDLE ObjectHandle );
using NtQueryObjectType = NTSTATUS( API_STDCALL* )( HANDLE ObjectHandle, OBJECT_INFORMATION_CLASS ObjectInformationClass, void* ObjectInformation, std::uint32_t ObjectInformationLength, std::uint32_t* ReturnLength );
using NtSetInformationObjectType = NTSTATUS( API_STDCALL* )( HANDLE ObjectHandle, OBJECT_INFORMATION_CLASS ObjectInformationClass, void* ObjectInformation, std::uint32_t ObjectInformationLength );
using NtSignalAndWaitForSingleObjectType = NTSTATUS( API_STDCALL* )( HANDLE ObjectToSignal, HANDLE WaitableObject, bool Alertable, LARGE_INTEGER* TimeOut );
using NtWaitForMultipleObjectsType = NTSTATUS( API_STDCALL* )( std::uint32_t ObjectCount, HANDLE* ObjectsArray, OBJECT_WAIT_TYPE WaitType, bool Alertable, LARGE_INTEGER* TimeOut );
using NtWaitForSingleObjectType = NTSTATUS( API_STDCALL* )( HANDLE ObjectHandle, bool Alertable, LARGE_INTEGER* TimeOut );



} // namespace horizon::win32
```

`horizon/win32/file.cpp`:

```cpp
#include "file.hpp"
#include "basic.hpp"
#include "trace.hpp"

#include "sdk/unicode_string.hpp"
#include "sdk/io_status_block.hpp"

#include "../core/map_data.hpp"

namespace horizon::win32
{

NtFile::NtFile()
	: m_object( nullptr )
{ }

NtFile::~NtFile()
{
	Close();
}

bool NtFile::IsOpen() const
{
	return ( m_object && m_object != INVALID_HANDLE_VALUE );
}

bool NtFile::IsDirectory() const
{
	IO_STATUS_BLOCK io_status_block = { };
	FILE_STANDARD_INFORMATION information = { };

	const auto status = g_map_data.NtQueryInformationFile( m_object, &io_status_block, &information, sizeof( information ), FileStandardInformation );

	if( !NT_SUCCESS( status ) )
	{
		TRACE( "%s: NtQueryInformationFile( ... ) error! (0x%08X)", ATOM_FUNCTION, status );
		return false;
	}

	return ( information.Directory != FALSE );
}

void NtFile::Close()
{
	if( IsOpen() )
	{
		const auto status = g_map_data.NtClose( m_object );

		if( !NT_SUCCESS( status ) )
		{
			TRACE( "%s: NtClose( ... ) error! (0x%08X)", ATOM_FUNCTION, status );
		}
	}

	m_object = nullptr;
}

bool NtFile::OpenInternal( const std::wstring& path, bool create_if_not_existing, std::uint32_t desired_access, std::uint32_t create_options )
{
	constexpr auto share_access = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;

	desired_access |= SYNCHRONIZE;
	create_options |= FILE_SYNCHRONOUS_IO_NONALERT;

	const auto create_disposition = ( create_if_not_existing ? FILE_OPEN_IF : FILE_OPEN );

	UNICODE_STRING object_name = { };
	InitializeUnicodeString( &object_name, path.c_str() );

	OBJECT_ATTRIBUTES object_attributes = { };
	InitializeObjectAttributes( &object_attributes, &object_name, OBJ_CASE_INSENSITIVE );

	IO_STATUS_BLOCK io_status_block = { };

	const auto status = g_map_data.NtCreateFile( &m_object, desired_access, &object_attributes, &io_status_block, nullptr, FILE_ATTRIBUTE_NORMAL,
																							 share_access, create_disposition, create_options, nullptr, 0 );

	if( !NT_SUCCESS( status ) )
	{
		TRACE( "%s: NtCreateFile( ... ) error! (0x%08X)", ATOM_FUNCTION, status );
		return false;
	}

	return true;
}

Directory::Directory( const std::wstring& path, bool create_if_not_existing /*= false*/, std::uint32_t desired_access /*= FILE_READ_DATA*/ )
	: NtFile()
{
	if( !Open( path, create_if_not_existing, desired_access ) )
	{
		TRACE( "%s: Open( ... ) error!", ATOM_FUNCTION );
	}
}

bool Directory::Open( const std::wstring& path, bool create_if_not_existing /*= false*/, std::uint32_t desired_access /*= FILE_READ_DATA*/ )
{
	return OpenInternal( path, create_if_not_existing, desired_access, FILE_DIRECTORY_FILE );
}

bool Directory::Query( FILE_DIRECTORY_INFORMATION* information, bool restart /*= false*/ )
{
	IO_STATUS_BLOCK io_status_block = { };

	std::memset( information, 0, sizeof( FILE_DIRECTORY_INFORMATION ) );

	const auto status = g_map_data.NtQueryDirectoryFile( m_object, nullptr, nullptr, nullptr, &io_status_block,
																											 information, sizeof( FILE_DIRECTORY_INFORMATION ),
																											 FileDirectoryInformation, TRUE, nullptr, restart ? TRUE : FALSE );

	if( !NT_SUCCESS( status ) )
	{
		if( status != STATUS_NO_MORE_FILES )
		{
			TRACE( "%s: NtQueryDirectoryFile( ... ) error! (0x%08X)", ATOM_FUNCTION, status );
		}

		return false;
	}

	return true;
}

File::File( const std::wstring& path, bool create_if_not_existing /*= false*/, std::uint32_t desired_access /*= FILE_READ_DATA*/ )
	: NtFile()
{
	if( !Open( path, create_if_not_existing, desired_access ) )
	{
		TRACE( "%s: Open( ... ) error!", ATOM_FUNCTION );
	}
}

bool File::Open( const std::wstring& path, bool create_if_not_existing /*= false*/, std::uint32_t desired_access /*= FILE_READ_DATA*/ )
{
	return OpenInternal( path, create_if_not_existing, desired_access, FILE_NON_DIRECTORY_FILE );
}

bool File::Read( void* data, std::size_t size_to_read, std::size_t* size_read /*= nullptr*/ )
{
	IO_STATUS_BLOCK io_status_block = { };

	const auto status = g_map_data.NtReadFile( m_object, nullptr, nullptr, nullptr, &io_status_block,
																						 data, static_cast< std::uint32_t >( size_to_read ), nullptr, nullptr );

	if( !NT_SUCCESS( status ) )
	{
		TRACE( "%s: NtReadFile( ... ) error! (0x%08X)", ATOM_FUNCTION, status );
		return false;
	}

	if( size_read )
	{
		( *size_read ) = io_status_block.Information;
	}

	return true;
}

bool File::Write( const void* const data, std::size_t size_to_write, std::size_t* size_written /*= nullptr*/ )
{
	IO_STATUS_BLOCK io_status_block = { };

	const auto status = g_map_data.NtWriteFile( m_object, nullptr, nullptr, nullptr, &io_status_block,
																							const_cast< void* >( data ), static_cast< std::uint32_t >( size_to_write ), nullptr, nullptr );

	if( !NT_SUCCESS( status ) )
	{
		TRACE( "%s: NtWriteFile( ... ) error! (0x%08X)", ATOM_FUNCTION, status );
		return false;
	}

	if( size_written )
	{
		( *size_written ) = io_status_block.Information;
	}

	return true;
}

std::size_t File::GetSize() const
{
	IO_STATUS_BLOCK io_status_block = { };
	FILE_STANDARD_INFO information = { };

	const auto status = g_map_data.NtQueryInformationFile( m_object, &io_status_block, &information, sizeof( information ), FileStandardInformation );

	if( !NT_SUCCESS( status ) )
	{
		TRACE( "%s: NtQueryInformationFile( ... ) error! (0x%08X)", ATOM_FUNCTION, status );
		return 0;
	}

	return static_cast< std::size_t >( information.EndOfFile.QuadPart );
}

} // namespace horizon::win32
```

`horizon/win32/file.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "sdk/handle.hpp"
#include "sdk/file_information_class.hpp"
#include "sdk/file_standard_information.hpp"
#include "sdk/file_directory_information.hpp"

namespace horizon::win32
{

class NtFile
{
public:
	NtFile();

public:
	~NtFile();

public:
	bool IsOpen() const;
	bool IsDirectory() const;

	void Close();

protected:
	bool OpenInternal( const std::wstring& path, bool create_if_not_existing, std::uint32_t desired_access, std::uint32_t create_options );

protected:
	HANDLE m_object = nullptr;
};

class Directory : public NtFile
{
public:
	Directory( const std::wstring& path, bool create_if_not_existing = false, std::uint32_t desired_access = FILE_READ_DATA );

public:
	bool Open( const std::wstring& path, bool create_if_not_existing = false, std::uint32_t desired_access = FILE_READ_DATA );
	bool Query( FILE_DIRECTORY_INFORMATION* information, bool restart = false );
};

class File : public NtFile
{
public:
	File( const std::wstring& path, bool create_if_not_existing = false, std::uint32_t desired_access = FILE_READ_DATA );

public:
	bool Open( const std::wstring& path, bool create_if_not_existing = false, std::uint32_t desired_access = FILE_READ_DATA );

	bool Read( void* data, std::size_t size_to_read, std::size_t* size_read = nullptr );
	bool Write( const void* const data, std::size_t size_to_write, std::size_t* size_written = nullptr );

	std::size_t GetSize() const;
};

} // namespace horizon::win32
```

`horizon/win32/image.cpp`:

```cpp
#include "image.hpp"
#include "string.hpp"
#include "process.hpp"

#include "../constant/hash.hpp"

#include "../memory/operation.hpp"

#include "../win32/trace.hpp"

namespace horizon::win32
{

IMAGE_DOS_HEADER* GetImageDosHeader( std::uintptr_t image )
{
	if( memory::IsAddressValid( image ) )
	{
		const auto image_dos_header = reinterpret_cast< IMAGE_DOS_HEADER* >( image );

		if( image_dos_header->e_magic == IMAGE_DOS_SIGNATURE )
		{
			return image_dos_header;
		}
	}

	return nullptr;
}

IMAGE_NT_HEADERS* GetImageNtHeaders( std::uintptr_t image )
{
	const auto image_dos_header = GetImageDosHeader( image );

	if( memory::IsAddressValid( image_dos_header ) )
	{
		const auto image_nt_headers = reinterpret_cast< IMAGE_NT_HEADERS* >( image + image_dos_header->e_lfanew );

		if( image_nt_headers->Signature == IMAGE_NT_SIGNATURE )
		{
			return image_nt_headers;
		}
	}

	return nullptr;
}

IMAGE_DATA_DIRECTORY* GetImageDataDirectory( std::uintptr_t image, std::uint16_t directory )
{
	if( directory < IMAGE_NUMBEROF_DIRECTORY_ENTRIES )
	{
		const auto image_nt_headers = GetImageNtHeaders( image );

		if( memory::IsAddressValid( image_nt_headers ) )
		{
			return &image_nt_headers->OptionalHeader.DataDirectory[ directory ];
		}
	}

	return nullptr;
}

IMAGE_SECTION_HEADER* GetImageSectionHeader( std::uintptr_t image, std::size_t* size /*= nullptr*/ )
{
	const auto image_nt_headers = GetImageNtHeaders( image );

	if( memory::IsAddressValid( image_nt_headers ) )
	{
		const auto image_file_header = &image_nt_headers->FileHeader;
		const auto image_optional_header = &image_nt_headers->OptionalHeader;

		if( memory::IsAddressValid( size ) )
		{
			( *size ) = static_cast< std::size_t >( image_file_header->NumberOfSections );
		}

		if( image_file_header->NumberOfSections )
		{
			const auto image_section_header = ( memory::ToAddress( image_optional_header ) + image_file_header->SizeOfOptionalHeader );
			return reinterpret_cast< IMAGE_SECTION_HEADER* >( image_section_header );
		}
	}

	return nullptr;
}

bool EnumerateImages( OnImageEntryFn enumerate, ImageParameters* parameters /*= nullptr*/ )
{
	if( memory::IsAddressValid( enumerate ) )
	{
		const auto peb = NtCurrentPeb();

		if( memory::IsAddressValid( peb ) )
		{
			const auto peb_ldr_data = peb->Ldr;

			if( memory::IsAddressValid( peb_ldr_data ) )
			{
				const auto list_head = &peb_ldr_data->InLoadOrderModuleList;

				for( auto list_entry = list_head->Flink; list_entry != list_head; list_entry = list_entry->Flink )
				{
					const auto entry = CONTAINING_RECORD( list_entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks );

					if( memory::IsAddressValid( entry ) )
					{
						if( enumerate( parameters, entry ) )
						{
							return true;
						}
					}
				}
			}
		}
	}

	return false;
}

bool EnumerateImageSections( std::uintptr_t image, OnImageSectionFn enumerate, SectionParameters* parameters /*= nullptr*/ )
{
	if( memory::IsAddressValid( enumerate ) )
	{
		std::size_t image_section_header_size = 0;
		const auto image_section_header = GetImageSectionHeader( image, &image_section_header_size );

		if( memory::IsAddressValid( image_section_header ) )
		{
			for( std::size_t index = 0; index < image_section_header_size; index++ )
			{
				const auto section = &image_section_header[ index ];

				if( memory::IsAddressValid( section ) )
				{
					if( enumerate( parameters, section ) )
					{
						return true;
					}
				}
			}
		}
	}

	return false;
}

bool EnumerateImageExports( std::uintptr_t image, OnImageExportFn enumerate, ExportParameters* parameters /*= nullptr*/ )
{
	if( memory::IsAddressValid( enumerate ) )
	{
		std::size_t image_export_directory_size = 0;
		const auto image_export_directory = GetImageDataDirectory< IMAGE_EXPORT_DIRECTORY* >( image, IMAGE_DIRECTORY_ENTRY_EXPORT,
																																													&image_export_directory_size );

		if( memory::IsAddressValid( image_export_directory ) )
		{
			if( image_export_directory->AddressOfFunctions &&
					image_export_directory->AddressOfNames &&
					image_export_directory->AddressOfNameOrdinals )
			{
				const auto functions = reinterpret_cast< const std::uint32_t* >( image + image_export_directory->AddressOfFunctions );
				const auto names = reinterpret_cast< const std::uint32_t* >( image + image_export_directory->AddressOfNames );
				const auto ordinals = reinterpret_cast< const std::uint16_t* >( image + image_export_directory->AddressOfNameOrdinals );

				for( std::uint32_t index = 0; index < image_export_directory->NumberOfNames; index++ )
				{
					const auto ordinal = ordinals[ index ];
					const auto displacement = functions[ ordinal ];

					if( displacement )
					{
						const auto address = ( image + displacement );
						const auto name_displacement = names[ index ];

						if( name_displacement )
						{
							const auto name = reinterpret_cast< const char* >( image + name_displacement );

							if( enumerate( parameters, address, ordinal, name ) )
							{
								return true;
							}
						}
					}
				}
			}
		}
	}

	return false;
}

const LDR_DATA_TABLE_ENTRY* GetLdrDataTableEntry( const LIST_ENTRY* list_head, const wchar_t* const name )
{
	for( auto list_entry = list_head->Flink; list_entry != list_head; list_entry = list_entry->Flink )
	{
		const auto ldr_data_table_entry = CONTAINING_RECORD( list_entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks );

		if( memory::IsAddressValid( ldr_data_table_entry ) )
		{
			const auto& base_name = ldr_data_table_entry->BaseDllName;

			if( constant::AreEqual( base_name, name, true ) )
			{
				return ldr_data_table_entry;
			}
		}
	}

	return nullptr;
}

const LDR_DATA_TABLE_ENTRY* GetLdrDataTableEntry( const LIST_ENTRY* list_head, std::uint64_t name_hash )
{
	for( auto list_entry = list_head->Flink; list_entry != list_head; list_entry = list_entry->Flink )
	{
		const auto ldr_data_table_entry = CONTAINING_RECORD( list_entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks );

		if( memory::IsAddressValid( ldr_data_table_entry ) )
		{
			const auto& base_name = ldr_data_table_entry->BaseDllName;

			if( base_name.Length > 0 )
			{
				if( constant::Hash( base_name, true ) == name_hash )
				{
					return ldr_data_table_entry;
				}
			}
		}
	}

	return nullptr;
}

/*
std::uintptr_t GetImageExport( std::uintptr_t image, const char* const name )
{
	if( !memory::IsAddressValid( name ) )
	{
		return 0;
	}

	const auto name_length = constant::GetLength( name );

	if( name_length <= 1 )
	{
		return 0;
	}

	const auto image_data_directory = GetImageDataDirectory( image, IMAGE_DIRECTORY_ENTRY_EXPORT );

	if( !memory::IsAddressValid( image_data_directory ) )
	{
		return 0;
	}

	const auto image_export_directory = reinterpret_cast< const IMAGE_EXPORT_DIRECTORY* >( image + image_data_directory->VirtualAddress );

	if( !memory::IsAddressValid( image_export_directory ) )
	{
		return 0;
	}

	if( !image_export_directory->Base ||
			!image_export_directory->AddressOfFunctions ||
			!image_export_directory->AddressOfNames ||
			!image_export_directory->AddressOfNameOrdinals ||
			!image_export_directory->NumberOfFunctions ||
			!image_export_directory->NumberOfNames )
	{
		return 0;
	}

	const auto functions = reinterpret_cast< const std::uint32_t* >( image + image_export_directory->AddressOfFunctions );
	const auto names = reinterpret_cast< const std::uint32_t* >( image + image_export_directory->AddressOfNames );
	const auto name_ordinals = reinterpret_cast< const std::uint16_t* >( image + image_export_directory->AddressOfNameOrdinals );

	for( auto index = 0ul; index < image_export_directory->NumberOfFunctions; index++ )
	{
		const auto export_ordinal = name_ordinals[ index ];
		const auto export_procedure = functions[ export_ordinal ];

		if( export_procedure )
		{
			const auto export_name = reinterpret_cast< const char* >( image + names[ index ] );

			if( memory::IsAddressValid( export_name ) )
			{
				if( constant::AreEqual( export_name, name, name_length, true ) )
				{
					return ( image + export_procedure );
				}
			}
		}
	}

	return 0;
}

std::uintptr_t GetImageExport( std::uintptr_t image, std::uint64_t name_hash )
{
	if( !name_hash )
	{
		return 0;
	}

	const auto image_data_directory = GetImageDataDirectory( image, IMAGE_DIRECTORY_ENTRY_EXPORT );

	if( !memory::IsAddressValid( image_data_directory ) )
	{
		return 0;
	}

	const auto image_export_directory = reinterpret_cast< const IMAGE_EXPORT_DIRECTORY* >( image + image_data_directory->VirtualAddress );

	if( !memory::IsAddressValid( image_export_directory ) )
	{
		return 0;
	}

	if( !image_export_directory->Base ||
			!image_export_directory->AddressOfFunctions ||
			!image_export_directory->AddressOfNames ||
			!image_export_directory->AddressOfNameOrdinals ||
			!image_export_directory->NumberOfFunctions ||
			!image_export_directory->NumberOfNames )
	{
		return 0;
	}

	const auto functions = reinterpret_cast< const std::uint32_t* >( image + image_export_directory->AddressOfFunctions );
	const auto names = reinterpret_cast< const std::uint32_t* >( image + image_export_directory->AddressOfNames );
	const auto name_ordinals = reinterpret_cast< const std::uint16_t* >( image + image_export_directory->AddressOfNameOrdinals );

	for( auto index = 0ul; index < image_export_directory->NumberOfFunctions; index++ )
	{
		const auto export_ordinal = name_ordinals[ index ];
		const auto export_procedure = functions[ export_ordinal ];

		if( export_procedure )
		{
			const auto export_name = reinterpret_cast< const char* >( image + names[ index ] );

			if( memory::IsAddressValid( export_name ) )
			{
				if( constant::Hash( export_name, true ) == name_hash )
				{
					return ( image + export_procedure );
				}
			}
		}
	}

	return 0;
}
*/

} // namespace horizon::win32
```

`horizon/win32/image.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "../constant/character.hpp"
#include "../constant/hash.hpp"
#include "../constant/string.hpp"

#include "../memory/operation.hpp"

#include "sdk/list_entry.hpp"

#include "sdk/string.hpp"
#include "sdk/unicode_string.hpp"

#include "sdk/image_base_relocation.hpp"
#include "sdk/image_data_directory.hpp"
#include "sdk/image_dos_header.hpp"
#include "sdk/image_export_directory.hpp"
#include "sdk/image_file_header.hpp"
#include "sdk/image_import_by_name.hpp"
#include "sdk/image_import_descriptor.hpp"
#include "sdk/image_nt_headers.hpp"
#include "sdk/image_optional_header.hpp"
#include "sdk/image_relocation.hpp"
#include "sdk/image_runtime_function_entry.hpp"
#include "sdk/image_section_header.hpp"
#include "sdk/image_thunk_data.hpp"

#include "sdk/ldr_data_table_entry.hpp"

namespace horizon::win32
{

IMAGE_DOS_HEADER* GetImageDosHeader( std::uintptr_t image );
IMAGE_NT_HEADERS* GetImageNtHeaders( std::uintptr_t image );

IMAGE_DATA_DIRECTORY* GetImageDataDirectory( std::uintptr_t image, std::uint16_t directory );

template< typename Type = std::uintptr_t >
Type GetImageDataDirectory( std::uintptr_t image, std::uint16_t directory, std::size_t* size = nullptr )
{
	const auto image_data_directory = GetImageDataDirectory( image, directory );

	if( memory::IsAddressValid( image_data_directory ) )
	{
		if( memory::IsAddressValid( size ) )
		{
			( *size ) = static_cast< std::size_t >( image_data_directory->Size );
		}

		if( image_data_directory->VirtualAddress )
		{
			return Type( image + image_data_directory->VirtualAddress );
		}
	}

	return { };
}

IMAGE_SECTION_HEADER* GetImageSectionHeader( std::uintptr_t image, std::size_t* size = nullptr );

struct ImageParameters
{
	std::uint64_t m_hash = 0;		// 0x0000
	std::uintptr_t m_base = 0;	// 0x0008
	std::size_t m_size = 0;			// 0x0010
};
// sizeof( ImageParameters ) = 0x0018

struct SectionParameters
{
	std::uint64_t m_hash = 0;		// 0x0000
	std::uint32_t m_base = 0;		// 0x0008
	std::uint32_t m_size = 0;		// 0x000C
};
// sizeof( SectionParameters ) = 0x0010

struct ExportParameters
{
	std::uint64_t m_hash = 0;			// 0x0000
	std::uint16_t m_ordinal = 0;	// 0x0008
	std::uintptr_t m_address = 0;	// 0x0010
};
// sizeof( ExportParameters ) = 0x0018

using OnImageEntryFn = bool( * )( ImageParameters* parameters, LDR_DATA_TABLE_ENTRY* entry );
using OnImageSectionFn = bool( * )( SectionParameters* parameters, IMAGE_SECTION_HEADER* section );
using OnImageExportFn = bool( * )( ExportParameters* parameters, std::uintptr_t address, std::uint16_t ordinal, const char* const name );

bool EnumerateImages( OnImageEntryFn enumerate, ImageParameters* parameters = nullptr );
bool EnumerateImageSections( std::uintptr_t image, OnImageSectionFn enumerate, SectionParameters* parameters = nullptr );
bool EnumerateImageExports( std::uintptr_t image, OnImageExportFn enumerate, ExportParameters* parameters = nullptr );

template< typename Type = std::uintptr_t >
Type GetImage( std::uint64_t hash, std::size_t* size = nullptr )
{
	auto enumerate = []( ImageParameters* parameters, LDR_DATA_TABLE_ENTRY* entry )
	{
		if( memory::IsAddressValid( parameters ) )
		{
			if( parameters->m_hash )
			{
				const auto& base_name = entry->BaseDllName;

				if( base_name.Length )
				{
					if( constant::Hash( base_name, true ) == parameters->m_hash )
					{
						parameters->m_base = memory::ToAddress( entry->DllBase );
						parameters->m_size = static_cast< std::size_t >( entry->SizeOfImage );
						return true;
					}
				}
			}
			else
			{
				parameters->m_base = memory::ToAddress( entry->DllBase );
				parameters->m_size = static_cast< std::size_t >( entry->SizeOfImage );
				return true;
			}
		}

		return false;
	};

	ImageParameters parameters = { };
	parameters.m_hash = hash;

	if( EnumerateImages( enumerate, &parameters ) )
	{
		if( memory::IsAddressValid( size ) )
		{
			( *size ) = parameters.m_size;
		}

		return Type( parameters.m_base );
	}

	return { };
}

template< typename Type = std::uintptr_t >
Type GetImage( const wchar_t* const name, std::size_t* size = nullptr )
{
	std::uint64_t hash = 0;

	if( memory::IsAddressValid( name ) )
	{
		hash = constant::Hash( name, true );
	}

	return GetImage< Type >( hash, size );
}

template< typename Type = std::uintptr_t >
Type GetImageSection( std::uintptr_t image, std::uint64_t hash, std::size_t* size = nullptr )
{
	auto enumerate = []( SectionParameters* parameters, IMAGE_SECTION_HEADER* section )
	{
		if( memory::IsAddressValid( parameters ) )
		{
			char section_name[ 16 ] = { };
			std::memcpy( section_name, section->Name, sizeof( section->Name ) );

			if( constant::Hash( section_name, true ) == parameters->m_hash )
			{
				parameters->m_base = section->VirtualAddress;
				parameters->m_size = section->Misc.VirtualSize;
				return true;
			}
		}

		return false;
	};

	SectionParameters parameters = { };
	parameters.m_hash = hash;

	if( EnumerateImageSections( image, enumerate, &parameters ) )
	{
		if( memory::IsAddressValid( size ) )
		{
			( *size ) = static_cast< std::size_t >( parameters.m_size );
		}

		if( parameters.m_base )
		{
			return Type( image + parameters.m_base );
		}
	}

	return { };
}

template< typename Type = std::uintptr_t >
Type GetImageSection( std::uintptr_t image, const char* const name, std::size_t* size = nullptr )
{
	if( memory::IsAddressValid( name ) )
	{
		const auto hash = constant::Hash( name, true );
		return GetImageSection< Type >( image, hash, size );
	}

	return { };
}

template< typename Type = std::uintptr_t >
Type GetImageExport( std::uintptr_t image, std::uint64_t hash )
{
	auto enumerate = []( ExportParameters* parameters, std::uintptr_t address, std::uint16_t ordinal, const char* const name )
	{
		if( memory::IsAddressValid( parameters ) )
		{
			const auto hash = constant::Hash( name, true );

			if( hash == parameters->m_hash )
			{
				parameters->m_address = address;
				parameters->m_ordinal = ordinal;
				return true;
			}
		}

		return false;
	};

	ExportParameters parameters = { };
	parameters.m_hash = hash;

	if( EnumerateImageExports( image, enumerate, &parameters ) )
	{
		return Type( parameters.m_address );
	}

	return { };
}

template< typename Type = std::uintptr_t >
Type GetImageExport( std::uintptr_t image, const char* const name )
{
	if( memory::IsAddressValid( name ) )
	{
		const auto hash = constant::Hash( name, true );
		return GetImageExport< Type >( image, hash );
	}

	return { };
}

const LDR_DATA_TABLE_ENTRY* GetLdrDataTableEntry( const LIST_ENTRY* list_head, const wchar_t* const name );
const LDR_DATA_TABLE_ENTRY* GetLdrDataTableEntry( const LIST_ENTRY* list_head, std::uint64_t name_hash );

} // namespace horizon::win32
```

`horizon/win32/input_manager.cpp`:

```cpp
#include "input_manager.hpp"
#include "trace.hpp"

#include "../memory/operation.hpp"

namespace horizon::win32
{

InputManager::~InputManager()
{
	Destroy();
}

void InputManager::Destroy()
{
	m_events.clear();
}

WindowEvent* InputManager::Find( std::uint64_t hash )
{
	if( m_events.empty() )
	{
		TRACE( "%s: m_events is empty!", FN );
		return nullptr;
	}

	for( auto& entry : m_events )
	{
		if( entry.m_hash == hash )
		{
			return &entry;
		}
	}

	return nullptr;
}

const WindowEvent* InputManager::Find( std::uint64_t hash ) const
{
	if( m_events.empty() )
	{
		TRACE( "%s: m_events is empty!", FN );
		return nullptr;
	}

	for( const auto& entry : m_events )
	{
		if( entry.m_hash == hash )
		{
			return &entry;
		}
	}

	return nullptr;
}

bool InputManager::RegisterEvent( std::uint64_t hash, WindowEvent::MessageFn message )
{
	if( !memory::IsAddressValid( message ) )
	{
		TRACE( "%s: message is not valid!", FN );
		return false;
	}

	const auto window_event = Find( hash );

	if( memory::IsAddressValid( window_event ) )
	{
		TRACE( "%s: Event '0x%016llX' already exists!", FN, hash );
		return true;
	}

	m_events.push_back( { hash, message } );
	return true;
}

void InputManager::UnregisterEvent( std::uint64_t hash )
{
	auto window_event = Find( hash );

	if( memory::IsAddressValid( window_event ) )
	{
		TRACE( "%s: Event '0x%016llX' is not valid!", FN, hash );
		return;
	}

	window_event->m_message = nullptr;
}

bool InputManager::ProcessMessage( HWND window, std::uint32_t message, std::uintptr_t wparam, std::intptr_t lparam )
{
	auto input = false;

	for( auto& window_event : m_events )
	{
		if( memory::IsAddressValid( window_event.m_message ) )
		{
			input |= window_event.m_message( window, message, wparam, lparam );
		}
	}

	return input;
}

bool InputManager::OnDispatchMessage( const MSG* msg )
{
	if( !memory::IsAddressValid( msg ) )
	{
		return false;
	}

	auto input = false;

	for( auto& window_event : m_events )
	{
		if( memory::IsAddressValid( window_event.m_message ) )
		{
			input |= window_event.m_message( msg->hwnd, msg->message, msg->wParam, msg->lParam );
		}
	}

	return input;
}

} // namespace horizon::win32
```

`horizon/win32/input_manager.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "../core/singleton.hpp"

namespace horizon::win32
{

struct WindowEvent
{
	using MessageFn = bool( * )( const void* window, std::uint32_t message, std::uintptr_t wparam, std::intptr_t lparam );

	WindowEvent()
		: m_hash( 0 )
		, m_message( nullptr )
	{ }

	WindowEvent( std::uint64_t hash, MessageFn message )
		: m_hash( hash )
		, m_message( message )
	{ }

	std::uint64_t m_hash = 0;
	MessageFn m_message = nullptr;
};

class InputManager : public core::Singleton< InputManager >
{
public:
	~InputManager();

public:
	void Destroy();

public:
	WindowEvent* Find( std::uint64_t hash );
	const WindowEvent* Find( std::uint64_t hash ) const;

	bool RegisterEvent( std::uint64_t hash, WindowEvent::MessageFn message );
	void UnregisterEvent( std::uint64_t hash );

public:
	bool ProcessMessage( HWND window, std::uint32_t message, std::uintptr_t wparam, std::intptr_t lparam );
	bool OnDispatchMessage( const MSG* msg );

protected:
	POINT	m_mouse = { };
	std::vector< WindowEvent > m_events = { };
};


} // namespace horizon::win32
```

`horizon/win32/math.cpp`:

```cpp
#include "math.hpp"

#include "../core/map_data.hpp"

#include <xmmintrin.h>

#include <cassert>

#define GET_FLOAT_WORD( i, d )			\
	do																\
	{																	\
		ieee_float_shape_type gf_u;			\
		gf_u.value = ( d );							\
		( i ) = gf_u.word;							\
	}																	\
	while( 0 )

#define SET_FLOAT_WORD( d, i )			\
	do																\
	{																	\
		ieee_float_shape_type sf_u;			\
		sf_u.word = ( i );							\
		( d ) = sf_u.value;							\
	}																	\
	while( 0 )

namespace horizon::win32
{

// 
// constants
// 

constexpr float XM_PI = 3.141592654f;
constexpr float XM_2PI = 6.283185307f;
constexpr float XM_1DIVPI = 0.318309886f;
constexpr float XM_1DIV2PI = 0.159154943f;
constexpr float XM_PIDIV2 = 1.570796327f;
constexpr float XM_PIDIV4 = 0.785398163f;

// 
// imports
// 

double pow( double x, double y )
{
	return g_map_data.pow( x, y );
}

float powf( float x, float y )
{
	return static_cast< float >( pow( static_cast< double >( x ), static_cast< double >( y ) ) );
}

double fmod( double x, double y )
{
	return g_map_data.fmod( x, y );
}

float fmodf( float x, float y )
{
	return static_cast< float >( fmod( static_cast< double >( x ), static_cast< double >( y ) ) );
}

double atof( const char* const data )
{
	return g_map_data.atof( data );
}

double floor( double x )
{
	return g_map_data.floor( x );
}

float floorf( float x )
{
	return static_cast< float >( floor( static_cast< double >( x ) ) );
}

double ceil( double x )
{
	return g_map_data.ceil( x );
}

float ceilf( float x )
{
	return static_cast< float >( ceil( static_cast< double >( x ) ) );
}

void qsort( void* a1, size_t a2, size_t a3, _CoreCrtNonSecureSearchSortCompareFunction a4 )
{
	return g_map_data.qsort( a1, a2, a3, a4 );
}

double atan2( double y, double x )
{
	return g_map_data.atan2( y, x );
}

// 
// implementation
// 

union ieee_float_shape_type
{
	float value;
	std::uint32_t word;
};

float roundf( float x )
{
	std::uint32_t w;
	GET_FLOAT_WORD( w, x );

	const auto exponent_less_127 = static_cast< std::int32_t >( ( w & 0x7f800000 ) >> 23 ) - 127;

	if( exponent_less_127 < 23 )
	{
		if( exponent_less_127 < 0 )
		{
			w &= 0x80000000;

			if( exponent_less_127 == -1 )
			{
				w |= ( static_cast< std::uint32_t >( 127 ) << 23 );
			}
		}
		else
		{
			const auto exponent_mask = 0x007fffffu >> exponent_less_127;

			if( ( w & exponent_mask ) == 0 )
			{
				return x;
			}

			w += 0x00400000 >> exponent_less_127;
			w &= ~exponent_mask;
		}
	}
	else
	{
		if( exponent_less_127 == 128 )
		{
			return x + x;
		}
		else
		{
			return x;
		}
	}

	SET_FLOAT_WORD( x, w );
	return x;
}

float fabsf( float x )
{
	return ( x < 0.f ? -x : x );
}

float sqrtf( float x )
{
	auto root = _mm_set_ss( x );
	root = _mm_sqrt_ss( root );
	return _mm_cvtss_f32( root );
}

float sinf( float x )
{
	auto quotient = XM_1DIV2PI * x;

	if( x >= 0.f )
	{
		quotient = static_cast< float >( static_cast< int >( quotient + 0.5f ) );
	}
	else
	{
		quotient = static_cast< float >( static_cast< int >( quotient - 0.5f ) );
	}

	auto y = x - XM_2PI * quotient;
	auto sign = 0.f;

	if( y > XM_PIDIV2 )
	{
		y = XM_PI - y;
		sign = -1.f;
	}
	else if( y < -XM_PIDIV2 )
	{
		y = -XM_PI - y;
		sign = -1.f;
	}
	else
	{
		sign = +1.f;
	}

	auto y2 = y * y;
	return ( ( ( ( ( ( -2.3889859e-08f * y2 + 2.7525562e-06f ) * y2 - 0.00019840874f ) * y2 + 0.0083333310f ) * y2 - 0.16666667f ) * y2 + 1.f ) * y );
}

float cosf( float x )
{
	auto quotient = XM_1DIV2PI * x;

	if( x >= 0.f )
	{
		quotient = static_cast< float >( static_cast< int >( quotient + 0.5f ) );
	}
	else
	{
		quotient = static_cast< float >( static_cast< int >( quotient - 0.5f ) );
	}

	auto y = x - XM_2PI * quotient;
	auto sign = 0.f;

	if( y > XM_PIDIV2 )
	{
		y = XM_PI - y;
		sign = -1.f;
	}
	else if( y < -XM_PIDIV2 )
	{
		y = -XM_PI - y;
		sign = -1.f;
	}
	else
	{
		sign = +1.f;
	}

	auto y2 = y * y;
	auto p = ( ( ( ( ( -2.6051615e-07f * y2 + 2.4760495e-05f ) * y2 - 0.0013888378f ) * y2 + 0.041666638f ) * y2 - 0.5f ) * y2 + 1.f );

	return ( sign * p );
}

float tanf( float x )
{
	auto s = sinf( x );
	auto c = cosf( x );

	return ( s / c );
}

float asinf( float x )
{
	auto non_negative = ( x >= 0.f );

	auto pox = fabsf( x );
	auto omx = 1.f - pox;

	if( omx < 0.f )
	{
		omx = 0.f;
	}

	auto root = sqrtf( omx );
	auto result = ( ( ( ( ( ( ( -0.0012624911f * pox + 0.0066700901f ) * pox - 0.0170881256f ) * pox + 0.0308918810f ) * pox - 0.0501743046f ) * pox + 0.0889789874f ) * pox - 0.2145988016f ) * pox + 1.5707963050f );

	result *= root;
	return ( non_negative ? ( XM_PIDIV2 - result ) : ( result - XM_PIDIV2 ) );
}

float acosf( float x )
{
	auto non_negative = ( x >= 0.f );

	auto pox = fabsf( x );
	auto omx = 1.f - pox;

	if( omx < 0.f )
	{
		omx = 0.f;
	}

	auto root = sqrtf( omx );
	auto result = ( ( ( ( ( ( ( -0.0012624911f * pox + 0.0066700901f ) * pox - 0.0170881256f ) * pox + 0.0308918810f ) * pox - 0.0501743046f ) * pox + 0.0889789874f ) * pox - 0.2145988016f ) * pox + 1.5707963050f );

	result *= root;
	return ( non_negative ? result : ( XM_PI - result ) );
}

float atanf( float x )
{
	auto x2 = x * x;
	auto root = sqrtf( 1.f + x2 );
	return asinf( x / root );
}

float atan2f( float y, float x )
{
	return static_cast< float >( atan2( static_cast< double >( y ), static_cast< double >( x ) ) );
}

long atol( const char* const data )
{
	return g_map_data.atol( data );
}

int atoi( const char* const data )
{
	return static_cast< int >( atol( data ) );
}

} // namespace horizon::win32
```

`horizon/win32/math.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

namespace horizon::win32
{

// 
// imported
// 

double pow( double x, double y );
float powf( float x, float y );
double fmod( double x, double y );
float fmodf( float x, float y );
double atof( const char* const data );

double floor( double x );
float floorf( float x );
double ceil( double x );
float ceilf( float x );

void qsort( void* a1, size_t a2, size_t a3, _CoreCrtNonSecureSearchSortCompareFunction a4 );

double atan2( double y, double x );

// 
// implemented
// 

float roundf( float x );

float fabsf( float x );
float sqrtf( float x );

float sinf( float x );
float cosf( float x );
float tanf( float x );

float asinf( float x );
float acosf( float x );
float atanf( float x );

float atan2f( float y, float x );

float tanf( float x );
float sinf( float x );
float cosf( float x );
float acosf( float x );
float atan2f( float y, float x );
double atof( const char* str );
float floorf( float x );
float ceilf( float x );

// 
// wrappers
// 

inline float pow( float x, float y )
{
	return powf( x, y );
}

inline float fmod( float x, float y )
{
	return fmodf( x, y );
}

inline float mod( float x, float y )
{
	return fmodf( x, y );
}

inline float floor( float x )
{
	return floorf( x );
}

inline float ceil( float x )
{
	return ceilf( x );
}

inline float round( float x )
{
	return roundf( x );
}

inline float fabs( float x )
{
	return fabsf( x );
}

inline float abs( float x )
{
	return fabsf( x );
}

inline float sqrt( float x )
{
	return sqrtf( x );
}

inline float sin( float x )
{
	return sinf( x );
}

inline float cos( float x )
{
	return cosf( x );
}

inline float tan( float x )
{
	return tanf( x );
}

inline float asin( float x )
{
	return asinf( x );
}

inline float acos( float x )
{
	return acosf( x );
}

inline float atan( float x )
{
	return atanf( x );
}

inline float atan2( float y, float x )
{
	return atan2f( y, x );
}

int atoi( const char* const data );
long atol( const char* const data );

} // namespace horizon::win32
```

`horizon/win32/process.cpp`:

```cpp
#include "process.hpp"

#include "../core/map_data.hpp"
#include "../memory/operation.hpp"
#include "../win32/trace.hpp"

namespace horizon::win32
{

HANDLE NtCurrentProcess() noexcept
{
	constexpr std::intptr_t current_process = -1;
	return reinterpret_cast< const HANDLE >( current_process );
}

HANDLE NtCurrentThread() noexcept
{
	constexpr std::intptr_t current_thread = -2;
	return reinterpret_cast< const HANDLE >( current_thread );
}

HANDLE NtCurrentSession() noexcept
{
	constexpr std::intptr_t current_session = -3;
	return reinterpret_cast< const HANDLE >( current_session );
}

TEB* NtCurrentTeb() noexcept
{
	auto teb = static_cast< std::uintptr_t >( 0 );
	auto displacement = static_cast< std::uint32_t >( FIELD_OFFSET( NT_TIB, Self ) );

#if defined( HORIZON_X86 )
	teb = __readfsdword( displacement );
#elif defined( HORIZON_X64 )
	teb = __readgsqword( displacement );
#endif // HORIZON_X86

	return reinterpret_cast< TEB* >( teb );
}

PEB* NtCurrentPeb() noexcept
{
	const auto teb = NtCurrentTeb();

	if( memory::IsAddressValid( teb ) )
	{
		return teb->ProcessEnvironmentBlock;
	}

	return nullptr;
}

std::uint32_t NtCurrentProcessId() noexcept
{
	const auto teb = NtCurrentTeb();

	if( memory::IsAddressValid( teb ) )
	{
		const auto process_id = memory::ToAddress( teb->ClientId.UniqueProcess );
		return static_cast< std::uint32_t >( process_id );
	}

	return 0;
}

std::uint32_t NtCurrentThreadId() noexcept
{
	const auto teb = NtCurrentTeb();

	if( memory::IsAddressValid( teb ) )
	{
		const auto thread_id = memory::ToAddress( teb->ClientId.UniqueThread );
		return static_cast< std::uint32_t >( thread_id );
	}

	return 0;
}

std::int32_t GetLastStatus() noexcept
{
	const auto teb = NtCurrentTeb();

	if( memory::IsAddressValid( teb ) )
	{
		return static_cast< std::int32_t >( teb->LastStatusValue );
	}

	return STATUS_INVALID_THREAD;
}

void SetLastStatus( std::int32_t last_status ) noexcept
{
	const auto teb = NtCurrentTeb();

	if( memory::IsAddressValid( teb ) )
	{
		teb->LastStatusValue = static_cast< std::uint32_t >( last_status );
	}
}

std::uint32_t GetLastError() noexcept
{
	const auto teb = NtCurrentTeb();

	if( memory::IsAddressValid( teb ) )
	{
		return teb->LastErrorValue;
	}

	return ERROR_INVALID_THREAD_ID;
}

void SetLastError( std::uint32_t last_error ) noexcept
{
	const auto teb = NtCurrentTeb();

	if( memory::IsAddressValid( teb ) )
	{
		teb->LastErrorValue = last_error;
	}
}

void* GetProcessHeap() noexcept
{
	const auto peb = NtCurrentPeb();

	if( memory::IsAddressValid( peb ) )
	{
		return peb->ProcessHeap;
	}

	return nullptr;
}

void* RtlAllocateHeap( void* heap_handle, std::uint32_t flags, std::size_t size ) noexcept
{
	if( !heap_handle )
	{
		TRACE( "%s: heap_handle is nullptr!", ATOM_FUNCTION );
		return nullptr;
	}

	return g_map_data.RtlAllocateHeap( heap_handle, flags, size );
}

void* RtlReAllocateHeap( void* heap_handle, std::uint32_t flags, void* memory_pointer, std::size_t size )
{
	if( !heap_handle )
	{
		TRACE( "%s: heap_handle is nullptr!", ATOM_FUNCTION );
		return nullptr;
	}

	return g_map_data.RtlReAllocateHeap( heap_handle, flags, memory_pointer, size );
}

bool RtlFreeHeap( void* heap_handle, std::uint32_t flags, void* memory_pointer ) noexcept
{
	if( !heap_handle )
	{
		TRACE( "%s: heap_handle is nullptr!", ATOM_FUNCTION );
		return false;
	}

	if( !memory_pointer )
	{
		TRACE( "%s: memory_pointer is nullptr!", ATOM_FUNCTION );
		return false;
	}

	return g_map_data.RtlFreeHeap( heap_handle, flags, memory_pointer );
}

} // namespace horizon::win32
```

`horizon/win32/process.hpp`:

```hpp
#pragma once

#include "../include/auto.hpp"
#include "../include/base.hpp"
#include "../include/win32.hpp"

#include "sdk/handle.hpp"

#include "sdk/teb.hpp"
#include "sdk/peb.hpp"

namespace horizon::win32
{

HANDLE NtCurrentProcess() noexcept;
HANDLE NtCurrentThread() noexcept;
HANDLE NtCurrentSession() noexcept;

TEB* NtCurrentTeb() noexcept;
PEB* NtCurrentPeb() noexcept;

std::uint32_t NtCurrentProcessId() noexcept;
std::uint32_t NtCurrentThreadId() noexcept;

std::int32_t GetLastStatus() noexcept;
void SetLastStatus( std::int32_t last_status ) noexcept;

std::uint32_t GetLastError() noexcept;
void SetLastError( std::uint32_t last_error ) noexcept;

void* GetProcessHeap() noexcept;

void* RtlAllocateHeap( void* heap_handle, std::uint32_t flags, std::size_t size ) noexcept;
void* RtlReAllocateHeap( void* heap_handle, std::uint32_t flags, void* memory_pointer, std::size_t size );
bool RtlFreeHeap( void* heap_handle, std::uint32_t flags, void* memory_pointer ) noexcept;

} // namespace horizon::win32
```

`horizon/win32/sdk/access_mask.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

using ACCESS_MASK = std::uint32_t;
// sizeof( ACCESS_MASK ) = 0x0004

constexpr ACCESS_MASK AccessDelete = 0x00010000;
constexpr ACCESS_MASK AccessReadControl = 0x00020000;
constexpr ACCESS_MASK AccessWriteDAC = 0x00040000;
constexpr ACCESS_MASK AccessWriteOwner = 0x00080000;
constexpr ACCESS_MASK AccessSynchronize = 0x00100000;

constexpr ACCESS_MASK AccessStandardRightsRequired = 0x000F0000;

constexpr ACCESS_MASK AccessStandardRightsRead = AccessReadControl;
constexpr ACCESS_MASK AccessStandardRightsWrite = AccessReadControl;
constexpr ACCESS_MASK AccessStandardRightsExecute = AccessReadControl;

constexpr ACCESS_MASK AccessStandardRightsAll = 0x001F0000;
constexpr ACCESS_MASK AccessSpecificRightsAll = 0x0000FFFF;

constexpr ACCESS_MASK AccessSystemSecurity = 0x01000000;
constexpr ACCESS_MASK AccessMaximumAllowed = 0x02000000;

constexpr ACCESS_MASK AccessGenericRead = 0x80000000;
constexpr ACCESS_MASK AccessGenericWrite = 0x40000000;
constexpr ACCESS_MASK AccessGenericExecute = 0x20000000;
constexpr ACCESS_MASK AccessGenericAll = 0x10000000;

} // namespace horizon::win32
```

`horizon/win32/sdk/activation_context_stack.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "rtl_activation_context_stack_frame.hpp"
#include "list_entry.hpp"

namespace horizon::win32
{

struct ACTIVATION_CONTEXT_STACK
{
	RTL_ACTIVATION_CONTEXT_STACK_FRAME* ActiveFrame = nullptr;	// 0x0000
	LIST_ENTRY FrameListCache = { };														// 0x0008
	std::uint32_t Flags = 0;																		// 0x0018
	std::uint32_t NextCookieSequenceNumber = 0;									// 0x001C
	std::uint32_t StackId = 0;																	// 0x0020
	FIELD_PAD( 0x0004 );																				// 0x0024
};
// sizeof( ACTIVATION_CONTEXT_STACK ) = 0x0028

} // namespace horizon::win32
```

`horizon/win32/sdk/alternative_architecture_type.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

enum ALTERNATIVE_ARCHITECTURE_TYPE
{
	StandardDesign = 0,
	NEC98x86 = 1,
	EndAlternatives = 2,
};
// sizeof( ALTERNATIVE_ARCHITECTURE_TYPE ) = 0x0004

} // namespace horizon::win32
```

`horizon/win32/sdk/client_id.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct CLIENT_ID32
{
	std::uint32_t UniqueProcess = 0;
	std::uint32_t UniqueThread = 0;
};

struct CLIENT_ID64
{
	std::uint64_t UniqueProcess = 0;
	std::uint64_t UniqueThread = 0;
};

struct CLIENT_ID
{
	void* UniqueProcess = nullptr;
	void* UniqueThread = nullptr;
};

} // namespace horizon::win32
```

`horizon/win32/sdk/constant_page.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

constexpr std::uint32_t PageNoAccess = 0x00000001;
constexpr std::uint32_t PageReadOnly = 0x00000002;
constexpr std::uint32_t PageReadWrite = 0x00000004;
constexpr std::uint32_t PageWriteCopy = 0x00000008;
constexpr std::uint32_t PageExecute = 0x00000010;
constexpr std::uint32_t PageExecuteRead = 0x00000020;
constexpr std::uint32_t PageExecuteReadWrite = 0x00000040;
constexpr std::uint32_t PageExecuteWriteCopy = 0x00000080;
constexpr std::uint32_t PageGuard = 0x00000100;
constexpr std::uint32_t PageNoCache = 0x00000200;
constexpr std::uint32_t PageWriteCombine = 0x00000400;

} // namespace horizon::win32
```

`horizon/win32/sdk/constant_region.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

constexpr std::uint32_t MemCommit = 0x00001000;
constexpr std::uint32_t MemReserve = 0x00002000;
constexpr std::uint32_t MemDecommit = 0x00004000;
constexpr std::uint32_t MemRelease = 0x00008000;
constexpr std::uint32_t MemFree = 0x00010000;
constexpr std::uint32_t MemPrivate = 0x00020000;
constexpr std::uint32_t MemMapped = 0x00040000;
constexpr std::uint32_t MemReset = 0x00080000;
constexpr std::uint32_t MemTopDown = 0x00100000;
constexpr std::uint32_t MemWriteWatch = 0x00200000;
constexpr std::uint32_t MemPhysical = 0x00400000;
constexpr std::uint32_t MemRotate = 0x00800000;
constexpr std::uint32_t MemDifferentImageBaseOk = 0x00800000;
constexpr std::uint32_t MemResetUndo = 0x01000000;
constexpr std::uint32_t MemLargePages = 0x02000000;
constexpr std::uint32_t Mem4MbPages = 0x08000000;

constexpr std::uint32_t MemImage = 0x01000000;

} // namespace horizon::win32
```

`horizon/win32/sdk/constant_section.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

constexpr std::uint32_t SecBased = 0x00200000;
constexpr std::uint32_t SecNoChange = 0x00400000;
constexpr std::uint32_t SecFile = 0x00800000;
constexpr std::uint32_t SecImage = 0x01000000;
constexpr std::uint32_t SecProtectedImage = 0x02000000;
constexpr std::uint32_t SecReserve = 0x04000000;
constexpr std::uint32_t SecCommit = 0x08000000;
constexpr std::uint32_t SecNoCache = 0x10000000;
constexpr std::uint32_t SecGlobal = 0x20000000;
constexpr std::uint32_t SecWriteCombine = 0x40000000;
constexpr std::uint32_t SecLargePages = 0x80000000;
constexpr std::uint32_t SecImageNoExecute = ( SecImage | SecNoCache );

} // namespace horizon::win32
```

`horizon/win32/sdk/event_basic_information.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "event_type.hpp"

namespace horizon::win32
{

struct EVENT_BASIC_INFORMATION
{
	EVENT_TYPE EventType = NotificationEvent;	// 0x0000
	std::int32_t EventState = 0;							// 0x0004
};
// sizeof( EVENT_BASIC_INFORMATION ) = 0x0008

} // namespace horizon::win32
```

`horizon/win32/sdk/event_information_class.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

enum EVENT_INFORMATION_CLASS
{
	EventBasicInformation,
};
// sizeof( EVENT_INFORMATION_CLASS ) = 0x0004

} // namespace horizon::win32
```

`horizon/win32/sdk/event_type.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

enum EVENT_TYPE
{
	NotificationEvent,
	SynchronizationEvent,
};
// sizeof( EVENT_TYPE ) = 0x0004

} // namespace horizon::win32
```

`horizon/win32/sdk/exception_registration_record.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct EXCEPTION_REGISTRATION_RECORD32
{
	std::uint32_t Next = 0;
	std::uint32_t Handler = 0;
};

struct EXCEPTION_REGISTRATION_RECORD64
{
	std::uint64_t Next = 0;
	std::uint64_t Handler = 0;
};

struct EXCEPTION_REGISTRATION_RECORD
{
	EXCEPTION_REGISTRATION_RECORD* Next = nullptr;
	void* Handler = nullptr;
};

} // namespace horizon::win32
```

`horizon/win32/sdk/file_basic_information.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "large_integer.hpp"

namespace horizon::win32
{

struct FILE_BASIC_INFORMATION
{
	LARGE_INTEGER CreationTime = { };		// 0x0000
	LARGE_INTEGER LastAccessTime = { };	// 0x0008
	LARGE_INTEGER LastWriteTime = { };	// 0x0010
	LARGE_INTEGER ChangeTime = { };			// 0x0018
	std::uint32_t FileAttributes = 0;		// 0x0020
	FIELD_PAD( 0x0004 );								// 0x0024
};
// sizeof( FILE_BASIC_INFORMATION ) = 0x0028

} // namespace horizon::win32
```

`horizon/win32/sdk/file_directory_information.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "large_integer.hpp"

namespace horizon::win32
{

struct FILE_DIRECTORY_INFORMATION
{
	std::uint32_t NextEntryOffset = 0;
	std::uint32_t FileIndex = 0;
	LARGE_INTEGER CreationTime = { };
	LARGE_INTEGER LastAccessTime = { };
	LARGE_INTEGER LastWriteTime = { };
	LARGE_INTEGER ChangeTime = { };
	LARGE_INTEGER EndOfFile = { };
	LARGE_INTEGER AllocationSize = { };
	std::uint32_t FileAttributes = 0;
	std::uint32_t FileNameLength = 0;
	wchar_t FileName[ MAX_PATH ] = { };
};
// sizeof( FILE_DIRECTORY_INFORMATION ) = 0x0248

} // namespace horizon::win32
```

`horizon/win32/sdk/file_id_both_dir_information.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "large_integer.hpp"

namespace horizon::win32
{

struct FILE_ID_BOTH_DIR_INFORMATION
{
	std::uint32_t NextEntryOffset = 0;	// 0x0000
	std::uint32_t FileIndex = 0;				// 0x0004
	LARGE_INTEGER CreationTime = { };		// 0x0008
	LARGE_INTEGER LastAccessTime = { };	// 0x0010
	LARGE_INTEGER LastWriteTime = { };	// 0x0018
	LARGE_INTEGER ChangeTime = { };			// 0x0020
	LARGE_INTEGER EndOfFile = { };			// 0x0028
	LARGE_INTEGER AllocationSize = { };	// 0x0030
	std::uint32_t FileAttributes = 0;		// 0x0038
	std::uint32_t FileNameLength = 0;		// 0x003C
	std::uint32_t EaSize = 0;						// 0x0040
	char ShortNameLength = 0;						// 0x0044
	FIELD_PAD( 0x0001 );								// 0x0045
	wchar_t ShortName[ 12 ] = { };			// 0x0046
	FIELD_PAD( 0x0002 );								// 0x005E
	LARGE_INTEGER FileId = { };					// 0x0060
	wchar_t FileName[ 1 ] = { };				// 0x0068
};
// sizeof( FILE_ID_BOTH_DIR_INFORMATION ) = 0x0070

} // namespace horizon::win32
```

`horizon/win32/sdk/file_information_class.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

enum FILE_INFORMATION_CLASS
{
	FileDirectoryInformation = 1,
	FileFullDirectoryInformation = 2,
	FileBothDirectoryInformation = 3,
	FileBasicInformation = 4,
	FileStandardInformation = 5,

	FileIdBothDirectoryInformation = 37,
};
// sizeof( FILE_INFORMATION_CLASS ) = 0x0004

} // namespace horizon::win32
```

`horizon/win32/sdk/file_standard_information.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "large_integer.hpp"

namespace horizon::win32
{

struct FILE_STANDARD_INFORMATION
{
	LARGE_INTEGER AllocationSize = { };	// 0x0000
	LARGE_INTEGER EndOfFile = { };			// 0x0008
	std::uint32_t NumberOfLinks = 0;		// 0x0010
	std::uint8_t DeletePending = 0;			// 0x0014
	std::uint8_t Directory = 0;					// 0x0015
	FIELD_PAD( 0x0002 );								// 0x0016
};
// sizeof( FILE_STANDARD_INFORMATION ) = 0x0018

} // namespace horizon::win32
```

`horizon/win32/sdk/gdi_teb_batch.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct GDI_TEB_BATCH
{
	struct
	{
		std::uint32_t Offset : 31;							// 0x0000
		std::uint32_t HasRenderingCommand : 1;	// 0x0000
	};
	FIELD_PAD( 0x0004 );											// 0x0004
	std::uint64_t HDC = 0;										// 0x0008
	std::uint32_t Buffer[ 310 ] = { };				// 0x0010
};
// sizeof( GDI_TEB_BATCH ) = 0x04E8

} // namespace horizon::win32
```

`horizon/win32/sdk/guid.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct GUID
{
	std::uint32_t Data1 = 0;				// 0x0000
	std::uint16_t Data2 = 0;				// 0x0004
	std::uint16_t Data3 = 0;				// 0x0006
	std::uint8_t Data4[ 8 ] = { };	// 0x0008
};
// sizeof( GUID ) = 0x0010

} // namespace horizon::win32
```

`horizon/win32/sdk/handle.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

using HANDLE = void*;

} // namespace horizon::win32
```

`horizon/win32/sdk/image_base_relocation.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct IMAGE_BASE_RELOCATION
{
	std::uint32_t VirtualAddress = 0;	// 0x0000
	std::uint32_t SizeOfBlock = 0;		// 0x0004
};
// sizeof( IMAGE_BASE_RELOCATION ) = 0x0008

} // namespace horizon::win32
```

`horizon/win32/sdk/image_data_directory.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

constexpr std::uint16_t ImageDirectoryEntryExport = 0;
constexpr std::uint16_t ImageDirectoryEntryImport = 1;
constexpr std::uint16_t ImageDirectoryEntryResource = 2;
constexpr std::uint16_t ImageDirectoryEntryException = 3;
constexpr std::uint16_t ImageDirectoryEntrySecurity = 4;
constexpr std::uint16_t ImageDirectoryEntryBaseReloc = 5;
constexpr std::uint16_t ImageDirectoryEntryDebug = 6;
constexpr std::uint16_t ImageDirectoryEntryArchitecture = 7;
constexpr std::uint16_t ImageDirectoryEntryGlobalPtr = 8;
constexpr std::uint16_t ImageDirectoryEntryTLS = 9;
constexpr std::uint16_t ImageDirectoryEntryLoadConfig = 10;
constexpr std::uint16_t ImageDirectoryEntryBoundImport = 11;
constexpr std::uint16_t ImageDirectoryEntryIAT = 12;
constexpr std::uint16_t ImageDirectoryEntryDelayImport = 13;
constexpr std::uint16_t ImageDirectoryEntryComDescriptor = 14;

constexpr std::uint16_t ImageNumberOfDirectoryEntries = 16;

struct IMAGE_DATA_DIRECTORY
{
	std::uint32_t VirtualAddress = 0;	// 0x0000
	std::uint32_t Size = 0;						// 0x0004
};
// sizeof( IMAGE_DATA_DIRECTORY ) = 0x0008

} // namespace horizon::win32
```

`horizon/win32/sdk/image_dos_header.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

constexpr std::uint16_t ImageDosSignature = 0x5A4D;	// 'MZ'

struct IMAGE_DOS_HEADER
{
	std::uint16_t e_magic = 0;				// 0x0000
	std::uint16_t e_cblp = 0;					// 0x0002
	std::uint16_t e_cp = 0;						// 0x0004
	std::uint16_t e_crlc = 0;					// 0x0006
	std::uint16_t e_cparhdr = 0;			// 0x0008
	std::uint16_t e_minalloc = 0;			// 0x000A
	std::uint16_t e_maxalloc = 0;			// 0x000C
	std::uint16_t e_ss = 0;						// 0x000E
	std::uint16_t e_sp = 0;						// 0x0010
	std::uint16_t e_csum = 0;					// 0x0012
	std::uint16_t e_ip = 0;						// 0x0014
	std::uint16_t e_cs = 0;						// 0x0016
	std::uint16_t e_lfarlc = 0;				// 0x0018
	std::uint16_t e_ovno = 0;					// 0x001A
	std::uint16_t e_res[ 4 ] = { };		// 0x001C
	std::uint16_t e_oemid = 0;				// 0x0024
	std::uint16_t e_oeminfo = 0;			// 0x0026
	std::uint16_t e_res2[ 10 ] = { };	// 0x0028
	std::uint32_t e_lfanew = 0;				// 0x003C
};
// sizeof( IMAGE_DOS_HEADER ) = 0x0040

} // namespace horizon::win32
```

`horizon/win32/sdk/image_export_directory.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct IMAGE_EXPORT_DIRECTORY
{
	std::uint32_t Characteristics = 0;				// 0x0000
	std::uint32_t TimeDateStamp = 0;					// 0x0004
	std::uint16_t MajorVersion = 0;						// 0x0008
	std::uint16_t MinorVersion = 0;						// 0x000A
	std::uint32_t Name = 0;										// 0x000C
	std::uint32_t Base = 0;										// 0x0010
	std::uint32_t NumberOfFunctions = 0;			// 0x0014
	std::uint32_t NumberOfNames = 0;					// 0x0018
	std::uint32_t AddressOfFunctions = 0;			// 0x001C
	std::uint32_t AddressOfNames = 0;					// 0x0020
	std::uint32_t AddressOfNameOrdinals = 0;	// 0x0024
};
// sizeof( IMAGE_EXPORT_DIRECTORY ) = 0x0028

} // namespace horizon::win32
```

`horizon/win32/sdk/image_file_header.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

constexpr std::size_t ImageSizeOfFileHeader = 20;

constexpr std::uint16_t ImageFileRelocsStripped = 0x0001;
constexpr std::uint16_t ImageFileExecutableImage = 0x0002;
constexpr std::uint16_t ImageFileLineNumsStripped = 0x0004;
constexpr std::uint16_t ImageFileLocalSymsStripped = 0x0008;
constexpr std::uint16_t ImageFileAggresiveWsTrim = 0x0010;
constexpr std::uint16_t ImageFileLargeAddressAware = 0x0020;
constexpr std::uint16_t ImageFileBytesReversedLo = 0x0080;
constexpr std::uint16_t ImageFile32BitMachine = 0x0100;
constexpr std::uint16_t ImageFileDebugStripped = 0x0200;
constexpr std::uint16_t ImageFileRemovableRunFromSwap = 0x0400;
constexpr std::uint16_t ImageFileNetRunFromSwap = 0x0800;
constexpr std::uint16_t ImageFileSystem = 0x1000;
constexpr std::uint16_t ImageFileDll = 0x2000;
constexpr std::uint16_t ImageFileUpSystemOnly = 0x4000;
constexpr std::uint16_t ImageFileBytesReversedHi = 0x8000;

constexpr std::uint16_t ImageFileMachineUnknown = 0x0000;
constexpr std::uint16_t ImageFileMachineTargetHost = 0x0001;
constexpr std::uint16_t ImageFileMachineI386 = 0x014C;
constexpr std::uint16_t ImageFileMachineIA64 = 0x0200;
constexpr std::uint16_t ImageFileMachineAMD64 = 0x8664;

struct IMAGE_FILE_HEADER
{
	std::uint16_t Machine = 0;							// 0x0000
	std::uint16_t NumberOfSections = 0;			// 0x0002
	std::uint32_t TimeDateStamp = 0;				// 0x0004
	std::uint32_t PointerToSymbolTable = 0;	// 0x0008
	std::uint32_t NumberOfSymbols = 0;			// 0x000C
	std::uint16_t SizeOfOptionalHeader = 0;	// 0x0010
	std::uint16_t Characteristics = 0;			// 0x0012
};
// sizeof( IMAGE_FILE_HEADER ) = 0x0014

} // namespace horizon::win32
```

`horizon/win32/sdk/image_import_by_name.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct IMAGE_IMPORT_BY_NAME
{
	std::uint16_t Hint = 0;	// 0x0000
	char Name[ 1 ] = { };		// 0x0002
};
// sizeof( IMAGE_IMPORT_BY_NAME ) = 0x0004

} // namespace horizon::win32
```

`horizon/win32/sdk/image_import_descriptor.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct IMAGE_IMPORT_DESCRIPTOR
{
	union
	{
		std::uint32_t Characteristics = 0;	// 0x0000
		std::uint32_t OriginalFirstThunk;		// 0x0000
	};
	std::uint32_t TimeDateStamp = 0;			// 0x0004
	std::uint32_t ForwarderChain = 0;			// 0x0008
	std::uint32_t Name = 0;								// 0x000C
	std::uint32_t FirstThunk = 0;					// 0x0010
};
// sizeof( IMAGE_IMPORT_DESCRIPTOR ) = 0x0014

} // namespace horizon::win32
```

`horizon/win32/sdk/image_nt_headers.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "image_file_header.hpp"
#include "image_optional_header.hpp"

namespace horizon::win32
{

constexpr std::uint32_t ImageNtSignature = 0x00004550;	// 'PE00'

struct IMAGE_NT_HEADERS32
{
	std::uint32_t Signature = 0;									// 0x0000
	IMAGE_FILE_HEADER FileHeader = { };						// 0x0004
	IMAGE_OPTIONAL_HEADER32 OptionalHeader = { };	// 0x0018
};
// sizeof( IMAGE_NT_HEADERS32 ) = 0x00F8

struct IMAGE_NT_HEADERS64
{
	std::uint32_t Signature = 0;									// 0x0000
	IMAGE_FILE_HEADER FileHeader = { };						// 0x0004
	IMAGE_OPTIONAL_HEADER64 OptionalHeader = { };	// 0x0018
};
// sizeof( IMAGE_NT_HEADERS32 ) = 0x0108

#if defined( HORIZON_X32 )
using IMAGE_NT_HEADERS = IMAGE_NT_HEADERS32;
#elif defined( HORIZON_X64 )
using IMAGE_NT_HEADERS = IMAGE_NT_HEADERS64;
#endif // HORIZON_X32

} // namespace horizon::win32
```

`horizon/win32/sdk/image_optional_header.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "image_data_directory.hpp"

namespace horizon::win32
{

constexpr std::uint16_t ImageNtOptionalHdr32Magic = 0x010B;
constexpr std::uint16_t ImageNtOptionalHdr64Magic = 0x020B;

struct IMAGE_OPTIONAL_HEADER32
{
	std::uint16_t Magic = 0;																										// 0x0000
	std::uint8_t MajorLinkerVersion = 0;																				// 0x0002
	std::uint8_t MinorLinkerVersion = 0;																				// 0x0003
	std::uint32_t SizeOfCode = 0;																								// 0x0004
	std::uint32_t SizeOfInitializedData = 0;																		// 0x0008
	std::uint32_t SizeOfUninitializedData = 0;																	// 0x000C
	std::uint32_t AddressOfEntryPoint = 0;																			// 0x0010
	std::uint32_t BaseOfCode = 0;																								// 0x0014
	std::uint32_t BaseOfData = 0;																								// 0x0018
	std::uint32_t ImageBase = 0;																								// 0x001C
	std::uint32_t SectionAlignment = 0;																					// 0x0020
	std::uint32_t FileAlignment = 0;																						// 0x0024
	std::uint16_t MajorOperatingSystemVersion = 0;															// 0x0028
	std::uint16_t MinorOperatingSystemVersion = 0;															// 0x002A
	std::uint16_t MajorImageVersion = 0;																				// 0x002C
	std::uint16_t MinorImageVersion = 0;																				// 0x002E
	std::uint16_t MajorSubsystemVersion = 0;																		// 0x0030
	std::uint16_t MinorSubsystemVersion = 0;																		// 0x0032
	std::uint32_t Win32VersionValue = 0;																				// 0x0034
	std::uint32_t SizeOfImage = 0;																							// 0x0038
	std::uint32_t SizeOfHeaders = 0;																						// 0x003C
	std::uint32_t CheckSum = 0;																									// 0x0040
	std::uint16_t Subsystem = 0;																								// 0x0044
	std::uint16_t DllCharacteristics = 0;																				// 0x0046
	std::uint32_t SizeOfStackReserve = 0;																				// 0x0048
	std::uint32_t SizeOfStackCommit = 0;																				// 0x004C
	std::uint32_t SizeOfHeapReserve = 0;																				// 0x0050
	std::uint32_t SizeOfHeapCommit = 0;																					// 0x0054
	std::uint32_t LoaderFlags = 0;																							// 0x0058
	std::uint32_t NumberOfRvaAndSizes = 0;																			// 0x005C
	IMAGE_DATA_DIRECTORY DataDirectory[ ImageNumberOfDirectoryEntries ] = { };	// 0x0060
};
// sizeof( IMAGE_OPTIONAL_HEADER32 ) = 0x00E0

struct IMAGE_OPTIONAL_HEADER64
{
	std::uint16_t Magic = 0;																										// 0x0000
	std::uint8_t MajorLinkerVersion = 0;																				// 0x0002
	std::uint8_t MinorLinkerVersion = 0;																				// 0x0003
	std::uint32_t SizeOfCode = 0;																								// 0x0004
	std::uint32_t SizeOfInitializedData = 0;																		// 0x0008
	std::uint32_t SizeOfUninitializedData = 0;																	// 0x000C
	std::uint32_t AddressOfEntryPoint = 0;																			// 0x0010
	std::uint32_t BaseOfCode = 0;																								// 0x0014
	std::uint64_t ImageBase = 0;																								// 0x0018
	std::uint32_t SectionAlignment = 0;																					// 0x0020
	std::uint32_t FileAlignment = 0;																						// 0x0024
	std::uint16_t MajorOperatingSystemVersion = 0;															// 0x0028
	std::uint16_t MinorOperatingSystemVersion = 0;															// 0x002A
	std::uint16_t MajorImageVersion = 0;																				// 0x002C
	std::uint16_t MinorImageVersion = 0;																				// 0x002E
	std::uint16_t MajorSubsystemVersion = 0;																		// 0x0030
	std::uint16_t MinorSubsystemVersion = 0;																		// 0x0032
	std::uint32_t Win32VersionValue = 0;																				// 0x0034
	std::uint32_t SizeOfImage = 0;																							// 0x0038
	std::uint32_t SizeOfHeaders = 0;																						// 0x003C
	std::uint32_t CheckSum = 0;																									// 0x0040
	std::uint16_t Subsystem = 0;																								// 0x0044
	std::uint16_t DllCharacteristics = 0;																				// 0x0046
	std::uint64_t SizeOfStackReserve = 0;																				// 0x0048
	std::uint64_t SizeOfStackCommit = 0;																				// 0x0050
	std::uint64_t SizeOfHeapReserve = 0;																				// 0x0058
	std::uint64_t SizeOfHeapCommit = 0;																					// 0x0060
	std::uint32_t LoaderFlags = 0;																							// 0x0068
	std::uint32_t NumberOfRvaAndSizes = 0;																			// 0x006C
	IMAGE_DATA_DIRECTORY DataDirectory[ ImageNumberOfDirectoryEntries ] = { };	// 0x0070
};
// sizeof( IMAGE_OPTIONAL_HEADER64 ) = 0x00F0

#if defined( HORIZON_X32 )
using IMAGE_OPTIONAL_HEADER = IMAGE_OPTIONAL_HEADER32;
#elif defined( HORIZON_X64 )
using IMAGE_OPTIONAL_HEADER = IMAGE_OPTIONAL_HEADER64;
#endif // HORIZON_X32

} // namespace horizon::win32
```

`horizon/win32/sdk/image_relocation.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

#pragma pack( push, 2 )

struct IMAGE_RELOCATION
{
	union
	{
		std::uint32_t VirtualAddress = 0;	// 0x0000
		std::uint32_t RelocCount;					// 0x0000
	};
	std::uint32_t SymbolTableIndex = 0;	// 0x0004
	std::uint16_t Type = 0;							// 0x0008
};
// sizeof( IMAGE_RELOCATION ) = 0x000A

#pragma pack( pop )

} // namespace horizon::win32
```

`horizon/win32/sdk/image_runtime_function_entry.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct IMAGE_RUNTIME_FUNCTION_ENTRY
{
	std::uint32_t BeginAddress = 0;					// 0x0000
	std::uint32_t EndAddress = 0;						// 0x0004
	union
	{
		std::uint32_t UnwindInfoAddress = 0;	// 0x0008
		std::uint32_t UnwindData;							// 0x0008
	};
};
// sizeof( IMAGE_RUNTIME_FUNCTION_ENTRY ) = 0x000C

} // namespace horizon::win32
```

`horizon/win32/sdk/image_section_header.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

constexpr std::uint16_t ImageSizeOfShortName = 8;
constexpr std::uint16_t ImageSizeOfSectionHeader = 40;


struct IMAGE_RELOCATION;

struct IMAGE_SECTION_HEADER
{
	std::uint8_t Name[ ImageSizeOfShortName ] = { };	// 0x0000
	union
	{
		std::uint32_t PhysicalAddress = 0;							// 0x0008
		std::uint32_t VirtualSize;											// 0x0008
	} Misc = { };																			// 0x0008
	std::uint32_t VirtualAddress = 0;									// 0x000C
	std::uint32_t SizeOfRawData = 0;									// 0x0010
	std::uint32_t PointerToRawData = 0;								// 0x0014
	std::uint32_t PointerToRelocations = 0;						// 0x0018
	std::uint32_t PointerToLinenumbers = 0;						// 0x001C
	std::uint16_t NumberOfRelocations = 0;						// 0x0020
	std::uint16_t NumberOfLinenumbers = 0;						// 0x0022
	std::uint32_t Characteristics = 0;								// 0x0024
};
// sizeof( IMAGE_SECTION_HEADER ) = 0x0028

} // namespace horizon::win32
```

`horizon/win32/sdk/image_thunk_data.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

constexpr std::uint32_t ImageOrdinalFlag32 = 0x80000000;
constexpr std::uint64_t ImageOrdinalFlag64 = 0x8000000000000000;

#if defined( HORIZON_X32 )
constexpr auto ImageOrdinalFlag = ImageOrdinalFlag32;
#elif defined( HORIZON_X64 )
constexpr auto ImageOrdinalFlag = ImageOrdinalFlag64;
#endif // HORIZON_X32

struct IMAGE_THUNK_DATA32
{
	union
	{
		std::uint32_t ForwarderString = 0;	// 0x0000
		std::uint32_t Function;							// 0x0000
		std::uint32_t Ordinal;							// 0x0000
		std::uint32_t AddressOfData;				// 0x0000
	} u1 = { };														// 0x0000
};
// sizeof( IMAGE_THUNK_DATA32 ) = 0x0004

struct IMAGE_THUNK_DATA64
{
	union
	{
		std::uint64_t ForwarderString = 0;	// 0x0000
		std::uint64_t Function;							// 0x0000
		std::uint64_t Ordinal;							// 0x0000
		std::uint64_t AddressOfData;				// 0x0000
	} u1 = { };														// 0x0000
};
// sizeof( IMAGE_THUNK_DATA64 ) = 0x0008

#if defined( HORIZON_X32 )
using IMAGE_THUNK_DATA = IMAGE_THUNK_DATA32;
#elif defined( HORIZON_X64 )
using IMAGE_THUNK_DATA = IMAGE_THUNK_DATA64;
#endif // HORIZON_X32

} // namespace horizon::win32
```

`horizon/win32/sdk/io_apc_routine.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "io_status_block.hpp"

namespace horizon::win32
{

using IO_APC_ROUTINE =
void( * )( void* ApcContext,
					 IO_STATUS_BLOCK* IoStatusBlock,
					 std::uint32_t Reserved );

} // namespace horizon::win32
```

`horizon/win32/sdk/io_status_block.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct IO_STATUS_BLOCK
{
	union
	{
		std::int32_t Status;					// 0x0000
		void* Pointer = nullptr;			// 0x0000
	};
	std::uint32_t Information = 0;	// 0x0000
	FIELD_PAD( 0x0004 );						// 0x0004
};
// sizeof( IO_STATUS_BLOCK ) = 0x0008

} // namespace horizon::win32
```

`horizon/win32/sdk/ksystem_time.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct KSYSTEM_TIME
{
	std::uint32_t LowPart = 0;	// 0x0000
	std::int32_t High1Time = 0;	// 0x0004
	std::int32_t High2Time = 0;	// 0x0008
};
// sizeof( KSYSTEM_TIME ) = 0x000C

} // namespace horizon::win32
```

`horizon/win32/sdk/kuser_shared_data.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "ksystem_time.hpp"
#include "nt_product_type.hpp"
#include "alternative_architecture_type.hpp"
#include "large_integer.hpp"

namespace horizon::win32
{

struct KUSER_SHARED_DATA
{
	std::uint32_t TickCountLowDeprecated = 0;
	std::uint32_t TickCountMultiplier = 0;
	KSYSTEM_TIME InterruptTime = { };
	KSYSTEM_TIME SystemTime = { };
	KSYSTEM_TIME TimeZoneBias = { };
	std::uint16_t ImageNumberLow = 0;
	std::uint16_t ImageNumberHigh = 0;
	wchar_t NtSystemRoot[ 260 ] = { };
	std::uint32_t MaxStackTraceDepth = 0;
	std::uint32_t CryptoExponent = 0;
	std::uint32_t TimeZoneId = 0;
	std::uint32_t LargePageMinimum = 0;
	std::uint32_t AitSamplingValue = 0;
	std::uint32_t AppCompatFlag = 0;
	std::uint64_t RNGSeedVersion = 0;
	std::uint32_t GlobalValidationRunlevel = 0;
	std::int32_t TimeZoneBiasStamp = 0;
	std::uint32_t NtBuildNumber = 0;
	NT_PRODUCT_TYPE NtProductType = NtProductWinNt;
	std::uint8_t ProductTypeIsValid = 0;
	FIELD_PAD( 0x0001 );
	std::uint16_t NativeProcessorArchitecture = 0;
	std::uint32_t NtMajorVersion = 0;
	std::uint32_t NtMinorVersion = 0;
	std::uint8_t ProcessorFeatures[ 64 ] = { };
	FIELD_PAD( 0x0008 );
	std::uint32_t TimeSlip = 0;
	ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture = StandardDesign;
	std::uint32_t BootId = 0;
	LARGE_INTEGER SystemExpirationDate = { };
	std::uint32_t SuiteMask = 0;
	std::uint8_t KdDebuggerEnabled = 0;
	union
	{
		std::uint8_t MitigationPolicies = 0;
		struct
		{
			std::uint8_t NXSupportPolicy : 2;
			std::uint8_t SEHValidationPolicy : 2;
			std::uint8_t CurDirDevicesSkippedForDlls : 2;
			std::uint8_t Reserved : 2;
		};
	};
	FIELD_PAD( 0x0002 );
	std::uint32_t ActiveConsoleId = 0;
	std::uint32_t DismountCount = 0;
	std::uint32_t ComPlusPackage = 0;
	std::uint32_t LastSystemRITEventTickCount = 0;
	std::uint32_t NumberOfPhysicalPages = 0;
	std::uint8_t SafeBootMode = 0;
	std::uint8_t VirtualizationFlags = 0;
	FIELD_PAD( 0x0002 );
	union
	{
		std::uint32_t SharedDataFlags = 0;
		struct
		{
			std::uint32_t DbgErrorPortPresent : 1;
			std::uint32_t DbgElevationEnabled : 1;
			std::uint32_t DbgVirtEnabled : 1;
			std::uint32_t DbgInstallerDetectEnabled : 1;
			std::uint32_t DbgLkgEnabled : 1;
			std::uint32_t DbgDynProcessorEnabled : 1;
			std::uint32_t DbgConsoleBrokerEnabled : 1;
			std::uint32_t DbgSecureBootEnabled : 1;
			std::uint32_t DbgMultiSessionSku : 1;
			std::uint32_t DbgMultiUsersInSessionSku : 1;
			std::uint32_t DbgStateSeparationEnabled : 1;
			std::uint32_t SpareBits : 21;
		};
	};
	FIELD_PAD( 0x0004 );
	std::uint64_t TestRetInstruction = 0;
	std::int64_t QpcFrequency = 0;
	std::uint32_t SystemCall = 0;
	FIELD_PAD( 0x0014 );
	union
	{
		KSYSTEM_TIME TickCount = { };
		std::uint64_t TickCountQuad;
		std::uint32_t ReservedTickCountOverlay[ 3 ];
	};
	FIELD_PAD( 0x0004 );
	std::uint32_t Cookie = 0;
	FIELD_PAD( 0x0004 );
	std::int64_t ConsoleSessionForegroundProcessId = 0;
	std::uint64_t TimeUpdateLock = 0;
	std::uint64_t BaselineSystemTimeQpc = 0;
	std::uint64_t BaselineInterruptTimeQpc = 0;
	std::uint64_t QpcSystemTimeIncrement = 0;
	std::uint64_t QpcInterruptTimeIncrement = 0;
	std::uint8_t QpcSystemTimeIncrementShift = 0;
	std::uint8_t QpcInterruptTimeIncrementShift = 0;
	std::uint16_t UnparkedProcessorCount = 0;
	std::uint32_t EnclaveFeatureMask[ 4 ] = { };
	std::uint32_t TelemetryCoverageRound = 0;
	std::uint16_t UserModeGlobalLogger[ 16 ] = { };
	std::uint32_t ImageFileExecutionOptions = 0;
	std::uint32_t LangGenerationCount = 0;
	FIELD_PAD( 0x0008 );
	std::uint64_t InterruptTimeBias = 0;
	std::uint64_t QpcBias = 0;
	std::uint32_t ActiveProcessorCount = 0;
	std::uint8_t ActiveGroupCount = 0;
	FIELD_PAD( 0x0001 );
	union
	{
		std::uint16_t QpcData = 0;
		struct
		{
			std::uint8_t QpcBypassEnabled;
			std::uint8_t QpcShift;
		};
	};
	LARGE_INTEGER TimeZoneBiasEffectiveStart = { };
	LARGE_INTEGER TimeZoneBiasEffectiveEnd = { };
};
// sizeof( KUSER_SHARED_DATA ) = 0x0710

} // namespace horizon::win32
```

`horizon/win32/sdk/large_integer.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

union LARGE_INTEGER
{
	union
	{
		struct
		{
			std::uint32_t LowPart;		// 0x0000
			std::int32_t HighPart;		// 0x0004
		};
		struct
		{
			std::uint32_t LowPart;		// 0x0000
			std::int32_t HighPart;		// 0x0004
		} u;
		std::int64_t QuadPart = 0;	// 0x0000
	};
};
// sizeof( LARGE_INTEGER ) = 0x0008

} // namespace horizon::win32
```

`horizon/win32/sdk/ldr_data_table_entry.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "list_entry.hpp"
#include "unicode_string.hpp"
#include "rtl_balanced_node.hpp"
#include "large_integer.hpp"

namespace horizon::win32
{

enum LDR_DLL_LOAD_REASON
{
	LoadReasonStaticDependency = 0,
	LoadReasonStaticForwarderDependency = 1,
	LoadReasonDynamicForwarderDependency = 2,
	LoadReasonDelayloadDependency = 3,
	LoadReasonDynamicLoad = 4,
	LoadReasonAsImageLoad = 5,
	LoadReasonAsDataLoad = 6,
	LoadReasonEnclavePrimary = 7,
	LoadReasonEnclaveDependency = 8,
	LoadReasonUnknown = -1,
};

struct LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks = { };
	LIST_ENTRY InMemoryOrderLinks = { };
	LIST_ENTRY InInitializationOrderLinks = { };
	void* DllBase = nullptr;
	void* EntryPoint = nullptr;
	std::uint32_t SizeOfImage = 0;
	FIELD_PAD( 0x0004 );
	UNICODE_STRING FullDllName = { };
	UNICODE_STRING BaseDllName = { };
	union
	{
		std::uint8_t FlagGroup[ 4 ] = { };
		std::uint32_t Flags;
		struct
		{
			std::uint32_t PackagedBinary : 1;
			std::uint32_t MarkedForRemoval : 1;
			std::uint32_t ImageDll : 1;
			std::uint32_t LoadNotificationsSent : 1;
			std::uint32_t TelemetryEntryProcessed : 1;
			std::uint32_t ProcessStaticImport : 1;
			std::uint32_t InLegacyLists : 1;
			std::uint32_t InIndexes : 1;
			std::uint32_t ShimDll : 1;
			std::uint32_t InExceptionTable : 1;
			std::uint32_t ReservedFlags1 : 2;
			std::uint32_t LoadInProgress : 1;
			std::uint32_t LoadConfigProcessed : 1;
			std::uint32_t EntryProcessed : 1;
			std::uint32_t ProtectDelayLoad : 1;
			std::uint32_t ReservedFlags3 : 2;
			std::uint32_t DontCallForThreads : 1;
			std::uint32_t ProcessAttachCalled : 1;
			std::uint32_t ProcessAttachFailed : 1;
			std::uint32_t CorDeferredValidate : 1;
			std::uint32_t CorImage : 1;
			std::uint32_t DontRelocate : 1;
			std::uint32_t CorILOnly : 1;
			std::uint32_t ReservedFlags5 : 2;
			std::uint32_t Redirected : 1;
			std::uint32_t ReservedFlags6 : 2;
			std::uint32_t CompatDatabaseProcessed : 1;
		};
	};
	std::uint16_t ObsoleteLoadCount = 0;
	std::uint16_t TlsIndex = 0;
	LIST_ENTRY HashLinks = { };
	std::uint32_t TimeDateStamp = 0;
	FIELD_PAD( 0x0004 );
	void* EntryPointActivationContext = nullptr;
	void* Lock = nullptr;
	void* DdagNode = nullptr;
	LIST_ENTRY NodeModuleLink = { };
	void* LoadContext = nullptr;
	void* ParentDllBase = nullptr;
	void* SwitchBackContext = nullptr;
	RTL_BALANCED_NODE BaseAddressIndexNode = { };
	RTL_BALANCED_NODE MappingInfoIndexNode = { };
	std::uint64_t OriginalBase = 0;
	LARGE_INTEGER LoadTime = { };
	std::uint32_t BaseNameHashValue = 0;
	LDR_DLL_LOAD_REASON LoadReason = LoadReasonUnknown;
	std::uint32_t ImplicitPathOptions = 0;
	std::uint32_t ReferenceCount = 0;
	std::uint32_t DependentLoadFlags = 0;
	std::uint8_t SigningLevel = 0;
	FIELD_PAD( 0x0003 );
};

} // namespace horizon::win32
```

`horizon/win32/sdk/list_entry.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct LIST_ENTRY32
{
	std::uint32_t Flink = 0;
	std::uint32_t Blink = 0;
};

struct LIST_ENTRY64
{
	std::uint64_t Flink = 0;
	std::uint64_t Blink = 0;
};

struct LIST_ENTRY
{
	LIST_ENTRY* Flink = nullptr;	// 0x0000
	LIST_ENTRY* Blink = nullptr;	// 0x0008
};
// sizeof( LIST_ENTRY ) = 0x0008

FORCEINLINE void InitializeListHead( LIST_ENTRY* ListHead )
{
	ListHead->Flink = ListHead->Blink = ListHead;
}

FORCEINLINE bool IsListEmpty( LIST_ENTRY* ListHead )
{
	return ( ListHead->Flink == ListHead );
}

FORCEINLINE bool RemoveEntryList( LIST_ENTRY* Entry )
{
	auto Flink = Entry->Flink;
	auto Blink = Entry->Blink;
	
	Blink->Flink = Flink;
	Flink->Blink = Blink;

	return ( Flink == Blink );
}

FORCEINLINE LIST_ENTRY* RemoveHeadList( LIST_ENTRY* ListHead )
{
	auto Entry = ListHead->Flink;
	auto Flink = Entry->Flink;
	
	ListHead->Flink = Flink;
	Flink->Blink = ListHead;

	return Entry;
}

FORCEINLINE LIST_ENTRY* RemoveTailList( LIST_ENTRY* ListHead )
{
	auto Entry = ListHead->Blink;
	auto Blink = Entry->Blink;

	ListHead->Blink = Blink;
	Blink->Flink = ListHead;

	return Entry;
}

FORCEINLINE void InsertTailList( LIST_ENTRY* ListHead, LIST_ENTRY* Entry )
{
	auto Blink = ListHead->Blink;

	Entry->Flink = ListHead;
	Entry->Blink = Blink;

	Blink->Flink = Entry;
	ListHead->Blink = Entry;
}

FORCEINLINE void InsertHeadList( LIST_ENTRY* ListHead, LIST_ENTRY* Entry )
{
	auto Flink = ListHead->Flink;

	Entry->Flink = Flink;
	Entry->Blink = ListHead;

	Flink->Blink = Entry;
	ListHead->Flink = Entry;
}

FORCEINLINE void AppendTailList( LIST_ENTRY* ListHead, LIST_ENTRY* ListToAppend )
{
	auto Blink = ListHead->Blink;

	ListHead->Blink->Flink = ListToAppend;
	ListHead->Blink = ListToAppend->Blink;

	ListToAppend->Blink->Flink = ListHead;
	ListToAppend->Blink = Blink;
}

} // namespace horizon::win32
```

`horizon/win32/sdk/memory_basic_information.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct MEMORY_BASIC_INFORMATION
{
	void* BaseAddress = nullptr;					// 0x0000
	void* AllocationBase = nullptr;				// 0x0008
	std::uint32_t AllocationProtect = 0;	// 0x0010
	FIELD_PAD( 0x0004 );									// 0x0014
	std::size_t RegionSize = 0;						// 0x0018
	std::uint32_t State = 0;							// 0x0020
	std::uint32_t Protect = 0;						// 0x0024
	std::uint32_t Type = 0;								// 0x0028
	FIELD_PAD( 0x0004 );									// 0x002C
};
// sizeof( MEMORY_BASIC_INFORMATION ) = 0x0030

} // namespace horizon::win32
```

`horizon/win32/sdk/memory_enclave_image_information.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "memory_image_information.hpp"

namespace horizon::win32
{

struct MEMORY_ENCLAVE_IMAGE_INFORMATION
{
	MEMORY_IMAGE_INFORMATION ImageInfo = { };	// 0x0000
	std::uint8_t UniqueID[ 32 ] = { };				// 0x0018
	std::uint8_t AuthorID[ 32 ] = { };				// 0x0038
};
// sizeof( MEMORY_ENCLAVE_IMAGE_INFORMATION ) = 0x0058

} // namespace horizon::win32
```

`horizon/win32/sdk/memory_frame_information.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct MEMORY_FRAME_INFORMATION
{
	std::uint64_t UseDescription : 4;		// 0x0000
	std::uint64_t ListDescription : 3;	// 0x0000
	std::uint64_t Cold : 1;							// 0x0000
	std::uint64_t Pinned : 1;						// 0x0000
	std::uint64_t DontUse : 48;					// 0x0000
	std::uint64_t Priority : 3;					// 0x0000
	std::uint64_t Reserved : 4;					// 0x0000
};
// sizeof( MEMORY_FRAME_INFORMATION ) = 0x0008

} // namespace horizon::win32
```

`horizon/win32/sdk/memory_image_information.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct MEMORY_IMAGE_INFORMATION
{
	void* ImageBase = nullptr;								// 0x0000
	std::size_t SizeOfImage = 0;							// 0x0008
	union
	{
		std::uint32_t ImageFlags = 0;						// 0x0010
		struct
		{
			std::uint32_t ImagePartialMap : 1;		// 0x0010
			std::uint32_t ImageNotExecutable : 1;	// 0x0010
			std::uint32_t ImageSigningLevel : 4;	// 0x0010
			std::uint32_t Reserved : 26;					// 0x0010
		};
	};
	FIELD_PAD( 0x0004 );											// 0x0014
};
// sizeof( MEMORY_IMAGE_INFORMATION ) = 0x0018

} // namespace horizon::win32
```

`horizon/win32/sdk/memory_information_class.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

enum MEMORY_INFORMATION_CLASS
{
	MemoryBasicInformation,
	MemoryWorkingSetInformation,
	MemoryMappedFilenameInformation,
	MemoryRegionInformation,
	MemoryWorkingSetExInformation,
	MemorySharedCommitInformation,
	MemoryImageInformation,
	MemoryRegionInformationEx,
	MemoryPrivilegedBasicInformation,
	MemoryEnclaveImageInformation,
};
// sizeof( MEMORY_INFORMATION_CLASS ) = 0x0004

} // namespace horizon::win32
```

`horizon/win32/sdk/memory_region_information.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "memory_working_set_block.hpp"

namespace horizon::win32
{

struct MEMORY_REGION_INFORMATION
{
	void* AllocationBase = 0;											// 0x0000
	std::uint32_t AllocationProtect = 0;					// 0x0008
	union
	{
		std::uint32_t RegionType = 0;								// 0x000C
		struct
		{
			std::uint32_t Private : 1;								// 0x000C
			std::uint32_t MappedDataFile : 1;					// 0x000C
			std::uint32_t MappedImage : 1;						// 0x000C
			std::uint32_t MappedPageFile : 1;					// 0x000C
			std::uint32_t MappedPhysical : 1;					// 0x000C
			std::uint32_t DirectMapped : 1;						// 0x000C
			std::uint32_t SoftwareEnclave : 1;				// 0x000C
			std::uint32_t PageSize64Kb : 1;						// 0x000C
			std::uint32_t PlaceholderReservation : 1;	// 0x000C
			std::uint32_t Reserved : 23;							// 0x000C
		};
	};
	std::size_t RegionSize = 0;										// 0x0010
	std::size_t CommitSize = 0;										// 0x0018
	std::uintptr_t PartitionId = 0;								// 0x0020
};
// sizeof( MEMORY_REGION_INFORMATION ) = 0x0028

} // namespace horizon::win32
```

`horizon/win32/sdk/memory_shared_commit_information.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct MEMORY_SHARED_COMMIT_INFORMATION
{
	std::size_t CommitSize = 0;	// 0x0000
};
// sizeof( MEMORY_SHARED_COMMIT_INFORMATION ) = 0x0008

} // namespace horizon::win32
```

`horizon/win32/sdk/memory_working_set_block.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct MEMORY_WORKING_SET_BLOCK
{
	std::uintptr_t Protection : 5;		// 0x0000
	std::uintptr_t ShareCount : 3;		// 0x0000
	std::uintptr_t Shared : 1;				// 0x0000
	std::uintptr_t Node : 3;					// 0x0000
#if defined( HORIZON_X32 )
	std::uintptr_t VirtualPage : 20;	// 0x0000
#elif defined( HORIZON_X64 )
	std::uintptr_t VirtualPage : 52;	// 0x0000
#endif // HORIZON_X32
};
// sizeof( MEMORY_WORKING_SET_BLOCK ) = 0x0008

} // namespace horizon::win32
```

`horizon/win32/sdk/memory_working_set_ex_block.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct MEMORY_WORKING_SET_EX_BLOCK
{
	union
	{
		struct
		{
			std::uintptr_t Valid : 1;										// 0x0000
			std::uintptr_t ShareCount : 3;							// 0x0000
			std::uintptr_t Win32Protection : 11;				// 0x0000
			std::uintptr_t Shared : 1;									// 0x0000
			std::uintptr_t Node : 6;										// 0x0000
			std::uintptr_t Locked : 1;									// 0x0000
			std::uintptr_t LargePage : 1;								// 0x0000
			std::uintptr_t Priority : 3;								// 0x0000
			std::uintptr_t Reserved0 : 3;								// 0x0000
			std::uintptr_t SharedOriginal : 1;					// 0x0000
			std::uintptr_t Bad : 1;											// 0x0000
			std::uintptr_t Win32GraphicsProtection : 4;	// 0x0000
#if defined( HORIZON_X64 )
			std::uintptr_t Reserved1 : 28;							// 0x0000
#endif // HORIZON_X64
		};
		struct
		{
			std::uintptr_t Valid : 1;										// 0x0000
			std::uintptr_t Reserved0 : 14;							// 0x0000
			std::uintptr_t Shared : 1;									// 0x0000
			std::uintptr_t Reserved1 : 5;								// 0x0000
			std::uintptr_t PageTable : 1;								// 0x0000
			std::uintptr_t Location : 2;								// 0x0000
			std::uintptr_t Priority : 3;								// 0x0000
			std::uintptr_t ModifiedList : 1;						// 0x0000
			std::uintptr_t Reserved2 : 2;								// 0x0000
			std::uintptr_t SharedOriginal : 1;					// 0x0000
			std::uintptr_t Bad : 1;											// 0x0000
#if defined( HORIZON_X64 )
			std::uintptr_t Reserved3 : 32;							// 0x0000
#endif // HORIZON_X64
		} Invalid;																		// 0x0000
	};
};
// sizeof( MEMORY_WORKING_SET_EX_BLOCK ) = 0x0008

} // namespace horizon::win32
```

`horizon/win32/sdk/memory_working_set_ex_information.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "memory_working_set_ex_block.hpp"

namespace horizon::win32
{

struct MEMORY_WORKING_SET_EX_INFORMATION
{
	void* VirtualAddress = nullptr;													// 0x0000
	union
	{
		MEMORY_WORKING_SET_EX_BLOCK VirtualAttributes = { };	// 0x0008
		std::uintptr_t Long;																	// 0x0008
	} u1;																										// 0x0008
};
// sizeof( MEMORY_WORKING_SET_EX_INFORMATION ) = 0x0010

} // namespace horizon::win32
```

`horizon/win32/sdk/memory_working_set_ex_location.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

enum MEMORY_WORKING_SET_EX_LOCATION
{
	MemoryLocationInvalid,
	MemoryLocationResident,
	MemoryLocationPagefile,
	MemoryLocationReserved,
};
// sizeof( MEMORY_WORKING_SET_EX_LOCATION ) = 0x0004

} // namespace horizon::win32
```

`horizon/win32/sdk/memory_working_set_information.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "memory_working_set_block.hpp"

namespace horizon::win32
{

struct MEMORY_WORKING_SET_INFORMATION
{
	std::size_t NumberOfEntries = 0;										// 0x0000
	MEMORY_WORKING_SET_BLOCK WorkingSetInfo[ 1 ] = { };	// 0x0008
};
// sizeof( MEMORY_WORKING_SET_INFORMATION ) = 0x0010

} // namespace horizon::win32
```

`horizon/win32/sdk/mutant_basic_information.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct MUTANT_BASIC_INFORMATION
{
	std::int32_t CurrentCount = 0;		// 0x0000
	std::uint8_t OwnedByCaller = 0;		// 0x0004
	std::uint8_t AbandonedState = 0;	// 0x0005
	FIELD_PAD( 0x0002 );							// 0x0006
};
// sizeof( MUTANT_BASIC_INFORMATION ) = 0x0008

} // namespace horizon::win32
```

`horizon/win32/sdk/mutant_information_class.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

enum MUTANT_INFORMATION_CLASS
{
	MutantBasicInformation,
};
// sizeof( MUTANT_INFORMATION_CLASS ) = 0x0004

} // namespace horizon::win32
```

`horizon/win32/sdk/nt_product_type.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

enum NT_PRODUCT_TYPE
{
	NtProductWinNt = 1,
	NtProductLanManNt = 2,
	NtProductServer = 3,
};
// sizeof( NT_PRODUCT_TYPE ) = 0x0004

} // namespace horizon::win32
```

`horizon/win32/sdk/nt_tib.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "exception_registration_record.hpp"

namespace horizon::win32
{

struct NT_TIB32
{
	std::uint32_t ExceptionList = 0;
	std::uint32_t StackBase = 0;
	std::uint32_t StackLimit = 0;
	std::uint32_t SubSystemTib = 0;
	union
	{
		std::uint32_t FiberData = 0;
		std::uint32_t Version;
	};
	std::uint32_t ArbitraryUserPointer = 0;
	std::uint32_t Self = 0;
};

struct NT_TIB64
{
	std::uint64_t ExceptionList = 0;
	std::uint64_t StackBase = 0;
	std::uint64_t StackLimit = 0;
	std::uint64_t SubSystemTib = 0;
	union
	{
		std::uint64_t FiberData = 0;
		std::uint32_t Version;
	};
	std::uint64_t ArbitraryUserPointer = 0;
	std::uint64_t Self = 0;
};

struct NT_TIB
{
	EXCEPTION_REGISTRATION_RECORD* ExceptionList = nullptr;
	void* StackBase = nullptr;
	void* StackLimit = nullptr;
	void* SubSystemTib = nullptr;
	union
	{
		void* FiberData = nullptr;
		std::uint32_t Version;
	};
	void* ArbitraryUserPointer = nullptr;
	NT_TIB* Self = nullptr;
};

} // namespace horizon::win32
```

`horizon/win32/sdk/object_attributes.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "unicode_string.hpp"

namespace horizon::win32
{

struct OBJECT_ATTRIBUTES
{
	std::uint32_t Length = 0;									// 0x0000
	FIELD_PAD( 0x0004 );											// 0x0004
	void* RootDirectory = nullptr;						// 0x0008
	UNICODE_STRING* ObjectName = nullptr;			// 0x0010
	std::uint32_t Attributes = 0;							// 0x0018
	FIELD_PAD( 0x0004 );											// 0x001C
	void* SecurityDescriptor = nullptr;				// 0x0020
	void* SecurityQualityOfService = nullptr;	// 0x0028
};
// sizeof( OBJECT_ATTRIBUTES ) = 0x0030

} // namespace horizon::win32
```

`horizon/win32/sdk/object_basic_information.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "access_mask.hpp"
#include "large_integer.hpp"

namespace horizon::win32
{

struct OBJECT_BASIC_INFORMATION
{
	std::uint32_t Attributes = 0;								// 0x0000
	ACCESS_MASK DesiredAccess = 0;							// 0x0004
	std::uint32_t HandleCount = 0;							// 0x0008
	std::uint32_t ReferenceCount = 0;						// 0x000C
	std::uint32_t PagedPoolUsage = 0;						// 0x0010
	std::uint32_t NonPagedPoolUsage = 0;				// 0x0014
	std::uint32_t Reserved[ 3 ] = { };					// 0x0018
	std::uint32_t NameInformationLength = 0;		// 0x0024
	std::uint32_t TypeInformationLength = 0;		// 0x0028
	std::uint32_t SecurityDescriptorLength = 0;	// 0x002C
	LARGE_INTEGER CreationTime = { };						// 0x0020
};
// sizeof( OBJECT_BASIC_INFORMATION ) = 0x0028

} // namespace horizon::win32
```

`horizon/win32/sdk/object_information_class.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

enum OBJECT_INFORMATION_CLASS
{
	ObjectBasicInformation,
	ObjectNameInformation,
	ObjectTypeInformation,
	ObjectAllInformation,
	ObjectDataInformation,
};
// sizeof( OBJECT_INFORMATION_CLASS ) = 0x0004

} // namespace horizon::win32
```

`horizon/win32/sdk/object_name_information.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "unicode_string.hpp"

namespace horizon::win32
{

struct OBJECT_NAME_INFORMATION
{
	UNICODE_STRING Name = { };	// 0x0000
};
// sizeof( OBJECT_NAME_INFORMATION ) = 0x0010

} // namespace horizon::win32
```

`horizon/win32/sdk/object_wait_type.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

enum OBJECT_WAIT_TYPE
{
	WaitAllObject,
	WaitAnyObject,
};
// sizeof( OBJECT_INFORMATION_CLASS ) = 0x0004

} // namespace horizon::win32
```

`horizon/win32/sdk/peb.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "peb_ldr_data.hpp"
#include "large_integer.hpp"
#include "ularge_integer.hpp"

namespace horizon::win32
{

struct PEB
{
	std::uint8_t InheritedAddressSpace = 0;
	std::uint8_t ReadImageFileExecOptions = 0;
	std::uint8_t BeingDebugged = 0;
	union
	{
		std::uint8_t BitField = 0;
		struct
		{
			std::uint8_t ImageUsesLargePages : 1;
			std::uint8_t IsProtectedProcess : 1;
			std::uint8_t IsImageDynamicallyRelocated : 1;
			std::uint8_t SkipPatchingUser32Forwarders : 1;
			std::uint8_t IsPackagedProcess : 1;
			std::uint8_t IsAppContainer : 1;
			std::uint8_t IsProtectedProcessLight : 1;
			std::uint8_t IsLongPathAwareProcess : 1;
		};
	};
	FIELD_PAD( 0x0004 );
	void* Mutant = nullptr;
	void* ImageBaseAddress = nullptr;
	PEB_LDR_DATA* Ldr = nullptr;
	void* ProcessParameters = nullptr;
	void* SubSystemData = nullptr;
	void* ProcessHeap = nullptr;
	void* FastPebLock = nullptr;
	void* volatile AtlThunkSListPtr = nullptr;
	void* IFEOKey = nullptr;
	union
	{
		std::uint32_t CrossProcessFlags = 0;
		struct
		{
			std::uint32_t ProcessInJob : 1;
			std::uint32_t ProcessInitializing : 1;
			std::uint32_t ProcessUsingVEH: 1;
			std::uint32_t ProcessUsingVCH: 1;
			std::uint32_t ProcessUsingFTH: 1;
			std::uint32_t ProcessPreviouslyThrottled : 1;
			std::uint32_t ProcessCurrentlyThrottled : 1;
			std::uint32_t ProcessImagesHotPatched : 1;
			std::uint32_t ReservedBits0 : 1;
		};
	};
	FIELD_PAD( 0x0004 );
	union
	{
		void* KernelCallbackTable = nullptr;
		void* UserSharedInfoPtr;
	};
	FIELD_PAD( 0x0004 );
	std::uint32_t AtlThunkSListPtr32 = 0;
	void* ApiSetMap = nullptr;
	std::uint32_t TlsExpansionCounter = 0;
	FIELD_PAD( 0x0004 );
	void* TlsBitmap = nullptr;
	std::uint32_t TlsBitmapBits[ 2 ] = { };
	void* ReadOnlySharedMemoryBase = nullptr;
	void* SharedData = nullptr;
	void** ReadOnlyStaticServerData = nullptr;
	void* AnsiCodePageData = nullptr;
	void* OemCodePageData = nullptr;
	void* UnicodeCaseTableData = nullptr;
	std::uint32_t NumberOfProcessors = 0;
	std::uint32_t NtGlobalFlag = 0;
};

} // namespace horizon::win32
```

`horizon/win32/sdk/peb_ldr_data.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "list_entry.hpp"

namespace horizon::win32
{

struct PEB_LDR_DATA
{
	std::uint32_t Length = 0;													// 0x0000
	std::uint8_t Initialized = 0;											// 0x0004
	FIELD_PAD( 0x0003 );															// 0x0005
	void* SsHandle = nullptr;													// 0x0008
	LIST_ENTRY InLoadOrderModuleList = { };						// 0x0010
	LIST_ENTRY InMemoryOrderModuleList = { };					// 0x0020
	LIST_ENTRY InInitializationOrderModuleList = { };	// 0x0030
	void* EntryInProgress = nullptr;									// 0x0040
	std::uint8_t ShutdownInProgress = 0;							// 0x0048
	FIELD_PAD( 0x0007 );															// 0x0049
	void* ShutdownThreadId = nullptr;									// 0x0050
};
// sizeof( PEB_LDR_DATA ) = 0x0058 ( 88 )


} // namespace horizon::win32
```

`horizon/win32/sdk/rtl_activation_context_stack_frame.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct ACTIVATION_CONTEXT;

struct RTL_ACTIVATION_CONTEXT_STACK_FRAME
{
	RTL_ACTIVATION_CONTEXT_STACK_FRAME* Previous = nullptr;	// 0x0000
	ACTIVATION_CONTEXT* ActivationContext = nullptr;				// 0x0008
	std::uint32_t Flags = 0;																// 0x0010
	FIELD_PAD( 0x0004 );																		// 0x0014
};
// sizeof( RTL_ACTIVATION_CONTEXT_STACK_FRAME ) = 0x0018

} // namespace horizon::win32
```

`horizon/win32/sdk/rtl_balanced_node.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct RTL_BALANCED_NODE
{
	union
	{
		RTL_BALANCED_NODE* Children[ 2 ] = { };
		struct
		{
			RTL_BALANCED_NODE* Left;
			RTL_BALANCED_NODE* Right;
		};
	};
	union
	{
		std::uint8_t Red : 1;
		std::uint8_t Balance : 2;
		std::uint64_t ParentValue = 0;
	};
};

} // namespace horizon::win32
```

`horizon/win32/sdk/rtl_condition_variable.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct RTL_CONDITION_VARIABLE
{
	void* Ptr = nullptr;	// 0x0000
};
// sizeof( RTL_CONDITION_VARIABLE ) = 0x0008

} // horizon::win32
```

`horizon/win32/sdk/rtl_critical_section.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "rtl_critical_section_debug.hpp"

namespace horizon::win32
{

struct RTL_CRITICAL_SECTION
{
	RTL_CRITICAL_SECTION_DEBUG* DebugInfo = nullptr;	// 0x0000
	std::int32_t LockCount = 0;												// 0x0008
	std::int32_t RecursionCount = 0;									// 0x000C
	void* OwningThread = nullptr;											// 0x0010
	void* LockSemaphore = nullptr;										// 0x0018
	std::uint64_t SpinCount = 0;											// 0x0020
};
// sizeof( RTL_CRITICAL_SECTION ) = 0x0028 ( 40 )

} // namespace horizon::win32
```

`horizon/win32/sdk/rtl_critical_section_debug.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "list_entry.hpp"

namespace horizon::win32
{

struct RTL_CRITICAL_SECTION;

struct RTL_CRITICAL_SECTION_DEBUG
{
	std::uint16_t Type = 0;														// 0x0000
	std::uint16_t CreatorBackTraceIndex = 0;					// 0x0002
	FIELD_PAD( 0x0004 );															// 0x0004
	RTL_CRITICAL_SECTION* CriticalSection = nullptr;	// 0x0008
	LIST_ENTRY ProcessLocksList = { };								// 0x0010
	std::uint32_t EntryCount = 0;											// 0x0020
	std::uint32_t ContentionCount = 0;								// 0x0024
	std::uint32_t Flags = 0;													// 0x0028
	std::uint16_t CreatorBackTraceIndexHigh = 0;			// 0x002C
	FIELD_PAD( 0x0002 );															// 0x002E
};
// sizeof( RTL_CRITICAL_SECTION_DEBUG ) = 0x0030 ( 48 )

} // namespace horizon::win32
```

`horizon/win32/sdk/rtl_heap_parameters.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct RTL_HEAP_PARAMETERS
{
	std::uint32_t Length = 0;										// 0x0000
	FIELD_PAD( 0x0004 );												// 0x0004
	std::size_t SegmentReserve = 0;							// 0x0008
	std::size_t SegmentCommit = 0;							// 0x0010
	std::size_t DeCommitFreeBlockThreshold = 0;	// 0x0018
	std::size_t DeCommitTotalFreeThreshold = 0;	// 0x0020
	std::size_t MaximumAllocationSize = 0;			// 0x0028
	std::size_t VirtualMemoryThreshold = 0;			// 0x0030
	std::size_t InitialCommit = 0;							// 0x0038
	std::size_t InitialReserve = 0;							// 0x0040
	void* CommitRoutine = nullptr;							// 0x0048
	std::size_t Reserved[ 2 ] = { };						// 0x0050
};
// sizeof( RTL_HEAP_PARAMETERS ) = 0x0060

} // namespace horizon::win32
```

`horizon/win32/sdk/section_basic_information.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "large_integer.hpp"

namespace horizon::win32
{

struct SECTION_BASIC_INFORMATION
{
	void* BaseAddress = nullptr;						// 0x0000
	std::uint32_t AllocationAttributes = 0;	// 0x0008
	FIELD_PAD( 0x0004 );										// 0x000C
	LARGE_INTEGER MaximumSize = { };				// 0x0010
};
// sizeof( SECTION_BASIC_INFORMATION ) = 0x0018

} // namespace horizon::win32
```

`horizon/win32/sdk/section_information_class.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

enum SECTION_INFORMATION_CLASS
{
	SectionBasicInformation,
	SectionImageInformation,
	SectionRelocationInformation,
};
// sizeof( SECTION_INFORMATION_CLASS ) = 0x0004

} // namespace horizon::win32
```

`horizon/win32/sdk/section_inherit.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

enum SECTION_INHERIT
{
	ViewShare = 1,
	ViewUnmap,
};
// sizeof( SECTION_INHERIT ) = 0x0004

} // namespace horizon::win32
```

`horizon/win32/sdk/string.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct STRING32
{
	std::uint16_t Length = 0;
	std::uint16_t MaximumLength = 0;
	std::uint32_t Buffer = 0;
};

struct STRING64
{
	std::uint16_t Length = 0;
	std::uint16_t MaximumLength = 0;
	FIELD_PAD( 0x0004 );
	std::uint64_t Buffer = 0;
};

struct STRING
{
	std::uint16_t Length = 0;
	std::uint16_t MaximumLength = 0;
	FIELD_PAD( 0x0004 );
	char* Buffer = nullptr;
};

using ANSI_STRING32 = STRING32;
using ANSI_STRING64 = STRING64;
using ANSI_STRING = STRING;

} // namespace horizon::win32
```

`horizon/win32/sdk/teb.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "nt_tib.hpp"
#include "client_id.hpp"
#include "peb.hpp"
#include "activation_context_stack.hpp"
#include "gdi_teb_batch.hpp"
#include "unicode_string.hpp"
#include "list_entry.hpp"
#include "guid.hpp"

namespace horizon::win32
{

struct TEB
{
	NT_TIB NtTib = { };																// 0x0000
	void* EnvironmentPointer = nullptr;								// 0x0038
	CLIENT_ID ClientId = { };													// 0x0040
	void* ActiveRpcHandle = nullptr;									// 0x0050
	void* ThreadLocalStoragePointer = nullptr;				// 0x0058
	PEB* ProcessEnvironmentBlock = nullptr;						// 0x0060
	std::uint32_t LastErrorValue = 0;									// 0x0068
	std::uint32_t CountOfOwnedCriticalSections = 0;		// 0x006C
	void* CsrClientThread = nullptr;									// 0x0070
	void* Win32ThreadInfo = nullptr;									// 0x0078
	std::uint32_t User32Reserved[ 26 ] = { };					// 0x0080
	std::uint32_t UserReserved[ 5 ] = { };						// 0x00
	FIELD_PAD( 0x0004 );															// 0x00
	void* WOW32Reserved = nullptr;										// 0x00
	std::uint32_t CurrentLocale = 0;									// 0x00
	std::uint32_t FpSoftwareStatusRegister = 0;				// 0x00
	void* ReservedForDebuggerInstrumentation[ 16 ] = { };
	void* SystemReserved1[ 30 ] = { };
	std::int8_t PlaceholderCompatibilityMode = 0;
	std::uint8_t PlaceholderHydrationAlwaysExplicit = 0;
	std::int8_t PlaceholderReserved[ 10 ] = { };
	std::uint32_t ProxiedProcessId = 0;
	ACTIVATION_CONTEXT_STACK _ActivationStack = { };
	std::uint8_t WorkingOnBehalfTicket[ 8 ] = { };
	std::int32_t ExceptionCode = 0;
	std::uint8_t Padding0[ 4 ] = { };
	ACTIVATION_CONTEXT_STACK* ActivationContextStackPointer = nullptr;
	std::uint64_t InstrumentationCallbackSp = 0;
	std::uint64_t InstrumentationCallbackPreviousPc = 0;
	std::uint64_t InstrumentationCallbackPreviousSp = 0;
	std::uint32_t TxFsContext = 0;
	std::uint8_t InstrumentationCallbackDisabled = 0;
	std::uint8_t UnalignedLoadStoreExceptions = 0;
	std::uint8_t Padding1[ 2 ] = { };
	GDI_TEB_BATCH GdiTebBatch = { };
	CLIENT_ID RealClientId = { };
	void* GdiCachedProcessHandle = nullptr;
	std::uint32_t GdiClientPID = 0;
	std::uint32_t GdiClientTID = 0;
	void* GdiThreadLocalInfo = nullptr;
	std::uint64_t Win32ClientInfo[ 62 ] = { };
	void* glDispatchTable[ 233 ] = { };
	std::uint64_t glReserved1[ 29 ] = { };
	void* glReserved2 = nullptr;
	void* glSectionInfo = nullptr;
	void* glSection = nullptr;
	void* glTable = nullptr;
	void* glCurrentRC = nullptr;
	void* glContext = nullptr;
	std::uint32_t LastStatusValue = 0;
	std::uint8_t Padding2[ 4 ] = { };
	UNICODE_STRING StaticUnicodeString = { };
	wchar_t StaticUnicodeBuffer[ 261 ] = { };
	std::uint8_t Padding3[ 6 ] = { };
	void* DeallocationStack = nullptr;
	void* TlsSlots[ 64 ] = { };
	LIST_ENTRY TlsLinks = { };
	void* Vdm = nullptr;
	void* ReservedForNtRpc = nullptr;
	void* DbgSsReserved[ 2 ] = { };
	std::uint32_t HardErrorMode = 0;
	std::uint8_t Padding4[ 4 ] = { };
	void* Instrumentation[ 11 ] = { };
	GUID ActivityId = { };
	void* SubProcessTag = nullptr;
	void* PerflibData = nullptr;
	void* EtwTraceData = nullptr;
	void* WinSockData = nullptr;
	std::uint32_t GdiBatchCount = 0;
	union
	{
		PROCESSOR_NUMBER CurrentIdealProcessor = { };
		std::uint32_t IdealProcessorValue;
		struct
		{
			std::uint8_t ReservedPad0;
			std::uint8_t ReservedPad1;
			std::uint8_t ReservedPad2;
			std::uint8_t IdealProcessor;
		};
	};
	std::uint32_t GuaranteedStackBytes = 0;
	std::uint8_t Padding5[ 4 ] = { };
	void* ReservedForPerf = nullptr;
	void* ReservedForOle = nullptr;
	std::uint32_t WaitingOnLoaderLock = 0;
	std::uint8_t Padding6[ 4 ] = { };
	void* SavedPriorityState = nullptr;
	std::uint64_t ReservedForCodeCoverage = 0;
	void* ThreadPoolData = nullptr;
	void** TlsExpansionSlots = nullptr;
	void* DeallocationBStore = nullptr;
	void* BStoreLimit = nullptr;
	std::uint32_t MuiGeneration = 0;
	std::uint32_t IsImpersonating = 0;
	void* NlsCache = nullptr;
	void* pShimData = nullptr;
	std::uint32_t HeapData = 0;
	std::uint8_t Padding7[ 4 ] = { };
	void* CurrentTransactionHandle = nullptr;
	void* ActiveFrame = nullptr;
	void* FlsData = nullptr;
	void* PreferredLanguages = nullptr;
	void* UserPrefLanguages = nullptr;
	void* MergedPrefLanguages = nullptr;
	std::uint32_t MuiImpersonation = 0;
	union
	{
		volatile std::uint16_t CrossTebFlags = 0;
		std::uint16_t SpareCrossTebBits : 16;
	};
	union
	{
		std::uint16_t SameTebFlags = 0;
		struct
		{
			std::uint16_t SafeThunkCall : 1;
			std::uint16_t InDebugPrint : 1;
			std::uint16_t HasFiberData : 1;
			std::uint16_t SkipThreadAttach : 1;
			std::uint16_t WerInShipAssertCode : 1;
			std::uint16_t RanProcessInit : 1;
			std::uint16_t ClonedThread : 1;
			std::uint16_t SupressDebugMsg : 1;
			std::uint16_t DisableUserStackWalk : 1;
			std::uint16_t RtlExceptionAttached : 1;
			std::uint16_t InitialThread : 1;
			std::uint16_t SessionAware : 1;
			std::uint16_t LoadOwner : 1;
			std::uint16_t LoaderWorker : 1;
			std::uint16_t SkipLoaderInit : 1;
			std::uint16_t SpareSameTebBits : 1;
		};
	};
	void* TxnScopeEnterCallback = nullptr;
	void* TxnScopeExitCallback = nullptr;
	void* TxnScopeContext = nullptr;
	std::uint32_t LockCount = 0;
	std::int32_t WowTebOffset = 0;
	void* ResourceRetValue = nullptr;
	void* ReservedForWdf = nullptr;
	std::uint64_t ReservedForCrt = 0;
	GUID EffectiveContainerId = { };
};

} // namespace horizon::win32
```

`horizon/win32/sdk/ularge_integer.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

union ULARGE_INTEGER
{
	union
	{
		struct
		{
			std::uint32_t LowPart;
			std::uint32_t HighPart;
		};
		struct
		{
			std::uint32_t LowPart;
			std::uint32_t HighPart;
		} u;
		std::uint64_t QuadPart = 0;
	};
};

} // namespace horizon::win32
```

`horizon/win32/sdk/unicode_string.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct UNICODE_STRING32
{
	std::uint16_t Length = 0;
	std::uint16_t MaximumLength = 0;
	std::uint32_t Buffer = 0;
};

struct UNICODE_STRING64
{
	std::uint16_t Length = 0;
	std::uint16_t MaximumLength = 0;
	FIELD_PAD( 0x0004 );
	std::uint64_t Buffer = 0;
};

struct UNICODE_STRING
{
	std::uint16_t Length = 0;
	std::uint16_t MaximumLength = 0;
	FIELD_PAD( 0x0004 );
	wchar_t* Buffer = nullptr;
};

} // namespace horizon::win32
```

`horizon/win32/sdk/xstate_configuration.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

#include "xstate_feature.hpp"

namespace horizon::win32
{

struct XSTATE_CONFIGURATION
{
	std::uint64_t EnabledFeatures = 0;
	std::uint64_t EnabledVolatileFeatures = 0;
	std::uint32_t Size = 0;
	union
	{
		std::uint32_t ControlFlags = 0;
		struct
		{
			std::uint32_t OptimizedSave : 1;
			std::uint32_t CompactionEnabled : 1;
		};
	};
	XSTATE_FEATURE Features[ 64 ] = { };
	std::uint64_t EnabledSupervisorFeatures = 0;
	std::uint64_t AlignedFeatures = 0;
	std::uint32_t AllFeatureSize = 0;
	std::uint32_t AllFeature[ 64 ] = { };
	FIELD_PAD( 0x0004 );
	std::uint64_t EnabledUserVisibleSupervisorFeatures = 0;
};
// sizeof( XSTATE_CONFIGURATION ) = 0x0338

} // namespace horizon::win32
```

`horizon/win32/sdk/xstate_feature.hpp`:

```hpp
#pragma once

#include "../../include/auto.hpp"
#include "../../include/base.hpp"
#include "../../include/win32.hpp"

namespace horizon::win32
{

struct XSTATE_FEATURE
{
	std::uint32_t Offset = 0;	// 0x0000
	std::uint32_t Size = 0;		// 0x0004
};
// sizeof( XSTATE_FEATURE ) = 0x0008

} // namespace horizon::win32
```

`rust/main/entry.cpp`:

```cpp
#include "../rust/core.hpp"

namespace atom
{

void ImageLoad( void* instance, void* reserved )
{
	__try
	{
		// 
		// reset image headers
		// 
		std::memset( instance, 0, PAGE_SIZE );

		if( rust::Create() )
		{

		}
		else
		{
			TRACE( "%s: rust::Create() error!", ATOM_FUNCTION );
		}
	}
	__except( EXCEPTION_EXECUTE_HANDLER )
	{
		TRACE( "%s: Exception occured = '0x%08X'!", ATOM_FUNCTION, GetExceptionCode() );
	}
}

void ImageFree( void* reserved )
{
	if( reserved )
	{
		rust::Destroy();
	}
}

int Dispatch( void* instance, std::uint32_t reason, void* reserved )
{
	switch( reason )
	{
		case DLL_PROCESS_ATTACH:
		{
			ImageLoad( instance, reserved );
			break;
		}
		case DLL_PROCESS_DETACH:
		{
			ImageFree( reserved );
			break;
		}
	}

	return TRUE;
}

} // namespace atom

int API_STDCALL DllMain( void* instance, unsigned long reason, void* reserved )
{
	return atom::Dispatch( instance, reason, reserved );
}
```

`rust/main/vcruntime.cpp`:

```cpp
#include "../unity/sdk.hpp"

#pragma comment( linker, "/merge:.CRT=.rdata" )
#pragma comment( linker, "/merge:.pdata=.rdata" )
#pragma comment( linker, "/merge:.rdata=.text" )

extern "C"
{

	std::int32_t _fltused = 0x9875;

}; // extern "C"

using _PVFV = void( * )( );

extern "C"
{

	// 
	// std::unordered_map support
	// 
#pragma function( ceilf )
	float ceilf( float x )
	{
		return horizon::win32::ceil( x );
	}

	int _purecall()
	{
		return 0;
	}

}; // extern "C"

type_info::~type_info()
{ }

__declspec( noreturn ) void _invalid_parameter_noinfo_noreturn()
{ }

void __std_exception_copy( struct __std_exception_data const*, struct __std_exception_data* )
{ }

void __std_exception_destroy( struct __std_exception_data* )
{ }

namespace std
{

void _Xlength_error( const char* )
{ }

void _Xout_of_range( const char* )
{ }

} // namespace std

extern "C"
{

	EXCEPTION_DISPOSITION __C_specific_handler( PEXCEPTION_RECORD ExceptionRecord, PVOID EstablisherFrame, PCONTEXT ContextRecord, PDISPATCHER_CONTEXT DispatcherContext )
	{
		return g_map_data.__C_specific_handler( ExceptionRecord, EstablisherFrame, ContextRecord, DispatcherContext );
	}

	void _CxxThrowException( void*, _ThrowInfo* )
	{ }

	void __CxxFrameHandler4()
	{ }

}; // extern "C"
```

`rust/options/storage.cpp`:

```cpp
#include "storage.hpp"

namespace options
{

CategoryAimbot m_aimbot = { };
CategoryVisuals m_visuals = { };
CategoryCommon m_common = { };
CategoryColors m_colors = { };

struct StorageData
{
	static constexpr auto Signature = HASH( "StorageData" );

	StorageData( bool initialize )
		: m_signature( initialize ? Signature : 0 )
		, m_aimbot()
		, m_visuals()
		, m_common()
		, m_colors()
	{ }

	bool IsValid() const
	{
		return ( m_signature == Signature );
	}

	std::uint64_t m_signature = 0;
	CategoryAimbot m_aimbot = { };
	CategoryVisuals m_visuals = { };
	CategoryCommon m_common = { };
	CategoryColors m_colors = { };
};

bool Load( const std::wstring& name )
{
	std::wstring directory( SECURE( L"\\SystemRoot\\" ) );
	directory.append( name );

	if( directory.find( SECURE( L".bin" ) ) == std::wstring::npos )
	{
		// 
		// Add extension to file path
		// 
		directory.append( SECURE( L".bin" ) );
	}

	win32::File file( directory, true, FILE_READ_DATA );

	if( file.IsOpen() )
	{
		StorageData storage( false );

		if( file.Read( &storage, sizeof( storage ) ) )
		{
			if( storage.IsValid() )
			{
				std::memcpy( &m_aimbot, &storage.m_aimbot, sizeof( CategoryAimbot ) );
				std::memcpy( &m_visuals, &storage.m_visuals, sizeof( CategoryVisuals ) );
				std::memcpy( &m_common, &storage.m_common, sizeof( CategoryCommon ) );
				std::memcpy( &m_colors, &storage.m_colors, sizeof( CategoryColors ) );
				return true;
			}
			else
			{
				TRACE( "%s: Storage data is not valid!", ATOM_FUNCTION );
			}
		}
		else
		{
			TRACE( "%s: Couldn't read file!", ATOM_FUNCTION );
		}
	}
	else
	{
		TRACE( "%s: Couldn't open file!", ATOM_FUNCTION );
	}

	return false;
}

bool Save( const std::wstring& name )
{
	std::wstring directory( SECURE( L"\\SystemRoot\\" ) );
	directory.append( name );

	if( directory.find( SECURE( L".bin" ) ) == std::wstring::npos )
	{
		// 
		// Add extension to file path
		// 
		directory.append( SECURE( L".bin" ) );
	}

	win32::File file( directory, true, FILE_READ_DATA | FILE_WRITE_DATA );

	if( file.IsOpen() )
	{
		StorageData storage( true );
		
		std::memcpy( &storage.m_aimbot, &m_aimbot, sizeof( CategoryAimbot ) );
		std::memcpy( &storage.m_visuals, &m_visuals, sizeof( CategoryVisuals ) );
		std::memcpy( &storage.m_common, &m_common, sizeof( CategoryCommon) );
		std::memcpy( &storage.m_colors, &m_colors, sizeof( CategoryColors ) );

		if( file.Write( &storage, sizeof( storage ) ) )
		{
			return true;
		}
		else
		{
			TRACE( "%s: Couldn't write file!", ATOM_FUNCTION );
		}
	}
	else
	{
		TRACE( "%s: Couldn't open file!", ATOM_FUNCTION );
	}

	return false;
}

} // namespace options
```

`rust/options/storage.hpp`:

```hpp
#pragma once

#include "../unity/sdk.hpp"

namespace options
{

struct CategoryAimbot
{
	struct
	{
		int m_mode = 2;									// 0 - 2				| 0 - Off, 1 - Auto, 2 - Key
		int m_key = 2;									// 0 - 128			| Aim lock bind
		bool m_auto_fire = false;				//							| Shoot automatically
		bool m_auto_cycle = true;				//							| Change target automatically
	} m_general = { };
	struct
	{
		float m_pitch = 0.f;						// 0 - 100 (%)	| Amount of vertical recoil compensation
		float m_yaw = 0.f;							// 0 - 100 (%)	| Amount of horizontal recoil compensation
	} m_accuracy = { };
	struct
	{
		int m_bone = 37;								// 0 - 128			| Bone to aim at
		int m_priority = 2;							// 0 - 2				| 0 - Random, 1 - Distance, 2 - FOV
		float m_radius = 180.f;					// 0.f - 180.f	| Maximum degrees to target
		float m_distance = 8192.f;			// 0.f - 8192.f	| Maximum distance to target
		bool m_trace = false;						//							| Aim only at visible targets
		bool m_friendly = false;				//							| Aim at friednly targets
	} m_target = { };
	struct
	{
		int m_mode = 0;									// 0 - 2				| 0 - Off, 1 - Constant, 2 - Linear
		float m_pitch = 0.f;						// 0.f - 100.f	| Vertical aim step or smooth amount
		float m_yaw = 0.f;							// 0.f - 100.f	| Horizontal aim step or smooth amount
	} m_step = { };
	struct
	{
		int m_cycle = 0;
		int m_delay = 0;
		int m_duration = 0;
	} m_time = { };
	struct
	{
		bool m_show_fov = false;
	} m_drawings = { };
};

struct CategoryVisuals
{
	bool m_state = true;							//							| Visuals master switch
	int m_box = 1;										// 0 - 2				| 0 - Off, 1 - Normal, 2 - Corners
	bool m_border = true;							//							| Border box black border
	bool m_name = false;							//							| Show player name
	bool m_trace = false;							//							| Show visible players with different color
	bool m_weapon = false;						//							| Show current equipped item
	bool m_skeleton = true;						//							| Show player skeleton
	bool m_distance = true;						//							| Show distance to player

	//other shit
	bool m_show_building_block = false;
	bool m_show_box_storage = false;
	bool m_show_gun_trap = false;
	bool m_show_bear_trap = false;
	bool m_show_vending = false;
	bool m_show_stash_container = false;
	bool m_show_building_privledge = false;
	bool m_show_workbench = false;
	bool m_show_base_oven = false;
	bool m_show_research_table = false;
	bool m_show_dropped_item = false;
	bool m_show_player_corpse = false;
	bool m_show_ore_hot_spot = false;
};

struct CategoryCommon
{
	bool m_crosshair = true;					//							| Show crosshair in screen center

	//bool m_debug_time = false;				//							| Always day                 } its a shit, need one option. 'admin mode'
	//bool m_debug_camera = false;			//							| Admin debug camera         } its a shit, need one option. 'admin mode'
	bool m_admin_mode = false;
};

struct CategoryColors
{
	struct
	{
		Color m_box = Color::Cyan();
		Color m_border = Color::Black();
		Color m_name = Color::White();
		Color m_trace = Color::Green();
		Color m_weapon = Color::White();
		Color m_skeleton = Color::White();
		Color m_skeleton_invisible = Color::Red();
		Color m_distance = Color::White();
		Color m_box_storage = Color(1.f, 0.f, 0.f);
		Color m_gun_trap = Color(0.f, 1.f, 1.f);
		Color m_bear_trap = Color(1.f, 1.f, 0.f);
		Color m_vedning = Color(0.f, 0.5f, 0.2f);
		Color m_stash_container = Color(1.f, 0.f, 0.f);
		Color m_building_privledge = Color(1.f, 0.5f, 0.f);
		Color m_workbench = Color(0.f, 0.05f, 1.f);
		Color m_base_oven = Color(0.5f, 0.f, 1.f);
		Color m_research_table = Color(1.f, 0.f, 1.f);
		Color m_dropped_item = Color(1.f, 0.f, 0.f);
		Color m_player_corpse = Color(1.f, 1.f, 1.f);
		Color m_ore_hot_spot = Color(1.f, 0.33f, 1.f);

	} m_visuals = { };
	struct
	{
		Color m_crosshair = Color::Cyan();
	} m_common = { };
};

extern CategoryAimbot m_aimbot;
extern CategoryVisuals m_visuals;
extern CategoryCommon m_common;
extern CategoryColors m_colors;

bool Load( const std::wstring& name );
bool Save( const std::wstring& name );

} // namespace options
```

`rust/rust.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{946F1633-F2E3-41A6-B7DB-70890015E1ED}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>rust</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\x64\</OutDir>
    <IntDir>$(SolutionDir)obj\$(ProjectName)\x64\release\</IntDir>
    <GenerateManifest>false</GenerateManifest>
    <EmbedManifest>false</EmbedManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>
      </SDLCheck>
      <PreprocessorDefinitions>NDEBUG;RUST_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <AdditionalIncludeDirectories>$(DXSDK_DIR)Include\;$(SolutionDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <DebugInformationFormat>None</DebugInformationFormat>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalLibraryDirectories>$(SolutionDir)bin\x64\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>horizon.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <AdditionalOptions>/EMITPOGOPHASEINFO %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;RUST_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;RUST_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;RUST_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main\entry.cpp" />
    <ClCompile Include="main\vcruntime.cpp" />
    <ClCompile Include="options\storage.cpp" />
    <ClCompile Include="rust\core.cpp" />
    <ClCompile Include="rust\features\aimbot.cpp" />
    <ClCompile Include="rust\features\user_interface.cpp" />
    <ClCompile Include="rust\features\visuals.cpp" />
    <ClCompile Include="rust\hooks\dispatch_message.cpp" />
    <ClCompile Include="rust\hooks\is_admin.cpp" />
    <ClCompile Include="rust\hooks\present.cpp" />
    <ClCompile Include="rust\hooks\resize_buffers.cpp" />
    <ClCompile Include="rust\il2cpp.cpp" />
    <ClCompile Include="unity\engine\math.cpp" />
    <ClCompile Include="unity\engine\matrix4x4.cpp" />
    <ClCompile Include="unity\engine\vector2.cpp" />
    <ClCompile Include="unity\engine\vector3.cpp" />
    <ClCompile Include="unity\il2cpp\il2cpp-api.cpp" />
    <ClCompile Include="unity\object\unity_engine.cpp" />
    <ClCompile Include="unity\sdk.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="options\storage.hpp" />
    <ClInclude Include="rust\core.hpp" />
    <ClInclude Include="rust\features\aimbot.hpp" />
    <ClInclude Include="rust\features\user_interface.hpp" />
    <ClInclude Include="rust\features\visuals.hpp" />
    <ClInclude Include="rust\hooks\dispatch_message.hpp" />
    <ClInclude Include="rust\hooks\is_admin.hpp" />
    <ClInclude Include="rust\hooks\present.hpp" />
    <ClInclude Include="rust\hooks\resize_buffers.hpp" />
    <ClInclude Include="rust\il2cpp.hpp" />
    <ClInclude Include="rust\steam.hpp" />
    <ClInclude Include="unity\engine\math.hpp" />
    <ClInclude Include="unity\engine\matrix4x4.hpp" />
    <ClInclude Include="unity\engine\vector2.hpp" />
    <ClInclude Include="unity\engine\vector3.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-api-functions.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-api-types.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-api.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-blob.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-class-internals.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-config.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-config-api.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-metadata.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-object-internals.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-runtime-metadata.hpp" />
    <ClInclude Include="unity\object\rust.hpp" />
    <ClInclude Include="unity\object\unity_engine.hpp" />
    <ClInclude Include="unity\sdk.hpp" />
    <ClInclude Include="unity\object\system.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`rust/rust.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="main\entry.cpp" />
    <ClCompile Include="unity\sdk.cpp" />
    <ClCompile Include="main\vcruntime.cpp" />
    <ClCompile Include="rust\core.cpp" />
    <ClCompile Include="unity\il2cpp\il2cpp-api.cpp" />
    <ClCompile Include="rust\hooks\resize_buffers.cpp" />
    <ClCompile Include="rust\hooks\present.cpp" />
    <ClCompile Include="rust\il2cpp.cpp" />
    <ClCompile Include="unity\engine\matrix4x4.cpp" />
    <ClCompile Include="unity\engine\vector2.cpp" />
    <ClCompile Include="unity\engine\vector3.cpp" />
    <ClCompile Include="unity\engine\math.cpp" />
    <ClCompile Include="options\storage.cpp" />
    <ClCompile Include="rust\features\visuals.cpp" />
    <ClCompile Include="rust\features\aimbot.cpp" />
    <ClCompile Include="rust\features\user_interface.cpp" />
    <ClCompile Include="rust\hooks\dispatch_message.cpp" />
    <ClCompile Include="unity\object\unity_engine.cpp" />
    <ClCompile Include="rust\hooks\is_admin.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="unity\sdk.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-api-types.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-blob.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-config.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-config-api.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-metadata.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-object-internals.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-runtime-metadata.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-class-internals.hpp" />
    <ClInclude Include="rust\core.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-api.hpp" />
    <ClInclude Include="unity\il2cpp\il2cpp-api-functions.hpp" />
    <ClInclude Include="rust\hooks\resize_buffers.hpp" />
    <ClInclude Include="rust\hooks\present.hpp" />
    <ClInclude Include="rust\il2cpp.hpp" />
    <ClInclude Include="unity\engine\vector2.hpp" />
    <ClInclude Include="unity\engine\vector3.hpp" />
    <ClInclude Include="unity\engine\matrix4x4.hpp" />
    <ClInclude Include="unity\engine\math.hpp" />
    <ClInclude Include="options\storage.hpp" />
    <ClInclude Include="rust\features\visuals.hpp" />
    <ClInclude Include="rust\features\aimbot.hpp" />
    <ClInclude Include="rust\features\user_interface.hpp" />
    <ClInclude Include="rust\hooks\dispatch_message.hpp" />
    <ClInclude Include="rust\steam.hpp" />
    <ClInclude Include="unity\object\system.hpp" />
    <ClInclude Include="unity\object\unity_engine.hpp" />
    <ClInclude Include="unity\object\rust.hpp" />
    <ClInclude Include="rust\hooks\is_admin.hpp" />
  </ItemGroup>
</Project>
```

`rust/rust.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`rust/rust/core.cpp`:

```cpp
#include "core.hpp"
#include "il2cpp.hpp"

#include "hooks/dispatch_message.hpp"
#include "hooks/present.hpp"
#include "hooks/resize_buffers.hpp"

#include "features/aimbot.hpp"
#include "features/user_interface.hpp"
#include "features/visuals.hpp"

namespace rust
{

std::uintptr_t m_unity_player = 0;
std::uintptr_t m_game_assembly = 0;
std::uintptr_t m_game_overlay_renderer = 0;

D3D11SwapChain* m_d3d11_swap_chain = nullptr;
IDXGISwapChain* m_swap_chain = nullptr;

SteamUser32* m_steam_user32 = nullptr;

memory::VFTableHook::Unique m_swap_chain_hook = { };

std::uintptr_t m_dispatch_message = 0;

std::uintptr_t m_present = 0;
std::uintptr_t m_resize_buffers = 0;

SteamUser32* GetSteamUser32()
{
	const auto address = memory::ScanImage( m_game_overlay_renderer, SECURE( "80 3D ? ? ? ? ? 74 10 8D 41 F0" ) );

	if( !memory::IsAddressValid( address ) )
	{
		TRACE( "%s: memory::ScanImage( ... ) error!", ATOM_FUNCTION );
		return nullptr;
	}

	const auto user32 = memory::GetAbsoluteAddress( address, 2 ) + 1;

	if( !memory::IsAddressValid( user32 ) )
	{
		TRACE( "%s: memory::GetAbsoluteAddress( 0x%016llX, 2 ) error!", ATOM_FUNCTION, address );
		return nullptr;
	}

	return reinterpret_cast< SteamUser32* >( user32 );
}

bool Create()
{
	auto& renderer = graphics::Renderer::Instance();

	auto& aimbot = features::Aimbot::Instance();
	auto& user_interface = features::UserInterface::Instance();
	auto& visuals = features::Visuals::Instance();

	m_unity_player = win32::GetImage( HASH( L"UnityPlayer.dll" ) );

	if( !memory::IsAddressValid( m_unity_player ) )
	{
		TRACE( "%s: win32::GetImage( ... ) error!", ATOM_FUNCTION );
		return false;
	}

	m_game_assembly = win32::GetImage( HASH( L"GameAssembly.dll" ) );

	if( !memory::IsAddressValid( m_game_assembly ) )
	{
		TRACE( "%s: win32::GetImage( ... ) error!", ATOM_FUNCTION );
		return false;
	}

	m_game_overlay_renderer = win32::GetImage( HASH( L"GameOverlayRenderer64.dll" ) );

	if( !memory::IsAddressValid( m_game_overlay_renderer ) )
	{
		TRACE( "%s: win32::GetImage( ... ) error!", ATOM_FUNCTION );
		return false;
	}

	if( !CreateIL2CPP() )
	{
		TRACE( "%s: CreateIL2CPP() error!", ATOM_FUNCTION );
		return false;
	}

	m_d3d11_swap_chain = GetD3D11SwapChain();

	if( !memory::IsAddressValid( m_d3d11_swap_chain ) )
	{
		TRACE( "%s: GetD3D11SwapChain() error!", ATOM_FUNCTION );
		return false;
	}

	m_swap_chain = m_d3d11_swap_chain->GetSwapChain();

	if( !memory::IsAddressValid( m_swap_chain ) )
	{
		TRACE( "%s: D3D11SwapChain::GetSwapChain() error!", ATOM_FUNCTION );
		return false;
	}

	m_steam_user32 = GetSteamUser32();

	if( !memory::IsAddressValid( m_steam_user32 ) )
	{
		TRACE( "%s: GetSteamUser32() error!", ATOM_FUNCTION );
		return false;
	}

	if( !renderer.Create( m_swap_chain ) )
	{
		TRACE( "%s: Renderer::Create( ... ) error!", ATOM_FUNCTION );
		return false;
	}

	if( !user_interface.Create() )
	{
		TRACE( "%s: UserInterface::Create() error!", ATOM_FUNCTION );
		return false;
	}

	m_dispatch_message = m_steam_user32->DispatchMessageA;
	
	if( memory::IsAddressValid( m_dispatch_message ) )
	{
		// 
		// hook pointer in GameOverlayRenderer64.dll
		// 
		m_steam_user32->DispatchMessageA = memory::ToAddress( &hooks::DispatchMessageA );
	}

	m_swap_chain_hook = std::make_unique< memory::VFTableHook >( m_swap_chain );

	if( m_swap_chain_hook )
	{
		m_present = m_swap_chain_hook->Get< 8 >();
		m_resize_buffers = m_swap_chain_hook->Get< 13 >();

		m_swap_chain_hook->Hook( &hooks::Present, 8 );
		m_swap_chain_hook->Hook( &hooks::ResizeBuffers, 13 );
	}

	return true;
}

void Destroy()
{
	auto& renderer = graphics::Renderer::Instance();

	if( memory::IsAddressValid( m_steam_user32 ) )
	{
		// 
		// restore pointer in GameOverlayRenderer64.dll
		// 
		m_steam_user32->DispatchMessageA = m_dispatch_message;
		m_steam_user32 = nullptr;
	}

	m_swap_chain_hook.reset();

	renderer.Destroy();

	m_swap_chain = nullptr;
	m_d3d11_swap_chain = nullptr;
	m_game_assembly = 0;
	m_unity_player = 0;
}

D3D11SwapChain* GetD3D11SwapChain()
{
	const auto address = memory::ScanImage( m_unity_player, SECURE( "48 8B 3D ? ? ? ? 45 8B E1 48 8B CF" ) );

	if( !memory::IsAddressValid( address ) )
	{
		TRACE( "%s: memory::ScanImage( ... ) error!", ATOM_FUNCTION );
		return nullptr;
	}

	const auto pointer = memory::GetAbsoluteAddress( address, 3 );

	if( !memory::IsAddressValid( pointer ) )
	{
		TRACE( "%s: memory::GetAbsoluteAddress( ... ) error!", ATOM_FUNCTION );
		return nullptr;
	}

	return memory::Dereference< D3D11SwapChain* >( pointer );
}

const Il2CppClass* FindClass( const Il2CppImage* image, const char* name_space, const char* name )
{
	return il2cpp_class_from_name( image, name_space, name );
}

const Il2CppClass* FindClass( const char* name_space, const char* name )
{
	const auto domain = il2cpp_domain_get();
	
	if( memory::IsAddressValid( domain ) )
	{
		std::size_t count = 0;
		const auto assemblies = il2cpp_domain_get_assemblies( domain, &count );
		
		if( memory::IsAddressValid( assemblies ) )
		{
			for( std::size_t index = 0; index < count; index++ )
			{
				const auto assembly = assemblies[ index ];

				if( memory::IsAddressValid( assembly ) )
				{
					const auto image = il2cpp_assembly_get_image( assembly );
					
					if( memory::IsAddressValid( image ) )
					{
						const auto instance = FindClass( image, name_space, name );

						if( memory::IsAddressValid( instance ) )
						{
							return instance;
						}
					}
				}
			}
		}
		else
		{
			TRACE( "%s: il2cpp_domain_get_assemblies( ... ) error!", ATOM_FUNCTION );
		}
	}
	else
	{
		TRACE( "%s: il2cpp_domain_get() error!", ATOM_FUNCTION );
	}

	return nullptr;
}

const FieldInfo* FindField( const Il2CppClass* object, std::uint64_t name_hash )
{
	auto super = object;

	while( memory::IsAddressValid( super ) )
	{
		auto iterator = static_cast< void* >( nullptr );
		auto field = il2cpp_class_get_fields( super, &iterator );

		while( memory::IsAddressValid( field ) )
		{
			const auto name = il2cpp_field_get_name( field );

			if( memory::IsAddressValid( name ) )
			{
				if( constant::Hash( name, true ) == name_hash )
				{
					return field;
				}
			}

			field = il2cpp_class_get_fields( super, &iterator );
		}

		super = super->parent;
	}

	return nullptr;
}

const PropertyInfo* FindProperty( const Il2CppClass* object, std::uint64_t name_hash )
{
	auto super = object;

	while( memory::IsAddressValid( super ) )
	{
		auto iterator = static_cast< void* >( nullptr );
		auto prop = il2cpp_class_get_properties( super, &iterator );

		while( memory::IsAddressValid( prop ) )
		{
			const auto name = il2cpp_property_get_name( prop );

			if( memory::IsAddressValid( name ) )
			{
				if( constant::Hash( name, true ) == name_hash )
				{
					return prop;
				}
			}

			prop = il2cpp_class_get_properties( super, &iterator );
		}

		super = super->parent;
	}

	return nullptr;
}

const MethodInfo* FindMethod( const Il2CppClass* object, std::uint64_t name_hash )
{
	return nullptr;
}

} // namespace rust

/*
class Aimbot : public core::Singleton< Aimbot >
{
public:
	void StepConstant( Vector3& rotation )
	{
		const auto pitch = 30.f;
		const auto yaw = 30.f;

		auto rotation_step = ( rotation - m_angles );
		// rotation_step.Normalize();

		if( pitch > 0.f )
		{
			auto factor_pitch = ( pitch / 100.f );

			if( rotation_step[ 0 ] < 0.f )
			{
				if( factor_pitch > std::abs( rotation_step[ 0 ] ) )
				{
					factor_pitch = std::abs( rotation_step[ 0 ] );
				}

				rotation[ 0 ] = m_angles[ 0 ] - factor_pitch;
			}
			else
			{
				if( factor_pitch > rotation_step[ 0 ] )
				{
					factor_pitch = rotation_step[ 0 ];
				}

				rotation[ 0 ] = m_angles[ 0 ] + factor_pitch;
			}
		}

		if( yaw > 0.f )
		{
			auto factor_yaw = ( yaw / 100.f );

			if( rotation_step[ 1 ] < 0.f )
			{
				if( factor_yaw > std::abs( rotation_step[ 1 ] ) )
				{
					factor_yaw = std::abs( rotation_step[ 1 ] );
				}

				rotation[ 1 ] = m_angles[ 1 ] - factor_yaw;
			}
			else
			{
				if( factor_yaw > rotation_step[ 1 ] )
				{
					factor_yaw = rotation_step[ 1 ];
				}

				rotation[ 1 ] = m_angles[ 1 ] + factor_yaw;
			}
		}
	}

	void StepDecreasing( Vector3& rotation )
	{
		const auto pitch = 8.f;
		const auto yaw = 8.f;

		auto rotation_step = ( rotation - m_angles );
		rotation_step.Normalize();

		if( pitch > 0.f )
		{
			rotation[ 0 ] = m_angles[ 0 ] + ( rotation_step[ 0 ] / pitch );
		}

		if( yaw > 0.f )
		{
			rotation[ 1 ] = m_angles[ 1 ] + ( rotation_step[ 1 ] / yaw );
		}
	}

	bool Execute( Camera* camera, BasePlayer* player, BasePlayer* target )
	{
		if( !win32::GetAsyncKeyState( VK_CAPITAL ) )
		{
			return false;
		}

		m_camera = camera;

		if( !memory::IsAddressValid( m_camera ) )
		{
			return false;
		}

		m_player = player;

		if( !memory::IsAddressValid( m_player ) )
		{
			return false;
		}

		auto input = m_player->input();

		if( !memory::IsAddressValid( input ) )
		{
			return false;
		}

		m_item = m_player->GetActiveItem();

		if( !memory::IsAddressValid( m_item ) )
		{
			return false;
		}

		const auto item_info = m_item->info();

		if( memory::IsAddressValid( item_info ) )
		{
			const auto item_name = item_info->shortname();

			if( memory::IsAddressValid( item_name ) )
			{
				auto speed = 250.f;

				switch( constant::Hash( item_name->c_str(), true ) )
				{
					case HASH( L"rifle.bolt" ):
					{
						speed = 656.25f;
						break;
					}
					case HASH( L"rifle.ak" ):
					case HASH( L"rifle.lr300" ):
					case HASH( L"rifle.semiauto" ):
					{
						speed = 375.f;
						break;
					}
					case HASH( L"smg.thompson" ):
					{
						speed = 300.f;
						break;
					}
					case HASH( L"smg.2" ):
					{
						speed = 240.f;
						break;
					}
					case HASH( L"smg.mp5" ):
					{
						speed = 180.f;
						break;
					}
					case HASH( L"pistol.m92" ):
					case HASH( L"pistol.semiauto" ):
					case HASH( L"pistol.python" ):
					{
						speed = 300.f;
						break;
					}
					case HASH( L"crossbow" ):
					{
						speed = 75.f;
						break;
					}
					case HASH( L"bow.hunting" ):
					{
						speed = 50.f;
						break;
					}
					default:
					{
						break;
					}
				}

				auto target_transform = target->get_transform();

				if( memory::IsAddressValid( target_transform ) )
				{
					auto player_transform = m_player->get_transform();
					auto camera_position = camera->get_position();

					// 
					// aim bone - 37 (head)
					// 
					auto position = target->GetBone( 37 );

					Vector3 output = { };
					if( camera->WorldToScreen( position, output ) )
					{
						const auto& io = ImGui::GetIO();
						Vector3 center( io.DisplaySize[ 0 ] * 0.5f, io.DisplaySize[ 1 ] * 0.5f, 0.f );

						const auto fov = center.Distance2D( output );

						if( fov < 15.f )
						{
							auto distance = camera_position.Distance( position );

							if( distance > 0.f )
							{
								auto time = ( distance / speed );
								auto acceleration = target->GetVelocity();

								// 
								// player movement prediction
								// 
								position[ 0 ] += acceleration[ 0 ] * time;
								position[ 2 ] += acceleration[ 2 ] * time;

								constexpr auto gravity = 9.81f;
								const auto drop = 0.5f * gravity * time * time;

								// 
								// bullet drop prediction
								// 
								position[ 1 ] += drop;
							}

							auto direction = camera_position - position;
							auto angles = direction.ToEulerAngles();
							NormalizeAngles( angles );

							if( memory::IsAddressValid( input ) )
							{
								// 
								// rcs
								// 
								const auto recoil = input->recoilAngles();
								angles[ 0 ] -= recoil[ 0 ];
								angles[ 1 ] -= recoil[ 1 ];

								// 
								// smooth
								// 
								// StepConstant( angles );

								input->SetViewVars( angles );
							}
						}
					}
				}
			}
		}

		return true;
	}

protected:
	Camera* m_camera = nullptr;
	BasePlayer* m_player = nullptr;
	Vector3 m_angles = { };
	Item* m_item = nullptr;

	BasePlayer* m_target_player = nullptr;
	float m_target_radius = 0.f;
	float m_target_distance = 0.f;
	Vector3 m_target_position = { };
};

void DumpEntities()
{
	const auto client_entities = BaseNetworkable::clientEntities();

	if( !memory::IsAddressValid( client_entities ) )
	{
		return;
	}

	const auto entity_list = client_entities->entityList();
	
	if( !memory::IsAddressValid( entity_list ) )
	{
		return;
	}

	const auto entities = entity_list->vals;
	
	if( !memory::IsAddressValid( entities ) )
	{
		return;
	}

	if( !memory::IsAddressValid( entities->buffer ) )
	{
		return;
	}

	const auto camera = UnityEngine::Camera::get_main();
	TRACE( "camera = '0x%016llX'", memory::ToAddress( camera ) );

	for( std::int32_t index = 0; index < entities->count; index++ )
	{
		const auto entity = entities->buffer->m_Items[ index ];

		if( memory::IsAddressValid( entity ) )
		{
			const auto transform = entity->get_transform();

			if( memory::IsAddressValid( transform ) )
			{
				const auto position = transform->get_position();

				if( entity->IsA( BasePlayer::StaticClass() ) )
				{
					const auto base_player = static_cast< BasePlayer* >( entity );
					const auto name = base_player->get_displayName();
					const auto health = base_player->get_health();

					if( memory::IsAddressValid( name ) )
					{
						TRACE( L"[%04d] '%s' | '%f' | '%f, %f, %f'", index, name->c_str(), health, position[ 0 ], position[ 1 ], position[ 2 ] );
					}
				}
				else if( entity->IsA( ResourceEntity::StaticClass() ) )
				{
					const auto name = entity->klass->name;
					
					if( memory::IsAddressValid( name ) )
					{
						TRACE( "[%04d] '%s' | '%f, %f, %f'", index, name, position[ 0 ], position[ 1 ], position[ 2 ] );
					}
				}
			}
		}
	}
}

void RenderBones( UnityEngine::Camera* camera, BasePlayer* base_player )
{
	auto& renderer = graphics::Renderer::Instance();

	for( std::size_t index = 0; index < base_player->GetBoneCount(); index++ )
	{
		const auto parent = base_player->GetBoneParent( index );

		if( parent != -1 )
		{
			const auto bone = base_player->GetBone( index );
			const auto bone_parent = base_player->GetBone( parent );

			UnityEngine::Vector3 screen = { };
			UnityEngine::Vector3 screen_parent = { };

			if( camera->WorldToScreen( bone, screen ) && camera->WorldToScreen( bone_parent, screen_parent ) )
			{
				renderer.DrawLine( { screen[ 0 ], screen[ 1 ] }, { screen_parent[ 0 ], screen_parent[ 1 ] }, Color::White() );
			}
		}
	}
}

void Simulate( Camera* camera, BasePlayer* player, Vector3& position )
{
	auto speed = 300.f;

	auto camera_position = camera->get_position();
	// auto position = player->GetBone( 37 );

	auto distance = camera_position.Distance( position );

	if( distance > 0.f )
	{
		auto time = ( distance / speed );
		auto acceleration = player->GetVelocity();

		if( acceleration.Length() > 0.f )
		{
			// TRACE( "acceleration = '%f, %f, %f'", acceleration[ 0 ], acceleration[ 1 ], acceleration[ 2 ] );

			position[ 0 ] += acceleration[ 0 ] * time;
			position[ 1 ] += acceleration[ 1 ] * time;
			position[ 2 ] += acceleration[ 2 ] * time;
		}

		constexpr auto gravity = 9.81f;
		const auto drop = 0.5f * gravity * time * time;

		position[ 1 ] += drop;
	}
}

bool GetBox( UnityEngine::Camera* camera, BasePlayer* base_player, ImVec4& box )
{
	auto& renderer = graphics::Renderer::Instance();

	const auto transform = base_player->get_transform();

	if( !memory::IsAddressValid( transform ) )
	{
		return false;
	}

	const auto model = base_player->playerModel();

	if( !memory::IsAddressValid( model ) )
	{
		return false;
	}

	const auto collision = model->collision();

	if( !memory::IsAddressValid( collision ) )
	{
		return false;
	}

	const auto& bound = base_player->bounds();

	const auto center = bound.m_Center;
	const auto extents = bound.m_Extents;

	const UnityEngine::Vector3 mins =
	{
		-( extents[ 0 ] ),
		-( extents[ 1 ] ),
		-( extents[ 2 ] ),
	};

	const UnityEngine::Vector3 maxs =
	{
		( extents[ 0 ] ),
		( extents[ 1 ] ),
		( extents[ 2 ] ),
	};

	UnityEngine::Vector3 corners[ 8 ] =
	{
		{ mins[ 0 ], mins[ 1 ], mins[ 2 ] },
		{ mins[ 0 ], maxs[ 1 ], mins[ 2 ] },
		{ maxs[ 0 ], maxs[ 1 ], mins[ 2 ] },
		{ maxs[ 0 ], mins[ 1 ], mins[ 2 ] },
		{ maxs[ 0 ], maxs[ 1 ], maxs[ 2 ] },
		{ mins[ 0 ], maxs[ 1 ], maxs[ 2 ] },
		{ mins[ 0 ], mins[ 1 ], maxs[ 2 ] },
		{ maxs[ 0 ], mins[ 1 ], maxs[ 2 ] },
	};

	const auto angles = transform->get_eulerAngles();
	
	auto position = transform->get_position();
	Simulate( camera, base_player, position );

	const auto viewport = renderer.GetViewport();

	box.x = viewport.Width;
	box.y = viewport.Height;
	box.z = -1.f;
	box.w = -1.f;

	const auto yaw = ToRadians( angles[ 1 ] );
	
	const auto sine = -win32::sin( yaw );
	const auto cosine = win32::cos( yaw );

	for( const auto& corner : corners )
	{
		UnityEngine::Vector3 p =
		{
			( position[ 0 ] + center[ 0 ] + ( corner[ 0 ] * cosine - corner[ 2 ] * sine ) ),
			( position[ 1 ] + center[ 1 ] + ( corner[ 1 ] ) ),
			( position[ 2 ] + center[ 2 ] + ( corner[ 0 ] * sine + corner[ 2 ] * cosine ) ),
		};

		UnityEngine::Vector3 screen = { };

		if( !camera->WorldToScreen( p, screen ) )
		{
			return false;
		}

		box.x = std::min( box.x, screen.x );
		box.y = std::min( box.y, screen.y );

		box.z = std::max( box.z, screen.x );
		box.w = std::max( box.w, screen.y );
	}

	return true;
}

void RenderEntities()
{
	auto& aimbot = Aimbot::Instance();
	auto& renderer = graphics::Renderer::Instance();

	const auto client_entities = BaseNetworkable::clientEntities();

	if( !memory::IsAddressValid( client_entities ) )
	{
		return;
	}

	const auto entity_list = client_entities->entityList();

	if( !memory::IsAddressValid( entity_list ) )
	{
		return;
	}

	const auto entities = entity_list->vals;

	if( !memory::IsAddressValid( entities ) )
	{
		return;
	}

	if( !memory::IsAddressValid( entities->buffer ) )
	{
		return;
	}

	const auto camera = UnityEngine::Camera::get_current();

	static BasePlayer* player = nullptr;
	
	for( std::int32_t index = 0; index < entities->count; index++ )
	{
		const auto entity = entities->buffer->m_Items[ index ];

		if( memory::IsAddressValid( entity ) )
		{
			const auto transform = entity->get_transform();

			if( memory::IsAddressValid( transform ) )
			{
				const auto position = transform->get_position();

				UnityEngine::Vector3 screen = { };

				if( camera->WorldToScreen( position, screen ) )
				{
					if( entity->IsA( BasePlayer::StaticClass() ) )
					{
						const auto base_player = static_cast< BasePlayer* >( entity );

						const auto name = base_player->get_displayName();
						const auto health = base_player->get_health();

						if( memory::IsAddressValid( name ) )
						{
							char display[ 256 ] = { };
							win32::sprintf_s( display, sizeof( display ), SECURE( "[%S]" ), name->c_str() );

							if( base_player->IsLocalPlayer() )
							{
								player = base_player;
							}
							else
							{
								if( memory::IsAddressValid( player ) )
								{
									aimbot.Execute( camera, player, base_player );
								}
							}

							RenderBones( camera, base_player );

							ImVec4 box = { };

							if( GetBox( camera, base_player, box ) )
							{
								const auto width = box.z - box.x;
								const auto height = box.w - box.y;

								renderer.DrawBoxBorder( { box.x, box.y }, { width, height }, 1.f, Color::Cyan() );
								renderer.DrawTextShadow( { box.x + width * 0.5f, box.y + height + 2.f }, TextCenterH, Color::Cyan(), display );
								renderer.DrawTextShadow( { box.x + width * 0.5f, box.y + height + 14.f + 2.f }, TextCenterH, Color::White(), SECURE( "[%.2fm]" ), position.Distance( camera->get_position() ) );

								const auto item = base_player->GetActiveItem();

								if( memory::IsAddressValid( item ) )
								{
									const auto info = item->info();

									if( memory::IsAddressValid( info ) )
									{
										const auto item_name = info->shortname();

										if( memory::IsAddressValid( item_name ) )
										{
											std::memset( display, 0, sizeof( display ) );
											win32::sprintf_s( display, sizeof( display ), SECURE( "[%S]" ), item_name->c_str() );
											renderer.DrawTextShadow( { box.x + width * 0.5f, box.y + height + 28.f + 2.f }, TextCenterH, Color::White(), display );
										}
									}
								}
							}
						}
					}
					else if( !entity->IsA( BuildingBlock::StaticClass() ) )
					{
						auto color = Color::White();

						if( entity->IsA( BoxStorage::StaticClass() ) )
						{
							color = Color( 1.f, 0.f, 0.f );
						}
						else if( entity->IsA( GunTrap::StaticClass() ) )
						{
							color = Color( 0.f, 1.f, 1.f );
						}
						else if( entity->IsA( BearTrap::StaticClass() ) )
						{
							color = Color( 1.f, 1.f, 0.f );
						}
						else if( entity->IsA( VendingMachineMapMarker::StaticClass() ) )
						{
							color = Color( 0.f, 0.5f, 0.2f );
						}
						else if( entity->IsA( StashContainer::StaticClass() ) )
						{
							color = Color( 1.f, 0.f, 0.f );
						}
						else if( entity->IsA( BuildingPrivlidge::StaticClass() ) )
						{
							color = Color( 1.f, 0.5f, 0.f );
						}
						else if( entity->IsA( Workbench::StaticClass() ) )
						{
							color = Color( 0.f, 0.05f, 1.f );
						}
						else if( entity->IsA( BaseOven::StaticClass() ) )
						{
							color = Color( 0.5f, 0.f, 1.f );
						}
						else if( entity->IsA( ResearchTable::StaticClass() ) )
						{
							color = Color( 1.f, 0.f, 1.f );
						}
						else if( entity->IsA( DroppedItem::StaticClass() ) )
						{
							color = Color( 1.f, 0.f, 0.f );
						}
						else if( entity->IsA( PlayerCorpse::StaticClass() ) )
						{
							color = Color( 1.f, 1.f, 1.f );
						}
						else if( entity->IsA( OreHotSpot::StaticClass() ) )
						{
							color = Color( 1.f, 0.33f, 1.f );
						}
						else
						{
							continue;
						}

						const auto name = entity->klass->name;

						if( memory::IsAddressValid( name ) )
						{
							renderer.DrawTextShadow( { screen[ 0 ], screen[ 1 ] }, TextLeft, color, SECURE( "[%s]" ), name );
						}
					}
				}
			}
		}
	}
}*/
```

`rust/rust/core.hpp`:

```hpp
#pragma once

#include "../unity/sdk.hpp"

#include "steam.hpp"

namespace rust
{

extern std::uintptr_t m_unity_player;
extern std::uintptr_t m_game_assembly;
extern std::uintptr_t m_game_overlay_renderer;

extern D3D11SwapChain* m_d3d11_swap_chain;
extern IDXGISwapChain* m_swap_chain;

extern SteamUser32* m_steam_user32;

extern memory::VFTableHook::Unique m_swap_chain_hook;

extern std::uintptr_t m_dispatch_message;

extern std::uintptr_t m_present;
extern std::uintptr_t m_resize_buffers;

bool Create();
void Destroy();

D3D11SwapChain* GetD3D11SwapChain();

} // namespace rust

void DumpEntities();
void RenderEntities();
```

`rust/rust/features/aimbot.cpp`:

```cpp
#include "aimbot.hpp"

#include "../../options/storage.hpp"

float DirectionToRadius( const Vector3& angles, const Vector3& begin, const Vector3& end )
{
	auto direction = ( end - begin );
	direction.Normalize();

	auto forward = angles.ToVector();
	forward.Normalize();

	const auto dot = std::clamp( forward.Dot( direction ), -1.f, 1.f );
	return UnityEngine::ToDegrees( win32::acos( dot ) );
}

namespace rust::features
{

void Aimbot::Execute( BasePlayer* player )
{
	const auto& general = options::m_aimbot.m_general;
	const auto& accuracy = options::m_aimbot.m_accuracy;
	const auto& step = options::m_aimbot.m_step;
	const auto& time = options::m_aimbot.m_time;

	if( !general.m_mode )
	{
		return;
	}

	auto client_entities = BaseNetworkable::clientEntities();

	if( !memory::IsAddressValid( client_entities ) )
	{
		return;
	}

	auto entities = client_entities->entityList();

	if( !memory::IsAddressValid( entities ) )
	{
		return;
	}

	m_entities = entities->vals;

	if( !memory::IsAddressValid( m_entities ) )
	{
		return;
	}

	m_entity_array = m_entities->buffer;

	if( !memory::IsAddressValid( m_entity_array ) )
	{
		return;
	}

	m_camera = Camera::get_current();

	if( !memory::IsAddressValid( m_camera ) )
	{
		return;
	}

	m_player = player;

	if( !memory::IsAddressValid( m_player ) )
	{
		return;
	}

	m_input = m_player->input();

	if( !memory::IsAddressValid( m_input ) )
	{
		return;
	}

	m_camera_angles = m_input->bodyAngles();
	m_camera_position = m_camera->get_position();

	if( general.m_mode == 2 )
	{
		if( !win32::GetAsyncKeyState( general.m_key ) )
		{
			m_target_cycle = true;
			m_target_timer.reset();
			return;
		}
	}

	if( m_target_cycle )
	{
		TargetUpdate();
	}

	if( TargetValidate( m_target_index ) )
	{
		if( time.m_delay )
		{
			if( m_target_timer.elapsed() < time.m_delay )
			{
				// 
				// delay before locking
				// 
				return;
			}
		}

		if( time.m_duration )
		{
			if( m_target_timer.elapsed() >= time.m_duration )
			{
				// 
				// release lock
				// 
				return;
			}
		}

		auto direction = ( m_target_position - m_camera_position );
		direction.Normalize();

		auto angles = direction.ToEulerAngles();
		UnityEngine::AnglesNormalize( angles );

		const auto& angles_recoil = m_input->recoilAngles();

		if( accuracy.m_pitch > 0.f )
		{
			angles[ 0 ] -= ( angles_recoil[ 0 ] * ( accuracy.m_pitch / 100.f ) );
		}

		if( accuracy.m_yaw > 0.f )
		{
			angles[ 1 ] -= ( angles_recoil[ 1 ] * ( accuracy.m_yaw / 100.f ) );
		}

		if( step.m_mode == 1 )
		{
			StepConstant( angles );
		}
		else if( step.m_mode == 2 )
		{
			StepDecreasing( angles );
		}

		UnityEngine::AnglesNormalize( angles );

		m_input->SetViewVars( angles );

		if( general.m_auto_fire )
		{

		}
	}
	else
	{
		if( general.m_auto_cycle )
		{
			if( time.m_cycle )
			{
				if( m_target_timer.elapsed() < time.m_cycle )
				{
					// 
					// delay before target update
					// 
					return;
				}
			}

			m_target_cycle = true;
		}
	}
}

bool Aimbot::TargetValidate( std::int32_t index )
{
	const auto& general = options::m_aimbot.m_general;
	const auto& target = options::m_aimbot.m_target;

	if( index < 0 || index >= m_entities->count )
	{
		return false;
	}

	const auto base_networkable = m_entity_array->m_Items[ index ];

	if( !memory::IsAddressValid( base_networkable ) )
	{
		return false;
	}

	if( !base_networkable->IsA( BasePlayer::StaticClass() ) )
	{
		return false;
	}

	const auto base_player = static_cast< BasePlayer* >( base_networkable );

	if( base_player->IsLocalPlayer() )
	{
		return false;
	}

	auto position = base_player->GetBone(target.m_bone);

	if (position.IsZero())
	{
		return false;
	}

	if (!UnityEngine::Physics::Raycast(m_camera_position, position))
	{
		return false;
	}

	TargetSimulate( base_player, position );

	const auto distance = m_camera_position.Distance( position );

	if( distance > target.m_distance )
	{
		return false;
	}

	m_target_distance = distance;

	const auto radius = DirectionToRadius( m_camera_angles, m_camera_position, position );

	if( radius >= target.m_radius )
	{
		return false;
	}

	m_target_radius = radius;
	m_target_position = position;

	return true;
}

void Aimbot::TargetUpdate()
{
	const auto& general = options::m_aimbot.m_general;
	const auto& target = options::m_aimbot.m_target;

	auto best_distance = std::numeric_limits< float >::max();

	if( target.m_priority == 1 )
	{
		// 
		// sort by distance
		// 
		best_distance = target.m_distance;
	}
	else if( target.m_priority == 2 )
	{
		// 
		// sort by radius
		// 
		best_distance = target.m_radius;
	}

	for( std::int32_t index = 0; index < m_entities->count; index++ )
	{
		if( TargetValidate( index ) )
		{
			if( target.m_priority == 0 )
			{
				// 
				// use any target
				// 
				m_target_cycle = false;
				m_target_index = index;
				break;
			}
			else if( target.m_priority == 1 )
			{
				// 
				// use nearest target
				// 
				if( m_target_distance < best_distance )
				{
					best_distance = m_target_distance;
					m_target_cycle = false;
					m_target_index = index;
				}
			}
			else if( target.m_priority == 2 )
			{
				// 
				// use target closest to crosshair
				// 
				if( m_target_radius < best_distance )
				{
					best_distance = m_target_radius;
					m_target_cycle = false;
					m_target_index = index;
				}
			}
		}
	}
}

void Aimbot::TargetSimulate( BasePlayer* base_player, Vector3& position )
{
	auto item = m_player->GetActiveItem();

	if( !memory::IsAddressValid( item ) )
	{
		return;
	}

	auto item_info = item->info();

	if( !memory::IsAddressValid( item_info ) )
	{
		return;
	}

	auto item_name = item_info->shortname();

	if( !memory::IsAddressValid( item_name ) )
	{
		return;
	}

	auto speed = 250.f;

	switch( constant::Hash( item_name->c_str(), true ) )
	{
		case HASH( L"rifle.bolt" ):
		{
			speed = 656.25f;
			break;
		}
		case HASH( L"rifle.ak" ):
		case HASH( L"rifle.lr300" ):
		case HASH( L"rifle.semiauto" ):
		{
			speed = 375.f;
			break;
		}
		case HASH( L"smg.thompson" ):
		{
			speed = 300.f;
			break;
		}
		case HASH( L"smg.2" ):
		{
			speed = 240.f;
			break;
		}
		case HASH( L"smg.mp5" ):
		{
			speed = 180.f;
			break;
		}
		case HASH( L"pistol.m92" ):
		case HASH( L"pistol.semiauto" ):
		case HASH( L"pistol.python" ):
		{
			speed = 300.f;
			break;
		}
		case HASH( L"crossbow" ):
		{
			speed = 75.f;
			break;
		}
		case HASH( L"bow.hunting" ):
		{
			speed = 55.f;
			break;
		}
		default:
		{
			break;
		}
	}

	auto distance = m_camera_position.Distance( position );

	if( distance > 0.f )
	{
		auto time = ( distance / speed );
		auto velocity = base_player->GetVelocity();

		position[ 0 ] += velocity[ 0 ] * time;
		position[ 1 ] += velocity[ 1 ] * time;
		position[ 2 ] += velocity[ 2 ] * time;

		constexpr auto gravity = 9.81f;
		const auto drop = 0.5f * gravity * time * time;

		position[ 1 ] += drop;
	}
}

std::int32_t Aimbot::GetTargetIndex() const
{
	return m_target_index;
}

void Aimbot::StepConstant( Vector3& angles )
{
	const auto& step = options::m_aimbot.m_step;

	auto angles_step = ( angles - m_camera_angles );
	UnityEngine::AnglesNormalize( angles_step );

	if( step.m_pitch > 0.f )
	{
		auto factor_pitch = ( step.m_pitch / 100.f );

		if( angles_step[ 0 ] < 0.f )
		{
			if( factor_pitch > std::abs( angles_step[ 0 ] ) )
			{
				factor_pitch = std::abs( angles_step[ 0 ] );
			}

			angles[ 0 ] = m_camera_angles[ 0 ] - factor_pitch;
		}
		else
		{
			if( factor_pitch > angles_step[ 0 ] )
			{
				factor_pitch = angles_step[ 0 ];
			}

			angles[ 0 ] = m_camera_angles[ 0 ] + factor_pitch;
		}
	}

	if( step.m_yaw > 0.f )
	{
		auto factor_yaw = ( step.m_yaw / 100.f );

		if( angles_step[ 1 ] < 0.f )
		{
			if( factor_yaw > std::abs( angles_step[ 1 ] ) )
			{
				factor_yaw = std::abs( angles_step[ 1 ] );
			}

			angles[ 1 ] = m_camera_angles[ 1 ] - factor_yaw;
		}
		else
		{
			if( factor_yaw > angles_step[ 1 ] )
			{
				factor_yaw = angles_step[ 1 ];
			}

			angles[ 1 ] = m_camera_angles[ 1 ] + factor_yaw;
		}
	}
}

void Aimbot::StepDecreasing( Vector3& angles )
{
	const auto& step = options::m_aimbot.m_step;

	auto angles_step = ( angles - m_camera_angles );
	UnityEngine::AnglesNormalize( angles_step );

	if( step.m_pitch > 0.f )
	{
		angles[ 0 ] = m_camera_angles[ 0 ] + ( angles_step[ 0 ] / step.m_pitch );
	}

	if( step.m_yaw > 0.f )
	{
		angles[ 1 ] = m_camera_angles[ 1 ] + ( angles_step[ 1 ] / step.m_yaw );
	}
}

} // namespace rust::features
```

`rust/rust/features/aimbot.hpp`:

```hpp
#pragma once

#include "../../unity/sdk.hpp"

#include "../../unity/object/rust.hpp"
#include "../../unity/object/system.hpp"
#include "../../unity/object/unity_engine.hpp"

namespace rust::features
{

class Aimbot : public core::Singleton< Aimbot >
{
public:
	void Execute( BasePlayer* player );

public:
	bool TargetValidate( std::int32_t index );
	void TargetUpdate();
	void TargetSimulate( BasePlayer* base_player, Vector3& position );

	std::int32_t GetTargetIndex() const;

protected:
	void StepConstant( Vector3& angles );
	void StepDecreasing( Vector3& angles );

protected:
	using EntityList = System::BufferList< BaseNetworkable* >;
	using EntityArray = System::Array< BaseNetworkable* >;

protected:
	EntityList* m_entities = nullptr;
	EntityArray* m_entity_array = nullptr;
	Camera* m_camera = nullptr;

	BasePlayer* m_player = nullptr;
	PlayerInput* m_input = nullptr;

	Vector3 m_camera_angles = { };
	Vector3 m_camera_position = { };

	bool m_target_cycle = true;
	std::int32_t m_target_index = -1;
	Vector3 m_target_position = { };
	float m_target_radius = 0.f;
	float m_target_distance = 0.f;
	core::Timer m_target_timer = { };
	BasePlayer* m_target_player = nullptr;
};

} // namespace rust::features
```

`rust/rust/features/user_interface.cpp`:

```cpp
#include "user_interface.hpp"
#include "../../options/storage.hpp"

namespace ImGui
{

bool g_key_waiting = false;
int* g_key_output = nullptr;

int TranslateMouseButton( ImGuiMouseButton button )
{
	switch( button )
	{
		case ImGuiMouseButton_Left:
		{
			return 1;
		}
		case ImGuiMouseButton_Right:
		{
			return 2;
		}
		case ImGuiMouseButton_Middle:
		{
			return 4;
		}
		case 3:
		{
			return 5;
		}
		case 4:
		{
			return 6;
		}
	}

	return 0;
}

void KeyBind( const char* label, int* key )
{
	if( !key )
	{
		return;
	}

	if( g_key_waiting )
	{
		for( auto index = 0; index < ImGuiMouseButton_COUNT; index++ )
		{
			if( ImGui::IsMouseReleased( index ) )
			{
				( *key ) = TranslateMouseButton( index );
				g_key_output = key;
				g_key_waiting = false;
				break;
			}
		}

		for( auto index = 0; index < 512; index++ )
		{
			if( ImGui::IsKeyReleased( index ) )
			{
				( *key ) = index;
				g_key_output = key;
				g_key_waiting = false;
				break;
			}
		}
	}

	auto key_code = g_map_data.NtUserMapVirtualKeyEx( *key, MAPVK_VK_TO_VSC_EX, 0, 0 );

	switch( *key )
	{
		case VK_LEFT: case VK_UP: case VK_RIGHT: case VK_DOWN:
		case VK_RCONTROL: case VK_RMENU:
		case VK_LWIN: case VK_RWIN: case VK_APPS:
		case VK_PRIOR: case VK_NEXT:
		case VK_END: case VK_HOME:
		case VK_INSERT: case VK_DELETE:
		case VK_DIVIDE:
		case VK_NUMLOCK:
		{
			key_code |= KF_EXTENDED;
			break;
		}
	}

	wchar_t wide_key_name[ 128 ] = { };
	g_map_data.NtUserGetKeyNameText( key_code << 16, wide_key_name, ARRAYSIZE( wide_key_name ) );

	char key_name[ 128 ] = { };
	win32::sprintf_s( key_name, ARRAYSIZE( key_name ), SECURE( "[%u] %ws" ), *key, wide_key_name );

	const char* text = nullptr;

	if( g_key_waiting && g_key_output == key )
	{
		text = "...";
	}
	else
	{
		text = key_name;
	}

	if( ImGui::Button( text, { -1.f, 0.f } ) )
	{
		g_key_output = key;
		g_key_waiting = true;
	}
}

} // namespace ImGui

namespace ImGui
{

void StyleColorsAtom( ImGuiStyle* dst = nullptr )
{
	auto style = dst ? dst : &ImGui::GetStyle();
	auto colors = style->Colors;

	style->WindowPadding = { 4.f, 4.f };
	style->FramePadding = { 4.f, 2.f };
	style->ItemSpacing = { 4.f, 4.f };
	style->ItemInnerSpacing = { 4.f, 4.f };
	style->TouchExtraPadding = { 0.f, 0.f };
	style->IndentSpacing = 30.f;
	style->ScrollbarSize = 10.f;
	style->GrabMinSize = 6.f;

	style->WindowBorderSize = 0.f;
	style->ChildBorderSize = 1.f;
	style->PopupBorderSize = 1.f;
	style->FrameBorderSize = 1.f;
	style->TabBorderSize = 1.f;

	style->WindowRounding = 0.f;
	style->ChildRounding = 0.f;
	style->FrameRounding = 0.f;
	style->PopupRounding = 0.f;
	style->ScrollbarRounding = 0.f;
	style->GrabRounding = 0.f;
	style->TabRounding = 0.f;

	colors[ ImGuiCol_Text ] = { 0.86f, 0.86f, 0.86f, 1.00f };
	colors[ ImGuiCol_TextDisabled ] = { 0.43f, 0.43f, 0.43f, 1.00f };
	colors[ ImGuiCol_WindowBg ] = { 0.16f, 0.16f, 0.16f, 1.00f };
	colors[ ImGuiCol_ChildBg ] = { 0.00f, 0.00f, 0.00f, 0.00f };
	colors[ ImGuiCol_PopupBg ] = { 0.08f, 0.08f, 0.08f, 0.94f };
	colors[ ImGuiCol_Border ] = { 0.31f, 0.31f, 0.31f, 1.00f };
	colors[ ImGuiCol_BorderShadow ] = { 0.00f, 0.00f, 0.00f, 0.00f };
	colors[ ImGuiCol_FrameBg ] = { 0.12f, 0.12f, 0.12f, 1.00f };
	colors[ ImGuiCol_FrameBgHovered ] = { 0.13f, 0.13f, 0.13f, 1.00f };
	colors[ ImGuiCol_FrameBgActive ] = { 0.15f, 0.15f, 0.15f, 1.00f };
	colors[ ImGuiCol_TitleBg ] = { 0.08f, 0.08f, 0.08f, 1.00f };
	colors[ ImGuiCol_TitleBgActive ] = { 0.09f, 0.09f, 0.09f, 1.00f };
	colors[ ImGuiCol_TitleBgCollapsed ] = { 0.11f, 0.11f, 0.11f, 1.00f };
	colors[ ImGuiCol_MenuBarBg ] = { 0.12f, 0.12f, 0.12f, 1.00f };
	colors[ ImGuiCol_ScrollbarBg ] = { 0.12f, 0.12f, 0.12f, 1.00f };
	colors[ ImGuiCol_ScrollbarGrab ] = { 0.75f, 0.37f, 0.37f, 1.00f };
	colors[ ImGuiCol_ScrollbarGrabHovered ] = { 0.78f, 0.41f, 0.41f, 1.00f };
	colors[ ImGuiCol_ScrollbarGrabActive ] = { 0.82f, 0.45f, 0.45f, 1.00f };
	colors[ ImGuiCol_CheckMark ] = { 0.75f, 0.37f, 0.37f, 1.00f };
	colors[ ImGuiCol_SliderGrab ] = { 0.75f, 0.37f, 0.37f, 1.00f };
	colors[ ImGuiCol_SliderGrabActive ] = { 0.82f, 0.45f, 0.45f, 1.00f };
	colors[ ImGuiCol_Button ] = { 0.14f, 0.14f, 0.14f, 1.00f };
	colors[ ImGuiCol_ButtonHovered ] = { 0.75f, 0.37f, 0.37f, 1.00f };
	colors[ ImGuiCol_ButtonActive ] = { 0.78f, 0.41f, 0.41f, 1.00f };
	colors[ ImGuiCol_Header ] = { 0.14f, 0.14f, 0.14f, 1.00f };
	colors[ ImGuiCol_HeaderHovered ] = { 0.75f, 0.37f, 0.37f, 1.00f };
	colors[ ImGuiCol_HeaderActive ] = { 0.78f, 0.41f, 0.41f, 1.00f };
	colors[ ImGuiCol_Separator ] = { 0.43f, 0.43f, 0.50f, 0.50f };
	colors[ ImGuiCol_SeparatorHovered ] = { 0.10f, 0.40f, 0.75f, 0.78f };
	colors[ ImGuiCol_SeparatorActive ] = { 0.10f, 0.40f, 0.75f, 1.00f };
	colors[ ImGuiCol_ResizeGrip ] = { 0.26f, 0.59f, 0.98f, 0.25f };
	colors[ ImGuiCol_ResizeGripHovered ] = { 0.26f, 0.59f, 0.98f, 0.67f };
	colors[ ImGuiCol_ResizeGripActive ] = { 0.26f, 0.59f, 0.98f, 0.95f };
	colors[ ImGuiCol_Tab ] = { 0.18f, 0.35f, 0.58f, 0.86f };
	colors[ ImGuiCol_TabHovered ] = { 0.26f, 0.59f, 0.98f, 0.80f };
	colors[ ImGuiCol_TabActive ] = { 0.20f, 0.41f, 0.68f, 1.00f };
	colors[ ImGuiCol_TabUnfocused ] = { 0.07f, 0.10f, 0.15f, 0.97f };
	colors[ ImGuiCol_TabUnfocusedActive ] = { 0.14f, 0.26f, 0.42f, 1.00f };
	colors[ ImGuiCol_PlotLines ] = { 0.61f, 0.61f, 0.61f, 1.00f };
	colors[ ImGuiCol_PlotLinesHovered ] = { 1.00f, 0.43f, 0.35f, 1.00f };
	colors[ ImGuiCol_PlotHistogram ] = { 0.90f, 0.70f, 0.00f, 1.00f };
	colors[ ImGuiCol_PlotHistogramHovered ] = { 1.00f, 0.60f, 0.00f, 1.00f };
	colors[ ImGuiCol_TextSelectedBg ] = { 0.78f, 0.41f, 0.41f, 1.00f };
	colors[ ImGuiCol_DragDropTarget ] = { 1.00f, 1.00f, 0.00f, 0.90f };
	colors[ ImGuiCol_NavHighlight ] = { 0.26f, 0.59f, 0.98f, 1.00f };
	colors[ ImGuiCol_NavWindowingHighlight ] = { 1.00f, 1.00f, 1.00f, 0.70f };
	colors[ ImGuiCol_NavWindowingDimBg ] = { 0.80f, 0.80f, 0.80f, 0.20f };
	colors[ ImGuiCol_ModalWindowDimBg ] = { 0.80f, 0.80f, 0.80f, 0.35f };
}

bool Items_VectorGetter( void* data, int n, const char** out_text )
{
	const auto& v = *static_cast< const std::vector< std::string >* >( data );
	*out_text = v[ n ].c_str();
	return true;
}

bool Combo( const char* label, int* current_item, std::vector< std::string >& items, int popup_max_height_in_items = -1 )
{
	return ImGui::Combo( label, current_item, Items_VectorGetter,
											 &items, static_cast< int >( items.size() ),
											 popup_max_height_in_items );
}

} // namespace ImGui

namespace rust::features
{

UserInterface::~UserInterface()
{
	Destroy();
}

bool UserInterface::Create()
{
	auto& input_manager = win32::InputManager::Instance();

	if( !input_manager.RegisterEvent( HASH( L"UserInterface::MessageEvent" ), &MessageEvent ) )
	{
		TRACE( "%s: InputManager::RegisterEvent( ... ) error!", ATOM_FUNCTION );
		return false;
	}

	ImGui::StyleColorsAtom();
	return true;
}

void UserInterface::Destroy()
{
	m_state = false;
}

void UserInterface::Present()
{
	auto& io = ImGui::GetIO();
	io.MouseDrawCursor = m_state;

	if( m_state )
	{
		const ImVec2 screen_size( io.DisplaySize );
		const ImVec2 screen_center( screen_size[ 0 ] * 0.5f, screen_size[ 1 ] * 0.5f );

		const ImVec2 window_size( 540.f, 320.f );
		const ImVec2 window_center( screen_center[ 0 ] - ( window_size[ 0 ] * 0.5f ), screen_center[ 1 ] - ( window_size[ 1 ] * 0.5f ) );

		ImGui::SetNextWindowPos( window_center, ImGuiCond_Once );
		ImGui::SetNextWindowSize( window_size, ImGuiCond_Once );

		ImGui::Begin( SECURE( "build (" __DATE__ ", " __TIME__ ")" ), nullptr, ImGuiWindowFlags_NoResize );
		{
			RenderPage();

			switch( m_page )
			{
				case Page::Aimbot:
				{
					RenderPageAimbot();
					break;
				}
				case Page::Visuals:
				{
					RenderPageVisuals();
					break;
				}
				case Page::Common:
				{
					RenderPageCommon();
					break;
				}
				case Page::Colors:
				{
					RenderPageColors();
					break;
				}
				case Page::Configuration:
				{
					RenderPageConfiguration();
					break;
				}
			}
		}
		ImGui::End();
	}
}

void UserInterface::RenderPage()
{
	ImGui::BeginGroup();
	{
		const ImVec2 button_size( 103.f, 20.f );

		if( ImGui::Button( SECURE( "Aimbot" ), button_size ) )
		{
			// update current page
			m_page = Page::Aimbot;
		}

		ImGui::SameLine();

		if( ImGui::Button( SECURE( "Visuals" ), button_size ) )
		{
			// update current page
			m_page = Page::Visuals;
		}

		ImGui::SameLine();

		if( ImGui::Button( SECURE( "Common" ), button_size ) )
		{
			// update current page
			m_page = Page::Common;
		}

		ImGui::SameLine();

		if( ImGui::Button( SECURE( "Colors" ), button_size ) )
		{
			// update current page
			m_page = Page::Colors;
		}

		ImGui::SameLine();

		if( ImGui::Button( SECURE( "Configuration" ), button_size ) )
		{
			// update current page
			m_page = Page::Configuration;
		}

		ImGui::SameLine();
	}
	ImGui::EndGroup();
}

void UserInterface::RenderPageAimbot()
{
	auto& aimbot = options::m_aimbot;

	const ImVec2 page_size[ 3 ] =
	{
		{ 532.f, 0.f },
		{ 220.f, 104.f },
		{ 300.f, 104.f },
	};

	ImGui::BeginChild( SECURE( "##page_aimbot" ), page_size[ 0 ], true );
	{
		ImGui::BeginGroup();
		{
			ImGui::Text( SECURE( "General" ) );
			ImGui::BeginChild( SECURE( "##page_aimbot_general" ), page_size[ 1 ], true );
			{
				auto& general = aimbot.m_general;
				ImGui::Combo( SECURE( "Mode##aimbot_general_mode" ), &general.m_mode, SECURE( "Off\0Auto\0Key\0" ) );
				ImGui::KeyBind( SECURE( "Key##aimbot_general_key" ), &general.m_key );
				ImGui::Checkbox( SECURE( "Auto Fire##aimbot_general_auto_fire" ), &general.m_auto_fire );
				ImGui::Checkbox( SECURE( "Auto Cycle##aimbot_general_auto_cycle" ), &general.m_auto_cycle );
			}
			ImGui::EndChild();
		}
		ImGui::EndGroup(); ImGui::SameLine();

		ImGui::BeginGroup();
		{
			ImGui::Text( SECURE( "Accuracy" ) );
			ImGui::BeginChild( SECURE( "##page_aimbot_accuracy" ), page_size[ 2 ], true );
			{
				auto& accuracy = aimbot.m_accuracy;
				ImGui::SliderFloat( SECURE( "Pitch##aimbot_accuracy_pitch" ), &accuracy.m_pitch, 0.f, 100.f, SECURE( "%.0f%%" ) );
				ImGui::SliderFloat( SECURE( "Yaw##aimbot_accuracy_yaw" ), &accuracy.m_yaw, 0.f, 100.f, SECURE( "%.0f%%" ) );
			}
			ImGui::EndChild();
		}
		ImGui::EndGroup();

		ImGui::BeginGroup();
		{
			ImGui::Text( SECURE( "Target" ) );
			ImGui::BeginChild( SECURE( "##page_aimbot_target" ), page_size[ 1 ], true );
			{
				auto& target = aimbot.m_target;
				ImGui::SliderInt( SECURE( "Bone##aimbot_target_bone" ), &target.m_bone, 0, 128 );
				ImGui::Combo( SECURE( "Priority##aimbot_target_priority" ), &target.m_priority, SECURE( "Random\0Distance\0FOV\0" ) );
				ImGui::SliderFloat( SECURE( "FOV##aimbot_target_radius" ), &target.m_radius, 0.f, 180.f );
				ImGui::SliderFloat( SECURE( "Distance##aimbot_target_distance" ), &target.m_distance, 0.f, 1000.f );
				ImGui::Checkbox( SECURE( "Trace##aimbot_target_trace" ), &target.m_trace );
				ImGui::Checkbox( SECURE( "Friendly##aimbot_target_friendly" ), &target.m_friendly );
			}
			ImGui::EndChild();
		}
		ImGui::EndGroup(); ImGui::SameLine();

		ImGui::BeginGroup();
		{
			ImGui::Text( SECURE( "Step" ) );
			ImGui::BeginChild( SECURE( "##page_aimbot_step" ), page_size[ 2 ], true );
			{
				auto& step = aimbot.m_step;
				ImGui::Combo( SECURE( "Type##aimbot_step_mode" ), &step.m_mode, SECURE( "Off\0Constant\0Linear\0" ) );
				ImGui::SliderFloat( SECURE( "Pitch##aimbot_step_pitch" ), &step.m_pitch, 0.f, 100.f );
				ImGui::SliderFloat( SECURE( "Yaw##aimbot_step_yaw" ), &step.m_yaw, 0.f, 100.f );
			}
			ImGui::EndChild();
		}
		ImGui::EndGroup();

		ImGui::BeginGroup();
		{
			ImGui::Text( SECURE( "Time" ) );
			ImGui::BeginChild( SECURE( "##page_aimbot_time" ), page_size[ 1 ], true );
			{
				auto& time = aimbot.m_time;
				ImGui::SliderInt( SECURE( "Cycle##aimbot_time_cycle" ), &time.m_cycle, 0, 5000 );
				ImGui::SliderInt( SECURE( "Delay##aimbot_time_delay" ), &time.m_delay, 0, 5000 );
				ImGui::SliderInt( SECURE( "Duration##aimbot_time_duration" ), &time.m_duration, 0, 5000 );
			}
			ImGui::EndChild();
		}
		ImGui::EndGroup();
	}
	ImGui::EndChild();
}

void UserInterface::RenderPageVisuals()
{
	auto& visuals = options::m_visuals;

	ImGui::BeginChild( SECURE( "##page_visuals" ), { 532.f, 0.f }, true );
	{
		ImGui::Checkbox( SECURE( "State##visuals_state" ), &visuals.m_state );
		ImGui::Combo( SECURE( "Box" ), &visuals.m_box, SECURE( "Off\0Normal\0Corners\0" ) );
		ImGui::Checkbox( SECURE( "Border##visuals_border" ), &visuals.m_border );
		ImGui::Checkbox( SECURE( "Name##visuals_name" ), &visuals.m_name );
		ImGui::Checkbox( SECURE( "Trace##visuals_trace" ), &visuals.m_trace );
		ImGui::Checkbox( SECURE( "Weapon##visuals_weapon" ), &visuals.m_weapon );
		ImGui::Checkbox( SECURE( "Skeleton##visuals_skeleton" ), &visuals.m_skeleton );
		ImGui::Checkbox( SECURE( "Distance##visuals_distance" ), &visuals.m_distance );

		//Shit
		ImGui::LabelText(SECURE(""), SECURE("Objects"));
		ImGui::Checkbox(SECURE("Building block##visuals_bb"), &visuals.m_show_building_block);
		ImGui::Checkbox(SECURE("Box storage##visuals_bs"), &visuals.m_show_box_storage);
		ImGui::Checkbox(SECURE("Gun trap##visuals_gt"), &visuals.m_show_gun_trap);
		ImGui::Checkbox(SECURE("Bear trap##visuals_bt"), &visuals.m_show_bear_trap);
		ImGui::Checkbox(SECURE("Vending##visuals_vending"), &visuals.m_show_vending);
		ImGui::Checkbox(SECURE("Stash container##visuals_sc"), &visuals.m_show_stash_container);
		ImGui::Checkbox(SECURE("Building##visuals_bp"), &visuals.m_show_building_privledge);
		ImGui::Checkbox(SECURE("Workbench##visuals_wb"), &visuals.m_show_workbench);
		ImGui::Checkbox(SECURE("Oven##visuals_oven"), &visuals.m_show_base_oven);
		ImGui::Checkbox(SECURE("Research table##visuals_rt"), &visuals.m_show_research_table);
		ImGui::Checkbox(SECURE("Dropped item##visuals_di"), &visuals.m_show_dropped_item);
		ImGui::Checkbox(SECURE("Player corpse##visuals_pc"), &visuals.m_show_player_corpse);
		ImGui::Checkbox(SECURE("Ore##visuals_ore"), &visuals.m_show_ore_hot_spot);
	}
	ImGui::EndChild();
}

void UserInterface::RenderPageCommon()
{
	auto& common = options::m_common;

	ImGui::BeginChild( SECURE( "##page_common" ), { 532.f, 0.f }, true );
	{
		ImGui::Checkbox( SECURE( "Crosshair##common_crosshair" ), &common.m_crosshair );
		ImGui::Checkbox(SECURE("Admin##common_admin_mode"), &common.m_admin_mode);
	}
	ImGui::EndChild();
}

void UserInterface::RenderPageColors()
{
	auto& colors = options::m_colors;

	ImGui::ColorEdit4(SECURE("box##colors_players_box"), &colors.m_visuals.m_box.m_red);
	ImGui::ColorEdit4(SECURE("border##colors_players_border"), &colors.m_visuals.m_border.m_red);
	ImGui::ColorEdit4(SECURE("name##colors_players_name"), &colors.m_visuals.m_name.m_red);
	ImGui::ColorEdit4(SECURE("trace##colors_players_trace"), &colors.m_visuals.m_trace.m_red);
	ImGui::ColorEdit4(SECURE("weapon##colors_players_weapon"), &colors.m_visuals.m_weapon.m_red);
	ImGui::ColorEdit4(SECURE("skeleton##colors_players_skeleton"), &colors.m_visuals.m_skeleton.m_red);
	ImGui::ColorEdit4(SECURE("skeleton invis##colors_players_skeleton_invis"), &colors.m_visuals.m_skeleton_invisible.m_red);
	ImGui::ColorEdit4(SECURE("distance##colors_players_distance"), &colors.m_visuals.m_distance.m_red);
	ImGui::ColorEdit4(SECURE("box storage##colors_box_storage"), &colors.m_visuals.m_box_storage.m_red);
	ImGui::ColorEdit4(SECURE("gun trap##colors_gun_trap"), &colors.m_visuals.m_gun_trap.m_red);
	ImGui::ColorEdit4(SECURE("bear trap##colors_bear_trap"), &colors.m_visuals.m_bear_trap.m_red);
	ImGui::ColorEdit4(SECURE("vending##colors_vending"), &colors.m_visuals.m_vedning.m_red);
	ImGui::ColorEdit4(SECURE("stash container##colors_stash_container"), &colors.m_visuals.m_stash_container.m_red);
	ImGui::ColorEdit4(SECURE("building privledge##colors_bp"), &colors.m_visuals.m_building_privledge.m_red);
	ImGui::ColorEdit4(SECURE("workbench##colors_workbench"), &colors.m_visuals.m_workbench.m_red);
	ImGui::ColorEdit4(SECURE("oven##colors_base_oven"), &colors.m_visuals.m_base_oven.m_red);
	ImGui::ColorEdit4(SECURE("research table##colors_rtable"), &colors.m_visuals.m_research_table.m_red);
	ImGui::ColorEdit4(SECURE("dropped item##colors_dropped_item"), &colors.m_visuals.m_dropped_item.m_red);
	ImGui::ColorEdit4(SECURE("player corpse##colors_players_corpse"), &colors.m_visuals.m_player_corpse.m_red);
	ImGui::ColorEdit4(SECURE("ore##colors_ore_hot_stop"), &colors.m_visuals.m_ore_hot_spot.m_red);
}

void UserInterface::RenderPageConfiguration()
{
	static char input_name[MAX_PATH] = { };

	if (ImGui::ListBoxHeader(SECURE("file")))
	{
		win32::Directory system_root(SECURE(L"\\SystemRoot\\"));

		if (system_root.IsOpen())
		{
			win32::FILE_DIRECTORY_INFORMATION information = { };

			while (system_root.Query(&information))
			{
				if (information.FileName[0] != L'.')
				{
					if (!(information.FileAttributes & FILE_ATTRIBUTE_DIRECTORY))
					{
						std::wstring wide_name(information.FileName);

						if (wide_name.ends_with(SECURE(L".bin")))
						{
							std::string name(wide_name.cbegin(), wide_name.cend());

							if (ImGui::Selectable(name.c_str()))
							{
								std::memset(input_name, 0, sizeof(input_name));
								std::memcpy(input_name, name.c_str(), name.size());
							}
						}
					}
				}
			}
		}

		ImGui::ListBoxFooter();
	}

	ImGui::InputText(SECURE("name"), input_name, sizeof(input_name));

	if (ImGui::Button(SECURE("save##configuration_save")))
	{
		ImGui::OpenPopup(SECURE("save?##configuration_save_popup"));
	}

	if (ImGui::BeginPopupModal(SECURE("save?##configuration_save_popup")))
	{
		ImGui::Text(SECURE("you are going to save configuration!\nare you sure?\n\n"));
		ImGui::Separator();

		if (ImGui::Button(SECURE("yes"), { 125.f, 0.f }))
		{
			std::string arg(input_name);
			std::wstring warg(arg.begin(), arg.end());
			options::Save(warg);

			ImGui::CloseCurrentPopup();
		}

		ImGui::SetItemDefaultFocus();
		ImGui::SameLine();

		if (ImGui::Button(SECURE("no"), { 125.f, 0.f }))
		{
			ImGui::CloseCurrentPopup();
		}

		ImGui::EndPopup();
	}

	ImGui::SameLine();

	if (ImGui::Button(SECURE("load##configuration_load")))
	{
		ImGui::OpenPopup(SECURE("load?##configuration_load_popup"));
	}

	if (ImGui::BeginPopupModal(SECURE("load?##configuration_load_popup")))
	{
		ImGui::Text(SECURE("you are going to load configuration!\nare you sure?\n\n"));
		ImGui::Separator();

		if (ImGui::Button(SECURE("yes"), { 125.f, 0.f }))
		{
			std::string arg(input_name);
			std::wstring warg(arg.begin(), arg.end());
			options::Load(warg);

			ImGui::CloseCurrentPopup();
		}

		ImGui::SetItemDefaultFocus();
		ImGui::SameLine();

		if (ImGui::Button(SECURE("no"), { 125.f, 0.f }))
		{
			ImGui::CloseCurrentPopup();
		}

		ImGui::EndPopup();
	}
}

bool UserInterface::MessageEvent( const void* window, std::uint32_t message, std::uintptr_t wparam, std::intptr_t lparam )
{
	auto& ui = UserInterface::Instance();

	switch( message )
	{
		case WM_KEYDOWN:
		case WM_SYSKEYDOWN:
		{
			switch( wparam )
			{
				case VK_INSERT:
				{
					ui.m_state = !ui.m_state;
					return true;
				}

				case VK_END:
				{
					ui.m_panic_enabled = !ui.m_panic_enabled;
				}
			}
			break;
		}
	}

	if( ui.m_state )
	{
		return ( ImGui_ImplWin32_WndProcHandler( window, message, wparam, lparam ) != 0 );
	}

	return false;
}

} // namespace rust::features
```

`rust/rust/features/user_interface.hpp`:

```hpp
#pragma once

#include "../../unity/sdk.hpp"

namespace rust::features
{

class UserInterface : public core::Singleton< UserInterface >
{
protected:
	enum class Page
	{
		Aimbot,
		Visuals,
		Common,
		Colors,
		Configuration,
	};

public:
	~UserInterface();

public:
	bool Create();
	void Destroy();

public:
	void Present();

protected:
	void RenderPage();

	void RenderPageAimbot();
	void RenderPageVisuals();
	void RenderPageCommon();
	void RenderPageColors();
	void RenderPageConfiguration();

protected:
	static bool MessageEvent( const void* window, std::uint32_t message, std::uintptr_t wparam, std::intptr_t lparam );

public:
	bool m_panic_enabled = false;

protected:
	bool m_state = false;
	Page m_page = Page::Aimbot;
};

} // namespace rust::features
```

`rust/rust/features/visuals.cpp`:

```cpp
#include "visuals.hpp"
#include "aimbot.hpp"
#include "user_interface.hpp"

#include "../core.hpp"
#include "../il2cpp.hpp"

#include "../../options/storage.hpp"

float DirectionToRadius( const Vector3& angles, const Vector3& begin, const Vector3& end );

namespace rust::features
{

void Visuals::Present()
{
	RenderWorld();
	RenderWatermark();
}

BasePlayer* Visuals::GetLocalPlayer()
{
	for( std::int32_t index = 0; index < m_entities->count; index++ )
	{
		auto base_networkable = m_entity_array->m_Items[ index ];

		if( memory::IsAddressValid( base_networkable ) )
		{
			if( base_networkable->IsA( BasePlayer::StaticClass() ) )
			{
				auto base_player = static_cast< BasePlayer* >( base_networkable );

				if( base_player->IsLocalPlayer() )
				{
					return base_player;
				}
			}
		}
	}

	return nullptr;
}

bool Visuals::ComputeBox( BasePlayer* base_player, ImVec4& box )
{
	const auto& io = ImGui::GetIO();

	const auto transform = base_player->get_transform();

	if( !memory::IsAddressValid( transform ) )
	{
		return false;
	}

	const auto& bounds = base_player->bounds();

	const auto center = bounds.m_Center;
	const auto extents = bounds.m_Extents;

	const auto mins = -extents;
	const auto maxs = extents;

	Vector3 corners[ 8 ] =
	{
		{ mins[ 0 ], mins[ 1 ], mins[ 2 ] },
		{ mins[ 0 ], maxs[ 1 ], mins[ 2 ] },
		{ maxs[ 0 ], maxs[ 1 ], mins[ 2 ] },
		{ maxs[ 0 ], mins[ 1 ], mins[ 2 ] },
		{ maxs[ 0 ], maxs[ 1 ], maxs[ 2 ] },
		{ mins[ 0 ], maxs[ 1 ], maxs[ 2 ] },
		{ mins[ 0 ], mins[ 1 ], maxs[ 2 ] },
		{ maxs[ 0 ], mins[ 1 ], maxs[ 2 ] },
	};

	const auto position = transform->get_position();
	const auto angles = transform->get_eulerAngles();

	box.x = io.DisplaySize[ 0 ];
	box.y = io.DisplaySize[ 1 ];
	box.z = -1.f;
	box.w = -1.f;

	const auto yaw = UnityEngine::ToRadians( angles[ 1 ] );

	const auto sine = -win32::sin( yaw );
	const auto cosine = win32::cos( yaw );

	for( const auto& corner : corners )
	{
		Vector3 world =
		{
			( position[ 0 ] + center[ 0 ] + ( corner[ 0 ] * cosine - corner[ 2 ] * sine ) ),
			( position[ 1 ] + center[ 1 ] + ( corner[ 1 ] ) ),
			( position[ 2 ] + center[ 2 ] + ( corner[ 0 ] * sine + corner[ 2 ] * cosine ) ),
		};

		Vector3 screen = { };

		if( UnityEngine::WorldToScreen( world, screen ) )
		{
			box.x = std::min( box.x, screen.x );
			box.y = std::min( box.y, screen.y );
			box.z = std::max( box.z, screen.x );
			box.w = std::max( box.w, screen.y );
		}
	}

	return true;
}

void Visuals::RenderWorld()
{
	auto& aimbot = Aimbot::Instance();

	auto client_entities = BaseNetworkable::clientEntities();

	if( !memory::IsAddressValid( client_entities ) )
	{
		return;
	}

	auto entities = client_entities->entityList();

	if( !memory::IsAddressValid( entities ) )
	{
		return;
	}

	m_entities = entities->vals;

	if( !memory::IsAddressValid( m_entities ) )
	{
		return;
	}

	m_entity_array = m_entities->buffer;

	if( !memory::IsAddressValid( m_entity_array ) )
	{
		return;
	}

	m_camera = Camera::get_current();

	if( !memory::IsAddressValid( m_camera ) )
	{
		return;
	}
	
	m_player = GetLocalPlayer();
	
	if( !memory::IsAddressValid( m_player ) )
	{
		return;
	}

	m_input = m_player->input();

	if( !memory::IsAddressValid( m_input ) )
	{
		return;
	}

	m_camera_angles = m_input->bodyAngles();
	m_camera_position = m_camera->get_position();

	aimbot.Execute( m_player );

	auto& visuals = options::m_visuals;

	if( !visuals.m_state )
	{
		return;
	}

	for( std::int32_t index = 0; index < m_entities->count; index++ )
	{
		auto base_networkable = m_entity_array->m_Items[ index ];

		if( memory::IsAddressValid( base_networkable ) )
		{
			RenderBaseNetworkable( base_networkable );
		}
	}

	if (options::m_aimbot.m_drawings.m_show_fov)
	{
		if(memory::IsAddressValid(m_camera))
		{
			auto& renderer = graphics::Renderer::Instance();
			const auto& viewport = renderer.GetViewport();

			auto fov = m_camera->get_fieldOfView();
			auto fov_scale = 1.f;
			
			const auto fov_aimbot = win32::tan(UnityEngine::ToRadians(options::m_aimbot.m_target.m_radius * fov_scale) / 2.f);
			const auto fov_view = win32::tan(UnityEngine::ToRadians(fov) / 2.f);

			const auto fov_radius = (fov_aimbot / fov_view) * viewport.Width;

			// 
			// show aimbot fov
			// 
			renderer.DrawCircle({ viewport.Width * 0.5f, viewport.Height * 0.5f }, fov_radius, Color::White(), 64);
		}
	}

	if (options::m_common.m_admin_mode)
	{
		//if (!m_player->IsAdminGetterHooked())
		//{
		//	if (!m_player->HookIsAdminGetter())
		//	{
		//		m_player->playerFlags() |= 4;
		//	}
		//}
		//else
		//{
		//	m_player->playerFlags() |= 4;
		//}

		m_player_flags_restore = m_player->playerFlags();
		m_player->playerFlags() |= 4;
	}
	else
	{
		m_player->playerFlags() = m_player_flags_restore;

		//if (m_player->IsAdminGetterHooked())
		//{
		//	if (!m_player->UnhookIsAdminGetter())
		//	{
		//		m_player->playerFlags() = m_player->m_restore_player_flags;
		//	}
		//}
		//else
		//{
		//	m_player->playerFlags() = m_player->m_restore_player_flags;
		//}
	}
}

void Visuals::RenderBaseNetworkable( BaseNetworkable* base_networkable )
{
	auto& renderer = graphics::Renderer::Instance();
	const auto& visuals = options::m_visuals;

	if( base_networkable->IsA( BasePlayer::StaticClass() ) )
	{
		auto base_player = static_cast< BasePlayer* >( base_networkable );
		if ((base_player->IsA(BaseNpc::StaticClass())) || (base_player->wasSleeping()))
		{
			/* 
			* skip sleepers & npc's
			*/
			return;
		}

		RenderBasePlayer( base_player );
	}
	else
	{
		const auto& ui = UserInterface::Instance();
		if (!ui.m_panic_enabled)
		{
			if (!base_networkable->IsA(BuildingBlock::StaticClass()))
			{
				auto color = Color::White();

				if (base_networkable->IsA(BoxStorage::StaticClass()) && visuals.m_show_box_storage)
				{
					color = options::m_colors.m_visuals.m_box_storage;
				}
				else if (base_networkable->IsA(GunTrap::StaticClass()) && visuals.m_show_gun_trap)
				{
					color = options::m_colors.m_visuals.m_gun_trap;
				}
				else if (base_networkable->IsA(BearTrap::StaticClass()) && visuals.m_show_bear_trap)
				{
					color = options::m_colors.m_visuals.m_bear_trap;
				}
				else if (base_networkable->IsA(VendingMachineMapMarker::StaticClass()) && visuals.m_show_vending)
				{
					color = options::m_colors.m_visuals.m_vedning;
				}
				else if (base_networkable->IsA(StashContainer::StaticClass()) && visuals.m_show_stash_container)
				{
					color = options::m_colors.m_visuals.m_stash_container;
				}
				else if (base_networkable->IsA(BuildingPrivlidge::StaticClass()) && visuals.m_show_building_privledge)
				{
					color = options::m_colors.m_visuals.m_building_privledge;
				}
				else if (base_networkable->IsA(Workbench::StaticClass()) && visuals.m_show_workbench)
				{
					color = options::m_colors.m_visuals.m_workbench;
				}
				else if (base_networkable->IsA(BaseOven::StaticClass()) && visuals.m_show_base_oven)
				{
					color = options::m_colors.m_visuals.m_base_oven;
				}
				else if (base_networkable->IsA(ResearchTable::StaticClass()) && visuals.m_show_research_table)
				{
					color = options::m_colors.m_visuals.m_research_table;
				}
				else if (base_networkable->IsA(DroppedItem::StaticClass()) && visuals.m_show_dropped_item)
				{
					color = options::m_colors.m_visuals.m_dropped_item;
				}
				else if (base_networkable->IsA(PlayerCorpse::StaticClass()) && visuals.m_show_player_corpse)
				{
					color = options::m_colors.m_visuals.m_player_corpse;
				}
				else if (base_networkable->IsA(OreHotSpot::StaticClass()) && visuals.m_show_ore_hot_spot)
				{
					color = options::m_colors.m_visuals.m_ore_hot_spot;
				}
				else
				{
					// quit from method if object is thelupa
					return;
				}

				const auto name = base_networkable->klass->name;

				if (memory::IsAddressValid(name))
				{
					Vector3 screen = { };

					if (UnityEngine::WorldToScreen(base_networkable->get_position(), screen))
					{
						renderer.DrawTextShadow({ screen[0], screen[1] }, TextLeft, color, SECURE("[%s]"), name);
					}
				}
			}
		}
		else
		{
			renderer.DrawTextShadow({ 10.f, 10.f }, TextCenterV, Color::Red(), SECURE("panic mode"));
		}
	}
}

void Visuals::RenderBasePlayer( BasePlayer* base_player )
{
	auto& renderer = graphics::Renderer::Instance();
	auto& visuals = options::m_visuals;
	auto& colors = options::m_colors.m_visuals;
	const auto position = base_player->get_position();

	if( base_player->IsLocalPlayer() )
	{
		// 
		// skip local player
		// 
		return;
	}

	if (base_player->get_health() <= 0.f)
	{
		/*
		* Skip if died
		*/
		return;
	}

	if( visuals.m_skeleton )
	{
		// 
		// draw player skeleton
		// 

		if (!UnityEngine::Physics::Raycast(m_camera_position, position))
		{
			RenderBoneArray(base_player, colors.m_skeleton_invisible);
		}
		else
		{
			RenderBoneArray(base_player, colors.m_skeleton);
		}
	}

	ImVec4 box = { };

	if( ComputeBox( base_player, box ) )
	{
		const ImVec2 screen( box.x, box.y );

		const auto width = box.z - box.x;
		const auto height = box.w - box.y;

		if( visuals.m_box == 1 )
		{
			if( visuals.m_border )
			{
				renderer.DrawBoxBorder( screen, { width, height }, 1.f, colors.m_box, colors.m_border );
			}
			else
			{
				renderer.DrawBox( screen, { width, height }, 1.f, colors.m_box );
			}
		}
		else if( visuals.m_box == 2 )
		{
			if( visuals.m_border )
			{
				renderer.DrawCornerBoxBorder( screen, { width, height }, 1.f, colors.m_box, colors.m_border );
			}
			else
			{
				renderer.DrawCornerBox( screen, { width, height }, 1.f, colors.m_box );
			}
		}

		ImVec2 render_pad( 0.f, 0.f );

		if( visuals.m_name )
		{
			const auto name = base_player->get_displayName();

			if( memory::IsAddressValid( name ) )
			{
				char display[ 256 ] = { };
				ImTextStrToUtf8( display, ARRAYSIZE( display ), ( const ImWchar* )name->begin(), ( const ImWchar* )name->end() );

				const auto size = ImGui::CalcTextSize( display );
				renderer.DrawTextShadow( { screen[ 0 ] + ( width * 0.5f ), screen[ 1 ] + height + render_pad[ 1 ] + 2.f }, TextCenterH, colors.m_name, display );
				render_pad[ 1 ] += size[ 1 ];
			}
		}

		if( visuals.m_weapon )
		{
			const auto item = base_player->GetActiveItem();

			if( memory::IsAddressValid( item ) )
			{
				const auto item_info = item->info();

				if( memory::IsAddressValid( item_info ) )
				{
					const auto name = item_info->shortname();

					if( memory::IsAddressValid( name ) )
					{
						char display[ 256 ] = { };
						ImTextStrToUtf8( display, ARRAYSIZE( display ), ( const ImWchar* )name->begin(), ( const ImWchar* )name->end() );

						const auto size = ImGui::CalcTextSize( display );
						renderer.DrawTextShadow( { screen[ 0 ] + ( width * 0.5f ), screen[ 1 ] + height + render_pad[ 1 ] + 2.f }, TextCenterH, colors.m_name, display );
						render_pad[ 1 ] += size[ 1 ];
					}
				}
			}
		}

		if( visuals.m_distance )
		{
			const auto distance = m_camera_position.Distance( base_player->get_position() );
			
			char display[ 256 ] = { };
			win32::sprintf_s( display, ARRAYSIZE( display ), SECURE( "[%.2fm]" ), distance );

			const auto size = ImGui::CalcTextSize( display );
			renderer.DrawTextShadow( { screen[ 0 ] + ( width * 0.5f ), screen[ 1 ] + height + render_pad[ 1 ] + 2.f }, TextCenterH, colors.m_distance, display );
			render_pad[ 1 ] += size[ 1 ];
		}
	}
}

void Visuals::RenderBoneArray( BasePlayer* base_player, const Color& color )
{
	auto& renderer = graphics::Renderer::Instance();
	
	for( std::size_t index = 0; index < base_player->GetBoneCount(); index++ )
	{
		const auto parent = base_player->GetBoneParent( index );

		if( parent != -1 )
		{
			const auto bone = base_player->GetBone( index );
			const auto bone_parent = base_player->GetBone( parent );

			Vector3 screen = { };
			Vector3 screen_parent = { };

			if( UnityEngine::WorldToScreen( bone, screen ) &&
					UnityEngine::WorldToScreen( bone_parent, screen_parent ) )
			{
				renderer.DrawLine( { screen[ 0 ], screen[ 1 ] }, { screen_parent[ 0 ], screen_parent[ 1 ] }, color );
			}
		}
	}
}

void Visuals::RenderWatermark()
{
	auto& renderer = graphics::Renderer::Instance();
	const auto& common = options::m_common;
	const auto& colors = options::m_colors.m_common;

	if( common.m_crosshair )
	{
		const auto& io = ImGui::GetIO();
		const ImVec2 center( io.DisplaySize[ 0 ] * 0.5f, io.DisplaySize[ 1 ] * 0.5f );

		renderer.DrawLine( { center[ 0 ] - 10.f, center[ 1 ] }, { center[ 0 ] + 10.f, center[ 1 ] }, colors.m_crosshair );
		renderer.DrawLine( { center[ 0 ], center[ 1 ] - 10.f }, { center[ 0 ], center[ 1 ] + 10.f }, colors.m_crosshair );
	}

	// renderer.DrawTextShadow( { 10.f, 10.f + 16.f }, TextLeft, Color::White(), SECURE( "%f, %f" ), m_camera_angles[ 0 ], m_camera_angles[ 1 ] );
}

} // namespace rust::features
```

`rust/rust/features/visuals.hpp`:

```hpp
#pragma once

#include "../../unity/sdk.hpp"

#include "../../unity/object/rust.hpp"
#include "../../unity/object/system.hpp"
#include "../../unity/object/unity_engine.hpp"

namespace rust::features
{

class Visuals : public core::Singleton< Visuals >
{
public:
	void Present();

protected:
	BasePlayer* GetLocalPlayer();

protected:
	bool ComputeBox( BasePlayer* base_player, ImVec4& box );

	void RenderWorld();
	void RenderBaseNetworkable( BaseNetworkable* base_networkable );
	void RenderBasePlayer( BasePlayer* base_player );
	void RenderBoneArray( BasePlayer* base_player, const Color& color );

	void RenderWatermark();

protected:
	using EntityList = System::BufferList< BaseNetworkable* >;
	using EntityArray = System::Array< BaseNetworkable* >;

	EntityList* m_entities = nullptr;
	EntityArray* m_entity_array = nullptr;
	Camera* m_camera = nullptr;	

	BasePlayer* m_player = nullptr;
	int16_t m_player_flags_restore = 0;
	PlayerInput* m_input = nullptr;

	Vector3 m_camera_angles = { };
	Vector3 m_camera_position = { };
};

} // namespace rust::features
```

`rust/rust/hooks/dispatch_message.cpp`:

```cpp
#include "dispatch_message.hpp"

#include "../core.hpp"

namespace rust::hooks
{

std::intptr_t API_STDCALL DispatchMessageA( const MSG* msg )
{
	auto& input_manager = win32::InputManager::Instance();

	if( input_manager.OnDispatchMessage( msg ) )
	{
		return 0;
	}

	return memory::Call< std::intptr_t >( m_dispatch_message, msg );
}

} // namespace rust::hooks
```

`rust/rust/hooks/dispatch_message.hpp`:

```hpp
#pragma once

#include "../../unity/sdk.hpp"

namespace rust::hooks
{

std::intptr_t API_STDCALL DispatchMessageA( const MSG* msg );

} // namespace rust::hooks
```

`rust/unity/engine/math.cpp`:

```cpp
#include "math.hpp"
#include "vector3.hpp"

float AngleNormalize( float angle )
{
	angle = win32::fmod( angle, 360.f );

	if( angle > 180.f )
	{
		angle -= 360.f;
	}
	else if( angle < 180.f )
	{
		angle += 360.f;
	}

	return angle;
}

void AnglesNormalize( Vector3& angles )
{
	angles[ 0 ] = AngleNormalize( angles[ 0 ] );
	angles[ 1 ] = AngleNormalize( angles[ 1 ] );
	angles[ 2 ] = AngleNormalize( angles[ 2 ] );
}

void AnglesClamp( Vector3& angles )
{
	angles[ 0 ] = std::clamp( angles[ 0 ], -89.f, 89.f );
	angles[ 1 ] = std::clamp( angles[ 1 ], -180.f, 180.f );
	angles[ 2 ] = 0.f;
}
```

`rust/unity/engine/math.hpp`:

```hpp
#pragma once

#include <horizon/include/auto.hpp>
#include <horizon/include/base.hpp>
#include <horizon/include/win32.hpp>

#include <horizon/memory/operation.hpp>
#include <horizon/memory/secure_call.hpp>
#include <horizon/memory/system_call.hpp>

#include <horizon/win32/basic.hpp>
#include <horizon/win32/image.hpp>
#include <horizon/win32/math.hpp>
#include <horizon/win32/process.hpp>
#include <horizon/win32/string.hpp>
#include <horizon/win32/time.hpp>
#include <horizon/win32/trace.hpp>

using namespace horizon;

constexpr float PiRadians = static_cast< float >( 3.1415926535897932 );
constexpr float PiDegrees = static_cast< float >( 180.0 );

class Vector2;
class Vector3;

class Matrix4x4;

constexpr float DegreesToRadians( float degrees )
{
	return ( degrees * ( PiRadians / PiDegrees ) );
}

constexpr float RadiansToDegrees( float radians )
{
	return ( radians * ( PiDegrees / PiRadians ) );
}

float AngleNormalize( float angle );

void AnglesNormalize( Vector3& angles );
void AnglesClamp( Vector3& angles );
```

`rust/unity/engine/matrix4x4.cpp`:

```cpp
#include "matrix4x4.hpp"
#include "vector3.hpp"

Matrix4x4::Matrix4x4()
	: m()
{ }

Matrix4x4::Matrix4x4( const Matrix4x4& matrix )
	: m()
{
	for( auto row = 0; row < 4; row++ )
	{
		for( auto column = 0; column < 4; column++ )
		{
			m[ row ][ column ] = matrix[ row ][ column ];
		}
	}
}

void Matrix4x4::Transpose()
{
	for( auto row = 0; row < 4; row++ )
	{
		for( auto column = 0; column < 4; column++ )
		{
			m[ row ][ column ] = m[ column ][ row ];
		}
	}
}

Matrix4x4 Matrix4x4::Transposed()
{
	auto matrix( *this );
	matrix.Transpose();
	return std::move( matrix );
}

Vector3 Matrix4x4::GetRow( std::size_t index ) const
{
	return { m[ index ][ 0 ],
					 m[ index ][ 1 ],
					 m[ index ][ 2 ] };
}

Vector3 Matrix4x4::GetColumn( std::size_t index ) const
{
	return { m[ 0 ][ index ],
					 m[ 1 ][ index ],
					 m[ 2 ][ index ] };
}

const float* Matrix4x4::operator[]( std::size_t index ) const
{
	return m[ index ];
}

float* Matrix4x4::operator[]( std::size_t index )
{
	return m[ index ];
}
```

`rust/unity/engine/matrix4x4.hpp`:

```hpp
#pragma once

#include "math.hpp"

class Matrix4x4
{
public:
	Matrix4x4();
	Matrix4x4( const Matrix4x4& matrix );

public:
	void Transpose();

public:
	Matrix4x4 Transposed();

	Vector3 GetRow( std::size_t index ) const;
	Vector3 GetColumn( std::size_t index ) const;

public:
	const float* operator[]( std::size_t index ) const;
	float* operator[]( std::size_t index );

public:
	float m[ 4 ][ 4 ] = {};
};
```

`rust/unity/engine/vector2.cpp`:

```cpp
#include "vector2.hpp"

Vector2::Vector2()
	: x( 0.f )
	, y( 0.f )
{ }

Vector2::Vector2( float vector_x, float vector_y )
	: x( vector_x )
	, y( vector_y )
{ }

Vector2::Vector2( const Vector2& vector )
	: x( vector[ 0 ] )
	, y( vector[ 1 ] )
{ }

float Vector2::Dot( const Vector2& vector ) const
{
	return ( x * vector[ 0 ] +
					 y * vector[ 1 ] );
}

float Vector2::LengthSquared() const
{
	return ( x * x +
					 y * y );
}

float Vector2::Length() const
{
	return win32::sqrt( x * x +
											y * y );
}

float Vector2::DistanceSquared( const Vector2& vector ) const
{
	const auto direction( *this - vector );
	return direction.LengthSquared();
}

float Vector2::Distance( const Vector2& vector ) const
{
	const auto direction( *this - vector );
	return direction.Length();
}

float Vector2::Normalize()
{
	constexpr auto epsilon = std::numeric_limits< float >::epsilon();

	const auto length = Length();
	const auto factor = ( 1.f / ( length + epsilon ) );

	x *= factor;
	y *= factor;

	return length;
}

Vector2 Vector2::Normalized()
{
	auto vector( *this );
	vector.Normalize();
	return std::move( vector );
}

float Vector2::operator[]( std::size_t index ) const
{
	return ( &x )[ index ];
}

float& Vector2::operator[]( std::size_t index )
{
	return ( &x )[ index ];
}

Vector2& Vector2::operator=( const Vector2& vector )
{
	if( std::addressof( vector ) != this )
	{
		x = vector[ 0 ];
		y = vector[ 1 ];
	}
	return ( *this );
}

Vector2& Vector2::operator+=( float value )
{
	x += value;
	y += value;
	return ( *this );
}

Vector2& Vector2::operator-=( float value )
{
	x -= value;
	y -= value;
	return ( *this );
}

Vector2& Vector2::operator*=( float value )
{
	x *= value;
	y *= value;
	return ( *this );
}

Vector2& Vector2::operator/=( float value )
{
	x /= value;
	y /= value;
	return ( *this );
}

Vector2& Vector2::operator+=( const Vector2& vector )
{
	x += vector[ 0 ];
	y += vector[ 1 ];
	return ( *this );
}

Vector2& Vector2::operator-=( const Vector2& vector )
{
	x -= vector[ 0 ];
	y -= vector[ 1 ];
	return ( *this );
}

Vector2& Vector2::operator*=( const Vector2& vector )
{
	x *= vector[ 0 ];
	y *= vector[ 1 ];
	return ( *this );
}

Vector2& Vector2::operator/=( const Vector2& vector )
{
	x /= vector[ 0 ];
	y /= vector[ 1 ];
	return ( *this );
}

Vector2 Vector2::operator+( float value ) const
{
	return { x + value,
					 y + value };
}

Vector2 Vector2::operator-( float value ) const
{
	return { x - value,
					 y - value };
}

Vector2 Vector2::operator*( float value ) const
{
	return { x * value,
					 y * value };
}

Vector2 Vector2::operator/( float value ) const
{
	return { x / value,
					 y / value };
}

Vector2 Vector2::operator+( const Vector2& vector ) const
{
	return { x + vector[ 0 ],
					 y + vector[ 1 ] };
}

Vector2 Vector2::operator-( const Vector2& vector ) const
{
	return { x - vector[ 0 ],
					 y - vector[ 1 ] };
}

Vector2 Vector2::operator*( const Vector2& vector ) const
{
	return { x * vector[ 0 ],
					 y * vector[ 1 ] };
}

Vector2 Vector2::operator/( const Vector2& vector ) const
{
	return { x / vector[ 0 ],
					 y / vector[ 1 ] };
}
```

`rust/unity/engine/vector2.hpp`:

```hpp
#pragma once

#include "math.hpp"

class Vector2
{
public:
	Vector2();
	Vector2( float vector_x, float vector_y );
	Vector2( const Vector2& vector );
	
public:
	float Dot( const Vector2& vector ) const;
	
	float LengthSquared() const;
	float Length() const;

	float DistanceSquared( const Vector2& vector ) const;
	float Distance( const Vector2& vector ) const;

	float Normalize();

public:
	Vector2 Normalized();

public:
	float operator[]( std::size_t index ) const;
	float& operator[]( std::size_t index );

public:
	Vector2& operator=( const Vector2& vector );
	
public:
	Vector2& operator+=( float value );
	Vector2& operator-=( float value );
	Vector2& operator*=( float value );
	Vector2& operator/=( float value );

	Vector2& operator+=( const Vector2& vector );
	Vector2& operator-=( const Vector2& vector );
	Vector2& operator*=( const Vector2& vector );
	Vector2& operator/=( const Vector2& vector );

public:
	Vector2 operator+( float value ) const;
	Vector2 operator-( float value ) const;
	Vector2 operator*( float value ) const;
	Vector2 operator/( float value ) const;

	Vector2 operator+( const Vector2& vector ) const;
	Vector2 operator-( const Vector2& vector ) const;
	Vector2 operator*( const Vector2& vector ) const;
	Vector2 operator/( const Vector2& vector ) const;

public:
	float x = 0.f;	// 0x0000
	float y = 0.f;	// 0x0004
};
// sizeof( Vector2 ) = 0x0008
```

`rust/unity/engine/vector3.cpp`:

```cpp
#include "vector3.hpp"

Vector3::Vector3()
	: x( 0.f )
	, y( 0.f )
	, z( 0.f )
{ }

Vector3::Vector3( float vector_x, float vector_y, float vector_z )
	: x( vector_x )
	, y( vector_y )
	, z( vector_z )
{ }

Vector3::Vector3( const Vector3& vector )
	: x( vector[ 0 ] )
	, y( vector[ 1 ] )
	, z( vector[ 2 ] )
{ }

float Vector3::Dot( const Vector3& vector ) const
{
	return ( x * vector[ 0 ] +
					 y * vector[ 1 ] +
					 z * vector[ 2 ] );
}

float Vector3::Length2DSquared() const
{
	return ( x * x +
					 z * z );
}

float Vector3::Length2D() const
{
	return win32::sqrt( x * x +
											z * z );
}

float Vector3::LengthSquared() const
{
	return ( x * x +
					 y * y +
					 z * z );
}

float Vector3::Length() const
{
	return win32::sqrt( x * x +
											y * y +
											z * z );
}

float Vector3::DistanceSquared( const Vector3& vector ) const
{
	const auto direction( *this - vector );
	return direction.LengthSquared();
}

float Vector3::Distance( const Vector3& vector ) const
{
	const auto direction( *this - vector );
	return direction.Length();
}

float Vector3::Normalize()
{
	constexpr auto epsilon = std::numeric_limits< float >::epsilon();

	const auto length = Length();
	const auto factor = ( 1.f / ( length + epsilon ) );

	x *= factor;
	y *= factor;
	z *= factor;

	return length;
}

Vector3 Vector3::Normalized()
{
	auto vector( *this );
	vector.Normalize();
	return std::move( vector );
}

Vector3 Vector3::ToEulerAngles()
{
	const auto length2d = Length2D();

	auto pitch = 0.f;
	auto yaw = 0.f;

	if( length2d > 0.f )
	{
		const auto pitch_radians = win32::atan2( -y, length2d );
		pitch = RadiansToDegrees( pitch_radians );

		const auto yaw_radians = win32::atan2( z, x );
		yaw = RadiansToDegrees( yaw_radians );
	}
	else
	{
		pitch = ( y > 0.f ) ? 270.f : 90.f;
	}

	return { AngleNormalize( pitch ),
					 AngleNormalize( yaw ),
					 0.f };
}

float Vector3::operator[]( std::size_t index ) const
{
	return ( &x )[ index ];
}

float& Vector3::operator[]( std::size_t index )
{
	return ( &x )[ index ];
}

Vector3& Vector3::operator=( const Vector3& vector )
{
	if( std::addressof( vector ) != this )
	{
		x = vector[ 0 ];
		y = vector[ 1 ];
		z = vector[ 2 ];
	}
	return ( *this );
}

Vector3& Vector3::operator+=( float value )
{
	x += value;
	y += value;
	z += value;
	return ( *this );
}

Vector3& Vector3::operator-=( float value )
{
	x -= value;
	y -= value;
	z -= value;
	return ( *this );
}

Vector3& Vector3::operator*=( float value )
{
	x *= value;
	y *= value;
	z *= value;
	return ( *this );
}

Vector3& Vector3::operator/=( float value )
{
	x /= value;
	y /= value;
	z /= value;
	return ( *this );
}

Vector3& Vector3::operator+=( const Vector3& vector )
{
	x += vector[ 0 ];
	y += vector[ 1 ];
	z += vector[ 2 ];
	return ( *this );
}

Vector3& Vector3::operator-=( const Vector3& vector )
{
	x -= vector[ 0 ];
	y -= vector[ 1 ];
	z -= vector[ 2 ];
	return ( *this );
}

Vector3& Vector3::operator*=( const Vector3& vector )
{
	x *= vector[ 0 ];
	y *= vector[ 1 ];
	z *= vector[ 2 ];
	return ( *this );
}

Vector3& Vector3::operator/=( const Vector3& vector )
{
	x /= vector[ 0 ];
	y /= vector[ 1 ];
	z /= vector[ 2 ];
	return ( *this );
}

Vector3 Vector3::operator+( float value ) const
{
	return { x + value,
					 y + value,
					 z + value };
}

Vector3 Vector3::operator-( float value ) const
{
	return { x - value,
					 y - value,
					 z - value };
}

Vector3 Vector3::operator*( float value ) const
{
	return { x * value,
					 y * value,
					 z * value };
}

Vector3 Vector3::operator/( float value ) const
{
	return { x / value,
					 y / value,
					 z / value };
}

Vector3 Vector3::operator+( const Vector3& vector ) const
{
	return { x + vector[ 0 ],
					 y + vector[ 1 ],
					 z + vector[ 2 ] };
}

Vector3 Vector3::operator-( const Vector3& vector ) const
{
	return { x - vector[ 0 ],
					 y - vector[ 1 ],
					 z - vector[ 2 ] };
}

Vector3 Vector3::operator*( const Vector3& vector ) const
{
	return { x * vector[ 0 ],
					 y * vector[ 1 ],
					 z * vector[ 2 ] };
}

Vector3 Vector3::operator/( const Vector3& vector ) const
{
	return { x / vector[ 0 ],
					 y / vector[ 1 ],
					 z / vector[ 2 ] };
}
```

`rust/unity/engine/vector3.hpp`:

```hpp
#pragma once

#include "math.hpp"

class Vector3
{
public:
	Vector3();
	Vector3( float vector_x, float vector_y, float vector_z );
	Vector3( const Vector3& vector );

public:
	float Dot( const Vector3& vector ) const;

	float Length2DSquared() const;
	float Length2D() const;

	float LengthSquared() const;
	float Length() const;

	float DistanceSquared( const Vector3& vector ) const;
	float Distance( const Vector3& vector ) const;

	float Normalize();

public:
	Vector3 Normalized();
	
	Vector3 ToEulerAngles();

public:
	float operator[]( std::size_t index ) const;
	float& operator[]( std::size_t index );

public:
	Vector3& operator=( const Vector3& vector );

public:
	Vector3& operator+=( float value );
	Vector3& operator-=( float value );
	Vector3& operator*=( float value );
	Vector3& operator/=( float value );

	Vector3& operator+=( const Vector3& vector );
	Vector3& operator-=( const Vector3& vector );
	Vector3& operator*=( const Vector3& vector );
	Vector3& operator/=( const Vector3& vector );

public:
	Vector3 operator+( float value ) const;
	Vector3 operator-( float value ) const;
	Vector3 operator*( float value ) const;
	Vector3 operator/( float value ) const;

	Vector3 operator+( const Vector3& vector ) const;
	Vector3 operator-( const Vector3& vector ) const;
	Vector3 operator*( const Vector3& vector ) const;
	Vector3 operator/( const Vector3& vector ) const;

public:
	float x = 0.f;	// 0x0000
	float y = 0.f;	// 0x0004
	float z = 0.f;	// 0x0008
};
// sizeof( Vector3 ) = 0x000C
```

`rust/unity/il2cpp/il2cpp-api-functions.hpp`:

```hpp
#pragma once

```

`rust/unity/il2cpp/il2cpp-api-types.hpp`:

```hpp
#pragma once

#include <horizon/include/auto.hpp>
#include <horizon/include/base.hpp>
#include <horizon/include/win32.hpp>

#include <horizon/memory/operation.hpp>

struct MethodInfo;

enum class Il2CppProfileFlags
{
	IL2CPP_PROFILE_NONE = 0,
	IL2CPP_PROFILE_APPDOMAIN_EVENTS = 1 << 0,
	IL2CPP_PROFILE_ASSEMBLY_EVENTS = 1 << 1,
	IL2CPP_PROFILE_MODULE_EVENTS = 1 << 2,
	IL2CPP_PROFILE_CLASS_EVENTS = 1 << 3,
	IL2CPP_PROFILE_JIT_COMPILATION = 1 << 4,
	IL2CPP_PROFILE_INLINING = 1 << 5,
	IL2CPP_PROFILE_EXCEPTIONS = 1 << 6,
	IL2CPP_PROFILE_ALLOCATIONS = 1 << 7,
	IL2CPP_PROFILE_GC = 1 << 8,
	IL2CPP_PROFILE_THREADS = 1 << 9,
	IL2CPP_PROFILE_REMOTING = 1 << 10,
	IL2CPP_PROFILE_TRANSITIONS = 1 << 11,
	IL2CPP_PROFILE_ENTER_LEAVE = 1 << 12,
	IL2CPP_PROFILE_COVERAGE = 1 << 13,
	IL2CPP_PROFILE_INS_COVERAGE = 1 << 14,
	IL2CPP_PROFILE_STATISTICAL = 1 << 15,
	IL2CPP_PROFILE_METHOD_EVENTS = 1 << 16,
	IL2CPP_PROFILE_MONITOR_EVENTS = 1 << 17,
	IL2CPP_PROFILE_IOMAP_EVENTS = 1 << 18,
	IL2CPP_PROFILE_GC_MOVES = 1 << 19,
	IL2CPP_PROFILE_FILEIO = 1 << 20,
};
// sizeof( Il2CppProfileFlags ) = 0x0004

enum class Il2CppProfileFileIOKind
{
	IL2CPP_PROFILE_FILEIO_WRITE = 0,
	IL2CPP_PROFILE_FILEIO_READ,
};
// sizeof( Il2CppProfileFileIOKind ) = 0x0004

enum class Il2CppGCEvent
{
	IL2CPP_GC_EVENT_START,
	IL2CPP_GC_EVENT_MARK_START,
	IL2CPP_GC_EVENT_MARK_END,
	IL2CPP_GC_EVENT_RECLAIM_START,
	IL2CPP_GC_EVENT_RECLAIM_END,
	IL2CPP_GC_EVENT_END,
	IL2CPP_GC_EVENT_PRE_STOP_WORLD,
	IL2CPP_GC_EVENT_POST_STOP_WORLD,
	IL2CPP_GC_EVENT_PRE_START_WORLD,
	IL2CPP_GC_EVENT_POST_START_WORLD,
};
// sizeof( Il2CppGCEvent ) = 0x0004

enum class Il2CppStat
{
	IL2CPP_STAT_NEW_OBJECT_COUNT,
	IL2CPP_STAT_INITIALIZED_CLASS_COUNT,
	IL2CPP_STAT_METHOD_COUNT,
	IL2CPP_STAT_CLASS_STATIC_DATA_SIZE,
	IL2CPP_STAT_GENERIC_INSTANCE_COUNT,
	IL2CPP_STAT_GENERIC_CLASS_COUNT,
	IL2CPP_STAT_INFLATED_METHOD_COUNT,
	IL2CPP_STAT_INFLATED_TYPE_COUNT,
};
// sizeof( Il2CppStat ) = 0x0004

enum class Il2CppRuntimeUnhandledExceptionPolicy
{
	IL2CPP_UNHANDLED_POLICY_LEGACY,
	IL2CPP_UNHANDLED_POLICY_CURRENT,
};
// sizeof( Il2CppRuntimeUnhandledExceptionPolicy ) = 0x0004

struct Il2CppStackFrameInfo
{
	const MethodInfo* method = nullptr;	// 0x0000
};
// sizeof( Il2CppStackFrameInfo ) = 0x0008

struct Il2CppMemoryCallbacks
{
	void*( *malloc_func )( std::size_t size ) = nullptr;																						// 0x0000
	void*( *aligned_malloc_func )( std::size_t size, std::size_t alignment ) = nullptr;							// 0x0008
	void( *free_func )( void* ptr ) = nullptr;																											// 0x0010
	void( *aligned_free_func )( void* ptr ) = nullptr;																							// 0x0018
	void*( *calloc_func )( std::size_t nmemb, std::size_t size ) = nullptr;													// 0x0020
	void*( *realloc_func )( void* ptr, std::size_t size ) = nullptr;																// 0x0028
	void*( *aligned_realloc_func )( void* ptr, std::size_t size, std::size_t alignment ) = nullptr;	// 0x0030
};
// sizeof( Il2CppMemoryCallbacks ) = 0x0038

using Il2CppChar = wchar_t;
// sizeof( Il2CppChar ) = 0x0002

using Il2CppNativeChar = wchar_t;
// sizeof( Il2CppNativeChar ) = 0x0002

#define IL2CPP_NATIVE_STRING( str )		L ## str

using Il2CppMethodPointer = void( * )();
// sizeof( Il2CppMethodPointer ) = 0x0008

#define ARRAY_LENGTH_AS_INT32( a )		( ( std::int32_t )a )
```

`rust/unity/il2cpp/il2cpp-api.cpp`:

```cpp
#include "il2cpp-api.hpp"

#include "../sdk.hpp"

void il2cpp_init()
{
	const auto game_assembly = win32::GetImage( HASH( L"GameAssembly.dll" ) );

	if( memory::IsAddressValid( game_assembly ) )
	{
		
	}
}

void il2cpp_shutdown()
{ }
```

`rust/unity/il2cpp/il2cpp-api.hpp`:

```hpp
#pragma once

#include <horizon/include/auto.hpp>
#include <horizon/include/base.hpp>
#include <horizon/include/win32.hpp>

#include <horizon/memory/operation.hpp>

#include "il2cpp-config-api.hpp"
#include "il2cpp-class-internals.hpp"
#include "il2cpp-object-internals.hpp"

#define DO_API( return_type, name, parameters )	extern return_type ( *name ) parameters


```

`rust/unity/il2cpp/il2cpp-blob.hpp`:

```hpp
#pragma once

#include <horizon/include/auto.hpp>
#include <horizon/include/base.hpp>
#include <horizon/include/win32.hpp>

#include <horizon/memory/operation.hpp>

enum class Il2CppTypeEnum
{
	IL2CPP_TYPE_END = 0x00,
	IL2CPP_TYPE_VOID = 0x01,
	IL2CPP_TYPE_BOOLEAN = 0x02,
	IL2CPP_TYPE_CHAR = 0x03,
	IL2CPP_TYPE_I1 = 0x04,
	IL2CPP_TYPE_U1 = 0x05,
	IL2CPP_TYPE_I2 = 0x06,
	IL2CPP_TYPE_U2 = 0x07,
	IL2CPP_TYPE_I4 = 0x08,
	IL2CPP_TYPE_U4 = 0x09,
	IL2CPP_TYPE_I8 = 0x0A,
	IL2CPP_TYPE_U8 = 0x0B,
	IL2CPP_TYPE_R4 = 0x0C,
	IL2CPP_TYPE_R8 = 0x0D,
	IL2CPP_TYPE_STRING = 0x0E,
	IL2CPP_TYPE_PTR = 0x0F,
	IL2CPP_TYPE_BYREF = 0x10,
	IL2CPP_TYPE_VALUETYPE = 0x11,
	IL2CPP_TYPE_CLASS = 0x12,
	IL2CPP_TYPE_VAR = 0x13,
	IL2CPP_TYPE_ARRAY = 0x14,
	IL2CPP_TYPE_GENERICINST = 0x15,
	IL2CPP_TYPE_TYPEDBYREF = 0x16,
	IL2CPP_TYPE_I = 0x18,
	IL2CPP_TYPE_U = 0x19,
	IL2CPP_TYPE_FNPTR = 0x1B,
	IL2CPP_TYPE_OBJECT = 0x1C,
	IL2CPP_TYPE_SZARRAY = 0x1D,
	IL2CPP_TYPE_MVAR = 0x1E,
	IL2CPP_TYPE_CMOD_REQD = 0x1F,
	IL2CPP_TYPE_CMOD_OPT = 0x20,
	IL2CPP_TYPE_INTERNAL = 0x21,
	IL2CPP_TYPE_MODIFIER = 0x40,
	IL2CPP_TYPE_SENTINEL = 0x41,
	IL2CPP_TYPE_PINNED = 0x45,
	IL2CPP_TYPE_ENUM = 0x55,
};
// sizeof( Il2CppTypeEnum ) = 0x0004
```

`rust/unity/il2cpp/il2cpp-class-internals.hpp`:

```hpp
#pragma once

#include <horizon/include/auto.hpp>
#include <horizon/include/base.hpp>
#include <horizon/include/win32.hpp>

#include <horizon/memory/operation.hpp>

#include "il2cpp-metadata.hpp"
#include "il2cpp-runtime-metadata.hpp"

#define IL2CPP_CLASS_IS_ARRAY( c )	( ( c )->rank )

struct Il2CppIUnknown;

struct Il2CppGuid;
struct Il2CppImage;
struct Il2CppDomain;
struct Il2CppAssembly;
struct Il2CppAppDomain;
struct Il2CppAppDomainSetup;
struct Il2CppDelegate;
struct Il2CppAppContext;
struct Il2CppClass;
struct Il2CppObject;
struct Il2CppNameToTypeDefinitionIndexHashTable;

struct MethodInfo;
struct FieldInfo;
struct MemberInfo;

struct VirtualInvokeData
{
	Il2CppMethodPointer methodPtr = nullptr;	// 0x0000
	const MethodInfo* method = nullptr;				// 0x0008
};
// sizeof( VirtualInvokeData ) = 0x0010

enum class Il2CppTypeNameFormat
{
	IL2CPP_TYPE_NAME_FORMAT_IL,
	IL2CPP_TYPE_NAME_FORMAT_REFLECTION,
	IL2CPP_TYPE_NAME_FORMAT_FULL_NAME,
	IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED,
};
// sizeof( Il2CppTypeNameFormat ) = 0x0004

struct CustomAttributesCache
{
	std::int32_t count = 0;								// 0x0000
	FIELD_PAD( 0x0004 );									// 0x0004
	Il2CppObject** attributes = nullptr;	// 0x0008
};
// sizeof( CustomAttributesCache ) = 0x0010

using CustomAttributesCacheGenerator = void( * )( CustomAttributesCache* );
// sizeof( CustomAttributesCacheGenerator ) = 0x0008

constexpr std::int32_t THREAD_STATIC_FIELD_OFFSET = -1;

struct FieldInfo
{
	const char* name = nullptr;				// 0x0000
	const Il2CppType* type = nullptr;	// 0x0008
	Il2CppClass* parent = nullptr;		// 0x0010
	std::int32_t offset = -1;					// 0x0018
	std::uint32_t token = 0;					// 0x001C
};
// sizeof( FieldInfo ) = 0x0020

struct PropertyInfo
{
	Il2CppClass* parent = nullptr;		// 0x0000
	const char* name = nullptr;				// 0x0008
	const MethodInfo* get = nullptr;	// 0x0010
	const MethodInfo* set = nullptr;	// 0x0018
	std::uint32_t attrs = 0;					// 0x0020
	std::uint32_t token = 0;					// 0x0024
};
// sizeof( PropertyInfo ) = 0x0028

struct EventInfo
{
	const char* name = nullptr;							// 0x0000
	const Il2CppType* eventType = nullptr;	// 0x0008
	Il2CppClass* parent = nullptr;					// 0x0010
	const MethodInfo* add = nullptr;				// 0x0018
	const MethodInfo* remove = nullptr;			// 0x0020
	const MethodInfo* raise = nullptr;			// 0x0028
	std::uint32_t token = 0;								// 0x0030
	FIELD_PAD( 0x0004 );										// 0x0034
};
// sizeof( EventInfo ) = 0x0038

struct ParameterInfo
{
	const char* name = nullptr;									// 0x0000
	std::int32_t position = 0;									// 0x0008
	std::uint32_t token = 0;										// 0x000C
	const Il2CppType* parameter_type = nullptr;	// 0x0010
};
// sizeof( ParameterInfo ) = 0x0018

using InvokerMethod = void*( * )( Il2CppMethodPointer, const MethodInfo*, void*, void** );
// sizeof( InvokerMethod ) = 0x0008

enum class MethodVariableKind
{
	kMethodVariableKind_This,
	kMethodVariableKind_Parameter,
	kMethodVariableKind_LocalVariable,
};
// sizeof( MethodVariableKind ) = 0x0004

enum class SequencePointKind
{
	kSequencePointKind_Normal,
	kSequencePointKind_StepOut,
};
// sizeof( SequencePointKind ) = 0x0004

struct Il2CppMethodExecutionContextInfo
{
	std::int32_t typeIndex = -1;	// 0x0000
	std::int32_t nameIndex = -1;	// 0x0004
	std::int32_t scopeIndex = -1;	// 0x0008
};
// sizeof( Il2CppMethodExecutionContextInfo ) = 0x000C

struct Il2CppMethodExecutionContextInfoIndex
{
	std::int8_t tableIndex = 0;		// 0x0000
	FIELD_PAD( 0x0003 );					// 0x0001
	std::int32_t startIndex = 0;	// 0x0004
	std::int32_t count = 0;				// 0x0008
};
// sizeof( Il2CppMethodExecutionContextInfoIndex ) = 0x000C

struct Il2CppMethodScope
{
	std::int32_t startOffset = 0;	// 0x0000
	std::int32_t endOffset = 0;		// 0x0004
};
// sizeof( Il2CppMethodScope ) = 0x0008

union Il2CppRGCTXData
{
	void* rgctxDataDummy = nullptr;	// 0x0000
	const MethodInfo* method;				// 0x0000
	const Il2CppType* type;					// 0x0000
	Il2CppClass* klass;							// 0x0000
};
// sizeof( Il2CppRGCTXData ) = 0x0008

struct MethodInfo
{
	Il2CppMethodPointer methodPointer = nullptr;					// 0x0000
	InvokerMethod invoker_method = nullptr;								// 0x0008
	const char* name = nullptr;														// 0x0010
	Il2CppClass* klass = nullptr;													// 0x0018
	const Il2CppType* return_type = nullptr;							// 0x0020
	const ParameterInfo* parameters = nullptr;						// 0x0028
	union
	{
		const Il2CppRGCTXData* rgctx_data = nullptr;				// 0x0030
		const Il2CppMethodDefinition* methodDefinition;			// 0x0030
	};
	union
	{
		const Il2CppGenericMethod* genericMethod = nullptr;	// 0x0038
		const Il2CppGenericContainer* genericContainer;			// 0x0038
	};
	std::uint32_t token = 0;															// 0x0040
	std::uint16_t flags = 0;															// 0x0044
	std::uint16_t iflags = 0;															// 0x0046
	std::uint16_t slot = 0;																// 0x0048
	std::uint8_t parameters_count = 0;										// 0x004A
	std::uint8_t is_generic : 1;													// 0x004B
	std::uint8_t is_inflated : 1;													// 0x004B
	std::uint8_t wrapper_type : 1;												// 0x004B
	std::uint8_t is_marshaled_from_native : 1;						// 0x004B
	FIELD_PAD( 0x0004 );																	// 0x004C
};
// sizeof( MethodInfo ) = 0x0050

struct Il2CppRuntimeInterfaceOffsetPair
{
	Il2CppClass* interfaceType = nullptr;	// 0x0000
	std::int32_t offset = -1;							// 0x0008
	FIELD_PAD( 0x0004 );									// 0x000C
};
// sizeof( Il2CppRuntimeInterfaceOffsetPair ) = 0x0010

using PInvokeMarshalToNativeFunc = void( * )( void* managedStructure, void* marshaledStructure );
// sizeof( PInvokeMarshalToNativeFunc ) = 0x0008

using PInvokeMarshalFromNativeFunc = void( * )( void* marshaledStructure, void* managedStructure );
// sizeof( PInvokeMarshalFromNativeFunc ) = 0x0008

using PInvokeMarshalCleanupFunc = void( * )( void* marshaledStructure );
// sizeof( PInvokeMarshalCleanupFunc ) = 0x0008

using CreateCCWFunc = Il2CppIUnknown*( * )( Il2CppObject* obj );
// sizeof( CreateCCWFunc ) = 0x0008

struct Il2CppInteropData
{
	Il2CppMethodPointer delegatePInvokeWrapperFunction = nullptr;							// 0x0000
	PInvokeMarshalToNativeFunc pinvokeMarshalToNativeFunction = nullptr;			// 0x0008
	PInvokeMarshalFromNativeFunc  pinvokeMarshalFromNativeFunction = nullptr;	// 0x0010
	PInvokeMarshalCleanupFunc pinvokeMarshalCleanupFunction = nullptr;				// 0x0018
	CreateCCWFunc createCCWFunction = nullptr;																// 0x0020
	const Il2CppGuid* guid = nullptr;																					// 0x0028
	const Il2CppType* type = nullptr;																					// 0x0030
};
// sizeof( Il2CppInteropData ) = 0x0038

struct Il2CppClass
{
	const Il2CppImage* image = nullptr;														// 0x0000
	void* gc_desc = nullptr;																			// 0x0008
	const char* name = nullptr;																		// 0x0010
	const char* namespaze = nullptr;															// 0x0018
	Il2CppType byval_arg = { };																		// 0x0020
	Il2CppType this_arg = { };																		// 0x0030
	Il2CppClass* element_class = nullptr;													// 0x0040
	Il2CppClass* castClass = nullptr;															// 0x0048
	Il2CppClass* declaringType = nullptr;													// 0x0050
	Il2CppClass* parent = nullptr;																// 0x0058
	Il2CppGenericClass* generic_class = nullptr;									// 0x0060
	const Il2CppTypeDefinition* typeDefinition = nullptr;					// 0x0068
	const Il2CppInteropData* interopData = nullptr;								// 0x0070
	Il2CppClass* klass = nullptr;																	// 0x0078
	FieldInfo* fields = nullptr;																	// 0x0080
	const EventInfo* events = nullptr;														// 0x0088
	const PropertyInfo* properties = nullptr;											// 0x0090
	const MethodInfo** methods = nullptr;													// 0x0098
	Il2CppClass** nestedTypes = nullptr;													// 0x00A0
	Il2CppClass** implementedInterfaces = nullptr;								// 0x00A8
	Il2CppRuntimeInterfaceOffsetPair* interfaceOffsets = nullptr;	// 0x00B0
	void* static_fields = nullptr;																// 0x00B8
	const Il2CppRGCTXData* rgctx_data = nullptr;									// 0x00C0
	Il2CppClass** typeHierarchy = nullptr;												// 0x00C8
	std::uint32_t initializationExceptionGCHandle = 0;						// 0x00D0
	std::uint32_t cctor_started = 0;															// 0x00D4
	std::uint32_t cctor_finished = 0;															// 0x00D8
	FIELD_PAD( 0x0004 );																					// 0x00DC
	ALIGN_TYPE( 8 ) std::uint64_t cctor_thread = 0;								// 0x00E0
	std::int32_t genericContainerIndex = -1;											// 0x00E8
	std::uint32_t instance_size = 0;															// 0x00EC
	std::uint32_t actualSize = 0;																	// 0x00F0
	std::uint32_t element_size = 0;																// 0x00F4
	std::int32_t native_size = 0;																	// 0x00F8
	std::uint32_t static_fields_size = 0;													// 0x00FC
	std::uint32_t thread_static_fields_size = 0;									// 0x0100
	std::int32_t thread_static_fields_offset = -1;								// 0x0104
	std::uint32_t flags = 0;																			// 0x0108
	std::uint32_t token = 0;																			// 0x010C
	std::uint16_t method_count = 0;																// 0x0110
	std::uint16_t property_count = 0;															// 0x0112
	std::uint16_t field_count = 0;																// 0x0114
	std::uint16_t event_count = 0;																// 0x0116
	std::uint16_t nested_type_count = 0;													// 0x0118
	std::uint16_t vtable_count = 0;																// 0x011A
	std::uint16_t interfaces_count = 0;														// 0x011C
	std::uint16_t interface_offsets_count = 0;										// 0x011E
	std::uint8_t typeHierarchyDepth = 0;													// 0x0120
	std::uint8_t genericRecursionDepth = 0;												// 0x0121
	std::uint8_t rank = 0;																				// 0x0122
	std::uint8_t minimumAlignment = 0;														// 0x0123
	std::uint8_t naturalAligment = 0;															// 0x0124
	std::uint8_t packingSize = 0;																	// 0x0125
	std::uint8_t initialized_and_no_error : 1;										// 0x0126
	std::uint8_t valuetype : 1;																		// 0x0126
	std::uint8_t initialized : 1;																	// 0x0126
	std::uint8_t enumtype : 1;																		// 0x0126
	std::uint8_t is_generic : 1;																	// 0x0126
	std::uint8_t has_references : 1;															// 0x0126
	std::uint8_t init_pending : 1;																// 0x0126
	std::uint8_t size_inited : 1;																	// 0x0126
	std::uint8_t has_finalize : 1;																// 0x0127
	std::uint8_t has_cctor : 1;																		// 0x0127
	std::uint8_t is_blittable : 1;																// 0x0127
	std::uint8_t is_import_or_windows_runtime : 1;								// 0x0127
	std::uint8_t is_vtable_initialized : 1;												// 0x0127
	std::uint8_t has_initialization_error : 1;										// 0x0127
	VirtualInvokeData vtable[ IL2CPP_ZERO_LEN_ARRAY ];						// 0x0128
};
// sizeof( Il2CppClass ) = 0x0128

struct Il2CppTypeDefinitionSizes
{
	std::uint32_t instance_size = 0;							// 0x0000
	std::int32_t native_size = 0;									// 0x0004
	std::uint32_t static_fields_size = 0;					// 0x0008
	std::uint32_t thread_static_fields_size = 0;	// 0x000C
};
// sizeof( Il2CppTypeDefinitionSizes ) = 0x0010

struct Il2CppDomain
{
	Il2CppAppDomain* domain = nullptr;						// 0x0000
	Il2CppAppDomainSetup* setup = nullptr;				// 0x0008
	Il2CppAppContext* default_context = nullptr;	// 0x0010
	const char* friendly_name = nullptr;					// 0x0018
	std::uint32_t domain_id = 0;									// 0x0020
	FIELD_PAD( 0x0004 );													// 0x0024
	void* agent_info = nullptr;										// 0x0028
};
// sizeof( Il2CppDomain ) = 0x0030

struct Il2CppAssemblyName
{
	const char* name = nullptr;																		// 0x0000
	const char* culture = nullptr;																// 0x0008
	const char* hash_value = nullptr;															// 0x0010
	const char* public_key = nullptr;															// 0x0018
	std::uint32_t hash_alg = 0;																		// 0x0020
	std::int32_t hash_len = 0;																		// 0x0024
	std::uint32_t flags = 0;																			// 0x0028
	std::int32_t major = 0;																				// 0x002C
	std::int32_t minor = 0;																				// 0x0030
	std::int32_t build = 0;																				// 0x0034
	std::int32_t revision = 0;																		// 0x0038
	FIELD_PAD( 0x0004 );																					// 0x003C
	std::uint8_t public_key_token[ kPublicKeyByteLength ] = { };	// 0x0040
};
// sizeof( Il2CppAssemblyName ) = 0x0048

struct Il2CppImage
{
	const char* name = nullptr;																								// 0x0000
	const char* nameNoExt = nullptr;																					// 0x0008
	Il2CppAssembly* assembly = nullptr;																				// 0x0010
	std::int32_t typeStart = -1;																							// 0x0018
	std::uint32_t typeCount = 0;																							// 0x001C
	std::int32_t exportedTypeStart = -1;																			// 0x0020
	std::uint32_t exportedTypeCount = 0;																			// 0x0024
	std::int32_t CustomAttributeStart = -1;																		// 0x0028
	std::uint32_t CustomAttributeCount = 0;																		// 0x002C
	std::int32_t entryPointIndex = -1;																				// 0x0030
	FIELD_PAD( 0x0004 );																											// 0x0034
	Il2CppNameToTypeDefinitionIndexHashTable* nameToClassHashTable = nullptr;	// 0x0038
	std::uint32_t token = 0;																									// 0x0040
	std::uint8_t dynamic = 0;																									// 0x0044
	FIELD_PAD( 0x0003 );																											// 0x0045
};
// sizeof( Il2CppImage ) = 0x0048

struct Il2CppAssembly
{
	Il2CppImage* image = nullptr;								// 0x0000
	std::uint32_t token = 0;										// 0x0008
	std::int32_t referencedAssemblyStart = -1;	// 0x000C
	std::int32_t referencedAssemblyCount = 0;		// 0x0010
	FIELD_PAD( 0x0004 );												// 0x0014
	Il2CppAssemblyName aname = { };							// 0x0018
};
// sizeof( Il2CppAssembly ) = 0x0060

struct Il2CppCodeGenOptions
{
	bool enablePrimitiveValueTypeGenericSharing = false;	// 0x0000
};
// sizeof( Il2CppCodeGenOptions ) = 0x0001
```

`rust/unity/il2cpp/il2cpp-config-api.hpp`:

```hpp
#pragma once

#include <horizon/include/auto.hpp>
#include <horizon/include/base.hpp>
#include <horizon/include/win32.hpp>

#include <horizon/memory/operation.hpp>

#include "il2cpp-api-types.hpp"
```

`rust/unity/il2cpp/il2cpp-config.hpp`:

```hpp
#pragma once

#include <horizon/include/auto.hpp>
#include <horizon/include/base.hpp>
#include <horizon/include/win32.hpp>

#include <horizon/memory/operation.hpp>

#include "il2cpp-config-api.hpp"

#define ALIGN_OF( T )						__alignof( T )
#define ALIGN_TYPE( val )				
#define ALIGN_FIELD( val )			__declspec( align( val ) )

#define IL2CPP_PAGE_SIZE				4096

#define IL2CPP_ZERO_LEN_ARRAY		0

using Il2CppMethodSlot = std::uint32_t;
// sizeof( Il2CppMethodSlot ) = 0x0004

constexpr Il2CppMethodSlot kInvalidIl2CppMethodSlot = 65535;
// sizeof( kInvalidIl2CppMethodSlot ) = 0x0004

#define IL2CPP_DIR_SEPARATOR		'\\'

constexpr Il2CppChar kIl2CppNewLine[] = { '\r', '\n', '\0' };
// sizeof( kIl2CppNewLine ) = 0x0006
```

`rust/unity/il2cpp/il2cpp-metadata.hpp`:

```hpp
#pragma once

#include <horizon/include/auto.hpp>
#include <horizon/include/base.hpp>
#include <horizon/include/win32.hpp>

#include <horizon/memory/operation.hpp>

#include "il2cpp-config.hpp"

enum class Il2CppMetadataUsage
{
	kIl2CppMetadataUsageInvalid,
	kIl2CppMetadataUsageTypeInfo,
	kIl2CppMetadataUsageIl2CppType,
	kIl2CppMetadataUsageMethodDef,
	kIl2CppMetadataUsageFieldInfo,
	kIl2CppMetadataUsageStringLiteral,
	kIl2CppMetadataUsageMethodRef,
};
// sizeof( Il2CppMetadataUsage ) = 0x0004

static inline Il2CppMetadataUsage GetEncodedIndexType( std::uint32_t index )
{
	return static_cast< Il2CppMetadataUsage >( ( index & 0xE0000000 ) >> 29 );
}

static inline std::uint32_t GetDecodedMethodIndex( std::uint32_t index )
{
	return ( index & 0x1FFFFFFF );
}

struct Il2CppImage;
struct Il2CppType;
struct Il2CppTypeDefinitionMetadata;

union Il2CppRGCTXDefinitionData
{
	std::int32_t rgctxDataDummy = -1;	// 0x0000
	std::int32_t methodIndex;					// 0x0000
	std::int32_t typeIndex;						// 0x0000
};
// sizeof( Il2CppRGCTXDefinitionData ) = 0x0004

enum class Il2CppRGCTXDataType
{
	IL2CPP_RGCTX_DATA_INVALID,
	IL2CPP_RGCTX_DATA_TYPE,
	IL2CPP_RGCTX_DATA_CLASS,
	IL2CPP_RGCTX_DATA_METHOD,
	IL2CPP_RGCTX_DATA_ARRAY,
};
// sizeof( Il2CppRGCTXDataType ) = 0x0004

struct Il2CppRGCTXDefinition
{
	Il2CppRGCTXDataType type = Il2CppRGCTXDataType::IL2CPP_RGCTX_DATA_INVALID;	// 0x0000
	Il2CppRGCTXDefinitionData data = { };																				// 0x0004
};
// sizeof( Il2CppRGCTXDefinition ) = 0x0008

struct Il2CppInterfaceOffsetPair
{
	std::int32_t interfaceTypeIndex = -1;	// 0x0000
	std::int32_t offset = 0;							// 0x0004
};
// sizeof( Il2CppInterfaceOffsetPair ) = 0x0008

struct Il2CppTypeDefinition
{
	std::int32_t nameIndex = -1;								// 0x0000
	std::int32_t namespaceIndex = -1;						// 0x0004
	std::int32_t byvalTypeIndex = -1;						// 0x0008
	std::int32_t byrefTypeIndex = -1;						// 0x000C
	std::int32_t declaringTypeIndex = -1;				// 0x0010
	std::int32_t parentIndex = -1;							// 0x0014
	std::int32_t elementTypeIndex = -1;					// 0x0018
	std::int32_t rgctxStartIndex = -1;					// 0x001C
	std::int32_t rgctxCount = 0;								// 0x0020
	std::int32_t genericContainerIndex = -1;		// 0x0024
	std::uint32_t flags = 0;										// 0x0028
	std::int32_t fieldStart = -1;								// 0x002C
	std::int32_t methodStart = -1;							// 0x0030
	std::int32_t eventStart = -1;								// 0x0034
	std::int32_t propertyStart = -1;						// 0x0038
	std::int32_t nestedTypesStart = -1;					// 0x003C
	std::int32_t interfacesStart = -1;					// 0x0040
	std::int32_t vtableStart = -1;							// 0x0044
	std::int32_t interfaceOffsetsStart = -1;		// 0x0048
	std::uint16_t method_count = 0;							// 0x004C
	std::uint16_t property_count = 0;						// 0x004E
	std::uint16_t field_count = 0;							// 0x0050
	std::uint16_t event_count = 0;							// 0x0052
	std::uint16_t nested_type_count = 0;				// 0x0054
	std::uint16_t vtable_count = 0;							// 0x0056
	std::uint16_t interfaces_count = 0;					// 0x0058
	std::uint16_t interface_offsets_count = 0;	// 0x005A
	std::uint32_t bitfield = 0;									// 0x005C
	std::uint32_t token = 0;										// 0x0060
};
// sizeof( Il2CppTypeDefinition ) = 0x0064

struct Il2CppFieldDefinition
{
	std::int32_t nameIndex = -1;	// 0x0000
	std::int32_t typeIndex = -1;	// 0x0004
	std::uint32_t token = 0;			// 0x0008
};
// sizeof( Il2CppFieldDefinition ) = 0x000C

struct Il2CppFieldDefaultValue
{
	std::int32_t fieldIndex = -1;	// 0x0000
	std::int32_t typeIndex = -1;	// 0x0004
	std::int32_t dataIndex = -1;	// 0x0008
};
// sizeof( Il2CppFieldDefaultValue ) = 0x000C

struct Il2CppFieldMarshaledSize
{
	std::int32_t fieldIndex = -1;	// 0x0000
	std::int32_t typeIndex = -1;	// 0x0004
	std::int32_t size = 0;				// 0x0008
};
// sizeof( Il2CppFieldMarshaledSize ) = 0x000C

struct Il2CppFieldRef
{
	std::int32_t typeIndex = -1;	// 0x0000
	std::int32_t fieldIndex = -1;	// 0x0004
};
// sizeof( Il2CppFieldRef ) = 0x0008

struct Il2CppParameterDefinition
{
	std::int32_t nameIndex = -1;	// 0x0000
	std::uint32_t token = 0;			// 0x0004
	std::int32_t typeIndex = -1;	// 0x0008
};
// sizeof( Il2CppParameterDefinition ) = 0x000C

struct Il2CppParameterDefaultValue
{
	std::int32_t parameterIndex = -1;	// 0x0000
	std::int32_t typeIndex = -1;			// 0x0004
	std::int32_t dataIndex = -1;			// 0x0008
};
// sizeof( Il2CppParameterDefaultValue ) = 0x000C

struct Il2CppMethodDefinition
{
	std::int32_t nameIndex = -1;									// 0x0000
	std::int32_t declaringType = -1;							// 0x0004
	std::int32_t returnType = -1;									// 0x0008
	std::int32_t parameterStart = -1;							// 0x000C
	std::int32_t genericContainerIndex = -1;			// 0x0010
	std::int32_t methodIndex = -1;								// 0x0014
	std::int32_t invokerIndex = -1;								// 0x0018
	std::int32_t reversePInvokeWrapperIndex = -1;	// 0x001C
	std::int32_t rgctxStartIndex = -1;						// 0x0020
	std::int32_t rgctxCount = 0;									// 0x0024
	std::uint32_t token = 0;											// 0x0028
	std::uint16_t flags = 0;											// 0x002C
	std::uint16_t iflags = 0;											// 0x002E
	std::uint16_t slot = 0;												// 0x0030
	std::uint16_t parameterCount = 0;							// 0x0032
};
// sizeof( Il2CppMethodDefinition ) = 0x0034

struct Il2CppEventDefinition
{
	std::int32_t nameIndex = -1;	// 0x0000
	std::int32_t typeIndex = -1;	// 0x0004
	std::int32_t add = -1;				// 0x0008
	std::int32_t remove = -1;			// 0x000C
	std::int32_t raise = -1;			// 0x0010
	std::uint32_t token = 0;			// 0x0014
};
// sizeof( Il2CppEventDefinition ) = 0x0018

struct Il2CppPropertyDefinition
{
	std::int32_t nameIndex = -1;	// 0x0000
	std::int32_t get = -1;				// 0x0004
	std::int32_t set = -1;				// 0x0008
	std::uint32_t attrs = 0;			// 0x000C
	std::uint32_t token = 0;			// 0x0010
};
// sizeof( Il2CppPropertyDefinition ) = 0x0014

struct Il2CppMethodSpec
{
	std::int32_t methodDefinitionIndex = -1;	// 0x0000
	std::int32_t classIndexIndex = -1;				// 0x0004
	std::int32_t methodIndexIndex = -1;				// 0x0008
};
// sizeof( Il2CppMethodSpec ) = 0x000C

struct Il2CppStringLiteral
{
	std::uint32_t length = 0;			// 0x0000
	std::int32_t dataIndex = -1;	// 0x0004
};
// sizeof( Il2CppStringLiteral ) = 0x0008

struct Il2CppGenericMethodIndices
{
	std::int32_t methodIndex = -1;	// 0x0000
	std::int32_t invokerIndex = -1;	// 0x0004
};
// sizeof( Il2CppGenericMethodIndices ) = 0x0008

struct Il2CppGenericMethodFunctionsDefinitions
{
	std::int32_t genericMethodIndex = -1;			// 0x0000
	Il2CppGenericMethodIndices indices = { };	// 0x0004
};
// sizeof( Il2CppGenericMethodFunctionsDefinitions ) = 0x000C

constexpr std::int32_t kPublicKeyByteLength = 8;
// sizeof( kPublicKeyByteLength ) = 0x0004

struct Il2CppAssemblyNameDefinition
{
	std::int32_t nameIndex = -1;																	// 0x0000
	std::int32_t cultureIndex = -1;																// 0x0004
	std::int32_t hashValueIndex = -1;															// 0x0008
	std::int32_t publicKeyIndex = -1;															// 0x000C
	std::uint32_t hash_alg = 0;																		// 0x0010
	std::int32_t hash_len = 0;																		// 0x0014
	std::uint32_t flags = 0;																			// 0x0018
	std::int32_t major = 0;																				// 0x001C
	std::int32_t minor = 0;																				// 0x0020
	std::int32_t build = 0;																				// 0x0024
	std::int32_t revision = 0;																		// 0x0028
	std::uint8_t public_key_token[ kPublicKeyByteLength ] = { };	// 0x002C
};
// sizeof( Il2CppAssemblyNameDefinition ) = 0x0034

struct Il2CppImageDefinition
{
	std::int32_t nameIndex = -1;						// 0x0000
	std::int32_t assemblyIndex = -1;				// 0x0004
	std::int32_t typeStart = -1;						// 0x0008
	std::uint32_t typeCount = 0;						// 0x000C
	std::int32_t exportedTypeStart = -1;		// 0x0010
	std::uint32_t exportedTypeCount = 0;		// 0x0014
	std::int32_t entryPointIndex = -1;			// 0x0018
	std::uint32_t token = 0;								// 0x001C
	std::int32_t customAttributeStart = -1;	// 0x0020
	std::uint32_t customAttributeCount = 0;	// 0x0024
};
// sizeof( Il2CppImageDefinition ) = 0x0028

struct Il2CppAssemblyDefinition
{
	std::int32_t imageIndex = -1;								// 0x0000
	std::uint32_t token = 0;										// 0x0004
	std::int32_t referencedAssemblyStart = -1;	// 0x0008
	std::int32_t referencedAssemblyCount = 0;		// 0x000C
	Il2CppAssemblyNameDefinition aname = { };		// 0x0010
};
// sizeof( Il2CppAssemblyDefinition ) = 0x0044

struct Il2CppMetadataUsageList
{
	std::uint32_t start = 0;	// 0x0000
	std::uint32_t count = 0;	// 0x0004
};
// sizeof( Il2CppMetadataUsageList ) = 0x0008

struct Il2CppMetadataUsagePair
{
	std::uint32_t destinationIndex = 0;		// 0x0000
	std::uint32_t encodedSourceIndex = 0;	// 0x0004
};
// sizeof( Il2CppMetadataUsagePair ) = 0x0008

struct Il2CppCustomAttributeTypeRange
{
	std::uint32_t token = 0;	// 0x0000
	std::int32_t start = 0;		// 0x0004
	std::int32_t count = 0;		// 0x0008
};
// sizeof( Il2CppCustomAttributeTypeRange ) = 0x000C

struct Il2CppRange
{
	std::int32_t start = 0;		// 0x0000
	std::int32_t length = 0;	// 0x0004
};
// sizeof( Il2CppRange ) = 0x0008

struct Il2CppWindowsRuntimeTypeNamePair
{
	std::int32_t nameIndex = -1;	// 0x0000
	std::int32_t typeIndex = -1;	// 0x0004
};
// sizeof( Il2CppWindowsRuntimeTypeNamePair ) = 0x0008
```

`rust/unity/il2cpp/il2cpp-object-internals.hpp`:

```hpp
#pragma once

#include <horizon/include/auto.hpp>
#include <horizon/include/base.hpp>
#include <horizon/include/win32.hpp>

#include <horizon/memory/operation.hpp>

#include "il2cpp-config.hpp"
#include "il2cpp-class-internals.hpp"

struct Il2CppType;

struct Il2CppReflectionAssembly;

struct MonitorData;

using Il2CppVTable = Il2CppClass;
// sizeof( Il2CppVTable ) = 0x0128

struct Il2CppObject
{
	union
	{
		Il2CppClass* klass = nullptr;		// 0x0000
		Il2CppVTable* vtable;						// 0x0000
	};
	MonitorData* monitor = nullptr;		// 0x0008
};
// sizeof( Il2CppObject ) = 0x0010

struct Il2CppArrayBounds
{
	std::size_t length = 0;				// 0x0000
	std::int32_t lower_bound = 0;	// 0x0008
	FIELD_PAD( 0x0004 );					// 0x000C
};
// sizeof( Il2CppArrayBounds ) = 0x0010

struct Il2CppArray : Il2CppObject
{
	Il2CppArrayBounds* bounds = nullptr;	// 0x0010
	std::size_t max_length = 0;						// 0x0018
};
// sizeof( Il2CppArray ) = 0x0020

struct Il2CppArraySize : Il2CppArray
{
	ALIGN_TYPE( 8 ) void* vector[ 0 ];	// 0x0020
};
// sizeof( Il2CppArraySize ) = 0x0020

struct Il2CppString
{
	Il2CppObject object = { };									// 0x0000
	std::int32_t length = 0;										// 0x0010
	FIELD_PAD( 0x0004 );												// 0x0014
	Il2CppChar chars[ IL2CPP_ZERO_LEN_ARRAY ];	// 0x0018
};
// sizeof( Il2CppString ) = 0x0018

struct Il2CppReflectionType
{
	Il2CppObject object = { };				// 0x0000
	const Il2CppType* type = nullptr;	// 0x0010
};
// sizeof( Il2CppReflectionType ) = 0x0018

struct Il2CppReflectionRuntimeType
{
	Il2CppReflectionType type = { };						// 0x0000
	Il2CppObject* type_info = nullptr;					// 0x0018
	Il2CppObject* genericCache = nullptr;				// 0x0020
	Il2CppObject* serializationCtor = nullptr;	// 0x0028
};
// sizeof( Il2CppReflectionRuntimeType ) = 0x0030

struct Il2CppReflectionMonoType
{
	const Il2CppType* GetIl2CppType() const
	{
		return type.type.type;
	}

	Il2CppReflectionRuntimeType type = { };	// 0x0000
};
// sizeof( Il2CppReflectionMonoType ) = 0x0030

struct Il2CppReflectionEvent
{
	Il2CppObject object = { };								// 0x0000
	Il2CppObject* cached_add_event = nullptr;	// 0x0010
};
// sizeof( Il2CppReflectionEvent ) = 0x0018

struct Il2CppReflectionMonoEvent
{
	Il2CppReflectionEvent event = { };							// 0x0000
	Il2CppReflectionType* reflectedType = nullptr;	// 0x0018
	const EventInfo* eventInfo = nullptr;						// 0x0020
};
// sizeof( Il2CppReflectionMonoEvent ) = 0x0028

struct Il2CppReflectionMethod;

struct Il2CppReflectionMonoEventInfo
{
	Il2CppReflectionType* declaringType = nullptr;	// 0x0000
	Il2CppReflectionType* reflectedType = nullptr;	// 0x0008
	Il2CppString* name = nullptr;										// 0x0010
	Il2CppReflectionMethod* addMethod = nullptr;		// 0x0018
	Il2CppReflectionMethod* removeMethod = nullptr;	// 0x0020
	Il2CppReflectionMethod* raiseMethod = nullptr;	// 0x0028
	std::uint32_t eventAttributes = 0;							// 0x0030
	FIELD_PAD( 0x0004 );														// 0x0034
	Il2CppArray* otherMethods = nullptr;						// 0x0038
};
// sizeof( Il2CppReflectionMonoEventInfo ) = 0x0040

struct Il2CppReflectionField
{
	Il2CppObject object = { };						// 0x0000
	Il2CppClass* klass = nullptr;					// 0x0010
	FieldInfo* field = nullptr;						// 0x0018
	Il2CppString* name = nullptr;					// 0x0020
	Il2CppReflectionType* type = nullptr;	// 0x0028
	std::uint32_t attrs = 0;							// 0x0030
	FIELD_PAD( 0x0004 );									// 0x0034
};
// sizeof( Il2CppReflectionField ) = 0x0038

struct Il2CppReflectionProperty
{
	Il2CppObject object = { };							// 0x0000
	Il2CppClass* klass = nullptr;						// 0x0010
	const PropertyInfo* property = nullptr;	// 0x0018
};
// sizeof( Il2CppReflectionProperty ) = 0x0020

struct Il2CppReflectionMethod
{
	Il2CppObject object = { };								// 0x0000
	const MethodInfo* method = nullptr;				// 0x0010
	Il2CppString* name = nullptr;							// 0x0018
	Il2CppReflectionType* reftype = nullptr;	// 0x0020
};
// sizeof( Il2CppReflectionMethod ) = 0x0028

struct Il2CppReflectionGenericMethod : Il2CppReflectionMethod
{ };
// sizeof( Il2CppReflectionGenericMethod ) = 0x0028

struct Il2CppMethodInfo
{
	Il2CppReflectionType* parent = nullptr;	// 0x0000
	Il2CppReflectionType* ret = nullptr;		// 0x0008
	std::uint32_t attrs = 0;								// 0x0010
	std::uint32_t implattrs = 0;						// 0x0014
	std::uint32_t callconv = 0;							// 0x0018
	FIELD_PAD( 0x0004 );										// 0x001C
};
// sizeof( Il2CppMethodInfo ) = 0x0020

struct Il2CppPropertyInfo
{
	Il2CppReflectionType* parent = nullptr;					// 0x0000
	Il2CppReflectionType* delcaringType = nullptr;	// 0x0008
	Il2CppString* name = nullptr;										// 0x0010
	Il2CppReflectionMethod* get = nullptr;					// 0x0018
	Il2CppReflectionMethod* set = nullptr;					// 0x0020
	std::uint32_t attrs = 0;												// 0x0028
	FIELD_PAD( 0x0004 );														// 0x002C
};
// sizeof( Il2CppPropertyInfo ) = 0x0030

struct Il2CppReflectionParameter
{
	Il2CppObject object = { };									// 0x0000
	Il2CppReflectionType* ClassImpl = nullptr;	// 0x0010
	Il2CppObject* DefaultValueImpl = nullptr;		// 0x0018
	Il2CppObject* MemberImpl = nullptr;					// 0x0020
	Il2CppString* NameImpl = nullptr;						// 0x0028
	std::int32_t PositionImpl = 0;							// 0x0030
	std::uint32_t AttrsImpl = 0;								// 0x0034
	Il2CppObject* MarshalAsImpl = nullptr;			// 0x0038
};
// sizeof( Il2CppReflectionParameter ) = 0x0040

struct Il2CppReflectionModule
{
	Il2CppObject object = { };										// 0x0000
	const Il2CppImage* image = nullptr;						// 0x0010
	Il2CppReflectionAssembly* assembly = nullptr;	// 0x0018
	Il2CppString* fqname = nullptr;								// 0x0020
	Il2CppString* name = nullptr;									// 0x0028
	Il2CppString* scopename = nullptr;						// 0x0030
	bool is_resource = false;											// 0x0038
	FIELD_PAD( 0x0003 );													// 0x0039
	std::uint32_t token = 0;											// 0x003C
};
// sizeof( Il2CppReflectionModule ) = 0x0040

struct Il2CppReflectionAssemblyName
{
	Il2CppObject object = { };								// 0x0000
	Il2CppString* name = nullptr;							// 0x0010
	Il2CppString* codebase = nullptr;					// 0x0018
	std::int32_t major = 0;										// 0x0020
	std::int32_t minor = 0;										// 0x0024
	std::int32_t build = 0;										// 0x0028
	std::int32_t revision = 0;								// 0x002C
	Il2CppObject* cultureInfo = nullptr;			// 0x0030
	std::uint32_t flags = 0;									// 0x0038
	std::uint32_t hashalg = 0;								// 0x003C
	Il2CppObject* keypair = nullptr;					// 0x0040
	Il2CppArray* publicKey = nullptr;					// 0x0048
	Il2CppArray* keyToken = nullptr;					// 0x0050
	std::uint32_t versioncompat = 0;					// 0x0058
	FIELD_PAD( 0x0004 );											// 0x005C
	Il2CppObject* version = nullptr;					// 0x0060
	std::uint32_t processor_architecture = 0;	// 0x0068
	std::uint32_t contentType = 0;						// 0x006C
};
// sizeof( Il2CppReflectionAssemblyName ) = 0x0070

struct Il2CppReflectionAssembly
{
	Il2CppObject object = { };										// 0x0000
	const Il2CppAssembly* assembly = nullptr;			// 0x0010
	Il2CppObject* resolve_event_holder = nullptr;	// 0x0018
	Il2CppObject* evidence = nullptr;							// 0x0020
	Il2CppObject* minimum = nullptr;							// 0x0028
	Il2CppObject* optional = nullptr;							// 0x0030
	Il2CppObject* refuse = nullptr;								// 0x0038
	Il2CppObject* granted = nullptr;							// 0x0040
	Il2CppObject* denied = nullptr;								// 0x0048
	bool from_byte_array = false;									// 0x0050
	FIELD_PAD( 0x0007 );													// 0x0051
	Il2CppString* name = nullptr;									// 0x0058
};
// sizeof( Il2CppReflectionAssembly ) = 0x0060

struct Il2CppReflectionMarshal
{
	Il2CppObject object = { };							// 0x0000
	std::int32_t count = 0;									// 0x0010
	std::int32_t type = 0;									// 0x0014
	std::int32_t eltype = 0;								// 0x0018
	FIELD_PAD( 0x0004 );										// 0x001C
	Il2CppString* guid = nullptr;						// 0x0020
	Il2CppString* mcookie = nullptr;				// 0x0028
	Il2CppString* marshaltype = nullptr;		// 0x0030
	Il2CppString* marshaltyperef = nullptr;	// 0x0038
	std::int32_t param_num = 0;							// 0x0040
	bool has_size = false;									// 0x0044
	FIELD_PAD( 0x0003 );										// 0x0045
};
// sizeof( Il2CppReflectionMarshal ) = 0x0048

struct Il2CppReflectionPointer
{
	Il2CppObject object = { };						// 0x0000
	void* data = nullptr;									// 0x0010
	Il2CppReflectionType* type = nullptr;	// 0x0018
};
// sizeof( Il2CppReflectionPointer ) = 0x0020

struct Il2CppInternalThread
{
	Il2CppObject object = { };											// 0x0000
	std::int32_t lock_thread_id = 0;								// 0x0010
	FIELD_PAD( 0x0004 );														// 0x0014
	void* handle = nullptr;													// 0x0018
	void* native_handle = nullptr;									// 0x0020
	Il2CppArray* cached_culture_info = nullptr;			// 0x0028
	Il2CppChar* name = nullptr;											// 0x0030
	std::int32_t name_len = 0;											// 0x0038
	std::uint32_t state = 0;												// 0x003C
	Il2CppObject* abort_exc = nullptr;							// 0x0040
	std::int32_t abort_state_handle = 0;						// 0x0048
	FIELD_PAD( 0x0004 );														// 0x004C
	std::uint64_t tid = 0;													// 0x0050
	std::intptr_t debugger_thread = 0;							// 0x0058
	void** static_data = nullptr;										// 0x0060
	void* runtime_thread_info = nullptr;						// 0x0068
	Il2CppObject* current_appcontext = nullptr;			// 0x0070
	Il2CppObject* root_domain_thread = nullptr;			// 0x0078
	Il2CppArray* _serialized_principal = nullptr;		// 0x0080
	std::int32_t _serialized_principal_version = 0;	// 0x0088
	FIELD_PAD( 0x0004 );														// 0x008C
	void* appdomain_refs = nullptr;									// 0x0090
	std::int32_t interruption_requested = 0;				// 0x0098
	FIELD_PAD( 0x0004 );														// 0x009C
	void* synch_cs = nullptr;												// 0x00A0
	bool threadpool_thread = false;									// 0x00A8
	bool thread_interrupt_requested = false;				// 0x00A9
	FIELD_PAD( 0x0002 );														// 0x00AA
	std::int32_t stack_size = 0;										// 0x00AC
	std::uint8_t apartment_state = 0;								// 0x00B0
	FIELD_PAD( 0x0003 );														// 0x00B1
	std::int32_t critical_region_level = 0;					// 0x00B4
	std::int32_t managed_id = 0;										// 0x00B8
	std::uint32_t small_id = 0;											// 0x00BC
	void* manage_callback = nullptr;								// 0x00C0
	void* interrupt_on_stop = nullptr;							// 0x00C8
	std::intptr_t flags = 0;												// 0x00D0
	void* thread_pinning_ref = nullptr;							// 0x00D8
	void* abort_protected_block_count = nullptr;		// 0x00E0
	std::int32_t priority = 0;											// 0x00E8
	FIELD_PAD( 0x0004 );														// 0x00EC
	void* owned_mutexes = nullptr;									// 0x00F0
	void* suspended = nullptr;											// 0x00F8
	std::int32_t self_suspended = 0;								// 0x0100
	FIELD_PAD( 0x0004 );														// 0x0104
	std::size_t thread_state = 0;										// 0x0108
	FIELD_PAD( 0x0008 );														// 0x0110
	void* last = nullptr;														// 0x0118
};
// sizeof( Il2CppInternalThread ) = 0x0120

// constexpr auto disp_of_chars = FIELD_OFFSET( Il2CppString, chars );
// constexpr auto size_of_Il2CppString = sizeof( Il2CppString );
```

`rust/unity/il2cpp/il2cpp-runtime-metadata.hpp`:

```hpp
#pragma once

#include <horizon/include/auto.hpp>
#include <horizon/include/base.hpp>
#include <horizon/include/win32.hpp>

#include <horizon/memory/operation.hpp>

#include "il2cpp-blob.hpp"
#include "il2cpp-metadata.hpp"

struct Il2CppClass;
struct Il2CppType;

struct MethodInfo;

struct Il2CppArrayType
{
	const Il2CppType* etype = nullptr;	// 0x0000
	std::uint8_t rank = 0;							// 0x0008
	std::uint8_t numsizes = 0;					// 0x0009
	std::uint8_t numlobounds = 0;				// 0x000A
	FIELD_PAD( 0x0005 );								// 0x000B
	std::int32_t* sizes = nullptr;			// 0x0010
	std::int32_t* lobounds = nullptr;		// 0x0018
};
// sizeof( Il2CppArrayType ) = 0x0020

struct Il2CppGenericInst
{
	std::uint32_t type_argc = 0;						// 0x0000
	FIELD_PAD( 0x0004 );										// 0x0004
	const Il2CppType** type_argv = nullptr;	// 0x0008
};
// sizeof( Il2CppGenericInst ) = 0x0010

struct Il2CppGenericContext
{
	const Il2CppGenericInst* class_inst = nullptr;	// 0x0000
	const Il2CppGenericInst* method_inst = nullptr;	// 0x0008
};
// sizeof( Il2CppGenericContext ) = 0x0010

struct Il2CppGenericParameter
{
	std::int32_t ownerIndex = -1;				// 0x0000
	std::int32_t nameIndex = -1;				// 0x0004
	std::int32_t constraintsStart = -1;	// 0x0008
	std::int16_t constraintsCount = 0;	// 0x000C
	std::uint16_t num = 0;							// 0x000E
	std::uint16_t flags = 0;						// 0x0010
	FIELD_PAD( 0x0002 );								// 0x0012
};
// sizeof( Il2CppGenericParameter ) = 0x0014

struct Il2CppGenericContainer
{
	std::int32_t ownerIndex = -1;							// 0x0000
	std::int32_t type_argc = 0;								// 0x0004
	std::int32_t is_method = 0;								// 0x0008
	std::int32_t genericParameterStart = -1;	// 0x000C
};
// sizeof( Il2CppGenericContainer ) = 0x0010

struct Il2CppGenericClass
{
	std::int32_t typeDefinitionIndex = -1;	// 0x0000
	FIELD_PAD( 0x0004 );										// 0x0004
	Il2CppGenericContext context = { };			// 0x0008
	Il2CppClass* cached_class = nullptr;		// 0x0018
};
// sizeof( Il2CppGenericClass ) = 0x0020

struct Il2CppGenericMethod
{
	const MethodInfo* methodDefinition = nullptr;	// 0x0000
	Il2CppGenericContext context = { };						// 0x0008
};
// sizeof( Il2CppGenericMethod ) = 0x0018

struct Il2CppType
{
	union
	{
		void* dummy = nullptr;							// 0x0000
		std::int32_t klassIndex;						// 0x0000
		const Il2CppType* type;							// 0x0000
		Il2CppArrayType* array;							// 0x0000
		std::int32_t genericParameterIndex;	// 0x0000
		Il2CppGenericClass* generic_class;	// 0x0000
	} data = { };													// 0x0000
	std::uint32_t attrs : 16;							// 0x0008
	Il2CppTypeEnum type : 8;							// 0x0008
	std::uint32_t num_mods : 6;						// 0x0008
	std::uint32_t byref : 1;							// 0x0008
	std::uint32_t pinned : 1;							// 0x0008
	FIELD_PAD( 0x0004 );									// 0x000C
};
// sizeof( Il2CppType ) = 0x0010

enum class Il2CppCallConvention
{
	IL2CPP_CALL_DEFAULT,
	IL2CPP_CALL_C,
	IL2CPP_CALL_STDCALL,
	IL2CPP_CALL_THISCALL,
	IL2CPP_CALL_FASTCALL,
	IL2CPP_CALL_VARARG,
};
// sizeof( Il2CppCallConvention ) = 0x0004

enum class Il2CppCharSet
{
	CHARSET_ANSI,
	CHARSET_UNICODE,
	CHARSET_NOT_SPECIFIED,
};
// sizeof( Il2CppCharSet ) = 0x0004
```

`rust/unity/object/rust.hpp`:

```hpp
#pragma once

#include "../sdk.hpp"

#include "system.hpp"
#include "unity_engine.hpp"

struct FacepunchBehaviour : UnityEngine::MonoBehaviour
{
	IL2CPP_CLASS( "FacepunchBehaviour" );
};

struct BaseMonoBehaviour : FacepunchBehaviour
{
	IL2CPP_CLASS( "BaseMonoBehaviour" );
};

struct Translate : Il2CppObject
{
	struct Phrase : Il2CppObject
	{
		IL2CPP_CLASS( "Translate.Phrase" );
		IL2CPP_FIELD( System::String*, token );
		IL2CPP_FIELD( System::String*, english );
	};
	IL2CPP_CLASS( "Translate" );
};

namespace Facepunch
{

IL2CPP_NAME_SPACE( "Facepunch" );

struct SkeletonDefinition : UnityEngine::ScriptableObject
{
	struct Bone
	{
		int Id = 0;																	// 0x0000
		int Depth = 0;															// 0x0004
		int Parent = 0;															// 0x0008
		FIELD_PAD( 0x0004 );												// 0x000C
		System::String* Name = nullptr;							// 0x0010
		UnityEngine::GameObject* Target = nullptr;	// 0x0018
		int Flags = 0;															// 0x0020
	};
	IL2CPP_CLASS( "SkeletonDefinition" );
	IL2CPP_FIELD( UnityEngine::GameObject*, SourceObject );
	IL2CPP_FIELD( System::Array< Bone >*, Bones );
};

struct Skeleton : UnityEngine::MonoBehaviour
{
	System::Array< SkeletonDefinition::Bone >* GetSourceBones()
	{
		const auto source = Source();

		if( memory::IsAddressValid( source ) )
		{
			return source->Bones();
		}

		return nullptr;
	}

	IL2CPP_CLASS( "Skeleton" );
	IL2CPP_FIELD( SkeletonDefinition*, Source );
	IL2CPP_FIELD( System::Array< UnityEngine::GameObject* >*, Bones );
};

} // namespace Facepunch

struct SkinnedMultiMesh : UnityEngine::MonoBehaviour
{
	System::Array< Facepunch::SkeletonDefinition::Bone >* GetSourceBones()
	{
		const auto player_skeleton = skeleton();

		if( memory::IsAddressValid( player_skeleton ) )
		{
			return player_skeleton->GetSourceBones();
		}

		return nullptr;
	}

	System::Array< UnityEngine::GameObject* >* GetBones()
	{
		const auto player_skeleton = skeleton();

		if( memory::IsAddressValid( player_skeleton ) )
		{
			return player_skeleton->Bones();
		}

		return nullptr;
	}

	IL2CPP_CLASS( "SkinnedMultiMesh" );
	IL2CPP_FIELD( Facepunch::Skeleton*, skeleton );
};

struct PlayerModel : FacepunchBehaviour
{
	System::Array< Facepunch::SkeletonDefinition::Bone >* GetSourceBones()
	{
		const auto player_mesh = _multiMesh();

		if( memory::IsAddressValid( player_mesh ) )
		{
			return player_mesh->GetSourceBones();
		}

		return nullptr;
	}

	System::Array< UnityEngine::GameObject* >* GetBones()
	{
		const auto player_mesh = _multiMesh();

		if( memory::IsAddressValid( player_mesh ) )
		{
			return player_mesh->GetBones();
		}

		return nullptr;
	}

	IL2CPP_CLASS( "PlayerModel" );
	IL2CPP_FIELD( SkinnedMultiMesh*, _multiMesh );
	IL2CPP_FIELD( bool, isLocalPlayer );
	IL2CPP_FIELD( UnityEngine::Vector3, velocity );
	IL2CPP_FIELD( UnityEngine::BoxCollider*, collision );
};

enum class ItemCategory : std::int32_t
{
	Weapon,
	Construction,
	Items,
	Resources,
	Attire,
	Tool,
	Medical,
	Food,
	Ammunition,
	Traps,
	Misc,
	All,
	Common,
	Component,
	Search,
	Favourite,
	Electrical,
	Fun,
};
// sizeof( ItemCategory ) = 0x0004

struct ItemDefinition : UnityEngine::MonoBehaviour
{
	IL2CPP_CLASS( "ItemDefinition" );
	IL2CPP_FIELD( std::int32_t, itemid );
	IL2CPP_FIELD( System::String*, shortname );
	IL2CPP_FIELD( ItemCategory, category );
};

struct Item : Il2CppObject
{
	IL2CPP_CLASS( "Item" );
	IL2CPP_FIELD( std::uint32_t, uid );
	IL2CPP_FIELD( ItemDefinition*, info );
};

struct ItemContainer : Il2CppObject
{
	IL2CPP_CLASS( "ItemContainer" );
	IL2CPP_FIELD( System::List< Item* >*, itemList );
};

struct PlayerInput : BaseMonoBehaviour
{
	void SetViewVars( const UnityEngine::Vector3& new_angles )
	{
		bodyAngles() = new_angles;
	}

	IL2CPP_CLASS( "PlayerInput" );
	IL2CPP_FIELD( Vector3, bodyAngles );
	IL2CPP_FIELD( Vector3, headAngles );
	IL2CPP_FIELD( Vector3, recoilAngles );
};

struct BaseNetworkable : BaseMonoBehaviour
{
	struct EntityRealm : Il2CppObject
	{
		using List = System::ListDictionary< std::uint32_t, BaseNetworkable* >;
		IL2CPP_FIELD( List*, entityList );
	};
	IL2CPP_CLASS( "BaseNetworkable" );
	IL2CPP_STATIC_FIELD( EntityRealm*, clientEntities );
	IL2CPP_FIELD( System::String*, _prefabName );
	IL2CPP_FIELD( System::String*, _prefabNameWithoutExtension );
	IL2CPP_PROPERTY( System::String*, PrefabName );
	IL2CPP_PROPERTY( System::String*, ShortPrefabName );
};

struct BaseEntity : BaseNetworkable
{
	IL2CPP_CLASS( "BaseEntity" );
	IL2CPP_FIELD( UnityEngine::Bounds, bounds );
	IL2CPP_FIELD( System::String*, _name );
};

struct ResourceEntity : BaseEntity
{
	IL2CPP_CLASS( "ResourceEntity" );
};

struct SkeletonProperties : UnityEngine::ScriptableObject
{
	struct BoneProperty : Il2CppObject
	{
		IL2CPP_CLASS( "SkeletonProperties.BoneProperty" );
		IL2CPP_FIELD( UnityEngine::GameObject*, bone );
		IL2CPP_FIELD( Translate::Phrase*, name );
		IL2CPP_FIELD( std::int32_t, area );
	};
	IL2CPP_CLASS( "SkeletonProperties" );
	IL2CPP_FIELD( UnityEngine::GameObject*, boneReference );
	IL2CPP_FIELD( System::Array< BoneProperty* >*, bones );
};

struct BaseCombatEntity : BaseEntity
{
	IL2CPP_CLASS( "BaseCombatEntity" );
	IL2CPP_FIELD( SkeletonProperties*, skeletonProperties );
	IL2CPP_PROPERTY( float, health );
};

struct PlayerInventory : Il2CppObject
{
	IL2CPP_CLASS( "PlayerInventory" );
	IL2CPP_FIELD( ItemContainer*, containerBelt );
};

__forceinline bool hooked_isAdmin_getter()
{
	return false;
}

struct BasePlayer : BaseCombatEntity
{
	typedef bool (*get_isAdmin)();

	bool IsLocalPlayer()
	{
		const auto player_model = playerModel();

		if( memory::IsAddressValid( player_model ) )
		{
			return player_model->isLocalPlayer();
		}

		return false;
	}

	std::size_t GetBoneCount()
	{
		const auto player_model = playerModel();

		if( memory::IsAddressValid( player_model ) )
		{
			const auto bone_array = player_model->GetBones();

			if( memory::IsAddressValid( bone_array ) )
			{
				return bone_array->max_length;
			}
		}

		return 0;
	}

	std::int32_t GetBoneParent( std::size_t index )
	{
		const auto player_model = playerModel();

		if( memory::IsAddressValid( player_model ) )
		{
			const auto player_bones = player_model->GetSourceBones();

			if( memory::IsAddressValid( player_bones ) )
			{
				const auto player_bone = player_bones->m_Items[ index ];
				return player_bone.Parent;
			}
		}

		return -1;
	}

	UnityEngine::Vector3 GetBone( std::size_t index )
	{
		const auto player_model = playerModel();

		if( memory::IsAddressValid( player_model ) )
		{
			const auto player_bones = player_model->GetBones();

			if( memory::IsAddressValid( player_bones ) )
			{
				const auto player_bone = player_bones->m_Items[ index ];

				if( memory::IsAddressValid( player_bone ) )
				{
					const auto transform = player_bone->get_transform();

					if( memory::IsAddressValid( transform ) )
					{
						return transform->get_position();
					}
				}
			}
		}

		return { };
	}

	UnityEngine::Vector3 GetVelocity()
	{
		const auto player_model = playerModel();

		if( memory::IsAddressValid( player_model ) )
		{
			return player_model->velocity();
		}

		return { };
	}

	Item* GetActiveItem()
	{
		const auto active_item = clActiveItem();
		const auto player_inventory = inventory();

		if( memory::IsAddressValid( player_inventory ) )
		{
			const auto belt = player_inventory->containerBelt();

			if( memory::IsAddressValid( belt ) )
			{
				const auto item_list = belt->itemList();

				if( memory::IsAddressValid( item_list ) )
				{
					const auto items = item_list->_items;

					if( memory::IsAddressValid( items ) )
					{
						for( std::int32_t index = 0; index < item_list->_size; index++ )
						{
							const auto item = items->m_Items[ index ];

							if( memory::IsAddressValid( item ) )
							{
								if( item->uid() == active_item )
								{
									return item;
								}
							}
						}
					}
				}
			}
		}

		return nullptr;
	}

	IL2CPP_CLASS( "BasePlayer" );
	IL2CPP_FIELD( PlayerModel*, playerModel );
	IL2CPP_FIELD( std::uint32_t, playerFlags );
	IL2CPP_FIELD( std::uint32_t, clActiveItem );
	IL2CPP_FIELD( PlayerInput*, input );
	IL2CPP_FIELD( PlayerInventory*, inventory );
	IL2CPP_FIELD(bool, wasDead);
	IL2CPP_FIELD(bool, wasSleeping);
	IL2CPP_PROPERTY( System::String*, displayName );

	bool m_isAdmin_getter_hooked = false;
	get_isAdmin m_restore_isAdmin_getter = nullptr;
	get_isAdmin m_current_isAdmin_getter = nullptr;
	int16_t m_restore_player_flags = 0;

	bool IsAdminGetterHooked()
	{
		return m_isAdmin_getter_hooked;
	}

	bool HookIsAdminGetter()
	{
		if (m_isAdmin_getter_hooked)
			return true;

		m_current_isAdmin_getter = reinterpret_cast<get_isAdmin>(win32::GetImage(HASH("GameAssembly.dll")) + 0x00307270);
		if (!memory::IsAddressValid(m_current_isAdmin_getter))
		{
			return false;
		}

		std::memcpy(m_restore_isAdmin_getter, m_current_isAdmin_getter, sizeof(uintptr_t));
		m_restore_player_flags = playerFlags();

		m_current_isAdmin_getter = &hooked_isAdmin_getter;
		m_isAdmin_getter_hooked = true;

		return true;
	}

	bool UnhookIsAdminGetter()
	{
		if (!m_isAdmin_getter_hooked)
			return true;

		if (!memory::IsAddressValid(m_restore_isAdmin_getter))
			return false;

		std::memcpy(m_current_isAdmin_getter, m_restore_isAdmin_getter, sizeof(uintptr_t));
		std::memset(m_restore_isAdmin_getter, 0, sizeof(uintptr_t));
		m_isAdmin_getter_hooked = false;

		return true;
	}
};

struct DecayEntity : BaseCombatEntity
{
	IL2CPP_CLASS( "DecayEntity" );
};

struct StabilityEntity : DecayEntity
{
	IL2CPP_CLASS( "StabilityEntity" );
};

struct BuildingBlock : StabilityEntity
{
	IL2CPP_CLASS( "BuildingBlock" );
};

struct BaseNpc : BaseCombatEntity
{
	IL2CPP_CLASS( "BaseNpc" );
};

struct BaseAnimalNPC : BaseNpc
{
	IL2CPP_CLASS( "BaseAnimalNPC" );
};

struct BaseTrap : DecayEntity
{
	IL2CPP_CLASS( "BaseTrap" );
};

struct BearTrap : BaseTrap
{
	IL2CPP_CLASS( "BearTrap" );
};

struct MapMarker : BaseEntity
{
	IL2CPP_CLASS( "MapMarker" );
};

struct VendingMachineMapMarker : MapMarker
{
	IL2CPP_CLASS( "VendingMachineMapMarker" );
};

struct StorageContainer : DecayEntity
{
	IL2CPP_CLASS( "StorageContainer" );
};

struct BoxStorage : StorageContainer
{
	IL2CPP_CLASS( "BoxStorage" );
};

struct StashContainer : StorageContainer
{
	IL2CPP_CLASS( "StashContainer" );
};

struct BuildingPrivlidge : StorageContainer
{
	IL2CPP_CLASS( "BuildingPrivlidge" );
};

struct Workbench : StorageContainer
{
	IL2CPP_CLASS( "Workbench" );
};

struct BaseOven : StorageContainer
{
	IL2CPP_CLASS( "BaseOven" );
};

struct ResearchTable : StorageContainer
{
	IL2CPP_CLASS( "ResearchTable" );
};

struct WorldItem : BaseEntity
{
	IL2CPP_CLASS( "WorldItem" );
};

struct DroppedItem : WorldItem
{
	IL2CPP_CLASS( "DroppedItem" );
};

struct BaseCorpse : BaseCombatEntity
{
	IL2CPP_CLASS( "BaseCorpse" );
};

struct LootableCorpse : BaseCorpse
{
	IL2CPP_CLASS( "LootableCorpse" );
};

struct PlayerCorpse : LootableCorpse
{
	IL2CPP_CLASS( "PlayerCorpse" );
};

struct GunTrap : StorageContainer
{
	IL2CPP_CLASS( "GunTrap" );
};

struct OreHotSpot : BaseCombatEntity
{
	IL2CPP_CLASS( "OreHotSpot" );
};
```

`rust/unity/object/system.hpp`:

```hpp
#pragma once

#include "../sdk.hpp"

namespace System
{

IL2CPP_NAME_SPACE( "System" );

struct Object : Il2CppObject
{
	IL2CPP_CLASS( "Object" );
};

struct String : Il2CppObject
{
	const wchar_t* c_str() const
	{
		return m_firstChar;
	}

	wchar_t* begin()
	{
		return m_firstChar;
	}

	wchar_t* end()
	{
		return ( begin() + m_stringLength );
	}

	const wchar_t* begin() const
	{
		return m_firstChar;
	}

	const wchar_t* end() const
	{
		return ( begin() + m_stringLength );
	}

	IL2CPP_CLASS( "String" );
	std::int32_t m_stringLength = 0;	// 0x0010
	wchar_t m_firstChar[ 1 ] = { };		// 0x0014
};

template< typename Type >
struct Array : Il2CppArray
{
	Type m_Items[ 1 ] = { };
};

template< typename Type >
struct BufferList : Il2CppObject
{
	std::int32_t count = 0;						// 0x0010
	FIELD_PAD( 0x0004 );							// 0x0014
	Array< Type >* buffer = nullptr;	// 0x0018
};

template< typename KeyType, typename ValueType >
struct ListDictionary : Il2CppObject
{
	FIELD_PAD( 0x0010 );											// 0x0010
	BufferList< KeyType >* keys = nullptr;		// 0x0020
	BufferList< ValueType >* vals = nullptr;	// 0x0040
};

template< typename Type >
struct List : Il2CppObject
{
	Array< Type >* _items = nullptr;		// 0x0010
	std::int32_t _size = 0;							// 0x0018
	std::int32_t _version = 0;					// 0x001C
	Il2CppObject* _syncRoot = nullptr;	// 0x0020
};
// sizeof( List ) = 0x0028

} // namespace System
```

`rust/unity/object/unity_engine.cpp`:

```cpp
#include "unity_engine.hpp"

namespace UnityEngine
{

// 
// [ Vector3 ] implementation
// 
Vector3::Vector3()
	: x( 0.f )
	, y( 0.f )
	, z( 0.f )
{ }

Vector3::Vector3( float vector_x, float vector_y, float vector_z )
	: x( vector_x )
	, y( vector_y )
	, z( vector_z )
{ }

Vector3::Vector3( const Vector3& vector )
	: x( vector[ 0 ] )
	, y( vector[ 1 ] )
	, z( vector[ 2 ] )
{ }

float Vector3::Dot( const Vector3& vector ) const
{
	return ( x * vector[ 0 ] + y * vector[ 1 ] + z * vector[ 2 ] );
}

float Vector3::Length() const
{
	return win32::sqrt( x * x + y * y + z * z );
}

float Vector3::Length2D() const
{
	return win32::sqrt( x * x + z * z );
}

float Vector3::Distance( const Vector3& vector ) const
{
	const auto direction = ( *this - vector );
	return direction.Length();
}

float Vector3::Distance2D( const Vector3& vector ) const
{
	const auto direction = ( *this - vector );
	return direction.Length2D();
}

float Vector3::Normalize()
{
	const auto length = Length();

	if( length > 0.f )
	{
		x /= length;
		y /= length;
		z /= length;
	}
	else
	{
		x = 0.f;
		y = 0.f;
		z = 0.f;
	}

	return length;
}

bool Vector3::IsZero() const
{
	return ( x == 0.f &&
					 y == 0.f &&
					 z == 0.f );
}

Vector3 Vector3::ToVector() const
{
	const auto pitch = ToRadians( x );
	const auto yaw = ToRadians( y );

	const auto cp = win32::cos( pitch );
	const auto cy = win32::cos( yaw );

	const auto sp = win32::sin( pitch );
	const auto sy = win32::sin( yaw );

	return { cp * sy, -sp, cp * cy };
}

Vector3 Vector3::ToEulerAngles() const
{
	const auto length = Length();

	const auto pitch = -ToDegrees( win32::asin( y / length ) );
	const auto yaw = ToDegrees( win32::atan2( x, z ) );

	return { pitch, yaw, 0.f };
}

float Vector3::operator[]( std::size_t index ) const
{
	return ( &x )[ index ];
}

float& Vector3::operator[]( std::size_t index )
{
	return ( &x )[ index ];
}

Vector3 Vector3::operator-() const
{
	return { -x, -y, -z };
}

Vector3 Vector3::operator+( const Vector3& vector ) const
{
	return { x + vector[ 0 ],
					 y + vector[ 1 ],
					 z + vector[ 2 ] };
}

Vector3 Vector3::operator-( const Vector3& vector ) const
{
	return { x - vector[ 0 ],
					 y - vector[ 1 ],
					 z - vector[ 2 ] };
}

Vector3 Vector3::operator*( const Vector3& vector ) const
{
	return { x * vector[ 0 ],
					 y * vector[ 1 ],
					 z * vector[ 2 ] };
}

Vector3 Vector3::operator/( const Vector3& vector ) const
{
	return { x / vector[ 0 ],
					 y / vector[ 1 ],
					 z / vector[ 2 ] };
}

Vector3 Vector3::Zero( 0.f, 0.f, 0.f );
Vector3 Vector3::Forward(0.f, 0.f, 1.f);
Vector3 Vector3::Back(0.f, 0.f, -1.f);

// 
// [ Component ] implementation
// 
Vector3 Component::get_position()
{
	const auto transform = get_transform();

	if( memory::IsAddressValid( transform ) )
	{
		return transform->get_position();
	}

	return Vector3::Zero;
}

// 
// [ Camera ] implementation
// 
bool Camera::WorldToScreen( const Vector3& position, Vector3& output )
{
	const auto& io = ImGui::GetIO();

	if( !memory::IsAddressValid( view ) )
	{
		return false;
	}

	const auto matrix = view->viewMatrix;
	const auto translation = matrix.GetColumn( 3 );

	const auto w = translation.Dot( position ) + matrix[ 3 ][ 3 ];

	if( w < 0.098f )
	{
		return false;
	}

	const auto right = matrix.GetColumn( 0 );
	const auto up = matrix.GetColumn( 1 );

	const auto x = right.Dot( position ) + matrix[ 3 ][ 0 ];
	const auto y = up.Dot( position ) + matrix[ 3 ][ 1 ];

	output[ 0 ] = ( io.DisplaySize[ 0 ] * 0.5f ) * ( 1.f + ( x / w ) );
	output[ 1 ] = ( io.DisplaySize[ 1 ] * 0.5f ) * ( 1.f - ( y / w ) );

	return true;
}

float ToRadians( float degrees )
{
	return ( degrees * ( PiRadians / PiDegrees ) );
}

float ToDegrees( float radians )
{
	return ( radians * ( PiDegrees / PiRadians ) );
}

float AngleNormalize( float angle )
{
	angle = win32::fmod( angle, 360.f );
	if( angle < -180.f )
	{
		angle += 360.f;
	}
	else if( angle > 180.f )
	{
		angle -= 360.f;
	}
	return angle;
}

void AnglesNormalize( Vector3& angles )
{
	angles[ 0 ] = AngleNormalize( angles[ 0 ] );
	angles[ 1 ] = AngleNormalize( angles[ 1 ] );
	angles[ 2 ] = AngleNormalize( angles[ 2 ] );
}

bool WorldToScreen( const Vector3& position, Vector3& output )
{
	auto camera = Camera::get_current();

	if( !memory::IsAddressValid( camera ) )
	{
		return false;
	}

	return camera->WorldToScreen( position, output );
}

bool Physics::Raycast(Vector3 origin, Vector3 direction)
{
	static uintptr_t procedure = 0;

	if (!memory::IsAddressValid(procedure))
	{
		procedure = win32::GetImage(HASH("GameAssembly.dll")) + 0x01AD8750;
	}
	
	if (!memory::IsAddressValid(procedure))
		return false;

	return memory::SecureCall<bool>(procedure, std::cref(origin), std::cref(direction));
}

} // namespace UnityEngine
```

`rust/unity/object/unity_engine.hpp`:

```hpp
#pragma once

#include "../sdk.hpp"

#include "system.hpp"

namespace UnityEngine
{

IL2CPP_NAME_SPACE( "UnityEngine" );

struct Vector3;
struct Bounds;
struct Matrix4x4;

struct Object;
struct Component;
struct Behaviour;
struct MonoBehaviour;
struct Transform;
struct GameObject;
struct Camera;

constexpr auto PiRadians = static_cast< float >( 3.1415926535897932 );
constexpr auto PiDegrees = static_cast< float >( 180.0 );

struct Vector3
{
	Vector3();
	Vector3( float vector_x, float vector_y, float vector_z );
	Vector3( const Vector3& vector );

	float Dot( const Vector3& vector ) const;

	float Length() const;
	float Length2D() const;

	float Distance( const Vector3& vector ) const;
	float Distance2D( const Vector3& vector ) const;

	float Normalize();

	bool IsZero() const;

	Vector3 ToVector() const;
	Vector3 ToEulerAngles() const;

	float operator[]( std::size_t index ) const;
	float& operator[]( std::size_t index );

	Vector3 operator-() const;

	Vector3 operator+( const Vector3& vector ) const;
	Vector3 operator-( const Vector3& vector ) const;
	Vector3 operator*( const Vector3& vector ) const;
	Vector3 operator/( const Vector3& vector ) const;

	static Vector3 Zero;

	float x = 0.f;
	float y = 0.f;
	float z = 0.f;

	static Vector3 Forward;
	static Vector3 Back;
};
// sizeof( Vector3 ) = 0x000C

struct Bounds
{
	Vector3 m_Center = { };		// 0x0000
	Vector3 m_Extents = { };	// 0x000C
};
// sizeof( Bounds ) = 0x0018

struct Matrix4x4
{
	Matrix4x4()
		: m()
	{ }

	Matrix4x4( const Matrix4x4& matrix )
	{
		for( auto row = 0; row < 4; row++ )
		{
			for( auto column = 0; column < 4; column++ )
			{
				m[ row ][ column ] = matrix.m[ row ][ column ];
			}
		}
	}

	void Transpose()
	{
		for( auto row = 0; row < 4; row++ )
		{
			for( auto column = 0; column < 4; column++ )
			{
				m[ row ][ column ] = m[ column ][ row ];
			}
		}
	}

	Matrix4x4 Transposed() const
	{
		auto matrix( *this );
		matrix.Transpose();
		return std::move( matrix );
	}

	Vector3 GetRow( std::size_t index ) const
	{
		return { m[ index ][ 0 ], m[ index ][ 1 ], m[ index ][ 2 ] };
	}

	Vector3 GetColumn( std::size_t index ) const
	{
		return { m[ 0 ][ index ], m[ 1 ][ index ], m[ 2 ][ index ] };
	}

	Vector3 GetAxis( std::size_t index ) const
	{
		return { m[ index ][ 0 ], m[ index ][ 1 ], m[ index ][ 2 ] };
	}

	const float* operator[]( std::size_t index ) const
	{
		return m[ index ];
	}

	float* operator[]( std::size_t index )
	{
		return m[ index ];
	}

	float m[ 4 ][ 4 ] = { };
};

struct Object : Il2CppObject
{
	bool IsA( const Il2CppClass* object )
	{
		auto super = klass;

		while( memory::IsAddressValid( super ) )
		{
			if( super == object )
			{
				return true;
			}

			super = super->parent;
		}

		return false;
	}

	IL2CPP_CLASS( "Object" );
	IL2CPP_FIELD( std::intptr_t, m_CachedPtr );
	IL2CPP_PROPERTY( System::String*, name );
};

struct Component : Object
{
	Vector3 get_position();

	IL2CPP_CLASS( "Component" );
	IL2CPP_PROPERTY( Transform*, transform );
	IL2CPP_PROPERTY( GameObject*, gameObject );
};

struct Behaviour : Component
{
	IL2CPP_CLASS( "Behaviour" );
};

struct MonoBehaviour : Behaviour
{
	IL2CPP_CLASS( "MonoBehaviour" );
};

struct Transform : Component
{
	IL2CPP_CLASS( "Transform" );
	IL2CPP_PROPERTY( Vector3, position );
	IL2CPP_PROPERTY( Vector3, localPosition );
	IL2CPP_PROPERTY( Vector3, eulerAngles );
	IL2CPP_PROPERTY( Vector3, localEulerAngles );
	IL2CPP_PROPERTY( Vector3, right );
	IL2CPP_PROPERTY( Vector3, up );
	IL2CPP_PROPERTY( Vector3, forward );
	IL2CPP_PROPERTY( Vector3, localScale );
};

struct GameObject : Object
{
	IL2CPP_CLASS( "GameObject" );
	IL2CPP_PROPERTY( Transform*, transform );
	IL2CPP_PROPERTY( std::int32_t, layer );
	IL2CPP_PROPERTY( System::String*, tag );
	IL2CPP_PROPERTY( GameObject*, gameObject );
};

struct Camera : Behaviour
{
	struct View
	{
		FIELD_PAD( 0x00DC );				// 0x0000
		Matrix4x4 viewMatrix = { };	// 0x00DC
	};

	View* view = nullptr;					// 0x0018

	bool WorldToScreen( const Vector3& position, Vector3& output );

	IL2CPP_CLASS( "Camera" );
	IL2CPP_STATIC_PROPERTY( Camera*, main );
	IL2CPP_STATIC_PROPERTY( Camera*, current );
	IL2CPP_PROPERTY(float, fieldOfView);
	IL2CPP_PROPERTY( Matrix4x4, worldToCameraMatrix );
	IL2CPP_PROPERTY( Matrix4x4, projectionMatrix );
};

struct Physics
{
	static bool Raycast(Vector3 origin, Vector3 direction);
};

struct ScriptableObject : Object
{
	IL2CPP_CLASS( "ScriptableObject" );
};

struct Collider : Component
{
	IL2CPP_CLASS( "Collider" );
	IL2CPP_PROPERTY( Bounds, bounds );
};

struct BoxCollider : Collider
{
	IL2CPP_CLASS( "BoxCollider" );
	IL2CPP_PROPERTY( Vector3, center );
	IL2CPP_PROPERTY( Vector3, size );
};

float ToRadians( float degrees );
float ToDegrees( float radians );

float AngleNormalize( float angle );
void AnglesNormalize( Vector3& angles );

bool WorldToScreen( const Vector3& position, Vector3& output );

} // namespace UnityEngine

using UnityEngine::Vector3;
using UnityEngine::Camera;
```

`rust/unity/sdk.cpp`:

```cpp
#include "sdk.hpp"

// 
// [ D3D11SwapChain ] implementation
// 

IDXGISwapChain* D3D11SwapChain::GetSwapChain() const
{
	return m_SwapChain;
}
```

`rust/unity/sdk.hpp`:

```hpp
#pragma once

#include <horizon/constant/character.hpp>
#include <horizon/constant/hash.hpp>
#include <horizon/constant/secure_string.hpp>
#include <horizon/constant/string.hpp>

#include <horizon/core/map_data.hpp>
#include <horizon/core/mutex.hpp>
#include <horizon/core/no_copy.hpp>
#include <horizon/core/no_move.hpp>
#include <horizon/core/singleton.hpp>
#include <horizon/core/timer.hpp>

#include <horizon/graphics/color.hpp>
#include <horizon/graphics/renderer.hpp>

#include <horizon/hde/hde64.hpp>

#include <horizon/include/auto.hpp>
#include <horizon/include/base.hpp>
#include <horizon/include/win32.hpp>

#include <horizon/memory/detour_hook.hpp>
#include <horizon/memory/operation.hpp>
#include <horizon/memory/scan.hpp>
#include <horizon/memory/secure_call.hpp>
#include <horizon/memory/vftable_hook.hpp>

#include <horizon/vcruntime/dll_dllmain.hpp>
#include <horizon/vcruntime/security_cookie.hpp>
#include <horizon/vcruntime/thread_local_storage.hpp>
#include <horizon/vcruntime/thread_safe_statics.hpp>

#include <horizon/win32/sdk/access_mask.hpp>
#include <horizon/win32/sdk/client_id.hpp>
#include <horizon/win32/sdk/constant_page.hpp>
#include <horizon/win32/sdk/constant_region.hpp>
#include <horizon/win32/sdk/constant_section.hpp>
#include <horizon/win32/sdk/event_basic_information.hpp>
#include <horizon/win32/sdk/event_information_class.hpp>
#include <horizon/win32/sdk/event_type.hpp>
#include <horizon/win32/sdk/exception_registration_record.hpp>
#include <horizon/win32/sdk/file_basic_information.hpp>
#include <horizon/win32/sdk/io_apc_routine.hpp>
#include <horizon/win32/sdk/io_status_block.hpp>
#include <horizon/win32/sdk/large_integer.hpp>
#include <horizon/win32/sdk/ldr_data_table_entry.hpp>
#include <horizon/win32/sdk/list_entry.hpp>
#include <horizon/win32/sdk/memory_basic_information.hpp>
#include <horizon/win32/sdk/memory_enclave_image_information.hpp>
#include <horizon/win32/sdk/memory_frame_information.hpp>
#include <horizon/win32/sdk/memory_image_information.hpp>
#include <horizon/win32/sdk/memory_information_class.hpp>
#include <horizon/win32/sdk/memory_region_information.hpp>
#include <horizon/win32/sdk/memory_shared_commit_information.hpp>
#include <horizon/win32/sdk/memory_working_set_block.hpp>
#include <horizon/win32/sdk/memory_working_set_ex_block.hpp>
#include <horizon/win32/sdk/memory_working_set_ex_information.hpp>
#include <horizon/win32/sdk/memory_working_set_ex_location.hpp>
#include <horizon/win32/sdk/memory_working_set_information.hpp>
#include <horizon/win32/sdk/mutant_basic_information.hpp>
#include <horizon/win32/sdk/mutant_information_class.hpp>
#include <horizon/win32/sdk/nt_tib.hpp>
#include <horizon/win32/sdk/object_attributes.hpp>
#include <horizon/win32/sdk/object_basic_information.hpp>
#include <horizon/win32/sdk/object_information_class.hpp>
#include <horizon/win32/sdk/object_name_information.hpp>
#include <horizon/win32/sdk/object_wait_type.hpp>
#include <horizon/win32/sdk/peb.hpp>
#include <horizon/win32/sdk/peb_ldr_data.hpp>
#include <horizon/win32/sdk/rtl_balanced_node.hpp>
#include <horizon/win32/sdk/rtl_condition_variable.hpp>
#include <horizon/win32/sdk/rtl_critical_section.hpp>
#include <horizon/win32/sdk/rtl_critical_section_debug.hpp>
#include <horizon/win32/sdk/rtl_heap_parameters.hpp>
#include <horizon/win32/sdk/section_basic_information.hpp>
#include <horizon/win32/sdk/section_information_class.hpp>
#include <horizon/win32/sdk/section_inherit.hpp>
#include <horizon/win32/sdk/string.hpp>
#include <horizon/win32/sdk/teb.hpp>
#include <horizon/win32/sdk/ularge_integer.hpp>
#include <horizon/win32/sdk/unicode_string.hpp>

#include <horizon/win32/basic.hpp>
#include <horizon/win32/image.hpp>
#include <horizon/win32/input_manager.hpp>
#include <horizon/win32/math.hpp>
#include <horizon/win32/process.hpp>
#include <horizon/win32/string.hpp>
#include <horizon/win32/time.hpp>
#include <horizon/win32/trace.hpp>

using namespace horizon;

using graphics::TextLeft;
using graphics::TextRight;
using graphics::TextCenterH;
using graphics::TextCenterV;
using graphics::TextCenter;

using graphics::Color;

#include "il2cpp/il2cpp-api.hpp"
#include "il2cpp/il2cpp-api-types.hpp"
#include "il2cpp/il2cpp-blob.hpp"
#include "il2cpp/il2cpp-class-internals.hpp"
#include "il2cpp/il2cpp-config.hpp"
#include "il2cpp/il2cpp-config-api.hpp"
#include "il2cpp/il2cpp-metadata.hpp"
#include "il2cpp/il2cpp-object-internals.hpp"
#include "il2cpp/il2cpp-runtime-metadata.hpp"

// 
// [ procedure ] il2cpp declarations
// 
namespace rust
{

DO_API( Il2CppDomain*, il2cpp_domain_get, ( ) );
DO_API( const Il2CppAssembly**, il2cpp_domain_get_assemblies, ( const Il2CppDomain* domain, std::size_t* size ) );

DO_API( void, il2cpp_set_memory_callbacks, ( Il2CppMemoryCallbacks* callbacks ) );
DO_API( const Il2CppImage*, il2cpp_get_corlib, ( ) );
DO_API( void, il2cpp_add_internal_call, ( const char* name, Il2CppMethodPointer method ) );
DO_API( Il2CppMethodPointer, il2cpp_resolve_icall, ( const char* name ) );

DO_API( void*, il2cpp_alloc, ( std::size_t size ) );
DO_API( void, il2cpp_free, ( void* ptr ) );

DO_API( const Il2CppImage*, il2cpp_assembly_get_image, ( const Il2CppAssembly* assembly ) );

DO_API( bool, il2cpp_class_has_parent, ( Il2CppClass* klass, Il2CppClass* klassc ) );
DO_API( Il2CppClass*, il2cpp_class_from_name, ( const Il2CppImage* image, const char* namespaze, const char* name ) );
DO_API( const EventInfo*, il2cpp_class_get_events, ( const Il2CppClass* klass, void** iter ) );
DO_API( FieldInfo*, il2cpp_class_get_fields, ( const Il2CppClass* klass, void** iter ) );
DO_API( FieldInfo*, il2cpp_class_get_field_from_name, ( const Il2CppClass* klass, const char* name ) );
DO_API( const PropertyInfo*, il2cpp_class_get_properties, ( const Il2CppClass* klass, void** iter ) );
DO_API( const PropertyInfo*, il2cpp_class_get_property_from_name, ( const Il2CppClass* klass, const char* name ) );
DO_API( const MethodInfo*, il2cpp_class_get_methods, ( Il2CppClass* klass, void** iter ) );
DO_API( const MethodInfo*, il2cpp_class_get_method_from_name, ( Il2CppClass* klass, const char* name, int argsCount ) );
DO_API( const char*, il2cpp_class_get_name, ( Il2CppClass* klass ) );
DO_API( const char*, il2cpp_class_get_namespace, ( Il2CppClass* klass ) );
DO_API( Il2CppClass*, il2cpp_class_get_parent, ( Il2CppClass* klass ) );

DO_API( const char*, il2cpp_field_get_name, ( const FieldInfo* field ) );
DO_API( std::size_t, il2cpp_field_get_offset, ( const FieldInfo* field ) );

DO_API( const MethodInfo*, il2cpp_property_get_get_method, ( const PropertyInfo* prop ) );
DO_API( const MethodInfo*, il2cpp_property_get_set_method, ( const PropertyInfo* prop ) );
DO_API( const char*, il2cpp_property_get_name, ( const PropertyInfo* prop ) );

DO_API( const Il2CppAssembly*, il2cpp_image_get_assembly, ( const Il2CppImage* image ) );
DO_API( const char*, il2cpp_image_get_name, ( const Il2CppImage* image ) );
DO_API( const char*, il2cpp_image_get_filename, ( const Il2CppImage* image ) );
DO_API( const MethodInfo*, il2cpp_image_get_entry_point, ( const Il2CppImage* image ) );

const Il2CppClass* FindClass( const Il2CppImage* image, const char* name_space, const char* name );
const Il2CppClass* FindClass( const char* name_space, const char* name );
const FieldInfo* FindField( const Il2CppClass* object, std::uint64_t name_hash );
const PropertyInfo* FindProperty( const Il2CppClass* object, std::uint64_t name_hash );

} // namespace rust

// 
// [ macro ] il2cpp definitions
// 
#pragma region region_macro_il2cpp
#define IL2CPP_NAME_SPACE( name )																															\
	static constexpr const char* cx_name_space = name

#define IL2CPP_CLASS( name )																																	\
	static const Il2CppClass* StaticClass()																											\
	{																																														\
		static const Il2CppClass* instance = nullptr;																							\
		if( !memory::IsAddressValid( instance ) )																									\
		{																																													\
			instance = rust::FindClass( cx_name_space, name );																			\
		}																																													\
		return instance;																																					\
	}

#define IL2CPP_FIELD( return_type, name )																											\
	return_type& name()																																					\
	{																																														\
		static std::size_t offset = 0;																														\
		if( !offset )																																							\
		{																																													\
			const auto field = rust::FindField( klass, HASH( #name ) );															\
			if( memory::IsAddressValid( field ) )																										\
			{																																												\
				offset = rust::il2cpp_field_get_offset( field );																			\
			}																																												\
		}																																													\
		return *reinterpret_cast< return_type* >( memory::ToAddress( this ) + offset );						\
	}

#define IL2CPP_STATIC_FIELD( return_type, name )																							\
	static return_type& name()																																	\
	{																																														\
		static auto offset = std::numeric_limits< std::size_t >::max();														\
		if( offset == std::numeric_limits< std::size_t >::max() )																	\
		{																																													\
			const auto field = rust::FindField( StaticClass(), HASH( #name ) );											\
			if( memory::IsAddressValid( field ) )																										\
			{																																												\
				offset = rust::il2cpp_field_get_offset( field );																			\
			}																																												\
		}																																													\
		const auto static_fields = StaticClass()->static_fields;																	\
		return *reinterpret_cast< return_type* >( memory::ToAddress( static_fields ) + offset );	\
	}

#define IL2CPP_PROPERTY( return_type, name )																																		\
	return_type JOIN( get_, name )()																																							\
	{																																																							\
		static std::uintptr_t procedure = 0;																																				\
		if( !memory::IsAddressValid( procedure ) )																																	\
		{																																																						\
			const auto prop = rust::FindProperty( klass, HASH( #name ) );																							\
			if( memory::IsAddressValid( prop ) )																																			\
			{																																																					\
				const auto method = rust::il2cpp_property_get_get_method( prop );																				\
				if( memory::IsAddressValid( method ) )																																	\
				{																																																				\
					procedure = memory::ToAddress( method->methodPointer );																								\
				}																																																				\
			}																																																					\
		}																																																						\
		if constexpr( sizeof( return_type ) > sizeof( std::uintptr_t ) )																						\
		{																																																						\
			return_type data = { };																																										\
			const auto method = reinterpret_cast< return_type*( __fastcall* )( return_type*, void* ) >( procedure );	\
			method( &data, this );																																										\
			return std::move( data );																																									\
		}																																																						\
		else																																																				\
		{																																																						\
			const auto method = reinterpret_cast< return_type( __fastcall* )( void* ) >( procedure );									\
			return method( this );																																										\
		}																																																						\
	}

#define IL2CPP_STATIC_PROPERTY( return_type, name )																															\
	static return_type JOIN( get_, name )()																																				\
	{																																																							\
		static std::uintptr_t procedure = 0;																																				\
		if( !memory::IsAddressValid( procedure ) )																																	\
		{																																																						\
			const auto prop = rust::FindProperty( StaticClass(), HASH( #name ) );																			\
			if( memory::IsAddressValid( prop ) )																																			\
			{																																																					\
				const auto method = rust::il2cpp_property_get_get_method( prop );																				\
				if( memory::IsAddressValid( method ) )																																	\
				{																																																				\
					procedure = memory::ToAddress( method->methodPointer );																								\
				}																																																				\
			}																																																					\
		}																																																						\
		if constexpr( sizeof( return_type ) > sizeof( std::uintptr_t ) )																						\
		{																																																						\
			return_type data = { };																																										\
			const auto method = reinterpret_cast< return_type*( __fastcall* )( return_type* ) >( procedure );					\
			method( &data );																																													\
			return std::move( data );																																									\
		}																																																						\
		else																																																				\
		{																																																						\
			const auto method = reinterpret_cast< return_type( __fastcall* )() >( procedure );												\
			return method();																																													\
		}																																																						\
	}
#pragma endregion

IL2CPP_NAME_SPACE( "" );

// 
// [ struct ] declarations
// 


//
// [ class ] declarations
// 
class D3D11SwapChain;

// 
// [ class ] definitions
// 
class D3D11SwapChain
{
public:
	IDXGISwapChain* GetSwapChain() const;

protected:
	FIELD_PAD( 0x03A0 );										// 0x0000
	IDXGISwapChain* m_SwapChain = nullptr;	// 0x03A0
};
// sizeof( D3D11SwapChain ) = 0x03A8
```