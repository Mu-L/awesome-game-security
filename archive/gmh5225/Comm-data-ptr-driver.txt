Project Path: arc_gmh5225_Comm-data-ptr-driver_jer_fj7b

Source Tree:

```txt
arc_gmh5225_Comm-data-ptr-driver_jer_fj7b
├── README.md
├── WKDRIVER
│   ├── WKDRIVER.inf
│   ├── WKDRIVER.vcxproj
│   ├── WKDRIVER.vcxproj.filters
│   ├── WKDRIVER.vcxproj.user
│   ├── core
│   │   ├── framework.h
│   │   ├── hook.cpp
│   │   └── hook.h
│   ├── driver
│   │   ├── defs.h
│   │   ├── include.h
│   │   └── xorstr.h
│   ├── main.cpp
│   ├── memory
│   │   ├── memory.cpp
│   │   ├── memory.h
│   │   ├── phys.cpp
│   │   └── phys.h
│   ├── process
│   │   ├── funcs.h
│   │   └── proc_funcs.cpp
│   └── system
│       ├── funcs.h
│       └── sys_funcs.cpp
└── WKUSER
    ├── WKUSER.vcxproj
    ├── WKUSER.vcxproj.filters
    ├── WKUSER.vcxproj.user
    ├── kernel
    │   ├── driver.cpp
    │   └── driver.h
    ├── main.cpp
    └── xorstr.h

```

`README.md`:

```md
# .data-ptr-driver
An other Detected &amp; Pasted driver

```

`WKDRIVER/WKDRIVER.inf`:

```inf
;
; WKDRIVER.inf
;

[Version]
Signature="$WINDOWS NT$"
Class = System
ClassGuid = {4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
CatalogFile=WKDRIVER.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
WKDRIVER_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================


[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
WKDRIVER.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%WKDRIVER.DeviceDesc%=WKDRIVER_Device, Root\WKDRIVER ; TODO: edit hw-id

[WKDRIVER_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
WKDRIVER.sys

;-------------- Service installation
[WKDRIVER_Device.NT.Services]
AddService = WKDRIVER,%SPSVCINST_ASSOCSERVICE%, WKDRIVER_Service_Inst

; -------------- WKDRIVER driver install sections
[WKDRIVER_Service_Inst]
DisplayName    = %WKDRIVER.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\WKDRIVER.sys

;
;--- WKDRIVER_Device Coinstaller installation ------
;

[WKDRIVER_Device.NT.CoInstallers]
AddReg=WKDRIVER_Device_CoInstaller_AddReg
CopyFiles=WKDRIVER_Device_CoInstaller_CopyFiles

[WKDRIVER_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[WKDRIVER_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[WKDRIVER_Device.NT.Wdf]
KmdfService =  WKDRIVER, WKDRIVER_wdfsect
[WKDRIVER_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "WKDRIVER Installation Disk"
WKDRIVER.DeviceDesc = "WKDRIVER Device"
WKDRIVER.SVCDESC = "WKDRIVER Service"

```

`WKDRIVER/WKDRIVER.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{469C3CC0-2357-4DB4-A1D9-B8F4464D40D4}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>LovenseRemoteDriver</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <CharacterSet>NotSet</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IntDir>$(SolutionDir)$(Platform)\Int_Release\$(ProjectName)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <IncludePath>$(SolutionDir)$(TargetName.Replace(' ',''))\;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <ExceptionHandling>Sync</ExceptionHandling>
      <TreatWarningAsError>false</TreatWarningAsError>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <AssemblerOutput>All</AssemblerOutput>
      <BrowseInformation>true</BrowseInformation>
    </ClCompile>
    <Link>
      <LargeAddressAware>true</LargeAddressAware>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <Profile>false</Profile>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="WKDRIVER.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="core\hook.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="memory\memory.cpp" />
    <ClCompile Include="process\proc_funcs.cpp" />
    <ClCompile Include="system\sys_funcs.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver\defs.h" />
    <ClInclude Include="core\framework.h" />
    <ClInclude Include="core\hook.h" />
    <ClInclude Include="driver\include.h" />
    <ClInclude Include="Driver\IoControl.h" />
    <ClInclude Include="Driver\StaticConfig.h" />
    <ClInclude Include="driver\xorstr.h" />
    <ClInclude Include="memory\memory.h" />
    <ClInclude Include="process\funcs.h" />
    <ClInclude Include="Protection\XorStr.h" />
    <ClInclude Include="system\funcs.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`WKDRIVER/WKDRIVER.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="WKDRIVER.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="system\sys_funcs.cpp" />
    <ClCompile Include="process\proc_funcs.cpp" />
    <ClCompile Include="core\hook.cpp" />
    <ClCompile Include="memory\memory.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Driver\IoControl.h" />
    <ClInclude Include="Driver\StaticConfig.h" />
    <ClInclude Include="Protection\XorStr.h" />
    <ClInclude Include="system\funcs.h" />
    <ClInclude Include="process\funcs.h" />
    <ClInclude Include="driver\xorstr.h" />
    <ClInclude Include="driver\include.h" />
    <ClInclude Include="core\hook.h" />
    <ClInclude Include="core\framework.h" />
    <ClInclude Include="driver\defs.h" />
    <ClInclude Include="memory\memory.h" />
  </ItemGroup>
</Project>
```

`WKDRIVER/WKDRIVER.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`WKDRIVER/core/framework.h`:

```h
#pragma once
#include <driver/include.h>
#include <stdint.h>

namespace system
{
	// Process Environment Block
	typedef struct _PEB_LDR_DATA
	{
		ULONG Length;
		UCHAR Initialized;
		PVOID SsHandle;
		LIST_ENTRY InLoadOrderModuleList;
		LIST_ENTRY InMemoryOrderModuleList;
		LIST_ENTRY InInitializationOrderModuleList;
	} PEB_LDR_DATA, *PPEB_LDR_DATA;


	typedef struct _IMAGE_FILE_HEADER {
		WORD    Machine;
		WORD    NumberOfSections;
		DWORD   TimeDateStamp;
		DWORD   PointerToSymbolTable;
		DWORD   NumberOfSymbols;
		WORD    SizeOfOptionalHeader;
		WORD    Characteristics;
	} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

	typedef struct _IMAGE_DATA_DIRECTORY {
		DWORD   VirtualAddress;
		DWORD   Size;
	} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16
	typedef struct _IMAGE_OPTIONAL_HEADER64 {
		WORD        Magic;
		BYTE        MajorLinkerVersion;
		BYTE        MinorLinkerVersion;
		DWORD       SizeOfCode;
		DWORD       SizeOfInitializedData;
		DWORD       SizeOfUninitializedData;
		DWORD       AddressOfEntryPoint;
		DWORD       BaseOfCode;
		ULONGLONG   ImageBase;
		DWORD       SectionAlignment;
		DWORD       FileAlignment;
		WORD        MajorOperatingSystemVersion;
		WORD        MinorOperatingSystemVersion;
		WORD        MajorImageVersion;
		WORD        MinorImageVersion;
		WORD        MajorSubsystemVersion;
		WORD        MinorSubsystemVersion;
		DWORD       Win32VersionValue;
		DWORD       SizeOfImage;
		DWORD       SizeOfHeaders;
		DWORD       CheckSum;
		WORD        Subsystem;
		WORD        DllCharacteristics;
		ULONGLONG   SizeOfStackReserve;
		ULONGLONG   SizeOfStackCommit;
		ULONGLONG   SizeOfHeapReserve;
		ULONGLONG   SizeOfHeapCommit;
		DWORD       LoaderFlags;
		DWORD       NumberOfRvaAndSizes;
		IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
	} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

	typedef struct _IMAGE_NT_HEADERS64 {
		DWORD Signature;
		IMAGE_FILE_HEADER FileHeader;
		IMAGE_OPTIONAL_HEADER64 OptionalHeader;
	} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;


	typedef struct _IMAGE_DOS_HEADER
	{
		WORD e_magic;
		WORD e_cblp;
		WORD e_cp;
		WORD e_crlc;
		WORD e_cparhdr;
		WORD e_minalloc;
		WORD e_maxalloc;
		WORD e_ss;
		WORD e_sp;
		WORD e_csum;
		WORD e_ip;
		WORD e_cs;
		WORD e_lfarlc;
		WORD e_ovno;
		WORD e_res[4];
		WORD e_oemid;
		WORD e_oeminfo;
		WORD e_res2[10];
		LONG e_lfanew;
	} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

#define IMAGE_SIZEOF_SHORT_NAME              8
	typedef struct _IMAGE_SECTION_HEADER {
		BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
		union {
			DWORD   PhysicalAddress;
			DWORD   VirtualSize;
		} Misc;
		DWORD   VirtualAddress;
		DWORD   SizeOfRawData;
		DWORD   PointerToRawData;
		DWORD   PointerToRelocations;
		DWORD   PointerToLinenumbers;
		WORD    NumberOfRelocations;
		WORD    NumberOfLinenumbers;
		DWORD   Characteristics;
	} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#define IMAGE_FIRST_SECTION( ntheader ) ((System::PIMAGE_SECTION_HEADER)  \
    ((ULONG_PTR)(ntheader) +                                      \
     FIELD_OFFSET( System::IMAGE_NT_HEADERS, OptionalHeader ) +           \
     ((ntheader))->FileHeader.SizeOfOptionalHeader   \
    ))


	typedef struct _PEB
	{
		UCHAR InheritedAddressSpace;
		UCHAR ReadImageFileExecOptions;
		UCHAR BeingDebugged;
		UCHAR BitField;
		PVOID Mutant;
		PVOID ImageBaseAddress;
		PPEB_LDR_DATA Ldr;
		PVOID ProcessParameters;
		PVOID SubSystemData;
		PVOID ProcessHeap;
		PVOID FastPebLock;
		PVOID AtlThunkSListPtr;
		PVOID IFEOKey;
		PVOID CrossProcessFlags;
		PVOID KernelCallbackTable;
		ULONG SystemReserved;
		ULONG AtlThunkSListPtr32;
		PVOID ApiSetMap;
	} PEB, *PPEB;


	// Loader
	typedef struct _NON_PAGED_DEBUG_INFO
	{
		USHORT      Signature;
		USHORT      Flags;
		ULONG       Size;
		USHORT      Machine;
		USHORT      Characteristics;
		ULONG       TimeDateStamp;
		ULONG       CheckSum;
		ULONG       SizeOfImage;
		ULONGLONG   ImageBase;
	} NON_PAGED_DEBUG_INFO, *PNON_PAGED_DEBUG_INFO;

	typedef struct _LDR_DATA_TABLE_ENTRY
	{
		LIST_ENTRY InLoadOrderLinks;
		PVOID ExceptionTable;
		ULONG ExceptionTableSize;
		// ULONG padding on IA64
		PVOID GpValue;
		PNON_PAGED_DEBUG_INFO NonPagedDebugInfo;
		PVOID DllBase;
		PVOID EntryPoint;
		ULONG SizeOfImage;
		UNICODE_STRING FullDllName;
		UNICODE_STRING BaseDllName;
		ULONG Flags;
		USHORT LoadCount;
		USHORT __Unused5;
		PVOID SectionPointer;
		ULONG CheckSum;
		// ULONG padding on IA64
		PVOID LoadedImports;
		PVOID PatchInformation;
	} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;



	typedef struct _RTL_PROCESS_MODULE_INFORMATION
	{
		HANDLE Section;
		PVOID MappedBase;
		PVOID ImageBase;
		ULONG ImageSize;
		ULONG Flags;
		USHORT LoadOrderIndex;
		USHORT InitOrderIndex;
		USHORT LoadCount;
		USHORT OffsetToFileName;
		UCHAR  FullPathName[MAXIMUM_FILENAME_LENGTH];
	} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

	typedef struct _RTL_PROCESS_MODULES
	{
		ULONG NumberOfModules;
		RTL_PROCESS_MODULE_INFORMATION Modules[1];
	} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;


	// Enums
	typedef enum _SYSTEM_INFORMATION_CLASS
	{
		SystemBasicInformation = 0x0,
		SystemProcessorInformation = 0x1,
		SystemPerformanceInformation = 0x2,
		SystemTimeOfDayInformation = 0x3,
		SystemPathInformation = 0x4,
		SystemProcessInformation = 0x5,
		SystemCallCountInformation = 0x6,
		SystemDeviceInformation = 0x7,
		SystemProcessorPerformanceInformation = 0x8,
		SystemFlagsInformation = 0x9,
		SystemCallTimeInformation = 0xa,
		SystemModuleInformation = 0xb,
		SystemLocksInformation = 0xc,
		SystemStackTraceInformation = 0xd,
		SystemPagedPoolInformation = 0xe,
		SystemNonPagedPoolInformation = 0xf,
		SystemHandleInformation = 0x10,
		SystemObjectInformation = 0x11,
		SystemPageFileInformation = 0x12,
		SystemVdmInstemulInformation = 0x13,
		SystemVdmBopInformation = 0x14,
		SystemFileCacheInformation = 0x15,
		SystemPoolTagInformation = 0x16,
		SystemInterruptInformation = 0x17,
		SystemDpcBehaviorInformation = 0x18,
		SystemFullMemoryInformation = 0x19,
		SystemLoadGdiDriverInformation = 0x1a,
		SystemUnloadGdiDriverInformation = 0x1b,
		SystemTimeAdjustmentInformation = 0x1c,
		SystemSummaryMemoryInformation = 0x1d,
		SystemMirrorMemoryInformation = 0x1e,
		SystemPerformanceTraceInformation = 0x1f,
		SystemObsolete0 = 0x20,
		SystemExceptionInformation = 0x21,
		SystemCrashDumpStateInformation = 0x22,
		SystemKernelDebuggerInformation = 0x23,
		SystemContextSwitchInformation = 0x24,
		SystemRegistryQuotaInformation = 0x25,
		SystemExtendServiceTableInformation = 0x26,
		SystemPrioritySeperation = 0x27,
		SystemVerifierAddDriverInformation = 0x28,
		SystemVerifierRemoveDriverInformation = 0x29,
		SystemProcessorIdleInformation = 0x2a,
		SystemLegacyDriverInformation = 0x2b,
		SystemCurrentTimeZoneInformation = 0x2c,
		SystemLookasideInformation = 0x2d,
		SystemTimeSlipNotification = 0x2e,
		SystemSessionCreate = 0x2f,
		SystemSessionDetach = 0x30,
		SystemSessionInformation = 0x31,
		SystemRangeStartInformation = 0x32,
		SystemVerifierInformation = 0x33,
		SystemVerifierThunkExtend = 0x34,
		SystemSessionProcessInformation = 0x35,
		SystemLoadGdiDriverInSystemSpace = 0x36,
		SystemNumaProcessorMap = 0x37,
		SystemPrefetcherInformation = 0x38,
		SystemExtendedProcessInformation = 0x39,
		SystemRecommendedSharedDataAlignment = 0x3a,
		SystemComPlusPackage = 0x3b,
		SystemNumaAvailableMemory = 0x3c,
		SystemProcessorPowerInformation = 0x3d,
		SystemEmulationBasicInformation = 0x3e,
		SystemEmulationProcessorInformation = 0x3f,
		SystemExtendedHandleInformation = 0x40,
		SystemLostDelayedWriteInformation = 0x41,
		SystemBigPoolInformation = 0x42,
		SystemSessionPoolTagInformation = 0x43,
		SystemSessionMappedViewInformation = 0x44,
		SystemHotpatchInformation = 0x45,
		SystemObjectSecurityMode = 0x46,
		SystemWatchdogTimerHandler = 0x47,
		SystemWatchdogTimerInformation = 0x48,
		SystemLogicalProcessorInformation = 0x49,
		SystemWow64SharedInformationObsolete = 0x4a,
		SystemRegisterFirmwareTableInformationHandler = 0x4b,
		SystemFirmwareTableInformation = 0x4c,
		SystemModuleInformationEx = 0x4d,
		SystemVerifierTriageInformation = 0x4e,
		SystemSuperfetchInformation = 0x4f,
		SystemMemoryListInformation = 0x50,
		SystemFileCacheInformationEx = 0x51,
		SystemThreadPriorityClientIdInformation = 0x52,
		SystemProcessorIdleCycleTimeInformation = 0x53,
		SystemVerifierCancellationInformation = 0x54,
		SystemProcessorPowerInformationEx = 0x55,
		SystemRefTraceInformation = 0x56,
		SystemSpecialPoolInformation = 0x57,
		SystemProcessIdInformation = 0x58,
		SystemErrorPortInformation = 0x59,
		SystemBootEnvironmentInformation = 0x5a,
		SystemHypervisorInformation = 0x5b,
		SystemVerifierInformationEx = 0x5c,
		SystemTimeZoneInformation = 0x5d,
		SystemImageFileExecutionOptionsInformation = 0x5e,
		SystemCoverageInformation = 0x5f,
		SystemPrefetchPatchInformation = 0x60,
		SystemVerifierFaultsInformation = 0x61,
		SystemSystemPartitionInformation = 0x62,
		SystemSystemDiskInformation = 0x63,
		SystemProcessorPerformanceDistribution = 0x64,
		SystemNumaProximityNodeInformation = 0x65,
		SystemDynamicTimeZoneInformation = 0x66,
		SystemCodeIntegrityInformation = 0x67,
		SystemProcessorMicrocodeUpdateInformation = 0x68,
		SystemProcessorBrandString = 0x69,
		SystemVirtualAddressInformation = 0x6a,
		SystemLogicalProcessorAndGroupInformation = 0x6b,
		SystemProcessorCycleTimeInformation = 0x6c,
		SystemStoreInformation = 0x6d,
		SystemRegistryAppendString = 0x6e,
		SystemAitSamplingValue = 0x6f,
		SystemVhdBootInformation = 0x70,
		SystemCpuQuotaInformation = 0x71,
		SystemNativeBasicInformation = 0x72,
		SystemErrorPortTimeouts = 0x73,
		SystemLowPriorityIoInformation = 0x74,
		SystemBootEntropyInformation = 0x75,
		SystemVerifierCountersInformation = 0x76,
		SystemPagedPoolInformationEx = 0x77,
		SystemSystemPtesInformationEx = 0x78,
		SystemNodeDistanceInformation = 0x79,
		SystemAcpiAuditInformation = 0x7a,
		SystemBasicPerformanceInformation = 0x7b,
		SystemQueryPerformanceCounterInformation = 0x7c,
		SystemSessionBigPoolInformation = 0x7d,
		SystemBootGraphicsInformation = 0x7e,
		SystemScrubPhysicalMemoryInformation = 0x7f,
		SystemBadPageInformation = 0x80,
		SystemProcessorProfileControlArea = 0x81,
		SystemCombinePhysicalMemoryInformation = 0x82,
		SystemEntropyInterruptTimingInformation = 0x83,
		SystemConsoleInformation = 0x84,
		SystemPlatformBinaryInformation = 0x85,
		SystemThrottleNotificationInformation = 0x86,
		SystemHypervisorProcessorCountInformation = 0x87,
		SystemDeviceDataInformation = 0x88,
		SystemDeviceDataEnumerationInformation = 0x89,
		SystemMemoryTopologyInformation = 0x8a,
		SystemMemoryChannelInformation = 0x8b,
		SystemBootLogoInformation = 0x8c,
		SystemProcessorPerformanceInformationEx = 0x8d,
		SystemSpare0 = 0x8e,
		SystemSecureBootPolicyInformation = 0x8f,
		SystemPageFileInformationEx = 0x90,
		SystemSecureBootInformation = 0x91,
		SystemEntropyInterruptTimingRawInformation = 0x92,
		SystemPortableWorkspaceEfiLauncherInformation = 0x93,
		SystemFullProcessInformation = 0x94,
		SystemKernelDebuggerInformationEx = 0x95,
		SystemBootMetadataInformation = 0x96,
		SystemSoftRebootInformation = 0x97,
		SystemElamCertificateInformation = 0x98,
		SystemOfflineDumpConfigInformation = 0x99,
		SystemProcessorFeaturesInformation = 0x9a,
		SystemRegistryReconciliationInformation = 0x9b,
		MaxSystemInfoClass = 0x9c,
	} SYSTEM_INFORMATION_CLASS;

	// Imports
	extern "C" __declspec(dllimport) PLIST_ENTRY PsLoadedModuleList;

	extern "C" NTSTATUS NTAPI ZwQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);

	extern "C" PVOID NTAPI RtlFindExportedRoutineByName(PVOID ImageBase, PCCH RoutineName);
}

namespace process
{
	// Imports
	extern "C" system::PPEB NTAPI PsGetProcessPeb(PEPROCESS Process);
	extern "C" PVOID PsGetProcessSectionBaseAddress(PEPROCESS Process);
	extern "C" PVOID PsGetProcessSectionBaseAddress(PEPROCESS Process);
}

namespace memory
{
	// Imports
	extern "C" NTSTATUS NTAPI ZwProtectVirtualMemory(HANDLE ProcessHandle, PVOID * BaseAddress, PULONG NumberOfBytesToProtect, ULONG NewAccessProtection, PULONG OldAccessProtection);
	extern "C" NTSTATUS NTAPI MmCopyVirtualMemory(PEPROCESS SourceProcess, PVOID SourceAddress, PEPROCESS TargetProcess, PVOID TargetAddress, SIZE_T BufferSize, KPROCESSOR_MODE PreviousMode, PSIZE_T ReturnSize);
}
```

`WKDRIVER/core/hook.cpp`:

```cpp
#include "hook.h"
#include <memory/memory.h> //read_process_memory, write_process_memory
#include <process/funcs.h>
#include <system/funcs.h>




NTSTATUS GetModuleBaseAddress( int processId, const char *moduleName, uint64_t *baseAddress )
{
	ANSI_STRING ansiString;
	UNICODE_STRING compareString;
	KAPC_STATE state;
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	PEPROCESS process = NULL;
	system::PPEB pPeb = NULL;

	RtlInitAnsiString( &ansiString, moduleName );
	RtlAnsiStringToUnicodeString( &compareString, &ansiString, TRUE );

	printf( "Looking for module %d\n", processId );

	if ( !NT_SUCCESS( PsLookupProcessByProcessId( ( HANDLE ) processId, &process ) ) )
		return STATUS_UNSUCCESSFUL;

	printf( "Found process %d\n", processId );

	KeStackAttachProcess( process, &state );
	pPeb = process::PsGetProcessPeb( process );

	if ( pPeb )
	{
		system::PPEB_LDR_DATA pLdr = ( system::PPEB_LDR_DATA ) pPeb->Ldr;

		if ( pLdr )
		{
			for ( PLIST_ENTRY listEntry = ( PLIST_ENTRY ) pLdr->InLoadOrderModuleList.Flink;
				listEntry != &pLdr->InLoadOrderModuleList;
				listEntry = ( PLIST_ENTRY ) listEntry->Flink ) {
			
				system::PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD( listEntry, system::LDR_DATA_TABLE_ENTRY, InLoadOrderLinks );
				printf( "%wZ\n", pEntry->BaseDllName );
				if ( RtlCompareUnicodeString( &pEntry->BaseDllName, &compareString, TRUE ) == 0 )
				{
					*baseAddress = ( uint64_t ) pEntry->DllBase;
					status = STATUS_SUCCESS;
					break;
				}
			}
		}
	}
	KeUnstackDetachProcess( &state );
	RtlFreeUnicodeString( &compareString );
	return status;
}


__int64 __fastcall core_hook::hooked_fptr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
	if (!a1 || ExGetPreviousMode() != UserMode)
	{
		printf("!a1 || ExGetPreviousMode() != UserMode fail. arguments: %p, %p, %p, %p\n", a1, a2, a3, a4);
		return 0;
	}

	if (a3 != fptr_data::static_identifier)
	{
		printf("arguments: % p, %p, %p, %p\n", a1, a2, a3, a4);
		if (o_fptr)
		{
			printf("original .data ptr call.\n");
			return o_fptr(a1, a2, a3, a4);
		}
		printf("Call failed static identifier check.\n");
		return 0;
	}

	// We in our territory now
	/*fptr_data::kernel_com com{};
	size_t read = 0;

	if (!NT_SUCCESS(memory::read_virtual(memory::get_kernel_dirbase(), a1, (uint8_t *)&com, sizeof(com), &read)) || read != sizeof(com))
	{
		printf("invalid memory sent to kernel for operation.\n");
		return 0;
	}*/
	fptr_data::kernel_com *com = (fptr_data::kernel_com *)a1;
	com->error = fptr_data::kernel_err::no_error;

	switch (static_cast<fptr_data::kernel_opr>(a4))
	{
		case fptr_data::kernel_opr::unhook_driver:
		{
			InterlockedExchangePointer((volatile PVOID *)core_hook::fptr_addr, core_hook::o_fptr);
			printf("unloaded driver.\n");
			break;
		}
		case fptr_data::kernel_opr::get_process_base:
		{
			NTSTATUS status = STATUS_SUCCESS;

			PEPROCESS proc = process::get_by_id(com->target_pid, &status);
			if (!NT_SUCCESS(status))
			{
				com->error = fptr_data::kernel_err::invalid_process;
				com->success = false;

				printf("get_process_base failed: invalid process.\n");
				return 1;
			}

			com->buffer = (uintptr_t)process::PsGetProcessSectionBaseAddress(proc);
			ObDereferenceObject(proc);
			break;
		}
		case fptr_data::kernel_opr::get_process_module:
		{
			// Inputs
			if (!com->target_pid)
			{
				com->error = fptr_data::kernel_err::invalid_data;
				com->success = false;
				printf("get_process_module failed: no valid process id given.\n");
				break;
			}


			uintptr_t buffer = 0;
			com->buffer = 0;
			if ( NT_SUCCESS( GetModuleBaseAddress( com->target_pid, com->name, &buffer ) ) )
				com->buffer = buffer;
			break;
			
			break;
		}
		case fptr_data::kernel_opr::write:
		{
			if (!NT_SUCCESS(memory::write_process_memory(com->target_pid, com->user_pid, com->address, com->buffer, com->size, &com->transfer)))
			{
				com->success = false;
				com->error = fptr_data::kernel_err::invalid_data;
				printf("write failed: invalid data.\n");
				return 1;
			}
			break;
		}
		case fptr_data::kernel_opr::read:
		{
			if (!NT_SUCCESS(memory::read_process_memory(com->target_pid, com->user_pid, com->address, com->buffer, com->size, &com->transfer)))
			{
				com->success = false;
				com->error = fptr_data::kernel_err::invalid_data;
				printf("read failed: invalid data.\n");
				return 1;
			}
			break;
		}



		case fptr_data::kernel_opr::protect:
		{
			NTSTATUS status = STATUS_SUCCESS;
			PEPROCESS hProc = process::get_by_id(com->target_pid, &status);
			if (!NT_SUCCESS(status) || !hProc)
			{
				com->success = false;
				com->error = fptr_data::kernel_err::check_fail;
				return 1;
			}

			void *addr = (void *)com->address;
			uint64_t size = com->size;
			uint32_t oldProtection = 0;
			uint32_t protection = com->buffer; // no condoms oke

			KAPC_STATE state;
			KeStackAttachProcess(hProc, &state);

			MEMORY_BASIC_INFORMATION mbi;
			if (!NT_SUCCESS(ZwQueryVirtualMemory(ZwCurrentProcess(), addr, MemoryBasicInformation, &mbi, sizeof(mbi), NULL)))
			{
				KeUnstackDetachProcess(&state);
				com->success = false;
				com->error = fptr_data::kernel_err::check_fail;
				return 1;
			}

			if (mbi.Protect != com->buffer)
			{
				if (!NT_SUCCESS(memory::ZwProtectVirtualMemory(ZwCurrentProcess(), &addr, (PULONG)&size, protection, (PULONG)&oldProtection)))
				{
					KeUnstackDetachProcess(&state);
					com->success = false;
					com->error = fptr_data::kernel_err::check_fail;
					return 1;
				}
				KeUnstackDetachProcess(&state);
				ObDereferenceObject(hProc);

				com->buffer = oldProtection;
			}
			else
			{
				KeUnstackDetachProcess(&state);
				ObDereferenceObject(hProc);

				com->buffer = mbi.Protect;
			}
			break;
		}
		case fptr_data::kernel_opr::alloc:
		{
			NTSTATUS status = STATUS_SUCCESS;
			PEPROCESS hProc = process::get_by_id(com->target_pid, &status);
			if (!NT_SUCCESS(status) || !hProc)
			{
				com->success = false;
				com->error = fptr_data::kernel_err::check_fail;
				return 1;
			}

			uintptr_t addr, size, buffer, user_pid;
			addr = com->address;
			size = com->size;
			buffer = com->buffer;
			user_pid = com->user_pid;

			KAPC_STATE state;
			KeStackAttachProcess(hProc, &state);
			status = ZwAllocateVirtualMemory(ZwCurrentProcess(), (PVOID *)&addr, 0, &size, buffer, user_pid);
			if (!NT_SUCCESS(status))
			{
				KeUnstackDetachProcess(&state);
				ObDereferenceObject(hProc);
				com->success = false;
				com->error = fptr_data::kernel_err::check_fail;
				return 1;
			}
			KeUnstackDetachProcess(&state);

			com->address = addr;
			com->size = size;

			ObDereferenceObject(hProc);
			break;
		}
		case fptr_data::kernel_opr::free:
		{
			NTSTATUS status = STATUS_SUCCESS;
			PEPROCESS hProc = process::get_by_id(com->target_pid, &status);
			if (!NT_SUCCESS(status) || !hProc)
			{
				com->success = false;
				com->error = fptr_data::kernel_err::check_fail;
				return 1;
			}

			uintptr_t addr, size;
			addr = com->address;
			size = 0;

			KAPC_STATE state;
			KeStackAttachProcess(hProc, &state);
			if (!NT_SUCCESS(ZwFreeVirtualMemory(ZwCurrentProcess(), (PVOID *)&addr, &size, MEM_RELEASE)))
			{
				KeUnstackDetachProcess(&state);
				com->success = false;
				com->error = fptr_data::kernel_err::check_fail;
				return 1;
			}
			KeUnstackDetachProcess(&state);
			ObDereferenceObject(hProc);
			break;
		}

		default:
		{
			com->success = false;
			com->error = fptr_data::kernel_err::no_operation;
			printf("(%p) failed: unknown operation.\n", a4);
			return 1;
		}
	}

	com->success = true;
	printf("kernel operation completed successfully.\n");
	return 1; //doesn't actually matter what this is (just >0)
}
```

`WKDRIVER/core/hook.h`:

```h
#pragma once
#include <driver/defs.h>
#include <driver/include.h>
#include <system/funcs.h>



namespace core_hook
{
	typedef __int64(__fastcall *pfunc_hk_t)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4);


	inline uintptr_t fptr_addr = NULL;
	inline pfunc_hk_t o_fptr = (pfunc_hk_t)NULL;


	/* All information about this .data ptr:
	
	NtGdiPolyPolyDraw + 0x366 is the fptr.
	
	if ( qword_1C0251830 )
	{
		v21 = qword_1C0251830(); <--- another fptr, possible to hook if wanted.
		v9 = -1073741637;
		a1 = v25;
	}
	else
	{
		v9 = -1073741637;
		v21 = -1073741637;
	}
	if ( v21 < 0 )
		return v8;
	v22 = (int)qword_1C0251838;
	if ( qword_1C0251838 )
		v22 = qword_1C0251838(a1, v7, v6, (unsigned int)v5); <--- hooked fptr    a1 = a1, v7 = a2, v6 = a3, v5 = (unsigned)(a4 [!>0])
	if ( v22 )
		return v8;

	a5 when calling NtGdiPolyPolyDraw must be 2.

	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	!! a4 CAN *NOT* be NULL or else it will immediately return 0. Any other value is acceptable. !!
	!! a4 CAN *NOT* be NULL or else it will immediately return 0. Any other value is acceptable. !!
	!! a4 CAN *NOT* be NULL or else it will immediately return 0. Any other value is acceptable. !!
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	a1-a3 are free to use however you want *as they have no effect until it reaches the hooked_fptr*.


	when hooked_fptr returns non-null value, the function will return 1.
	when hooked_fptr returns 0, it will continue throughout the function (normally returns 0, but suggest returning 1 always).
	
	a1 = kernel_com
	a2   -- unused
	a3 = 0xBADC0DE
	a4 = control code
	*/
	__int64 __fastcall hooked_fptr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4);
}
```

`WKDRIVER/driver/defs.h`:

```h
#pragma once
#include <stdint.h>



namespace fptr_data
{
	constexpr uint64_t static_identifier = 0xBADC0DE;


	enum class kernel_opr : uint32_t
	{
		read = 1,
		write,
		get_process_module,
		get_process_base,

		unhook_driver,


		alloc,
		free,
		protect
	};


	enum class kernel_err : uint16_t
	{
		invalid_process = 2,
		check_fail,
		no_operation,
		invalid_data,

		no_error = 0,
		unset_err = 1
	};

	struct kernel_com
	{
		bool success;
		kernel_err error;


		uint32_t target_pid;
		uint32_t user_pid;

		uintptr_t address;
		uintptr_t buffer;
		
		union
		{
			size_t size;
			const char *name;
		};

		size_t transfer;
	};
}
```

`WKDRIVER/driver/include.h`:

```h
#pragma once
#include <stdint.h>
#include <ntdef.h>
#include <ntifs.h>
#include <ntddk.h>
#include <windef.h>
#include <ntstrsafe.h>

#include <driver/xorstr.h>


#define printf(text, ...) DbgPrintEx(DPFLTR_IHVBUS_ID, 0, XORS("[WKD]: " text), ##__VA_ARGS__)
```

`WKDRIVER/driver/xorstr.h`:

```h
#pragma once

/*____________________________________________________________________________________________________________

Original Author: skadro
Github: https://github.com/skadro-official
License: See end of file

skCrypter
		Compile-time, Usermode + Kernelmode, safe and lightweight string crypter library for C++11+

							*Not removing this part is appreciated*
____________________________________________________________________________________________________________*/

#ifdef _KERNEL_MODE
namespace std
{
	// STRUCT TEMPLATE remove_reference
	template <class _Ty>
	struct remove_reference {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&> {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&&> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

	// STRUCT TEMPLATE remove_const
	template <class _Ty>
	struct remove_const { // remove top-level const qualifier
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_const<const _Ty> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;
}
#else
#include <type_traits>
#endif

namespace xorcrypt
{
	template<class _Ty>
	using clean_type = typename std::remove_const_t<std::remove_reference_t<_Ty>>;

	template <int _size, char _key1, char _key2, typename T>
	class xorcrypt
	{
	public:
		__forceinline constexpr xorcrypt(T* data)
		{
			crypt(data);
		}

		__forceinline T* get()
		{
			return _storage;
		}

		__forceinline int size() // (w)char count
		{
			return _size;
		}

		__forceinline  char key()
		{
			return _key1;
		}

		__forceinline  T* encrypt()
		{
			if (!isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline  T* decrypt()
		{
			if (isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline bool isEncrypted()
		{
			return _storage[_size - 1] != 0;
		}

		__forceinline void clear() // set full storage to 0
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = 0;
			}
		}

		__forceinline operator T* ()
		{
			decrypt();

			return _storage;
		}

	private:
		__forceinline constexpr void crypt(T* data)
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = data[i] ^ (_key1 + i % (1 + _key2));
			}
		}

		T _storage[_size]{};
	};
}

#define XORS(str) XORS_KEY(str, __TIME__[4], __TIME__[7])
#define XORS_KEY(str, key1, key2) []() { \
			constexpr static auto crypted = xorcrypt::xorcrypt \
				<sizeof(str) / sizeof(str[0]), key1, key2, xorcrypt::clean_type<decltype(str[0])>>((xorcrypt::clean_type<decltype(str[0])>*)str); \
					return crypted; }()
```

`WKDRIVER/main.cpp`:

```cpp
#include <driver/include.h>
#include <driver/xorstr.h>

#include <system/funcs.h>
#include <core/hook.h>



extern "C" NTSTATUS DriverEntry(PDRIVER_OBJECT, PUNICODE_STRING)
{
	if (system::get_loaded_module(XORS(L"easyanticheat.sys")) ||
		system::get_loaded_module(XORS(L"bedaisy.sys")) ||
		system::get_loaded_module(XORS(L"vgk.sys")))
	{
		ExRaiseStatus(STATUS_ABANDONED);
		ExRaiseAccessViolation();
		*(uint32_t *)0 = 0x13376969;
		return 0xBADC0DE;
	}

	uintptr_t win32kbase = system::get_system_module(XORS(L"win32kbase.sys"));
	if (!win32kbase)
	{
		printf("win32kbase.sys not found in system modules, unable to load driver.\n");
		return STATUS_ABANDONED;
	}

	uintptr_t target_func = system::get_routine_address(win32kbase, XORS("NtGdiPolyPolyDraw"));
	if (!target_func)
	{
		printf("unable to find target function in exports of win32kbase.sys.\n");
		return STATUS_UNSUCCESSFUL;
	}


	target_func += 0x366; // Offset

	//48 8B 05 FB B9 18 00                          mov     rax, cs:qword_1C0251838
	core_hook::fptr_addr = (uintptr_t)target_func + *(uint32_t *)((uint8_t *)target_func + 3) + 7;
	core_hook::o_fptr = (core_hook::pfunc_hk_t)InterlockedExchangePointer((volatile PVOID *)core_hook::fptr_addr, &core_hook::hooked_fptr);
	
	printf("driver successfully loaded.\n");
	return STATUS_SUCCESS;
}
```

`WKDRIVER/memory/memory.cpp`:

```cpp
#include "memory.h"
#include <core/framework.h>
#include <process/funcs.h>



NTSTATUS memory::write_process_memory(uint32_t pid, uint32_t user_pid, uintptr_t addr, uintptr_t buffer, size_t size, size_t *bytes_written)
{
	NTSTATUS status = STATUS_SUCCESS;

	PEPROCESS user_proc = process::get_by_id(user_pid, &status);
	if (!NT_SUCCESS(status)) return status;
	PEPROCESS target_proc = process::get_by_id(pid, &status);
	if (!NT_SUCCESS(status))
	{
		ObDereferenceObject(user_proc);
		return status;
	}

	size_t processed;
	status = memory::MmCopyVirtualMemory(user_proc, (void *)buffer, target_proc, (void *)addr, size, UserMode, &processed);

	ObDereferenceObject(user_proc);
	ObDereferenceObject(target_proc);

	if (!NT_SUCCESS(status)) return status;
	if (bytes_written) *bytes_written = processed;

	if (processed != size)
		return STATUS_FAIL_CHECK;
	return STATUS_SUCCESS;
}

NTSTATUS memory::read_process_memory(uint32_t pid, uint32_t user_pid, uintptr_t addr, uintptr_t buffer, size_t size, size_t *bytes_read)
{
	NTSTATUS status = STATUS_SUCCESS;

	PEPROCESS user_proc = process::get_by_id(user_pid, &status);
	if (!NT_SUCCESS(status)) return status;
	PEPROCESS target_proc = process::get_by_id(pid, &status);
	if (!NT_SUCCESS(status)) return status;

	size_t processed;
	status = memory::MmCopyVirtualMemory(target_proc, (void *)addr, user_proc, (void *)buffer, size, UserMode, &processed);
	if (!NT_SUCCESS(status)) return status;
	if (bytes_read) *bytes_read = processed;

	if (processed != size)
		return STATUS_FAIL_CHECK;
	return STATUS_SUCCESS;
}
```

`WKDRIVER/memory/memory.h`:

```h
#pragma once
#include <driver/include.h>



namespace memory
{
	NTSTATUS write_process_memory(uint32_t pid, uint32_t user_pid, uintptr_t addr, uintptr_t buffer, size_t size, size_t *bytes_written);
	NTSTATUS read_process_memory(uint32_t pid, uint32_t user_pid, uintptr_t addr, uintptr_t buffer, size_t size, size_t *bytes_read);
}
```

`WKDRIVER/memory/phys.cpp`:

```cpp
#include "phys.h"


// Thank you Astronaut00, I promise I will learn from this one day.
// I actually mean that though, I just need this for now
//https://github.com/Astronaut00/DoubleDataPointer/blob/master/Driver/core.cpp


//https://ntdiff.github.io/
#define WINDOWS_1803 17134
#define WINDOWS_1809 17763
#define WINDOWS_1903 18362
#define WINDOWS_1909 18363
#define WINDOWS_2004 19041
#define WINDOWS_20H2 19569
#define WINDOWS_21H1 20180

DWORD GetUserDirectoryTableBaseOffset()
{
	RTL_OSVERSIONINFOW ver = { 0 };
	RtlGetVersion(&ver);

	switch (ver.dwBuildNumber)
	{
		case WINDOWS_1803:
			return 0x0278;
			break;
		case WINDOWS_1809:
			return 0x0278;
			break;
		case WINDOWS_1903:
			return 0x0280;
			break;
		case WINDOWS_1909:
			return 0x0280;
			break;
		case WINDOWS_2004:
			return 0x0388;
			break;
		case WINDOWS_20H2:
			return 0x0388;
			break;
		case WINDOWS_21H1:
			return 0x0388;
			break;
		default:
			return 0x0388;
	}
}

//check normal dirbase if 0 then get from UserDirectoryTableBas
ULONG_PTR get_process_cr3(PEPROCESS pProcess)
{
	PUCHAR process = (PUCHAR)pProcess;
	ULONG_PTR process_dirbase = *(PULONG_PTR)(process + 0x28); //dirbase x64, 32bit is 0x18
	if (process_dirbase == 0)
	{
		DWORD UserDirOffset = GetUserDirectoryTableBaseOffset();
		ULONG_PTR process_userdirbase = *(PULONG_PTR)(process + UserDirOffset);
		return process_userdirbase;
	}
	return process_dirbase;
}
ULONG_PTR memory::get_kernel_dirbase()
{
	PUCHAR process = (PUCHAR)PsGetCurrentProcess();
	ULONG_PTR cr3 = *(PULONG_PTR)(process + 0x28); //dirbase x64, 32bit is 0x18
	return cr3;
}
uint64_t TranslateLinearAddress(uint64_t directoryTableBase, uint64_t virtualAddress);
NTSTATUS ReadPhysicalAddress(uint64_t TargetAddress, PVOID lpBuffer, SIZE_T Size, SIZE_T* BytesRead);
NTSTATUS WritePhysicalAddress(uint64_t TargetAddress, PVOID lpBuffer, SIZE_T Size, SIZE_T* BytesWritten);


NTSTATUS memory::read_virtual(uint64_t dirbase, uint64_t address, uint8_t* buffer, SIZE_T size, SIZE_T* read)
{
	uint64_t paddress = TranslateLinearAddress(dirbase, address);
	return ReadPhysicalAddress(paddress, buffer, size, read);
}

NTSTATUS memory::write_virtual(uint64_t dirbase, uint64_t address, uint8_t* buffer, SIZE_T size, SIZE_T* written)
{
	uint64_t paddress = TranslateLinearAddress(dirbase, address);
	return WritePhysicalAddress(paddress, buffer, size, written);
}

NTSTATUS ReadPhysicalAddress(uint64_t TargetAddress, PVOID lpBuffer, SIZE_T Size, SIZE_T* BytesRead)
{
	MM_COPY_ADDRESS AddrToRead = { 0 };
	AddrToRead.PhysicalAddress.QuadPart = TargetAddress;
	return MmCopyMemory(lpBuffer, AddrToRead, Size, MM_COPY_MEMORY_PHYSICAL, BytesRead);
}

//MmMapIoSpaceEx limit is page 4096 byte
NTSTATUS WritePhysicalAddress(uint64_t TargetAddress, PVOID lpBuffer, SIZE_T Size, SIZE_T* BytesWritten)
{
	if (!TargetAddress)
		return STATUS_UNSUCCESSFUL;

	PHYSICAL_ADDRESS AddrToWrite = { 0 };
	AddrToWrite.QuadPart = TargetAddress;

	PVOID pmapped_mem = MmMapIoSpaceEx(AddrToWrite, Size, PAGE_READWRITE);

	if (!pmapped_mem)
		return STATUS_UNSUCCESSFUL;

	memcpy(pmapped_mem, lpBuffer, Size);

	if (BytesWritten) *BytesWritten = Size;
	MmUnmapIoSpace(pmapped_mem, Size);
	return STATUS_SUCCESS;
}

#define PAGE_OFFSET_SIZE 12
static const uint64_t PMASK = (~0xfull << 8) & 0xfffffffffull;

uint64_t TranslateLinearAddress(uint64_t directoryTableBase, uint64_t virtualAddress) {
	directoryTableBase &= ~0xf;

	uint64_t pageOffset = virtualAddress & ~(~0ul << PAGE_OFFSET_SIZE);
	uint64_t pte = ((virtualAddress >> 12) & (0x1ffll));
	uint64_t pt = ((virtualAddress >> 21) & (0x1ffll));
	uint64_t pd = ((virtualAddress >> 30) & (0x1ffll));
	uint64_t pdp = ((virtualAddress >> 39) & (0x1ffll));

	SIZE_T readsize = 0;
	uint64_t pdpe = 0;
	ReadPhysicalAddress(directoryTableBase + 8 * pdp, &pdpe, sizeof(pdpe), &readsize);
	if (~pdpe & 1)
		return 0;

	uint64_t pde = 0;
	ReadPhysicalAddress((pdpe & PMASK) + 8 * pd, &pde, sizeof(pde), &readsize);
	if (~pde & 1)
		return 0;

	/* 1GB large page, use pde's 12-34 bits */
	if (pde & 0x80)
		return (pde & (~0ull << 42 >> 12)) + (virtualAddress & ~(~0ull << 30));

	uint64_t pteAddr = 0;
	ReadPhysicalAddress((pde & PMASK) + 8 * pt, &pteAddr, sizeof(pteAddr), &readsize);
	if (~pteAddr & 1)
		return 0;

	/* 2MB large page */
	if (pteAddr & 0x80)
		return (pteAddr & PMASK) + (virtualAddress & ~(~0ull << 21));

	virtualAddress = 0;
	ReadPhysicalAddress((pteAddr & PMASK) + 8 * pte, &virtualAddress, sizeof(virtualAddress), &readsize);
	virtualAddress &= PMASK;

	if (!virtualAddress)
		return 0;

	return virtualAddress + pageOffset;
}


//
NTSTATUS ReadProcessMemory(int pid, uint64_t Address, uint64_t AllocatedBuffer, SIZE_T size, SIZE_T* read)
{
	PEPROCESS pProcess = NULL;
	if (pid == 0) return STATUS_UNSUCCESSFUL;

	NTSTATUS NtRet = PsLookupProcessByProcessId((HANDLE)pid, &pProcess);
	if (NtRet != STATUS_SUCCESS) return NtRet;

	ULONG_PTR process_dirbase = get_process_cr3(pProcess);
	ObDereferenceObject(pProcess);

	SIZE_T CurOffset = 0;
	SIZE_T TotalSize = size;
	while (TotalSize)
	{

		uint64_t CurPhysAddr = TranslateLinearAddress(process_dirbase, (ULONG64)Address + CurOffset);
		if (!CurPhysAddr) return STATUS_UNSUCCESSFUL;

		ULONG64 ReadSize = min(PAGE_SIZE - (CurPhysAddr & 0xFFF), TotalSize);
		SIZE_T BytesRead = 0;
		NtRet = ReadPhysicalAddress(CurPhysAddr, (PVOID)((ULONG64)AllocatedBuffer + CurOffset), ReadSize, &BytesRead);
		TotalSize -= BytesRead;
		CurOffset += BytesRead;
		if (NtRet != STATUS_SUCCESS) break;
		if (BytesRead == 0) break;
	}

	*read = CurOffset;
	return NtRet;
}

NTSTATUS WriteProcessMemory(int pid, uint64_t Address, uint64_t AllocatedBuffer, SIZE_T size, SIZE_T* written)
{
	PEPROCESS pProcess = NULL;
	if (pid == 0) return STATUS_UNSUCCESSFUL;

	NTSTATUS NtRet = PsLookupProcessByProcessId((HANDLE)pid, &pProcess);
	if (NtRet != STATUS_SUCCESS) return NtRet;

	ULONG_PTR process_dirbase = get_process_cr3(pProcess);
	ObDereferenceObject(pProcess);

	SIZE_T CurOffset = 0;
	SIZE_T TotalSize = size;
	while (TotalSize)
	{
		uint64_t CurPhysAddr = TranslateLinearAddress(process_dirbase, (ULONG64)Address + CurOffset);
		if (!CurPhysAddr) return STATUS_UNSUCCESSFUL;

		ULONG64 WriteSize = min(PAGE_SIZE - (CurPhysAddr & 0xFFF), TotalSize);
		SIZE_T BytesWritten = 0;
		NtRet = WritePhysicalAddress(CurPhysAddr, (PVOID)((ULONG64)AllocatedBuffer + CurOffset), WriteSize, &BytesWritten);
		TotalSize -= BytesWritten;
		CurOffset += BytesWritten;
		if (NtRet != STATUS_SUCCESS) break;
		if (BytesWritten == 0) break;
	}

	*written = CurOffset;
	return NtRet;
}



namespace memory
{
	NTSTATUS write_process_memory(uint32_t pid, uintptr_t addr, uintptr_t buffer, size_t size, size_t *bytes_written)
	{
		NTSTATUS status = STATUS_SUCCESS;
		size_t btransfer;
		status = WriteProcessMemory(pid, addr, buffer, size, &btransfer);
		if (bytes_written)
			*bytes_written = btransfer;
		return status;
	}

	NTSTATUS read_process_memory(uint32_t pid, uintptr_t addr, uintptr_t buffer, size_t size, size_t *bytes_read)
	{
		NTSTATUS status = STATUS_SUCCESS;
		size_t btransfer;
		status = ReadProcessMemory(pid, addr, buffer, size, &btransfer);
		if (bytes_read)
			*bytes_read = btransfer;
		return status;
	}
}
```

`WKDRIVER/memory/phys.h`:

```h
#pragma once
#include <driver/include.h>



namespace memory
{
	ULONG_PTR get_kernel_dirbase();
	NTSTATUS read_virtual(uint64_t dirbase, uint64_t address, uint8_t* buffer, SIZE_T size, SIZE_T* read);
	NTSTATUS write_virtual(uint64_t dirbase, uint64_t address, uint8_t* buffer, SIZE_T size, SIZE_T* written);

	NTSTATUS write_process_memory(uint32_t pid, uintptr_t addr, uintptr_t buffer, size_t size, size_t *bytes_written);
	NTSTATUS read_process_memory(uint32_t pid, uintptr_t addr, uintptr_t buffer, size_t size, size_t *bytes_read);
}
```

`WKDRIVER/process/funcs.h`:

```h
#pragma once
#include <driver/include.h>
#include <core/framework.h>



namespace process
{
	PEPROCESS get_by_id(uint32_t pid, NTSTATUS *pstatus = nullptr);
}
```

`WKDRIVER/process/proc_funcs.cpp`:

```cpp
#include "funcs.h"


PEPROCESS process::get_by_id(uint32_t pid, NTSTATUS *pstatus)
{
	PEPROCESS hProc;
	NTSTATUS status = PsLookupProcessByProcessId( ( HANDLE ) pid, &hProc );
	if ( !NT_SUCCESS( status ) )
	{
		if ( pstatus )
			*pstatus = status;
		return NULL;
	}
	return hProc;
}
```

`WKDRIVER/system/funcs.h`:

```h
#pragma once
#include <driver/include.h>
#include <core/framework.h>



namespace system
{
	uintptr_t get_loaded_module(const wchar_t *name, PLDR_DATA_TABLE_ENTRY *entry = nullptr);
	uintptr_t get_system_module(const wchar_t *name);
	uintptr_t get_routine_address(uintptr_t image, const char *name);
}
```

`WKDRIVER/system/sys_funcs.cpp`:

```cpp
#include "funcs.h"


namespace system
{
	uintptr_t get_loaded_module(const wchar_t *name, PLDR_DATA_TABLE_ENTRY *entry)
	{
		if (!name || PsLoadedModuleList == NULL || IsListEmpty(PsLoadedModuleList))
			return NULL;

		UNICODE_STRING modName;
		RtlInitUnicodeString(&modName, name);

		for (PLIST_ENTRY pEntry = PsLoadedModuleList->Flink; pEntry != PsLoadedModuleList; pEntry = pEntry->Flink)
		{
			PLDR_DATA_TABLE_ENTRY data = CONTAINING_RECORD(pEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
			if (RtlEqualUnicodeString(&data->BaseDllName, &modName, TRUE))
			{
				if (entry)
					*entry = data;
				return (uintptr_t)data->DllBase;
			}
		}
		return NULL;
	}

	uintptr_t get_system_module(const wchar_t *name)
	{
		NTSTATUS status = STATUS_SUCCESS;
		ANSI_STRING s_name;
		UNICODE_STRING su_name;
		RtlInitUnicodeString(&su_name, name);
		RtlUnicodeStringToAnsiString(&s_name, &su_name, TRUE);

		PRTL_PROCESS_MODULES pModules = NULL;
		uint32_t szModules = 0;

		status = ZwQuerySystemInformation(SystemModuleInformation, 0, szModules, (PULONG)&szModules);
		if (!szModules)
		{
			RtlFreeAnsiString(&s_name);
			return 0;
		}

		pModules = (PRTL_PROCESS_MODULES)ExAllocatePool(NonPagedPool, szModules);
		if (!pModules)
		{
			RtlFreeAnsiString(&s_name);
			return 0;
		}
		RtlZeroMemory(pModules, szModules);

		status = ZwQuerySystemInformation(SystemModuleInformation, pModules, szModules, (PULONG)&szModules);
		if (!NT_SUCCESS(status))
		{
			RtlFreeAnsiString(&s_name);
			ExFreePool(pModules);
			return 0;
		}

		uintptr_t modBase = 0;
		PRTL_PROCESS_MODULE_INFORMATION pMods = pModules->Modules;
		for (ULONG i = 0; i < pModules->NumberOfModules && !modBase; i++)
		{
			RTL_PROCESS_MODULE_INFORMATION pMod = pMods[i];
			char *fullPath = (char*)pMod.FullPathName;
			if (fullPath && strlen(fullPath) > 0)
			{
				int32_t lastFound = -1;
				char *baseFullPath = (char *)pMod.FullPathName;
				while (*fullPath != 0)
				{
					if (*fullPath == '\\')
						lastFound = (fullPath - baseFullPath) + 1;
					fullPath++;
				}

				if (lastFound >= 0)
					fullPath = baseFullPath + lastFound;
			}
			else continue;

			ANSI_STRING s_fullPath;
			RtlInitAnsiString(&s_fullPath, fullPath);
			if (RtlEqualString(&s_fullPath, &s_name, TRUE))
				modBase = (uintptr_t)pMod.ImageBase;
		}
		RtlFreeAnsiString(&s_name);
		ExFreePool(pModules);
		return modBase;
	}

	uintptr_t get_routine_address(uintptr_t image, const char *name)
	{
		if (!image || !name)
			return NULL;
		return (uintptr_t)RtlFindExportedRoutineByName((PVOID)image, name);
	}
}
```

`WKUSER/WKUSER.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{4b5ce82b-61fd-4925-a2a8-6c72c93aa200}</ProjectGuid>
    <RootNamespace>WKUSER</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IntDir>$(SolutionDir)$(Platform)\Int_Release\$(ProjectName)\</IntDir>
    <IncludePath>$(SolutionDir)WKDRIVER\;$(SolutionDir)$(TargetName.Replace(' ',''))\;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="kernel\driver.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="kernel\driver.h" />
    <ClInclude Include="xorstr.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`WKUSER/WKUSER.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="kernel\driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="kernel\driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="xorstr.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`WKUSER/WKUSER.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`WKUSER/kernel/driver.cpp`:

```cpp
#include <Windows.h>
#include <iostream>
#include "driver.h"
#include <xorstr.h>



kernel::driver::driver() : pid(0u)
{}

kernel::driver::~driver()
{}



typedef __int64(__fastcall *pfunc_hk_t)(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned int a4, int a5);;
pfunc_hk_t pHookFunc = (pfunc_hk_t)NULL;



template<bool debug>
bool invoke_driver(fptr_data::kernel_com *com, fptr_data::kernel_opr op)
{
	if (!pHookFunc) return false;

	com->error = fptr_data::kernel_err::unset_err;
	if (!pHookFunc((uintptr_t)com, 0, fptr_data::static_identifier, (int32_t)op, 2) &&
		com->error == fptr_data::kernel_err::unset_err)
	{
		printf(XORS("Driver not loaded.\n"));
		return false;
	}

	if (com->success) return true && com->error == fptr_data::kernel_err::no_error;
	if (!debug) return false;

	switch (com->error)
	{
		case fptr_data::kernel_err::check_fail:
		{
			printf(XORS("Security check failure.\n"));
			break;
		}
		case fptr_data::kernel_err::invalid_data:
		{
			printf(XORS("Invalid data.\n"));
			break;
		}
		case fptr_data::kernel_err::invalid_process:
		{
			printf(XORS("Invalid process.\n"));
			break;
		}
		case fptr_data::kernel_err::no_operation:
		{
			printf(XORS("Invalid funciton operation sent to driver.\n"));
			break;
		}
	}
	return false;
}



HMODULE ensure_dll_load()
{
#define LOAD_DLL(str) LoadLibrary(XORS(str))
	
	LOAD_DLL("user32.dll");

#undef LOAD_DLL
	return LoadLibrary(XORS("win32u.dll"));
}


bool kernel::driver::init()
{
	if (!pHookFunc)
	{
		HMODULE hDll = GetModuleHandle(XORS("win32u.dll"));
		if (!hDll)
		{
			hDll = ensure_dll_load();
			if (!hDll) return false;
		}

		pHookFunc = (pfunc_hk_t)GetProcAddress(hDll, XORS("NtGdiPolyPolyDraw"));
		if (!pHookFunc)
		{
			pHookFunc = (pfunc_hk_t)NULL;
			return false;
		}
	}

	if (get_process_base(GetCurrentProcessId()) != (uintptr_t)GetModuleHandle(NULL))
		return false;
	return true;
}



void kernel::driver::unload()
{
	fptr_data::kernel_com com{};
	invoke_driver<true>(&com, fptr_data::kernel_opr::unhook_driver);
}

uintptr_t kernel::driver::get_process_module(const char *name)
{
	fptr_data::kernel_com com{};
	com.target_pid = this->pid;
	com.name = name;

	if (!invoke_driver<true>(&com, fptr_data::kernel_opr::get_process_module))
		return 0;
	return com.buffer;
}

uintptr_t kernel::driver::get_process_base(uint32_t _pid)
{
	fptr_data::kernel_com com{};
	com.target_pid = _pid ? _pid : this->pid;

	if (invoke_driver<true>(&com, fptr_data::kernel_opr::get_process_base))
		return com.buffer;
	return 0;
}


bool kernel::driver::read_buffer(uintptr_t addr, uint8_t *buffer, size_t size, size_t *transfer)
{
	fptr_data::kernel_com com{};
	com.target_pid = this->pid;
	com.user_pid = GetCurrentProcessId();

	com.address = addr;
	com.buffer = (uintptr_t)buffer;
	com.size = size;

	if (!invoke_driver<true>(&com, fptr_data::kernel_opr::read))
		return false;

	if (transfer)
		*transfer = com.transfer;
	return true;
}

bool kernel::driver::write_buffer(uintptr_t addr, uint8_t *buffer, size_t size, size_t *transfer)
{
	fptr_data::kernel_com com{};
	com.target_pid = this->pid;
	com.user_pid = GetCurrentProcessId();

	com.address = addr;
	com.buffer = (uintptr_t)buffer;
	com.size = size;

	if (!invoke_driver<true>(&com, fptr_data::kernel_opr::write))
		return false;

	if (transfer)
		*transfer = com.transfer;
	return true;
}







uintptr_t kernel::driver::alloc(uintptr_t addr, size_t size, uint32_t alloc_flags, uint32_t protection)
{
	fptr_data::kernel_com com{};
	com.target_pid = this->pid;

	com.address = addr;
	com.size = size;
	com.buffer = alloc_flags;
	com.user_pid = protection;

	invoke_driver<true>(&com, fptr_data::kernel_opr::alloc);

	return com.address;
}

void kernel::driver::free(uintptr_t addr)
{
	fptr_data::kernel_com com{};
	com.target_pid = this->pid;

	com.address = addr;

	invoke_driver<true>(&com, fptr_data::kernel_opr::free);
}

void kernel::driver::protect(uintptr_t addr, size_t size, uint32_t protection)
{
	fptr_data::kernel_com com{};
	com.target_pid = this->pid;

	com.address = addr;
	com.buffer = protection;
	com.size = size;

	invoke_driver<true>(&com, fptr_data::kernel_opr::protect);
}
```

`WKUSER/kernel/driver.h`:

```h
#pragma once
#include <driver/defs.h>



namespace kernel
{
	class driver
	{
	public:
		driver();
		~driver();

	public:
		uint32_t pid;

		void attach(uint32_t pid) { this->pid = pid; }
		bool init();


		void unload();

		uintptr_t get_process_module(const char *name);
		uintptr_t get_process_base(uint32_t _pid = 0);

		bool read_buffer(uintptr_t addr, uint8_t *buffer, size_t size, size_t *transfer = nullptr);
		bool write_buffer(uintptr_t addr, uint8_t *buffer, size_t size, size_t *transfer = nullptr);

		template<typename Value_T>
		Value_T read(uintptr_t addr)
		{
			Value_T val;
			if (!this->read_buffer(addr, (uint8_t *)&val, sizeof(Value_T)))
				memset((void *)&val, 0, sizeof(val));
			return val;
		}

		template<typename Value_T>
		void write(uintptr_t addr, Value_T val) { this->write_buffer(addr, (uint8_t *)&val, sizeof(Value_T)); }



		uintptr_t alloc(uintptr_t addr, size_t size, uint32_t alloc_flags, uint32_t protection);
		void free(uintptr_t addr);
		void protect(uintptr_t addr, size_t size, uint32_t protection);
	};
}
```

`WKUSER/main.cpp`:

```cpp
#include <Windows.h>
#include <kernel/driver.h>
#include <iostream>
#include <string>



int main()
{
	SetConsoleTitle("Usermode Driver Test");
	printf("Welcome to Usermode.\n");


	kernel::driver driver;
	//if (!driver.init())
	//{
	//	printf("Initialization or communication test failed.\nPlease make sure driver is loaded.\n");
	//	Sleep(1500);
	//	return 1;
	//}
	driver.init();

	printf("operation: ");
	std::string str = "";
	std::getline(std::cin, str);
	if (str == "unhook")
	{
		driver.unload();
		return 0;
	}

	driver.attach( GetCurrentProcessId( ) );

	std::cout << driver.get_process_module( "UnityPlayer.dll" ) << std::endl;
	

	printf("Testing read/write:\n");
	printf("PID: ");


	std::string pid_str = "";
	std::getline(std::cin, pid_str);
	driver.attach(stoi(pid_str));

	std::cout << driver.get_process_module( "UnityPlayer.dll" ) << std::endl;
	std::cin.get( );

	printf("getting base...\n");
	uintptr_t base = driver.get_process_module(NULL);
	printf("base: %p\n", base);
	
	uintptr_t varInt = 0x7FF6134F60D0 - 0x00007FF6134F0000 + base;
	uintptr_t arrChar128 = 0x7FF6134F6050 - 0x00007FF6134F0000 + base;
	uintptr_t memoryPtr = 0x7FF6134F6788 - 0x00007FF6134F0000 + base;
	
	
	printf("Testing bad write...\n");
	driver.write<int>(0x69, 0xDEADBEEF);
	printf("Bad write passed.\n");

	printf("Writing to varInt: (%i) -> 654321\n", driver.read<int>(varInt));
	driver.write<int>(varInt, 654321);
	
	char arrChar[128];
	driver.read_buffer(arrChar128, (uint8_t *)arrChar, sizeof(arrChar));
	printf("Writing to arrChar[128]: \"%s\" -> HeLlO\n", arrChar);
	
	memcpy(arrChar, "HeLlO\0\0\0\0\0\0\0\0", sizeof("HeLlO\0\0\0\0\0\0\0\0"));
	driver.write_buffer(arrChar128, (uint8_t *)arrChar, sizeof(arrChar));

	printf("INTERP = DONKEY.\n");

	uintptr_t addr = driver.alloc(NULL, 1024, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	driver.write(memoryPtr, addr);
	MessageBox(NULL, "Press OK to free\n", "", MB_OK);
	driver.free(addr);

	MessageBox(NULL, "Press OK to stress test reading\n", "", MB_OK);
	printf("Stress testing...\n");
	while (true)
	{
		int thing = driver.read<int>(varInt);
		printf("%i\n", thing);
	}
	
	std::cin.get();
	return 0;
}
```

`WKUSER/xorstr.h`:

```h
#pragma once

/*____________________________________________________________________________________________________________

Original Author: skadro
Github: https://github.com/skadro-official
License: See end of file

skCrypter
		Compile-time, Usermode + Kernelmode, safe and lightweight string crypter library for C++11+

							*Not removing this part is appreciated*
____________________________________________________________________________________________________________*/

#ifdef _KERNEL_MODE
namespace std
{
	// STRUCT TEMPLATE remove_reference
	template <class _Ty>
	struct remove_reference {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&> {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&&> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

	// STRUCT TEMPLATE remove_const
	template <class _Ty>
	struct remove_const { // remove top-level const qualifier
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_const<const _Ty> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;
}
#else
#include <type_traits>
#endif

namespace xorcrypt
{
	template<class _Ty>
	using clean_type = typename std::remove_const_t<std::remove_reference_t<_Ty>>;

	template <int _size, char _key1, char _key2, typename T>
	class xorcrypt
	{
	public:
		__forceinline constexpr xorcrypt(T* data)
		{
			crypt(data);
		}

		__forceinline T* get()
		{
			return _storage;
		}

		__forceinline int size() // (w)char count
		{
			return _size;
		}

		__forceinline  char key()
		{
			return _key1;
		}

		__forceinline  T* encrypt()
		{
			if (!isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline  T* decrypt()
		{
			if (isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline bool isEncrypted()
		{
			return _storage[_size - 1] != 0;
		}

		__forceinline void clear() // set full storage to 0
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = 0;
			}
		}

		__forceinline operator T* ()
		{
			decrypt();

			return _storage;
		}

	private:
		__forceinline constexpr void crypt(T* data)
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = data[i] ^ (_key1 + i % (1 + _key2));
			}
		}

		T _storage[_size]{};
	};
}

#define XORS(str) XORS_KEY(str, __TIME__[4], __TIME__[7])
#define XORS_KEY(str, key1, key2) []() { \
			constexpr static auto crypted = xorcrypt::xorcrypt \
				<sizeof(str) / sizeof(str[0]), key1, key2, xorcrypt::clean_type<decltype(str[0])>>((xorcrypt::clean_type<decltype(str[0])>*)str); \
					return crypted; }()
```