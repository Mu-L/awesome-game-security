Project Path: arc_gmh5225_Comm-NekoSwap_pr4a1h_p

Source Tree:

```txt
arc_gmh5225_Comm-NekoSwap_pr4a1h_p
├── NekoSwap
│   ├── NekoSwap
│   │   ├── NekoSwap.vcxproj
│   │   ├── NekoSwap.vcxproj.filters
│   │   ├── VMProtectDDK64.lib
│   │   ├── defines.h
│   │   ├── global.h
│   │   ├── main.cpp
│   │   ├── utils.cpp
│   │   ├── utils.h
│   │   ├── vmp.h
│   │   └── xor.h
│   └── NekoSwap.sln
└── NekoTest
    ├── NekoTest
    │   ├── NekoTest.vcxproj
    │   ├── NekoTest.vcxproj.filters
    │   ├── driver.h
    │   └── main.cpp
    └── NekoTest.sln

```

`NekoSwap/NekoSwap.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32602.215
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NekoSwap", "NekoSwap\NekoSwap.vcxproj", "{A3414578-709D-47B2-87E9-86149C8184BC}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A3414578-709D-47B2-87E9-86149C8184BC}.Release|x64.ActiveCfg = Release|x64
		{A3414578-709D-47B2-87E9-86149C8184BC}.Release|x64.Build.0 = Release|x64
		{A3414578-709D-47B2-87E9-86149C8184BC}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {88716EEC-C5FB-4EB9-972B-5B4EC34E80FA}
	EndGlobalSection
EndGlobal

```

`NekoSwap/NekoSwap/NekoSwap.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{A3414578-709D-47B2-87E9-86149C8184BC}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>NekoSwap</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
      <DisableSpecificWarnings>4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
    </ClCompile>
    <Link>
      <AdditionalDependencies>VMProtectDDK64.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <EntryPointSymbol>EntryPoint</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defines.h" />
    <ClInclude Include="global.h" />
    <ClInclude Include="utils.h" />
    <ClInclude Include="vmp.h" />
    <ClInclude Include="xor.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`NekoSwap/NekoSwap/NekoSwap.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="utils.cpp">
      <Filter>Source</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="xor.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="vmp.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="global.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="defines.h">
      <Filter>Source</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`NekoSwap/NekoSwap/defines.h`:

```h
#pragma once

namespace Defines
{
	// win32k!ext_ms_win_core_win32k_fulluser_l1
	enum FullUserFunctionList
	{
		NtUserAcquireIAMKey,
		NtUserAcquireInteractiveControlBackgroundAccess,
		NtUserAddClipboardFormatListener,
		NtUserAlterWindowStyle,
		NtUserAssociateInputContext,
		NtUserAttachThreadInput,
		NtUserAutoPromoteMouseInPointer,
		NtUserEnableMouseInPointerForWindow,
		NtUserAutoRotateScreen,
		NtUserBeginLayoutUpdate,
		NtUserBeginPaint,
		NtUserBitBltSysBmp,
		NtUserBlockInput,
		NtUserBroadcastThemeChangeEvent,
		NtUserBuildHimcList,
		NtUserBuildHwndList,
		NtUserBuildNameList,
		NtUserBuildPropList,
		NtUserCalcMenuBar,
		NtUserCalculatePopupWindowPosition,
		NtUserCallHwnd,
		NtUserCallHwndLock,
		NtUserCallHwndLockSafe,
		NtUserCallHwndOpt,
		NtUserCallHwndParam,
		NtUserCallHwndParamLock,
		NtUserCallHwndParamLockSafe,
		NtUserCallHwndSafe,
		NtUserCallMsgFilter,
		NtUserCallNextHookEx,
		NtUserCanBrokerForceForeground,
		NtUserChangeClipboardChain,
		NtUserChangeWindowMessageFilterEx,
		NtUserCheckAccessForIntegrityLevel,
		NtUserCheckMenuItem,
		NtUserCheckProcessForClipboardAccess,
		NtUserCheckWindowThreadDesktop,
		NtUserChildWindowFromPointEx,
		NtUserClearForeground,
		NtUserCloseClipboard,
		NtUserCompositionInputSinkLuidFromPoint,
		NtUserCompositionInputSinkViewInstanceIdFromPoint,
		NtUserConfirmResizeCommit,
		NtUserConsoleControl,
		NtUserConvertMemHandle,
		NtUserCopyAcceleratorTable,
		NtUserCountClipboardFormats,
		NtUserCreateAcceleratorTable,
		NtUserCreateCaret,
		NtUserCreateEmptyCursorObject,
		NtUserCreateInputContext,
		NtUserCreateLocalMemHandle,
		NtUserCreateWindowEx,
		NtUserCreateWindowGroup,
		NtUserCtxDisplayIOCtl,
		NtUserDdeInitialize,
		NtUserDeferWindowDpiChanges,
		NtUserDeferWindowPosAndBand,
		NtUserDefSetText,
		NtUserDeleteMenu,
		NtUserDeleteWindowGroup,
		NtUserDestroyAcceleratorTable,
		NtUserDestroyCursor,
		NtUserDestroyInputContext,
		NtUserDestroyMenu,
		NtUserDestroyWindow,
		NtUserDisableImmersiveOwner,
		NtUserDisableProcessWindowFiltering,
		NtUserDisableThreadIme,
		NtUserDiscardPointerFrameMessages,
		NtUserDispatchMessage,
		NtUserDoSoundConnect,
		NtUserDoSoundDisconnect,
		NtUserDragDetect,
		NtUserDragObject,
		NtUserDrawAnimatedRects,
		NtUserDrawCaption,
		NtUserDrawCaptionTemp,
		NtUserDrawIconEx,
		NtUserDrawMenuBarTemp,
		NtUserDwmGetRemoteSessionOcclusionEvent,
		NtUserDwmGetRemoteSessionOcclusionState,
		NtUserDwmValidateWindow,
		NtUserEmptyClipboard,
		NtUserEnableChildWindowDpiMessage,
		NtUserEnableIAMAccess,
		NtUserEnableMenuItem,
		NtUserEnableMouseInputForCursorSuppression,
		NtUserEnableNonClientDpiScaling,
		NtUserEnableScrollBar,
		NtUserEnableSoftwareCursorForScreenCapture,
		NtUserEnableWindowGDIScaledDpiMessage,
		NtUserEnableWindowGroupPolicy,
		NtUserEnableWindowResizeOptimization,
		NtUserEndDeferWindowPosEx,
		NtUserEndMenu,
		NtUserEndPaint,
		NtUserEvent,
		NtUserExcludeUpdateRgn,
		NtUserFillWindow,
		NtUserFindExistingCursorIcon,
		NtUserFindWindowEx,
		NtUserFlashWindowEx,
		NtUserForceWindowToDpiForTest,
		NtUserFrostCrashedWindow,
		NtUserGetActiveProcessesDpis,
		NtUserGetAltTabInfo,
		NtUserGetAncestor,
		NtUserGetAppImeLevel,
		NtUserGetAtomName,
		NtUserGetAutoRotationState,
		NtUserGetCaretBlinkTime,
		NtUserGetCaretPos,
		NtUserGetCIMSSM,
		NtUserGetClassInfoEx,
		NtUserGetClassName,
		NtUserGetClipboardAccessToken,
		NtUserGetClipboardData,
		NtUserGetClipboardFormatName,
		NtUserGetClipboardOwner,
		NtUserGetClipboardSequenceNumber,
		NtUserGetClipboardViewer,
		NtUserGetComboBoxInfo,
		NtUserGetControlBrush,
		NtUserGetControlColor,
		NtUserGetCPD,
		NtUserGetCurrentDpiInfoForWindow,
		NtUserGetCurrentInputMessageSource,
		NtUserGetCursor,
		NtUserGetCursorFrameInfo,
		NtUserGetCursorInfo,
		NtUserGetDCEx,
		NtUserGetDesktopID,
		NtUserGetDisplayAutoRotationPreferences,
		NtUserGetDisplayAutoRotationPreferencesByProcessId,
		NtUserGetDManipHookInitFunction,
		NtUserGetDpiForCurrentProcess,
		NtUserGetForegroundWindow,
		NtUserGetGestureConfig,
		NtUserGetGestureExtArgs,
		NtUserGetGestureInfo,
		NtUserGetGuiResources,
		NtUserGetGUIThreadInfo,
		NtUserGetHimetricScaleFactorFromPixelLocation,
		NtUserGetIconInfo,
		NtUserGetIconSize,
		NtUserGetImeHotKey,
		NtUserGetImeInfoEx,
		NtUserGetInputLocaleInfo,
		NtUserGetInteractiveControlDeviceInfo,
		NtUserGetInteractiveControlInfo,
		NtUserGetInteractiveCtrlSupportedWaveforms,
		NtUserGetInternalWindowPos,
		NtUserGetKeyboardLayoutName,
		NtUserGetKeyNameText,
		NtUserGetLayeredWindowAttributes,
		NtUserGetListBoxInfo,
		NtUserGetMenuBarInfo,
		NtUserGetMenuIndex,
		NtUserGetMenuItemRect,
		NtUserGetMessage,
		NtUserGetMouseMovePointsEx,
		NtUserGetOemBitmapSize,
		NtUserGetOpenClipboardWindow,
		NtUserGetOwnerTransformedMonitorRect,
		NtUserGetPhysicalDeviceRect,
		NtUserGetPointerDeviceCursors,
		NtUserGetPriorityClipboardFormat,
		NtUserGetProcessUIContextInformation,
		NtUserGetProp,
		NtUserGetQueueStatusReadonly,
		NtUserGetRawInputBuffer,
		NtUserGetRawInputData,
		NtUserGetRawInputDeviceInfo,
		NtUserGetRawInputDeviceList,
		NtUserGetRegisteredRawInputDevices,
		NtUserGetRequiredCursorSizes,
		NtUserGetScrollBarInfo,
		NtUserGetSystemMenu,
		NtUserGetTitleBarInfo,
		NtUserGetTopLevelWindow,
		NtUserGetTouchInputInfo,
		NtUserGetTouchValidationStatus,
		NtUserGetUpdatedClipboardFormats,
		NtUserGetUpdateRect,
		NtUserGetUpdateRgn,
		NtUserGetWindowBand,
		NtUserGetWindowCompositionAttribute,
		NtUserGetWindowCompositionInfo,
		NtUserGetWindowDC,
		NtUserGetWindowDisplayAffinity,
		NtUserGetWindowFeedbackSetting,
		NtUserGetWindowGroupId,
		NtUserGetWindowMinimizeRect,
		NtUserGetWindowPlacement,
		NtUserGetWindowProcessHandle,
		NtUserGetWindowRgnEx,
		NtUserGetWOWClass,
		NtUserGhostWindowFromHungWindow,
		NtUserHardErrorControl,
		NtUserHideCaret,
		NtUserHidePointerContactVisualization,
		NtUserHiliteMenuItem,
		NtUserHungWindowFromGhostWindow,
		NtUserHwndQueryRedirectionInfo,
		NtUserHwndSetRedirectionInfo,
		NtUserImpersonateDdeClientWindow,
		NtUserInheritWindowMonitor,
		NtUserInitializeClientPfnArrays,
		NtUserInitializeTouchInjection,
		NtUserInitTask,
		NtUserInjectGesture,
		NtUserInjectTouchInput,
		NtUserInteractiveControlQueryUsage,
		NtUserInternalGetWindowIcon,
		NtUserInternalGetWindowText,
		NtUserInvalidateRect,
		NtUserInvalidateRgn,
		NtUserIsChildWindowDpiMessageEnabled,
		NtUserIsClipboardFormatAvailable,
		NtUserIsMouseInputEnabled,
		NtUserIsNonClientDpiScalingEnabled,
		NtUserIsTopLevelWindow,
		NtUserIsTouchWindow,
		NtUserIsWindowBroadcastingDpiToChildren,
		NtUserIsWindowGDIScaledDpiMessageEnabled,
		NtUserKillTimer,
		NtUserLayoutCompleted,
		NtUserLinkDpiCursor,
		NtUserLockWindowStation,
		NtUserLockWindowUpdate,
		NtUserLockWorkStation,
		NtUserLogicalToPerMonitorDPIPhysicalPoint,
		NtUserLogicalToPhysicalDpiPointForWindow,
		NtUserLogicalToPhysicalPoint,
		NtUserMagControl,
		NtUserMagGetContextInformation,
		NtUserMagSetContextInformation,
		NtUserMenuItemFromPoint,
		NtUserMessageCall,
		NtUserMinMaximize,
		NtUserMNDragLeave,
		NtUserMNDragOver,
		NtUserModifyUserStartupInfoFlags,
		NtUserModifyWindowTouchCapability,
		NtUserMoveWindow,
		NtUserMsgWaitForMultipleObjectsEx,
		NtUserNavigateFocus,
		NtUserNotifyIMEStatus,
		NtUserNotifyProcessCreate,
		NtUserNotifyWinEvent,
		NtUserOpenClipboard,
		NtUserOpenDesktop,
		NtUserOpenThreadDesktop,
		NtUserOpenWindowStation,
		NtUserPaintDesktop,
		NtUserPaintMenuBar,
		NtUserPaintMonitor,
		NtUserPeekMessage,
		NtUserPerMonitorDPIPhysicalToLogicalPoint,
		NtUserPhysicalToLogicalDpiPointForWindow,
		NtUserPhysicalToLogicalPoint,
		NtUserPostMessage,
		NtUserPostThreadMessage,
		NtUserPrintWindow,
		NtUserProcessConnect,
		NtUserProcessInkFeedbackCommand,
		NtUserPromoteMouseInPointer,
		NtUserPromotePointer,
		NtUserQueryBSDRWindow,
		NtUserQueryInformationThread,
		NtUserQueryInputContext,
		NtUserQuerySendMessage,
		NtUserQueryWindow,
		NtUserRealChildWindowFromPoint,
		NtUserRealInternalGetMessage,
		NtUserRealWaitMessageEx,
		NtUserRedrawWindow,
		NtUserRegisterBSDRWindow,
		NtUserRegisterClassExWOW,
		NtUserRegisterDManipHook,
		NtUserRegisterEdgy,
		NtUserRegisterErrorReportingDialog,
		NtUserRegisterHotKey,
		NtUserRegisterPointerDeviceNotifications,
		NtUserRegisterRawInputDevices,
		NtUserRegisterServicesProcess,
		NtUserRegisterShellPTPListener,
		NtUserRegisterTasklist,
		NtUserRegisterTouchHitTestingWindow,
		NtUserRegisterUserApiHook,
		NtUserRegisterWindowMessage,
		NtUserRemoteConnect,
		NtUserRemoteRedrawRectangle,
		NtUserRemoteRedrawScreen,
		NtUserRemoteStopScreenUpdates,
		NtUserRemoveClipboardFormatListener,
		NtUserRemoveMenu,
		NtUserRemoveProp,
		NtUserRequestMoveSizeOperation,
		NtUserResolveDesktopForWOW,
		NtUserRestoreWindowDpiChanges,
		NtUserSBGetParms,
		NtUserScrollDC,
		NtUserScrollWindowEx,
		NtUserSelectPalette,
		NtUserSendEventMessage,
		NtUserSendInput,
		NtUserSendInteractiveControlHapticsReport,
		NtUserSetActivationFilter,
		NtUserSetActiveProcessForMonitor,
		NtUserSetActiveWindow,
		NtUserSetAppImeLevel,
		NtUserSetAutoRotation,
		NtUserSetBridgeWindowChild,
		NtUserSetBrokeredForeground,
		NtUserSetCalibrationData,
		NtUserSetCapture,
		NtUserSetChildWindowNoActivate,
		NtUserSetClassLong,
		NtUserSetClassWord,
		NtUserSetClipboardData,
		NtUserSetClipboardViewer,
		NtUserSetCoreWindow,
		NtUserSetCoreWindowPartner,
		NtUserSetCursor,
		NtUserSetCursorContents,
		NtUserSetCursorIconData,
		NtUserSetDesktopColorTransform,
		NtUserSetMagnificationDesktopMagnifierOffsetsDWMUpdated,
		NtUserSetFullscreenMagnifierOffsetsDWMUpdated,
		NtUserSetDialogControlDpiChangeBehavior,
		NtUserSetDisplayAutoRotationPreferences,
		NtUserSetDisplayMapping,
		NtUserSetFallbackForeground,
		NtUserSetFocus,
		NtUserSetForegroundWindowForApplication,
		NtUserSetGestureConfig,
		NtUserSetImeHotKey,
		NtUserSetImeInfoEx,
		NtUserSetImeOwnerWindow,
		NtUserSetInformationThread,
		NtUserSetInteractiveControlFocus,
		NtUserSetInteractiveCtrlRotationAngle,
		NtUserSetInternalWindowPos,
		NtUserSetKeyboardState,
		NtUserSetLayeredWindowAttributes,
		NtUserSetMenu,
		NtUserSetMenuContextHelpId,
		NtUserSetMenuDefaultItem,
		NtUserSetMenuFlagRtoL,
		NtUserSetMirrorRendering,
		NtUserSetObjectInformation,
		NtUserSetParent,
		NtUserSetProcessInteractionFlags,
		NtUserSetProcessRestrictionExemption,
		NtUserSetProcessUIAccessZorder,
		NtUserSetProp,
		NtUserSetScrollInfo,
		NtUserSetSensorPresence,
		NtUserSetShellWindowEx,
		NtUserSetSystemCursor,
		NtUserSetSystemMenu,
		NtUserSetSystemTimer,
		NtUserSetTargetForResourceBrokering,
		NtUserSetThreadDesktop,
		NtUserSetThreadInputBlocked,
		NtUserSetThreadLayoutHandles,
		NtUserSetThreadState,
		NtUserSetTimer,
		NtUserSetWindowArrangement,
		NtUserSetWindowBand,
		NtUserSetWindowCompositionAttribute,
		NtUserSetWindowCompositionTransition,
		NtUserSetWindowDisplayAffinity,
		NtUserSetWindowFeedbackSetting,
		NtUserSetWindowFNID,
		NtUserSetWindowGroup,
		NtUserSetWindowLong,
		NtUserSetWindowPlacement,
		NtUserSetWindowPos,
		NtUserSetWindowRgn,
		NtUserSetWindowRgnEx,
		NtUserSetWindowsHookAW,
		NtUserSetWindowsHookEx,
		NtUserSetWindowShowState,
		NtUserSetWindowStationUser,
		NtUserSetWindowWord,
		NtUserSetWinEventHook,
		NtUserShowCaret,
		NtUserShowCursor,
		NtUserShowScrollBar,
		NtUserShowSystemCursor,
		NtUserShowWindow,
		NtUserShowWindowAsync,
		NtUserShutdownBlockReasonCreate,
		NtUserShutdownBlockReasonQuery,
		NtUserShutdownReasonDestroy,
		NtUserSignalRedirectionStartComplete,
		NtUserSlicerControl,
		NtUserSoundSentry,
		NtUserSwitchDesktop,
		NtUserSystemParametersInfoForDpi,
		NtUserTestForInteractiveUser,
		NtUserThunkedMenuInfo,
		NtUserThunkedMenuItemInfo,
		NtUserTrackMouseEvent,
		NtUserTrackPopupMenuEx,
		NtUserTransformPoint,
		NtUserTransformRect,
		NtUserTranslateAccelerator,
		NtUserTranslateMessage,
		NtUserUnhookWindowsHookEx,
		NtUserUnhookWinEvent,
		NtUserUnlockWindowStation,
		NtUserUnregisterClass,
		NtUserUnregisterHotKey,
		NtUserUnregisterUserApiHook,
		NtUserUpdateDefaultDesktopThumbnail,
		NtUserUpdateInputContext,
		NtUserUpdateInstance,
		NtUserUpdateLayeredWindow,
		NtUserUpdateWindowInputSinkHints,
		NtUserUpdateWindowTrackingInfo,
		NtUserUserHandleGrantAccess,
		NtUserValidateRect,
		NtUserValidateTimerCallback,
		NtUserWaitAvailableMessageEx,
		NtUserWaitForInputIdle,
		NtUserWaitForMsgAndEvent,
		NtUserWaitForRedirectionStartComplete,
		NtUserWaitMessage,
		NtUserWindowFromDC,
		NtUserWindowFromPhysicalPoint,
		NtUserWindowFromPoint,
		NtUserWOWCleanup,
		NtUserYieldTask
	};

	enum InputFunctionList
	{
		NtCloseCompositionInputSink,
		NtCompositionInputThread,
		NtCompositionSetDropTarget,
		NtConfigureInputSpace,
		NtInputSpaceRegionFromPoint,
		NtCreateCompositionInputSink,
		NtCreateImplicitCompositionInputSink,
		NtDuplicateCompositionInputSink,
		NtEnableOneCoreTransformMode,
		NtIsOneCoreTransformMode,
		NtQueryCompositionInputIsImplicit,
		NtQueryCompositionInputQueueAndTransform,
		NtQueryCompositionInputSink,
		NtQueryCompositionInputSinkLuid,
		NtQueryCompositionInputSinkViewId,
		NtSetCursorInputSpace,
		NtSetPointerDeviceInputSpace,
		NtSetShellCursorState,
		NtUpdateInputSinkTransforms,
		NtUserCreatePalmRejectionDelayZone,
		NtUserDestroyPalmRejectionDelayZone,
		NtUserEnableTouchPad,
		NtUserGetAsyncKeyState,
		NtUserEnableMouseInPointer,
		NtUserIsMouseInPointerEnabled,
		NtUserGetInputContainerId,
		NtUserGetKeyboardLayout,
		NtUserGetKeyboardLayoutList,
		NtUserGetKeyboardState,
		NtUserGetKeyState,
		NtUserInitializeGenericHidInjection,
		NtUserInitializeInputDeviceInjection,
		NtUserInitializePointerDeviceInjection,
		NtUserInitializePointerDeviceInjectionEx,
		NtUserInjectDeviceInput,
		NtUserInjectGenericHidInput,
		NtUserInjectKeyboardInput,
		NtUserInjectMouseInput,
		NtUserInjectPointerInput,
		NtUserLoadKeyboardLayoutEx,
		NtUserLockCursor,
		NtUserRemoveInjectionDevice,
		NtUserSetFeatureReportResponse,
		NtUserSetManipulationInputTarget,
		NtUserSetPrecisionTouchPadConfiguration,
		NtUserUnloadKeyboardLayout,
		NtUserSetDesktopVisualInputSink
	};

	enum GdiFunctionList
	{
		NtGdiAbortDoc,
		NtGdiAbortPath,
		NtGdiAddEmbFontToDC,
		NtGdiAddFontMemResourceEx,
		NtGdiAddFontResourceW,
		NtGdiAddInitialFonts,
		NtGdiAddRemoteFontToDC,
		NtGdiAddRemoteMMInstanceToDC,
		NtGdiAlphaBlend,
		NtGdiAngleArc,
		NtGdiAnyLinkedFonts,
		NtGdiArcInternal,
		NtGdiBeginGdiRendering,
		NtGdiBeginPath,
		NtGdiBitBlt,
		NtGdiBRUSHOBJ_DeleteRbrush,
		NtGdiBRUSHOBJ_hGetColorTransform,
		NtGdiBRUSHOBJ_pvAllocRbrush,
		NtGdiBRUSHOBJ_pvGetRbrush,
		NtGdiBRUSHOBJ_ulGetBrushColor,
		NtGdiCancelDC,
		NtGdiChangeGhostFont,
		NtGdiCheckBitmapBits,
		NtGdiClearBitmapAttributes,
		NtGdiClearBrushAttributes,
		NtGdiCLIPOBJ_bEnum,
		NtGdiCLIPOBJ_cEnumStart,
		NtGdiCLIPOBJ_ppoGetPath,
		NtGdiCloseFigure,
		NtGdiColorCorrectPalette,
		NtGdiCombineTransform,
		NtGdiComputeXformCoefficients,
		NtGdiConvertMetafileRect,
		NtGdiCreateBitmap,
		NtGdiCreateBitmapFromDxSurface,
		NtGdiCreateBitmapFromDxSurface2,
		NtGdiCreateClientObj,
		NtGdiCreateColorSpace,
		NtGdiCreateColorTransform,
		NtGdiCreateCompatibleBitmap,
		NtGdiCreateCompatibleDC,
		NtGdiCreateDIBBrush,
		NtGdiCreateDIBitmapInternal,
		NtGdiCreateDIBSection,
		NtGdiCreateEllipticRgn,
		NtGdiCreateHalftonePalette,
		NtGdiCreateHatchBrushInternal,
		NtGdiCreateMetafileDC,
		NtGdiCreatePaletteInternal,
		NtGdiCreatePatternBrushInternal,
		NtGdiCreatePen,
		NtGdiCreateRoundRectRgn,
		NtGdiCreateServerMetaFile,
		NtGdiCreateSessionMappedDIBSection,
		NtGdiCreateSolidBrush,
		NtGdiDdCreateFullscreenSprite,
		NtGdiDdDestroyFullscreenSprite,
		NtGdiDdNotifyFullscreenSpriteUpdate,
		NtGdiDdQueryVisRgnUniqueness,
		NtGdiDeleteClientObj,
		NtGdiDeleteColorSpace,
		NtGdiDeleteColorTransform,
		NtGdiDescribePixelFormat,
		NtGdiDoBanding,
		NtGdiDoPalette,
		NtGdiDrawEscape,
		NtGdiDrawStream,
		NtGdiEllipse,
		NtGdiEnableEudc,
		NtGdiEndDoc,
		NtGdiEndGdiRendering,
		NtGdiEndPage,
		NtGdiEndPath,
		NtGdiEngAlphaBlend,
		NtGdiEngAssociateSurface,
		NtGdiEngBitBlt,
		NtGdiEngCheckAbort,
		NtGdiEngComputeGlyphSet,
		NtGdiEngCopyBits,
		NtGdiEngCreateBitmap,
		NtGdiEngCreateClip,
		NtGdiEngCreateDeviceBitmap,
		NtGdiEngCreateDeviceSurface,
		NtGdiEngCreatePalette,
		NtGdiEngDeleteClip,
		NtGdiEngDeletePalette,
		NtGdiEngDeletePath,
		NtGdiEngDeleteSurface,
		NtGdiEngEraseSurface,
		NtGdiEngFillPath,
		NtGdiEngGradientFill,
		NtGdiEngLineTo,
		NtGdiEngLockSurface,
		NtGdiEngMarkBandingSurface,
		NtGdiEngPaint,
		NtGdiEngPlgBlt,
		NtGdiEngStretchBlt,
		NtGdiEngStretchBltROP,
		NtGdiEngStrokeAndFillPath,
		NtGdiEngStrokePath,
		NtGdiEngTextOut,
		NtGdiEngTransparentBlt,
		NtGdiEngUnlockSurface,
		NtGdiEnsureDpiDepDefaultGuiFontForPlateau,
		NtGdiEnumFonts,
		NtGdiEnumObjects,
		NtGdiEudcLoadUnloadLink,
		NtGdiExcludeClipRect,
		NtGdiExtCreatePen,
		NtGdiExtEscape,
		NtGdiExtFloodFill,
		NtGdiExtGetObjectW,
		NtGdiExtSelectClipRgn,
		NtGdiExtTextOutW,
		NtGdiFillPath,
		NtGdiFillRgn,
		NtGdiFlattenPath,
		NtGdiFontIsLinked,
		NtGdiFONTOBJ_cGetAllGlyphHandles,
		NtGdiFONTOBJ_cGetGlyphs,
		NtGdiFONTOBJ_pfdg,
		NtGdiFONTOBJ_pifi,
		NtGdiFONTOBJ_pQueryGlyphAttrs,
		NtGdiFONTOBJ_pvTrueTypeFontFile,
		NtGdiFONTOBJ_pxoGetXform,
		NtGdiFONTOBJ_vGetInfo,
		NtGdiForceUFIMapping,
		NtGdiFrameRgn,
		NtGdiFullscreenControl,
		NtGdiGetAndSetDCDword,
		NtGdiGetAppClipBox,
		NtGdiGetBitmapBits,
		NtGdiGetBitmapDimension,
		NtGdiGetBitmapDpiScaleValue,
		NtGdiGetBoundsRect,
		NtGdiGetCharABCWidthsW,
		NtGdiGetCharacterPlacementW,
		NtGdiGetCharSet,
		NtGdiGetCharWidthInfo,
		NtGdiGetCharWidthW,
		NtGdiGetColorAdjustment,
		NtGdiGetColorSpaceforBitmap,
		NtGdiGetDCDpiScaleValue,
		NtGdiGetDCDword,
		NtGdiGetDCforBitmap,
		NtGdiGetDCObject,
		NtGdiGetDCPoint,
		NtGdiGetDeviceGammaRamp,
		NtGdiGetDeviceWidth,
		NtGdiGetDhpdev,
		NtGdiGetDIBitsInternal,
		NtGdiGetEmbedFonts,
		NtGdiGetEmbUFI,
		NtGdiGetETM,
		NtGdiGetEudcTimeStampEx,
		NtGdiGetFontData,
		NtGdiGetFontFileData,
		NtGdiGetFontFileInfo,
		NtGdiGetFontResourceInfoInternalW,
		NtGdiGetFontUnicodeRanges,
		NtGdiGetGlyphIndicesW,
		NtGdiGetGlyphIndicesWInternal,
		NtGdiGetGlyphOutline,
		NtGdiGetKerningPairs,
		NtGdiGetLinkedUFIs,
		NtGdiGetMiterLimit,
		NtGdiGetMonitorID,
		NtGdiGetNearestColor,
		NtGdiGetNearestPaletteIndex,
		NtGdiGetNumberOfPhysicalMonitors,
		NtGdiGetObjectBitmapHandle,
		NtGdiGetOutlineTextMetricsInternalW,
		NtGdiGetPath,
		NtGdiGetPerBandInfo,
		NtGdiGetPhysicalMonitorDescription,
		NtGdiGetPhysicalMonitors,
		NtGdiGetPixel,
		NtGdiGetProcessSessionFonts,
		NtGdiGetPublicFontTableChangeCookie,
		NtGdiGetRandomRgn,
		NtGdiGetRasterizerCaps,
		NtGdiGetRealizationInfo,
		NtGdiGetServerMetaFileBits,
		NtGdiGetSpoolMessage,
		NtGdiGetStats,
		NtGdiGetStringBitmapW,
		NtGdiGetSystemPaletteUse,
		NtGdiGetTextCharsetInfo,
		NtGdiGetTextExtent,
		NtGdiGetTextExtentExW,
		NtGdiGetTextFaceW,
		NtGdiGetTextMetricsW,
		NtGdiGetTransform,
		NtGdiGetUFI,
		NtGdiGetUFIPathname,
		NtGdiGetWidthTable,
		NtGdiGradientFill,
		NtGdiHfontCreate,
		NtGdiHLSurfGetInformation,
		NtGdiHLSurfSetInformation,
		NtGdiHT_Get8BPPFormatPalette,
		NtGdiHT_Get8BPPMaskPalette,
		NtGdiIcmBrushInfo,
		NtGdiInitSpool,
		NtGdiIntersectClipRect,
		NtGdiInvertRgn,
		NtGdiLineTo,
		NtGdiMakeFontDir,
		NtGdiMakeInfoDC,
		NtGdiMakeObjectUnXferable,
		NtGdiMakeObjectXferable,
		NtGdiMaskBlt,
		NtGdiMirrorWindowOrg,
		NtGdiModifyWorldTransform,
		NtGdiMonoBitmap,
		NtGdiMoveTo,
		NtGdiOffsetClipRgn,
		NtGdiPatBlt,
		NtGdiPATHOBJ_bEnum,
		NtGdiPATHOBJ_bEnumClipLines,
		NtGdiPATHOBJ_vEnumStart,
		NtGdiPATHOBJ_vEnumStartClipLines,
		NtGdiPATHOBJ_vGetBounds,
		NtGdiPathToRegion,
		NtGdiPlgBlt,
		NtGdiPolyDraw,
		NtGdiPolyPatBlt,
		NtGdiPolyTextOutW,
		NtGdiPtInRegion,
		NtGdiPtVisible,
		NtGdiQueryFontAssocInfo,
		NtGdiQueryFonts,
		NtGdiRectangle,
		NtGdiRectVisible,
		NtGdiRemoveFontMemResourceEx,
		NtGdiRemoveFontResourceW,
		NtGdiRemoveMergeFont,
		NtGdiResetDC,
		NtGdiResizePalette,
		NtGdiRestoreDC,
		NtGdiRoundRect,
		NtGdiSaveDC,
		NtGdiScaleRgn,
		NtGdiScaleValues,
		NtGdiScaleViewportExtEx,
		NtGdiScaleWindowExtEx,
		NtGdiSelectBitmap,
		NtGdiSelectBrush,
		NtGdiSelectClipPath,
		NtGdiSelectFont,
		NtGdiSelectPen,
		NtGdiSetBitmapAttributes,
		NtGdiSetBitmapBits,
		NtGdiSetBitmapDimension,
		NtGdiSetBoundsRect,
		NtGdiSetBrushAttributes,
		NtGdiSetBrushOrg,
		NtGdiSetColorAdjustment,
		NtGdiSetColorSpace,
		NtGdiSetDeviceGammaRamp,
		NtGdiSetDIBitsToDeviceInternal,
		NtGdiSetFontEnumeration,
		NtGdiSetFontXform,
		NtGdiSetIcmMode,
		NtGdiSetLayout,
		NtGdiSetLinkedUFIs,
		NtGdiSetMagicColors,
		NtGdiSetMetaRgn,
		NtGdiSetMiterLimit,
		NtGdiSetPixel,
		NtGdiSetPixelFormat,
		NtGdiSetPUMPDOBJ,
		NtGdiSetSizeDevice,
		NtGdiSetSystemPaletteUse,
		NtGdiSetTextJustification,
		NtGdiSetUMPDSandboxState,
		NtGdiSetVirtualResolution,
		NtGdiStartDoc,
		NtGdiStartPage,
		NtGdiStretchBlt,
		NtGdiStretchDIBitsInternal,
		NtGdiSTROBJ_bEnum,
		NtGdiSTROBJ_bEnumPositionsOnly,
		NtGdiSTROBJ_bGetAdvanceWidths,
		NtGdiSTROBJ_dwGetCodePage,
		NtGdiSTROBJ_vEnumStart,
		NtGdiStrokeAndFillPath,
		NtGdiStrokePath,
		NtGdiSwapBuffers,
		NtGdiTransformPoints,
		NtGdiTransparentBlt,
		NtGdiUMPDEngFreeUserMem,
		NtGdiUnloadPrinterDriver,
		NtGdiUnmapMemFont,
		NtGdiUnrealizeObject,
		NtGdiUpdateColors,
		NtGdiUpdateTransform,
		NtGdiWidenPath,
		NtGdiXFORMOBJ_bApplyXform,
		NtGdiXFORMOBJ_iGetXform,
		NtGdiXLATEOBJ_cGetPalette,
		NtGdiXLATEOBJ_hGetColorTransform,
		NtGdiXLATEOBJ_iXlate,
		NtGdiDwmCreatedBitmapRemotingOutput
	};

	enum TableList
	{
		ext_ms_win_core_win32k_base_export_l1,
		ext_ms_win_core_win32k_base_export_l1_host,
		ext_ms_win_core_win32k_baseinit_l1,
		ext_ms_win_core_win32k_baseinit_l1_host,
		ext_ms_win_core_win32k_common_export_l1,
		ext_ms_win_core_win32k_common_export_l1_host,
		ext_ms_win_core_win32k_common_input_l1,
		ext_ms_win_core_win32k_common_input_l1_host,
		ext_ms_win_core_win32k_common_inputrim_l1,
		ext_ms_win_core_win32k_common_inputrim_l1_host,
		ext_ms_win_core_win32k_common_user_l1,
		ext_ms_win_core_win32k_common_user_l1_host,
		ext_ms_win_core_win32k_dcomp_l1,
		ext_ms_win_core_win32k_dcomp_l1_host,
		ext_ms_win_core_win32k_ddccigdi_l1,
		ext_ms_win_core_win32k_ddccigdi_l1_host,
		ext_ms_win_core_win32k_dxgdi_l1,
		ext_ms_win_core_win32k_dxgdi_l1_host,
		ext_ms_win_core_win32k_full_export_l1,
		ext_ms_win_core_win32k_full_export_l1_host,
		ext_ms_win_core_win32k_full_float_export_l1,
		ext_ms_win_core_win32k_full_float_export_l1_host,
		ext_ms_win_core_win32k_fulldcompbase_l1,
		ext_ms_win_core_win32k_fulldcompbase_l1_host,
		ext_ms_win_core_win32k_fulldwm_l1,
		ext_ms_win_core_win32k_fulldwm_l1_host,
		ext_ms_win_core_win32k_fullgdi_l1,
		ext_ms_win_core_win32k_fullgdi_l1_host,
		ext_ms_win_core_win32k_fulluser_l1,
		ext_ms_win_core_win32k_fulluser_l1_host,
		ext_ms_win_core_win32k_fulluser64_l1,
		ext_ms_win_core_win32k_fulluser64_l1_host,
		ext_ms_win_core_win32k_fulluserbase_l1,
		ext_ms_win_core_win32k_fulluserbase_l1_host,
		ext_ms_win_core_win32k_gdi_l1,
		ext_ms_win_core_win32k_gdi_l1_host,
		ext_ms_win_core_win32k_input_l1,
		ext_ms_win_core_win32k_input_l1_host,
		ext_ms_win_core_win32k_inputmit_l1,
		ext_ms_win_core_win32k_inputmit_l1_host,
		ext_ms_win_core_win32k_inputrim_l1,
		ext_ms_win_core_win32k_inputrim_l1_host,
		ext_ms_win_core_win32k_mindwm_l1,
		ext_ms_win_core_win32k_mindwm_l1_host,
		ext_ms_win_core_win32k_mininput_l1,
		ext_ms_win_core_win32k_mininput_l1_host,
		ext_ms_win_core_win32k_mininputmit_l1,
		ext_ms_win_core_win32k_mininputmit_l1_host,
		ext_ms_win_core_win32k_mininputmitbase_l1,
		ext_ms_win_core_win32k_mininputmitbase_l1_host,
		ext_ms_win_core_win32k_minuser_l1,
		ext_ms_win_core_win32k_minuser_l1_host,
		ext_ms_win_core_win32k_opmgdi_l1,
		ext_ms_win_core_win32k_opmgdi_l1_host,
		ext_ms_win_core_win32k_user_l1,
		ext_ms_win_core_win32k_user_l1_host,
		ext_ms_win_core_win32k_userdisplay_l1,
		ext_ms_win_core_win32k_userdisplay_l1_host
	};
}
```

`NekoSwap/NekoSwap/global.h`:

```h
#pragma once

#include <ntifs.h>
#include <minwindef.h>
#include <ntimage.h>
#include <ntstrsafe.h>

#include "xor.h"
#include "vmp.h"
#include "utils.h"
#include "defines.h"
```

`NekoSwap/NekoSwap/main.cpp`:

```cpp
#include "global.h"

/*
 * WARNING
 * Windows implementation of syscalls is not passing the entire stack
 * to the kernel. Only the given amount of argument. Always verify that
 * the original function has enough arguments or you will be getting
 * garbage (5+ arg is passed on stack).
 */

DWORD64* GetFunctionFromTable(DWORD64 tableEntry, int tableIndex, int functionIndex)
{
	PROTECT_ULTRA();
	DWORD64 functionTable = *reinterpret_cast<DWORD64*>(tableEntry + (tableIndex * sizeof(DWORD64)));
	DWORD64* functionPointer = reinterpret_cast<DWORD64*>(functionTable + (functionIndex * sizeof(DWORD64)));
	PROTECT_END();
	return functionPointer;
}

NTSTATUS TestCallback(PVOID arg1, PVOID arg2, PVOID arg3, PVOID arg4, PVOID arg5, PVOID arg6, PVOID arg7)
{
	//__debugbreak();
	DbgPrintEx(0, 0, "arg1: 0x%p arg2: 0x%p arg3: 0x%p arg4: 0x%p arg5: 0x%p arg6: 0x%p arg7: 0x%p\n", arg1, arg2, arg3, arg4, arg5, arg6, arg7);
	return STATUS_SUCCESS;
}

NTSTATUS EntryPoint()
{
	PROTECT_ULTRA();
	PVOID moduleBase = Utils::GetModuleBase(E("win32k.sys"));
	if (!moduleBase)
		return STATUS_NOT_FOUND;

	// cmp     cs:off_FFFFF97FFF05B078, 0
	// jz      short loc_FFFFF97FFF001418
	// xor     esi, esi
	// lea     r14, Win32kApiSetTable
	// xor     edi, edi
	DWORD64 tableScan = Utils::FindPatternImage(moduleBase, E("48 83 3D ? ? ? ? ? 74 41 33 F6 4C 8D 35 ? ? ? ? 33 FF"));
	if (!tableScan)
		return STATUS_INVALID_PARAMETER;

	DWORD64 table = tableScan + 19 + *reinterpret_cast<int*>(tableScan + 15);

	DWORD64* functionNtUserSetGestureConfig = GetFunctionFromTable(table, Defines::ext_ms_win_core_win32k_fulluser_l1, Defines::NtUserSetGestureConfig);
	*functionNtUserSetGestureConfig = reinterpret_cast<DWORD64>(&PsLookupProcessByProcessId);

	DWORD64* functionNtUserSetSensorPresence = GetFunctionFromTable(table, Defines::ext_ms_win_core_win32k_fulluser_l1, Defines::NtUserSetSensorPresence);
	*functionNtUserSetSensorPresence = reinterpret_cast<DWORD64>(&ExAllocatePool);

	DWORD64* functionNtUserSetSystemCursor = GetFunctionFromTable(table, Defines::ext_ms_win_core_win32k_fulluser_l1, Defines::NtUserSetSystemCursor);
	*functionNtUserSetSystemCursor = reinterpret_cast<DWORD64>(&PsGetCurrentThread);

	//DWORD64* functionNtUserGetGestureConfig = GetFunctionFromTable(table, Defines::ext_ms_win_core_win32k_fulluser_l1, Defines::NtUserGetGestureConfig);
	//*functionNtUserGetGestureConfig = reinterpret_cast<DWORD64>(&RtlCopyMemory);

	// __int64 __fastcall NtGdiGetEmbUFI(HDC a1, _QWORD *a2, char *a3, _BYTE *a4, __int64 a5, __int64 a6, __int64 a7)
	DWORD64* functionNtGdiGetEmbUFI = GetFunctionFromTable(table, Defines::ext_ms_win_core_win32k_fullgdi_l1, Defines::NtGdiGetEmbUFI);
	*functionNtGdiGetEmbUFI = reinterpret_cast<DWORD64>(&Utils::MmCopyVirtualMemory);
	//*functionNtGdiGetEmbUFI = reinterpret_cast<DWORD64>(&TestCallback);

	// TODO: disable APCs
	// TODO: registry check
	PROTECT_END();
	return STATUS_SUCCESS;
}
```

`NekoSwap/NekoSwap/utils.cpp`:

```cpp
#include "global.h"

char* Utils::Compare(const char* haystack, const char* needle)
{
    PROTECT_MUTATE();
    do
    {
        const char* h = haystack;
        const char* n = needle;
        while (tolower(static_cast<unsigned char>(*h)) == tolower(static_cast<unsigned char>(*n)) && *n)
        {
            h++;
            n++;
        }

        if (*n == 0)
            return const_cast<char*>(haystack);
    } while (*haystack++);
    PROTECT_END();
    return nullptr;
}

PVOID Utils::GetModuleBase(const char* moduleName)
{
    PROTECT_ULTRA();
    PVOID address = nullptr;
    ULONG size = 0;

    NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, &size, 0, &size);
    if (status != STATUS_INFO_LENGTH_MISMATCH)
        return nullptr;

    PSYSTEM_MODULE_INFORMATION moduleList = static_cast<PSYSTEM_MODULE_INFORMATION>(ExAllocatePool(NonPagedPool, size));
    if (!moduleList)
        return nullptr;

    status = ZwQuerySystemInformation(SystemModuleInformation, moduleList, size, nullptr);
    if (!NT_SUCCESS(status))
        goto end;

    for (ULONG_PTR i = 0; i < moduleList->ulModuleCount; i++)
    {
        DWORD64 pointer = (DWORD64)&moduleList->Modules[i];
        pointer += sizeof(SYSTEM_MODULE);
        if (pointer > ((DWORD64)moduleList + size))
            break;

        SYSTEM_MODULE module = moduleList->Modules[i];
        module.ImageName[255] = '\0';
        if (Compare(module.ImageName, moduleName))
        {
            address = module.Base;
            break;
        }
    }

end:
    ExFreePool(moduleList);
    PROTECT_END();
    return address;
}

#define IN_RANGE(x, a, b) (x >= a && x <= b)
#define GET_BITS(x) (IN_RANGE((x&(~0x20)),'A','F')?((x&(~0x20))-'A'+0xA):(IN_RANGE(x,'0','9')?x-'0':0))
#define GET_BYTE(a, b) (GET_BITS(a) << 4 | GET_BITS(b))
DWORD64 Utils::FindPattern(void* baseAddress, DWORD64 size, const char* pattern)
{
    PROTECT_MUTATE();
    BYTE* firstMatch = nullptr;
    const char* currentPattern = pattern;

    BYTE* start = static_cast<BYTE*>(baseAddress);
    BYTE* end = start + size;

    for (BYTE* current = start; current < end; current++)
    {
        BYTE byte = currentPattern[0]; if (!byte) return reinterpret_cast<DWORD64>(firstMatch);
        if (byte == '\?' || *static_cast<BYTE*>(current) == GET_BYTE(byte, currentPattern[1]))
        {
            if (!firstMatch) firstMatch = current;
            if (!currentPattern[2]) return reinterpret_cast<DWORD64>(firstMatch);
            ((byte == '\?') ? (currentPattern += 2) : (currentPattern += 3));
        }
        else
        {
            currentPattern = pattern;
            firstMatch = nullptr;
        }
    }

    PROTECT_END();
    return 0;
}

DWORD64 Utils::FindPatternImage(void* base, const char* pattern, bool page)
{
    PROTECT_MUTATE();
    DWORD64 match = 0;

    PIMAGE_NT_HEADERS64 headers = reinterpret_cast<PIMAGE_NT_HEADERS64>(reinterpret_cast<DWORD64>(base) + static_cast<PIMAGE_DOS_HEADER>(base)->e_lfanew);
    PIMAGE_SECTION_HEADER sections = IMAGE_FIRST_SECTION(headers);
    for (USHORT i = 0; i < headers->FileHeader.NumberOfSections; ++i)
    {
        PIMAGE_SECTION_HEADER section = &sections[i];
        if (memcmp(section->Name, E(".text"), 5) == 0)
        {
            match = FindPattern(reinterpret_cast<void*>(reinterpret_cast<DWORD64>(base) + section->VirtualAddress), section->Misc.VirtualSize, pattern);
            if (match)
                break;
        }

        if (page)
        {
            if (*reinterpret_cast<DWORD32*>(section->Name) == 'EGAP')
            {
                match = FindPattern(reinterpret_cast<void*>(reinterpret_cast<DWORD64>(base) + section->VirtualAddress), section->Misc.VirtualSize, pattern);
                if (match)
                    break;
            }
        }
    }

    PROTECT_END();
    return match;
}

PVOID Utils::AlignedAlloc(size_t size, size_t alignment)
{
    // https://sites.google.com/site/ruslancray/lab/bookshelf/interview/ci/low-level/write-an-aligned-malloc-free-function
    void* p1;
    void** p2;
    size_t offset = alignment - 1 + sizeof(void*);
    if ((p1 = ExAllocatePool(NonPagedPool, size + offset)) == nullptr)
        return nullptr;
    p2 = reinterpret_cast<void**>((reinterpret_cast<size_t>(p1) + offset) & ~(alignment - 1));
    p2[-1] = p1;
    return p2;
}

void Utils::AlignedFree(PVOID pointer)
{
    ExFreePool((static_cast<void**>(pointer))[-1]);
}
```

`NekoSwap/NekoSwap/utils.h`:

```h
#pragma once

namespace Utils
{
    typedef enum _SYSTEM_INFORMATION_CLASS
    {
        SystemInformationClassMin = 0,
        SystemBasicInformation = 0,
        SystemProcessorInformation = 1,
        SystemPerformanceInformation = 2,
        SystemTimeOfDayInformation = 3,
        SystemPathInformation = 4,
        SystemNotImplemented1 = 4,
        SystemProcessInformation = 5,
        SystemProcessesAndThreadsInformation = 5,
        SystemCallCountInfoInformation = 6,
        SystemCallCounts = 6,
        SystemDeviceInformation = 7,
        SystemConfigurationInformation = 7,
        SystemProcessorPerformanceInformation = 8,
        SystemProcessorTimes = 8,
        SystemFlagsInformation = 9,
        SystemGlobalFlag = 9,
        SystemCallTimeInformation = 10,
        SystemNotImplemented2 = 10,
        SystemModuleInformation = 11,
        SystemLocksInformation = 12,
        SystemLockInformation = 12,
        SystemStackTraceInformation = 13,
        SystemNotImplemented3 = 13,
        SystemPagedPoolInformation = 14,
        SystemNotImplemented4 = 14,
        SystemNonPagedPoolInformation = 15,
        SystemNotImplemented5 = 15,
        SystemHandleInformation = 16,
        SystemObjectInformation = 17,
        SystemPageFileInformation = 18,
        SystemPagefileInformation = 18,
        SystemVdmInstemulInformation = 19,
        SystemInstructionEmulationCounts = 19,
        SystemVdmBopInformation = 20,
        SystemInvalidInfoClass1 = 20,
        SystemFileCacheInformation = 21,
        SystemCacheInformation = 21,
        SystemPoolTagInformation = 22,
        SystemInterruptInformation = 23,
        SystemProcessorStatistics = 23,
        SystemDpcBehaviourInformation = 24,
        SystemDpcInformation = 24,
        SystemFullMemoryInformation = 25,
        SystemNotImplemented6 = 25,
        SystemLoadImage = 26,
        SystemUnloadImage = 27,
        SystemTimeAdjustmentInformation = 28,
        SystemTimeAdjustment = 28,
        SystemSummaryMemoryInformation = 29,
        SystemNotImplemented7 = 29,
        SystemNextEventIdInformation = 30,
        SystemNotImplemented8 = 30,
        SystemEventIdsInformation = 31,
        SystemNotImplemented9 = 31,
        SystemCrashDumpInformation = 32,
        SystemExceptionInformation = 33,
        SystemCrashDumpStateInformation = 34,
        SystemKernelDebuggerInformation = 35,
        SystemContextSwitchInformation = 36,
        SystemRegistryQuotaInformation = 37,
        SystemLoadAndCallImage = 38,
        SystemPrioritySeparation = 39,
        SystemPlugPlayBusInformation = 40,
        SystemNotImplemented10 = 40,
        SystemDockInformation = 41,
        SystemNotImplemented11 = 41,
        SystemInvalidInfoClass2 = 42,
        SystemProcessorSpeedInformation = 43,
        SystemInvalidInfoClass3 = 43,
        SystemCurrentTimeZoneInformation = 44,
        SystemTimeZoneInformation = 44,
        SystemLookasideInformation = 45,
        SystemSetTimeSlipEvent = 46,
        SystemCreateSession = 47,
        SystemDeleteSession = 48,
        SystemInvalidInfoClass4 = 49,
        SystemRangeStartInformation = 50,
        SystemVerifierInformation = 51,
        SystemAddVerifier = 52,
        SystemSessionProcessesInformation = 53,
        SystemInformationClassMax
    } SYSTEM_INFORMATION_CLASS;

    typedef struct _SYSTEM_MODULE
    {
        ULONG_PTR Reserved[2];
        PVOID Base;
        ULONG Size;
        ULONG Flags;
        USHORT Index;
        USHORT Unknown;
        USHORT LoadCount;
        USHORT ModuleNameOffset;
        CHAR ImageName[256];
    } SYSTEM_MODULE, * PSYSTEM_MODULE;

    typedef struct _SYSTEM_MODULE_INFORMATION
    {
        ULONG_PTR ulModuleCount;
        SYSTEM_MODULE Modules[1];
    } SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

    extern "C"
    {
        NTSTATUS ZwQuerySystemInformation(SYSTEM_INFORMATION_CLASS systemInformationClass, PVOID systemInformation, ULONG systemInformationLength, PULONG returnLength);
        NTSTATUS ObReferenceObjectByName(PUNICODE_STRING objectName, ULONG attributes, PACCESS_STATE accessState, ACCESS_MASK desiredAccess, POBJECT_TYPE objectType, KPROCESSOR_MODE accessMode, PVOID parseContext, PVOID* object);
        NTSTATUS ObCreateObject(KPROCESSOR_MODE ProbeMode, POBJECT_TYPE ObjectType, POBJECT_ATTRIBUTES ObjectAttributes, KPROCESSOR_MODE OwnershipMode, PVOID ParseContext, ULONG ObjectBodySize, ULONG PagedPoolCharge, ULONG NonPagedPoolCharge, PVOID* Object);
        NTSTATUS MmCopyVirtualMemory(PEPROCESS sourceProcess, PVOID sourceAddress, PEPROCESS targetProcess, PVOID targetAddress, SIZE_T bufferSize, KPROCESSOR_MODE previousMode, PSIZE_T returnSize);
    }

    extern "C" POBJECT_TYPE * IoDriverObjectType;
    extern "C" POBJECT_TYPE * IoDeviceObjectType;

    char* Compare(const char* haystack, const char* needle);
    PVOID GetModuleBase(const char* moduleName);
    DWORD64 FindPattern(VOID* baseAddress, DWORD64 size, const char* pattern);
    DWORD64 FindPatternImage(void* base, const char* pattern, bool page = false);
    PVOID AlignedAlloc(size_t size, size_t alignment);
    void AlignedFree(PVOID pointer);
}
```

`NekoSwap/NekoSwap/vmp.h`:

```h
#pragma once

#define VMP_IMPORT __declspec(dllimport)
#define VMP_API __stdcall
#define VMP_WCHAR wchar_t
#ifdef _WIN64
#pragma comment(lib, "VMProtectDDK64.lib")
#else
#pragma comment(lib, "VMProtectDDK32.lib")
#endif // _WIN64

#ifdef __cplusplus
extern "C" {
#endif

    // protection
    VMP_IMPORT void VMP_API VMProtectBegin(const char*);
    VMP_IMPORT void VMP_API VMProtectBeginVirtualization(const char*);
    VMP_IMPORT void VMP_API VMProtectBeginMutation(const char*);
    VMP_IMPORT void VMP_API VMProtectBeginUltra(const char*);
    VMP_IMPORT void VMP_API VMProtectBeginVirtualizationLockByKey(const char*);
    VMP_IMPORT void VMP_API VMProtectBeginUltraLockByKey(const char*);
    VMP_IMPORT void VMP_API VMProtectEnd(void);

    // utils
    VMP_IMPORT BOOLEAN VMP_API VMProtectIsProtected();
    VMP_IMPORT BOOLEAN VMP_API VMProtectIsDebuggerPresent(BOOLEAN); // IRQL = PASSIVE_LEVEL
    VMP_IMPORT BOOLEAN VMP_API VMProtectIsVirtualMachinePresent(void); // IRQL = PASSIVE_LEVEL
    VMP_IMPORT BOOLEAN VMP_API VMProtectIsValidImageCRC(void);
    VMP_IMPORT const char* VMP_API VMProtectDecryptStringA(const char* value);
    VMP_IMPORT const VMP_WCHAR* VMP_API VMProtectDecryptStringW(const VMP_WCHAR* value);
    VMP_IMPORT BOOLEAN VMP_API VMProtectFreeString(const void* value);

    // licensing
    enum VMProtectSerialStateFlags
    {
        SERIAL_STATE_SUCCESS = 0,
        SERIAL_STATE_FLAG_CORRUPTED = 0x00000001,
        SERIAL_STATE_FLAG_INVALID = 0x00000002,
        SERIAL_STATE_FLAG_BLACKLISTED = 0x00000004,
        SERIAL_STATE_FLAG_DATE_EXPIRED = 0x00000008,
        SERIAL_STATE_FLAG_RUNNING_TIME_OVER = 0x00000010,
        SERIAL_STATE_FLAG_BAD_HWID = 0x00000020,
        SERIAL_STATE_FLAG_MAX_BUILD_EXPIRED = 0x00000040,
    };

#pragma pack(push, 1)
    typedef struct
    {
        unsigned short	wYear;
        unsigned char	bMonth;
        unsigned char	bDay;
    } VMProtectDate;

    typedef struct
    {
        int				nState;				// VMProtectSerialStateFlags
        VMP_WCHAR		wUserName[256];		// user name
        VMP_WCHAR		wEMail[256];		// email
        VMProtectDate	dtExpire;			// date of serial number expiration
        VMProtectDate	dtMaxBuild;			// max date of build, that will accept this key
        int				bRunningTime;		// running time in minutes
        unsigned char	nUserDataLength;	// length of user data in bUserData
        unsigned char	bUserData[255];		// up to 255 bytes of user data
    } VMProtectSerialNumberData;
#pragma pack(pop)

    VMP_IMPORT int VMP_API VMProtectSetSerialNumber(const char* serial);
    VMP_IMPORT int VMP_API VMProtectGetSerialNumberState();
    VMP_IMPORT BOOLEAN VMP_API VMProtectGetSerialNumberData(VMProtectSerialNumberData* data, int size);
    VMP_IMPORT int VMP_API VMProtectGetCurrentHWID(char* hwid, int size);

    // activation
    enum VMProtectActivationFlags
    {
        ACTIVATION_OK = 0,
        ACTIVATION_SMALL_BUFFER,
        ACTIVATION_NO_CONNECTION,
        ACTIVATION_BAD_REPLY,
        ACTIVATION_BANNED,
        ACTIVATION_CORRUPTED,
        ACTIVATION_BAD_CODE,
        ACTIVATION_ALREADY_USED,
        ACTIVATION_SERIAL_UNKNOWN,
        ACTIVATION_EXPIRED,
        ACTIVATION_NOT_AVAILABLE
    };

    VMP_IMPORT int VMP_API VMProtectActivateLicense(const char* code, char* serial, int size);
    VMP_IMPORT int VMP_API VMProtectDeactivateLicense(const char* serial);
    VMP_IMPORT int VMP_API VMProtectGetOfflineActivationString(const char* code, char* buf, int size);
    VMP_IMPORT int VMP_API VMProtectGetOfflineDeactivationString(const char* serial, char* buf, int size);

#ifdef __cplusplus
}
#endif


#define PROTECT_ULTRA() VMProtectBeginUltra(nullptr)
#define PROTECT_MUTATE() VMProtectBeginMutation(nullptr)
#define PROTECT_END() VMProtectEnd()

//#define PROTECT_ULTRA() /**/
//#define PROTECT_MUTATE() /**/
//#define PROTECT_END() /**/
```

`NekoSwap/NekoSwap/xor.h`:

```h
#pragma once

// =============================================================================
namespace crypt
{
    // =============================================================================

    // convert __TIME__ == "hh:mm:ss" to a sum of seconds this gives us a compile-time seed
    // Note: in some weird cases I've seen the seed being different from encryption
    // to decryption so it's safer to not use time and set the seed manually
#if 1
#define TBX_XSTR_SEED ((__TIME__[7] - '0') * 1ull    + (__TIME__[6] - '0') * 10ull  + \
                       (__TIME__[4] - '0') * 60ull   + (__TIME__[3] - '0') * 600ull + \
                       (__TIME__[1] - '0') * 3600ull + (__TIME__[0] - '0') * 36000ull)
#else
#define TBX_XSTR_SEED (3600ull)
#endif

// -----------------------------------------------------------------------------

// @return a pseudo random number clamped at 0xFFFFFFFF
    constexpr unsigned long long linear_congruent_generator(unsigned rounds)
    {
        return 1013904223ull + (1664525ull * ((rounds > 0) ? linear_congruent_generator(rounds - 1) : (TBX_XSTR_SEED))) % 0xFFFFFFFF;
    }

    // -----------------------------------------------------------------------------

#define Random() linear_congruent_generator(10)
#define XSTR_RANDOM_NUMBER(Min, Max) (Min + (Random() % (Max - Min + 1)))

// -----------------------------------------------------------------------------

    constexpr const unsigned long long XORKEY = XSTR_RANDOM_NUMBER(0, 0xFF);

    // -----------------------------------------------------------------------------

    template<typename Char >
    constexpr Char encrypt_character(const Char character, int index)
    {
        return character ^ (Char)(static_cast<Char>(XORKEY) + index);
    }

    // -----------------------------------------------------------------------------

    template <unsigned size, typename Char>
    class Xor_string {
    public:
        const unsigned _nb_chars = (size - 1);
        Char _string[size];

        // if every goes alright this constructor should be executed at compile time
        inline constexpr Xor_string(const Char* string)
            : _string{}
        {
            for (unsigned i = 0u; i < size; ++i)
                _string[i] = encrypt_character<Char>(string[i], i);
        }

        // This is executed at runtime.
        // HACK: although decrypt() is const we modify '_string' in place
        const Char* decrypt() const
        {
            Char* string = const_cast<Char*>(_string);
            for (unsigned t = 0; t < _nb_chars; t++)
            {
                string[t] = string[t] ^ (Char)(static_cast<Char>(XORKEY) + t);
            }
            string[_nb_chars] = '\0';
            return string;
        }
    };
}// END crypt NAMESPACE ========================================================

#define XorS(name, my_string)    constexpr crypt::Xor_string<(sizeof(my_string)/sizeof(char)), char> name(my_string)
// Because of a limitation/bug in msvc 2017 we need to declare crypt::Xor_string() as a constexpr
// otherwise the constructor is not evaluated at compile time. The lambda function is here to allow this declaration inside the macro
// because there is no such thing as casting to 'constexpr' (and casting to const does not solve this bug).
#define XorString(my_string) []{ constexpr crypt::Xor_string<(sizeof(my_string)/sizeof(char)), char> expr(my_string); return expr; }().decrypt()

#define E( string ) XorString( string )

#define XorWS(name, my_string)       constexpr crypt::Xor_string<(sizeof(my_string)/sizeof(wchar_t)), wchar_t> name(my_string)
#define XorWideString(my_string) []{ constexpr crypt::Xor_string<(sizeof(my_string)/sizeof(wchar_t)), wchar_t> expr(my_string); return expr; }().decrypt()

#define EW( string ) XorWideString( string )
```

`NekoTest/NekoTest.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32602.215
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NekoTest", "NekoTest\NekoTest.vcxproj", "{9BB6FD9B-1F93-474F-95AB-BD9FDC7D6D0A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9BB6FD9B-1F93-474F-95AB-BD9FDC7D6D0A}.Release|x64.ActiveCfg = Release|x64
		{9BB6FD9B-1F93-474F-95AB-BD9FDC7D6D0A}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {CF1CD64B-0351-4C69-8D85-7428B8B46FE9}
	EndGlobalSection
EndGlobal

```

`NekoTest/NekoTest/NekoTest.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{9bb6fd9b-1f93-474f-95ab-bd9fdc7d6d0a}</ProjectGuid>
    <RootNamespace>NekoTest</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <Optimization>MaxSpeed</Optimization>
      <TreatWarningAsError>true</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`NekoTest/NekoTest/NekoTest.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver.h">
      <Filter>Source</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`NekoTest/NekoTest/driver.h`:

```h
#ifndef NEKO_CONTROL_H
#define NEKO_CONTROL_H

/*
 * WARNING
 * Disable Control Flow Guard and Security Check
 */

#include <Windows.h>
#include <winternl.h>
#include <thread>

#pragma warning(disable : 4312)
#pragma warning(disable : 4244)
#pragma warning(disable : 4311)
#pragma warning(disable : 4302)

typedef enum _MEMORY_INFORMATION_CLASS
{
	MemoryBasicInformation, // MEMORY_BASIC_INFORMATION
	MemoryWorkingSetInformation, // MEMORY_WORKING_SET_INFORMATION
	MemoryMappedFilenameInformation, // UNICODE_STRING
	MemoryRegionInformation, // MEMORY_REGION_INFORMATION
	MemoryWorkingSetExInformation, // MEMORY_WORKING_SET_EX_INFORMATION
	MemorySharedCommitInformation, // MEMORY_SHARED_COMMIT_INFORMATION
	MemoryImageInformation, // MEMORY_IMAGE_INFORMATION
	MemoryRegionInformationEx,
	MemoryPrivilegedBasicInformation,
	MemoryEnclaveImageInformation, // MEMORY_ENCLAVE_IMAGE_INFORMATION // since REDSTONE3
	MemoryBasicInformationCapped
} MEMORY_INFORMATION_CLASS;

extern "C" NTSTATUS NTAPI NtQueryVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);

#define MAX_VIRTUAL_USERMODE 0x7FFFFFFFFFFF
#define MIN_VIRTUAL_USERMODE 0x10000

class NekoControl
{
private:
	HANDLE targetProcessPid;
	PVOID currentProcess;
	PVOID targetProcess;
	PVOID kernelMemory;

	typedef PVOID(__stdcall* ExAllocatePool_t)(DWORD64 PoolType, SIZE_T NumberOfBytes);
	volatile ExAllocatePool_t ExAllocatePool = nullptr;
	typedef PVOID(__stdcall* RtlCopyMemory_t)(void* destination, void* source, size_t length);
	volatile RtlCopyMemory_t KernelRtlCopyMemory = nullptr;
	typedef PVOID(__stdcall* PsGetCurrentThread_t)();
	volatile PsGetCurrentThread_t PsGetCurrentThread = nullptr;
	typedef DWORD64(__stdcall* PsLookupProcessByProcessId_t)(HANDLE processId, void** process);
	volatile PsLookupProcessByProcessId_t PsLookupProcessByProcessId = nullptr;
	typedef DWORD64(__stdcall* MmCopyVirtualMemory_t)(PVOID sourceProcess, PVOID sourceAddress, PVOID targetProcess, PVOID targetAddress, SIZE_T bufferSize, CCHAR previousMode, PVOID returnSize);
	volatile MmCopyVirtualMemory_t MmCopyVirtualMemory = nullptr;

	bool CheckAddress(PVOID address)
	{
		if (reinterpret_cast<DWORD64>(address) > MAX_VIRTUAL_USERMODE)
			return false;

		if (reinterpret_cast<DWORD64>(address) < MIN_VIRTUAL_USERMODE)
			return false;

		return true;
	}
public:
	void Init()
	{
		// if not loaded, the syscalls will literally shit itself
		HMODULE userModule = LoadLibraryA("user32.dll");
		if (!userModule)
			return;
		printf("user32.dll: 0x%p\n", userModule);

		HMODULE targetModule = LoadLibraryA("win32u.dll");
		if (!targetModule)
			return;
		printf("win32u.dll: 0x%p\n", targetModule);

		PsLookupProcessByProcessId = reinterpret_cast<PsLookupProcessByProcessId_t>(GetProcAddress(targetModule, "NtUserSetGestureConfig"));
		KernelRtlCopyMemory = reinterpret_cast<RtlCopyMemory_t>(GetProcAddress(targetModule, "NtUserGetGestureConfig"));
		ExAllocatePool = reinterpret_cast<ExAllocatePool_t>(GetProcAddress(targetModule, "NtUserSetSensorPresence"));
		PsGetCurrentThread = reinterpret_cast<PsGetCurrentThread_t>(GetProcAddress(targetModule, "NtUserSetSystemCursor"));
		MmCopyVirtualMemory = reinterpret_cast<MmCopyVirtualMemory_t>(GetProcAddress(targetModule, "NtGdiGetEmbUFI"));

		if (!PsLookupProcessByProcessId
			|| !MmCopyVirtualMemory
			|| !ExAllocatePool
			|| !KernelRtlCopyMemory
			|| !PsGetCurrentThread)
		{
			printf("Failed to resolve functions!\n");
			getchar();
			return;
		}

		printf("NtUserSetGestureConfig: 0x%p\n", PsLookupProcessByProcessId);
		printf("NtGdiGetEmbUFI: 0x%p\n", MmCopyVirtualMemory);

		DWORD64 status = PsLookupProcessByProcessId(reinterpret_cast<HANDLE>(GetCurrentProcessId()), &currentProcess);
		if (status != 0)
		{
			printf("Failed to get current process EPROCESS (0x%p)!\n", reinterpret_cast<PVOID>(status));
			getchar();
			return;
		}

		printf("Client EPROCESS: 0x%p\n", currentProcess);

		kernelMemory = ExAllocatePool(0, 128);
		if (!kernelMemory)
		{
			printf("Failed to allocate non paged memory!\n");
			getchar();
			return;
		}

		printf("Non paged memory: 0x%p\n", kernelMemory);
	}

	void SetTarget(HANDLE pid)
	{
		targetProcessPid = pid;

		DWORD64 status = PsLookupProcessByProcessId(targetProcessPid, &targetProcess);
		if (status != 0)
		{
			printf("Failed to get target process EPROCESS (0x%p)!\n", reinterpret_cast<PVOID>(status));
			getchar();
			return;
		}

		printf("Target EPROCESS: 0x%p\n", targetProcess);
	}

	bool Check()
	{
		return reinterpret_cast<DWORD64>(currentProcess) > 0x7FFFFFFFFFFF;
	}

	bool ReadMemory(PVOID source, PVOID destination, SIZE_T size)
	{
		if (!CheckAddress(source))
			return false;

		if (!CheckAddress(destination))
			return false;

		//printf("ReadMemory:\n\ttargetProcess: 0x%p\n\tsource: 0x%p\n\tcurrentProcess: 0x%p\n\tdestination: 0x%p\n\tsize: %llu\n", targetProcess, source, currentProcess, destination, size);
		DWORD64 status = MmCopyVirtualMemory(targetProcess, source, currentProcess, destination, size, 0 /* KernelMode */, kernelMemory);
		return status == 0;
	}

	bool WriteMemory(PVOID source, PVOID destination, SIZE_T size)
	{
		if (!CheckAddress(source))
			return false;

		if (!CheckAddress(destination))
			return false;

		//printf("WriteMemory:\n\ttargetProcess: 0x%p\n\tsource: 0x%p\n\tcurrentProcess: 0x%p\n\tdestination: 0x%p\n\tsize: %llu\n", targetProcess, source, currentProcess, destination, size);
		DWORD64 status = MmCopyVirtualMemory(currentProcess, source, targetProcess, destination, size, 0, kernelMemory);
		return status == 0;
	}

	PVOID GetModule(const wchar_t* moduleName)
	{
		HANDLE targetProcessHandle = OpenProcess(PROCESS_QUERY_INFORMATION, 0, *reinterpret_cast<DWORD*>(&targetProcessPid));
		if (!targetProcessHandle || targetProcessHandle == INVALID_HANDLE_VALUE)
			return nullptr;

		DWORD64 currentAddress = 0;
		MEMORY_BASIC_INFORMATION memoryInformation;
		while (VirtualQueryEx(targetProcessHandle, reinterpret_cast<PVOID>(currentAddress), &memoryInformation, sizeof(MEMORY_BASIC_INFORMATION64)))
		{
			if (memoryInformation.Type == MEM_MAPPED || memoryInformation.Type == MEM_IMAGE)
			{
				constexpr SIZE_T bufferSize = 1024;
				PVOID buffer = malloc(bufferSize);

				SIZE_T bytesOut;
				NTSTATUS status = NtQueryVirtualMemory(targetProcessHandle, memoryInformation.BaseAddress, MemoryMappedFilenameInformation, buffer, bufferSize, &bytesOut);
				if (status == 0)
				{
					UNICODE_STRING* stringBuffer = static_cast<UNICODE_STRING*>(buffer);
					if (wcsstr(stringBuffer->Buffer, moduleName) && !wcsstr(stringBuffer->Buffer, L".mui"))
					{
						free(buffer);
						CloseHandle(targetProcessHandle);
						return memoryInformation.BaseAddress;
					}
				}

				free(buffer);
			}

			currentAddress = reinterpret_cast<DWORD64>(memoryInformation.BaseAddress) + memoryInformation.RegionSize;
		}

		CloseHandle(targetProcessHandle);
		return nullptr;
	}

	template<typename T>
	T Read(DWORD64 address)
	{
		T val = T();
		ReadMemory((PVOID)address, &val, sizeof(T));
		return val;
	}

	template<typename T>
	void Write(DWORD64 address, T value)
	{
		WriteMemory(&value, (PVOID)address, sizeof(T));
	}
};

extern NekoControl* g_Drv;

#endif
```

`NekoTest/NekoTest/main.cpp`:

```cpp
#include <Windows.h>
#include <iostream>
#include <tlhelp32.h>
#include "driver.h"

NekoControl driver;

typedef struct _LargeBuffer
{
	unsigned char Buffer[56000];
} LargeBuffer;

void PrintHex(const unsigned char* buf, size_t buf_len)
{
	size_t i = 0;
	for (i = 0; i < buf_len; ++i)
		printf("%02X%s", buf[i],
			(i + 1) % 16 == 0 ? "\r\n" : " ");

	printf("\n");
}

int GetProcessID(const wchar_t* processName)
{
	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (snapshot)
	{
		PROCESSENTRY32 entry = { 0 };
		entry.dwSize = sizeof(entry);
		if (Process32First(snapshot, &entry))
		{
			do
			{
				if (0 == _wcsicmp(entry.szExeFile, processName))
				{
					CloseHandle(snapshot);
					return entry.th32ProcessID;
				}
			} while (Process32Next(snapshot, &entry));
		}

		CloseHandle(snapshot);
	}

	return 0;
}

static DWORD64 moduleBase = 0;
void ThreadBench(int id)
{
	while (true)
	{
		DWORD64 totalOk = 0;
		DWORD64 totalFail = 0;

		auto t1 = std::chrono::high_resolution_clock::now();
		for (int i = 0; i < 100000; i++)
		{
			int offset = rand() % 20 + 1; // this is slow btw
			offset += 0x48;
			volatile int readValue = driver.Read<int>(moduleBase + offset);
			volatile int readConfirm = driver.Read<int>(moduleBase + offset);
			if (readValue == readConfirm && readValue != 0)
				totalOk++;
			else
			{
				totalFail++;
				printf("Invalid read: %x %x\n", readValue, readConfirm);
			}
		}
		auto t2 = std::chrono::high_resolution_clock::now();
		auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(t2 - t1).count();
		printf("Ok: %llu Fail: %llu In: %llu\n", totalOk, totalFail, duration);
	}
}

int main()
{
	printf("Waiting on ProcessHacker.exe...\n");
	int targetProcessId = 0;
	while (targetProcessId == 0)
	{
		targetProcessId = GetProcessID(L"ProcessHacker.exe");
		Sleep(10);
	}

	printf("Init...\n");
	driver.Init();

	printf("Check...\n");
	bool status = driver.Check();
	if (!status)
	{
		printf("Failed check!\n");
		getchar();
		return -1;
	}
	printf("Communication check done\n");

	printf("Set target...\n");
	driver.SetTarget(reinterpret_cast<HANDLE>(targetProcessId));

	//printf("Disable APCs...\n");
	//driver.ModifyThread();

	printf("Get modules...\n");
	PVOID module1 = driver.GetModule(L"kernel32.dll");
	PVOID module2 = driver.GetModule(L"user32.dll");
	moduleBase = (DWORD64)module1;
	printf("kernel32.dll: 0x%p\n", module1);
	printf("user32.dll: 0x%p\n", module2);

	printf("Waiting...\n");
	Sleep(100);

	LargeBuffer* largeBuffer = static_cast<LargeBuffer*>(malloc(sizeof(LargeBuffer)));
	printf("Short read test...\n");
	memset(largeBuffer, 0, sizeof(LargeBuffer));
	driver.ReadMemory(module1, largeBuffer, 20);
	PrintHex(largeBuffer->Buffer, 20);

	printf("Press key to continue\n");
	getchar();
	Sleep(1000);

	printf("Multi-thread test...\n");
	for (int i = 0; i < 5; i++)
	{
		printf("Starting ID %i...\n", i);
		std::thread thread(ThreadBench, i);
		thread.detach();
	}

	while (true)
		Sleep(10000);
}
```