Project Path: arc_gmh5225_FridaScript_z2xc0k3i

Source Tree:

```txt
arc_gmh5225_FridaScript_z2xc0k3i
├── FridaScript
│   ├── Assets.xcassets
│   │   ├── AccentColor.colorset
│   │   │   └── Contents.json
│   │   ├── AppIcon.appiconset
│   │   │   └── Contents.json
│   │   └── Contents.json
│   ├── ContentView.swift
│   ├── FridaScript.swift
│   ├── Runtime
│   │   ├── ErrorThrow.h
│   │   ├── ErrorThrow.m
│   │   ├── HookFS
│   │   │   ├── HookFS.h
│   │   │   └── HookFS.m
│   │   ├── Include.h
│   │   ├── Include.m
│   │   ├── Modules
│   │   │   ├── IO
│   │   │   │   ├── Helper
│   │   │   │   │   ├── NSStringCpy.h
│   │   │   │   │   ├── NSStringCpy.m
│   │   │   │   │   ├── UniOrigHolder.h
│   │   │   │   │   └── UniOrigHolder.m
│   │   │   │   ├── IO.h
│   │   │   │   ├── IO.m
│   │   │   │   ├── IO.md
│   │   │   │   ├── Macro.h
│   │   │   │   └── Types
│   │   │   │       ├── DIR.h
│   │   │   │       ├── DIR.m
│   │   │   │       ├── Dirent.h
│   │   │   │       ├── Dirent.m
│   │   │   │       ├── FILE.h
│   │   │   │       ├── FILE.m
│   │   │   │       ├── Stat.h
│   │   │   │       └── Stat.m
│   │   │   ├── MacroHelper.h
│   │   │   ├── Math
│   │   │   │   ├── Math.h
│   │   │   │   └── Math.m
│   │   │   ├── Memory
│   │   │   │   ├── Memory.h
│   │   │   │   └── Memory.m
│   │   │   ├── Proc
│   │   │   │   ├── Proc.h
│   │   │   │   └── Proc.m
│   │   │   └── String
│   │   │       ├── String.h
│   │   │       └── String.m
│   │   ├── ReturnObjBuilder.h
│   │   ├── ReturnObjBuilder.m
│   │   ├── Runtime.h
│   │   ├── Runtime.m
│   │   └── Safety.m
│   ├── UI
│   │   ├── CLI.swift
│   │   ├── CodeEditor.swift
│   │   ├── FluidGradient
│   │   │   ├── BlobLayer.swift
│   │   │   ├── CGPoint+Extensions.swift
│   │   │   ├── FluidGradient.swift
│   │   │   ├── FluidGradientView.swift
│   │   │   └── ResizableLayer.swift
│   │   ├── NSRangeHelper.swift
│   │   ├── Popup
│   │   │   ├── BottomPopupView.swift
│   │   │   └── Items
│   │   │       ├── ButtonBar.swift
│   │   │       ├── Header.swift
│   │   │       ├── Picker.swift
│   │   │       └── TextField.swift
│   │   ├── TerminalView.swift
│   │   └── UIFileList.swift
│   └── bridge.h
├── FridaScript.xcodeproj
│   ├── project.pbxproj
│   ├── project.xcworkspace
│   │   ├── contents.xcworkspacedata
│   │   └── xcuserdata
│   │       └── fridakitten.xcuserdatad
│   │           └── UserInterfaceState.xcuserstate
│   └── xcuserdata
│       └── fridakitten.xcuserdatad
│           ├── xcdebugger
│           │   └── Breakpoints_v2.xcbkptlist
│           └── xcschemes
│               └── xcschememanagement.plist
├── LICENSE
└── README.md

```

`FridaScript.xcodeproj/project.pbxproj`:

```pbxproj
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 77;
	objects = {

/* Begin PBXFileReference section */
		AFBE41752D85E4B500315155 /* FridaScript.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = FridaScript.app; sourceTree = BUILT_PRODUCTS_DIR; };
/* End PBXFileReference section */

/* Begin PBXFileSystemSynchronizedRootGroup section */
		AFBE41772D85E4B500315155 /* FridaScript */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = FridaScript;
			sourceTree = "<group>";
		};
/* End PBXFileSystemSynchronizedRootGroup section */

/* Begin PBXFrameworksBuildPhase section */
		AFBE41722D85E4B500315155 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		AFBE416C2D85E4B500315155 = {
			isa = PBXGroup;
			children = (
				AFBE41772D85E4B500315155 /* FridaScript */,
				AFBE41762D85E4B500315155 /* Products */,
			);
			sourceTree = "<group>";
		};
		AFBE41762D85E4B500315155 /* Products */ = {
			isa = PBXGroup;
			children = (
				AFBE41752D85E4B500315155 /* FridaScript.app */,
			);
			name = Products;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		AFBE41742D85E4B500315155 /* FridaScript */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = AFBE41832D85E4B700315155 /* Build configuration list for PBXNativeTarget "FridaScript" */;
			buildPhases = (
				AFBE41712D85E4B500315155 /* Sources */,
				AFBE41722D85E4B500315155 /* Frameworks */,
				AFBE41732D85E4B500315155 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			fileSystemSynchronizedGroups = (
				AFBE41772D85E4B500315155 /* FridaScript */,
			);
			name = FridaScript;
			packageProductDependencies = (
			);
			productName = FJS;
			productReference = AFBE41752D85E4B500315155 /* FridaScript.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		AFBE416D2D85E4B500315155 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastSwiftUpdateCheck = 1620;
				LastUpgradeCheck = 1620;
				TargetAttributes = {
					AFBE41742D85E4B500315155 = {
						CreatedOnToolsVersion = 16.2;
						LastSwiftMigration = 1620;
					};
				};
			};
			buildConfigurationList = AFBE41702D85E4B500315155 /* Build configuration list for PBXProject "FridaScript" */;
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = AFBE416C2D85E4B500315155;
			minimizedProjectReferenceProxies = 1;
			preferredProjectObjectVersion = 77;
			productRefGroup = AFBE41762D85E4B500315155 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				AFBE41742D85E4B500315155 /* FridaScript */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		AFBE41732D85E4B500315155 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		AFBE41712D85E4B500315155 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin XCBuildConfiguration section */
		AFBE41812D85E4B700315155 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				HEADER_SEARCH_PATHS = FJS;
				IPHONEOS_DEPLOYMENT_TARGET = 15.6;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = "DEBUG $(inherited)";
				SWIFT_OBJC_BRIDGING_HEADER = "";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		AFBE41822D85E4B700315155 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				HEADER_SEARCH_PATHS = FJS;
				IPHONEOS_DEPLOYMENT_TARGET = 15.6;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SDKROOT = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OBJC_BRIDGING_HEADER = "";
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		AFBE41842D85E4B700315155 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = "";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "";
				DEVELOPMENT_TEAM = L4A6CKH3TV;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				HEADER_SEARCH_PATHS = FridaScript;
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				IPHONEOS_DEPLOYMENT_TARGET = 15.6;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.sinac.FridaScript;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_OBJC_BRIDGING_HEADER = FridaScript/bridge.h;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		AFBE41852D85E4B700315155 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = "";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "";
				DEVELOPMENT_TEAM = L4A6CKH3TV;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				HEADER_SEARCH_PATHS = FridaScript;
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				IPHONEOS_DEPLOYMENT_TARGET = 15.6;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.sinac.FridaScript;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_OBJC_BRIDGING_HEADER = FridaScript/bridge.h;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		AFBE41702D85E4B500315155 /* Build configuration list for PBXProject "FridaScript" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				AFBE41812D85E4B700315155 /* Debug */,
				AFBE41822D85E4B700315155 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		AFBE41832D85E4B700315155 /* Build configuration list for PBXNativeTarget "FridaScript" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				AFBE41842D85E4B700315155 /* Debug */,
				AFBE41852D85E4B700315155 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = AFBE416D2D85E4B500315155 /* Project object */;
}

```

`FridaScript.xcodeproj/project.xcworkspace/contents.xcworkspacedata`:

```xcworkspacedata
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>

```

`FridaScript.xcodeproj/xcuserdata/fridakitten.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist`:

```xcbkptlist
<?xml version="1.0" encoding="UTF-8"?>
<Bucket
   uuid = "2B39E835-6311-4C5E-ABD6-29BD5FD218A1"
   type = "1"
   version = "2.0">
   <Breakpoints>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "C13688E4-8566-4059-8A97-504FBDA1152D"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FJS/UI/CLI.swift"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "66"
            endingLineNumber = "66"
            landmarkName = "makeUIView(context:)"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "0E69E5EF-77B5-4DAA-BC93-26A1C6247AF0"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FJS/UI/CLI.swift"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "68"
            endingLineNumber = "68"
            landmarkName = "makeUIView(context:)"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "6E151098-FE76-46E4-AEA0-45F0BB123FF2"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FJS/UI/CLI.swift"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "67"
            endingLineNumber = "67"
            landmarkName = "makeUIView(context:)"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "19F6B931-8041-44DB-8E2D-E3CB05F7D2F8"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FJS/UI/CLI.swift"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "69"
            endingLineNumber = "69"
            landmarkName = "makeUIView(context:)"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "056516B3-0342-4C12-9E5B-E9788A8E6E4D"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FJS/UI/CLI.swift"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "70"
            endingLineNumber = "70"
            landmarkName = "makeUIView(context:)"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "888F332E-DD22-417D-88A8-98A468EFE095"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FJS/UI/CLI.swift"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "71"
            endingLineNumber = "71"
            landmarkName = "makeUIView(context:)"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "98017852-2570-4301-BDBB-C22E2B9C7D87"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FJS/UI/CLI.swift"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "72"
            endingLineNumber = "72"
            landmarkName = "makeUIView(context:)"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "C9A95A4A-AB68-48CE-A626-C013FBAE75D1"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FJS/UI/CLI.swift"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "74"
            endingLineNumber = "74"
            landmarkName = "makeUIView(context:)"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "6682C58C-74E8-49EA-8922-66942E650B36"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FridaScript/Runtime/Modules/IO/IO.m"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "345"
            endingLineNumber = "345"
            landmarkName = "-access:flags:"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "0B0D4031-CC43-474C-A7A2-705AEE02773D"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FridaScript/Runtime/Modules/IO/IO.m"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "346"
            endingLineNumber = "346"
            landmarkName = "-access:flags:"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "1B11D182-87E5-4D56-97CF-871A4186E6C5"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FridaScript/Runtime/Modules/IO/IO.m"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "355"
            endingLineNumber = "355"
            landmarkName = "-remove:"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "68BEF6C8-3070-4B01-BB92-3BF54852D292"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FridaScript/Runtime/Modules/IO/IO.m"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "356"
            endingLineNumber = "356"
            landmarkName = "-remove:"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "7DD1B816-AF1B-4037-A78B-24B3DD9BCCB4"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FridaScript/Runtime/Modules/IO/IO.m"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "314"
            endingLineNumber = "314"
            landmarkName = "-stat:"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "FC1B9B23-F155-427C-9573-DC697324B3DA"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FridaScript/Runtime/Modules/IO/IO.m"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "315"
            endingLineNumber = "315"
            landmarkName = "-stat:"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "6B1BFC6D-95BF-4924-8255-851D36DD885F"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FridaScript/Runtime/Modules/IO/IO.m"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "330"
            endingLineNumber = "330"
            landmarkName = "-seek:position:flags:"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "7CAC02D9-88EF-4123-8472-8C03FB9CCE9D"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FridaScript/Runtime/Modules/IO/IO.m"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "331"
            endingLineNumber = "331"
            landmarkName = "-seek:position:flags:"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "6102C098-FAC0-46CF-8312-B6ACFDC248BF"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FridaScript/Runtime/Modules/IO/IO.m"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "278"
            endingLineNumber = "278"
            landmarkName = "-read:size:"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "3382C7EF-FB1E-469E-9573-235E39CC8511"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FridaScript/Runtime/Modules/IO/IO.m"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "279"
            endingLineNumber = "279"
            landmarkName = "-read:size:"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "F50FC1BC-CFB1-4227-A040-4D780E42FF2D"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FridaScript/Runtime/Modules/IO/IO.m"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "256"
            endingLineNumber = "256"
            landmarkName = "-write:text:size:"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "C845C385-241B-415B-80CB-D2A58792599D"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FridaScript/Runtime/Modules/IO/IO.m"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "257"
            endingLineNumber = "257"
            landmarkName = "-write:text:size:"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "892BC0F4-D6A2-410E-AF20-6C4929C208AF"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FridaScript/Runtime/Modules/IO/IO.m"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "240"
            endingLineNumber = "240"
            landmarkName = "-close:"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "7BCA01E9-CB05-4542-BD1D-83D35C6D80E7"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FridaScript/Runtime/Modules/IO/IO.m"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "241"
            endingLineNumber = "241"
            landmarkName = "-close:"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "B669073B-D33D-4537-A400-E2A35B417EDC"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FridaScript/Runtime/Modules/IO/IO.m"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "217"
            endingLineNumber = "217"
            landmarkName = "-open:withFlags:perms:"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "97F9F9D0-A6DA-44F2-BC10-0490E0F384F6"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FridaScript/Runtime/Modules/IO/IO.m"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "218"
            endingLineNumber = "218"
            landmarkName = "-open:withFlags:perms:"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
      <BreakpointProxy
         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
         <BreakpointContent
            uuid = "51A784F8-C84E-4E67-96E4-86179C936F7D"
            shouldBeEnabled = "Yes"
            ignoreCount = "0"
            continueAfterRunningActions = "No"
            filePath = "FridaScript/Runtime/Modules/IO/IO.m"
            startingColumnNumber = "9223372036854775807"
            endingColumnNumber = "9223372036854775807"
            startingLineNumber = "219"
            endingLineNumber = "219"
            landmarkName = "-open:withFlags:perms:"
            landmarkType = "7">
         </BreakpointContent>
      </BreakpointProxy>
   </Breakpoints>
</Bucket>

```

`FridaScript.xcodeproj/xcuserdata/fridakitten.xcuserdatad/xcschemes/xcschememanagement.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>SchemeUserState</key>
	<dict>
		<key>FJS.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>0</integer>
		</dict>
		<key>FridaScript.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>0</integer>
		</dict>
	</dict>
</dict>
</plist>

```

`FridaScript/Assets.xcassets/AccentColor.colorset/Contents.json`:

```json
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`FridaScript/Assets.xcassets/AppIcon.appiconset/Contents.json`:

```json
{
  "images" : [
    {
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "dark"
        }
      ],
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "tinted"
        }
      ],
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`FridaScript/Assets.xcassets/Contents.json`:

```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`FridaScript/ContentView.swift`:

```swift
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

import SwiftUI

struct RuntimeView: UIViewRepresentable {
    var view: TerminalWindow
    let runtime: FJ_Runtime
    var code: String = ""
    
    init(code: String) {
        self.code = code
        self.view = TerminalWindow()
        self.runtime = FJ_Runtime(self.view)
    }
    
    func makeUIView(context: Context) -> UIView {
        let view = UIView()
        
        let terminalView = self.view
        terminalView.frame = view.bounds
        terminalView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
        view.addSubview(terminalView)
        
        DispatchQueue.global(qos: .utility).async {
            self.runtime.run(code)
        }
        
        return view
    }

    func updateUIView(_ uiView: UIView, context: Context) {}
}

struct RuntimeRunnerView: View {
    @Binding var sheet: Bool
    @State var code: String
    
    var body: some View {
        NavigationView {
            RuntimeView(code: code)
                .navigationTitle("Console")
                .navigationBarTitleDisplayMode(.inline)
                .toolbar {
                    ToolbarItem(placement: .navigationBarLeading)
                    {
                        Button("Close")
                        {
                            sheet = false
                        }
                        .accentColor(.primary)
                    }
                }
        }
    }
}

struct ContentView: View {
    @State private var actpath: String = ""
    @State private var action: Int = 0
    var body: some View {
        NavigationView {
            FileList(title: "Root", directoryPath: URL(fileURLWithPath: RootPath), actpath: $actpath, action: $action)
        }
        .accentColor(.primary)
        .tint(.primary)
    }
}

```

`FridaScript/FridaScript.swift`:

```swift
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

import SwiftUI

let RootPath: String = "\(NSHomeDirectory())/Documents"

@main
struct FJSApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}

```

`FridaScript/Runtime/ErrorThrow.h`:

```h
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#ifndef ERRORTHROW_H
#define ERRORTHROW_H

#import <Foundation/Foundation.h>
#import <JavaScriptCore/JavaScriptCore.h>

// premade errors
#define EW_ARGUMENT        @"Parameter failure"
#define EW_RUNTIME_SAFETY  @"Safety compromise detected, runtime safety is enabled, please disable it by calling disable_safety_checks();"
#define EW_UNEXPECTED      @"An unexpected mistake happened"
#define EW_PERMISSION      @"Permission denied"
#define EW_NULL_POINTER    @"Null pointer exception"
#define EW_OUT_OF_BOUNDS   @"Index out of bounds"
#define EW_MEMORY_LEAK     @"Memory leak detected"
#define EW_MEMORY_UAF      @"Attempt to use memory after freed detected"
#define EW_UNAUTHORIZED    @"Unauthorized access"
#define EW_INVALID_STATE   @"Invalid state encountered"
#define EW_TIMEOUT         @"Operation timed out"
#define EW_NETWORK_ERROR   @"Network error occurred"
#define EW_FILE_NOT_FOUND  @"File not found"
#define EW_INVALID_FORMAT  @"Invalid format"
#define EW_DIVIDE_BY_ZERO  @"Attempt to divide by zero"
#define EW_INTERNAL_ERROR  @"Internal error occurred"
#define EW_INVALID_INPUT   @"Invalid input provided"
#define EW_OVERFLOW        @"Buffer overflow detected"
#define EW_CONVERSION_ERROR @"Type conversion failed"
#define EW_RESOURCE_EXCEEDED @"Resource limit exceeded"
#define EW_UNSUPPORTED_OPERATION @"Operation not supported"
#define EW_DISK_FULL       @"Disk is full"
#define EW_UNKNOWN_ERROR   @"An unknown error occurred"

JSValue* jsDoThrowError(NSString *msg);

#if __has_feature(objc_arc) && !defined(__cplusplus)
    #define JS_THROW_ERROR(msg) \
        jsDoThrowError([NSString stringWithFormat:@"%@ %@", NSStringFromSelector(_cmd), msg])
#else
    #define JS_THROW_ERROR(msg) \
        jsDoThrowError([NSString stringWithFormat:@"'%s': %@", __func__, msg])
#endif

#endif

```

`FridaScript/Runtime/ErrorThrow.m`:

```m
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#import "ErrorThrow.h"

/*
 @Brief rewritten version of jsDoThrowError in ObjC
 */
JSValue* jsDoThrowError(NSString *msg) {
    JSValue *error = [JSValue valueWithNewErrorFromMessage:msg inContext:[JSContext currentContext]];
    [[JSContext currentContext] setException:error];
    return error;
}

```

`FridaScript/Runtime/HookFS/HookFS.h`:

```h
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#ifndef HOOKFS_H
#define HOOKFS_H

#import <Foundation/Foundation.h>
#import <JavaScriptCore/JavaScriptCore.h>

@interface HookFS : NSObject

@property (nonatomic,readonly) const char *root;

@end

#endif

```

`FridaScript/Runtime/HookFS/HookFS.m`:

```m
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#import "HookFS.h"
#import <Runtime/Modules/IO/Helper/NSStringCpy.h>

@implementation HookFS

- (instancetype)init:(NSString*)root
{
    self = [super init];
    _root = NSStringCpy(root);
    return self;
}

@end

```

`FridaScript/Runtime/Include.h`:

```h
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#ifndef FJ_INCLUDE_H
#define FJ_INCLUDE_H

#import <Foundation/Foundation.h>
#import <JavaScriptCore/JavaScriptCore.h>
#import <UIKit/UIKit.h>
#import <Runtime/Runtime.h>

void add_include_symbols(FJ_Runtime *Runtime, UIView *Term);

#endif

```

`FridaScript/Runtime/Include.m`:

```m
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#import <Runtime/Include.h>
#import <Runtime/ErrorThrow.h>

// Module Headers
#import <Runtime/Modules/IO/IO.h>
#import <Runtime/Modules/Memory/Memory.h>
#import <Runtime/Modules/String/String.h>
#import <Runtime/Modules/Math/Math.h>
#import <Runtime/Modules/Proc/Proc.h>

// UI Headers
#import <FridaScript-Swift.h>

// IO Headers for Macros
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>

extern BOOL FJ_RUNTIME_SAFETY_ENABLED;

void fj_include(FJ_Runtime *Runtime, TerminalWindow *Term, NSString *LibName)
{
    if ([LibName isEqualToString:@"io"]) {
        IO_MACRO_MAP();
        IOModule *ioModule = [[IOModule alloc] init:Term];
        [Runtime.Context setObject:ioModule forKeyedSubscript:@"io"];
        [Runtime handoffIOModule:ioModule];
    } else if ([LibName isEqual:@"string"]) {
        StringModule *stringModule = [[StringModule alloc] init];
        [Runtime.Context setObject:stringModule forKeyedSubscript:@"string"];
    } else if ([LibName isEqualToString:@"memory"]) {
        MemoryModule *memoryModule = [[MemoryModule alloc] init];
        [Runtime.Context setObject:memoryModule forKeyedSubscript:@"memory"];
        [Runtime handoffMemoryModule:memoryModule];
    } else if ([LibName isEqualToString:@"math"]) {
        MathModule *mathModule = [[MathModule alloc] init];
        [Runtime.Context setObject:mathModule forKeyedSubscript:@"math"];
    } else if ([LibName isEqualToString:@"proc"]) {
        ProcModule *procModule = [[ProcModule alloc] init];
        [Runtime.Context setObject:procModule forKeyedSubscript:@"proc"];
    }
}

void add_include_symbols(FJ_Runtime *Runtime, TerminalWindow *Term)
{
    __block FJ_Runtime *BlockRuntime = Runtime;
    __block TerminalWindow *BlockTerm = Term;
    if (Runtime) {
        [Runtime.Context setObject:^(NSString *LibName) {
            fj_include(BlockRuntime, Term, LibName);
        } forKeyedSubscript:@"include"];
        
        // ! ATTENTION !
        // very sensitive symbol
        // will need user verification
        [Runtime.Context setObject:^id {
            dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
            dispatch_async(dispatch_get_main_queue(), ^{
                [BlockTerm safetyAlertWithSemaphore:semaphore];
            });
            dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
            if(FJ_RUNTIME_SAFETY_ENABLED == NO)
            {
                return NULL;
            } else {
                return jsDoThrowError(@"User decided to not consent\n");
            }
        } forKeyedSubscript:@"disable_safety_checks"];
    }
}

```

`FridaScript/Runtime/Modules/IO/Helper/NSStringCpy.h`:

```h
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#ifndef NSStringCpy_H
#define NSStringCpy_H

#import <Foundation/Foundation.h>

char* NSStringCpy(NSString *nsstring);

#endif

```

`FridaScript/Runtime/Modules/IO/Helper/NSStringCpy.m`:

```m
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#import <Runtime/Modules/IO/Helper/NSStringCpy.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* NSStringCpy(NSString *nsstring)
{
    const char *ro_buffer = [nsstring UTF8String];
    size_t size_of_ro_buffer = strlen(ro_buffer);
    char *rw_buffer = malloc(size_of_ro_buffer);
    memcpy(rw_buffer, ro_buffer, size_of_ro_buffer);
    return rw_buffer;
}

```

`FridaScript/Runtime/Modules/IO/Helper/UniOrigHolder.h`:

```h
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#ifndef UNIORIGHOLDER_H
#define UNIORIGHOLDER_H

#import <Foundation/Foundation.h>

@interface UniversalOriginalHolder : NSObject

@property (nonatomic,readonly) void *ptr;

- (instancetype)init:(void*)ptr;

@end

#endif

```

`FridaScript/Runtime/Modules/IO/Helper/UniOrigHolder.m`:

```m
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#import <Runtime/Modules/IO/Helper/UniOrigHolder.h>

@implementation UniversalOriginalHolder

- (instancetype)init:(void*)ptr
{
    self = [super init];
    _ptr = ptr;
    return self;
}

@end

```

`FridaScript/Runtime/Modules/IO/IO.h`:

```h
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#import <Foundation/Foundation.h>
#import <JavaScriptCore/JavaScriptCore.h>
#import <FridaScript-Swift.h>
#import <Runtime/Modules/IO/Macro.h>

@protocol IOModuleExport <JSExport>

/*
 @Brief console functions
 */
- (id)print:(NSString*)buffer;
- (id)readline:(NSString*)prompt;
- (id)getchar;

/*
 @Brief macro functions
 */
- (BOOL)S_ISDIR:(UInt64)m;
- (BOOL)S_ISREG:(UInt64)m;
- (BOOL)S_ISLNK:(UInt64)m;
- (BOOL)S_ISCHR:(UInt64)m;
- (BOOL)S_ISBLK:(UInt64)m;
- (BOOL)S_ISFIFO:(UInt64)m;
- (BOOL)S_ISSOCK:(UInt64)m;

/*
 @Brief file descriptor functions
 */
JSExportAs(open,
- (id)open:(NSString *)path withFlags:(int)flags perms:(UInt16)perms
);

- (id)close:(int)fd;

JSExportAs(write,
- (id)write:(int)fd text:(NSString*)text size:(UInt16)size
);
JSExportAs(read,
- (id)read:(int)fd size:(UInt16)size
);
- (id)stat:(int)fd;
JSExportAs(seek,
- (id)seek:(int)fd position:(UInt16)position flags:(int)flags
);
JSExportAs(access,
- (id)access:(NSString*)path flags:(int)flags
);
- (id)remove:(NSString*)path;
JSExportAs(mkdir,
- (id)mkdir:(NSString*)path perms:(UInt16)perms
);


- (id)rmdir:(NSString*)path;

JSExportAs(chown,
- (id)chown:(NSString*)path uid:(int)uid gid:(int)gid
);
JSExportAs(chmod,
- (id)chmod:(NSString*)path flags:(UInt16)flags
);

// file functions
JSExportAs(fopen,
- (id)fopen:(NSString*)path mode:(NSString*)mode
);
- (id)fclose:(JSValue*)fileObject;
JSExportAs(freopen,
- (id)freopen:(NSString*)path mode:(NSString*)mode fileObject:(JSValue*)fileObject
);

// directory functions
- (id)opendir:(NSString*)path;
- (id)closedir:(JSValue*)DIR_obj;
- (id)readdir:(JSValue*)DIR_obj;
- (id)rewinddir:(JSValue*)DIR_obj;

@end

@interface IOModule : NSObject <IOModuleExport>

@property (nonatomic,strong) TerminalWindow *term;
@property (nonatomic, strong) NSMutableArray<NSNumber *> *array;

- (instancetype)init:(TerminalWindow*)term;
- (NSString*)moduleCleanup;

@end

```

`FridaScript/Runtime/Modules/IO/IO.m`:

```m
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#import <Runtime/Modules/IO/IO.h>
#import <Runtime/Modules/IO/Types/Stat.h>
#import <Runtime/Modules/IO/Types/DIR.h>
#import <Runtime/Modules/IO/Types/FILE.h>
#import <Runtime/Modules/IO/Types/Dirent.h>
#import <Runtime/ReturnObjBuilder.h>
#import <Runtime/ErrorThrow.h>

#include <errno.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>

extern BOOL FJ_RUNTIME_SAFETY_ENABLED;

@implementation IOModule

- (instancetype)init:(TerminalWindow*)term
{
    self = [super init];
    _array = [[NSMutableArray alloc] init];
    _term = term;
    return self;
}

- (NSString*)moduleCleanup
{
    NSString *buffer = @"";
    
    if(FJ_RUNTIME_SAFETY_ENABLED)
    {
        for (id item in _array) {
            buffer = [buffer stringByAppendingFormat:@"%@", [NSString stringWithFormat:@"File Descriptor %d was not closed, closing it for you <3\n", [item intValue]]];
            if (close([item intValue]) != 0) {
                buffer = [buffer stringByAppendingFormat:@"%@", [NSString stringWithFormat:@"Failed to close file descriptor %d :c\n", [item intValue]]];
            };
        }
    }
    
    return buffer;
}

/*
 @Brief functions for fd preservation
 */
- (void)addFD:(UInt64)fd
{
    if(FJ_RUNTIME_SAFETY_ENABLED)
    {
        [_array addObject:[[NSNumber alloc] initWithUnsignedLongLong:fd]];
    }
}

- (BOOL)isFDThere:(UInt64)fd
{
    if(FJ_RUNTIME_SAFETY_ENABLED)
    {
        return [_array containsObject:[[NSNumber alloc] initWithUnsignedLongLong:fd]];
    }
    return true;
}

- (void)removeFD:(UInt64)fd
{
    if(FJ_RUNTIME_SAFETY_ENABLED)
    {
        [_array removeObject:[[NSNumber alloc] initWithUnsignedLongLong:fd]];
    }
}


/*
 @Brief console functions
 */

- (id)print:(NSString*)buffer
{
    usleep(1);
    
    if(!_term)
    {
        return JS_THROW_ERROR(EW_NULL_POINTER);
    }
    
    dispatch_sync(dispatch_get_main_queue(), ^{
        _term.terminalText.text = [_term.terminalText.text stringByAppendingFormat:@"%@", buffer];
    });
    
    return NULL;
}

- (id)readline:(NSString*)prompt
{
    usleep(1);
    __block dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
    __block NSString *captured = @"";
    __block TerminalWindow *BlockTerm = _term;
    
    dispatch_async(dispatch_get_main_queue(), ^{
        BlockTerm.terminalText.text = [BlockTerm.terminalText.text stringByAppendingFormat:@"%@", prompt];
        [self->_term setInput:^(NSString *input) {
            if([input isEqual:@"\n"])
            {
                BlockTerm.terminalText.text = [BlockTerm.terminalText.text stringByAppendingFormat:@"%@", input];
                dispatch_semaphore_signal(semaphore);
                return;
            }
            BlockTerm.terminalText.text = [BlockTerm.terminalText.text stringByAppendingFormat:@"%@", input];
            captured = [captured stringByAppendingFormat:@"%@", input];
        }];
        [self->_term setDeletion:^(NSString *input) {
            if(![captured isEqual:@""])
            {
                BlockTerm.terminalText.text = [BlockTerm.terminalText.text substringToIndex:[BlockTerm.terminalText.text length] - 1];
                captured = [captured substringToIndex:[captured length] - 1];
            }
        }];
    });
    
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    
    [self->_term setInput:^(NSString *input) {}];
    [self->_term setDeletion:^(NSString *input) {}];
    
    return captured;
}

- (id)getchar
{
    usleep(1);
    __block dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
    __block NSString *captured = @"";
    
    dispatch_async(dispatch_get_main_queue(), ^{
        [self->_term setInput:^(NSString *input) {
            if(![input isEqual:@""])
            {
                captured = input;
                dispatch_semaphore_signal(semaphore);
            }
        }];
    });
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    
    [self->_term setInput:^(NSString *input) {}];
    
    return captured;
}

/*
 @Brief Macro Functions
 */
- (BOOL)S_ISDIR:(UInt64)m
{
    return S_ISDIR(m);
}

- (BOOL)S_ISREG:(UInt64)m
{
    return S_ISREG(m);
}

- (BOOL)S_ISLNK:(UInt64)m
{
    return S_ISLNK(m);
}

- (BOOL)S_ISCHR:(UInt64)m
{
    return S_ISCHR(m);
}

- (BOOL)S_ISBLK:(UInt64)m
{
    return S_ISBLK(m);
}

- (BOOL)S_ISFIFO:(UInt64)m
{
    return S_ISFIFO(m);
}

- (BOOL)S_ISSOCK:(UInt64)m
{
    return S_ISSOCK(m);
}

/*
 @Brief file descriptor functions
 */
- (id)open:(NSString *)path withFlags:(int)flags perms:(UInt16)perms {
    const char *cPath = [[NSString stringWithFormat:@"%@/Documents/%@", NSHomeDirectory(), path] UTF8String];
    if (cPath == NULL) {
        return JS_THROW_ERROR(EW_NULL_POINTER);
    }

    int fd = -1;
    if(perms != 0)
    {
        fd = open(cPath, flags, perms);
    } else {
        fd = open(cPath, flags, (mode_t)0777);
    }
    
    if (fd == -1) {
        return JS_THROW_ERROR(EW_UNEXPECTED);
    }
    
    [self addFD:fd];

    return [[NSNumber alloc] initWithInt:fd];
}

- (id)close:(int)fd
{
    if(![self isFDThere:fd])
    {
        return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
    }
    
    if(close(fd) == -1) {
        return JS_THROW_ERROR(EW_UNEXPECTED);
    }
    
    [self removeFD:fd];
    
    return NULL;
}

- (id)write:(int)fd text:(NSString*)text size:(UInt16)size
{
    if(size == 0)
    {
        return JS_THROW_ERROR(EW_INVALID_INPUT);
    }
    
    if(![self isFDThere:fd])
    {
        return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
    }
    
    const char *buffer = [text UTF8String];
    ssize_t bytesWritten = write(fd, buffer, size);
    
    if (bytesWritten < 0) {
        return JS_THROW_ERROR(EW_UNEXPECTED);
    }
    
    return @(bytesWritten);
}

- (id)read:(int)fd size:(UInt16)size
{
    if(size == 0)
    {
        return JS_THROW_ERROR(EW_INVALID_INPUT);
    }
    
    if(![self isFDThere:fd])
    {
        return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
    }
    
    NSMutableData *buffer = [NSMutableData dataWithLength:size];
    
    ssize_t bytesRead = read(fd, buffer.mutableBytes, size);
    
    if (bytesRead < 0)
    {
        return JS_THROW_ERROR(EW_UNEXPECTED);
    }
    
    if (bytesRead == 0)
    {
        // EOF
        return NULL;
    }
    
    NSData *resultData = [NSData dataWithBytes:buffer.bytes length:bytesRead];
    NSString *resultString = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
    
    return ReturnObjectBuilder(@{
        @"bytesRead": @(bytesRead),
        @"buffer": resultString,
    });
}

- (id)stat:(int)fd
{
    if(![self isFDThere:fd])
    {
        return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
    }
    
    struct stat statbuf;
    if (fstat(fd, &statbuf) < 0)
    {
        return JS_THROW_ERROR(EW_UNEXPECTED);
    }
    
    return buildStat(statbuf);
}

- (id)seek:(int)fd position:(UInt16)position flags:(int)flags
{
    if(![self isFDThere:fd])
    {
        return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
    }
    
    if(lseek(fd, position, flags) != 0)
    {
        return JS_THROW_ERROR(EW_UNEXPECTED);
    }
    
    return NULL;
}

- (id)access:(NSString*)path flags:(int)flags
{
    const char *cPath = [[NSString stringWithFormat:@"%@/Documents/%@", NSHomeDirectory(), path] UTF8String];
    if (cPath == NULL) {
        return JS_THROW_ERROR(EW_NULL_POINTER);
    }
    
    return [[NSNumber alloc] initWithInt: access(cPath, flags)];
}

- (id)remove:(NSString*)path
{
    const char *cPath = [[NSString stringWithFormat:@"%@/Documents/%@", NSHomeDirectory(), path] UTF8String];
    if (cPath == NULL) {
        return JS_THROW_ERROR(EW_NULL_POINTER);
    }
    
    if (remove(cPath) != 0)
    {
        return JS_THROW_ERROR(EW_UNEXPECTED);
    }
    
    return NULL;
}

- (id)mkdir:(NSString*)path perms:(UInt16)perms
{
    const char *cPath = [[NSString stringWithFormat:@"%@/Documents/%@", NSHomeDirectory(), path] UTF8String];
    if (cPath == NULL) {
        return JS_THROW_ERROR(EW_NULL_POINTER);
    }
    
    int result = 0;
    if(perms != 0)
    {
        result = mkdir(cPath, (mode_t)perms);
    } else {
        result = mkdir(cPath, (mode_t)0777);
    }
    
    if(result != 0)
    {
        return JS_THROW_ERROR(EW_UNEXPECTED);
    }
    
    return NULL;
}

- (id)rmdir:(NSString*)path
{
    const char *cPath = [[NSString stringWithFormat:@"%@/Documents/%@", NSHomeDirectory(), path] UTF8String];
    if (cPath == NULL) {
        return JS_THROW_ERROR(EW_NULL_POINTER);
    }
    
    if(rmdir(cPath) != 0)
    {
        return JS_THROW_ERROR(EW_UNEXPECTED);
    }
    
    return NULL;
}

- (id)chown:(NSString*)path uid:(int)uid gid:(int)gid
{
    const char *cPath = [[NSString stringWithFormat:@"%@/Documents/%@", NSHomeDirectory(), path] UTF8String];
    if (cPath == NULL) {
        return JS_THROW_ERROR(EW_NULL_POINTER);
    }
    
    if(chown(cPath, uid, gid) != 0)
    {
        return JS_THROW_ERROR(EW_UNEXPECTED);
    }
    
    return NULL;
}

- (id)chmod:(NSString*)path flags:(UInt16)flags
{
    const char *cPath = [[NSString stringWithFormat:@"%@/Documents/%@", NSHomeDirectory(), path] UTF8String];
    if (cPath == NULL) {
        return JS_THROW_ERROR(EW_NULL_POINTER);
    }
    
    if(chmod(cPath, (mode_t)flags) != 0)
    {
        return JS_THROW_ERROR(EW_UNEXPECTED);
    }
    
    return NULL;
}

// File functions
- (id)fopen:(NSString*)path mode:(NSString*)mode
{
    const char *cPath = [[NSString stringWithFormat:@"%@/Documents/%@", NSHomeDirectory(), path] UTF8String];
    if (cPath == NULL) {
        return JS_THROW_ERROR(EW_NULL_POINTER);
    }
    
    // getting the file
    FILE *file = fopen(cPath, [mode UTF8String]);
    
    // checking if file was allocated
    if(file == NULL)
    {
        return JS_THROW_ERROR(EW_NULL_POINTER);
    }

    // getting file descriptor of file
    int fd = fileno(file);
    
    // checking fd
    if(fd == -1)
    {
        return JS_THROW_ERROR(EW_UNEXPECTED);
    }
    
    // adding it to the file descriptor system
    [self addFD:fd];
    
    // returning it
    return buildFILE(file);
}

- (id)fclose:(JSValue*)fileObject
{
    if(fileObject == NULL)
    {
        return JS_THROW_ERROR(EW_INVALID_INPUT);
    }
    
    FILE *file = restoreFILE(fileObject);
    
    // checking if file was allocated
    if(file == NULL)
    {
        return JS_THROW_ERROR(EW_NULL_POINTER);
    }
    
    // getting file descriptor of file
    int fd = fileno(file);
    
    // checking fd
    if(fd == -1)
    {
        return JS_THROW_ERROR(EW_UNEXPECTED);
    }
    
    if(![self isFDThere:fd])
    {
        return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
    }
    
    if(fclose(file) != 0)
    {
        return JS_THROW_ERROR(EW_UNEXPECTED);
    }
    
    [self removeFD:fd];
    
    updateFILE(file, fileObject);
    
    return NULL;
}

- (id)freopen:(NSString*)path mode:(NSString*)mode fileObject:(JSValue*)fileObject
{
    if(fileObject == NULL)
    {
        return JS_THROW_ERROR(EW_INVALID_INPUT);
    }
    
    FILE *file = restoreFILE(fileObject);
    
    // checking if file was allocated
    if(file == NULL)
    {
        return JS_THROW_ERROR(EW_NULL_POINTER);
    }
    
    // getting file descriptor of file
    int fd = fileno(file);
    
    if(![self isFDThere:fd])
    {
        return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
    }
    
    FILE *reopenedfile = freopen([path UTF8String], [mode UTF8String], file);
    if (reopenedfile == NULL)
    {
        return JS_THROW_ERROR(EW_NULL_POINTER);
    }
    
    int reopenedfd = fileno(reopenedfile);
    if(reopenedfd == -1)
    {
        return JS_THROW_ERROR(EW_UNEXPECTED);
    }
    
    [self removeFD:fd];
    [self addFD:reopenedfd];
    
    updateFILE(reopenedfile, fileObject);
    
    return fileObject;
}

// Directory functions
- (id)opendir:(NSString*)path
{
    const char *cPath = [[NSString stringWithFormat:@"%@/Documents/%@", NSHomeDirectory(), path] UTF8String];
    if (cPath == NULL) {
        return JS_THROW_ERROR(EW_NULL_POINTER);
    }
    
    DIR *directory = opendir(cPath);
    
    if(directory == NULL)
    {
        return JS_THROW_ERROR(EW_NULL_POINTER);
    }
    
    [self addFD:directory->__dd_fd];
    
    return buildDIR(directory);
}

- (id)closedir:(JSValue*)DIR_obj
{
    if(DIR_obj == NULL)
    {
        return JS_THROW_ERROR(EW_INVALID_INPUT);
    }
    
    DIR *directory = buildBackDIR(DIR_obj);
    if (directory == NULL) {
        return JS_THROW_ERROR(EW_NULL_POINTER);
    }
    
    UInt64 fd = directory->__dd_fd;
    if(![self isFDThere:fd])
    {
        return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
    }
    
    if (closedir(directory) != 0)
    {
        return JS_THROW_ERROR(EW_UNEXPECTED);
    }
    
    [self removeFD:fd];
    
    return NULL;
}

- (id)readdir:(JSValue*)DIR_obj
{
    if(DIR_obj == NULL)
    {
        return JS_THROW_ERROR(EW_INVALID_INPUT);
    }
    
    DIR *directory = buildBackDIR(DIR_obj);
    if (directory == NULL) {
        return JS_THROW_ERROR(EW_NULL_POINTER);
    }

    UInt64 fd = directory->__dd_fd;
    if (![self isFDThere:fd]) {
        return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
    }

    errno = 0;
    struct dirent *result = readdir(directory);

    if (result == NULL) {
        return JS_THROW_ERROR(EW_NULL_POINTER);
    }

    struct dirent dir;
    memcpy(&dir, result, sizeof(struct dirent));

    updateDIR(directory, DIR_obj);

    JSValue *dirent_obj = buildDirent(dir);

    return dirent_obj;
}

- (id)rewinddir:(JSValue*)DIR_obj
{
    if(DIR_obj == NULL)
    {
        return JS_THROW_ERROR(EW_INVALID_INPUT);
    }
    
    DIR *directory = buildBackDIR(DIR_obj);
    if (directory == NULL) {
        return JS_THROW_ERROR(EW_NULL_POINTER);
    }

    UInt64 fd = directory->__dd_fd;
    if (![self isFDThere:fd]) {
        return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
    }
    
    rewinddir(directory);
    
    updateDIR(directory, DIR_obj);
    
    return NULL;
}

@end

```

`FridaScript/Runtime/Modules/IO/IO.md`:

```md
# IO Module
## Description
Module to interact with the file system and the console.
## Macros
### Open Macros
<table border="1" cellpadding="8" cellspacing="0">
  <thead>
    <tr>
      <th>Macro</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>O_RDONLY</code></td>
      <td>Open for <strong>read-only</strong> access.</td>
    </tr>
    <tr>
      <td><code>O_WRONLY</code></td>
      <td>Open for <strong>write-only</strong> access.</td>
    </tr>
    <tr>
      <td><code>O_RDWR</code></td>
      <td>Open for <strong>read-write</strong> access.</td>
    </tr>
    <tr>
      <td><code>O_APPEND</code></td>
      <td>Writes will always <strong>append</strong> to the end of the file.</td>
    </tr>
    <tr>
      <td><code>O_CREAT</code></td>
      <td><strong>Create</strong> the file if it does not exist.</td>
    </tr>
    <tr>
      <td><code>O_EXCL</code></td>
      <td>Used with <code>O_CREAT</code>; fails if file exists. Ensures <strong>exclusive creation</strong>.</td>
    </tr>
    <tr>
      <td><code>O_TRUNC</code></td>
      <td>If file exists, <strong>truncate</strong> it to zero length.</td>
    </tr>
    <tr>
      <td><code>O_NOCTTY</code></td>
      <td>If file is a terminal, do <strong>not assign</strong> it as controlling terminal.</td>
    </tr>
    <tr>
      <td><code>O_SYNC</code></td>
      <td>Open for synchronous I/O; <strong>writes are flushed to disk immediately</strong>.</td>
    </tr>
    <tr>
      <td><code>O_DSYNC</code></td>
      <td>Similar to <code>O_SYNC</code>, but only <strong>data is synchronized</strong>, not metadata.</td>
    </tr>
    <tr>
      <td><code>O_NONBLOCK</code></td>
      <td>Open in <strong>non-blocking mode</strong>; I/O returns immediately.</td>
    </tr>
    <tr>
      <td><code>O_CLOEXEC</code></td>
      <td>Set <strong>close-on-exec</strong> flag; descriptor closed on <code>exec()</code>.</td>
    </tr>
    <tr>
      <td><code>O_ACCMODE</code></td>
      <td>Mask to extract access mode (<code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code>).</td>
    </tr>
  </tbody>
</table>

### File Macros

<table border="1" cellpadding="8" cellspacing="0">
  <thead>
    <tr>
      <th>Macro</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>F_OK</code></td>
      <td>Check if a file exists (used with <code>access()</code> function).</td>
    </tr>
    <tr>
      <td><code>F_DUPFD</code></td>
      <td>Duplicate a file descriptor (used with <code>fcntl()</code>).</td>
    </tr>
    <tr>
      <td><code>F_GETFD</code></td>
      <td>Get file descriptor flags (like <code>FD_CLOEXEC</code>).</td>
    </tr>
    <tr>
      <td><code>F_SETFD</code></td>
      <td>Set file descriptor flags.</td>
    </tr>
    <tr>
      <td><code>F_GETFL</code></td>
      <td>Get file status flags (e.g., <code>O_NONBLOCK</code>, <code>O_APPEND</code>).</td>
    </tr>
    <tr>
      <td><code>F_SETFL</code></td>
      <td>Set file status flags.</td>
    </tr>
    <tr>
      <td><code>F_GETLK</code></td>
      <td>Check if a file lock is held (used with <code>fcntl()</code> and <code>struct flock</code>).</td>
    </tr>
    <tr>
      <td><code>F_SETLK</code></td>
      <td>Set (non-blocking) file lock.</td>
    </tr>
    <tr>
      <td><code>F_SETLKW</code></td>
      <td>Set file lock and wait (blocking) if lock is not immediately available.</td>
    </tr>
    <tr>
      <td><code>F_GETOWN</code></td>
      <td>Get PID or process group ID that receives <code>SIGIO</code>/<code>SIGURG</code> signals for asynchronous I/O.</td>
    </tr>
    <tr>
      <td><code>F_SETOWN</code></td>
      <td>Set PID or process group to receive <code>SIGIO</code>/<code>SIGURG</code> signals.</td>
    </tr>
    <tr>
      <td><code>F_RDLCK</code></td>
      <td>Set a <strong>read (shared) lock</strong> on file (used in <code>struct flock</code>).</td>
    </tr>
    <tr>
      <td><code>F_WRLCK</code></td>
      <td>Set a <strong>write (exclusive) lock</strong> on file.</td>
    </tr>
    <tr>
      <td><code>F_UNLCK</code></td>
      <td>Remove/unlock a previously set lock.</td>
    </tr>
  </tbody>
</table>

### Seek Macros

<table border="1" cellpadding="8" cellspacing="0">
  <thead>
    <tr>
      <th>Macro</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>SEEK_SET</code></td>
      <td>Set file offset to a specific position relative to the <strong>beginning of the file</strong>.</td>
    </tr>
    <tr>
      <td><code>SEEK_CUR</code></td>
      <td>Set file offset <strong>relative to the current file position</strong>.</td>
    </tr>
    <tr>
      <td><code>SEEK_END</code></td>
      <td>Set file offset relative to the <strong>end of the file</strong>.</td>
    </tr>
  </tbody>
</table>

### File Permission Bit Macros

<table border="1" cellpadding="8" cellspacing="0">
  <thead>
    <tr>
      <th>Macro</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>S_IFMT</code></td>
      <td>Bitmask for the file type bit fields (used to extract file type from <code>st_mode</code>).</td>
    </tr>
    <tr>
      <td><code>S_IFSOCK</code></td>
      <td>File type: <strong>socket</strong>.</td>
    </tr>
    <tr>
      <td><code>S_IFLNK</code></td>
      <td>File type: <strong>symbolic link</strong>.</td>
    </tr>
    <tr>
      <td><code>S_IFREG</code></td>
      <td>File type: <strong>regular file</strong>.</td>
    </tr>
    <tr>
      <td><code>S_IFBLK</code></td>
      <td>File type: <strong>block device</strong>.</td>
    </tr>
    <tr>
      <td><code>S_IFDIR</code></td>
      <td>File type: <strong>directory</strong>.</td>
    </tr>
    <tr>
      <td><code>S_IFCHR</code></td>
      <td>File type: <strong>character device</strong>.</td>
    </tr>
    <tr>
      <td><code>S_IFIFO</code></td>
      <td>File type: <strong>FIFO (named pipe)</strong>.</td>
    </tr>
    <tr>
      <td><code>S_IRWXU</code></td>
      <td>Owner permissions: <strong>read, write, execute</strong> (rwx).</td>
    </tr>
    <tr>
      <td><code>S_IRUSR</code></td>
      <td>Owner permission: <strong>read</strong> (r).</td>
    </tr>
    <tr>
      <td><code>S_IWUSR</code></td>
      <td>Owner permission: <strong>write</strong> (w).</td>
    </tr>
    <tr>
      <td><code>S_IXUSR</code></td>
      <td>Owner permission: <strong>execute/search</strong> (x).</td>
    </tr>
    <tr>
      <td><code>S_IRWXG</code></td>
      <td>Group permissions: <strong>read, write, execute</strong> (rwx).</td>
    </tr>
    <tr>
      <td><code>S_IRGRP</code></td>
      <td>Group permission: <strong>read</strong> (r).</td>
    </tr>
    <tr>
      <td><code>S_IWGRP</code></td>
      <td>Group permission: <strong>write</strong> (w).</td>
    </tr>
    <tr>
      <td><code>S_IXGRP</code></td>
      <td>Group permission: <strong>execute/search</strong> (x).</td>
    </tr>
    <tr>
      <td><code>S_IRWXO</code></td>
      <td>Others permissions: <strong>read, write, execute</strong> (rwx).</td>
    </tr>
    <tr>
      <td><code>S_IROTH</code></td>
      <td>Others permission: <strong>read</strong> (r).</td>
    </tr>
    <tr>
      <td><code>S_IWOTH</code></td>
      <td>Others permission: <strong>write</strong> (w).</td>
    </tr>
    <tr>
      <td><code>S_IXOTH</code></td>
      <td>Others permission: <strong>execute/search</strong> (x).</td>
    </tr>
    <tr>
      <td><code>S_ISUID</code></td>
      <td>Set-user-ID on execution.</td>
    </tr>
    <tr>
      <td><code>S_ISGID</code></td>
      <td>Set-group-ID on execution.</td>
    </tr>
    <tr>
      <td><code>S_ISVTX</code></td>
      <td>Sticky bit (restricts file deletion; used on directories like <code>/tmp</code>).</td>
    </tr>
  </tbody>
</table>

### Directory Macros

<table border="1" cellpadding="8" cellspacing="0">
  <thead>
    <tr>
      <th>Macro</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DT_BLK</code></td>
      <td>Block device file.</td>
    </tr>
    <tr>
      <td><code>DT_CHR</code></td>
      <td>Character device file.</td>
    </tr>
    <tr>
      <td><code>DT_DIR</code></td>
      <td>Directory.</td>
    </tr>
    <tr>
      <td><code>DT_LNK</code></td>
      <td>Symbolic link.</td>
    </tr>
    <tr>
      <td><code>DT_REG</code></td>
      <td>Regular file.</td>
    </tr>
    <tr>
      <td><code>DT_WHT</code></td>
      <td>Whiteout (used on some filesystems like unionfs, rarely used in general).</td>
    </tr>
    <tr>
      <td><code>DT_FIFO</code></td>
      <td>FIFO (named pipe).</td>
    </tr>
    <tr>
      <td><code>DT_SOCK</code></td>
      <td>Socket.</td>
    </tr>
    <tr>
      <td><code>DT_UNKNOWN</code></td>
      <td>Unknown file type.</td>
    </tr>
  </tbody>
</table>

## Functions
### print
```
io.print(<string:content>);
```
Prints the specified string to the console.

### readline
```
let ret = io.readline(<string:prompt>);
```
Displays a prompt message and waits for the user to input a line. Returns the inputted string when the user presses Enter.

### getchar
```
let ret = io.getchar();
```
Waits for the user to input a single character and returns it once typed.

### open
```
try {
    let fd = io.open(<string:path>, <integer:flags>, <integer:mode>);
} catch (error) {
    io.print(error);
}
```
Opens a file for reading, writing, or appending using the specified flags. Optionally, a mode can be set if the file needs to be created. Returns the file descriptor.

### close

```
try {
    io.close(<integer:fd>);
} catch (error) {
    io.print(error);
}
```
Closes the file descriptor passed as an argument.

### write

```
try {
    io.write(<integer:fd>, <string:content>, <integer:size>);
} catch (error) {
    io.print(error);
}
```
Writes the specified content to the file descriptor, limited by the specified size. Returns the number of bytes written.

### read

```
try {
    let ret = io.read(<integer:fd>, <integer:size>);
} catch (error) {
    io.print(error);
}
```
Reads data from the specified file descriptor. Returns an object containing the `size` of the buffer and the `buffer` itself, representing the data read.

### stat

```
try {
    let stat = io.stat(<integer:fd>);
} catch (error) {
    io.print(error);
}
```
Returns a `stat` object containing detailed information about the file descriptor.

### seek

```
try {
    io.seek(<integer:fd>, <integer:position>, <integer:flags>);
} catch (error) {
    io.print(error);
}
```
Moves the file pointer to the specified position, using the given flags (e.g., `SEEK_SET`).

### access

```
try {
    io.access(<string:path>, <integer:flags>);
} catch (error) {
    io.print(error);
}
```
Checks the specified file path for access rights based on the flags (e.g., `F_OK`). Returns an integer value indicating success or failure.

### remove

```
try {
    io.remove(<string:path>);
} catch (error) {
    io.print(error);
}
```
Removes the file or directory at the given path.

### mkdir

```
try {
    io.mkdir(<string:path>, <integer:mode>);
} catch (error) {
    io.print(error);
}
```
Creates a new directory at the specified path with the given mode.

### rmdir

```
try {
    io.rmdir(<string:path>);
} catch (error) {
    io.print(error);
}
```
Removes the directory at the specified path.

### chown

```
try {
    io.chown(<string:path>, <integer:uid>, <integer:gid>);
} catch (error) {
    io.print(error);
}
```
Changes the ownership of the file or directory at the specified path.

### chmod

```
try {
    io.chmod(<string:path>, <integer:flags>);
} catch (error) {
    io.print(error);
}
```
Changes the permissions of the file or directory at the specified path using the given flags.

### fopen

```
try {
    let file = io.fopen(<string:path>, <string:mode>);
} catch (error) {
    io.print(error);
}
```

### fclose

```
try {
    io.fclose(<FILE:file object>);
} catch (error) {
    io.print(error);
}
```
Opens a file with the specified path and mode. Similar to open but takes a mode string (e.g., "r", "w").

### freopen

```
try {
    let file = io.freopen(<string:path>, <string:mode>, <FILE:file object>);
} catch (error) {
    io.print(error);
}
```
This function reopens a file with a different mode. It is useful when you want to change the file mode of an already opened file without closing it and reopening it. The function returns the file object after reopening the file.

### opendir

```
try {
    let dir = io.opendir(<string:path>);
} catch (error) {
    io.print(error);
}
```
This function opens a directory stream, which can be used to read the contents of a directory.

### closedir

```
try {
    io.closedir(<DIR:directory object>);
} catch (error) {
    io.print(error);
}
```
This function closes a previously opened directory stream. It's important to call this when you're done reading the directory contents to release resources.

### readdir

```
try {
    let dirent = io.readdir(<DIR:directory object>);
} catch (error) {
    io.print(error);
}
```
This function reads the next directory entry from the opened directory stream. It returns an object containing the file/directory name.

### rewinddir

```
try {
    let dir = io.rewinddir(<DIR:directory object>);
} catch (error) {
    io.print(error);
}
```
This function resets the position of the directory stream, allowing you to start reading the directory from the beginning again.

```

`FridaScript/Runtime/Modules/IO/Macro.h`:

```h
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#include <Runtime/Modules/MacroHelper.h>

#define IO_MACRO_MAP() \
DECLARE_CONTEXT_MAPPING(O_RDONLY) \
DECLARE_CONTEXT_MAPPING(O_WRONLY) \
DECLARE_CONTEXT_MAPPING(O_RDWR) \
DECLARE_CONTEXT_MAPPING(O_APPEND) \
DECLARE_CONTEXT_MAPPING(O_CREAT) \
DECLARE_CONTEXT_MAPPING(O_EXCL) \
DECLARE_CONTEXT_MAPPING(O_TRUNC) \
DECLARE_CONTEXT_MAPPING(O_NOCTTY) \
DECLARE_CONTEXT_MAPPING(O_NOFOLLOW) \
DECLARE_CONTEXT_MAPPING(O_SYNC) \
DECLARE_CONTEXT_MAPPING(O_DSYNC) \
DECLARE_CONTEXT_MAPPING(O_NONBLOCK) \
DECLARE_CONTEXT_MAPPING(O_CLOEXEC) \
DECLARE_CONTEXT_MAPPING(O_ACCMODE) \
DECLARE_CONTEXT_MAPPING(F_OK) \
DECLARE_CONTEXT_MAPPING(F_DUPFD) \
DECLARE_CONTEXT_MAPPING(F_GETFD) \
DECLARE_CONTEXT_MAPPING(F_SETFD) \
DECLARE_CONTEXT_MAPPING(F_GETFL) \
DECLARE_CONTEXT_MAPPING(F_SETFL) \
DECLARE_CONTEXT_MAPPING(F_GETLK) \
DECLARE_CONTEXT_MAPPING(F_SETLK) \
DECLARE_CONTEXT_MAPPING(F_SETLKW) \
DECLARE_CONTEXT_MAPPING(F_GETOWN) \
DECLARE_CONTEXT_MAPPING(F_SETOWN) \
DECLARE_CONTEXT_MAPPING(F_RDLCK) \
DECLARE_CONTEXT_MAPPING(F_WRLCK) \
DECLARE_CONTEXT_MAPPING(F_UNLCK) \
DECLARE_CONTEXT_MAPPING(SEEK_SET) \
DECLARE_CONTEXT_MAPPING(SEEK_CUR) \
DECLARE_CONTEXT_MAPPING(SEEK_END) \
DECLARE_CONTEXT_MAPPING(S_IFMT) \
DECLARE_CONTEXT_MAPPING(S_IFSOCK) \
DECLARE_CONTEXT_MAPPING(S_IFMT) \
DECLARE_CONTEXT_MAPPING(S_IFLNK) \
DECLARE_CONTEXT_MAPPING(S_IFREG) \
DECLARE_CONTEXT_MAPPING(S_IFBLK) \
DECLARE_CONTEXT_MAPPING(S_IFDIR) \
DECLARE_CONTEXT_MAPPING(S_IFCHR) \
DECLARE_CONTEXT_MAPPING(S_IFIFO) \
DECLARE_CONTEXT_MAPPING(S_IRWXU) \
DECLARE_CONTEXT_MAPPING(S_IRUSR) \
DECLARE_CONTEXT_MAPPING(S_IWUSR) \
DECLARE_CONTEXT_MAPPING(S_IXUSR) \
DECLARE_CONTEXT_MAPPING(S_IRWXG) \
DECLARE_CONTEXT_MAPPING(S_IRGRP) \
DECLARE_CONTEXT_MAPPING(S_IWGRP) \
DECLARE_CONTEXT_MAPPING(S_IXGRP) \
DECLARE_CONTEXT_MAPPING(S_IRWXO) \
DECLARE_CONTEXT_MAPPING(S_IROTH) \
DECLARE_CONTEXT_MAPPING(S_IWOTH) \
DECLARE_CONTEXT_MAPPING(S_IXOTH) \
DECLARE_CONTEXT_MAPPING(S_ISUID) \
DECLARE_CONTEXT_MAPPING(S_ISGID) \
DECLARE_CONTEXT_MAPPING(S_ISVTX) \
DECLARE_CONTEXT_MAPPING(DT_BLK) \
DECLARE_CONTEXT_MAPPING(DT_CHR) \
DECLARE_CONTEXT_MAPPING(DT_DIR) \
DECLARE_CONTEXT_MAPPING(DT_LNK) \
DECLARE_CONTEXT_MAPPING(DT_REG) \
DECLARE_CONTEXT_MAPPING(DT_WHT) \
DECLARE_CONTEXT_MAPPING(DT_WHT) \
DECLARE_CONTEXT_MAPPING(DT_FIFO) \
DECLARE_CONTEXT_MAPPING(DT_SOCK) \
DECLARE_CONTEXT_MAPPING(DT_UNKNOWN) \

```

`FridaScript/Runtime/Modules/IO/Types/DIR.h`:

```h
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#ifndef JSKERN_DIR_H
#define JSKERN_DIR_H

#import <Foundation/Foundation.h>
#import <JavaScriptCore/JavaScriptCore.h>

#include <dirent.h>

JSValue* buildDIR(DIR *directory);
DIR* buildBackDIR(JSValue *dirObject);
void updateDIR(DIR *directory, JSValue *dirObject);

#endif

```

`FridaScript/Runtime/Modules/IO/Types/DIR.m`:

```m
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#import <Runtime/Modules/IO/Types/DIR.h>
#import <Runtime/Modules/IO/Helper/NSStringCpy.h>
#import <Runtime/Modules/IO/Helper/UniOrigHolder.h>

JSValue* buildDIR(DIR *directory)
{
    JSValue *dirObject = [JSValue valueWithNewObjectInContext:[JSContext currentContext]];
    
    UniversalOriginalHolder *Holder = [[UniversalOriginalHolder alloc] init:directory];
    
    dirObject[@"__orig"] = [JSValue valueWithObject:Holder inContext:[JSContext currentContext]];
    dirObject[@"__dd_fd"] = @(directory->__dd_fd);
    dirObject[@"__dd_loc"] = @(directory->__dd_loc);
    dirObject[@"__dd_size"] = @(directory->__dd_size);
    dirObject[@"__dd_buf"] = @(directory->__dd_buf);
    dirObject[@"__dd_len"] = @(directory->__dd_len);
    dirObject[@"__dd_seek"] = @(directory->__dd_seek);
    dirObject[@"__padding"] = @(directory->__padding);
    dirObject[@"__dd_flags"] = @(directory->__dd_flags);
    
    return dirObject;
}

void updateDIR(DIR *directory, JSValue *dirObject)
{
    UniversalOriginalHolder *Holder = [[UniversalOriginalHolder alloc] init:directory];
    
    dirObject[@"__orig"] = [JSValue valueWithObject:Holder inContext:[JSContext currentContext]];
    dirObject[@"__dd_fd"] = @(directory->__dd_fd);
    dirObject[@"__dd_loc"] = @(directory->__dd_loc);
    dirObject[@"__dd_size"] = @(directory->__dd_size);
    dirObject[@"__dd_buf"] = @(directory->__dd_buf);
    dirObject[@"__dd_len"] = @(directory->__dd_len);
    dirObject[@"__dd_seek"] = @(directory->__dd_seek);
    dirObject[@"__padding"] = @(directory->__padding);
    dirObject[@"__dd_flags"] = @(directory->__dd_flags);
}


DIR* buildBackDIR(JSValue *dirObject)
{
    JSValue *holderValue = dirObject[@"__orig"];
    UniversalOriginalHolder *Holder = [holderValue toObject];
    return Holder.ptr;
}

```

`FridaScript/Runtime/Modules/IO/Types/Dirent.h`:

```h
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#ifndef JSKERN_DIRENT_H
#define JSKERN_DIRENT_H

#import <Foundation/Foundation.h>
#import <JavaScriptCore/JavaScriptCore.h>

#include <dirent.h>

JSValue* buildDirent(struct dirent Dirent);

#endif

```

`FridaScript/Runtime/Modules/IO/Types/Dirent.m`:

```m
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#import "Dirent.h"

JSValue* buildDirent(struct dirent Dirent)
{
    JSValue *direntObject = [JSValue valueWithNewObjectInContext:[JSContext currentContext]];
    
    direntObject[@"d_ino"] = @(Dirent.d_ino);
    direntObject[@"d_reclen"] = @(Dirent.d_reclen);
    direntObject[@"d_type"] = @(Dirent.d_type);
    direntObject[@"d_namlen"] = @(Dirent.d_namlen);
    direntObject[@"d_name"] = @(Dirent.d_name);
    
    return direntObject;
}

```

`FridaScript/Runtime/Modules/IO/Types/FILE.h`:

```h
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#ifndef JSKERN_FILE_H
#define JSKERN_FILE_H

#import <Foundation/Foundation.h>
#import <JavaScriptCore/JavaScriptCore.h>

#include <fcntl.h>

JSValue* buildFILE(FILE *file);
void updateFILE(FILE *file, JSValue *fileObject);
FILE* restoreFILE(JSValue *fileObject);

#endif

```

`FridaScript/Runtime/Modules/IO/Types/FILE.m`:

```m
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#import <Runtime/Modules/IO/Types/FILE.h>
#import <Runtime/Modules/IO/Helper/UniOrigHolder.h>
#import <Runtime/Modules/IO/Helper/NSStringCpy.h>

#import <Runtime/ErrorThrow.h>
#import <Runtime/ReturnObjBuilder.h>

JSValue* buildFILE(FILE *file)
{
    JSValue *fileObject = [JSValue valueWithNewObjectInContext:[JSContext currentContext]];
    
    UniversalOriginalHolder *Holder = [[UniversalOriginalHolder alloc] init:file];
    
    fileObject[@"__orig"] = [JSValue valueWithObject:Holder inContext:[JSContext currentContext]];
    fileObject[@"_p"] = [NSString stringWithFormat:@"%s", file->_p];
    fileObject[@"_r"] = @(file->_r);
    fileObject[@"_r"] = @(file->_w);
    fileObject[@"_flags"] = @(file->_flags);
    fileObject[@"_file"] = @(file->_file);
    
    JSValue *sbufObject = [JSValue valueWithNewObjectInContext:[JSContext currentContext]];
    sbufObject[@"_base"] = [NSString stringWithFormat:@"%s", file->_bf._base];
    sbufObject[@"_size"] = @(file->_bf._size);
    
    fileObject[@"_bf"] = sbufObject;
    fileObject[@"_lbfsize"] = @(file->_lbfsize);
    
    // who ever wanna implement cookie, have fun
    //fileObject[@"_cookie"] = @(file->_cookie);
    
    // close function
    fileObject[@"_close"] = ^JSValue* {
        // prevent crash
        if(file == NULL || file->_close == NULL)
        {
            return jsDoThrowError(@"Arguments invalid\n");
        }

        file->_close(file);
        
        return NULL;
    };
    
    fileObject[@"_read"] = ^id (UInt16 length) {
        // prevent crash
        if(file == NULL || file->_read == NULL)
        {
            return jsDoThrowError(@"Arguments invalid\n");
        }

        // calling function
        char *buffer = malloc(length);
        ssize_t bytesRead = file->_read(file, buffer, length);
        
        // returning
        return ReturnObjectBuilder(@{
            @"bytesRead": @(bytesRead),
            @"buffer": @(buffer),
        });
    };
    
    fileObject[@"_seek"] = ^id (UInt16 pos, UInt16 flags) {
        // prevent crash
        if(file == NULL || file->_read == NULL)
        {
            return jsDoThrowError(@"Arguments invalid\n");
        }
        
        fpos_t npos = file->_seek(file, pos, flags);
        
        // returning the new pos after you passed the flags and stuff
        return @(npos);
    };
    
    fileObject[@"_write"] = ^id (NSString *buffer, UInt16 size) {
        // prevent crash
        if(file == NULL || file->_write == NULL || buffer == NULL)
        {
            return jsDoThrowError(@"Arguments invalid\n");
        }
        
        // we need the buffer
        const char *ro_buffer = [buffer UTF8String];
        
        // writing thr buffer
        ssize_t bytesWritten = file->_write(file, ro_buffer, size);
        
        return @(bytesWritten);
    };
    
    // now lets continue with the rest of the structure
    JSValue *sbufSecondObject = [JSValue valueWithNewObjectInContext:[JSContext currentContext]];
    sbufSecondObject[@"_base"] = [NSString stringWithFormat:@"%s", file->_ub._base];
    sbufSecondObject[@"_size"] = @(file->_ub._size);
    
    fileObject[@"_ub"] = sbufSecondObject;
    
    /*
     @Note if you can implement __sFILEX, here is the place
     */
    //fileObject[@"_extra"] = @(file->_extra);
    
    fileObject[@"_ur"] = @(file->_ur);
    fileObject[@"_ubuf"] = [NSString stringWithFormat:@"%s", file->_ubuf];
    fileObject[@"_nbuf"] = [NSString stringWithFormat:@"%s", file->_nbuf];
    
    JSValue *sbufThirdObject = [JSValue valueWithNewObjectInContext:[JSContext currentContext]];
    sbufThirdObject[@"_base"] = [NSString stringWithFormat:@"%s", file->_lb._base];
    sbufThirdObject[@"_size"] = @(file->_lb._size);
    
    fileObject[@"_ub"] = sbufSecondObject;
    fileObject[@"_blksize"] = @(file->_blksize);
    
    fileObject[@"_offset"] = @(file->_offset);
    
    return fileObject;
}

void updateFILE(FILE *file, JSValue *fileObject)
{
    UniversalOriginalHolder *Holder = [[UniversalOriginalHolder alloc] init:file];
    
    fileObject[@"__orig"] = [JSValue valueWithObject:Holder inContext:[JSContext currentContext]];
    fileObject[@"_p"] = [NSString stringWithFormat:@"%s", file->_p];
    fileObject[@"_r"] = @(file->_r);
    fileObject[@"_r"] = @(file->_w);
    fileObject[@"_flags"] = @(file->_flags);
    fileObject[@"_file"] = @(file->_file);
    
    JSValue *sbufObject = [JSValue valueWithNewObjectInContext:[JSContext currentContext]];
    sbufObject[@"_base"] = [NSString stringWithFormat:@"%s", file->_bf._base];
    sbufObject[@"_size"] = @(file->_bf._size);
    
    fileObject[@"_bf"] = sbufObject;
    fileObject[@"_lbfsize"] = @(file->_lbfsize);
    
    // who ever wanna implement cookie, have fun
    //fileObject[@"_cookie"] = @(file->_cookie);
    
    // close function
    fileObject[@"_close"] = ^JSValue* {
        // prevent crash
        if(file == NULL || file->_close == NULL)
        {
            return jsDoThrowError(@"Arguments invalid\n");
        }

        file->_close(file);
        
        return NULL;
    };
    
    fileObject[@"_read"] = ^id (UInt16 length) {
        // prevent crash
        if(file == NULL || file->_read == NULL)
        {
            return jsDoThrowError(@"Arguments invalid\n");
        }

        // calling function
        char *buffer = malloc(length);
        ssize_t bytesRead = file->_read(file, buffer, length);
        
        // returning
        return ReturnObjectBuilder(@{
            @"bytesRead": @(bytesRead),
            @"buffer": @(buffer),
        });
    };
    
    fileObject[@"_seek"] = ^id (UInt16 pos, UInt16 flags) {
        // prevent crash
        if(file == NULL || file->_read == NULL)
        {
            return jsDoThrowError(@"Arguments invalid\n");
        }
        
        fpos_t npos = file->_seek(file, pos, flags);
        
        // returning the new pos after you passed the flags and stuff
        return @(npos);
    };
    
    fileObject[@"_write"] = ^id (NSString *buffer, UInt16 size) {
        // prevent crash
        if(file == NULL || file->_write == NULL || buffer == NULL)
        {
            return jsDoThrowError(@"Arguments invalid\n");
        }
        
        // we need the buffer
        const char *ro_buffer = [buffer UTF8String];
        
        // writing thr buffer
        ssize_t bytesWritten = file->_write(file, ro_buffer, size);
        
        return @(bytesWritten);
    };
    
    // now lets continue with the rest of the structure
    JSValue *sbufSecondObject = [JSValue valueWithNewObjectInContext:[JSContext currentContext]];
    sbufSecondObject[@"_base"] = [NSString stringWithFormat:@"%s", file->_ub._base];
    sbufSecondObject[@"_size"] = @(file->_ub._size);
    
    fileObject[@"_ub"] = sbufSecondObject;
    
    /*
     @Note if you can implement __sFILEX, here is the place
     */
    //fileObject[@"_extra"] = @(file->_extra);
    
    fileObject[@"_ur"] = @(file->_ur);
    fileObject[@"_ubuf"] = [NSString stringWithFormat:@"%s", file->_ubuf];
    fileObject[@"_nbuf"] = [NSString stringWithFormat:@"%s", file->_nbuf];
    
    JSValue *sbufThirdObject = [JSValue valueWithNewObjectInContext:[JSContext currentContext]];
    sbufThirdObject[@"_base"] = [NSString stringWithFormat:@"%s", file->_lb._base];
    sbufThirdObject[@"_size"] = @(file->_lb._size);
    
    fileObject[@"_ub"] = sbufSecondObject;
    fileObject[@"_blksize"] = @(file->_blksize);
    
    fileObject[@"_offset"] = @(file->_offset);
}

FILE* restoreFILE(JSValue *fileObject)
{
    JSValue *holderValue = fileObject[@"__orig"];
    UniversalOriginalHolder *Holder = [holderValue toObject];
    return Holder.ptr;
}

```

`FridaScript/Runtime/Modules/IO/Types/Stat.h`:

```h
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#ifndef JSKERN_STAT_H
#define JSKERN_STAT_H

#import <Foundation/Foundation.h>
#import <JavaScriptCore/JavaScriptCore.h>

JSValue* buildStat(struct stat statStruct);

#endif

```

`FridaScript/Runtime/Modules/IO/Types/Stat.m`:

```m
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#import <Runtime/Modules/IO/Types/Stat.h>
#import <sys/stat.h>

JSValue* buildStat(struct stat statStruct)
{
    JSValue *statObject = [JSValue valueWithNewObjectInContext:[JSContext currentContext]];
    
    JSValue *stATimespec = [JSValue valueWithNewObjectInContext:[JSContext currentContext]];
    stATimespec[@"tv_sec"] = @(statStruct.st_atimespec.tv_sec);
    stATimespec[@"tv_nsec"] = @(statStruct.st_atimespec.tv_nsec);
    
    JSValue *stMTimespec = [JSValue valueWithNewObjectInContext:[JSContext currentContext]];
    stMTimespec[@"tv_sec"] = @(statStruct.st_mtimespec.tv_sec);
    stMTimespec[@"tv_nsec"] = @(statStruct.st_mtimespec.tv_nsec);
    
    JSValue *stCTimespec = [JSValue valueWithNewObjectInContext:[JSContext currentContext]];
    stCTimespec[@"tv_sec"] = @(statStruct.st_ctimespec.tv_sec);
    stCTimespec[@"tv_nsec"] = @(statStruct.st_ctimespec.tv_nsec);
    
    JSValue *stBirthTimespec = [JSValue valueWithNewObjectInContext:[JSContext currentContext]];
    stBirthTimespec[@"tv_sec"] = @(statStruct.st_birthtimespec.tv_sec);
    stBirthTimespec[@"tv_nsec"] = @(statStruct.st_birthtimespec.tv_nsec);
    
    statObject[@"st_atimespec"] = stATimespec;
    statObject[@"st_mtimespec"] = stMTimespec;
    statObject[@"st_ctimespec"] = stCTimespec;
    statObject[@"st_birthtimespec"] = stBirthTimespec;
    statObject[@"st_blksize"] = @(statStruct.st_blksize);
    statObject[@"st_blocks"] = @(statStruct.st_blocks);
    statObject[@"st_ctimespec"] = @(statStruct.st_ctimespec.tv_sec);
    statObject[@"st_dev"] = @(statStruct.st_dev);
    statObject[@"st_flags"] = @(statStruct.st_flags);
    statObject[@"st_gen"] = @(statStruct.st_gen);
    statObject[@"st_gid"] = @(statStruct.st_gid);
    statObject[@"st_ino"] = @(statStruct.st_ino);
    statObject[@"st_lspare"] = @(statStruct.st_lspare);
    statObject[@"st_mode"] = @(statStruct.st_mode);
    statObject[@"st_mtimespec"] = @(statStruct.st_mtimespec.tv_sec);
    statObject[@"st_nlink"] = @(statStruct.st_nlink);
    
    // ToDo fix that please later, as it seems that this is not really compatible XD
    //statObject[@"st_qspare"] = @(statStruct.st_qspare);
    
    statObject[@"st_rdev"] = @(statStruct.st_rdev);
    statObject[@"st_size"] = @(statStruct.st_size);
    statObject[@"st_uid"] = @(statStruct.st_uid);
    
    return statObject;
}

```

`FridaScript/Runtime/Modules/MacroHelper.h`:

```h
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#define DECLARE_CONTEXT_MAPPING(name) \
    Runtime.Context[[NSString stringWithFormat:@"%s", #name]] = @(name);

```

`FridaScript/Runtime/Modules/Math/Math.h`:

```h
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#ifndef JS_MATH_H
#define JS_MATH_H

#import <Foundation/Foundation.h>
#import <JavaScriptCore/JavaScriptCore.h>

@protocol MathModuleExport <JSExport>

- (int)abs:(int)x;
- (int)sqrt:(int)x;
JSExportAs(pow,
- (double)pow:(double)x y:(double)y
);
- (double)sin:(double)x;
- (double)cos:(double)x;
- (double)tan:(double)x;
- (double)log:(double)x;
- (double)exp:(double)x;
- (double)floor:(double)x;
- (double)ceil:(double)x;
- (double)round:(double)x;
- (int)min:(int)x y:(int)y;
- (int)max:(int)x y:(int)y;
- (int)rand;

@end

@interface MathModule : NSObject <MathModuleExport>

@end

#endif

```

`FridaScript/Runtime/Modules/Math/Math.m`:

```m
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#import "Math.h"

@implementation MathModule

- (instancetype)init
{
    self = [super init];
    return self;
}

- (int)abs:(int)x
{
    return abs(x);
}

- (int)sqrt:(int)x
{
    return sqrt(x);
}

- (double)pow:(double)x y:(double)y
{
    return pow(x, y);
}

- (double)sin:(double)x
{
    return sin(x);
}

- (double)cos:(double)x
{
    return cos(x);
}

- (double)tan:(double)x
{
    return tan(x);
}

- (double)log:(double)x
{
    return log(x);
}

- (double)exp:(double)x
{
    return exp(x);
}

- (double)floor:(double)x
{
    return floor(x);
}

- (double)ceil:(double)x
{
    return ceil(x);
}

- (double)round:(double)x
{
    return round(x);
}

- (int)min:(int)x y:(int)y
{
    return (x < y) ? x : y;
}

- (int)max:(int)x y:(int)y
{
    return (x > y) ? x : y;
}

- (int)rand
{
    return rand();
}

@end

```

`FridaScript/Runtime/Modules/Memory/Memory.h`:

```h
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#ifndef FJ_MEMORY_H
#define FJ_MEMORY_H

#import <Foundation/Foundation.h>
#import <JavaScriptCore/JavaScriptCore.h>

@protocol MemoryModuleExport <JSExport>

/*
 @Brief low level memory handline
 */
- (UInt64)malloc:(size_t)size;
- (id)free:(UInt64)pointer;

/*
 @Brief low level memory read
 */
- (id)mread8:(UInt64)pointer;
- (id)mread16:(UInt64)pointer;
- (id)mread32:(UInt64)pointer;
- (id)mread64:(UInt64)pointer;

/*
 @Brief low level memory write
 */
JSExportAs(mwrite8,
- (id)mwrite8:(UInt64)pointer value:(UInt8)value
);
JSExportAs(mwrite16,
- (id)mwrite16:(UInt64)pointer value:(UInt16)value
);
JSExportAs(mwrite32,
- (id)mwrite32:(UInt64)pointer value:(UInt32)value
);
JSExportAs(mwrite64,
- (id)mwrite64:(UInt64)pointer value:(UInt64)value
);

@end

@interface MemoryModule : NSObject <MemoryModuleExport>

@property (nonatomic, strong) NSMutableArray<NSNumber *> *array;

- (NSString*)moduleCleanup;

@end


#endif

```

`FridaScript/Runtime/Modules/Memory/Memory.m`:

```m
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#import <Runtime/Modules/Memory/Memory.h>
#import <Runtime/ErrorThrow.h>

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

extern BOOL FJ_RUNTIME_SAFETY_ENABLED;

@implementation MemoryModule

- (instancetype)init
{
    self = [super init];
    _array = [[NSMutableArray alloc] init];
    return self;
}

- (NSString*)moduleCleanup
{
    NSString *buffer = @"";
    
    if(FJ_RUNTIME_SAFETY_ENABLED)
    {
        for (id item in _array) {
            buffer = [buffer stringByAppendingFormat:@"%@", [NSString stringWithFormat:@"Pointer %p was not freed, freeing it for you <3\n", (void*)[item unsignedLongLongValue]]];
            // if free fails then app crashes anyways
            free((void*)[item unsignedLongLongValue]);
        }
    }
    
    return buffer;
}

/*
 @Brief memory safety
 */
- (void)addPtr:(UInt64)pointer
{
    if(FJ_RUNTIME_SAFETY_ENABLED)
    {
        [_array addObject:[[NSNumber alloc] initWithUnsignedLongLong:pointer]];
    }
}

- (BOOL)isPtrThere:(UInt64)pointer
{
    if(FJ_RUNTIME_SAFETY_ENABLED)
    {
        return [_array containsObject:[[NSNumber alloc] initWithUnsignedLongLong:pointer]];
    }
    return true;
}

- (void)removePtr:(UInt64)pointer
{
    if(FJ_RUNTIME_SAFETY_ENABLED)
    {
        [_array removeObject:[[NSNumber alloc] initWithUnsignedLongLong:pointer]];
    }
}

/*
 @Brief Heap memory handling functions
 */
- (UInt64)malloc:(size_t)size
{
    UInt64 pointer;
    void *ptr = malloc(size);
    pointer = (UInt64)ptr;
    [self addPtr:pointer];
    return pointer;
}

- (id)free:(UInt64)pointer
{
    if(![self isPtrThere:pointer])
    {
        return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
    }
    
    void *ptr = (void*)pointer;
    free(ptr);
    
    [self removePtr:pointer];
    
    return NULL;
}

/*
 @Brief low level functions to read memory
 */
- (id)mread8:(UInt64)pointer
{
    if(![self isPtrThere:pointer])
    {
        return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
    }
    
    uint8_t *ptr = (uint8_t*)pointer;
    return [[NSNumber alloc] initWithUnsignedShort:*ptr];
}

- (id)mread16:(UInt64)pointer
{
    if(![self isPtrThere:pointer])
    {
        return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
    }
    
    uint16_t *ptr = (uint16_t*)pointer;
    return [[NSNumber alloc] initWithUnsignedInt:*ptr];
}

- (id)mread32:(UInt64)pointer
{
    if(![self isPtrThere:pointer])
    {
        return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
    }
    
    uint32_t *ptr = (uint32_t*)pointer;
    return [[NSNumber alloc] initWithUnsignedLong:*ptr];
}

- (id)mread64:(UInt64)pointer
{
    if(![self isPtrThere:pointer])
    {
        return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
    }
    
    uint64_t *ptr = (uint64_t*)pointer;
    return [[NSNumber alloc] initWithUnsignedLong:*ptr];
}

/*
 @Brief low level functions to write memory
 */
- (id)mwrite8:(UInt64)pointer value:(UInt8)value
{
    if(![self isPtrThere:pointer])
    {
        return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
    }
    
    uint8_t *ptr = (uint8_t*)pointer;
    *ptr = value;
    
    return NULL;
}

- (id)mwrite16:(UInt64)pointer value:(UInt16)value
{
    if(![self isPtrThere:pointer])
    {
        return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
    }
    
    uint16_t *ptr = (uint16_t*)pointer;
    *ptr = value;
    
    return NULL;
}

- (id)mwrite32:(UInt64)pointer value:(UInt32)value
{
    if(![self isPtrThere:pointer])
    {
        return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
    }
    
    uint32_t *ptr = (uint32_t*)pointer;
    *ptr = value;
    
    return NULL;
}

- (id)mwrite64:(UInt64)pointer value:(UInt64)value
{
    if(![self isPtrThere:pointer])
    {
        return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
    }
    
    uint64_t *ptr = (uint64_t*)pointer;
    *ptr = value;
    
    return NULL;
}

@end

```

`FridaScript/Runtime/Modules/Proc/Proc.h`:

```h
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#ifndef MODULE_PROC_H
#define MODULE_PROC_H

#import <Foundation/Foundation.h>
#import <JavaScriptCore/JavaScriptCore.h>

@protocol ProcModuleExport <JSExport>

- (UInt32)getpid;
- (UInt32)getppid;
- (UInt32)getuid;
- (UInt32)geteuid;
- (UInt32)getgid;
- (UInt32)getegid;
- (id)setuid:(UInt32)uid;
- (id)setgid:(UInt32)gid;
- (UInt32)getpgid:(UInt32)pid;
JSExportAs(setpgid,
           - (id)setpgid:(UInt32)pid pgid:(UInt32)pgid
           );

@end

@interface ProcModule : NSObject <ProcModuleExport>

@end

#endif

```

`FridaScript/Runtime/Modules/Proc/Proc.m`:

```m
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#import <Runtime/Modules/Proc/Proc.h>
#import <Runtime/ErrorThrow.h>

#include <unistd.h>

extern BOOL FJ_RUNTIME_SAFETY_ENABLED;

@implementation ProcModule

- (instancetype)init
{
    self = [super init];
    return self;
}

- (UInt32)getpid
{
    return getpid();
}

- (UInt32)getppid
{
    return getppid();
}

- (UInt32)getuid
{
    return getuid();
}

- (UInt32)geteuid
{
    return geteuid();
}

- (UInt32)getgid
{
    return getgid();
}

- (UInt32)getegid
{
    return getegid();
}

- (UInt32)getpgid:(UInt32)pid
{
    return getpgid(pid);
}

- (id)setuid:(UInt32)uid
{
    if(!FJ_RUNTIME_SAFETY_ENABLED) { return @(setuid(uid)); }
    return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
}

- (id)setgid:(UInt32)gid
{
    if(!FJ_RUNTIME_SAFETY_ENABLED) { return @(setgid(gid)); }
    return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
}

- (id)setpgid:(UInt32)pid pgid:(UInt32)pgid
{
    if(!FJ_RUNTIME_SAFETY_ENABLED) { return @(setpgid(pid, pgid)); }
    return JS_THROW_ERROR(EW_RUNTIME_SAFETY);
}

@end

```

`FridaScript/Runtime/Modules/String/String.h`:

```h
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#ifndef JSKERN_STRING_H
#define JSKERN_STRING_H

#import <Foundation/Foundation.h>
#import <JavaScriptCore/JavaScriptCore.h>

@protocol StringModuleExport <JSExport>

- (id)strlen:(NSString*)string;

@end

@interface StringModule : NSObject <StringModuleExport>

- (instancetype)init;

@end

#endif

```

`FridaScript/Runtime/Modules/String/String.m`:

```m
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#import <Runtime/Modules/String/String.h>
#import <Runtime/ErrorThrow.h>

#include <string.h>

@implementation StringModule

- (instancetype)init
{
    self = [super init];
    return self;
}

- (id)strlen:(NSString*)string
{
    if(!string)
    {
        return jsDoThrowError(@"Arguments invalid");
    }
    
    const char *cstring = [string UTF8String];
    if (cstring == NULL) {
        return jsDoThrowError(@"Failed to convert string");
    }
    
    return [[NSNumber alloc] initWithUnsignedLong:strlen(cstring)];
}

@end

```

`FridaScript/Runtime/ReturnObjBuilder.h`:

```h
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#ifndef RETOBJBUILD_H
#define RETOBJBUILD_H

#import <Foundation/Foundation.h>
#import <JavaScriptCore/JavaScriptCore.h>

JSValue *ReturnObjectBuilder(NSDictionary *dictionary);

#endif

```

`FridaScript/Runtime/ReturnObjBuilder.m`:

```m
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#import <Runtime/ReturnObjBuilder.h>

JSValue *ReturnObjectBuilder(NSDictionary *dictionary) {
    JSContext *context = [JSContext currentContext];
    if (context == nil || dictionary == nil) {
        return nil;
    }

    JSValue *jsObject = [JSValue valueWithObject:@{} inContext:context];

    for (NSString *key in dictionary) {
        id value = dictionary[key];
        JSValue *jsValue = [JSValue valueWithObject:value inContext:context];
        [jsObject setValue:jsValue forProperty:key];
    }

    return jsObject;
}

```

`FridaScript/Runtime/Runtime.h`:

```h
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#ifndef FJS_RUNTIME_H
#define FJS_RUNTIME_H

#import <Foundation/Foundation.h>
#import <JavaScriptCore/JavaScriptCore.h>
#import <UIKit/UIKit.h>
#include <pthread.h>

@interface FJ_Runtime : NSObject

@property (nonatomic,strong,readonly) JSContext *Context;
@property (nonatomic,readonly) pthread_t Thread;

// Main Runtime functions you should focus on
- (instancetype)init:(UIView*)ptr;
- (void)run:(NSString*)code;

// Module Handoff
- (void)handoffIOModule:(id)object;
- (void)handoffMemoryModule:(id)object;
- (void)tuirun:(NSString*)code;
- (void)cleanup;

@end

@interface JSContext ()

@property (nonatomic,strong) FJ_Runtime *fj_runtime;

@end

#endif

```

`FridaScript/Runtime/Runtime.m`:

```m
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#import <Runtime/Runtime.h>
#import <Runtime/Include.h>
#import <FridaScript-Swift.h>

// modules for clean init
#import <Runtime/Modules/IO/IO.h>
#import <Runtime/Modules/Memory/Memory.h>

extern bool FJ_RUNTIME_SAFETY_ENABLED;

@interface FJ_Runtime ()

@property (nonatomic,strong) TerminalWindow *Serial;

@property (nonatomic,strong) IOModule *ioModule;
@property (nonatomic,strong) MemoryModule *memoryModule;

@end

@implementation FJ_Runtime

- (instancetype)init:(UIView*)ptr
{
    self = [super init];
    FJ_RUNTIME_SAFETY_ENABLED = true;
    _Serial = (TerminalWindow*)ptr;
    _Context = [[JSContext alloc] init];
    _ioModule = NULL;
    _memoryModule = NULL;
    add_include_symbols(self, ptr);
    return self;
}

- (void)run:(NSString*)code {
    // Initial run
    __block TerminalWindow *BlockSerial = _Serial;
    _Context.exceptionHandler = ^(JSContext *context, JSValue *exception) {
        dispatch_sync(dispatch_get_main_queue(), ^{
            BlockSerial.terminalText.text = [BlockSerial.terminalText.text stringByAppendingFormat:@"\nFridaScript Error: %@", exception];
        });
    };
    [_Context evaluateScript:code];
    
    // Module Cleanup on condition
    dispatch_sync(dispatch_get_main_queue(), ^{
        BlockSerial.terminalText.text = [BlockSerial.terminalText.text stringByAppendingFormat:@"\nRUNTIME END\n[Module Cleanup]\n"];
    });
    if(_ioModule != NULL)
    {
        __block NSString *buffer = [_ioModule moduleCleanup];
        dispatch_sync(dispatch_get_main_queue(), ^{
            BlockSerial.terminalText.text = [BlockSerial.terminalText.text stringByAppendingFormat:@"%@", buffer];
        });
    }
    if(_memoryModule != NULL)
    {
        __block NSString *buffer = [_memoryModule moduleCleanup];
        dispatch_sync(dispatch_get_main_queue(), ^{
            BlockSerial.terminalText.text = [BlockSerial.terminalText.text stringByAppendingFormat:@"%@", buffer];
        });
    }
    dispatch_sync(dispatch_get_main_queue(), ^{
        BlockSerial.terminalText.text = [BlockSerial.terminalText.text stringByAppendingFormat:@"[EXIT]\n"];
    });
    
    // Hope ARC will clean JSContext
    _Context = nil;
}

- (void)tuirun:(NSString*)code {
    // Initial TUI run
    __block TerminalWindow *BlockSerial = _Serial;
    _Context.exceptionHandler = ^(JSContext *context, JSValue *exception) {
        dispatch_sync(dispatch_get_main_queue(), ^{
            BlockSerial.terminalText.text = [BlockSerial.terminalText.text stringByAppendingFormat:@"\n%@\n", exception];
        });
    };
    [_Context evaluateScript:code];
}

- (void)cleanup
{
    __block TerminalWindow *BlockSerial = _Serial;
    // Module Cleanup on condition
    dispatch_sync(dispatch_get_main_queue(), ^{
        BlockSerial.terminalText.text = [BlockSerial.terminalText.text stringByAppendingFormat:@"\nRUNTIME END\n[Module Cleanup]\n"];
    });
    if(_ioModule != NULL)
    {
        __block NSString *buffer = [_ioModule moduleCleanup];
        dispatch_sync(dispatch_get_main_queue(), ^{
            BlockSerial.terminalText.text = [BlockSerial.terminalText.text stringByAppendingFormat:@"%@", buffer];
        });
    }
    if(_memoryModule != NULL)
    {
        __block NSString *buffer = [_memoryModule moduleCleanup];
        dispatch_sync(dispatch_get_main_queue(), ^{
            BlockSerial.terminalText.text = [BlockSerial.terminalText.text stringByAppendingFormat:@"%@", buffer];
        });
    }
    dispatch_sync(dispatch_get_main_queue(), ^{
        BlockSerial.terminalText.text = [BlockSerial.terminalText.text stringByAppendingFormat:@"[EXIT]\n"];
    });
    
    // Hope ARC will clean JSContext
    _Context = nil;
}

/*
 @Brief handoff functions
 */
- (void)handoffIOModule:(id)object
{
    _ioModule = object;
}

- (void)handoffMemoryModule:(id)object
{
    _memoryModule = object;
}

@end

```

`FridaScript/Runtime/Safety.m`:

```m
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#import <Foundation/Foundation.h>

BOOL FJ_RUNTIME_SAFETY_ENABLED;

void setFJSafety(BOOL value)
{
    FJ_RUNTIME_SAFETY_ENABLED = value;
}

```

`FridaScript/UI/CLI.swift`:

```swift
//
//  CLI.swift
//  FJS
//
//  Created by fridakitten on 17.03.25.
//

import SwiftUI
import UIKit

func clireadline(cli: TerminalWindow, prompt: String) -> String
{
    usleep(1);
    let semaphore = DispatchSemaphore(value: 0)
    var capture: String = ""
    DispatchQueue.main.async {
        cli.terminalText.text.append(prompt)
        cli.setInput { character in
            cli.terminalText.text.append(character)
            if character == "\n" {
                semaphore.signal()
                return
            }
            capture.append(character)
        }
        cli.setDeletion { _ in
            if !capture.isEmpty {
                cli.terminalText.text.removeLast()
                capture.removeLast()
            }
        }
    }
    
    semaphore.wait()
    
    DispatchQueue.main.async {
        cli.setInput { _ in }
        cli.setDeletion { _ in }
    }
    
    return capture
}

struct CLIView: UIViewRepresentable {
    var view: TerminalWindow
    let runtime: FJ_Runtime
    var code: String = ""
    
    init() {
        self.code = ""
        self.view = TerminalWindow()
        self.runtime = FJ_Runtime(self.view)
    }
    
    func makeUIView(context: Context) -> UIView {
        let view = UIView()
        
        let terminalView = self.view
        terminalView.frame = view.bounds
        terminalView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
        view.addSubview(terminalView)
        
        DispatchQueue.global(qos: .utility).async {
            while true
            {
                let input = clireadline(cli: terminalView, prompt: "$ ")
                if(input != "exit")
                {
                    self.runtime.tuirun(input)
                } else {
                    break;
                }
            }
            self.runtime.cleanup()
        }
        
        return view
    }

    func updateUIView(_ uiView: UIView, context: Context) {}
}

```

`FridaScript/UI/CodeEditor.swift`:

```swift
/*
UICodeEditor.swift
 
Copyright (C) 2024 fridakitten

This file is part of JSTerm.

FridaCodeManager is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

FridaCodeManager is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with FridaCodeManager. If not, see <https://www.gnu.org/licenses/>.

 ______    _     _         _____        __ _                           ______                    _       _   _
|  ___|  (_)   | |       /  ___|      / _| |                          |  ___|                  | |     | | (_)
| |_ _ __ _  __| | __ _  \ `--.  ___ | |_| |___      ____ _ _ __ ___  | |_ ___  _   _ _ __   __| | __ _| |_ _  ___  _ __
|  _| '__| |/ _` |/ _` |  `--. \/ _ \|  _| __\ \ /\ / / _` | '__/ _ \ |  _/ _ \| | | | '_ \ / _` |/ _` | __| |/ _ \| '_ \
| | | |  | | (_| | (_| | /\__/ / (_) | | | |_ \ V  V / (_| | | |  __/ | || (_) | |_| | | | | (_| | (_| | |_| | (_) | | | |
\_| |_|  |_|\__,_|\__,_| \____/ \___/|_|  \__| \_/\_/ \__,_|_|  \___| \_| \___/ \__,_|_| |_|\__,_|\__,_|\__|_|\___/|_| |_|
Founded by. Sean Boleslawski, Benjamin Hornbeck and Lucienne Salim in 2023
*/

// MARK: Code Editor
import SwiftUI
import UIKit
import Foundation

struct NeoEditorHelper: View {
    @Binding var isPresented: Bool
    @Binding var filepath: String
    @State var ready: Bool = false

    var body: some View {
        Group {
            if ready {
                NavigationBarViewControllerRepresentable(isPresented: $isPresented, filepath: filepath)
                    .edgesIgnoringSafeArea(.all)
            }
        }
        .onAppear {
            ready = true
        }
    }
}

// caches for toolbar v2
var highlightLayerCache: [CAShapeLayer] = []
var toolbarItemCache: [UIBarButtonItem] = []

// configuration for NeoEditor
struct NeoEditorConfig {
    var background: UIColor
    var selection: UIColor
    var current: UIColor
    var standard: UIColor
    var font: UIFont
}

// restore class
struct NavigationBarViewControllerRepresentable: UIViewControllerRepresentable {
    @Binding var isPresented: Bool
    var filepath: String

    var title: String
    var backgroundColor: UIColor = UIColor.systemGray6
    var tintColor: UIColor = UIColor.label

    let textView: CustomTextView = CustomTextView()

    private var filename: String
    private let config: NeoEditorConfig = {
        let userInterfaceStyle = UIScreen.main.traitCollection.userInterfaceStyle

        var meow: NeoEditorConfig = NeoEditorConfig(background: UIColor.clear, selection: UIColor.clear, current: UIColor.clear, standard: UIColor.clear, font: UIFont.systemFont(ofSize: 10.0))

        meow.font = UIFont.monospacedSystemFont(ofSize: CGFloat(UserDefaults.standard.double(forKey: "CEFontSize")), weight: UIFont.Weight.medium)

        if userInterfaceStyle == .light {
            meow.background = light_background
            meow.selection = light_selection
            meow.current = light_current
            meow.standard = light_standard
        } else {
            meow.background = dark_background
            meow.selection = dark_selection
            meow.current = dark_current
            meow.standard = dark_standard
        }

        return meow
    }()

    init(
        isPresented: Binding<Bool>,
        filepath: String
    ) {
        _isPresented = isPresented
        self.filepath = filepath
        self.filename = {
            let fileURL = URL(fileURLWithPath: filepath)
            return fileURL.lastPathComponent
        }()
        self.title = filename
    }

    func makeUIViewController(context: Context) -> UINavigationController {
        let hostingController = UIHostingController(rootView: NeoEditor(isPresented: $isPresented, filepath: filepath, textView: textView, config: config))
        hostingController.view.backgroundColor = config.background
        let navigationController = UINavigationController(rootViewController: hostingController)
        let navigationBar = navigationController.navigationBar
        navigationBar.prefersLargeTitles = false
        navigationBar.backgroundColor = backgroundColor
        navigationBar.tintColor = tintColor

        let appearance = UINavigationBarAppearance()
        appearance.configureWithOpaqueBackground()
        appearance.backgroundColor = backgroundColor
        appearance.titleTextAttributes = [.foregroundColor: tintColor]
        appearance.largeTitleTextAttributes = [.foregroundColor: tintColor]

        navigationBar.standardAppearance = appearance
        navigationBar.scrollEdgeAppearance = appearance

        let saveButton = ClosureBarButtonItem(title: "Save", style: .plain) {
            textView.endEditing(true)
            let fileURL = URL(fileURLWithPath: filepath)
            do {
                try textView.text.write(to: fileURL, atomically: true, encoding: .utf8)
            } catch {
            }
        }

        let closeButton = ClosureBarButtonItem(title: "Close", style: .plain) {
            textView.endEditing(true)
            isPresented = false
        }

        hostingController.navigationItem.rightBarButtonItem = saveButton
        hostingController.navigationItem.leftBarButtonItem = closeButton

        return navigationController
    }

    func updateUIViewController(_ uiViewController: UINavigationController, context: Context) {
        uiViewController.navigationBar.topItem?.title = title
        uiViewController.navigationBar.backgroundColor = backgroundColor
        uiViewController.navigationBar.tintColor = tintColor
    }
}

struct NeoEditor: UIViewRepresentable {
    private let containerView: UIView
    private let textView: CustomTextView
    private let highlightRules: [HighlightRule]
    private let filepath: String
    private let filename: String
    private let toolbar: UIToolbar

    private let config: NeoEditorConfig

    @Binding private var sheet: Bool

    @AppStorage("CERender") var render: Double = 1.0
    @AppStorage("CEFontSize") var font: Double = 13.0
    @AppStorage("CEToolbar") var enableToolbar: Bool = true
    @AppStorage("CECurrentLineHighlighting") var current_line_highlighting: Bool = false
    @AppStorage("CEHighlightCache") var cachehighlightings: Bool = false

    init(
        isPresented: Binding<Bool>,
        filepath: String,
        textView: CustomTextView,
        config: NeoEditorConfig
    ) {
        _sheet = isPresented

        self.filepath = filepath
        self.filename = {
            let fileURL = URL(fileURLWithPath: filepath)
            return fileURL.lastPathComponent
        }()

        self.highlightRules = grule(gsuffix(from: filename))
        self.containerView = UIView()
        self.textView = textView
        self.toolbar = UIToolbar()
        self.config = config
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }

    func makeUIView(context: Context) -> UIView {
        textView.text = {
            do {
                return try String(contentsOfFile: filepath)
            } catch {
                sheet = false
                return ""
            }
        }()
        textView.delegate = context.coordinator
        context.coordinator.applyHighlighting(to: textView, with: NSRange(location: 0, length: textView.text.utf16.count))
        context.coordinator.runIntrospect(textView)

        textView.translatesAutoresizingMaskIntoConstraints = false

        containerView.addSubview(textView)

        NSLayoutConstraint.activate([
            textView.topAnchor.constraint(equalTo: containerView.topAnchor),
            textView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor),
            textView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor),
            textView.bottomAnchor.constraint(equalTo: containerView.bottomAnchor)
        ])

        textView.backgroundColor = config.background
        textView.tintColor = config.selection
        textView.textColor = config.standard
        textView.lineLight = config.current.cgColor
        if current_line_highlighting {
            textView.setupHighlightLayer()
        }
        textView.keyboardType = .asciiCapable
        textView.textContentType = .none
        textView.smartQuotesType = .no
        textView.smartDashesType = .no
        textView.smartInsertDeleteType = .no
        textView.autocorrectionType = .no
        textView.autocapitalizationType = .none
        textView.layoutManager.allowsNonContiguousLayout = true
        textView.layer.shouldRasterize = true
        textView.layer.rasterizationScale = UIScreen.main.scale * CGFloat(render)
        textView.isUserInteractionEnabled = true
        textView.layoutManager.addTextContainer(textView.textContainer)
        textView.layoutManager.ensureLayout(for: textView.textContainer)

        var claimed: [Int] = []

        if enableToolbar {
            setupToolbar(textView: textView)
        }

        return containerView
    }

    func setupToolbar(textView: UITextView) {
        toolbar.sizeToFit()
        let tabButton = ClosureButton(title: "Tab") {
            insertTextAtCurrentPosition(textView: textView, newText: "\t")
        }

        let flexibleSpace = UIBarButtonItem(barButtonSystemItem: .flexibleSpace, target: nil, action: nil)

        let action1 = UIAction(title: "Go To Line", image: UIImage(systemName: "arrow.right")) { _ in
            toolbarItemCache = toolbar.items ?? []

            self.animateToolbarItemsDisappearance {
                let textField = UITextField()
                textField.text = ""
                textField.placeholder = "Line number to jump to"
                textField.borderStyle = .roundedRect
                textField.keyboardType = .asciiCapable
                textField.textContentType = .none
                textField.smartQuotesType = .no
                textField.smartDashesType = .no
                textField.smartInsertDeleteType = .no
                textField.autocorrectionType = .no
                textField.autocapitalizationType = .none
                let doneButton = ClosureButton(title: "Cancel") {
                    self.animateToolbarItemsDisappearance {
                        self.restoreToolbarItems()
                    }
                }
                let gotoButton = ClosureButton(title: "Goto") {
                    guard let lineNumber = Int(textField.text ?? "n/a") else { return }
                    guard let textView = textView as? CustomTextView else { return }
                    guard let askedRange: NSRange = textView.rangeOfLine(lineNumber: lineNumber - 1) else { return }
                    guard let rect: CGRect = visualRangeRect(in: textView, for: askedRange) else { return }
                    setSelectedTextRange(for: textView, with: askedRange)
                    textView.scrollRangeToVisible(askedRange)
                    guard let highlight: CAShapeLayer = textView.addPath(color: UIColor.yellow.withAlphaComponent(0.3), rect: rect, entirePath: false, radius: 4.0) else { return }
                    let animation = CABasicAnimation(keyPath: "opacity")
                    animation.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeOut)
                    animation.fillMode = CAMediaTimingFillMode.forwards
                    animation.isRemovedOnCompletion = false
                    animation.fromValue = 1.0
                    animation.toValue = 0.0
                    animation.duration = 1.5
                    highlight.add(animation, forKey: nil)
                    DispatchQueue.main.asyncAfter(deadline: .now() + animation.duration) {
                        highlight.removeFromSuperlayer()
                    }
                    self.animateToolbarItemsDisappearance {
                        self.restoreToolbarItems()
                    }
                }
                let doneBarButtonItem = UIBarButtonItem(customView: doneButton)
                let gotoBarButtonItem = UIBarButtonItem(customView: gotoButton)
                let textBarButtonItem = UIBarButtonItem(customView: textField)
                let flexibleSpace = UIBarButtonItem(barButtonSystemItem: .flexibleSpace, target: nil, action: nil)
                restoreToolbarItems(with: [doneBarButtonItem, flexibleSpace, textBarButtonItem, flexibleSpace, gotoBarButtonItem])
            }
        }

        let action2 = UIAction(title: "Search String", image: UIImage(systemName: "magnifyingglass")) { _ in
            toolbarItemCache = toolbar.items ?? []
            self.animateToolbarItemsDisappearance {
                let textField = UITextField()
                textField.text = ""
                textField.placeholder = "String to search"
                textField.borderStyle = .roundedRect
                textField.keyboardType = .asciiCapable
                textField.textContentType = .none
                textField.smartQuotesType = .no
                textField.smartDashesType = .no
                textField.smartInsertDeleteType = .no
                textField.autocorrectionType = .no
                textField.autocapitalizationType = .none
                let doneButton = ClosureButton(title: "Close") {
                    if !highlightLayerCache.isEmpty {
                        for item in highlightLayerCache {
                            item.removeFromSuperlayer()
                        }
                    }
                    self.animateToolbarItemsDisappearance {
                        self.restoreToolbarItems()
                    }
                }
                let searchButton = ClosureButton(title: "Search") {
                    guard let string = textField.text else { return }
                    guard let textView = textView as? CustomTextView else { return }
                    if !highlightLayerCache.isEmpty {
                        for item in highlightLayerCache {
                            item.removeFromSuperlayer()
                        }
                    }
                    let nsranges: [NSRange] = findRanges(of: string, in: textView.text)
                    for item in nsranges {
                        if let rect = visualRangeRect(in: textView, for: item) {
                            let layer = textView.addPath(color: UIColor.yellow.withAlphaComponent(0.3), rect: rect, entirePath: false, radius: 4.0)
                            if let layer = layer {
                                highlightLayerCache.append(layer)
                            }
                        }
                    }
                }
                let doneBarButtonItem = UIBarButtonItem(customView: doneButton)
                let gotoBarButtonItem = UIBarButtonItem(customView: searchButton)
                let textBarButtonItem = UIBarButtonItem(customView: textField)
                let flexibleSpace = UIBarButtonItem(barButtonSystemItem: .flexibleSpace, target: nil, action: nil)
                restoreToolbarItems(with: [doneBarButtonItem, flexibleSpace, textBarButtonItem, flexibleSpace, gotoBarButtonItem])
            }
        }

        let menu = UIMenu(title: "Tools", children: [action2, action1])
        let menuButton = UIButton(type: .system)
        menuButton.tintColor = UIColor.label
        menuButton.setTitle("Tools", for: .normal)
        menuButton.menu = menu
        menuButton.showsMenuAsPrimaryAction = true
        let menuBarButtonItem = UIBarButtonItem(customView: menuButton)
        let TabBarButtonItem = UIBarButtonItem(customView: tabButton)
        toolbar.items = [TabBarButtonItem, flexibleSpace, menuBarButtonItem]
        textView.inputAccessoryView = toolbar
    }

    func animateToolbarItemsDisappearance(completion: @escaping () -> Void) {
        guard let items = toolbar.items else { return }
        let fadeOutDuration: TimeInterval = 0.3
        UIView.animate(withDuration: fadeOutDuration, animations: {
            for item in items {
                item.customView?.alpha = 0.0
            }
        }) { _ in
            self.toolbar.items = []
            completion()
        }
    }

    func restoreToolbarItems(with cache: [UIBarButtonItem] = toolbarItemCache) {
        toolbar.items = cache
        guard let items = toolbar.items else { return }
        let fadeInDuration: TimeInterval = 0.3
        for item in items {
            item.customView?.alpha = 0.0
        }
        UIView.animate(withDuration: fadeInDuration) {
            for item in items {
                item.customView?.alpha = 1.0
            }
        }
    }

    func insertTextAtCurrentPosition(textView: UITextView, newText: String) {
        if let selectedRange = textView.selectedTextRange {
            textView.replace(selectedRange, withText: newText)
        }
    }

    func updateUIView(_ uiView: UIView, context: Context) { }

    final class Coordinator: NSObject, UITextViewDelegate {
        var parent: NeoEditor
        private var highlightCache: [NSRange: [NSAttributedString.Key: Any]] = [:]

        init(_ markdownEditorView: NeoEditor) {
            self.parent = markdownEditorView
        }

        func runIntrospect(_ textView: UITextView) {
            textView.font = parent.config.font
        }

        func textViewDidChange(_ textView: UITextView) {
            guard let textView = textView as? CustomTextView else { return }

            if textView.didPasted {
                self.applyHighlighting(to: textView, with: NSRange(location: 0, length: textView.text.utf16.count))
                textView.didPasted = false
            } else {
                self.applyHighlighting(to: textView, with: textView.cachedLineRange ?? NSRange(location: 0, length: 0))
            }
        }

        func applyHighlighting(to textView: UITextView, with visibleRange: NSRange) {
            let text = textView.text ?? ""

            DispatchQueue.global(qos: .userInitiated).async {
                var attributesToApply = [(NSRange, NSAttributedString.Key, Any)]()
                self.parent.highlightRules.forEach { rule in
                    let matches = rule.pattern.matches(in: text, options: [], range: visibleRange)
                    matches.forEach { match in
                        let matchRange = match.range
                        if let cachedAttributes = self.highlightCache[matchRange] {
                            for (key, value) in cachedAttributes {
                                attributesToApply.append((matchRange, key, value))
                            }
                            return
                        }
                        let isOverlapping = attributesToApply.contains { (range, _, _) in
                            NSIntersectionRange(range, matchRange).length > 0
                        }
                        guard !isOverlapping else { return }
                        rule.formattingRules.forEach { formattingRule in
                            guard let key = formattingRule.key,
                                  let calculateValue = formattingRule.calculateValue else { return }
                            if let matchRangeStr = Range(match.range, in: text) {
                                let matchContent = String(text[matchRangeStr])
                                let value = calculateValue(matchContent, matchRangeStr)
                                if self.parent.cachehighlightings {
                                    self.highlightCache[matchRange] = [key: value]
                                }
                                attributesToApply.append((match.range, key, value))
                            }
                        }
                    }
                }
                DispatchQueue.main.async {
                    textView.textStorage.beginEditing()
                    textView.textStorage.addAttribute(.foregroundColor, value: self.parent.config.standard, range: visibleRange)
                    attributesToApply.forEach { (range, key, value) in
                        textView.textStorage.addAttribute(key, value: value, range: range)
                    }
                    textView.textStorage.endEditing()
                }
            }
        }

        func textViewDidBeginEditing(_ textView: UITextView) {
            guard let textView = textView as? CustomTextView else { return }
            textView.enableHighlightLayer()
        }

        func textViewDidEndEditing(_ textView: UITextView) {
            guard let textView = textView as? CustomTextView else { return }
            textView.disableHighlightLayer()
        }
    }
}

class CustomTextView: UITextView {
    var didPasted: Bool = false
    var lineLight: CGColor = UIColor.clear.cgColor

    private(set) var hightlight_setuped: Bool = false
    private(set) var cachedLineRange: NSRange?
    private var wempty: Bool = false
    private let highlightLayer = CAShapeLayer()
    var highlightTMPLayer: [CAShapeLayer] = []
    var buttonTMPLayer: [UIButton] = []

    override func paste(_ sender: Any?) {
        didPasted = true
        super.paste(sender)
    }

    override func caretRect(for position: UITextPosition) -> CGRect {
        let caretRect = super.caretRect(for: position)
        updateCurrentLineRange()
        return caretRect
    }

    func setupHighlightLayer() {
        highlightLayer.fillColor = lineLight
        layer.insertSublayer(highlightLayer, at: 0)
        hightlight_setuped = true
    }

    private func updateCurrentLineRange() {
        guard let caretPosition = selectedTextRange?.start else {
            return
        }

        let caretIndex = offset(from: beginningOfDocument, to: caretPosition)
        let text = self.text as NSString
        let lineRange = text.lineRange(for: NSRange(location: caretIndex, length: 0))

        cachedLineRange = lineRange

        if hightlight_setuped {
            updateHighlightLayer()
        }
    }

    private func updateHighlightLayer() {
        guard let currentLineRange = cachedLineRange else {
            highlightLayer.path = nil
            return
        }

        let path = UIBezierPath()

        layoutManager.enumerateLineFragments(forGlyphRange: currentLineRange) { (rect, usedRect, _, glyphRange, _) in
            let textRect = usedRect.offsetBy(dx: self.textContainerInset.left, dy: self.textContainerInset.top)
            path.append(UIBezierPath(roundedRect: textRect, cornerRadius: 4.0))
        }

        animateHighlightLayer(from: highlightLayer.path, to: path.cgPath)

        highlightLayer.path = path.cgPath
    }

    private func animateHighlightLayer(from oldPath: CGPath?, to newPath: CGPath) {
        let animation = CABasicAnimation(keyPath: "path")
        animation.duration = 0.25

        animation.toValue = newPath
        animation.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeOut)
        animation.fillMode = CAMediaTimingFillMode.forwards
        animation.isRemovedOnCompletion = false

        if newPath.boundingBox.isEmpty && !wempty {
            animation.keyPath = "opacity"
            animation.fromValue = 1.0
            animation.toValue = 0.0
            animation.duration = 0.50
            wempty = true
            highlightLayer.add(animation, forKey: nil)
        } else if wempty && !newPath.boundingBox.isEmpty {
            animation.keyPath = "opacity"
            animation.fromValue = 0.0
            animation.toValue = 1.0
            animation.duration = 0.50
            wempty = false
        }

        if wempty {
            return
        }

        highlightLayer.add(animation, forKey: nil)
    }

    func enableHighlightLayer() {
        if hightlight_setuped {
            setupHighlightLayer()
        }
    }

    func disableHighlightLayer() {
        if hightlight_setuped {
            highlightLayer.removeFromSuperlayer()
        }
    }

    func rangeOfLine(lineNumber: Int) -> NSRange? {
        let nsString = self.text as NSString
        let lines = nsString.components(separatedBy: .newlines)
        guard lineNumber >= 0 && lineNumber < lines.count else {
            return nil
        }
        var location = 0
        for i in 0..<lineNumber {
            location += (lines[i] as NSString).length + 1
        }
        let length = (lines[lineNumber] as NSString).length
        return NSRange(location: location, length: length)
    }

    func addPath(color: UIColor, rect: CGRect, entirePath: Bool? = nil, radius: CGFloat? = 0.0) -> CAShapeLayer? {
        let newHighlightLayer = CAShapeLayer()
        newHighlightLayer.fillColor = color.cgColor
        layer.insertSublayer(newHighlightLayer, at: 1)

        let path = UIBezierPath()
        var newRect: CGRect = rect

        if let entirePath = entirePath {
            if entirePath {
                newRect.size.width = UIScreen.main.bounds.size.width
            }
        } else {
            newRect.size.width = UIScreen.main.bounds.size.width
        }

        path.append(UIBezierPath(roundedRect: newRect, cornerRadius: radius ?? 0.0))

        newHighlightLayer.path = path.cgPath
        highlightTMPLayer.append(newHighlightLayer)

        return newHighlightLayer
    }

    func addAnimatedPath(color: UIColor, rect: CGRect, entirePath: Bool? = nil, radius: CGFloat? = 0.0) -> CAShapeLayer? {
        let newHighlightLayer = CAShapeLayer()
        newHighlightLayer.fillColor = color.cgColor
        layer.insertSublayer(newHighlightLayer, at: 1)

        let path = UIBezierPath()
        var newRect: CGRect = rect

        if let entirePath = entirePath {
            if entirePath {
                newRect.size.width = UIScreen.main.bounds.size.width
                newRect.origin.x = 0
            }
        } else {
            newRect.size.width = UIScreen.main.bounds.size.width
            newRect.origin.x = 0
        }

        path.append(UIBezierPath(roundedRect: newRect, cornerRadius: radius ?? 0.0))

        newHighlightLayer.path = path.cgPath
        newHighlightLayer.opacity = 0.1
        highlightTMPLayer.append(newHighlightLayer)

        let animation = CABasicAnimation(keyPath: "opacity")
        animation.duration = 0.25
        animation.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeOut)
        animation.fillMode = CAMediaTimingFillMode.forwards
        animation.isRemovedOnCompletion = false
        animation.fromValue = 0.0
        animation.toValue = 1.0
        newHighlightLayer.add(animation, forKey: nil)

        return newHighlightLayer
    }

    func highlightLine(at lineNumber: Int, with color: UIColor, with text: String, with symbol: String) {
        guard let range = rangeOfLine(lineNumber: lineNumber) else { return }
        guard let rect = visualRangeRect(in: self, for: range) else { return }

        _ = addAnimatedPath(color: color.withAlphaComponent(0.3), rect: rect)

        let lineRect: CGRect = rect

        var button: UIButton = UIButton()
        button = ClosureButton(title: "") {
            let uiView: UIView = UIView()
            uiView.backgroundColor = UIColor.systemGray6
            uiView.frame = CGRect(x: (UIScreen.main.bounds.width - (UIScreen.main.bounds.width / 2.25)) - (self.font?.pointSize ?? 0.0), y: lineRect.midY - ((self.font?.pointSize ?? 0.0) / 2), width: (UIScreen.main.bounds.width / 2.25) + (self.font?.pointSize ?? 0.0), height: 100)
            uiView.layer.cornerRadius = 15
            uiView.layer.borderWidth = 1
            uiView.layer.borderColor = color.cgColor
            uiView.clipsToBounds = true
            let dissmissButton: UIButton = ClosureButton(title: "") {
                UIView.animate(withDuration: 0.1, delay: 0, options: .curveEaseIn, animations: {
                    uiView.alpha = 0.0
                }, completion: { finished in
                    if finished {
                        uiView.removeFromSuperview()
                    }
                })
            }
            dissmissButton.frame = CGRect(x: uiView.bounds.width - 30 , y: 10, width: 15, height: 15)
            let symbolConfig = UIImage.SymbolConfiguration(pointSize: 15, weight: .regular)
            let image = UIImage(systemName: "xmark.circle", withConfiguration: symbolConfig)
            dissmissButton.setImage(image, for: .normal)
            dissmissButton.tintColor = UIColor.label
            let issueLabel: UILabel = PaddedLabel()
            issueLabel.frame = CGRect(x: 10, y: dissmissButton.frame.maxY + 10, width: uiView.bounds.width - 20, height: (uiView.bounds.height - dissmissButton.bounds.height) - 30)
            issueLabel.backgroundColor = UIColor.systemBackground
            issueLabel.layer.cornerRadius = 10
            issueLabel.layer.borderWidth = 1
            issueLabel.layer.borderColor = color.withAlphaComponent(0.5).cgColor
            issueLabel.clipsToBounds = true
            issueLabel.numberOfLines = 0
            issueLabel.font = self.font?.withSize(CGFloat((self.font?.pointSize ?? 0.0) / 1.5))
            issueLabel.text = text
            uiView.addSubview(dissmissButton)
            uiView.addSubview(issueLabel)
            uiView.alpha = 0.0
            self.addSubview(uiView)
            UIView.animate(withDuration: 0.1, delay: 0, options: .curveEaseIn, animations: {
                uiView.alpha = 1.0
            }, completion: nil)
        }
        let symbolConfig = UIImage.SymbolConfiguration(pointSize: 24, weight: .regular)
        let image = UIImage(systemName: symbol, withConfiguration: symbolConfig)
        button.setImage(image, for: .normal)
        button.tintColor = color
        button.backgroundColor = .clear
        button.frame = CGRect(x: (UIScreen.main.bounds.width - 5) - (font?.pointSize ?? 0.0), y: lineRect.midY - ((font?.pointSize ?? 0.0) / 2), width: font?.pointSize ?? 0.0, height: font?.pointSize ?? 0.0)
        self.addSubview(button)
        bringSubviewToFront(button)
        buttonTMPLayer.append(button)
    }

    var onLayoutCompletion: (() -> Void)?

    override func layoutSubviews() {
        super.layoutSubviews()
        onLayoutCompletion?()
        onLayoutCompletion = nil
    }

    func setLayoutCompletionHandler(_ handler: @escaping () -> Void) {
        self.onLayoutCompletion = handler
    }
}

class PaddedLabel: UILabel {
    var textInsets = UIEdgeInsets(top: 8, left: 16, bottom: 8, right: 16)

    override func drawText(in rect: CGRect) {
        super.drawText(in: rect.inset(by: textInsets))
    }

    override var intrinsicContentSize: CGSize {
        let size = super.intrinsicContentSize
        return CGSize(width: size.width + textInsets.left + textInsets.right,
                      height: size.height + textInsets.top + textInsets.bottom)
    }
}

struct TextFormattingRule {
   typealias AttributedKeyCallback = (String, Range<String.Index>) -> Any

   let key: NSAttributedString.Key?
   let calculateValue: AttributedKeyCallback?

   init(key: NSAttributedString.Key, value: Any) {
       self.init(key: key, calculateValue: { _, _ in value })
   }

   init(
       key: NSAttributedString.Key? = nil,
       calculateValue: AttributedKeyCallback? = nil
   ) {
       self.key = key
       self.calculateValue = calculateValue
   }
}

struct HighlightRule {
   let pattern: NSRegularExpression

   let formattingRules: [TextFormattingRule]

   init(pattern: NSRegularExpression, formattingRules: [TextFormattingRule]) {
       self.pattern = pattern
       self.formattingRules = formattingRules
   }
}

class ClosureBarButtonItem: UIBarButtonItem {
    private var actionHandler: (() -> Void)?

    init(title: String?, style: UIBarButtonItem.Style, actionHandler: @escaping () -> Void) {
        self.actionHandler = actionHandler
        super.init()
        self.title = title
        self.style = style
        self.target = self
        self.tintColor = UIColor.label
        self.action = #selector(didTapButton)
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
    }

    @objc private func didTapButton() {
        actionHandler?()
    }
}

class ClosureButton: UIButton {
    private var actionHandler: (() -> Void)?

    init(title: String, actionHandler: @escaping () -> Void) {
        self.actionHandler = actionHandler
        super.init(frame: .zero)
        setTitle(title, for: .normal)
        self.setTitleColor(.label, for: .normal)
        self.addTarget(self, action: #selector(didTapButton), for: .touchUpInside)
        self.tintColor = UIColor.label
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
    }

    @objc private func didTapButton() {
        actionHandler?()
    }
}

func grule(_ isaythis: String) -> [HighlightRule] {
    let userInterfaceStyle = UIScreen.main.traitCollection.userInterfaceStyle

    var color1: UIColor = UIColor.clear   // Keywords
    var color2: UIColor = UIColor.clear   // Structure or Class Name
    var color4: UIColor = UIColor.clear   // Numbers
    var color5: UIColor = UIColor.clear   // Comments
    var color6: UIColor = UIColor.clear   // Strings
    var color7: UIColor = UIColor.clear   // Functions
    var color8: UIColor = UIColor.clear   // Function/Variable names
    var color10: UIColor = UIColor.clear  // Preprocessor Statements

    if userInterfaceStyle == .light {
        color1 = light_color1
        color2 = light_color2
        color4 = light_color4
        color5 = light_color5
        color6 = light_color6
        color7 = light_color7
        color8 = light_color8
        color10 = light_color10
    } else {
        color1 = dark_color1
        color2 = dark_color2
        color4 = dark_color4
        color5 = dark_color5
        color6 = dark_color6
        color7 = dark_color7
        color8 = dark_color8
        color10 = dark_color10
    }

    switch(isaythis) {
        case "fs":
            return [
                HighlightRule(pattern: try! NSRegularExpression(pattern: "(//.*|\\/\\*[\\s\\S]*?\\*\\/)", options: []), formattingRules: [ TextFormattingRule(key: .foregroundColor, value: color5)
                ]), HighlightRule(pattern: try! NSRegularExpression(pattern: "(?<!\\/\\/)(<(.*?)>)", options: []), formattingRules: [ TextFormattingRule(key: .foregroundColor, value: color6)
                ]), HighlightRule(pattern: try! NSRegularExpression(pattern: "(?<!\\/\\/)(\"(.*?)\")", options: []), formattingRules: [ TextFormattingRule(key: .foregroundColor, value: color6)
                ]), HighlightRule(pattern: try! NSRegularExpression(pattern: "\\b(function|if|else|for|while|do|switch|case|default|break|continue|return|var|let|const|class|constructor|this|super|new|extends|static|null|undefined|true|false|try|catch|finally|throw|debugger|import|export|in|instanceof|await|async|yield|enum|implements|interface|let|package|private|protected|public|static)\\b", options: []), formattingRules: [ TextFormattingRule(key: .foregroundColor, value: color1)
                ]), HighlightRule(pattern: try! NSRegularExpression(pattern: "\\b\\w+(?=(\\())", options: []), formattingRules: [ TextFormattingRule(key: .foregroundColor, value: color8)
                ])
            ]
        default:
            return []
    }
}

// MARK: Theming
// XCode format
// 1: Keywords
// 2: Type Declarations
// 4: Numbers
// 5: Comments
// 6: Strings
// 7: Other Class Names
// 8: Other Declarations
// 10: Project Preprocessor Macros

// MARK: Color Storage
// Light Color storage
var light_color1: UIColor = neoRGB(155, 35, 147)
var light_color2: UIColor = neoRGB(28, 70, 74)
var light_color4: UIColor = neoRGB(28, 0, 207)
var light_color5: UIColor = neoRGB(93, 108, 121)
var light_color6: UIColor = neoRGB(196, 26, 22)
var light_color7: UIColor = neoRGB(57, 0, 160)
var light_color8: UIColor = neoRGB(15, 104, 160)
var light_color10: UIColor = neoRGB(100, 56, 32)

// Dark Color storage
var dark_color1: UIColor = neoRGB(252, 95, 163)
var dark_color2: UIColor = neoRGB(93, 216, 255)
var dark_color4: UIColor = neoRGB(208, 191, 105)
var dark_color5: UIColor = neoRGB(108, 121, 134)
var dark_color6: UIColor = neoRGB(252, 106, 93)
var dark_color7: UIColor = neoRGB(208, 168, 255)
var dark_color8: UIColor = neoRGB(65, 161, 192)
var dark_color10: UIColor = neoRGB(253, 143, 63)

var light_standard: UIColor = UIColor.black
var light_background: UIColor = neoRGB(255, 255, 255)
var light_selection: UIColor = neoRGB(164, 205, 255)
var light_current: UIColor = neoRGB(232, 242, 255)
var light_cursor: UIColor = neoRGB(0, 0, 0)

var dark_standard: UIColor = UIColor.white
var dark_background: UIColor = neoRGB(31, 31, 36)
var dark_selection: UIColor = neoRGB(81, 91, 112)
var dark_current: UIColor = neoRGB(35, 37, 43)
var dark_cursor: UIColor = neoRGB(255, 255, 255)

// MARK: Theme system
func neoRGB(_ red: CGFloat,_ green: CGFloat,_ blue: CGFloat ) -> UIColor {
    return UIColor(red: red/255.0, green: green/255.0, blue: blue/255.0, alpha: 1.0)
}

extension UserDefaults {
    func setColor(_ color: UIColor, forKey key: String) {
        if let colorData = try? NSKeyedArchiver.archivedData(withRootObject: color, requiringSecureCoding: false) {
            self.set(colorData, forKey: key)
        }
    }
    func color(forKey key: String) -> UIColor {
        if let colorData = self.data(forKey: key),
           let color = try? NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(colorData) as? UIColor {
            return color
        }
        return UIColor.clear
    }
}

func gsuffix(from fileName: String) -> String {
    let trimmedFileName = fileName.replacingOccurrences(of: " ", with: "")
    let suffix = URL(string: trimmedFileName)?.pathExtension
    return suffix ?? ""
}

```

`FridaScript/UI/FluidGradient/BlobLayer.swift`:

```swift
//
//  BlobLayer.swift
//  BlobLayer
//
//  Created by João Gabriel Pozzobon dos Santos on 04/10/22.
//

import SwiftUI

/// A CALayer that draws a single blob on the screen
public class BlobLayer: CAGradientLayer {
    init(color: Color) {
        super.init()
        
        self.type = .radial
        #if os(OSX)
        autoresizingMask = [.layerWidthSizable, .layerHeightSizable]
        #endif
        
        // Set color
        set(color: color)
        
        // Center point
        let position = newPosition()
        self.startPoint = position
        
        // Radius
        let radius = newRadius()
        self.endPoint = position.displace(by: radius)
    }
    
    /// Generate a random point on the canvas
    func newPosition() -> CGPoint {
        return CGPoint(x: CGFloat.random(in: 0.0...1.0),
                       y: CGFloat.random(in: 0.0...1.0)).capped()
    }
    
    /// Generate a random radius for the blob
    func newRadius() -> CGPoint {
        let size = CGFloat.random(in: 0.15...0.75)
        let viewRatio = frame.width/frame.height
        let safeRatio = max(viewRatio.isNaN ? 1 : viewRatio, 1)
        let ratio = safeRatio*CGFloat.random(in: 0.25...1.75)
        return CGPoint(x: size,
                       y: size*ratio)
    }
    
    /// Animate the blob to a random point and size on screen at set speed
    func animate(speed: CGFloat) {
        guard speed > 0 else { return }
        
        self.removeAllAnimations()
        let currentLayer = self.presentation() ?? self
        
        let animation = CASpringAnimation()
        animation.mass = 10/speed
        animation.damping = 50
        animation.duration = 1/speed
        
        animation.isRemovedOnCompletion = false
        animation.fillMode = CAMediaTimingFillMode.forwards
        
        let position = newPosition()
        let radius = newRadius()
        
        // Center point
        let start = animation.copy() as! CASpringAnimation
        start.keyPath = "startPoint"
        start.fromValue = currentLayer.startPoint
        start.toValue = position
        
        // Radius
        let end = animation.copy() as! CASpringAnimation
        end.keyPath = "endPoint"
        end.fromValue = currentLayer.endPoint
        end.toValue = position.displace(by: radius)
        
        self.startPoint = position
        self.endPoint = position.displace(by: radius)
        
        // Opacity
        let value = Float.random(in: 0.5...1)
        let opacity = animation.copy() as! CASpringAnimation
        opacity.fromValue = self.opacity
        opacity.toValue = value
        
        self.opacity = value
        
        self.add(opacity, forKey: "opacity")
        self.add(start, forKey: "startPoint")
        self.add(end, forKey: "endPoint")
    }
    
    /// Set the color of the blob
    func set(color: Color) {
        // Converted to the system color so that cgColor isn't nil
        self.colors = [SystemColor(color).cgColor,
                       SystemColor(color).cgColor,
                       SystemColor(color.opacity(0.0)).cgColor]
        self.locations = [0.0, 0.9, 1.0]
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    // Required by the framework
    public override init(layer: Any) {
        super.init(layer: layer)
    }
}

```

`FridaScript/UI/FluidGradient/CGPoint+Extensions.swift`:

```swift
//
//  CGPoint+Extensions.swift
//  
//
//  Created by João Gabriel Pozzobon dos Santos on 03/10/22.
//

import CoreGraphics

extension CGPoint {
    /// Build a point from an origin and a displacement
    func displace(by point: CGPoint = .init(x: 0.0, y: 0.0)) -> CGPoint {
        return CGPoint(x: self.x+point.x,
                       y: self.y+point.y)
    }
    
    /// Caps the point to the unit space
    func capped() -> CGPoint {
        return CGPoint(x: max(min(x, 1), 0),
                       y: max(min(y, 1), 0))
    }
}

```

`FridaScript/UI/FluidGradient/FluidGradient.swift`:

```swift
//
//  FluidGradient.swift
//  FluidGradient
//
//  Created by Oskar Groth on 2021-12-23.
//

import SwiftUI

public struct FluidGradient: View {
    private var blobs: [Color]
    private var highlights: [Color]
    private var speed: CGFloat
    private var blur: CGFloat
    
    @State var blurValue: CGFloat = 0.0
    
    public init(blobs: [Color],
                highlights: [Color] = [],
                speed: CGFloat = 1.0,
                blur: CGFloat = 0.75) {
        self.blobs = blobs
        self.highlights = highlights
        self.speed = speed
        self.blur = blur
    }
    
    public var body: some View {
        Representable(blobs: blobs,
                      highlights: highlights,
                      speed: speed,
                      blurValue: $blurValue)
        .blur(radius: pow(blurValue, blur))
        .accessibility(hidden: true)
        .clipped()
    }
}

#if os(OSX)
typealias SystemRepresentable = NSViewRepresentable
#else
typealias SystemRepresentable = UIViewRepresentable
#endif

// MARK: - Representable
extension FluidGradient {
    struct Representable: SystemRepresentable {
        var blobs: [Color]
        var highlights: [Color]
        var speed: CGFloat
        
        @Binding var blurValue: CGFloat
        
        func makeView(context: Context) -> FluidGradientView {
            context.coordinator.view
        }
        
        func updateView(_ view: FluidGradientView, context: Context) {
            context.coordinator.create(blobs: blobs, highlights: highlights)
            DispatchQueue.main.async {
                context.coordinator.update(speed: speed)
            }
        }
        
#if os(OSX)
        func makeNSView(context: Context) -> FluidGradientView {
            makeView(context: context)
        }
        func updateNSView(_ view: FluidGradientView, context: Context) {
            updateView(view, context: context)
        }
#else
        func makeUIView(context: Context) -> FluidGradientView {
            makeView(context: context)
        }
        func updateUIView(_ view: FluidGradientView, context: Context) {
            updateView(view, context: context)
        }
#endif
        
        func makeCoordinator() -> Coordinator {
            Coordinator(blobs: blobs,
                        highlights: highlights,
                        speed: speed,
                        blurValue: $blurValue)
        }
    }
    
    class Coordinator: FluidGradientDelegate {
        var blobs: [Color]
        var highlights: [Color]
        var speed: CGFloat
        var blurValue: Binding<CGFloat>
        
        var view: FluidGradientView
        
        init(blobs: [Color],
             highlights: [Color],
             speed: CGFloat,
             blurValue: Binding<CGFloat>) {
            self.blobs = blobs
            self.highlights = highlights
            self.speed = speed
            self.blurValue = blurValue
            self.view = FluidGradientView(blobs: blobs,
                                          highlights: highlights,
                                          speed: speed)
            self.view.delegate = self
        }
        
        /// Create blobs and highlights
        func create(blobs: [Color], highlights: [Color]) {
            guard blobs != self.blobs || highlights != self.highlights else { return }
            self.blobs = blobs
            self.highlights = highlights
            
            view.create(blobs, layer: view.baseLayer)
            view.create(highlights, layer: view.highlightLayer)
            view.update(speed: speed)
        }
        
        /// Update speed
        func update(speed: CGFloat) {
            guard speed != self.speed else { return }
            self.speed = speed
            view.update(speed: speed)
        }
        
        func updateBlur(_ value: CGFloat) {
            blurValue.wrappedValue = value
        }
    }
}

```

`FridaScript/UI/FluidGradient/FluidGradientView.swift`:

```swift
//
//  FluidGradientView.swift
//  FluidGradientView
//
//  Created by Oskar Groth on 2021-12-23.
//

import SwiftUI
import Combine
 
#if os(OSX)
import AppKit
public typealias SystemColor = NSColor
public typealias SystemView = NSView
#else
import UIKit
public typealias SystemColor = UIColor
public typealias SystemView = UIView
#endif

/// A system view that presents an animated gradient with ``CoreAnimation``
public class FluidGradientView: SystemView {
    var speed: CGFloat
    
    let baseLayer = ResizableLayer()
    let highlightLayer = ResizableLayer()
    
    var cancellables = Set<AnyCancellable>()
    
    weak var delegate: FluidGradientDelegate?
    
    init(blobs: [Color] = [],
         highlights: [Color] = [],
         speed: CGFloat = 1.0) {
        self.speed = speed
        super.init(frame: .zero)
        
        if let compositingFilter = CIFilter(name: "CIOverlayBlendMode") {
            highlightLayer.compositingFilter = compositingFilter
        }
        
        #if os(OSX)
        layer = ResizableLayer()
        
        wantsLayer = true
        postsFrameChangedNotifications = true
        
        layer?.delegate = self
        baseLayer.delegate = self
        highlightLayer.delegate = self
        
        self.layer?.addSublayer(baseLayer)
        self.layer?.addSublayer(highlightLayer)
        #else
        self.layer.addSublayer(baseLayer)
        self.layer.addSublayer(highlightLayer)
        #endif
        
        create(blobs, layer: baseLayer)
        create(highlights, layer: highlightLayer)
        DispatchQueue.main.async {
            self.update(speed: speed)
        }
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    /// Create blobs and add to specified layer
    public func create(_ colors: [Color], layer: CALayer) {
        // Remove blobs at the end if colors are removed
        let count = layer.sublayers?.count ?? 0
        let removeCount = count - colors.count
        if removeCount > 0 {
            layer.sublayers?.removeLast(removeCount)
        }
        
        for (index, color) in colors.enumerated() {
            if index < count {
                if let existing = layer.sublayers?[index] as? BlobLayer {
                    existing.set(color: color)
                }
            } else {
                layer.addSublayer(BlobLayer(color: color))
            }
        }
    }
    
    /// Update sublayers and set speed and blur levels
    public func update(speed: CGFloat) {
        cancellables.removeAll()
        self.speed = speed
        guard speed > 0 else { return }
        
        let layers = (baseLayer.sublayers ?? []) + (highlightLayer.sublayers ?? [])
        for layer in layers {
            if let layer = layer as? BlobLayer {
                Timer.publish(every: .random(in: 0.8/speed...1.2/speed),
                              on: .main,
                              in: .common)
                    .autoconnect()
                    .sink { _ in
                        #if os(OSX)
                        let visible = self.window?.occlusionState.contains(.visible)
                        guard visible == true else { return }
                        #endif
                        layer.animate(speed: speed)
                    }
                    .store(in: &cancellables)
            }
        }
    }
    
    /// Compute and update new blur value
    private func updateBlur() {
        delegate?.updateBlur(min(frame.width, frame.height))
    }
    
    /// Functional methods
    #if os(OSX)
    public override func viewDidMoveToWindow() {
        super.viewDidMoveToWindow()
        let scale = window?.backingScaleFactor ?? 2
        layer?.contentsScale = scale
        baseLayer.contentsScale = scale
        highlightLayer.contentsScale = scale
        
        updateBlur()
    }
    
    public override func resize(withOldSuperviewSize oldSize: NSSize) {
        updateBlur()
    }
    #else
    public override func layoutSubviews() {
        layer.frame = self.bounds
        baseLayer.frame = self.bounds
        highlightLayer.frame = self.bounds
        
        updateBlur()
    }
    #endif
}

protocol FluidGradientDelegate: AnyObject {
    func updateBlur(_ value: CGFloat)
}

#if os(OSX)
extension FluidGradientView: CALayerDelegate, NSViewLayerContentScaleDelegate {
    public func layer(_ layer: CALayer,
                      shouldInheritContentsScale newScale: CGFloat,
                      from window: NSWindow) -> Bool {
        return true
    }
}
#endif

```

`FridaScript/UI/FluidGradient/ResizableLayer.swift`:

```swift
//
//  ResizableLayer.swift
//  ResizableLayer
//
//  Created by João Gabriel Pozzobon dos Santos on 03/10/22.
//

import SwiftUI

/// An implementation of ``CALayer`` that resizes its sublayers
public class ResizableLayer: CALayer {
    override init() {
        super.init()
        #if os(OSX)
        autoresizingMask = [.layerWidthSizable, .layerHeightSizable]
        #endif
        sublayers = []
    }
    
    public override init(layer: Any) {
        super.init(layer: layer)
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    public override func layoutSublayers() {
        super.layoutSublayers()
        sublayers?.forEach { layer in
            layer.frame = self.frame
        }
    }
}

```

`FridaScript/UI/NSRangeHelper.swift`:

```swift
/*
NrangeKit.swift
 
Copyright (C) 2024 fridakitten

This file is part of JSTerm.

FridaCodeManager is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

FridaCodeManager is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with FridaCodeManager. If not, see <https://www.gnu.org/licenses/>.

 ______    _     _         _____        __ _                           ______                    _       _   _
|  ___|  (_)   | |       /  ___|      / _| |                          |  ___|                  | |     | | (_)
| |_ _ __ _  __| | __ _  \ `--.  ___ | |_| |___      ____ _ _ __ ___  | |_ ___  _   _ _ __   __| | __ _| |_ _  ___  _ __
|  _| '__| |/ _` |/ _` |  `--. \/ _ \|  _| __\ \ /\ / / _` | '__/ _ \ |  _/ _ \| | | | '_ \ / _` |/ _` | __| |/ _ \| '_ \
| | | |  | | (_| | (_| | /\__/ / (_) | | | |_ \ V  V / (_| | | |  __/ | || (_) | |_| | | | | (_| | (_| | |_| | (_) | | | |
\_| |_|  |_|\__,_|\__,_| \____/ \___/|_|  \__| \_/\_/ \__,_|_|  \___| \_| \___/ \__,_|_| |_|\__,_|\__,_|\__|_|\___/|_| |_|
Founded by. Sean Boleslawski, Benjamin Hornbeck and Lucienne Salim in 2023
*/

import Foundation
import UIKit

func findRanges(of word: String, in text: String) -> [NSRange] {
    let nsText = NSString(string: text)
    var ranges: [NSRange] = []

    var searchRange = NSRange(location: 0, length: nsText.length)

    while true {
        let range = nsText.range(of: word, options: [], range: searchRange)

        if range.location == NSNotFound {
            break
        }

        ranges.append(range)

        let newLocation = range.location + range.length
        searchRange = NSRange(location: newLocation, length: nsText.length - newLocation)
    }

    return ranges
}

func setSelectedTextRange(for textView: UITextView, with askedRange: NSRange) {
    guard let text = textView.text,
          askedRange.location != NSNotFound,
          askedRange.location + askedRange.length <= text.count else {
        return
    }

    let caretRange = NSRange(location: askedRange.location + askedRange.length, length: 0)

    let startPosition = textView.position(from: textView.beginningOfDocument, offset: caretRange.location)
    let endPosition = textView.position(from: startPosition!, offset: 0)

    let textRange = textView.textRange(from: startPosition!, to: endPosition!)
    textView.selectedTextRange = textRange
}

func visualRangeRect(in textView: UITextView, for textRange: NSRange) -> CGRect? {
    guard textRange.location != NSNotFound,
          textRange.location + textRange.length <= textView.textStorage.length else {
          return nil
    }

    let layoutManager = textView.layoutManager
    let textContainer = textView.textContainer
    let glyphRange = layoutManager.glyphRange(forCharacterRange: textRange, actualCharacterRange: nil)

    var rect = layoutManager.boundingRect(forGlyphRange: glyphRange, in: textContainer)

    rect.origin.x += textView.textContainerInset.left
    rect.origin.y += textView.textContainerInset.top

    return rect
}

```

`FridaScript/UI/Popup/BottomPopupView.swift`:

```swift
/*
BottomPopupView.swift
 
Copyright (C) 2024 fridakitten

This file is part of JSTerm.

FridaCodeManager is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

FridaCodeManager is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with FridaCodeManager. If not, see <https://www.gnu.org/licenses/>.

 ______    _     _         _____        __ _                           ______                    _       _   _
|  ___|  (_)   | |       /  ___|      / _| |                          |  ___|                  | |     | | (_)
| |_ _ __ _  __| | __ _  \ `--.  ___ | |_| |___      ____ _ _ __ ___  | |_ ___  _   _ _ __   __| | __ _| |_ _  ___  _ __
|  _| '__| |/ _` |/ _` |  `--. \/ _ \|  _| __\ \ /\ / / _` | '__/ _ \ |  _/ _ \| | | | '_ \ / _` |/ _` | __| |/ _ \| '_ \
| | | |  | | (_| | (_| | /\__/ / (_) | | | |_ \ V  V / (_| | | |  __/ | || (_) | |_| | | | | (_| | (_| | |_| | (_) | | | |
\_| |_|  |_|\__,_|\__,_| \____/ \___/|_|  \__| \_/\_/ \__,_|_|  \___| \_| \___/ \__,_|_| |_|\__,_|\__,_|\__|_|\___/|_| |_|
Founded by. Sean Boleslawski, Benjamin Hornbeck and Lucienne Salim in 2023
*/

import SwiftUI

struct BottomPopupView<Content: View>: View {
    let content: Content

    @State private var keyboardHeight: CGFloat = 0
    @State private var isKeyboardVisible: Bool = false
    @State private var addition: CGFloat = UIDevice.current.hasNotch ? 25.0 : 0.0
    @State private var corner_addition: CGFloat = 0

    init(@ViewBuilder content: () -> Content) {
        self.content = content()
    }

    var body: some View {
        GeometryReader { geometry in
            VStack {
                Spacer()
                VStack(alignment: .leading, spacing: 16) {
                    content
                }
                .padding(20)
                    .padding(.bottom, geometry.safeAreaInsets.bottom + addition)
                    .background {
                        FluidGradient(blobs: [.purple, .primary, .pink],
                                 highlights: [.purple, .primary, .pink],
                                                            speed: 0.25,
                                                            blur: 0.75)
                            .ignoresSafeArea()
                            .background(.quaternary)
                    }
                    .background(Color(.systemBackground))
                    .cornerRadius(isPad ? 16 : corner_addition)
                    .frame(width: isPad ? UIScreen.main.bounds.width / 4 : UIScreen.main.bounds.width - corner_addition * 2)
                    .offset(x: corner_addition , y: isKeyboardVisible ? -keyboardHeight : 0)
                    .animation(.easeInOut, value: keyboardHeight)
            }
            .edgesIgnoringSafeArea([.bottom])
            .onAppear {
                NotificationCenter.default.addObserver(forName: UIResponder.keyboardWillShowNotification, object: nil, queue: .main) { notification in
                    if let keyboardSize = notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect {
                        withAnimation(.easeOut(duration: 0.5)) {
                            addition = 0
                            corner_addition = 16
                            self.keyboardHeight = keyboardSize.height + 25
                            self.isKeyboardVisible = true
                        }
                    }
                }
                NotificationCenter.default.addObserver(forName: UIResponder.keyboardWillHideNotification, object: nil, queue: .main) { _ in
                    withAnimation(.easeOut(duration: 0.5)) {
                        if UIDevice.current.hasNotch {
                            addition = 25.0
                        }
                        corner_addition = 0
                        self.keyboardHeight = 0
                        self.isKeyboardVisible = false
                    }
                }
            }
            .onDisappear {
                NotificationCenter.default.removeObserver(self)
            }
        }
        .transition(.move(edge: .bottom))
    }
}

extension UIDevice {
    var hasNotch: Bool {
        guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene else {
            return false
        }
        let bottomInset = windowScene.windows.first?.safeAreaInsets.bottom ?? 0
        return bottomInset > 0
    }
}

```

`FridaScript/UI/Popup/Items/ButtonBar.swift`:

```swift
/*
ButtonBar.swift
 
Copyright (C) 2024 fridakitten

This file is part of JSTerm.

FridaCodeManager is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

FridaCodeManager is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with FridaCodeManager. If not, see <https://www.gnu.org/licenses/>.

 ______    _     _         _____        __ _                           ______                    _       _   _
|  ___|  (_)   | |       /  ___|      / _| |                          |  ___|                  | |     | | (_)
| |_ _ __ _  __| | __ _  \ `--.  ___ | |_| |___      ____ _ _ __ ___  | |_ ___  _   _ _ __   __| | __ _| |_ _  ___  _ __
|  _| '__| |/ _` |/ _` |  `--. \/ _ \|  _| __\ \ /\ / / _` | '__/ _ \ |  _/ _ \| | | | '_ \ / _` |/ _` | __| |/ _ \| '_ \
| | | |  | | (_| | (_| | /\__/ / (_) | | | |_ \ V  V / (_| | | |  __/ | || (_) | |_| | | | | (_| | (_| | |_| | (_) | | | |
\_| |_|  |_|\__,_|\__,_| \____/ \___/|_|  \__| \_/\_/ \__,_|_|  \___| \_| \___/ \__,_|_| |_|\__,_|\__,_|\__|_|\___/|_| |_|
Founded by. Sean Boleslawski, Benjamin Hornbeck and Lucienne Salim in 2023
*/

import SwiftUI

struct POButtonBar: View {
    let cancel: () -> Void
    let confirm: () -> Void
    var body: some View {
        HStack {
            Button(action: {
                cancel()
            }, label: {
                Text("Cancel")
            })
            .frame(width: 80, height: 36)
            .background(Color(.systemBackground).opacity(0.7))
            .foregroundColor(.primary)
            .cornerRadius(10)
            Spacer()
            Button(action: {
                confirm()
            }, label: {
                Text("Confirm")
            })
            .frame(width: 80, height: 36)
            .background(Color(.systemBackground).opacity(0.7))
            .foregroundColor(.primary)
            .cornerRadius(10)
        }
    }
}

```

`FridaScript/UI/Popup/Items/Header.swift`:

```swift
/*
Header.swift
 
Copyright (C) 2024 fridakitten

This file is part of JSTerm.

FridaCodeManager is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

FridaCodeManager is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with FridaCodeManager. If not, see <https://www.gnu.org/licenses/>.

 ______    _     _         _____        __ _                           ______                    _       _   _
|  ___|  (_)   | |       /  ___|      / _| |                          |  ___|                  | |     | | (_)
| |_ _ __ _  __| | __ _  \ `--.  ___ | |_| |___      ____ _ _ __ ___  | |_ ___  _   _ _ __   __| | __ _| |_ _  ___  _ __
|  _| '__| |/ _` |/ _` |  `--. \/ _ \|  _| __\ \ /\ / / _` | '__/ _ \ |  _/ _ \| | | | '_ \ / _` |/ _` | __| |/ _ \| '_ \
| | | |  | | (_| | (_| | /\__/ / (_) | | | |_ \ V  V / (_| | | |  __/ | || (_) | |_| | | | | (_| | (_| | |_| | (_) | | | |
\_| |_|  |_|\__,_|\__,_| \____/ \___/|_|  \__| \_/\_/ \__,_|_|  \___| \_| \___/ \__,_|_| |_|\__,_|\__,_|\__|_|\___/|_| |_|
Founded by. Sean Boleslawski, Benjamin Hornbeck and Lucienne Salim in 2023
*/

import SwiftUI

struct POHeader: View {
    var title: String

    var body: some View {
        HStack {
            Text(title)
                .font(.system(size: 25, weight: .bold, design: .default))
                .foregroundColor(.primary)
            Spacer()
        }
    }
}

struct POBHeader: View {
    @Binding var title: String

    var body: some View {
        HStack {
            Text(title)
                .font(.system(size: 25, weight: .bold, design: .default))
                .foregroundColor(.primary)
            Spacer()
        }
    }
}

```

`FridaScript/UI/Popup/Items/Picker.swift`:

```swift
/*
Picker.swift
 
Copyright (C) 2024 fridakitten

This file is part of JSTerm.

FridaCodeManager is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

FridaCodeManager is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with FridaCodeManager. If not, see <https://www.gnu.org/licenses/>.

 ______    _     _         _____        __ _                           ______                    _       _   _
|  ___|  (_)   | |       /  ___|      / _| |                          |  ___|                  | |     | | (_)
| |_ _ __ _  __| | __ _  \ `--.  ___ | |_| |___      ____ _ _ __ ___  | |_ ___  _   _ _ __   __| | __ _| |_ _  ___  _ __
|  _| '__| |/ _` |/ _` |  `--. \/ _ \|  _| __\ \ /\ / / _` | '__/ _ \ |  _/ _ \| | | | '_ \ / _` |/ _` | __| |/ _ \| '_ \
| | | |  | | (_| | (_| | /\__/ / (_) | | | |_ \ V  V / (_| | | |  __/ | || (_) | |_| | | | | (_| | (_| | |_| | (_) | | | |
\_| |_|  |_|\__,_|\__,_| \____/ \___/|_|  \__| \_/\_/ \__,_|_|  \___| \_| \___/ \__,_|_| |_|\__,_|\__,_|\__|_|\___/|_| |_|
Founded by. Sean Boleslawski, Benjamin Hornbeck and Lucienne Salim in 2023
*/

import SwiftUI

let isiOS16: Bool = ProcessInfo.processInfo.isOperatingSystemAtLeast(OperatingSystemVersion(majorVersion: 16, minorVersion: 0, patchVersion: 0))
let isPad: Bool = {
    if UIDevice.current.userInterfaceIdiom == .pad {
        return true
    } else {
        return false
    }
}()

struct PickerItems: Identifiable {
    let id: Int
    let name: String
}

struct PickerArrays: Identifiable {
    let id: UUID = UUID()
    let title: String
    let items: [PickerItems]
}

struct POPicker: View {
    let function: () -> Void

    var title: String
    var arrays: [PickerArrays]
    @Binding var type: Int

    var body: some View  {
        HStack {
            VStack {
                HStack {
                    Spacer().frame(width: 10)
                    Text(title)
                        .foregroundColor(.primary)
                    Spacer()
                    Picker("", selection: $type) {
                        if isiOS16 {
                            ForEach(arrays) { item in
                                Section(header: Text(item.title)) {
                                    ForEach(item.items) { subItem in
                                        Text(subItem.name).tag(subItem.id)
                                    }
                                }
                            }
                        } else {
                            ForEach(arrays.reversed()) { item in
                                Section {
                                    ForEach(item.items.reversed()) { subItem in
                                        Text("\(subItem.name) (\(item.title))").tag(subItem.id)
                                    }
                                }
                            }
                        }
                    }
                    .pickerStyle(MenuPickerStyle())
                    Spacer()
                }
            }
            .frame(height: 36)
            .background(Color(.systemBackground).opacity(0.7))
            .foregroundColor(.primary)
            .accentColor(.secondary)
            .cornerRadius(10)

            Spacer()

            Button(action: {
                function()
            }, label: {
                Text("Submit")
                    .frame(width: 80, height: 36)
                    .background(Color(.systemBackground).opacity(0.7))
                    .foregroundColor(.primary)
                    .cornerRadius(10)
            })
        }
        .frame(height: 36)
    }
}


```

`FridaScript/UI/Popup/Items/TextField.swift`:

```swift
/*
TextField.swift
 
Copyright (C) 2024 fridakitten

This file is part of JSTerm.

FridaCodeManager is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

FridaCodeManager is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with FridaCodeManager. If not, see <https://www.gnu.org/licenses/>.

 ______    _     _         _____        __ _                           ______                    _       _   _
|  ___|  (_)   | |       /  ___|      / _| |                          |  ___|                  | |     | | (_)
| |_ _ __ _  __| | __ _  \ `--.  ___ | |_| |___      ____ _ _ __ ___  | |_ ___  _   _ _ __   __| | __ _| |_ _  ___  _ __
|  _| '__| |/ _` |/ _` |  `--. \/ _ \|  _| __\ \ /\ / / _` | '__/ _ \ |  _/ _ \| | | | '_ \ / _` |/ _` | __| |/ _ \| '_ \
| | | |  | | (_| | (_| | /\__/ / (_) | | | |_ \ V  V / (_| | | |  __/ | || (_) | |_| | | | | (_| | (_| | |_| | (_) | | | |
\_| |_|  |_|\__,_|\__,_| \____/ \___/|_|  \__| \_/\_/ \__,_|_|  \___| \_| \___/ \__,_|_| |_|\__,_|\__,_|\__|_|\___/|_| |_|
Founded by. Sean Boleslawski, Benjamin Hornbeck and Lucienne Salim in 2023
*/

import SwiftUI

struct POTextField: View {
    var title: String
    @Binding var content: String
    var body: some View {
        TextField(title, text: $content)
            .frame(height: 36)
            .padding([.leading, .trailing], 10)
            .background(Color(.systemBackground).opacity(0.7))
            .cornerRadius(10)
            .disableAutocorrection(true)
            .autocapitalization(.none)
    }
}

```

`FridaScript/UI/TerminalView.swift`:

```swift
/*
TerminalView.swift
 
Copyright (C) 2024 fridakitten

This file is part of JSTerm.

FridaCodeManager is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

FridaCodeManager is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with FridaCodeManager. If not, see <https://www.gnu.org/licenses/>.

 ______    _     _         _____        __ _                           ______                    _       _   _
|  ___|  (_)   | |       /  ___|      / _| |                          |  ___|                  | |     | | (_)
| |_ _ __ _  __| | __ _  \ `--.  ___ | |_| |___      ____ _ _ __ ___  | |_ ___  _   _ _ __   __| | __ _| |_ _  ___  _ __
|  _| '__| |/ _` |/ _` |  `--. \/ _ \|  _| __\ \ /\ / / _` | '__/ _ \ |  _/ _ \| | | | '_ \ / _` |/ _` | __| |/ _ \| '_ \
| | | |  | | (_| | (_| | /\__/ / (_) | | | |_ \ V  V / (_| | | |  __/ | || (_) | |_| | | | | (_| | (_| | |_| | (_) | | | |
\_| |_|  |_|\__,_|\__,_| \____/ \___/|_|  \__| \_/\_/ \__,_|_|  \___| \_| \___/ \__,_|_| |_|\__,_|\__,_|\__|_|\___/|_| |_|
Founded by. Sean Boleslawski, Benjamin Hornbeck and Lucienne Salim in 2023
*/

import SwiftUI
import UIKit

var setcolor: (Color) -> Void = { color in  }

struct RootTerminalViewSub: UIViewRepresentable {
    var rootView: TerminalWindow
    
    init(rootView: TerminalWindow) {
        self.rootView = rootView
    }

    func makeUIView(context: Context) -> UIView {
        let view = UIView()
        
        let terminalView = rootView
        terminalView.frame = view.bounds
        terminalView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
        view.addSubview(terminalView)
        
        return view
    }

    func updateUIView(_ uiView: UIView, context: Context) {}
}

var refreshcolor: () -> Void = {}
struct RootTerminalView: View {
    var id: UUID = UUID()
    var rootView: TerminalWindow
    @State var color: Color = Color.clear
    
    init(rootView: TerminalWindow) {
        self.id = UUID()
        self.rootView = rootView
    }
    
    var body: some View {
        ZStack {
            color
                .ignoresSafeArea(.all)
            RootTerminalViewSub(rootView: rootView)
        }
        .onAppear {
            color = Color(rootView.terminalText.backgroundColor ?? UIColor.clear)
            refreshcolor = {
                self.color = Color(rootView.terminalText.backgroundColor ?? UIColor.clear)
            }
        }
    }
}

@objc class TerminalWindow: UIView, UITextViewDelegate {
    @objc let id: UUID = UUID()
    @objc var terminalText: UITextView = UITextView()
    @objc var capturedInput: String = ""
    @objc var input: (String) -> Void = { _ in }
    @objc var deletion: (String) -> Void = { _ in }
    @objc var refreshcolor: (UIColor) -> Void = { _ in }
    @objc var name: String = "Serial"

    @objc func setInput(new: @escaping (String) -> Void) {
        input = new
    }

    @objc func setDeletion(new: @escaping (String) -> Void) {
        deletion = new
    }
    
    @objc func safetyAlert(semaphore: DispatchSemaphore) -> Void {
        let ownSemaphore: DispatchSemaphore = DispatchSemaphore(value: 0)
        
        guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
                let keyWindow = windowScene.keyWindow,
                let rootViewController = keyWindow.rootViewController else {
            return
        }

        let alertController = UIAlertController(title: "Warning", message: "Script wants to disable safety checks which could lead to the crash of the app and uncontrolled behaviour\n", preferredStyle: .alert)

        alertController.addAction(UIAlertAction(title: "Cancel", style: .cancel, handler: { _ in
            setFJSafety(true)
            semaphore.signal()
        }))
        
        alertController.addAction(UIAlertAction(title: "Proceed", style: .default, handler: { _ in
            setFJSafety(false)
            semaphore.signal()
        }))
        
        var topController = rootViewController
        while let presentedController = topController.presentedViewController {
            topController = presentedController
        }
        topController.present(alertController, animated: true, completion: nil)
    }

    override init(frame: CGRect) {
        super.init(frame: frame)
        setupView()
    }

    required init?(coder: NSCoder) {
        super.init(coder: coder)
        setupView()
    }

    private func setupView() {
        terminalText.frame = self.bounds
        terminalText.autoresizingMask = [.flexibleWidth, .flexibleHeight]
        terminalText.text = ""
        terminalText.backgroundColor = .clear
        terminalText.isEditable = true
        terminalText.font = UIFont.monospacedSystemFont(ofSize: 10.0, weight: .semibold)
        terminalText.delegate = self
        terminalText.keyboardType = .asciiCapable
        terminalText.textContentType = .none
        terminalText.smartQuotesType = .no
        terminalText.smartDashesType = .no
        terminalText.smartInsertDeleteType = .no
        terminalText.autocorrectionType = .no
        terminalText.autocapitalizationType = .none
        //terminalText.layoutManager.allowsNonContiguousLayout = true
        terminalText.layer.shouldRasterize = true
        terminalText.layer.rasterizationScale = UIScreen.main.scale
        terminalText.isUserInteractionEnabled = true
        //terminalText.layoutManager.addTextContainer(terminalText.textContainer)
        //terminalText.layoutManager.ensureLayout(for: terminalText.textContainer)
        terminalText.isUserInteractionEnabled = false
        self.addSubview(terminalText)
    }

    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText string: String) -> Bool {
        if string.isEmpty {
            deletion(string)
        } else {
            input(string)
        }
        return false
    }
    
    override func didMoveToWindow() {
        super.didMoveToWindow()
        if self.window != nil {
            DispatchQueue.main.async {
                self.terminalText.becomeFirstResponder()
            }
        }
    }
}

```

`FridaScript/UI/UIFileList.swift`:

```swift
/*
UIFileList.swift
 
Copyright (C) 2024 fridakitten

This file is part of JSTerm.

FridaCodeManager is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

FridaCodeManager is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with FridaCodeManager. If not, see <https://www.gnu.org/licenses/>.

 ______    _     _         _____        __ _                           ______                    _       _   _
|  ___|  (_)   | |       /  ___|      / _| |                          |  ___|                  | |     | | (_)
| |_ _ __ _  __| | __ _  \ `--.  ___ | |_| |___      ____ _ _ __ ___  | |_ ___  _   _ _ __   __| | __ _| |_ _  ___  _ __
|  _| '__| |/ _` |/ _` |  `--. \/ _ \|  _| __\ \ /\ / / _` | '__/ _ \ |  _/ _ \| | | | '_ \ / _` |/ _` | __| |/ _ \| '_ \
| | | |  | | (_| | (_| | /\__/ / (_) | | | |_ \ V  V / (_| | | |  __/ | || (_) | |_| | | | | (_| | (_| | |_| | (_) | | | |
\_| |_|  |_|\__,_|\__,_| \____/ \___/|_|  \__| \_/\_/ \__,_|_|  \___| \_| \___/ \__,_|_| |_|\__,_|\__,_|\__|_|\___/|_| |_|
Founded by. Sean Boleslawski, Benjamin Hornbeck and Lucienne Salim in 2023
*/

import SwiftUI
import Foundation
import UniformTypeIdentifiers

private let invalidFS: Set<Character> = ["/", "\\", ":", "*", "?", "\"", "<", ">", "|"]

private enum ActiveSheet: Identifiable {
   case create, rename, remove

   var id: Int {
       hashValue
   }
}

struct FileProperty {
   var symbol: String
   var color: Color
   var size: Int
}

struct FileObject: View {
   var properties: FileProperty
   var item: URL
   var body: some View {
       HStack {
           HStack {
               ZStack {
                   Image(systemName: "doc.fill")
                       .foregroundColor(properties.color)
                   VStack {
                       Spacer().frame(height: 8)
                       Text(properties.symbol)
                           .font(.system(size: CGFloat(properties.size), weight: .bold))
                           .foregroundColor(Color(.systemBackground))
                   }
               }
               Text(item.lastPathComponent)
               Spacer()
                   Text("\(gfilesize(atPath: item.path))")
                       .font(.system(size: 10, weight: .semibold))
           }
       }
   }
}

var code: String = ""
struct FileList: View {
   var title: String?
   var directoryPath: URL
   @State private var activeSheet: ActiveSheet?
   @State private var files: [URL] = []
   @State private var quar: Bool = false
   @State private var selpath: String = ""
   @State private var fbool: Bool = false
   @Binding var actpath: String
   @Binding var action: Int

   @State private var poheader: String = ""
   @State private var potextfield: String = ""
   @State private var type: Int = 0

   @State private var macros: [String] = []
   @State private var cmacro: String = ""
    
   @State private var sheet: Bool = false
   @State private var cli: Bool = false

   // GitHub
   @AppStorage("GIT_ENABLED") var enabled: Bool = false
   @AppStorage("GIT_TOKEN") var token: String = ""
   var body: some View {
       List {
           Section {
               ForEach(files, id: \.self) { item in
                   HStack {
                       if isDirectory(item) {
                           NavigationLink(destination: FileList(title: nil, directoryPath: item, actpath: $actpath, action: $action)) {
                               HStack {
                                   Image(systemName: "folder.fill")
                                       .foregroundColor(.primary)
                                   Text(item.lastPathComponent)
                               }
                           }
                       } else {
                           Button(action: {
                               selpath = item.path
                               if !gtypo(item: item.lastPathComponent) {
                                   quar = true
                               } else {
                                   fbool = true
                               }
                           }) {
                               FileObject(properties: gProperty(item), item: item)
                           }
                       }
                   }
                   .contextMenu {
                       Button(action: {
                           sheet = true
                       }) {
                           Label("Run Code", systemImage: "bolt.fill")
                       }
                       Button(action: {
                           let readcode = {
                               do {
                                   return try String(contentsOfFile: item.path)
                               } catch {
                                   sheet = false
                                   return ""
                               }
                           }()
                           code = readcode
                       }) {
                           Label("Load Code", systemImage: "bolt.fill")
                       }
                       Section {
                           Button(action: {
                               selpath = item.lastPathComponent
                               potextfield = selpath
                               activeSheet = .rename
                           }) {
                               Label("Rename", systemImage: "pencil")
                           }
                       }
                       Section {
                           Button(action: {
                               actpath = item.path
                               action = 1
                           }) {
                               Label("Copy", systemImage: "doc.on.doc.fill")
                           }
                           Button(action: {
                               actpath = item.path
                               action = 2
                           }) {
                               Label("Move", systemImage: "folder.fill")
                           }
                       }
                       Section {
                           Button( action: {
                               share(url: item, remove: false)
                           }) {
                               Label("Share", systemImage: "square.and.arrow.up.fill")
                           }
                       }
                       Section {
                           Button(role: .destructive, action: {
                               selpath = item.path
                               activeSheet = .remove
                               poheader = "Remove \"\(item.lastPathComponent)\"?"
                           }) {
                               Label("Remove", systemImage: "trash.fill")
                           }
                       }
                   }
               }
           }
       }
       .refreshable {
           DispatchQueue.main.asyncAfter(deadline: .now() + 0.75) {
               withAnimation {
                   files = []
               }
               DispatchQueue.main.asyncAfter(deadline: .now() + 0.45) {
                   bindLoadFiles(directoryPath: directoryPath, files: $files)
               }
           }
       }
       .onAppear {
           bindLoadFiles(directoryPath: directoryPath, files: $files)
       }
       .listStyle(InsetGroupedListStyle())
       .navigationTitle(
           title ?? directoryPath.lastPathComponent
       )
       .navigationBarTitleDisplayMode(.inline)
       .toolbar {
           ToolbarItem(placement: .navigationBarTrailing) {
               Menu {
                   Section {
                       Button(action: { activeSheet = .create }) {
                           Label("Create", systemImage: "doc.fill.badge.plus")
                       }
                   }
                   if action > 0 {
                       Section {
                           Button(action: {
                               if action == 1 {
                                   _ = cp(actpath, "\(directoryPath.path)/\(URL(fileURLWithPath: actpath).lastPathComponent)")
                                   action = 0
                               } else if action == 2 {
                                   _ = mv(actpath, "\(directoryPath.path)/\(URL(fileURLWithPath: actpath).lastPathComponent)")
                                   action = 0
                               }
                               //haptfeedback(1)
                               bindLoadFiles(directoryPath: directoryPath, files: $files)
                           }) {
                               Label("Paste", systemImage: "doc.on.clipboard")
                           }
                       }
                   }
               } label: {
                   Label("", systemImage: "ellipsis.circle")
               }
           }
           ToolbarItem(placement: .navigationBarLeading)
           {
               Button(action: {
                   cli = true
               }) {
                   Label("", systemImage: "apple.terminal")
               }
           }
       }
       .sheet(item: $activeSheet) { sheet in
           Group {
               BottomPopupView {
                   switch sheet {
                   case .create:
                       POHeader(title: "Create")
                       POTextField(title: "Filename", content: $potextfield)
                       POPicker(function: create_selected, title: "Type", arrays: [PickerArrays(title: "Type", items: [PickerItems(id: 0, name: "File"), PickerItems(id: 1, name: "Folder")])], type: $type)
                   case .rename:
                       POHeader(title: "Rename")
                       POTextField(title: "Filename", content: $potextfield)
                       POButtonBar(cancel: dissmiss_sheet, confirm: rename_selected)
                   case .remove:
                       POBHeader(title: $poheader)
                       Spacer().frame(height: 10)
                       POButtonBar(cancel: dissmiss_sheet, confirm: remove_selected)
                   default:
                       Spacer()
                   }
               }
           }
           .background(BackgroundClearView())
           .edgesIgnoringSafeArea([.bottom])
           .onDisappear {
               poheader = ""
               potextfield = ""
               bindLoadFiles(directoryPath: directoryPath, files: $files)
           }
       }
       .fullScreenCover(isPresented: $quar) {
           NeoEditorHelper(isPresented: $quar, filepath: $selpath)
       }
       .fullScreenCover(isPresented: $fbool) {
           ImageView(imagePath: $selpath, fbool: $fbool)
       }
       .fullScreenCover(isPresented: $sheet) {
           RuntimeRunnerView(sheet: $sheet, code: code)
       }
       .fullScreenCover(isPresented: $cli) {
           CLIView()
       }
   }

   private func create_selected() -> Void {
       if !potextfield.isEmpty && potextfield.rangeOfCharacter(from: CharacterSet(charactersIn: String(invalidFS))) == nil {
           if type == 0 {
           var content = ""
               switch gsuffix(from: potextfield) {
                   case "swift", "c", "m", "mm", "cpp", "h", "hpp", "js":
                       content = authorgen(file: potextfield)
                       break
                   default:
                       break
               }
               cfile(atPath: "\(directoryPath.path)/\(potextfield)", withContent: content)
           } else {
               cfolder(atPath: "\(directoryPath.path)/\(potextfield)")
           }
           //haptfeedback(1)
           activeSheet = nil
       } else {
           //haptfeedback(2)
       }
   }

   private func rename_selected() -> Void {
       if !potextfield.isEmpty && potextfield.rangeOfCharacter(from: CharacterSet(charactersIn: String(invalidFS))) == nil {
           _ = mv("\(directoryPath.path)/\(selpath)", "\(directoryPath.path)/\(potextfield)")
           //haptfeedback(1)
           activeSheet = nil
       } else {
           //haptfeedback(2)
       }
   }

   private func remove_selected() -> Void {
       _ = rm(selpath)
       //haptfeedback(1)
       activeSheet = nil
   }

   private func dissmiss_sheet() -> Void {
       activeSheet = nil
   }

   private func gtypo(item: String) -> Bool {
       let suffix = gsuffix(from: item)
       switch(suffix) {
           case "png", "jpg", "jpeg", "PNG", "JPG":
               return true
           default:
               return false
       }
   }
}

struct ImageView: View {
   @Binding var imagePath: String
   @Binding var fbool: Bool

   init(imagePath: Binding<String>, fbool: Binding<Bool>) {
       _imagePath = imagePath
       _fbool = fbool
       UIInit(type: 1)
   }

   var body: some View {
       NavigationView {
           ZStack {
               Color(UIColor.systemGray6)
                   .ignoresSafeArea()
               VStack {
                   Image(uiImage: loadImage())
                       .resizable()
                       .scaledToFit()
                       .aspectRatio(contentMode: .fit)
                       .frame(width: UIScreen.main.bounds.width)
               }
               .navigationBarTitle("Image Viewer", displayMode: .inline)
               .navigationBarItems(leading:
                   Button(action: {
                       UIInit(type: 0)
                       fbool = false
                   }) {
                       Text("Close")
                   }
               )
           }
       }
   }

   private func loadImage() -> UIImage {
       guard let image = UIImage(contentsOfFile: imagePath) else {
           return UIImage(systemName: "photo")!
       }
       return image
   }
}

struct SDKList: View {
   @State private var files: [URL] = []
   @State var directoryPath: URL
   @Binding var sdk: String
   @Binding var isActive: Bool
   var body: some View {
       List {
           Section {
               ForEach(files, id: \.self) { folder in
                   Button( action: {
                       sdk = folder.lastPathComponent
                       isActive = false
                   }){
                       HStack {
                           Image(systemName: "sdcard.fill")
                           Text(folder.lastPathComponent)
                       }
                   }
               }
           }
       }
       .onAppear {
           bindLoadFiles(directoryPath: directoryPath, files: $files)
       }
       .accentColor(.primary)
       .listStyle(InsetGroupedListStyle())
       .navigationTitle("SDKs")
       .navigationBarTitleDisplayMode(.inline)
   }
}

private func gfilesize(atPath filePath: String) -> String {
   let fileURL = URL(fileURLWithPath: filePath)

   do {
       let attributes = try FileManager.default.attributesOfItem(atPath: fileURL.path)

       if let fileSize = attributes[FileAttributeKey.size] as? Int64 {
           let fileSizeInBytes = Double(fileSize)
           let units = ["B", "KB", "MB", "GB", "TB"]
           var unitIndex = 0
           var adjustedSize = fileSizeInBytes

           while adjustedSize >= 1024 && unitIndex < units.count - 1 {
               adjustedSize /= 1024
               unitIndex += 1
           }

           return String(format: "%.2f %@", adjustedSize, units[unitIndex])
       } else {
           return "0.00 B"
       }
   } catch {
       return "0.00 B"
   }
}


func isDirectory(_ url: URL) -> Bool {
   var isDir: ObjCBool = false
   return FileManager.default.fileExists(atPath: url.path, isDirectory: &isDir) && isDir.boolValue
}

private func gProperty(_ fileURL: URL) -> FileProperty {
   var property: FileProperty = FileProperty(symbol: "", color: Color.black, size: 0)

   let suffix = gsuffix(from: fileURL.path)
   switch(suffix) {
       case "m":
           property.symbol = "m"
           property.color = Color.orange
           property.size = 8
       case "js":
           property.symbol = "js"
           property.color = Color.orange
           property.size = 5
       case "c":
           property.symbol = "c"
           property.color = Color.blue
           property.size = 8
       case "mm":
           property.symbol = "mm"
           property.color = Color.yellow
           property.size = 5
       case "cpp":
           property.symbol = "cpp"
           property.color = Color.green
           property.size = 4
       case "hpp":
           property.symbol = "hpp"
           property.color = Color.secondary
           property.size = 4
       case "swift":
           property.color = Color.red
       case "h":
           property.symbol = "h"
           property.color = Color.secondary
           property.size = 8
       case "api":
           property.symbol = "api"
           property.color = Color.purple
           property.size = 4
       default:
           property.color = Color.primary
   }

   return property
}

private func bindLoadFiles(directoryPath: URL, files: Binding<[URL]>) -> Void {
   let fileManager = FileManager.default

   DispatchQueue.global(qos: .background).async {
       do {
           let items = try fileManager.contentsOfDirectory(at: directoryPath, includingPropertiesForKeys: nil)

           var fileGroups: [String: [URL]] = [:]

           for item in items {
               let fileExtension = item.pathExtension.lowercased()
               if !isDirectory(item) {
                   if fileGroups[fileExtension] == nil {
                       fileGroups[fileExtension] = []
                   }
                   fileGroups[fileExtension]?.append(item)
               }
           }

           DispatchQueue.main.async {
               withAnimation {
                   files.wrappedValue.removeAll { file in
                       !fileManager.fileExists(atPath: file.path)
                   }
               }
           }

           for item in items {
               if isDirectory(item) {
                   DispatchQueue.main.async {
                       if !files.wrappedValue.contains(item) {
                           withAnimation {
                               files.wrappedValue.append(item)
                           }
                       }
                   }
                   usleep(500)
               }
           }

           for (_, groupedFiles) in fileGroups.sorted(by: { $0.key < $1.key }) {
               for file in groupedFiles {
                   DispatchQueue.main.async {
                       if !files.wrappedValue.contains(file) {
                           withAnimation {
                               files.wrappedValue.append(file)
                           }
                       }
                   }
                   usleep(500)
               }
           }

       } catch {
           DispatchQueue.main.async {
               print("Error loading files: \(error.localizedDescription)")
           }
       }
   }
}

struct DocumentPicker: UIViewControllerRepresentable {
   @State var pathURL: URL
   @Environment(\.presentationMode) private var presentationMode

   func makeUIViewController(context: Context) -> UIDocumentPickerViewController {
       let documentPicker = UIDocumentPickerViewController(forOpeningContentTypes: [.item], asCopy: true)
       documentPicker.allowsMultipleSelection = true
       documentPicker.delegate = context.coordinator
       return documentPicker
   }

   func updateUIViewController(_ uiViewController: UIDocumentPickerViewController, context: Context) {}

   func makeCoordinator() -> Coordinator {
       return Coordinator(self)
   }

   class Coordinator: NSObject, UIDocumentPickerDelegate {
       let parent: DocumentPicker

       init(_ parent: DocumentPicker) {
           self.parent = parent
       }

       func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
           for item in urls {
               _ = mv(item.path, "\(parent.pathURL.path)/\(item.lastPathComponent)")
           }
           parent.presentationMode.wrappedValue.dismiss()
       }

       func documentPickerWasCancelled(_ controller: UIDocumentPickerViewController) {
           parent.presentationMode.wrappedValue.dismiss()
       }
   }
}

func share(url: URL, remove: Bool = false) -> Void {
    let activityViewController = UIActivityViewController(activityItems: [url], applicationActivities: nil)
    activityViewController.modalPresentationStyle = .popover
        if remove {
        activityViewController.completionWithItemsHandler = { activity, success, items, error in
            do {
                try FileManager.default.removeItem(at: url)
            } catch {
            }
        }
    }

    DispatchQueue.main.async {
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene {
            if let rootViewController = windowScene.windows.first?.rootViewController {
                if let popoverController = activityViewController.popoverPresentationController {
                    popoverController.sourceView = rootViewController.view
                    popoverController.sourceRect = CGRect(x: rootViewController.view.bounds.midX,
                                                      y: rootViewController.view.bounds.midY,
                                                      width: 0, height: 0)
                    popoverController.permittedArrowDirections = []
                }
                rootViewController.present(activityViewController, animated: true, completion: nil)
            } else {
                print("No root view controller found.")
            }
        } else {
            print("No window scene found.")
        }
    }
}

import Foundation

func cfolder(atPath path: String) -> Void {
   do {
       try FileManager.default.createDirectory(atPath: path, withIntermediateDirectories: true, attributes: nil)
   } catch {
       print("Error creating folder: \(error)")
   }
}

func cfile(atPath path: String, withContent content: String) -> Void {
   do {
       try content.write(toFile: path, atomically: true, encoding: .utf8)
       print("File created successfully at path: \(path)")
   } catch {
       print("Error creating file: \(error.localizedDescription)")
   }
}

func copyf(sourcePath: String, destinationPath: String) -> Void {
   do {
       try FileManager.default.copyItem(atPath: sourcePath, toPath: destinationPath)
   } catch {
       print("Error creating file: \(error.localizedDescription)")
   }
}

func copyc(from sp: String, to dp: String) throws {
   let sourcePath = sp
   let destinationPath = dp

   let fileManager = FileManager.default
   
   // Check if the source path exists
   guard fileManager.fileExists(atPath: sourcePath) else {
       throw NSError(domain: "CopyContentsError", code: 1, userInfo: [NSLocalizedDescriptionKey: "Source path not found"])
   }
   
   // Check if the destination path exists, create it if not
   if !fileManager.fileExists(atPath: destinationPath) {
       try fileManager.createDirectory(atPath: destinationPath, withIntermediateDirectories: true, attributes: nil)
   }
   
   // Get contents of the source path
   let contents = try fileManager.contentsOfDirectory(atPath: sourcePath)
   
   // Copy each item to the destination path
   for item in contents {
       let sourceItemPath = (sourcePath as NSString).appendingPathComponent(item)
       let destinationItemPath = (destinationPath as NSString).appendingPathComponent(item)
       
       try fileManager.copyItem(atPath: sourceItemPath, toPath: destinationItemPath)
   }
}

func renameFile(atPath filePath: String, to newFileName: String) throws {
   let directoryPath = (filePath as NSString).deletingLastPathComponent
   let newFilePath = (directoryPath as NSString).appendingPathComponent(newFileName)
   try FileManager.default.moveItem(atPath: filePath, toPath: newFilePath)
}

func adv_rm(atPath path: String) throws {
   let protectedPaths: Set<String> = ["/", "/System", "/bin", "/sbin", "/usr", "/etc", "/var"]
   let normalizedPath = URL(fileURLWithPath: path).standardized.path
   
   guard !protectedPaths.contains(normalizedPath) else {
       throw NSError(domain: "com.example.FileManagerError", code: 1, userInfo: [NSLocalizedDescriptionKey: "Attempted to remove contents from a protected system path: \(path)"])
   }

   let fileManager = FileManager.default
   let contents = try fileManager.contentsOfDirectory(atPath: normalizedPath)
   
   for item in contents {
       let itemPath = normalizedPath + "/" + item
       do {
           try fileManager.removeItem(atPath: itemPath)
       } catch {
           throw error
       }
   }
}

@discardableResult func rm(_ path: String) -> Int {
   let fileManager = FileManager.default
   if fileManager.fileExists(atPath: path) {
       do {
           try fileManager.removeItem(atPath: path)
       } catch {
           return 2
       }
   } else {
       return 1
   }
   return 0
}

@discardableResult func mv(_ fromPath: String, _ toPath: String) -> Int {
   let fileManager = FileManager.default
   if fileManager.fileExists(atPath: fromPath) {
       do {
           try fileManager.moveItem(atPath: fromPath, toPath: toPath)
       } catch {
           return 2
       }
   } else {
       return 1
   }
   return 0
}

@discardableResult func cp(_ sourcePath: String,_ destinationPath: String) -> Int {
   let fileManager = FileManager.default
   
   do {
       guard fileManager.fileExists(atPath: sourcePath) else {
           return 1
       }
       
       if fileManager.fileExists(atPath: destinationPath) {
           try fileManager.removeItem(atPath: destinationPath)
       }
       
       try fileManager.copyItem(atPath: sourcePath, toPath: destinationPath)
       
       return 0
   } catch {
       return 1
   }
}

struct BackgroundClearView: UIViewRepresentable {
   func makeUIView(context: Context) -> UIView {
       let view = UIView()

       DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
           view.superview?.superview?.backgroundColor = .clear
       }

       return view
   }

   func updateUIView(_ uiView: UIView, context: Context) {}
}

func authorgen(file: String) -> String {
    let author = UserDefaults.standard.string(forKey: "Author")
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "dd.MM.yy"
    let currentDate = Date()
    return "//\n// \(file)\n//\n// Created by \(author ?? "Anonym") on \(dateFormatter.string(from: currentDate))\n//\n \n"
}

func UIInit(type: Int) -> Void {
    switch type {
        case 0:
            let navigationBarAppearance = UINavigationBarAppearance()
            navigationBarAppearance.backgroundColor = UIColor.systemBackground
            let titleAttributes = [NSAttributedString.Key.foregroundColor: UIColor.label]
            navigationBarAppearance.titleTextAttributes = titleAttributes
            let buttonAttributes = [NSAttributedString.Key.foregroundColor: UIColor.white]
            navigationBarAppearance.buttonAppearance.normal.titleTextAttributes = buttonAttributes
            let backItemAppearance = UIBarButtonItemAppearance()
            backItemAppearance.normal.titleTextAttributes = [.foregroundColor : UIColor.label]
            navigationBarAppearance.backButtonAppearance = backItemAppearance
            UINavigationBar.appearance().standardAppearance = navigationBarAppearance
            UINavigationBar.appearance().compactAppearance = navigationBarAppearance
            UINavigationBar.appearance().scrollEdgeAppearance = navigationBarAppearance
            let appearance = UITabBarAppearance()
            appearance.configureWithOpaqueBackground()
            appearance.backgroundColor = UIColor.systemBackground
            UITabBar.appearance().standardAppearance = appearance
            UITabBar.appearance().scrollEdgeAppearance = appearance
            return
        case 1:
            let navigationBarAppearance = UINavigationBarAppearance()
            navigationBarAppearance.configureWithDefaultBackground()
            UINavigationBar.appearance().standardAppearance = navigationBarAppearance
            UINavigationBar.appearance().compactAppearance = navigationBarAppearance
            UINavigationBar.appearance().scrollEdgeAppearance = navigationBarAppearance
            return
        default:
            return
    }
}

func clearContentsOfFolder(atPath folderPath: String) throws {
    let fileManager = FileManager.default

    // Check if the folder exists
    guard fileManager.fileExists(atPath: folderPath) else {
        throw NSError(domain: "FolderNotFoundError", code: 1, userInfo: [NSLocalizedDescriptionKey: "The folder does not exist at path: \(folderPath)"])
    }

    // Get the contents of the folder
    let contents = try fileManager.contentsOfDirectory(atPath: folderPath)

    for item in contents {
        let fullPath = (folderPath as NSString).appendingPathComponent(item)
        var isDirectory: ObjCBool = false

        // Check if the item is a directory
        if fileManager.fileExists(atPath: fullPath, isDirectory: &isDirectory) {
            if isDirectory.boolValue {
                // Remove the directory and its contents
                try fileManager.removeItem(atPath: fullPath)
            } else {
                // Remove the file
                try fileManager.removeItem(atPath: fullPath)
            }
        }
    }
}

func FindFilesStack(_ projectPath: String, _ fileExtensions: [String], _ ignore: [String]) -> [String] {
    do {
        let (fileExtensionsSet, ignoreSet, allFiles) = (Set(fileExtensions), Set(ignore), try FileManager.default.subpathsOfDirectory(atPath: projectPath))

        var objCFiles: [String] = []

        for file in allFiles {
            if fileExtensionsSet.contains(where: { file.hasSuffix($0) }) &&
               !ignoreSet.contains(where: { file.hasPrefix($0) }) {
                objCFiles.append("\(file)")
            }
        }
        return objCFiles
    } catch {
        return []
    }
}

```

`FridaScript/bridge.h`:

```h
/*
 MIT License

 Copyright (c) 2025 SeanIsTethered

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

#import "Runtime.h"

void setFJSafety(BOOL value);

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 SeanIsTethered

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# FridaScript [WIP]
## Intro
This project is an attempt to create a new JIT-less script language based on the JavaScriptCore Framework by apple. Im working on that to make coding on just your phone easier and just because I am bored. JavaScriptCore also offers a extremely easy way to expose ObjectiveC Objects and interact with them inside ur script. This enables us to do awesome things. I also might work on creating a `ui` module for FridaScript to create GUIs for your code.
## Modules
Modules are like libraries in FridaScript, you can use the `include("<module name>");` function to load modules into ur FridaScript code. They expose a lot of apples low level functions and make them usable in a safe way. We call the safety `Runtime Safety` it prevents the app from being crashed by low level operations, by tracking and disallowing their malicious use. If you still wish to do malicious things you can call `disable_safety_checks();` which will show up a user alert the user has to consent to. Also the modules currently available are...

- [`io`](FridaScript/Runtime/Modules/IO/IO.md)
- `memory`
- `string`
- `math`
- `proc`

`io` is the most finished module from all and it's for now the most advanced module in FridaScript. `io` is exposing low level C functions so you can basically interact with files.

```