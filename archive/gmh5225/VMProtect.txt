Project Path: arc_gmh5225_VMProtect__ulmx32z

Source Tree:

```txt
arc_gmh5225_VMProtect__ulmx32z
├── Compiler
│   ├── example-GetInput.ASM
│   ├── example-PassCheck.ASM
│   ├── example-SumAndPrint.ASM
│   ├── example-createFile.ASM
│   └── vm.inc
├── Debugger
│   ├── Makefile
│   ├── conn.cpp
│   ├── helpers.cpp
│   ├── lconn.cpp
│   ├── main.cpp
│   ├── main.hpp
│   └── w32conn.cpp
├── Editor
│   └── main.py
├── INSTALL.sh
├── LICENSE
├── README.md
├── SharedCode
│   ├── datatypes.hpp
│   ├── global.hpp
│   ├── memsize.hpp
│   ├── nethelpers.cpp
│   ├── nethelpers.hpp
│   ├── opcodes.hpp
│   └── vmdebug.hpp
├── VMCore
│   ├── Makefile
│   ├── include
│   │   ├── advancesecurity.hpp
│   │   ├── drivers
│   │   │   ├── linuxsysbus.hpp
│   │   │   ├── sysbus.hpp
│   │   │   └── win32sysbus.hpp
│   │   ├── main.hpp
│   │   ├── memory.hpp
│   │   ├── protected.hpp
│   │   ├── screen.hpp
│   │   ├── test.hpp
│   │   ├── vmbase.hpp
│   │   └── vmcpu.hpp
│   ├── src
│   │   ├── advancesecurity.cpp
│   │   ├── framesmanager.cpp
│   │   ├── linuxsysbus.cpp
│   │   ├── loader.cpp
│   │   ├── main.cpp
│   │   ├── vmcpu.cpp
│   │   ├── vmcpudbg.cpp
│   │   ├── vmcpuexecuter.cpp
│   │   └── win32sysbus.cpp
│   └── tests
│       ├── main.cpp
│       ├── vmtest.cpp
│       └── vmtest.hpp
├── VMPROTECT.py
└── doc
    ├── 1.png
    ├── 2.png
    ├── 3.png
    ├── 4.png
    ├── 5.png
    ├── 6.png
    ├── 7.png
    ├── CPU_Opcodes.md
    └── Sysbus.md

```

`Compiler/example-GetInput.ASM`:

```ASM
%include "vm.inc"

start:
    dw 0x6d56
; PRINT "PASS"
    movd r1, data1
    movd r3, 0x0
    movd r4, 0x3
JLL1:
    mov r3, r1
    push r3
    poc
    advrd r1, 0x1
    movmrb r3, r1
    cmp r3, r4
    jz JLL2
    jnz JLL1
JLL2:
    tib
; Print user input
    movd r0, 0x0
    movd r1, 0x0
JLL4:
    gic r0
    cmp r7, r4
    jz JLL3
    mov r1, r7
    push r1
    pic
    advrd r0, 0x01
    jnz JLL4
JLL3:
    ee

data1:
    db "WRITE SOMETHING: ", 0x3, 0
```

`Compiler/example-PassCheck.ASM`:

```ASM
; pass: vmobfuscationisthebest

%include "vm.inc"

start:
    dw 0x6d56
    movd r0, 0x0
    movd r1, data3
    movd r2, data3
    movd r6, 0x3
GETIN1:
    mov r3, r1
    push r3
    poc
    advrd r1, 0x1
    advrd r2, 0x1
    movmrb r3, r2
    cmp r3, r6
    jz GETIN2
    jnz GETIN1
GETIN2:
    tib
    movd r3, 0x10
    movd r1, 0x1
    movd r2, 0x0
    movd r4, 0x0
    movd r5, 0x3
    advrd r3, 0x5
JLL9:
    gic r1
    mov r2, r7
    cmp r2, r5
    jz JLL8
    advrd r1, 0x1
    adrr r4, r2
    cmp r2, r5
    advrd r4, 0x5

    gic r1
    mov r2, r7
    cmp r2, r5
    jz JLL8
    advrd r1, 0x1
    adrr r4, r2
    advrd r4, 0xa

    gic r1
    mov r2, r7
    cmp r2, r5
    jz JLL8
    advrd r1, 0x1
    adrr r4, r2
    subvrd r4, 0x6

    gic r1
    mov r2, r7
    cmp r2, r5
    jz JLL8
    advrd r1, 0x1
    mov r2, r7
    adrr r4, r2
    subvrd r4, 0xc

    gic r1
    mov r2, r7
    cmp r2, r5
    jz JLL8
    advrd r1, 0x1
    adrr r4, r2
    advrd r4, 0xf

    jnz JLL9

JLL8:    
    advrd r3, 0x5
    movd r3, 0x8a
    movd r5, 0x980
    xor r4, r5
    cmp r4, r3
    jz JLL6
    jnz JLL7

JLL6:
; PRINT "PASS"
    movd r4, 0x0
    jmp JLL5

JLL7:
; PRINT "FAILED"
    movd r4, 0x0
    jmp JLL4

JLL5:
    movd r1, data1
    jmp JLL3

JLL4:
    movd r1, data2
    jmp JLL3

JLL3:
    mov r2, r1
    advrd r2, 0x1
    movd r3, 0x0
    movd r4, 0x0

JLL1:
    mov r3, r1
    push r3
    poc
    advrd r1, 0x1
    advrd r2, 0x1
    movmrb r3, r2
    cmp r3, r4
    jz JLL2
    jnz JLL1

JLL2:
    mov r3, r1
    push r3
    pocn
    ee

data1:
    db "PASS", 0 
data2:
    db "FAILED", 0
data3:
    db "PASSWORD: ", 0x3, 0
```

`Compiler/example-SumAndPrint.ASM`:

```ASM
%include "vm.inc"

start:
    dw 0x6d56
    movd r0, 0x5
    advrd r0, 0x5
    push r0
    pxvn
    ee
```

`Compiler/example-createFile.ASM`:

```ASM
%include "vm.inc"

start:
    dw 0x6d56
    movd r1, 0x0
    movd r2, 0x0
    movd r1, path
    movd r2, data
    push r1
    push r2
    vmsysbus sysfilecr
    ee

data:
    db 0x01, 0x02, 0x03, 0x04, 0x3, 0xD
path:
    db "/home/eaglx/file.bin", 0x3, 0xD
```

`Compiler/vm.inc`:

```inc
[org 0x0]

; VMSysbus
%define sysdircr 1
%define sysdirdel 2
%define sysdirmv 3
%define sysdircp 4
%define sysfilecr 5
%define sysfiledel 6
%define sysfilemv 7
%define sysfilecp 8

; Registers
%define r0 0
%define r1 1
%define r2 2
%define r3 3
%define r4 4
%define r5 5
%define r6 6
%define r7 7

%macro nop 0
db 0x00
%endmacro

%macro ee 0
db 0xee
%endmacro

%macro mov 2
db 0x01, %1, %2
%endmacro

%macro movmb 2
db 0x02, %1 
dd %2
%endmacro

%macro movmw 2
db 0x03, %1 
dd %2
%endmacro

%macro movb 2
db 0x04, %1, %2
%endmacro

%macro movw 2
db 0x05, %1 
dw %2
%endmacro

%macro movbm 2
db 0x06
dw %1 
db %2
%endmacro

%macro movwm 2
db 0x07
dw %1 
db %2
%endmacro

%macro movmrb 2
db 0x08, %1, %2
%endmacro

%macro movmrw 2
db 0x09, %1, %2
%endmacro

%macro movmd 2
db 0x0a, %1, %2
%endmacro

%macro movd 2
db 0x0b, %1
dd %2
%endmacro

%macro movdm 2
db 0x0c, %1, %2
%endmacro

%macro movmrd 2
db 0x0d, %1, %2
%endmacro

%macro jmp 1
db 0x20
dw %1
%endmacro

%macro jz 1
db 0x21
dw %1
%endmacro

%macro jnz 1
db 0x22
dw %1
%endmacro

%macro jae 1
db 0x23
dw %1
%endmacro

%macro jbe 1
db 0x24
dw %1
%endmacro

%macro jb 1
db 0x25
dw %1
%endmacro

%macro ja 1
db 0x26
dw %1
%endmacro

%macro advr 2
db 0x30, %1
dw %2
%endmacro

%macro adrr 2
db 0x31, %1, %2
%endmacro

%macro adrrl 2
db 0x32, %1, %2
%endmacro

%macro subvr 2
db 0x33, %1
dw %2
%endmacro

%macro subrr 2
db 0x34, %1, %2
%endmacro

%macro subrrl 2
db 0x35, %1, %2
%endmacro

%macro xor 2
db 0x36, %1, %2
%endmacro

%macro xorl 2
db 0x37, %1, %2
%endmacro

%macro not 1
db 0x38, %1
%endmacro

%macro notb 1
db 0x39, %1
%endmacro

%macro advrd 2
db 0x3a, %1
dd %2
%endmacro

%macro subvrd 2
db 0x3b, %1
dd %2
%endmacro

%macro shr 2
db 0x3c, %1
db %2
%endmacro

%macro shl 2
db 0x3d, %1
db %2
%endmacro

%macro cmp 2
db 0x50, %1, %2
%endmacro

%macro cmpl 2
db 0x51, %1, %2
%endmacro

%macro vmsysbus 1
db 0x60,
dw %1
%endmacro

%macro push 1
db 0x90, %1
%endmacro

%macro pop 1
db 0x91, %1
%endmacro

%macro clst 0
db 0x92
%endmacro

%macro setsp 1
db 0x93
dd %1
%endmacro

%macro poc 0
db 0xa0
%endmacro

%macro pocn 0
db 0xa1
%endmacro

%macro tib 0
db 0xa2
%endmacro

%macro gic 1
db 0xa3, %1
%endmacro

%macro pic 0
db 0xa4
%endmacro

%macro picn 0
db 0xa5
%endmacro

%macro pxv 0
db 0xa6
%endmacro

%macro pxvn 0
db 0xa7
%endmacro
```

`Debugger/Makefile`:

```
PROJECTNAME = VmprotDEBUGGER
CC = g++
CFLAGS = -Wall -Wextra -std=c++17
SRC_DIR = .
SHARED_SRC_DIR = ../SharedCode
OBJ_DIR = obj
PRSOURCES = $(wildcard $(SRC_DIR)/*.cpp) $(wildcard $(SHARED_SRC_DIR)/*.cpp)
PROBJECTS = $(PRSOURCES:$(SRC_DIR)/%.cpp=$(OBJ_DIR)/%.o)
PREXEC = $(PROJECTNAME).exe

.DEFAULT_GOAL := help
.PHONY: help

help:
	@grep -E '^[a-zA-Z0-9_-]+:.*?## .*$$' $(MAKEFILE_LIST) \
	| sed -n 's/^\(.*\): \(.*\)##\(.*\)/\1\3/p' \
	| column -t -s ' '

build: $(PREXEC) ## Build project

$(PREXEC): $(PROBJECTS)
	$(CC) $(PROBJECTS) -o $(PREXEC) $(CFLAGS)

# telling make how to turn file.cpp into file.o for an arbitary file
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.cpp | $(OBJ_DIR)
	$(CC) -c $^ -o $@ $(CFLAGS)

$(OBJ_DIR):
	mkdir $@

clean: ## Clean project
	@echo "Clean..."
	rm -rf $(OBJ_DIR)
	rm ./*.exe

run: ## Run project
	@echo "Running..."
	./$(PREXEC) $(ARGS)
```

`Debugger/conn.cpp`:

```cpp
#include "main.hpp"

void conn(int cliSocket)
{
    bool connLoop = true;
    MESSAGE_TO_DEBUGGER msgToDebg;
    MESSAGE_FROM_DEBUGGER msgFromDebg;
    char bufferMSGtoDbg[PACKET_TO_DEBUGGER_SIZE];
    char bufferMSGfromDbg[PACKET_FROM_DEBUGGER_SIZE];
    int retValFromFunc;
    DEBUG_OPTIONS cmdDBG;

    while(connLoop)
    {
        retValFromFunc = recvData(cliSocket, bufferMSGtoDbg, PACKET_TO_DEBUGGER_SIZE);
        if(retValFromFunc == RECIVE_ERROR)
        {
            std::cout << "[ERROR] Failed receive data\n";
            #ifdef  _LINUX_DEV_ENVIRONMENT
                close(cliSocket);
            #else //_WIN32_DEV_ENVIRONMENT
                closesocket(cliSocket);
                WSACleanup();
            #endif
            exit(-1);
        }
        deserializeMSG(&msgToDebg,bufferMSGtoDbg);
SHOWOPTIONS:
        printOptions();
        int temp_cmdDBG;
        std::cin >> temp_cmdDBG;
        cmdDBG = static_cast<DEBUG_OPTIONS>(temp_cmdDBG);
        switch(cmdDBG)
        {
            case DEBUG_OPTIONS::EXEC:
                msgFromDebg.cmdFlag = CMD_RUN;
                serializeMSG(&msgFromDebg, bufferMSGfromDbg);
                retValFromFunc = sendData(cliSocket, bufferMSGfromDbg, PACKET_FROM_DEBUGGER_SIZE);
                if(retValFromFunc == SEND_ERROR) errorSend(cliSocket);
                break;
            case DEBUG_OPTIONS::STEP:
                msgFromDebg.cmdFlag = CMD_STEP;
                serializeMSG(&msgFromDebg, bufferMSGfromDbg);
                retValFromFunc = sendData(cliSocket, bufferMSGfromDbg, PACKET_FROM_DEBUGGER_SIZE);
                if(retValFromFunc == SEND_ERROR) errorSend(cliSocket);
                break;
            case DEBUG_OPTIONS::EXIT_DBG:
                msgFromDebg.cmdFlag = CMD_EXIT;
                connLoop = false;
                serializeMSG(&msgFromDebg, bufferMSGfromDbg);
                retValFromFunc = sendData(cliSocket, bufferMSGfromDbg, PACKET_FROM_DEBUGGER_SIZE);
                if(retValFromFunc == SEND_ERROR) errorSend(cliSocket);
                break;
            case DEBUG_OPTIONS::SET_VAL:
                {
                    int option;
                    VDWORD val;
                    std::cout << "Select a register to modify:\n"
                                << "\t1. PC\n"
                                << "\t2. SP\n"
                                << "\t3. Rx\n";
                    std::cout << "Choice: ";
                    std::cin >> option;
                    switch(option)
                    {
                        case 1:
                            std::cout << "Value (hex e.g. 1B or 1b): ";
                            std::cin >> std::hex >> val;
                            msgFromDebg.cmdFlag = CMD_SET_PC;
                            *(VDWORD*) &msgFromDebg.buffer[0] = val;
                            serializeMSG(&msgFromDebg, bufferMSGfromDbg);
                            retValFromFunc = sendData(cliSocket, bufferMSGfromDbg, PACKET_FROM_DEBUGGER_SIZE);
                            if(retValFromFunc == SEND_ERROR) errorSend(cliSocket);
                            break;
                        case 2:
                            std::cout << "Value (hex e.g. 1B or 1b): ";
                            std::cin >> std::hex >> val;
                            msgFromDebg.cmdFlag = CMD_SET_SP;
                            *(VDWORD*) &msgFromDebg.buffer[0] = val;
                            serializeMSG(&msgFromDebg, bufferMSGfromDbg);
                            retValFromFunc = sendData(cliSocket, bufferMSGfromDbg, PACKET_FROM_DEBUGGER_SIZE);
                            if(retValFromFunc == SEND_ERROR) errorSend(cliSocket);
                            break;
                        case 3:
                            int regNr;
                            std::cout << "register nr: ";
                            std::cin >> regNr;
                            std::cout << "Value (hex e.g. 1B or 1b): ";
                            std::cin >> std::hex >> val;
                            msgFromDebg.cmdFlag = CMD_SET_R;
                            msgFromDebg.buffer[0] = regNr + '0';
                            *(VDWORD*) &msgFromDebg.buffer[1] = val;
                            serializeMSG(&msgFromDebg, bufferMSGfromDbg);
                            retValFromFunc = sendData(cliSocket, bufferMSGfromDbg, PACKET_FROM_DEBUGGER_SIZE);
                            if(retValFromFunc == SEND_ERROR) errorSend(cliSocket);
                            break;
                        default:
                            std::cout << "Unkonown command!\n";
                            goto SHOWOPTIONS;
                    }
                }
                break;
            case DEBUG_OPTIONS::SET_FLAG:
                {
                    int option;
                    std::cout << "Select a flag to modify:\n"
                                << "\t1. ZF\n"
                                << "\t2. CF\n";
                    std::cout << "Choice: ";
                    std::cin >> option;
                    char val;
                    switch(option)
                    {
                        case 1:
                            {
                                std::cout << "Value: ";
                                std::cin >> val;
                                msgFromDebg.cmdFlag = CMD_SET_ZF;
                                msgFromDebg.buffer[0] = val;
                                serializeMSG(&msgFromDebg, bufferMSGfromDbg);
                                retValFromFunc = sendData(cliSocket, bufferMSGfromDbg, PACKET_FROM_DEBUGGER_SIZE);
                                if(retValFromFunc == SEND_ERROR) errorSend(cliSocket);
                            }
                            break;
                        case 2:
                            {
                                std::cout << "Value: ";
                                std::cin >> val;
                                msgFromDebg.cmdFlag = CMD_SET_CF;
                                msgFromDebg.buffer[0] = val;
                                serializeMSG(&msgFromDebg, bufferMSGfromDbg);
                                retValFromFunc = sendData(cliSocket, bufferMSGfromDbg, PACKET_FROM_DEBUGGER_SIZE);
                                if(retValFromFunc == SEND_ERROR) errorSend(cliSocket);
                            }
                            break;
                        default:
                            std::cout << "Unkonown command!\n";
                            goto SHOWOPTIONS;
                    }
                }
                break;
            case DEBUG_OPTIONS::SHOW_STACK:
                {
                    int numberDataToPrint = 0;
                    std::cout << "How many data to print: ";
                    std::cin >> numberDataToPrint;
                    if(numberDataToPrint > STACK_SIZE) numberDataToPrint = STACK_SIZE;
                    int sti = STACK_SIZE - 1;
                    while(sti >= (STACK_SIZE - numberDataToPrint))
                    {
                        std::cout << sti << ": " << std::bitset<32>(msgToDebg.stack[sti]) << std::endl;
                        --sti;
                    }
                    std::cout << "\n";
                    goto SHOWOPTIONS;
                }
                break;
            case DEBUG_OPTIONS::SHOW_CODE_DATA:
                {
                    int numberDataToPrint = 0;
                    std::cout << "How many data to print: ";
                    std::cin >> numberDataToPrint;
                    if(numberDataToPrint > CODE_DATA_SIZE) numberDataToPrint = CODE_DATA_SIZE;
                    for(int i = 0; i < numberDataToPrint; i++)
                    {
                        std::cout << std::bitset<8>(msgToDebg.codeData[i]) << std::endl;
                    }
                    std::cout << "\n";
                    goto SHOWOPTIONS;
                }
                break;
            case DEBUG_OPTIONS::SHOW_DATA_BUFFER:
                {
                    int numberDataToPrint = 0;
                    std::cout << "How many data to print: ";
                    std::cin >> numberDataToPrint;
                    if(numberDataToPrint > INPUT_BUFFER_SIZE) numberDataToPrint = INPUT_BUFFER_SIZE;
                    for(int i = 0; i < numberDataToPrint; i++)
                    {
                        std::cout << std::bitset<8>(msgToDebg.dataBuffer[i]) << std::endl;
                    }
                    std::cout << "\n";
                    goto SHOWOPTIONS;
                }
                break;
            case DEBUG_OPTIONS::SHOW_REGS:
                std::cout << "PC: " << std::bitset<32>(msgToDebg.PC) << std::endl;
                std::cout << "SP: " << std::bitset<32>(msgToDebg.SP) << std::endl;
                for(int i = 0; i < 8; i++) 
                {
                    std::cout << "R[" << i << "]: " << std::bitset<32>(msgToDebg.R[i]) << std::endl;
                }
                std::cout << "ZF: " << std::bitset<8>(msgToDebg.ZF) << std::endl;
                std::cout << "CF: " << std::bitset<8>(msgToDebg.CF) << std::endl;
                goto SHOWOPTIONS;
                break;
            case DEBUG_OPTIONS::WRITE_CODE:
                {
                    std::string toModify = "";
                    std::cout << "Data to modify (in bit, 1VBYTE==8bit): ";
                    std::cin >> toModify;
                    if((toModify.length()/8) > MSG_FROM_DBG_SIZE) 
                    {
                        toModify = toModify.substr(0, MSG_FROM_DBG_SIZE);
                    }
                    msgFromDebg.buffer[0] = (toModify.length()/8) + '0';
                    msgFromDebg.cmdFlag = CMD_WRITE_MEM;
                    int counter = 1;
                    for(int k = 0; k < toModify.length(); k+=8) 
                    {
                        std::string binary_num = toModify.substr(k, 8); 
                        msgFromDebg.buffer[counter++] = std::stol(binary_num, nullptr, 2); 
                    }
                    serializeMSG(&msgFromDebg, bufferMSGfromDbg);
                    retValFromFunc = sendData(cliSocket, bufferMSGfromDbg, PACKET_FROM_DEBUGGER_SIZE);
                    if(retValFromFunc == SEND_ERROR) errorSend(cliSocket);
                }
                break;
            default:
                std::cout << "Unkonown command!\n";
                goto SHOWOPTIONS;
        }
    }

#ifdef  _LINUX_DEV_ENVIRONMENT
    close(cliSocket);
#else //_WIN32_DEV_ENVIRONMENT
    closesocket(cliSocket);
    WSACleanup();
#endif
}
```

`Debugger/helpers.cpp`:

```cpp
#include "main.hpp"

void printIntro()
{
    std::cout << R"(
 _   ____  _______________ _____ _____ _____ _____ _____ 
| | | |  \/  || ___ \ ___ \  _  |_   _|  ___/  __ \_   _|
| | | | .  . || |_/ / |_/ / | | | | | | |__ | /  \/ | |  
| | | | |\/| ||  __/|    /| | | | | | |  __|| |     | |  
\ \_/ / |  | || |   | |\ \\ \_/ / | | | |___| \__/\ | |  
 \___/\_|  |_/\_|   \_| \_|\___/  \_/ \____/ \____/ \_/  
                                                         
                                                         
______ ___________ _   _ _____ _____  ___________        
|  _  \  ___| ___ \ | | |  __ \  __ \|  ___| ___ \       
| | | | |__ | |_/ / | | | |  \/ |  \/| |__ | |_/ /       
| | | |  __|| ___ \ | | | | __| | __ |  __||    /        
| |/ /| |___| |_/ / |_| | |_\ \ |_\ \| |___| |\ \        
|___/ \____/\____/ \___/ \____/\____/\____/\_| \_|       
                                                         
    )" << std::endl;
    std::cout << "version 0.3.220222.1630\n" << std::endl;
}

void printOptions()
{
    std::cout << "Options:\n"
                << "\t" << static_cast<int>(DEBUG_OPTIONS::EXEC) << ". Execute a program on the VM\n"
                << "\t" << static_cast<int>(DEBUG_OPTIONS::STEP) << ". Step execution\n"
                << "\t" << static_cast<int>(DEBUG_OPTIONS::EXIT_DBG) << ". Exit debugger and exit debug mode in the VM\n"
                << "\t" << static_cast<int>(DEBUG_OPTIONS::SET_VAL) << ". Set a value in a register\n"
                << "\t" << static_cast<int>(DEBUG_OPTIONS::SET_FLAG) << ". Set a flag\n"
                << "\t" << static_cast<int>(DEBUG_OPTIONS::SHOW_STACK) << ". Show the stack\n"
                << "\t" << static_cast<int>(DEBUG_OPTIONS::SHOW_CODE_DATA) << ". Show the code data\n"
                << "\t" << static_cast<int>(DEBUG_OPTIONS::SHOW_DATA_BUFFER) << ". Show the data buffer\n"
                << "\t" << static_cast<int>(DEBUG_OPTIONS::SHOW_REGS) << ". Show all registers\n"
                << "\t" << static_cast<int>(DEBUG_OPTIONS::WRITE_CODE) << ". Write to the code data\n"
                << std::endl;
    std::cout << "Choice: ";
}


void errorSend(int cliSocket)
{
    std::cout << "Failed send data in debug\n";
#ifdef  _LINUX_DEV_ENVIRONMENT
    close(cliSocket);
#else _WIN32_DEV_ENVIRONMENT
    closesocket(cliSocket);
    WSACleanup();
#endif
    exit(-1);
}
```

`Debugger/lconn.cpp`:

```cpp
#include "main.hpp"
#ifdef _LINUX_DEV_ENVIRONMENT
int setLinuxConnection()
{
    int cliSocket = 0;
    struct sockaddr_in serv_addr;

    if ((cliSocket = socket(AF_INET, SOCK_STREAM, 0)) < 0) 
    { 
        std::cout << "[ERROR] Failed socket creation\n"; 
        return -1;
    }

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);

    if(inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr)<=0)  
    { 
        std::cout << "[ERROR] Invalid address\n";
        return -1;
    }

    if (connect(cliSocket, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) 
    { 
        std::cout << "[ERROR] Connection failed\n";
        return -1;
    }

   return cliSocket;
}
#endif
```

`Debugger/main.cpp`:

```cpp
#include "main.hpp"

int main()
{
    printIntro();
    int cliSocket;
#ifdef _WIN32_DEV_ENVIRONMENT
    cliSocket = setWin32Connection();
#else _LINUX_DEV_ENVIRONMENT
    cliSocket = setLinuxConnection();
#endif
    if(cliSocket == -1) return -1;
    else conn(cliSocket);
    return 0;
}
```

`Debugger/main.hpp`:

```hpp
#ifndef DEBUGGER_MAIN_HPP
#define DEBUGGER_MAIN_HPP

#include <iostream>
#include <string>
#include "../SharedCode/opcodes.hpp"
#include "../VMCore/include/vmcpu.hpp"
#include "../SharedCode/vmdebug.hpp"

#ifdef _WIN32_DEV_ENVIRONMENT
    #include <windows.h>
    #include <winsock2.h>
    #include <ws2tcpip.h>
    #include <stdlib.h>
    #include <stdio.h>
    #include <string> 

    // Need to link with Ws2_32.lib, Mswsock.lib, and Advapi32.lib
    #pragma comment (lib, "Ws2_32.lib")
    #pragma comment (lib, "Mswsock.lib")
    #pragma comment (lib, "AdvApi32.lib")
#endif

#ifdef _LINUX_DEV_ENVIRONMENT
    #include <arpa/inet.h>
#endif

#include <bitset>

#include "../SharedCode/global.hpp"

enum class DEBUG_OPTIONS { 
    EXEC = 1, 
    STEP,
    EXIT_DBG,
    SET_VAL,
    SET_FLAG,
    SHOW_STACK,
    SHOW_CODE_DATA,
    SHOW_DATA_BUFFER,
    SHOW_REGS,
    WRITE_CODE
};


/* *****************  FUNCTIONS *****************  */
void printIntro();
void printOptions();
void errorSend(int);
void conn(int);

#ifdef _WIN32_DEV_ENVIRONMENT
    int setWin32Connection();
#else _LINUX_DEV_ENVIRONMENT
    int setLinuxConnection();
#endif
/* **********************************************  */

#endif
```

`Debugger/w32conn.cpp`:

```cpp
#include "main.hpp"
#ifdef _WIN32_DEV_ENVIRONMENT
int setWin32Connection()
{
    //Initialize Winsock
    WSADATA wsaData;
    int status = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (status != NO_ERROR)
    {
        std::cout << "[ERROR " << status << "] WSAStartup Failed"<< std::endl;
        return -1;
    }

    SOCKET cliSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (cliSocket == INVALID_SOCKET)
    {
        std::cout << "Error at socket(): " << WSAGetLastError() << std::endl;
        WSACleanup();
        return -1;
    }

    sockaddr_in addrServer;
    addrServer.sin_family = AF_INET;
    InetPton(AF_INET, _T("127.0.0.1"), &addrServer.sin_addr.s_addr);
    addrServer.sin_port = htons(PORT);
    memset(&(addrServer.sin_zero), '\0', 8);

    // Connect to server.
    status = connect(cliSocket, (SOCKADDR*)&addrServer, sizeof(addrServer));
    if (status == SOCKET_ERROR)
    {
        closesocket(cliSocket);
        std::cout << "[ERROR] Unable to connect VMCore" << std::endl;
        WSACleanup();
        return -1;
    }

    return cliSocket;
}
#endif
```

`Editor/main.py`:

```py
from tkinter import *
from tkinter import messagebox
from tkinter import filedialog

import subprocess
import binascii
import time
import threading
import os

class Editor:
  # Defining Constructor
  def __init__(self,root):
    # Assigning root
    self.root = root
    # Title of the window
    self.root.title("VMPROTECT EDITOR")
    # Window Geometry
    self.root.geometry("1200x700+200+150")
    # Initializing filename
    self.filename = None
    # Declaring Title variable
    self.title = StringVar()
    # Declaring Status variable
    self.status = StringVar()

    # Creating Titlebar
    self.titlebar = Label(self.root,textvariable=self.title,font=("times new roman",15,"bold"),bd=2,relief=GROOVE)
    # Packing Titlebar to root window
    self.titlebar.pack(side=TOP,fill=BOTH)
    # Calling Settitle Function
    self.settitle()

    # Creating Statusbar
    self.statusbar = Label(self.root,textvariable=self.status,font=("times new roman",15,"bold"),bd=2,relief=GROOVE)
    # Packing status bar to root window
    self.statusbar.pack(side=BOTTOM,fill=BOTH)
    # Initializing Status
    self.status.set("Welcome :)")

    # Creating Menubar
    self.menubar = Menu(self.root,font=("times new roman",15,"bold"),activebackground="skyblue")
    # Configuring menubar on root window
    self.root.config(menu=self.menubar)

    # Creating File Menu
    self.filemenu = Menu(self.menubar,font=("times new roman",12,"bold"),activebackground="skyblue",tearoff=0)
    # Adding New file Command
    self.filemenu.add_command(label="New",accelerator="Ctrl+N",command=self.newfile)
    # Adding Open file Command
    self.filemenu.add_command(label="Open",accelerator="Ctrl+O",command=self.openfile)
    # Adding Save File Command
    self.filemenu.add_command(label="Save",accelerator="Ctrl+S",command=self.savefile)
    # Adding Save As file Command
    self.filemenu.add_command(label="Save As",accelerator="Ctrl+A",command=self.saveasfile)
    # Adding Seprator
    self.filemenu.add_separator()
    # Adding Exit window Command
    self.filemenu.add_command(label="Exit",accelerator="Ctrl+E",command=self.exit)
    # Cascading filemenu to menubar
    self.menubar.add_cascade(label="File", menu=self.filemenu)

    # Creating Edit Menu
    self.editmenu = Menu(self.menubar,font=("times new roman",12,"bold"),activebackground="skyblue",tearoff=0)
    # Adding Cut text Command
    self.editmenu.add_command(label="Cut",accelerator="Ctrl+X",command=self.cut)
    # Adding Copy text Command
    self.editmenu.add_command(label="Copy",accelerator="Ctrl+C",command=self.copy)
    # Adding Paste text command
    self.editmenu.add_command(label="Paste",accelerator="Ctrl+V",command=self.paste)
    # Adding Seprator
    self.editmenu.add_separator()
    # Adding Undo text Command
    self.editmenu.add_command(label="Undo",accelerator="Ctrl+U",command=self.undo)
    # Cascading editmenu to menubar
    self.menubar.add_cascade(label="Edit", menu=self.editmenu)

    # Creating Build Menu
    self.buildmenu = Menu(self.menubar,font=("times new roman",12,"bold"),activebackground="red",tearoff=0)
    # Adding Build separately mode text Command
    self.buildmenu.add_command(label="Build code separately from VMCore",accelerator="Ctrl+B+S",command=self.buildS)
    # Adding Build integrated mode text Command
    self.buildmenu.add_command(label="Build code integrated to VMCore",accelerator="Ctrl+B+I",command=self.buildI)
    # Cascading buildmenu to menubar
    self.menubar.add_cascade(label="Build", menu=self.buildmenu)

    # Creating Help Menu
    self.helpmenu = Menu(self.menubar,font=("times new roman",12,"bold"),activebackground="skyblue",tearoff=0)
    # Adding About Command
    self.helpmenu.add_command(label="About",command=self.infoabout)
    # Cascading helpmenu to menubar
    self.menubar.add_cascade(label="Help", menu=self.helpmenu)

    # Creating Settings button if win32
    # ********************************** TODO: read a config file **********************************
    self.pathToCompiler = ""
    self.pathToNASM = ""
    if os.name == 'nt':
      self.menubar.add_command(label="Settings", command=self.showSettings)
    # ********************************** TODO: read a config file **********************************

    # Creating Scrollbar
    scrol_y = Scrollbar(self.root,orient=VERTICAL)
    # Creating Text Area
    self.txtarea = Text(self.root,yscrollcommand=scrol_y.set,font=("times new roman",15,"bold"),state="normal",relief=GROOVE)
    # Packing scrollbar to root window
    scrol_y.pack(side=RIGHT,fill=Y)
    # Adding Scrollbar to text area
    scrol_y.config(command=self.txtarea.yview)
    # Packing Text Area to root window
    self.txtarea.pack(fill=BOTH,side=TOP,expand=1)

    # Creating Outputbar
    self.outputbar = Label(self.root,text="Build Output",font=("times new roman",15,"bold"))
    # Packing Outputbar to root window
    self.outputbar.pack(side=TOP,fill=BOTH,expand=1)
    # Creating Scrollbar
    scrol_y_out = Scrollbar(self.root,orient=VERTICAL)
    # Creating Build Output Area
    self.buildOutputArea = Text(self.root,yscrollcommand=scrol_y_out.set,font=("times new roman",15,"bold"),state="normal",relief=GROOVE)
    # Packing scrollbar to root window
    scrol_y_out.pack(side=RIGHT,fill=Y)
    # Adding Scrollbar to text area
    scrol_y_out.config(command=self.buildOutputArea.yview)
    # Packing Build Output Area to root window
    self.buildOutputArea.pack(fill=BOTH,side=TOP,expand=1)
    # Set Build Output Area to non editable
    self.buildOutputArea.config(state=DISABLED)

    # Calling shortcuts funtion
    self.shortcuts()

  # Defining settitle function
  def settitle(self):
    # Checking if Filename is not None
    if self.filename:
      # Updating Title as filename
      self.title.set(self.filename)
    else:
      # Updating Title as Untitled
      self.title.set("Untitled")

  # Defining New file Function
  def newfile(self,*args):
    # Clearing the Text Area
    self.txtarea.delete("1.0",END)
    # Updating filename as None
    self.filename = None
    # Calling settitle funtion
    self.settitle()
    # updating status
    self.status.set("New File Created")

  # Defining Open File Funtion
  def openfile(self,*args):
    # Exception handling
    try:
      # Asking for file to open
      self.filename = filedialog.askopenfilename(title = "Select file",filetypes = (("All Files","*.*"),("Text Files","*.txt"),("Python Files","*.py")))
      # checking if filename not none
      if self.filename:
        # opening file in readmode
        infile = open(self.filename,"r")
        # Clearing text area
        self.txtarea.delete("1.0",END)
        # Inserting data Line by line into text area
        for line in infile:
          self.txtarea.insert(END,line)
        # Closing the file  
        infile.close()
        # Calling Set title
        self.settitle()
        # Updating Status
        self.status.set("Opened Successfully")
    except Exception as e:
      messagebox.showerror("Exception",e)

  # Defining Save File Funtion
  def savefile(self,*args):
    # Exception handling
    try:
      # checking if filename not none
      if self.filename:
        # Reading the data from text area
        data = self.txtarea.get("1.0",END)
        # opening File in write mode
        outfile = open(self.filename,"w")
        # Writing Data into file
        outfile.write(data)
        # Closing File
        outfile.close()
        # Calling Set title
        self.settitle()
        # Updating Status
        self.status.set("Saved Successfully")
      else:
        self.saveasfile()
    except Exception as e:
      messagebox.showerror("Exception",e)

  # Defining Save As File Funtion
  def saveasfile(self,*args):
    # Exception handling
    try:
      # Asking for file name and type to save
      untitledfile = filedialog.asksaveasfilename(title = "Save file As",defaultextension=".txt",initialfile = "Untitled.txt",filetypes = (("All Files","*.*"),("Text Files","*.txt"),("Python Files","*.py")))
      # Reading the data from text area
      data = self.txtarea.get("1.0",END)
      # opening File in write mode
      outfile = open(untitledfile,"w")
      # Writing Data into file
      outfile.write(data)
      # Closing File
      outfile.close()
      # Updating filename as Untitled
      self.filename = untitledfile
      # Calling Set title
      self.settitle()
      # Updating Status
      self.status.set("Saved Successfully")
    except Exception as e:
      messagebox.showerror("Exception",e)

  # Defining Exit Funtion
  def exit(self,*args):
    op = messagebox.askyesno("WARNING","Your Unsaved Data May be Lost!!")
    if op>0:
      self.root.destroy()
    else:
      return

  # Defining Cut Funtion
  def cut(self,*args):
    self.txtarea.event_generate("<<Cut>>")

  # Defining Copy Funtion
  def copy(self,*args):
          self.txtarea.event_generate("<<Copy>>")

  # Defining Paste Funtion
  def paste(self,*args):
    self.txtarea.event_generate("<<Paste>>")

  # Defining Undo Funtion
  def undo(self,*args):
    # Exception handling
    try:
      # checking if filename not none
      if self.filename:
        # Clearing Text Area
        self.txtarea.delete("1.0",END)
        # opening File in read mode
        infile = open(self.filename,"r")
        # Inserting data Line by line into text area
        for line in infile:
          self.txtarea.insert(END,line)
        # Closing File
        infile.close()
        # Calling Set title
        self.settitle()
        # Updating Status
        self.status.set("Undone Successfully")
      else:
        # Clearing Text Area
        self.txtarea.delete("1.0",END)
        # Updating filename as None
        self.filename = None
        # Calling Set title
        self.settitle()
        # Updating Status
        self.status.set("Undone Successfully")
    except Exception as e:
      messagebox.showerror("Exception",e)

  # Defining About Funtion
  def infoabout(self):
    messagebox.showinfo("About VMPROTECT","A code obfuscation method using virtual machines to protect a product.\nMore information at github.com/eaglx/VMPROTECT")

  # Settings
  def showSettings(self):
    tl = Toplevel(self.root)
    tl.geometry("500x100")
    tl.wm_title("Settings")
    Label(tl, text="Path to NASM").grid(row=0)
    Label(tl, text="Path to cl.exe").grid(row=1)
    textEntry1 = Entry(tl, width = 60) 
    textEntry1.grid(row=0, column=1)
    textEntry2 = Entry(tl, width = 60)
    textEntry2.grid(row=1, column=1)
    def getTextInput():
        self.pathToNASM = textEntry1.get()
        self.pathToCompiler = textEntry2.get()
    Button(tl, text='Save', command=getTextInput, width = 25).grid(row=3, column=1, pady=4) 

  # Defining shortcuts Funtion
  def shortcuts(self):
    # Binding Ctrl+n to newfile funtion
    self.txtarea.bind("<Control-n>",self.newfile)
    # Binding Ctrl+o to openfile funtion
    self.txtarea.bind("<Control-o>",self.openfile)
    # Binding Ctrl+s to savefile funtion
    self.txtarea.bind("<Control-s>",self.savefile)
    # Binding Ctrl+a to saveasfile funtion
    self.txtarea.bind("<Control-a>",self.saveasfile)
    # Binding Ctrl+e to exit funtion
    self.txtarea.bind("<Control-e>",self.exit)
    # Binding Ctrl+x to cut funtion
    self.txtarea.bind("<Control-x>",self.cut)
    # Binding Ctrl+c to copy funtion
    self.txtarea.bind("<Control-c>",self.copy)
    # Binding Ctrl+v to paste funtion
    self.txtarea.bind("<Control-v>",self.paste)
    # Binding Ctrl+u to undo funtion
    self.txtarea.bind("<Control-u>",self.undo)
    
    # Binding Ctrl+b+i to build separately funtion
    self.root.bind("<Control-b><s>",self.buildS)
    # Binding Ctrl+b+i to build integrated funtion
    self.root.bind("<Control-b><i>",self.buildI)

  # Build a program separately to VMCore
  def buildS(self, event = None):
    self.buildOutputArea.config(state=NORMAL)
    self.buildOutputArea.delete("1.0",END)
    self.status.set("building separately ...")
    self.buildStage1()
    codePart = "#ifndef _VM_PROTECTED_D\n#define _VM_PROTECTED_D\n#include \"main.hpp\"\nVBYTE ProtectedData[] = { 0xFF };\n#endif"
    thread = threading.Thread(target = self.buildStage2, args = (codePart,))
    thread.start()

  # Build a program integrated to VMCore
  def buildI(self, event = None):
    self.buildOutputArea.config(state=NORMAL)
    self.buildOutputArea.delete("1.0",END)
    self.status.set("building integrated ...")
    self.buildStage1()
    codePart1 = "#ifndef _VM_PROTECTED_D\n#define _VM_PROTECTED_D\n#include \"main.hpp\"\nVBYTE ProtectedData[] = { "
    codePart2 = ""
    fileNamePart1 = (self.filename.replace(self.filename.split("/")[-1],''))
    fileNamePart2 = (self.filename.split("/")[-1]).split('.')[0]
    with open(fileNamePart1 + fileNamePart2, mode='rb') as file:
      codePart2 = file.read()
    codePart2str = binascii.hexlify(VBYTEarray(codePart2)).decode("utf-8")
    codePart2final = ""
    for i in range(0, len(codePart2str), 2):
      s1,s2 = codePart2str[i:i+2]
      codePart2final += "0x" + s1 + s2 + ", "
    codePart2final = codePart2final[:-2]
    codePart3 = "};\n#endif"
    fullCode = codePart1 + codePart2final + codePart3
    thread = threading.Thread(target = self.buildStage2, args = (fullCode,))
    thread.start()
  
  def buildStage1(self):
    cmdProcess = subprocess.Popen(['nasm', self.filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = cmdProcess.communicate()
    self.buildOutputArea.insert(END, out)
    self.buildOutputArea.insert(END, err)
  
  def buildStage2(self, codeToWrite):
    f = open("./VMCore/include/protected.hpp", 'w')
    f.write(codeToWrite)
    f.close()
    if os.name == 'nt':
      codeToWrite = "#ifndef _GLOBAL_VARIABLES_HPP\n#define _GLOBAL_VARIABLES_HPP\n#define _WIN32_DEV_ENVIRONMENT\n#endif"
      f = open("./SharedCode/global.hpp.hpp", 'w')
      f.write(codeToWrite)
      f.close()
    else:
      codeToWrite = "#ifndef _GLOBAL_VARIABLES_HPP\n#define _GLOBAL_VARIABLES_HPP\n#define _LINUX_DEV_ENVIRONMENT\n#endif"
      f = open("./SharedCode/global.hpp.hpp", 'w')
      f.write(codeToWrite)
      f.close()
    time.sleep(3)
    self.buildStage3()
    self.buildOutputArea.config(state=DISABLED)
    self.status.set("build finished")

  def buildStage3(self):
    if os.name == 'nt':
      # TODO: NOT IMPLEMENTED YET!
      # cl /EHsc or msbuild project.sln/Flags 
      # self.pathToCompiler
      # self.pathToNASM
      pass
    else:
      cmdProcess = subprocess.Popen(['make', '-C', './VMCore', 'clean'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
      out, err = cmdProcess.communicate()
      self.buildOutputArea.insert(END, out)
      self.buildOutputArea.insert(END, err)
      cmdProcess = subprocess.Popen(['make', '-C', './VMCore', 'build'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
      out, err = cmdProcess.communicate()
      self.buildOutputArea.insert(END, out)
      self.buildOutputArea.insert(END, err)
      cmdProcess = subprocess.Popen(['make', '-C', './Debugger', 'build'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
      out, err = cmdProcess.communicate()
      self.buildOutputArea.insert(END, out)
      self.buildOutputArea.insert(END, err)
      cmdProcess = subprocess.Popen(['cp', '-v', './VMCore/VMPROTECT.exe', (self.filename.replace(self.filename.split("/")[-1],'')) + 'VMPROTECT.exe'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
      out, err = cmdProcess.communicate()
      self.buildOutputArea.insert(END, out)
      self.buildOutputArea.insert(END, err)
      cmdProcess = subprocess.Popen(['cp', '-v', './Debugger/VmprotDEBUGGER.exe', (self.filename.replace(self.filename.split("/")[-1],'')) + 'VmprotDEBUGGER.exe'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
      out, err = cmdProcess.communicate()
      self.buildOutputArea.insert(END, out)
      self.buildOutputArea.insert(END, err)
```

`INSTALL.sh`:

```sh
#!/bin/bash

cat << "EOF"
 __   ____  __ ___ ___  ___ _____ ___ ___ _____                                                
 \ \ / /  \/  | _ \ _ \/ _ \_   _| __/ __|_   _|                                               
  \ V /| |\/| |  _/   / (_) || | | _| (__  | |                                                 
   \_/ |_|  |_|_| |_|_\\___/ |_| |___\___| |_|                _                            _   
  __| |_____ _____| |___ _ __ _ __  ___ _ _| |_   ___ _ ___ _(_)_ _ ___ _ _  _ __  ___ _ _| |_ 
 / _` / -_) V / -_) / _ \ '_ \ '  \/ -_) ' \  _| / -_) ' \ V / | '_/ _ \ ' \| '  \/ -_) ' \  _|
 \__,_\___|\_/\___|_\___/ .__/_|_|_\___|_||_\__| \___|_||_\_/|_|_| \___/_||_|_|_|_\___|_||_\__|
 (_)_ _  __| |_ __ _| | |_|_ _ _                                                               
 | | ' \(_-<  _/ _` | | / -_) '_|                                                              
 |_|_||_/__/\__\__,_|_|_\___|_|                                                                

EOF
echo "version 0.1.211007.1837"
echo "#####################################"

echo ""
echo -n "Path to deploy VMPROTECT: "
read pathToInstall

vmDirName="/VMPROTECT"
fullPathToDeploy="$pathToInstall$vmDirName"

# #####################################
# ############## STAGE 1 ##############
echo "*****************************"
echo "STAGE 1 - check if required programs are installed"
echo "*****************************"
if ! [ -x "$(command -v python3)" ];
then
        echo -e "  \e[1;33mWARNING: python3 could not be found\e[0m"
        if [ $EUID != 0 ]; then
                sudo "$0" "$@"
        fi
        sudo apt install python3 -y
else
        echo -e "  python3 is installed - \e[96myes\e[0m"
fi

if python3 -c 'import pkgutil; exit(not pkgutil.find_loader("tkinter"))'; then
        echo -e '  tkinter is installed - \e[96myes\e[0m'
else
        echo -e '  \e[1;33mWARNING: tkinter could not be found\e[0m'
        if [ $EUID != 0 ]; then
                sudo "$0" "$@"
        fi 
        sudo apt-get install python3-tk -y
fi

if ! [ -x "$(command -v make)" ];
then
        echo -e "  \e[1;33mWARNING: make could not be found\e[0m"
        if [ $EUID != 0 ]; then
                sudo "$0" "$@"
        fi
        sudo apt install build-essential -y
else
        echo -e "  make is installed - \e[96myes\e[0m"
fi

if ! [ -x "$(command -v g++)" ];
then
        echo -e "  \e[1;33mWARNING: g++ could not be found\e[0m"
        if [ $EUID != 0 ]; then
                sudo "$0" "$@"
        fi
        sudo apt install build-essential -y
else
        echo -e "  g++ is installed - \e[96myes\e[0m"
fi

if ! [ -x "$(command -v nasm)" ];
then
        echo -e "  \e[1;33mWARNING: nasm could not be found\e[0m"
        if [ $EUID != 0 ]; then
                sudo "$0" "$@"
        fi
        sudo apt install nasm -y
else
        echo -e "  nasm is installed - \e[96myes\e[0m"
fi
# #####################################

# #####################################
# ############## STAGE 2 ##############
echo "*****************************"
echo "STAGE 2 - copy files"
echo "*****************************"
mkdir $fullPathToDeploy
cp -v -R ./VMCore $fullPathToDeploy/VMCore
cp -v -R ./Editor $fullPathToDeploy/Editor
cp -v -R ./Debugger $fullPathToDeploy/Debugger
cp -v -R ./SharedCode $fullPathToDeploy/SharedCode
cp -v ./Compiler/vm.inc $fullPathToDeploy/vm.inc
cp -v ./VMPROTECT.py $fullPathToDeploy/VMPROTECT.py
chmod +x $fullPathToDeploy/VMPROTECT.py
# #####################################

# #####################################
# ############## STAGE 3 ##############
echo "*****************************"
echo "STAGE 3 - test the environment"
echo "*****************************"
make -C $fullPathToDeploy/VMCore buildtests
make -C $fullPathToDeploy/VMCore runtests
printf "\n\n"
make -C $fullPathToDeploy/VMCore clean
make -C $fullPathToDeploy/VMCore build
# #####################################

printf "\n"
echo -e "\e[96mFINISHED!\e[0m"

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special passVWORD or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.
```

`README.md`:

```md
# VMPROTECT

<img src="https://repository-images.githubusercontent.com/236199786/eab7cc00-05b7-11eb-9f91-6ea165c2cc2c" height="200">

<i>A code obfuscation method using virtual machines to protect programs</i>

<a href="https://github.com/eaglx/VMPROTECT/stargazers"><img src="https://img.shields.io/github/stars/eaglx/VMPROTECT" alt="Stars Badge"/></a>
<a href="https://github.com/eaglx/VMPROTECT/network/members"><img src="https://img.shields.io/github/forks/eaglx/VMPROTECT" alt="Forks Badge"/></a>
<a href="https://github.com/eaglx/VMPROTECT/blob/master/LICENSE"><img src="https://img.shields.io/github/license/eaglx/VMPROTECT?color=2b9348" alt="License Badge"/></a>
[![GitHub release](https://img.shields.io/github/release/eaglx/VMPROTECT)](https://GitHub.com/eaglx/VMPROTECT/releases/)
![Progress](https://progress-bar.dev/4/?title=progress-v0.5)

A virtual machine that simulates a CPU along with a few other hardware components, allows to perform arithmetic operations, reads and writes to memory and interacts with I/O devices. It can understand a machine language which can be used to program it. Virtual machines used in code obfuscation are completely different than common virtual machnines. They are very specific to the task of executing a few set of instructions. Each instruction is given a custom opcode (often generated at random).

:warning: Project only tested on Linux!

## Table of contents
* [Requirements](#requirements)
* [Setup](#setup)
* [Editor](#editor)
* [Compiler](#compiler)
* [Debugger](#debugger)
* [VMCore](#vmcore)
  * [Args](#args)
  * [Security](#security)
  * [Documentation](#documentation)
    * [Memory](#memory)
    * [Drivers](#drivers)
      * [Sysbus](#sysbus)
    * [Registers](#registers)
    * [Instructions](#instructions)
* [Disclaimer](#disclaimer)

## Requirements
* NASM [tested on 2.13.02]
* Only MacOS and Linux:
  * Python3 [tested on 3.6.9]
  * Tkinter [tested on 8.6]
* g++ [tested on 7.5.0]
* make [tested on 4.1]

## Setup
A bash script was created for easier setup of the development environment. At the beginning the script checks and installs the necessary software. Next, copy files and run some unit tests. The bash script is compatible with Debian-based distributions and *Advanced Package Tool*, which handle the installation and removal of software.

<img src="doc/1.png" height="300">

Or simply clone the project to the desired directory and install required software.

After setting up the environment, the directory structure looks like in the screenshot below. There are:
* Debugger - the source code of the debugger,
* SharedCode - shared codes between debugger and VMCore,
* VMCore - the source code of the virtual machine,
* vm.inc - the file with definitions of opcodes,
* Editor - the source code of the code editor (only MacOS and Linux),
* VMPROTECT.py - start here (only MacOS and Linux) :smile:

<img src="doc/2.png" height="150">

In ShareCode/global.hpp you can set the target system environment.

```c++
#ifndef _GLOBAL_VARIABLES_HPP
#define _GLOBAL_VARIABLES_HPP

#define _LINUX_DEV_ENVIRONMENT
// #define _WIN32_DEV_ENVIRONMENT

#endif
```

## Editor
:warning: **SUPPORTED MacOS and Linux**

The editor was written in *Python*. It is a plain text editor with no code syntax highlighting. You can write programs for *VMPROTECT* here. The window consists of a menu, a space for entering text and an output from compiling and building the program. Additionally, the editor status is shown at the bottom.

<img src="doc/3.png" height="300">

There are two options for building a program. The first mode is to compile the program into a separate file and prepare the *VMPROTECT* and *VMPROTECT-DEBUGGER* executables. The second option differs from the previous one in that it merges the compiled code with *VMPROTECT*. Then *VMPROTECT* can be executed without passing arguments.

<img src="doc/4.png" height="300">

Remember to save the source code with the extension (e.g. *asm*) because the editor doesn't support compiling without the extension. Which can lead to the unexpected operation of the editor program. The following files will be created in the directory where the file, with source code, was saved (please do not confuse the *exe* extension with *PE* files for the Windows operating system):
* compiled program file
* VMPROTECT.exe
* VmprotDebugger.exe

<img src="doc/5.png" height="300">

## Compiler
The *nasm* as compiler is used for compilation a code. Remember to include the *vm.inc* file with definitions of opcodes in your programs. Additionally, at the beginning of the code should be included magic number *0x566d*. An example program for virtual machine below.

```nasm
%include "vm.inc"   ; Or full path to this file!

start:
    dw 0x6d56
    movd r0, 0x5
    advrd r0, 0x5
    push r0
    pxvn
    ee
```

## Debugger
When debugging a program you can use a dedicated debugger for *VMPROTECT*. The debugger has following options:
1. Execute a program on the VM.
2. Step execution.
3. Exit debugger and exit debug mode in the *VMPROTECT*.
4. Set a value in a register.
5. Set a flag.
6. Show the stack.
7. Show the code data.
8. Show the data buffer.
9. Show all registers.
10. Write to the code data.

In case of option *10*, the overwritten data will start from where the *PC* register points. The debugger connects to the *VMPROTECT* using a TCP socket, default port *9313*. An example of debugging is seen in the screenshot below.

<img src="doc/6.png" height="300">

An example of debugging with the *V_DEBUG* option turned on is seen in the screenshot below.

<img src="doc/7.png" height="300">

In *vmcpu.cpp* change (uncomment *#define V_DEBUG*, see below code sample) to print more details.

```c++
#include "../include/vmcpu.hpp"

// #define V_DEBUG  <- ****uncomment this to print debug****
// #include <bitset>

VMCPU::VMCPU()
{
```

## VMCore
### Args
The *VMPROTECT* can be start with no arguments but there need to be set a code to execute in *protected.hpp*.

```c++
VBYTE ProtectedData[] = { 0xFF }; // <- HERE PASTE A CODE TO EXECUTE BY VMCPU.
```

Param *-m* set a program mode. Possible program execution modes:
* exec - normal execution,
* debug - debugging mode, you need to run *VMPROTECT-Debugger*.

Param *-p* describe a path to a file with a compiled code to execute.

Example usage of *VMPROTECT* below.

```ascii
VMPROTECT.exe -m exec -p ./example-SumAndPrint

# OR

VMPROTECT.exe -m debug -p ./example-SumAndPrint
```

### Security
The *VMCore* use (only in *Linux*) the ptrace syscall in order to implement a resistent anti debugging techniques. Patching the code wit *NOP's* will not work out of the box either, because the offset calculation must not be destroyed in order to guarantee normal execution.

```c++
offset = value;
if (ptrace(PTRACE_TRACEME, 0, 1, 0) == 0) offset = value;
if (ptrace(PTRACE_TRACEME, 0, 1, 0) == -1) offset *= value;
if (offset != value) return 0;
```

### Documentation
The VM will simulate a fictional cpu (32-bit). It has a custom instrucion set compared to x86-64.

#### Memory
The VM has 51,200 memory locations, each of which stores a 8-bit value (it can store a total of 50kb). The VM has stack, which is a separate data structure. The stack has 256 memory locations, each of which stores a 32-bit value (it can store a total of 512b).

Also, there is a data buffer which has 1024 memory locations, each of which stores a 1-bit value. This buffer will store user input.

```c++
typedef uint8_t VBYTE;
typedef uint16_t VWORD;
typedef uint32_t VDWORD;

#define CODE_DATA_SIZE 51200
#define STACK_SIZE 256
#define INPUT_BUFFER_SIZE 1024

VBYTE codeData[CODE_DATA_SIZE];
VDWORD stack[STACK_SIZE];
VBYTE dataBuffer[INPUT_BUFFER_SIZE];
```

In addition, the *VMCore* has implemented memory management through memory frames. This allows the execution of programs larger than those specified by CODE_DATA_SIZE. The frames will be saved in files named *.cached.x.frame* where *x* is the frame number.

#### Drivers
Drivers are designed to expand the *VMPROTECT*'s capabilities.

OPCODE | Mnemonic and params | Description
--- | --- | ---
60  |  VMSYSBUS word | Arguments to functions pass via the stack |

#### Sysbus
A sysbus is a driver that allows access to a filesystem. Arguments to functions pass via the stack.

FUNC | CMD | CODE | Windows | Linux | MacOS
--- | --- | --- | --- | --- | ---
createDirectory | sysdircr | 1 | YES | YES | NO |
deleteDirectory | sysdirdel | 2 | YES | YES | NO |
moveDirectory | sysdirmv | 3 | YES | NO | NO |
copyDirectory | sysdircp | 4 | YES | NO | NO |
createFile | sysfilecr | 5 | YES | YES | NO |
deleteFile | sysfiledel | 6 | YES | YES | NO |
moveFile | sysfilemv | 7 | YES | YES | NO |
copyFile | sysfilecp | 8 | YES | YES | NO |

Functions' implementation:
```c++
int createDirectory(std::string, int));
int deleteDirectory(std::string);
int moveDirectory(std::string, std::string);
int copyDirectory(std::string, std::string);
int createFile(std::string, uint8_t*, int);
int deleteFile(std::string);
int moveFile(std::string, std::string);
int copyFile(std::string, std::string);
```

Example call function use case:
```nasm
%include "vm.inc"

start:
    dw 0x6d56
    movd r1, 0x0
    movd r2, 0x0
    movd r1, path
    movd r2, data
    push r1
    push r2
    vmsysbus sysfilecr
    ee

data:
    db 0x01, 0x02, 0x03, 0x04, 0x3, 0xD
path:
    db "/home/eaglx/file.bin", 0x3, 0xD
```

#### Registers
A register is a slot for storing value on the CPU. The VM has 10 total registers, each of which is 4 bytes (32 bits). The six of them are general purpose, one has designated role as program counter and another has role as stack pointer. The VM has also two regisers ZF (Zero Flag) and CF (Carry Flag). These two provide information about the most recently executed calculation (allows to check logical conditions such as *AND*).

```c++
/* General Purpose Registers R0 -> R7 */
VDWORD R[8];
struct {
    /* Zero Flag 
        value 1 - flag is set if the result of the last comparison was zero
        value 0 - flag is not set
    */
    unsigned char ZF : 1;
    /* Carry Flag 
        value 1 - flag is set the results of the last comparison was moving
        value 0 - flag is not set
    */
    unsigned char CF : 1;
};
/* Program Counter */
VDWORD PC;
/* Stack Pointer */
VDWORD SP;
```

#### Instructions
An instruction is a command which tells the CPU (and the VM's cpu) to do some task, such compare two values. Instructions have both an opcode which indicates the kind of task to perform and a set of parameters which provide inputs to the task being performed.

```assembly
ADRR R2, R1 => 22 02 01
```

<details>
  <summary>Show full list of opcodes</summary>

OPCODE | Mnemonic and params | Description
--- | --- | ---
00  | NOP | No operation |
EE  | EE | End of code and end of the VM's cpu |
01  | MOV r<sub>dst</sub>, r<sub>src</sub> | Move from a register to a register|
02  |  MOVMB r<sub>dst</sub>, addr<sub>src</sub> | Move and extend byte from memory to a register|
03  |  MOVMW r<sub>dst</sub>, addr<sub>src</sub> | Move word from memory to a register |
04  |  MOVB r<sub>dst</sub>, byte | Move and extend byte to a register  |
05  |  MOVW r<sub>dst</sub>, word | Move word to a register |
06  |  MOVBM addr<sub>dst</sub>, r<sub>src</sub> | Move byte from a register to memory location |
07  |  MOVWM addr<sub>dst</sub>, r<sub>src</sub> | Move word from a register to memory location |
08  |  MOVMRB r<sub>dst</sub>, r<sub>src</sub> | Move and extend byte from memory to a register; get an address from a register |
09  |  MOVMRW r<sub>dst</sub>, r<sub>src</sub> | Move word from memory to a register; get an address from a register |
0A  |  MOVMD r<sub>dst</sub>, addr<sub>src</sub> | Move double word from memory to a register |
0B  |  MOVD r<sub>dst</sub>, dword | Move double word to a register |
0C  |  MOVDM addr<sub>dst</sub>, r<sub>src</sub> | Move double word from a register to memory location |
0D  |  MOVMRD r<sub>dst</sub>, r<sub>src</sub> | Move double from memory to a register; get an address from a register |
  | | |
20  |  JMP addr | Unconditional jump |
21  |  JZ addr | Jump if equal; it set up PC to the specified location if the ZF is set (1) |
22  |  JNZ addr | Jump if not equal; it set up PC to the specified location if the ZF is not set (0) |
23  |  JAE addr | Jump if above or equal; it set up PC to the specified location if the ZF is set (1) and the CF is not set (0) |
24  |  JBE addr | Jump if below or equal; it set up PC to the specified location if the ZF is set (1) and the CF is set (1) |
25  |  JB addr | Jump if below; it set up PC to the specified location if the ZF is not set (0) and the CF is set (1) |
26  |  JA addr | Jump if above; it set up PC to the specified location if the ZF is not set (0) and the CF is not set (0) |
  | | |
30  |  ADVR r<sub>dst</sub>, word | Add word value to a register |
31  |  ADRR r<sub>dst</sub>, r<sub>src</sub> | Add two registers |
32  |  ADRRL r<sub>dst</sub>, r<sub>src</sub> | Add two registers (the low byte) |
33  |  SUBVR r<sub>dst</sub>, word | Substract word value from a register |
34  |  SUBRR r<sub>dst</sub>, r<sub>src</sub> | Substract two registers |
35  |  SUBRRL r<sub>dst</sub>, r<sub>src</sub> | Substract two registers (the low byte) |
36  |  XOR r<sub>dst</sub>, r<sub>src</sub> | Xor two registers |
37  |  XOR r<sub>dst</sub>, r<sub>src</sub> | Xor two registers (the low byte) |
38  |  NOT r<sub>dst</sub>| Bitwise NOT on value in a register |
39  |  NOT r<sub>dst</sub> | Bitwise NOT on value in a register (the low byte) |
3A  |  ADVRD r<sub>dst</sub>, dword | Add double word value to a register |
3B  |  SUBVR r<sub>dst</sub>, dword | Substract double word value from a register |
3C  |  SHR r<sub>dst</sub>, count<sub>byte</sub> | Shift the bits of the operand destination to the right, by the number of bits specified in the count operand |
3D  |  SHL r<sub>dst</sub>, count<sub>byte</sub> | Shift the bits of the operand destination to the left, by the number of bits specified in the count operand |
  | | |
50  |  CMP r<sub>dst</sub>, r<sub>src</sub> | Compare two registers |
51  |  CMPL r<sub>dst</sub>, r<sub>src</sub> | Compare two registers (the low byte) |
  | | |
60  |  VMSYSBUS word | Arguments to functions pass via the stack |
  | | |
90  |  PUSH r<sub>src</sub> | Push value from a register to stack |
91  |  POP r<sub>dst</sub> | Pop value from stack to a register |
92  |  CLST | Clear the stack |
93  |  SETSP dword| Set the stack pointer to the double word value |
  | | |
A0  |  POC  | Print char without new line, the value must be at the top of the stack |
A1  |  POCN  | Print char with new line, the value must be at the top of the stack |
A2  |  TIB  | Take input and move to the data buffer, the length of the string is stored in R[7] |
A3  |  GIC r<sub>src</sub> | Get a specific char from input, that is stored in the data buffer, the value will be stored in R[7], pass the position of char via a some register |
A4  |  PIC  | Print char from input without new line, the value must be at the top of the stack |
A5  |  PICN  | Print char from input with new line, the value must be at the top of the stack |
A6  |  PXV  | Print a value in hex, the value must be at the top of the stack |
A7  |  PXVN  | Print a value in hex with a new line, the value must be at the top of the stack |

</details>

---
## Disclaimer
#### VMPROTECT is for EDUCATION and/or RESEARCH purposes only. The author takes NO responsibility and/or liability for how you choose to use this software and damages caused by this software. You bear the full responsibility for your actions.

#### By using this software, you automatically agree to the above.
---

```

`SharedCode/datatypes.hpp`:

```hpp
#ifndef _VDATA_TYPES_HPP
#define _VDATA_TYPES_HPP

#include <stdint.h>

typedef uint8_t VBYTE;
typedef uint16_t VWORD;
typedef uint32_t VDWORD;


#endif //_VDATA_TYPES_HPP
```

`SharedCode/global.hpp`:

```hpp
#ifndef _GLOBAL_VARIABLES_HPP
#define _GLOBAL_VARIABLES_HPP

#define _LINUX_DEV_ENVIRONMENT
// #define _WIN32_DEV_ENVIRONMENT

#endif
```

`SharedCode/memsize.hpp`:

```hpp
#ifndef _MEM_SIZE_HPP
#define _MEM_SIZE_HPP

#define CODE_DATA_SIZE 51200
#define STACK_SIZE 256
#define INPUT_BUFFER_SIZE 1024

#endif //_MEM_SIZE_HPP
```

`SharedCode/nethelpers.cpp`:

```cpp
#include "nethelpers.hpp"

int sendData(int socket, void *buffer, size_t length)
{
    char *ptr = (char*) buffer;
    int i;

    while (length > 0)
    {
        i = send(socket, ptr, length, 0);
        if (i < 0) return SEND_ERROR;
        else if(i == 0) return SEND_ZERO;
        ptr += i;
        length -= i;
    }
    return SEND_ALL_DATA;
}

int recvData(int socket, void *buffer, size_t length)
{
    char *ptr = (char*) buffer;
    int i;
    int iteration = 0;
    bool loopFinish = false;

    while (!loopFinish)
    {
        i = recv(socket, ptr, length, 0);
        if (i == -1) return RECIVE_ERROR;
        else if(i == 0)
        {
            if(iteration == 0) return RECIVE_ZERO;
            else loopFinish = true;
        }
        ptr += i;
        length -= i;
        ++iteration;
        if(length <= 0) loopFinish = true;
    }
    return i;
}

void serializeMSG(MESSAGE_TO_DEBUGGER *msgPacket, char *dataArray)
{
    VDWORD *d1 = (VDWORD *) dataArray;
    memcpy(d1, msgPacket->R, 32);
    d1 += VDWORD(8);
    *d1 = msgPacket->PC; ++d1;
    *d1 = msgPacket->SP; ++d1;
    // memcpy(d1, msgPacket->stack, STACK_SIZE);
    for(VDWORD i = 0; i < STACK_SIZE; i++)
    {
        *d1 = msgPacket->stack[i]; ++d1;
    }
    // d1 += VDWORD(STACK_SIZE);
    char *d2 = (char *) d1;
    *d2 = msgPacket->ZF; ++d2;
    *d2 = msgPacket->CF; ++d2;
    memcpy(d2, msgPacket->codeData, CODE_DATA_SIZE);
    d2 += CODE_DATA_SIZE;
    memcpy(d2, msgPacket->dataBuffer, INPUT_BUFFER_SIZE);
    d2 += INPUT_BUFFER_SIZE;
}

void deserializeMSG(MESSAGE_TO_DEBUGGER *msgPacket, char *dataArray)
{
    VDWORD *d1 = (VDWORD *) dataArray;
    memcpy(msgPacket->R, d1, 32);
    d1 += VDWORD(8);
    msgPacket->PC = *d1; ++d1;
    msgPacket->SP = *d1; ++d1;
    // memcpy(msgPacket->stack, d1, STACK_SIZE);
    for(VDWORD i = 0; i < STACK_SIZE; i++)
    {
        msgPacket->stack[i] = *d1; ++d1;
    }
    // d1 += VDWORD(STACK_SIZE);

    char *d2 = (char *) d1;
    msgPacket->ZF = *d2; ++d2;
    msgPacket->CF = *d2; ++d2;
    memcpy(msgPacket->codeData, d2, CODE_DATA_SIZE);
    d2 += CODE_DATA_SIZE;
    memcpy(msgPacket->dataBuffer, d2, INPUT_BUFFER_SIZE);
    d2 += INPUT_BUFFER_SIZE;
}

void serializeMSG(MESSAGE_FROM_DEBUGGER *msgPacket, char *dataArray)
{
    int *d1 = (int *) dataArray;
    *d1 = msgPacket->cmdFlag; ++d1;

    char *d2 = (char *) d1;
    memcpy(d2, msgPacket->buffer, MSG_FROM_DBG_SIZE);
}

void deserializeMSG(MESSAGE_FROM_DEBUGGER *msgPacket, char *dataArray)
{
    int *d1 = (int *) dataArray;
    msgPacket->cmdFlag = *d1; ++d1;

    char *d2 = (char *) d1;
    memcpy(msgPacket->buffer, d2, MSG_FROM_DBG_SIZE);
}
```

`SharedCode/nethelpers.hpp`:

```hpp
#ifndef VM_NET_HELPERS_H
#define VM_NET_HELPERS_H

#include "datatypes.hpp"
#include "memsize.hpp"
#include "global.hpp"

#include <string.h>

#ifdef _LINUX_DEV_ENVIRONMENT
    #include <unistd.h> 
    #include <sys/socket.h> 
    #include <netinet/in.h>
#else //_WIN32_DEV_ENVIRONMENT
    #include <winsock2.h>
    #include <ws2tcpip.h>
    #include <tchar.h>

    // Need to link with Ws2_32.lib
    #pragma comment (lib, "Ws2_32.lib")
#endif

#define SEND_ALL_DATA 1
#define SEND_ZERO 0
#define SEND_ERROR -1
#define RECIVE_ZERO 0
#define RECIVE_ERROR -1

int sendData(int, void *, size_t);
int recvData(int, void *, size_t);

#define PACKET_TO_DEBUGGER_SIZE sizeof(MESSAGE_TO_DEBUGGER)
#define PACKET_FROM_DEBUGGER_SIZE sizeof(MESSAGE_FROM_DEBUGGER)

struct MESSAGE_TO_DEBUGGER
{
    VDWORD R[8];
    VDWORD PC;
    VDWORD SP;
    VDWORD stack[STACK_SIZE];
    unsigned char ZF;
    unsigned char CF;
    VBYTE codeData[CODE_DATA_SIZE];
    VBYTE dataBuffer[INPUT_BUFFER_SIZE];
};

#define CMD_RUN 100
#define CMD_STEP 101
#define CMD_EXIT 102
#define CMD_SET_PC 103
#define CMD_SET_SP 104
#define CMD_SET_R 105
#define CMD_SET_ZF 106
#define CMD_SET_CF 107
#define CMD_WRITE_MEM 108

#define MSG_FROM_DBG_SIZE 20
struct MESSAGE_FROM_DEBUGGER
{
    int cmdFlag;
    char buffer[MSG_FROM_DBG_SIZE];
};

void serializeMSG(MESSAGE_TO_DEBUGGER *, char *);
void deserializeMSG(MESSAGE_TO_DEBUGGER *, char *);
void serializeMSG(MESSAGE_FROM_DEBUGGER *, char *);
void deserializeMSG(MESSAGE_FROM_DEBUGGER *, char *);

#endif
```

`SharedCode/opcodes.hpp`:

```hpp
#ifndef _VM_CPU_OPC
#define _VM_CPU_OPC

#define NOP 0x00
#define EE 0xEE
#define MOV 0x01
#define MOVMB 0x02
#define MOVMW 0x03
#define MOVB 0x04
#define MOVW 0x05
#define MOVBM 0x06
#define MOVWM 0x07
#define MOVMRB 0x08
#define MOVMRW 0x09
#define MOVMD 0x0A
#define MOVD 0x0B
#define MOVDM 0x0C
#define MOVMRD 0x0D
#define JMP 0x20
#define JZ 0x21
#define JNZ 0x22
#define JAE 0x23
#define JBE 0x24
#define JB 0x25
#define JA 0x26
#define ADVR 0x30
#define ADRR 0x31
#define ADRRL 0x32
#define SUBVR 0x33
#define SUBRR 0x34
#define SUBRRL 0x35
#define XOR 0x36
#define XORL 0x37
#define NOT 0x38
#define NOTB 0x39
#define ADVRD 0x3A
#define SUBVRD 0x3B
#define SHR 0x3C
#define SHL 0x3D
#define CMP 0x50
#define CMPL 0x51
#define VMSYSBUS 0x60
#define PUSH 0x90
#define POP 0x91
#define CLST 0x92
#define SETSP 0x93
#define POC 0xA0
#define POCN 0xA1
#define TIB 0xA2
#define GIC 0xA3
#define PIC 0xA4
#define PICN 0xA5
#define PXV 0xA6
#define PXVN 0xA7

#endif
```

`SharedCode/vmdebug.hpp`:

```hpp
#ifndef _VM_DEBUG
#define _VM_DEBUG

/*
Not support development on Windows right now!
#define WIN_SOCK
*/

#ifndef VMTESTS
    #define PORT 9313
    #include "nethelpers.hpp"
#endif

#endif
```

`VMCore/Makefile`:

```
PROJECTNAME = VMPROTECT
CC = g++
CFLAGS = -Wall -Wextra -std=c++17
SRC_DIR = src
SHARED_SRC_DIR = ../SharedCode
OBJ_DIR = obj
PRSOURCES = $(wildcard $(SRC_DIR)/*.cpp) $(wildcard $(SHARED_SRC_DIR)/*.cpp)
PROBJECTS = $(PRSOURCES:$(SRC_DIR)/%.cpp=$(OBJ_DIR)/%.o)
PREXEC = $(PROJECTNAME).exe

.DEFAULT_GOAL := help
.PHONY: help

help:
	@grep -E '^[a-zA-Z0-9_-]+:.*?## .*$$' $(MAKEFILE_LIST) \
	| sed -n 's/^\(.*\): \(.*\)##\(.*\)/\1\3/p' \
	| column -t -s ' '

build: $(PREXEC) ## Build project

$(PREXEC): $(PROBJECTS)
	$(CC) $(PROBJECTS) -o $(PREXEC) $(CFLAGS)

# telling make how to turn file.cpp into file.o for an arbitary file
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.cpp | $(OBJ_DIR)
	$(CC) -c $^ -o $@ $(CFLAGS)

$(OBJ_DIR):
	mkdir $@

clean: ## Clean project
	@echo "Clean..."
	rm -rf $(OBJ_DIR)
	rm ./*.exe

run: ## Run project
	@echo "Running..."
	./$(PREXEC) $(ARGS)

TEST_SRC_DIR = tests
TEST_SOURCE = $(wildcard $(TEST_SRC_DIR)/*.cpp) $(wildcard $(SRC_DIR)/vmcpu.cpp) $(wildcard $(SRC_DIR)/vmcpuexecuter.cpp) $(wildcard $(SRC_DIR)/vmcpudbg.cpp) $(wildcard $(SRC_DIR)/framesmanager.cpp) $(wildcard $(SRC_DIR)/advancesecurity.cpp) $(wildcard $(SRC_DIR)/screen.cpp) $(wildcard $(SRC_DIR)/linuxsysbus.cpp)
TEST_EXEC = VMCoreTESTS.exe
buildtests: ## Build tests
	@echo "Building tests..."
	$(CC) $(TEST_SOURCE) -o $(TEST_EXEC) $(CFLAGS) -DVMTESTS

runtests: ## Run tests
	@echo "Running tests..."
	./$(TEST_EXEC) $(ARGS)
```

`VMCore/include/advancesecurity.hpp`:

```hpp
#ifndef _ADVM_SEC_HPP
#define _ADVM_SEC_HPP

#include <iostream>

#include "vmcpu.hpp"

/* ****** HEADERS ****** */
#ifdef _WIN32_DEV_ENVIRONMENT
    #include <intrin.h>
#else //_LINUX_DEV_ENVIRONMENT
    #include <unistd.h>
    #include <sys/ptrace.h>
    #include <cpuid.h>
#endif

class AdvanceSecurity {
    public:
        #ifdef _WIN32_DEV_ENVIRONMENT
            /* ****** TBD ****** */
        #else //_LINUX_DEV_ENVIRONMENT
            static void checkPtrace(int);
        #endif
        static void isHypervisor(void);
};

#endif //_ADVM_SEC_HPP
```

`VMCore/include/drivers/linuxsysbus.hpp`:

```hpp
#ifndef _LINUX_SYSTEM_BUS_HPP
#define _LINUX_SYSTEM_BUS_HPP

#include "sysbus.hpp"

#ifdef _LINUX_DEV_ENVIRONMENT
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    #include <unistd.h>
    #include <errno.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>

    class UNIX: public SYSBUS {
        public:
            UNIX() { };
            ~UNIX() { };
            int createDirectory(std::string, int);
            int deleteDirectory(std::string);
            int moveDirectory(std::string, std::string);
            int copyDirectory(std::string, std::string);
            int deleteFile(std::string);
            int moveFile(std::string, std::string);
            int copyFile(std::string, std::string);

        private:
            mode_t getMode(int);
    };
#endif

#endif
```

`VMCore/include/drivers/sysbus.hpp`:

```hpp
#ifndef _SYSTEM_BUS_HPP
#define _SYSTEM_BUS_HPP

#include "../../../SharedCode/global.hpp"
#include <iostream>
#include <string>
#include <fstream>

#include "../../../SharedCode/datatypes.hpp"

#define DIR_CREATED 200000
#define DIR_CREATED_ERROR 200001
#define DIR_EXIST 200002
#define DELETE_DIR 200011
#define MOVE_DIR 200003
#define COPY_DIR 200004
#define OTHER_DIR_ERROR 200005
#define FILE_CREATED 200006
#define FILE_EXIST 200007
#define DELETE_FILE 200012
#define MOVE_FILE 200008
#define COPY_FILE 200009
#define OTHER_FILE_ERROR 200010
#define NO_IMPLEMENTED_ERROR 200110

#define SYSBUS_CREATE_DIR 1
#define SYSBUS_DELETE_DIR 2
#define SYSBUS_MOVE_DIR 3
#define SYSBUS_COPY_DIR 4
#define SYSBUS_CREATE_FILE 5
#define SYSBUS_DELETE_FILE 6
#define SYSBUS_MOVE_FILE 7
#define SYSBUS_COPY_FILE 8

class SYSBUS {
    public:
        int createFile(std::string fileName, VBYTE *dataToWrite, int dataSize)
        {
            std::fstream fs;
            fs.open(fileName.c_str(), std::fstream::in);
            if(fs)
            {
                fs.close();
                fs.open(fileName.c_str(), std::fstream::out | std::fstream:: app| std::fstream::binary);
            }
            else fs.open(fileName.c_str(), std::fstream::out | std::fstream::binary);
            fs.write((char*)dataToWrite, dataSize);
            fs.close();
            return 0;
        }
};

#endif
```

`VMCore/include/drivers/win32sysbus.hpp`:

```hpp
#ifndef _WIN32_SYSTEM_BUS_HPP
#define _WIN32_SYSTEM_BUS_HPP

#include "sysbus.hpp"

#ifdef _WIN32_DEV_ENVIRONMENT
    #include <Windows.h>
    #include <tchar.h>
    #include <shellapi.h>

    class WIN32: public SYSBUS {
        public:
            WIN32() { };
            ~WIN32() { };
            int createDirectory(std::string, int);
            int deleteDirectory(std::string);
            int moveDirectory(std::string, std::string);
            int copyDirectory(std::string, std::string);
            int deleteFile(std::string);
            int moveFile(std::string, std::string);
            int copyFile(std::string, std::string);

        private:
            bool deleteDir(LPCTSTR);
            bool copyDir(std::wstring, std::wstring);
            std::wstringstringToWString(const std::string&);
    };
#endif

#endif
```

`VMCore/include/main.hpp`:

```hpp
#ifndef _MAIN_HPP
#define _MAIN_HPP

#include <iostream>
#include <map>
#include "../../SharedCode/datatypes.hpp"

#define MAGIC_NUMBER (uint16_t)0x566d
#define MODE_DEBUG "debug"
#define MODE_EXEC "exec"

#endif //_MAIN_HPP
```

`VMCore/include/memory.hpp`:

```hpp
#ifndef _MEMORY_VM_HPP
#define _MEMORY_VM_HPP

#include "../../SharedCode/datatypes.hpp"
#include "../../SharedCode/memsize.hpp"

typedef struct {
    /* Here will be a code to execute and other data - 50KB*/
    VBYTE codeData[CODE_DATA_SIZE];

    /* Size of one element is VDWORD 
    in order to be able to push addresses. */
    VDWORD stack[STACK_SIZE];

    /* Here will be a user input*/
    VBYTE dataBuffer[INPUT_BUFFER_SIZE];
} ADDRESS_SPACE, *PADDRESS_SPACE;

typedef struct {
    /* General Purpose Registers R0 -> R7 */
    VDWORD R[8];
    struct {
        /* Zero Flag 
            value 1 - flag is set if the result of the last comparison was zero
            value 0 - flag is not set
        */
        unsigned char ZF : 1;
        /* Carry Flag 
            value 1 - flag is set the results of the last comparison was moving
            value 0 - flag is not set
        */
        unsigned char CF : 1;
    };
    /* Program Counter */
    VDWORD PC;
    /* Stack Pointer */
    VDWORD SP;
} REGISTERSS, *PREGISTERSS;


class Memory {  /* ************* TBD ************* */
    private:
        // void writeByteIntoFrame(int, int, std::vector<VBYTE>);
        // std::vector<VBYTE> getByteFromFrame(int, int);
        // int loadFrame(int);
        // void restoreFrame();
        // PADDRESS_SPACE AS;
        // PREGISTERSS REGS;
        
        // std::map<int, int> frameMap;

    public:
        // bool areFramesNeeded;
        Memory() {}
};

#endif //_MEMORY_VM_HPP
```

`VMCore/include/protected.hpp`:

```hpp
#ifndef _VM_PROTECTED_D
#define _VM_PROTECTED_D

#include "../../SharedCode/datatypes.hpp"

/* 
    Here paste a compiled program to be integrated in VMCore.
    VBYTE ProtectedData[] = { 0xFF }; <---- Deafault, no code
*/
VBYTE ProtectedData[] = { 0xFF };

#endif
```

`VMCore/include/screen.hpp`:

```hpp
#ifndef _SCREEN_VM_HPP
#define _SCREEN_VM_HPP

#include <iostream>

enum class SCREEN_MODE { NORMAL = 0, HEX };

class Screen {
    public:
        template<typename DTVM>
        static void vmPrint(DTVM d, SCREEN_MODE sm, bool newLine) { 
            switch(sm) {
                case SCREEN_MODE::NORMAL:
                    std::cout << d;
                    break;
                case SCREEN_MODE::HEX:
                    std::cout << std::hex << d;
                    break;
            }
            if(newLine) std::cout << "\n";
        }
};

#endif //_SCREEN_VM_HPP
```

`VMCore/include/test.hpp`:

```hpp
#ifndef _VM_TEST_HPP
#define _VM_TEST_HPP

#define _VM_CPU_TEST_

#endif //_VM_TEST_HPP
```

`VMCore/include/vmbase.hpp`:

```hpp
#ifndef _VM_BASE_HPP
#define _VM_HPP

class VMBase {
    protected:
        // Opcodes functions
        virtual void funcNop() = 0;
        virtual void funcEE() = 0;
        virtual void funcMov() = 0;
        virtual void funcMovmb() = 0;
        virtual void funcMovmw() = 0;
        virtual void funcMovb() = 0;
        virtual void funcMovw() = 0;
        virtual void funcMovbm() = 0;
        virtual void funcMovwm() = 0;
        virtual void funcMovmrb() = 0;
        virtual void funcMovmrw() = 0;
        virtual void funcMovmd() = 0;
        virtual void funcMovd() = 0;
        virtual void funcMovdm() = 0;
        virtual void funcMovmrd() = 0;
        virtual void funcJmp() = 0;
        virtual void funcJz() = 0;
        virtual void funcJnz() = 0;
        virtual void funcJae() = 0;
        virtual void funcJbe() = 0;
        virtual void funcJb() = 0;
        virtual void funcJa() = 0;
        virtual void funcAdvr() = 0;
        virtual void funcAdrr() = 0;
        virtual void funcAdrrl() = 0;
        virtual void funcSubvr() = 0;
        virtual void funcSubrr() = 0;
        virtual void funcSubrrl() = 0;
        virtual void funcXor() = 0;
        virtual void funcXorl() = 0;
        virtual void funcNot() = 0;
        virtual void funcNotb() = 0;
        virtual void funcAdvrd() = 0;
        virtual void funcSubvrd() = 0;
        virtual void funcShr() = 0;
        virtual void funcShl() = 0;
        virtual void funcCmp() = 0;
        virtual void funcCmpl() = 0;
        virtual void funcVmSysbus() = 0;
        virtual void funcPush() = 0;
        virtual void funcPop() = 0;
        virtual void funcClSt() = 0;
        virtual void funcSetSp() = 0;
};

#endif //_VM_BASE_HPP
```

`VMCore/include/vmcpu.hpp`:

```hpp
#ifndef _VM_CPU_HPP
#define _VM_CPU_HPP

#include <iostream>
#include <string.h>
#include <vector>
#include <sstream>
#include <map>
#include <fstream>
#include <utility>

#include "vmbase.hpp"
#include "screen.hpp"

#ifdef _WIN32_DEV_ENVIRONMENT
    #include <Windows.h>
#else _LINUX_DEV_ENVIRONMENT
    #include <unistd.h>
#endif

// #include <thread>
// #include <mutex>
// #include <condition_variable>

#include "../../SharedCode/global.hpp"
#include "../../SharedCode/opcodes.hpp"
#include "./advancesecurity.hpp"

#ifdef _WIN32_DEV_ENVIRONMENT
    #include "./drivers/win32sysbus.hpp"
#else //_LINUX_DEV_ENVIRONMENT
    #include "./drivers/linuxsysbus.hpp"
#endif

// #define V_DEBUG

#ifdef VMTESTS
    #include "./test.hpp"
#endif //VMTESTS

#include "./memory.hpp"
#include "../../SharedCode/datatypes.hpp"
#include "../../SharedCode/vmdebug.hpp"


#ifdef _VM_CPU_TEST_
    enum class VCpuFlag {OK = 0, ERROR, UNDERFLOW, OVERFLOW};
#endif // _VM_CPU_TEST_

class VMCPU: private VMBase {
    typedef void (VMCPU::*MFP)();

    public:
        bool areFramesNeeded;
        std::map<int, int> frameMap;

    private:
        PADDRESS_SPACE AS;
        PREGISTERSS REGS;
        #ifdef _WIN32_DEV_ENVIRONMENT
            WIN32 *sysBus;
        #else //_LINUX_DEV_ENVIRONMENT
            UNIX *sysBus;
        #endif

        // std::mutex memMutex;
        // std::condition_variable memConditionVar;
        int currentFrameNumber;
        bool isError;
        

    private:
        int executer(VBYTE);
        void getDataFromCodeData(std::string &, int);
        
        /* ******************** MEMORY *********************** */
        void writeByteIntoFrame(int, int, std::vector<VBYTE>);
        std::vector<VBYTE> getByteFromFrame(int, int);
        int loadFrame(int);
        void restoreFrame();
        /* ^^^^^^^^^^^^^ TODO: MOVE TO NEW CLASS ^^^^^^^^^^^^^ */

        int checkOpcodeSize(VBYTE, bool);
        void funcException(std::string e);

        // Opcodes functions
        void funcNop();
        void funcEE();
        void funcMov();
        void funcMovmb();
        void funcMovmw();
        void funcMovb();
        void funcMovw();
        void funcMovbm();
        void funcMovwm();
        void funcMovmrb();
        void funcMovmrw();
        void funcMovmd();
        void funcMovd();
        void funcMovdm();
        void funcMovmrd();
        void funcJmp();
        void funcJz();
        void funcJnz();
        void funcJae();
        void funcJbe();
        void funcJb();
        void funcJa();
        void funcAdvr();
        void funcAdrr();
        void funcAdrrl();
        void funcSubvr();
        void funcSubrr();
        void funcSubrrl();
        void funcXor();
        void funcXorl();
        void funcNot();
        void funcNotb();
        void funcAdvrd();
        void funcSubvrd();
        void funcShr();
        void funcShl();
        void funcCmp();
        void funcCmpl();
        void funcVmSysbus();
        void funcPush();
        void funcPop();
        void funcClSt();
        void funcSetSp();
        void funcPoc();
        void funcPocn();
        void funcTib();
        void funcGic();
        void funcPic();
        void funcPicn();
        void funcPxv();
        void funcPxvn();

        std::map <int, std::pair<int,MFP>> dOpcodesFunction = { 
            {0x56, {0,&VMCPU::funcNop}},
            {0x6d, {0,&VMCPU::funcNop}},
            {NOP, {0,&VMCPU::funcNop}},
            {EE, {0,&VMCPU::funcEE}},
            {MOV, {2,&VMCPU::funcMov}},
            {MOVMB, {3,&VMCPU::funcMovmb}},
            {MOVMW, {3,&VMCPU::funcMovmw}},
            {MOVB, {2,&VMCPU::funcMovb}},
            {MOVW, {3,&VMCPU::funcMovw}},
            {MOVBM, {3,&VMCPU::funcMovbm}},
            {MOVWM, {3,&VMCPU::funcMovwm}},
            {MOVMRB, {2,&VMCPU::funcMovmrb}},
            {MOVMRW, {2,&VMCPU::funcMovmrw}},
            {MOVMD, {3,&VMCPU::funcMovmd}},
            {MOVD, {5,&VMCPU::funcMovd}},
            {MOVDM, {3,&VMCPU::funcMovdm}},
            {MOVMRD, {2,&VMCPU::funcMovmrd}},
            {JMP, {2,&VMCPU::funcJmp}},
            {JZ, {2,&VMCPU::funcJz}},
            {JNZ, {2,&VMCPU::funcJnz}},
            {JAE, {2,&VMCPU::funcJae}},
            {JBE, {2,&VMCPU::funcJbe}},
            {JB, {2,&VMCPU::funcJb}},
            {JA, {2,&VMCPU::funcJa}},
            {ADVR, {3,&VMCPU::funcAdvr}},
            {ADRR, {2,&VMCPU::funcAdrr}},
            {ADRRL, {2,&VMCPU::funcAdrrl}},
            {SUBVR, {3,&VMCPU::funcSubvr}},
            {SUBRR, {2,&VMCPU::funcSubrr}},
            {SUBRRL, {2,&VMCPU::funcSubrrl}},
            {XOR, {2,&VMCPU::funcXor}},
            {XORL, {2,&VMCPU::funcXorl}},
            {NOT, {1,&VMCPU::funcNot}},
            {NOTB, {1,&VMCPU::funcNotb}},
            {ADVRD, {5,&VMCPU::funcAdvrd}},
            {SUBVRD, {5,&VMCPU::funcSubvrd}},
            {SHR, {2,&VMCPU::funcShr}},
            {SHL, {2,&VMCPU::funcShl}},
            {CMP, {2,&VMCPU::funcCmp}},
            {CMPL, {2,&VMCPU::funcCmpl}},
            {VMSYSBUS, {1,&VMCPU::funcVmSysbus}},
            {PUSH, {1,&VMCPU::funcPush}},
            {POP, {1,&VMCPU::funcPop}},
            {CLST, {0,&VMCPU::funcClSt}},
            {SETSP, {4,&VMCPU::funcSetSp}},
            {POC, {0,&VMCPU::funcPoc}},
            {POCN, {0,&VMCPU::funcPocn}},
            {TIB, {0,&VMCPU::funcTib}},
            {GIC, {1,&VMCPU::funcGic}},
            {PIC, {0,&VMCPU::funcPic}},
            {PICN, {0,&VMCPU::funcPicn}},
            {PXV, {0,&VMCPU::funcPxv}},
            {PXVN, {0,&VMCPU::funcPxvn}}
        };

    public:
        VMCPU();
        ~VMCPU();
        void run();
        void debug();
        bool loadCode(VBYTE *, int);
        bool loadCode(int, std::string);

    private:
        VBYTE* loadProtectedCode(int &, std::string);

    #ifdef _VM_CPU_TEST_
    public:
        static const bool bIsOnTest = true;
        VCpuFlag vcpuFlag;

        PADDRESS_SPACE getAS() { return AS; }
        PREGISTERSS getREGS() { return REGS; }
    #endif // _VM_CPU_TEST_
};

#endif //_VM_CPU_HPP
```

`VMCore/src/advancesecurity.cpp`:

```cpp
#include "../include/advancesecurity.hpp"

#ifdef _WIN32_DEV_ENVIRONMENT
    /* ****** TBD ****** */
#else //_LINUX_DEV_ENVIRONMENT
    void AdvanceSecurity::checkPtrace(int argc) {
        int offset = 10;
        if (ptrace(PTRACE_TRACEME, 0, 1, 0) == 0) offset = 66;
        if (ptrace(PTRACE_TRACEME, 0, 1, 0) == -1) offset *= 23;
        if (offset != 66 * 23) {
            unsigned milliseconds = 100 * argc;
            VMCPU *vm = new VMCPU();
            usleep(milliseconds * 1000);
            exit(0);
        }
    }
#endif

void AdvanceSecurity::isHypervisor(void) {
    #ifdef _WIN32_DEV_ENVIRONMENT
        int cpuinfo[4]; 
        __cpuid(cpuinfo, 1);
        if (cpuinfo[2] >> 31 & 1) exit(0);
    #else
        unsigned int eax, ebx, ecx, edx;
        __get_cpuid (1, &eax, &ebx, &ecx, &edx);
        if (ecx >> 31 & 1) exit(0);
    #endif
    
    return;
}
```

`VMCore/src/framesmanager.cpp`:

```cpp
#include "../include/vmcpu.hpp"

void VMCPU::getDataFromCodeData(std::string &arg1, int startFrom)
{
    int counter = startFrom;
    int frameNumberToRestore = currentFrameNumber;
    std::stringstream ss;
    VBYTE b;
    while(true)
    {
        if(areFramesNeeded && (counter >= CODE_DATA_SIZE)) counter = loadFrame(counter);
        b = AS->codeData[counter++];
        if((b == 0x3) && (AS->codeData[counter] == 0xD)) break;
        ss << std::hex << b;
    }
    arg1 = ss.str();
    currentFrameNumber = frameNumberToRestore;
    restoreFrame();
    return;
} 

void VMCPU::writeByteIntoFrame(int bytePosition, int howManyBytes, std::vector<VBYTE> bytes)
{
    #ifdef V_DEBUG
        std::cout << "[DEBUG] Write bytes into frame" << std::endl;
    #endif
    auto sum = 0;
    auto frameNumber = -1;
    for (const auto& [key, value] : frameMap) {
        sum += value;
        if(sum >= (bytePosition + 1))
        {
            frameNumber = key;
            break;
        }
    }
    if(frameNumber == -1) goto error_getByteFromFrame;
    else
    {
        char byte;
        std::vector<VBYTE> readData;
        std::string frameToLoadName = ".cached." + std::to_string(frameNumber) + ".frame";
        std::ifstream fileBinToRead;
        std::ofstream fileBinToWrite;
        fileBinToRead.open(frameToLoadName, std::ios::binary);
        auto positionToGet = frameMap[frameNumber] - (sum - bytePosition);
        auto counter = 0;
        if(fileBinToRead.is_open())
        {
            while(fileBinToRead.get(byte))
            {
                ++counter;
                readData.push_back(byte);
            }
            fileBinToRead.close();
            
            for(auto i = 0; i < howManyBytes; i++) readData[positionToGet++] = bytes[i];
            
            fileBinToWrite.open(frameToLoadName.c_str(), std::fstream::out | std::ios::binary);
            VBYTE *dataToWrite = &readData[0];
            fileBinToWrite.write((char*)dataToWrite, counter-1);
            fileBinToWrite.close();
        }
        else goto error_getByteFromFrame;
    }
    goto ok_getByteFromFrame;

error_getByteFromFrame:
    #ifdef V_DEBUG
        std::cout << "[ERROR] Write bytes into frame" << std::endl;
    #endif
    isError = true;
    return;
ok_getByteFromFrame:
    isError = false;
    return;
}

std::vector<VBYTE> VMCPU::getByteFromFrame(int bytePosition, int howManyBytes)
{
    #ifdef V_DEBUG
        std::cout << "[DEBUG] Get a byte from frame" << std::endl;
    #endif
    std::vector<VBYTE> readBytes;
    char byte;
    auto sum = 0;
    auto frameNumber = -1;
    for (const auto& [key, value] : frameMap) {
        sum += value;
        if(sum >= (bytePosition + 1))
        {
            frameNumber = key;
            break;
        }
    }
    if(frameNumber == -1) goto error_getByteFromFrame;
    else
    {
        std::string frameToLoadName = ".cached." + std::to_string(frameNumber) + ".frame";
        std::ifstream fileBinToRead;
        fileBinToRead.open(frameToLoadName, std::ios::binary);
        auto positionToGet = frameMap[frameNumber] - (sum - bytePosition);
        if(fileBinToRead.is_open())
        {
            auto counter = 0;
            while(fileBinToRead.get(byte))
            {
                if(counter == positionToGet)
                { 
                    readBytes.push_back(byte);
                    --howManyBytes;
                    ++positionToGet;
                    if(howManyBytes == 0) break;
                }
                ++counter;
            }
            fileBinToRead.close();
        }
        else goto error_getByteFromFrame;
    }
    goto ok_getByteFromFrame;

error_getByteFromFrame:
    #ifdef V_DEBUG
        std::cout << "[ERROR] Failed get a byte from frame" << std::endl;
    #endif
    isError = true;
    readBytes.push_back(0x0);
    return readBytes;
ok_getByteFromFrame:
    isError = false;
    return readBytes;
}

int VMCPU::loadFrame(int pc)
{
    #ifdef V_DEBUG
        std::cout << "[DEBUG] Load a frame" << std::endl;
    #endif
    auto sum = 0;
    auto frameNumber = -1;
    for (const auto& [key, value] : frameMap) {
        sum += value;
        if(sum >= (pc+1))
        {
            frameNumber = key;
            break;
        }
    }

    if(frameMap[currentFrameNumber] == pc)
    {
        frameNumber = currentFrameNumber + 1;
        pc = 0;
        sum = frameMap[frameNumber];
    }

    #ifdef V_DEBUG
        std::cout << "[DEBUG] Frame number: " << frameNumber << std::endl;
    #endif
    if(frameNumber == -1) goto error_loadFrame;
    else
    {
        std::string frameToLoadName = ".cached." + std::to_string(frameNumber) + ".frame";
        std::ifstream fileBinToRead;
        fileBinToRead.open(frameToLoadName, std::ios::binary);
        if(fileBinToRead.is_open())
        {
            char vb;
            auto counter = 0;
            memset(AS->codeData, 0, CODE_DATA_SIZE*sizeof(*(AS->codeData)));
            while(fileBinToRead.get(vb)) AS->codeData[counter++] = vb;
            fileBinToRead.close();
        }
        else goto error_loadFrame;
    }
    goto ok_loadFrame;

error_loadFrame:
    #ifdef V_DEBUG
        std::cout << "[ERROR] Failed load a frame" << std::endl;
    #endif
    isError = true;
    return 0;

ok_loadFrame:
    currentFrameNumber = frameNumber;
    isError = false;
    return (frameMap[frameNumber] - (sum - pc));
}

void VMCPU::restoreFrame()
{
    #ifdef V_DEBUG
        std::cout << "[DEBUG] Restore a frame" << std::endl;
    #endif
    std::string frameToLoadName = ".cached." + std::to_string(currentFrameNumber) + ".frame";
    std::ifstream fileBinToRead;
    fileBinToRead.open(frameToLoadName, std::ios::binary);
    if(fileBinToRead.is_open())
    {
        char vb;
        auto counter = 0;
        memset(AS->codeData, 0, CODE_DATA_SIZE*sizeof(*(AS->codeData)));
        while(fileBinToRead.get(vb)) AS->codeData[counter++] = vb;
        fileBinToRead.close();
    }
    else goto error_restoreFrame;
    goto ok_restoreFrame;

error_restoreFrame:
    #ifdef V_DEBUG
        std::cout << "[ERROR] Failed restore a frame" << std::endl;
    #endif
    isError = true;
    return;
ok_restoreFrame:
    isError = false;
    return;
}
```

`VMCore/src/linuxsysbus.cpp`:

```cpp
#include "../include/drivers/linuxsysbus.hpp"

#ifdef _LINUX_DEV_ENVIRONMENT
    int UNIX::createDirectory(std::string dirName, int dirMode)
    {
        struct stat st = {0};
        if (stat(dirName.c_str(), &st) == -1) // checking if the directory exists
        {
            if(!mkdir(dirName.c_str(), getMode(dirMode))) return DIR_CREATED_ERROR;
            return DIR_CREATED;
        }
        else return DIR_EXIST;
    }

    int UNIX::deleteDirectory(std::string dirName)
    {
        struct stat st = {0};
        if(stat(dirName.c_str(), &st) == 0)
        {
            if(!rmdir(dirName.c_str())) return DELETE_DIR;
            else return OTHER_DIR_ERROR;
        }
        else return OTHER_DIR_ERROR;
    }

    int UNIX::moveDirectory(std::string dirSource, std::string dirDest)
    {
        // No implemented yet
        return NO_IMPLEMENTED_ERROR;
    }

    int UNIX::copyDirectory(std::string dirSource, std::string dirDest)
    {
        // No implemented yet
        return NO_IMPLEMENTED_ERROR;
    }

    int UNIX::deleteFile(std::string filePath)
    {
        if(!remove(filePath.c_str())) return DELETE_FILE;
        else return OTHER_FILE_ERROR;
    }

    int UNIX::moveFile(std::string sourcePath, std::string destPath)
    {
        if(!rename(sourcePath.c_str(), destPath.c_str())) return MOVE_FILE;
        else return OTHER_FILE_ERROR;
    }

    int UNIX::copyFile(std::string sourcePath, std::string destPath)
    {
        const char *to = destPath.c_str();
        const char *from = sourcePath.c_str();
        int fd_to, fd_from;
        char buf[4096];
        ssize_t nread;

        fd_from = open(from, O_RDONLY);
        if (fd_from < 0) return OTHER_FILE_ERROR;

        fd_to = open(to, O_WRONLY | O_CREAT | O_EXCL, 0666);
        if (fd_to < 0)
        {
            close(fd_from);
            if (fd_to >= 0) close(fd_to);
            return OTHER_FILE_ERROR;
        }

        while (nread = read(fd_from, buf, sizeof buf), nread > 0)
        {
            char *out_ptr = buf;
            ssize_t nwritten;

            do {
                nwritten = write(fd_to, out_ptr, nread);

                if (nwritten >= 0)
                {
                    nread -= nwritten;
                    out_ptr += nwritten;
                }
                else if (errno != EINTR)
                {
                    close(fd_from);
                    if (fd_to >= 0) close(fd_to);
                    return OTHER_FILE_ERROR;
                }
            } while (nread > 0);
        }

        if (nread == 0)
        {
            if (close(fd_to) < 0)
            {
                fd_to = -1;
                close(fd_from);
                if (fd_to >= 0) close(fd_to);
                return OTHER_FILE_ERROR;
            }
            close(fd_from);
            return COPY_FILE;
        }

        close(fd_from);
        if (fd_to >= 0) close(fd_to);
        return OTHER_FILE_ERROR;
    }

    mode_t UNIX::getMode(int m)
    {
        mode_t mode = 0;
        std::string s = std::to_string(m);
        // 1111111111 == rwxrwxrwx
        // 1000000000 == ---------
        const char *perm = s.c_str();

        if (perm[1] == '1') mode |= 0400;
        if (perm[2] == '1') mode |= 0200;
        if (perm[3] == '1') mode |= 0100;
        if (perm[4] == '1') mode |= 0040;
        if (perm[5] == '1') mode |= 0020;
        if (perm[6] == '1') mode |= 0010;
        if (perm[7] == '1') mode |= 0004;
        if (perm[8] == '1') mode |= 0002;
        if (perm[9] == '1') mode |= 0001;

        return mode;
    }

#endif
```

`VMCore/src/loader.cpp`:

```cpp
#include "../include/main.hpp"
#include "../include/vmcpu.hpp"
#include <string.h>
#include <fstream>
#include <vector>

// #include <bitset>

#define CODE_DATA_SIZE 51200

bool VMCPU::loadCode(VBYTE *mcode, int mcsize)
{
    memset(AS->codeData, 0, CODE_DATA_SIZE*sizeof(*(AS->codeData)));
    memset(AS->stack, 0, STACK_SIZE*sizeof(*(AS->stack)));
    memset(AS->dataBuffer, 0, INPUT_BUFFER_SIZE*sizeof(*(AS->dataBuffer)));
    if((unsigned) (mcsize) > (sizeof(AS->codeData) / sizeof(AS->codeData[0]))) 
    {
        std::cout << "[ERROR 101001] TOO BIG A CODE TO EXECUTE!\n";
        return false;
    }
    memcpy(AS->codeData, mcode, mcsize);
    for(int i = 0; i < 8; i++)
    {
        REGS->R[i] = (VDWORD) 0;
    }
    REGS->CF = 0;
    REGS->ZF = 0;
    return true;
}

bool VMCPU::loadCode(int mcsize, std::string fileName) 
{
    auto *mc = loadProtectedCode(mcsize, fileName);
    auto valToReturn = false;
    if(loadCode(mc, mcsize)) valToReturn = true;
    delete mc;
    return valToReturn;
}

int VMCPU::checkOpcodeSize(VBYTE opcode, bool isOpcode) 
{
    if(!isOpcode) return 0;
    else
    {
        if(dOpcodesFunction.find(opcode) == dOpcodesFunction.end()) return 0;
        else return dOpcodesFunction[opcode].first;
    }
}

VBYTE* VMCPU::loadProtectedCode(int &mcsize, std::string fileName)
{
    VBYTE *mc;
    std::ifstream fileBinToRead;
    std::ofstream fileBinToWrite;
    int framesCount;
    
    fileBinToRead.open(fileName, std::ios::binary);

    if(fileBinToRead.is_open())
    {
        fileBinToRead.seekg(0, fileBinToRead.end);
        mcsize = fileBinToRead.tellg();
        fileBinToRead.seekg(0, fileBinToRead.beg);

        VWORD highVBYTE = fileBinToRead.get();
        VWORD lowVBYTE = fileBinToRead.get();
        // std::cout << std::bitset<8>(highVBYTE) << std::endl;
        // std::cout << std::hex << highVBYTE << std::endl;
        VDWORD magicNumber = (highVBYTE << 8) | lowVBYTE;

        if(magicNumber != MAGIC_NUMBER)
        {
            fileBinToRead.close();
            throw 100012;
        }
        
        if(mcsize > CODE_DATA_SIZE)
        {
            areFramesNeeded = true;
            framesCount = int((mcsize + CODE_DATA_SIZE - 1) / CODE_DATA_SIZE);
            for(int i = 0; i < framesCount; i++) frameMap[i] = 0;
        }

        fileBinToRead.seekg(0, fileBinToRead.beg);

        mc = new VBYTE[mcsize];
        char vb;
        int counter = 0;
        framesCount = 0;
        std::string tempFileToOpen;
        std::vector<VBYTE> readData;
        int argCount = 0;
        bool isOpcode;

        if(areFramesNeeded) {
            tempFileToOpen = ".cached." + std::to_string(framesCount++) + ".frame";
            fileBinToWrite.open(tempFileToOpen.c_str(), std::fstream::out | std::ios::binary);
        }
        while(fileBinToRead.get(vb))
        {   
            if(areFramesNeeded) {
                ++counter;
                if(argCount == 0) 
                {
                    isOpcode = true;
                    argCount = checkOpcodeSize(vb, isOpcode);
                }
                else if(vb == 0xEE)
                {
                    argCount = -1;
                    isOpcode = false;
                }
                else
                {
                    --argCount;
                    isOpcode = false;
                }
                if((counter + checkOpcodeSize(vb, isOpcode)) > CODE_DATA_SIZE) {
                    frameMap[framesCount - 1] = counter - 1;
                    VBYTE *dataToWrite = &readData[0];
                    fileBinToWrite.write((char*)dataToWrite, counter-1);
                    fileBinToWrite.close();

                    std::string tempFileToOpen = ".cached." + std::to_string(framesCount++) + ".frame";
                    fileBinToWrite.open(tempFileToOpen.c_str(), std::fstream::out | std::ios::binary);
                    
                    readData.clear();
                    readData.push_back(vb);
                    counter = 1;
                }
                else 
                {
                    if(framesCount == 1) mc[counter - 1] = vb;
                    readData.push_back(vb);
                }
            }
            else {
                mc[counter++] = vb;
                //std::cout << "\t<READ> : " << static_cast<uint16_t>(mc[counter - 1]) << std::endl;
            }
        }
        if(areFramesNeeded)
        {
            mcsize = frameMap[0];
            VBYTE *dataToWrite = &readData[0];
            frameMap[framesCount - 1] = counter;
            fileBinToWrite.write((char*)dataToWrite, counter);
            fileBinToWrite.close();
        }
        fileBinToRead.close();
    }
    else
    {
        throw 100010;
    }
    return mc;
}
```

`VMCore/src/main.cpp`:

```cpp
/*
    VMCore - a virtual machine that simulates a CPU, allows to perform arithmetic operations, 
    reads and writes to memory and interacts with I/O devices. It can understand a machine
    language which can be used to program it.
    
    Copyright (C) eaglx.
    version 0.4.190222.2030
*/
#include "../../SharedCode/global.hpp"
#include "../include/main.hpp"
#include "../include/vmcpu.hpp"
#include "../include/protected.hpp"
// #include <sstream>

void showUsage()
{
    std::cout << "Usage:"
                << "\t-m value\t\tSet program mode. The value can be debug or exec\n"
                << "\t-p filename\t\tPath to a file to execute"
                << std::endl;
}

int runVM(int argc, char *argv[])
{
    VMCPU *vm = new VMCPU();

    if(argc == 1) {
        if(ProtectedData[0] == 0xFF)
        {
            showUsage();
            return 0;
        }
        else
        {
            if(!vm->loadCode(ProtectedData, sizeof(ProtectedData)/sizeof(ProtectedData[0]))) return -1; //TODO: rewrite
  
            try {
                vm->run();
                return 0;
            } catch(...) {
                return -1;
            }
        }
    }

    std::string mode = "";
    std::string path_to_file = "";

    for(int i = 1; i < argc; i++) {
        std::string arg = argv[i];

        if(arg == "-h") {
            showUsage();
            return 0;
        }
        else if(arg == "-m") {
            i += 1;
            mode =  argv[i];
        }
        else if(arg == "-p") {
            i += 1;
            path_to_file = argv[i];
        }
        else {
            showUsage();
            return 0;
        }
    }

    try { if(!vm->loadCode(0, path_to_file)) { delete vm; return -1; } }
    catch (int e) {
        std::cout << "[ERROR " << e << "] NO FILE OR SE \n";
        return -1;
    }

    if(mode.compare(MODE_DEBUG) == 0) vm->debug();
    else if(mode.compare(MODE_EXEC) == 0) {
        try{ vm->run(); delete vm; } catch(...) { return -1; }
    }
    else {
        std::cout << "[ERROR 100101] INCORRECT MODE!\n";
        return -1;
    }
    return 0;
}

int main(int argc, char *argv[])
{
    #ifdef _WIN32_DEV_ENVIRONMENT
        AdvanceSecurity::isHypervisor();
        return runVM(argc, argv);
    #else //_LINUX_DEV_ENVIRONMENT
        AdvanceSecurity::isHypervisor();
        AdvanceSecurity::checkPtrace(argc);
        return runVM(argc, argv);
    #endif
}

```

`VMCore/src/vmcpu.cpp`:

```cpp
#include "../include/vmcpu.hpp"

#ifdef _WIN32_DEV_ENVIRONMENT
    #include <string>
#endif

// #include <bitset>

VMCPU::VMCPU()
{
    AS = (PADDRESS_SPACE) new ADDRESS_SPACE;
    REGS = (PREGISTERSS) new REGISTERSS;

    memset(AS->codeData, 0, sizeof(AS->codeData));

    REGS->PC = 0;
    REGS->SP = sizeof(AS->stack) / sizeof(VDWORD);

    areFramesNeeded = false;
    currentFrameNumber = 0;
    isError = false;

    #ifdef _WIN32_DEV_ENVIRONMENT
        sysBus = new WIN32();
    #else //_LINUX_DEV_ENVIRONMENT
        sysBus = new UNIX();
    #endif
}

VMCPU::~VMCPU()
{
    if(areFramesNeeded)
    {
        std::string fileNameToRemove;
        for (const auto& [key, value] : frameMap) 
        {
            fileNameToRemove = "./.cached." + std::to_string(key) + ".frame";
            int retVal = sysBus->deleteFile(fileNameToRemove);
        }
    }
    delete AS;
    delete REGS;
    delete sysBus;
    dOpcodesFunction.clear();
}

void VMCPU::run()
{
    isError = false;
    bool exit = false;
    VBYTE opcode;

    while(!exit)
    {
        if(areFramesNeeded && (REGS->PC >= frameMap[currentFrameNumber])) REGS->PC = loadFrame(REGS->PC);
        if(isError) return;
        opcode = AS->codeData[REGS->PC++];
        exit = executer(opcode);
    }
    return;
}

```

`VMCore/src/vmcpudbg.cpp`:

```cpp
#include "../include/vmcpu.hpp"

void VMCPU::debug()
{
#ifndef VMTESTS
    bool debugLoop = true;
    
    #ifdef _WIN32_DEV_ENVIRONMENT
        //Initialize Winsock
        WSADATA wsaData;
        int iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
        if (iResult != NO_ERROR)
        {
            std::cout << "[ERROR " << iResult << "] WSAStartup failed" << std::endl;
            exit(iResult);;
        }
        //Create a SOCKET for listening for incoming connections request
        SOCKET serverSocket, debuggerSocket;
        serverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serverSocket == INVALID_SOCKET)
        {
            std::cout << "[ERROR " << WSAGetLastError() << "] Socket failed" << std::endl;
            WSACleanup();
            exit(WSAGetLastError());
        }

        sockaddr_in addrServer;
        addrServer.sin_family = AF_INET;
        InetPton(AF_INET, _T("127.0.0.1"), &addrServer.sin_addr.s_addr);
        addrServer.sin_port = htons(PORT);
        memset(&(addrServer.sin_zero), '\0', 8);

        //Bind socket
        if (bind(serverSocket, (SOCKADDR*)&addrServer, sizeof(addrServer)) == SOCKET_ERROR)
        {
            std::cout << "[ERROR " << WSAGetLastError() << "] Bind failed" << std::endl;
            closesocket(serverSocket);
            WSACleanup();
            exit(WSAGetLastError());
        }

        debuggerSocket = accept(serverSocket, NULL, NULL);
        if (debuggerSocket == INVALID_SOCKET)
        {
            std::cout << "[ERROR " << WSAGetLastError() << "] Accept failed" << std::endl;
            closesocket(serverSocket);
            WSACleanup();
            exit(WSAGetLastError());
        }

        closesocket(serverSocket);
    #else //_LINUX_DEV_ENVIRONMENT
        int serverSocket, debuggerSocket;
        struct sockaddr_in address;
        int opt = 1; 
        int addrlen = sizeof(address);

        if((serverSocket = socket(AF_INET, SOCK_STREAM, 0)) == 0) 
        { 
            std::cout << "[ERROR 101002] Socket failed in debug\n";
            exit(EXIT_FAILURE); 
        }

        if(setsockopt(serverSocket, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) 
        { 
            std::cout << "[ERROR 101003] setsockopt in debug\n";
            exit(EXIT_FAILURE); 
        }

        address.sin_family = AF_INET;
        address.sin_addr.s_addr = INADDR_ANY;
        address.sin_port = htons(PORT);

        if(bind(serverSocket, (struct sockaddr *)&address, sizeof(address))<0) 
        { 
            std::cout << "[ERROR 101004] Bind failed in debug\n";
            exit(EXIT_FAILURE);
        } 
        if (listen(serverSocket, 3) < 0) 
        { 
            std::cout << "[ERROR 101005] Listen failed in debug\n";
            exit(EXIT_FAILURE);
        } 
        if ((debuggerSocket = accept(serverSocket, (struct sockaddr *)&address, (socklen_t*)&addrlen))<0) 
        { 
            std::cout << "[ERROR 101006] Accept failed in debug\n";
            exit(EXIT_FAILURE);
        }
    #endif

        VBYTE opcode;
        MESSAGE_TO_DEBUGGER msgToDebg;
        MESSAGE_FROM_DEBUGGER msgFromDebg;
        char bufferMSGtoDbg[PACKET_TO_DEBUGGER_SIZE];
        char bufferMSGfromDbg[PACKET_FROM_DEBUGGER_SIZE];
        int retValFromFunc;
        while(debugLoop)
        {
            memcpy(msgToDebg.R, REGS->R, 32);
            msgToDebg.PC = REGS->PC;
            msgToDebg.SP = REGS->SP;
            memcpy(msgToDebg.stack, AS->stack, STACK_SIZE);
            for(int asStI = 0; asStI < STACK_SIZE; asStI++) { msgToDebg.stack[asStI] = AS->stack[asStI]; }
            msgToDebg.ZF = REGS->ZF;
            msgToDebg.CF = REGS->CF;
            memcpy(msgToDebg.codeData, AS->codeData, CODE_DATA_SIZE);
            memcpy(msgToDebg.dataBuffer, AS->dataBuffer, INPUT_BUFFER_SIZE);
            serializeMSG(&msgToDebg, bufferMSGtoDbg);

            retValFromFunc = sendData(debuggerSocket, bufferMSGtoDbg, PACKET_TO_DEBUGGER_SIZE);
            if(retValFromFunc == SEND_ERROR)
            {
                std::cout << "[ERROR 101007] Failed send data in debug\n";
                #ifdef _WIN32_DEV_ENVIRONMENT
                    closesocket(debuggerSocket);
                    WSACleanup();
                #else //_LINUX_DEV_ENVIRONMENT
                    close(debuggerSocket);
                    close(serverSocket);
                #endif
                debugLoop = false;
                exit(-101007);
            }

            retValFromFunc = recvData(debuggerSocket, bufferMSGfromDbg, PACKET_FROM_DEBUGGER_SIZE);
            if(retValFromFunc == RECIVE_ERROR)
            {
                std::cout << "[ERROR 101008] Failed receive data in debug\n";
                #ifdef _WIN32_DEV_ENVIRONMENT
                    closesocket(debuggerSocket);
                    WSACleanup();
                #else //_LINUX_DEV_ENVIRONMENT
                    close(debuggerSocket);
                    close(serverSocket);
                #endif
                debugLoop = false;
                exit(-101008);
            }
            deserializeMSG(&msgFromDebg, bufferMSGfromDbg);

            switch(msgFromDebg.cmdFlag)
            {
                case CMD_RUN:
                    {
                        bool exit = false;
                        while(!exit)
                        {
                            opcode = AS->codeData[REGS->PC++];
                            exit = executer(opcode);
                        }
                    }
                    break;
                case CMD_STEP:
                    opcode = AS->codeData[REGS->PC++];
                    executer(opcode);
                    break;
                case CMD_EXIT:
                    debugLoop = false;
                    break;
                case CMD_SET_PC:
                    REGS->PC = *(VDWORD*) &msgFromDebg.buffer[0];
                    break;
                case CMD_SET_SP:
                    REGS->SP = *(VDWORD*) &msgFromDebg.buffer[0];
                    break;
                case CMD_SET_R:
                    {
                        int regNr = msgFromDebg.buffer[0] - '0';
                        REGS->R[regNr] = *(VDWORD*) &msgFromDebg.buffer[1];
                    }
                    break;
                case CMD_SET_ZF:
                    if(msgFromDebg.buffer[0] == '0'|| msgFromDebg.buffer[0] == '1') REGS->ZF = msgFromDebg.buffer[0];
                    break;
                case CMD_SET_CF:
                    if(msgFromDebg.buffer[0] == '0'|| msgFromDebg.buffer[0] == '1') REGS->CF = msgFromDebg.buffer[0];
                    break;
                case CMD_WRITE_MEM:
                    {
                        int VBYTEToWrite = msgFromDebg.buffer[0] - '0';
                        for(int i = 0; i < VBYTEToWrite; i++) { AS->codeData[REGS->PC++] = msgFromDebg.buffer[i + 1]; }
                    }
                    break;
                default:
                    std::cout << "[ERROR 101009] Unkonown command!\n";
            }
        }

    #ifdef _WIN32_DEV_ENVIRONMENT
        closesocket(debuggerSocket);
        WSACleanup();
    #else //_LINUX_DEV_ENVIRONMENT
        close(debuggerSocket);
        close(serverSocket);
    #endif
#endif
    return;
}
```

`VMCore/src/vmcpuexecuter.cpp`:

```cpp
#include "../include/vmcpu.hpp"

int VMCPU::executer(VBYTE opcode)
{
    int valToReturn = 0;
    if(opcode == EE) valToReturn = 1;
    else {
        if(dOpcodesFunction.find(opcode) == dOpcodesFunction.end()) {
            funcException("[ERROR] unknown opcode!");
            isError = true;
            valToReturn = -1;
        }
        else {
            MFP fp = dOpcodesFunction[opcode].second;
            (this->*fp)();
        }
    }
    return valToReturn;
}

void VMCPU::funcException(std::string e)
{
    #ifdef _VM_CPU_TEST_
        if(vcpuFlag == VCpuFlag::OK) vcpuFlag = VCpuFlag::ERROR;
    #endif
    #ifndef _VM_CPU_TEST_
        std::cout << "[ERROR] vCPU CRASH!" << std::endl;
        std::cout << "[ERROR] INFO: " << e << std::endl;
    #endif
    isError = true;
    areFramesNeeded = false;
}

/* NOP */
void VMCPU::funcNop()
{
    #ifdef V_DEBUG
        std::cout << "[DEBUG] NOP" << std::endl;
    #endif
}

/* EE - end of code */
void VMCPU::funcEE()
{
    #ifdef V_DEBUG
        std::cout << "[DEBUG] EE" << std::endl;
    #endif
    //valToReturn = 1;
}

/*
    MOV - move from register to register
    01 02 05 => MOV R2, R5
    01 00 00 => MOV R0, R0
*/
void VMCPU::funcMov()
{
    VBYTE bTmp_0;
    VBYTE bTmp_1;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] MOV" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    bTmp_1 = AS->codeData[REGS->PC++];
    #ifdef V_DEBUG
        std::cout << std::hex << REGS->R[bTmp_0] << std::endl;
        std::cout << std::hex << REGS->R[bTmp_1] << std::endl;
        // std::cout << std::hex << bTmp_0 << "\n";
        // std::cout << std::hex << bTmp_1 << "\n";
        // std::cout << std::bitset<8>(bTmp_0) << std::endl;
        // std::cout << std::bitset<8>(bTmp_1) << std::endl;
    #endif
    if((bTmp_0 >= 0 && bTmp_0 <= 7) && (bTmp_1 >= 0 && bTmp_1 <= 7))
    {
        REGS->R[bTmp_0] = REGS->R[bTmp_1];
    }
    else funcException("register index out of range!");
}

/* 
    MOVMB - move and extend byte from memory to register 
    02 03 04 01 => MOVMB R3, 0104
*/
void VMCPU::funcMovmb()
{
    VBYTE bTmp_0;
    VWORD wTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] MOVMB" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    wTmp_0 = *(VWORD*) &AS->codeData[REGS->PC];
    //if(wTmp_0 >= sizeof(AS->codeData)) funcException("memory index out of range!");
    REGS->PC += 2;
    REGS->R[bTmp_0] = 0;
    if(areFramesNeeded && (wTmp_0 >= frameMap[currentFrameNumber]))
    {
        std::vector<VBYTE> bytes = getByteFromFrame(wTmp_0, 1);
        if(isError) funcException("get byte from frame!");
        *(VBYTE*) &REGS->R[bTmp_0] = bytes[0];
    }
    else *(VBYTE*) &REGS->R[bTmp_0] = AS->codeData[wTmp_0];
}

/* 
    MOVMW - move and extend word from memory to register 
    03 03 04 01 => MOVMW R3, 0104
*/
void VMCPU::funcMovmw()
{
    VBYTE bTmp_0;
    VWORD wTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] MOVMW" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    wTmp_0 = *(VWORD*) &AS->codeData[REGS->PC];
    //if(wTmp_0 >= sizeof(AS->codeData)) funcException("memory index out of range!");
    REGS->PC += 2;
    if(areFramesNeeded && (wTmp_0 >= frameMap[currentFrameNumber]))
    {
        std::vector<VBYTE> bytes = getByteFromFrame(wTmp_0, 2);
        if(isError) funcException("get byte from frame!");
        VBYTE hb = bytes[0];
        VBYTE lb = bytes[1];
        VWORD w = ((VWORD) hb << 8) | lb;
        *(VWORD*) &REGS->R[bTmp_0] = w;
    }
    else *(VWORD*) &REGS->R[bTmp_0] = *(VWORD*) &AS->codeData[wTmp_0];
}

/* 
    MOVB - move and extend byte to register 
    04 02 43 => MOVB R2, 43
*/
void VMCPU::funcMovb()
{
    VBYTE bTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] MOVB" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    REGS->R[bTmp_0] = 0;
    *(VBYTE *) &REGS->R[bTmp_0] = AS->codeData[REGS->PC++];
}

/* 
    MOVW - move and extend word to register 
    05 01 15 28 => MOVW R1, 2815
*/
void VMCPU::funcMovw()
{
    VBYTE bTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] MOVW" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    *(VWORD*) &REGS->R[bTmp_0] = *(VWORD *) &AS->codeData[REGS->PC];
    REGS->PC += 2;
}

/* 
    MOVBM - move byte from register to memory location 
    07 43 13 04 => MOVBM 1343, R4
*/
void VMCPU::funcMovbm()
{
    VBYTE bTmp_0;
    VWORD wTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] MOVBM" << std::endl;
    #endif
    wTmp_0 = *(VWORD*) &AS->codeData[REGS->PC];
    //if(wTmp_0 >= sizeof(AS->codeData)) funcException("memory index out of range!");
    REGS->PC += 2;
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    if(areFramesNeeded && (wTmp_0 >= frameMap[currentFrameNumber]))
    {
        std::vector<VBYTE> byteToWrite;
        byteToWrite.push_back(*(VBYTE*) &REGS->R[bTmp_0]);
        writeByteIntoFrame(wTmp_0, 1, byteToWrite);
        if(isError) funcException("write byte to frame!");
    }
    else AS->codeData[wTmp_0] = *(VBYTE*) &REGS->R[bTmp_0];
}

/* 
    MOVWM - move word from register to memory location 
    07 43 13 04 => MOVWM 1343,R4
*/
void VMCPU::funcMovwm()
{
    VBYTE bTmp_0;
    VWORD wTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] MOVWM" << std::endl;
    #endif
    wTmp_0 = *(VWORD*) &AS->codeData[REGS->PC];
    //if(wTmp_0 >= sizeof(AS->codeData)) funcException("memory index out of range!");
    REGS->PC += 2;
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    if(areFramesNeeded && (wTmp_0 >= frameMap[currentFrameNumber]))
    {
        std::vector<VBYTE> byteToWrite;
        VWORD w = *(VWORD*) &REGS->R[bTmp_0];
        byteToWrite.push_back(w >> 8);
        byteToWrite.push_back(w & 0xff);
        writeByteIntoFrame(wTmp_0, 2, byteToWrite);
        if(isError) funcException("write byte to frame!");
    }
    else *(VWORD*) &AS->codeData[wTmp_0] = REGS->R[bTmp_0];
}

/* 
    MOVMRB - move and extend byte from memory to register
            get addr from register
    08 02 01 => MOVMRB R2, R1
*/
void VMCPU::funcMovmrb()
{
    VBYTE bTmp_0;
    VBYTE bTmp_1;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] MOVMRB" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    bTmp_1 = AS->codeData[REGS->PC++];
    if(bTmp_1 > 8) funcException("register index out of range!");
    //if(REGS->R[bTmp_1] >= sizeof(AS->codeData)) funcException("memory index out of range!");
    REGS->R[bTmp_0] = 0;
    if(areFramesNeeded && (REGS->R[bTmp_1] >= frameMap[currentFrameNumber]))
    {
        std::vector<VBYTE> bytes = getByteFromFrame(REGS->R[bTmp_1], 1);
        if(isError) funcException("get byte from frame!");
        *(VBYTE*) &REGS->R[bTmp_0] = bytes[0];
    }
    else *(VBYTE*) &REGS->R[bTmp_0] = AS->codeData[REGS->R[bTmp_1]];
}

/* 
    MOVMRW - move and extend word from memory to register
            get addr from register
    09 02 01 => MOVMRW R2, R1
*/
void VMCPU::funcMovmrw()
{
    VBYTE bTmp_0;
    VBYTE bTmp_1;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] MOVMRW" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    bTmp_1 = AS->codeData[REGS->PC++];
    if(bTmp_1 > 8) funcException("register index out of range!");
    //if(REGS->R[bTmp_1] >= sizeof(AS->codeData))  funcException("memory index out of range!");
    if(areFramesNeeded && (REGS->R[bTmp_1] >= frameMap[currentFrameNumber]))
    {
        std::vector<VBYTE> bytes = getByteFromFrame(REGS->R[bTmp_1], 2);
        if(isError) funcException("get byte from frame!");
        VBYTE hb = bytes[0];
        VBYTE lb = bytes[1];
        VWORD w = ((VWORD) hb << 8) | lb;
        *(VWORD*) &REGS->R[bTmp_0] = w;
    }
    else *(VWORD*) &REGS->R[bTmp_0] = *(VWORD*) &AS->codeData[REGS->R[bTmp_1]];
}

/* 
    MOVMD - move double word from memory to register 
    0A 03 04 01 => MOVMW R3, 0104
*/
void VMCPU::funcMovmd()
{
    VBYTE bTmp_0;
    VBYTE bTmp_1;
    VDWORD dTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] MOVMD" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    dTmp_0 = *(VDWORD*) &AS->codeData[REGS->PC];
    //if(dTmp_0 >= sizeof(AS->codeData)) funcException("memory index out of range!");
    REGS->PC += 2;
    if(areFramesNeeded && (dTmp_0 >= frameMap[currentFrameNumber]))
    {
        std::vector<VBYTE> bytes = getByteFromFrame(dTmp_0, 4);
        if(isError) funcException("get byte from frame!");
        VBYTE hb3 = bytes[0];
        VBYTE hb2 = bytes[1];
        VBYTE hb1 = bytes[2];
        VBYTE lb = bytes[3];
        VDWORD dw = ((VDWORD) hb3 << 24) | ((VDWORD) hb2 << 16) | ((VDWORD) hb1 << 8) | lb;
        REGS->R[bTmp_0] = dw;
    }
    else REGS->R[bTmp_0] = *(VDWORD*) &AS->codeData[dTmp_0];
}

/* 
    MOVD - move value to register 
    0B 01 00 00 15 28 => MOVW R1, 2815
*/
void VMCPU::funcMovd()
{
    VBYTE bTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] MOVD" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    REGS->R[bTmp_0] = *(VDWORD *) &AS->codeData[REGS->PC];
    REGS->PC += 4;
}

/* 
    MOVDM - move double word from register to memory location 
    0C 43 13 04 => MOVWM 1343, R4
*/
void VMCPU::funcMovdm()
{
    VBYTE bTmp_0;
    VWORD wTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] MOVDM" << std::endl;
    #endif
    wTmp_0 = *(VWORD*) &AS->codeData[REGS->PC];
    //if(wTmp_0 >= sizeof(AS->codeData)) funcException("memory index out of range!");
    REGS->PC += 2;
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    if(areFramesNeeded && (wTmp_0 >= frameMap[currentFrameNumber]))
    {
        std::vector<VBYTE> byteToWrite;
        VDWORD dw = REGS->R[bTmp_0];
        byteToWrite.push_back(dw >> 24);
        byteToWrite.push_back(dw >> 16);
        byteToWrite.push_back(dw >> 8);
        byteToWrite.push_back(dw);
        writeByteIntoFrame(wTmp_0, 2, byteToWrite);
        if(isError) funcException("write byte to frame!");
    }
    else *(VDWORD*) &AS->codeData[wTmp_0] = REGS->R[bTmp_0];
}

/* 
    MOVMRD - move double word from memory to register
            get addr from register
    0D 02 01 => MOVMRW R2, R1
*/
void VMCPU::funcMovmrd()
{
    VBYTE bTmp_0;
    VBYTE bTmp_1;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] MOVMRD" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    bTmp_1 = AS->codeData[REGS->PC++];
    if(bTmp_1 > 8) funcException("register index out of range!");
    //if(REGS->R[bTmp_1] >= sizeof(AS->codeData)) funcException("memory index out of range!");
    if(areFramesNeeded && (REGS->R[bTmp_1] >= frameMap[currentFrameNumber]))
    {
        std::vector<VBYTE> bytes = getByteFromFrame(REGS->R[bTmp_1], 4);
        if(isError) funcException("get byte from frame!");
        VBYTE hb3 = bytes[0];
        VBYTE hb2 = bytes[1];
        VBYTE hb1 = bytes[2];
        VBYTE lb = bytes[3];
        VDWORD dw = ((VDWORD) hb3 << 24) | ((VDWORD) hb2 << 16) | ((VDWORD) hb1 << 8) | lb;
        REGS->R[bTmp_0] = dw;
    }
    else REGS->R[bTmp_0] = *(VDWORD*) &AS->codeData[REGS->R[bTmp_1]];
}

/*
    JMP - unconditional jump
    20 15 00 => JMP 0015
*/
void VMCPU::funcJmp()
{
    VWORD wTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] JMP" << std::endl;
    #endif
    wTmp_0 = *(VWORD*) &AS->codeData[REGS->PC];
    REGS->PC += 2;
    // if(wTmp_0 > sizeof(AS->codeData)) funcException("memory index out of range!");
    REGS->PC = wTmp_0;
}

/*
    JZ - jump if equal
    21 15 00 => JZ 0015
*/
void VMCPU::funcJz()
{
    VWORD wTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] JZ" << std::endl;
    #endif
    wTmp_0 = *(VWORD*) &AS->codeData[REGS->PC];
    REGS->PC += 2;
    // if(wTmp_0 > sizeof(AS->codeData)) funcException("memory index out of range!");
    if(REGS->ZF) REGS->PC = wTmp_0;
}

/*
    JNZ - jump if not equal
    22 15 00 => JNZ 0015
*/
void VMCPU::funcJnz()
{
    VWORD wTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] JNZ" << std::endl;
    #endif
    wTmp_0 = *(VWORD*) &AS->codeData[REGS->PC];
    REGS->PC += 2;
    // if(wTmp_0 > sizeof(AS->codeData)) funcException("memory index out of range!");
    if(!REGS->ZF) REGS->PC = wTmp_0;
}

/*
    JAE - jump if above or equal
    23 15 00 => JAE 0015
*/
void VMCPU::funcJae()
{
    VWORD wTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] JAE" << std::endl;
    #endif
    wTmp_0 = *(VWORD*) &AS->codeData[REGS->PC];
    REGS->PC += 2;
    // if(wTmp_0 > sizeof(AS->codeData)) funcException("memory index out of range!");
    if(REGS->ZF || !REGS->CF) REGS->PC = wTmp_0;
}

/*
    JBE - jump if below or equal
    24 15 00 => JBE 0015
*/
void VMCPU::funcJbe()
{
    VWORD wTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] JBE" << std::endl;
    #endif
    wTmp_0 = *(VWORD*) &AS->codeData[REGS->PC];
    REGS->PC += 2;
    // if(wTmp_0 > sizeof(AS->codeData)) funcException("memory index out of range!");
    if(REGS->ZF || REGS->CF) REGS->PC = wTmp_0;
}

/*
    JB - jump if below
    25 15 00 => JB 0015
*/
void VMCPU::funcJb()
{
    VWORD wTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] JB" << std::endl;
    #endif
    wTmp_0 = *(VWORD*) &AS->codeData[REGS->PC];
    REGS->PC += 2;
    // if(wTmp_0 > sizeof(AS->codeData)) funcException("memory index out of range!");
    if(!REGS->ZF && REGS->CF) REGS->PC = wTmp_0;
}

/*
    JA - jump if above
    26 15 00 => JA 0015
*/
void VMCPU::funcJa()
{
    VWORD wTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] JA" << std::endl;
    #endif
    wTmp_0 = *(VWORD*) &AS->codeData[REGS->PC];
    REGS->PC += 2;
    // if(wTmp_0 > sizeof(AS->codeData)) funcException("memory index out of range!");
    if(!REGS->ZF && !REGS->CF) REGS->PC = wTmp_0;
}

/*
    ADVR - Add word value to register
    30 02 10 00 => ADVR R2, 10
*/
void VMCPU::funcAdvr()
{
    VBYTE bTmp_0;
    VWORD wTmp_0;
    VWORD wTmp_1;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] ADVR" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    wTmp_0 = *(VWORD*) &AS->codeData[REGS->PC];
    REGS->PC += 2;
    wTmp_1 = REGS->R[bTmp_0] + wTmp_0;          
    if(wTmp_1 == 0) REGS->ZF = 1;
    else REGS->ZF = 0;
    if(wTmp_1 < REGS->R[bTmp_0]) REGS->CF = 1;
    else REGS->CF = 0;
    *(VWORD *) &REGS->R[bTmp_0] = wTmp_1;
}

/*
    ADRR - Add two registers
            and save result in first
    31 02 01 => ADRR R2, R1
*/
void VMCPU::funcAdrr()
{
    VBYTE bTmp_0;
    VBYTE bTmp_1;
    VDWORD dTmp_0;
    VDWORD dTmp_1;
    VDWORD dTmp_2;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] ADRR" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    bTmp_1 = AS->codeData[REGS->PC++];
    if(bTmp_1 > 8) funcException("register index out of range!");
    dTmp_0 = REGS->R[bTmp_0];
    dTmp_1 = REGS->R[bTmp_1];
    dTmp_2 = dTmp_0 + dTmp_1;
    REGS->R[bTmp_0] = dTmp_2;
    if(dTmp_2 == 0) REGS->ZF = 1;
    else REGS->ZF = 0;
    if(dTmp_2 < dTmp_0) REGS->CF = 1;
    else REGS->CF = 0;
}

/*
    ADRRL - Add two registers (low byte)
            and save result in first
    32 02 01 => ADRR R2, R1
*/
void VMCPU::funcAdrrl()
{
    VBYTE bTmp_0;
    VBYTE bTmp_1;
    VBYTE bTmp_2;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] ADRRL" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    bTmp_1 = AS->codeData[REGS->PC++];
    if(bTmp_1 > 8) funcException("register index out of range!");
    bTmp_2 = *(VBYTE *) &REGS->R[bTmp_0];
    bTmp_1 = *(VBYTE *) &REGS->R[bTmp_1];
    bTmp_1 += bTmp_2;
    *(VBYTE *) &REGS->R[bTmp_0] = bTmp_1;
    if(bTmp_1 == 0) REGS->ZF = 1;
    else REGS->ZF = 0;
    if(bTmp_1 < bTmp_2) REGS->CF = 1;
    else REGS->CF = 0;
}

/*
    SUBVR - Substract word value from register
    33 02 10 00 => SUBVR R2, 10
*/
void VMCPU::funcSubvr()
{
    VBYTE bTmp_0;
    VWORD wTmp_0;
    VWORD wTmp_1;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] SUBVR" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    wTmp_0 = *(VWORD*) &AS->codeData[REGS->PC];
    REGS->PC += 2;
    wTmp_1 = REGS->R[bTmp_0] - wTmp_0;          
    if(wTmp_1 == 0) REGS->ZF = 1;
    else REGS->ZF = 0;
    if(wTmp_1 > REGS->R[bTmp_0]) REGS->CF = 1;
    else REGS->CF = 0;
    *(VWORD *) &REGS->R[bTmp_0] = wTmp_1;
}

/*
    SUBRR - Substract two registers
            and save result in first
    34 02 01 => SUBRR R2, R1
*/
void VMCPU::funcSubrr()
{
    VBYTE bTmp_0;
    VBYTE bTmp_1;
    VDWORD dTmp_0;
    VDWORD dTmp_1;
    VDWORD dTmp_2;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] SUBRR" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    bTmp_1 = AS->codeData[REGS->PC++];
    if(bTmp_1 > 8) funcException("register index out of range!");
    dTmp_0 = REGS->R[bTmp_0];
    dTmp_1 = REGS->R[bTmp_1];
    dTmp_2 = dTmp_0 - dTmp_1;
    REGS->R[bTmp_0] = dTmp_2;
    if(dTmp_2 == 0) REGS->ZF = 1;
    else REGS->ZF = 0;
    if(dTmp_2 > dTmp_0) REGS->CF = 1;
    else REGS->CF = 0;
}

/*
    SUBRRL - Substract two registers (low byte)
            and save result in first
    35 02 01 => ADRR R2, R1
*/
void VMCPU::funcSubrrl()
{
    VBYTE bTmp_0;
    VBYTE bTmp_1;
    VBYTE bTmp_2;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] SUBRRL" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    bTmp_1 = AS->codeData[REGS->PC++];
    if(bTmp_1 > 8) funcException("register index out of range!");
    bTmp_2 = *(VBYTE *) &REGS->R[bTmp_0];
    bTmp_1 = *(VBYTE *) &REGS->R[bTmp_1];
    bTmp_1 -= bTmp_2;
    *(VBYTE *) &REGS->R[bTmp_0] = bTmp_1;
    if(bTmp_1 == 0) REGS->ZF = 1;
    else REGS->ZF = 0;
    if(bTmp_1 > bTmp_2) REGS->CF = 1;
    else REGS->CF = 0;
}

/*
    XOR - Xor two registers
        and save result in first
    36 02 01 => XOR R2, R1
*/
void VMCPU::funcXor()
{
    VBYTE bTmp_0;
    VBYTE bTmp_1;
    VDWORD dTmp_0;
    VDWORD dTmp_1;
    VDWORD dTmp_2;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] XOR" << std::endl;
    #endif 
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    bTmp_1 = AS->codeData[REGS->PC++];
    if(bTmp_1 > 8) funcException("register index out of range!");
    dTmp_0 = REGS->R[bTmp_0];
    dTmp_1 = REGS->R[bTmp_1];
    dTmp_2 = dTmp_0 ^ dTmp_1;
    if(dTmp_2 == 0) REGS->ZF = 1;
    else REGS->ZF = 0;
    REGS->R[bTmp_0] = dTmp_2;
    REGS->CF = 0;
}

/*
    XORL - Xor two registers (lower bytes)
        and save result in first
    37 02 01 => XOR R2, R1
*/
void VMCPU::funcXorl()
{
    VBYTE bTmp_0;
    VBYTE bTmp_1;
    VBYTE bTmp_2;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] XORL" << std::endl;
    #endif 
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    bTmp_1 = AS->codeData[REGS->PC++];
    if(bTmp_1 > 8) funcException("register index out of range!");
    bTmp_2 = REGS->R[bTmp_0];
    bTmp_1 = REGS->R[bTmp_1];
    bTmp_2 ^= bTmp_1;
    if(bTmp_2 == 0) REGS->ZF = 1;
    else REGS->ZF = 0;
    *(VBYTE *) &REGS->R[bTmp_0] = bTmp_2;
    REGS->CF = 0;
}

/*
    NOT - Bitwise not on value in a register
        and save result in this register
    38 02 => NOT R2
*/
void VMCPU::funcNot()
{
    VBYTE bTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] NOT" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    REGS->R[bTmp_0] = ~ REGS->R[bTmp_0];
}

/*
    NOTB - Bitwise not on value in a register (lower bytes)
        and save result in this register
    39 02 => NOT R2
*/
void VMCPU::funcNotb()
{
    VBYTE bTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] NOTB" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    *(VBYTE *) &REGS->R[bTmp_0] = ~ (*(VBYTE *) &REGS->R[bTmp_0]);
}

/*
    ADVRD - Add double word value to register
    3A 02 10 00 00 00 => ADVR R2, 10
*/
void VMCPU::funcAdvrd()
{
    VBYTE bTmp_0;
    VDWORD dTmp_0;
    VDWORD dTmp_1;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] ADVRD" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    dTmp_0 = *(VDWORD*) &AS->codeData[REGS->PC];
    REGS->PC += 4;
    dTmp_1 = REGS->R[bTmp_0] + dTmp_0;          
    if(dTmp_1 == 0) REGS->ZF = 1;
    else REGS->ZF = 0;
    if(dTmp_1 < REGS->R[bTmp_0]) REGS->CF = 1;
    else REGS->CF = 0;
    REGS->R[bTmp_0] = dTmp_1;
}

/*
    SUBVRD - Substract double word value from register
    3B 02 10 00 00 00 => SUBVR R2, 10
*/
void VMCPU::funcSubvrd()
{
    VBYTE bTmp_0;
    VDWORD dTmp_0;
    VDWORD dTmp_1;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] SUBVRD" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    dTmp_0 = *(VDWORD*) &AS->codeData[REGS->PC];
    REGS->PC += 4;
    dTmp_1 = REGS->R[bTmp_0] - dTmp_0;          
    if(dTmp_1 == 0) REGS->ZF = 1;
    else REGS->ZF = 0;
    if(dTmp_1 > REGS->R[bTmp_0]) REGS->CF = 1;
    else REGS->CF = 0;
    *(VDWORD *) &REGS->R[bTmp_0] = dTmp_1;
}

/*
    SHR - Shift the bits of the operand destination to the right,
            by the number of bits specified in the count operand
    3C 02 05 => SHR R2, 5
*/
void VMCPU::funcShr()
{
    VBYTE bTmp_0;
    VBYTE bTmp_1;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] SHR" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    bTmp_1 = AS->codeData[REGS->PC++];
    REGS->R[bTmp_0] = REGS->R[bTmp_0] >> bTmp_1;
}

/*
    SHL -Shift the bits of the operand destination to the left,
            by the number of bits specified in the count operand
    3D 02 05 => SHL R2, 5
*/
void VMCPU::funcShl()
{
    VBYTE bTmp_0;
    VBYTE bTmp_1;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] SHL" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    bTmp_1 = AS->codeData[REGS->PC++];
    REGS->R[bTmp_0] = REGS->R[bTmp_0] << bTmp_1;
}

/*
    CMP - compare two registers
    50 02 01 => CMP R2, R1
*/
void VMCPU::funcCmp()
{
    VBYTE bTmp_0;
    VBYTE bTmp_1;
    VDWORD dTmp_0;
    VDWORD dTmp_1;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] CMP" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    bTmp_1 = AS->codeData[REGS->PC++];
    if(bTmp_1 > 8) funcException("register index out of range!");
    dTmp_0 = REGS->R[bTmp_0];
    dTmp_1 = REGS->R[bTmp_1];
    #ifdef V_DEBUG
        std::cout << dTmp_0 << std::endl;
        std::cout << dTmp_1 << std::endl;
    #endif
    if(dTmp_1 == dTmp_0) REGS->ZF = 1;
    else REGS->ZF = 0;
    if(dTmp_1 > dTmp_0) REGS->CF = 1;
    else REGS->CF = 0;
}

/*
    CMPL - compare two registers (lower byte)
    51 02 01 => CMP R2, R1
*/
void VMCPU::funcCmpl()
{
    VBYTE bTmp_0;
    VBYTE bTmp_1;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] CMPL" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    bTmp_1 = AS->codeData[REGS->PC++];
    if(bTmp_1 > 8) funcException("register index out of range!");
    bTmp_0 = *(VBYTE*) &REGS->R[bTmp_0];
    bTmp_1 = *(VBYTE*) &REGS->R[bTmp_1];
    if(bTmp_0 == bTmp_1) REGS->ZF = 1;
    else REGS->ZF = 0;
    if(bTmp_0 < bTmp_1) REGS->CF = 1;
    else REGS->CF = 0;
}

/*
    VMSYSBUS FUNC_CODE
    60 01 00 => SYSBUS createDirectory
*/
void VMCPU::funcVmSysbus()
{
    VWORD wTmp_0 = *(VWORD*) &AS->codeData[REGS->PC];
    VWORD wTmp_1;
    REGS->PC += 2;
    REGS->R[6] = 0;
    REGS->R[7] = 0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] VMSYSBUS" << std::endl;
        std::cout << "[DEBUG] CALL " << wTmp_0 << std::endl;
    #endif
    switch(wTmp_0)
    {
        case SYSBUS_CREATE_DIR:
            {
                wTmp_1 = AS->stack[REGS->SP]; // second arg
                REGS->SP += 1;
                wTmp_0 = AS->stack[REGS->SP]; // first arg
                REGS->SP += 1;
                std::string arg1 = "";
                getDataFromCodeData(arg1, wTmp_0);
                REGS->R[6] = sysBus->createDirectory(arg1, wTmp_1);
            }
            break;
        case SYSBUS_DELETE_DIR:
            {
                wTmp_0 = AS->stack[REGS->SP];
                REGS->SP += 1;
                std::string arg1 = "";
                getDataFromCodeData(arg1, wTmp_0);
                REGS->R[6] = sysBus->deleteDirectory(arg1);
            }
            break;
        case SYSBUS_MOVE_DIR:
            {
                wTmp_1 = AS->stack[REGS->SP]; // second arg
                REGS->SP += 1;
                wTmp_0 = AS->stack[REGS->SP]; // first arg
                REGS->SP += 1;
                std::string arg1 = "";
                std::string arg2 = "";
                getDataFromCodeData(arg2, wTmp_1);
                getDataFromCodeData(arg1, wTmp_0);
                REGS->R[6] = sysBus->moveDirectory(arg1, arg2);
            }
            break;
        case SYSBUS_COPY_DIR:
            {
                wTmp_1 = AS->stack[REGS->SP]; // second arg
                REGS->SP += 1;
                wTmp_0 = AS->stack[REGS->SP]; // first arg
                REGS->SP += 1;
                std::string arg1 = "";
                std::string arg2 = "";
                getDataFromCodeData(arg2, wTmp_1);
                getDataFromCodeData(arg1, wTmp_0);
                REGS->R[6] = sysBus->copyDirectory(arg1, arg2);
            }
            break;
        case SYSBUS_CREATE_FILE:
            {
                wTmp_1 = AS->stack[REGS->SP];
                REGS->SP += 1;
                wTmp_0 = AS->stack[REGS->SP];
                REGS->SP += 1;
                std::string arg2 = "";
                int counter = wTmp_1;
                int dataLength = 0;
                VBYTE b;
                std::vector<VBYTE> dataVbyte;
                int frameNumberToRestore = currentFrameNumber;
                while(true)
                {
                    if(areFramesNeeded && (counter >= frameMap[currentFrameNumber])) counter = loadFrame(counter);
                    if(isError) return;
                    b = AS->codeData[counter++];
                    if((b == 0x3) && (AS->codeData[counter] == 0xD)) break;
                    ++dataLength;
                    dataVbyte.push_back(b);
                    std::cout << std::hex << b << std::endl;
                }
                currentFrameNumber = frameNumberToRestore;
                restoreFrame();
                if(isError) return;
                VBYTE *dataToWrite = &dataVbyte[0];
                std::string arg1 = "";
                getDataFromCodeData(arg1, wTmp_0);
                REGS->R[6] = sysBus->createFile(arg1, dataToWrite, dataLength);
            }
            break;
        case SYSBUS_DELETE_FILE:
            {
                wTmp_0 = AS->stack[REGS->SP];
                REGS->SP += 1;
                std::string arg1 = "";
                getDataFromCodeData(arg1, wTmp_0);
                REGS->R[6] = sysBus->deleteFile(arg1);
            }
            break;
        case SYSBUS_MOVE_FILE:
            {
                wTmp_1 = AS->stack[REGS->SP]; // second arg
                REGS->SP += 1;
                wTmp_0 = AS->stack[REGS->SP]; // first arg
                REGS->SP += 1;
                std::string arg1 = "";
                std::string arg2 = "";
                getDataFromCodeData(arg2, wTmp_1);
                getDataFromCodeData(arg1, wTmp_0);
                REGS->R[6] = sysBus->moveFile(arg1, arg2);
            }
            break;
        case SYSBUS_COPY_FILE:
            {
                wTmp_1 = AS->stack[REGS->SP]; // second arg
                REGS->SP += 1;
                wTmp_0 = AS->stack[REGS->SP]; // first arg
                REGS->SP += 1;
                std::string arg1 = "";
                std::string arg2 = "";
                getDataFromCodeData(arg2, wTmp_1);
                getDataFromCodeData(arg1, wTmp_0);
                REGS->R[6] = sysBus->copyFile(arg1, arg2);
            }
            break;
        default:
            REGS->R[7] = 1;
    }
}

/*
    PUSH REGISTER
    90 03 => PUSH R3
*/
void VMCPU::funcPush()
{
    VBYTE bTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] PUSH" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    REGS->SP -= 1;
    if(REGS->SP == 0xFFFFFFFF) {
        #ifdef _VM_CPU_TEST_
            vcpuFlag = VCpuFlag::OVERFLOW;
        #endif
        #ifndef _VM_CPU_TEST_
            std::cout << "[ERROR] STACK OVERFLOW!" << std::endl;
        #endif
        funcException("stack overflow!");
    }
    else AS->stack[REGS->SP] = REGS->R[bTmp_0];
    #ifdef V_DEBUG
        std::cout <<"val: " << std::hex << AS->stack[REGS->SP] << std::endl;
    #endif
}

/*
    POP TO A REGISTER
    91 03 => POP R3
*/
void VMCPU::funcPop()
{
    VBYTE bTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] POP" << std::endl;
    #endif
    bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 > 8) funcException("register index out of range!");
    if((&AS->stack[REGS->SP]) == (&AS->stack[sizeof(AS->stack)/sizeof(VDWORD)])){
        #ifdef _VM_CPU_TEST_
            vcpuFlag = VCpuFlag::UNDERFLOW;
        #endif
        #ifndef _VM_CPU_TEST_
            std::cout << "[ERROR] STACK UNDERFLOW!" << std::endl;
        #endif
        funcException("stack underflow!");
    }
    else {
        REGS->R[bTmp_0] = AS->stack[REGS->SP];
        REGS->SP += 1;
    }
}

/*
    Clear the stack
    92 => CLST
*/
void VMCPU::funcClSt()
{
    #ifdef V_DEBUG
        std::cout << "[DEBUG] CLST" << std::endl;
    #endif
    memset(AS->stack, 0, STACK_SIZE*sizeof(*(AS->stack)));
    REGS->SP = 0;
}

/*
    Set the stack pointer
    93 01 00 00 00 => SETSP 1
*/
void VMCPU::funcSetSp()
{
    #ifdef V_DEBUG
        std::cout << "[DEBUG] SETSP" << std::endl;
    #endif
    REGS->SP = 0;
    REGS->SP = *(VDWORD *) &AS->codeData[REGS->PC];
    if(REGS->SP > STACK_SIZE) funcException("stack pointer to high!");
    REGS->PC += 4;
}

/*
    POC - Print char without new line
        the value must be at the top of
        the stack
    A0 => POC
*/
void VMCPU::funcPoc()
{
    VBYTE bTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] POC" << std::endl;
    #endif
    if(&AS->stack[REGS->SP] == &AS->stack[sizeof(AS->stack)/sizeof(VDWORD)]){
        #ifdef _VM_CPU_TEST_
            vcpuFlag = VCpuFlag::UNDERFLOW;
        #endif
        #ifndef _VM_CPU_TEST_
            std::cout << "[ERROR] STACK UNDERFLOW!" << std::endl;
        #endif
        funcException("stack underflow!");
    }
    if(areFramesNeeded && (AS->stack[REGS->SP] >= frameMap[currentFrameNumber]))
    {
        std::vector<VBYTE> bytes = getByteFromFrame(AS->stack[REGS->SP++], 1);
        bTmp_0 = bytes[0];
    }
    else bTmp_0 = *(VBYTE*) &AS->codeData[AS->stack[REGS->SP++]];
    if(isError) funcException("get byte from frame!");
    Screen::vmPrint(bTmp_0, SCREEN_MODE::NORMAL, false);
}

/*
    POCN - Print char with new line
        the value must be at the top of
        the stack
    A1 => POCN
*/
void VMCPU::funcPocn()
{
    VBYTE bTmp_0;
    #ifdef V_DEBUG
        std::cout << "[DEBUG] POCN" << std::endl;
    #endif
    if(&AS->stack[REGS->SP] == &AS->stack[sizeof(AS->stack)/sizeof(VDWORD)]){
        #ifdef _VM_CPU_TEST_
            vcpuFlag = VCpuFlag::UNDERFLOW;
        #endif
        #ifndef _VM_CPU_TEST_
            std::cout << "[ERROR] STACK UNDERFLOW!" << std::endl;
        #endif
        funcException("stack underflow!");
    }
    if(areFramesNeeded && (AS->stack[REGS->SP] >= frameMap[currentFrameNumber]))
    {
        std::vector<VBYTE> bytes = getByteFromFrame(AS->stack[REGS->SP++], 1);
        bTmp_0 = bytes[0];
    }
    else bTmp_0 = *(VBYTE*) &AS->codeData[AS->stack[REGS->SP++]];
    if(isError) funcException("get byte from frame!");
    Screen::vmPrint(bTmp_0, SCREEN_MODE::NORMAL, true);
}

/*
    TIB - Take input and move to the data buffer,
            the length of the string is stored in R[7]
    A2 => TIB
*/
void VMCPU::funcTib()
{
    #ifdef V_DEBUG
        std::cout << "[DEBUG] TIB" << std::endl;
    #endif
    {
        memset(AS->dataBuffer, 0, INPUT_BUFFER_SIZE*sizeof(*(AS->dataBuffer)));
        std::string inData = "";
        std::getline(std::cin, inData);
        VBYTE endOfText = 0x3;
        if(inData.length() > (INPUT_BUFFER_SIZE - 1)) 
        {
            inData = inData.substr(0, (INPUT_BUFFER_SIZE - 1));
        }
        int counter = 0;
        for(char const &c: inData)
        {
            AS->dataBuffer[counter++] = c;
        }
        AS->dataBuffer[counter++] = endOfText;
        REGS->R[7] = 0;
        *(VWORD *) &REGS->R[7] = counter;
    }
}

/*
    GIC - Get a specific char from input, that is stored in the data buffer,
            the value will be stored in R[7],
            pass the position of char via a some register
    A3 02 => GIC R2
*/
void VMCPU::funcGic()
{
    #ifdef V_DEBUG
        std::cout << "[DEBUG] GIC" << std::endl;
    #endif
    VBYTE bTmp_0 = AS->codeData[REGS->PC++];
    if(bTmp_0 >= 0 && bTmp_0 <= 7)
    {
        if(REGS->R[bTmp_0] >= INPUT_BUFFER_SIZE) funcException("input buffer too big!");
        REGS->R[7] = 0;
        *(VBYTE *) &REGS->R[7] = AS->dataBuffer[REGS->R[bTmp_0]];
    }
    else funcException("register index out of range!");
}

/*
    PIC - Print char from input without new line
        the value must be at the top of
        the stack
    A4 => PIC
*/
void VMCPU::funcPic()
{
    #ifdef V_DEBUG
        std::cout << "[DEBUG] PIC" << std::endl;
    #endif
    if(&AS->stack[REGS->SP] == &AS->stack[sizeof(AS->stack)/sizeof(VDWORD)]){
        #ifdef _VM_CPU_TEST_
            vcpuFlag = VCpuFlag::UNDERFLOW;
        #endif
        #ifndef _VM_CPU_TEST_
            std::cout << "[ERROR] STACK UNDERFLOW!" << std::endl;
        #endif
        funcException("stack underflow!");
    }
    VBYTE bTmp_0 = AS->stack[REGS->SP++];
    Screen::vmPrint(bTmp_0, SCREEN_MODE::NORMAL, false);
}

/*
    PICN - Print char from input with new line
        the value must be at the top of
        the stack
    A5 => POCN
*/
void VMCPU::funcPicn()
{
    #ifdef V_DEBUG
        std::cout << "[DEBUG] PICN" << std::endl;
    #endif
    if(&AS->stack[REGS->SP] == &AS->stack[sizeof(AS->stack)/sizeof(VDWORD)]){
        #ifdef _VM_CPU_TEST_
            vcpuFlag = VCpuFlag::UNDERFLOW;
        #endif
        #ifndef _VM_CPU_TEST_
            std::cout << "[ERROR] STACK UNDERFLOW!" << std::endl;
        #endif
        funcException("stack underflow!");
    }
    VBYTE bTmp_0 = AS->stack[REGS->SP++];
    Screen::vmPrint(bTmp_0, SCREEN_MODE::NORMAL, true);
}

/*
    PXV - Print a value in hex;
        the value must be at the top of the stack
    A6 => PXV
*/
void VMCPU::funcPxv()
{
    #ifdef V_DEBUG
        std::cout << "[DEBUG] PXV" << std::endl;
    #endif
    if(&AS->stack[REGS->SP] == &AS->stack[sizeof(AS->stack)/sizeof(VDWORD)]){
        #ifdef _VM_CPU_TEST_
            vcpuFlag = VCpuFlag::UNDERFLOW;
        #endif
        #ifndef _VM_CPU_TEST_
            std::cout << "[ERROR] STACK UNDERFLOW!" << std::endl;
        #endif
        funcException("stack underflow!");
    }
    VDWORD dTmp_0 = AS->stack[REGS->SP++];
    Screen::vmPrint(dTmp_0, SCREEN_MODE::HEX, false);
}

/*
    PXVN - Print a value in hex with a new line;
        the value must be at the top of the stack
    A7 => PXV
*/
void VMCPU::funcPxvn()
{
    #ifdef V_DEBUG
        std::cout << "[DEBUG] PXVN" << std::endl;
        // std::cout << std::bitset<32>(AS->stack[REGS->SP]) << std::endl;
    #endif
    if(&AS->stack[REGS->SP] == &AS->stack[sizeof(AS->stack)/sizeof(VDWORD)]){
        #ifdef _VM_CPU_TEST_
            vcpuFlag = VCpuFlag::UNDERFLOW;
        #endif
        #ifndef _VM_CPU_TEST_
            std::cout << "[ERROR] STACK UNDERFLOW!" << std::endl;
        #endif
        funcException("stack underflow!");
    }
    VDWORD dTmp_0 = AS->stack[REGS->SP++];
    Screen::vmPrint(dTmp_0, SCREEN_MODE::HEX, true);
}

```

`VMCore/src/win32sysbus.cpp`:

```cpp
#include "../include/drivers/win32sysbus.hpp"

#ifdef _WIN32_DEV_ENVIRONMENT
    int WIN32::createDirectory(std::string dirName, int dirMode)
    {
        if (CreateDirectoryA(dirName.c_str(), NULL)) return DIR_CREATED;
        else if (ERROR_ALREADY_EXISTS == GetLastError()) return DIR_EXIST;
        else return OTHER_DIR_ERROR;
    }

    int WIN32::deleteDirectory(std::string dirName)
    {
        if(deleteDir((stringToWString(dirName)).c_str())) return DELETE_DIR;
        else return OTHER_DIR_ERROR;
    }

    int WIN32::moveDirectory(std::string dirSource, std::string dirDest)
    {
        if (!MoveFileExA(dirSource.c_str(), dirDest.c_str(), MOVEFILE_WRITE_THROUGH)) return OTHER_DIR_ERROR;
        else return MOVE_DIR;
    }

    int WIN32::copyDirectory(std::string dirSource, std::string dirDest)
    {
        if(copyDir((stringToWString(dirSource)).c_str()), (stringToWString(dirDest)).c_str())) return COPY_DIR;
        else return OTHER_DIR_ERROR;
    }

    int WIN32::deleteFile(std::string filePath)
    {
        try {
            DeleteFile(stringToWString(filePath).c_str());
            return DELETE_FILE;
        }
        catch(...) {
            return OTHER_FILE_ERROR;
        }
    }

    int WIN32::copyFile(std::string filePathSource, std::string filePathDest)
    {
        try {
            if (CopyFile(stringToWString(filePathSource).c_str(), stringToWString(filePathDest).c_str(), true)) return COPY_FILE;
            else return OTHER_FILE_ERROR;
        }
        catch (...) {
            return OTHER_FILE_ERROR;
        }
    }

    int WIN32::moveFile(std::string filePathSource, std::string filePathDest)
    {
        auto retval = copyFile(std::string filePathSource, std::string filePathDest);
        if(retval == OTHER_FILE_ERROR) return OTHER_FILE_ERROR;
        return deleteFile(std::string filePathSource);
    }
    
    bool WIN32::copyDir(std::wstring dirSource, std::wstring dirDest)
    {
        std::wstring new_sf = dirSource + L"\\*";
        WCHAR sf[MAX_PATH + 1];
        WCHAR tf[MAX_PATH + 1];

        wcscpy_s(sf, MAX_PATH, new_sf.c_str());
        wcscpy_s(tf, MAX_PATH, dirDest.c_str());

        sf[lstrlenW(sf) + 1] = 0;
        tf[lstrlenW(tf) + 1] = 0;

        SHFILEOPSTRUCTW s = { 0 };
        s.wFunc = FO_COPY;
        s.pTo = tf;
        s.pFrom = sf;
        s.fFlags = FOF_SILENT | FOF_NOCONFIRMMKDIR | FOF_NOCONFIRMATION | FOF_NOERRORUI | FOF_NO_UI;
        int res = SHFileOperationW(&s);

        return res == 0;
    }

    int WIN32::deleteDir(LPCTSTR lpszDir)
    {
        bool noRecycleBin = true;
        int len = _tcslen(lpszDir);
        TCHAR* pszFrom = new TCHAR[len + 2];
        _tcscpy_s(pszFrom, len + 2, lpszDir);
        pszFrom[len] = 0;
        pszFrom[len + 1] = 0;

        SHFILEOPSTRUCT fileop;
        fileop.hwnd = NULL;    // no status display
        fileop.wFunc = FO_DELETE;  // delete operation
        fileop.pFrom = pszFrom;  // source file name as double null terminated string
        fileop.pTo = NULL;    // no destination needed
        fileop.fFlags = FOF_NOCONFIRMATION | FOF_SILENT;  // do not prompt the user

        if (!noRecycleBin) fileop.fFlags |= FOF_ALLOWUNDO;

        fileop.fAnyOperationsAborted = FALSE;
        fileop.lpszProgressTitle = NULL;
        fileop.hNameMappings = NULL;

        int ret = SHFileOperation(&fileop);
        delete[] pszFrom;
        return (ret == 0);
    }

    std::wstring WIN32::stringToWString(const std::string& s)
    {
        std::wstring ws;
        std::wstring wsTmp(s.begin(), s.end());
        ws = wsTmp;
        return ws;
    }
#endif
```

`VMCore/tests/main.cpp`:

```cpp
#include "vmtest.hpp"

int main()
{
    std::cout << R"(
 _   ____  _______________ _____ _____ _____ _____ _____ 
| | | |  \/  || ___ \ ___ \  _  |_   _|  ___/  __ \_   _|
| | | | .  . || |_/ / |_/ / | | | | | | |__ | /  \/ | |  
| | | | |\/| ||  __/|    /| | | | | | |  __|| |     | |  
\ \_/ / |  | || |   | |\ \\ \_/ / | | | |___| \__/\ | |  
 \___/\_|  |_/\_|   \_| \_|\___/  \_/ \____/ \____/ \_/  
                                                         
                                                         
 _____ _____ _____ _____ _____                           
|_   _|  ___/  ___|_   _/  ___|                          
  | | | |__ \ `--.  | | \ `--.                           
  | | |  __| `--. \ | |  `--. \                          
  | | | |___/\__/ / | | /\__/ /                          
  \_/ \____/\____/  \_/ \____/                           
                                                         
    )" << std::endl;
    std::cout << "version 0.4.051021.1436\n" << std::endl;

    if(VMCPU::bIsOnTest) {
        VMTest *vmt = new VMTest();

        std::cout << "[INFO] TESTS VMCPU STARTED" << std::endl;
        if(vmt->testVM()) std::cout << "\t[INFO] ALL TESTS PASS" << std::endl;
        else std::cout << "\t[ERROR] SOME TESTS FAILED!" << std::endl;

        delete vmt;
    }
    else{
        std::cout << "\t[ERROR] CANNOT START VMCPU'S TESTS!" << std::endl;
    }
    return 0;
}
```

`VMCore/tests/vmtest.cpp`:

```cpp
#include "vmtest.hpp"

std::ostream &operator << ( std::ostream& os, const VCpuFlag vcf ) {
    switch(vcf) {
        case VCpuFlag::OK:
            os << "OK";
        break;
        case VCpuFlag::ERROR:
            os << "ERROR";
        break;
        case VCpuFlag::UNDERFLOW:
            os << "UNDERFLOW";
        break;
        case VCpuFlag::OVERFLOW:
            os << "OVERFLOW";
        break;
    }
    return os;
}

void VMTest::printTestResult(bool bTestPass, unsigned int currentTestNumber)
{
    if(bTestPass == true) std::cout << "\t[INFO] TEST " << currentTestNumber << ": PASS" << std::endl;
    else std::cout << "\t[INFO] TEST " << currentTestNumber << ": FAIL!" << std::endl;
}

bool VMTest::testVM()
{
    bool bTestPass = true;
    unsigned int currentTestNumber = 0;

    T_AS = vm->getAS();
    T_REGS = vm->getREGS();

    /* ************************* */
        /* TEST 1 
        desc: check for unforeseen modifications
        */
    /* ************************* */
    ++currentTestNumber;
    T_AS->codeData[0] = NOP;
    T_AS->codeData[1] = EE;
    vm->vcpuFlag = VCpuFlag::OK;
    vm->run();
    if(vm->vcpuFlag == VCpuFlag::ERROR) {
        bTestPass = false;
        goto FINISH_TESTS;
    }
    if(T_AS->codeData[T_REGS->PC] == 0x00) {
        for(int i = 0; i < 6; i++){
            if(T_REGS->R[i] != (VDWORD) 0) {
                bTestPass = false;
                goto FINISH_TESTS;
            }
        }
        for(int i = 3; i < 4096; i++){
            if(T_AS->codeData[i] != 0x00) {
                bTestPass = false;
                goto FINISH_TESTS;
            }
        }
    }
    else {
        bTestPass = false;
        goto FINISH_TESTS;
    }
    T_AS->codeData[0] = 0x00;
    T_AS->codeData[1] = 0x00;
    T_REGS->PC = (VDWORD) 0;
    printTestResult(bTestPass, currentTestNumber);
    /* ************************* */
        /* TEST 2
        desc: check the correctness of data transfer from a register to a register
        */
    /* ************************* */
    ++currentTestNumber;
    T_REGS->R[1] = (VDWORD) 5;
    T_REGS->R[2] = (VDWORD) 1;
    T_AS->codeData[0] = MOV;
    T_AS->codeData[1] = 0x01; // R1
    T_AS->codeData[2] = 0x02; // R2
    T_AS->codeData[3] = EE;
    vm->vcpuFlag = VCpuFlag::OK;
    vm->run();
    if(vm->vcpuFlag == VCpuFlag::ERROR) {
        bTestPass = false;
        goto FINISH_TESTS;
    }
    if(T_REGS->R[2] == (VDWORD) 1) {
        if(T_REGS->R[1] != (VDWORD) 1) {
            bTestPass = false;
            goto FINISH_TESTS;
        }
    }
    else {
        bTestPass = false;
        goto FINISH_TESTS;
    }
    T_REGS->R[1] = (VDWORD) 0;
    T_REGS->R[2] = (VDWORD) 0;
    T_AS->codeData[0] = 0x00;
    T_AS->codeData[1] = 0x00;
    T_AS->codeData[2] = 0x00;
    T_AS->codeData[3] = 0x00;
    T_REGS->PC = (VDWORD) 0;
    printTestResult(bTestPass, currentTestNumber);
    /* ************************* */
        /* TEST 3
        desc: check the correctness of data transfer (VBYTE and extend to VWORD) from memory to a register
        */
    /* ************************* */
    ++currentTestNumber;
    T_REGS->R[2] = (VDWORD) 6;
    T_AS->codeData[0] = MOVMB;
    T_AS->codeData[1] = 0x02; // R2
    T_AS->codeData[2] = 0x07;
    T_AS->codeData[3] = 0x00; // 0007h
    T_AS->codeData[4] = EE;
    T_AS->codeData[7] = 0x03;
    vm->vcpuFlag = VCpuFlag::OK;
    vm->run();
    if(vm->vcpuFlag == VCpuFlag::ERROR) {
        bTestPass = false;
        goto FINISH_TESTS;
    }
    if(T_REGS->R[2] != (VDWORD) 3){
        bTestPass = false;
        goto FINISH_TESTS;
    }
    T_REGS->R[2] = (VDWORD) 0;
    T_AS->codeData[0] = 0x00;
    T_AS->codeData[1] = 0x00;
    T_AS->codeData[2] = 0x00;
    T_AS->codeData[3] = 0x00;
    T_AS->codeData[4] = 0x00;
    T_AS->codeData[7] = 0x00;
    T_REGS->PC = (VDWORD) 0;
    printTestResult(bTestPass, currentTestNumber);
    /* ************************* */
        /* TEST 4
        desc: check the correctness of data transfer (VWORD) from memory to a register
        */
    /* ************************* */
    ++currentTestNumber;
    T_REGS->R[2] = (VDWORD) 0;
    T_REGS->R[2] = (VWORD) 6;
    T_AS->codeData[0] = MOVMW;
    T_AS->codeData[1] = 0x02; // R2
    T_AS->codeData[2] = 0x07;
    T_AS->codeData[3] = 0x00; // 0007h
    T_AS->codeData[4] = EE;
    T_AS->codeData[7] = 0x03;
    T_AS->codeData[8] = 0x04;
    vm->vcpuFlag = VCpuFlag::OK;
    vm->run();
    if(vm->vcpuFlag == VCpuFlag::ERROR) {
        bTestPass = false;
        goto FINISH_TESTS;
    }
    if(T_REGS->R[2] != (VWORD) 0x0403){
        bTestPass = false;
        goto FINISH_TESTS;
    }
    T_REGS->R[2] = (VDWORD) 0;
    T_AS->codeData[0] = 0x00;
    T_AS->codeData[1] = 0x00;
    T_AS->codeData[2] = 0x00;
    T_AS->codeData[3] = 0x00;
    T_AS->codeData[4] = 0x00;
    T_AS->codeData[7] = 0x00;
    T_AS->codeData[8] = 0x00;
    T_REGS->PC = (VDWORD) 0;
    printTestResult(bTestPass, currentTestNumber);
    /* ************************* */
        /* TEST 5
        desc: check the correctness of data transfer (VBYTE) from a register to memory
        */
    /* ************************* */
    ++currentTestNumber;
    T_REGS->R[2] = (VDWORD) 6;
    T_AS->codeData[0] = MOVBM;
    T_AS->codeData[1] = 0x07;
    T_AS->codeData[2] = 0x00; // 0007h
    T_AS->codeData[3] = 0x02; // R2
    T_AS->codeData[4] = EE;
    T_AS->codeData[7] = 0x03;
    vm->vcpuFlag = VCpuFlag::OK;
    vm->run();
    if(vm->vcpuFlag == VCpuFlag::ERROR) {
        bTestPass = false;
        goto FINISH_TESTS;
    }
    if(T_REGS->R[2] == (VDWORD) 6) {
        if(T_AS->codeData[7] == 0x06) {
            if(T_AS->codeData[8] != 0x00) {
                bTestPass = false;
                goto FINISH_TESTS;
            }
        }
        else {
            bTestPass = false;
            goto FINISH_TESTS;
        }
    }
    else {
        bTestPass = false;
        goto FINISH_TESTS;
    }
    T_REGS->R[2] = (VDWORD) 0;
    T_AS->codeData[0] = 0x00;
    T_AS->codeData[1] = 0x00;
    T_AS->codeData[2] = 0x00;
    T_AS->codeData[3] = 0x00;
    T_AS->codeData[4] = 0x00;
    T_AS->codeData[7] = 0x00;
    T_REGS->PC = (VDWORD) 0;
    printTestResult(bTestPass, currentTestNumber);
    /* ************************* */
        /* TEST 6
        desc: check the correctness of data transfer (VWORD) from a register to memory
        */
    /* ************************* */
    ++currentTestNumber;
    T_REGS->R[2] = (VDWORD) 6;
    T_AS->codeData[0] = MOVWM;
    T_AS->codeData[1] = 0x07;
    T_AS->codeData[2] = 0x00; // 0007h
    T_AS->codeData[3] = 0x02; // R2
    T_AS->codeData[4] = EE;
    T_AS->codeData[7] = 0x03;
    T_AS->codeData[8] = 0x04;
    vm->vcpuFlag = VCpuFlag::OK;
    vm->run();
    if(vm->vcpuFlag == VCpuFlag::ERROR) {
        bTestPass = false;
        goto FINISH_TESTS;
    }
    if(T_REGS->R[2] == (VDWORD) 6) {
        if(T_AS->codeData[7] == 0x06) {
            if(T_AS->codeData[8] != 0x00) {
                bTestPass = false;
                goto FINISH_TESTS;
            }
        }
        else {
            bTestPass = false;
            goto FINISH_TESTS;
        }
    }
    else {
        bTestPass = false;
        goto FINISH_TESTS;
    }
    T_REGS->R[2] = (VDWORD) 0;
    T_AS->codeData[0] = 0x00;
    T_AS->codeData[1] = 0x00;
    T_AS->codeData[2] = 0x00;
    T_AS->codeData[3] = 0x00;
    T_AS->codeData[4] = 0x00;
    T_AS->codeData[7] = 0x00;
    T_AS->codeData[8] = 0x00;
    T_REGS->PC = (VDWORD) 0;
    printTestResult(bTestPass, currentTestNumber);
    /* ************************* */
        /* TEST 7
        desc: check the stack underflow
        */
    /* ************************* */
    ++currentTestNumber;
    T_REGS->R[2] = (VDWORD) 6;
    T_AS->codeData[0] = POP;
    T_AS->codeData[1] = 0x02; // R2
    T_AS->codeData[2] = EE;
    vm->vcpuFlag = VCpuFlag::OK;
    vm->run();
    if(vm->vcpuFlag == VCpuFlag::ERROR) {
        bTestPass = false;
        goto FINISH_TESTS;
    }
    else if(vm->vcpuFlag == VCpuFlag::OK){
        bTestPass = false;
        goto FINISH_TESTS;
    }
    else if(vm->vcpuFlag == VCpuFlag::UNDERFLOW){
        if(T_REGS->R[2] != (VDWORD) 6) {
            bTestPass = false;
            goto FINISH_TESTS;
        }
    }
    T_REGS->R[2] = (VDWORD) 0;
    T_AS->codeData[0] = 0x00;
    T_AS->codeData[1] = 0x00;
    T_AS->codeData[2] = 0x00;
    T_REGS->PC = (VDWORD) 0;
    printTestResult(bTestPass, currentTestNumber);
    /* ************************* */
        /* TEST 8
        desc: check the stack overflow
        */
    /* ************************* */
    ++currentTestNumber;
    T_REGS->R[2] = (VDWORD) 6;
    T_REGS->SP = 0;
    T_AS->codeData[0] = PUSH;
    T_AS->codeData[1] = 0x02; // R2
    T_AS->codeData[2] = EE;
    vm->vcpuFlag = VCpuFlag::OK;
    vm->run();
    if(vm->vcpuFlag == VCpuFlag::ERROR) {
        bTestPass = false;
        goto FINISH_TESTS;
    }
    else if(vm->vcpuFlag == VCpuFlag::OVERFLOW){
        if(T_REGS->R[2] != (VDWORD) 6) {
            bTestPass = false;
            goto FINISH_TESTS;
        }
    }
    else {
        bTestPass = false;
        goto FINISH_TESTS;
    }
    T_REGS->R[2] = (VDWORD) 0;
    T_AS->codeData[0] = 0x00;
    T_AS->codeData[1] = 0x00;
    T_AS->codeData[2] = 0x00;
    T_REGS->SP = sizeof(T_AS->stack) / sizeof(VDWORD);
    T_REGS->PC = (VDWORD) 0;
    printTestResult(bTestPass, currentTestNumber);
    /* ************************* */
        /* TEST 9
        desc: shift the bits to the right
        */
    /* ************************* */
    ++currentTestNumber;
    T_REGS->R[2] = (VDWORD) 4;
    T_AS->codeData[0] = SHR;
    T_AS->codeData[1] = 0x02;
    T_AS->codeData[2] = 0x01;
    T_AS->codeData[3] = EE;
    vm->vcpuFlag = VCpuFlag::OK;
    vm->run();
    if(vm->vcpuFlag == VCpuFlag::ERROR) {
        bTestPass = false;
        goto FINISH_TESTS;
    }
    if(T_REGS->R[2] != (VDWORD) 2){
        bTestPass = false;
        goto FINISH_TESTS;
    }
    T_REGS->R[2] = (VDWORD) 0;
    T_REGS->PC = (VDWORD) 0;
    T_AS->codeData[0] = 0x00;
    T_AS->codeData[1] = 0x00;
    T_AS->codeData[2] = 0x00;
    T_AS->codeData[3] = 0x00;
    printTestResult(bTestPass, currentTestNumber);
    /* ************************* */
        /* TEST 10
        desc: shift the bits to the left
        */
    /* ************************* */
    ++currentTestNumber;
    T_REGS->R[2] = (VDWORD) 4;
    T_AS->codeData[0] = SHL;
    T_AS->codeData[1] = 0x02;
    T_AS->codeData[2] = 0x01;
    T_AS->codeData[3] = EE;
    vm->vcpuFlag = VCpuFlag::OK;
    vm->run();
    if(vm->vcpuFlag == VCpuFlag::ERROR) {
        bTestPass = false;
        goto FINISH_TESTS;
    }
    if(T_REGS->R[2] != (VDWORD) 8){
        bTestPass = false;
        goto FINISH_TESTS;
    }
    T_REGS->R[2] = (VDWORD) 0;
    T_REGS->PC = (VDWORD) 0;
    T_AS->codeData[0] = 0x00;
    T_AS->codeData[1] = 0x00;
    T_AS->codeData[2] = 0x00;
    T_AS->codeData[3] = 0x00;
    printTestResult(bTestPass, currentTestNumber);
    /* ************************* */

    goto FINISH_TESTS;

FINISH_TESTS:
    if(bTestPass == false) printTestResult(bTestPass, currentTestNumber);
    T_AS = NULL;
    T_REGS = NULL;
    return bTestPass;
}
```

`VMCore/tests/vmtest.hpp`:

```hpp
#ifndef _VM_TEST_HPP
#define _VM_TEST_HPP

#define _VM_CPU_TEST_

#include "../include/vmcpu.hpp"

class VMTest {
    private:
        VMCPU *vm;
        PADDRESS_SPACE T_AS;
        PREGISTERSS T_REGS;
        void printTestResult(bool, unsigned int);

    public:
        VMTest() {
            vm = new VMCPU();
        }
        ~VMTest() {
            delete vm;
        }
        bool testVM();
};
#endif
```

`VMPROTECT.py`:

```py
#!/usr/bin/python3

import Editor.main as editor

from tkinter import *
from tkinter import messagebox
from tkinter import filedialog

print("""\
 _   ____  _______________ _____ _____ _____ _____ _____ 
| | | |  \/  || ___ \ ___ \  _  |_   _|  ___/  __ \_   _|
| | | | .  . || |_/ / |_/ / | | | | | | |__ | /  \/ | |  
| | | | |\/| ||  __/|    /| | | | | | |  __|| |     | |  
\ \_/ / |  | || |   | |\ \\ \_/ / | | | |___| \__/\ | |  
 \___/\_|  |_/\_|   \_| \_|\___/  \_/ \____/ \____/ \_/  
""")
print("version 0.2.201005.2057")

# Creating TK Container
root = Tk()
# Passing Root to Editor Class
editor.Editor(root)
# Root Window Looping
root.mainloop()
```

`doc/CPU_Opcodes.md`:

```md
# CPU's opcodes

OPCODE | Mnemonic and params | Description
--- | --- | ---
00  | NOP | No operation |
EE  | EE | End of code and end of the VM's cpu |
01  | MOV r<sub>dst</sub>, r<sub>src</sub> | Move from a register to a register|
02  |  MOVMB r<sub>dst</sub>, addr<sub>src</sub> | Move and extend byte from memory to a register|
03  |  MOVMW r<sub>dst</sub>, addr<sub>src</sub> | Move word from memory to a register |
04  |  MOVB r<sub>dst</sub>, byte | Move and extend byte to a register  |
05  |  MOVW r<sub>dst</sub>, word | Move word to a register |
06  |  MOVBM addr<sub>dst</sub>, r<sub>src</sub> | Move byte from a register to memory location |
07  |  MOVWM addr<sub>dst</sub>, r<sub>src</sub> | Move word from a register to memory location |
08  |  MOVMRB r<sub>dst</sub>, r<sub>src</sub> | Move and extend byte from memory to a register; get an address from a register |
09  |  MOVMRW r<sub>dst</sub>, r<sub>src</sub> | Move word from memory to a register; get an address from a register |
0A  |  MOVMD r<sub>dst</sub>, addr<sub>src</sub> | Move double word from memory to a register |
0B  |  MOVD r<sub>dst</sub>, dword | Move double word to a register |
0C  |  MOVDM addr<sub>dst</sub>, r<sub>src</sub> | Move double word from a register to memory location |
0D  |  MOVMRD r<sub>dst</sub>, r<sub>src</sub> | Move double from memory to a register; get an address from a register |
  | | |
20  |  JMP addr | Unconditional jump |
21  |  JZ addr | Jump if equal; it set up PC to the specified location if the ZF is set (1) |
22  |  JNZ addr | Jump if not equal; it set up PC to the specified location if the ZF is not set (0) |
23  |  JAE addr | Jump if above or equal; it set up PC to the specified location if the ZF is set (1) and the CF is not set (0) |
24  |  JBE addr | Jump if below or equal; it set up PC to the specified location if the ZF is set (1) and the CF is set (1) |
25  |  JB addr | Jump if below; it set up PC to the specified location if the ZF is not set (0) and the CF is set (1) |
26  |  JA addr | Jump if above; it set up PC to the specified location if the ZF is not set (0) and the CF is not set (0) |
  | | |
30  |  ADVR r<sub>dst</sub>, word | Add word value to a register |
31  |  ADRR r<sub>dst</sub>, r<sub>src</sub> | Add two registers |
32  |  ADRRL r<sub>dst</sub>, r<sub>src</sub> | Add two registers (the low byte) |
33  |  SUBVR r<sub>dst</sub>, word | Substract word value from a register |
34  |  SUBRR r<sub>dst</sub>, r<sub>src</sub> | Substract two registers |
35  |  SUBRRL r<sub>dst</sub>, r<sub>src</sub> | Substract two registers (the low byte) |
36  |  XOR r<sub>dst</sub>, r<sub>src</sub> | Xor two registers |
37  |  XOR r<sub>dst</sub>, r<sub>src</sub> | Xor two registers (the low byte) |
38  |  NOT r<sub>dst</sub>| Bitwise NOT on value in a register |
39  |  NOT r<sub>dst</sub> | Bitwise NOT on value in a register (the low byte) |
3A  |  ADVRD r<sub>dst</sub>, dword | Add double word value to a register |
3B  |  SUBVR r<sub>dst</sub>, dword | Substract double word value from a register |
3C  |  SHR r<sub>dst</sub>, count<sub>byte</sub> | Shift the bits of the operand destination to the right, by the number of bits specified in the count operand |
3D  |  SHL r<sub>dst</sub>, count<sub>byte</sub> | Shift the bits of the operand destination to the left, by the number of bits specified in the count operand |
  | | |
50  |  CMP r<sub>dst</sub>, r<sub>src</sub> | Compare two registers |
51  |  CMPL r<sub>dst</sub>, r<sub>src</sub> | Compare two registers (the low byte) |
  | | |
60  |  VMSYSBUS word | Arguments to functions pass via the stack |
  | | |
90  |  PUSH r<sub>src</sub> | Push value from a register to stack |
91  |  POP r<sub>dst</sub> | Pop value from stack to a register |
92  |  CLST | Clear the stack |
93  |  SETSP dword| Set the stack pointer to the double word value |
  | | |
A0  |  POC  | Print char without new line, the value must be at the top of the stack |
A1  |  POCN  | Print char with new line, the value must be at the top of the stack |
A2  |  TIB  | Take input and move to the data buffer, the length of the string is stored in R[7] |
A3  |  GIC r<sub>src</sub> | Get a specific char from input, that is stored in the data buffer, the value will be stored in R[7], pass the position of char via a some register |
A4  |  PIC  | Print char from input without new line, the value must be at the top of the stack |
A5  |  PICN  | Print char from input with new line, the value must be at the top of the stack |
A6  |  PXV  | Print a value in hex, the value must be at the top of the stack |
A7  |  PXVN  | Print a value in hex with a new line, the value must be at the top of the stack |
```

`doc/Sysbus.md`:

```md
# A system bus

## Values
CODE | RETURN VALUE
--- | ---
DIR_CREATED | 200000
DIR_CREATED_ERROR | 200001
DIR_EXIST | 200002
DELETE_DIR | 200011
MOVE_DIR | 200003
COPY_DIR | 200004
OTHER_DIR_ERROR | 200005
FILE_CREATED | 200006
FILE_EXIST | 200007
DELETE_FILE | 200012
MOVE_FILE | 200008
COPY_FILE | 200009
OTHER_FILE_ERROR | 200010
NO_IMPLEMENTED_ERROR | 200110

## Functions
Arguments to functions pass via the stack.

```c++
int createDirectory(std::string, int));
int deleteDirectory(std::string);
int moveDirectory(std::string, std::string);
int copyDirectory(std::string, std::string);
int createFile(std::string, uint8_t*, int);
int deleteFile(std::string);
int moveFile(std::string, std::string);
int copyFile(std::string, std::string);
```
## OS support
FUNC | CMD | CODE | Windows | Linux | MacOS
--- | --- | --- | --- | --- | ---
createDirectory | sysdircr | 1 | YES | YES | NO |
deleteDirectory | sysdirdel | 2 | YES | YES | NO |
moveDirectory | sysdirmv | 3 | YES | NO | NO |
copyDirectory | sysdircp | 4 | YES | NO | NO |
createFile | sysfilecr | 5 | YES | YES | NO |
deleteFile | sysfiledel | 6 | YES | YES | NO |
moveFile | sysfilemv | 7 | YES | YES | NO |
copyFile | sysfilecp | 8 | YES | YES | NO |
```