Project Path: arc_gmh5225_Voyager_4az6wdf6

Source Tree:

```txt
arc_gmh5225_Voyager_4az6wdf6
├── BootMgfw.c
├── BootMgfw.h
├── CryptoPkg
│   └── Include
│       └── Library
│           ├── BaseCryptLib.h
│           └── TlsLib.h
├── Hv.c
├── Hv.h
├── HvLoader.c
├── HvLoader.h
├── InlineHook.c
├── InlineHook.h
├── LICENSE
├── PagingTables.h
├── PayLoad (AMD)
│   ├── PayLoad (AMD).vcxproj
│   ├── PayLoad (AMD).vcxproj.filters
│   ├── PayLoad (AMD).vcxproj.user
│   ├── debug.cpp
│   ├── debug.h
│   ├── ia32.hpp
│   ├── mm.cpp
│   ├── mm.h
│   ├── types.h
│   ├── vmexit.cpp
│   ├── vmexit.h
│   └── vmexit_handler.cpp
├── PayLoad (Intel)
│   ├── PayLoad (Intel).vcxproj
│   ├── PayLoad (Intel).vcxproj.filters
│   ├── PayLoad (Intel).vcxproj.user
│   ├── debug.cpp
│   ├── debug.h
│   ├── ia32.hpp
│   ├── mm.cpp
│   ├── mm.h
│   ├── types.h
│   ├── vmexit.cpp
│   ├── vmexit.h
│   └── vmexit_handler.cpp
├── PayLoad.c
├── PayLoad.h
├── README.md
├── ShellPkg
│   └── Include
│       ├── Guid
│       │   ├── ShellAliasGuid.h
│       │   ├── ShellEnvironment2Ext.h
│       │   ├── ShellLibHiiGuid.h
│       │   ├── ShellMapGuid.h
│       │   ├── ShellPkgTokenSpace.h
│       │   └── ShellVariableGuid.h
│       ├── Library
│       │   ├── BcfgCommandLib.h
│       │   ├── HandleParsingLib.h
│       │   ├── ShellCEntryLib.h
│       │   ├── ShellCommandLib.h
│       │   └── ShellLib.h
│       └── Protocol
│           ├── EfiShellEnvironment2.h
│           └── EfiShellInterface.h
├── SplashScreen.c
├── SplashScreen.h
├── UefiMain.c
├── Utils.c
├── Utils.h
├── Voyager.sln
├── Voyager.vcxproj
├── Voyager.vcxproj.filters
├── Voyager.vcxproj.user
├── WinLoad.c
├── WinLoad.h
├── example
│   ├── example.vcxproj
│   ├── example.vcxproj.filters
│   ├── example.vcxproj.user
│   ├── libvoyager.hpp
│   ├── libvoyager.lib
│   ├── main.cpp
│   ├── util
│   │   ├── nt.hpp
│   │   └── util.hpp
│   └── vdm_ctx
│       ├── vdm_ctx.cpp
│       └── vdm_ctx.hpp
└── libvoyager
    ├── com.asm
    ├── libvoyager.cpp
    ├── libvoyager.hpp
    ├── libvoyager.sln
    ├── libvoyager.vcxproj
    ├── libvoyager.vcxproj.filters
    └── libvoyager.vcxproj.user

```

`BootMgfw.c`:

```c
#include "BootMgfw.h"
#include "SplashScreen.h"

INLINE_HOOK BootMgfwShitHook;
EFI_STATUS EFIAPI RestoreBootMgfw(VOID)
{
	UINTN HandleCount = NULL;
	EFI_STATUS Result;
	EFI_HANDLE* Handles = NULL;
	EFI_FILE_HANDLE VolumeHandle;
	EFI_FILE_HANDLE BootMgfwHandle;
	EFI_FILE_IO_INTERFACE* FileSystem = NULL;

	if (EFI_ERROR((Result = gBS->LocateHandleBuffer(ByProtocol, &gEfiSimpleFileSystemProtocolGuid, NULL, &HandleCount, &Handles))))
	{
		Print(L"error getting file system handles -> 0x%p\n", Result);
		return Result;
	}

	for (UINT32 Idx = 0u; Idx < HandleCount; ++Idx)
	{
		if (EFI_ERROR((Result = gBS->OpenProtocol(Handles[Idx], &gEfiSimpleFileSystemProtocolGuid, (VOID**)&FileSystem, gImageHandle, NULL, EFI_OPEN_PROTOCOL_GET_PROTOCOL))))
		{
			Print(L"error opening protocol -> 0x%p\n", Result);
			return Result;
		}

		if (EFI_ERROR((Result = FileSystem->OpenVolume(FileSystem, &VolumeHandle))))
		{
			Print(L"error opening file system -> 0x%p\n", Result);
			return Result;
		}

		if (!EFI_ERROR((Result = VolumeHandle->Open(VolumeHandle, &BootMgfwHandle, WINDOWS_BOOTMGFW_PATH, EFI_FILE_MODE_READ, EFI_FILE_READ_ONLY))))
		{
			VolumeHandle->Close(VolumeHandle);
			EFI_FILE_PROTOCOL* BootMgfwFile = NULL;
			EFI_DEVICE_PATH* BootMgfwPathProtocol = FileDevicePath(Handles[Idx], WINDOWS_BOOTMGFW_PATH);

			// open bootmgfw as read/write then delete it...
			if (EFI_ERROR((Result = EfiOpenFileByDevicePath(&BootMgfwPathProtocol, &BootMgfwFile, EFI_FILE_MODE_WRITE | EFI_FILE_MODE_READ, NULL))))
			{
				Print(L"error opening bootmgfw... reason -> %r\n", Result);
				return Result;
			}

			if (EFI_ERROR((Result = BootMgfwFile->Delete(BootMgfwFile))))
			{
				Print(L"error deleting bootmgfw... reason -> %r\n", Result);
				return Result;
			}

			// open bootmgfw.efi.backup
			BootMgfwPathProtocol = FileDevicePath(Handles[Idx], WINDOWS_BOOTMGFW_BACKUP_PATH);
			if (EFI_ERROR((Result = EfiOpenFileByDevicePath(&BootMgfwPathProtocol, &BootMgfwFile, EFI_FILE_MODE_WRITE | EFI_FILE_MODE_READ, NULL))))
			{
				Print(L"failed to open backup file... reason -> %r\n", Result);
				return Result;
			}

			EFI_FILE_INFO* FileInfoPtr = NULL;
			UINTN FileInfoSize = NULL;

			// get the size of bootmgfw.efi.backup...
			if (EFI_ERROR((Result = BootMgfwFile->GetInfo(BootMgfwFile, &gEfiFileInfoGuid, &FileInfoSize, NULL))))
			{
				if (Result == EFI_BUFFER_TOO_SMALL)
				{
					gBS->AllocatePool(EfiBootServicesData, FileInfoSize, &FileInfoPtr);
					if (EFI_ERROR(Result = BootMgfwFile->GetInfo(BootMgfwFile, &gEfiFileInfoGuid, &FileInfoSize, FileInfoPtr)))
					{
						Print(L"get backup file information failed... reason -> %r\n", Result);
						return Result;
					}
				}
				else
				{
					Print(L"Failed to get file information... reason -> %r\n", Result);
					return Result;
				}
			}

			VOID* BootMgfwBuffer = NULL;
			UINTN BootMgfwSize = FileInfoPtr->FileSize;
			gBS->AllocatePool(EfiBootServicesData, FileInfoPtr->FileSize, &BootMgfwBuffer);

			// read the backup file into an allocated pool...
			if (EFI_ERROR((Result = BootMgfwFile->Read(BootMgfwFile, &BootMgfwSize, BootMgfwBuffer))))
			{
				Print(L"Failed to read backup file into buffer... reason -> %r\n", Result);
				return Result;
			}

			// delete the backup file...
			if (EFI_ERROR((Result = BootMgfwFile->Delete(BootMgfwFile))))
			{
				Print(L"unable to delete backup file... reason -> %r\n", Result);
				return Result;
			}

			// create a new bootmgfw file...
			BootMgfwPathProtocol = FileDevicePath(Handles[Idx], WINDOWS_BOOTMGFW_PATH);
			if (EFI_ERROR((Result = EfiOpenFileByDevicePath(&BootMgfwPathProtocol, &BootMgfwFile, EFI_FILE_MODE_CREATE | EFI_FILE_MODE_WRITE | EFI_FILE_MODE_READ, EFI_FILE_SYSTEM))))
			{
				Print(L"unable to create new bootmgfw on disk... reason -> %r\n", Result);
				return Result;
			}

			// write the data from the backup file to the new bootmgfw file...
			BootMgfwSize = FileInfoPtr->FileSize;
			if (EFI_ERROR((Result = BootMgfwFile->Write(BootMgfwFile, &BootMgfwSize, BootMgfwBuffer))))
			{
				Print(L"unable to write to newly created bootmgfw.efi... reason -> %r\n", Result);
				return Result;
			}

			BootMgfwFile->Close(BootMgfwFile);
			gBS->FreePool(FileInfoPtr);
			gBS->FreePool(BootMgfwBuffer);
			return EFI_SUCCESS;
		}

		if (EFI_ERROR((Result = gBS->CloseProtocol(Handles[Idx], &gEfiSimpleFileSystemProtocolGuid, gImageHandle, NULL))))
		{
			Print(L"error closing protocol -> 0x%p\n", Result);
			return Result;
		}
	}

	gBS->FreePool(Handles);
	return EFI_ABORTED;
}

EFI_STATUS EFIAPI GetBootMgfwPath(EFI_DEVICE_PATH** BootMgfwDevicePath)
{
	UINTN HandleCount = NULL;
	EFI_STATUS Result;
	EFI_HANDLE* Handles = NULL;
	EFI_FILE_HANDLE VolumeHandle;
	EFI_FILE_HANDLE BootMgfwHandle;
	EFI_FILE_IO_INTERFACE* FileSystem = NULL;

	if (EFI_ERROR((Result = gBS->LocateHandleBuffer(ByProtocol, &gEfiSimpleFileSystemProtocolGuid, NULL, &HandleCount, &Handles))))
	{
		Print(L"error getting file system handles -> 0x%p\n", Result);
		return Result;
	}

	for (UINT32 Idx = 0u; Idx < HandleCount; ++Idx)
	{
		if (EFI_ERROR((Result = gBS->OpenProtocol(Handles[Idx], &gEfiSimpleFileSystemProtocolGuid, (VOID**)&FileSystem, gImageHandle, NULL, EFI_OPEN_PROTOCOL_GET_PROTOCOL))))
		{
			Print(L"error opening protocol -> 0x%p\n", Result);
			return Result;
		}

		if (EFI_ERROR((Result = FileSystem->OpenVolume(FileSystem, &VolumeHandle))))
		{
			Print(L"error opening file system -> 0x%p\n", Result);
			return Result;
		}

		if (!EFI_ERROR(VolumeHandle->Open(VolumeHandle, &BootMgfwHandle, WINDOWS_BOOTMGFW_PATH, EFI_FILE_MODE_READ, EFI_FILE_READ_ONLY)))
		{
			VolumeHandle->Close(BootMgfwHandle);
			*BootMgfwDevicePath = FileDevicePath(Handles[Idx], WINDOWS_BOOTMGFW_PATH);
			return EFI_SUCCESS;
		}

		if (EFI_ERROR((Result = gBS->CloseProtocol(Handles[Idx], &gEfiSimpleFileSystemProtocolGuid, gImageHandle, NULL))))
		{
			Print(L"error closing protocol -> 0x%p\n", Result);
			return Result;
		}
	}
	return EFI_NOT_FOUND;
}

EFI_STATUS EFIAPI InstallBootMgfwHooks(EFI_HANDLE ImageHandle)
{
	EFI_STATUS Result = EFI_SUCCESS;
	EFI_LOADED_IMAGE* BootMgfw = NULL;
	
	if (EFI_ERROR(Result = gBS->HandleProtocol(ImageHandle, &gEfiLoadedImageProtocolGuid, (VOID**)&BootMgfw)))
		return Result;

	Print(L"BootMgfw Image Base -> 0x%p\n", BootMgfw->ImageBase);
	Print(L"BootMgfw Image Size -> 0x%x\n", BootMgfw->ImageSize);

	VOID* ArchStartBootApplication =
		FindPattern(
			BootMgfw->ImageBase,
			BootMgfw->ImageSize,
			START_BOOT_APPLICATION_SIG,
			START_BOOT_APPLICATION_MASK
		);

	if (!ArchStartBootApplication)
		return EFI_NOT_FOUND;

#if WINVER >= 1703
	Print(L"BootMgfw.BlImgStartBootApplication -> 0x%p\n", ArchStartBootApplication);
	MakeInlineHook(&BootMgfwShitHook, ArchStartBootApplication, &ArchStartBootApplicationHook, TRUE);
#else
	Print(L"BootMgfw.BlImgStartBootApplication -> 0x%p\n", RESOLVE_RVA(ArchStartBootApplication, 5, 1));
	MakeInlineHook(&BootMgfwShitHook, RESOLVE_RVA(ArchStartBootApplication, 5, 1), &ArchStartBootApplicationHook, TRUE);
#endif
	return EFI_SUCCESS;
}

EFI_STATUS EFIAPI ArchStartBootApplicationHook(VOID* AppEntry, VOID* ImageBase, UINT32 ImageSize, UINT8 BootOption, VOID* ReturnArgs)
{
	// disable ArchStartBootApplication shithook
	DisableInlineHook(&BootMgfwShitHook);

	// on 1703 and below, winload does not export any functions
	if (!GetExport(ImageBase, "BlLdrLoadImage"))
	{
		VOID* ImgLoadPEImageEx =
			FindPattern(
				ImageBase,
				ImageSize,
				LOAD_PE_IMG_SIG,
				LOAD_PE_IMG_MASK
			);

		gST->ConOut->ClearScreen(gST->ConOut);
		gST->ConOut->OutputString(gST->ConOut, AsciiArt);
		Print(L"\n");

		Print(L"Hyper-V PayLoad Size -> 0x%x\n", PayLoadSize());
		Print(L"winload.BlImgLoadPEImageEx -> 0x%p\n", RESOLVE_RVA(ImgLoadPEImageEx, 10, 6));
		MakeInlineHook(&WinLoadImageShitHook, RESOLVE_RVA(ImgLoadPEImageEx, 10, 6), &BlImgLoadPEImageEx, TRUE);
	}
	else // else the installed windows version is between 2004 and 1709
	{
		VOID* LdrLoadImage = GetExport(ImageBase, "BlLdrLoadImage");
		VOID* ImgAllocateImageBuffer =
			FindPattern(
				ImageBase,
				ImageSize,
				ALLOCATE_IMAGE_BUFFER_SIG,
				ALLOCATE_IMAGE_BUFFER_MASK
			);

		gST->ConOut->ClearScreen(gST->ConOut);
		gST->ConOut->OutputString(gST->ConOut, AsciiArt);
		Print(L"\n");

		Print(L"Hyper-V PayLoad Size -> 0x%x\n", PayLoadSize());
		Print(L"winload.BlLdrLoadImage -> 0x%p\n", LdrLoadImage);
		Print(L"winload.BlImgAllocateImageBuffer -> 0x%p\n", RESOLVE_RVA(ImgAllocateImageBuffer, 5, 1));

		MakeInlineHook(&WinLoadImageShitHook, LdrLoadImage, &BlLdrLoadImage, TRUE);
		MakeInlineHook(&WinLoadAllocateImageHook, RESOLVE_RVA(ImgAllocateImageBuffer, 5, 1), &BlImgAllocateImageBuffer, TRUE);
	}
	return ((IMG_ARCH_START_BOOT_APPLICATION)BootMgfwShitHook.Address)(AppEntry, ImageBase, ImageSize, BootOption, ReturnArgs);
}
```

`BootMgfw.h`:

```h
#pragma once
#include "WinLoad.h"

#if WINVER > 1709
#define START_BOOT_APPLICATION_SIG "\x48\x8B\xC4\x48\x89\x58\x20\x44\x89\x40\x18\x48\x89\x50\x10\x48\x89\x48\x08\x55\x56\x57\x41\x54"
#define START_BOOT_APPLICATION_MASK "xxxxxxxxxxxxxxxxxxxxxxxx"
#elif WINVER == 1709
#define START_BOOT_APPLICATION_SIG "\x48\x8B\xC4\x48\x89\x58\x00\x44\x89\x40\x00\x48\x89\x50\x00\x48\x89\x48\x00\x55\x56\x57\x41\x54\x41\x55\x41\x56\x41\x57\x48\x8D\x68"
#define START_BOOT_APPLICATION_MASK "xxxxxx?xxx?xxx?xxx?xxxxxxxxxxxxxx"
#elif WINVER == 1703
#define START_BOOT_APPLICATION_SIG "\x48\x8B\xC4\x48\x89\x58\x00\x44\x89\x48\x00\x44\x89\x40\x00\x48\x89\x48\x00\x55\x56\x57\x41\x54\x41\x55\x41\x56\x41\x57\x48\x8D\x68\xA9"
#define START_BOOT_APPLICATION_MASK "xxxxxx?xxx?xxx?xxx?xxxxxxxxxxxxxxx"
#elif WINVER < 1703
#define START_BOOT_APPLICATION_SIG "\xE8\x00\x00\x00\x00\x48\x8B\xCE\x8B\xD8\xE8\x00\x00\x00\x00\x41\x8B\xCF"
#define START_BOOT_APPLICATION_MASK "x????xxxxxx????xxx"
#endif
static_assert(sizeof(START_BOOT_APPLICATION_SIG) == sizeof(START_BOOT_APPLICATION_MASK), "signature and mask size's dont match...");

#define WINDOWS_BOOTMGFW_PATH L"\\efi\\microsoft\\boot\\bootmgfw.efi"
#define PAYLOAD_PATH L"\\efi\\microsoft\\boot\\payload.dll"
#define WINDOWS_BOOTMGFW_BACKUP_PATH L"\\efi\\microsoft\\boot\\bootmgfw.efi.backup"

extern INLINE_HOOK BootMgfwShitHook;
typedef EFI_STATUS(EFIAPI* IMG_ARCH_START_BOOT_APPLICATION)(VOID*, VOID*, UINT32, UINT8, VOID*);

/// <summary>
/// restores bootmgfw on disk to its original...
/// </summary>
/// <param name=""></param>
/// <returns>status of completion</returns>
EFI_STATUS EFIAPI RestoreBootMgfw(VOID);

/// <summary>
/// gets bootmgfw device path...
/// </summary>
/// <param name="BootMgfwDevicePath">pointer to a device path pointer...</param>
/// <returns>status of completion...</returns>
EFI_STATUS EFIAPI GetBootMgfwPath(EFI_DEVICE_PATH** BootMgfwDevicePath);

/// <summary>
/// Called to install hooks on bootmgfw... specifically ArchStartBootApplication which
/// is called to load winload...
/// </summary>
/// <param name="ImageHandle">Handle to bootmgfw...</param>
/// <returns>efi success if hooks where installed...</returns>
EFI_STATUS EFIAPI InstallBootMgfwHooks(EFI_HANDLE BootMgfwPath);

/// <summary>
/// This function is called when winload is loaded into memory... all hooks related to winload will be put here...
/// </summary>
/// <param name="AppEntry">Unknown</param>
/// <param name="ImageBase">Base Address of winload...</param>
/// <param name="ImageSize">Size of winload (in memory not on disk)</param>
/// <param name="BootOption">Unknown</param>
/// <param name="ReturnArgs">Unknown</param>
/// <returns>original function's return value...</returns>
EFI_STATUS EFIAPI ArchStartBootApplicationHook(VOID* AppEntry, VOID* ImageBase, UINT32 ImageSize, UINT8 BootOption, VOID* ReturnArgs);
```

`CryptoPkg/Include/Library/BaseCryptLib.h`:

```h
/** @file
  Defines base cryptographic library APIs.
  The Base Cryptographic Library provides implementations of basic cryptography
  primitives (Hash Serials, HMAC, RSA, Diffie-Hellman, etc) for UEFI security
  functionality enabling.

Copyright (c) 2009 - 2018, Intel Corporation. All rights reserved.<BR>
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#ifndef __BASE_CRYPT_LIB_H__
#define __BASE_CRYPT_LIB_H__

#include <Uefi/UefiBaseType.h>

///
/// MD4 digest size in bytes
///
#define MD4_DIGEST_SIZE     16

///
/// MD5 digest size in bytes
///
#define MD5_DIGEST_SIZE     16

///
/// SHA-1 digest size in bytes.
///
#define SHA1_DIGEST_SIZE    20

///
/// SHA-256 digest size in bytes
///
#define SHA256_DIGEST_SIZE  32

///
/// SHA-384 digest size in bytes
///
#define SHA384_DIGEST_SIZE  48

///
/// SHA-512 digest size in bytes
///
#define SHA512_DIGEST_SIZE  64

///
/// TDES block size in bytes
///
#define TDES_BLOCK_SIZE     8

///
/// AES block size in bytes
///
#define AES_BLOCK_SIZE      16

///
/// RSA Key Tags Definition used in RsaSetKey() function for key component identification.
///
typedef enum {
  RsaKeyN,      ///< RSA public Modulus (N)
  RsaKeyE,      ///< RSA Public exponent (e)
  RsaKeyD,      ///< RSA Private exponent (d)
  RsaKeyP,      ///< RSA secret prime factor of Modulus (p)
  RsaKeyQ,      ///< RSA secret prime factor of Modules (q)
  RsaKeyDp,     ///< p's CRT exponent (== d mod (p - 1))
  RsaKeyDq,     ///< q's CRT exponent (== d mod (q - 1))
  RsaKeyQInv    ///< The CRT coefficient (== 1/q mod p)
} RSA_KEY_TAG;

//=====================================================================================
//    One-Way Cryptographic Hash Primitives
//=====================================================================================

/**
  Retrieves the size, in bytes, of the context buffer required for MD4 hash operations.

  If this interface is not supported, then return zero.

  @return  The size, in bytes, of the context buffer required for MD4 hash operations.
  @retval  0   This interface is not supported.

**/
UINTN
EFIAPI
Md4GetContextSize (
  VOID
  );

/**
  Initializes user-supplied memory pointed by Md4Context as MD4 hash context for
  subsequent use.

  If Md4Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[out]  Md4Context  Pointer to MD4 context being initialized.

  @retval TRUE   MD4 context initialization succeeded.
  @retval FALSE  MD4 context initialization failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Md4Init (
  OUT  VOID  *Md4Context
  );

/**
  Makes a copy of an existing MD4 context.

  If Md4Context is NULL, then return FALSE.
  If NewMd4Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]  Md4Context     Pointer to MD4 context being copied.
  @param[out] NewMd4Context  Pointer to new MD4 context.

  @retval TRUE   MD4 context copy succeeded.
  @retval FALSE  MD4 context copy failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Md4Duplicate (
  IN   CONST VOID  *Md4Context,
  OUT  VOID        *NewMd4Context
  );

/**
  Digests the input data and updates MD4 context.

  This function performs MD4 digest on a data buffer of the specified size.
  It can be called multiple times to compute the digest of long or discontinuous data streams.
  MD4 context should be already correctly initialized by Md4Init(), and should not be finalized
  by Md4Final(). Behavior with invalid context is undefined.

  If Md4Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  Md4Context  Pointer to the MD4 context.
  @param[in]       Data        Pointer to the buffer containing the data to be hashed.
  @param[in]       DataSize    Size of Data buffer in bytes.

  @retval TRUE   MD4 data digest succeeded.
  @retval FALSE  MD4 data digest failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Md4Update (
  IN OUT  VOID        *Md4Context,
  IN      CONST VOID  *Data,
  IN      UINTN       DataSize
  );

/**
  Completes computation of the MD4 digest value.

  This function completes MD4 hash computation and retrieves the digest value into
  the specified memory. After this function has been called, the MD4 context cannot
  be used again.
  MD4 context should be already correctly initialized by Md4Init(), and should not be
  finalized by Md4Final(). Behavior with invalid MD4 context is undefined.

  If Md4Context is NULL, then return FALSE.
  If HashValue is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  Md4Context  Pointer to the MD4 context.
  @param[out]      HashValue   Pointer to a buffer that receives the MD4 digest
                               value (16 bytes).

  @retval TRUE   MD4 digest computation succeeded.
  @retval FALSE  MD4 digest computation failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Md4Final (
  IN OUT  VOID   *Md4Context,
  OUT     UINT8  *HashValue
  );

/**
  Computes the MD4 message digest of a input data buffer.

  This function performs the MD4 message digest of a given data buffer, and places
  the digest value into the specified memory.

  If this interface is not supported, then return FALSE.

  @param[in]   Data        Pointer to the buffer containing the data to be hashed.
  @param[in]   DataSize    Size of Data buffer in bytes.
  @param[out]  HashValue   Pointer to a buffer that receives the MD4 digest
                           value (16 bytes).

  @retval TRUE   MD4 digest computation succeeded.
  @retval FALSE  MD4 digest computation failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Md4HashAll (
  IN   CONST VOID  *Data,
  IN   UINTN       DataSize,
  OUT  UINT8       *HashValue
  );

/**
  Retrieves the size, in bytes, of the context buffer required for MD5 hash operations.

  If this interface is not supported, then return zero.

  @return  The size, in bytes, of the context buffer required for MD5 hash operations.
  @retval  0   This interface is not supported.

**/
UINTN
EFIAPI
Md5GetContextSize (
  VOID
  );

/**
  Initializes user-supplied memory pointed by Md5Context as MD5 hash context for
  subsequent use.

  If Md5Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[out]  Md5Context  Pointer to MD5 context being initialized.

  @retval TRUE   MD5 context initialization succeeded.
  @retval FALSE  MD5 context initialization failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Md5Init (
  OUT  VOID  *Md5Context
  );

/**
  Makes a copy of an existing MD5 context.

  If Md5Context is NULL, then return FALSE.
  If NewMd5Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]  Md5Context     Pointer to MD5 context being copied.
  @param[out] NewMd5Context  Pointer to new MD5 context.

  @retval TRUE   MD5 context copy succeeded.
  @retval FALSE  MD5 context copy failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Md5Duplicate (
  IN   CONST VOID  *Md5Context,
  OUT  VOID        *NewMd5Context
  );

/**
  Digests the input data and updates MD5 context.

  This function performs MD5 digest on a data buffer of the specified size.
  It can be called multiple times to compute the digest of long or discontinuous data streams.
  MD5 context should be already correctly initialized by Md5Init(), and should not be finalized
  by Md5Final(). Behavior with invalid context is undefined.

  If Md5Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  Md5Context  Pointer to the MD5 context.
  @param[in]       Data        Pointer to the buffer containing the data to be hashed.
  @param[in]       DataSize    Size of Data buffer in bytes.

  @retval TRUE   MD5 data digest succeeded.
  @retval FALSE  MD5 data digest failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Md5Update (
  IN OUT  VOID        *Md5Context,
  IN      CONST VOID  *Data,
  IN      UINTN       DataSize
  );

/**
  Completes computation of the MD5 digest value.

  This function completes MD5 hash computation and retrieves the digest value into
  the specified memory. After this function has been called, the MD5 context cannot
  be used again.
  MD5 context should be already correctly initialized by Md5Init(), and should not be
  finalized by Md5Final(). Behavior with invalid MD5 context is undefined.

  If Md5Context is NULL, then return FALSE.
  If HashValue is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  Md5Context  Pointer to the MD5 context.
  @param[out]      HashValue   Pointer to a buffer that receives the MD5 digest
                               value (16 bytes).

  @retval TRUE   MD5 digest computation succeeded.
  @retval FALSE  MD5 digest computation failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Md5Final (
  IN OUT  VOID   *Md5Context,
  OUT     UINT8  *HashValue
  );

/**
  Computes the MD5 message digest of a input data buffer.

  This function performs the MD5 message digest of a given data buffer, and places
  the digest value into the specified memory.

  If this interface is not supported, then return FALSE.

  @param[in]   Data        Pointer to the buffer containing the data to be hashed.
  @param[in]   DataSize    Size of Data buffer in bytes.
  @param[out]  HashValue   Pointer to a buffer that receives the MD5 digest
                           value (16 bytes).

  @retval TRUE   MD5 digest computation succeeded.
  @retval FALSE  MD5 digest computation failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Md5HashAll (
  IN   CONST VOID  *Data,
  IN   UINTN       DataSize,
  OUT  UINT8       *HashValue
  );

/**
  Retrieves the size, in bytes, of the context buffer required for SHA-1 hash operations.

  If this interface is not supported, then return zero.

  @return  The size, in bytes, of the context buffer required for SHA-1 hash operations.
  @retval  0   This interface is not supported.

**/
UINTN
EFIAPI
Sha1GetContextSize (
  VOID
  );

/**
  Initializes user-supplied memory pointed by Sha1Context as SHA-1 hash context for
  subsequent use.

  If Sha1Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[out]  Sha1Context  Pointer to SHA-1 context being initialized.

  @retval TRUE   SHA-1 context initialization succeeded.
  @retval FALSE  SHA-1 context initialization failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Sha1Init (
  OUT  VOID  *Sha1Context
  );

/**
  Makes a copy of an existing SHA-1 context.

  If Sha1Context is NULL, then return FALSE.
  If NewSha1Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]  Sha1Context     Pointer to SHA-1 context being copied.
  @param[out] NewSha1Context  Pointer to new SHA-1 context.

  @retval TRUE   SHA-1 context copy succeeded.
  @retval FALSE  SHA-1 context copy failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Sha1Duplicate (
  IN   CONST VOID  *Sha1Context,
  OUT  VOID        *NewSha1Context
  );

/**
  Digests the input data and updates SHA-1 context.

  This function performs SHA-1 digest on a data buffer of the specified size.
  It can be called multiple times to compute the digest of long or discontinuous data streams.
  SHA-1 context should be already correctly initialized by Sha1Init(), and should not be finalized
  by Sha1Final(). Behavior with invalid context is undefined.

  If Sha1Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  Sha1Context  Pointer to the SHA-1 context.
  @param[in]       Data         Pointer to the buffer containing the data to be hashed.
  @param[in]       DataSize     Size of Data buffer in bytes.

  @retval TRUE   SHA-1 data digest succeeded.
  @retval FALSE  SHA-1 data digest failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Sha1Update (
  IN OUT  VOID        *Sha1Context,
  IN      CONST VOID  *Data,
  IN      UINTN       DataSize
  );

/**
  Completes computation of the SHA-1 digest value.

  This function completes SHA-1 hash computation and retrieves the digest value into
  the specified memory. After this function has been called, the SHA-1 context cannot
  be used again.
  SHA-1 context should be already correctly initialized by Sha1Init(), and should not be
  finalized by Sha1Final(). Behavior with invalid SHA-1 context is undefined.

  If Sha1Context is NULL, then return FALSE.
  If HashValue is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  Sha1Context  Pointer to the SHA-1 context.
  @param[out]      HashValue    Pointer to a buffer that receives the SHA-1 digest
                                value (20 bytes).

  @retval TRUE   SHA-1 digest computation succeeded.
  @retval FALSE  SHA-1 digest computation failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Sha1Final (
  IN OUT  VOID   *Sha1Context,
  OUT     UINT8  *HashValue
  );

/**
  Computes the SHA-1 message digest of a input data buffer.

  This function performs the SHA-1 message digest of a given data buffer, and places
  the digest value into the specified memory.

  If this interface is not supported, then return FALSE.

  @param[in]   Data        Pointer to the buffer containing the data to be hashed.
  @param[in]   DataSize    Size of Data buffer in bytes.
  @param[out]  HashValue   Pointer to a buffer that receives the SHA-1 digest
                           value (20 bytes).

  @retval TRUE   SHA-1 digest computation succeeded.
  @retval FALSE  SHA-1 digest computation failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Sha1HashAll (
  IN   CONST VOID  *Data,
  IN   UINTN       DataSize,
  OUT  UINT8       *HashValue
  );

/**
  Retrieves the size, in bytes, of the context buffer required for SHA-256 hash operations.

  @return  The size, in bytes, of the context buffer required for SHA-256 hash operations.

**/
UINTN
EFIAPI
Sha256GetContextSize (
  VOID
  );

/**
  Initializes user-supplied memory pointed by Sha256Context as SHA-256 hash context for
  subsequent use.

  If Sha256Context is NULL, then return FALSE.

  @param[out]  Sha256Context  Pointer to SHA-256 context being initialized.

  @retval TRUE   SHA-256 context initialization succeeded.
  @retval FALSE  SHA-256 context initialization failed.

**/
BOOLEAN
EFIAPI
Sha256Init (
  OUT  VOID  *Sha256Context
  );

/**
  Makes a copy of an existing SHA-256 context.

  If Sha256Context is NULL, then return FALSE.
  If NewSha256Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]  Sha256Context     Pointer to SHA-256 context being copied.
  @param[out] NewSha256Context  Pointer to new SHA-256 context.

  @retval TRUE   SHA-256 context copy succeeded.
  @retval FALSE  SHA-256 context copy failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Sha256Duplicate (
  IN   CONST VOID  *Sha256Context,
  OUT  VOID        *NewSha256Context
  );

/**
  Digests the input data and updates SHA-256 context.

  This function performs SHA-256 digest on a data buffer of the specified size.
  It can be called multiple times to compute the digest of long or discontinuous data streams.
  SHA-256 context should be already correctly initialized by Sha256Init(), and should not be finalized
  by Sha256Final(). Behavior with invalid context is undefined.

  If Sha256Context is NULL, then return FALSE.

  @param[in, out]  Sha256Context  Pointer to the SHA-256 context.
  @param[in]       Data           Pointer to the buffer containing the data to be hashed.
  @param[in]       DataSize       Size of Data buffer in bytes.

  @retval TRUE   SHA-256 data digest succeeded.
  @retval FALSE  SHA-256 data digest failed.

**/
BOOLEAN
EFIAPI
Sha256Update (
  IN OUT  VOID        *Sha256Context,
  IN      CONST VOID  *Data,
  IN      UINTN       DataSize
  );

/**
  Completes computation of the SHA-256 digest value.

  This function completes SHA-256 hash computation and retrieves the digest value into
  the specified memory. After this function has been called, the SHA-256 context cannot
  be used again.
  SHA-256 context should be already correctly initialized by Sha256Init(), and should not be
  finalized by Sha256Final(). Behavior with invalid SHA-256 context is undefined.

  If Sha256Context is NULL, then return FALSE.
  If HashValue is NULL, then return FALSE.

  @param[in, out]  Sha256Context  Pointer to the SHA-256 context.
  @param[out]      HashValue      Pointer to a buffer that receives the SHA-256 digest
                                  value (32 bytes).

  @retval TRUE   SHA-256 digest computation succeeded.
  @retval FALSE  SHA-256 digest computation failed.

**/
BOOLEAN
EFIAPI
Sha256Final (
  IN OUT  VOID   *Sha256Context,
  OUT     UINT8  *HashValue
  );

/**
  Computes the SHA-256 message digest of a input data buffer.

  This function performs the SHA-256 message digest of a given data buffer, and places
  the digest value into the specified memory.

  If this interface is not supported, then return FALSE.

  @param[in]   Data        Pointer to the buffer containing the data to be hashed.
  @param[in]   DataSize    Size of Data buffer in bytes.
  @param[out]  HashValue   Pointer to a buffer that receives the SHA-256 digest
                           value (32 bytes).

  @retval TRUE   SHA-256 digest computation succeeded.
  @retval FALSE  SHA-256 digest computation failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Sha256HashAll (
  IN   CONST VOID  *Data,
  IN   UINTN       DataSize,
  OUT  UINT8       *HashValue
  );

/**
  Retrieves the size, in bytes, of the context buffer required for SHA-384 hash operations.

  @return  The size, in bytes, of the context buffer required for SHA-384 hash operations.

**/
UINTN
EFIAPI
Sha384GetContextSize (
  VOID
  );

/**
  Initializes user-supplied memory pointed by Sha384Context as SHA-384 hash context for
  subsequent use.

  If Sha384Context is NULL, then return FALSE.

  @param[out]  Sha384Context  Pointer to SHA-384 context being initialized.

  @retval TRUE   SHA-384 context initialization succeeded.
  @retval FALSE  SHA-384 context initialization failed.

**/
BOOLEAN
EFIAPI
Sha384Init (
  OUT  VOID  *Sha384Context
  );

/**
  Makes a copy of an existing SHA-384 context.

  If Sha384Context is NULL, then return FALSE.
  If NewSha384Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]  Sha384Context     Pointer to SHA-384 context being copied.
  @param[out] NewSha384Context  Pointer to new SHA-384 context.

  @retval TRUE   SHA-384 context copy succeeded.
  @retval FALSE  SHA-384 context copy failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Sha384Duplicate (
  IN   CONST VOID  *Sha384Context,
  OUT  VOID        *NewSha384Context
  );

/**
  Digests the input data and updates SHA-384 context.

  This function performs SHA-384 digest on a data buffer of the specified size.
  It can be called multiple times to compute the digest of long or discontinuous data streams.
  SHA-384 context should be already correctly initialized by Sha384Init(), and should not be finalized
  by Sha384Final(). Behavior with invalid context is undefined.

  If Sha384Context is NULL, then return FALSE.

  @param[in, out]  Sha384Context  Pointer to the SHA-384 context.
  @param[in]       Data           Pointer to the buffer containing the data to be hashed.
  @param[in]       DataSize       Size of Data buffer in bytes.

  @retval TRUE   SHA-384 data digest succeeded.
  @retval FALSE  SHA-384 data digest failed.

**/
BOOLEAN
EFIAPI
Sha384Update (
  IN OUT  VOID        *Sha384Context,
  IN      CONST VOID  *Data,
  IN      UINTN       DataSize
  );

/**
  Completes computation of the SHA-384 digest value.

  This function completes SHA-384 hash computation and retrieves the digest value into
  the specified memory. After this function has been called, the SHA-384 context cannot
  be used again.
  SHA-384 context should be already correctly initialized by Sha384Init(), and should not be
  finalized by Sha384Final(). Behavior with invalid SHA-384 context is undefined.

  If Sha384Context is NULL, then return FALSE.
  If HashValue is NULL, then return FALSE.

  @param[in, out]  Sha384Context  Pointer to the SHA-384 context.
  @param[out]      HashValue      Pointer to a buffer that receives the SHA-384 digest
                                  value (48 bytes).

  @retval TRUE   SHA-384 digest computation succeeded.
  @retval FALSE  SHA-384 digest computation failed.

**/
BOOLEAN
EFIAPI
Sha384Final (
  IN OUT  VOID   *Sha384Context,
  OUT     UINT8  *HashValue
  );

/**
  Computes the SHA-384 message digest of a input data buffer.

  This function performs the SHA-384 message digest of a given data buffer, and places
  the digest value into the specified memory.

  If this interface is not supported, then return FALSE.

  @param[in]   Data        Pointer to the buffer containing the data to be hashed.
  @param[in]   DataSize    Size of Data buffer in bytes.
  @param[out]  HashValue   Pointer to a buffer that receives the SHA-384 digest
                           value (48 bytes).

  @retval TRUE   SHA-384 digest computation succeeded.
  @retval FALSE  SHA-384 digest computation failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Sha384HashAll (
  IN   CONST VOID  *Data,
  IN   UINTN       DataSize,
  OUT  UINT8       *HashValue
  );

/**
  Retrieves the size, in bytes, of the context buffer required for SHA-512 hash operations.

  @return  The size, in bytes, of the context buffer required for SHA-512 hash operations.

**/
UINTN
EFIAPI
Sha512GetContextSize (
  VOID
  );

/**
  Initializes user-supplied memory pointed by Sha512Context as SHA-512 hash context for
  subsequent use.

  If Sha512Context is NULL, then return FALSE.

  @param[out]  Sha512Context  Pointer to SHA-512 context being initialized.

  @retval TRUE   SHA-512 context initialization succeeded.
  @retval FALSE  SHA-512 context initialization failed.

**/
BOOLEAN
EFIAPI
Sha512Init (
  OUT  VOID  *Sha512Context
  );

/**
  Makes a copy of an existing SHA-512 context.

  If Sha512Context is NULL, then return FALSE.
  If NewSha512Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]  Sha512Context     Pointer to SHA-512 context being copied.
  @param[out] NewSha512Context  Pointer to new SHA-512 context.

  @retval TRUE   SHA-512 context copy succeeded.
  @retval FALSE  SHA-512 context copy failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Sha512Duplicate (
  IN   CONST VOID  *Sha512Context,
  OUT  VOID        *NewSha512Context
  );

/**
  Digests the input data and updates SHA-512 context.

  This function performs SHA-512 digest on a data buffer of the specified size.
  It can be called multiple times to compute the digest of long or discontinuous data streams.
  SHA-512 context should be already correctly initialized by Sha512Init(), and should not be finalized
  by Sha512Final(). Behavior with invalid context is undefined.

  If Sha512Context is NULL, then return FALSE.

  @param[in, out]  Sha512Context  Pointer to the SHA-512 context.
  @param[in]       Data           Pointer to the buffer containing the data to be hashed.
  @param[in]       DataSize       Size of Data buffer in bytes.

  @retval TRUE   SHA-512 data digest succeeded.
  @retval FALSE  SHA-512 data digest failed.

**/
BOOLEAN
EFIAPI
Sha512Update (
  IN OUT  VOID        *Sha512Context,
  IN      CONST VOID  *Data,
  IN      UINTN       DataSize
  );

/**
  Completes computation of the SHA-512 digest value.

  This function completes SHA-512 hash computation and retrieves the digest value into
  the specified memory. After this function has been called, the SHA-512 context cannot
  be used again.
  SHA-512 context should be already correctly initialized by Sha512Init(), and should not be
  finalized by Sha512Final(). Behavior with invalid SHA-512 context is undefined.

  If Sha512Context is NULL, then return FALSE.
  If HashValue is NULL, then return FALSE.

  @param[in, out]  Sha512Context  Pointer to the SHA-512 context.
  @param[out]      HashValue      Pointer to a buffer that receives the SHA-512 digest
                                  value (64 bytes).

  @retval TRUE   SHA-512 digest computation succeeded.
  @retval FALSE  SHA-512 digest computation failed.

**/
BOOLEAN
EFIAPI
Sha512Final (
  IN OUT  VOID   *Sha512Context,
  OUT     UINT8  *HashValue
  );

/**
  Computes the SHA-512 message digest of a input data buffer.

  This function performs the SHA-512 message digest of a given data buffer, and places
  the digest value into the specified memory.

  If this interface is not supported, then return FALSE.

  @param[in]   Data        Pointer to the buffer containing the data to be hashed.
  @param[in]   DataSize    Size of Data buffer in bytes.
  @param[out]  HashValue   Pointer to a buffer that receives the SHA-512 digest
                           value (64 bytes).

  @retval TRUE   SHA-512 digest computation succeeded.
  @retval FALSE  SHA-512 digest computation failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Sha512HashAll (
  IN   CONST VOID  *Data,
  IN   UINTN       DataSize,
  OUT  UINT8       *HashValue
  );

//=====================================================================================
//    MAC (Message Authentication Code) Primitive
//=====================================================================================

/**
  Retrieves the size, in bytes, of the context buffer required for HMAC-MD5 operations.
  (NOTE: This API is deprecated.
         Use HmacMd5New() / HmacMd5Free() for HMAC-MD5 Context operations.)

  If this interface is not supported, then return zero.

  @return  The size, in bytes, of the context buffer required for HMAC-MD5 operations.
  @retval  0   This interface is not supported.

**/
UINTN
EFIAPI
HmacMd5GetContextSize (
  VOID
  );

/**
  Allocates and initializes one HMAC_CTX context for subsequent HMAC-MD5 use.

  If this interface is not supported, then return NULL.

  @return  Pointer to the HMAC_CTX context that has been initialized.
           If the allocations fails, HmacMd5New() returns NULL.
  @retval  NULL  This interface is not supported.

**/
VOID *
EFIAPI
HmacMd5New (
  VOID
  );

/**
  Release the specified HMAC_CTX context.

  If this interface is not supported, then do nothing.

  @param[in]  HmacMd5Ctx  Pointer to the HMAC_CTX context to be released.

**/
VOID
EFIAPI
HmacMd5Free (
  IN  VOID  *HmacMd5Ctx
  );

/**
  Initializes user-supplied memory pointed by HmacMd5Context as HMAC-MD5 context for
  subsequent use.

  If HmacMd5Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[out]  HmacMd5Context  Pointer to HMAC-MD5 context being initialized.
  @param[in]   Key             Pointer to the user-supplied key.
  @param[in]   KeySize         Key size in bytes.

  @retval TRUE   HMAC-MD5 context initialization succeeded.
  @retval FALSE  HMAC-MD5 context initialization failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
HmacMd5Init (
  OUT  VOID         *HmacMd5Context,
  IN   CONST UINT8  *Key,
  IN   UINTN        KeySize
  );

/**
  Makes a copy of an existing HMAC-MD5 context.

  If HmacMd5Context is NULL, then return FALSE.
  If NewHmacMd5Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]  HmacMd5Context     Pointer to HMAC-MD5 context being copied.
  @param[out] NewHmacMd5Context  Pointer to new HMAC-MD5 context.

  @retval TRUE   HMAC-MD5 context copy succeeded.
  @retval FALSE  HMAC-MD5 context copy failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
HmacMd5Duplicate (
  IN   CONST VOID  *HmacMd5Context,
  OUT  VOID        *NewHmacMd5Context
  );

/**
  Digests the input data and updates HMAC-MD5 context.

  This function performs HMAC-MD5 digest on a data buffer of the specified size.
  It can be called multiple times to compute the digest of long or discontinuous data streams.
  HMAC-MD5 context should be already correctly initialized by HmacMd5Init(), and should not be
  finalized by HmacMd5Final(). Behavior with invalid context is undefined.

  If HmacMd5Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  HmacMd5Context  Pointer to the HMAC-MD5 context.
  @param[in]       Data            Pointer to the buffer containing the data to be digested.
  @param[in]       DataSize        Size of Data buffer in bytes.

  @retval TRUE   HMAC-MD5 data digest succeeded.
  @retval FALSE  HMAC-MD5 data digest failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
HmacMd5Update (
  IN OUT  VOID        *HmacMd5Context,
  IN      CONST VOID  *Data,
  IN      UINTN       DataSize
  );

/**
  Completes computation of the HMAC-MD5 digest value.

  This function completes HMAC-MD5 hash computation and retrieves the digest value into
  the specified memory. After this function has been called, the HMAC-MD5 context cannot
  be used again.
  HMAC-MD5 context should be already correctly initialized by HmacMd5Init(), and should not be
  finalized by HmacMd5Final(). Behavior with invalid HMAC-MD5 context is undefined.

  If HmacMd5Context is NULL, then return FALSE.
  If HmacValue is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  HmacMd5Context  Pointer to the HMAC-MD5 context.
  @param[out]      HmacValue       Pointer to a buffer that receives the HMAC-MD5 digest
                                   value (16 bytes).

  @retval TRUE   HMAC-MD5 digest computation succeeded.
  @retval FALSE  HMAC-MD5 digest computation failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
HmacMd5Final (
  IN OUT  VOID   *HmacMd5Context,
  OUT     UINT8  *HmacValue
  );

/**
  Retrieves the size, in bytes, of the context buffer required for HMAC-SHA1 operations.
  (NOTE: This API is deprecated.
         Use HmacSha1New() / HmacSha1Free() for HMAC-SHA1 Context operations.)

  If this interface is not supported, then return zero.

  @return  The size, in bytes, of the context buffer required for HMAC-SHA1 operations.
  @retval  0   This interface is not supported.

**/
UINTN
EFIAPI
HmacSha1GetContextSize (
  VOID
  );

/**
  Allocates and initializes one HMAC_CTX context for subsequent HMAC-SHA1 use.

  If this interface is not supported, then return NULL.

  @return  Pointer to the HMAC_CTX context that has been initialized.
           If the allocations fails, HmacSha1New() returns NULL.
  @return  NULL   This interface is not supported.

**/
VOID *
EFIAPI
HmacSha1New (
  VOID
  );

/**
  Release the specified HMAC_CTX context.

  If this interface is not supported, then do nothing.

  @param[in]  HmacSha1Ctx  Pointer to the HMAC_CTX context to be released.

**/
VOID
EFIAPI
HmacSha1Free (
  IN  VOID  *HmacSha1Ctx
  );

/**
  Initializes user-supplied memory pointed by HmacSha1Context as HMAC-SHA1 context for
  subsequent use.

  If HmacSha1Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[out]  HmacSha1Context  Pointer to HMAC-SHA1 context being initialized.
  @param[in]   Key              Pointer to the user-supplied key.
  @param[in]   KeySize          Key size in bytes.

  @retval TRUE   HMAC-SHA1 context initialization succeeded.
  @retval FALSE  HMAC-SHA1 context initialization failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
HmacSha1Init (
  OUT  VOID         *HmacSha1Context,
  IN   CONST UINT8  *Key,
  IN   UINTN        KeySize
  );

/**
  Makes a copy of an existing HMAC-SHA1 context.

  If HmacSha1Context is NULL, then return FALSE.
  If NewHmacSha1Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]  HmacSha1Context     Pointer to HMAC-SHA1 context being copied.
  @param[out] NewHmacSha1Context  Pointer to new HMAC-SHA1 context.

  @retval TRUE   HMAC-SHA1 context copy succeeded.
  @retval FALSE  HMAC-SHA1 context copy failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
HmacSha1Duplicate (
  IN   CONST VOID  *HmacSha1Context,
  OUT  VOID        *NewHmacSha1Context
  );

/**
  Digests the input data and updates HMAC-SHA1 context.

  This function performs HMAC-SHA1 digest on a data buffer of the specified size.
  It can be called multiple times to compute the digest of long or discontinuous data streams.
  HMAC-SHA1 context should be already correctly initialized by HmacSha1Init(), and should not
  be finalized by HmacSha1Final(). Behavior with invalid context is undefined.

  If HmacSha1Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  HmacSha1Context Pointer to the HMAC-SHA1 context.
  @param[in]       Data            Pointer to the buffer containing the data to be digested.
  @param[in]       DataSize        Size of Data buffer in bytes.

  @retval TRUE   HMAC-SHA1 data digest succeeded.
  @retval FALSE  HMAC-SHA1 data digest failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
HmacSha1Update (
  IN OUT  VOID        *HmacSha1Context,
  IN      CONST VOID  *Data,
  IN      UINTN       DataSize
  );

/**
  Completes computation of the HMAC-SHA1 digest value.

  This function completes HMAC-SHA1 hash computation and retrieves the digest value into
  the specified memory. After this function has been called, the HMAC-SHA1 context cannot
  be used again.
  HMAC-SHA1 context should be already correctly initialized by HmacSha1Init(), and should
  not be finalized by HmacSha1Final(). Behavior with invalid HMAC-SHA1 context is undefined.

  If HmacSha1Context is NULL, then return FALSE.
  If HmacValue is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  HmacSha1Context  Pointer to the HMAC-SHA1 context.
  @param[out]      HmacValue        Pointer to a buffer that receives the HMAC-SHA1 digest
                                    value (20 bytes).

  @retval TRUE   HMAC-SHA1 digest computation succeeded.
  @retval FALSE  HMAC-SHA1 digest computation failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
HmacSha1Final (
  IN OUT  VOID   *HmacSha1Context,
  OUT     UINT8  *HmacValue
  );

/**
  Retrieves the size, in bytes, of the context buffer required for HMAC-SHA256 operations.
  (NOTE: This API is deprecated.
         Use HmacSha256New() / HmacSha256Free() for HMAC-SHA256 Context operations.)

  If this interface is not supported, then return zero.

  @return  The size, in bytes, of the context buffer required for HMAC-SHA256 operations.
  @retval  0   This interface is not supported.

**/
UINTN
EFIAPI
HmacSha256GetContextSize (
  VOID
  );

/**
  Allocates and initializes one HMAC_CTX context for subsequent HMAC-SHA256 use.

  @return  Pointer to the HMAC_CTX context that has been initialized.
           If the allocations fails, HmacSha256New() returns NULL.

**/
VOID *
EFIAPI
HmacSha256New (
  VOID
  );

/**
  Release the specified HMAC_CTX context.

  @param[in]  HmacSha256Ctx  Pointer to the HMAC_CTX context to be released.

**/
VOID
EFIAPI
HmacSha256Free (
  IN  VOID  *HmacSha256Ctx
  );

/**
  Initializes user-supplied memory pointed by HmacSha256Context as HMAC-SHA256 context for
  subsequent use.

  If HmacSha256Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[out]  HmacSha256Context  Pointer to HMAC-SHA256 context being initialized.
  @param[in]   Key                Pointer to the user-supplied key.
  @param[in]   KeySize            Key size in bytes.

  @retval TRUE   HMAC-SHA256 context initialization succeeded.
  @retval FALSE  HMAC-SHA256 context initialization failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
HmacSha256Init (
  OUT  VOID         *HmacSha256Context,
  IN   CONST UINT8  *Key,
  IN   UINTN        KeySize
  );

/**
  Makes a copy of an existing HMAC-SHA256 context.

  If HmacSha256Context is NULL, then return FALSE.
  If NewHmacSha256Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]  HmacSha256Context     Pointer to HMAC-SHA256 context being copied.
  @param[out] NewHmacSha256Context  Pointer to new HMAC-SHA256 context.

  @retval TRUE   HMAC-SHA256 context copy succeeded.
  @retval FALSE  HMAC-SHA256 context copy failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
HmacSha256Duplicate (
  IN   CONST VOID  *HmacSha256Context,
  OUT  VOID        *NewHmacSha256Context
  );

/**
  Digests the input data and updates HMAC-SHA256 context.

  This function performs HMAC-SHA256 digest on a data buffer of the specified size.
  It can be called multiple times to compute the digest of long or discontinuous data streams.
  HMAC-SHA256 context should be already correctly initialized by HmacSha256Init(), and should not
  be finalized by HmacSha256Final(). Behavior with invalid context is undefined.

  If HmacSha256Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  HmacSha256Context Pointer to the HMAC-SHA256 context.
  @param[in]       Data              Pointer to the buffer containing the data to be digested.
  @param[in]       DataSize          Size of Data buffer in bytes.

  @retval TRUE   HMAC-SHA256 data digest succeeded.
  @retval FALSE  HMAC-SHA256 data digest failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
HmacSha256Update (
  IN OUT  VOID        *HmacSha256Context,
  IN      CONST VOID  *Data,
  IN      UINTN       DataSize
  );

/**
  Completes computation of the HMAC-SHA256 digest value.

  This function completes HMAC-SHA256 hash computation and retrieves the digest value into
  the specified memory. After this function has been called, the HMAC-SHA256 context cannot
  be used again.
  HMAC-SHA256 context should be already correctly initialized by HmacSha256Init(), and should
  not be finalized by HmacSha256Final(). Behavior with invalid HMAC-SHA256 context is undefined.

  If HmacSha256Context is NULL, then return FALSE.
  If HmacValue is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  HmacSha256Context  Pointer to the HMAC-SHA256 context.
  @param[out]      HmacValue          Pointer to a buffer that receives the HMAC-SHA256 digest
                                      value (32 bytes).

  @retval TRUE   HMAC-SHA256 digest computation succeeded.
  @retval FALSE  HMAC-SHA256 digest computation failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
HmacSha256Final (
  IN OUT  VOID   *HmacSha256Context,
  OUT     UINT8  *HmacValue
  );

//=====================================================================================
//    Symmetric Cryptography Primitive
//=====================================================================================

/**
  Retrieves the size, in bytes, of the context buffer required for TDES operations.

  If this interface is not supported, then return zero.

  @return  The size, in bytes, of the context buffer required for TDES operations.
  @retval  0   This interface is not supported.

**/
UINTN
EFIAPI
TdesGetContextSize (
  VOID
  );

/**
  Initializes user-supplied memory as TDES context for subsequent use.

  This function initializes user-supplied memory pointed by TdesContext as TDES context.
  In addition, it sets up all TDES key materials for subsequent encryption and decryption
  operations.
  There are 3 key options as follows:
  KeyLength = 64,  Keying option 1: K1 == K2 == K3 (Backward compatibility with DES)
  KeyLength = 128, Keying option 2: K1 != K2 and K3 = K1 (Less Security)
  KeyLength = 192  Keying option 3: K1 != K2 != K3 (Strongest)

  If TdesContext is NULL, then return FALSE.
  If Key is NULL, then return FALSE.
  If KeyLength is not valid, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[out]  TdesContext  Pointer to TDES context being initialized.
  @param[in]   Key          Pointer to the user-supplied TDES key.
  @param[in]   KeyLength    Length of TDES key in bits.

  @retval TRUE   TDES context initialization succeeded.
  @retval FALSE  TDES context initialization failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
TdesInit (
  OUT  VOID         *TdesContext,
  IN   CONST UINT8  *Key,
  IN   UINTN        KeyLength
  );

/**
  Performs TDES encryption on a data buffer of the specified size in ECB mode.

  This function performs TDES encryption on data buffer pointed by Input, of specified
  size of InputSize, in ECB mode.
  InputSize must be multiple of block size (8 bytes). This function does not perform
  padding. Caller must perform padding, if necessary, to ensure valid input data size.
  TdesContext should be already correctly initialized by TdesInit(). Behavior with
  invalid TDES context is undefined.

  If TdesContext is NULL, then return FALSE.
  If Input is NULL, then return FALSE.
  If InputSize is not multiple of block size (8 bytes), then return FALSE.
  If Output is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]   TdesContext  Pointer to the TDES context.
  @param[in]   Input        Pointer to the buffer containing the data to be encrypted.
  @param[in]   InputSize    Size of the Input buffer in bytes.
  @param[out]  Output       Pointer to a buffer that receives the TDES encryption output.

  @retval TRUE   TDES encryption succeeded.
  @retval FALSE  TDES encryption failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
TdesEcbEncrypt (
  IN   VOID         *TdesContext,
  IN   CONST UINT8  *Input,
  IN   UINTN        InputSize,
  OUT  UINT8        *Output
  );

/**
  Performs TDES decryption on a data buffer of the specified size in ECB mode.

  This function performs TDES decryption on data buffer pointed by Input, of specified
  size of InputSize, in ECB mode.
  InputSize must be multiple of block size (8 bytes). This function does not perform
  padding. Caller must perform padding, if necessary, to ensure valid input data size.
  TdesContext should be already correctly initialized by TdesInit(). Behavior with
  invalid TDES context is undefined.

  If TdesContext is NULL, then return FALSE.
  If Input is NULL, then return FALSE.
  If InputSize is not multiple of block size (8 bytes), then return FALSE.
  If Output is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]   TdesContext  Pointer to the TDES context.
  @param[in]   Input        Pointer to the buffer containing the data to be decrypted.
  @param[in]   InputSize    Size of the Input buffer in bytes.
  @param[out]  Output       Pointer to a buffer that receives the TDES decryption output.

  @retval TRUE   TDES decryption succeeded.
  @retval FALSE  TDES decryption failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
TdesEcbDecrypt (
  IN   VOID         *TdesContext,
  IN   CONST UINT8  *Input,
  IN   UINTN        InputSize,
  OUT  UINT8        *Output
  );

/**
  Performs TDES encryption on a data buffer of the specified size in CBC mode.

  This function performs TDES encryption on data buffer pointed by Input, of specified
  size of InputSize, in CBC mode.
  InputSize must be multiple of block size (8 bytes). This function does not perform
  padding. Caller must perform padding, if necessary, to ensure valid input data size.
  Initialization vector should be one block size (8 bytes).
  TdesContext should be already correctly initialized by TdesInit(). Behavior with
  invalid TDES context is undefined.

  If TdesContext is NULL, then return FALSE.
  If Input is NULL, then return FALSE.
  If InputSize is not multiple of block size (8 bytes), then return FALSE.
  If Ivec is NULL, then return FALSE.
  If Output is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]   TdesContext  Pointer to the TDES context.
  @param[in]   Input        Pointer to the buffer containing the data to be encrypted.
  @param[in]   InputSize    Size of the Input buffer in bytes.
  @param[in]   Ivec         Pointer to initialization vector.
  @param[out]  Output       Pointer to a buffer that receives the TDES encryption output.

  @retval TRUE   TDES encryption succeeded.
  @retval FALSE  TDES encryption failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
TdesCbcEncrypt (
  IN   VOID         *TdesContext,
  IN   CONST UINT8  *Input,
  IN   UINTN        InputSize,
  IN   CONST UINT8  *Ivec,
  OUT  UINT8        *Output
  );

/**
  Performs TDES decryption on a data buffer of the specified size in CBC mode.

  This function performs TDES decryption on data buffer pointed by Input, of specified
  size of InputSize, in CBC mode.
  InputSize must be multiple of block size (8 bytes). This function does not perform
  padding. Caller must perform padding, if necessary, to ensure valid input data size.
  Initialization vector should be one block size (8 bytes).
  TdesContext should be already correctly initialized by TdesInit(). Behavior with
  invalid TDES context is undefined.

  If TdesContext is NULL, then return FALSE.
  If Input is NULL, then return FALSE.
  If InputSize is not multiple of block size (8 bytes), then return FALSE.
  If Ivec is NULL, then return FALSE.
  If Output is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]   TdesContext  Pointer to the TDES context.
  @param[in]   Input        Pointer to the buffer containing the data to be encrypted.
  @param[in]   InputSize    Size of the Input buffer in bytes.
  @param[in]   Ivec         Pointer to initialization vector.
  @param[out]  Output       Pointer to a buffer that receives the TDES encryption output.

  @retval TRUE   TDES decryption succeeded.
  @retval FALSE  TDES decryption failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
TdesCbcDecrypt (
  IN   VOID         *TdesContext,
  IN   CONST UINT8  *Input,
  IN   UINTN        InputSize,
  IN   CONST UINT8  *Ivec,
  OUT  UINT8        *Output
  );

/**
  Retrieves the size, in bytes, of the context buffer required for AES operations.

  If this interface is not supported, then return zero.

  @return  The size, in bytes, of the context buffer required for AES operations.
  @retval  0   This interface is not supported.

**/
UINTN
EFIAPI
AesGetContextSize (
  VOID
  );

/**
  Initializes user-supplied memory as AES context for subsequent use.

  This function initializes user-supplied memory pointed by AesContext as AES context.
  In addition, it sets up all AES key materials for subsequent encryption and decryption
  operations.
  There are 3 options for key length, 128 bits, 192 bits, and 256 bits.

  If AesContext is NULL, then return FALSE.
  If Key is NULL, then return FALSE.
  If KeyLength is not valid, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[out]  AesContext  Pointer to AES context being initialized.
  @param[in]   Key         Pointer to the user-supplied AES key.
  @param[in]   KeyLength   Length of AES key in bits.

  @retval TRUE   AES context initialization succeeded.
  @retval FALSE  AES context initialization failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
AesInit (
  OUT  VOID         *AesContext,
  IN   CONST UINT8  *Key,
  IN   UINTN        KeyLength
  );

/**
  Performs AES encryption on a data buffer of the specified size in ECB mode.

  This function performs AES encryption on data buffer pointed by Input, of specified
  size of InputSize, in ECB mode.
  InputSize must be multiple of block size (16 bytes). This function does not perform
  padding. Caller must perform padding, if necessary, to ensure valid input data size.
  AesContext should be already correctly initialized by AesInit(). Behavior with
  invalid AES context is undefined.

  If AesContext is NULL, then return FALSE.
  If Input is NULL, then return FALSE.
  If InputSize is not multiple of block size (16 bytes), then return FALSE.
  If Output is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]   AesContext  Pointer to the AES context.
  @param[in]   Input       Pointer to the buffer containing the data to be encrypted.
  @param[in]   InputSize   Size of the Input buffer in bytes.
  @param[out]  Output      Pointer to a buffer that receives the AES encryption output.

  @retval TRUE   AES encryption succeeded.
  @retval FALSE  AES encryption failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
AesEcbEncrypt (
  IN   VOID         *AesContext,
  IN   CONST UINT8  *Input,
  IN   UINTN        InputSize,
  OUT  UINT8        *Output
  );

/**
  Performs AES decryption on a data buffer of the specified size in ECB mode.

  This function performs AES decryption on data buffer pointed by Input, of specified
  size of InputSize, in ECB mode.
  InputSize must be multiple of block size (16 bytes). This function does not perform
  padding. Caller must perform padding, if necessary, to ensure valid input data size.
  AesContext should be already correctly initialized by AesInit(). Behavior with
  invalid AES context is undefined.

  If AesContext is NULL, then return FALSE.
  If Input is NULL, then return FALSE.
  If InputSize is not multiple of block size (16 bytes), then return FALSE.
  If Output is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]   AesContext  Pointer to the AES context.
  @param[in]   Input       Pointer to the buffer containing the data to be decrypted.
  @param[in]   InputSize   Size of the Input buffer in bytes.
  @param[out]  Output      Pointer to a buffer that receives the AES decryption output.

  @retval TRUE   AES decryption succeeded.
  @retval FALSE  AES decryption failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
AesEcbDecrypt (
  IN   VOID         *AesContext,
  IN   CONST UINT8  *Input,
  IN   UINTN        InputSize,
  OUT  UINT8        *Output
  );

/**
  Performs AES encryption on a data buffer of the specified size in CBC mode.

  This function performs AES encryption on data buffer pointed by Input, of specified
  size of InputSize, in CBC mode.
  InputSize must be multiple of block size (16 bytes). This function does not perform
  padding. Caller must perform padding, if necessary, to ensure valid input data size.
  Initialization vector should be one block size (16 bytes).
  AesContext should be already correctly initialized by AesInit(). Behavior with
  invalid AES context is undefined.

  If AesContext is NULL, then return FALSE.
  If Input is NULL, then return FALSE.
  If InputSize is not multiple of block size (16 bytes), then return FALSE.
  If Ivec is NULL, then return FALSE.
  If Output is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]   AesContext  Pointer to the AES context.
  @param[in]   Input       Pointer to the buffer containing the data to be encrypted.
  @param[in]   InputSize   Size of the Input buffer in bytes.
  @param[in]   Ivec        Pointer to initialization vector.
  @param[out]  Output      Pointer to a buffer that receives the AES encryption output.

  @retval TRUE   AES encryption succeeded.
  @retval FALSE  AES encryption failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
AesCbcEncrypt (
  IN   VOID         *AesContext,
  IN   CONST UINT8  *Input,
  IN   UINTN        InputSize,
  IN   CONST UINT8  *Ivec,
  OUT  UINT8        *Output
  );

/**
  Performs AES decryption on a data buffer of the specified size in CBC mode.

  This function performs AES decryption on data buffer pointed by Input, of specified
  size of InputSize, in CBC mode.
  InputSize must be multiple of block size (16 bytes). This function does not perform
  padding. Caller must perform padding, if necessary, to ensure valid input data size.
  Initialization vector should be one block size (16 bytes).
  AesContext should be already correctly initialized by AesInit(). Behavior with
  invalid AES context is undefined.

  If AesContext is NULL, then return FALSE.
  If Input is NULL, then return FALSE.
  If InputSize is not multiple of block size (16 bytes), then return FALSE.
  If Ivec is NULL, then return FALSE.
  If Output is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]   AesContext  Pointer to the AES context.
  @param[in]   Input       Pointer to the buffer containing the data to be encrypted.
  @param[in]   InputSize   Size of the Input buffer in bytes.
  @param[in]   Ivec        Pointer to initialization vector.
  @param[out]  Output      Pointer to a buffer that receives the AES encryption output.

  @retval TRUE   AES decryption succeeded.
  @retval FALSE  AES decryption failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
AesCbcDecrypt (
  IN   VOID         *AesContext,
  IN   CONST UINT8  *Input,
  IN   UINTN        InputSize,
  IN   CONST UINT8  *Ivec,
  OUT  UINT8        *Output
  );

/**
  Retrieves the size, in bytes, of the context buffer required for ARC4 operations.

  If this interface is not supported, then return zero.

  @return  The size, in bytes, of the context buffer required for ARC4 operations.
  @retval  0   This interface is not supported.

**/
UINTN
EFIAPI
Arc4GetContextSize (
  VOID
  );

/**
  Initializes user-supplied memory as ARC4 context for subsequent use.

  This function initializes user-supplied memory pointed by Arc4Context as ARC4 context.
  In addition, it sets up all ARC4 key materials for subsequent encryption and decryption
  operations.

  If Arc4Context is NULL, then return FALSE.
  If Key is NULL, then return FALSE.
  If KeySize does not in the range of [5, 256] bytes, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[out]  Arc4Context  Pointer to ARC4 context being initialized.
  @param[in]   Key          Pointer to the user-supplied ARC4 key.
  @param[in]   KeySize      Size of ARC4 key in bytes.

  @retval TRUE   ARC4 context initialization succeeded.
  @retval FALSE  ARC4 context initialization failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Arc4Init (
  OUT  VOID         *Arc4Context,
  IN   CONST UINT8  *Key,
  IN   UINTN        KeySize
  );

/**
  Performs ARC4 encryption on a data buffer of the specified size.

  This function performs ARC4 encryption on data buffer pointed by Input, of specified
  size of InputSize.
  Arc4Context should be already correctly initialized by Arc4Init(). Behavior with
  invalid ARC4 context is undefined.

  If Arc4Context is NULL, then return FALSE.
  If Input is NULL, then return FALSE.
  If Output is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  Arc4Context  Pointer to the ARC4 context.
  @param[in]       Input        Pointer to the buffer containing the data to be encrypted.
  @param[in]       InputSize    Size of the Input buffer in bytes.
  @param[out]      Output       Pointer to a buffer that receives the ARC4 encryption output.

  @retval TRUE   ARC4 encryption succeeded.
  @retval FALSE  ARC4 encryption failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Arc4Encrypt (
  IN OUT  VOID         *Arc4Context,
  IN      CONST UINT8  *Input,
  IN      UINTN        InputSize,
  OUT     UINT8        *Output
  );

/**
  Performs ARC4 decryption on a data buffer of the specified size.

  This function performs ARC4 decryption on data buffer pointed by Input, of specified
  size of InputSize.
  Arc4Context should be already correctly initialized by Arc4Init(). Behavior with
  invalid ARC4 context is undefined.

  If Arc4Context is NULL, then return FALSE.
  If Input is NULL, then return FALSE.
  If Output is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  Arc4Context  Pointer to the ARC4 context.
  @param[in]       Input        Pointer to the buffer containing the data to be decrypted.
  @param[in]       InputSize    Size of the Input buffer in bytes.
  @param[out]      Output       Pointer to a buffer that receives the ARC4 decryption output.

  @retval TRUE   ARC4 decryption succeeded.
  @retval FALSE  ARC4 decryption failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Arc4Decrypt (
  IN OUT  VOID   *Arc4Context,
  IN      UINT8  *Input,
  IN      UINTN  InputSize,
  OUT     UINT8  *Output
  );

/**
  Resets the ARC4 context to the initial state.

  The function resets the ARC4 context to the state it had immediately after the
  ARC4Init() function call.
  Contrary to ARC4Init(), Arc4Reset() requires no secret key as input, but ARC4 context
  should be already correctly initialized by ARC4Init().

  If Arc4Context is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  Arc4Context  Pointer to the ARC4 context.

  @retval TRUE   ARC4 reset succeeded.
  @retval FALSE  ARC4 reset failed.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Arc4Reset (
  IN OUT  VOID  *Arc4Context
  );

//=====================================================================================
//    Asymmetric Cryptography Primitive
//=====================================================================================

/**
  Allocates and initializes one RSA context for subsequent use.

  @return  Pointer to the RSA context that has been initialized.
           If the allocations fails, RsaNew() returns NULL.

**/
VOID *
EFIAPI
RsaNew (
  VOID
  );

/**
  Release the specified RSA context.

  If RsaContext is NULL, then return FALSE.

  @param[in]  RsaContext  Pointer to the RSA context to be released.

**/
VOID
EFIAPI
RsaFree (
  IN  VOID  *RsaContext
  );

/**
  Sets the tag-designated key component into the established RSA context.

  This function sets the tag-designated RSA key component into the established
  RSA context from the user-specified non-negative integer (octet string format
  represented in RSA PKCS#1).
  If BigNumber is NULL, then the specified key component in RSA context is cleared.

  If RsaContext is NULL, then return FALSE.

  @param[in, out]  RsaContext  Pointer to RSA context being set.
  @param[in]       KeyTag      Tag of RSA key component being set.
  @param[in]       BigNumber   Pointer to octet integer buffer.
                               If NULL, then the specified key component in RSA
                               context is cleared.
  @param[in]       BnSize      Size of big number buffer in bytes.
                               If BigNumber is NULL, then it is ignored.

  @retval  TRUE   RSA key component was set successfully.
  @retval  FALSE  Invalid RSA key component tag.

**/
BOOLEAN
EFIAPI
RsaSetKey (
  IN OUT  VOID         *RsaContext,
  IN      RSA_KEY_TAG  KeyTag,
  IN      CONST UINT8  *BigNumber,
  IN      UINTN        BnSize
  );

/**
  Gets the tag-designated RSA key component from the established RSA context.

  This function retrieves the tag-designated RSA key component from the
  established RSA context as a non-negative integer (octet string format
  represented in RSA PKCS#1).
  If specified key component has not been set or has been cleared, then returned
  BnSize is set to 0.
  If the BigNumber buffer is too small to hold the contents of the key, FALSE
  is returned and BnSize is set to the required buffer size to obtain the key.

  If RsaContext is NULL, then return FALSE.
  If BnSize is NULL, then return FALSE.
  If BnSize is large enough but BigNumber is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  RsaContext  Pointer to RSA context being set.
  @param[in]       KeyTag      Tag of RSA key component being set.
  @param[out]      BigNumber   Pointer to octet integer buffer.
  @param[in, out]  BnSize      On input, the size of big number buffer in bytes.
                               On output, the size of data returned in big number buffer in bytes.

  @retval  TRUE   RSA key component was retrieved successfully.
  @retval  FALSE  Invalid RSA key component tag.
  @retval  FALSE  BnSize is too small.
  @retval  FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
RsaGetKey (
  IN OUT  VOID         *RsaContext,
  IN      RSA_KEY_TAG  KeyTag,
  OUT     UINT8        *BigNumber,
  IN OUT  UINTN        *BnSize
  );

/**
  Generates RSA key components.

  This function generates RSA key components. It takes RSA public exponent E and
  length in bits of RSA modulus N as input, and generates all key components.
  If PublicExponent is NULL, the default RSA public exponent (0x10001) will be used.

  Before this function can be invoked, pseudorandom number generator must be correctly
  initialized by RandomSeed().

  If RsaContext is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  RsaContext           Pointer to RSA context being set.
  @param[in]       ModulusLength        Length of RSA modulus N in bits.
  @param[in]       PublicExponent       Pointer to RSA public exponent.
  @param[in]       PublicExponentSize   Size of RSA public exponent buffer in bytes.

  @retval  TRUE   RSA key component was generated successfully.
  @retval  FALSE  Invalid RSA key component tag.
  @retval  FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
RsaGenerateKey (
  IN OUT  VOID         *RsaContext,
  IN      UINTN        ModulusLength,
  IN      CONST UINT8  *PublicExponent,
  IN      UINTN        PublicExponentSize
  );

/**
  Validates key components of RSA context.
  NOTE: This function performs integrity checks on all the RSA key material, so
        the RSA key structure must contain all the private key data.

  This function validates key components of RSA context in following aspects:
  - Whether p is a prime
  - Whether q is a prime
  - Whether n = p * q
  - Whether d*e = 1  mod lcm(p-1,q-1)

  If RsaContext is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]  RsaContext  Pointer to RSA context to check.

  @retval  TRUE   RSA key components are valid.
  @retval  FALSE  RSA key components are not valid.
  @retval  FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
RsaCheckKey (
  IN  VOID  *RsaContext
  );

/**
  Carries out the RSA-SSA signature generation with EMSA-PKCS1-v1_5 encoding scheme.

  This function carries out the RSA-SSA signature generation with EMSA-PKCS1-v1_5 encoding scheme defined in
  RSA PKCS#1.
  If the Signature buffer is too small to hold the contents of signature, FALSE
  is returned and SigSize is set to the required buffer size to obtain the signature.

  If RsaContext is NULL, then return FALSE.
  If MessageHash is NULL, then return FALSE.
  If HashSize is not equal to the size of MD5, SHA-1 or SHA-256 digest, then return FALSE.
  If SigSize is large enough but Signature is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]      RsaContext   Pointer to RSA context for signature generation.
  @param[in]      MessageHash  Pointer to octet message hash to be signed.
  @param[in]      HashSize     Size of the message hash in bytes.
  @param[out]     Signature    Pointer to buffer to receive RSA PKCS1-v1_5 signature.
  @param[in, out] SigSize      On input, the size of Signature buffer in bytes.
                               On output, the size of data returned in Signature buffer in bytes.

  @retval  TRUE   Signature successfully generated in PKCS1-v1_5.
  @retval  FALSE  Signature generation failed.
  @retval  FALSE  SigSize is too small.
  @retval  FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
RsaPkcs1Sign (
  IN      VOID         *RsaContext,
  IN      CONST UINT8  *MessageHash,
  IN      UINTN        HashSize,
  OUT     UINT8        *Signature,
  IN OUT  UINTN        *SigSize
  );

/**
  Verifies the RSA-SSA signature with EMSA-PKCS1-v1_5 encoding scheme defined in
  RSA PKCS#1.

  If RsaContext is NULL, then return FALSE.
  If MessageHash is NULL, then return FALSE.
  If Signature is NULL, then return FALSE.
  If HashSize is not equal to the size of MD5, SHA-1, SHA-256 digest, then return FALSE.

  @param[in]  RsaContext   Pointer to RSA context for signature verification.
  @param[in]  MessageHash  Pointer to octet message hash to be checked.
  @param[in]  HashSize     Size of the message hash in bytes.
  @param[in]  Signature    Pointer to RSA PKCS1-v1_5 signature to be verified.
  @param[in]  SigSize      Size of signature in bytes.

  @retval  TRUE   Valid signature encoded in PKCS1-v1_5.
  @retval  FALSE  Invalid signature or invalid RSA context.

**/
BOOLEAN
EFIAPI
RsaPkcs1Verify (
  IN  VOID         *RsaContext,
  IN  CONST UINT8  *MessageHash,
  IN  UINTN        HashSize,
  IN  CONST UINT8  *Signature,
  IN  UINTN        SigSize
  );

/**
  Retrieve the RSA Private Key from the password-protected PEM key data.

  If PemData is NULL, then return FALSE.
  If RsaContext is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]  PemData      Pointer to the PEM-encoded key data to be retrieved.
  @param[in]  PemSize      Size of the PEM key data in bytes.
  @param[in]  Password     NULL-terminated passphrase used for encrypted PEM key data.
  @param[out] RsaContext   Pointer to new-generated RSA context which contain the retrieved
                           RSA private key component. Use RsaFree() function to free the
                           resource.

  @retval  TRUE   RSA Private Key was retrieved successfully.
  @retval  FALSE  Invalid PEM key data or incorrect password.
  @retval  FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
RsaGetPrivateKeyFromPem (
  IN   CONST UINT8  *PemData,
  IN   UINTN        PemSize,
  IN   CONST CHAR8  *Password,
  OUT  VOID         **RsaContext
  );

/**
  Retrieve the RSA Public Key from one DER-encoded X509 certificate.

  If Cert is NULL, then return FALSE.
  If RsaContext is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]  Cert         Pointer to the DER-encoded X509 certificate.
  @param[in]  CertSize     Size of the X509 certificate in bytes.
  @param[out] RsaContext   Pointer to new-generated RSA context which contain the retrieved
                           RSA public key component. Use RsaFree() function to free the
                           resource.

  @retval  TRUE   RSA Public Key was retrieved successfully.
  @retval  FALSE  Fail to retrieve RSA public key from X509 certificate.
  @retval  FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
RsaGetPublicKeyFromX509 (
  IN   CONST UINT8  *Cert,
  IN   UINTN        CertSize,
  OUT  VOID         **RsaContext
  );

/**
  Retrieve the subject bytes from one X.509 certificate.

  If Cert is NULL, then return FALSE.
  If SubjectSize is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]      Cert         Pointer to the DER-encoded X509 certificate.
  @param[in]      CertSize     Size of the X509 certificate in bytes.
  @param[out]     CertSubject  Pointer to the retrieved certificate subject bytes.
  @param[in, out] SubjectSize  The size in bytes of the CertSubject buffer on input,
                               and the size of buffer returned CertSubject on output.

  @retval  TRUE   The certificate subject retrieved successfully.
  @retval  FALSE  Invalid certificate, or the SubjectSize is too small for the result.
                  The SubjectSize will be updated with the required size.
  @retval  FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
X509GetSubjectName (
  IN      CONST UINT8  *Cert,
  IN      UINTN        CertSize,
  OUT     UINT8        *CertSubject,
  IN OUT  UINTN        *SubjectSize
  );

/**
  Retrieve the common name (CN) string from one X.509 certificate.

  @param[in]      Cert             Pointer to the DER-encoded X509 certificate.
  @param[in]      CertSize         Size of the X509 certificate in bytes.
  @param[out]     CommonName       Buffer to contain the retrieved certificate common
                                   name string (UTF8). At most CommonNameSize bytes will be
                                   written and the string will be null terminated. May be
                                   NULL in order to determine the size buffer needed.
  @param[in,out]  CommonNameSize   The size in bytes of the CommonName buffer on input,
                                   and the size of buffer returned CommonName on output.
                                   If CommonName is NULL then the amount of space needed
                                   in buffer (including the final null) is returned.

  @retval RETURN_SUCCESS           The certificate CommonName retrieved successfully.
  @retval RETURN_INVALID_PARAMETER If Cert is NULL.
                                   If CommonNameSize is NULL.
                                   If CommonName is not NULL and *CommonNameSize is 0.
                                   If Certificate is invalid.
  @retval RETURN_NOT_FOUND         If no CommonName entry exists.
  @retval RETURN_BUFFER_TOO_SMALL  If the CommonName is NULL. The required buffer size
                                   (including the final null) is returned in the
                                   CommonNameSize parameter.
  @retval RETURN_UNSUPPORTED       The operation is not supported.

**/
RETURN_STATUS
EFIAPI
X509GetCommonName (
  IN      CONST UINT8  *Cert,
  IN      UINTN        CertSize,
  OUT     CHAR8        *CommonName,  OPTIONAL
  IN OUT  UINTN        *CommonNameSize
  );

/**
  Verify one X509 certificate was issued by the trusted CA.

  If Cert is NULL, then return FALSE.
  If CACert is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]      Cert         Pointer to the DER-encoded X509 certificate to be verified.
  @param[in]      CertSize     Size of the X509 certificate in bytes.
  @param[in]      CACert       Pointer to the DER-encoded trusted CA certificate.
  @param[in]      CACertSize   Size of the CA Certificate in bytes.

  @retval  TRUE   The certificate was issued by the trusted CA.
  @retval  FALSE  Invalid certificate or the certificate was not issued by the given
                  trusted CA.
  @retval  FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
X509VerifyCert (
  IN  CONST UINT8  *Cert,
  IN  UINTN        CertSize,
  IN  CONST UINT8  *CACert,
  IN  UINTN        CACertSize
  );

/**
  Construct a X509 object from DER-encoded certificate data.

  If Cert is NULL, then return FALSE.
  If SingleX509Cert is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]  Cert            Pointer to the DER-encoded certificate data.
  @param[in]  CertSize        The size of certificate data in bytes.
  @param[out] SingleX509Cert  The generated X509 object.

  @retval     TRUE            The X509 object generation succeeded.
  @retval     FALSE           The operation failed.
  @retval     FALSE           This interface is not supported.

**/
BOOLEAN
EFIAPI
X509ConstructCertificate (
  IN   CONST UINT8  *Cert,
  IN   UINTN        CertSize,
  OUT  UINT8        **SingleX509Cert
  );

/**
  Construct a X509 stack object from a list of DER-encoded certificate data.

  If X509Stack is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  X509Stack  On input, pointer to an existing or NULL X509 stack object.
                              On output, pointer to the X509 stack object with new
                              inserted X509 certificate.
  @param           ...        A list of DER-encoded single certificate data followed
                              by certificate size. A NULL terminates the list. The
                              pairs are the arguments to X509ConstructCertificate().

  @retval     TRUE            The X509 stack construction succeeded.
  @retval     FALSE           The construction operation failed.
  @retval     FALSE           This interface is not supported.

**/
BOOLEAN
EFIAPI
X509ConstructCertificateStack (
  IN OUT  UINT8  **X509Stack,
  ...
  );

/**
  Release the specified X509 object.

  If the interface is not supported, then ASSERT().

  @param[in]  X509Cert  Pointer to the X509 object to be released.

**/
VOID
EFIAPI
X509Free (
  IN  VOID  *X509Cert
  );

/**
  Release the specified X509 stack object.

  If the interface is not supported, then ASSERT().

  @param[in]  X509Stack  Pointer to the X509 stack object to be released.

**/
VOID
EFIAPI
X509StackFree (
  IN  VOID  *X509Stack
  );

/**
  Retrieve the TBSCertificate from one given X.509 certificate.

  @param[in]      Cert         Pointer to the given DER-encoded X509 certificate.
  @param[in]      CertSize     Size of the X509 certificate in bytes.
  @param[out]     TBSCert      DER-Encoded To-Be-Signed certificate.
  @param[out]     TBSCertSize  Size of the TBS certificate in bytes.

  If Cert is NULL, then return FALSE.
  If TBSCert is NULL, then return FALSE.
  If TBSCertSize is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @retval  TRUE   The TBSCertificate was retrieved successfully.
  @retval  FALSE  Invalid X.509 certificate.

**/
BOOLEAN
EFIAPI
X509GetTBSCert (
  IN  CONST UINT8  *Cert,
  IN  UINTN        CertSize,
  OUT UINT8        **TBSCert,
  OUT UINTN        *TBSCertSize
  );

/**
  Derives a key from a password using a salt and iteration count, based on PKCS#5 v2.0
  password based encryption key derivation function PBKDF2, as specified in RFC 2898.

  If Password or Salt or OutKey is NULL, then return FALSE.
  If the hash algorithm could not be determined, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]  PasswordLength  Length of input password in bytes.
  @param[in]  Password        Pointer to the array for the password.
  @param[in]  SaltLength      Size of the Salt in bytes.
  @param[in]  Salt            Pointer to the Salt.
  @param[in]  IterationCount  Number of iterations to perform. Its value should be
                              greater than or equal to 1.
  @param[in]  DigestSize      Size of the message digest to be used (eg. SHA256_DIGEST_SIZE).
                              NOTE: DigestSize will be used to determine the hash algorithm.
                                    Only SHA1_DIGEST_SIZE or SHA256_DIGEST_SIZE is supported.
  @param[in]  KeyLength       Size of the derived key buffer in bytes.
  @param[out] OutKey          Pointer to the output derived key buffer.

  @retval  TRUE   A key was derived successfully.
  @retval  FALSE  One of the pointers was NULL or one of the sizes was too large.
  @retval  FALSE  The hash algorithm could not be determined from the digest size.
  @retval  FALSE  The key derivation operation failed.
  @retval  FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
Pkcs5HashPassword (
  IN  UINTN        PasswordLength,
  IN  CONST CHAR8  *Password,
  IN  UINTN        SaltLength,
  IN  CONST UINT8  *Salt,
  IN  UINTN        IterationCount,
  IN  UINTN        DigestSize,
  IN  UINTN        KeyLength,
  OUT UINT8        *OutKey
  );

/**
  The 3rd parameter of Pkcs7GetSigners will return all embedded
  X.509 certificate in one given PKCS7 signature. The format is:
  //
  // UINT8  CertNumber;
  // UINT32 Cert1Length;
  // UINT8  Cert1[];
  // UINT32 Cert2Length;
  // UINT8  Cert2[];
  // ...
  // UINT32 CertnLength;
  // UINT8  Certn[];
  //

  The two following C-structure are used for parsing CertStack more clearly.
**/
#pragma pack(1)

typedef struct {
  UINT32    CertDataLength;       // The length in bytes of X.509 certificate.
  UINT8     CertDataBuffer[0];    // The X.509 certificate content (DER).
} EFI_CERT_DATA;

typedef struct {
  UINT8             CertNumber;   // Number of X.509 certificate.
  //EFI_CERT_DATA   CertArray[];  // An array of X.509 certificate.
} EFI_CERT_STACK;

#pragma pack()

/**
  Get the signer's certificates from PKCS#7 signed data as described in "PKCS #7:
  Cryptographic Message Syntax Standard". The input signed data could be wrapped
  in a ContentInfo structure.

  If P7Data, CertStack, StackLength, TrustedCert or CertLength is NULL, then
  return FALSE. If P7Length overflow, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]  P7Data       Pointer to the PKCS#7 message to verify.
  @param[in]  P7Length     Length of the PKCS#7 message in bytes.
  @param[out] CertStack    Pointer to Signer's certificates retrieved from P7Data.
                           It's caller's responsibility to free the buffer with
                           Pkcs7FreeSigners().
                           This data structure is EFI_CERT_STACK type.
  @param[out] StackLength  Length of signer's certificates in bytes.
  @param[out] TrustedCert  Pointer to a trusted certificate from Signer's certificates.
                           It's caller's responsibility to free the buffer with
                           Pkcs7FreeSigners().
  @param[out] CertLength   Length of the trusted certificate in bytes.

  @retval  TRUE            The operation is finished successfully.
  @retval  FALSE           Error occurs during the operation.
  @retval  FALSE           This interface is not supported.

**/
BOOLEAN
EFIAPI
Pkcs7GetSigners (
  IN  CONST UINT8  *P7Data,
  IN  UINTN        P7Length,
  OUT UINT8        **CertStack,
  OUT UINTN        *StackLength,
  OUT UINT8        **TrustedCert,
  OUT UINTN        *CertLength
  );

/**
  Wrap function to use free() to free allocated memory for certificates.

  If this interface is not supported, then ASSERT().

  @param[in]  Certs        Pointer to the certificates to be freed.

**/
VOID
EFIAPI
Pkcs7FreeSigners (
  IN  UINT8        *Certs
  );

/**
  Retrieves all embedded certificates from PKCS#7 signed data as described in "PKCS #7:
  Cryptographic Message Syntax Standard", and outputs two certificate lists chained and
  unchained to the signer's certificates.
  The input signed data could be wrapped in a ContentInfo structure.

  @param[in]  P7Data            Pointer to the PKCS#7 message.
  @param[in]  P7Length          Length of the PKCS#7 message in bytes.
  @param[out] SignerChainCerts  Pointer to the certificates list chained to signer's
                                certificate. It's caller's responsibility to free the buffer
                                with Pkcs7FreeSigners().
                                This data structure is EFI_CERT_STACK type.
  @param[out] ChainLength       Length of the chained certificates list buffer in bytes.
  @param[out] UnchainCerts      Pointer to the unchained certificates lists. It's caller's
                                responsibility to free the buffer with Pkcs7FreeSigners().
                                This data structure is EFI_CERT_STACK type.
  @param[out] UnchainLength     Length of the unchained certificates list buffer in bytes.

  @retval  TRUE         The operation is finished successfully.
  @retval  FALSE        Error occurs during the operation.

**/
BOOLEAN
EFIAPI
Pkcs7GetCertificatesList (
  IN  CONST UINT8  *P7Data,
  IN  UINTN        P7Length,
  OUT UINT8        **SignerChainCerts,
  OUT UINTN        *ChainLength,
  OUT UINT8        **UnchainCerts,
  OUT UINTN        *UnchainLength
  );

/**
  Creates a PKCS#7 signedData as described in "PKCS #7: Cryptographic Message
  Syntax Standard, version 1.5". This interface is only intended to be used for
  application to perform PKCS#7 functionality validation.

  If this interface is not supported, then return FALSE.

  @param[in]  PrivateKey       Pointer to the PEM-formatted private key data for
                               data signing.
  @param[in]  PrivateKeySize   Size of the PEM private key data in bytes.
  @param[in]  KeyPassword      NULL-terminated passphrase used for encrypted PEM
                               key data.
  @param[in]  InData           Pointer to the content to be signed.
  @param[in]  InDataSize       Size of InData in bytes.
  @param[in]  SignCert         Pointer to signer's DER-encoded certificate to sign with.
  @param[in]  OtherCerts       Pointer to an optional additional set of certificates to
                               include in the PKCS#7 signedData (e.g. any intermediate
                               CAs in the chain).
  @param[out] SignedData       Pointer to output PKCS#7 signedData. It's caller's
                               responsibility to free the buffer with FreePool().
  @param[out] SignedDataSize   Size of SignedData in bytes.

  @retval     TRUE             PKCS#7 data signing succeeded.
  @retval     FALSE            PKCS#7 data signing failed.
  @retval     FALSE            This interface is not supported.

**/
BOOLEAN
EFIAPI
Pkcs7Sign (
  IN   CONST UINT8  *PrivateKey,
  IN   UINTN        PrivateKeySize,
  IN   CONST UINT8  *KeyPassword,
  IN   UINT8        *InData,
  IN   UINTN        InDataSize,
  IN   UINT8        *SignCert,
  IN   UINT8        *OtherCerts      OPTIONAL,
  OUT  UINT8        **SignedData,
  OUT  UINTN        *SignedDataSize
  );

/**
  Verifies the validity of a PKCS#7 signed data as described in "PKCS #7:
  Cryptographic Message Syntax Standard". The input signed data could be wrapped
  in a ContentInfo structure.

  If P7Data, TrustedCert or InData is NULL, then return FALSE.
  If P7Length, CertLength or DataLength overflow, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]  P7Data       Pointer to the PKCS#7 message to verify.
  @param[in]  P7Length     Length of the PKCS#7 message in bytes.
  @param[in]  TrustedCert  Pointer to a trusted/root certificate encoded in DER, which
                           is used for certificate chain verification.
  @param[in]  CertLength   Length of the trusted certificate in bytes.
  @param[in]  InData       Pointer to the content to be verified.
  @param[in]  DataLength   Length of InData in bytes.

  @retval  TRUE  The specified PKCS#7 signed data is valid.
  @retval  FALSE Invalid PKCS#7 signed data.
  @retval  FALSE This interface is not supported.

**/
BOOLEAN
EFIAPI
Pkcs7Verify (
  IN  CONST UINT8  *P7Data,
  IN  UINTN        P7Length,
  IN  CONST UINT8  *TrustedCert,
  IN  UINTN        CertLength,
  IN  CONST UINT8  *InData,
  IN  UINTN        DataLength
  );

/**
  Extracts the attached content from a PKCS#7 signed data if existed. The input signed
  data could be wrapped in a ContentInfo structure.

  If P7Data, Content, or ContentSize is NULL, then return FALSE. If P7Length overflow,
  then return FALSE. If the P7Data is not correctly formatted, then return FALSE.

  Caution: This function may receive untrusted input. So this function will do
           basic check for PKCS#7 data structure.

  @param[in]   P7Data       Pointer to the PKCS#7 signed data to process.
  @param[in]   P7Length     Length of the PKCS#7 signed data in bytes.
  @param[out]  Content      Pointer to the extracted content from the PKCS#7 signedData.
                            It's caller's responsibility to free the buffer with FreePool().
  @param[out]  ContentSize  The size of the extracted content in bytes.

  @retval     TRUE          The P7Data was correctly formatted for processing.
  @retval     FALSE         The P7Data was not correctly formatted for processing.

**/
BOOLEAN
EFIAPI
Pkcs7GetAttachedContent (
  IN  CONST UINT8  *P7Data,
  IN  UINTN        P7Length,
  OUT VOID         **Content,
  OUT UINTN        *ContentSize
  );

/**
  Verifies the validity of a PE/COFF Authenticode Signature as described in "Windows
  Authenticode Portable Executable Signature Format".

  If AuthData is NULL, then return FALSE.
  If ImageHash is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]  AuthData     Pointer to the Authenticode Signature retrieved from signed
                           PE/COFF image to be verified.
  @param[in]  DataSize     Size of the Authenticode Signature in bytes.
  @param[in]  TrustedCert  Pointer to a trusted/root certificate encoded in DER, which
                           is used for certificate chain verification.
  @param[in]  CertSize     Size of the trusted certificate in bytes.
  @param[in]  ImageHash    Pointer to the original image file hash value. The procedure
                           for calculating the image hash value is described in Authenticode
                           specification.
  @param[in]  HashSize     Size of Image hash value in bytes.

  @retval  TRUE   The specified Authenticode Signature is valid.
  @retval  FALSE  Invalid Authenticode Signature.
  @retval  FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
AuthenticodeVerify (
  IN  CONST UINT8  *AuthData,
  IN  UINTN        DataSize,
  IN  CONST UINT8  *TrustedCert,
  IN  UINTN        CertSize,
  IN  CONST UINT8  *ImageHash,
  IN  UINTN        HashSize
  );

/**
  Verifies the validity of a RFC3161 Timestamp CounterSignature embedded in PE/COFF Authenticode
  signature.

  If AuthData is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in]  AuthData     Pointer to the Authenticode Signature retrieved from signed
                           PE/COFF image to be verified.
  @param[in]  DataSize     Size of the Authenticode Signature in bytes.
  @param[in]  TsaCert      Pointer to a trusted/root TSA certificate encoded in DER, which
                           is used for TSA certificate chain verification.
  @param[in]  CertSize     Size of the trusted certificate in bytes.
  @param[out] SigningTime  Return the time of timestamp generation time if the timestamp
                           signature is valid.

  @retval  TRUE   The specified Authenticode includes a valid RFC3161 Timestamp CounterSignature.
  @retval  FALSE  No valid RFC3161 Timestamp CounterSignature in the specified Authenticode data.

**/
BOOLEAN
EFIAPI
ImageTimestampVerify (
  IN  CONST UINT8  *AuthData,
  IN  UINTN        DataSize,
  IN  CONST UINT8  *TsaCert,
  IN  UINTN        CertSize,
  OUT EFI_TIME     *SigningTime
  );

//=====================================================================================
//    DH Key Exchange Primitive
//=====================================================================================

/**
  Allocates and Initializes one Diffie-Hellman Context for subsequent use.

  @return  Pointer to the Diffie-Hellman Context that has been initialized.
           If the allocations fails, DhNew() returns NULL.
           If the interface is not supported, DhNew() returns NULL.

**/
VOID *
EFIAPI
DhNew (
  VOID
  );

/**
  Release the specified DH context.

  If the interface is not supported, then ASSERT().

  @param[in]  DhContext  Pointer to the DH context to be released.

**/
VOID
EFIAPI
DhFree (
  IN  VOID  *DhContext
  );

/**
  Generates DH parameter.

  Given generator g, and length of prime number p in bits, this function generates p,
  and sets DH context according to value of g and p.

  Before this function can be invoked, pseudorandom number generator must be correctly
  initialized by RandomSeed().

  If DhContext is NULL, then return FALSE.
  If Prime is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  DhContext    Pointer to the DH context.
  @param[in]       Generator    Value of generator.
  @param[in]       PrimeLength  Length in bits of prime to be generated.
  @param[out]      Prime        Pointer to the buffer to receive the generated prime number.

  @retval TRUE   DH parameter generation succeeded.
  @retval FALSE  Value of Generator is not supported.
  @retval FALSE  PRNG fails to generate random prime number with PrimeLength.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
DhGenerateParameter (
  IN OUT  VOID   *DhContext,
  IN      UINTN  Generator,
  IN      UINTN  PrimeLength,
  OUT     UINT8  *Prime
  );

/**
  Sets generator and prime parameters for DH.

  Given generator g, and prime number p, this function and sets DH
  context accordingly.

  If DhContext is NULL, then return FALSE.
  If Prime is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  DhContext    Pointer to the DH context.
  @param[in]       Generator    Value of generator.
  @param[in]       PrimeLength  Length in bits of prime to be generated.
  @param[in]       Prime        Pointer to the prime number.

  @retval TRUE   DH parameter setting succeeded.
  @retval FALSE  Value of Generator is not supported.
  @retval FALSE  Value of Generator is not suitable for the Prime.
  @retval FALSE  Value of Prime is not a prime number.
  @retval FALSE  Value of Prime is not a safe prime number.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
DhSetParameter (
  IN OUT  VOID         *DhContext,
  IN      UINTN        Generator,
  IN      UINTN        PrimeLength,
  IN      CONST UINT8  *Prime
  );

/**
  Generates DH public key.

  This function generates random secret exponent, and computes the public key, which is
  returned via parameter PublicKey and PublicKeySize. DH context is updated accordingly.
  If the PublicKey buffer is too small to hold the public key, FALSE is returned and
  PublicKeySize is set to the required buffer size to obtain the public key.

  If DhContext is NULL, then return FALSE.
  If PublicKeySize is NULL, then return FALSE.
  If PublicKeySize is large enough but PublicKey is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  DhContext      Pointer to the DH context.
  @param[out]      PublicKey      Pointer to the buffer to receive generated public key.
  @param[in, out]  PublicKeySize  On input, the size of PublicKey buffer in bytes.
                                 On output, the size of data returned in PublicKey buffer in bytes.

  @retval TRUE   DH public key generation succeeded.
  @retval FALSE  DH public key generation failed.
  @retval FALSE  PublicKeySize is not large enough.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
DhGenerateKey (
  IN OUT  VOID   *DhContext,
  OUT     UINT8  *PublicKey,
  IN OUT  UINTN  *PublicKeySize
  );

/**
  Computes exchanged common key.

  Given peer's public key, this function computes the exchanged common key, based on its own
  context including value of prime modulus and random secret exponent.

  If DhContext is NULL, then return FALSE.
  If PeerPublicKey is NULL, then return FALSE.
  If KeySize is NULL, then return FALSE.
  If Key is NULL, then return FALSE.
  If KeySize is not large enough, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[in, out]  DhContext          Pointer to the DH context.
  @param[in]       PeerPublicKey      Pointer to the peer's public key.
  @param[in]       PeerPublicKeySize  Size of peer's public key in bytes.
  @param[out]      Key                Pointer to the buffer to receive generated key.
  @param[in, out]  KeySize            On input, the size of Key buffer in bytes.
                                     On output, the size of data returned in Key buffer in bytes.

  @retval TRUE   DH exchanged key generation succeeded.
  @retval FALSE  DH exchanged key generation failed.
  @retval FALSE  KeySize is not large enough.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
DhComputeKey (
  IN OUT  VOID         *DhContext,
  IN      CONST UINT8  *PeerPublicKey,
  IN      UINTN        PeerPublicKeySize,
  OUT     UINT8        *Key,
  IN OUT  UINTN        *KeySize
  );

//=====================================================================================
//    Pseudo-Random Generation Primitive
//=====================================================================================

/**
  Sets up the seed value for the pseudorandom number generator.

  This function sets up the seed value for the pseudorandom number generator.
  If Seed is not NULL, then the seed passed in is used.
  If Seed is NULL, then default seed is used.
  If this interface is not supported, then return FALSE.

  @param[in]  Seed      Pointer to seed value.
                        If NULL, default seed is used.
  @param[in]  SeedSize  Size of seed value.
                        If Seed is NULL, this parameter is ignored.

  @retval TRUE   Pseudorandom number generator has enough entropy for random generation.
  @retval FALSE  Pseudorandom number generator does not have enough entropy for random generation.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
RandomSeed (
  IN  CONST  UINT8  *Seed  OPTIONAL,
  IN  UINTN         SeedSize
  );

/**
  Generates a pseudorandom byte stream of the specified size.

  If Output is NULL, then return FALSE.
  If this interface is not supported, then return FALSE.

  @param[out]  Output  Pointer to buffer to receive random value.
  @param[in]   Size    Size of random bytes to generate.

  @retval TRUE   Pseudorandom byte stream generated successfully.
  @retval FALSE  Pseudorandom number generator fails to generate due to lack of entropy.
  @retval FALSE  This interface is not supported.

**/
BOOLEAN
EFIAPI
RandomBytes (
  OUT  UINT8  *Output,
  IN   UINTN  Size
  );

#endif // __BASE_CRYPT_LIB_H__

```

`CryptoPkg/Include/Library/TlsLib.h`:

```h
/** @file
  Defines TLS Library APIs.

Copyright (c) 2016 - 2017, Intel Corporation. All rights reserved.<BR>
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#ifndef __TLS_LIB_H__
#define __TLS_LIB_H__

/**
  Initializes the OpenSSL library.

  This function registers ciphers and digests used directly and indirectly
  by SSL/TLS, and initializes the readable error messages.
  This function must be called before any other action takes places.

  @retval TRUE   The OpenSSL library has been initialized.
  @retval FALSE  Failed to initialize the OpenSSL library.

**/
BOOLEAN
EFIAPI
TlsInitialize (
  VOID
  );

/**
  Free an allocated SSL_CTX object.

  @param[in]  TlsCtx    Pointer to the SSL_CTX object to be released.

**/
VOID
EFIAPI
TlsCtxFree (
  IN   VOID                  *TlsCtx
  );

/**
  Creates a new SSL_CTX object as framework to establish TLS/SSL enabled
  connections.

  @param[in]  MajorVer    Major Version of TLS/SSL Protocol.
  @param[in]  MinorVer    Minor Version of TLS/SSL Protocol.

  @return  Pointer to an allocated SSL_CTX object.
           If the creation failed, TlsCtxNew() returns NULL.

**/
VOID *
EFIAPI
TlsCtxNew (
  IN     UINT8                    MajorVer,
  IN     UINT8                    MinorVer
  );

/**
  Free an allocated TLS object.

  This function removes the TLS object pointed to by Tls and frees up the
  allocated memory. If Tls is NULL, nothing is done.

  @param[in]  Tls    Pointer to the TLS object to be freed.

**/
VOID
EFIAPI
TlsFree (
  IN     VOID                     *Tls
  );

/**
  Create a new TLS object for a connection.

  This function creates a new TLS object for a connection. The new object
  inherits the setting of the underlying context TlsCtx: connection method,
  options, verification setting.

  @param[in]  TlsCtx    Pointer to the SSL_CTX object.

  @return  Pointer to an allocated SSL object.
           If the creation failed, TlsNew() returns NULL.

**/
VOID *
EFIAPI
TlsNew (
  IN     VOID                     *TlsCtx
  );

/**
  Checks if the TLS handshake was done.

  This function will check if the specified TLS handshake was done.

  @param[in]  Tls    Pointer to the TLS object for handshake state checking.

  @retval  TRUE     The TLS handshake was done.
  @retval  FALSE    The TLS handshake was not done.

**/
BOOLEAN
EFIAPI
TlsInHandshake (
  IN     VOID                     *Tls
  );

/**
  Perform a TLS/SSL handshake.

  This function will perform a TLS/SSL handshake.

  @param[in]       Tls            Pointer to the TLS object for handshake operation.
  @param[in]       BufferIn       Pointer to the most recently received TLS Handshake packet.
  @param[in]       BufferInSize   Packet size in bytes for the most recently received TLS
                                  Handshake packet.
  @param[out]      BufferOut      Pointer to the buffer to hold the built packet.
  @param[in, out]  BufferOutSize  Pointer to the buffer size in bytes. On input, it is
                                  the buffer size provided by the caller. On output, it
                                  is the buffer size in fact needed to contain the
                                  packet.

  @retval EFI_SUCCESS             The required TLS packet is built successfully.
  @retval EFI_INVALID_PARAMETER   One or more of the following conditions is TRUE:
                                  Tls is NULL.
                                  BufferIn is NULL but BufferInSize is NOT 0.
                                  BufferInSize is 0 but BufferIn is NOT NULL.
                                  BufferOutSize is NULL.
                                  BufferOut is NULL if *BufferOutSize is not zero.
  @retval EFI_BUFFER_TOO_SMALL    BufferOutSize is too small to hold the response packet.
  @retval EFI_ABORTED             Something wrong during handshake.

**/
EFI_STATUS
EFIAPI
TlsDoHandshake (
  IN     VOID                     *Tls,
  IN     UINT8                    *BufferIn, OPTIONAL
  IN     UINTN                    BufferInSize, OPTIONAL
     OUT UINT8                    *BufferOut, OPTIONAL
  IN OUT UINTN                    *BufferOutSize
  );

/**
  Handle Alert message recorded in BufferIn. If BufferIn is NULL and BufferInSize is zero,
  TLS session has errors and the response packet needs to be Alert message based on error type.

  @param[in]       Tls            Pointer to the TLS object for state checking.
  @param[in]       BufferIn       Pointer to the most recently received TLS Alert packet.
  @param[in]       BufferInSize   Packet size in bytes for the most recently received TLS
                                  Alert packet.
  @param[out]      BufferOut      Pointer to the buffer to hold the built packet.
  @param[in, out]  BufferOutSize  Pointer to the buffer size in bytes. On input, it is
                                  the buffer size provided by the caller. On output, it
                                  is the buffer size in fact needed to contain the
                                  packet.

  @retval EFI_SUCCESS             The required TLS packet is built successfully.
  @retval EFI_INVALID_PARAMETER   One or more of the following conditions is TRUE:
                                  Tls is NULL.
                                  BufferIn is NULL but BufferInSize is NOT 0.
                                  BufferInSize is 0 but BufferIn is NOT NULL.
                                  BufferOutSize is NULL.
                                  BufferOut is NULL if *BufferOutSize is not zero.
  @retval EFI_ABORTED             An error occurred.
  @retval EFI_BUFFER_TOO_SMALL    BufferOutSize is too small to hold the response packet.

**/
EFI_STATUS
EFIAPI
TlsHandleAlert (
  IN     VOID                     *Tls,
  IN     UINT8                    *BufferIn, OPTIONAL
  IN     UINTN                    BufferInSize, OPTIONAL
     OUT UINT8                    *BufferOut, OPTIONAL
  IN OUT UINTN                    *BufferOutSize
  );

/**
  Build the CloseNotify packet.

  @param[in]       Tls            Pointer to the TLS object for state checking.
  @param[in, out]  Buffer         Pointer to the buffer to hold the built packet.
  @param[in, out]  BufferSize     Pointer to the buffer size in bytes. On input, it is
                                  the buffer size provided by the caller. On output, it
                                  is the buffer size in fact needed to contain the
                                  packet.

  @retval EFI_SUCCESS             The required TLS packet is built successfully.
  @retval EFI_INVALID_PARAMETER   One or more of the following conditions is TRUE:
                                  Tls is NULL.
                                  BufferSize is NULL.
                                  Buffer is NULL if *BufferSize is not zero.
  @retval EFI_BUFFER_TOO_SMALL    BufferSize is too small to hold the response packet.

**/
EFI_STATUS
EFIAPI
TlsCloseNotify (
  IN     VOID                     *Tls,
  IN OUT UINT8                    *Buffer,
  IN OUT UINTN                    *BufferSize
  );

/**
  Attempts to read bytes from one TLS object and places the data in Buffer.

  This function will attempt to read BufferSize bytes from the TLS object
  and places the data in Buffer.

  @param[in]      Tls           Pointer to the TLS object.
  @param[in,out]  Buffer        Pointer to the buffer to store the data.
  @param[in]      BufferSize    The size of Buffer in bytes.

  @retval  >0    The amount of data successfully read from the TLS object.
  @retval  <=0   No data was successfully read.

**/
INTN
EFIAPI
TlsCtrlTrafficOut (
  IN     VOID                     *Tls,
  IN OUT VOID                     *Buffer,
  IN     UINTN                    BufferSize
  );

/**
  Attempts to write data from the buffer to TLS object.

  This function will attempt to write BufferSize bytes data from the Buffer
  to the TLS object.

  @param[in]  Tls           Pointer to the TLS object.
  @param[in]  Buffer        Pointer to the data buffer.
  @param[in]  BufferSize    The size of Buffer in bytes.

  @retval  >0    The amount of data successfully written to the TLS object.
  @retval <=0    No data was successfully written.

**/
INTN
EFIAPI
TlsCtrlTrafficIn (
  IN     VOID                     *Tls,
  IN     VOID                     *Buffer,
  IN     UINTN                    BufferSize
  );

/**
  Attempts to read bytes from the specified TLS connection into the buffer.

  This function tries to read BufferSize bytes data from the specified TLS
  connection into the Buffer.

  @param[in]      Tls           Pointer to the TLS connection for data reading.
  @param[in,out]  Buffer        Pointer to the data buffer.
  @param[in]      BufferSize    The size of Buffer in bytes.

  @retval  >0    The read operation was successful, and return value is the
                 number of bytes actually read from the TLS connection.
  @retval  <=0   The read operation was not successful.

**/
INTN
EFIAPI
TlsRead (
  IN     VOID                     *Tls,
  IN OUT VOID                     *Buffer,
  IN     UINTN                    BufferSize
  );

/**
  Attempts to write data to a TLS connection.

  This function tries to write BufferSize bytes data from the Buffer into the
  specified TLS connection.

  @param[in]  Tls           Pointer to the TLS connection for data writing.
  @param[in]  Buffer        Pointer to the data buffer.
  @param[in]  BufferSize    The size of Buffer in bytes.

  @retval  >0    The write operation was successful, and return value is the
                 number of bytes actually written to the TLS connection.
  @retval <=0    The write operation was not successful.

**/
INTN
EFIAPI
TlsWrite (
  IN     VOID                     *Tls,
  IN     VOID                     *Buffer,
  IN     UINTN                    BufferSize
  );

/**
  Set a new TLS/SSL method for a particular TLS object.

  This function sets a new TLS/SSL method for a particular TLS object.

  @param[in]  Tls         Pointer to a TLS object.
  @param[in]  MajorVer    Major Version of TLS/SSL Protocol.
  @param[in]  MinorVer    Minor Version of TLS/SSL Protocol.

  @retval  EFI_SUCCESS           The TLS/SSL method was set successfully.
  @retval  EFI_INVALID_PARAMETER The parameter is invalid.
  @retval  EFI_UNSUPPORTED       Unsupported TLS/SSL method.

**/
EFI_STATUS
EFIAPI
TlsSetVersion (
  IN     VOID                     *Tls,
  IN     UINT8                    MajorVer,
  IN     UINT8                    MinorVer
  );

/**
  Set TLS object to work in client or server mode.

  This function prepares a TLS object to work in client or server mode.

  @param[in]  Tls         Pointer to a TLS object.
  @param[in]  IsServer    Work in server mode.

  @retval  EFI_SUCCESS           The TLS/SSL work mode was set successfully.
  @retval  EFI_INVALID_PARAMETER The parameter is invalid.
  @retval  EFI_UNSUPPORTED       Unsupported TLS/SSL work mode.

**/
EFI_STATUS
EFIAPI
TlsSetConnectionEnd (
  IN     VOID                     *Tls,
  IN     BOOLEAN                  IsServer
  );

/**
  Set the ciphers list to be used by the TLS object.

  This function sets the ciphers for use by a specified TLS object.

  @param[in]  Tls          Pointer to a TLS object.
  @param[in]  CipherId     Array of UINT16 cipher identifiers. Each UINT16
                           cipher identifier comes from the TLS Cipher Suite
                           Registry of the IANA, interpreting Byte1 and Byte2
                           in network (big endian) byte order.
  @param[in]  CipherNum    The number of cipher in the list.

  @retval  EFI_SUCCESS           The ciphers list was set successfully.
  @retval  EFI_INVALID_PARAMETER The parameter is invalid.
  @retval  EFI_UNSUPPORTED       No supported TLS cipher was found in CipherId.
  @retval  EFI_OUT_OF_RESOURCES  Memory allocation failed.

**/
EFI_STATUS
EFIAPI
TlsSetCipherList (
  IN     VOID                     *Tls,
  IN     UINT16                   *CipherId,
  IN     UINTN                    CipherNum
  );

/**
  Set the compression method for TLS/SSL operations.

  This function handles TLS/SSL integrated compression methods.

  @param[in]  CompMethod    The compression method ID.

  @retval  EFI_SUCCESS        The compression method for the communication was
                              set successfully.
  @retval  EFI_UNSUPPORTED    Unsupported compression method.

**/
EFI_STATUS
EFIAPI
TlsSetCompressionMethod (
  IN     UINT8                    CompMethod
  );

/**
  Set peer certificate verification mode for the TLS connection.

  This function sets the verification mode flags for the TLS connection.

  @param[in]  Tls           Pointer to the TLS object.
  @param[in]  VerifyMode    A set of logically or'ed verification mode flags.

**/
VOID
EFIAPI
TlsSetVerify (
  IN     VOID                     *Tls,
  IN     UINT32                   VerifyMode
  );

/**
  Sets a TLS/SSL session ID to be used during TLS/SSL connect.

  This function sets a session ID to be used when the TLS/SSL connection is
  to be established.

  @param[in]  Tls             Pointer to the TLS object.
  @param[in]  SessionId       Session ID data used for session resumption.
  @param[in]  SessionIdLen    Length of Session ID in bytes.

  @retval  EFI_SUCCESS           Session ID was set successfully.
  @retval  EFI_INVALID_PARAMETER The parameter is invalid.
  @retval  EFI_UNSUPPORTED       No available session for ID setting.

**/
EFI_STATUS
EFIAPI
TlsSetSessionId (
  IN     VOID                     *Tls,
  IN     UINT8                    *SessionId,
  IN     UINT16                   SessionIdLen
  );

/**
  Adds the CA to the cert store when requesting Server or Client authentication.

  This function adds the CA certificate to the list of CAs when requesting
  Server or Client authentication for the chosen TLS connection.

  @param[in]  Tls         Pointer to the TLS object.
  @param[in]  Data        Pointer to the data buffer of a DER-encoded binary
                          X.509 certificate or PEM-encoded X.509 certificate.
  @param[in]  DataSize    The size of data buffer in bytes.

  @retval  EFI_SUCCESS             The operation succeeded.
  @retval  EFI_INVALID_PARAMETER   The parameter is invalid.
  @retval  EFI_OUT_OF_RESOURCES    Required resources could not be allocated.
  @retval  EFI_ABORTED             Invalid X.509 certificate.

**/
EFI_STATUS
EFIAPI
TlsSetCaCertificate (
  IN     VOID                     *Tls,
  IN     VOID                     *Data,
  IN     UINTN                    DataSize
  );

/**
  Loads the local public certificate into the specified TLS object.

  This function loads the X.509 certificate into the specified TLS object
  for TLS negotiation.

  @param[in]  Tls         Pointer to the TLS object.
  @param[in]  Data        Pointer to the data buffer of a DER-encoded binary
                          X.509 certificate or PEM-encoded X.509 certificate.
  @param[in]  DataSize    The size of data buffer in bytes.

  @retval  EFI_SUCCESS             The operation succeeded.
  @retval  EFI_INVALID_PARAMETER   The parameter is invalid.
  @retval  EFI_OUT_OF_RESOURCES    Required resources could not be allocated.
  @retval  EFI_ABORTED             Invalid X.509 certificate.

**/
EFI_STATUS
EFIAPI
TlsSetHostPublicCert (
  IN     VOID                     *Tls,
  IN     VOID                     *Data,
  IN     UINTN                    DataSize
  );

/**
  Adds the local private key to the specified TLS object.

  This function adds the local private key (PEM-encoded RSA or PKCS#8 private
  key) into the specified TLS object for TLS negotiation.

  @param[in]  Tls         Pointer to the TLS object.
  @param[in]  Data        Pointer to the data buffer of a PEM-encoded RSA
                          or PKCS#8 private key.
  @param[in]  DataSize    The size of data buffer in bytes.

  @retval  EFI_SUCCESS     The operation succeeded.
  @retval  EFI_UNSUPPORTED This function is not supported.
  @retval  EFI_ABORTED     Invalid private key data.

**/
EFI_STATUS
EFIAPI
TlsSetHostPrivateKey (
  IN     VOID                     *Tls,
  IN     VOID                     *Data,
  IN     UINTN                    DataSize
  );

/**
  Adds the CA-supplied certificate revocation list for certificate validation.

  This function adds the CA-supplied certificate revocation list data for
  certificate validity checking.

  @param[in]  Data        Pointer to the data buffer of a DER-encoded CRL data.
  @param[in]  DataSize    The size of data buffer in bytes.

  @retval  EFI_SUCCESS     The operation succeeded.
  @retval  EFI_UNSUPPORTED This function is not supported.
  @retval  EFI_ABORTED     Invalid CRL data.

**/
EFI_STATUS
EFIAPI
TlsSetCertRevocationList (
  IN     VOID                     *Data,
  IN     UINTN                    DataSize
  );

/**
  Gets the protocol version used by the specified TLS connection.

  This function returns the protocol version used by the specified TLS
  connection.

  If Tls is NULL, then ASSERT().

  @param[in]  Tls    Pointer to the TLS object.

  @return  The protocol version of the specified TLS connection.

**/
UINT16
EFIAPI
TlsGetVersion (
  IN     VOID                     *Tls
  );

/**
  Gets the connection end of the specified TLS connection.

  This function returns the connection end (as client or as server) used by
  the specified TLS connection.

  If Tls is NULL, then ASSERT().

  @param[in]  Tls    Pointer to the TLS object.

  @return  The connection end used by the specified TLS connection.

**/
UINT8
EFIAPI
TlsGetConnectionEnd (
  IN     VOID                     *Tls
  );

/**
  Gets the cipher suite used by the specified TLS connection.

  This function returns current cipher suite used by the specified
  TLS connection.

  @param[in]      Tls         Pointer to the TLS object.
  @param[in,out]  CipherId    The cipher suite used by the TLS object.

  @retval  EFI_SUCCESS           The cipher suite was returned successfully.
  @retval  EFI_INVALID_PARAMETER The parameter is invalid.
  @retval  EFI_UNSUPPORTED       Unsupported cipher suite.

**/
EFI_STATUS
EFIAPI
TlsGetCurrentCipher (
  IN     VOID                     *Tls,
  IN OUT UINT16                   *CipherId
  );

/**
  Gets the compression methods used by the specified TLS connection.

  This function returns current integrated compression methods used by
  the specified TLS connection.

  @param[in]      Tls              Pointer to the TLS object.
  @param[in,out]  CompressionId    The current compression method used by
                                   the TLS object.

  @retval  EFI_SUCCESS           The compression method was returned successfully.
  @retval  EFI_INVALID_PARAMETER The parameter is invalid.
  @retval  EFI_ABORTED           Invalid Compression method.
  @retval  EFI_UNSUPPORTED       This function is not supported.

**/
EFI_STATUS
EFIAPI
TlsGetCurrentCompressionId (
  IN     VOID                     *Tls,
  IN OUT UINT8                    *CompressionId
  );

/**
  Gets the verification mode currently set in the TLS connection.

  This function returns the peer verification mode currently set in the
  specified TLS connection.

  If Tls is NULL, then ASSERT().

  @param[in]  Tls    Pointer to the TLS object.

  @return  The verification mode set in the specified TLS connection.

**/
UINT32
EFIAPI
TlsGetVerify (
  IN     VOID                     *Tls
  );

/**
  Gets the session ID used by the specified TLS connection.

  This function returns the TLS/SSL session ID currently used by the
  specified TLS connection.

  @param[in]      Tls             Pointer to the TLS object.
  @param[in,out]  SessionId       Buffer to contain the returned session ID.
  @param[in,out]  SessionIdLen    The length of Session ID in bytes.

  @retval  EFI_SUCCESS           The Session ID was returned successfully.
  @retval  EFI_INVALID_PARAMETER The parameter is invalid.
  @retval  EFI_UNSUPPORTED       Invalid TLS/SSL session.

**/
EFI_STATUS
EFIAPI
TlsGetSessionId (
  IN     VOID                     *Tls,
  IN OUT UINT8                    *SessionId,
  IN OUT UINT16                   *SessionIdLen
  );

/**
  Gets the client random data used in the specified TLS connection.

  This function returns the TLS/SSL client random data currently used in
  the specified TLS connection.

  @param[in]      Tls             Pointer to the TLS object.
  @param[in,out]  ClientRandom    Buffer to contain the returned client
                                  random data (32 bytes).

**/
VOID
EFIAPI
TlsGetClientRandom (
  IN     VOID                     *Tls,
  IN OUT UINT8                    *ClientRandom
  );

/**
  Gets the server random data used in the specified TLS connection.

  This function returns the TLS/SSL server random data currently used in
  the specified TLS connection.

  @param[in]      Tls             Pointer to the TLS object.
  @param[in,out]  ServerRandom    Buffer to contain the returned server
                                  random data (32 bytes).

**/
VOID
EFIAPI
TlsGetServerRandom (
  IN     VOID                     *Tls,
  IN OUT UINT8                    *ServerRandom
  );

/**
  Gets the master key data used in the specified TLS connection.

  This function returns the TLS/SSL master key material currently used in
  the specified TLS connection.

  @param[in]      Tls            Pointer to the TLS object.
  @param[in,out]  KeyMaterial    Buffer to contain the returned key material.

  @retval  EFI_SUCCESS           Key material was returned successfully.
  @retval  EFI_INVALID_PARAMETER The parameter is invalid.
  @retval  EFI_UNSUPPORTED       Invalid TLS/SSL session.

**/
EFI_STATUS
EFIAPI
TlsGetKeyMaterial (
  IN     VOID                     *Tls,
  IN OUT UINT8                    *KeyMaterial
  );

/**
  Gets the CA Certificate from the cert store.

  This function returns the CA certificate for the chosen
  TLS connection.

  @param[in]      Tls         Pointer to the TLS object.
  @param[out]     Data        Pointer to the data buffer to receive the CA
                              certificate data sent to the client.
  @param[in,out]  DataSize    The size of data buffer in bytes.

  @retval  EFI_SUCCESS             The operation succeeded.
  @retval  EFI_UNSUPPORTED         This function is not supported.
  @retval  EFI_BUFFER_TOO_SMALL    The Data is too small to hold the data.

**/
EFI_STATUS
EFIAPI
TlsGetCaCertificate (
  IN     VOID                     *Tls,
  OUT    VOID                     *Data,
  IN OUT UINTN                    *DataSize
  );

/**
  Gets the local public Certificate set in the specified TLS object.

  This function returns the local public certificate which was currently set
  in the specified TLS object.

  @param[in]      Tls         Pointer to the TLS object.
  @param[out]     Data        Pointer to the data buffer to receive the local
                              public certificate.
  @param[in,out]  DataSize    The size of data buffer in bytes.

  @retval  EFI_SUCCESS             The operation succeeded.
  @retval  EFI_INVALID_PARAMETER   The parameter is invalid.
  @retval  EFI_NOT_FOUND           The certificate is not found.
  @retval  EFI_BUFFER_TOO_SMALL    The Data is too small to hold the data.

**/
EFI_STATUS
EFIAPI
TlsGetHostPublicCert (
  IN     VOID                     *Tls,
  OUT    VOID                     *Data,
  IN OUT UINTN                    *DataSize
  );

/**
  Gets the local private key set in the specified TLS object.

  This function returns the local private key data which was currently set
  in the specified TLS object.

  @param[in]      Tls         Pointer to the TLS object.
  @param[out]     Data        Pointer to the data buffer to receive the local
                              private key data.
  @param[in,out]  DataSize    The size of data buffer in bytes.

  @retval  EFI_SUCCESS             The operation succeeded.
  @retval  EFI_UNSUPPORTED         This function is not supported.
  @retval  EFI_BUFFER_TOO_SMALL    The Data is too small to hold the data.

**/
EFI_STATUS
EFIAPI
TlsGetHostPrivateKey (
  IN     VOID                     *Tls,
  OUT    VOID                     *Data,
  IN OUT UINTN                    *DataSize
  );

/**
  Gets the CA-supplied certificate revocation list data set in the specified
  TLS object.

  This function returns the CA-supplied certificate revocation list data which
  was currently set in the specified TLS object.

  @param[out]     Data        Pointer to the data buffer to receive the CRL data.
  @param[in,out]  DataSize    The size of data buffer in bytes.

  @retval  EFI_SUCCESS             The operation succeeded.
  @retval  EFI_UNSUPPORTED         This function is not supported.
  @retval  EFI_BUFFER_TOO_SMALL    The Data is too small to hold the data.

**/
EFI_STATUS
EFIAPI
TlsGetCertRevocationList (
  OUT    VOID                     *Data,
  IN OUT UINTN                    *DataSize
  );

#endif // __TLS_LIB_H__


```

`Hv.c`:

```c
#include "Hv.h"

PVOYAGER_T PayLoadDataPtr = NULL;
VOID* MapModule(PVOYAGER_T VoyagerData, UINT8* ImageBase)
{
	if (!VoyagerData || !ImageBase)
		return NULL;

	EFI_IMAGE_DOS_HEADER* dosHeaders = (EFI_IMAGE_DOS_HEADER*)ImageBase;
	if (dosHeaders->e_magic != EFI_IMAGE_DOS_SIGNATURE)
		return NULL;

	EFI_IMAGE_NT_HEADERS64* ntHeaders = (EFI_IMAGE_NT_HEADERS64*)(ImageBase + dosHeaders->e_lfanew);
	if (ntHeaders->Signature != EFI_IMAGE_NT_SIGNATURE)
		return NULL;

	MemCopy(VoyagerData->ModuleBase, ImageBase, ntHeaders->OptionalHeader.SizeOfHeaders);
	EFI_IMAGE_SECTION_HEADER* sections = (EFI_IMAGE_SECTION_HEADER*)((UINT8*)&ntHeaders->OptionalHeader + ntHeaders->FileHeader.SizeOfOptionalHeader);
	for (UINT32 i = 0; i < ntHeaders->FileHeader.NumberOfSections; ++i) 
	{
		EFI_IMAGE_SECTION_HEADER* section = &sections[i];
		if (section->SizeOfRawData)
		{
			MemCopy
			(
				VoyagerData->ModuleBase + section->VirtualAddress,
				ImageBase + section->PointerToRawData,
				section->SizeOfRawData
			);
		}
	}

	EFI_IMAGE_EXPORT_DIRECTORY* ExportDir = (EFI_IMAGE_EXPORT_DIRECTORY*)(
		VoyagerData->ModuleBase + ntHeaders->OptionalHeader.DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	UINT32* Address = (UINT32*)(VoyagerData->ModuleBase + ExportDir->AddressOfFunctions);
	UINT32* Name = (UINT32*)(VoyagerData->ModuleBase + ExportDir->AddressOfNames);
	UINT16* Ordinal = (UINT16*)(VoyagerData->ModuleBase + ExportDir->AddressOfNameOrdinals);

	for (UINT16 i = 0; i < ExportDir->AddressOfFunctions; i++)
	{
		if (AsciiStrStr(VoyagerData->ModuleBase + Name[i], "voyager_context"))
		{
			*(VOYAGER_T*)(VoyagerData->ModuleBase + Address[Ordinal[i]]) = *VoyagerData;
			break; // DO NOT REMOVE? #Stink Code 2020...
		}
	}

	// Resolve relocations
	EFI_IMAGE_DATA_DIRECTORY* baseRelocDir = &ntHeaders->OptionalHeader.DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC];
	if (baseRelocDir->VirtualAddress) 
	{
		EFI_IMAGE_BASE_RELOCATION* reloc = (EFI_IMAGE_BASE_RELOCATION*)(VoyagerData->ModuleBase + baseRelocDir->VirtualAddress);
		for (UINT32 currentSize = 0; currentSize < baseRelocDir->Size; ) 
		{
			UINT32 relocCount = (reloc->SizeOfBlock - sizeof(EFI_IMAGE_BASE_RELOCATION)) / sizeof(UINT16);
			UINT16* relocData = (UINT16*)((UINT8*)reloc + sizeof(EFI_IMAGE_BASE_RELOCATION));
			UINT8* relocBase = VoyagerData->ModuleBase + reloc->VirtualAddress;

			for (UINT32 i = 0; i < relocCount; ++i, ++relocData) 
			{
				UINT16 data = *relocData;
				UINT16 type = data >> 12;
				UINT16 offset = data & 0xFFF;

				switch (type) 
				{
				case EFI_IMAGE_REL_BASED_ABSOLUTE:
					break;
				case EFI_IMAGE_REL_BASED_DIR64: 
				{
					UINT64* rva = (UINT64*)(relocBase + offset);
					*rva = (UINT64)(VoyagerData->ModuleBase + (*rva - ntHeaders->OptionalHeader.ImageBase));
					break;
				}
				default:
					return NULL;
				}
			}

			currentSize += reloc->SizeOfBlock;
			reloc = (EFI_IMAGE_BASE_RELOCATION*)relocData;
		}
	}

	return VoyagerData->ModuleBase + ntHeaders->OptionalHeader.AddressOfEntryPoint;
}

VOID MakeVoyagerData
(
	PVOYAGER_T VoyagerData,
	VOID* HypervAlloc,
	UINT64 HypervAllocSize,
	VOID* PayLoadBase,
	UINT64 PayLoadSize
)
{
	VoyagerData->HypervModuleBase = HypervAlloc;
	VoyagerData->HypervModuleSize = HypervAllocSize;
	VoyagerData->ModuleBase = PayLoadBase;
	VoyagerData->ModuleSize = PayLoadSize;

	VOID* VmExitHandler =
		FindPattern(
			HypervAlloc,
			HypervAllocSize,
			INTEL_VMEXIT_HANDLER_SIG,
			INTEL_VMEXIT_HANDLER_MASK
		);

	if (VmExitHandler)
	{
		/*
			.text:FFFFF80000237436                 mov     rcx, [rsp+arg_18] ; rcx = pointer to stack that contians all register values
			.text:FFFFF8000023743B                 mov     rdx, [rsp+arg_28]
			.text:FFFFF80000237440                 call    vmexit_c_handler	 ; RIP relative call
			.text:FFFFF80000237445                 jmp     loc_FFFFF80000237100
		*/

		UINT64 VmExitHandlerCall = ((UINT64)VmExitHandler) + 19; // + 19 bytes to -> call vmexit_c_handler
		UINT64 VmExitHandlerCallRip = (UINT64)VmExitHandlerCall + 5; // + 5 bytes because "call vmexit_c_handler" is 5 bytes
		UINT64 VmExitFunction = VmExitHandlerCallRip + *(INT32*)((UINT64)(VmExitHandlerCall + 1)); // + 1 to skip E8 (call) and read 4 bytes (RVA)
		VoyagerData->VmExitHandlerRva = ((UINT64)PayLoadEntry(PayLoadBase)) - (UINT64)VmExitFunction;
	}
	else // else AMD
	{
		VOID* VmExitHandlerCall =
			FindPattern(
				HypervAlloc,
				HypervAllocSize,
				AMD_VMEXIT_HANDLER_SIG,
				AMD_VMEXIT_HANDLER_MASK
			);

		UINT64 VmExitHandlerCallRip = (UINT64)VmExitHandlerCall + 5; // + 5 bytes because "call vmexit_c_handler" is 5 bytes
		UINT64 VmExitHandlerFunc = VmExitHandlerCallRip + *(INT32*)((UINT64)VmExitHandlerCall + 1); // + 1 to skip E8 (call) and read 4 bytes (RVA)
		VoyagerData->VmExitHandlerRva = ((UINT64)PayLoadEntry(PayLoadBase)) - VmExitHandlerFunc;
	}
}

VOID* HookVmExit(VOID* HypervBase, VOID* HypervSize, VOID* VmExitHook)
{
	VOID* VmExitHandler =
		FindPattern(
			HypervBase,
			HypervSize,
			INTEL_VMEXIT_HANDLER_SIG,
			INTEL_VMEXIT_HANDLER_MASK
		);

	if (VmExitHandler)
	{
		/*
			.text:FFFFF80000237436                 mov     rcx, [rsp+arg_18] ; rcx = pointer to stack that contians all register values
			.text:FFFFF8000023743B                 mov     rdx, [rsp+arg_28]
			.text:FFFFF80000237440                 call    vmexit_c_handler	 ; RIP relative call
			.text:FFFFF80000237445                 jmp     loc_FFFFF80000237100
		*/

		UINT64 VmExitHandlerCall = ((UINT64)VmExitHandler) + 19; // + 19 bytes to -> call vmexit_c_handler
		UINT64 VmExitHandlerCallRip = (UINT64)VmExitHandlerCall + 5; // + 5 bytes because "call vmexit_c_handler" is 5 bytes
		UINT64 VmExitFunction = VmExitHandlerCallRip + *(INT32*)((UINT64)(VmExitHandlerCall + 1)); // + 1 to skip E8 (call) and read 4 bytes (RVA)
		INT32 NewVmExitRVA = ((INT64)VmExitHook) - VmExitHandlerCallRip;
		*(INT32*)((UINT64)(VmExitHandlerCall + 1)) = NewVmExitRVA;
		return VmExitFunction;
	}
	else // else AMD
	{
		VOID* VmExitHandlerCall =
			FindPattern(
				HypervBase,
				HypervSize,
				AMD_VMEXIT_HANDLER_SIG,
				AMD_VMEXIT_HANDLER_MASK
			);

		UINT64 VmExitHandlerCallRip = ((UINT64)VmExitHandlerCall) + 5; // + 5 bytes to next instructions address...
		UINT64 VmExitHandlerFunction = VmExitHandlerCallRip + *(INT32*)(((UINT64)VmExitHandlerCall) + 1); // + 1 to skip E8 (call) and read 4 bytes (RVA)
		INT32 NewVmExitHandlerRVA = ((INT64)VmExitHook) - VmExitHandlerCallRip;
		*(INT32*)((UINT64)VmExitHandlerCall + 1) = NewVmExitHandlerRVA;
		return VmExitHandlerFunction;
	}
}
```

`Hv.h`:

```h
#pragma once
#include "PayLoad.h"

extern PVOYAGER_T PayLoadDataPtr;
#if WINVER == 2004
#define INTEL_VMEXIT_HANDLER_SIG "\x65\xC6\x04\x25\x6D\x00\x00\x00\x00\x48\x8B\x4C\x24\x00\x48\x8B\x54\x24\x00\xE8\x00\x00\x00\x00\xE9"
#define INTEL_VMEXIT_HANDLER_MASK "xxxxxxxxxxxxx?xxxx?x????x"
#elif WINVER == 1909
#define INTEL_VMEXIT_HANDLER_SIG "\x48\x8B\x4C\x24\x00\xEB\x07\xE8\x00\x00\x00\x00\xEB\xF2\x48\x8B\x54\x24\x00\xE8\x00\x00\x00\x00\xE9"
#define INTEL_VMEXIT_HANDLER_MASK "xxxx?xxx????xxxxxx?x????x"
#elif WINVER == 1903
#define INTEL_VMEXIT_HANDLER_SIG "\x48\x8B\x4C\x24\x00\xEB\x07\xE8\x00\x00\x00\x00\xEB\xF2\x48\x8B\x54\x24\x00\xE8\x00\x00\x00\x00\xE9"
#define INTEL_VMEXIT_HANDLER_MASK "xxxx?xxx????xxxxxx?x????x"
#elif WINVER == 1809
#define INTEL_VMEXIT_HANDLER_SIG "\x48\x8B\x4C\x24\x00\xEB\x07\xE8\x00\x00\x00\x00\xEB\xF2\x48\x8B\x54\x24\x00\xE8\x00\x00\x00\x00\xE9"
#define INTEL_VMEXIT_HANDLER_MASK "xxxx?xxx????xxxxxx?x????x"
#elif WINVER == 1803
#define INTEL_VMEXIT_HANDLER_SIG "\xF2\x80\x3D\xFC\x12\x46\x00\x00\x0F\x84\x00\x00\x00\x00\x48\x8B\x54\x24\x00\xE8\x00\x00\x00\x00\xE9"
#define INTEL_VMEXIT_HANDLER_MASK "xxxxxxx?xx????xxxx?x????x"
#elif WINVER <= 1709 && WINVER != 1507
#define INTEL_VMEXIT_HANDLER_SIG "\xD0\x80\x00\x00\x00\x00\x00\x00\x0F\x84\x00\x00\x00\x00\x48\x8B\x54\x24\x00\xE8\x00\x00\x00\x00\xE9"
#define INTEL_VMEXIT_HANDLER_MASK "xx????x?xx????xxxx?x????x"
#elif WINVER == 1507
#define INTEL_VMEXIT_HANDLER_SIG "\x60\xC0\x0F\x29\x68\xD0\x80\x3D\x7E\xAF\x49\x00\x01\x0F\x84\x00\x00\x00\x00\xE8\x00\x00\x00\x00\xE9"
#define INTEL_VMEXIT_HANDLER_MASK "xxxxxxxxxxxxxxx????x????x"
#endif

#define AMD_VMEXIT_HANDLER_SIG "\xE8\x00\x00\x00\x00\x48\x89\x04\x24\xE9"
#define AMD_VMEXIT_HANDLER_MASK "x????xxxxx"

static_assert(sizeof(AMD_VMEXIT_HANDLER_SIG) == sizeof(AMD_VMEXIT_HANDLER_MASK), "signature does not match mask size!");

#define HV_ALLOC_SIZE 0x1400000
static_assert(sizeof(INTEL_VMEXIT_HANDLER_SIG) == sizeof(INTEL_VMEXIT_HANDLER_MASK), "signature does not match mask size!");
static_assert(sizeof(INTEL_VMEXIT_HANDLER_SIG) == 26, "signature is invalid length!");

/// <summary>
/// manually map module into hyper-v's extended relocation section...
/// </summary>
/// <param name="VoyagerData">all the data needed to map the module...</param>
/// <param name="ImageBase">base address of the payload...</param>
/// <returns></returns>
VOID* MapModule(PVOYAGER_T VoyagerData, UINT8* ImageBase);

/// <summary>
/// hook vmexit handler...
/// </summary>
/// <param name="HypervBase">base address of hyper-v</param>
/// <param name="HypervSize">hyper-v size (SizeOfImage in memory)</param>
/// <param name="VmExitHook">vmexit hook function address (where to jump too)</param>
/// <returns></returns>
VOID* HookVmExit(VOID* HypervBase, VOID* HypervSize, VOID* VmExitHook);

/// <summary>
/// populates a VOYAGER_T structure passed by reference...
/// </summary>
/// <param name="VoyagerData">pass by ref VOYAGER_T...</param>
/// <param name="HypervAlloc">hyper-v module base...</param>
/// <param name="HypervAllocSize">hyper-v module size...</param>
/// <param name="PayLoadBase">payload base address...</param>
/// <param name="PayLoadSize">payload module size...</param>
VOID MakeVoyagerData
(
	PVOYAGER_T VoyagerData,
	VOID* HypervAlloc,
	UINT64 HypervAllocSize,
	VOID* PayLoadBase,
	UINT64 PayLoadSize
);
```

`HvLoader.c`:

```c
#include "HvLoader.h"

INLINE_HOOK HvLoadImageHook;
INLINE_HOOK HvLoadImageBufferHook;
INLINE_HOOK HvLoadAllocImageHook;
INLINE_HOOK TransferControlShitHook;

BOOLEAN HvExtendedAllocation = FALSE;
BOOLEAN HvHookedHyperV = FALSE;
MAP_PHYSICAL MmMapPhysicalMemory;

EFI_STATUS EFIAPI HvBlImgLoadPEImageFromSourceBuffer
(
	VOID* a1,
	VOID* a2,
	VOID* a3, 
	VOID* a4, 
	UINT64* ImageBase,
	UINT32* ImageSize, 
	VOID* a7,
	VOID* a8, 
	VOID* a9, 
	VOID* a10,
	VOID* a11,
	VOID* a12, 
	VOID* a13,
	VOID* a14,
	VOID* a15
)
{
	// disable hook and call the original...
	DisableInlineHook(&HvLoadImageBufferHook);
	EFI_STATUS Result = ((HV_LDR_LOAD_IMAGE_BUFFER)HvLoadImageBufferHook.Address)
	(
		a1,
		a2,
		a3,
		a4,
		ImageBase,
		ImageSize,
		a7,
		a8,
		a9,
		a10,
		a11,
		a12,
		a13,
		a14,
		a15
	);

	// keep hooking until we have extended hyper-v allocation and hooked into hyper-v...
	if(!HvExtendedAllocation && !HvHookedHyperV)
		EnableInlineHook(&HvLoadImageBufferHook);

	if (HvExtendedAllocation && !HvHookedHyperV)
	{
		HvHookedHyperV = TRUE;
		VOYAGER_T VoyagerData;

		// add a new section to hyper-v called "payload", then fill in voyager data
		// and hook the vmexit handler...
		MakeVoyagerData
		(
			&VoyagerData,
			*ImageBase,
			*ImageSize,
			AddSection
			(
				*ImageBase,
				"payload",
				PayLoadSize(),
				SECTION_RWX
			),
			PayLoadSize()
		);

		HookVmExit
		(
			VoyagerData.HypervModuleBase,
			VoyagerData.HypervModuleSize,
			MapModule(&VoyagerData, PayLoad)
		);

		// extend the size of the image in hyper-v's nt headers and LDR data entry...
		// this is required, if this is not done, then hyper-v will simply not be loaded...
		*ImageSize += NT_HEADER(*ImageBase)->OptionalHeader.SizeOfImage;
	}
	return Result;
}

EFI_STATUS EFIAPI HvBlImgLoadPEImageEx
(
	VOID* DeviceId,
	VOID* MemoryType, 
	CHAR16* Path,
	UINT64* ImageBase,
	UINT32* ImageSize,
	VOID* Hash,
	VOID* Flags,
	VOID* a8,
	VOID* a9, 
	VOID* a10,
	VOID* a11, 
	VOID* a12, 
	VOID* a13
)
{
	// disable shithook and call the original...
	DisableInlineHook(&HvLoadImageHook);
	EFI_STATUS Result = ((HV_LDR_LOAD_IMAGE)HvLoadImageHook.Address)
	(
		DeviceId,
		MemoryType, 
		Path, 
		ImageBase, 
		ImageSize, 
		Hash, 
		Flags,
		a8,
		a9,
		a10,
		a11, 
		a12, 
		a13
	);

	// keep hooking until we have extended hyper-v allocation and hooked into hyper-v...
	if(!HvExtendedAllocation && !HvHookedHyperV)
		EnableInlineHook(&HvLoadImageHook);

	if (HvExtendedAllocation && !HvHookedHyperV)
	{
		HvHookedHyperV = TRUE;
		VOYAGER_T VoyagerData;

		// add a new section to hyper-v called "payload", then fill in voyager data
		// and hook the vmexit handler...
		MakeVoyagerData
		(
			&VoyagerData,
			*ImageBase,
			*ImageSize,
			AddSection
			(
				*ImageBase,
				"payload",
				PayLoadSize(),
				SECTION_RWX
			),
			PayLoadSize()
		);

		HookVmExit
		(
			VoyagerData.HypervModuleBase,
			VoyagerData.HypervModuleSize,
			MapModule(&VoyagerData, PayLoad)
		);

		// extend the size of the image in hyper-v's nt headers and LDR data entry...
		// this is required, if this is not done, then hyper-v will simply not be loaded...
		*ImageSize = NT_HEADER(*ImageBase)->OptionalHeader.SizeOfImage;
	}
	return Result;
}

UINT64 EFIAPI HvBlImgAllocateImageBuffer
(
	VOID** imageBuffer, 
	UINTN imageSize,
	UINT32 memoryType,
	UINT32 attributes,
	VOID* unused, 
	UINT32 Value
)
{
	if (imageSize >= HV_ALLOC_SIZE && !HvExtendedAllocation)
	{
		HvExtendedAllocation = TRUE;
		imageSize += PayLoadSize();

		// allocate the entire hyper-v module as rwx...
		memoryType = BL_MEMORY_ATTRIBUTE_RWX;
	}

	// disable shithook and call the original function....
	DisableInlineHook(&HvLoadAllocImageHook);
	UINT64 Result = ((ALLOCATE_IMAGE_BUFFER)HvLoadAllocImageHook.Address)
	(
		imageBuffer, 
		imageSize,
		memoryType,
		attributes,
		unused, 
		Value
	);

	// continue shithooking this function until we have extended the allocation of hyper-v...
	if(!HvExtendedAllocation)
		EnableInlineHook(&HvLoadAllocImageHook);

	return Result;
	
	// x64-86 supported
}

```

`HvLoader.h`:

```h
#pragma once
#include "PayLoad.h"
#include "Hv.h"
#include "InlineHook.h"
#include "PagingTables.h"

extern INLINE_HOOK HvLoadImageHook;
extern INLINE_HOOK HvLoadAllocImageHook;
extern INLINE_HOOK HvLoadImageBufferHook;
extern INLINE_HOOK TransferControlShitHook;

#define HV_ALLOCATE_IMAGE_BUFFER_SIG "\xE8\x00\x00\x00\x00\x8B\xF8\x85\xC0\x79\x0A"
#define HV_ALLOCATE_IMAGE_BUFFER_MASK "x????xxxxxx"
static_assert(sizeof(HV_ALLOCATE_IMAGE_BUFFER_SIG) == sizeof(HV_ALLOCATE_IMAGE_BUFFER_MASK), "signature and mask do not match size!");

#define HV_LOAD_PE_IMG_FROM_BUFFER_SIG "\xE8\x00\x00\x00\x00\x44\x8B\xAD"
#define HV_LOAD_PE_IMG_FROM_BUFFER_MASK "x????xxx"
static_assert(sizeof(HV_LOAD_PE_IMG_FROM_BUFFER_SIG) == sizeof(HV_LOAD_PE_IMG_FROM_BUFFER_MASK), "signature and mask do not match size!");

#define HV_LOAD_PE_IMG_SIG "\x48\x89\x44\x24\x00\xE8\x00\x00\x00\x00\x44\x8B\xF0\x85\xC0\x0F\x88\x00\x00\x00\x00\x4C\x8D\x45"
#define HV_LOAD_PE_IMG_MASK "xxxx?x????xxxxxxx????xxx"
static_assert(sizeof(HV_LOAD_PE_IMG_SIG) == sizeof(HV_LOAD_PE_IMG_MASK), "signature and mask do not match size...");

typedef EFI_STATUS(EFIAPI* ALLOCATE_IMAGE_BUFFER)(VOID** imageBuffer, UINTN imageSize, UINT32 memoryType, 
	UINT32 attributes, VOID* unused, UINT32 Value);

typedef EFI_STATUS(EFIAPI* HV_LDR_LOAD_IMAGE_BUFFER)(VOID* a1, VOID* a2, VOID* a3, VOID* a4, UINT64* ImageBase,
	UINT32* ImageSize, VOID* a7, VOID* a8, VOID* a9, VOID* a10, VOID* a11, VOID* a12, VOID* a13, VOID* a14, VOID* a15);

typedef EFI_STATUS(EFIAPI* HV_LDR_LOAD_IMAGE)(VOID* DeviceId, VOID* MemoryType, CHAR16* Path, VOID** ImageBase, UINT32* ImageSize,
	VOID* Hash, VOID* Flags, VOID* a8, VOID* a9, VOID* a10, VOID* a11, VOID* a12, VOID* a13);

/// <summary>
/// hook on hvloader.BlImgAllocateImageBuffer, hooked to extend the 
/// allocation size....
/// </summary>
/// <param name="imageBuffer">pass by ref pointer to allocations base...</param>
/// <param name="imageSize">size of allocation...</param>
/// <param name="memoryType"></param>
/// <param name="attributes"></param>
/// <param name="unused"></param>
/// <param name="flags"></param>
/// <returns></returns>
UINT64 EFIAPI HvBlImgAllocateImageBuffer
(
	VOID** imageBuffer,
	UINTN imageSize, 
	UINT32 memoryType,
	UINT32 attributes, 
	VOID* unused,
	UINT32 Value
);

/// <summary>
/// hook on hvloader.BlImgLoadPEImageEx... hyper-v is loaded into memory
/// by this function so im hooking it to extend it/inject into it.
/// </summary>
/// <param name="DeviceId"></param>
/// <param name="MemoryType"></param>
/// <param name="Path"></param>
/// <param name="ImageBase"></param>
/// <param name="ImageSize"></param>
/// <param name="Hash"></param>
/// <param name="Flags"></param>
/// <param name="a8"></param>
/// <param name="a9"></param>
/// <param name="a10"></param>
/// <param name="a11"></param>
/// <param name="a12"></param>
/// <param name="a13"></param>
/// <returns></returns>
EFI_STATUS EFIAPI HvBlImgLoadPEImageEx
(
	VOID* DeviceId, 
	VOID* MemoryType,
	CHAR16* Path,
	UINT64* ImageBase,
	UINT32* ImageSize,
	VOID* Hash,
	VOID* Flags,
	VOID* a8,
	VOID* a9,
	VOID* a10,
	VOID* a11,
	VOID* a12,
	VOID* a13
);

/// <summary>
/// for some reason 1703 hvloader.BlImgLoadPEImageFromSourceBuffer is called
/// to load hyper-v into memory... Hooking this like i hook hvloader.BlImgLoadPEImageEx...
/// </summary>
/// <param name="a1"></param>
/// <param name="a2"></param>
/// <param name="a3"></param>
/// <param name="a4"></param>
/// <param name="ImageBase"></param>
/// <param name="ImageSize"></param>
/// <param name="a7"></param>
/// <param name="a8"></param>
/// <param name="a9"></param>
/// <param name="a10"></param>
/// <param name="a11"></param>
/// <param name="a12"></param>
/// <param name="a13"></param>
/// <param name="a14"></param>
/// <param name="a15"></param>
/// <returns></returns>
EFI_STATUS EFIAPI HvBlImgLoadPEImageFromSourceBuffer
(
	VOID* a1,
	VOID* a2,
	VOID* a3, 
	VOID* a4,
	UINT64* ImageBase,
	UINT32* ImageSize,
	VOID* a7,
	VOID* a8,
	VOID* a9, 
	VOID* a10,
	VOID* a11,
	VOID* a12, 
	VOID* a13, 
	VOID* a14,
	VOID* a15
);
```

`InlineHook.c`:

```c
#include "InlineHook.h"

// x64-86 Compatible

VOID MakeInlineHook(PINLINE_HOOK_T Hook, VOID* HookFrom, VOID* HookTo, BOOLEAN Install)
{
	unsigned char JmpCode[14] =
	{
		0xff, 0x25, 0x0, 0x0, 0x0, 0x0,		// jmp    QWORD PTR[rip + 0x0]

		// jmp address...
		0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0
	};

	// save original bytes, and hook related addresses....
	Hook->Address = HookFrom;
	Hook->HookAddress = HookTo;
	MemCopy(Hook->Code, HookFrom, sizeof Hook->Code);

	// setup hook...
	MemCopy(JmpCode + 6, &HookTo, sizeof HookTo);
	MemCopy(Hook->JmpCode, JmpCode, sizeof JmpCode);
	if (Install) EnableInlineHook(Hook);
}

VOID EnableInlineHook(PINLINE_HOOK_T Hook)
{
	MemCopy(Hook->Address, Hook->JmpCode, sizeof Hook->JmpCode);
}

VOID DisableInlineHook(PINLINE_HOOK_T Hook)
{
	MemCopy(Hook->Address, Hook->Code, sizeof Hook->Code);
}

```

`InlineHook.h`:

```h
#pragma once
#include "Utils.h"

typedef struct _INLINE_HOOK
{
	unsigned char Code[14];
	unsigned char JmpCode[14];

	void* Address;
	void* HookAddress;
} INLINE_HOOK, *PINLINE_HOOK_T;

VOID MakeInlineHook(PINLINE_HOOK_T Hook, VOID* HookFrom, VOID* HookTo, BOOLEAN Install);
VOID EnableInlineHook(PINLINE_HOOK_T Hook);
VOID DisableInlineHook(PINLINE_HOOK_T Hook);
```

`LICENSE`:

```
MIT License

Copyright (c) 2022 StormFN

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`PagingTables.h`:

```h
#pragma once
#include "Utils.h"

#define MAP_PHYSICAL_SIG "\xE8\x00\x00\x00\x00\x85\xC0\x0F\x88\x00\x00\x00\x00\x48\x8B\xBC\x24"
#define MAP_PHYSICAL_MASK "x????xxxx????xxxx"
static_assert(sizeof(MAP_PHYSICAL_SIG) == sizeof(MAP_PHYSICAL_MASK), "signature and mask do not patch sizes...\n");

typedef EFI_STATUS(EFIAPI* MAP_PHYSICAL)
(
    VOID** VirtualAddress, 
    VOID* PhysicalAddress,
    UINTN Size,
    VOID* Unknown,
    VOID* Unknown2
);
extern MAP_PHYSICAL MmMapPhysicalMemory;

typedef union _CR3
{
    UINTN Value;
    struct
    {
        UINTN reserved1 : 3;
        UINTN PageLevelWriteThrough : 1;
        UINTN PageLevelCacheDisable : 1;
        UINTN reserved2 : 7;
        UINTN Pml4Pfn : 36;
        UINTN reserved3 : 16;
    };
} CR3;

typedef union _VIRT_ADDR_T
{
    void* Value;
    struct
    {
        UINT64 offset : 12;
        UINT64 PtIdx : 9;
        UINT64 PdIdx : 9;
        UINT64 PdptIdx : 9;
        UINT64 Pml4Idx : 9;
        UINT64 reserved : 16;
    };
} VIRT_ADDR_T, *PVIRT_ADDR_T;


typedef union _PML4E_T
{
    UINT64 Value;
    struct
    {
        UINT64 Present : 1;          // Must be 1, region invalid if 0.
        UINT64 ReadWrite : 1;        // If 0, writes not allowed.
        UINT64 UserSuperVisor : 1;   // If 0, user-mode accesses not allowed.
        UINT64 page_write_through : 1; // Determines the memory type used to access PDPT.
        UINT64 page_cache : 1; // Determines the memory type used to access PDPT.
        UINT64 accessed : 1;         // If 0, this entry has not been used for translation.
        UINT64 ignore_1 : 1;
        UINT64 LargePage : 1;         // Must be 0 for PML4E.
        UINT64 ignore_2 : 4;
        UINT64 Pfn : 36; // The page frame number of the PDPT of this PML4E.
        UINT64 reserved : 4;
        UINT64 ignore_3 : 11;
        UINT64 nx : 1; // If 1, instruction fetches not allowed.
    };
} PML4E_T, * PPML4E_T;

typedef union _PDPTE
{
    UINT64 Value;
    struct
    {
        UINT64 Present : 1;          // Must be 1, region invalid if 0.
        UINT64 ReadWrite : 1;        // If 0, writes not allowed.
        UINT64 UserSuperVisor : 1;   // If 0, user-mode accesses not allowed.
        UINT64 page_write_through : 1; // Determines the memory type used to access PD.
        UINT64 page_cache : 1; // Determines the memory type used to access PD.
        UINT64 accessed : 1;         // If 0, this entry has not been used for translation.
        UINT64 ignore_1 : 1;
        UINT64 LargePage : 1;         // If 1, this entry maps a 1GB page.
        UINT64 ignore_2 : 4;
        UINT64 Pfn : 36; // The page frame number of the PD of this PDPTE.
        UINT64 reserved : 4;
        UINT64 ignore_3 : 11;
        UINT64 nx : 1; // If 1, instruction fetches not allowed.
    };
} PDPTE_T, * PPDPTE_T;

typedef union _PDE
{
    UINT64 Value;
    struct
    {
        UINT64 Present : 1;          // Must be 1, region invalid if 0.
        UINT64 ReadWrite : 1;        // If 0, writes not allowed.
        UINT64 UserSuperVisor : 1;   // If 0, user-mode accesses not allowed.
        UINT64 page_write_through : 1; // Determines the memory type used to access PT.
        UINT64 page_cache : 1; // Determines the memory type used to access PT.
        UINT64 accessed : 1;         // If 0, this entry has not been used for translation.
        UINT64 ignore_1 : 1;
        UINT64 LargePage : 1; // If 1, this entry maps a 2MB page.
        UINT64 ignore_2 : 4;
        UINT64 Pfn : 36; // The page frame number of the PT of this PDE.
        UINT64 reserved : 4;
        UINT64 ignore_3 : 11;
        UINT64 nx : 1; // If 1, instruction fetches not allowed.
    };
} PDE_T, * PPDE_T;

typedef union _PTE
{
    UINT64 Value;
    struct
    {
        UINT64 Present : 1;          // Must be 1, region invalid if 0.
        UINT64 ReadWrite : 1;        // If 0, writes not allowed.
        UINT64 UserSuperVisor : 1;   // If 0, user-mode accesses not allowed.
        UINT64 page_write_through : 1; // Determines the memory type used to access the memory.
        UINT64 page_cache : 1; // Determines the memory type used to access the memory.
        UINT64 accessed : 1;         // If 0, this entry has not been used for translation.
        UINT64 dirty : 1;            // If 0, the memory backing this page has not been written to.
        UINT64 access_type : 1;   // Determines the memory type used to access the memory.
        UINT64 global : 1;           // If 1 and the PGE bit of CR4 is set, translations are global.
        UINT64 ignore_2 : 3;
        UINT64 Pfn : 36; // The page frame number of the backing physical page.
        UINT64 reserved : 4;
        UINT64 ignore_3 : 7;
        UINT64 pk : 4;  // If the PKE bit of CR4 is set, determines the protection key.
        UINT64 nx : 1; // If 1, instruction fetches not allowed.
    };
} PTE_T, *PPTE_T;

typedef struct _TABLE_ENTRIES
{
    PML4E_T Pml4Entry;
    PDPTE_T PdptEntry;
    PDE_T PdEntry;
    PTE_T PtEntry;
} TABLE_ENTRIES, *PTABLE_ENTRIES;
```

`PayLoad (AMD)/PayLoad (AMD).vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="1507|x64">
      <Configuration>1507</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1511|x64">
      <Configuration>1511</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1607|x64">
      <Configuration>1607</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1703|x64">
      <Configuration>1703</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1709|x64">
      <Configuration>1709</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1803|x64">
      <Configuration>1803</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1809|x64">
      <Configuration>1809</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1903|x64">
      <Configuration>1903</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1909|x64">
      <Configuration>1909</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="2004|x64">
      <Configuration>2004</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>PayLoad__AMD_</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1909|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1903|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1809|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1803|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1709|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1703|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1607|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1507|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='2004|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1909|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1903|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1809|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1803|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1709|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1703|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1607|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1507|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='2004|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1909|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <TreatWarningAsError>false</TreatWarningAsError>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);WINVER=1909;</PreprocessorDefinitions>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ExceptionHandling>false</ExceptionHandling>
    </ClCompile>
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1903|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <TreatWarningAsError>false</TreatWarningAsError>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);WINVER=1903;</PreprocessorDefinitions>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ExceptionHandling>false</ExceptionHandling>
    </ClCompile>
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1809|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <TreatWarningAsError>false</TreatWarningAsError>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);WINVER=1809;</PreprocessorDefinitions>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ExceptionHandling>false</ExceptionHandling>
    </ClCompile>
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1803|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <TreatWarningAsError>false</TreatWarningAsError>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);WINVER=1803;</PreprocessorDefinitions>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ExceptionHandling>false</ExceptionHandling>
    </ClCompile>
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1709|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <TreatWarningAsError>false</TreatWarningAsError>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);WINVER=1709</PreprocessorDefinitions>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ExceptionHandling>false</ExceptionHandling>
    </ClCompile>
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1703|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <TreatWarningAsError>false</TreatWarningAsError>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);WINVER=1703</PreprocessorDefinitions>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ExceptionHandling>false</ExceptionHandling>
    </ClCompile>
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1607|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <TreatWarningAsError>false</TreatWarningAsError>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);WINVER=1607</PreprocessorDefinitions>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ExceptionHandling>false</ExceptionHandling>
    </ClCompile>
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <TreatWarningAsError>false</TreatWarningAsError>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);WINVER=1511;</PreprocessorDefinitions>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ExceptionHandling>false</ExceptionHandling>
    </ClCompile>
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1507|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <TreatWarningAsError>false</TreatWarningAsError>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);WINVER=1507;</PreprocessorDefinitions>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ExceptionHandling>false</ExceptionHandling>
    </ClCompile>
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='2004|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <TreatWarningAsError>false</TreatWarningAsError>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);WINVER=2004;</PreprocessorDefinitions>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ExceptionHandling>false</ExceptionHandling>
    </ClCompile>
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="debug.h" />
    <ClInclude Include="ia32.hpp" />
    <ClInclude Include="mm.h" />
    <ClInclude Include="types.h" />
    <ClInclude Include="vmexit.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="debug.cpp" />
    <ClCompile Include="mm.cpp" />
    <ClCompile Include="vmexit.cpp" />
    <ClCompile Include="vmexit_handler.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`PayLoad (AMD)/PayLoad (AMD).vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="types.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ia32.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="debug.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="mm.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="vmexit.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="vmexit_handler.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="debug.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="mm.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="vmexit.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`PayLoad (AMD)/PayLoad (AMD).vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`PayLoad (AMD)/debug.cpp`:

```cpp
#include "debug.h"

auto dbg::debug_print_decimal(long long number) -> void
{
    if (number < 0) 
    {
        __outbyte(PORT_NUM, '-');
        number = -number;
    }

    for (auto d = 1000000000000000000; d != 0; d /= 10) 
        if ((number / d) != 0)
            __outbyte(PORT_NUM, alphabet[(number / d) % 10]);
}

auto dbg::debug_print_hex(u64 number, const bool show_zeros) -> void
{
    for (auto d = 0x1000000000000000; d != 0; d /= 0x10) 
        if (show_zeros || (number / d) != 0) 
            __outbyte(PORT_NUM, alphabet[(number / d) % 0x10]);
}

auto dbg::print(const char* format, ...) -> void
{
    va_list args;
    va_start(args, format);

    while (format[0]) 
    {
        if (format[0] == '%') 
        {
            switch (format[1]) 
            {
            case 'd':
                debug_print_decimal(va_arg(args, int));
                format += 2;
                continue;
            case 'x':
                debug_print_hex(va_arg(args, u32), false);
                format += 2;
                continue;
            case 'l':
                if (format[2] == 'l') 
                {
                    switch (format[3]) 
                    {
                    case 'd':
                        debug_print_decimal(va_arg(args, u64));
                        format += 4;
                        continue;
                    case 'x':
                        debug_print_hex(va_arg(args, u64), false);
                        format += 4;
                        continue;
                    }
                }
                break;
            case 'p':
                debug_print_hex(va_arg(args, u64), true);
                format += 2;
                continue;
            }
        }

        __outbyte(PORT_NUM, format[0]);
        ++format;
    }
    va_end(args);
}
```

`PayLoad (AMD)/debug.h`:

```h
#pragma once
#include <stdarg.h>
#include <stddef.h>
#include "types.h"

#define PORT_NUM 0x2F8
namespace dbg
{
	constexpr char alphabet[] = "0123456789ABCDEF";
	auto debug_print_decimal(long long number) -> void;
	auto debug_print_hex(u64 number, const bool show_zeros) -> void;
	auto print(const char* format, ...) -> void;
}
```

`PayLoad (AMD)/ia32.hpp`:

```hpp
/** @file */
#pragma once
using UINT8_t = unsigned char;
using UINT16_t = unsigned short;
using UINT32_t = unsigned int;
using UINT64_t = unsigned long long;

/**
 * @defgroup intel_manual \
 *           Intel Manual
 *
 * @remarks All references are based on <b>Intel(R) 64 and IA-32 architectures software developer's manual combined volumes:
 *          1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4</b> (May 2018).
 * @{
 */
 /**
  * @defgroup control_registers \
  *           Control registers
  *
  * Control registers (CR0, CR1, CR2, CR3, and CR4) determine operating mode of the processor and the characteristics of the
  * currently executing task. These registers are 32 bits in all 32-bit modes and compatibility mode.
  * In 64-bit mode, control registers are expanded to 64 bits. The MOV CRn instructions are used to manipulate the register
  * bits. Operand-size prefixes for these instructions are ignored. The following is also true:
  * - The control registers can be read and loaded (or modified) using the move-to-or-from-control-registers forms of the
  * MOV instruction. In protected mode, the MOV instructions allow the control registers to be read or loaded (at privilege
  * level 0 only). This restriction means that application programs or operating-system procedures (running at privilege
  * levels 1, 2, or 3) are prevented from reading or loading the control registers.
  * - Bits 63:32 of CR0 and CR4 are reserved and must be written with zeros. Writing a nonzero value to any of the upper 32
  * bits results in a general-protection exception, \#GP(0).
  * - All 64 bits of CR2 are writable by software.
  * - Bits 51:40 of CR3 are reserved and must be 0.
  * - The MOV CRn instructions do not check that addresses written to CR2 and CR3 are within the linear-address or
  * physical-address limitations of the implementation.
  * - Register CR8 is available in 64-bit mode only. The control registers are summarized below, and each architecturally
  * defined control field in these control registers is described individually.
  * - CR0 - Contains system control flags that control operating mode and states of the processor.
  * - CR1 - Reserved.
  * - CR2 - Contains the page-fault linear address (the linear address that caused a page fault).
  * - CR3 - Contains the physical address of the base of the paging-structure hierarchy and two flags (PCD and PWT). Only
  * the most-significant bits (less the lower 12 bits) of the base address are specified; the lower 12 bits of the address
  * are assumed to be 0. The first paging structure must thus be aligned to a page (4-KByte) boundary. The PCD and PWT flags
  * control caching of that paging structure in the processor's internal data caches (they do not control TLB caching of
  * page-directory information). When using the physical address extension, the CR3 register contains the base address of
  * the page-directorypointer table. In IA-32e mode, the CR3 register contains the base address of the PML4 table.
  * - CR4 - Contains a group of flags that enable several architectural extensions, and indicate operating system or
  * executive support for specific processor capabilities.
  * - CR8 - Provides read and write access to the Task Priority Register (TPR). It specifies the priority threshold value
  * that operating systems use to control the priority class of external interrupts allowed to interrupt the processor. This
  * register is available only in 64-bit mode. However, interrupt filtering continues to apply in compatibility mode.
  *
  * @see Vol3A[2.5(CONTROL REGISTERS)] (reference)
  * @{
  */
typedef union
{
    UINT64_t flags;
    struct
    {
        /**
         * @brief Protection Enable
         *
         * [Bit 0] Enables protected mode when set; enables real-address mode when clear. This flag does not enable paging
         * directly. It only enables segment-level protection. To enable paging, both the PE and PG flags must be set.
         *
         * @see Vol3A[9.9(Mode Switching)]
         */
        UINT64_t protection_enable : 1;
#define CR0_PROTECTION_ENABLE_BIT                                    0
#define CR0_PROTECTION_ENABLE_FLAG                                   0x01
#define CR0_PROTECTION_ENABLE_MASK                                   0x01
#define CR0_PROTECTION_ENABLE(_)                                     (((_) >> 0) & 0x01)

        /**
         * @brief Monitor Coprocessor
         *
         * [Bit 1] Controls the interaction of the WAIT (or FWAIT) instruction with the TS flag (bit 3 of CR0). If the MP flag is
         * set, a WAIT instruction generates a device-not-available exception (\#NM) if the TS flag is also set. If the MP flag is
         * clear, the WAIT instruction ignores the setting of the TS flag.
         */
        UINT64_t monitor_coprocessor : 1;
#define CR0_MONITOR_COPROCESSOR_BIT                                  1
#define CR0_MONITOR_COPROCESSOR_FLAG                                 0x02
#define CR0_MONITOR_COPROCESSOR_MASK                                 0x01
#define CR0_MONITOR_COPROCESSOR(_)                                   (((_) >> 1) & 0x01)

        /**
         * @brief FPU Emulation
         *
         * [Bit 2] Indicates that the processor does not have an internal or external x87 FPU when set; indicates an x87 FPU is
         * present when clear. This flag also affects the execution of MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions.
         * When the EM flag is set, execution of an x87 FPU instruction generates a device-not-available exception (\#NM). This
         * flag must be set when the processor does not have an internal x87 FPU or is not connected to an external math
         * coprocessor. Setting this flag forces all floating-point instructions to be handled by software emulation.
         * Also, when the EM flag is set, execution of an MMX instruction causes an invalid-opcode exception (\#UD) to be
         * generated. Thus, if an IA-32 or Intel 64 processor incorporates MMX technology, the EM flag must be set to 0 to enable
         * execution of MMX instructions. Similarly for SSE/SSE2/SSE3/SSSE3/SSE4 extensions, when the EM flag is set, execution of
         * most SSE/SSE2/SSE3/SSSE3/SSE4 instructions causes an invalid opcode exception (\#UD) to be generated. If an IA-32 or
         * Intel 64 processor incorporates the SSE/SSE2/SSE3/SSSE3/SSE4 extensions, the EM flag must be set to 0 to enable
         * execution of these extensions. SSE/SSE2/SSE3/SSSE3/SSE4 instructions not affected by the EM flag include: PAUSE,
         * PREFETCHh, SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
         */
        UINT64_t emulate_fpu : 1;
#define CR0_EMULATE_FPU_BIT                                          2
#define CR0_EMULATE_FPU_FLAG                                         0x04
#define CR0_EMULATE_FPU_MASK                                         0x01
#define CR0_EMULATE_FPU(_)                                           (((_) >> 2) & 0x01)

        /**
         * @brief Task Switched
         *
         * [Bit 3] Allows the saving of the x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 context on a task switch to be delayed until an
         * x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction is actually executed by the new task. The processor sets this flag on
         * every task switch and tests it when executing x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions.
         * - If the TS flag is set and the EM flag (bit 2 of CR0) is clear, a device-not-available exception (\#NM) is raised prior
         * to the execution of any x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction; with the exception of PAUSE, PREFETCHh,
         * SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
         * - If the TS flag is set and the MP flag (bit 1 of CR0) and EM flag are clear, an \#NM exception is not raised prior to
         * the execution of an x87 FPU WAIT/FWAIT instruction.
         * - If the EM flag is set, the setting of the TS flag has no effect on the execution of x87
         * FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions.
         *   The processor does not automatically save the context of the x87 FPU, XMM, and MXCSR registers on a task switch.
         *   Instead, it sets the TS flag, which causes the processor to raise an \#NM exception whenever it encounters an x87
         *   FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction in the instruction stream for the new task (with the exception of the
         *   instructions listed above).
         *   The fault handler for the \#NM exception can then be used to clear the TS flag (with the CLTS instruction) and save
         *   the context of the x87 FPU, XMM, and MXCSR registers. If the task never encounters an x87
         *   FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction, the x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 context is never saved.
         */
        UINT64_t task_switched : 1;
#define CR0_TASK_SWITCHED_BIT                                        3
#define CR0_TASK_SWITCHED_FLAG                                       0x08
#define CR0_TASK_SWITCHED_MASK                                       0x01
#define CR0_TASK_SWITCHED(_)                                         (((_) >> 3) & 0x01)

        /**
         * @brief Extension Type
         *
         * [Bit 4] Reserved in the Pentium 4, Intel Xeon, P6 family, and Pentium processors. In the Pentium 4, Intel Xeon, and P6
         * family processors, this flag is hardcoded to 1. In the Intel386 and Intel486 processors, this flag indicates support of
         * Intel 387 DX math coprocessor instructions when set.
         */
        UINT64_t extension_type : 1;
#define CR0_EXTENSION_TYPE_BIT                                       4
#define CR0_EXTENSION_TYPE_FLAG                                      0x10
#define CR0_EXTENSION_TYPE_MASK                                      0x01
#define CR0_EXTENSION_TYPE(_)                                        (((_) >> 4) & 0x01)

        /**
         * @brief Numeric Error
         *
         * [Bit 5] Enables the native (internal) mechanism for reporting x87 FPU errors when set; enables the PC-style x87 FPU
         * error reporting mechanism when clear. When the NE flag is clear and the IGNNE\# input is asserted, x87 FPU errors are
         * ignored. When the NE flag is clear and the IGNNE\# input is deasserted, an unmasked x87 FPU error causes the processor
         * to assert the FERR\# pin to generate an external interrupt and to stop instruction execution immediately before
         * executing the next waiting floating-point instruction or WAIT/FWAIT instruction.
         * The FERR\# pin is intended to drive an input to an external interrupt controller (the FERR\# pin emulates the ERROR\#
         * pin of the Intel 287 and Intel 387 DX math coprocessors). The NE flag, IGNNE\# pin, and FERR\# pin are used with
         * external logic to implement PC-style error reporting. Using FERR\# and IGNNE\# to handle floating-point exceptions is
         * deprecated by modern operating systems; this non-native approach also limits newer processors to operate with one
         * logical processor active.
         *
         * @see Vol1[8.7(Handling x87 FPU Exceptions in Software)]
         * @see Vol1[A.1(APPENDIX A | EFLAGS Cross-Reference)]
         */
        UINT64_t numeric_error : 1;
#define CR0_NUMERIC_ERROR_BIT                                        5
#define CR0_NUMERIC_ERROR_FLAG                                       0x20
#define CR0_NUMERIC_ERROR_MASK                                       0x01
#define CR0_NUMERIC_ERROR(_)                                         (((_) >> 5) & 0x01)
        UINT64_t reserved1 : 10;

        /**
         * @brief Write Protect
         *
         * [Bit 16] When set, inhibits supervisor-level procedures from writing into readonly pages; when clear, allows
         * supervisor-level procedures to write into read-only pages (regardless of the U/S bit setting). This flag facilitates
         * implementation of the copy-onwrite method of creating a new process (forking) used by operating systems such as UNIX.
         *
         * @see Vol3A[4.1.3(Paging-Mode Modifiers)]
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        UINT64_t write_protect : 1;
#define CR0_WRITE_PROTECT_BIT                                        16
#define CR0_WRITE_PROTECT_FLAG                                       0x10000
#define CR0_WRITE_PROTECT_MASK                                       0x01
#define CR0_WRITE_PROTECT(_)                                         (((_) >> 16) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * @brief Alignment Mask
         *
         * [Bit 18] Enables automatic alignment checking when set; disables alignment checking when clear. Alignment checking is
         * performed only when the AM flag is set, the AC flag in the EFLAGS register is set, CPL is 3, and the processor is
         * operating in either protected or virtual-8086 mode.
         */
        UINT64_t alignment_mask : 1;
#define CR0_ALIGNMENT_MASK_BIT                                       18
#define CR0_ALIGNMENT_MASK_FLAG                                      0x40000
#define CR0_ALIGNMENT_MASK_MASK                                      0x01
#define CR0_ALIGNMENT_MASK(_)                                        (((_) >> 18) & 0x01)
        UINT64_t reserved3 : 10;

        /**
         * @brief Not Write-through
         *
         * [Bit 29] When the NW and CD flags are clear, write-back (for Pentium 4, Intel Xeon, P6 family, and Pentium processors)
         * or write-through (for Intel486 processors) is enabled for writes that hit the cache and invalidation cycles are enabled.
         */
        UINT64_t not_write_through : 1;
#define CR0_NOT_WRITE_THROUGH_BIT                                    29
#define CR0_NOT_WRITE_THROUGH_FLAG                                   0x20000000
#define CR0_NOT_WRITE_THROUGH_MASK                                   0x01
#define CR0_NOT_WRITE_THROUGH(_)                                     (((_) >> 29) & 0x01)

        /**
         * @brief Cache Disable
         *
         * [Bit 30] When the CD and NW flags are clear, caching of memory locations for the whole of physical memory in the
         * processor's internal (and external) caches is enabled. When the CD flag is set, caching is restricted. To prevent the
         * processor from accessing and updating its caches, the CD flag must be set and the caches must be invalidated so that no
         * cache hits can occur.
         *
         * @see Vol3A[11.5.3(Preventing Caching)]
         * @see Vol3A[11.5(CACHE CONTROL)]
         */
        UINT64_t cache_disable : 1;
#define CR0_CACHE_DISABLE_BIT                                        30
#define CR0_CACHE_DISABLE_FLAG                                       0x40000000
#define CR0_CACHE_DISABLE_MASK                                       0x01
#define CR0_CACHE_DISABLE(_)                                         (((_) >> 30) & 0x01)

        /**
         * @brief Paging Enable
         *
         * [Bit 31] Enables paging when set; disables paging when clear. When paging is disabled, all linear addresses are treated
         * as physical addresses. The PG flag has no effect if the PE flag (bit 0 of register CR0) is not also set; setting the PG
         * flag when the PE flag is clear causes a general-protection exception (\#GP).
         * On Intel 64 processors, enabling and disabling IA-32e mode operation also requires modifying CR0.PG.
         *
         * @see Vol3A[4(PAGING)]
         */
        UINT64_t paging_enable : 1;
#define CR0_PAGING_ENABLE_BIT                                        31
#define CR0_PAGING_ENABLE_FLAG                                       0x80000000
#define CR0_PAGING_ENABLE_MASK                                       0x01
#define CR0_PAGING_ENABLE(_)                                         (((_) >> 31) & 0x01)
        UINT64_t reserved4 : 32;
    };
} cr0;

typedef union
{
    UINT64_t flags;
    struct
    {
        UINT64_t reserved1 : 3;

        /**
         * @brief Page-level Write-Through
         *
         * [Bit 3] Controls the memory type used to access the first paging structure of the current paging-structure hierarchy.
         * This bit is not used if paging is disabled, with PAE paging, or with 4-level paging if CR4.PCIDE=1.
         *
         * @see Vol3A[4.9(PAGING AND MEMORY TYPING)]
         */
        UINT64_t page_level_write_through : 1;
#define CR3_PAGE_LEVEL_WRITE_THROUGH_BIT                             3
#define CR3_PAGE_LEVEL_WRITE_THROUGH_FLAG                            0x08
#define CR3_PAGE_LEVEL_WRITE_THROUGH_MASK                            0x01
#define CR3_PAGE_LEVEL_WRITE_THROUGH(_)                              (((_) >> 3) & 0x01)

        /**
         * @brief Page-level Cache Disable
         *
         * [Bit 4] Controls the memory type used to access the first paging structure of the current paging-structure hierarchy.
         * This bit is not used if paging is disabled, with PAE paging, or with 4-level paging2 if CR4.PCIDE=1.
         *
         * @see Vol3A[4.9(PAGING AND MEMORY TYPING)]
         */
        UINT64_t page_level_cache_disable : 1;
#define CR3_PAGE_LEVEL_CACHE_DISABLE_BIT                             4
#define CR3_PAGE_LEVEL_CACHE_DISABLE_FLAG                            0x10
#define CR3_PAGE_LEVEL_CACHE_DISABLE_MASK                            0x01
#define CR3_PAGE_LEVEL_CACHE_DISABLE(_)                              (((_) >> 4) & 0x01)
        UINT64_t reserved2 : 7;

        /**
         * @brief Address of page directory
         *
         * [Bits 47:12] Physical address of the 4-KByte aligned page directory (32-bit paging) or PML4 table (64-bit paging) used
         * for linear-address translation.
         *
         * @see Vol3A[4.3(32-BIT PAGING)]
         * @see Vol3A[4.5(4-LEVEL PAGING)]
         */
        UINT64_t pml4_pfn : 36;
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_BIT                            12
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_FLAG                           0xFFFFFFFFF000
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_MASK                           0xFFFFFFFFF
#define CR3_ADDRESS_OF_PAGE_DIRECTORY(_)                             (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved3 : 16;
    };
} cr3;

typedef union
{
    struct
    {
        /**
         * @brief Virtual-8086 Mode Extensions
         *
         * [Bit 0] Enables interrupt- and exception-handling extensions in virtual-8086 mode when set; disables the extensions when
         * clear. Use of the virtual mode extensions can improve the performance of virtual-8086 applications by eliminating the
         * overhead of calling the virtual- 8086 monitor to handle interrupts and exceptions that occur while executing an 8086
         * program and, instead, redirecting the interrupts and exceptions back to the 8086 program's handlers. It also provides
         * hardware support for a virtual interrupt flag (VIF) to improve reliability of running 8086 programs in multitasking and
         * multiple-processor environments.
         *
         * @see Vol3B[20.3(INTERRUPT AND EXCEPTION HANDLING IN VIRTUAL-8086 MODE)]
         */
        UINT64_t virtual_mode_extensions : 1;
#define CR4_VIRTUAL_MODE_EXTENSIONS_BIT                              0
#define CR4_VIRTUAL_MODE_EXTENSIONS_FLAG                             0x01
#define CR4_VIRTUAL_MODE_EXTENSIONS_MASK                             0x01
#define CR4_VIRTUAL_MODE_EXTENSIONS(_)                               (((_) >> 0) & 0x01)

        /**
         * @brief Protected-Mode Virtual Interrupts
         *
         * [Bit 1] Enables hardware support for a virtual interrupt flag (VIF) in protected mode when set; disables the VIF flag in
         * protected mode when clear.
         *
         * @see Vol3B[20.4(PROTECTED-MODE VIRTUAL INTERRUPTS)]
         */
        UINT64_t protected_mode_virtual_interrupts : 1;
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_BIT                    1
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_FLAG                   0x02
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_MASK                   0x01
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS(_)                     (((_) >> 1) & 0x01)

        /**
         * @brief Time Stamp Disable
         *
         * [Bit 2] Restricts the execution of the RDTSC instruction to procedures running at privilege level 0 when set; allows
         * RDTSC instruction to be executed at any privilege level when clear. This bit also applies to the RDTSCP instruction if
         * supported (if CPUID.80000001H:EDX[27] = 1).
         */
        UINT64_t timestamp_disable : 1;
#define CR4_TIMESTAMP_DISABLE_BIT                                    2
#define CR4_TIMESTAMP_DISABLE_FLAG                                   0x04
#define CR4_TIMESTAMP_DISABLE_MASK                                   0x01
#define CR4_TIMESTAMP_DISABLE(_)                                     (((_) >> 2) & 0x01)

        /**
         * @brief Debugging Extensions
         *
         * [Bit 3] References to debug registers DR4 and DR5 cause an undefined opcode (\#UD) exception to be generated when set;
         * when clear, processor aliases references to registers DR4 and DR5 for compatibility with software written to run on
         * earlier IA-32 processors.
         *
         * @see Vol3B[17.2.2(Debug Registers DR4 and DR5)]
         */
        UINT64_t debugging_extensions : 1;
#define CR4_DEBUGGING_EXTENSIONS_BIT                                 3
#define CR4_DEBUGGING_EXTENSIONS_FLAG                                0x08
#define CR4_DEBUGGING_EXTENSIONS_MASK                                0x01
#define CR4_DEBUGGING_EXTENSIONS(_)                                  (((_) >> 3) & 0x01)

        /**
         * @brief Page Size Extensions
         *
         * [Bit 4] Enables 4-MByte pages with 32-bit paging when set; restricts 32-bit paging to pages of 4 KBytes when clear.
         *
         * @see Vol3A[4.3(32-BIT PAGING)]
         */
        UINT64_t page_size_extensions : 1;
#define CR4_PAGE_SIZE_EXTENSIONS_BIT                                 4
#define CR4_PAGE_SIZE_EXTENSIONS_FLAG                                0x10
#define CR4_PAGE_SIZE_EXTENSIONS_MASK                                0x01
#define CR4_PAGE_SIZE_EXTENSIONS(_)                                  (((_) >> 4) & 0x01)

        /**
         * @brief Physical Address Extension
         *
         * [Bit 5] When set, enables paging to produce physical addresses with more than 32 bits. When clear, restricts physical
         * addresses to 32 bits. PAE must be set before entering IA-32e mode.
         *
         * @see Vol3A[4(PAGING)]
         */
        UINT64_t physical_address_extension : 1;
#define CR4_PHYSICAL_ADDRESS_EXTENSION_BIT                           5
#define CR4_PHYSICAL_ADDRESS_EXTENSION_FLAG                          0x20
#define CR4_PHYSICAL_ADDRESS_EXTENSION_MASK                          0x01
#define CR4_PHYSICAL_ADDRESS_EXTENSION(_)                            (((_) >> 5) & 0x01)

        /**
         * @brief Machine-Check Enable
         *
         * [Bit 6] Enables the machine-check exception when set; disables the machine-check exception when clear.
         *
         * @see Vol3B[15(MACHINE-CHECK ARCHITECTURE)]
         */
        UINT64_t machine_check_enable : 1;
#define CR4_MACHINE_CHECK_ENABLE_BIT                                 6
#define CR4_MACHINE_CHECK_ENABLE_FLAG                                0x40
#define CR4_MACHINE_CHECK_ENABLE_MASK                                0x01
#define CR4_MACHINE_CHECK_ENABLE(_)                                  (((_) >> 6) & 0x01)

        /**
         * @brief Page Global Enable
         *
         * [Bit 7] (Introduced in the P6 family processors.) Enables the global page feature when set; disables the global page
         * feature when clear. The global page feature allows frequently used or shared pages to be marked as global to all users
         * (done with the global flag, bit 8, in a page-directory or page-table entry). Global pages are not flushed from the
         * translation-lookaside buffer (TLB) on a task switch or a write to register CR3. When enabling the global page feature,
         * paging must be enabled (by setting the PG flag in control register CR0) before the PGE flag is set. Reversing this
         * sequence may affect program correctness, and processor performance will be impacted.
         *
         * @see Vol3A[4.10(CACHING TRANSLATION INFORMATION)]
         */
        UINT64_t page_global_enable : 1;
#define CR4_PAGE_GLOBAL_ENABLE_BIT                                   7
#define CR4_PAGE_GLOBAL_ENABLE_FLAG                                  0x80
#define CR4_PAGE_GLOBAL_ENABLE_MASK                                  0x01
#define CR4_PAGE_GLOBAL_ENABLE(_)                                    (((_) >> 7) & 0x01)

        /**
         * @brief Performance-Monitoring Counter Enable
         *
         * [Bit 8] Enables execution of the RDPMC instruction for programs or procedures running at any protection level when set;
         * RDPMC instruction can be executed only at protection level 0 when clear.
         */
        UINT64_t performance_monitoring_counter_enable : 1;
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_BIT                8
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_FLAG               0x100
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_MASK               0x01
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE(_)                 (((_) >> 8) & 0x01)

        /**
         * @brief Operating System Support for FXSAVE and FXRSTOR instructions
         *
         * [Bit 9] When set, this flag:
         * -# indicates to software that the operating system supports the use of the FXSAVE and FXRSTOR instructions,
         * -# enables the FXSAVE and FXRSTOR instructions to save and restore the contents of the XMM and MXCSR registers along
         * with the contents of the x87 FPU and MMX registers, and
         * -# enables the processor to execute SSE/SSE2/SSE3/SSSE3/SSE4 instructions, with the exception of the PAUSE, PREFETCHh,
         * SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
         * If this flag is clear, the FXSAVE and FXRSTOR instructions will save and restore the contents of the x87 FPU and MMX
         * registers, but they may not save and restore the contents of the XMM and MXCSR registers. Also, the processor will
         * generate an invalid opcode exception (\#UD) if it attempts to execute any SSE/SSE2/SSE3 instruction, with the exception
         * of PAUSE, PREFETCHh, SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT. The operating system or executive must
         * explicitly set this flag.
         *
         * @remarks CPUID feature flag FXSR indicates availability of the FXSAVE/FXRSTOR instructions. The OSFXSR bit provides
         *          operating system software with a means of enabling FXSAVE/FXRSTOR to save/restore the contents of the X87 FPU, XMM and
         *          MXCSR registers. Consequently OSFXSR bit indicates that the operating system provides context switch support for
         *          SSE/SSE2/SSE3/SSSE3/SSE4.
         */
        UINT64_t os_fxsave_fxrstor_support : 1;
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_BIT                            9
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_FLAG                           0x200
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_MASK                           0x01
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT(_)                             (((_) >> 9) & 0x01)

        /**
         * @brief Operating System Support for Unmasked SIMD Floating-Point Exceptions
         *
         * [Bit 10] Operating System Support for Unmasked SIMD Floating-Point Exceptions - When set, indicates that the operating
         * system supports the handling of unmasked SIMD floating-point exceptions through an exception handler that is invoked
         * when a SIMD floating-point exception (\#XM) is generated. SIMD floating-point exceptions are only generated by
         * SSE/SSE2/SSE3/SSE4.1 SIMD floatingpoint instructions.
         * The operating system or executive must explicitly set this flag. If this flag is not set, the processor will generate an
         * invalid opcode exception (\#UD) whenever it detects an unmasked SIMD floating-point exception.
         */
        UINT64_t os_xmm_exception_support : 1;
#define CR4_OS_XMM_EXCEPTION_SUPPORT_BIT                             10
#define CR4_OS_XMM_EXCEPTION_SUPPORT_FLAG                            0x400
#define CR4_OS_XMM_EXCEPTION_SUPPORT_MASK                            0x01
#define CR4_OS_XMM_EXCEPTION_SUPPORT(_)                              (((_) >> 10) & 0x01)

        /**
         * @brief User-Mode Instruction Prevention
         *
         * [Bit 11] When set, the following instructions cannot be executed if CPL > 0: SGDT, SIDT, SLDT, SMSW, and STR. An attempt
         * at such execution causes a generalprotection exception (\#GP).
         */
        UINT64_t usermode_instruction_prevention : 1;
#define CR4_USERMODE_INSTRUCTION_PREVENTION_BIT                      11
#define CR4_USERMODE_INSTRUCTION_PREVENTION_FLAG                     0x800
#define CR4_USERMODE_INSTRUCTION_PREVENTION_MASK                     0x01
#define CR4_USERMODE_INSTRUCTION_PREVENTION(_)                       (((_) >> 11) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * @brief VMX-Enable
         *
         * [Bit 13] Enables VMX operation when set.
         *
         * @see Vol3C[23(INTRODUCTION TO VIRTUAL MACHINE EXTENSIONS)]
         */
        UINT64_t vmx_enable : 1;
#define CR4_VMX_ENABLE_BIT                                           13
#define CR4_VMX_ENABLE_FLAG                                          0x2000
#define CR4_VMX_ENABLE_MASK                                          0x01
#define CR4_VMX_ENABLE(_)                                            (((_) >> 13) & 0x01)

        /**
         * @brief SMX-Enable
         *
         * [Bit 14] Enables SMX operation when set.
         *
         * @see Vol2[6(SAFER MODE EXTENSIONS REFERENCE)]
         */
        UINT64_t smx_enable : 1;
#define CR4_SMX_ENABLE_BIT                                           14
#define CR4_SMX_ENABLE_FLAG                                          0x4000
#define CR4_SMX_ENABLE_MASK                                          0x01
#define CR4_SMX_ENABLE(_)                                            (((_) >> 14) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * @brief FSGSBASE-Enable
         *
         * [Bit 16] Enables the instructions RDFSBASE, RDGSBASE, WRFSBASE, and WRGSBASE.
         */
        UINT64_t fsgsbase_enable : 1;
#define CR4_FSGSBASE_ENABLE_BIT                                      16
#define CR4_FSGSBASE_ENABLE_FLAG                                     0x10000
#define CR4_FSGSBASE_ENABLE_MASK                                     0x01
#define CR4_FSGSBASE_ENABLE(_)                                       (((_) >> 16) & 0x01)

        /**
         * @brief PCID-Enable
         *
         * [Bit 17] Enables process-context identifiers (PCIDs) when set. Can be set only in IA-32e mode (if IA32_EFER.LMA = 1).
         *
         * @see Vol3A[4.10.1(Process-Context Identifiers (PCIDs))]
         */
        UINT64_t pcid_enable : 1;
#define CR4_PCID_ENABLE_BIT                                          17
#define CR4_PCID_ENABLE_FLAG                                         0x20000
#define CR4_PCID_ENABLE_MASK                                         0x01
#define CR4_PCID_ENABLE(_)                                           (((_) >> 17) & 0x01)

        /**
         * @brief XSAVE and Processor Extended States-Enable
         *
         * [Bit 18] When set, this flag:
         * -# indicates (via CPUID.01H:ECX.OSXSAVE[bit 27]) that the operating system supports the use of the XGETBV, XSAVE and
         * XRSTOR instructions by general software;
         * -# enables the XSAVE and XRSTOR instructions to save and restore the x87 FPU state (including MMX registers), the SSE
         * state (XMM registers and MXCSR), along with other processor extended states enabled in XCR0;
         * -# enables the processor to execute XGETBV and XSETBV instructions in order to read and write XCR0.
         *
         * @see Vol3A[2.6(EXTENDED CONTROL REGISTERS (INCLUDING XCR0))]
         * @see Vol3A[13(SYSTEM PROGRAMMING FOR INSTRUCTION SET EXTENSIONS AND PROCESSOR EXTENDED)]
         */
        UINT64_t os_xsave : 1;
#define CR4_OS_XSAVE_BIT                                             18
#define CR4_OS_XSAVE_FLAG                                            0x40000
#define CR4_OS_XSAVE_MASK                                            0x01
#define CR4_OS_XSAVE(_)                                              (((_) >> 18) & 0x01)
        UINT64_t reserved3 : 1;

        /**
         * @brief SMEP-Enable
         *
         * [Bit 20] Enables supervisor-mode execution prevention (SMEP) when set.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        UINT64_t smep_enable : 1;
#define CR4_SMEP_ENABLE_BIT                                          20
#define CR4_SMEP_ENABLE_FLAG                                         0x100000
#define CR4_SMEP_ENABLE_MASK                                         0x01
#define CR4_SMEP_ENABLE(_)                                           (((_) >> 20) & 0x01)

        /**
         * @brief SMAP-Enable
         *
         * [Bit 21] Enables supervisor-mode access prevention (SMAP) when set.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        UINT64_t smap_enable : 1;
#define CR4_SMAP_ENABLE_BIT                                          21
#define CR4_SMAP_ENABLE_FLAG                                         0x200000
#define CR4_SMAP_ENABLE_MASK                                         0x01
#define CR4_SMAP_ENABLE(_)                                           (((_) >> 21) & 0x01)

        /**
         * @brief Protection-Key-Enable
         *
         * [Bit 22] Enables 4-level paging to associate each linear address with a protection key. The PKRU register specifies, for
         * each protection key, whether user-mode linear addresses with that protection key can be read or written. This bit also
         * enables access to the PKRU register using the RDPKRU and WRPKRU instructions.
         */
        UINT64_t protection_key_enable : 1;
#define CR4_PROTECTION_KEY_ENABLE_BIT                                22
#define CR4_PROTECTION_KEY_ENABLE_FLAG                               0x400000
#define CR4_PROTECTION_KEY_ENABLE_MASK                               0x01
#define CR4_PROTECTION_KEY_ENABLE(_)                                 (((_) >> 22) & 0x01)
        UINT64_t reserved4 : 41;
    };

    UINT64_t flags;
} cr4;

typedef union
{
    struct
    {
        /**
         * @brief Task Priority Level
         *
         * [Bits 3:0] This sets the threshold value corresponding to the highestpriority interrupt to be blocked. A value of 0
         * means all interrupts are enabled. This field is available in 64- bit mode. A value of 15 means all interrupts will be
         * disabled.
         */
        UINT64_t task_priority_level : 4;
#define CR8_TASK_PRIORITY_LEVEL_BIT                                  0
#define CR8_TASK_PRIORITY_LEVEL_FLAG                                 0x0F
#define CR8_TASK_PRIORITY_LEVEL_MASK                                 0x0F
#define CR8_TASK_PRIORITY_LEVEL(_)                                   (((_) >> 0) & 0x0F)

        /**
         * @brief Reserved
         *
         * [Bits 63:4] Reserved and must be written with zeros. Failure to do this causes a general-protection exception.
         */
        UINT64_t reserved : 60;
#define CR8_RESERVED_BIT                                             4
#define CR8_RESERVED_FLAG                                            0xFFFFFFFFFFFFFFF0
#define CR8_RESERVED_MASK                                            0xFFFFFFFFFFFFFFF
#define CR8_RESERVED(_)                                              (((_) >> 4) & 0xFFFFFFFFFFFFFFF)
    };

    UINT64_t flags;
} cr8;

/**
 * @}
 */

 /**
  * @defgroup debug_registers \
  *           Debug registers
  *
  * Eight debug registers control the debug operation of the processor. These registers can be written to and read using the
  * move to/from debug register form of the MOV instruction. A debug register may be the source or destination operand for
  * one of these instructions.
  * Debug registers are privileged resources; a MOV instruction that accesses these registers can only be executed in
  * real-address mode, in SMM or in protected mode at a CPL of 0. An attempt to read or write the debug registers from any
  * other privilege level generates a general-protection exception (\#GP). The primary function of the debug registers is to
  * set up and monitor from 1 to 4 breakpoints, numbered 0 though 3. For each breakpoint, the following information can be
  * specified:
  * - The linear address where the breakpoint is to occur.
  * - The length of the breakpoint location: 1, 2, 4, or 8 bytes.
  * - The operation that must be performed at the address for a debug exception to be generated.
  * - Whether the breakpoint is enabled.
  * - Whether the breakpoint condition was present when the debug exception was generated.
  *
  * @see Vol3B[17.2.4(Debug Control Register (DR7))]
  * @see Vol3B[17.2(DEBUG REGISTERS)] (reference)
  * @{
  */
typedef union
{
    struct
    {
        /**
         * @brief B0 through B3 (breakpoint condition detected) flags
         *
         * [Bits 3:0] Indicates (when set) that its associated breakpoint condition was met when a debug exception was generated.
         * These flags are set if the condition described for each breakpoint by the LENn, and R/Wn flags in debug control register
         * DR7 is true. They may or may not be set if the breakpoint is not enabled by the Ln or the Gn flags in register DR7.
         * Therefore on a \#DB, a debug handler should check only those B0-B3 bits which correspond to an enabled breakpoint.
         */
        UINT64_t breakpoint_condition : 4;
#define DR6_BREAKPOINT_CONDITION_BIT                                 0
#define DR6_BREAKPOINT_CONDITION_FLAG                                0x0F
#define DR6_BREAKPOINT_CONDITION_MASK                                0x0F
#define DR6_BREAKPOINT_CONDITION(_)                                  (((_) >> 0) & 0x0F)
        UINT64_t reserved1 : 9;

        /**
         * @brief BD (debug register access detected) flag
         *
         * [Bit 13] Indicates that the next instruction in the instruction stream accesses one of the debug registers (DR0 through
         * DR7). This flag is enabled when the GD (general detect) flag in debug control register DR7 is set.
         *
         * @see Vol3B[17.2.4(Debug Control Register (DR7))]
         */
        UINT64_t debug_register_access_detected : 1;
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_BIT                       13
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_FLAG                      0x2000
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_MASK                      0x01
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED(_)                        (((_) >> 13) & 0x01)

        /**
         * @brief BS (single step) flag
         *
         * [Bit 14] Indicates (when set) that the debug exception was triggered by the singlestep execution mode (enabled with the
         * TF flag in the EFLAGS register). The single-step mode is the highestpriority debug exception. When the BS flag is set,
         * any of the other debug status bits also may be set.
         */
        UINT64_t single_instruction : 1;
#define DR6_SINGLE_INSTRUCTION_BIT                                   14
#define DR6_SINGLE_INSTRUCTION_FLAG                                  0x4000
#define DR6_SINGLE_INSTRUCTION_MASK                                  0x01
#define DR6_SINGLE_INSTRUCTION(_)                                    (((_) >> 14) & 0x01)

        /**
         * @brief BT (task switch) flag
         *
         * [Bit 15] Indicates (when set) that the debug exception was triggered by the singlestep execution mode (enabled with the
         * TF flag in the EFLAGS register). The single-step mode is the highestpriority debug exception. When the BS flag is set,
         * any of the other debug status bits also may be set.
         */
        UINT64_t task_switch : 1;
#define DR6_TASK_SWITCH_BIT                                          15
#define DR6_TASK_SWITCH_FLAG                                         0x8000
#define DR6_TASK_SWITCH_MASK                                         0x01
#define DR6_TASK_SWITCH(_)                                           (((_) >> 15) & 0x01)

        /**
         * @brief RTM (restricted transactional memory) flag
         *
         * [Bit 16] Indicates (when clear) that a debug exception (\#DB) or breakpoint exception (\#BP) occurred inside an RTM
         * region while advanced debugging of RTM transactional regions was enabled. This bit is set for any other debug exception
         * (including all those that occur when advanced debugging of RTM transactional regions is not enabled). This bit is always
         * 1 if the processor does not support RTM.
         *
         * @see Vol3B[17.3.3(Debug Exceptions, Breakpoint Exceptions, and Restricted Transactional Memory (RTM))]
         */
        UINT64_t restricted_transactional_memory : 1;
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_BIT                      16
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_FLAG                     0x10000
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_MASK                     0x01
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY(_)                       (((_) >> 16) & 0x01)
        UINT64_t reserved2 : 47;
    };

    UINT64_t flags;
} dr6;

typedef union
{
    struct
    {
        /**
         * @brief L0 through L3 (local breakpoint enable) flags (bits 0, 2, 4, and 6)
         *
         * [Bit 0] Enables (when set) the breakpoint condition for the associated breakpoint for the current task. When a
         * breakpoint condition is detected and its associated Ln flag is set, a debug exception is generated. The processor
         * automatically clears these flags on every task switch to avoid unwanted breakpoint conditions in the new task.
         */
        UINT64_t local_breakpoint_0 : 1;
#define DR7_LOCAL_BREAKPOINT_0_BIT                                   0
#define DR7_LOCAL_BREAKPOINT_0_FLAG                                  0x01
#define DR7_LOCAL_BREAKPOINT_0_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_0(_)                                    (((_) >> 0) & 0x01)

        /**
         * @brief G0 through G3 (global breakpoint enable) flags (bits 1, 3, 5, and 7)
         *
         * [Bit 1] Enables (when set) the breakpoint condition for the associated breakpoint for all tasks. When a breakpoint
         * condition is detected and its associated Gn flag is set, a debug exception is generated. The processor does not clear
         * these flags on a task switch, allowing a breakpoint to be enabled for all tasks.
         */
        UINT64_t global_breakpoint_0 : 1;
#define DR7_GLOBAL_BREAKPOINT_0_BIT                                  1
#define DR7_GLOBAL_BREAKPOINT_0_FLAG                                 0x02
#define DR7_GLOBAL_BREAKPOINT_0_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_0(_)                                   (((_) >> 1) & 0x01)
        UINT64_t local_breakpoint_1 : 1;
#define DR7_LOCAL_BREAKPOINT_1_BIT                                   2
#define DR7_LOCAL_BREAKPOINT_1_FLAG                                  0x04
#define DR7_LOCAL_BREAKPOINT_1_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_1(_)                                    (((_) >> 2) & 0x01)
        UINT64_t global_breakpoint_1 : 1;
#define DR7_GLOBAL_BREAKPOINT_1_BIT                                  3
#define DR7_GLOBAL_BREAKPOINT_1_FLAG                                 0x08
#define DR7_GLOBAL_BREAKPOINT_1_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_1(_)                                   (((_) >> 3) & 0x01)
        UINT64_t local_breakpoint_2 : 1;
#define DR7_LOCAL_BREAKPOINT_2_BIT                                   4
#define DR7_LOCAL_BREAKPOINT_2_FLAG                                  0x10
#define DR7_LOCAL_BREAKPOINT_2_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_2(_)                                    (((_) >> 4) & 0x01)
        UINT64_t global_breakpoint_2 : 1;
#define DR7_GLOBAL_BREAKPOINT_2_BIT                                  5
#define DR7_GLOBAL_BREAKPOINT_2_FLAG                                 0x20
#define DR7_GLOBAL_BREAKPOINT_2_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_2(_)                                   (((_) >> 5) & 0x01)
        UINT64_t local_breakpoint_3 : 1;
#define DR7_LOCAL_BREAKPOINT_3_BIT                                   6
#define DR7_LOCAL_BREAKPOINT_3_FLAG                                  0x40
#define DR7_LOCAL_BREAKPOINT_3_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_3(_)                                    (((_) >> 6) & 0x01)
        UINT64_t global_breakpoint_3 : 1;
#define DR7_GLOBAL_BREAKPOINT_3_BIT                                  7
#define DR7_GLOBAL_BREAKPOINT_3_FLAG                                 0x80
#define DR7_GLOBAL_BREAKPOINT_3_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_3(_)                                   (((_) >> 7) & 0x01)

        /**
         * @brief LE (local exact breakpoint enable)
         *
         * [Bit 8] This feature is not supported in the P6 family processors, later IA-32 processors, and Intel 64 processors. When
         * set, these flags cause the processor to detect the exact instruction that caused a data breakpoint condition. For
         * backward and forward compatibility with other Intel processors, we recommend that the LE and GE flags be set to 1 if
         * exact breakpoints are required.
         */
        UINT64_t local_exact_breakpoint : 1;
#define DR7_LOCAL_EXACT_BREAKPOINT_BIT                               8
#define DR7_LOCAL_EXACT_BREAKPOINT_FLAG                              0x100
#define DR7_LOCAL_EXACT_BREAKPOINT_MASK                              0x01
#define DR7_LOCAL_EXACT_BREAKPOINT(_)                                (((_) >> 8) & 0x01)
        UINT64_t global_exact_breakpoint : 1;
#define DR7_GLOBAL_EXACT_BREAKPOINT_BIT                              9
#define DR7_GLOBAL_EXACT_BREAKPOINT_FLAG                             0x200
#define DR7_GLOBAL_EXACT_BREAKPOINT_MASK                             0x01
#define DR7_GLOBAL_EXACT_BREAKPOINT(_)                               (((_) >> 9) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * @brief RTM (restricted transactional memory) flag
         *
         * [Bit 11] Enables (when set) advanced debugging of RTM transactional regions. This advanced debugging is enabled only if
         * IA32_DEBUGCTL.RTM is also set.
         *
         * @see Vol3B[17.3.3(Debug Exceptions, Breakpoint Exceptions, and Restricted Transactional Memory (RTM))]
         */
        UINT64_t restricted_transactional_memory : 1;
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_BIT                      11
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_FLAG                     0x800
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_MASK                     0x01
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY(_)                       (((_) >> 11) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * @brief GD (general detect enable) flag
         *
         * [Bit 13] Enables (when set) debug-register protection, which causes a debug exception to be generated prior to any MOV
         * instruction that accesses a debug register. When such a condition is detected, the BD flag in debug status register DR6
         * is set prior to generating the exception. This condition is provided to support in-circuit emulators.
         * When the emulator needs to access the debug registers, emulator software can set the GD flag to prevent interference
         * from the program currently executing on the processor.
         * The processor clears the GD flag upon entering to the debug exception handler, to allow the handler access to the debug
         * registers.
         */
        UINT64_t general_detect : 1;
#define DR7_GENERAL_DETECT_BIT                                       13
#define DR7_GENERAL_DETECT_FLAG                                      0x2000
#define DR7_GENERAL_DETECT_MASK                                      0x01
#define DR7_GENERAL_DETECT(_)                                        (((_) >> 13) & 0x01)
        UINT64_t reserved3 : 2;

        /**
         * @brief R/W0 through R/W3 (read/write) fields (bits 16, 17, 20, 21, 24, 25, 28, and 29)
         *
         * [Bits 17:16] Specifies the breakpoint condition for the corresponding breakpoint. The DE (debug extensions) flag in
         * control register CR4 determines how the bits in the R/Wn fields are interpreted. When the DE flag is set, the processor
         * interprets bits as follows:
         * - 00 - Break on instruction execution only.
         * - 01 - Break on data writes only.
         * - 10 - Break on I/O reads or writes.
         * - 11 - Break on data reads or writes but not instruction fetches.
         * When the DE flag is clear, the processor interprets the R/Wn bits the same as for the Intel386(TM) and Intel486(TM)
         * processors, which is as follows:
         * - 00 - Break on instruction execution only.
         * - 01 - Break on data writes only.
         * - 10 - Undefined.
         * - 11 - Break on data reads or writes but not instruction fetches.
         */
        UINT64_t read_write_0 : 2;
#define DR7_READ_WRITE_0_BIT                                         16
#define DR7_READ_WRITE_0_FLAG                                        0x30000
#define DR7_READ_WRITE_0_MASK                                        0x03
#define DR7_READ_WRITE_0(_)                                          (((_) >> 16) & 0x03)

        /**
         * @brief LEN0 through LEN3 (Length) fields (bits 18, 19, 22, 23, 26, 27, 30, and 31)
         *
         * [Bits 19:18] Specify the size of the memory location at the address specified in the corresponding breakpoint address
         * register (DR0 through DR3). These fields are interpreted as follows:
         * - 00 - 1-byte length.
         * - 01 - 2-byte length.
         * - 10 - Undefined (or 8 byte length, see note below).
         * - 11 - 4-byte length.
         * If the corresponding RWn field in register DR7 is 00 (instruction execution), then the LENn field should also be 00. The
         * effect of using other lengths is undefined.
         *
         * @see Vol3B[17.2.5(Breakpoint Field Recognition)]
         */
        UINT64_t length_0 : 2;
#define DR7_LENGTH_0_BIT                                             18
#define DR7_LENGTH_0_FLAG                                            0xC0000
#define DR7_LENGTH_0_MASK                                            0x03
#define DR7_LENGTH_0(_)                                              (((_) >> 18) & 0x03)
        UINT64_t read_write_1 : 2;
#define DR7_READ_WRITE_1_BIT                                         20
#define DR7_READ_WRITE_1_FLAG                                        0x300000
#define DR7_READ_WRITE_1_MASK                                        0x03
#define DR7_READ_WRITE_1(_)                                          (((_) >> 20) & 0x03)
        UINT64_t length_1 : 2;
#define DR7_LENGTH_1_BIT                                             22
#define DR7_LENGTH_1_FLAG                                            0xC00000
#define DR7_LENGTH_1_MASK                                            0x03
#define DR7_LENGTH_1(_)                                              (((_) >> 22) & 0x03)
        UINT64_t read_write_2 : 2;
#define DR7_READ_WRITE_2_BIT                                         24
#define DR7_READ_WRITE_2_FLAG                                        0x3000000
#define DR7_READ_WRITE_2_MASK                                        0x03
#define DR7_READ_WRITE_2(_)                                          (((_) >> 24) & 0x03)
        UINT64_t length_2 : 2;
#define DR7_LENGTH_2_BIT                                             26
#define DR7_LENGTH_2_FLAG                                            0xC000000
#define DR7_LENGTH_2_MASK                                            0x03
#define DR7_LENGTH_2(_)                                              (((_) >> 26) & 0x03)
        UINT64_t read_write_3 : 2;
#define DR7_READ_WRITE_3_BIT                                         28
#define DR7_READ_WRITE_3_FLAG                                        0x30000000
#define DR7_READ_WRITE_3_MASK                                        0x03
#define DR7_READ_WRITE_3(_)                                          (((_) >> 28) & 0x03)
        UINT64_t length_3 : 2;
#define DR7_LENGTH_3_BIT                                             30
#define DR7_LENGTH_3_FLAG                                            0xC0000000
#define DR7_LENGTH_3_MASK                                            0x03
#define DR7_LENGTH_3(_)                                              (((_) >> 30) & 0x03)
        UINT64_t reserved4 : 32;
    };

    UINT64_t flags;
} dr7;

/**
 * @}
 */

 /**
  * @defgroup cpuid \
  *           CPUID
  *
  * @see Vol2A[3.2(CPUID)] (reference)
  * @{
  */
  /**
   * @brief Returns CPUID's Highest Value for Basic Processor Information and the Vendor Identification String
   *
   * When CPUID executes with EAX set to 0, the processor returns the highest value the CPUID recognizes for returning basic
   * processor information. The value is returned in the EAX register and is processor specific.
   * A vendor identification string is also returned in EBX, EDX, and ECX. For Intel processors, the string is "GenuineIntel"
   * and is expressed:
   * - EBX <- 756e6547h (* "Genu", with G in the low eight bits of BL *)
   * - EDX <- 49656e69h (* "ineI", with i in the low eight bits of DL *)
   * - ECX <- 6c65746eh (* "ntel", with n in the low eight bits of CL *)
   */
#define CPUID_SIGNATURE                                              0x00000000
typedef struct
{
    /**
     * @brief EAX
     *
     * Maximum Input Value for Basic CPUID Information.
     */
    UINT32_t max_cpuid_input_value;

    /**
     * @brief EBX
     *
     * "Genu"
     */
    UINT32_t ebx_value_genu;

    /**
     * @brief ECX
     *
     * "ntel"
     */
    UINT32_t ecx_value_ntel;

    /**
     * @brief EDX
     *
     * "ineI"
     */
    UINT32_t edx_value_inei;
} cpuid_eax_00;


/**
 * @brief Returns Model, Family, Stepping Information, Additional Information and Feature Information
 *
 * Returns:
 *   * Model, Family, Stepping Information in EAX
 *   * Additional Information in EBX
 *   * Feature Information in ECX and EDX
 */
#define CPUID_VERSION_INFORMATION                                    0x00000001
typedef struct
{
    /**
     * @brief When CPUID executes with EAX set to 01H, version information is returned in EAX
     */
    union
    {
        struct
        {
            UINT32_t stepping_id : 4;
#define CPUID_VERSION_INFORMATION_STEPPING_ID_BIT                    0
#define CPUID_VERSION_INFORMATION_STEPPING_ID_FLAG                   0x0F
#define CPUID_VERSION_INFORMATION_STEPPING_ID_MASK                   0x0F
#define CPUID_VERSION_INFORMATION_STEPPING_ID(_)                     (((_) >> 0) & 0x0F)
            UINT32_t model : 4;
#define CPUID_VERSION_INFORMATION_MODEL_BIT                          4
#define CPUID_VERSION_INFORMATION_MODEL_FLAG                         0xF0
#define CPUID_VERSION_INFORMATION_MODEL_MASK                         0x0F
#define CPUID_VERSION_INFORMATION_MODEL(_)                           (((_) >> 4) & 0x0F)
            UINT32_t family_id : 4;
#define CPUID_VERSION_INFORMATION_FAMILY_ID_BIT                      8
#define CPUID_VERSION_INFORMATION_FAMILY_ID_FLAG                     0xF00
#define CPUID_VERSION_INFORMATION_FAMILY_ID_MASK                     0x0F
#define CPUID_VERSION_INFORMATION_FAMILY_ID(_)                       (((_) >> 8) & 0x0F)

            /**
             * [Bits 13:12] - 0 - Original OEM Processor
             * - 1 - Intel OverDrive(R) Processor
             * - 2 - Dual processor (not applicable to Intel486 processors)
             * - 3 - Intel reserved
             */
            UINT32_t processor_type : 2;
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_BIT                 12
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_FLAG                0x3000
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_MASK                0x03
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE(_)                  (((_) >> 12) & 0x03)
            UINT32_t reserved1 : 2;

            /**
             * [Bits 19:16] The Extended Model ID needs to be examined only when the Family ID is 06H or 0FH.
             */
            UINT32_t extended_model_id : 4;
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_BIT              16
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_FLAG             0xF0000
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_MASK             0x0F
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID(_)               (((_) >> 16) & 0x0F)

            /**
             * [Bits 27:20] The Extended Family ID needs to be examined only when the Family ID is 0FH.
             */
            UINT32_t extended_family_id : 8;
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_BIT             20
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_FLAG            0xFF00000
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_MASK            0xFF
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID(_)              (((_) >> 20) & 0xFF)
            UINT32_t reserved2 : 4;
        };

        UINT32_t flags;
    } cpuid_version_information;

    /**
     * @brief When CPUID executes with EAX set to 01H, additional information is returned to the EBX register
     */
    union
    {
        struct
        {
            /**
             * [Bits 7:0] This number provides an entry into a brand string table that contains brand strings for IA-32 processors.
             * More information about this field is provided later in this section.
             */
            UINT32_t brand_index : 8;
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_BIT                 0
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_FLAG                0xFF
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_MASK                0xFF
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX(_)                  (((_) >> 0) & 0xFF)

            /**
             * @brief Value * 8 = cache line size in bytes; used also by CLFLUSHOPT
             *
             * [Bits 15:8] This number indicates the size of the cache line flushed by the CLFLUSH and CLFLUSHOPT instructions in
             * 8-byte increments. This field was introduced in the Pentium 4 processor.
             */
            UINT32_t clflush_line_size : 8;
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_BIT           8
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_FLAG          0xFF00
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_MASK          0xFF
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE(_)            (((_) >> 8) & 0xFF)

            /**
             * [Bits 23:16] Maximum number of addressable IDs for logical processors in this physical package.
             *
             * @remarks The nearest power-of-2 integer that is not smaller than EBX[23:16] is the number of unique initial APIC IDs
             *          reserved for addressing different logical processors in a physical package. This field is only valid if
             *          CPUID.1.EDX.HTT[bit 28] = 1.
             */
            UINT32_t max_addressable_ids : 8;
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_BIT         16
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_FLAG        0xFF0000
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_MASK        0xFF
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS(_)          (((_) >> 16) & 0xFF)

            /**
             * [Bits 31:24] This number is the 8-bit ID that is assigned to the local APIC on the processor during power up. This field
             * was introduced in the Pentium 4 processor.
             */
            UINT32_t initial_apic_id : 8;
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_BIT             24
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_FLAG            0xFF000000
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_MASK            0xFF
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID(_)              (((_) >> 24) & 0xFF)
        };

        UINT32_t flags;
    } cpuid_additional_information;

    /**
     * @brief When CPUID executes with EAX set to 01H, feature information is returned in ECX and EDX
     */
    union
    {
        struct
        {
            /**
             * @brief Streaming SIMD Extensions 3 (SSE3)
             *
             * [Bit 0] A value of 1 indicates the processor supports this technology.
             */
            UINT32_t streaming_simd_extensions_3 : 1;
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_BIT 0
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_FLAG 0x01
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3(_) (((_) >> 0) & 0x01)

            /**
             * @brief PCLMULQDQ instruction
             *
             * [Bit 1] A value of 1 indicates the processor supports the PCLMULQDQ instruction.
             */
            UINT32_t pclmulqdq_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_BIT      1
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_FLAG     0x02
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_MASK     0x01
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION(_)       (((_) >> 1) & 0x01)

            /**
             * @brief 64-bit DS Area
             *
             * [Bit 2] A value of 1 indicates the processor supports DS area using 64-bit layout.
             */
            UINT32_t ds_area_64bit_layout : 1;
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_BIT       2
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_FLAG      0x04
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_MASK      0x01
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT(_)        (((_) >> 2) & 0x01)

            /**
             * @brief MONITOR/MWAIT instruction
             *
             * [Bit 3] A value of 1 indicates the processor supports this feature.
             */
            UINT32_t monitor_mwait_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_BIT  3
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_FLAG 0x08
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION(_)   (((_) >> 3) & 0x01)

            /**
             * @brief CPL Qualified Debug Store
             *
             * [Bit 4] A value of 1 indicates the processor supports the extensions to the Debug Store feature to allow for branch
             * message storage qualified by CPL.
             */
            UINT32_t cpl_qualified_debug_store : 1;
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_BIT  4
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_FLAG 0x10
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE(_)   (((_) >> 4) & 0x01)

            /**
             * @brief Virtual Machine Extensions
             *
             * [Bit 5] A value of 1 indicates that the processor supports this technology.
             */
            UINT32_t virtual_machine_extensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_BIT 5
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_FLAG 0x20
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS(_)  (((_) >> 5) & 0x01)

            /**
             * @brief Safer Mode Extensions
             *
             * [Bit 6] A value of 1 indicates that the processor supports this technology.
             *
             * @see Vol2[6(SAFER MODE EXTENSIONS REFERENCE)]
             */
            UINT32_t safer_mode_extensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_BIT      6
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_FLAG     0x40
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_MASK     0x01
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS(_)       (((_) >> 6) & 0x01)

            /**
             * @brief Enhanced Intel SpeedStep(R) technology
             *
             * [Bit 7] A value of 1 indicates that the processor supports this technology.
             */
            UINT32_t enhanced_intel_speedstep_technology : 1;
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_BIT 7
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_FLAG 0x80
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY(_) (((_) >> 7) & 0x01)

            /**
             * @brief Thermal Monitor 2
             *
             * [Bit 8] A value of 1 indicates whether the processor supports this technology.
             */
            UINT32_t thermal_monitor_2 : 1;
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_BIT          8
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_FLAG         0x100
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_MASK         0x01
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2(_)           (((_) >> 8) & 0x01)

            /**
             * @brief Supplemental Streaming SIMD Extensions 3 (SSSE3)
             *
             * [Bit 9] A value of 1 indicates the presence of the Supplemental Streaming SIMD Extensions 3 (SSSE3). A value of 0
             * indicates the instruction extensions are not present in the processor.
             */
            UINT32_t supplemental_streaming_simd_extensions_3 : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_BIT 9
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_FLAG 0x200
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3(_) (((_) >> 9) & 0x01)

            /**
             * @brief L1 Context ID
             *
             * [Bit 10] A value of 1 indicates the L1 data cache mode can be set to either adaptive mode or shared mode. A value of 0
             * indicates this feature is not supported. See definition of the IA32_MISC_ENABLE MSR Bit 24 (L1 Data Cache Context Mode)
             * for details.
             */
            UINT32_t l1_context_id : 1;
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_BIT              10
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_FLAG             0x400
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID(_)               (((_) >> 10) & 0x01)

            /**
             * @brief IA32_DEBUG_INTERFACE MSR for silicon debug
             *
             * [Bit 11] A value of 1 indicates the processor supports IA32_DEBUG_INTERFACE MSR for silicon debug.
             */
            UINT32_t silicon_debug : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_BIT              11
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_FLAG             0x800
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG(_)               (((_) >> 11) & 0x01)

            /**
             * @brief FMA extensions using YMM state
             *
             * [Bit 12] A value of 1 indicates the processor supports FMA (Fused Multiple Add) extensions using YMM state.
             */
            UINT32_t fma_extensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_BIT             12
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_FLAG            0x1000
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_MASK            0x01
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS(_)              (((_) >> 12) & 0x01)

            /**
             * @brief CMPXCHG16B instruction
             *
             * [Bit 13] A value of 1 indicates that the feature is available.
             */
            UINT32_t cmpxchg16b_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_BIT     13
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_FLAG    0x2000
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_MASK    0x01
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION(_)      (((_) >> 13) & 0x01)

            /**
             * @brief xTPR Update Control
             *
             * [Bit 14] A value of 1 indicates that the processor supports changing IA32_MISC_ENABLE[bit 23].
             */
            UINT32_t xtpr_update_control : 1;
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_BIT        14
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_FLAG       0x4000
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_MASK       0x01
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL(_)         (((_) >> 14) & 0x01)

            /**
             * @brief Perfmon and Debug Capability
             *
             * [Bit 15] A value of 1 indicates the processor supports the performance and debug feature indication MSR
             * IA32_PERF_CAPABILITIES.
             */
            UINT32_t perfmon_and_debug_capability : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_BIT 15
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_FLAG 0x8000
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY(_) (((_) >> 15) & 0x01)
            UINT32_t reserved1 : 1;

            /**
             * @brief Process-context identifiers
             *
             * [Bit 17] A value of 1 indicates that the processor supports PCIDs and that software may set CR4.PCIDE to 1.
             */
            UINT32_t process_context_identifiers : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_BIT 17
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_FLAG 0x20000
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS(_) (((_) >> 17) & 0x01)

            /**
             * @brief Direct Cache Access
             *
             * [Bit 18] A value of 1 indicates the processor supports the ability to prefetch data from a memory mapped device (Direct
             * Cache Access).
             */
            UINT32_t direct_cache_access : 1;
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_BIT        18
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_FLAG       0x40000
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_MASK       0x01
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS(_)         (((_) >> 18) & 0x01)

            /**
             * @brief SSE4.1 support
             *
             * [Bit 19] A value of 1 indicates that the processor supports SSE4.1.
             */
            UINT32_t sse41_support : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_BIT              19
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_FLAG             0x80000
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT(_)               (((_) >> 19) & 0x01)

            /**
             * @brief SSE4.2 support
             *
             * [Bit 20] A value of 1 indicates that the processor supports SSE4.2.
             */
            UINT32_t sse42_support : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_BIT              20
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_FLAG             0x100000
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT(_)               (((_) >> 20) & 0x01)

            /**
             * @brief x2APIC support
             *
             * [Bit 21] A value of 1 indicates that the processor supports x2APIC feature.
             */
            UINT32_t x2apic_support : 1;
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_BIT             21
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_FLAG            0x200000
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_MASK            0x01
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT(_)              (((_) >> 21) & 0x01)

            /**
             * @brief MOVBE instruction
             *
             * [Bit 22] A value of 1 indicates that the processor supports MOVBE instruction.
             */
            UINT32_t movbe_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_BIT          22
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_FLAG         0x400000
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_MASK         0x01
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION(_)           (((_) >> 22) & 0x01)

            /**
             * @brief POPCNT instruction
             *
             * [Bit 23] A value of 1 indicates that the processor supports the POPCNT instruction.
             */
            UINT32_t popcnt_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_BIT         23
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_FLAG        0x800000
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_MASK        0x01
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION(_)          (((_) >> 23) & 0x01)

            /**
             * @brief TSC Deadline
             *
             * [Bit 24] A value of 1 indicates that the processor's local APIC timer supports one-shot operation using a TSC deadline
             * value.
             */
            UINT32_t tsc_deadline : 1;
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_BIT               24
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_FLAG              0x1000000
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_MASK              0x01
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE(_)                (((_) >> 24) & 0x01)

            /**
             * @brief AESNI instruction extensions
             *
             * [Bit 25] A value of 1 indicates that the processor supports the AESNI instruction extensions.
             */
            UINT32_t aesni_instruction_extensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_BIT 25
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_FLAG 0x2000000
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS(_) (((_) >> 25) & 0x01)

            /**
             * @brief XSAVE/XRSTOR instruction extensions
             *
             * [Bit 26] A value of 1 indicates that the processor supports the XSAVE/XRSTOR processor extended states feature, the
             * XSETBV/XGETBV instructions, and XCR0.
             */
            UINT32_t xsave_xrstor_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_BIT   26
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_FLAG  0x4000000
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_MASK  0x01
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION(_)    (((_) >> 26) & 0x01)

            /**
             * @brief CR4.OSXSAVE[bit 18] set
             *
             * [Bit 27] A value of 1 indicates that the OS has set CR4.OSXSAVE[bit 18] to enable XSETBV/XGETBV instructions to access
             * XCR0 and to support processor extended state management using XSAVE/XRSTOR.
             */
            UINT32_t osx_save : 1;
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_BIT                   27
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_FLAG                  0x8000000
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_MASK                  0x01
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE(_)                    (((_) >> 27) & 0x01)

            /**
             * @brief AVX instruction extensions support
             *
             * [Bit 28] A value of 1 indicates the processor supports the AVX instruction extensions.
             */
            UINT32_t avx_support : 1;
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_BIT                28
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_FLAG               0x10000000
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_MASK               0x01
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT(_)                 (((_) >> 28) & 0x01)

            /**
             * @brief 16-bit floating-point conversion instructions support
             *
             * [Bit 29] A value of 1 indicates that processor supports 16-bit floating-point conversion instructions.
             */
            UINT32_t half_precision_conversion_instructions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_BIT 29
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_FLAG 0x20000000
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS(_) (((_) >> 29) & 0x01)

            /**
             * @brief RDRAND instruction support
             *
             * [Bit 30] A value of 1 indicates that processor supports RDRAND instruction.
             */
            UINT32_t rdrand_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_BIT         30
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_FLAG        0x40000000
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_MASK        0x01
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION(_)          (((_) >> 30) & 0x01)
            UINT32_t reserved2 : 1;
        };

        UINT32_t flags;
    } cpuid_feature_information_ecx;

    /**
     * @brief When CPUID executes with EAX set to 01H, feature information is returned in ECX and EDX
     */
    union
    {
        struct
        {
            /**
             * @brief Floating Point Unit On-Chip
             *
             * [Bit 0] The processor contains an x87 FPU.
             */
            UINT32_t floating_point_unit_on_chip : 1;
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_BIT 0
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_FLAG 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP(_) (((_) >> 0) & 0x01)

            /**
             * @brief Virtual 8086 Mode Enhancements
             *
             * [Bit 1] Virtual 8086 mode enhancements, including CR4.VME for controlling the feature, CR4.PVI for protected mode
             * virtual interrupts, software interrupt indirection, expansion of the TSS with the software indirection bitmap, and
             * EFLAGS.VIF and EFLAGS.VIP flags.
             */
            UINT32_t virtual_8086_mode_enhancements : 1;
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_BIT 1
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_FLAG 0x02
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS(_) (((_) >> 1) & 0x01)

            /**
             * @brief Debugging Extensions
             *
             * [Bit 2] Support for I/O breakpoints, including CR4.DE for controlling the feature, and optional trapping of accesses to
             * DR4 and DR5.
             */
            UINT32_t debugging_extensions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_BIT       2
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_FLAG      0x04
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_MASK      0x01
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS(_)        (((_) >> 2) & 0x01)

            /**
             * @brief Page Size Extension
             *
             * [Bit 3] Large pages of size 4 MByte are supported, including CR4.PSE for controlling the feature, the defined dirty bit
             * in PDE (Page Directory Entries), optional reserved bit trapping in CR3, PDEs, and PTEs.
             */
            UINT32_t page_size_extension : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_BIT        3
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_FLAG       0x08
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_MASK       0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION(_)         (((_) >> 3) & 0x01)

            /**
             * @brief Time Stamp Counter
             *
             * [Bit 4] The RDTSC instruction is supported, including CR4.TSD for controlling privilege.
             */
            UINT32_t timestamp_counter : 1;
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_BIT          4
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_FLAG         0x10
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_MASK         0x01
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER(_)           (((_) >> 4) & 0x01)

            /**
             * @brief Model Specific Registers RDMSR and WRMSR Instructions
             *
             * [Bit 5] The RDMSR and WRMSR instructions are supported. Some of the MSRs are implementation dependent.
             */
            UINT32_t rdmsr_wrmsr_instructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_BIT   5
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_FLAG  0x20
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_MASK  0x01
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS(_)    (((_) >> 5) & 0x01)

            /**
             * @brief Physical Address Extension
             *
             * [Bit 6] Physical addresses greater than 32 bits are supported: extended page table entry formats, an extra level in the
             * page translation tables is defined, 2-MByte pages are supported instead of 4 Mbyte pages if PAE bit is 1.
             */
            UINT32_t physical_address_extension : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_BIT 6
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_FLAG 0x40
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION(_)  (((_) >> 6) & 0x01)

            /**
             * @brief Machine Check Exception
             *
             * [Bit 7] Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the feature. This feature does not
             * define the model-specific implementations of machine-check error logging, reporting, and processor shutdowns. Machine
             * Check exception handlers may have to depend on processor version to do model specific processing of the exception, or
             * test for the presence of the Machine Check feature.
             */
            UINT32_t machine_check_exception : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_BIT    7
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_FLAG   0x80
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_MASK   0x01
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION(_)     (((_) >> 7) & 0x01)

            /**
             * @brief CMPXCHG8B Instruction
             *
             * [Bit 8] The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly locked and atomic).
             */
            UINT32_t cmpxchg8b : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_BIT                  8
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_FLAG                 0x100
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_MASK                 0x01
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B(_)                   (((_) >> 8) & 0x01)

            /**
             * @brief APIC On-Chip
             *
             * [Bit 9] The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to memory mapped
             * commands in the physical address range FFFE0000H to FFFE0FFFH (by default - some processors permit the APIC to be
             * relocated).
             */
            UINT32_t apic_on_chip : 1;
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_BIT               9
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_FLAG              0x200
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_MASK              0x01
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP(_)                (((_) >> 9) & 0x01)
            UINT32_t reserved1 : 1;

            /**
             * @brief SYSENTER and SYSEXIT Instructions
             *
             * [Bit 11] The SYSENTER and SYSEXIT and associated MSRs are supported.
             */
            UINT32_t sysenter_sysexit_instructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_BIT 11
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_FLAG 0x800
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS(_) (((_) >> 11) & 0x01)

            /**
             * @brief Memory Type Range Registers
             *
             * [Bit 12] MTRRs are supported. The MTRRcap MSR contains feature bits that describe what memory types are supported, how
             * many variable MTRRs are supported, and whether fixed MTRRs are supported.
             */
            UINT32_t memory_type_range_registers : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_BIT 12
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_FLAG 0x1000
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS(_) (((_) >> 12) & 0x01)

            /**
             * @brief Page Global Bit
             *
             * [Bit 13] The global bit is supported in paging-structure entries that map a page, indicating TLB entries that are common
             * to different processes and need not be flushed. The CR4.PGE bit controls this feature.
             */
            UINT32_t page_global_bit : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_BIT            13
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_FLAG           0x2000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_MASK           0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT(_)             (((_) >> 13) & 0x01)

            /**
             * @brief Machine Check Architecture
             *
             * [Bit 14] A value of 1 indicates the Machine Check Architecture of reporting machine errors is supported. The MCG_CAP MSR
             * contains feature bits describing how many banks of error reporting MSRs are supported.
             */
            UINT32_t machine_check_architecture : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_BIT 14
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_FLAG 0x4000
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE(_)  (((_) >> 14) & 0x01)

            /**
             * @brief Conditional Move Instructions
             *
             * [Bit 15] The conditional move instruction CMOV is supported. In addition, if x87 FPU is present as indicated by the
             * CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported
             */
            UINT32_t conditional_move_instructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_BIT 15
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_FLAG 0x8000
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS(_) (((_) >> 15) & 0x01)

            /**
             * @brief Page Attribute Table
             *
             * [Bit 16] Page Attribute Table is supported. This feature augments the Memory Type Range Registers (MTRRs), allowing an
             * operating system to specify attributes of memory accessed through a linear address on a 4KB granularity.
             */
            UINT32_t page_attribute_table : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_BIT       16
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_FLAG      0x10000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_MASK      0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE(_)        (((_) >> 16) & 0x01)

            /**
             * @brief 36-Bit Page Size Extension
             *
             * [Bit 17] 4-MByte pages addressing physical memory beyond 4 GBytes are supported with 32-bit paging. This feature
             * indicates that upper bits of the physical address of a 4-MByte page are encoded in bits 20:13 of the page-directory
             * entry. Such physical addresses are limited by MAXPHYADDR and may be up to 40 bits in size.
             */
            UINT32_t page_size_extension_36bit : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_BIT  17
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_FLAG 0x20000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT(_)   (((_) >> 17) & 0x01)

            /**
             * @brief Processor Serial Number
             *
             * [Bit 18] The processor supports the 96-bit processor identification number feature and the feature is enabled.
             */
            UINT32_t processor_serial_number : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_BIT    18
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_FLAG   0x40000
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_MASK   0x01
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER(_)     (((_) >> 18) & 0x01)

            /**
             * @brief CLFLUSH Instruction
             *
             * [Bit 19] CLFLUSH Instruction is supported.
             */
            UINT32_t clflush : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_BIT                    19
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_FLAG                   0x80000
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_MASK                   0x01
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH(_)                     (((_) >> 19) & 0x01)
            UINT32_t reserved2 : 1;

            /**
             * @brief Debug Store
             *
             * [Bit 21] The processor supports the ability to write debug information into a memory resident buffer. This feature is
             * used by the branch trace store (BTS) and processor event-based sampling (PEBS) facilities.
             *
             * @see Vol3C[23(INTRODUCTION TO VIRTUAL MACHINE EXTENSIONS)]
             */
            UINT32_t debug_store : 1;
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_BIT                21
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_FLAG               0x200000
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_MASK               0x01
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE(_)                 (((_) >> 21) & 0x01)

            /**
             * @brief Thermal Monitor and Software Controlled Clock Facilities
             *
             * [Bit 22] The processor implements internal MSRs that allow processor temperature to be monitored and processor
             * performance to be modulated in predefined duty cycles under software control.
             */
            UINT32_t thermal_control_msrs_for_acpi : 1;
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_BIT 22
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_FLAG 0x400000
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI(_) (((_) >> 22) & 0x01)

            /**
             * @brief Intel MMX Technology
             *
             * [Bit 23] The processor supports the Intel MMX technology.
             */
            UINT32_t mmx_support : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_BIT                23
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_FLAG               0x800000
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_MASK               0x01
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT(_)                 (((_) >> 23) & 0x01)

            /**
             * @brief FXSAVE and FXRSTOR Instructions
             *
             * [Bit 24] The FXSAVE and FXRSTOR instructions are supported for fast save and restore of the floating point context.
             * Presence of this bit also indicates that CR4.OSFXSR is available for an operating system to indicate that it supports
             * the FXSAVE and FXRSTOR instructions.
             */
            UINT32_t fxsave_fxrstor_instructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_BIT 24
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_FLAG 0x1000000
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS(_) (((_) >> 24) & 0x01)

            /**
             * @brief SSE extensions support
             *
             * [Bit 25] The processor supports the SSE extensions.
             */
            UINT32_t sse_support : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_BIT                25
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_FLAG               0x2000000
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_MASK               0x01
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT(_)                 (((_) >> 25) & 0x01)

            /**
             * @brief SSE2 extensions support
             *
             * [Bit 26] The processor supports the SSE2 extensions.
             */
            UINT32_t sse2_support : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_BIT               26
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_FLAG              0x4000000
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_MASK              0x01
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT(_)                (((_) >> 26) & 0x01)

            /**
             * @brief Self Snoop
             *
             * [Bit 27] The processor supports the management of conflicting memory types by performing a snoop of its own cache
             * structure for transactions issued to the bus.
             */
            UINT32_t self_snoop : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_BIT                 27
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_FLAG                0x8000000
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_MASK                0x01
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP(_)                  (((_) >> 27) & 0x01)

            /**
             * @brief Max APIC IDs reserved field is Valid
             *
             * [Bit 28] A value of 0 for HTT indicates there is only a single logical processor in the package and software should
             * assume only a single APIC ID is reserved. A value of 1 for HTT indicates the value in CPUID.1.EBX[23:16] (the Maximum
             * number of addressable IDs for logical processors in this package) is valid for the package.
             */
            UINT32_t hyper_threading_technology : 1;
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_BIT 28
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_FLAG 0x10000000
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY(_)  (((_) >> 28) & 0x01)

            /**
             * @brief Thermal Monitor
             *
             * [Bit 29] The processor implements the thermal monitor automatic thermal control circuitry (TCC).
             */
            UINT32_t thermal_monitor : 1;
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_BIT            29
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_FLAG           0x20000000
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_MASK           0x01
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR(_)             (((_) >> 29) & 0x01)
            UINT32_t reserved3 : 1;

            /**
             * @brief Pending Break Enable
             *
             * [Bit 31] The processor supports the use of the FERR\#/PBE\# pin when the processor is in the stop-clock state (STPCLK\#
             * is asserted) to signal the processor that an interrupt is pending and that the processor should return to normal
             * operation to handle the interrupt. Bit 10 (PBE enable) in the IA32_MISC_ENABLE MSR enables this capability.
             */
            UINT32_t pending_break_enable : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_BIT       31
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_FLAG      0x80000000
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_MASK      0x01
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE(_)        (((_) >> 31) & 0x01)
        };

        UINT32_t flags;
    } cpuid_feature_information_edx;

} cpuid_eax_01;


/**
 * @brief Deterministic Cache Parameters Leaf
 *
 * When CPUID executes with EAX set to 04H and ECX contains an index value, the processor returns encoded data that
 * describe a set of deterministic cache parameters (for the cache level associated with the input in ECX). Valid index
 * values start from 0.
 * Software can enumerate the deterministic cache parameters for each level of the cache hierarchy starting with an index
 * value of 0, until the parameters report the value associated with the cache type field is 0. The architecturally defined
 * fields reported by deterministic cache parameters are documented in Table 3-8.
 * This Cache Size in Bytes
 * - = (Ways + 1) * (Partitions + 1) * (Line_Size + 1) * (Sets + 1)
 * - = (EBX[31:22] + 1) * (EBX[21:12] + 1) * (EBX[11:0] + 1) * (ECX + 1)
 * The CPUID leaf 04H also reports data that can be used to derive the topology of processor cores in a physical package.
 * This information is constant for all valid index values. Software can query the raw data reported by executing CPUID
 * with EAX=04H and ECX=0 and use it as part of the topology enumeration algorithm.
 *
 * @see Vol3A[8(Multiple-Processor Management)]
 */
#define CPUID_CACHE_PARAMETERS                                       0x00000004
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 4:0] - 0 = Null - No more caches.
             * - 1 = Data Cache.
             * - 2 = Instruction Cache.
             * - 3 = Unified Cache.
             * - 4-31 = Reserved.
             */
            UINT32_t cache_type_field : 5;
#define CPUID_EAX_CACHE_TYPE_FIELD_BIT                               0
#define CPUID_EAX_CACHE_TYPE_FIELD_FLAG                              0x1F
#define CPUID_EAX_CACHE_TYPE_FIELD_MASK                              0x1F
#define CPUID_EAX_CACHE_TYPE_FIELD(_)                                (((_) >> 0) & 0x1F)

            /**
             * [Bits 7:5] Cache Level (starts at 1).
             */
            UINT32_t cache_level : 3;
#define CPUID_EAX_CACHE_LEVEL_BIT                                    5
#define CPUID_EAX_CACHE_LEVEL_FLAG                                   0xE0
#define CPUID_EAX_CACHE_LEVEL_MASK                                   0x07
#define CPUID_EAX_CACHE_LEVEL(_)                                     (((_) >> 5) & 0x07)

            /**
             * [Bit 8] Self Initializing cache level (does not need SW initialization).
             */
            UINT32_t self_initializing_cache_level : 1;
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_BIT                  8
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_FLAG                 0x100
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_MASK                 0x01
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL(_)                   (((_) >> 8) & 0x01)

            /**
             * [Bit 9] Fully Associative cache.
             */
            UINT32_t fully_associative_cache : 1;
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_BIT                        9
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_FLAG                       0x200
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_MASK                       0x01
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE(_)                         (((_) >> 9) & 0x01)
            UINT32_t reserved1 : 4;

            /**
             * [Bits 25:14] Maximum number of addressable IDs for logical processors sharing this cache.
             *
             * @note Add one to the return value to get the result.
             *       The nearest power-of-2 integer that is not smaller than (1 + EAX[25:14]) is the number of unique initial APIC IDs
             *       reserved for addressing different logical processors sharing this cache.
             */
            UINT32_t max_addressable_ids_for_logical_processors_sharing_this_cache : 12;
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_BIT 14
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_FLAG 0x3FFC000
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_MASK 0xFFF
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE(_) (((_) >> 14) & 0xFFF)

            /**
             * [Bits 31:26] Maximum number of addressable IDs for processor cores in the physical package.
             *
             * @note Add one to the return value to get the result.
             *       The nearest power-of-2 integer that is not smaller than (1 + EAX[31:26]) is the number of unique Core_IDs reserved for
             *       addressing different processor cores in a physical package. Core ID is a subset of bits of the initial APIC ID.
             *       The returned value is constant for valid initial values in ECX. Valid ECX values start from 0.
             */
            UINT32_t max_addressable_ids_for_processor_cores_in_physical_package : 6;
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_BIT 26
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_FLAG 0xFC000000
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_MASK 0x3F
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE(_) (((_) >> 26) & 0x3F)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 11:0] System Coherency Line Size.
             *
             * @note Add one to the return value to get the result.
             */
            UINT32_t system_coherency_line_size : 12;
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_BIT                     0
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_FLAG                    0xFFF
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_MASK                    0xFFF
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE(_)                      (((_) >> 0) & 0xFFF)

            /**
             * [Bits 21:12] Physical Line partitions.
             *
             * @note Add one to the return value to get the result.
             */
            UINT32_t physical_line_partitions : 10;
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_BIT                       12
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_FLAG                      0x3FF000
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_MASK                      0x3FF
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS(_)                        (((_) >> 12) & 0x3FF)

            /**
             * [Bits 31:22] Ways of associativity.
             *
             * @note Add one to the return value to get the result.
             */
            UINT32_t ways_of_associativity : 10;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_BIT                          22
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_FLAG                         0xFFC00000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_MASK                         0x3FF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY(_)                           (((_) >> 22) & 0x3FF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Number of Sets.
             *
             * @note Add one to the return value to get the result.
             */
            UINT32_t number_of_sets : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT                                 0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * @brief Write-Back Invalidate/Invalidate
             *
             * [Bit 0] - 0 = WBINVD/INVD from threads sharing this cache acts upon lower level caches for threads sharing this cache.
             * - 1 = WBINVD/INVD is not guaranteed to act upon lower level caches of non-originating threads sharing this cache.
             */
            UINT32_t write_back_invalidate : 1;
#define CPUID_EDX_WRITE_BACK_INVALIDATE_BIT                          0
#define CPUID_EDX_WRITE_BACK_INVALIDATE_FLAG                         0x01
#define CPUID_EDX_WRITE_BACK_INVALIDATE_MASK                         0x01
#define CPUID_EDX_WRITE_BACK_INVALIDATE(_)                           (((_) >> 0) & 0x01)

            /**
             * @brief Cache Inclusiveness
             *
             * [Bit 1] - 0 = Cache is not inclusive of lower cache levels.
             * - 1 = Cache is inclusive of lower cache levels.
             */
            UINT32_t cache_inclusiveness : 1;
#define CPUID_EDX_CACHE_INCLUSIVENESS_BIT                            1
#define CPUID_EDX_CACHE_INCLUSIVENESS_FLAG                           0x02
#define CPUID_EDX_CACHE_INCLUSIVENESS_MASK                           0x01
#define CPUID_EDX_CACHE_INCLUSIVENESS(_)                             (((_) >> 1) & 0x01)

            /**
             * @brief Complex Cache Indexing
             *
             * [Bit 2] - 0 = Direct mapped cache.
             * - 1 = A complex function is used to index the cache, potentially using all address bits.
             */
            UINT32_t complex_cache_indexing : 1;
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_BIT                         2
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_FLAG                        0x04
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_MASK                        0x01
#define CPUID_EDX_COMPLEX_CACHE_INDEXING(_)                          (((_) >> 2) & 0x01)
            UINT32_t reserved1 : 29;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_04;


/**
 * @brief MONITOR/MWAIT Leaf
 *
 * When CPUID executes with EAX set to 05H, the processor returns information about features available to MONITOR/MWAIT
 * instructions. The MONITOR instruction is used for address-range monitoring in conjunction with MWAIT instruction. The
 * MWAIT instruction optionally provides additional extensions for advanced power management.
 */
#define CPUID_MONITOR_MWAIT                                          0x00000005
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 15:0] Smallest monitor-line size in bytes (default is processor's monitor granularity).
             */
            UINT32_t smallest_monitor_line_size : 16;
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_BIT                     0
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_FLAG                    0xFFFF
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_MASK                    0xFFFF
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE(_)                      (((_) >> 0) & 0xFFFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Largest monitor-line size in bytes (default is processor's monitor granularity).
             */
            UINT32_t largest_monitor_line_size : 16;
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_BIT                      0
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_FLAG                     0xFFFF
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_MASK                     0xFFFF
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE(_)                       (((_) >> 0) & 0xFFFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] Enumeration of Monitor-Mwait extensions (beyond EAX and EBX registers) supported.
             */
            UINT32_t enumeration_of_monitor_mwait_extensions : 1;
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_BIT        0
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_FLAG       0x01
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_MASK       0x01
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS(_)         (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Supports treating interrupts as break-event for MWAIT, even when interrupts disabled.
             */
            UINT32_t supports_treating_interrupts_as_break_event_for_mwait : 1;
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_BIT 1
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_FLAG 0x02
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_MASK 0x01
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT(_) (((_) >> 1) & 0x01)
            UINT32_t reserved1 : 30;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 3:0] Number of C0 sub C-states supported using MWAIT.
             */
            UINT32_t number_of_c0_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_BIT                      0
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_FLAG                     0x0F
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES(_)                       (((_) >> 0) & 0x0F)

            /**
             * [Bits 7:4] Number of C1 sub C-states supported using MWAIT.
             */
            UINT32_t number_of_c1_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_BIT                      4
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_FLAG                     0xF0
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES(_)                       (((_) >> 4) & 0x0F)

            /**
             * [Bits 11:8] Number of C2 sub C-states supported using MWAIT.
             */
            UINT32_t number_of_c2_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_BIT                      8
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_FLAG                     0xF00
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES(_)                       (((_) >> 8) & 0x0F)

            /**
             * [Bits 15:12] Number of C3 sub C-states supported using MWAIT.
             */
            UINT32_t number_of_c3_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_BIT                      12
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_FLAG                     0xF000
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES(_)                       (((_) >> 12) & 0x0F)

            /**
             * [Bits 19:16] Number of C4 sub C-states supported using MWAIT.
             */
            UINT32_t number_of_c4_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_BIT                      16
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_FLAG                     0xF0000
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES(_)                       (((_) >> 16) & 0x0F)

            /**
             * [Bits 23:20] Number of C5 sub C-states supported using MWAIT.
             */
            UINT32_t number_of_c5_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_BIT                      20
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_FLAG                     0xF00000
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES(_)                       (((_) >> 20) & 0x0F)

            /**
             * [Bits 27:24] Number of C6 sub C-states supported using MWAIT.
             */
            UINT32_t number_of_c6_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_BIT                      24
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_FLAG                     0xF000000
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES(_)                       (((_) >> 24) & 0x0F)

            /**
             * [Bits 31:28] Number of C7 sub C-states supported using MWAIT.
             */
            UINT32_t number_of_c7_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_BIT                      28
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_FLAG                     0xF0000000
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES(_)                       (((_) >> 28) & 0x0F)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_05;


/**
 * @brief Thermal and Power Management Leaf
 *
 * When CPUID executes with EAX set to 06H, the processor returns information about thermal and power management features.
 */
#define CPUID_THERMAL_AND_POWER_MANAGEMENT                           0x00000006
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bit 0] Digital temperature sensor is supported if set.
             */
            UINT32_t temperature_sensor_supported : 1;
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_BIT                   0
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_FLAG                  0x01
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_MASK                  0x01
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED(_)                    (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Intel Turbo Boost Technology available (see description of IA32_MISC_ENABLE[38]).
             */
            UINT32_t intel_turbo_boost_technology_available : 1;
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_BIT         1
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_FLAG        0x02
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_MASK        0x01
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE(_)          (((_) >> 1) & 0x01)

            /**
             * [Bit 2] ARAT. APIC-Timer-always-running feature is supported if set.
             */
            UINT32_t apic_timer_always_running : 1;
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_BIT                      2
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_FLAG                     0x04
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_MASK                     0x01
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING(_)                       (((_) >> 2) & 0x01)
            UINT32_t reserved1 : 1;

            /**
             * [Bit 4] PLN. Power limit notification controls are supported if set.
             */
            UINT32_t power_limit_notification : 1;
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_BIT                       4
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_FLAG                      0x10
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_MASK                      0x01
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION(_)                        (((_) >> 4) & 0x01)

            /**
             * [Bit 5] ECMD. Clock modulation duty cycle extension is supported if set.
             */
            UINT32_t clock_modulation_duty : 1;
#define CPUID_EAX_CLOCK_MODULATION_DUTY_BIT                          5
#define CPUID_EAX_CLOCK_MODULATION_DUTY_FLAG                         0x20
#define CPUID_EAX_CLOCK_MODULATION_DUTY_MASK                         0x01
#define CPUID_EAX_CLOCK_MODULATION_DUTY(_)                           (((_) >> 5) & 0x01)

            /**
             * [Bit 6] PTM. Package thermal management is supported if set.
             */
            UINT32_t package_thermal_management : 1;
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_BIT                     6
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_FLAG                    0x40
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_MASK                    0x01
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT(_)                      (((_) >> 6) & 0x01)

            /**
             * [Bit 7] HWP. HWP base registers (IA32_PM_ENABLE[bit 0], IA32_HWP_CAPABILITIES, IA32_HWP_REQUEST, IA32_HWP_STATUS) are
             * supported if set.
             */
            UINT32_t hwp_base_registers : 1;
#define CPUID_EAX_HWP_BASE_REGISTERS_BIT                             7
#define CPUID_EAX_HWP_BASE_REGISTERS_FLAG                            0x80
#define CPUID_EAX_HWP_BASE_REGISTERS_MASK                            0x01
#define CPUID_EAX_HWP_BASE_REGISTERS(_)                              (((_) >> 7) & 0x01)

            /**
             * [Bit 8] HWP_Notification. IA32_HWP_INTERRUPT MSR is supported if set.
             */
            UINT32_t hwp_notification : 1;
#define CPUID_EAX_HWP_NOTIFICATION_BIT                               8
#define CPUID_EAX_HWP_NOTIFICATION_FLAG                              0x100
#define CPUID_EAX_HWP_NOTIFICATION_MASK                              0x01
#define CPUID_EAX_HWP_NOTIFICATION(_)                                (((_) >> 8) & 0x01)

            /**
             * [Bit 9] HWP_Activity_Window. IA32_HWP_REQUEST[bits 41:32] is supported if set.
             */
            UINT32_t hwp_activity_window : 1;
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_BIT                            9
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_FLAG                           0x200
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_MASK                           0x01
#define CPUID_EAX_HWP_ACTIVITY_WINDOW(_)                             (((_) >> 9) & 0x01)

            /**
             * [Bit 10] HWP_Energy_Performance_Preference. IA32_HWP_REQUEST[bits 31:24] is supported if set.
             */
            UINT32_t hwp_energy_performance_preference : 1;
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_BIT              10
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_FLAG             0x400
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_MASK             0x01
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE(_)               (((_) >> 10) & 0x01)

            /**
             * [Bit 11] HWP_Package_Level_Request. IA32_HWP_REQUEST_PKG MSR is supported if set.
             */
            UINT32_t hwp_package_level_request : 1;
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_BIT                      11
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_FLAG                     0x800
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_MASK                     0x01
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST(_)                       (((_) >> 11) & 0x01)
            UINT32_t reserved2 : 1;

            /**
             * [Bit 13] HDC. HDC base registers IA32_PKG_HDC_CTL, IA32_PM_CTL1, IA32_THREAD_STALL MSRs are supported if set.
             */
            UINT32_t hdc : 1;
#define CPUID_EAX_HDC_BIT                                            13
#define CPUID_EAX_HDC_FLAG                                           0x2000
#define CPUID_EAX_HDC_MASK                                           0x01
#define CPUID_EAX_HDC(_)                                             (((_) >> 13) & 0x01)

            /**
             * [Bit 14] Intel(R) Turbo Boost Max Technology 3.0 available.
             */
            UINT32_t intel_turbo_boost_max_technology_3_available : 1;
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_BIT   14
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_FLAG  0x4000
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_MASK  0x01
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE(_)    (((_) >> 14) & 0x01)

            /**
             * [Bit 15] HWP Capabilities. Highest Performance change is supported if set.
             */
            UINT32_t hwp_capabilities : 1;
#define CPUID_EAX_HWP_CAPABILITIES_BIT                               15
#define CPUID_EAX_HWP_CAPABILITIES_FLAG                              0x8000
#define CPUID_EAX_HWP_CAPABILITIES_MASK                              0x01
#define CPUID_EAX_HWP_CAPABILITIES(_)                                (((_) >> 15) & 0x01)

            /**
             * [Bit 16] HWP PECI override is supported if set.
             */
            UINT32_t hwp_peci_override : 1;
#define CPUID_EAX_HWP_PECI_OVERRIDE_BIT                              16
#define CPUID_EAX_HWP_PECI_OVERRIDE_FLAG                             0x10000
#define CPUID_EAX_HWP_PECI_OVERRIDE_MASK                             0x01
#define CPUID_EAX_HWP_PECI_OVERRIDE(_)                               (((_) >> 16) & 0x01)

            /**
             * [Bit 17] Flexible HWP is supported if set.
             */
            UINT32_t flexible_hwp : 1;
#define CPUID_EAX_FLEXIBLE_HWP_BIT                                   17
#define CPUID_EAX_FLEXIBLE_HWP_FLAG                                  0x20000
#define CPUID_EAX_FLEXIBLE_HWP_MASK                                  0x01
#define CPUID_EAX_FLEXIBLE_HWP(_)                                    (((_) >> 17) & 0x01)

            /**
             * [Bit 18] Fast access mode for the IA32_HWP_REQUEST MSR is supported if set.
             */
            UINT32_t fast_access_mode_for_hwp_request_msr : 1;
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_BIT           18
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_FLAG          0x40000
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_MASK          0x01
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR(_)            (((_) >> 18) & 0x01)
            UINT32_t reserved3 : 1;

            /**
             * [Bit 20] Ignoring Idle Logical Processor HWP request is supported if set.
             */
            UINT32_t ignoring_idle_logical_processor_hwp_request : 1;
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_BIT    20
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_FLAG   0x100000
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_MASK   0x01
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST(_)     (((_) >> 20) & 0x01)
            UINT32_t reserved4 : 11;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 3:0] Number of Interrupt Thresholds in Digital Thermal Sensor.
             */
            UINT32_t number_of_interrupt_thresholds_in_thermal_sensor : 4;
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_BIT 0
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_FLAG 0x0F
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_MASK 0x0F
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR(_) (((_) >> 0) & 0x0F)
            UINT32_t reserved1 : 28;
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] Hardware Coordination Feedback Capability (Presence of IA32_MPERF and IA32_APERF). The capability to provide a
             * measure of delivered processor performance (since last reset of the counters), as a percentage of the expected processor
             * performance when running at the TSC frequency.
             */
            UINT32_t hardware_coordination_feedback_capability : 1;
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_BIT      0
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_FLAG     0x01
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_MASK     0x01
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY(_)       (((_) >> 0) & 0x01)
            UINT32_t reserved1 : 2;

            /**
             * [Bit 3] The processor supports performance-energy bias preference if CPUID.06H:ECX.SETBH[bit 3] is set and it also
             * implies the presence of a new architectural MSR called IA32_ENERGY_PERF_BIAS (1B0H).
             */
            UINT32_t performance_energy_bias_preference : 1;
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_BIT             3
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_FLAG            0x08
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_MASK            0x01
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE(_)              (((_) >> 3) & 0x01)
            UINT32_t reserved2 : 28;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_06;


/**
 * @brief Structured Extended Feature Flags Enumeration Leaf (Output depends on ECX input value)
 *
 * When CPUID executes with EAX set to 07H and ECX = 0, the processor returns information about the maximum input value for
 * sub-leaves that contain extended feature flags.
 * When CPUID executes with EAX set to 07H and the input value of ECX is invalid (see leaf 07H entry in Table 3-8), the
 * processor returns 0 in EAX/EBX/ECX/EDX. In subleaf 0, EAX returns the maximum input value of the highest leaf 7
 * sub-leaf, and EBX, ECX & EDX contain information of extended feature flags.
 */
#define CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS                      0x00000007
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the maximum input value for supported leaf 7 sub-leaves.
             */
            UINT32_t number_of_sub_leaves : 32;
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_BIT                           0
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_FLAG                          0xFFFFFFFF
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_MASK                          0xFFFFFFFF
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES(_)                            (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] Supports RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE if 1.
             */
            UINT32_t fsgsbase : 1;
#define CPUID_EBX_FSGSBASE_BIT                                       0
#define CPUID_EBX_FSGSBASE_FLAG                                      0x01
#define CPUID_EBX_FSGSBASE_MASK                                      0x01
#define CPUID_EBX_FSGSBASE(_)                                        (((_) >> 0) & 0x01)

            /**
             * [Bit 1] IA32_TSC_ADJUST MSR is supported if 1.
             */
            UINT32_t ia32_tsc_adjust_msr : 1;
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_BIT                            1
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_FLAG                           0x02
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_MASK                           0x01
#define CPUID_EBX_IA32_TSC_ADJUST_MSR(_)                             (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports Intel(R) Software Guard Extensions (Intel(R) SGX Extensions) if 1.
             */
            UINT32_t sgx : 1;
#define CPUID_EBX_SGX_BIT                                            2
#define CPUID_EBX_SGX_FLAG                                           0x04
#define CPUID_EBX_SGX_MASK                                           0x01
#define CPUID_EBX_SGX(_)                                             (((_) >> 2) & 0x01)

            /**
             * [Bit 3] BMI1.
             */
            UINT32_t bmi1 : 1;
#define CPUID_EBX_BMI1_BIT                                           3
#define CPUID_EBX_BMI1_FLAG                                          0x08
#define CPUID_EBX_BMI1_MASK                                          0x01
#define CPUID_EBX_BMI1(_)                                            (((_) >> 3) & 0x01)

            /**
             * [Bit 4] HLE.
             */
            UINT32_t hle : 1;
#define CPUID_EBX_HLE_BIT                                            4
#define CPUID_EBX_HLE_FLAG                                           0x10
#define CPUID_EBX_HLE_MASK                                           0x01
#define CPUID_EBX_HLE(_)                                             (((_) >> 4) & 0x01)

            /**
             * [Bit 5] AVX2.
             */
            UINT32_t avx2 : 1;
#define CPUID_EBX_AVX2_BIT                                           5
#define CPUID_EBX_AVX2_FLAG                                          0x20
#define CPUID_EBX_AVX2_MASK                                          0x01
#define CPUID_EBX_AVX2(_)                                            (((_) >> 5) & 0x01)

            /**
             * [Bit 6] x87 FPU Data Pointer updated only on x87 exceptions if 1.
             */
            UINT32_t fdp_excptn_only : 1;
#define CPUID_EBX_FDP_EXCPTN_ONLY_BIT                                6
#define CPUID_EBX_FDP_EXCPTN_ONLY_FLAG                               0x40
#define CPUID_EBX_FDP_EXCPTN_ONLY_MASK                               0x01
#define CPUID_EBX_FDP_EXCPTN_ONLY(_)                                 (((_) >> 6) & 0x01)

            /**
             * [Bit 7] Supports Supervisor-Mode Execution Prevention if 1.
             */
            UINT32_t smep : 1;
#define CPUID_EBX_SMEP_BIT                                           7
#define CPUID_EBX_SMEP_FLAG                                          0x80
#define CPUID_EBX_SMEP_MASK                                          0x01
#define CPUID_EBX_SMEP(_)                                            (((_) >> 7) & 0x01)

            /**
             * [Bit 8] BMI2.
             */
            UINT32_t bmi2 : 1;
#define CPUID_EBX_BMI2_BIT                                           8
#define CPUID_EBX_BMI2_FLAG                                          0x100
#define CPUID_EBX_BMI2_MASK                                          0x01
#define CPUID_EBX_BMI2(_)                                            (((_) >> 8) & 0x01)

            /**
             * [Bit 9] Supports Enhanced REP MOVSB/STOSB if 1.
             */
            UINT32_t enhanced_rep_movsb_stosb : 1;
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_BIT                       9
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_FLAG                      0x200
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_MASK                      0x01
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB(_)                        (((_) >> 9) & 0x01)

            /**
             * [Bit 10] If 1, supports INVPCID instruction for system software that manages process-context identifiers.
             */
            UINT32_t invpcid : 1;
#define CPUID_EBX_INVPCID_BIT                                        10
#define CPUID_EBX_INVPCID_FLAG                                       0x400
#define CPUID_EBX_INVPCID_MASK                                       0x01
#define CPUID_EBX_INVPCID(_)                                         (((_) >> 10) & 0x01)

            /**
             * [Bit 11] RTM.
             */
            UINT32_t rtm : 1;
#define CPUID_EBX_RTM_BIT                                            11
#define CPUID_EBX_RTM_FLAG                                           0x800
#define CPUID_EBX_RTM_MASK                                           0x01
#define CPUID_EBX_RTM(_)                                             (((_) >> 11) & 0x01)

            /**
             * [Bit 12] Supports Intel(R) Resource Director Technology (Intel(R) RDT) Monitoring capability if 1.
             */
            UINT32_t rdt_m : 1;
#define CPUID_EBX_RDT_M_BIT                                          12
#define CPUID_EBX_RDT_M_FLAG                                         0x1000
#define CPUID_EBX_RDT_M_MASK                                         0x01
#define CPUID_EBX_RDT_M(_)                                           (((_) >> 12) & 0x01)

            /**
             * [Bit 13] Deprecates FPU CS and FPU DS values if 1.
             */
            UINT32_t deprecates : 1;
#define CPUID_EBX_DEPRECATES_BIT                                     13
#define CPUID_EBX_DEPRECATES_FLAG                                    0x2000
#define CPUID_EBX_DEPRECATES_MASK                                    0x01
#define CPUID_EBX_DEPRECATES(_)                                      (((_) >> 13) & 0x01)

            /**
             * [Bit 14] Supports Intel(R) Memory Protection Extensions if 1.
             */
            UINT32_t mpx : 1;
#define CPUID_EBX_MPX_BIT                                            14
#define CPUID_EBX_MPX_FLAG                                           0x4000
#define CPUID_EBX_MPX_MASK                                           0x01
#define CPUID_EBX_MPX(_)                                             (((_) >> 14) & 0x01)

            /**
             * [Bit 15] Supports Intel(R) Resource Director Technology (Intel(R) RDT) Allocation capability if 1.
             */
            UINT32_t rdt : 1;
#define CPUID_EBX_RDT_BIT                                            15
#define CPUID_EBX_RDT_FLAG                                           0x8000
#define CPUID_EBX_RDT_MASK                                           0x01
#define CPUID_EBX_RDT(_)                                             (((_) >> 15) & 0x01)

            /**
             * [Bit 16] AVX512F.
             */
            UINT32_t avx512f : 1;
#define CPUID_EBX_AVX512F_BIT                                        16
#define CPUID_EBX_AVX512F_FLAG                                       0x10000
#define CPUID_EBX_AVX512F_MASK                                       0x01
#define CPUID_EBX_AVX512F(_)                                         (((_) >> 16) & 0x01)

            /**
             * [Bit 17] AVX512DQ.
             */
            UINT32_t avx512dq : 1;
#define CPUID_EBX_AVX512DQ_BIT                                       17
#define CPUID_EBX_AVX512DQ_FLAG                                      0x20000
#define CPUID_EBX_AVX512DQ_MASK                                      0x01
#define CPUID_EBX_AVX512DQ(_)                                        (((_) >> 17) & 0x01)

            /**
             * [Bit 18] RDSEED.
             */
            UINT32_t rdseed : 1;
#define CPUID_EBX_RDSEED_BIT                                         18
#define CPUID_EBX_RDSEED_FLAG                                        0x40000
#define CPUID_EBX_RDSEED_MASK                                        0x01
#define CPUID_EBX_RDSEED(_)                                          (((_) >> 18) & 0x01)

            /**
             * [Bit 19] ADX.
             */
            UINT32_t adx : 1;
#define CPUID_EBX_ADX_BIT                                            19
#define CPUID_EBX_ADX_FLAG                                           0x80000
#define CPUID_EBX_ADX_MASK                                           0x01
#define CPUID_EBX_ADX(_)                                             (((_) >> 19) & 0x01)

            /**
             * [Bit 20] Supports Supervisor-Mode Access Prevention (and the CLAC/STAC instructions) if 1.
             */
            UINT32_t smap : 1;
#define CPUID_EBX_SMAP_BIT                                           20
#define CPUID_EBX_SMAP_FLAG                                          0x100000
#define CPUID_EBX_SMAP_MASK                                          0x01
#define CPUID_EBX_SMAP(_)                                            (((_) >> 20) & 0x01)

            /**
             * [Bit 21] AVX512_IFMA.
             */
            UINT32_t avx512_ifma : 1;
#define CPUID_EBX_AVX512_IFMA_BIT                                    21
#define CPUID_EBX_AVX512_IFMA_FLAG                                   0x200000
#define CPUID_EBX_AVX512_IFMA_MASK                                   0x01
#define CPUID_EBX_AVX512_IFMA(_)                                     (((_) >> 21) & 0x01)
            UINT32_t reserved1 : 1;

            /**
             * [Bit 23] CLFLUSHOPT.
             */
            UINT32_t clflushopt : 1;
#define CPUID_EBX_CLFLUSHOPT_BIT                                     23
#define CPUID_EBX_CLFLUSHOPT_FLAG                                    0x800000
#define CPUID_EBX_CLFLUSHOPT_MASK                                    0x01
#define CPUID_EBX_CLFLUSHOPT(_)                                      (((_) >> 23) & 0x01)

            /**
             * [Bit 24] CLWB.
             */
            UINT32_t clwb : 1;
#define CPUID_EBX_CLWB_BIT                                           24
#define CPUID_EBX_CLWB_FLAG                                          0x1000000
#define CPUID_EBX_CLWB_MASK                                          0x01
#define CPUID_EBX_CLWB(_)                                            (((_) >> 24) & 0x01)

            /**
             * [Bit 25] Intel Processor Trace.
             */
            UINT32_t intel : 1;
#define CPUID_EBX_INTEL_BIT                                          25
#define CPUID_EBX_INTEL_FLAG                                         0x2000000
#define CPUID_EBX_INTEL_MASK                                         0x01
#define CPUID_EBX_INTEL(_)                                           (((_) >> 25) & 0x01)

            /**
             * [Bit 26] (Intel(R) Xeon Phi(TM) only).
             */
            UINT32_t avx512pf : 1;
#define CPUID_EBX_AVX512PF_BIT                                       26
#define CPUID_EBX_AVX512PF_FLAG                                      0x4000000
#define CPUID_EBX_AVX512PF_MASK                                      0x01
#define CPUID_EBX_AVX512PF(_)                                        (((_) >> 26) & 0x01)

            /**
             * [Bit 27] (Intel(R) Xeon Phi(TM) only).
             */
            UINT32_t avx512er : 1;
#define CPUID_EBX_AVX512ER_BIT                                       27
#define CPUID_EBX_AVX512ER_FLAG                                      0x8000000
#define CPUID_EBX_AVX512ER_MASK                                      0x01
#define CPUID_EBX_AVX512ER(_)                                        (((_) >> 27) & 0x01)

            /**
             * [Bit 28] AVX512CD.
             */
            UINT32_t avx512cd : 1;
#define CPUID_EBX_AVX512CD_BIT                                       28
#define CPUID_EBX_AVX512CD_FLAG                                      0x10000000
#define CPUID_EBX_AVX512CD_MASK                                      0x01
#define CPUID_EBX_AVX512CD(_)                                        (((_) >> 28) & 0x01)

            /**
             * [Bit 29] Supports Intel(R) Secure Hash Algorithm Extensions (Intel(R) SHA Extensions) if 1.
             */
            UINT32_t sha : 1;
#define CPUID_EBX_SHA_BIT                                            29
#define CPUID_EBX_SHA_FLAG                                           0x20000000
#define CPUID_EBX_SHA_MASK                                           0x01
#define CPUID_EBX_SHA(_)                                             (((_) >> 29) & 0x01)

            /**
             * [Bit 30] AVX512BW.
             */
            UINT32_t avx512bw : 1;
#define CPUID_EBX_AVX512BW_BIT                                       30
#define CPUID_EBX_AVX512BW_FLAG                                      0x40000000
#define CPUID_EBX_AVX512BW_MASK                                      0x01
#define CPUID_EBX_AVX512BW(_)                                        (((_) >> 30) & 0x01)

            /**
             * [Bit 31] AVX512VL.
             */
            UINT32_t avx512vl : 1;
#define CPUID_EBX_AVX512VL_BIT                                       31
#define CPUID_EBX_AVX512VL_FLAG                                      0x80000000
#define CPUID_EBX_AVX512VL_MASK                                      0x01
#define CPUID_EBX_AVX512VL(_)                                        (((_) >> 31) & 0x01)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] (Intel(R) Xeon Phi(TM) only).
             */
            UINT32_t prefetchwt1 : 1;
#define CPUID_ECX_PREFETCHWT1_BIT                                    0
#define CPUID_ECX_PREFETCHWT1_FLAG                                   0x01
#define CPUID_ECX_PREFETCHWT1_MASK                                   0x01
#define CPUID_ECX_PREFETCHWT1(_)                                     (((_) >> 0) & 0x01)

            /**
             * [Bit 1] AVX512_VBMI.
             */
            UINT32_t avx512_vbmi : 1;
#define CPUID_ECX_AVX512_VBMI_BIT                                    1
#define CPUID_ECX_AVX512_VBMI_FLAG                                   0x02
#define CPUID_ECX_AVX512_VBMI_MASK                                   0x01
#define CPUID_ECX_AVX512_VBMI(_)                                     (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports user-mode instruction prevention if 1.
             */
            UINT32_t umip : 1;
#define CPUID_ECX_UMIP_BIT                                           2
#define CPUID_ECX_UMIP_FLAG                                          0x04
#define CPUID_ECX_UMIP_MASK                                          0x01
#define CPUID_ECX_UMIP(_)                                            (((_) >> 2) & 0x01)

            /**
             * [Bit 3] Supports protection keys for user-mode pages if 1.
             */
            UINT32_t pku : 1;
#define CPUID_ECX_PKU_BIT                                            3
#define CPUID_ECX_PKU_FLAG                                           0x08
#define CPUID_ECX_PKU_MASK                                           0x01
#define CPUID_ECX_PKU(_)                                             (((_) >> 3) & 0x01)

            /**
             * [Bit 4] If 1, OS has set CR4.PKE to enable protection keys (and the RDPKRU/WRPKRU instructions).
             */
            UINT32_t ospke : 1;
#define CPUID_ECX_OSPKE_BIT                                          4
#define CPUID_ECX_OSPKE_FLAG                                         0x10
#define CPUID_ECX_OSPKE_MASK                                         0x01
#define CPUID_ECX_OSPKE(_)                                           (((_) >> 4) & 0x01)
            UINT32_t reserved1 : 12;

            /**
             * [Bits 21:17] The value of MAWAU used by the BNDLDX and BNDSTX instructions in 64-bit mode.
             */
            UINT32_t mawau : 5;
#define CPUID_ECX_MAWAU_BIT                                          17
#define CPUID_ECX_MAWAU_FLAG                                         0x3E0000
#define CPUID_ECX_MAWAU_MASK                                         0x1F
#define CPUID_ECX_MAWAU(_)                                           (((_) >> 17) & 0x1F)

            /**
             * [Bit 22] RDPID and IA32_TSC_AUX are available if 1.
             */
            UINT32_t rdpid : 1;
#define CPUID_ECX_RDPID_BIT                                          22
#define CPUID_ECX_RDPID_FLAG                                         0x400000
#define CPUID_ECX_RDPID_MASK                                         0x01
#define CPUID_ECX_RDPID(_)                                           (((_) >> 22) & 0x01)
            UINT32_t reserved2 : 7;

            /**
             * [Bit 30] Supports SGX Launch Configuration if 1.
             */
            UINT32_t sgx_lc : 1;
#define CPUID_ECX_SGX_LC_BIT                                         30
#define CPUID_ECX_SGX_LC_FLAG                                        0x40000000
#define CPUID_ECX_SGX_LC_MASK                                        0x01
#define CPUID_ECX_SGX_LC(_)                                          (((_) >> 30) & 0x01)
            UINT32_t reserved3 : 1;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_07;


/**
 * @brief Direct Cache Access Information Leaf
 *
 * When CPUID executes with EAX set to 09H, the processor returns information about Direct Cache Access capabilities.
 */
#define CPUID_DIRECT_CACHE_ACCESS_INFORMATION                        0x00000009
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H).
             */
            UINT32_t ia32_platform_dca_cap : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT                          0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)                           (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_09;


/**
 * @brief Architectural Performance Monitoring Leaf
 *
 * When CPUID executes with EAX set to 0AH, the processor returns information about support for architectural performance
 * monitoring capabilities. Architectural performance monitoring is supported if the version ID is greater than Pn 0. For
 * each version of architectural performance monitoring capability, software must enumerate this leaf to discover the
 * programming facilities and the architectural performance events available in the processor.
 *
 * @see Vol3C[23(Introduction to Virtual-Machine Extensions)]
 */
#define CPUID_ARCHITECTURAL_PERFORMANCE_MONITORING                   0x0000000A
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 7:0] Version ID of architectural performance monitoring.
             */
            UINT32_t version_id_of_architectural_performance_monitoring : 8;
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_BIT 0
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_FLAG 0xFF
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_MASK 0xFF
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING(_) (((_) >> 0) & 0xFF)

            /**
             * [Bits 15:8] Number of general-purpose performance monitoring counter per logical processor.
             */
            UINT32_t number_of_performance_monitoring_counter_per_logical_processor : 8;
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_BIT 8
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_FLAG 0xFF00
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_MASK 0xFF
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR(_) (((_) >> 8) & 0xFF)

            /**
             * [Bits 23:16] Bit width of general-purpose, performance monitoring counter.
             */
            UINT32_t bit_width_of_performance_monitoring_counter : 8;
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_BIT    16
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_FLAG   0xFF0000
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_MASK   0xFF
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER(_)     (((_) >> 16) & 0xFF)

            /**
             * [Bits 31:24] Length of EBX bit vector to enumerate architectural performance monitoring events.
             */
            UINT32_t ebx_bit_vector_length : 8;
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_BIT                          24
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_FLAG                         0xFF000000
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_MASK                         0xFF
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH(_)                           (((_) >> 24) & 0xFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] Core cycle event not available if 1.
             */
            UINT32_t core_cycle_event_not_available : 1;
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_BIT                 0
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_FLAG                0x01
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_MASK                0x01
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE(_)                  (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Instruction retired event not available if 1.
             */
            UINT32_t instruction_retired_event_not_available : 1;
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_BIT        1
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_FLAG       0x02
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_MASK       0x01
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE(_)         (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Reference cycles event not available if 1.
             */
            UINT32_t reference_cycles_event_not_available : 1;
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_BIT           2
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_FLAG          0x04
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_MASK          0x01
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE(_)            (((_) >> 2) & 0x01)

            /**
             * [Bit 3] Last-level cache reference event not available if 1.
             */
            UINT32_t last_level_cache_reference_event_not_available : 1;
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_BIT 3
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_FLAG 0x08
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE(_)  (((_) >> 3) & 0x01)

            /**
             * [Bit 4] Last-level cache misses event not available if 1.
             */
            UINT32_t last_level_cache_misses_event_not_available : 1;
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_BIT    4
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_FLAG   0x10
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_MASK   0x01
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE(_)     (((_) >> 4) & 0x01)

            /**
             * [Bit 5] Branch instruction retired event not available if 1.
             */
            UINT32_t branch_instruction_retired_event_not_available : 1;
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_BIT 5
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_FLAG 0x20
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE(_)  (((_) >> 5) & 0x01)

            /**
             * [Bit 6] Branch mispredict retired event not available if 1.
             */
            UINT32_t branch_mispredict_retired_event_not_available : 1;
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_BIT  6
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_FLAG 0x40
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE(_)   (((_) >> 6) & 0x01)
            UINT32_t reserved1 : 25;
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 4:0] Number of fixed-function performance counters (if Version ID > 1).
             */
            UINT32_t number_of_fixed_function_performance_counters : 5;
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_BIT  0
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_FLAG 0x1F
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_MASK 0x1F
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS(_)   (((_) >> 0) & 0x1F)

            /**
             * [Bits 12:5] Bit width of fixed-function performance counters (if Version ID > 1).
             */
            UINT32_t bit_width_of_fixed_function_performance_counters : 8;
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_BIT 5
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_FLAG 0x1FE0
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_MASK 0xFF
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS(_) (((_) >> 5) & 0xFF)
            UINT32_t reserved1 : 2;

            /**
             * [Bit 15] AnyThread deprecation.
             */
            UINT32_t any_thread_deprecation : 1;
#define CPUID_EDX_ANY_THREAD_DEPRECATION_BIT                         15
#define CPUID_EDX_ANY_THREAD_DEPRECATION_FLAG                        0x8000
#define CPUID_EDX_ANY_THREAD_DEPRECATION_MASK                        0x01
#define CPUID_EDX_ANY_THREAD_DEPRECATION(_)                          (((_) >> 15) & 0x01)
            UINT32_t reserved2 : 16;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_0a;


/**
 * @brief Extended Topology Enumeration Leaf
 *
 * When CPUID executes with EAX set to 0BH, the processor returns information about extended topology enumeration data.
 * Software must detect the presence of CPUID leaf 0BH by verifying
 * - the highest leaf index supported by CPUID is >= 0BH, and
 * - CPUID.0BH:EBX[15:0] reports a non-zero value.
 *
 * @note Most of Leaf 0BH output depends on the initial value in ECX. The EDX output of leaf 0BH is always valid and does
 *       not vary with input value in ECX. Output value in ECX[7:0] always equals input value in ECX[7:0]. Sub-leaf index 0
 *       enumerates SMT level. Each subsequent higher sub-leaf index enumerates a higherlevel topological entity in hierarchical
 *       order. For sub-leaves that return an invalid level-type of 0 in ECX[15:8]; EAX and EBX will return 0. If an input value
 *       n in ECX returns the invalid level-type of 0 in ECX[15:8], other input values with ECX > n also return 0 in ECX[15:8].
 */
#define CPUID_EXTENDED_TOPOLOGY                                      0x0000000B
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 4:0] Number of bits to shift right on x2APIC ID to get a unique topology ID of the next level type. All logical
             * processors with the same next level ID share current level.
             *
             * @note Software should use this field (EAX[4:0]) to enumerate processor topology of the system.
             */
            UINT32_t x2apic_id_to_unique_topology_id_shift : 5;
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_BIT          0
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_FLAG         0x1F
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_MASK         0x1F
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT(_)           (((_) >> 0) & 0x1F)
            UINT32_t reserved1 : 27;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Number of logical processors at this level type. The number reflects configuration as shipped by Intel.
             *
             * @note Software must not use EBX[15:0] to enumerate processor topology of the system. This value in this field
             *       (EBX[15:0]) is only intended for display/diagnostic purposes. The actual number of logical processors available to
             *       BIOS/OS/Applications may be different from the value of EBX[15:0], depending on software and platform hardware
             *       configurations.
             */
            UINT32_t number_of_logical_processors_at_this_level_type : 16;
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_BIT 0
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_FLAG 0xFFFF
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_MASK 0xFFFF
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE(_) (((_) >> 0) & 0xFFFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 7:0] Level number. Same value in ECX input.
             */
            UINT32_t level_number : 8;
#define CPUID_ECX_LEVEL_NUMBER_BIT                                   0
#define CPUID_ECX_LEVEL_NUMBER_FLAG                                  0xFF
#define CPUID_ECX_LEVEL_NUMBER_MASK                                  0xFF
#define CPUID_ECX_LEVEL_NUMBER(_)                                    (((_) >> 0) & 0xFF)

            /**
             * [Bits 15:8] Level type.
             *
             * @note The value of the "level type" field is not related to level numbers in any way, higher "level type" values do not
             *       mean higher levels. Level type field has the following encoding:
             *       - 0: Invalid.
             *       - 1: SMT.
             *       - 2: Core.
             *       - 3-255: Reserved.
             */
            UINT32_t level_type : 8;
#define CPUID_ECX_LEVEL_TYPE_BIT                                     8
#define CPUID_ECX_LEVEL_TYPE_FLAG                                    0xFF00
#define CPUID_ECX_LEVEL_TYPE_MASK                                    0xFF
#define CPUID_ECX_LEVEL_TYPE(_)                                      (((_) >> 8) & 0xFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] x2APIC ID the current logical processor.
             */
            UINT32_t x2apic_id : 32;
#define CPUID_EDX_X2APIC_ID_BIT                                      0
#define CPUID_EDX_X2APIC_ID_FLAG                                     0xFFFFFFFF
#define CPUID_EDX_X2APIC_ID_MASK                                     0xFFFFFFFF
#define CPUID_EDX_X2APIC_ID(_)                                       (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_0b;

/**
 * @defgroup cpuid_eax_0d \
 *           EAX = 0x0D
 *
 * When CPUID executes with EAX set to 0DH and ECX = 0, the processor returns information about the bit-vector
 * representation of all processor state extensions that are supported in the processor and storage size requirements of
 * the XSAVE/XRSTOR area.
 * When CPUID executes with EAX set to 0DH and ECX = n (n > 1, and is a valid sub-leaf index), the processor returns
 * information about the size and offset of each processor extended state save area within the XSAVE/XRSTOR area. Software
 * can use the forward-extendable technique depicted below to query the valid sub-leaves and obtain size and offset
 * information for each processor extended state save area:
 * <pre> For i = 2 to 62 // sub-leaf 1 is reserved IF (CPUID.(EAX=0DH, ECX=0):VECTOR[i] = 1) // VECTOR is the 64-bit value
 * of EDX:EAX Execute CPUID.(EAX=0DH, ECX = i) to examine size and offset for sub-leaf i; FI; </pre>
 * @{
 */
#define CPUID_EXTENDED_STATE_INFORMATION                             0x0000000D
 /**
  * @brief Processor Extended State Enumeration Main Leaf (EAX = 0DH, ECX = 0)
  */
typedef struct
{
    /**
     * @brief Reports the supported bits of the lower 32 bits of XCR0. XCR0[n] can be set to 1 only if EAX[n] is 1
     */
    union
    {
        struct
        {
            /**
             * [Bit 0] x87 state.
             */
            UINT32_t x87_state : 1;
#define CPUID_EAX_X87_STATE_BIT                                      0
#define CPUID_EAX_X87_STATE_FLAG                                     0x01
#define CPUID_EAX_X87_STATE_MASK                                     0x01
#define CPUID_EAX_X87_STATE(_)                                       (((_) >> 0) & 0x01)

            /**
             * [Bit 1] SSE state.
             */
            UINT32_t sse_state : 1;
#define CPUID_EAX_SSE_STATE_BIT                                      1
#define CPUID_EAX_SSE_STATE_FLAG                                     0x02
#define CPUID_EAX_SSE_STATE_MASK                                     0x01
#define CPUID_EAX_SSE_STATE(_)                                       (((_) >> 1) & 0x01)

            /**
             * [Bit 2] AVX state.
             */
            UINT32_t avx_state : 1;
#define CPUID_EAX_AVX_STATE_BIT                                      2
#define CPUID_EAX_AVX_STATE_FLAG                                     0x04
#define CPUID_EAX_AVX_STATE_MASK                                     0x01
#define CPUID_EAX_AVX_STATE(_)                                       (((_) >> 2) & 0x01)

            /**
             * [Bits 4:3] MPX state.
             */
            UINT32_t mpx_state : 2;
#define CPUID_EAX_MPX_STATE_BIT                                      3
#define CPUID_EAX_MPX_STATE_FLAG                                     0x18
#define CPUID_EAX_MPX_STATE_MASK                                     0x03
#define CPUID_EAX_MPX_STATE(_)                                       (((_) >> 3) & 0x03)

            /**
             * [Bits 7:5] AVX-512 state.
             */
            UINT32_t avx_512_state : 3;
#define CPUID_EAX_AVX_512_STATE_BIT                                  5
#define CPUID_EAX_AVX_512_STATE_FLAG                                 0xE0
#define CPUID_EAX_AVX_512_STATE_MASK                                 0x07
#define CPUID_EAX_AVX_512_STATE(_)                                   (((_) >> 5) & 0x07)

            /**
             * [Bit 8] Used for IA32_XSS.
             */
            UINT32_t used_for_ia32_xss_1 : 1;
#define CPUID_EAX_USED_FOR_IA32_XSS_1_BIT                            8
#define CPUID_EAX_USED_FOR_IA32_XSS_1_FLAG                           0x100
#define CPUID_EAX_USED_FOR_IA32_XSS_1_MASK                           0x01
#define CPUID_EAX_USED_FOR_IA32_XSS_1(_)                             (((_) >> 8) & 0x01)

            /**
             * [Bit 9] PKRU state.
             */
            UINT32_t pkru_state : 1;
#define CPUID_EAX_PKRU_STATE_BIT                                     9
#define CPUID_EAX_PKRU_STATE_FLAG                                    0x200
#define CPUID_EAX_PKRU_STATE_MASK                                    0x01
#define CPUID_EAX_PKRU_STATE(_)                                      (((_) >> 9) & 0x01)
            UINT32_t reserved1 : 3;

            /**
             * [Bit 13] Used for IA32_XSS.
             */
            UINT32_t used_for_ia32_xss_2 : 1;
#define CPUID_EAX_USED_FOR_IA32_XSS_2_BIT                            13
#define CPUID_EAX_USED_FOR_IA32_XSS_2_FLAG                           0x2000
#define CPUID_EAX_USED_FOR_IA32_XSS_2_MASK                           0x01
#define CPUID_EAX_USED_FOR_IA32_XSS_2(_)                             (((_) >> 13) & 0x01)
            UINT32_t reserved2 : 18;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) required by enabled features in XCR0.
             * May be different than ECX if some features at the end of the XSAVE save area are not enabled.
             */
            UINT32_t max_size_required_by_enabled_features_in_xcr0 : 32;
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_BIT  0
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_FLAG 0xFFFFFFFF
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_MASK 0xFFFFFFFF
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0(_)   (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) of the XSAVE/XRSTOR save area
             * required by all supported features in the processor, i.e., all the valid bit fields in XCR0.
             */
            UINT32_t max_size_of_xsave_xrstor_save_area : 32;
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_BIT             0
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_FLAG            0xFFFFFFFF
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_MASK            0xFFFFFFFF
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA(_)              (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the supported bits of the upper 32 bits of XCR0. XCR0[n+32] can be set to 1 only if EDX[n] is 1.
             */
            UINT32_t xcr0_supported_bits : 32;
#define CPUID_EDX_XCR0_SUPPORTED_BITS_BIT                            0
#define CPUID_EDX_XCR0_SUPPORTED_BITS_FLAG                           0xFFFFFFFF
#define CPUID_EDX_XCR0_SUPPORTED_BITS_MASK                           0xFFFFFFFF
#define CPUID_EDX_XCR0_SUPPORTED_BITS(_)                             (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_0d_ecx_00;

/**
 * @brief Direct Cache Access Information Leaf
 */
typedef struct
{
    union
    {
        struct
        {
            UINT32_t reserved1 : 1;

            /**
             * [Bit 1] Supports XSAVEC and the compacted form of XRSTOR if set.
             */
            UINT32_t supports_xsavec_and_compacted_xrstor : 1;
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_BIT           1
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_FLAG          0x02
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_MASK          0x01
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR(_)            (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports XGETBV with ECX = 1 if set.
             */
            UINT32_t supports_xgetbv_with_ecx_1 : 1;
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_BIT                     2
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_FLAG                    0x04
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_MASK                    0x01
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1(_)                      (((_) >> 2) & 0x01)

            /**
             * [Bit 3] Supports XSAVES/XRSTORS and IA32_XSS if set.
             */
            UINT32_t supports_xsave_xrstor_and_ia32_xss : 1;
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_BIT             3
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_FLAG            0x08
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_MASK            0x01
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS(_)              (((_) >> 3) & 0x01)
            UINT32_t reserved2 : 28;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] The size in bytes of the XSAVE area containing all states enabled by XCRO | IA32_XSS.
             */
            UINT32_t size_of_xsave_aread : 32;
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_BIT                            0
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_FLAG                           0xFFFFFFFF
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_MASK                           0xFFFFFFFF
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD(_)                             (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 7:0] Used for XCR0.
             */
            UINT32_t used_for_xcr0_1 : 8;
#define CPUID_ECX_USED_FOR_XCR0_1_BIT                                0
#define CPUID_ECX_USED_FOR_XCR0_1_FLAG                               0xFF
#define CPUID_ECX_USED_FOR_XCR0_1_MASK                               0xFF
#define CPUID_ECX_USED_FOR_XCR0_1(_)                                 (((_) >> 0) & 0xFF)

            /**
             * [Bit 8] PT state.
             */
            UINT32_t pt_state : 1;
#define CPUID_ECX_PT_STATE_BIT                                       8
#define CPUID_ECX_PT_STATE_FLAG                                      0x100
#define CPUID_ECX_PT_STATE_MASK                                      0x01
#define CPUID_ECX_PT_STATE(_)                                        (((_) >> 8) & 0x01)

            /**
             * [Bit 9] Used for XCR0.
             */
            UINT32_t used_for_xcr0_2 : 1;
#define CPUID_ECX_USED_FOR_XCR0_2_BIT                                9
#define CPUID_ECX_USED_FOR_XCR0_2_FLAG                               0x200
#define CPUID_ECX_USED_FOR_XCR0_2_MASK                               0x01
#define CPUID_ECX_USED_FOR_XCR0_2(_)                                 (((_) >> 9) & 0x01)
            UINT32_t reserved1 : 3;

            /**
             * [Bit 13] HWP state.
             */
            UINT32_t hwp_state : 1;
#define CPUID_ECX_HWP_STATE_BIT                                      13
#define CPUID_ECX_HWP_STATE_FLAG                                     0x2000
#define CPUID_ECX_HWP_STATE_MASK                                     0x01
#define CPUID_ECX_HWP_STATE(_)                                       (((_) >> 13) & 0x01)
            UINT32_t reserved2 : 18;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_0d_ecx_01;

/**
 * @brief Processor Extended State Enumeration Sub-leaves (EAX = 0DH, ECX = n, n > 1)
 *
 * @note Leaf 0DH output depends on the initial value in ECX. Each sub-leaf index (starting at position 2) is supported if
 *       it corresponds to a supported bit in either the XCR0 register or the IA32_XSS MSR.
 *       If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf n (0 <= n <= 31) is invalid if sub-leaf 0
 *       returns 0 in EAX[n] and sub-leaf 1 returns 0 in ECX[n]. Sub-leaf n (32 <= n <= 63) is invalid if sub-leaf 0 returns 0 in
 *       EDX[n-32] and sub-leaf 1 returns 0 in EDX[n-32].
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] The size in bytes (from the offset specified in EBX) of the save area for an extended state feature
             * associated with a valid sub-leaf index, n.
             */
            UINT32_t ia32_platform_dca_cap : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT                          0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)                           (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] The offset in bytes of this extended state component's save area from the beginning of the XSAVE/XRSTOR
             * area.
             * This field reports 0 if the sub-leaf index, n, does not map to a valid bit in the XCR0 register.
             */
            UINT32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] Is set if the bit n (corresponding to the sub-leaf index) is supported in the IA32_XSS MSR; it is clear if bit n
             * is instead supported in XCR0.
             */
            UINT32_t ecx_2 : 1;
#define CPUID_ECX_ECX_2_BIT                                          0
#define CPUID_ECX_ECX_2_FLAG                                         0x01
#define CPUID_ECX_ECX_2_MASK                                         0x01
#define CPUID_ECX_ECX_2(_)                                           (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Is set if, when the compacted format of an XSAVE area is used, this extended state component located on the next
             * 64-byte boundary following the preceding state component (otherwise, it is located immediately following the preceding
             * state component).
             */
            UINT32_t ecx_1 : 1;
#define CPUID_ECX_ECX_1_BIT                                          1
#define CPUID_ECX_ECX_1_FLAG                                         0x02
#define CPUID_ECX_ECX_1_MASK                                         0x01
#define CPUID_ECX_ECX_1(_)                                           (((_) >> 1) & 0x01)
            UINT32_t reserved1 : 30;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] This field reports 0 if the sub-leaf index, n, is invalid; otherwise it is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_0d_ecx_n;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_0f \
  *           EAX = 0x0F
  *
  * When CPUID executes with EAX set to 0FH and ECX = 0, the processor returns information about the bit-vector
  * representation of QoS monitoring resource types that are supported in the processor and maximum range of RMID values the
  * processor can use to monitor of any supported resource types. Each bit, starting from bit 1, corresponds to a specific
  * resource type if the bit is set. The bit position corresponds to the sub-leaf index (or ResID) that software must use to
  * query QoS monitoring capability available for that type. See Table 3-8.
  * When CPUID executes with EAX set to 0FH and ECX = n (n >= 1, and is a valid ResID), the processor returns information
  * software can use to program IA32_PQR_ASSOC, IA32_QM_EVTSEL MSRs before reading QoS data from the IA32_QM_CTR MSR.
  * @{
  */
#define CPUID_INTEL_RESOURCE_DIRECTOR_TECHNOLOGY_MONITORING_INFORMATION 0x0000000F
  /**
   * @brief Intel Resource Director Technology (Intel RDT) Monitoring Enumeration Sub-leaf (EAX = 0FH, ECX = 0)
   *
   * @note Leaf 0FH output depends on the initial value in ECX. Sub-leaf index 0 reports valid resource type starting at bit
   *       position 1 of EDX.
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum range (zero-based) of RMID within this physical processor of all types.
             */
            UINT32_t rmid_max_range : 32;
#define CPUID_EBX_RMID_MAX_RANGE_BIT                                 0
#define CPUID_EBX_RMID_MAX_RANGE_FLAG                                0xFFFFFFFF
#define CPUID_EBX_RMID_MAX_RANGE_MASK                                0xFFFFFFFF
#define CPUID_EBX_RMID_MAX_RANGE(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            UINT32_t reserved1 : 1;

            /**
             * [Bit 1] Supports L3 Cache Intel RDT Monitoring if 1.
             */
            UINT32_t supports_l3_cache_intel_rdt_monitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_BIT         1
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_FLAG        0x02
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_MASK        0x01
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING(_)          (((_) >> 1) & 0x01)
            UINT32_t reserved2 : 30;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_0f_ecx_00;

/**
 * @brief L3 Cache Intel RDT Monitoring Capability Enumeration Sub-leaf (EAX = 0FH, ECX = 1)
 *
 * @note Leaf 0FH output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Conversion factor from reported IA32_QM_CTR value to occupancy metric (bytes).
             */
            UINT32_t conversion_factor : 32;
#define CPUID_EBX_CONVERSION_FACTOR_BIT                              0
#define CPUID_EBX_CONVERSION_FACTOR_FLAG                             0xFFFFFFFF
#define CPUID_EBX_CONVERSION_FACTOR_MASK                             0xFFFFFFFF
#define CPUID_EBX_CONVERSION_FACTOR(_)                               (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum range (zero-based) of RMID within this physical processor of all types.
             */
            UINT32_t rmid_max_range : 32;
#define CPUID_ECX_RMID_MAX_RANGE_BIT                                 0
#define CPUID_ECX_RMID_MAX_RANGE_FLAG                                0xFFFFFFFF
#define CPUID_ECX_RMID_MAX_RANGE_MASK                                0xFFFFFFFF
#define CPUID_ECX_RMID_MAX_RANGE(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bit 0] Supports L3 occupancy monitoring if 1.
             */
            UINT32_t supports_l3_occupancy_monitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_BIT               0
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_FLAG              0x01
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_MASK              0x01
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING(_)                (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Supports L3 Total Bandwidth monitoring if 1.
             */
            UINT32_t supports_l3_total_bandwidth_monitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_BIT         1
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_FLAG        0x02
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_MASK        0x01
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING(_)          (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports L3 Local Bandwidth monitoring if 1.
             */
            UINT32_t supports_l3_local_bandwidth_monitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_BIT         2
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_FLAG        0x04
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_MASK        0x01
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING(_)          (((_) >> 2) & 0x01)
            UINT32_t reserved1 : 29;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_0f_ecx_01;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_10 \
  *           EAX = 0x10
  *
  * When CPUID executes with EAX set to 10H and ECX = 0, the processor returns information about the bit-vector
  * representation of QoS Enforcement resource types that are supported in the processor. Each bit, starting from bit 1,
  * corresponds to a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index (or ResID)
  * that software must use to query QoS enforcement capability available for that type.
  * When CPUID executes with EAX set to 10H and ECX = n (n >= 1, and is a valid ResID), the processor returns information
  * about available classes of service and range of QoS mask MSRs that software can use to configure each class of services
  * using capability bit masks in the QoS Mask registers, IA32_resourceType_Mask_n.
  * @{
  */
#define CPUID_INTEL_RESOURCE_DIRECTOR_TECHNOLOGY_ALLOCATION_INFORMATION 0x00000010
  /**
   * @brief Intel Resource Director Technology (Intel RDT) Allocation Enumeration Sub-leaf (EAX = 10H, ECX = 0)
   *
   * @note Leaf 10H output depends on the initial value in ECX. Sub-leaf index 0 reports valid resource identification
   *       (ResID) starting at bit position 1 of EBX.
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H).
             */
            UINT32_t ia32_platform_dca_cap : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT                          0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)                           (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            UINT32_t reserved1 : 1;

            /**
             * [Bit 1] Supports L3 Cache Allocation Technology if 1.
             */
            UINT32_t supports_l3_cache_allocation_technology : 1;
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_BIT        1
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_FLAG       0x02
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_MASK       0x01
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY(_)         (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports L2 Cache Allocation Technology if 1.
             */
            UINT32_t supports_l2_cache_allocation_technology : 1;
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_BIT        2
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_FLAG       0x04
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_MASK       0x01
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY(_)         (((_) >> 2) & 0x01)

            /**
             * [Bit 3] Supports Memory Bandwidth Allocation if 1.
             */
            UINT32_t supports_memory_bandwidth_allocation : 1;
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_BIT           3
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_FLAG          0x08
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_MASK          0x01
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION(_)            (((_) >> 3) & 0x01)
            UINT32_t reserved2 : 28;
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_10_ecx_00;

/**
 * @brief L3 Cache Allocation Technology Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 1)
 *
 * @note Leaf 10H output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 4:0] Length of the capacity bit mask for the corresponding ResID using minus-one notation.
             */
            UINT32_t length_of_capacity_bit_mask : 5;
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_BIT                    0
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_FLAG                   0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_MASK                   0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK(_)                     (((_) >> 0) & 0x1F)
            UINT32_t reserved1 : 27;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Bit-granular map of isolation/contention of allocation units.
             */
            UINT32_t ebx_0 : 32;
#define CPUID_EBX_EBX_0_BIT                                          0
#define CPUID_EBX_EBX_0_FLAG                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0_MASK                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0(_)                                           (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            UINT32_t reserved1 : 2;

            /**
             * [Bit 2] Code and Data Prioritization Technology supported if 1.
             */
            UINT32_t code_and_data_priorization_technology_supported : 1;
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_BIT 2
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_FLAG 0x04
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_MASK 0x01
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED(_) (((_) >> 2) & 0x01)
            UINT32_t reserved2 : 29;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Highest COS number supported for this ResID.
             */
            UINT32_t highest_cos_number_supported : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT                   0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_)                    (((_) >> 0) & 0xFFFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_10_ecx_01;

/**
 * @brief L2 Cache Allocation Technology Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 2)
 *
 * @note Leaf 10H output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 4:0] Length of the capacity bit mask for the corresponding ResID using minus-one notation.
             */
            UINT32_t length_of_capacity_bit_mask : 5;
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_BIT                    0
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_FLAG                   0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_MASK                   0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK(_)                     (((_) >> 0) & 0x1F)
            UINT32_t reserved1 : 27;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Bit-granular map of isolation/contention of allocation units.
             */
            UINT32_t ebx_0 : 32;
#define CPUID_EBX_EBX_0_BIT                                          0
#define CPUID_EBX_EBX_0_FLAG                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0_MASK                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0(_)                                           (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Highest COS number supported for this ResID.
             */
            UINT32_t highest_cos_number_supported : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT                   0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_)                    (((_) >> 0) & 0xFFFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_10_ecx_02;

/**
 * @brief Memory Bandwidth Allocation Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 3)
 *
 * @note Leaf 10H output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 11:0] Reports the maximum MBA throttling value supported for the corresponding ResID using minus-one notation.
             */
            UINT32_t max_mba_throttling_value : 12;
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_BIT                       0
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_FLAG                      0xFFF
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_MASK                      0xFFF
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE(_)                        (((_) >> 0) & 0xFFF)
            UINT32_t reserved1 : 20;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            UINT32_t reserved1 : 2;

            /**
             * [Bit 2] Reports whether the response of the delay values is linear.
             */
            UINT32_t response_of_delay_is_linear : 1;
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_BIT                    2
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_FLAG                   0x04
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_MASK                   0x01
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR(_)                     (((_) >> 2) & 0x01)
            UINT32_t reserved2 : 29;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Highest COS number supported for this ResID.
             */
            UINT32_t highest_cos_number_supported : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT                   0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_)                    (((_) >> 0) & 0xFFFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_10_ecx_03;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_12 \
  *           EAX = 0x12
  *
  * When CPUID executes with EAX set to 12H and ECX = 0H, the processor returns information about Intel SGX capabilities.
  * When CPUID executes with EAX set to 12H and ECX = 1H, the processor returns information about Intel SGX attributes.
  * When CPUID executes with EAX set to 12H and ECX = n (n > 1), the processor returns information about Intel SGX Enclave
  * Page Cache.
  * @{
  */
#define CPUID_INTEL_SGX                                              0x00000012
  /**
   * @brief Intel SGX Capability Enumeration Leaf, sub-leaf 0 (EAX = 12H, ECX = 0)
   *
   * @note Leaf 12H sub-leaf 0 (ECX = 0) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bit 0] If 1, Indicates Intel SGX supports the collection of SGX1 leaf functions.
             */
            UINT32_t sgx1 : 1;
#define CPUID_EAX_SGX1_BIT                                           0
#define CPUID_EAX_SGX1_FLAG                                          0x01
#define CPUID_EAX_SGX1_MASK                                          0x01
#define CPUID_EAX_SGX1(_)                                            (((_) >> 0) & 0x01)

            /**
             * [Bit 1] If 1, Indicates Intel SGX supports the collection of SGX2 leaf functions.
             */
            UINT32_t sgx2 : 1;
#define CPUID_EAX_SGX2_BIT                                           1
#define CPUID_EAX_SGX2_FLAG                                          0x02
#define CPUID_EAX_SGX2_MASK                                          0x01
#define CPUID_EAX_SGX2(_)                                            (((_) >> 1) & 0x01)
            UINT32_t reserved1 : 3;

            /**
             * [Bit 5] If 1, indicates Intel SGX supports ENCLV instruction leaves EINCVIRTCHILD, EDECVIRTCHILD, and ESETCONTEXT.
             */
            UINT32_t sgx_enclv_advanced : 1;
#define CPUID_EAX_SGX_ENCLV_ADVANCED_BIT                             5
#define CPUID_EAX_SGX_ENCLV_ADVANCED_FLAG                            0x20
#define CPUID_EAX_SGX_ENCLV_ADVANCED_MASK                            0x01
#define CPUID_EAX_SGX_ENCLV_ADVANCED(_)                              (((_) >> 5) & 0x01)

            /**
             * [Bit 6] If 1, indicates Intel SGX supports ENCLS instruction leaves ETRACKC, ERDINFO, ELDBC, and ELDUC.
             */
            UINT32_t sgx_encls_advanced : 1;
#define CPUID_EAX_SGX_ENCLS_ADVANCED_BIT                             6
#define CPUID_EAX_SGX_ENCLS_ADVANCED_FLAG                            0x40
#define CPUID_EAX_SGX_ENCLS_ADVANCED_MASK                            0x01
#define CPUID_EAX_SGX_ENCLS_ADVANCED(_)                              (((_) >> 6) & 0x01)
            UINT32_t reserved2 : 25;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Bit vector of supported extended SGX features.
             */
            UINT32_t miscselect : 32;
#define CPUID_EBX_MISCSELECT_BIT                                     0
#define CPUID_EBX_MISCSELECT_FLAG                                    0xFFFFFFFF
#define CPUID_EBX_MISCSELECT_MASK                                    0xFFFFFFFF
#define CPUID_EBX_MISCSELECT(_)                                      (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 7:0] The maximum supported enclave size in non-64-bit mode is 2^(EDX[7:0]).
             */
            UINT32_t max_enclave_size_not64 : 8;
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_BIT                         0
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_FLAG                        0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_MASK                        0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64(_)                          (((_) >> 0) & 0xFF)

            /**
             * [Bits 15:8] The maximum supported enclave size in 64-bit mode is 2^(EDX[15:8]).
             */
            UINT32_t max_enclave_size_64 : 8;
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_BIT                            8
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_FLAG                           0xFF00
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_MASK                           0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64(_)                             (((_) >> 8) & 0xFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_12_ecx_00;

/**
 * @brief Intel SGX Attributes Enumeration Leaf, sub-leaf 1 (EAX = 12H, ECX = 1)
 *
 * @note Leaf 12H sub-leaf 1 (ECX = 1) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[31:0] that software can set with ECREATE.
             */
            UINT32_t valid_secs_attributes_0 : 32;
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_BIT                        0
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_FLAG                       0xFFFFFFFF
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_MASK                       0xFFFFFFFF
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[63:32] that software can set with ECREATE.
             */
            UINT32_t valid_secs_attributes_1 : 32;
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_BIT                        0
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_FLAG                       0xFFFFFFFF
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_MASK                       0xFFFFFFFF
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[95:64] that software can set with ECREATE.
             */
            UINT32_t valid_secs_attributes_2 : 32;
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_BIT                        0
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_FLAG                       0xFFFFFFFF
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_MASK                       0xFFFFFFFF
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[127:96] that software can set with ECREATE.
             */
            UINT32_t valid_secs_attributes_3 : 32;
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_BIT                        0
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_FLAG                       0xFFFFFFFF
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_MASK                       0xFFFFFFFF
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_12_ecx_01;

/**
 * @brief Intel SGX EPC Enumeration Leaf, sub-leaves (EAX = 12H, ECX = 2 or higher)
 *
 * @note Leaf 12H sub-leaf 2 or higher (ECX >= 2) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
 *       This structure describes sub-leaf type 0.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 3:0] Sub-leaf Type 0. Indicates this sub-leaf is invalid.
             */
            UINT32_t sub_leaf_type : 4;
#define CPUID_EAX_SUB_LEAF_TYPE_BIT                                  0
#define CPUID_EAX_SUB_LEAF_TYPE_FLAG                                 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE_MASK                                 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE(_)                                   (((_) >> 0) & 0x0F)
            UINT32_t reserved1 : 28;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is zero.
             */
            UINT32_t zero : 32;
#define CPUID_EBX_ZERO_BIT                                           0
#define CPUID_EBX_ZERO_FLAG                                          0xFFFFFFFF
#define CPUID_EBX_ZERO_MASK                                          0xFFFFFFFF
#define CPUID_EBX_ZERO(_)                                            (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is zero.
             */
            UINT32_t zero : 32;
#define CPUID_ECX_ZERO_BIT                                           0
#define CPUID_ECX_ZERO_FLAG                                          0xFFFFFFFF
#define CPUID_ECX_ZERO_MASK                                          0xFFFFFFFF
#define CPUID_ECX_ZERO(_)                                            (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is zero.
             */
            UINT32_t zero : 32;
#define CPUID_EDX_ZERO_BIT                                           0
#define CPUID_EDX_ZERO_FLAG                                          0xFFFFFFFF
#define CPUID_EDX_ZERO_MASK                                          0xFFFFFFFF
#define CPUID_EDX_ZERO(_)                                            (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_12_ecx_02p_slt_0;

/**
 * @brief Intel SGX EPC Enumeration Leaf, sub-leaves (EAX = 12H, ECX = 2 or higher)
 *
 * @note Leaf 12H sub-leaf 2 or higher (ECX >= 2) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
 *       This structure describes sub-leaf type 1.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 3:0] Sub-leaf Type 1. This sub-leaf enumerates an EPC section. EBX:EAX and EDX:ECX provide information on the
             * Enclave Page Cache (EPC) section.
             */
            UINT32_t sub_leaf_type : 4;
#define CPUID_EAX_SUB_LEAF_TYPE_BIT                                  0
#define CPUID_EAX_SUB_LEAF_TYPE_FLAG                                 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE_MASK                                 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE(_)                                   (((_) >> 0) & 0x0F)
            UINT32_t reserved1 : 8;

            /**
             * [Bits 31:12] Bits 31:12 of the physical address of the base of the EPC section.
             */
            UINT32_t epc_base_physical_address_1 : 20;
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_BIT                    12
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_FLAG                   0xFFFFF000
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_MASK                   0xFFFFF
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1(_)                     (((_) >> 12) & 0xFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 19:0] Bits 51:32 of the physical address of the base of the EPC section.
             */
            UINT32_t epc_base_physical_address_2 : 20;
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_BIT                    0
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_FLAG                   0xFFFFF
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_MASK                   0xFFFFF
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2(_)                     (((_) >> 0) & 0xFFFFF)
            UINT32_t reserved1 : 12;
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 3:0] EPC section property encoding defined as follows:
             * - If EAX[3:0] 0000b, then all bits of the EDX:ECX pair are enumerated as 0.
             * - If EAX[3:0] 0001b, then this section has confidentiality and integrity protection.
             * All other encodings are reserved.
             */
            UINT32_t epc_section_property : 4;
#define CPUID_ECX_EPC_SECTION_PROPERTY_BIT                           0
#define CPUID_ECX_EPC_SECTION_PROPERTY_FLAG                          0x0F
#define CPUID_ECX_EPC_SECTION_PROPERTY_MASK                          0x0F
#define CPUID_ECX_EPC_SECTION_PROPERTY(_)                            (((_) >> 0) & 0x0F)
            UINT32_t reserved1 : 8;

            /**
             * [Bits 31:12] Bits 31:12 of the size of the corresponding EPC section within the Processor Reserved Memory.
             */
            UINT32_t epc_size_1 : 20;
#define CPUID_ECX_EPC_SIZE_1_BIT                                     12
#define CPUID_ECX_EPC_SIZE_1_FLAG                                    0xFFFFF000
#define CPUID_ECX_EPC_SIZE_1_MASK                                    0xFFFFF
#define CPUID_ECX_EPC_SIZE_1(_)                                      (((_) >> 12) & 0xFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 19:0] Bits 51:32 of the size of the corresponding EPC section within the Processor Reserved Memory.
             */
            UINT32_t epc_size_2 : 20;
#define CPUID_EDX_EPC_SIZE_2_BIT                                     0
#define CPUID_EDX_EPC_SIZE_2_FLAG                                    0xFFFFF
#define CPUID_EDX_EPC_SIZE_2_MASK                                    0xFFFFF
#define CPUID_EDX_EPC_SIZE_2(_)                                      (((_) >> 0) & 0xFFFFF)
            UINT32_t reserved1 : 12;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_12_ecx_02p_slt_1;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_14 \
  *           EAX = 0x14
  *
  * When CPUID executes with EAX set to 14H and ECX = 0H, the processor returns information about Intel Processor Trace
  * extensions.
  * When CPUID executes with EAX set to 14H and ECX = n (n > 0 and less than the number of non-zero bits in CPUID.(EAX=14H,
  * ECX= 0H).EAX), the processor returns information about packet generation in Intel Processor Trace.
  * @{
  */
#define CPUID_INTEL_PROCESSOR_TRACE_INFORMATION                      0x00000014
  /**
   * @brief Intel Processor Trace Enumeration Main Leaf (EAX = 14H, ECX = 0)
   *
   * @note Leaf 14H main leaf (ECX = 0).
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the maximum sub-leaf supported in leaf 14H.
             */
            UINT32_t max_sub_leaf : 32;
#define CPUID_EAX_MAX_SUB_LEAF_BIT                                   0
#define CPUID_EAX_MAX_SUB_LEAF_FLAG                                  0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF_MASK                                  0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF(_)                                    (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] If 1, indicates that IA32_RTIT_CTL.CR3Filter can be set to 1, and that IA32_RTIT_CR3_MATCH MSR can be accessed.
             */
            UINT32_t flag0 : 1;
#define CPUID_EBX_FLAG0_BIT                                          0
#define CPUID_EBX_FLAG0_FLAG                                         0x01
#define CPUID_EBX_FLAG0_MASK                                         0x01
#define CPUID_EBX_FLAG0(_)                                           (((_) >> 0) & 0x01)

            /**
             * [Bit 1] If 1, indicates support of Configurable PSB and Cycle-Accurate Mode.
             */
            UINT32_t flag1 : 1;
#define CPUID_EBX_FLAG1_BIT                                          1
#define CPUID_EBX_FLAG1_FLAG                                         0x02
#define CPUID_EBX_FLAG1_MASK                                         0x01
#define CPUID_EBX_FLAG1(_)                                           (((_) >> 1) & 0x01)

            /**
             * [Bit 2] If 1, indicates support of IP Filtering, TraceStop filtering, and preservation of Intel PT MSRs across warm
             * reset.
             */
            UINT32_t flag2 : 1;
#define CPUID_EBX_FLAG2_BIT                                          2
#define CPUID_EBX_FLAG2_FLAG                                         0x04
#define CPUID_EBX_FLAG2_MASK                                         0x01
#define CPUID_EBX_FLAG2(_)                                           (((_) >> 2) & 0x01)

            /**
             * [Bit 3] If 1, indicates support of MTC timing packet and suppression of COFI-based packets.
             */
            UINT32_t flag3 : 1;
#define CPUID_EBX_FLAG3_BIT                                          3
#define CPUID_EBX_FLAG3_FLAG                                         0x08
#define CPUID_EBX_FLAG3_MASK                                         0x01
#define CPUID_EBX_FLAG3(_)                                           (((_) >> 3) & 0x01)

            /**
             * [Bit 4] If 1, indicates support of PTWRITE. Writes can set IA32_RTIT_CTL[12] (PTWEn) and IA32_RTIT_CTL[5] (FUPonPTW),
             * and PTWRITE can generate packets.
             */
            UINT32_t flag4 : 1;
#define CPUID_EBX_FLAG4_BIT                                          4
#define CPUID_EBX_FLAG4_FLAG                                         0x10
#define CPUID_EBX_FLAG4_MASK                                         0x01
#define CPUID_EBX_FLAG4(_)                                           (((_) >> 4) & 0x01)

            /**
             * [Bit 5] If 1, indicates support of Power Event Trace. Writes can set IA32_RTIT_CTL[4] (PwrEvtEn), enabling Power Event
             * Trace packet generation.
             */
            UINT32_t flag5 : 1;
#define CPUID_EBX_FLAG5_BIT                                          5
#define CPUID_EBX_FLAG5_FLAG                                         0x20
#define CPUID_EBX_FLAG5_MASK                                         0x01
#define CPUID_EBX_FLAG5(_)                                           (((_) >> 5) & 0x01)
            UINT32_t reserved1 : 26;
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] If 1, Tracing can be enabled with IA32_RTIT_CTL.ToPA = 1, hence utilizing the ToPA output scheme;
             * IA32_RTIT_OUTPUT_BASE and IA32_RTIT_OUTPUT_MASK_PTRS MSRs can be accessed.
             */
            UINT32_t flag0 : 1;
#define CPUID_ECX_FLAG0_BIT                                          0
#define CPUID_ECX_FLAG0_FLAG                                         0x01
#define CPUID_ECX_FLAG0_MASK                                         0x01
#define CPUID_ECX_FLAG0(_)                                           (((_) >> 0) & 0x01)

            /**
             * [Bit 1] If 1, ToPA tables can hold any number of output entries, up to the maximum allowed by the MaskOrTableOffset
             * field of IA32_RTIT_OUTPUT_MASK_PTRS.
             */
            UINT32_t flag1 : 1;
#define CPUID_ECX_FLAG1_BIT                                          1
#define CPUID_ECX_FLAG1_FLAG                                         0x02
#define CPUID_ECX_FLAG1_MASK                                         0x01
#define CPUID_ECX_FLAG1(_)                                           (((_) >> 1) & 0x01)

            /**
             * [Bit 2] If 1, indicates support of Single-Range Output scheme.
             */
            UINT32_t flag2 : 1;
#define CPUID_ECX_FLAG2_BIT                                          2
#define CPUID_ECX_FLAG2_FLAG                                         0x04
#define CPUID_ECX_FLAG2_MASK                                         0x01
#define CPUID_ECX_FLAG2(_)                                           (((_) >> 2) & 0x01)

            /**
             * [Bit 3] If 1, indicates support of output to Trace Transport subsystem.
             */
            UINT32_t flag3 : 1;
#define CPUID_ECX_FLAG3_BIT                                          3
#define CPUID_ECX_FLAG3_FLAG                                         0x08
#define CPUID_ECX_FLAG3_MASK                                         0x01
#define CPUID_ECX_FLAG3(_)                                           (((_) >> 3) & 0x01)
            UINT32_t reserved1 : 27;

            /**
             * [Bit 31] If 1, generated packets which contain IP payloads have LIP values, which include the CS base component.
             */
            UINT32_t flag31 : 1;
#define CPUID_ECX_FLAG31_BIT                                         31
#define CPUID_ECX_FLAG31_FLAG                                        0x80000000
#define CPUID_ECX_FLAG31_MASK                                        0x01
#define CPUID_ECX_FLAG31(_)                                          (((_) >> 31) & 0x01)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_14_ecx_00;

/**
 * @brief Intel Processor Trace Enumeration Sub-leaf (EAX = 14H, ECX = 1)
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 2:0] Number of configurable Address Ranges for filtering.
             */
            UINT32_t number_of_configurable_address_ranges_for_filtering : 3;
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_BIT 0
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_FLAG 0x07
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_MASK 0x07
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING(_) (((_) >> 0) & 0x07)
            UINT32_t reserved1 : 13;

            /**
             * [Bits 31:16] Bitmap of supported MTC period encodings.
             */
            UINT32_t bitmap_of_supported_mtc_period_encodings : 16;
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_BIT       16
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_FLAG      0xFFFF0000
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_MASK      0xFFFF
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS(_)        (((_) >> 16) & 0xFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Bitmap of supported Cycle Threshold value encodings.
             */
            UINT32_t bitmap_of_supported_cycle_threshold_value_encodings : 16;
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_BIT 0
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_FLAG 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_MASK 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS(_) (((_) >> 0) & 0xFFFF)

            /**
             * [Bits 31:16] Bitmap of supported Configurable PSB frequency encodings.
             */
            UINT32_t bitmap_of_supported_configurable_psb_frequency_encodings : 16;
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_BIT 16
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_FLAG 0xFFFF0000
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_MASK 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS(_) (((_) >> 16) & 0xFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_14_ecx_01;

/**
 * @}
 */


 /**
  * @brief Stamp Counter and Nominal Core Crystal Clock Information Leaf
  *
  * When CPUID executes with EAX set to 15H and ECX = 0H, the processor returns information about Time Stamp Counter and
  * Core Crystal Clock.
  *
  * @note If EBX[31:0] is 0, the TSC/"core crystal clock" ratio is not enumerated. EBX[31:0]/EAX[31:0] indicates the ratio
  *       of the TSC frequency and the core crystal clock frequency.
  *       If ECX is 0, the nominal core crystal clock frequency is not enumerated. "TSC frequency" = "core crystal clock
  *       frequency" * EBX/EAX.
  */
#define CPUID_TIME_STAMP_COUNTER_INFORMATION                         0x00000015
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] An unsigned integer which is the denominator of the TSC/"core crystal clock" ratio.
             */
            UINT32_t denominator : 32;
#define CPUID_EAX_DENOMINATOR_BIT                                    0
#define CPUID_EAX_DENOMINATOR_FLAG                                   0xFFFFFFFF
#define CPUID_EAX_DENOMINATOR_MASK                                   0xFFFFFFFF
#define CPUID_EAX_DENOMINATOR(_)                                     (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] An unsigned integer which is the numerator of the TSC/"core crystal clock" ratio.
             */
            UINT32_t numerator : 32;
#define CPUID_EBX_NUMERATOR_BIT                                      0
#define CPUID_EBX_NUMERATOR_FLAG                                     0xFFFFFFFF
#define CPUID_EBX_NUMERATOR_MASK                                     0xFFFFFFFF
#define CPUID_EBX_NUMERATOR(_)                                       (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] An unsigned integer which is the nominal frequency of the core crystal clock in Hz.
             */
            UINT32_t nominal_frequency : 32;
#define CPUID_ECX_NOMINAL_FREQUENCY_BIT                              0
#define CPUID_ECX_NOMINAL_FREQUENCY_FLAG                             0xFFFFFFFF
#define CPUID_ECX_NOMINAL_FREQUENCY_MASK                             0xFFFFFFFF
#define CPUID_ECX_NOMINAL_FREQUENCY(_)                               (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_15;


/**
 * @brief Processor Frequency Information Leaf
 *
 * When CPUID executes with EAX set to 16H, the processor returns information about Processor Frequency Information.
 *
 * @note Data is returned from this interface in accordance with the processor's specification and does not reflect actual
 *       values. Suitable use of this data includes the display of processor information in like manner to the processor brand
 *       string and for determining the appropriate range to use when displaying processor information e.g. frequency history
 *       graphs. The returned information should not be used for any other purpose as the returned information does not
 *       accurately correlate to information / counters returned by other processor interfaces.
 *       While a processor may support the Processor Frequency Information leaf, fields that return a value of zero are not
 *       supported.
 */
#define CPUID_PROCESSOR_FREQUENCY_INFORMATION                        0x00000016
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 15:0] Processor Base Frequency (in MHz).
             */
            UINT32_t procesor_base_frequency_mhz : 16;
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_BIT                    0
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_FLAG                   0xFFFF
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_MASK                   0xFFFF
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ(_)                     (((_) >> 0) & 0xFFFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Maximum Frequency (in MHz).
             */
            UINT32_t processor_maximum_frequency_mhz : 16;
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_BIT                0
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_FLAG               0xFFFF
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_MASK               0xFFFF
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ(_)                 (((_) >> 0) & 0xFFFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Bus (Reference) Frequency (in MHz).
             */
            UINT32_t bus_frequency_mhz : 16;
#define CPUID_ECX_BUS_FREQUENCY_MHZ_BIT                              0
#define CPUID_ECX_BUS_FREQUENCY_MHZ_FLAG                             0xFFFF
#define CPUID_ECX_BUS_FREQUENCY_MHZ_MASK                             0xFFFF
#define CPUID_ECX_BUS_FREQUENCY_MHZ(_)                               (((_) >> 0) & 0xFFFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_16;

/**
 * @defgroup cpuid_eax_17 \
 *           EAX = 0x17
 *
 * When CPUID executes with EAX set to 17H, the processor returns information about the System-On-Chip Vendor Attribute
 * Enumeration.
 * @{
 */
#define CPUID_SOC_VENDOR_INFORMATION                                 0x00000017
 /**
  * @brief System-On-Chip Vendor Attribute Enumeration Main Leaf (EAX = 17H, ECX = 0)
  *
  * @note Leaf 17H main leaf (ECX = 0). Leaf 17H output depends on the initial value in ECX. Leaf 17H sub-leaves 1 through 3
  *       reports SOC Vendor Brand String. Leaf 17H is valid if MaxSOCID_Index >= 3. Leaf 17H sub-leaves 4 and above are reserved.
  */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the maximum input value of supported sub-leaf in leaf 17H.
             */
            UINT32_t max_soc_id_index : 32;
#define CPUID_EAX_MAX_SOC_ID_INDEX_BIT                               0
#define CPUID_EAX_MAX_SOC_ID_INDEX_FLAG                              0xFFFFFFFF
#define CPUID_EAX_MAX_SOC_ID_INDEX_MASK                              0xFFFFFFFF
#define CPUID_EAX_MAX_SOC_ID_INDEX(_)                                (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] SOC Vendor ID.
             */
            UINT32_t soc_vendor_id : 16;
#define CPUID_EBX_SOC_VENDOR_ID_BIT                                  0
#define CPUID_EBX_SOC_VENDOR_ID_FLAG                                 0xFFFF
#define CPUID_EBX_SOC_VENDOR_ID_MASK                                 0xFFFF
#define CPUID_EBX_SOC_VENDOR_ID(_)                                   (((_) >> 0) & 0xFFFF)

            /**
             * [Bit 16] If 1, the SOC Vendor ID field is assigned via an industry standard enumeration scheme. Otherwise, the SOC
             * Vendor ID field is assigned by Intel.
             */
            UINT32_t is_vendor_scheme : 1;
#define CPUID_EBX_IS_VENDOR_SCHEME_BIT                               16
#define CPUID_EBX_IS_VENDOR_SCHEME_FLAG                              0x10000
#define CPUID_EBX_IS_VENDOR_SCHEME_MASK                              0x01
#define CPUID_EBX_IS_VENDOR_SCHEME(_)                                (((_) >> 16) & 0x01)
            UINT32_t reserved1 : 15;
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] A unique number an SOC vendor assigns to its SOC projects.
             */
            UINT32_t project_id : 32;
#define CPUID_ECX_PROJECT_ID_BIT                                     0
#define CPUID_ECX_PROJECT_ID_FLAG                                    0xFFFFFFFF
#define CPUID_ECX_PROJECT_ID_MASK                                    0xFFFFFFFF
#define CPUID_ECX_PROJECT_ID(_)                                      (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] A unique number within an SOC project that an SOC vendor assigns.
             */
            UINT32_t stepping_id : 32;
#define CPUID_EDX_STEPPING_ID_BIT                                    0
#define CPUID_EDX_STEPPING_ID_FLAG                                   0xFFFFFFFF
#define CPUID_EDX_STEPPING_ID_MASK                                   0xFFFFFFFF
#define CPUID_EDX_STEPPING_ID(_)                                     (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_17_ecx_00;

/**
 * @brief System-On-Chip Vendor Attribute Enumeration Sub-leaf (EAX = 17H, ECX = 1..3)
 *
 * @note Leaf 17H output depends on the initial value in ECX. SOC Vendor Brand String is a UTF-8 encoded string padded with
 *       trailing bytes of 00H. The complete SOC Vendor Brand String is constructed by concatenating in ascending order of
 *       EAX:EBX:ECX:EDX and from the sub-leaf 1 fragment towards sub-leaf 3.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
             */
            UINT32_t soc_vendor_brand_string : 32;
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING_BIT                        0
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
             */
            UINT32_t soc_vendor_brand_string : 32;
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_BIT                        0
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
             */
            UINT32_t soc_vendor_brand_string : 32;
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_BIT                        0
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
             */
            UINT32_t soc_vendor_brand_string : 32;
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_BIT                        0
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_17_ecx_01_03;

/**
 * @brief System-On-Chip Vendor Attribute Enumeration Sub-leaves (EAX = 17H, ECX > MaxSOCID_Index)
 *
 * @note Leaf 17H output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reserved = 0.
             */
            UINT32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reserved = 0.
             */
            UINT32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reserved = 0.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reserved = 0.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_17_ecx_n;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_18 \
  *           EAX = 0x18
  *
  * When CPUID executes with EAX set to 18H, the processor returns information about the Deterministic Address Translation
  * Parameters.
  * @{
  */
#define CPUID_DETERMINISTIC_ADDRESS_TRANSLATION_PARAMETERS           0x00000018
  /**
   * @brief Deterministic Address Translation Parameters Main Leaf (EAX = 18H, ECX = 0)
   *
   * @note Each sub-leaf enumerates a different address translation structure.
   *       If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is invalid if n exceeds the value
   *       that sub-leaf 0 returns in EAX. A sub-leaf index is also invalid if EDX[4:0] returns 0. Valid sub-leaves do not need to
   *       be contiguous or in any particular order. A valid sub-leaf may be in a higher input ECX value than an invalid sub-leaf
   *       or than a valid sub-leaf of a higher or lower-level structure.
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the maximum input value of supported sub-leaf in leaf 18H.
             */
            UINT32_t max_sub_leaf : 32;
#define CPUID_EAX_MAX_SUB_LEAF_BIT                                   0
#define CPUID_EAX_MAX_SUB_LEAF_FLAG                                  0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF_MASK                                  0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF(_)                                    (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] 4K page size entries supported by this structure.
             */
            UINT32_t page_entries_4kb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_BIT                     0
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_FLAG                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED(_)                      (((_) >> 0) & 0x01)

            /**
             * [Bit 1] 2MB page size entries supported by this structure.
             */
            UINT32_t page_entries_2mb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_BIT                     1
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_FLAG                    0x02
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED(_)                      (((_) >> 1) & 0x01)

            /**
             * [Bit 2] 4MB page size entries supported by this structure.
             */
            UINT32_t page_entries_4mb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_BIT                     2
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_FLAG                    0x04
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED(_)                      (((_) >> 2) & 0x01)

            /**
             * [Bit 3] 1 GB page size entries supported by this structure.
             */
            UINT32_t page_entries_1gb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_BIT                     3
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_FLAG                    0x08
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED(_)                      (((_) >> 3) & 0x01)
            UINT32_t reserved1 : 4;

            /**
             * [Bits 10:8] Partitioning (0: Soft partitioning between the logical processors sharing this structure).
             */
            UINT32_t partitioning : 3;
#define CPUID_EBX_PARTITIONING_BIT                                   8
#define CPUID_EBX_PARTITIONING_FLAG                                  0x700
#define CPUID_EBX_PARTITIONING_MASK                                  0x07
#define CPUID_EBX_PARTITIONING(_)                                    (((_) >> 8) & 0x07)
            UINT32_t reserved2 : 5;

            /**
             * [Bits 31:16] W = Ways of associativity.
             */
            UINT32_t ways_of_associativity_00 : 16;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_BIT                       16
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_FLAG                      0xFFFF0000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_MASK                      0xFFFF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00(_)                        (((_) >> 16) & 0xFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Number of Sets.
             */
            UINT32_t number_of_sets : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT                                 0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 4:0] Translation cache type field.
             * - 00000b: Null (indicates this sub-leaf is not valid).
             * - 00001b: Data TLB.
             * - 00010b: Instruction TLB.
             * - 00011b: Unified TLB.
             * All other encodings are reserved.
             *
             * @note Some unified TLBs will allow a single TLB entry to satisfy data read/write and instruction fetches. Others will
             *       require separate entries (e.g., one loaded on data read/write and another loaded on an instruction fetch) . Please see
             *       the Intel(R) 64 and IA-32 Architectures Optimization Reference Manual for details of a particular product.
             */
            UINT32_t translation_cache_type_field : 5;
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_BIT                   0
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_FLAG                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_MASK                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD(_)                    (((_) >> 0) & 0x1F)

            /**
             * [Bits 7:5] Translation cache level (starts at 1).
             */
            UINT32_t translation_cache_level : 3;
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_BIT                        5
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_FLAG                       0xE0
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_MASK                       0x07
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL(_)                         (((_) >> 5) & 0x07)

            /**
             * [Bit 8] Fully associative structure.
             */
            UINT32_t fully_associative_structure : 1;
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_BIT                    8
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_FLAG                   0x100
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_MASK                   0x01
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE(_)                     (((_) >> 8) & 0x01)
            UINT32_t reserved1 : 5;

            /**
             * [Bits 25:14] Maximum number of addressable IDs for logical processors sharing this translation cache.
             *
             * @note Add one to the return value to get the result.
             */
            UINT32_t max_addressable_ids_for_logical_processors : 12;
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_BIT     14
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_FLAG    0x3FFC000
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_MASK    0xFFF
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS(_)      (((_) >> 14) & 0xFFF)
            UINT32_t reserved2 : 6;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_18_ecx_00;

/**
 * @brief Deterministic Address Translation Parameters Sub-leaf (EAX = 18H, ECX >= 1)
 *
 * @note Each sub-leaf enumerates a different address translation structure.
 *       If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is invalid if n exceeds the value
 *       that sub-leaf 0 returns in EAX. A sub-leaf index is also invalid if EDX[4:0] returns 0. Valid sub-leaves do not need to
 *       be contiguous or in any particular order. A valid sub-leaf may be in a higher input ECX value than an invalid sub-leaf
 *       or than a valid sub-leaf of a higher or lower-level structure.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] 4K page size entries supported by this structure.
             */
            UINT32_t page_entries_4kb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_BIT                     0
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_FLAG                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED(_)                      (((_) >> 0) & 0x01)

            /**
             * [Bit 1] 2MB page size entries supported by this structure.
             */
            UINT32_t page_entries_2mb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_BIT                     1
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_FLAG                    0x02
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED(_)                      (((_) >> 1) & 0x01)

            /**
             * [Bit 2] 4MB page size entries supported by this structure.
             */
            UINT32_t page_entries_4mb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_BIT                     2
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_FLAG                    0x04
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED(_)                      (((_) >> 2) & 0x01)

            /**
             * [Bit 3] 1 GB page size entries supported by this structure.
             */
            UINT32_t page_entries_1gb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_BIT                     3
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_FLAG                    0x08
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED(_)                      (((_) >> 3) & 0x01)
            UINT32_t reserved1 : 4;

            /**
             * [Bits 10:8] Partitioning (0: Soft partitioning between the logical processors sharing this structure).
             */
            UINT32_t partitioning : 3;
#define CPUID_EBX_PARTITIONING_BIT                                   8
#define CPUID_EBX_PARTITIONING_FLAG                                  0x700
#define CPUID_EBX_PARTITIONING_MASK                                  0x07
#define CPUID_EBX_PARTITIONING(_)                                    (((_) >> 8) & 0x07)
            UINT32_t reserved2 : 5;

            /**
             * [Bits 31:16] W = Ways of associativity.
             */
            UINT32_t ways_of_associativity_01 : 16;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_BIT                       16
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_FLAG                      0xFFFF0000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_MASK                      0xFFFF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01(_)                        (((_) >> 16) & 0xFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Number of Sets.
             */
            UINT32_t number_of_sets : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT                                 0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 4:0] Translation cache type field.
             * - 00000b: Null (indicates this sub-leaf is not valid).
             * - 00001b: Data TLB.
             * - 00010b: Instruction TLB.
             * - 00011b: Unified TLB.
             * All other encodings are reserved.
             *
             * @note Some unified TLBs will allow a single TLB entry to satisfy data read/write and instruction fetches. Others will
             *       require separate entries (e.g., one loaded on data read/write and another loaded on an instruction fetch) . Please see
             *       the Intel(R) 64 and IA-32 Architectures Optimization Reference Manual for details of a particular product.
             */
            UINT32_t translation_cache_type_field : 5;
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_BIT                   0
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_FLAG                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_MASK                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD(_)                    (((_) >> 0) & 0x1F)

            /**
             * [Bits 7:5] Translation cache level (starts at 1).
             */
            UINT32_t translation_cache_level : 3;
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_BIT                        5
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_FLAG                       0xE0
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_MASK                       0x07
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL(_)                         (((_) >> 5) & 0x07)

            /**
             * [Bit 8] Fully associative structure.
             */
            UINT32_t fully_associative_structure : 1;
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_BIT                    8
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_FLAG                   0x100
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_MASK                   0x01
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE(_)                     (((_) >> 8) & 0x01)
            UINT32_t reserved1 : 5;

            /**
             * [Bits 25:14] Maximum number of addressable IDs for logical processors sharing this translation cache.
             *
             * @note Add one to the return value to get the result.
             */
            UINT32_t max_addressable_ids_for_logical_processors : 12;
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_BIT     14
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_FLAG    0x3FFC000
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_MASK    0xFFF
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS(_)      (((_) >> 14) & 0xFFF)
            UINT32_t reserved2 : 6;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_18_ecx_01p;

/**
 * @}
 */


 /**
  * @brief Extended Function CPUID Information
  *
  * When CPUID executes with EAX set to 80000000H, the processor returns the highest value the processor recognizes for
  * returning extended processor information. The value is returned in the EAX register and is processor specific.
  */
#define CPUID_EXTENDED_FUNCTION_INFORMATION                          0x80000000
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum Input Value for Extended Function CPUID Information.
             */
            UINT32_t max_extended_functions : 32;
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_BIT                         0
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_FLAG                        0xFFFFFFFF
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_MASK                        0xFFFFFFFF
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS(_)                          (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_80000000;


/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_CPU_SIGNATURE                                 0x80000001
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] LAHF/SAHF available in 64-bit mode.
             */
            UINT32_t lahf_sahf_available_in_64_bit_mode : 1;
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_BIT             0
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_FLAG            0x01
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_MASK            0x01
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE(_)              (((_) >> 0) & 0x01)
            UINT32_t reserved1 : 4;

            /**
             * [Bit 5] LZCNT.
             */
            UINT32_t lzcnt : 1;
#define CPUID_ECX_LZCNT_BIT                                          5
#define CPUID_ECX_LZCNT_FLAG                                         0x20
#define CPUID_ECX_LZCNT_MASK                                         0x01
#define CPUID_ECX_LZCNT(_)                                           (((_) >> 5) & 0x01)
            UINT32_t reserved2 : 2;

            /**
             * [Bit 8] PREFETCHW.
             */
            UINT32_t prefetchw : 1;
#define CPUID_ECX_PREFETCHW_BIT                                      8
#define CPUID_ECX_PREFETCHW_FLAG                                     0x100
#define CPUID_ECX_PREFETCHW_MASK                                     0x01
#define CPUID_ECX_PREFETCHW(_)                                       (((_) >> 8) & 0x01)
            UINT32_t reserved3 : 23;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            UINT32_t reserved1 : 11;

            /**
             * [Bit 11] SYSCALL/SYSRET available in 64-bit mode.
             */
            UINT32_t syscall_sysret_available_in_64_bit_mode : 1;
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_BIT        11
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_FLAG       0x800
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_MASK       0x01
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE(_)         (((_) >> 11) & 0x01)
            UINT32_t reserved2 : 8;

            /**
             * [Bit 20] Execute Disable Bit available.
             */
            UINT32_t execute_disable_bit_available : 1;
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_BIT                  20
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_FLAG                 0x100000
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_MASK                 0x01
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE(_)                   (((_) >> 20) & 0x01)
            UINT32_t reserved3 : 5;

            /**
             * [Bit 26] 1-GByte pages are available if 1.
             */
            UINT32_t pages_1gb_available : 1;
#define CPUID_EDX_PAGES_1GB_AVAILABLE_BIT                            26
#define CPUID_EDX_PAGES_1GB_AVAILABLE_FLAG                           0x4000000
#define CPUID_EDX_PAGES_1GB_AVAILABLE_MASK                           0x01
#define CPUID_EDX_PAGES_1GB_AVAILABLE(_)                             (((_) >> 26) & 0x01)

            /**
             * [Bit 27] RDTSCP and IA32_TSC_AUX are available if 1.
             */
            UINT32_t rdtscp_available : 1;
#define CPUID_EDX_RDTSCP_AVAILABLE_BIT                               27
#define CPUID_EDX_RDTSCP_AVAILABLE_FLAG                              0x8000000
#define CPUID_EDX_RDTSCP_AVAILABLE_MASK                              0x01
#define CPUID_EDX_RDTSCP_AVAILABLE(_)                                (((_) >> 27) & 0x01)
            UINT32_t reserved4 : 1;

            /**
             * [Bit 29] Intel(R) 64 Architecture available if 1.
             */
            UINT32_t ia64_available : 1;
#define CPUID_EDX_IA64_AVAILABLE_BIT                                 29
#define CPUID_EDX_IA64_AVAILABLE_FLAG                                0x20000000
#define CPUID_EDX_IA64_AVAILABLE_MASK                                0x01
#define CPUID_EDX_IA64_AVAILABLE(_)                                  (((_) >> 29) & 0x01)
            UINT32_t reserved5 : 2;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_80000001;


/**
 * Extended Function CPUID Information.
 */
#define CPUID_BRAND_STRING1                                          0x80000002

 /**
  * Extended Function CPUID Information.
  */
#define CPUID_BRAND_STRING2                                          0x80000003

  /**
   * Extended Function CPUID Information.
   */
#define CPUID_BRAND_STRING3                                          0x80000004
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String.
             */
            UINT32_t processor_brand_string_1 : 32;
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1_BIT                       0
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1_FLAG                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1_MASK                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_2 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_BIT                       0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_FLAG                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_MASK                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_3 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_BIT                       0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_FLAG                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_MASK                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_4 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_BIT                       0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_FLAG                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_MASK                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_80000002;

/**
 * @brief Extended Function CPUID Information
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_5 : 32;
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5_BIT                       0
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5_FLAG                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5_MASK                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_6 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_BIT                       0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_FLAG                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_MASK                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_7 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_BIT                       0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_FLAG                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_MASK                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_8 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_BIT                       0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_FLAG                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_MASK                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_80000003;

/**
 * @brief Extended Function CPUID Information
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_9 : 32;
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9_BIT                       0
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9_FLAG                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9_MASK                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_10 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_BIT                      0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_FLAG                     0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_MASK                     0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10(_)                       (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_11 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_BIT                      0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_FLAG                     0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_MASK                     0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11(_)                       (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_12 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_BIT                      0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_FLAG                     0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_MASK                     0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12(_)                       (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_80000004;

/**
 * @brief Extended Function CPUID Information
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_80000005;


/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_CACHE_INFO                                    0x80000006
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 7:0] Cache Line size in bytes.
             */
            UINT32_t cache_line_size_inUINT8s : 8;
#define CPUID_ECX_CACHE_LINE_SIZE_INUINT8S_BIT                       0
#define CPUID_ECX_CACHE_LINE_SIZE_INUINT8S_FLAG                      0xFF
#define CPUID_ECX_CACHE_LINE_SIZE_INUINT8S_MASK                      0xFF
#define CPUID_ECX_CACHE_LINE_SIZE_INUINT8S(_)                        (((_) >> 0) & 0xFF)
            UINT32_t reserved1 : 4;

            /**
             * [Bits 15:12] L2 Associativity field.
             * L2 associativity field encodings:
             * - 00H - Disabled.
             * - 01H - Direct mapped.
             * - 02H - 2-way.
             * - 04H - 4-way.
             * - 06H - 8-way.
             * - 08H - 16-way.
             * - 0FH - Fully associative.
             */
            UINT32_t l2_associativity_field : 4;
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_BIT                         12
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_FLAG                        0xF000
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_MASK                        0x0F
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD(_)                          (((_) >> 12) & 0x0F)

            /**
             * [Bits 31:16] Cache size in 1K units.
             */
            UINT32_t cache_size_in_1k_units : 16;
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_BIT                         16
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_FLAG                        0xFFFF0000
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_MASK                        0xFFFF
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS(_)                          (((_) >> 16) & 0xFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_80000006;


/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_TIME_STAMP_COUNTER                            0x80000007
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            UINT32_t reserved1 : 8;

            /**
             * [Bit 8] Invariant TSC available if 1.
             */
            UINT32_t invariant_tsc_available : 1;
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_BIT                        8
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_FLAG                       0x100
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_MASK                       0x01
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE(_)                         (((_) >> 8) & 0x01)
            UINT32_t reserved2 : 23;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_80000007;

/**
 * @}
 */

 /**
  * @defgroup model_specific_registers \
  *           Model Specific Registers
  *
  * @see Vol2A[3.2(CPUID)] (reference)
  * @{
  */
  /**
   * @defgroup ia32_p5_mc \
   *           IA32_P5_MC_(x)
   *
   * When machine-check exceptions are enabled for the Pentium processor (MCE flag is set in control register CR4), the
   * machine-check exception handler uses the RDMSR instruction to read the error type from the P5_MC_TYPE register and the
   * machine check address from the P5_MC_ADDR register. The handler then normally reports these register values to the
   * system console before aborting execution.
   *
   * @see Vol3B[15.10.2(Pentium Processor Machine-Check Exception Handling)] (reference)
   * @{
   */
   /**
    * Machine-check exception address.
    *
    * @remarks 05_01H
    * @see Vol4[2.22(MSRS IN PENTIUM PROCESSORS)]
    */
#define IA32_P5_MC_ADDR                                              0x00000000

    /**
     * Machine-check exception type.
     *
     * @remarks 05_01H
     * @see Vol4[2.22(MSRS IN PENTIUM PROCESSORS)]
     */
#define IA32_P5_MC_TYPE                                              0x00000001
     /**
      * @}
      */

      /**
       * System coherence line size.
       *
       * @remarks 0F_03H
       * @see Vol3A[8.10.5(Monitor/Mwait Address Range Determination)]
       * @see Vol3A[8.10.5(Monitor/Mwait Address Range Determination)] (reference)
       */
#define IA32_MONITOR_FILTER_LINE_SIZE                                0x00000006

       /**
        * Value as returned by instruction RDTSC.
        *
        * @remarks 05_01H
        * @see Vol3B[17.17(TIME-STAMP COUNTER)]
        */
#define IA32_TIME_STAMP_COUNTER                                      0x00000010

        /**
         * The operating system can use this MSR to determine "slot" information for the processor and the proper microcode update
         * to load.
         *
         * @remarks 06_01H
         */
#define IA32_PLATFORM_ID                                             0x00000017
typedef union
{
    struct
    {
        UINT64_t reserved1 : 50;

        /**
         * @brief Platform Id <b>(RO)</b>
         *
         * [Bits 52:50] Contains information concerning the intended platform for the processor.
         *
         *
         * 52 | 51 | 50 | _
         * --:|:--:|:---|-----------------
         * 0  | 0  | 0  | Processor Flag 0
         * 0  | 0  | 1  | Processor Flag 1
         * 0  | 1  | 0  | Processor Flag 2
         * 0  | 1  | 1  | Processor Flag 3
         * 1  | 0  | 0  | Processor Flag 4
         * 1  | 0  | 1  | Processor Flag 5
         * 1  | 1  | 0  | Processor Flag 6
         * 1  | 1  | 1  | Processor Flag 7
         */
        UINT64_t platform_id : 3;
#define IA32_PLATFORM_ID_PLATFORM_ID_BIT                             50
#define IA32_PLATFORM_ID_PLATFORM_ID_FLAG                            0x1C000000000000
#define IA32_PLATFORM_ID_PLATFORM_ID_MASK                            0x07
#define IA32_PLATFORM_ID_PLATFORM_ID(_)                              (((_) >> 50) & 0x07)
        UINT64_t reserved2 : 11;
    };

    UINT64_t flags;
} ia32_platform_id_register;


/**
 * This register holds the APIC base address, permitting the relocation of the APIC memory map.
 *
 * @remarks 06_01H
 * @see Vol3A[10.4.4(Local APIC Status and Location)]
 * @see Vol3A[10.4.5(Relocating the Local APIC Registers)]
 */
#define IA32_APIC_BASE                                               0x0000001B
typedef union
{
    struct
    {
        UINT64_t reserved1 : 8;

        /**
         * [Bit 8] BSP flag.
         */
        UINT64_t bsp_flag : 1;
#define IA32_APIC_BASE_BSP_FLAG_BIT                                  8
#define IA32_APIC_BASE_BSP_FLAG_FLAG                                 0x100
#define IA32_APIC_BASE_BSP_FLAG_MASK                                 0x01
#define IA32_APIC_BASE_BSP_FLAG(_)                                   (((_) >> 8) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * [Bit 10] Enable x2APIC mode.
         */
        UINT64_t enable_x2apic_mode : 1;
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_BIT                        10
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_FLAG                       0x400
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_MASK                       0x01
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE(_)                         (((_) >> 10) & 0x01)

        /**
         * [Bit 11] APIC Global Enable.
         */
        UINT64_t apic_global_enable : 1;
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_BIT                        11
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_FLAG                       0x800
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_MASK                       0x01
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE(_)                         (((_) >> 11) & 0x01)

        /**
         * [Bits 47:12] APIC Base.
         */
        UINT64_t apic_base : 36;
#define IA32_APIC_BASE_APIC_BASE_BIT                                 12
#define IA32_APIC_BASE_APIC_BASE_FLAG                                0xFFFFFFFFF000
#define IA32_APIC_BASE_APIC_BASE_MASK                                0xFFFFFFFFF
#define IA32_APIC_BASE_APIC_BASE(_)                                  (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved3 : 16;
    };

    UINT64_t flags;
} ia32_apic_base_register;


/**
 * Control Features in Intel 64 Processor.
 *
 * @remarks If any one enumeration condition for defined bit field holds.
 */
#define IA32_FEATURE_CONTROL                                         0x0000003A
typedef union
{
    struct
    {
        /**
         * @brief Lock bit <b>(R/WO)</b>
         *
         * [Bit 0] When set, locks this MSR from being written; writes to this bit will result in GP(0).
         *
         * @note Once the Lock bit is set, the contents of this register cannot be modified. Therefore the lock bit must be set
         *       after configuring support for Intel Virtualization Technology and prior to transferring control to an option ROM or the
         *       OS. Hence, once the Lock bit is set, the entire IA32_FEATURE_CONTROL contents are preserved across RESET when PWRGOOD is
         *       not deasserted.
         * @remarks If any one enumeration condition for defined bit field position greater than bit 0 holds.
         */
        UINT64_t lock_bit : 1;
#define IA32_FEATURE_CONTROL_LOCK_BIT_BIT                            0
#define IA32_FEATURE_CONTROL_LOCK_BIT_FLAG                           0x01
#define IA32_FEATURE_CONTROL_LOCK_BIT_MASK                           0x01
#define IA32_FEATURE_CONTROL_LOCK_BIT(_)                             (((_) >> 0) & 0x01)

        /**
         * @brief Enable VMX inside SMX operation <b>(R/WL)</b>
         *
         * [Bit 1] This bit enables a system executive to use VMX in conjunction with SMX to support Intel(R) Trusted Execution
         * Technology. BIOS must set this bit only when the CPUID function 1 returns VMX feature flag and SMX feature flag set (ECX
         * bits 5 and 6 respectively).
         *
         * @remarks If CPUID.01H:ECX[5] = 1 && CPUID.01H:ECX[6] = 1
         */
        UINT64_t enable_vmx_inside_smx : 1;
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_BIT               1
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_FLAG              0x02
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_MASK              0x01
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX(_)                (((_) >> 1) & 0x01)

        /**
         * @brief Enable VMX outside SMX operation <b>(R/WL)</b>
         *
         * [Bit 2] This bit enables VMX for a system executive that does not require SMX. BIOS must set this bit only when the
         * CPUID function 1 returns the VMX feature flag set (ECX bit 5).
         *
         * @remarks If CPUID.01H:ECX[5] = 1
         */
        UINT64_t enable_vmx_outside_smx : 1;
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_BIT              2
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_FLAG             0x04
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_MASK             0x01
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX(_)               (((_) >> 2) & 0x01)
        UINT64_t reserved1 : 5;

        /**
         * @brief SENTER Local Function Enable <b>(R/WL)</b>
         *
         * [Bits 14:8] When set, each bit in the field represents an enable control for a corresponding SENTER function. This field
         * is supported only if CPUID.1:ECX.[bit 6] is set.
         *
         * @remarks If CPUID.01H:ECX[6] = 1
         */
        UINT64_t senter_local_function_enables : 7;
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_BIT       8
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_FLAG      0x7F00
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_MASK      0x7F
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES(_)        (((_) >> 8) & 0x7F)

        /**
         * @brief SENTER Global Enable <b>(R/WL)</b>
         *
         * [Bit 15] This bit must be set to enable SENTER leaf functions. This bit is supported only if CPUID.1:ECX.[bit 6] is set.
         *
         * @remarks If CPUID.01H:ECX[6] = 1
         */
        UINT64_t senter_global_enable : 1;
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_BIT                15
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_FLAG               0x8000
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_MASK               0x01
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE(_)                 (((_) >> 15) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * @brief SGX Launch Control Enable <b>(R/WL)</b>
         *
         * [Bit 17] This bit must be set to enable runtime reconfiguration of SGX Launch Control via the IA32_SGXLEPUBKEYHASHn MSR.
         *
         * @remarks If CPUID.(EAX=07H, ECX=0H): ECX[30] = 1
         */
        UINT64_t sgx_launch_control_enable : 1;
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_BIT           17
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_FLAG          0x20000
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_MASK          0x01
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE(_)            (((_) >> 17) & 0x01)

        /**
         * @brief SGX Global Enable <b>(R/WL)</b>
         *
         * [Bit 18] This bit must be set to enable SGX leaf functions.
         *
         * @remarks If CPUID.(EAX=07H, ECX=0H): EBX[2] = 1
         */
        UINT64_t sgx_global_enable : 1;
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_BIT                   18
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_FLAG                  0x40000
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_MASK                  0x01
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE(_)                    (((_) >> 18) & 0x01)
        UINT64_t reserved3 : 1;

        /**
         * @brief LMCE On <b>(R/WL)</b>
         *
         * [Bit 20] When set, system software can program the MSRs associated with LMCE to configure delivery of some machine check
         * exceptions to a single logical processor.
         *
         * @remarks If IA32_MCG_CAP[27] = 1
         */
        UINT64_t lmce_on : 1;
#define IA32_FEATURE_CONTROL_LMCE_ON_BIT                             20
#define IA32_FEATURE_CONTROL_LMCE_ON_FLAG                            0x100000
#define IA32_FEATURE_CONTROL_LMCE_ON_MASK                            0x01
#define IA32_FEATURE_CONTROL_LMCE_ON(_)                              (((_) >> 20) & 0x01)
        UINT64_t reserved4 : 43;
    };

    UINT64_t flags;
} ia32_feature_control_register;


/**
 * Per Logical Processor TSC Adjust.
 *
 * @remarks If CPUID.(EAX=07H, ECX=0H): EBX[1] = 1
 */
#define IA32_TSC_ADJUST                                              0x0000003B
typedef struct
{
    /**
     * Local offset value of the IA32_TSC for a logical processor. Reset value is zero. A write to IA32_TSC will modify the
     * local offset in IA32_TSC_ADJUST and the content of IA32_TSC, but does not affect the internal invariant TSC hardware.
     */
    UINT64_t thread_adjust;
} ia32_tsc_adjust_register;


/**
 * @brief BIOS Update Trigger <b>(W)</b>
 *
 * Executing a WRMSR instruction to this MSR causes a microcode update to be loaded into the processor. A processor may
 * prevent writing to this MSR when loading guest states on VM entries or saving guest states on VM exits.
 *
 * @remarks 06_01H
 * @see Vol3A[9.11.6(Microcode Update Loader)]
 */
#define IA32_BIOS_UPDATE_TRIGGER                                     0x00000079

 /**
  * @brief BIOS Update Signature <b>(RO)</b>
  *
  * Returns the microcode update signature following the execution of CPUID.01H. A processor may prevent writing to this MSR
  * when loading guest states on VM entries or saving guest states on VM exits.
  *
  * @remarks 06_01H
  */
#define IA32_BIOS_UPDATE_SIGNATURE                                   0x0000008B
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] Reserved.
         */
        UINT64_t reserved : 32;
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED_BIT                      0
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED_FLAG                     0xFFFFFFFF
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED_MASK                     0xFFFFFFFF
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED(_)                       (((_) >> 0) & 0xFFFFFFFF)

        /**
         * @brief Microcode update signature
         *
         * [Bits 63:32] This field contains the signature of the currently loaded microcode update when read following the
         * execution of the CPUID instruction, function 1. It is required that this register field be pre-loaded with zero prior to
         * executing the CPUID, function 1. If the field remains equal to zero, then there is no microcode update loaded. Another
         * nonzero value will be the signature.
         *
         * @see Vol3A[9.11.7.1(Determining the Signature)] (reference)
         */
        UINT64_t microcode_update_signature : 32;
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_BIT    32
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_FLAG   0xFFFFFFFF00000000
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_MASK   0xFFFFFFFF
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE(_)     (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64_t flags;
} ia32_bios_update_signature_register;

/**
 * @defgroup ia32_sgxlepubkeyhash \
 *           IA32_SGXLEPUBKEYHASH[(64*n+63):(64*n)]
 *
 * Bits (64*n+63):(64*n) of the SHA256 digest of the SIGSTRUCT.MODULUS for SGX Launch Enclave. On reset, the default value
 * is the digest of Intel's signing key.
 *
 * @remarks Read permitted If CPUID.(EAX=12H,ECX=0H): EAX[0]=1 && CPUID.(EAX=07H,ECX=0H):ECX[30]=1. Write permitted if
 *          CPUID.(EAX=12H,ECX=0H): EAX[0]=1 && IA32_FEATURE_CONTROL[17] = 1 && IA32_FEATURE_CONTROL[0] = 1.
 * @{
 */
#define IA32_SGXLEPUBKEYHASH0                                        0x0000008C
#define IA32_SGXLEPUBKEYHASH1                                        0x0000008D
#define IA32_SGXLEPUBKEYHASH2                                        0x0000008E
#define IA32_SGXLEPUBKEYHASH3                                        0x0000008F
 /**
  * @}
  */


  /**
   * SMM Monitor Configuration.
   *
   * @remarks If CPUID.01H: ECX[5]=1 || CPUID.01H: ECX[6] = 1
   */
#define IA32_SMM_MONITOR_CTL                                         0x0000009B
typedef union
{
    struct
    {
        /**
         * @brief Valid <b>(R/W)</b>
         *
         * [Bit 0] The STM may be invoked using VMCALL only if this bit is 1. Because VMCALL is used to activate the dual-monitor
         * treatment, the dual-monitor treatment cannot be activated if the bit is 0. This bit is cleared when the logical
         * processor is reset.
         *
         * @see Vol3C[34.15.6(Activating the Dual-Monitor Treatment)]
         * @see Vol3C[34.15.5(Enabling the Dual-Monitor Treatment)] (reference)
         */
        UINT64_t valid : 1;
#define IA32_SMM_MONITOR_CTL_VALID_BIT                               0
#define IA32_SMM_MONITOR_CTL_VALID_FLAG                              0x01
#define IA32_SMM_MONITOR_CTL_VALID_MASK                              0x01
#define IA32_SMM_MONITOR_CTL_VALID(_)                                (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * @brief Controls SMI unblocking by VMXOFF
         *
         * [Bit 2] Determines whether executions of VMXOFF unblock SMIs under the default treatment of SMIs and SMM. Executions of
         * VMXOFF unblock SMIs unless bit 2 is 1 (the value of bit 0 is irrelevant).
         *
         * @remarks If IA32_VMX_MISC[28]
         * @see Vol3C[34.14.4(VMXOFF and SMI Unblocking)]
         * @see Vol3C[34.15.5(Enabling the Dual-Monitor Treatment)] (reference)
         */
        UINT64_t smi_unblocking_by_vmxoff : 1;
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_BIT            2
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_FLAG           0x04
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_MASK           0x01
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF(_)             (((_) >> 2) & 0x01)
        UINT64_t reserved2 : 9;

        /**
         * @brief MSEG Base <b>(R/W)</b>
         *
         * [Bits 31:12] Value that, when shifted left 12 bits, is the physical address of MSEG (the MSEG base address).
         *
         * @see Vol3C[34.15.5(Enabling the Dual-Monitor Treatment)] (reference)
         */
        UINT64_t mseg_base : 20;
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_BIT                           12
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_FLAG                          0xFFFFF000
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_MASK                          0xFFFFF
#define IA32_SMM_MONITOR_CTL_MSEG_BASE(_)                            (((_) >> 12) & 0xFFFFF)
        UINT64_t reserved3 : 32;
    };

    UINT64_t flags;
} ia32_smm_monitor_ctl_register;

typedef struct
{
    /**
     * @brief MSEG revision identifier
     *
     * Different processors may use different MSEG revision identifiers. These identifiers enable software to avoid using an
     * MSEG header formatted for one processor on a processor that uses a different format. Software can discover the MSEG
     * revision identifier that a processor uses by reading the VMX capability MSR IA32_VMX_MISC.
     *
     * @see Vol3D[A.6(MISCELLANEOUS DATA)]
     */
    UINT32_t mseg_header_revision;

    /**
     * @brief SMM-transfer monitor features field
     *
     * Bits 31:1 of this field are reserved and must be zero. Bit 0 of the field is the IA-32e mode SMM feature bit. It
     * indicates whether the logical processor will be in IA-32e mode after the STM is activated.
     *
     * @see Vol3C[34.15.6(Activating the Dual-Monitor Treatment)]
     */
    UINT32_t monitor_features;

    /**
     * Define values for the MonitorFeatures field of MSEG_HEADER.
     */
#define IA32_STM_FEATURES_IA32E                                      0x00000001

     /**
      * Fields that determine how processor state is loaded when the STM is activated. SMM code should establish these fields so
      * that activating of the STM invokes the STM's initialization code.
      *
      * @see Vol3C[34.15.6.5(Loading Host State)]
      */
    UINT32_t gdtr_limit;
    UINT32_t gdtr_base_offset;
    UINT32_t cs_selector;
    UINT32_t eip_offset;
    UINT32_t esp_offset;
    UINT32_t cr3_offset;
} ia32_mseg_header;


/**
 * Base address of the logical processor's SMRAM image.
 *
 * @remarks If IA32_VMX_MISC[15]
 */
#define IA32_SMBASE                                                  0x0000009E
 /**
  * @defgroup ia32_pmc \
  *           IA32_PMC(n)
  *
  * General Performance Counters.
  *
  * @remarks If CPUID.0AH: EAX[15:8] > n
  * @{
  */
#define IA32_PMC0                                                    0x000000C1
#define IA32_PMC1                                                    0x000000C2
#define IA32_PMC2                                                    0x000000C3
#define IA32_PMC3                                                    0x000000C4
#define IA32_PMC4                                                    0x000000C5
#define IA32_PMC5                                                    0x000000C6
#define IA32_PMC6                                                    0x000000C7
#define IA32_PMC7                                                    0x000000C8
  /**
   * @}
   */


   /**
    * TSC Frequency Clock Counter.
    *
    * @remarks If CPUID.06H: ECX[0] = 1
    */
#define IA32_MPERF                                                   0x000000E7
typedef struct
{
    /**
     * @brief C0 TSC Frequency Clock Count
     *
     * Increments at fixed interval (relative to TSC freq.) when the logical processor is in C0. Cleared upon overflow /
     * wrap-around of IA32_APERF.
     */
    UINT64_t c0_mcnt;
} ia32_mperf_register;


/**
 * Actual Performance Clock Counter
 *
 * @remarks If CPUID.06H: ECX[0] = 1
 */
#define IA32_APERF                                                   0x000000E8
typedef struct
{
    /**
     * @brief C0 Actual Frequency Clock Count
     *
     * Accumulates core clock counts at the coordinated clock frequency, when the logical processor is in C0. Cleared upon
     * overflow / wrap-around of IA32_MPERF.
     */
    UINT64_t c0_acnt;
} ia32_aperf_register;


/**
 * MTRR Capability.
 *
 * @see Vol3A[11.11.2.1(IA32_MTRR_DEF_TYPE MSR)]
 * @see Vol3A[11.11.1(MTRR Feature Identification)] (reference)
 */
#define IA32_MTRR_CAPABILITIES                                       0x000000FE
typedef union
{
    struct
    {
        /**
         * @brief VCNT (variable range registers count) field
         *
         * [Bits 7:0] Indicates the number of variable ranges implemented on the processor.
         */
        UINT64_t variable_range_count : 8;
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_BIT              0
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_FLAG             0xFF
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_MASK             0xFF
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT(_)               (((_) >> 0) & 0xFF)

        /**
         * @brief FIX (fixed range registers supported) flag
         *
         * [Bit 8] Fixed range MTRRs (IA32_MTRR_FIX64K_00000 through IA32_MTRR_FIX4K_0F8000) are supported when set; no fixed range
         * registers are supported when clear.
         */
        UINT64_t fixed_range_supported : 1;
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_BIT             8
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_FLAG            0x100
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_MASK            0x01
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED(_)              (((_) >> 8) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * @brief WC (write combining) flag
         *
         * [Bit 10] The write-combining (WC) memory type is supported when set; the WC type is not supported when clear.
         */
        UINT64_t wc_supported : 1;
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_BIT                      10
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_FLAG                     0x400
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_MASK                     0x01
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED(_)                       (((_) >> 10) & 0x01)

        /**
         * @brief SMRR (System-Management Range Register) flag
         *
         * [Bit 11] The system-management range register (SMRR) interface is supported when bit 11 is set; the SMRR interface is
         * not supported when clear.
         */
        UINT64_t smrr_supported : 1;
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_BIT                    11
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_FLAG                   0x800
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_MASK                   0x01
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED(_)                     (((_) >> 11) & 0x01)
        UINT64_t reserved2 : 52;
    };

    UINT64_t flags;
} ia32_mtrr_capabilities_register;


/**
 * @brief SYSENTER_CS_MSR <b>(R/W)</b>
 *
 * The lower 16 bits of this MSR are the segment selector for the privilege level 0 code segment. This value is also used
 * to determine the segment selector of the privilege level 0 stack segment. This value cannot indicate a null selector.
 *
 * @remarks 06_01H
 * @see Vol2B[4.3(Instructions (M-U) | SYSCALL - Fast System Call)] (reference)
 */
#define IA32_SYSENTER_CS                                             0x00000174
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] CS Selector.
         */
        UINT64_t cs_selector : 16;
#define IA32_SYSENTER_CS_CS_SELECTOR_BIT                             0
#define IA32_SYSENTER_CS_CS_SELECTOR_FLAG                            0xFFFF
#define IA32_SYSENTER_CS_CS_SELECTOR_MASK                            0xFFFF
#define IA32_SYSENTER_CS_CS_SELECTOR(_)                              (((_) >> 0) & 0xFFFF)

        /**
         * [Bits 31:16] Not used.
         *
         * @remarks Can be read and written.
         */
        UINT64_t not_used_1 : 16;
#define IA32_SYSENTER_CS_NOT_USED_1_BIT                              16
#define IA32_SYSENTER_CS_NOT_USED_1_FLAG                             0xFFFF0000
#define IA32_SYSENTER_CS_NOT_USED_1_MASK                             0xFFFF
#define IA32_SYSENTER_CS_NOT_USED_1(_)                               (((_) >> 16) & 0xFFFF)

        /**
         * [Bits 63:32] Not used.
         *
         * @remarks Writes ignored; reads return zero.
         */
        UINT64_t not_used_2 : 32;
#define IA32_SYSENTER_CS_NOT_USED_2_BIT                              32
#define IA32_SYSENTER_CS_NOT_USED_2_FLAG                             0xFFFFFFFF00000000
#define IA32_SYSENTER_CS_NOT_USED_2_MASK                             0xFFFFFFFF
#define IA32_SYSENTER_CS_NOT_USED_2(_)                               (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64_t flags;
} ia32_sysenter_cs_register;


/**
 * @brief SYSENTER_ESP_MSR <b>(R/W)</b>
 *
 * The value of this MSR is loaded into RSP (thus, this value contains the stack pointer for the privilege level 0 stack).
 * This value cannot represent a non-canonical address. In protected mode, only bits 31:0 are loaded.
 *
 * @remarks 06_01H
 * @see Vol2B[4.3(Instructions (M-U) | SYSCALL - Fast System Call)] (reference)
 */
#define IA32_SYSENTER_ESP                                            0x00000175

 /**
  * @brief SYSENTER_EIP_MSR <b>(R/W)</b>
  *
  * The value of this MSR is loaded into RIP (thus, this value references the first instruction of the selected operating
  * procedure or routine). In protected mode, only bits 31:0 are loaded.
  *
  * @remarks 06_01H
  * @see Vol2B[4.3(Instructions (M-U) | SYSCALL - Fast System Call)] (reference)
  */
#define IA32_SYSENTER_EIP                                            0x00000176

  /**
   * Global Machine Check Capability.
   *
   * @remarks 06_01H
   */
#define IA32_MCG_CAP                                                 0x00000179
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Number of reporting banks.
         */
        UINT64_t count : 8;
#define IA32_MCG_CAP_COUNT_BIT                                       0
#define IA32_MCG_CAP_COUNT_FLAG                                      0xFF
#define IA32_MCG_CAP_COUNT_MASK                                      0xFF
#define IA32_MCG_CAP_COUNT(_)                                        (((_) >> 0) & 0xFF)

        /**
         * [Bit 8] IA32_MCG_CTL is present if this bit is set.
         */
        UINT64_t mcg_ctl_p : 1;
#define IA32_MCG_CAP_MCG_CTL_P_BIT                                   8
#define IA32_MCG_CAP_MCG_CTL_P_FLAG                                  0x100
#define IA32_MCG_CAP_MCG_CTL_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_CTL_P(_)                                    (((_) >> 8) & 0x01)

        /**
         * [Bit 9] Extended machine check state registers are present if this bit is set.
         */
        UINT64_t mcg_ext_p : 1;
#define IA32_MCG_CAP_MCG_EXT_P_BIT                                   9
#define IA32_MCG_CAP_MCG_EXT_P_FLAG                                  0x200
#define IA32_MCG_CAP_MCG_EXT_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_EXT_P(_)                                    (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Support for corrected MC error event is present.
         *
         * @remarks 06_01H
         */
        UINT64_t mcp_cmci_p : 1;
#define IA32_MCG_CAP_MCP_CMCI_P_BIT                                  10
#define IA32_MCG_CAP_MCP_CMCI_P_FLAG                                 0x400
#define IA32_MCG_CAP_MCP_CMCI_P_MASK                                 0x01
#define IA32_MCG_CAP_MCP_CMCI_P(_)                                   (((_) >> 10) & 0x01)

        /**
         * [Bit 11] Threshold-based error status register are present if this bit is set.
         */
        UINT64_t mcg_tes_p : 1;
#define IA32_MCG_CAP_MCG_TES_P_BIT                                   11
#define IA32_MCG_CAP_MCG_TES_P_FLAG                                  0x800
#define IA32_MCG_CAP_MCG_TES_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_TES_P(_)                                    (((_) >> 11) & 0x01)
        UINT64_t reserved1 : 4;

        /**
         * [Bits 23:16] Number of extended machine check state registers present.
         */
        UINT64_t mcg_ext_cnt : 8;
#define IA32_MCG_CAP_MCG_EXT_CNT_BIT                                 16
#define IA32_MCG_CAP_MCG_EXT_CNT_FLAG                                0xFF0000
#define IA32_MCG_CAP_MCG_EXT_CNT_MASK                                0xFF
#define IA32_MCG_CAP_MCG_EXT_CNT(_)                                  (((_) >> 16) & 0xFF)

        /**
         * [Bit 24] The processor supports software error recovery if this bit is set.
         */
        UINT64_t mcg_ser_p : 1;
#define IA32_MCG_CAP_MCG_SER_P_BIT                                   24
#define IA32_MCG_CAP_MCG_SER_P_FLAG                                  0x1000000
#define IA32_MCG_CAP_MCG_SER_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_SER_P(_)                                    (((_) >> 24) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * [Bit 26] Indicates that the processor allows platform firmware to be invoked when an error is detected so that it may
         * provide additional platform specific information in an ACPI format "Generic Error Data Entry" that augments the data
         * included in machine check bank registers.
         *
         * @remarks 06_3EH
         */
        UINT64_t mcg_elog_p : 1;
#define IA32_MCG_CAP_MCG_ELOG_P_BIT                                  26
#define IA32_MCG_CAP_MCG_ELOG_P_FLAG                                 0x4000000
#define IA32_MCG_CAP_MCG_ELOG_P_MASK                                 0x01
#define IA32_MCG_CAP_MCG_ELOG_P(_)                                   (((_) >> 26) & 0x01)

        /**
         * [Bit 27] Indicates that the processor supports extended state in IA32_MCG_STATUS and associated MSR necessary to
         * configure Local Machine Check Exception (LMCE).
         *
         * @remarks 06_3EH
         */
        UINT64_t mcg_lmce_p : 1;
#define IA32_MCG_CAP_MCG_LMCE_P_BIT                                  27
#define IA32_MCG_CAP_MCG_LMCE_P_FLAG                                 0x8000000
#define IA32_MCG_CAP_MCG_LMCE_P_MASK                                 0x01
#define IA32_MCG_CAP_MCG_LMCE_P(_)                                   (((_) >> 27) & 0x01)
        UINT64_t reserved3 : 36;
    };

    UINT64_t flags;
} ia32_mcg_cap_register;


/**
 * Global Machine Check Status.
 *
 * @remarks 06_01H
 */
#define IA32_MCG_STATUS                                              0x0000017A
typedef union
{
    struct
    {
        /**
         * [Bit 0] Restart IP valid.
         *
         * @remarks 06_01H
         */
        UINT64_t ripv : 1;
#define IA32_MCG_STATUS_RIPV_BIT                                     0
#define IA32_MCG_STATUS_RIPV_FLAG                                    0x01
#define IA32_MCG_STATUS_RIPV_MASK                                    0x01
#define IA32_MCG_STATUS_RIPV(_)                                      (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Error IP valid.
         *
         * @remarks 06_01H
         */
        UINT64_t eipv : 1;
#define IA32_MCG_STATUS_EIPV_BIT                                     1
#define IA32_MCG_STATUS_EIPV_FLAG                                    0x02
#define IA32_MCG_STATUS_EIPV_MASK                                    0x01
#define IA32_MCG_STATUS_EIPV(_)                                      (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Machine check in progress.
         *
         * @remarks 06_01H
         */
        UINT64_t mcip : 1;
#define IA32_MCG_STATUS_MCIP_BIT                                     2
#define IA32_MCG_STATUS_MCIP_FLAG                                    0x04
#define IA32_MCG_STATUS_MCIP_MASK                                    0x01
#define IA32_MCG_STATUS_MCIP(_)                                      (((_) >> 2) & 0x01)

        /**
         * [Bit 3] If IA32_MCG_CAP.LMCE_P[27] = 1.
         */
        UINT64_t lmce_s : 1;
#define IA32_MCG_STATUS_LMCE_S_BIT                                   3
#define IA32_MCG_STATUS_LMCE_S_FLAG                                  0x08
#define IA32_MCG_STATUS_LMCE_S_MASK                                  0x01
#define IA32_MCG_STATUS_LMCE_S(_)                                    (((_) >> 3) & 0x01)
        UINT64_t reserved1 : 60;
    };

    UINT64_t flags;
} ia32_mcg_status_register;


/**
 * Global Machine Check Control.
 *
 * @remarks If IA32_MCG_CAP.CTL_P[8] = 1
 */
#define IA32_MCG_CTL                                                 0x0000017B
 /**
  * @defgroup ia32_perfevtsel \
  *           IA32_PERFEVTSEL(n)
  *
  * Performance Event Select Register n.
  *
  * @remarks If CPUID.0AH: EAX[15:8] > n
  * @{
  */
#define IA32_PERFEVTSEL0                                             0x00000186
#define IA32_PERFEVTSEL1                                             0x00000187
#define IA32_PERFEVTSEL2                                             0x00000188
#define IA32_PERFEVTSEL3                                             0x00000189
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Selects a performance event logic unit.
         */
        UINT64_t event_select : 8;
#define IA32_PERFEVTSEL_EVENT_SELECT_BIT                             0
#define IA32_PERFEVTSEL_EVENT_SELECT_FLAG                            0xFF
#define IA32_PERFEVTSEL_EVENT_SELECT_MASK                            0xFF
#define IA32_PERFEVTSEL_EVENT_SELECT(_)                              (((_) >> 0) & 0xFF)

        /**
         * [Bits 15:8] Qualifies the microarchitectural condition to detect on the selected event logic.
         */
        UINT64_t u_mask : 8;
#define IA32_PERFEVTSEL_U_MASK_BIT                                   8
#define IA32_PERFEVTSEL_U_MASK_FLAG                                  0xFF00
#define IA32_PERFEVTSEL_U_MASK_MASK                                  0xFF
#define IA32_PERFEVTSEL_U_MASK(_)                                    (((_) >> 8) & 0xFF)

        /**
         * [Bit 16] Counts while in privilege level is not ring 0.
         */
        UINT64_t usr : 1;
#define IA32_PERFEVTSEL_USR_BIT                                      16
#define IA32_PERFEVTSEL_USR_FLAG                                     0x10000
#define IA32_PERFEVTSEL_USR_MASK                                     0x01
#define IA32_PERFEVTSEL_USR(_)                                       (((_) >> 16) & 0x01)

        /**
         * [Bit 17] Counts while in privilege level is ring 0.
         */
        UINT64_t os : 1;
#define IA32_PERFEVTSEL_OS_BIT                                       17
#define IA32_PERFEVTSEL_OS_FLAG                                      0x20000
#define IA32_PERFEVTSEL_OS_MASK                                      0x01
#define IA32_PERFEVTSEL_OS(_)                                        (((_) >> 17) & 0x01)

        /**
         * [Bit 18] Enables edge detection if set.
         */
        UINT64_t edge : 1;
#define IA32_PERFEVTSEL_EDGE_BIT                                     18
#define IA32_PERFEVTSEL_EDGE_FLAG                                    0x40000
#define IA32_PERFEVTSEL_EDGE_MASK                                    0x01
#define IA32_PERFEVTSEL_EDGE(_)                                      (((_) >> 18) & 0x01)

        /**
         * [Bit 19] Enables pin control.
         */
        UINT64_t pc : 1;
#define IA32_PERFEVTSEL_PC_BIT                                       19
#define IA32_PERFEVTSEL_PC_FLAG                                      0x80000
#define IA32_PERFEVTSEL_PC_MASK                                      0x01
#define IA32_PERFEVTSEL_PC(_)                                        (((_) >> 19) & 0x01)

        /**
         * [Bit 20] Enables interrupt on counter overflow.
         */
        UINT64_t intr : 1;
#define IA32_PERFEVTSEL_INTR_BIT                                     20
#define IA32_PERFEVTSEL_INTR_FLAG                                    0x100000
#define IA32_PERFEVTSEL_INTR_MASK                                    0x01
#define IA32_PERFEVTSEL_INTR(_)                                      (((_) >> 20) & 0x01)

        /**
         * [Bit 21] When set to 1, it enables counting the associated event conditions occurring across all logical processors
         * sharing a processor core. When set to 0, the counter only increments the associated event conditions occurring in the
         * logical processor which programmed the MSR.
         */
        UINT64_t any_thread : 1;
#define IA32_PERFEVTSEL_ANY_THREAD_BIT                               21
#define IA32_PERFEVTSEL_ANY_THREAD_FLAG                              0x200000
#define IA32_PERFEVTSEL_ANY_THREAD_MASK                              0x01
#define IA32_PERFEVTSEL_ANY_THREAD(_)                                (((_) >> 21) & 0x01)

        /**
         * [Bit 22] Enables the corresponding performance counter to commence counting when this bit is set.
         */
        UINT64_t en : 1;
#define IA32_PERFEVTSEL_EN_BIT                                       22
#define IA32_PERFEVTSEL_EN_FLAG                                      0x400000
#define IA32_PERFEVTSEL_EN_MASK                                      0x01
#define IA32_PERFEVTSEL_EN(_)                                        (((_) >> 22) & 0x01)

        /**
         * [Bit 23] Invert the CMASK.
         */
        UINT64_t inv : 1;
#define IA32_PERFEVTSEL_INV_BIT                                      23
#define IA32_PERFEVTSEL_INV_FLAG                                     0x800000
#define IA32_PERFEVTSEL_INV_MASK                                     0x01
#define IA32_PERFEVTSEL_INV(_)                                       (((_) >> 23) & 0x01)

        /**
         * [Bits 31:24] When CMASK is not zero, the corresponding performance counter increments each cycle if the event count is
         * greater than or equal to the CMASK.
         */
        UINT64_t cmask : 8;
#define IA32_PERFEVTSEL_CMASK_BIT                                    24
#define IA32_PERFEVTSEL_CMASK_FLAG                                   0xFF000000
#define IA32_PERFEVTSEL_CMASK_MASK                                   0xFF
#define IA32_PERFEVTSEL_CMASK(_)                                     (((_) >> 24) & 0xFF)
        UINT64_t reserved1 : 32;
    };

    UINT64_t flags;
} ia32_perfevtsel_register;

/**
 * @}
 */


 /**
  * Current Performance Status.
  *
  * @remarks 0F_03H
  * @see Vol3B[14.1.1(Software Interface For Initiating Performance State Transitions)]
  */
#define IA32_PERF_STATUS                                             0x00000198
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] Current performance State Value.
         */
        UINT64_t state_value : 16;
#define IA32_PERF_STATUS_STATE_VALUE_BIT                             0
#define IA32_PERF_STATUS_STATE_VALUE_FLAG                            0xFFFF
#define IA32_PERF_STATUS_STATE_VALUE_MASK                            0xFFFF
#define IA32_PERF_STATUS_STATE_VALUE(_)                              (((_) >> 0) & 0xFFFF)
        UINT64_t reserved1 : 48;
    };

    UINT64_t flags;
} ia32_perf_status_register;


/**
 * @brief Performance Control <b>(R/W)</b>
 *
 * Performance Control. Software makes a request for a new Performance state (P-State) by writing this MSR.
 *
 * @remarks 0F_03H
 * @see Vol3B[14.1.1(Software Interface For Initiating Performance State Transitions)]
 */
#define IA32_PERF_CTL                                                0x00000199
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] Target performance State Value.
         */
        UINT64_t target_state_value : 16;
#define IA32_PERF_CTL_TARGET_STATE_VALUE_BIT                         0
#define IA32_PERF_CTL_TARGET_STATE_VALUE_FLAG                        0xFFFF
#define IA32_PERF_CTL_TARGET_STATE_VALUE_MASK                        0xFFFF
#define IA32_PERF_CTL_TARGET_STATE_VALUE(_)                          (((_) >> 0) & 0xFFFF)
        UINT64_t reserved1 : 16;

        /**
         * [Bit 32] IDA Engage.
         *
         * @remarks 06_0FH (Mobile only)
         */
        UINT64_t ida_engage : 1;
#define IA32_PERF_CTL_IDA_ENGAGE_BIT                                 32
#define IA32_PERF_CTL_IDA_ENGAGE_FLAG                                0x100000000
#define IA32_PERF_CTL_IDA_ENGAGE_MASK                                0x01
#define IA32_PERF_CTL_IDA_ENGAGE(_)                                  (((_) >> 32) & 0x01)
        UINT64_t reserved2 : 31;
    };

    UINT64_t flags;
} ia32_perf_ctl_register;


/**
 * Clock Modulation Control.
 *
 * @remarks If CPUID.01H:EDX[22] = 1
 * @see Vol3B[14.7.3(Software Controlled Clock Modulation)]
 */
#define IA32_CLOCK_MODULATION                                        0x0000019A
typedef union
{
    struct
    {
        /**
         * [Bit 0] Extended On-Demand Clock Modulation Duty Cycle.
         *
         * @remarks If CPUID.06H:EAX[5] = 1
         */
        UINT64_t extended_on_demand_clock_modulation_duty_cycle : 1;
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_BIT 0
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_FLAG 0x01
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_MASK 0x01
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE(_) (((_) >> 0) & 0x01)

        /**
         * @brief On-Demand Clock Modulation Duty Cycle
         *
         * [Bits 3:1] On-Demand Clock Modulation Duty Cycle: Specific encoded values for target duty cycle modulation.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t on_demand_clock_modulation_duty_cycle : 3;
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_BIT 1
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_FLAG 0x0E
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_MASK 0x07
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE(_) (((_) >> 1) & 0x07)

        /**
         * @brief On-Demand Clock Modulation Enable
         *
         * [Bit 4] On-Demand Clock Modulation Enable: Set 1 to enable modulation.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t on_demand_clock_modulation_enable : 1;
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_BIT  4
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_FLAG 0x10
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_MASK 0x01
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE(_)   (((_) >> 4) & 0x01)
        UINT64_t reserved1 : 59;
    };

    UINT64_t flags;
} ia32_clock_modulation_register;


/**
 * @brief Thermal Interrupt Control <b>(R/W)</b>
 *
 * Thermal Interrupt Control. Enables and disables the generation of an interrupt on temperature transitions detected with
 * the processor's thermal sensors and thermal monitor.
 *
 * @remarks If CPUID.01H:EDX[22] = 1
 * @see Vol3B[14.7.2(Thermal Monitor)]
 */
#define IA32_THERM_INTERRUPT                                         0x0000019B
typedef union
{
    struct
    {
        /**
         * [Bit 0] High-Temperature Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t high_temperature_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_BIT   0
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_FLAG  0x01
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_MASK  0x01
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE(_)    (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Low-Temperature Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t low_temperature_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_BIT    1
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_FLAG   0x02
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_MASK   0x01
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE(_)     (((_) >> 1) & 0x01)

        /**
         * [Bit 2] PROCHOT\# Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t prochot_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_BIT            2
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_FLAG           0x04
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_MASK           0x01
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE(_)             (((_) >> 2) & 0x01)

        /**
         * [Bit 3] FORCEPR\# Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t forcepr_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_BIT            3
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_FLAG           0x08
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_MASK           0x01
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE(_)             (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Critical Temperature Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t critical_temperature_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_BIT 4
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x10
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 4) & 0x01)
        UINT64_t reserved1 : 3;

        /**
         * [Bits 14:8] Threshold \#1 Value
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t threshold1_value : 7;
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_BIT                    8
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_FLAG                   0x7F00
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_MASK                   0x7F
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE(_)                     (((_) >> 8) & 0x7F)

        /**
         * [Bit 15] Threshold \#1 Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t threshold1_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_BIT         15
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_FLAG        0x8000
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_MASK        0x01
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE(_)          (((_) >> 15) & 0x01)

        /**
         * [Bits 22:16] Threshold \#2 Value.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t threshold2_value : 7;
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_BIT                    16
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_FLAG                   0x7F0000
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_MASK                   0x7F
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE(_)                     (((_) >> 16) & 0x7F)

        /**
         * [Bit 23] Threshold \#2 Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t threshold2_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_BIT         23
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_FLAG        0x800000
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_MASK        0x01
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE(_)          (((_) >> 23) & 0x01)

        /**
         * [Bit 24] Power Limit Notification Enable.
         *
         * @remarks If CPUID.06H:EAX[4] = 1
         */
        UINT64_t power_limit_notification_enable : 1;
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_BIT     24
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_FLAG    0x1000000
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_MASK    0x01
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE(_)      (((_) >> 24) & 0x01)
        UINT64_t reserved2 : 39;
    };

    UINT64_t flags;
} ia32_therm_interrupt_register;


/**
 * @brief Thermal Status Information <b>(RO)</b>
 *
 * Thermal Status Information. Contains status information about the processor's thermal sensor and automatic thermal
 * monitoring facilities.
 *
 * @remarks If CPUID.01H:EDX[22] = 1
 * @see Vol3B[14.7.2(Thermal Monitor)]
 */
#define IA32_THERM_STATUS                                            0x0000019C
typedef union
{
    struct
    {
        /**
         * [Bit 0] Thermal Status
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t thermal_status : 1;
#define IA32_THERM_STATUS_THERMAL_STATUS_BIT                         0
#define IA32_THERM_STATUS_THERMAL_STATUS_FLAG                        0x01
#define IA32_THERM_STATUS_THERMAL_STATUS_MASK                        0x01
#define IA32_THERM_STATUS_THERMAL_STATUS(_)                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Thermal Status Log
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t thermal_status_log : 1;
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_BIT                     1
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_FLAG                    0x02
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_MASK                    0x01
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG(_)                      (((_) >> 1) & 0x01)

        /**
         * [Bit 2] PROCHOT \# or FORCEPR\# event
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t prochot_forcepr_event : 1;
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_BIT                  2
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_FLAG                 0x04
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_MASK                 0x01
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT(_)                   (((_) >> 2) & 0x01)

        /**
         * [Bit 3] PROCHOT \# or FORCEPR\# log
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t prochot_forcepr_log : 1;
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_BIT                    3
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_FLAG                   0x08
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_MASK                   0x01
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG(_)                     (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Critical Temperature Status
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t critical_temperature_status : 1;
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_BIT            4
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_FLAG           0x10
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_MASK           0x01
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS(_)             (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Critical Temperature Status log
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t critical_temperature_status_log : 1;
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_BIT        5
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_FLAG       0x20
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_MASK       0x01
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG(_)         (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Thermal Threshold \#1 Status
         *
         * @remarks If CPUID.01H:ECX[8] = 1
         */
        UINT64_t thermal_threshold1_status : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_BIT              6
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_FLAG             0x40
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_MASK             0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS(_)               (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Thermal Threshold \#1 log
         *
         * @remarks If CPUID.01H:ECX[8] = 1
         */
        UINT64_t thermal_threshold1_log : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_BIT                 7
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_FLAG                0x80
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_MASK                0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG(_)                  (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Thermal Threshold \#2 Status
         *
         * @remarks If CPUID.01H:ECX[8] = 1
         */
        UINT64_t thermal_threshold2_status : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_BIT              8
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_FLAG             0x100
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_MASK             0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS(_)               (((_) >> 8) & 0x01)

        /**
         * [Bit 9] Thermal Threshold \#2 log
         *
         * @remarks If CPUID.01H:ECX[8] = 1
         */
        UINT64_t thermal_threshold2_log : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_BIT                 9
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_FLAG                0x200
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_MASK                0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG(_)                  (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Power Limitation Status
         *
         * @remarks If CPUID.06H:EAX[4] = 1
         */
        UINT64_t power_limitation_status : 1;
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_BIT                10
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_FLAG               0x400
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_MASK               0x01
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS(_)                 (((_) >> 10) & 0x01)

        /**
         * [Bit 11] Power Limitation log
         *
         * @remarks If CPUID.06H:EAX[4] = 1
         */
        UINT64_t power_limitation_log : 1;
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_BIT                   11
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_FLAG                  0x800
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_MASK                  0x01
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG(_)                    (((_) >> 11) & 0x01)

        /**
         * [Bit 12] Current Limit Status
         *
         * @remarks If CPUID.06H:EAX[7] = 1
         */
        UINT64_t current_limit_status : 1;
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_BIT                   12
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_FLAG                  0x1000
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_MASK                  0x01
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS(_)                    (((_) >> 12) & 0x01)

        /**
         * [Bit 13] Current Limit log
         *
         * @remarks If CPUID.06H:EAX[7] = 1
         */
        UINT64_t current_limit_log : 1;
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_BIT                      13
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_FLAG                     0x2000
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_MASK                     0x01
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG(_)                       (((_) >> 13) & 0x01)

        /**
         * [Bit 14] Cross Domain Limit Status
         *
         * @remarks If CPUID.06H:EAX[7] = 1
         */
        UINT64_t cross_domain_limit_status : 1;
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_BIT              14
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_FLAG             0x4000
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_MASK             0x01
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS(_)               (((_) >> 14) & 0x01)

        /**
         * [Bit 15] Cross Domain Limit log
         *
         * @remarks If CPUID.06H:EAX[7] = 1
         */
        UINT64_t cross_domain_limit_log : 1;
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_BIT                 15
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_FLAG                0x8000
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_MASK                0x01
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG(_)                  (((_) >> 15) & 0x01)

        /**
         * [Bits 22:16] Digital Readout
         *
         * @remarks If CPUID.06H:EAX[0] = 1
         */
        UINT64_t digital_readout : 7;
#define IA32_THERM_STATUS_DIGITAL_READOUT_BIT                        16
#define IA32_THERM_STATUS_DIGITAL_READOUT_FLAG                       0x7F0000
#define IA32_THERM_STATUS_DIGITAL_READOUT_MASK                       0x7F
#define IA32_THERM_STATUS_DIGITAL_READOUT(_)                         (((_) >> 16) & 0x7F)
        UINT64_t reserved1 : 4;

        /**
         * [Bits 30:27] Resolution in Degrees Celsius
         *
         * @remarks If CPUID.06H:EAX[0] = 1
         */
        UINT64_t resolution_in_degrees_celsius : 4;
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_BIT          27
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_FLAG         0x78000000
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_MASK         0x0F
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS(_)           (((_) >> 27) & 0x0F)

        /**
         * [Bit 31] Reading Valid
         *
         * @remarks If CPUID.06H:EAX[0] = 1
         */
        UINT64_t reading_valid : 1;
#define IA32_THERM_STATUS_READING_VALID_BIT                          31
#define IA32_THERM_STATUS_READING_VALID_FLAG                         0x80000000
#define IA32_THERM_STATUS_READING_VALID_MASK                         0x01
#define IA32_THERM_STATUS_READING_VALID(_)                           (((_) >> 31) & 0x01)
        UINT64_t reserved2 : 32;
    };

    UINT64_t flags;
} ia32_therm_status_register;


/**
 * @brief Enable Misc. Processor Features <b>(R/W)</b>
 *
 * Allows a variety of processor functions to be enabled and disabled.
 */
#define IA32_MISC_ENABLE                                             0x000001A0
typedef union
{
    struct
    {
        /**
         * @brief Fast-Strings Enable
         *
         * [Bit 0] When set, the fast-strings feature (for REP MOVS and REP STORS) is enabled (default). When clear, fast-strings
         * are disabled.
         *
         * @remarks 0F_0H
         */
        UINT64_t fast_strings_enable : 1;
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_BIT                     0
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_FLAG                    0x01
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_MASK                    0x01
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE(_)                      (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 2;

        /**
         * @brief Automatic Thermal Control Circuit Enable <b>(R/W)</b>
         *
         * [Bit 3] - 1 = Setting this bit enables the thermal control circuit (TCC) portion of the Intel Thermal Monitor feature.
         * This allows the processor to automatically reduce power consumption in response to TCC activation.
         * - 0 = Disabled.
         *
         * @note In some products clearing this bit might be ignored in critical thermal conditions, and TM1, TM2 and adaptive
         *       thermal throttling will still be activated. The default value of this field varies with product.
         * @remarks 0F_0H
         */
        UINT64_t automatic_thermal_control_circuit_enable : 1;
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_BIT 3
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_FLAG 0x08
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_MASK 0x01
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE(_) (((_) >> 3) & 0x01)
        UINT64_t reserved2 : 3;

        /**
         * @brief Performance Monitoring Available <b>(R)</b>
         *
         * [Bit 7] - 1 = Performance monitoring enabled.
         * - 0 = Performance monitoring disabled.
         *
         * @remarks 0F_0H
         */
        UINT64_t performance_monitoring_available : 1;
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_BIT        7
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_FLAG       0x80
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_MASK       0x01
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE(_)         (((_) >> 7) & 0x01)
        UINT64_t reserved3 : 3;

        /**
         * @brief Branch Trace Storage Unavailable <b>(RO)</b>
         *
         * [Bit 11] - 1 = Processor doesn't support branch trace storage (BTS).
         * - 0 = BTS is supported.
         *
         * @remarks 0F_0H
         */
        UINT64_t branch_trace_storage_unavailable : 1;
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_BIT        11
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_FLAG       0x800
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_MASK       0x01
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE(_)         (((_) >> 11) & 0x01)

        /**
         * @brief Processor Event Based Sampling (PEBS) Unavailable <b>(RO)</b>
         *
         * [Bit 12] - 1 = PEBS is not supported.
         * - 0 = PEBS is supported.
         *
         * @remarks 06_0FH
         */
        UINT64_t processor_event_based_sampling_unavailable : 1;
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_BIT 12
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_FLAG 0x1000
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_MASK 0x01
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE(_) (((_) >> 12) & 0x01)
        UINT64_t reserved4 : 3;

        /**
         * @brief Enhanced Intel SpeedStep Technology Enable <b>(R/W)</b>
         *
         * [Bit 16] - 0 = Enhanced Intel SpeedStep Technology disabled.
         * - 1 = Enhanced Intel SpeedStep Technology enabled.
         *
         * @remarks If CPUID.01H: ECX[7] = 1
         */
        UINT64_t enhanced_intel_speedstep_technology_enable : 1;
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_BIT 16
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_FLAG 0x10000
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_MASK 0x01
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE(_) (((_) >> 16) & 0x01)
        UINT64_t reserved5 : 1;

        /**
         * @brief ENABLE MONITOR FSM <b>(R/W)</b>
         *
         * [Bit 18] When this bit is set to 0, the MONITOR feature flag is not set (CPUID.01H:ECX[bit3] = 0). This indicates that
         * MONITOR/MWAIT are not supported. Software attempts to execute MONITOR/MWAIT will cause \#UD when this bit is 0.
         * When this bit is set to 1 (default), MONITOR/MWAIT are supported (CPUID.01H:ECX[bit 3] = 1). If the SSE3 feature flag
         * ECX[0] is not set (CPUID.01H:ECX[bit 0] = 0), the OS must not attempt to alter this bit. BIOS must leave it in the
         * default state. Writing this bit when the SSE3 feature flag is set to 0 may generate a \#GP exception.
         *
         * @remarks 0F_03H
         */
        UINT64_t enable_monitor_fsm : 1;
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_BIT                      18
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_FLAG                     0x40000
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_MASK                     0x01
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM(_)                       (((_) >> 18) & 0x01)
        UINT64_t reserved6 : 3;

        /**
         * @brief Limit CPUID Maxval <b>(R/W)</b>
         *
         * [Bit 22] When this bit is set to 1, CPUID.00H returns a maximum value in EAX[7:0] of 2. BIOS should contain a setup
         * question that allows users to specify when the installed OS does not support CPUID functions greater than 2.
         * Before setting this bit, BIOS must execute the CPUID.0H and examine the maximum value returned in EAX[7:0]. If the
         * maximum value is greater than 2, this bit is supported.
         * Otherwise, this bit is not supported. Setting this bit when the maximum value is not greater than 2 may generate a \#GP
         * exception. Setting this bit may cause unexpected behavior in software that depends on the availability of CPUID leaves
         * greater than 2.
         *
         * @remarks 0F_03H
         */
        UINT64_t limit_cpuid_maxval : 1;
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_BIT                      22
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_FLAG                     0x400000
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_MASK                     0x01
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL(_)                       (((_) >> 22) & 0x01)

        /**
         * @brief xTPR Message Disable <b>(R/W)</b>
         *
         * [Bit 23] When set to 1, xTPR messages are disabled. xTPR messages are optional messages that allow the processor to
         * inform the chipset of its priority.
         *
         * @remarks If CPUID.01H:ECX[14] = 1
         */
        UINT64_t xtpr_message_disable : 1;
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_BIT                    23
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_FLAG                   0x800000
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_MASK                   0x01
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE(_)                     (((_) >> 23) & 0x01)
        UINT64_t reserved7 : 10;

        /**
         * @brief XD Bit Disable <b>(R/W)</b>
         *
         * [Bit 34] When set to 1, the Execute Disable Bit feature (XD Bit) is disabled and the XD Bit extended feature flag will
         * be clear (CPUID.80000001H: EDX[20]=0).
         * When set to a 0 (default), the Execute Disable Bit feature (if available) allows the OS to enable PAE paging and take
         * advantage of data only pages.
         * BIOS must not alter the contents of this bit location, if XD bit is not supported. Writing this bit to 1 when the XD Bit
         * extended feature flag is set to 0 may generate a \#GP exception.
         *
         * @remarks If CPUID.80000001H:EDX[20] = 1
         */
        UINT64_t xd_bit_disable : 1;
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_BIT                          34
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_FLAG                         0x400000000
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_MASK                         0x01
#define IA32_MISC_ENABLE_XD_BIT_DISABLE(_)                           (((_) >> 34) & 0x01)
        UINT64_t reserved8 : 29;
    };

    UINT64_t flags;
} ia32_misc_enable_register;


/**
 * Performance Energy Bias Hint.
 *
 * @remarks If CPUID.6H:ECX[3] = 1
 */
#define IA32_ENERGY_PERF_BIAS                                        0x000001B0
typedef union
{
    struct
    {
        /**
         * @brief Power Policy Preference
         *
         * [Bits 3:0] - 0 indicates preference to highest performance.
         * - 15 indicates preference to maximize energy saving.
         */
        UINT64_t power_policy_preference : 4;
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_BIT            0
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_FLAG           0x0F
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_MASK           0x0F
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE(_)             (((_) >> 0) & 0x0F)
        UINT64_t reserved1 : 60;
    };

    UINT64_t flags;
} ia32_energy_perf_bias_register;


/**
 * @brief Package Thermal Status Information <b>(RO)</b>
 *
 * Package Thermal Status Information. Contains status information about the package's thermal sensor.
 *
 * @remarks If CPUID.06H: EAX[6] = 1
 * @see Vol3B[14.8(PACKAGE LEVEL THERMAL MANAGEMENT)]
 */
#define IA32_PACKAGE_THERM_STATUS                                    0x000001B1
typedef union
{
    struct
    {
        /**
         * [Bit 0] Pkg Thermal Status
         */
        UINT64_t thermal_status : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_BIT                 0
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_FLAG                0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_MASK                0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS(_)                  (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Pkg Thermal Status Log
         */
        UINT64_t thermal_status_log : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_BIT             1
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_FLAG            0x02
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_MASK            0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG(_)              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Pkg PROCHOT \# event
         */
        UINT64_t prochot_event : 1;
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_BIT                  2
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_FLAG                 0x04
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_MASK                 0x01
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT(_)                   (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Pkg PROCHOT \# log
         */
        UINT64_t prochot_log : 1;
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_BIT                    3
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_FLAG                   0x08
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_MASK                   0x01
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG(_)                     (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Pkg Critical Temperature Status
         */
        UINT64_t critical_temperature_status : 1;
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_BIT    4
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_FLAG   0x10
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_MASK   0x01
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS(_)     (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Pkg Critical Temperature Status Log
         */
        UINT64_t critical_temperature_status_log : 1;
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_BIT 5
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_FLAG 0x20
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG(_) (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Pkg Thermal Threshold \#1 Status
         */
        UINT64_t thermal_threshold1_status : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_BIT      6
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_FLAG     0x40
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_MASK     0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS(_)       (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Pkg Thermal Threshold \#1 log
         */
        UINT64_t thermal_threshold1_log : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_BIT         7
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_FLAG        0x80
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_MASK        0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG(_)          (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Pkg Thermal Threshold \#2 Status
         */
        UINT64_t thermal_threshold2_status : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_BIT      8
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_FLAG     0x100
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_MASK     0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS(_)       (((_) >> 8) & 0x01)

        /**
         * [Bit 9] Pkg Thermal Threshold \#2 log
         */
        UINT64_t thermal_threshold2_log : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_BIT         9
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_FLAG        0x200
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_MASK        0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG(_)          (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Pkg Power Limitation Status
         */
        UINT64_t power_limitation_status : 1;
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_BIT        10
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_FLAG       0x400
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_MASK       0x01
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS(_)         (((_) >> 10) & 0x01)

        /**
         * [Bit 11] Pkg Power Limitation log
         */
        UINT64_t power_limitation_log : 1;
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_BIT           11
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_FLAG          0x800
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_MASK          0x01
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG(_)            (((_) >> 11) & 0x01)
        UINT64_t reserved1 : 4;

        /**
         * [Bits 22:16] Pkg Digital Readout
         */
        UINT64_t digital_readout : 7;
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_BIT                16
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_FLAG               0x7F0000
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_MASK               0x7F
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT(_)                 (((_) >> 16) & 0x7F)
        UINT64_t reserved2 : 41;
    };

    UINT64_t flags;
} ia32_package_therm_status_register;


/**
 * @brief Package Thermal Interrupt Control <b>(RO)</b>
 *
 * Enables and disables the generation of an interrupt on temperature transitions detected with the package's thermal
 * sensor.
 *
 * @remarks If CPUID.06H: EAX[6] = 1
 * @see Vol3B[14.8(PACKAGE LEVEL THERMAL MANAGEMENT)]
 */
#define IA32_PACKAGE_THERM_INTERRUPT                                 0x000001B2
typedef union
{
    struct
    {
        /**
         * [Bit 0] Pkg High-Temperature Interrupt Enable.
         */
        UINT64_t high_temperature_interrupt_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_BIT 0
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Pkg Low-Temperature Interrupt Enable.
         */
        UINT64_t low_temperature_interrupt_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_BIT 1
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x02
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Pkg PROCHOT\# Interrupt Enable.
         */
        UINT64_t prochot_interrupt_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_BIT    2
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_FLAG   0x04
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_MASK   0x01
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE(_)     (((_) >> 2) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * [Bit 4] Pkg Overheat Interrupt Enable.
         */
        UINT64_t overheat_interrupt_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_BIT   4
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_FLAG  0x10
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_MASK  0x01
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE(_)    (((_) >> 4) & 0x01)
        UINT64_t reserved2 : 3;

        /**
         * [Bits 14:8] Pkg Threshold \#1 Value
         */
        UINT64_t threshold1_value : 7;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_BIT            8
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_FLAG           0x7F00
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_MASK           0x7F
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE(_)             (((_) >> 8) & 0x7F)

        /**
         * [Bit 15] Pkg Threshold \#1 Interrupt Enable.
         */
        UINT64_t threshold1_interrupt_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_BIT 15
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_FLAG 0x8000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE(_)  (((_) >> 15) & 0x01)

        /**
         * [Bits 22:16] Pkg Threshold \#2 Value.
         */
        UINT64_t threshold2_value : 7;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_BIT            16
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_FLAG           0x7F0000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_MASK           0x7F
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE(_)             (((_) >> 16) & 0x7F)

        /**
         * [Bit 23] Pkg Threshold \#2 Interrupt Enable.
         */
        UINT64_t threshold2_interrupt_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_BIT 23
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_FLAG 0x800000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE(_)  (((_) >> 23) & 0x01)

        /**
         * [Bit 24] Pkg Power Limit Notification Enable.
         */
        UINT64_t power_limit_notification_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_BIT 24
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_FLAG 0x1000000
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE(_) (((_) >> 24) & 0x01)
        UINT64_t reserved3 : 39;
    };

    UINT64_t flags;
} ia32_package_therm_interrupt_register;


/**
 * Trace/Profile Resource Control.
 *
 * @remarks 06_0EH
 */
#define IA32_DEBUGCTL                                                0x000001D9
typedef union
{
    struct
    {
        /**
         * [Bit 0] Setting this bit to 1 enables the processor to record a running trace of the most recent branches taken by the
         * processor in the LBR stack.
         *
         * @remarks 06_01H
         */
        UINT64_t lbr : 1;
#define IA32_DEBUGCTL_LBR_BIT                                        0
#define IA32_DEBUGCTL_LBR_FLAG                                       0x01
#define IA32_DEBUGCTL_LBR_MASK                                       0x01
#define IA32_DEBUGCTL_LBR(_)                                         (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Setting this bit to 1 enables the processor to treat EFLAGS.TF as single-step on branches instead of single-step
         * on instructions.
         *
         * @remarks 06_01H
         */
        UINT64_t btf : 1;
#define IA32_DEBUGCTL_BTF_BIT                                        1
#define IA32_DEBUGCTL_BTF_FLAG                                       0x02
#define IA32_DEBUGCTL_BTF_MASK                                       0x01
#define IA32_DEBUGCTL_BTF(_)                                         (((_) >> 1) & 0x01)
        UINT64_t reserved1 : 4;

        /**
         * [Bit 6] Setting this bit to 1 enables branch trace messages to be sent.
         *
         * @remarks 06_0EH
         */
        UINT64_t tr : 1;
#define IA32_DEBUGCTL_TR_BIT                                         6
#define IA32_DEBUGCTL_TR_FLAG                                        0x40
#define IA32_DEBUGCTL_TR_MASK                                        0x01
#define IA32_DEBUGCTL_TR(_)                                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Setting this bit enables branch trace messages (BTMs) to be logged in a BTS buffer.
         *
         * @remarks 06_0EH
         */
        UINT64_t bts : 1;
#define IA32_DEBUGCTL_BTS_BIT                                        7
#define IA32_DEBUGCTL_BTS_FLAG                                       0x80
#define IA32_DEBUGCTL_BTS_MASK                                       0x01
#define IA32_DEBUGCTL_BTS(_)                                         (((_) >> 7) & 0x01)

        /**
         * [Bit 8] When clear, BTMs are logged in a BTS buffer in circular fashion. When this bit is set, an interrupt is generated
         * by the BTS facility when the BTS buffer is full.
         *
         * @remarks 06_0EH
         */
        UINT64_t btint : 1;
#define IA32_DEBUGCTL_BTINT_BIT                                      8
#define IA32_DEBUGCTL_BTINT_FLAG                                     0x100
#define IA32_DEBUGCTL_BTINT_MASK                                     0x01
#define IA32_DEBUGCTL_BTINT(_)                                       (((_) >> 8) & 0x01)

        /**
         * [Bit 9] When set, BTS or BTM is skipped if CPL = 0.
         *
         * @remarks 06_0FH
         */
        UINT64_t bts_off_os : 1;
#define IA32_DEBUGCTL_BTS_OFF_OS_BIT                                 9
#define IA32_DEBUGCTL_BTS_OFF_OS_FLAG                                0x200
#define IA32_DEBUGCTL_BTS_OFF_OS_MASK                                0x01
#define IA32_DEBUGCTL_BTS_OFF_OS(_)                                  (((_) >> 9) & 0x01)

        /**
         * [Bit 10] When set, BTS or BTM is skipped if CPL > 0.
         *
         * @remarks 06_0FH
         */
        UINT64_t bts_off_usr : 1;
#define IA32_DEBUGCTL_BTS_OFF_USR_BIT                                10
#define IA32_DEBUGCTL_BTS_OFF_USR_FLAG                               0x400
#define IA32_DEBUGCTL_BTS_OFF_USR_MASK                               0x01
#define IA32_DEBUGCTL_BTS_OFF_USR(_)                                 (((_) >> 10) & 0x01)

        /**
         * [Bit 11] When set, the LBR stack is frozen on a PMI request.
         *
         * @remarks If CPUID.01H: ECX[15] = 1 && CPUID.0AH: EAX[7:0] > 1
         */
        UINT64_t freeze_lbrs_on_pmi : 1;
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_BIT                         11
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_FLAG                        0x800
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_MASK                        0x01
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI(_)                          (((_) >> 11) & 0x01)

        /**
         * [Bit 12] When set, each ENABLE bit of the global counter control MSR are frozen (address 38FH) on a PMI request.
         *
         * @remarks If CPUID.01H: ECX[15] = 1 && CPUID.0AH: EAX[7:0] > 1
         */
        UINT64_t freeze_perfmon_on_pmi : 1;
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_BIT                      12
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_FLAG                     0x1000
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_MASK                     0x01
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI(_)                       (((_) >> 12) & 0x01)

        /**
         * [Bit 13] When set, enables the logical processor to receive and generate PMI on behalf of the uncore.
         *
         * @remarks 06_1AH
         */
        UINT64_t enable_uncore_pmi : 1;
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_BIT                          13
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_FLAG                         0x2000
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_MASK                         0x01
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI(_)                           (((_) >> 13) & 0x01)

        /**
         * [Bit 14] When set, freezes perfmon and trace messages while in SMM.
         *
         * @remarks If IA32_PERF_CAPABILITIES[12] = 1
         */
        UINT64_t freeze_while_smm : 1;
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_BIT                           14
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_FLAG                          0x4000
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_MASK                          0x01
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM(_)                            (((_) >> 14) & 0x01)

        /**
         * [Bit 15] When set, enables DR7 debug bit on XBEGIN.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[11] = 1)
         */
        UINT64_t rtm_debug : 1;
#define IA32_DEBUGCTL_RTM_DEBUG_BIT                                  15
#define IA32_DEBUGCTL_RTM_DEBUG_FLAG                                 0x8000
#define IA32_DEBUGCTL_RTM_DEBUG_MASK                                 0x01
#define IA32_DEBUGCTL_RTM_DEBUG(_)                                   (((_) >> 15) & 0x01)
        UINT64_t reserved2 : 48;
    };

    UINT64_t flags;
} ia32_debugctl_register;


/**
 * @brief SMRR Base Address <b>(Writeable only in SMM)</b>
 *
 * SMRR Base Address. Base address of SMM memory range.
 *
 * @remarks If IA32_MTRRCAP.SMRR[11] = 1
 */
#define IA32_SMRR_PHYSBASE                                           0x000001F2
typedef union
{
    struct
    {
        /**
         * @brief Type
         *
         * [Bits 7:0] Type. Specifies memory type of the range.
         */
        UINT64_t type : 8;
#define IA32_SMRR_PHYSBASE_TYPE_BIT                                  0
#define IA32_SMRR_PHYSBASE_TYPE_FLAG                                 0xFF
#define IA32_SMRR_PHYSBASE_TYPE_MASK                                 0xFF
#define IA32_SMRR_PHYSBASE_TYPE(_)                                   (((_) >> 0) & 0xFF)
        UINT64_t reserved1 : 4;

        /**
         * [Bits 31:12] SMRR physical Base Address.
         */
        UINT64_t smrr_physical_base_address : 20;
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_BIT            12
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_FLAG           0xFFFFF000
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_MASK           0xFFFFF
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS(_)             (((_) >> 12) & 0xFFFFF)
        UINT64_t reserved2 : 32;
    };

    UINT64_t flags;
} ia32_smrr_physbase_register;


/**
 * @brief SMRR Range Mask <b>(Writeable only in SMM)</b>
 *
 * Range Mask of SMM memory range.
 *
 * @remarks If IA32_MTRRCAP[SMRR] = 1
 */
#define IA32_SMRR_PHYSMASK                                           0x000001F3
typedef union
{
    struct
    {
        UINT64_t reserved1 : 11;

        /**
         * [Bit 11] Enable range mask.
         */
        UINT64_t enable_range_mask : 1;
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_BIT                     11
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_FLAG                    0x800
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_MASK                    0x01
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK(_)                      (((_) >> 11) & 0x01)

        /**
         * [Bits 31:12] SMRR address range mask.
         */
        UINT64_t smrr_address_range_mask : 20;
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_BIT               12
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_FLAG              0xFFFFF000
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_MASK              0xFFFFF
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK(_)                (((_) >> 12) & 0xFFFFF)
        UINT64_t reserved2 : 32;
    };

    UINT64_t flags;
} ia32_smrr_physmask_register;


/**
 * DCA Capability.
 *
 * @remarks If CPUID.01H: ECX[18] = 1
 */
#define IA32_PLATFORM_DCA_CAP                                        0x000001F8

 /**
  * If set, CPU supports Prefetch-Hint type.
  *
  * @remarks If CPUID.01H: ECX[18] = 1
  */
#define IA32_CPU_DCA_CAP                                             0x000001F9

  /**
   * DCA type 0 Status and Control register.
   *
   * @remarks If CPUID.01H: ECX[18] = 1
   */
#define IA32_DCA_0_CAP                                               0x000001FA
typedef union
{
    struct
    {
        /**
         * [Bit 0] Set by HW when DCA is fuseenabled and no defeatures are set.
         */
        UINT64_t dca_active : 1;
#define IA32_DCA_0_CAP_DCA_ACTIVE_BIT                                0
#define IA32_DCA_0_CAP_DCA_ACTIVE_FLAG                               0x01
#define IA32_DCA_0_CAP_DCA_ACTIVE_MASK                               0x01
#define IA32_DCA_0_CAP_DCA_ACTIVE(_)                                 (((_) >> 0) & 0x01)

        /**
         * [Bits 2:1] TRANSACTION.
         */
        UINT64_t transaction : 2;
#define IA32_DCA_0_CAP_TRANSACTION_BIT                               1
#define IA32_DCA_0_CAP_TRANSACTION_FLAG                              0x06
#define IA32_DCA_0_CAP_TRANSACTION_MASK                              0x03
#define IA32_DCA_0_CAP_TRANSACTION(_)                                (((_) >> 1) & 0x03)

        /**
         * [Bits 6:3] DCA_TYPE.
         */
        UINT64_t dca_type : 4;
#define IA32_DCA_0_CAP_DCA_TYPE_BIT                                  3
#define IA32_DCA_0_CAP_DCA_TYPE_FLAG                                 0x78
#define IA32_DCA_0_CAP_DCA_TYPE_MASK                                 0x0F
#define IA32_DCA_0_CAP_DCA_TYPE(_)                                   (((_) >> 3) & 0x0F)

        /**
         * [Bits 10:7] DCA_QUEUE_SIZE.
         */
        UINT64_t dca_queue_size : 4;
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_BIT                            7
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_FLAG                           0x780
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_MASK                           0x0F
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE(_)                             (((_) >> 7) & 0x0F)
        UINT64_t reserved1 : 2;

        /**
         * [Bits 16:13] Writes will update the register but have no HW side-effect.
         */
        UINT64_t dca_delay : 4;
#define IA32_DCA_0_CAP_DCA_DELAY_BIT                                 13
#define IA32_DCA_0_CAP_DCA_DELAY_FLAG                                0x1E000
#define IA32_DCA_0_CAP_DCA_DELAY_MASK                                0x0F
#define IA32_DCA_0_CAP_DCA_DELAY(_)                                  (((_) >> 13) & 0x0F)
        UINT64_t reserved2 : 7;

        /**
         * [Bit 24] SW can request DCA block by setting this bit.
         */
        UINT64_t sw_block : 1;
#define IA32_DCA_0_CAP_SW_BLOCK_BIT                                  24
#define IA32_DCA_0_CAP_SW_BLOCK_FLAG                                 0x1000000
#define IA32_DCA_0_CAP_SW_BLOCK_MASK                                 0x01
#define IA32_DCA_0_CAP_SW_BLOCK(_)                                   (((_) >> 24) & 0x01)
        UINT64_t reserved3 : 1;

        /**
         * [Bit 26] Set when DCA is blocked by HW (e.g. CR0.CD = 1).
         */
        UINT64_t hw_block : 1;
#define IA32_DCA_0_CAP_HW_BLOCK_BIT                                  26
#define IA32_DCA_0_CAP_HW_BLOCK_FLAG                                 0x4000000
#define IA32_DCA_0_CAP_HW_BLOCK_MASK                                 0x01
#define IA32_DCA_0_CAP_HW_BLOCK(_)                                   (((_) >> 26) & 0x01)
        UINT64_t reserved4 : 37;
    };

    UINT64_t flags;
} ia32_dca_0_cap_register;

/**
 * @defgroup ia32_mtrr_physbase \
 *           IA32_MTRR_PHYSBASE(n)
 *
 * IA32_MTRR_PHYSBASE(0-9).
 *
 * @remarks If CPUID.01H: EDX.MTRR[12] = 1
 * @see Vol3A[11.11.2.3(Variable Range MTRRs)]
 * @{
 */
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Specifies the memory type for the range.
         */
        UINT64_t type : 8;
#define IA32_MTRR_PHYSBASE_TYPE_BIT                                  0
#define IA32_MTRR_PHYSBASE_TYPE_FLAG                                 0xFF
#define IA32_MTRR_PHYSBASE_TYPE_MASK                                 0xFF
#define IA32_MTRR_PHYSBASE_TYPE(_)                                   (((_) >> 0) & 0xFF)
        UINT64_t reserved1 : 4;

        /**
         * [Bits 47:12] Specifies the base address of the address range. This 24-bit value, in the case where MAXPHYADDR is 36
         * bits, is extended by 12 bits at the low end to form the base address (this automatically aligns the address on a 4-KByte
         * boundary).
         */
        UINT64_t page_frame_number : 36;
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_BIT                     12
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_FLAG                    0xFFFFFFFFF000
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_MASK                    0xFFFFFFFFF
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER(_)                      (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved2 : 16;
    };

    UINT64_t flags;
} ia32_mtrr_physbase_register;

#define IA32_MTRR_PHYSBASE0                                          0x00000200
#define IA32_MTRR_PHYSBASE1                                          0x00000202
#define IA32_MTRR_PHYSBASE2                                          0x00000204
#define IA32_MTRR_PHYSBASE3                                          0x00000206
#define IA32_MTRR_PHYSBASE4                                          0x00000208
#define IA32_MTRR_PHYSBASE5                                          0x0000020A
#define IA32_MTRR_PHYSBASE6                                          0x0000020C
#define IA32_MTRR_PHYSBASE7                                          0x0000020E
#define IA32_MTRR_PHYSBASE8                                          0x00000210
#define IA32_MTRR_PHYSBASE9                                          0x00000212
/**
 * @}
 */

 /**
  * @defgroup ia32_mtrr_physmask \
  *           IA32_MTRR_PHYSMASK(n)
  *
  * IA32_MTRR_PHYSMASK(0-9).
  *
  * @remarks If CPUID.01H: EDX.MTRR[12] = 1
  * @see Vol3A[11.11.2.3(Variable Range MTRRs)]
  * @{
  */
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Specifies the memory type for the range.
         */
        UINT64_t type : 8;
#define IA32_MTRR_PHYSMASK_TYPE_BIT                                  0
#define IA32_MTRR_PHYSMASK_TYPE_FLAG                                 0xFF
#define IA32_MTRR_PHYSMASK_TYPE_MASK                                 0xFF
#define IA32_MTRR_PHYSMASK_TYPE(_)                                   (((_) >> 0) & 0xFF)
        UINT64_t reserved1 : 3;

        /**
         * [Bit 11] Enables the register pair when set; disables register pair when clear.
         */
        UINT64_t valid : 1;
#define IA32_MTRR_PHYSMASK_VALID_BIT                                 11
#define IA32_MTRR_PHYSMASK_VALID_FLAG                                0x800
#define IA32_MTRR_PHYSMASK_VALID_MASK                                0x01
#define IA32_MTRR_PHYSMASK_VALID(_)                                  (((_) >> 11) & 0x01)

        /**
         * [Bits 47:12] Specifies a mask (24 bits if the maximum physical address size is 36 bits, 28 bits if the maximum physical
         * address size is 40 bits). The mask determines the range of the region being mapped, according to the following
         * relationships:
         * - Address_Within_Range AND PhysMask = PhysBase AND PhysMask
         * - This value is extended by 12 bits at the low end to form the mask value.
         * - The width of the PhysMask field depends on the maximum physical address size supported by the processor.
         * CPUID.80000008H reports the maximum physical address size supported by the processor. If CPUID.80000008H is not
         * available, software may assume that the processor supports a 36-bit physical address size.
         *
         * @see Vol3A[11.11.3(Example Base and Mask Calculations)]
         */
        UINT64_t page_frame_number : 36;
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_BIT                     12
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_FLAG                    0xFFFFFFFFF000
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_MASK                    0xFFFFFFFFF
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER(_)                      (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved2 : 16;
    };

    UINT64_t flags;
} ia32_mtrr_physmask_register;

#define IA32_MTRR_PHYSMASK0                                          0x00000201
#define IA32_MTRR_PHYSMASK1                                          0x00000203
#define IA32_MTRR_PHYSMASK2                                          0x00000205
#define IA32_MTRR_PHYSMASK3                                          0x00000207
#define IA32_MTRR_PHYSMASK4                                          0x00000209
#define IA32_MTRR_PHYSMASK5                                          0x0000020B
#define IA32_MTRR_PHYSMASK6                                          0x0000020D
#define IA32_MTRR_PHYSMASK7                                          0x0000020F
#define IA32_MTRR_PHYSMASK8                                          0x00000211
#define IA32_MTRR_PHYSMASK9                                          0x00000213
/**
 * @}
 */

 /**
  * @defgroup ia32_mtrr_fix \
  *           IA32_MTRR_FIX(x)
  *
  * IA32_MTRR_FIX(x).
  *
  * @remarks If CPUID.01H: EDX.MTRR[12] = 1
  * @see Vol3A[11.11.2.2(Fixed Range MTRRs)]
  * @{
  */
  /**
   * @defgroup ia32_mtrr_fix64k \
   *           IA32_MTRR_FIX64K(x)
   *
   * IA32_MTRR_FIX64K(x).
   * @{
   */
#define IA32_MTRR_FIX64K_BASE                                        0x00000000
#define IA32_MTRR_FIX64K_SIZE                                        0x00010000
#define IA32_MTRR_FIX64K_00000                                       0x00000250
   /**
    * @}
    */

    /**
     * @defgroup ia32_mtrr_fix16k \
     *           IA32_MTRR_FIX16K(x)
     *
     * IA32_MTRR_FIX16K(x).
     * @{
     */
#define IA32_MTRR_FIX16K_BASE                                        0x00080000
#define IA32_MTRR_FIX16K_SIZE                                        0x00004000
#define IA32_MTRR_FIX16K_80000                                       0x00000258
#define IA32_MTRR_FIX16K_A0000                                       0x00000259
     /**
      * @}
      */

      /**
       * @defgroup ia32_mtrr_fix4k \
       *           IA32_MTRR_FIX4K(x)
       *
       * IA32_MTRR_FIX4K(x).
       * @{
       */
#define IA32_MTRR_FIX4K_BASE                                         0x000C0000
#define IA32_MTRR_FIX4K_SIZE                                         0x00001000
#define IA32_MTRR_FIX4K_C0000                                        0x00000268
#define IA32_MTRR_FIX4K_C8000                                        0x00000269
#define IA32_MTRR_FIX4K_D0000                                        0x0000026A
#define IA32_MTRR_FIX4K_D8000                                        0x0000026B
#define IA32_MTRR_FIX4K_E0000                                        0x0000026C
#define IA32_MTRR_FIX4K_E8000                                        0x0000026D
#define IA32_MTRR_FIX4K_F0000                                        0x0000026E
#define IA32_MTRR_FIX4K_F8000                                        0x0000026F
       /**
        * @}
        */

        /**
         * Architecture defined number of fixed range MTRRs (1 for 64k, 2 for 16k, 8 for 4k).
         */
#define IA32_MTRR_FIX_COUNT                                          ((1 + 2 + 8) * 8)

         /**
          * Architecture defined number of variable range MTRRs.
          */
#define IA32_MTRR_VARIABLE_COUNT                                     0x000000FF

          /**
           * A size of array to store all possible MTRRs.
           */
#define IA32_MTRR_COUNT                                              (IA32_MTRR_FIX_COUNT + IA32_MTRR_VARIABLE_COUNT)
           /**
            * @}
            */


            /**
             * IA32_PAT.
             *
             * @remarks If CPUID.01H: EDX.MTRR[16] = 1
             */
#define IA32_PAT                                                     0x00000277
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] PA0.
         */
        UINT64_t pa0 : 3;
#define IA32_PAT_PA0_BIT                                             0
#define IA32_PAT_PA0_FLAG                                            0x07
#define IA32_PAT_PA0_MASK                                            0x07
#define IA32_PAT_PA0(_)                                              (((_) >> 0) & 0x07)
        UINT64_t reserved1 : 5;

        /**
         * [Bits 10:8] PA1.
         */
        UINT64_t pa1 : 3;
#define IA32_PAT_PA1_BIT                                             8
#define IA32_PAT_PA1_FLAG                                            0x700
#define IA32_PAT_PA1_MASK                                            0x07
#define IA32_PAT_PA1(_)                                              (((_) >> 8) & 0x07)
        UINT64_t reserved2 : 5;

        /**
         * [Bits 18:16] PA2.
         */
        UINT64_t pa2 : 3;
#define IA32_PAT_PA2_BIT                                             16
#define IA32_PAT_PA2_FLAG                                            0x70000
#define IA32_PAT_PA2_MASK                                            0x07
#define IA32_PAT_PA2(_)                                              (((_) >> 16) & 0x07)
        UINT64_t reserved3 : 5;

        /**
         * [Bits 26:24] PA3.
         */
        UINT64_t pa3 : 3;
#define IA32_PAT_PA3_BIT                                             24
#define IA32_PAT_PA3_FLAG                                            0x7000000
#define IA32_PAT_PA3_MASK                                            0x07
#define IA32_PAT_PA3(_)                                              (((_) >> 24) & 0x07)
        UINT64_t reserved4 : 5;

        /**
         * [Bits 34:32] PA4.
         */
        UINT64_t pa4 : 3;
#define IA32_PAT_PA4_BIT                                             32
#define IA32_PAT_PA4_FLAG                                            0x700000000
#define IA32_PAT_PA4_MASK                                            0x07
#define IA32_PAT_PA4(_)                                              (((_) >> 32) & 0x07)
        UINT64_t reserved5 : 5;

        /**
         * [Bits 42:40] PA5.
         */
        UINT64_t pa5 : 3;
#define IA32_PAT_PA5_BIT                                             40
#define IA32_PAT_PA5_FLAG                                            0x70000000000
#define IA32_PAT_PA5_MASK                                            0x07
#define IA32_PAT_PA5(_)                                              (((_) >> 40) & 0x07)
        UINT64_t reserved6 : 5;

        /**
         * [Bits 50:48] PA6.
         */
        UINT64_t pa6 : 3;
#define IA32_PAT_PA6_BIT                                             48
#define IA32_PAT_PA6_FLAG                                            0x7000000000000
#define IA32_PAT_PA6_MASK                                            0x07
#define IA32_PAT_PA6(_)                                              (((_) >> 48) & 0x07)
        UINT64_t reserved7 : 5;

        /**
         * [Bits 58:56] PA7.
         */
        UINT64_t pa7 : 3;
#define IA32_PAT_PA7_BIT                                             56
#define IA32_PAT_PA7_FLAG                                            0x700000000000000
#define IA32_PAT_PA7_MASK                                            0x07
#define IA32_PAT_PA7(_)                                              (((_) >> 56) & 0x07)
        UINT64_t reserved8 : 5;
    };

    UINT64_t flags;
} ia32_pat_register;

/**
 * @defgroup ia32_mc_ctl2 \
 *           IA32_MC(i)_CTL2
 *
 * MSR to enable/disable CMCI capability for bank n.
 *
 * @remarks If IA32_MCG_CAP[10] = 1 && IA32_MCG_CAP[7:0] > n
 * @see Vol3B[15.3.2.5(IA32_MCi_CTL2 MSRs)]
 * @{
 */
#define IA32_MC0_CTL2                                                0x00000280
#define IA32_MC1_CTL2                                                0x00000281
#define IA32_MC2_CTL2                                                0x00000282
#define IA32_MC3_CTL2                                                0x00000283
#define IA32_MC4_CTL2                                                0x00000284
#define IA32_MC5_CTL2                                                0x00000285
#define IA32_MC6_CTL2                                                0x00000286
#define IA32_MC7_CTL2                                                0x00000287
#define IA32_MC8_CTL2                                                0x00000288
#define IA32_MC9_CTL2                                                0x00000289
#define IA32_MC10_CTL2                                               0x0000028A
#define IA32_MC11_CTL2                                               0x0000028B
#define IA32_MC12_CTL2                                               0x0000028C
#define IA32_MC13_CTL2                                               0x0000028D
#define IA32_MC14_CTL2                                               0x0000028E
#define IA32_MC15_CTL2                                               0x0000028F
#define IA32_MC16_CTL2                                               0x00000290
#define IA32_MC17_CTL2                                               0x00000291
#define IA32_MC18_CTL2                                               0x00000292
#define IA32_MC19_CTL2                                               0x00000293
#define IA32_MC20_CTL2                                               0x00000294
#define IA32_MC21_CTL2                                               0x00000295
#define IA32_MC22_CTL2                                               0x00000296
#define IA32_MC23_CTL2                                               0x00000297
#define IA32_MC24_CTL2                                               0x00000298
#define IA32_MC25_CTL2                                               0x00000299
#define IA32_MC26_CTL2                                               0x0000029A
#define IA32_MC27_CTL2                                               0x0000029B
#define IA32_MC28_CTL2                                               0x0000029C
#define IA32_MC29_CTL2                                               0x0000029D
#define IA32_MC30_CTL2                                               0x0000029E
#define IA32_MC31_CTL2                                               0x0000029F
typedef union
{
    struct
    {
        /**
         * [Bits 14:0] Corrected error count threshold.
         */
        UINT64_t corrected_error_count_threshold : 15;
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_BIT             0
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_FLAG            0x7FFF
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_MASK            0x7FFF
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD(_)              (((_) >> 0) & 0x7FFF)
        UINT64_t reserved1 : 15;

        /**
         * [Bit 30] CMCI_EN.
         */
        UINT64_t cmci_en : 1;
#define IA32_MC_CTL2_CMCI_EN_BIT                                     30
#define IA32_MC_CTL2_CMCI_EN_FLAG                                    0x40000000
#define IA32_MC_CTL2_CMCI_EN_MASK                                    0x01
#define IA32_MC_CTL2_CMCI_EN(_)                                      (((_) >> 30) & 0x01)
        UINT64_t reserved2 : 33;
    };

    UINT64_t flags;
} ia32_mc_ctl2_register;

/**
 * @}
 */


 /**
  * IA32_MTRR_DEF_TYPE.
  *
  * @remarks If CPUID.01H: EDX.MTRR[12] = 1
  */
#define IA32_MTRR_DEF_TYPE                                           0x000002FF
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] Default Memory Type.
         */
        UINT64_t default_memory_type : 3;
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_BIT                   0
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_FLAG                  0x07
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_MASK                  0x07
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE(_)                    (((_) >> 0) & 0x07)
        UINT64_t reserved1 : 7;

        /**
         * [Bit 10] Fixed Range MTRR Enable.
         */
        UINT64_t fixed_range_mtrr_enable : 1;
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_BIT               10
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_FLAG              0x400
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_MASK              0x01
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE(_)                (((_) >> 10) & 0x01)

        /**
         * [Bit 11] MTRR Enable.
         */
        UINT64_t mtrr_enable : 1;
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_BIT                           11
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_FLAG                          0x800
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_MASK                          0x01
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE(_)                            (((_) >> 11) & 0x01)
        UINT64_t reserved2 : 52;
    };

    UINT64_t flags;
} ia32_mtrr_def_type_register;

/**
 * @defgroup ia32_fixed_ctr \
 *           IA32_FIXED_CTR(n)
 *
 * Fixed-Function Performance Counter n.
 *
 * @remarks If CPUID.0AH: EDX[4:0] > n
 * @{
 */
 /**
  * Counts Instr_Retired.Any.
  */
#define IA32_FIXED_CTR0                                              0x00000309

  /**
   * Counts CPU_CLK_Unhalted.Core
   */
#define IA32_FIXED_CTR1                                              0x0000030A

   /**
    * Counts CPU_CLK_Unhalted.Ref
    */
#define IA32_FIXED_CTR2                                              0x0000030B
    /**
     * @}
     */


     /**
      * Read Only MSR that enumerates the existence of performance monitoring features.
      *
      * @remarks If CPUID.01H: ECX[15] = 1
      */
#define IA32_PERF_CAPABILITIES                                       0x00000345
typedef union
{
    struct
    {
        /**
         * [Bits 5:0] LBR format.
         */
        UINT64_t lbr_format : 6;
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_BIT                        0
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_FLAG                       0x3F
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_MASK                       0x3F
#define IA32_PERF_CAPABILITIES_LBR_FORMAT(_)                         (((_) >> 0) & 0x3F)

        /**
         * [Bit 6] PEBS Trap.
         */
        UINT64_t pebs_trap : 1;
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_BIT                         6
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_FLAG                        0x40
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_MASK                        0x01
#define IA32_PERF_CAPABILITIES_PEBS_TRAP(_)                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] PEBSSaveArchRegs.
         */
        UINT64_t pebs_save_arch_regs : 1;
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_BIT               7
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_FLAG              0x80
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_MASK              0x01
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS(_)                (((_) >> 7) & 0x01)

        /**
         * [Bits 11:8] PEBS Record Format.
         */
        UINT64_t pebs_record_format : 4;
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_BIT                8
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_FLAG               0xF00
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_MASK               0x0F
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT(_)                 (((_) >> 8) & 0x0F)

        /**
         * [Bit 12] Freeze while SMM is supported.
         */
        UINT64_t freeze_while_smm_is_supported : 1;
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_BIT     12
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_FLAG    0x1000
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_MASK    0x01
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED(_)      (((_) >> 12) & 0x01)

        /**
         * [Bit 13] Full width of counter writable via IA32_A_PMCx.
         */
        UINT64_t full_width_counter_write : 1;
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_BIT          13
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_FLAG         0x2000
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_MASK         0x01
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE(_)           (((_) >> 13) & 0x01)
        UINT64_t reserved1 : 50;
    };

    UINT64_t flags;
} ia32_perf_capabilities_register;


/**
 * @brief Fixed-Function Performance Counter Control <b>(R/W)</b>
 *
 * Fixed-Function Performance Counter Control. Counter increments while the results of ANDing respective enable bit in
 * IA32_PERF_GLOBAL_CTRL with the corresponding OS or USR bits in this MSR is true.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 1
 */
#define IA32_FIXED_CTR_CTRL                                          0x0000038D
typedef union
{
    struct
    {
        /**
         * [Bit 0] EN0_OS: Enable Fixed Counter 0 to count while CPL = 0.
         */
        UINT64_t en0_os : 1;
#define IA32_FIXED_CTR_CTRL_EN0_OS_BIT                               0
#define IA32_FIXED_CTR_CTRL_EN0_OS_FLAG                              0x01
#define IA32_FIXED_CTR_CTRL_EN0_OS_MASK                              0x01
#define IA32_FIXED_CTR_CTRL_EN0_OS(_)                                (((_) >> 0) & 0x01)

        /**
         * [Bit 1] EN0_Usr: Enable Fixed Counter 0 to count while CPL > 0.
         */
        UINT64_t en0_usr : 1;
#define IA32_FIXED_CTR_CTRL_EN0_USR_BIT                              1
#define IA32_FIXED_CTR_CTRL_EN0_USR_FLAG                             0x02
#define IA32_FIXED_CTR_CTRL_EN0_USR_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN0_USR(_)                               (((_) >> 1) & 0x01)

        /**
         * [Bit 2] AnyThread: When set to 1, it enables counting the associated event conditions occurring across all logical
         * processors sharing a processor core. When set to 0, the counter only increments the associated event conditions
         * occurring in the logical processor which programmed the MSR.
         */
        UINT64_t any_thread0 : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_BIT                          2
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_FLAG                         0x04
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_MASK                         0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0(_)                           (((_) >> 2) & 0x01)

        /**
         * [Bit 3] EN0_PMI: Enable PMI when fixed counter 0 overflows.
         */
        UINT64_t en0_pmi : 1;
#define IA32_FIXED_CTR_CTRL_EN0_PMI_BIT                              3
#define IA32_FIXED_CTR_CTRL_EN0_PMI_FLAG                             0x08
#define IA32_FIXED_CTR_CTRL_EN0_PMI_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN0_PMI(_)                               (((_) >> 3) & 0x01)

        /**
         * [Bit 4] EN1_OS: Enable Fixed Counter 1 to count while CPL = 0.
         */
        UINT64_t en1_os : 1;
#define IA32_FIXED_CTR_CTRL_EN1_OS_BIT                               4
#define IA32_FIXED_CTR_CTRL_EN1_OS_FLAG                              0x10
#define IA32_FIXED_CTR_CTRL_EN1_OS_MASK                              0x01
#define IA32_FIXED_CTR_CTRL_EN1_OS(_)                                (((_) >> 4) & 0x01)

        /**
         * [Bit 5] EN1_Usr: Enable Fixed Counter 1 to count while CPL > 0.
         */
        UINT64_t en1_usr : 1;
#define IA32_FIXED_CTR_CTRL_EN1_USR_BIT                              5
#define IA32_FIXED_CTR_CTRL_EN1_USR_FLAG                             0x20
#define IA32_FIXED_CTR_CTRL_EN1_USR_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN1_USR(_)                               (((_) >> 5) & 0x01)

        /**
         * [Bit 6] AnyThread: When set to 1, it enables counting the associated event conditions occurring across all logical
         * processors sharing a processor core. When set to 0, the counter only increments the associated event conditions
         * occurring in the logical processor which programmed the MSR.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 2
         */
        UINT64_t any_thread1 : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_BIT                          6
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_FLAG                         0x40
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_MASK                         0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1(_)                           (((_) >> 6) & 0x01)

        /**
         * [Bit 7] EN1_PMI: Enable PMI when fixed counter 1 overflows.
         */
        UINT64_t en1_pmi : 1;
#define IA32_FIXED_CTR_CTRL_EN1_PMI_BIT                              7
#define IA32_FIXED_CTR_CTRL_EN1_PMI_FLAG                             0x80
#define IA32_FIXED_CTR_CTRL_EN1_PMI_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN1_PMI(_)                               (((_) >> 7) & 0x01)

        /**
         * [Bit 8] EN2_OS: Enable Fixed Counter 2 to count while CPL = 0.
         */
        UINT64_t en2_os : 1;
#define IA32_FIXED_CTR_CTRL_EN2_OS_BIT                               8
#define IA32_FIXED_CTR_CTRL_EN2_OS_FLAG                              0x100
#define IA32_FIXED_CTR_CTRL_EN2_OS_MASK                              0x01
#define IA32_FIXED_CTR_CTRL_EN2_OS(_)                                (((_) >> 8) & 0x01)

        /**
         * [Bit 9] EN2_Usr: Enable Fixed Counter 2 to count while CPL > 0.
         */
        UINT64_t en2_usr : 1;
#define IA32_FIXED_CTR_CTRL_EN2_USR_BIT                              9
#define IA32_FIXED_CTR_CTRL_EN2_USR_FLAG                             0x200
#define IA32_FIXED_CTR_CTRL_EN2_USR_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN2_USR(_)                               (((_) >> 9) & 0x01)

        /**
         * [Bit 10] AnyThread: When set to 1, it enables counting the associated event conditions occurring across all logical
         * processors sharing a processor core. When set to 0, the counter only increments the associated event conditions
         * occurring in the logical processor which programmed the MSR.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 2
         */
        UINT64_t any_thread2 : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_BIT                          10
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_FLAG                         0x400
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_MASK                         0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2(_)                           (((_) >> 10) & 0x01)

        /**
         * [Bit 11] EN2_PMI: Enable PMI when fixed counter 2 overflows.
         */
        UINT64_t en2_pmi : 1;
#define IA32_FIXED_CTR_CTRL_EN2_PMI_BIT                              11
#define IA32_FIXED_CTR_CTRL_EN2_PMI_FLAG                             0x800
#define IA32_FIXED_CTR_CTRL_EN2_PMI_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN2_PMI(_)                               (((_) >> 11) & 0x01)
        UINT64_t reserved1 : 52;
    };

    UINT64_t flags;
} ia32_fixed_ctr_ctrl_register;


/**
 * Global Performance Counter Status.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 0
 */
#define IA32_PERF_GLOBAL_STATUS                                      0x0000038E
typedef union
{
    struct
    {
        /**
         * [Bit 0] Ovf_PMC0: Overflow status of IA32_PMC0.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > 0
         */
        UINT64_t ovf_pmc0 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0_BIT                         0
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0_FLAG                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0(_)                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Ovf_PMC1: Overflow status of IA32_PMC1.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > 1
         */
        UINT64_t ovf_pmc1 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_BIT                         1
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_FLAG                        0x02
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1(_)                          (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Ovf_PMC2: Overflow status of IA32_PMC2.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > 2
         */
        UINT64_t ovf_pmc2 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_BIT                         2
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_FLAG                        0x04
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2(_)                          (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Ovf_PMC3: Overflow status of IA32_PMC3.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > 3
         */
        UINT64_t ovf_pmc3 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_BIT                         3
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_FLAG                        0x08
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3(_)                          (((_) >> 3) & 0x01)
        UINT64_t reserved1 : 28;

        /**
         * [Bit 32] Ovf_FixedCtr0: Overflow status of IA32_FIXED_CTR0.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 1
         */
        UINT64_t ovf_fixedctr0 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_BIT                    32
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_FLAG                   0x100000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_MASK                   0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0(_)                     (((_) >> 32) & 0x01)

        /**
         * [Bit 33] Ovf_FixedCtr1: Overflow status of IA32_FIXED_CTR1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 1
         */
        UINT64_t ovf_fixedctr1 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_BIT                    33
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_FLAG                   0x200000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_MASK                   0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1(_)                     (((_) >> 33) & 0x01)

        /**
         * [Bit 34] Ovf_FixedCtr2: Overflow status of IA32_FIXED_CTR2.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 1
         */
        UINT64_t ovf_fixedctr2 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_BIT                    34
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_FLAG                   0x400000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_MASK                   0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2(_)                     (((_) >> 34) & 0x01)
        UINT64_t reserved2 : 20;

        /**
         * [Bit 55] Trace_ToPA_PMI: A PMI occurred due to a ToPA entry memory buffer that was completely filled.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && IA32_RTIT_CTL.ToPA = 1
         */
        UINT64_t trace_topa_pmi : 1;
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_BIT                   55
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_FLAG                  0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_MASK                  0x01
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI(_)                    (((_) >> 55) & 0x01)
        UINT64_t reserved3 : 2;

        /**
         * [Bit 58] LBR_Frz. LBRs are frozen due to:
         * * IA32_DEBUGCTL.FREEZE_LBR_ON_PMI=1.
         * * The LBR stack overflowed.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t lbr_frz : 1;
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_BIT                          58
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_FLAG                         0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_MASK                         0x01
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ(_)                           (((_) >> 58) & 0x01)

        /**
         * [Bit 59] CTR_Frz. Performance counters in the core PMU are frozen due to:
         * * IA32_DEBUGCTL.FREEZE_PERFMON_ON_PMI=1.
         * * One or more core PMU counters overflowed.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t ctr_frz : 1;
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_BIT                          59
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_FLAG                         0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_MASK                         0x01
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ(_)                           (((_) >> 59) & 0x01)

        /**
         * [Bit 60] ASCI: Data in the performance counters in the core PMU may include contributions from the direct or indirect
         * operation Intel SGX to protect an enclave.
         *
         * @remarks If CPUID.(EAX=07H, ECX=0):EBX[2] = 1
         */
        UINT64_t asci : 1;
#define IA32_PERF_GLOBAL_STATUS_ASCI_BIT                             60
#define IA32_PERF_GLOBAL_STATUS_ASCI_FLAG                            0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_ASCI_MASK                            0x01
#define IA32_PERF_GLOBAL_STATUS_ASCI(_)                              (((_) >> 60) & 0x01)

        /**
         * [Bit 61] Uncore counter overflow status.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 2
         */
        UINT64_t ovf_uncore : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_BIT                       61
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_FLAG                      0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_MASK                      0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE(_)                        (((_) >> 61) & 0x01)

        /**
         * [Bit 62] OvfBuf: DS SAVE area Buffer overflow status.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 0
         */
        UINT64_t ovf_buf : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_BIT                          62
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_FLAG                         0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_MASK                         0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF(_)                           (((_) >> 62) & 0x01)

        /**
         * [Bit 63] CondChgd: Status bits of this register have changed.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 0
         */
        UINT64_t cond_chgd : 1;
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_BIT                        63
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_FLAG                       0x8000000000000000
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_MASK                       0x01
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD(_)                         (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} ia32_perf_global_status_register;


/**
 * @brief Global Performance Counter Control <b>(R/W)</b>
 *
 * Global Performance Counter Control. Counter increments while the result of ANDing the respective enable bit in this MSR
 * with the corresponding OS or USR bits in the general-purpose or fixed counter control MSR is true.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 0
 */
#define IA32_PERF_GLOBAL_CTRL                                        0x0000038F
typedef struct
{
    /**
     * EN_PMC(n). Enable bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
     *
     * @remarks If CPUID.0AH: EAX[15:8] > n
     */
    UINT32_t en_pmcn;

    /**
     * EN_FIXED_CTR(n). Enable bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
     *
     * @remarks If CPUID.0AH: EDX[4:0] > n
     */
    UINT32_t en_fixed_ctrn;
} ia32_perf_global_ctrl_register;


/**
 * Global Performance Counter Overflow Reset Control.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PERF_GLOBAL_STATUS_RESET                                0x00000390
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] Set 1 to clear Ovf_PMC(n) bit. Clear bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > n
         */
        UINT64_t clear_ovf_pmcn : 32;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_BIT             0
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_FLAG            0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_MASK            0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN(_)              (((_) >> 0) & 0xFFFFFFFF)

        /**
         * [Bits 34:32] Set 1 to clear Ovf_FIXED_CTR(n) bit. Clear bitmask. Only the first n-1 bits are valid. Bits 31:n are
         * reserved.
         *
         * @remarks If CPUID.0AH: EDX[4:0] > n
         */
        UINT64_t clear_ovf_fixed_ctrn : 3;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_BIT       32
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_FLAG      0x700000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_MASK      0x07
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN(_)        (((_) >> 32) & 0x07)
        UINT64_t reserved1 : 20;

        /**
         * [Bit 55] Set 1 to clear Trace_ToPA_PMI bit.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && IA32_RTIT_CTL.ToPA = 1
         */
        UINT64_t clear_trace_topa_pmi : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_BIT       55
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_FLAG      0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_MASK      0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI(_)        (((_) >> 55) & 0x01)
        UINT64_t reserved2 : 2;

        /**
         * [Bit 58] Set 1 to clear LBR_Frz bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t clear_lbr_frz : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_BIT              58
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_FLAG             0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_MASK             0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ(_)               (((_) >> 58) & 0x01)

        /**
         * [Bit 59] Set 1 to clear CTR_Frz bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t clear_ctr_frz : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_BIT              59
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_FLAG             0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_MASK             0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ(_)               (((_) >> 59) & 0x01)

        /**
         * [Bit 60] Set 1 to clear ASCI bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t clear_asci : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_BIT                 60
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_FLAG                0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_MASK                0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI(_)                  (((_) >> 60) & 0x01)

        /**
         * [Bit 61] Set 1 to clear Ovf_Uncore bit.
         *
         * @remarks 06_2EH
         */
        UINT64_t clear_ovf_uncore : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_BIT           61
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_FLAG          0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_MASK          0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE(_)            (((_) >> 61) & 0x01)

        /**
         * [Bit 62] Set 1 to clear OvfBuf bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 0
         */
        UINT64_t clear_ovf_buf : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_BIT              62
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_FLAG             0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_MASK             0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF(_)               (((_) >> 62) & 0x01)

        /**
         * [Bit 63] Set 1 to clear CondChgd bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 0
         */
        UINT64_t clear_cond_chgd : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_BIT            63
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_FLAG           0x8000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_MASK           0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD(_)             (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} ia32_perf_global_status_reset_register;


/**
 * Global Performance Counter Overflow Set Control.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PERF_GLOBAL_STATUS_SET                                  0x00000391
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] Set 1 to cause Ovf_PMC(n) = 1. Set bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > n
         */
        UINT64_t ovf_pmcn : 32;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_BIT                     0
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_FLAG                    0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_MASK                    0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN(_)                      (((_) >> 0) & 0xFFFFFFFF)

        /**
         * [Bits 34:32] Set 1 to cause Ovf_FIXED_CTR(n) = 1. Set bitmask. Only the first n-1 bits are valid. Bits 31:n are
         * reserved.
         *
         * @remarks If CPUID.0AH: EDX[4:0] > n
         */
        UINT64_t ovf_fixed_ctrn : 3;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_BIT               32
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_FLAG              0x700000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_MASK              0x07
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN(_)                (((_) >> 32) & 0x07)
        UINT64_t reserved1 : 20;

        /**
         * [Bit 55] Set 1 to cause Trace_ToPA_PMI = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t trace_topa_pmi : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_BIT               55
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_FLAG              0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_MASK              0x01
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI(_)                (((_) >> 55) & 0x01)
        UINT64_t reserved2 : 2;

        /**
         * [Bit 58] Set 1 to cause LBR_Frz = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t lbr_frz : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_BIT                      58
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_FLAG                     0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_MASK                     0x01
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ(_)                       (((_) >> 58) & 0x01)

        /**
         * [Bit 59] Set 1 to cause CTR_Frz = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t ctr_frz : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_BIT                      59
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_FLAG                     0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_MASK                     0x01
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ(_)                       (((_) >> 59) & 0x01)

        /**
         * [Bit 60] Set 1 to cause ASCI = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t asci : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_BIT                         60
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_FLAG                        0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI(_)                          (((_) >> 60) & 0x01)

        /**
         * [Bit 61] Set 1 to cause Ovf_Uncore = 1.
         *
         * @remarks 06_2EH
         */
        UINT64_t ovf_uncore : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_BIT                   61
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_FLAG                  0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_MASK                  0x01
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE(_)                    (((_) >> 61) & 0x01)

        /**
         * [Bit 62] Set 1 to cause OvfBuf = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t ovf_buf : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_BIT                      62
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_FLAG                     0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_MASK                     0x01
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF(_)                       (((_) >> 62) & 0x01)
        UINT64_t reserved3 : 1;
    };

    UINT64_t flags;
} ia32_perf_global_status_set_register;


/**
 * Indicator that core perfmon interface is in use.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PERF_GLOBAL_INUSE                                       0x00000392
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] IA32_PERFEVTSEL(n) in use. Status bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > n
         */
        UINT64_t ia32_perfevtseln_in_use : 32;
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_BIT           0
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_FLAG          0xFFFFFFFF
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_MASK          0xFFFFFFFF
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE(_)            (((_) >> 0) & 0xFFFFFFFF)

        /**
         * [Bits 34:32] IA32_FIXED_CTR(n) in use. Status bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
         */
        UINT64_t ia32_fixed_ctrn_in_use : 3;
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_BIT            32
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_FLAG           0x700000000
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_MASK           0x07
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE(_)             (((_) >> 32) & 0x07)
        UINT64_t reserved1 : 28;

        /**
         * [Bit 63] PMI in use.
         */
        UINT64_t pmi_in_use : 1;
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_BIT                        63
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_FLAG                       0x8000000000000000
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_MASK                       0x01
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE(_)                         (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} ia32_perf_global_inuse_register;


/**
 * PEBS Control.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PEBS_ENABLE                                             0x000003F1
typedef union
{
    struct
    {
        /**
         * [Bit 0] Enable PEBS on IA32_PMC0.
         *
         * @remarks 06_0FH
         */
        UINT64_t enable_pebs : 1;
#define IA32_PEBS_ENABLE_ENABLE_PEBS_BIT                             0
#define IA32_PEBS_ENABLE_ENABLE_PEBS_FLAG                            0x01
#define IA32_PEBS_ENABLE_ENABLE_PEBS_MASK                            0x01
#define IA32_PEBS_ENABLE_ENABLE_PEBS(_)                              (((_) >> 0) & 0x01)

        /**
         * [Bits 3:1] Reserved or model specific.
         */
        UINT64_t reservedormodelspecific1 : 3;
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_BIT                1
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_FLAG               0x0E
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_MASK               0x07
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1(_)                 (((_) >> 1) & 0x07)
        UINT64_t reserved1 : 28;

        /**
         * [Bits 35:32] Reserved or model specific.
         */
        UINT64_t reservedormodelspecific2 : 4;
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_BIT                32
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_FLAG               0xF00000000
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_MASK               0x0F
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2(_)                 (((_) >> 32) & 0x0F)
        UINT64_t reserved2 : 28;
    };

    UINT64_t flags;
} ia32_pebs_enable_register;

/**
 * @defgroup ia32_mc_ctl \
 *           IA32_MC(i)_CTL
 *
 * IA32_MC(0-28)_CTL.
 *
 * @remarks If IA32_MCG_CAP.CNT > n
 * @{
 */
#define IA32_MC0_CTL                                                 0x00000400
#define IA32_MC1_CTL                                                 0x00000404
#define IA32_MC2_CTL                                                 0x00000408
#define IA32_MC3_CTL                                                 0x0000040C
#define IA32_MC4_CTL                                                 0x00000410
#define IA32_MC5_CTL                                                 0x00000414
#define IA32_MC6_CTL                                                 0x00000418
#define IA32_MC7_CTL                                                 0x0000041C
#define IA32_MC8_CTL                                                 0x00000420
#define IA32_MC9_CTL                                                 0x00000424
#define IA32_MC10_CTL                                                0x00000428
#define IA32_MC11_CTL                                                0x0000042C
#define IA32_MC12_CTL                                                0x00000430
#define IA32_MC13_CTL                                                0x00000434
#define IA32_MC14_CTL                                                0x00000438
#define IA32_MC15_CTL                                                0x0000043C
#define IA32_MC16_CTL                                                0x00000440
#define IA32_MC17_CTL                                                0x00000444
#define IA32_MC18_CTL                                                0x00000448
#define IA32_MC19_CTL                                                0x0000044C
#define IA32_MC20_CTL                                                0x00000450
#define IA32_MC21_CTL                                                0x00000454
#define IA32_MC22_CTL                                                0x00000458
#define IA32_MC23_CTL                                                0x0000045C
#define IA32_MC24_CTL                                                0x00000460
#define IA32_MC25_CTL                                                0x00000464
#define IA32_MC26_CTL                                                0x00000468
#define IA32_MC27_CTL                                                0x0000046C
#define IA32_MC28_CTL                                                0x00000470
 /**
  * @}
  */

  /**
   * @defgroup ia32_mc_status \
   *           IA32_MC(i)_STATUS
   *
   * IA32_MC(0-28)_STATUS.
   *
   * @remarks If IA32_MCG_CAP.CNT > n
   * @{
   */
#define IA32_MC0_STATUS                                              0x00000401
#define IA32_MC1_STATUS                                              0x00000405
#define IA32_MC2_STATUS                                              0x00000409
#define IA32_MC3_STATUS                                              0x0000040D
#define IA32_MC4_STATUS                                              0x00000411
#define IA32_MC5_STATUS                                              0x00000415
#define IA32_MC6_STATUS                                              0x00000419
#define IA32_MC7_STATUS                                              0x0000041D
#define IA32_MC8_STATUS                                              0x00000421
#define IA32_MC9_STATUS                                              0x00000425
#define IA32_MC10_STATUS                                             0x00000429
#define IA32_MC11_STATUS                                             0x0000042D
#define IA32_MC12_STATUS                                             0x00000431
#define IA32_MC13_STATUS                                             0x00000435
#define IA32_MC14_STATUS                                             0x00000439
#define IA32_MC15_STATUS                                             0x0000043D
#define IA32_MC16_STATUS                                             0x00000441
#define IA32_MC17_STATUS                                             0x00000445
#define IA32_MC18_STATUS                                             0x00000449
#define IA32_MC19_STATUS                                             0x0000044D
#define IA32_MC20_STATUS                                             0x00000451
#define IA32_MC21_STATUS                                             0x00000455
#define IA32_MC22_STATUS                                             0x00000459
#define IA32_MC23_STATUS                                             0x0000045D
#define IA32_MC24_STATUS                                             0x00000461
#define IA32_MC25_STATUS                                             0x00000465
#define IA32_MC26_STATUS                                             0x00000469
#define IA32_MC27_STATUS                                             0x0000046D
#define IA32_MC28_STATUS                                             0x00000471
   /**
    * @}
    */

    /**
     * @defgroup ia32_mc_addr \
     *           IA32_MC(i)_ADDR
     *
     * IA32_MC(0-28)_ADDR.
     *
     * @remarks If IA32_MCG_CAP.CNT > n
     * @{
     */
#define IA32_MC0_ADDR                                                0x00000402
#define IA32_MC1_ADDR                                                0x00000406
#define IA32_MC2_ADDR                                                0x0000040A
#define IA32_MC3_ADDR                                                0x0000040E
#define IA32_MC4_ADDR                                                0x00000412
#define IA32_MC5_ADDR                                                0x00000416
#define IA32_MC6_ADDR                                                0x0000041A
#define IA32_MC7_ADDR                                                0x0000041E
#define IA32_MC8_ADDR                                                0x00000422
#define IA32_MC9_ADDR                                                0x00000426
#define IA32_MC10_ADDR                                               0x0000042A
#define IA32_MC11_ADDR                                               0x0000042E
#define IA32_MC12_ADDR                                               0x00000432
#define IA32_MC13_ADDR                                               0x00000436
#define IA32_MC14_ADDR                                               0x0000043A
#define IA32_MC15_ADDR                                               0x0000043E
#define IA32_MC16_ADDR                                               0x00000442
#define IA32_MC17_ADDR                                               0x00000446
#define IA32_MC18_ADDR                                               0x0000044A
#define IA32_MC19_ADDR                                               0x0000044E
#define IA32_MC20_ADDR                                               0x00000452
#define IA32_MC21_ADDR                                               0x00000456
#define IA32_MC22_ADDR                                               0x0000045A
#define IA32_MC23_ADDR                                               0x0000045E
#define IA32_MC24_ADDR                                               0x00000462
#define IA32_MC25_ADDR                                               0x00000466
#define IA32_MC26_ADDR                                               0x0000046A
#define IA32_MC27_ADDR                                               0x0000046E
#define IA32_MC28_ADDR                                               0x00000472
     /**
      * @}
      */

      /**
       * @defgroup ia32_mc_misc \
       *           IA32_MC(i)_MISC
       *
       * IA32_MC(0-28)_MISC.
       *
       * @remarks If IA32_MCG_CAP.CNT > n
       * @{
       */
#define IA32_MC0_MISC                                                0x00000403
#define IA32_MC1_MISC                                                0x00000407
#define IA32_MC2_MISC                                                0x0000040B
#define IA32_MC3_MISC                                                0x0000040F
#define IA32_MC4_MISC                                                0x00000413
#define IA32_MC5_MISC                                                0x00000417
#define IA32_MC6_MISC                                                0x0000041B
#define IA32_MC7_MISC                                                0x0000041F
#define IA32_MC8_MISC                                                0x00000423
#define IA32_MC9_MISC                                                0x00000427
#define IA32_MC10_MISC                                               0x0000042B
#define IA32_MC11_MISC                                               0x0000042F
#define IA32_MC12_MISC                                               0x00000433
#define IA32_MC13_MISC                                               0x00000437
#define IA32_MC14_MISC                                               0x0000043B
#define IA32_MC15_MISC                                               0x0000043F
#define IA32_MC16_MISC                                               0x00000443
#define IA32_MC17_MISC                                               0x00000447
#define IA32_MC18_MISC                                               0x0000044B
#define IA32_MC19_MISC                                               0x0000044F
#define IA32_MC20_MISC                                               0x00000453
#define IA32_MC21_MISC                                               0x00000457
#define IA32_MC22_MISC                                               0x0000045B
#define IA32_MC23_MISC                                               0x0000045F
#define IA32_MC24_MISC                                               0x00000463
#define IA32_MC25_MISC                                               0x00000467
#define IA32_MC26_MISC                                               0x0000046B
#define IA32_MC27_MISC                                               0x0000046F
#define IA32_MC28_MISC                                               0x00000473
       /**
        * @}
        */


        /**
         * Reporting Register of Basic VMX Capabilities.
         *
         * @remarks If CPUID.01H:ECX.[5] = 1
         * @see Vol3D[A.1(BASIC VMX INFORMATION)]
         * @see Vol3D[A.1(Basic VMX Information)] (reference)
         */
#define IA32_VMX_BASIC                                               0x00000480
typedef union
{
    struct
    {
        /**
         * @brief VMCS revision identifier used by the processor
         *
         * [Bits 30:0] 31-bit VMCS revision identifier used by the processor. Processors that use the same VMCS revision identifier
         * use the same size for VMCS regions.
         */
        UINT64_t vmcs_revision_id : 31;
#define IA32_VMX_BASIC_VMCS_REVISION_ID_BIT                          0
#define IA32_VMX_BASIC_VMCS_REVISION_ID_FLAG                         0x7FFFFFFF
#define IA32_VMX_BASIC_VMCS_REVISION_ID_MASK                         0x7FFFFFFF
#define IA32_VMX_BASIC_VMCS_REVISION_ID(_)                           (((_) >> 0) & 0x7FFFFFFF)

        /**
         * [Bit 31] Bit 31 is always 0.
         */
        UINT64_t must_be_zero : 1;
#define IA32_VMX_BASIC_MUST_BE_ZERO_BIT                              31
#define IA32_VMX_BASIC_MUST_BE_ZERO_FLAG                             0x80000000
#define IA32_VMX_BASIC_MUST_BE_ZERO_MASK                             0x01
#define IA32_VMX_BASIC_MUST_BE_ZERO(_)                               (((_) >> 31) & 0x01)

        /**
         * @brief Size of the VMCS
         *
         * [Bits 44:32] Report the number of bytes that software should allocate for the VMXON region and any VMCS region. It is a
         * value greater than 0 and at most 4096 (bit 44 is set if and only if bits 43:32 are clear).
         */
        UINT64_t vmcs_size_inUINT8s : 13;
#define IA32_VMX_BASIC_VMCS_SIZE_INUINT8S_BIT                        32
#define IA32_VMX_BASIC_VMCS_SIZE_INUINT8S_FLAG                       0x1FFF00000000
#define IA32_VMX_BASIC_VMCS_SIZE_INUINT8S_MASK                       0x1FFF
#define IA32_VMX_BASIC_VMCS_SIZE_INUINT8S(_)                         (((_) >> 32) & 0x1FFF)
        UINT64_t reserved1 : 3;

        /**
         * @brief Width of physical address used for the VMCS
         *        - 0 -> limited to the available amount of physical RAM
         *        - 1 -> within the first 4 GB
         *
         * [Bit 48] Indicates the width of the physical addresses that may be used for the VMXON region, each VMCS, and data
         * structures referenced by pointers in a VMCS (I/O bitmaps, virtual-APIC page, MSR areas for VMX transitions). If the bit
         * is 0, these addresses are limited to the processor's physical-address width.2 If the bit is 1, these addresses are
         * limited to 32 bits. This bit is always 0 for processors that support Intel 64 architecture.
         */
        UINT64_t vmcs_physical_address_width : 1;
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_BIT               48
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_FLAG              0x1000000000000
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_MASK              0x01
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH(_)                (((_) >> 48) & 0x01)

        /**
         * @brief Whether the processor supports the dual-monitor treatment of system-management interrupts and system-management
         *        code (always 1)
         *
         * [Bit 49] Read as 1, the logical processor supports the dual-monitor treatment of system-management interrupts and
         * system-management mode.
         *
         * @see Vol3C[34.15(DUAL-MONITOR TREATMENT OF SMIs AND SMM)]
         */
        UINT64_t dual_monitor_support : 1;
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_BIT                      49
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_FLAG                     0x2000000000000
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_MASK                     0x01
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT(_)                       (((_) >> 49) & 0x01)

        /**
         * @brief Memory type that must be used for the VMCS
         *
         * [Bits 53:50] Report the memory type that should be used for the VMCS, for data structures referenced by pointers in the
         * VMCS (I/O bitmaps, virtual-APIC page, MSR areas for VMX transitions), and for the MSEG header. If software needs to
         * access these data structures (e.g., to modify the contents of the MSR bitmaps), it can configure the paging structures
         * to map them into the linear-address space. If it does so, it should establish mappings that use the memory type reported
         * bits 53:50 in this MSR.
         * As of this writing, all processors that support VMX operation indicate the write-back type.
         */
        UINT64_t memory_type : 4;
#define IA32_VMX_BASIC_MEMORY_TYPE_BIT                               50
#define IA32_VMX_BASIC_MEMORY_TYPE_FLAG                              0x3C000000000000
#define IA32_VMX_BASIC_MEMORY_TYPE_MASK                              0x0F
#define IA32_VMX_BASIC_MEMORY_TYPE(_)                                (((_) >> 50) & 0x0F)

        /**
         * @brief Whether the processor provides additional information for exits due to INS/OUTS
         *
         * [Bit 54] When set to 1, the processor reports information in the VM-exit instruction-information field on VM exits due
         * to execution of the INS and OUTS instructions. This reporting is done only if this bit is read as 1.
         *
         * @see Vol3C[27.2.4(Information for VM Exits Due to Instruction Execution)]
         */
        UINT64_t ins_outs_reporting : 1;
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_BIT                        54
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_FLAG                       0x40000000000000
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_MASK                       0x01
#define IA32_VMX_BASIC_INS_OUTS_REPORTING(_)                         (((_) >> 54) & 0x01)

        /**
         * @brief Whether default 1 bits in control MSRs (pin/proc/exit/entry) may be cleared to 0 and that 'true' control MSRs are
         *        supported
         *
         * [Bit 55] Is read as 1 if any VMX controls that default to 1 may be cleared to 0. It also reports support for the VMX
         * capability MSRs IA32_VMX_TRUE_PINBASED_CTLS, IA32_VMX_TRUE_PROCBASED_CTLS, IA32_VMX_TRUE_EXIT_CTLS, and
         * IA32_VMX_TRUE_ENTRY_CTLS.
         *
         * @see Vol3D[A.2(RESERVED CONTROLS AND DEFAULT SETTINGS)]
         * @see Vol3D[A.3.1(Pin-Based VM-Execution Controls)]
         * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)]
         * @see Vol3D[A.4(VM-EXIT CONTROLS)]
         * @see Vol3D[A.5(VM-ENTRY CONTROLS)]
         */
        UINT64_t vmx_controls : 1;
#define IA32_VMX_BASIC_VMX_CONTROLS_BIT                              55
#define IA32_VMX_BASIC_VMX_CONTROLS_FLAG                             0x80000000000000
#define IA32_VMX_BASIC_VMX_CONTROLS_MASK                             0x01
#define IA32_VMX_BASIC_VMX_CONTROLS(_)                               (((_) >> 55) & 0x01)
        UINT64_t reserved2 : 8;
    };

    UINT64_t flags;
} ia32_vmx_basic_register;


/**
 * Capability Reporting Register of Pin-Based VM-Execution Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.3.1(Pin-Based VM-Execution Controls)]
 * @see Vol3C[24.6.1(Pin-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PINBASED_CTLS                                       0x00000481
typedef union
{
    struct
    {
        /**
         * @brief External interrupts cause VM-exits if set; otherwise dispatched through the guest's IDT
         *
         * [Bit 0] If this control is 1, external interrupts cause VM exits. Otherwise, they are delivered normally through the
         * guest interrupt-descriptor table (IDT). If this control is 1, the value of RFLAGS.IF does not affect interrupt blocking.
         */
        UINT64_t external_interrupt_exiting : 1;
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_BIT        0
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_FLAG       0x01
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_MASK       0x01
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING(_)         (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 2;

        /**
         * @brief Non-maskable interrupts cause VM-exits if set; otherwise dispatched through the guest's IDT
         *
         * [Bit 3] If this control is 1, non-maskable interrupts (NMIs) cause VM exits. Otherwise, they are delivered normally
         * using descriptor 2 of the IDT. This control also determines interactions between IRET and blocking by NMI.
         *
         * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
         */
        UINT64_t nmi_exiting : 1;
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_BIT                       3
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_FLAG                      0x08
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_MASK                      0x01
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING(_)                        (((_) >> 3) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * @brief Virtual NMIs
         *
         * [Bit 5] If this control is 1, NMIs are never blocked and the "blocking by NMI" bit (bit 3) in the interruptibility-state
         * field indicates "virtual-NMI blocking". This control also interacts with the "NMI-window exiting" VM-execution control.
         *
         * @see Vol3C[24.6.2(Processor-Based VM-Execution Controls)]
         */
        UINT64_t virtual_nmi : 1;
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_BIT                       5
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_FLAG                      0x20
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_MASK                      0x01
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI(_)                        (((_) >> 5) & 0x01)

        /**
         * @brief Activate VMX preemption timer
         *
         * [Bit 6] If this control is 1, the VMX-preemption timer counts down in VMX non-root operation. A VM exit occurs when the
         * timer counts down to zero.
         *
         * @see Vol3C[25.5.1(VMX-Preemption Timer)]
         * @see Vol3C[25.2(OTHER CAUSES OF VM EXITS)]
         */
        UINT64_t activate_vmx_preemption_timer : 1;
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_BIT     6
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_FLAG    0x40
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_MASK    0x01
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER(_)      (((_) >> 6) & 0x01)

        /**
         * @brief Process interrupts with the posted-interrupt notification vector
         *
         * [Bit 7] If this control is 1, the processor treats interrupts with the posted-interrupt notification vector specially,
         * updating the virtual-APIC page with posted-interrupt requests.
         *
         * @see Vol3C[24.6.8(Controls for APIC Virtualization)]
         * @see Vol3C[29.6(POSTED-INTERRUPT PROCESSING)]
         */
        UINT64_t process_posted_interrupts : 1;
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_BIT         7
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_FLAG        0x80
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_MASK        0x01
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS(_)          (((_) >> 7) & 0x01)
        UINT64_t reserved3 : 56;
    };

    UINT64_t flags;
} ia32_vmx_pinbased_ctls_register;


/**
 * Capability Reporting Register of Primary Processor-Based VM-Execution Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)]
 * @see Vol3C[24.6.2(Processor-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PROCBASED_CTLS                                      0x00000482
typedef union
{
    struct
    {
        UINT64_t reserved1 : 2;

        /**
         * @brief VM-exit as soon as RFLAGS.IF=1 and no blocking is active
         *
         * [Bit 2] If this control is 1, a VM exit occurs at the beginning of any instruction if RFLAGS.IF = 1 and there are no
         * other blocking of interrupts.
         *
         * @see Vol3C[24.4.2(Guest Non-Register State)]
         */
        UINT64_t interrupt_window_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_BIT         2
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_FLAG        0x04
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_MASK        0x01
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING(_)          (((_) >> 2) & 0x01)

        /**
         * @brief Use timestamp counter offset
         *
         * [Bit 3] This control determines whether executions of RDTSC, executions of RDTSCP, and executions of RDMSR that read
         * from the IA32_TIME_STAMP_COUNTER MSR return a value modified by the TSC offset field.
         *
         * @see Vol3C[24.6.5(Time-Stamp Counter Offset and Multiplier)]
         * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
         */
        UINT64_t use_tsc_offsetting : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_BIT               3
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_FLAG              0x08
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_MASK              0x01
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING(_)                (((_) >> 3) & 0x01)
        UINT64_t reserved2 : 3;

        /**
         * @brief VM-exit when executing the HLT instruction
         *
         * [Bit 7] This control determines whether executions of HLT cause VM exits.
         */
        UINT64_t hlt_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_BIT                      7
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_FLAG                     0x80
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_MASK                     0x01
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING(_)                       (((_) >> 7) & 0x01)
        UINT64_t reserved3 : 1;

        /**
         * @brief VM-exit when executing the INVLPG instruction
         *
         * [Bit 9] This control determines whether executions of INVLPG cause VM exits.
         */
        UINT64_t invlpg_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_BIT                   9
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_FLAG                  0x200
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING(_)                    (((_) >> 9) & 0x01)

        /**
         * @brief VM-exit when executing the MWAIT instruction
         *
         * [Bit 10] This control determines whether executions of MWAIT cause VM exits.
         */
        UINT64_t mwait_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_BIT                    10
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_FLAG                   0x400
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING(_)                     (((_) >> 10) & 0x01)

        /**
         * @brief VM-exit when executing the RDPMC instruction
         *
         * [Bit 11] This control determines whether executions of RDPMC cause VM exits.
         */
        UINT64_t rdpmc_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_BIT                    11
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_FLAG                   0x800
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING(_)                     (((_) >> 11) & 0x01)

        /**
         * @brief VM-exit when executing the RDTSC/RDTSCP instruction
         *
         * [Bit 12] This control determines whether executions of RDTSC and RDTSCP cause VM exits.
         */
        UINT64_t rdtsc_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_BIT                    12
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_FLAG                   0x1000
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING(_)                     (((_) >> 12) & 0x01)
        UINT64_t reserved4 : 2;

        /**
         * @brief VM-exit when executing the MOV to CR3 instruction (forced to 1 on the 'first' VT-x capable CPUs; this actually
         *        includes the newest Nehalem CPUs)
         *
         * [Bit 15] In conjunction with the CR3-target controls, this control determines whether executions of MOV to CR3 cause VM
         * exits. The first processors to support the virtual-machine extensions supported only the 1-setting of this control.
         *
         * @see Vol3C[24.6.7(CR3-Target Controls)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        UINT64_t cr3_load_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_BIT                 15
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_FLAG                0x8000
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_MASK                0x01
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING(_)                  (((_) >> 15) & 0x01)

        /**
         * @brief VM-exit when executing the MOV from CR3 instruction (forced to 1 on the 'first' VT-x capable CPUs; this actually
         *        includes the newest Nehalem CPUs)
         *
         * [Bit 16] This control determines whether executions of MOV from CR3 cause VM exits. The first processors to support the
         * virtual-machine extensions supported only the 1-setting of this control.
         */
        UINT64_t cr3_store_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_BIT                16
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_FLAG               0x10000
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_MASK               0x01
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING(_)                 (((_) >> 16) & 0x01)
        UINT64_t reserved5 : 2;

        /**
         * @brief VM-exit on CR8 loads
         *
         * [Bit 19] This control determines whether executions of MOV to CR8 cause VM exits.
         */
        UINT64_t cr8_load_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_BIT                 19
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_FLAG                0x80000
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_MASK                0x01
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING(_)                  (((_) >> 19) & 0x01)

        /**
         * @brief VM-exit on CR8 stores
         *
         * [Bit 20] This control determines whether executions of MOV from CR8 cause VM exits.
         */
        UINT64_t cr8_store_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_BIT                20
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_FLAG               0x100000
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_MASK               0x01
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING(_)                 (((_) >> 20) & 0x01)

        /**
         * @brief Use TPR shadow
         *
         * [Bit 21] Setting this control to 1 enables TPR virtualization and other APIC-virtualization features.
         *
         * @see Vol3C[29(APIC VIRTUALIZATION AND VIRTUAL INTERRUPTS)]
         */
        UINT64_t use_tpr_shadow : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_BIT                   21
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_FLAG                  0x200000
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW(_)                    (((_) >> 21) & 0x01)

        /**
         * @brief VM-exit when virtual NMI blocking is disabled
         *
         * [Bit 22] If this control is 1, a VM exit occurs at the beginning of any instruction if there is no virtual-NMI blocking.
         *
         * @see Vol3C[24.4.2(Guest Non-Register State)]
         */
        UINT64_t nmi_window_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_BIT               22
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_FLAG              0x400000
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_MASK              0x01
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING(_)                (((_) >> 22) & 0x01)

        /**
         * @brief VM-exit when executing a MOV DRx instruction
         *
         * [Bit 23] This control determines whether executions of MOV DR cause VM exits.
         */
        UINT64_t mov_dr_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_BIT                   23
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_FLAG                  0x800000
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING(_)                    (((_) >> 23) & 0x01)

        /**
         * @brief VM-exit when executing IO instructions
         *
         * [Bit 24] This control determines whether executions of I/O instructions (IN, INS/INSB/INSW/INSD, OUT, and
         * OUTS/OUTSB/OUTSW/OUTSD) cause VM exits.
         */
        UINT64_t unconditional_io_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_BIT         24
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_FLAG        0x1000000
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_MASK        0x01
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING(_)          (((_) >> 24) & 0x01)

        /**
         * @brief Use IO bitmaps
         *
         * [Bit 25] This control determines whether I/O bitmaps are used to restrict executions of I/O instructions For this
         * control, "0" means "do not use I/O bitmaps" and "1" means "use I/O bitmaps." If the I/O bitmaps are used, the setting of
         * the "unconditional I/O exiting" control is ignored.
         *
         * @see Vol3C[24.6.4(I/O-Bitmap Addresses)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        UINT64_t use_io_bitmaps : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_BIT                   25
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_FLAG                  0x2000000
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS(_)                    (((_) >> 25) & 0x01)
        UINT64_t reserved6 : 1;

        /**
         * @brief Monitor trap flag
         *
         * [Bit 27] If this control is 1, the monitor trap flag debugging feature is enabled.
         *
         * @see Vol3C[25.5.2(Monitor Trap Flag)]
         */
        UINT64_t monitor_trap_flag : 1;
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_BIT                27
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_FLAG               0x8000000
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_MASK               0x01
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG(_)                 (((_) >> 27) & 0x01)

        /**
         * @brief Use MSR bitmaps
         *
         * [Bit 28] This control determines whether MSR bitmaps are used to control execution of the RDMSR and WRMSR instructions.
         * For this control, "0" means "do not use MSR bitmaps" and "1" means "use MSR bitmaps." If the MSR bitmaps are not used,
         * all executions of the RDMSR and WRMSR instructions cause VM exits.
         *
         * @see Vol3C[24.6.9(MSR-Bitmap Address)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        UINT64_t use_msr_bitmaps : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_BIT                  28
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_FLAG                 0x10000000
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS(_)                   (((_) >> 28) & 0x01)

        /**
         * @brief VM-exit when executing the MONITOR instruction
         *
         * [Bit 29] This control determines whether executions of MONITOR cause VM exits.
         */
        UINT64_t monitor_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_BIT                  29
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_FLAG                 0x20000000
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING(_)                   (((_) >> 29) & 0x01)

        /**
         * @brief VM-exit when executing the PAUSE instruction
         *
         * [Bit 30] This control determines whether executions of PAUSE cause VM exits.
         */
        UINT64_t pause_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_BIT                    30
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_FLAG                   0x40000000
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING(_)                     (((_) >> 30) & 0x01)

        /**
         * @brief Determines whether the secondary processor based VM-execution controls are used
         *
         * [Bit 31] This control determines whether the secondary processor-based VM-execution controls are used. If this control
         * is 0, the logical processor operates as if all the secondary processor-based VM-execution controls were also 0.
         */
        UINT64_t activate_secondary_controls : 1;
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_BIT      31
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_FLAG     0x80000000
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_MASK     0x01
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS(_)       (((_) >> 31) & 0x01)
        UINT64_t reserved7 : 32;
    };

    UINT64_t flags;
} ia32_vmx_procbased_ctls_register;


/**
 * Capability Reporting Register of VM-Exit Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.4(VM-EXIT CONTROLS)]
 * @see Vol3C[24.7.1(VM-Exit Controls)] (reference)
 */
#define IA32_VMX_EXIT_CTLS                                           0x00000483
typedef union
{
    struct
    {
        UINT64_t reserved1 : 2;

        /**
         * @brief Save guest debug controls (dr7 & IA32_DEBUGCTL_MSR) (forced to 1 on the 'first' VT-x capable CPUs; this actually
         *        includes the newest Nehalem CPUs)
         *
         * [Bit 2] This control determines whether DR7 and the IA32_DEBUGCTL MSR are saved on VM exit. The first processors to
         * support the virtual-machine extensions supported only the 1-setting of this control.
         */
        UINT64_t save_debug_controls : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_BIT                   2
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_FLAG                  0x04
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_MASK                  0x01
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS(_)                    (((_) >> 2) & 0x01)
        UINT64_t reserved2 : 6;

        /**
         * @brief Return to long mode after a VM-exit
         *
         * [Bit 9] On processors that support Intel 64 architecture, this control determines whether a logical processor is in
         * 64-bit mode after the next VM exit. Its value is loaded into CS.L, IA32_EFER.LME, and IA32_EFER.LMA on every VM exit.1
         * This control must be 0 on processors that do not support Intel 64 architecture.
         */
        UINT64_t host_address_space_size : 1;
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_BIT               9
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_FLAG              0x200
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_MASK              0x01
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE(_)                (((_) >> 9) & 0x01)
        UINT64_t reserved3 : 2;

        /**
         * @brief Whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM-exit
         *
         * [Bit 12] This control determines whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM exit.
         */
        UINT64_t load_ia32_perf_global_ctrl : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_BIT            12
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_FLAG           0x1000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_MASK           0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL(_)             (((_) >> 12) & 0x01)
        UINT64_t reserved4 : 2;

        /**
         * @brief Acknowledge external interrupts with the irq controller if one caused a VM-exit
         *
         * [Bit 15] This control affects VM exits due to external interrupts:
         * - If such a VM exit occurs and this control is 1, the logical processor acknowledges the interrupt controller, acquiring
         * the interrupt's vector. The vector is stored in the VM-exit interruption-information field, which is marked valid.
         * - If such a VM exit occurs and this control is 0, the interrupt is not acknowledged and the VM-exit
         * interruption-information field is marked invalid.
         */
        UINT64_t acknowledge_interrupt_on_exit : 1;
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_BIT         15
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_FLAG        0x8000
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_MASK        0x01
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT(_)          (((_) >> 15) & 0x01)
        UINT64_t reserved5 : 2;

        /**
         * @brief Whether the guest IA32_PAT MSR is saved on VM-exit
         *
         * [Bit 18] This control determines whether the IA32_PAT MSR is saved on VM exit.
         */
        UINT64_t save_ia32_pat : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_BIT                         18
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_FLAG                        0x40000
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_MASK                        0x01
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT(_)                          (((_) >> 18) & 0x01)

        /**
         * @brief Whether the host IA32_PAT MSR is loaded on VM-exit
         *
         * [Bit 19] This control determines whether the IA32_PAT MSR is loaded on VM exit.
         */
        UINT64_t load_ia32_pat : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_BIT                         19
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_FLAG                        0x80000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_MASK                        0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT(_)                          (((_) >> 19) & 0x01)

        /**
         * @brief Whether the guest IA32_EFER MSR is saved on VM-exit
         *
         * [Bit 20] This control determines whether the IA32_EFER MSR is saved on VM exit.
         */
        UINT64_t save_ia32_efer : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_BIT                        20
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_FLAG                       0x100000
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_MASK                       0x01
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER(_)                         (((_) >> 20) & 0x01)

        /**
         * @brief Whether the host IA32_EFER MSR is loaded on VM-exit
         *
         * [Bit 21] This control determines whether the IA32_EFER MSR is loaded on VM exit.
         */
        UINT64_t load_ia32_efer : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_BIT                        21
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_FLAG                       0x200000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_MASK                       0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER(_)                         (((_) >> 21) & 0x01)

        /**
         * @brief Whether the value of the VMX preemption timer is saved on every VM-exit
         *
         * [Bit 22] This control determines whether the value of the VMX-preemption timer is saved on VM exit.
         */
        UINT64_t save_vmx_preemption_timer_value : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_BIT       22
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_FLAG      0x400000
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_MASK      0x01
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE(_)        (((_) >> 22) & 0x01)

        /**
         * [Bit 23] This control determines whether the IA32_BNDCFGS MSR is cleared on VM exit.
         */
        UINT64_t clear_ia32_bndcfgs : 1;
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_BIT                    23
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_FLAG                   0x800000
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_MASK                   0x01
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS(_)                     (((_) >> 23) & 0x01)

        /**
         * [Bit 24] If this control is 1, Intel Processor Trace does not produce a paging information packet (PIP) on a VM exit or
         * a VMCS packet on an SMM VM exit.
         *
         * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
         */
        UINT64_t conceal_vmx_from_pt : 1;
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_BIT                   24
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_FLAG                  0x1000000
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_MASK                  0x01
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT(_)                    (((_) >> 24) & 0x01)
        UINT64_t reserved6 : 39;
    };

    UINT64_t flags;
} ia32_vmx_exit_ctls_register;


/**
 * Capability Reporting Register of VM-Entry Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.5(VM-ENTRY CONTROLS)]
 * @see Vol3D[24.8.1(VM-Entry Controls)] (reference)
 */
#define IA32_VMX_ENTRY_CTLS                                          0x00000484
typedef union
{
    struct
    {
        UINT64_t reserved1 : 2;

        /**
         * @brief Load guest debug controls (dr7 & IA32_DEBUGCTL_MSR) (forced to 1 on the 'first' VT-x capable CPUs; this actually
         *        includes the newest Nehalem CPUs)
         *
         * [Bit 2] This control determines whether DR7 and the IA32_DEBUGCTL MSR are loaded on VM entry. The first processors to
         * support the virtual-machine extensions supported only the 1-setting of this control.
         */
        UINT64_t load_debug_controls : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_BIT                  2
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_FLAG                 0x04
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_MASK                 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS(_)                   (((_) >> 2) & 0x01)
        UINT64_t reserved2 : 6;

        /**
         * @brief 64 bits guest mode. Must be 0 for CPUs that don't support AMD64
         *
         * [Bit 9] On processors that support Intel 64 architecture, this control determines whether the logical processor is in
         * IA-32e mode after VM entry. Its value is loaded into IA32_EFER.LMA as part of VM entry. This control must be 0 on
         * processors that do not support Intel 64 architecture.
         */
        UINT64_t ia32e_mode_guest : 1;
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_BIT                     9
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_FLAG                    0x200
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_MASK                    0x01
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST(_)                      (((_) >> 9) & 0x01)

        /**
         * @brief In SMM mode after VM-entry
         *
         * [Bit 10] This control determines whether the logical processor is in system-management mode (SMM) after VM entry. This
         * control must be 0 for any VM entry from outside SMM.
         */
        UINT64_t entry_to_smm : 1;
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_BIT                         10
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_FLAG                        0x400
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_MASK                        0x01
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM(_)                          (((_) >> 10) & 0x01)

        /**
         * @brief Disable dual treatment of SMI and SMM; must be zero for VM-entry outside of SMM
         *
         * [Bit 11] If set to 1, the default treatment of SMIs and SMM is in effect after the VM entry. This control must be 0 for
         * any VM entry from outside SMM
         *
         * @see Vol3C[34.15.7(Deactivating the Dual-Monitor Treatment)]
         */
        UINT64_t deactivate_dual_monitor_treatment : 1;
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_BIT    11
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_FLAG   0x800
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_MASK   0x01
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT(_)     (((_) >> 11) & 0x01)
        UINT64_t reserved3 : 1;

        /**
         * @brief Whether the guest IA32_PERF_GLOBAL_CTRL MSR is loaded on VM-entry
         *
         * [Bit 13] This control determines whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM entry.
         */
        UINT64_t load_ia32_perf_global_ctrl : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_BIT           13
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_FLAG          0x2000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_MASK          0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL(_)            (((_) >> 13) & 0x01)

        /**
         * @brief Whether the guest IA32_PAT MSR is loaded on VM-entry
         *
         * [Bit 14] This control determines whether the IA32_PAT MSR is loaded on VM entry.
         */
        UINT64_t load_ia32_pat : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_BIT                        14
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_FLAG                       0x4000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_MASK                       0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT(_)                         (((_) >> 14) & 0x01)

        /**
         * @brief Whether the guest IA32_EFER MSR is loaded on VM-entry
         *
         * [Bit 15] This control determines whether the IA32_EFER MSR is loaded on VM entry.
         */
        UINT64_t load_ia32_efer : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_BIT                       15
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_FLAG                      0x8000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_MASK                      0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER(_)                        (((_) >> 15) & 0x01)

        /**
         * [Bit 16] This control determines whether the IA32_BNDCFGS MSR is loaded on VM entry.
         */
        UINT64_t load_ia32_bndcfgs : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_BIT                    16
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_FLAG                   0x10000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_MASK                   0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS(_)                     (((_) >> 16) & 0x01)

        /**
         * [Bit 17] If this control is 1, Intel Processor Trace does not produce a paging information packet (PIP) on a VM entry or
         * a VMCS packet on a VM entry that returns from SMM.
         *
         * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
         */
        UINT64_t conceal_vmx_from_pt : 1;
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_BIT                  17
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_FLAG                 0x20000
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_MASK                 0x01
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT(_)                   (((_) >> 17) & 0x01)

        /**
         * [Bit 18] This control determines whether the IA32_RTIT_CTL MSR is loaded on VM entry.
         */
        UINT64_t load_ia32_rtit_ctl : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_BIT                   18
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_FLAG                  0x40000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_MASK                  0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL(_)                    (((_) >> 18) & 0x01)
        UINT64_t reserved4 : 1;

        /**
         * [Bit 20] This control determines whether CET-related MSRs and SPP are loaded on VM entry.
         */
        UINT64_t load_cet_state : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_BIT                       20
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_FLAG                      0x100000
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_MASK                      0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE(_)                        (((_) >> 20) & 0x01)
        UINT64_t reserved5 : 43;
    };

    UINT64_t flags;
} ia32_vmx_entry_ctls_register;


/**
 * Reporting Register of Miscellaneous VMX Capabilities.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.6(MISCELLANEOUS DATA)]
 * @see Vol3D[A.6(Miscellaneous Data)] (reference)
 */
#define IA32_VMX_MISC                                                0x00000485
typedef union
{
    struct
    {
        /**
         * @brief Relationship between the preemption timer and tsc; count down every time bit x of the tsc changes
         *
         * [Bits 4:0] Report a value X that specifies the relationship between the rate of the VMX-preemption timer and that of the
         * timestamp counter (TSC). Specifically, the VMX-preemption timer (if it is active) counts down by 1 every time bit X in
         * the TSC changes due to a TSC increment.
         */
        UINT64_t preemption_timer_tsc_relationship : 5;
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_BIT          0
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_FLAG         0x1F
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_MASK         0x1F
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP(_)           (((_) >> 0) & 0x1F)

        /**
         * @brief Whether VM-exit stores EFER.LMA into the "IA32e mode guest" field
         *
         * [Bit 5] When set to 1, VM exits store the value of IA32_EFER.LMA into the "IA-32e mode guest" VM-entry control. This bit
         * is read as 1 on any logical processor that supports the 1-setting of the "unrestricted guest" VM-execution control.
         *
         * @see Vol3C[27.2(RECORDING VM-EXIT INFORMATION AND UPDATING VM-ENTRY CONTROL FIELDS)]
         */
        UINT64_t store_efer_lma_on_vmexit : 1;
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_BIT                   5
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_FLAG                  0x20
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_MASK                  0x01
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT(_)                    (((_) >> 5) & 0x01)

        /**
         * @brief Activity states supported by the implementation
         *
         * [Bits 8:6] Report, as a bitmap, the activity states supported by the implementation:
         * - Bit 6 reports (if set) the support for activity state 1 (HLT).
         * - Bit 7 reports (if set) the support for activity state 2 (shutdown).
         * - Bit 8 reports (if set) the support for activity state 3 (wait-for-SIPI).
         * If an activity state is not supported, the implementation causes a VM entry to fail if it attempts to establish that
         * activity state. All implementations support VM entry to activity state 0 (active).
         */
        UINT64_t activity_states : 3;
#define IA32_VMX_MISC_ACTIVITY_STATES_BIT                            6
#define IA32_VMX_MISC_ACTIVITY_STATES_FLAG                           0x1C0
#define IA32_VMX_MISC_ACTIVITY_STATES_MASK                           0x07
#define IA32_VMX_MISC_ACTIVITY_STATES(_)                             (((_) >> 6) & 0x07)
        UINT64_t reserved1 : 5;

        /**
         * @brief Intel Processor Trace (Intel PT) can be used in VMX operation
         *
         * [Bit 14] When set to 1, Intel(R) Processor Trace (Intel PT) can be used in VMX operation. If the processor supports Intel
         * PT but does not allow it to be used in VMX operation, execution of VMXON clears IA32_RTIT_CTL.TraceEn; any attempt to
         * write IA32_RTIT_CTL while in VMX operation (including VMX root operation) causes a general-protection exception.
         *
         * @see Vol3C[30.3(VMX INSTRUCTIONS | VMXON-Enter VMX Operation)]
         */
        UINT64_t intel_pt_available_in_vmx : 1;
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_BIT                  14
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_FLAG                 0x4000
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_MASK                 0x01
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX(_)                   (((_) >> 14) & 0x01)

        /**
         * @brief Whether RDMSR can be used to read IA32_SMBASE_MSR in SMM
         *
         * [Bit 15] When set to 1, the RDMSR instruction can be used in system-management mode (SMM) to read the IA32_SMBASE MSR
         * (MSR address 9EH).
         *
         * @see Vol3C[34.15.6.3(Saving Guest State)]
         */
        UINT64_t rdmsr_can_read_ia32_smbase_msr_in_smm : 1;
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_BIT      15
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_FLAG     0x8000
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_MASK     0x01
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM(_)       (((_) >> 15) & 0x01)

        /**
         * @brief Number of CR3 target values supported by the processor (0-256)
         *
         * [Bits 24:16] Indicate the number of CR3-target values supported by the processor. This number is a value between 0 and
         * 256, inclusive (bit 24 is set if and only if bits 23:16 are clear).
         */
        UINT64_t cr3_target_count : 9;
#define IA32_VMX_MISC_CR3_TARGET_COUNT_BIT                           16
#define IA32_VMX_MISC_CR3_TARGET_COUNT_FLAG                          0x1FF0000
#define IA32_VMX_MISC_CR3_TARGET_COUNT_MASK                          0x1FF
#define IA32_VMX_MISC_CR3_TARGET_COUNT(_)                            (((_) >> 16) & 0x1FF)

        /**
         * @brief Maximum number of MSRs in the VMCS. (N+1)*512
         *
         * [Bits 27:25] Used to compute the recommended maximum number of MSRs that should appear in the VM-exit MSR-store list,
         * the VM-exit MSR-load list, or the VM-entry MSR-load list. Specifically, if the value bits 27:25 of IA32_VMX_MISC is N,
         * then 512 * (N + 1) is the recommended maximum number of MSRs to be included in each list. If the limit is exceeded,
         * undefined processor behavior may result (including a machine check during the VMX transition).
         */
        UINT64_t max_number_of_msr : 3;
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_BIT                          25
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_FLAG                         0xE000000
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_MASK                         0x07
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR(_)                           (((_) >> 25) & 0x07)

        /**
         * @brief Whether bit 2 of IA32_SMM_MONITOR_CTL can be set to 1
         *
         * [Bit 28] When set to 1, bit 2 of the IA32_SMM_MONITOR_CTL can be set to 1. VMXOFF unblocks SMIs unless
         * IA32_SMM_MONITOR_CTL[bit 2] is 1.
         *
         * @see Vol3C[34.14.4(VMXOFF and SMI Unblocking)]
         */
        UINT64_t smm_monitor_ctl_b2 : 1;
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_BIT                         28
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_FLAG                        0x10000000
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_MASK                        0x01
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2(_)                          (((_) >> 28) & 0x01)

        /**
         * @brief Whether VMWRITE can be used to write VM-exit information fields
         *
         * [Bit 29] When set to 1, software can use VMWRITE to write to any supported field in the VMCS; otherwise, VMWRITE cannot
         * be used to modify VM-exit information fields.
         */
        UINT64_t vmwrite_vmexit_info : 1;
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_BIT                        29
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_FLAG                       0x20000000
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_MASK                       0x01
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO(_)                         (((_) >> 29) & 0x01)

        /**
         * [Bit 30] When set to 1, VM entry allows injection of a software interrupt, software exception, or privileged software
         * exception with an instruction length of 0.
         */
        UINT64_t zero_length_instruction_vmentry_injection : 1;
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_BIT  30
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_FLAG 0x40000000
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_MASK 0x01
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION(_)   (((_) >> 30) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * @brief MSEG revision identifier used by the processor
         *
         * [Bits 63:32] Report the 32-bit MSEG revision identifier used by the processor.
         */
        UINT64_t mseg_id : 32;
#define IA32_VMX_MISC_MSEG_ID_BIT                                    32
#define IA32_VMX_MISC_MSEG_ID_FLAG                                   0xFFFFFFFF00000000
#define IA32_VMX_MISC_MSEG_ID_MASK                                   0xFFFFFFFF
#define IA32_VMX_MISC_MSEG_ID(_)                                     (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64_t flags;
} ia32_vmx_misc_register;


/**
 * Capability Reporting Register of CR0 Bits Fixed to 0.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.7(VMX-FIXED BITS IN CR0)]
 * @see Vol3D[A.7(VMX-Fixed Bits in CR0)] (reference)
 */
#define IA32_VMX_CR0_FIXED0                                          0x00000486

 /**
  * Capability Reporting Register of CR0 Bits Fixed to 1.
  *
  * @remarks If CPUID.01H:ECX.[5] = 1
  * @see Vol3D[A.7(VMX-FIXED BITS IN CR0)]
  * @see Vol3D[A.7(VMX-Fixed Bits in CR0)] (reference)
  */
#define IA32_VMX_CR0_FIXED1                                          0x00000487

  /**
   * Capability Reporting Register of CR4 Bits Fixed to 0.
   *
   * @remarks If CPUID.01H:ECX.[5] = 1
   * @see Vol3D[A.8(VMX-FIXED BITS IN CR4)]
   * @see Vol3D[A.8(VMX-Fixed Bits in CR4)] (reference)
   */
#define IA32_VMX_CR4_FIXED0                                          0x00000488

   /**
    * Capability Reporting Register of CR4 Bits Fixed to 1.
    *
    * @remarks If CPUID.01H:ECX.[5] = 1
    * @see Vol3D[A.8(VMX-FIXED BITS IN CR4)]
    * @see Vol3D[A.8(VMX-Fixed Bits in CR4)] (reference)
    */
#define IA32_VMX_CR4_FIXED1                                          0x00000489

    /**
     * Capability Reporting Register of VMCS Field Enumeration.
     *
     * @remarks If CPUID.01H:ECX.[5] = 1
     * @see Vol3D[A.9(VMCS ENUMERATION)]
     * @see Vol3D[A.9(VMCS Enumeration)] (reference)
     */
#define IA32_VMX_VMCS_ENUM                                           0x0000048A
typedef union
{
    struct
    {
        /**
         * [Bit 0] Indicates access type.
         */
        UINT64_t access_type : 1;
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE_BIT                           0
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE_FLAG                          0x01
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE_MASK                          0x01
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE(_)                            (((_) >> 0) & 0x01)

        /**
         * [Bits 9:1] Highest index value used for any VMCS encoding.
         */
        UINT64_t highest_index_value : 9;
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_BIT                   1
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_FLAG                  0x3FE
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_MASK                  0x1FF
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE(_)                    (((_) >> 1) & 0x1FF)

        /**
         * [Bits 11:10] Indicate the field's type.
         */
        UINT64_t field_type : 2;
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_BIT                            10
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_FLAG                           0xC00
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_MASK                           0x03
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE(_)                             (((_) >> 10) & 0x03)
        UINT64_t reserved1 : 1;

        /**
         * [Bits 14:13] Indicate the field's width.
         */
        UINT64_t field_width : 2;
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_BIT                           13
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_FLAG                          0x6000
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_MASK                          0x03
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH(_)                            (((_) >> 13) & 0x03)
        UINT64_t reserved2 : 49;
    };

    UINT64_t flags;
} ia32_vmx_vmcs_enum_register;


/**
 * Capability Reporting Register of Secondary Processor-Based VM-Execution Controls.
 *
 * @remarks If ( CPUID.01H:ECX.[5] && IA32_VMX_PROCBASED_CTLS[63] )
 * @see Vol3D[A.3.3(Secondary Processor-Based VM-Execution Controls)]
 * @see Vol3D[24.6.2(Processor-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PROCBASED_CTLS2                                     0x0000048B
typedef union
{
    struct
    {
        /**
         * @brief Virtualize APIC access
         *
         * [Bit 0] If this control is 1, the logical processor treats specially accesses to the page with the APICaccess address.
         *
         * @see Vol3C[29.4(VIRTUALIZING MEMORY-MAPPED APIC ACCESSES)]
         */
        UINT64_t virtualize_apic_accesses : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_BIT        0
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_FLAG       0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_MASK       0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES(_)         (((_) >> 0) & 0x01)

        /**
         * @brief EPT supported/enabled
         *
         * [Bit 1] If this control is 1, extended page tables (EPT) are enabled.
         *
         * @see Vol3C[28.2(THE EXTENDED PAGE TABLE MECHANISM (EPT))]
         */
        UINT64_t enable_ept : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_BIT                      1
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_FLAG                     0x02
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_MASK                     0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT(_)                       (((_) >> 1) & 0x01)

        /**
         * @brief Descriptor table instructions cause VM-exits
         *
         * [Bit 2] This control determines whether executions of LGDT, LIDT, LLDT, LTR, SGDT, SIDT, SLDT, and STR cause VM exits.
         */
        UINT64_t descriptor_table_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_BIT        2
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_FLAG       0x04
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_MASK       0x01
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING(_)         (((_) >> 2) & 0x01)

        /**
         * @brief RDTSCP supported/enabled
         *
         * [Bit 3] If this control is 0, any execution of RDTSCP causes an invalid-opcode exception (\#UD).
         */
        UINT64_t enable_rdtscp : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_BIT                   3
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_FLAG                  0x08
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP(_)                    (((_) >> 3) & 0x01)

        /**
         * @brief Virtualize x2APIC mode
         *
         * [Bit 4] If this control is 1, the logical processor treats specially RDMSR and WRMSR to APIC MSRs (in the range
         * 800H-8FFH).
         *
         * @see Vol3C[29.5(VIRTUALIZING MSR-BASED APIC ACCESSES)]
         */
        UINT64_t virtualize_x2apic_mode : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_BIT          4
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_FLAG         0x10
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_MASK         0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE(_)           (((_) >> 4) & 0x01)

        /**
         * @brief VPID supported/enabled
         *
         * [Bit 5] If this control is 1, cached translations of linear addresses are associated with a virtualprocessor identifier
         * (VPID).
         *
         * @see Vol3C[28.1(VIRTUAL PROCESSOR IDENTIFIERS (VPIDS))]
         */
        UINT64_t enable_vpid : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_BIT                     5
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_FLAG                    0x20
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_MASK                    0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID(_)                      (((_) >> 5) & 0x01)

        /**
         * @brief VM-exit when executing the WBINVD instruction
         *
         * [Bit 6] This control determines whether executions of WBINVD cause VM exits.
         */
        UINT64_t wbinvd_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_BIT                  6
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_FLAG                 0x40
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING(_)                   (((_) >> 6) & 0x01)

        /**
         * @brief Unrestricted guest execution
         *
         * [Bit 7] This control determines whether guest software may run in unpaged protected mode or in realaddress mode.
         */
        UINT64_t unrestricted_guest : 1;
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_BIT              7
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_FLAG             0x80
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_MASK             0x01
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST(_)               (((_) >> 7) & 0x01)

        /**
         * @brief APIC register virtualization
         *
         * [Bit 8] If this control is 1, the logical processor virtualizes certain APIC accesses.
         *
         * @see Vol3C[29.4(VIRTUALIZING MEMORY-MAPPED APIC ACCESSES)]
         * @see Vol3C[29.5(VIRTUALIZING MSR-BASED APIC ACCESSES)]
         */
        UINT64_t apic_register_virtualization : 1;
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_BIT    8
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_FLAG   0x100
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_MASK   0x01
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION(_)     (((_) >> 8) & 0x01)

        /**
         * @brief Virtual-interrupt delivery
         *
         * [Bit 9] This controls enables the evaluation and delivery of pending virtual interrupts as well as the emulation of
         * writes to the APIC registers that control interrupt prioritization.
         */
        UINT64_t virtual_interrupt_delivery : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_BIT      9
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_FLAG     0x200
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_MASK     0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY(_)       (((_) >> 9) & 0x01)

        /**
         * @brief A specified number of pause loops cause a VM-exit
         *
         * [Bit 10] This control determines whether a series of executions of PAUSE can cause a VM exit.
         *
         * @see Vol3C[24.6.13(Controls for PAUSE-Loop Exiting)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        UINT64_t pause_loop_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_BIT              10
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_FLAG             0x400
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_MASK             0x01
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING(_)               (((_) >> 10) & 0x01)

        /**
         * @brief VM-exit when executing RDRAND instructions
         *
         * [Bit 11] This control determines whether executions of RDRAND cause VM exits.
         */
        UINT64_t rdrand_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_BIT                  11
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_FLAG                 0x800
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING(_)                   (((_) >> 11) & 0x01)

        /**
         * @brief Enables INVPCID instructions
         *
         * [Bit 12] If this control is 0, any execution of INVPCID causes a \#UD.
         */
        UINT64_t enable_invpcid : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_BIT                  12
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_FLAG                 0x1000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID(_)                   (((_) >> 12) & 0x01)

        /**
         * @brief Enables VMFUNC instructions
         *
         * [Bit 13] Setting this control to 1 enables use of the VMFUNC instruction in VMX non-root operation.
         *
         * @see Vol3C[25.5.5(VM Functions)]
         */
        UINT64_t enable_vm_functions : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_BIT             13
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_FLAG            0x2000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_MASK            0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS(_)              (((_) >> 13) & 0x01)

        /**
         * @brief Enables VMCS shadowing
         *
         * [Bit 14] If this control is 1, executions of VMREAD and VMWRITE in VMX non-root operation may access a shadow VMCS
         * (instead of causing VM exits).
         *
         * @see {'Vol3C[24.10(VMCS TYPES': 'ORDINARY AND SHADOW)]'}
         * @see Vol3C[30.3(VMX INSTRUCTIONS)]
         */
        UINT64_t vmcs_shadowing : 1;
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_BIT                  14
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_FLAG                 0x4000
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING(_)                   (((_) >> 14) & 0x01)

        /**
         * @brief Enables ENCLS VM-exits
         *
         * [Bit 15] If this control is 1, executions of ENCLS consult the ENCLS-exiting bitmap to determine whether the instruction
         * causes a VM exit.
         *
         * @see Vol3C[24.6.16(ENCLS-Exiting Bitmap)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        UINT64_t enable_encls_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_BIT            15
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_FLAG           0x8000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_MASK           0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING(_)             (((_) >> 15) & 0x01)

        /**
         * @brief VM-exit when executing RDSEED
         *
         * [Bit 16] This control determines whether executions of RDSEED cause VM exits.
         */
        UINT64_t rdseed_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_BIT                  16
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_FLAG                 0x10000
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING(_)                   (((_) >> 16) & 0x01)

        /**
         * @brief Enables page-modification logging
         *
         * [Bit 17] If this control is 1, an access to a guest-physical address that sets an EPT dirty bit first adds an entry to
         * the page-modification log.
         *
         * @see Vol3C[28.2.5(Page-Modification Logging)]
         */
        UINT64_t enable_pml : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_BIT                      17
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_FLAG                     0x20000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_MASK                     0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML(_)                       (((_) >> 17) & 0x01)

        /**
         * @brief Controls whether EPT-violations may cause
         *
         * [Bit 18] If this control is 1, EPT violations may cause virtualization exceptions (\#VE) instead of VM exits.
         *
         * @see Vol3C[25.5.6(Virtualization Exceptions)]
         */
        UINT64_t ept_violation : 1;
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_BIT                   18
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_FLAG                  0x40000
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION(_)                    (((_) >> 18) & 0x01)

        /**
         * @brief Conceal VMX non-root operation from Intel processor trace (PT)
         *
         * [Bit 19] If this control is 1, Intel Processor Trace suppresses from PIPs an indication that the processor was in VMX
         * non-root operation and omits a VMCS packet from any PSB+ produced in VMX nonroot operation.
         *
         * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
         */
        UINT64_t conceal_vmx_from_pt : 1;
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_BIT             19
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_FLAG            0x80000
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_MASK            0x01
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT(_)              (((_) >> 19) & 0x01)

        /**
         * @brief Enables XSAVES/XRSTORS instructions
         *
         * [Bit 20] If this control is 0, any execution of XSAVES or XRSTORS causes a \#UD.
         */
        UINT64_t enable_xsaves : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_BIT                   20
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_FLAG                  0x100000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES(_)                    (((_) >> 20) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * [Bit 22] If this control is 1, EPT execute permissions are based on whether the linear address being accessed is
         * supervisor mode or user mode.
         *
         * @see Vol3C[28(VMX SUPPORT FOR ADDRESS TRANSLATION)]
         */
        UINT64_t mode_based_execute_control_for_ept : 1;
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_BIT 22
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_FLAG 0x400000
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT(_) (((_) >> 22) & 0x01)
        UINT64_t reserved2 : 2;

        /**
         * @brief Use TSC scaling
         *
         * [Bit 25] This control determines whether executions of RDTSC, executions of RDTSCP, and executions of RDMSR that read
         * from the IA32_TIME_STAMP_COUNTER MSR return a value modified by the TSC multiplier field.
         *
         * @see Vol3C[24.6.5(Time-Stamp Counter Offset and Multiplier)]
         * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
         */
        UINT64_t use_tsc_scaling : 1;
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_BIT                 25
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_FLAG                0x2000000
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_MASK                0x01
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING(_)                  (((_) >> 25) & 0x01)
        UINT64_t reserved3 : 38;
    };

    UINT64_t flags;
} ia32_vmx_procbased_ctls2_register;


/**
 * Capability Reporting Register of EPT and VPID.
 *
 * @remarks If ( CPUID.01H:ECX.[5] && IA32_VMX_PROCBASED_CTLS[63] && (IA32_VMX_PROCBASED_CTLS2[33] ||
 *          IA32_VMX_PROCBASED_CTLS2[37]) )
 * @see Vol3D[A.10(VPID AND EPT CAPABILITIES)]
 * @see Vol3D[A.10(VPID and EPT Capabilities)] (reference)
 */
#define IA32_VMX_EPT_VPID_CAP                                        0x0000048C
typedef union
{
    struct
    {
        /**
         * [Bit 0] When set to 1, the processor supports execute-only translations by EPT. This support allows software to
         * configure EPT paging-structure entries in which bits 1:0 are clear (indicating that data accesses are not allowed) and
         * bit 2 is set (indicating that instruction fetches are allowed).
         */
        UINT64_t execute_only_pages : 1;
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_BIT                 0
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_FLAG                0x01
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_MASK                0x01
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES(_)                  (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 5;

        /**
         * [Bit 6] Indicates support for a page-walk length of 4.
         */
        UINT64_t page_walk_length_4 : 1;
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_BIT                 6
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_FLAG                0x40
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_MASK                0x01
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4(_)                  (((_) >> 6) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * [Bit 8] When set to 1, the logical processor allows software to configure the EPT paging-structure memory type to be
         * uncacheable (UC).
         *
         * @see Vol3C[24.6.11(Extended-Page-Table Pointer (EPTP))]
         */
        UINT64_t memory_type_uncacheable : 1;
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_BIT            8
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_FLAG           0x100
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_MASK           0x01
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE(_)             (((_) >> 8) & 0x01)
        UINT64_t reserved3 : 5;

        /**
         * [Bit 14] When set to 1, the logical processor allows software to configure the EPT paging-structure memory type to be
         * write-back (WB).
         */
        UINT64_t memory_type_write_back : 1;
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_BIT             14
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_FLAG            0x4000
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_MASK            0x01
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK(_)              (((_) >> 14) & 0x01)
        UINT64_t reserved4 : 1;

        /**
         * [Bit 16] When set to 1, the logical processor allows software to configure a EPT PDE to map a 2-Mbyte page (by setting
         * bit 7 in the EPT PDE).
         */
        UINT64_t pde_2mb_pages : 1;
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_BIT                      16
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_FLAG                     0x10000
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_MASK                     0x01
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES(_)                       (((_) >> 16) & 0x01)

        /**
         * [Bit 17] When set to 1, the logical processor allows software to configure a EPT PDPTE to map a 1-Gbyte page (by setting
         * bit 7 in the EPT PDPTE).
         */
        UINT64_t pdpte_1gb_pages : 1;
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_BIT                    17
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_FLAG                   0x20000
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_MASK                   0x01
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES(_)                     (((_) >> 17) & 0x01)
        UINT64_t reserved5 : 2;

        /**
         * [Bit 20] If bit 20 is read as 1, the INVEPT instruction is supported.
         *
         * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
         * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
         */
        UINT64_t invept : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_BIT                             20
#define IA32_VMX_EPT_VPID_CAP_INVEPT_FLAG                            0x100000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_MASK                            0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT(_)                              (((_) >> 20) & 0x01)

        /**
         * [Bit 21] When set to 1, accessed and dirty flags for EPT are supported.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t ept_accessed_and_dirty_flags : 1;
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_BIT       21
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_FLAG      0x200000
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_MASK      0x01
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS(_)        (((_) >> 21) & 0x01)

        /**
         * [Bit 22] When set to 1, the processor reports advanced VM-exit information for EPT violations. This reporting is done
         * only if this bit is read as 1.
         *
         * @see Vol3C[27.2.1(Basic VM-Exit Information)]
         */
        UINT64_t advanced_vmexit_ept_violations_information : 1;
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_BIT 22
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_FLAG 0x400000
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION(_) (((_) >> 22) & 0x01)
        UINT64_t reserved6 : 2;

        /**
         * [Bit 25] When set to 1, the single-context INVEPT type is supported.
         *
         * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
         * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
         */
        UINT64_t invept_single_context : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_BIT              25
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_FLAG             0x2000000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_MASK             0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT(_)               (((_) >> 25) & 0x01)

        /**
         * [Bit 26] When set to 1, the all-context INVEPT type is supported.
         *
         * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
         * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
         */
        UINT64_t invept_all_contexts : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_BIT                26
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_FLAG               0x4000000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_MASK               0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS(_)                 (((_) >> 26) & 0x01)
        UINT64_t reserved7 : 5;

        /**
         * [Bit 32] When set to 1, the INVVPID instruction is supported.
         */
        UINT64_t invvpid : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_BIT                            32
#define IA32_VMX_EPT_VPID_CAP_INVVPID_FLAG                           0x100000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_MASK                           0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID(_)                             (((_) >> 32) & 0x01)
        UINT64_t reserved8 : 7;

        /**
         * [Bit 40] When set to 1, the individual-address INVVPID type is supported.
         */
        UINT64_t invvpid_individual_address : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_BIT         40
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_FLAG        0x10000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_MASK        0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS(_)          (((_) >> 40) & 0x01)

        /**
         * [Bit 41] When set to 1, the single-context INVVPID type is supported.
         */
        UINT64_t invvpid_single_context : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_BIT             41
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_FLAG            0x20000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_MASK            0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT(_)              (((_) >> 41) & 0x01)

        /**
         * [Bit 42] When set to 1, the all-context INVVPID type is supported.
         */
        UINT64_t invvpid_all_contexts : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_BIT               42
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_FLAG              0x40000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_MASK              0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS(_)                (((_) >> 42) & 0x01)

        /**
         * [Bit 43] When set to 1, the single-context-retaining-globals INVVPID type is supported.
         */
        UINT64_t invvpid_single_context_retain_globals : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_BIT 43
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_FLAG 0x80000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS(_) (((_) >> 43) & 0x01)
        UINT64_t reserved9 : 20;
    };

    UINT64_t flags;
} ia32_vmx_ept_vpid_cap_register;

/**
 * @defgroup ia32_vmx_true_ctls \
 *           IA32_VMX_TRUE_(x)_CTLS
 *
 * Capability Reporting Register of Pin-Based VM-Execution Flex Controls, Primary Processor-Based VM-Execution Flex
 * Controls, VM-Exit Flex Controls and VM-Entry Flex Controls.
 *
 * @remarks If ( CPUID.01H:ECX.[5] = 1 && IA32_VMX_BASIC[55] )
 * @see Vol3D[A.3.1(Pin-Based VM-Execution Controls)]
 * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)]
 * @see Vol3D[A.4(VM-EXIT CONTROLS)]
 * @see Vol3D[A.5(VM-ENTRY CONTROLS)]
 * @see Vol3D[A.3.1(Pin-Based VMExecution Controls)] (reference)
 * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)] (reference)
 * @see Vol3D[A.4(VM-Exit Controls)] (reference)
 * @see Vol3D[A.5(VM-Entry Controls)] (reference)
 * @{
 */
#define IA32_VMX_TRUE_PINBASED_CTLS                                  0x0000048D
#define IA32_VMX_TRUE_PROCBASED_CTLS                                 0x0000048E
#define IA32_VMX_TRUE_EXIT_CTLS                                      0x0000048F
#define IA32_VMX_TRUE_ENTRY_CTLS                                     0x00000490
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] Indicate the allowed 0-settings of these controls. VM entry allows control X to be 0 if bit X in the MSR is
         * cleared to 0; if bit X in the MSR is set to 1, VM entry fails if control X is 0.
         */
        UINT64_t allowed_0_settings : 32;
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_BIT                    0
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_FLAG                   0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_MASK                   0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS(_)                     (((_) >> 0) & 0xFFFFFFFF)

        /**
         * [Bits 63:32] Indicate the allowed 1-settings of these controls. VM entry allows control X to be 1 if bit 32+X in the MSR
         * is set to 1; if bit 32+X in the MSR is cleared to 0, VM entry fails if control X is 1.
         */
        UINT64_t allowed_1_settings : 32;
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_BIT                    32
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_FLAG                   0xFFFFFFFF00000000
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_MASK                   0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS(_)                     (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64_t flags;
} ia32_vmx_true_ctls_register;

/**
 * @}
 */


 /**
  * Capability Reporting Register of VMFunction Controls.
  *
  * @remarks If ( CPUID.01H:ECX.[5] = 1 && IA32_VMX_BASIC[55] )
  * @see Vol3D[A.11(VM FUNCTIONS)]
  * @see Vol3D[24.6.14(VM-Function Controls)] (reference)
  */
#define IA32_VMX_VMFUNC                                              0x00000491
typedef union
{
    struct
    {
        /**
         * [Bit 0] The EPTP-switching VM function changes the EPT pointer to a value chosen from the EPTP list.
         *
         * @see Vol3C[25.5.5.3(EPTP Switching)]
         */
        UINT64_t eptp_switching : 1;
#define IA32_VMX_VMFUNC_EPTP_SWITCHING_BIT                           0
#define IA32_VMX_VMFUNC_EPTP_SWITCHING_FLAG                          0x01
#define IA32_VMX_VMFUNC_EPTP_SWITCHING_MASK                          0x01
#define IA32_VMX_VMFUNC_EPTP_SWITCHING(_)                            (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 63;
    };

    UINT64_t flags;
} ia32_vmx_vmfunc_register;

/**
 * @defgroup ia32_a_pmc \
 *           IA32_A_PMC(n)
 *
 * Full Width Writable IA32_PMC(n) Alias.
 *
 * @remarks (If CPUID.0AH: EAX[15:8] > 0) && IA32_PERF_CAPABILITIES[13] = 1
 * @{
 */
#define IA32_A_PMC0                                                  0x000004C1
#define IA32_A_PMC1                                                  0x000004C2
#define IA32_A_PMC2                                                  0x000004C3
#define IA32_A_PMC3                                                  0x000004C4
#define IA32_A_PMC4                                                  0x000004C5
#define IA32_A_PMC5                                                  0x000004C6
#define IA32_A_PMC6                                                  0x000004C7
#define IA32_A_PMC7                                                  0x000004C8
 /**
  * @}
  */


  /**
   * Allows software to signal some MCEs to only a single logical processor in the system.
   *
   * @remarks If IA32_MCG_CAP.LMCE_P = 1
   * @see Vol3B[15.3.1.4(IA32_MCG_EXT_CTL MSR)]
   */
#define IA32_MCG_EXT_CTL                                             0x000004D0
typedef union
{
    struct
    {
        UINT64_t lmce_en : 1;
#define IA32_MCG_EXT_CTL_LMCE_EN_BIT                                 0
#define IA32_MCG_EXT_CTL_LMCE_EN_FLAG                                0x01
#define IA32_MCG_EXT_CTL_LMCE_EN_MASK                                0x01
#define IA32_MCG_EXT_CTL_LMCE_EN(_)                                  (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 63;
    };

    UINT64_t flags;
} ia32_mcg_ext_ctl_register;


/**
 * @brief Status and SVN Threshold of SGX Support for ACM <b>(RO)</b>
 *
 * Intel SGX only allows launching ACMs with an Intel SGX SVN that is at the same level or higher than the expected Intel
 * SGX SVN. The expected Intel SGX SVN is specified by BIOS and locked down by the processor on the first successful
 * execution of an Intel SGX instruction that doesn't return an error code. Intel SGX provides interfaces for system
 * software to discover whether a non faulting Intel SGX instruction has been executed, and evaluate the suitability of the
 * Intel SGX SVN value of any ACM that is expected to be launched by the OS or the VMM.
 *
 * @remarks If CPUID.(EAX=07H, ECX=0H): EBX[2] = 1
 * @see Vol3D[41.11.3(Interactions with Authenticated Code Modules (ACMs))] (reference)
 */
#define IA32_SGX_SVN_STATUS                                          0x00000500
typedef union
{
    struct
    {
        /**
         * [Bit 0] - If 1, indicates that a non-faulting Intel SGX instruction has been executed, consequently, launching a
         * properly signed ACM but with Intel SGX SVN value less than the BIOS specified Intel SGX SVN threshold would lead to an
         * TXT shutdown.
         * - If 0, indicates that the processor will allow a properly signed ACM to launch irrespective of the Intel SGX SVN value
         * of the ACM.
         *
         * @see Vol3D[41.11.3(Interactions with Authenticated Code Modules (ACMs))]
         */
        UINT64_t lock : 1;
#define IA32_SGX_SVN_STATUS_LOCK_BIT                                 0
#define IA32_SGX_SVN_STATUS_LOCK_FLAG                                0x01
#define IA32_SGX_SVN_STATUS_LOCK_MASK                                0x01
#define IA32_SGX_SVN_STATUS_LOCK(_)                                  (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 15;

        /**
         * @brief Reflects the expected threshold of Intel SGX SVN for the SINIT ACM
         *
         * [Bits 23:16] - If CPUID.01H:ECX.SMX = 1, this field reflects the expected threshold of Intel SGX SVN for the SINIT ACM.
         * - If CPUID.01H:ECX.SMX = 0, this field is reserved (0).
         *
         * @see Vol3D[41.11.3(Interactions with Authenticated Code Modules (ACMs))]
         */
        UINT64_t sgx_svn_sinit : 8;
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_BIT                        16
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_FLAG                       0xFF0000
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_MASK                       0xFF
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT(_)                         (((_) >> 16) & 0xFF)
        UINT64_t reserved2 : 40;
    };

    UINT64_t flags;
} ia32_sgx_svn_status_register;


/**
 * Trace Output Base Register.
 *
 * @remarks If ( (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && ( (CPUID.(EAX=14H,ECX=0): ECX[0] = 1) ||
 *          (CPUID.(EAX=14H,ECX=0):ECX[2] = 1) ) )
 * @see Vol3C[35.2.7.7(IA32_RTIT_OUTPUT_BASE MSR)] (reference)
 */
#define IA32_RTIT_OUTPUT_BASE                                        0x00000560
typedef union
{
    struct
    {
        UINT64_t reserved1 : 7;

        /**
         * @brief Base physical address
         *
         * [Bits 47:7] The base physical address. How this address is used depends on the value of IA32_RTIT_CTL.ToPA:
         * - 0: This is the base physical address of a single, contiguous physical output region. This could be mapped to DRAM or
         * to MMIO, depending on the value. The base address should be aligned with the size of the region, such that none of the
         * 1s in the mask value overlap with 1s in the base address. If the base is not aligned, an operational error will result.
         * - 1: The base physical address of the current ToPA table. The address must be 4K aligned. Writing an address in which
         * bits 11:7 are non-zero will not cause a \#GP, but an operational error will be signaled once TraceEn is set.
         *
         * @see Vol3C[35.2.7.8(IA32_RTIT_OUTPUT_MASK_PTRS MSR)]
         * @see Vol3C[35.3.9(Operational Errors)]
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA))]
         */
        UINT64_t base_physical_address : 41;
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_BIT              7
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_FLAG             0xFFFFFFFFFF80
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_MASK             0x1FFFFFFFFFF
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS(_)               (((_) >> 7) & 0x1FFFFFFFFFF)
        UINT64_t reserved2 : 16;
    };

    UINT64_t flags;
} ia32_rtit_output_base_register;


/**
 * Trace Output Mask Pointers Register.
 *
 * @remarks If ( (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && ( (CPUID.(EAX=14H,ECX=0):ECX[0] = 1) ||
 *          (CPUID.(EAX=14H,ECX=0):ECX[2] = 1) ) )
 * @see Vol3C[35.2.7.8(IA32_RTIT_OUTPUT_MASK_PTRS MSR)] (reference)
 */
#define IA32_RTIT_OUTPUT_MASK_PTRS                                   0x00000561
typedef union
{
    struct
    {
        /**
         * [Bits 6:0] Forced to 1, writes are ignored.
         */
        UINT64_t lower_mask : 7;
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_BIT                    0
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_FLAG                   0x7F
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_MASK                   0x7F
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK(_)                     (((_) >> 0) & 0x7F)

        /**
         * @brief MaskOrTableOffset
         *
         * [Bits 31:7] The use of this field depends on the value of IA32_RTIT_CTL.ToPA:
         * - 0: This field holds bits 31:7 of the mask value for the single, contiguous physical output region. The size of this
         * field indicates that regions can be of size 128B up to 4GB. This value (combined with the lower 7 bits, which are
         * reserved to 1) will be ANDed with the OutputOffset field to determine the next write address. All 1s in this field
         * should be consecutive and starting at bit 7, otherwise the region will not be contiguous, and an operational error will
         * be signaled when TraceEn is set.
         * - 1: This field holds bits 27:3 of the offset pointer into the current ToPA table. This value can be added to the
         * IA32_RTIT_OUTPUT_BASE value to produce a pointer to the current ToPA table entry, which itself is a pointer to the
         * current output region. In this scenario, the lower 7 reserved bits are ignored. This field supports tables up to 256
         * MBytes in size.
         *
         * @see Vol3C[35.3.9(Operational Errors)]
         */
        UINT64_t mask_or_table_offset : 25;
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_BIT          7
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_FLAG         0xFFFFFF80
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_MASK         0x1FFFFFF
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET(_)           (((_) >> 7) & 0x1FFFFFF)

        /**
         * @brief Output Offset
         *
         * [Bits 63:32] The use of this field depends on the value of IA32_RTIT_CTL.ToPA:
         * - 0: This is bits 31:0 of the offset pointer into the single, contiguous physical output region. This value will be
         * added to the IA32_RTIT_OUTPUT_BASE value to form the physical address at which the next byte of packet output data will
         * be written. This value must be less than or equal to the MaskOrTableOffset field, otherwise an operational error will be
         * signaled when TraceEn is set.
         * - 1: This field holds bits 31:0 of the offset pointer into the current ToPA output region. This value will be added to
         * the output region base field, found in the current ToPA table entry, to form the physical address at which the next byte
         * of trace output data will be written. This value must be less than the ToPA entry size, otherwise an operational error
         * will be signaled when TraceEn is set.
         *
         * @see Vol3C[35.3.9(Operational Errors)]
         */
        UINT64_t output_offset : 32;
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_BIT                 32
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_FLAG                0xFFFFFFFF00000000
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_MASK                0xFFFFFFFF
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET(_)                  (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64_t flags;
} ia32_rtit_output_mask_ptrs_register;


/**
 * Trace Control Register.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1)
 * @see Vol3C[35.2.7.2(IA32_RTIT_CTL MSR)] (reference)
 */
#define IA32_RTIT_CTL                                                0x00000570
typedef union
{
    struct
    {
        /**
         * @brief TraceEn
         *
         * [Bit 0] If 1, enables tracing; else tracing is disabled.
         * When this bit transitions from 1 to 0, all buffered packets are flushed out of internal buffers. A further store, fence,
         * or architecturally serializing instruction may be required to ensure that packet data can be observed at the trace
         * endpoint.
         * Note that the processor will clear this bit on \#SMI (Section) and warm reset. Other MSR bits of IA32_RTIT_CTL (and
         * other trace configuration MSRs) are not impacted by these events.
         *
         * @see Vol3C[35.2.7.3(Enabling and Disabling Packet Generation with TraceEn)]
         */
        UINT64_t trace_enabled : 1;
#define IA32_RTIT_CTL_TRACE_ENABLED_BIT                              0
#define IA32_RTIT_CTL_TRACE_ENABLED_FLAG                             0x01
#define IA32_RTIT_CTL_TRACE_ENABLED_MASK                             0x01
#define IA32_RTIT_CTL_TRACE_ENABLED(_)                               (((_) >> 0) & 0x01)

        /**
         * @brief CYCEn
         *
         * [Bit 1] - 0: Disables CYC Packet.
         * - 1: Enables CYC Packet.
         *
         * @remarks If CPUID.(EAX=14H, ECX=0):EBX.CPSB_CAM[bit 1] = 0
         * @see Vol3C[35.4.2.14(Cycle Count (CYC) Packet)]
         */
        UINT64_t cyc_enabled : 1;
#define IA32_RTIT_CTL_CYC_ENABLED_BIT                                1
#define IA32_RTIT_CTL_CYC_ENABLED_FLAG                               0x02
#define IA32_RTIT_CTL_CYC_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_CYC_ENABLED(_)                                 (((_) >> 1) & 0x01)

        /**
         * @brief OS
         *
         * [Bit 2] - 0: Packet generation is disabled when CPL = 0.
         * - 1: Packet generation may be enabled when CPL = 0.
         */
        UINT64_t os : 1;
#define IA32_RTIT_CTL_OS_BIT                                         2
#define IA32_RTIT_CTL_OS_FLAG                                        0x04
#define IA32_RTIT_CTL_OS_MASK                                        0x01
#define IA32_RTIT_CTL_OS(_)                                          (((_) >> 2) & 0x01)

        /**
         * @brief User
         *
         * [Bit 3] - 0: Packet generation is disabled when CPL > 0.
         * - 1: Packet generation may be enabled when CPL > 0.
         */
        UINT64_t user : 1;
#define IA32_RTIT_CTL_USER_BIT                                       3
#define IA32_RTIT_CTL_USER_FLAG                                      0x08
#define IA32_RTIT_CTL_USER_MASK                                      0x01
#define IA32_RTIT_CTL_USER(_)                                        (((_) >> 3) & 0x01)

        /**
         * @brief PwrEvtEn
         *
         * [Bit 4] - 0: Power Event Trace packets are disabled.
         * - 1: Power Event Trace packets are enabled.
         *
         * @see Vol3C[35.2.3(Power Event Tracing)]
         */
        UINT64_t power_event_trace_enabled : 1;
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_BIT                  4
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_FLAG                 0x10
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_MASK                 0x01
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED(_)                   (((_) >> 4) & 0x01)

        /**
         * @brief FUPonPTW
         *
         * [Bit 5] - 0: PTW packets are not followed by FUPs.
         * - 1: PTW packets are followed by FUPs.
         */
        UINT64_t fup_on_ptw : 1;
#define IA32_RTIT_CTL_FUP_ON_PTW_BIT                                 5
#define IA32_RTIT_CTL_FUP_ON_PTW_FLAG                                0x20
#define IA32_RTIT_CTL_FUP_ON_PTW_MASK                                0x01
#define IA32_RTIT_CTL_FUP_ON_PTW(_)                                  (((_) >> 5) & 0x01)

        /**
         * @brief FabricEn
         *
         * [Bit 6] - 0: Trace output is directed to the memory subsystem, mechanism depends on IA32_RTIT_CTL.ToPA.
         * - 1: Trace output is directed to the trace transport subsystem, IA32_RTIT_CTL.ToPA is ignored.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):ECX[3] = 1) Reserved if CPUID.(EAX=14H, ECX=0):ECX[bit 3] = 0
         */
        UINT64_t fabric_enabled : 1;
#define IA32_RTIT_CTL_FABRIC_ENABLED_BIT                             6
#define IA32_RTIT_CTL_FABRIC_ENABLED_FLAG                            0x40
#define IA32_RTIT_CTL_FABRIC_ENABLED_MASK                            0x01
#define IA32_RTIT_CTL_FABRIC_ENABLED(_)                              (((_) >> 6) & 0x01)

        /**
         * @brief CR3 filter
         *
         * [Bit 7] - 0: Disables CR3 filtering.
         * - 1: Enables CR3 filtering.
         */
        UINT64_t cr3_filter : 1;
#define IA32_RTIT_CTL_CR3_FILTER_BIT                                 7
#define IA32_RTIT_CTL_CR3_FILTER_FLAG                                0x80
#define IA32_RTIT_CTL_CR3_FILTER_MASK                                0x01
#define IA32_RTIT_CTL_CR3_FILTER(_)                                  (((_) >> 7) & 0x01)

        /**
         * @brief ToPA
         *
         * [Bit 8] - 0: Single-range output scheme enabled.
         * - 1: ToPA output scheme enabled.
         *
         * @remarks 0: If CPUID.(EAX=14H, ECX=0):ECX.SNGLRGNOUT[bit 2] = 1 and IA32_RTIT_CTL.FabricEn=0 1: If CPUID.(EAX=14H,
         *          ECX=0):ECX.TOPA[bit 0] = 1, and IA32_RTIT_CTL.FabricEn=0
         *          WRMSR to IA32_RTIT_CTL that sets TraceEn but clears this bit and FabricEn would cause \#GP: If CPUID.(EAX=14H,
         *          ECX=0):ECX.SNGLRGNOUT[bit 2] = 0 WRMSR to IA32_RTIT_CTL that sets this bit causes \#GP: If CPUID.(EAX=14H,
         *          ECX=0):ECX.TOPA[bit 0] = 0
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA))]
         */
        UINT64_t topa : 1;
#define IA32_RTIT_CTL_TOPA_BIT                                       8
#define IA32_RTIT_CTL_TOPA_FLAG                                      0x100
#define IA32_RTIT_CTL_TOPA_MASK                                      0x01
#define IA32_RTIT_CTL_TOPA(_)                                        (((_) >> 8) & 0x01)

        /**
         * @brief MTCEn
         *
         * [Bit 9] - 0: Disables MTC Packet.
         * - 1: Enables MTC Packet.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[3] = 1) Reserved if CPUID.(EAX=14H, ECX=0):EBX.MTC[bit 3] = 0
         * @see Vol3C[35.4.2.16(Overflow (OVF) Packet)]
         */
        UINT64_t mtc_enabled : 1;
#define IA32_RTIT_CTL_MTC_ENABLED_BIT                                9
#define IA32_RTIT_CTL_MTC_ENABLED_FLAG                               0x200
#define IA32_RTIT_CTL_MTC_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_MTC_ENABLED(_)                                 (((_) >> 9) & 0x01)

        /**
         * @brief TSCEn
         *
         * [Bit 10] - 0: Disable TSC packets.
         * - 1: Enable TSC packets.
         *
         * @see Vol3C[35.4.2.11(Timestamp Counter (TSC) Packet)]
         */
        UINT64_t tsc_enabled : 1;
#define IA32_RTIT_CTL_TSC_ENABLED_BIT                                10
#define IA32_RTIT_CTL_TSC_ENABLED_FLAG                               0x400
#define IA32_RTIT_CTL_TSC_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_TSC_ENABLED(_)                                 (((_) >> 10) & 0x01)

        /**
         * @brief DisRETC
         *
         * [Bit 11] - 0: Enable RET compression.
         * - 1: Disable RET compression.
         *
         * @see Vol3C[35.2.1.2(Indirect Transfer COFI)]
         */
        UINT64_t ret_compression_disabled : 1;
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_BIT                   11
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_FLAG                  0x800
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_MASK                  0x01
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED(_)                    (((_) >> 11) & 0x01)

        /**
         * @brief PTWEn
         *
         * [Bit 12] - 0: PTWRITE packet generation disabled.
         * - 1: PTWRITE packet generation enabled.
         */
        UINT64_t ptw_enabled : 1;
#define IA32_RTIT_CTL_PTW_ENABLED_BIT                                12
#define IA32_RTIT_CTL_PTW_ENABLED_FLAG                               0x1000
#define IA32_RTIT_CTL_PTW_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_PTW_ENABLED(_)                                 (((_) >> 12) & 0x01)

        /**
         * @brief BranchEn
         *
         * [Bit 13] - 0: Disable COFI-based packets.
         * - 1: Enable COFI-based packets: FUP, TIP, TIP.PGE, TIP.PGD, TNT, MODE.Exec, MODE.TSX.
         *
         * @see Vol3C[35.2.5.4(Branch Enable (BranchEn))]
         */
        UINT64_t branch_enabled : 1;
#define IA32_RTIT_CTL_BRANCH_ENABLED_BIT                             13
#define IA32_RTIT_CTL_BRANCH_ENABLED_FLAG                            0x2000
#define IA32_RTIT_CTL_BRANCH_ENABLED_MASK                            0x01
#define IA32_RTIT_CTL_BRANCH_ENABLED(_)                              (((_) >> 13) & 0x01)

        /**
         * @brief MTCFreq
         *
         * [Bits 17:14] Defines MTC packet Frequency, which is based on the core crystal clock, or Always Running Timer (ART). MTC
         * will be sent each time the selected ART bit toggles. The following Encodings are defined:
         * 0: ART(0), 1: ART(1), 2: ART(2), 3: ART(3), 4: ART(4), 5: ART(5), 6: ART(6), 7: ART(7), 8: ART(8), 9: ART(9), 10:
         * ART(10), 11: ART(11), 12: ART(12), 13: ART(13), 14: ART(14), 15: ART(15)
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[3] = 1) Reserved if CPUID.(EAX=14H, ECX=0):EBX.MTC[bit 3] = 0
         * @see Vol3C[35.3.1(Detection of Intel Processor Trace and Capability Enumeration)]
         */
        UINT64_t mtc_frequency : 4;
#define IA32_RTIT_CTL_MTC_FREQUENCY_BIT                              14
#define IA32_RTIT_CTL_MTC_FREQUENCY_FLAG                             0x3C000
#define IA32_RTIT_CTL_MTC_FREQUENCY_MASK                             0x0F
#define IA32_RTIT_CTL_MTC_FREQUENCY(_)                               (((_) >> 14) & 0x0F)
        UINT64_t reserved1 : 1;

        /**
         * @brief CYCThresh
         *
         * [Bits 22:19] CYC packet threshold. CYC packets will be sent with the first eligible packet after N cycles have passed
         * since the last CYC packet. If CycThresh is 0 then N=0, otherwise N is defined as 2(CycThresh-1). The following Encodings
         * are defined:
         * 0: 0, 1: 1, 2: 2, 3: 4, 4: 8, 5: 16, 6: 32, 7: 64, 8: 128, 9: 256, 10: 512, 11: 1024, 12: 2048, 13: 4096, 14: 8192, 15:
         * 16384
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[1] = 1) Reserved if CPUID.(EAX=14H, ECX=0):EBX.CPSB_CAM[bit 1] = 0
         * @see Vol3C[35.3.6(Cycle-Accurate Mode)]
         * @see Vol3C[35.3.1(Detection of Intel Processor Trace and Capability Enumeration)]
         */
        UINT64_t cyc_threshold : 4;
#define IA32_RTIT_CTL_CYC_THRESHOLD_BIT                              19
#define IA32_RTIT_CTL_CYC_THRESHOLD_FLAG                             0x780000
#define IA32_RTIT_CTL_CYC_THRESHOLD_MASK                             0x0F
#define IA32_RTIT_CTL_CYC_THRESHOLD(_)                               (((_) >> 19) & 0x0F)
        UINT64_t reserved2 : 1;

        /**
         * @brief PSBFreq
         *
         * [Bits 27:24] Indicates the frequency of PSB packets. PSB packet frequency is based on the number of Intel PT packet
         * bytes output, so this field allows the user to determine the increment of IA32_IA32_RTIT_STATUS.PacketByteCnt that
         * should cause a PSB to be generated. Note that PSB insertion is not precise, but the average output bytes per PSB should
         * approximate the SW selected period. The following Encodings are defined:
         * 0: 2K, 1: 4K, 2: 8K, 3: 16K, 4: 32K, 5: 64K, 6: 128K, 7: 256K, 8: 512K, 9: 1M, 10: 2M, 11: 4M, 12: 8M, 13: 16M, 14: 32M,
         * 15: 64M
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[1] = 1) Reserved if CPUID.(EAX=14H, ECX=0):EBX.CPSB_CAM[bit 1] = 0
         * @see Vol3C[35.3.1(Detection of Intel Processor Trace and Capability Enumeration)]
         */
        UINT64_t psb_frequency : 4;
#define IA32_RTIT_CTL_PSB_FREQUENCY_BIT                              24
#define IA32_RTIT_CTL_PSB_FREQUENCY_FLAG                             0xF000000
#define IA32_RTIT_CTL_PSB_FREQUENCY_MASK                             0x0F
#define IA32_RTIT_CTL_PSB_FREQUENCY(_)                               (((_) >> 24) & 0x0F)
        UINT64_t reserved3 : 4;

        /**
         * @brief ADDR0_CFG
         *
         * [Bits 35:32] Configures the base/limit register pair IA32_RTIT_ADDR0_A/B based on the following encodings:
         * - 0: ADDR0 range unused.
         * - 1: The [IA32_RTIT_ADDR0_A..IA32_RTIT_ADDR0_B] range defines a FilterEn range. FilterEn will only be set when the IP is
         * within this range, though other FilterEn ranges can additionally be used.
         * - 2: The [IA32_RTIT_ADDR0_A..IA32_RTIT_ADDR0_B] range defines a TraceStop range. TraceStop will be asserted if code
         * branches into this range.
         * - 3..15: Reserved (\#GP).
         *
         * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 0) Reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] >= 0
         * @see Vol3C[35.2.4.3(Filtering by IP)]
         * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
         */
        UINT64_t addr0_cfg : 4;
#define IA32_RTIT_CTL_ADDR0_CFG_BIT                                  32
#define IA32_RTIT_CTL_ADDR0_CFG_FLAG                                 0xF00000000
#define IA32_RTIT_CTL_ADDR0_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR0_CFG(_)                                   (((_) >> 32) & 0x0F)

        /**
         * @brief ADDR1_CFG
         *
         * [Bits 39:36] Configures the base/limit register pair IA32_RTIT_ADDR1_A/B based on the following encodings:
         * - 0: ADDR1 range unused.
         * - 1: The [IA32_RTIT_ADDR1_A..IA32_RTIT_ADDR1_B] range defines a FilterEn range. FilterEn will only be set when the IP is
         * within this range, though other FilterEn ranges can additionally be used.
         * - 2: The [IA32_RTIT_ADDR1_A..IA32_RTIT_ADDR1_B] range defines a TraceStop range. TraceStop will be asserted if code
         * branches into this range.
         * - 3..15: Reserved (\#GP).
         *
         * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 1) Reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] < 2
         * @see Vol3C[35.2.4.3(Filtering by IP)]
         * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
         */
        UINT64_t addr1_cfg : 4;
#define IA32_RTIT_CTL_ADDR1_CFG_BIT                                  36
#define IA32_RTIT_CTL_ADDR1_CFG_FLAG                                 0xF000000000
#define IA32_RTIT_CTL_ADDR1_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR1_CFG(_)                                   (((_) >> 36) & 0x0F)

        /**
         * @brief ADDR2_CFG
         *
         * [Bits 43:40] Configures the base/limit register pair IA32_RTIT_ADDR2_A/B based on the following encodings:
         * - 0: ADDR2 range unused.
         * - 1: The [IA32_RTIT_ADDR2_A..IA32_RTIT_ADDR2_B] range defines a FilterEn range. FilterEn will only be set when the IP is
         * within this range, though other FilterEn ranges can additionally be used.
         * - 2: The [IA32_RTIT_ADDR2_A..IA32_RTIT_ADDR2_B] range defines a TraceStop range. TraceStop will be asserted if code
         * branches into this range.
         * - 3..15: Reserved (\#GP).
         *
         * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 2) Reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] < 3
         * @see Vol3C[35.2.4.3(Filtering by IP)]
         * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
         */
        UINT64_t addr2_cfg : 4;
#define IA32_RTIT_CTL_ADDR2_CFG_BIT                                  40
#define IA32_RTIT_CTL_ADDR2_CFG_FLAG                                 0xF0000000000
#define IA32_RTIT_CTL_ADDR2_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR2_CFG(_)                                   (((_) >> 40) & 0x0F)

        /**
         * @brief ADDR3_CFG
         *
         * [Bits 47:44] Configures the base/limit register pair IA32_RTIT_ADDR3_A/B based on the following encodings:
         * - 0: ADDR3 range unused.
         * - 1: The [IA32_RTIT_ADDR3_A..IA32_RTIT_ADDR3_B] range defines a FilterEn range. FilterEn will only be set when the IP is
         * within this range, though other FilterEn ranges can additionally be used.
         * - 2: The [IA32_RTIT_ADDR3_A..IA32_RTIT_ADDR3_B] range defines a TraceStop range. TraceStop will be asserted if code
         * branches into this range.
         * - 3..15: Reserved (\#GP).
         *
         * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 3) Reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] < 4
         * @see Vol3C[35.2.4.3(Filtering by IP)]
         * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
         */
        UINT64_t addr3_cfg : 4;
#define IA32_RTIT_CTL_ADDR3_CFG_BIT                                  44
#define IA32_RTIT_CTL_ADDR3_CFG_FLAG                                 0xF00000000000
#define IA32_RTIT_CTL_ADDR3_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR3_CFG(_)                                   (((_) >> 44) & 0x0F)
        UINT64_t reserved4 : 8;

        /**
         * @brief InjectPsbPmiOnEnable
         *
         * [Bit 56] - 1: Enables use of IA32_RTIT_STATUS bits PendPSB[6] and PendTopaPMI[7].
         * - 0: IA32_RTIT_STATUS bits 6 and 7 are ignored.
         *
         * @remarks Reserved if CPUID.(EAX=14H, ECX=0):EBX.INJECTPSBPMI[6] = 0
         * @see Vol3C[35.2.7.4(IA32_RTIT_STATUS MSR)]
         */
        UINT64_t inject_psb_pmi_on_enable : 1;
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_BIT                   56
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_FLAG                  0x100000000000000
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_MASK                  0x01
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE(_)                    (((_) >> 56) & 0x01)
        UINT64_t reserved5 : 7;
    };

    UINT64_t flags;
} ia32_rtit_ctl_register;


/**
 * Tracing Status Register.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1)
 */
#define IA32_RTIT_STATUS                                             0x00000571
typedef union
{
    struct
    {
        /**
         * @brief FilterEn (writes ignored)
         *
         * [Bit 0] This bit is written by the processor, and indicates that tracing is allowed for the current IP. Writes are
         * ignored.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[2] = 1)
         * @see Vol3C[35.2.5.5(Filter Enable (FilterEn))]
         */
        UINT64_t filter_enabled : 1;
#define IA32_RTIT_STATUS_FILTER_ENABLED_BIT                          0
#define IA32_RTIT_STATUS_FILTER_ENABLED_FLAG                         0x01
#define IA32_RTIT_STATUS_FILTER_ENABLED_MASK                         0x01
#define IA32_RTIT_STATUS_FILTER_ENABLED(_)                           (((_) >> 0) & 0x01)

        /**
         * @brief ContexEn (writes ignored)
         *
         * [Bit 1] The processor sets this bit to indicate that tracing is allowed for the current context. Writes are ignored.
         *
         * @see Vol3C[35.2.5.3(Context Enable (ContextEn))]
         */
        UINT64_t context_enabled : 1;
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_BIT                         1
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_FLAG                        0x02
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_MASK                        0x01
#define IA32_RTIT_STATUS_CONTEXT_ENABLED(_)                          (((_) >> 1) & 0x01)

        /**
         * @brief TriggerEn (writes ignored)
         *
         * [Bit 2] The processor sets this bit to indicate that tracing is enabled. Writes are ignored.
         *
         * @see Vol3C[35.2.5.2(Trigger Enable (TriggerEn))]
         */
        UINT64_t trigger_enabled : 1;
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_BIT                         2
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_FLAG                        0x04
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_MASK                        0x01
#define IA32_RTIT_STATUS_TRIGGER_ENABLED(_)                          (((_) >> 2) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * @brief Error
         *
         * [Bit 4] The processor sets this bit to indicate that an operational error has been encountered. When this bit is set,
         * TriggerEn is cleared to 0 and packet generation is disabled.
         * When TraceEn is cleared, software can write this bit. Once it is set, only software can clear it. It is not recommended
         * that software ever set this bit, except in cases where it is restoring a prior saved state.
         *
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA) | ToPA Errors)]
         */
        UINT64_t error : 1;
#define IA32_RTIT_STATUS_ERROR_BIT                                   4
#define IA32_RTIT_STATUS_ERROR_FLAG                                  0x10
#define IA32_RTIT_STATUS_ERROR_MASK                                  0x01
#define IA32_RTIT_STATUS_ERROR(_)                                    (((_) >> 4) & 0x01)

        /**
         * @brief Stopped
         *
         * [Bit 5] The processor sets this bit to indicate that a ToPA Stop condition has been encountered. When this bit is set,
         * TriggerEn is cleared to 0 and packet generation is disabled.
         * When TraceEn is cleared, software can write this bit. Once it is set, only software can clear it. It is not recommended
         * that software ever set this bit, except in cases where it is restoring a prior saved state.
         *
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA) | ToPA STOP)]
         */
        UINT64_t stopped : 1;
#define IA32_RTIT_STATUS_STOPPED_BIT                                 5
#define IA32_RTIT_STATUS_STOPPED_FLAG                                0x20
#define IA32_RTIT_STATUS_STOPPED_MASK                                0x01
#define IA32_RTIT_STATUS_STOPPED(_)                                  (((_) >> 5) & 0x01)

        /**
         * @brief Pend PSB
         *
         * [Bit 6] If IA32_RTIT_CTL.InjectPsbPmiOnEnable[56] = 1, the processor sets this bit when the threshold for a PSB+ to be
         * inserted has been reached. The processor will clear this bit when the PSB+ has been inserted into the trace. If PendPSB
         * = 1 and InjectPsbPmiOnEnable = 1 when IA32_RTIT_CTL.TraceEn[0] transitions from 0 to 1, a PSB+ will be inserted into the
         * trace.
         *
         * @remarks If CPUID.(EAX=14H, ECX=0):EBX.INJECTPSBPMI[6] = 1
         */
        UINT64_t pend_psb : 1;
#define IA32_RTIT_STATUS_PEND_PSB_BIT                                6
#define IA32_RTIT_STATUS_PEND_PSB_FLAG                               0x40
#define IA32_RTIT_STATUS_PEND_PSB_MASK                               0x01
#define IA32_RTIT_STATUS_PEND_PSB(_)                                 (((_) >> 6) & 0x01)

        /**
         * @brief Pend ToPA PMI
         *
         * [Bit 7] If IA32_RTIT_CTL.InjectPsbPmiOnEnable[56] = 1, the processor sets this bit when the threshold for a ToPA PMI to
         * be inserted has been reached. Software should clear this bit once the ToPA PMI has been handled. If PendTopaPMI = 1 and
         * InjectPsbPmiOnEnable = 1 when IA32_RTIT_CTL.TraceEn[0] transitions from 0 to 1, a PMI will be pended.
         *
         * @remarks If CPUID.(EAX=14H, ECX=0):EBX.INJECTPSBPMI[6] = 1
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA) | ToPA PMI)]
         */
        UINT64_t pend_topa_pmi : 1;
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_BIT                           7
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_FLAG                          0x80
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_MASK                          0x01
#define IA32_RTIT_STATUS_PEND_TOPA_PMI(_)                            (((_) >> 7) & 0x01)
        UINT64_t reserved2 : 24;

        /**
         * @brief PacketByteCnt
         *
         * [Bits 48:32] This field is written by the processor, and holds a count of packet bytes that have been sent out. The
         * processor also uses this field to determine when the next PSB packet should be inserted. Note that the processor may
         * clear or modify this field at any time while IA32_RTIT_CTL.TraceEn=1. It will have a stable value when
         * IA32_RTIT_CTL.TraceEn=0.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[1] > 3)
         * @see Vol3C[35.4.2.17(Packet Stream Boundary (PSB) Packet)]
         */
        UINT64_t packetUINT8_count : 17;
#define IA32_RTIT_STATUS_PACKETUINT8_COUNT_BIT                       32
#define IA32_RTIT_STATUS_PACKETUINT8_COUNT_FLAG                      0x1FFFF00000000
#define IA32_RTIT_STATUS_PACKETUINT8_COUNT_MASK                      0x1FFFF
#define IA32_RTIT_STATUS_PACKETUINT8_COUNT(_)                        (((_) >> 32) & 0x1FFFF)
        UINT64_t reserved3 : 15;
    };

    UINT64_t flags;
} ia32_rtit_status_register;


/**
 * @brief Trace Filter CR3 Match Register <b>(R/W)</b>
 *
 * The IA32_RTIT_CR3_MATCH register is compared against CR3 when IA32_RTIT_CTL.CR3Filter is 1. Bits 63:5 hold the CR3
 * address value to match, bits 4:0 are reserved to 0.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1)
 * @see Vol3C[35.2.4.2(Filtering by CR3)]
 * @see Vol3C[35.2.7.6(IA32_RTIT_CR3_MATCH MSR)] (reference)
 */
#define IA32_RTIT_CR3_MATCH                                          0x00000572
typedef union
{
    struct
    {
        UINT64_t reserved1 : 5;

        /**
         * [Bits 63:5] CR3[63:5] value to match.
         */
        UINT64_t cr3_value_to_match : 59;
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_BIT                   5
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_FLAG                  0xFFFFFFFFFFFFFFE0
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_MASK                  0x7FFFFFFFFFFFFFF
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH(_)                    (((_) >> 5) & 0x7FFFFFFFFFFFFFF)
    };

    UINT64_t flags;
} ia32_rtit_cr3_match_register;

/**
 * @defgroup ia32_rtit_addr \
 *           IA32_RTIT_ADDR(x)
 *
 * The role of the IA32_RTIT_ADDRn_A/B register pairs, for each n, is determined by the corresponding ADDRn_CFG fields in
 * IA32_RTIT_CTL. The number of these register pairs is enumerated by CPUID.(EAX=14H, ECX=1):EAX.RANGECNT[2:0].
 *
 * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > n)
 * @see Vol3C[35.2.7.2(IA32_RTIT_CTL MSR)]
 * @see Vol3C[35.2.7.5(IA32_RTIT_ADDRn_A and IA32_RTIT_ADDRn_B MSRs)] (reference)
 * @{
 */
 /**
  * @defgroup ia32_rtit_addr_a \
  *           IA32_RTIT_ADDR(n)_A
  *
  * Region n Start Address.
  *
  * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > n)
  * @{
  */
#define IA32_RTIT_ADDR0_A                                            0x00000580
#define IA32_RTIT_ADDR1_A                                            0x00000582
#define IA32_RTIT_ADDR2_A                                            0x00000584
#define IA32_RTIT_ADDR3_A                                            0x00000586
  /**
   * @}
   */

   /**
    * @defgroup ia32_rtit_addr_b \
    *           IA32_RTIT_ADDR(n)_B
    *
    * Region n End Address.
    *
    * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > n)
    * @{
    */
#define IA32_RTIT_ADDR0_B                                            0x00000581
#define IA32_RTIT_ADDR1_B                                            0x00000583
#define IA32_RTIT_ADDR2_B                                            0x00000585
#define IA32_RTIT_ADDR3_B                                            0x00000587
    /**
     * @}
     */

typedef union
{
    struct
    {
        /**
         * [Bits 47:0] Virtual Address.
         */
        UINT64_t virtual_address : 48;
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_BIT                           0
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_FLAG                          0xFFFFFFFFFFFF
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_MASK                          0xFFFFFFFFFFFF
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS(_)                            (((_) >> 0) & 0xFFFFFFFFFFFF)

        /**
         * [Bits 63:48] SignExt_VA.
         */
        UINT64_t sign_ext_va : 16;
#define IA32_RTIT_ADDR_SIGN_EXT_VA_BIT                               48
#define IA32_RTIT_ADDR_SIGN_EXT_VA_FLAG                              0xFFFF000000000000
#define IA32_RTIT_ADDR_SIGN_EXT_VA_MASK                              0xFFFF
#define IA32_RTIT_ADDR_SIGN_EXT_VA(_)                                (((_) >> 48) & 0xFFFF)
    };

    UINT64_t flags;
} ia32_rtit_addr_register;

/**
 * @}
 */


 /**
  * DS Save Area. Points to the linear address of the first byte of the DS buffer management area, which is used to manage
  * the BTS and PEBS buffers.
  * Returns:
  * - [63:0] The linear address of the first byte of the DS buffer management area, if IA-32e mode is active.
  * - [31:0] The linear address of the first byte of the DS buffer management area, if not in IA-32e mode.
  * - [63:32] Reserved if not in IA-32e mode.
  *
  * @remarks If CPUID.01H:EDX.DS[21] = 1
  * @see Vol3B[18.6.3.4(Debug Store (DS) Mechanism)]
  */
#define IA32_DS_AREA                                                 0x00000600

  /**
   * TSC Target of Local APIC's TSC Deadline Mode.
   *
   * @remarks If CPUID.01H:ECX.[24] = 1
   */
#define IA32_TSC_DEADLINE                                            0x000006E0

   /**
    * Enable/disable HWP.
    *
    * @remarks If CPUID.06H:EAX.[7] = 1
    */
#define IA32_PM_ENABLE                                               0x00000770
typedef union
{
    struct
    {
        /**
         * [Bit 0] HWP_ENABLE.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.2(Enabling HWP)]
         */
        UINT64_t hwp_enable : 1;
#define IA32_PM_ENABLE_HWP_ENABLE_BIT                                0
#define IA32_PM_ENABLE_HWP_ENABLE_FLAG                               0x01
#define IA32_PM_ENABLE_HWP_ENABLE_MASK                               0x01
#define IA32_PM_ENABLE_HWP_ENABLE(_)                                 (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 63;
    };

    UINT64_t flags;
} ia32_pm_enable_register;


/**
 * HWP Performance Range Enumeration.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_HWP_CAPABILITIES                                        0x00000771
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Highest_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
         */
        UINT64_t highest_performance : 8;
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_BIT                0
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_FLAG               0xFF
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_MASK               0xFF
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE(_)                 (((_) >> 0) & 0xFF)

        /**
         * [Bits 15:8] Guaranteed_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
         */
        UINT64_t guaranteed_performance : 8;
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_BIT             8
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_FLAG            0xFF00
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_MASK            0xFF
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE(_)              (((_) >> 8) & 0xFF)

        /**
         * [Bits 23:16] Most_Efficient_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
         */
        UINT64_t most_efficient_performance : 8;
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_BIT         16
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_FLAG        0xFF0000
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_MASK        0xFF
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE(_)          (((_) >> 16) & 0xFF)

        /**
         * [Bits 31:24] Lowest_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
         */
        UINT64_t lowest_performance : 8;
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_BIT                 24
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_FLAG                0xFF000000
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_MASK                0xFF
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE(_)                  (((_) >> 24) & 0xFF)
        UINT64_t reserved1 : 32;
    };

    UINT64_t flags;
} ia32_hwp_capabilities_register;


/**
 * Power Management Control Hints for All Logical Processors in a Package.
 *
 * @remarks If CPUID.06H:EAX.[11] = 1
 */
#define IA32_HWP_REQUEST_PKG                                         0x00000772
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Minimum_Performance.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t minimum_performance : 8;
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_BIT                 0
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_FLAG                0xFF
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_MASK                0xFF
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE(_)                  (((_) >> 0) & 0xFF)

        /**
         * [Bits 15:8] Maximum_Performance.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t maximum_performance : 8;
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_BIT                 8
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_FLAG                0xFF00
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_MASK                0xFF
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE(_)                  (((_) >> 8) & 0xFF)

        /**
         * [Bits 23:16] Desired_Performance.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t desired_performance : 8;
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_BIT                 16
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_FLAG                0xFF0000
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_MASK                0xFF
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE(_)                  (((_) >> 16) & 0xFF)

        /**
         * [Bits 31:24] Energy_Performance_Preference.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1 && CPUID.06H:EAX.[10] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t energy_performance_preference : 8;
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_BIT       24
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_FLAG      0xFF000000
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_MASK      0xFF
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE(_)        (((_) >> 24) & 0xFF)

        /**
         * [Bits 41:32] Activity_Window.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1 && CPUID.06H:EAX.[9] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t activity_window : 10;
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_BIT                     32
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_FLAG                    0x3FF00000000
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_MASK                    0x3FF
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW(_)                      (((_) >> 32) & 0x3FF)
        UINT64_t reserved1 : 22;
    };

    UINT64_t flags;
} ia32_hwp_request_pkg_register;


/**
 * Control HWP Native Interrupts.
 *
 * @remarks If CPUID.06H:EAX.[8] = 1
 */
#define IA32_HWP_INTERRUPT                                           0x00000773
typedef union
{
    struct
    {
        /**
         * [Bit 0] EN_Guaranteed_Performance_Change.
         *
         * @remarks If CPUID.06H:EAX.[8] = 1
         * @see Vol3B[14.4.6(HWP Notifications)]
         */
        UINT64_t en_guaranteed_performance_change : 1;
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_BIT      0
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_FLAG     0x01
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_MASK     0x01
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE(_)       (((_) >> 0) & 0x01)

        /**
         * [Bit 1] EN_Excursion_Minimum.
         *
         * @remarks If CPUID.06H:EAX.[8] = 1
         * @see Vol3B[14.4.6(HWP Notifications)]
         */
        UINT64_t en_excursion_minimum : 1;
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_BIT                  1
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_FLAG                 0x02
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_MASK                 0x01
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM(_)                   (((_) >> 1) & 0x01)
        UINT64_t reserved1 : 62;
    };

    UINT64_t flags;
} ia32_hwp_interrupt_register;


/**
 * Power Management Control Hints to a Logical Processor.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_HWP_REQUEST                                             0x00000774
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Minimum_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t minimum_performance : 8;
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_BIT                     0
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_FLAG                    0xFF
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_MASK                    0xFF
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE(_)                      (((_) >> 0) & 0xFF)

        /**
         * [Bits 15:8] Maximum_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t maximum_performance : 8;
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_BIT                     8
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_FLAG                    0xFF00
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_MASK                    0xFF
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE(_)                      (((_) >> 8) & 0xFF)

        /**
         * [Bits 23:16] Desired_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t desired_performance : 8;
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_BIT                     16
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_FLAG                    0xFF0000
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_MASK                    0xFF
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE(_)                      (((_) >> 16) & 0xFF)

        /**
         * [Bits 31:24] Energy_Performance_Preference.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1 && CPUID.06H:EAX.[10] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t energy_performance_preference : 8;
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_BIT           24
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_FLAG          0xFF000000
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_MASK          0xFF
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE(_)            (((_) >> 24) & 0xFF)

        /**
         * [Bits 41:32] Activity_Window.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1 && CPUID.06H:EAX.[9] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t activity_window : 10;
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_BIT                         32
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_FLAG                        0x3FF00000000
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_MASK                        0x3FF
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW(_)                          (((_) >> 32) & 0x3FF)

        /**
         * [Bit 42] Package_Control.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1 && CPUID.06H:EAX.[11] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t package_control : 1;
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_BIT                         42
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_FLAG                        0x40000000000
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_MASK                        0x01
#define IA32_HWP_REQUEST_PACKAGE_CONTROL(_)                          (((_) >> 42) & 0x01)
        UINT64_t reserved1 : 21;
    };

    UINT64_t flags;
} ia32_hwp_request_register;


/**
 * Log bits indicating changes to Guaranteed & excursions to Minimum.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_HWP_STATUS                                              0x00000777
typedef union
{
    struct
    {
        /**
         * [Bit 0] Guaranteed_Performance_Change.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.5(HWP Feedback)]
         */
        UINT64_t guaranteed_performance_change : 1;
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_BIT            0
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_FLAG           0x01
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_MASK           0x01
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE(_)             (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * [Bit 2] Excursion_To_Minimum.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.5(HWP Feedback)]
         */
        UINT64_t excursion_to_minimum : 1;
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_BIT                     2
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_FLAG                    0x04
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_MASK                    0x01
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM(_)                      (((_) >> 2) & 0x01)
        UINT64_t reserved2 : 61;
    };

    UINT64_t flags;
} ia32_hwp_status_register;


/**
 * x2APIC ID Register.
 *
 * @remarks If CPUID.01H:ECX[21] = 1 && IA32_APIC_BASE.[10] = 1
 * @see Vol3A[10.12(EXTENDED XAPIC (X2APIC))]
 */
#define IA32_X2APIC_APICID                                           0x00000802

 /**
  * x2APIC Version Register.
  *
  * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
  */
#define IA32_X2APIC_VERSION                                          0x00000803

  /**
   * x2APIC Task Priority Register.
   *
   * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
   */
#define IA32_X2APIC_TPR                                              0x00000808

   /**
    * x2APIC Processor Priority Register.
    *
    * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
    */
#define IA32_X2APIC_PPR                                              0x0000080A

    /**
     * x2APIC EOI Register.
     *
     * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
     */
#define IA32_X2APIC_EOI                                              0x0000080B

     /**
      * x2APIC Logical Destination Register.
      *
      * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
      */
#define IA32_X2APIC_LDR                                              0x0000080D

      /**
       * x2APIC Spurious Interrupt Vector Register.
       *
       * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
       */
#define IA32_X2APIC_SIVR                                             0x0000080F
       /**
        * @defgroup ia32_x2apic_isr \
        *           IA32_X2APIC_ISR(n)
        *
        * x2APIC In-Service Register Bits (n * 32 + 31):(n * 32).
        *
        * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
        * @{
        */
#define IA32_X2APIC_ISR0                                             0x00000810
#define IA32_X2APIC_ISR1                                             0x00000811
#define IA32_X2APIC_ISR2                                             0x00000812
#define IA32_X2APIC_ISR3                                             0x00000813
#define IA32_X2APIC_ISR4                                             0x00000814
#define IA32_X2APIC_ISR5                                             0x00000815
#define IA32_X2APIC_ISR6                                             0x00000816
#define IA32_X2APIC_ISR7                                             0x00000817
        /**
         * @}
         */

         /**
          * @defgroup ia32_x2apic_tmr \
          *           IA32_X2APIC_TMR(n)
          *
          * x2APIC Trigger Mode Register Bits (n * 32 + 31):(n * 32).
          *
          * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
          * @{
          */
#define IA32_X2APIC_TMR0                                             0x00000818
#define IA32_X2APIC_TMR1                                             0x00000819
#define IA32_X2APIC_TMR2                                             0x0000081A
#define IA32_X2APIC_TMR3                                             0x0000081B
#define IA32_X2APIC_TMR4                                             0x0000081C
#define IA32_X2APIC_TMR5                                             0x0000081D
#define IA32_X2APIC_TMR6                                             0x0000081E
#define IA32_X2APIC_TMR7                                             0x0000081F
          /**
           * @}
           */

           /**
            * @defgroup ia32_x2apic_irr \
            *           IA32_X2APIC_IRR(n)
            *
            * x2APIC Interrupt Request Register Bits (n * 32 + 31):(n * 32).
            *
            * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
            * @{
            */
#define IA32_X2APIC_IRR0                                             0x00000820
#define IA32_X2APIC_IRR1                                             0x00000821
#define IA32_X2APIC_IRR2                                             0x00000822
#define IA32_X2APIC_IRR3                                             0x00000823
#define IA32_X2APIC_IRR4                                             0x00000824
#define IA32_X2APIC_IRR5                                             0x00000825
#define IA32_X2APIC_IRR6                                             0x00000826
#define IA32_X2APIC_IRR7                                             0x00000827
            /**
             * @}
             */


             /**
              * x2APIC Error Status Register.
              *
              * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
              */
#define IA32_X2APIC_ESR                                              0x00000828

              /**
               * x2APIC LVT Corrected Machine Check Interrupt Register.
               *
               * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
               */
#define IA32_X2APIC_LVT_CMCI                                         0x0000082F

               /**
                * x2APIC Interrupt Command Register.
                *
                * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                */
#define IA32_X2APIC_ICR                                              0x00000830

                /**
                 * x2APIC LVT Timer Interrupt Register.
                 *
                 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                 */
#define IA32_X2APIC_LVT_TIMER                                        0x00000832

                 /**
                  * x2APIC LVT Thermal Sensor Interrupt Register.
                  *
                  * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                  */
#define IA32_X2APIC_LVT_THERMAL                                      0x00000833

                  /**
                   * x2APIC LVT Performance Monitor Interrupt Register.
                   *
                   * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                   */
#define IA32_X2APIC_LVT_PMI                                          0x00000834

                   /**
                    * x2APIC LVT LINT0 Register.
                    *
                    * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                    */
#define IA32_X2APIC_LVT_LINT0                                        0x00000835

                    /**
                     * x2APIC LVT LINT1 Register.
                     *
                     * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                     */
#define IA32_X2APIC_LVT_LINT1                                        0x00000836

                     /**
                      * x2APIC LVT Error Register.
                      *
                      * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                      */
#define IA32_X2APIC_LVT_ERROR                                        0x00000837

                      /**
                       * x2APIC Initial Count Register.
                       *
                       * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                       */
#define IA32_X2APIC_INIT_COUNT                                       0x00000838

                       /**
                        * x2APIC Current Count Register.
                        *
                        * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                        */
#define IA32_X2APIC_CUR_COUNT                                        0x00000839

                        /**
                         * x2APIC Divide Configuration Register.
                         *
                         * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                         */
#define IA32_X2APIC_DIV_CONF                                         0x0000083E

                         /**
                          * x2APIC Self IPI Register.
                          *
                          * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                          */
#define IA32_X2APIC_SELF_IPI                                         0x0000083F

                          /**
                           * Silicon Debug Feature Control.
                           *
                           * @remarks If CPUID.01H:ECX.[11] = 1
                           */
#define IA32_DEBUG_INTERFACE                                         0x00000C80
typedef union
{
    struct
    {
        /**
         * @brief Enable <b>(R/W)</b>
         *
         * [Bit 0] BIOS set 1 to enable Silicon debug features. Default is 0.
         *
         * @remarks If CPUID.01H:ECX.[11] = 1
         */
        UINT64_t enable : 1;
#define IA32_DEBUG_INTERFACE_ENABLE_BIT                              0
#define IA32_DEBUG_INTERFACE_ENABLE_FLAG                             0x01
#define IA32_DEBUG_INTERFACE_ENABLE_MASK                             0x01
#define IA32_DEBUG_INTERFACE_ENABLE(_)                               (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 29;

        /**
         * @brief Lock <b>(R/W)</b>
         *
         * [Bit 30] If 1, locks any further change to the MSR. The lock bit is set automatically on the first SMI assertion even if
         * not explicitly set by BIOS. Default is 0.
         *
         * @remarks If CPUID.01H:ECX.[11] = 1
         */
        UINT64_t lock : 1;
#define IA32_DEBUG_INTERFACE_LOCK_BIT                                30
#define IA32_DEBUG_INTERFACE_LOCK_FLAG                               0x40000000
#define IA32_DEBUG_INTERFACE_LOCK_MASK                               0x01
#define IA32_DEBUG_INTERFACE_LOCK(_)                                 (((_) >> 30) & 0x01)

        /**
         * @brief Debug Occurred <b>(R/O)</b>
         *
         * [Bit 31] This "sticky bit" is set by hardware to indicate the status of bit 0. Default is 0.
         *
         * @remarks If CPUID.01H:ECX.[11] = 1
         */
        UINT64_t debug_occurred : 1;
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_BIT                      31
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_FLAG                     0x80000000
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_MASK                     0x01
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED(_)                       (((_) >> 31) & 0x01)
        UINT64_t reserved2 : 32;
    };

    UINT64_t flags;
} ia32_debug_interface_register;


/**
 * L3 QOS Configuration.
 *
 * @remarks If ( CPUID.(EAX=10H, ECX=1):ECX.[2] = 1 )
 */
#define IA32_L3_QOS_CFG                                              0x00000C81
typedef union
{
    struct
    {
        /**
         * @brief Enable <b>(R/W)</b>
         *
         * [Bit 0] Set 1 to enable L3 CAT masks and COS to operate in Code and Data Prioritization (CDP) mode.
         */
        UINT64_t enable : 1;
#define IA32_L3_QOS_CFG_ENABLE_BIT                                   0
#define IA32_L3_QOS_CFG_ENABLE_FLAG                                  0x01
#define IA32_L3_QOS_CFG_ENABLE_MASK                                  0x01
#define IA32_L3_QOS_CFG_ENABLE(_)                                    (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 63;
    };

    UINT64_t flags;
} ia32_l3_qos_cfg_register;


/**
 * L2 QOS Configuration.
 *
 * @remarks If ( CPUID.(EAX=10H, ECX=2):ECX.[2] = 1 )
 */
#define IA32_L2_QOS_CFG                                              0x00000C82
typedef union
{
    struct
    {
        /**
         * @brief Enable <b>(R/W)</b>
         *
         * [Bit 0] Set 1 to enable L2 CAT masks and COS to operate in Code and Data Prioritization (CDP) mode.
         */
        UINT64_t enable : 1;
#define IA32_L2_QOS_CFG_ENABLE_BIT                                   0
#define IA32_L2_QOS_CFG_ENABLE_FLAG                                  0x01
#define IA32_L2_QOS_CFG_ENABLE_MASK                                  0x01
#define IA32_L2_QOS_CFG_ENABLE(_)                                    (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 63;
    };

    UINT64_t flags;
} ia32_l2_qos_cfg_register;


/**
 * Monitoring Event Select Register.
 *
 * @remarks If ( CPUID.(EAX=07H, ECX=0):EBX.[12] = 1 )
 */
#define IA32_QM_EVTSEL                                               0x00000C8D
typedef union
{
    struct
    {
        /**
         * @brief Event ID
         *
         * [Bits 7:0] ID of a supported monitoring event to report via IA32_QM_CTR.
         */
        UINT64_t event_id : 8;
#define IA32_QM_EVTSEL_EVENT_ID_BIT                                  0
#define IA32_QM_EVTSEL_EVENT_ID_FLAG                                 0xFF
#define IA32_QM_EVTSEL_EVENT_ID_MASK                                 0xFF
#define IA32_QM_EVTSEL_EVENT_ID(_)                                   (((_) >> 0) & 0xFF)
        UINT64_t reserved1 : 24;

        /**
         * @brief Resource Monitoring ID
         *
         * [Bits 63:32] ID for monitoring hardware to report monitored data via IA32_QM_CTR.
         *
         * @remarks Bits [N+31:32] N = Ceil (Log2 (CPUID.(EAX= 0FH,ECX=0H).EBX[31:0] + 1))
         */
        UINT64_t resource_monitoring_id : 32;
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_BIT                    32
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_FLAG                   0xFFFFFFFF00000000
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_MASK                   0xFFFFFFFF
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID(_)                     (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64_t flags;
} ia32_qm_evtsel_register;


/**
 * Monitoring Counter Register.
 *
 * @remarks If ( CPUID.(EAX=07H, ECX=0):EBX.[12] = 1 )
 */
#define IA32_QM_CTR                                                  0x00000C8E
typedef union
{
    struct
    {
        /**
         * [Bits 61:0] Resource Monitored Data.
         */
        UINT64_t resource_monitored_data : 62;
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA_BIT                      0
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA_FLAG                     0x3FFFFFFFFFFFFFFF
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA_MASK                     0x3FFFFFFFFFFFFFFF
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA(_)                       (((_) >> 0) & 0x3FFFFFFFFFFFFFFF)

        /**
         * @brief Unavailable
         *
         * [Bit 62] If 1, indicates data for this RMID is not available or not monitored for this resource or RMID.
         */
        UINT64_t unavailable : 1;
#define IA32_QM_CTR_UNAVAILABLE_BIT                                  62
#define IA32_QM_CTR_UNAVAILABLE_FLAG                                 0x4000000000000000
#define IA32_QM_CTR_UNAVAILABLE_MASK                                 0x01
#define IA32_QM_CTR_UNAVAILABLE(_)                                   (((_) >> 62) & 0x01)

        /**
         * @brief Error
         *
         * [Bit 63] If 1, indicates an unsupported RMID or event type was written to IA32_PQR_QM_EVTSEL.
         */
        UINT64_t error : 1;
#define IA32_QM_CTR_ERROR_BIT                                        63
#define IA32_QM_CTR_ERROR_FLAG                                       0x8000000000000000
#define IA32_QM_CTR_ERROR_MASK                                       0x01
#define IA32_QM_CTR_ERROR(_)                                         (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} ia32_qm_ctr_register;


/**
 * Resource Association Register.
 *
 * @remarks If ( (CPUID.(EAX=07H, ECX=0):EBX[12] = 1) or (CPUID.(EAX=07H, ECX=0):EBX[15] = 1 ) )
 */
#define IA32_PQR_ASSOC                                               0x00000C8F
typedef union
{
    struct
    {
        /**
         * @brief Resource Monitoring ID <b>(R/W)</b>
         *
         * [Bits 31:0] ID for monitoring hardware to track internal operation, e.g., memory access.
         *
         * @remarks Bits [N-1:0] N = Ceil (Log2 (CPUID.(EAX= 0FH, ECX=0H).EBX[31:0] +1)) 31:N Reserved
         */
        UINT64_t resource_monitoring_id : 32;
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_BIT                    0
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_FLAG                   0xFFFFFFFF
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_MASK                   0xFFFFFFFF
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID(_)                     (((_) >> 0) & 0xFFFFFFFF)

        /**
         * @brief COS <b>(R/W)</b>
         *
         * [Bits 63:32] The class of service (COS) to enforce (on writes); returns the current COS when read.
         *
         * @remarks If ( CPUID.(EAX=07H, ECX=0):EBX.[15] = 1 )
         */
        UINT64_t cos : 32;
#define IA32_PQR_ASSOC_COS_BIT                                       32
#define IA32_PQR_ASSOC_COS_FLAG                                      0xFFFFFFFF00000000
#define IA32_PQR_ASSOC_COS_MASK                                      0xFFFFFFFF
#define IA32_PQR_ASSOC_COS(_)                                        (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64_t flags;
} ia32_pqr_assoc_register;


/**
 * Supervisor State of MPX Configuration.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0H):EBX[14] = 1)
 */
#define IA32_BNDCFGS                                                 0x00000D90
typedef union
{
    struct
    {
        /**
         * [Bit 0] Enable Intel MPX in supervisor mode.
         */
        UINT64_t enable : 1;
#define IA32_BNDCFGS_ENABLE_BIT                                      0
#define IA32_BNDCFGS_ENABLE_FLAG                                     0x01
#define IA32_BNDCFGS_ENABLE_MASK                                     0x01
#define IA32_BNDCFGS_ENABLE(_)                                       (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Preserve the bounds registers for near branch instructions in the absence of the BND prefix.
         */
        UINT64_t bnd_preserve : 1;
#define IA32_BNDCFGS_BND_PRESERVE_BIT                                1
#define IA32_BNDCFGS_BND_PRESERVE_FLAG                               0x02
#define IA32_BNDCFGS_BND_PRESERVE_MASK                               0x01
#define IA32_BNDCFGS_BND_PRESERVE(_)                                 (((_) >> 1) & 0x01)
        UINT64_t reserved1 : 10;

        /**
         * [Bits 63:12] Base Address of Bound Directory.
         */
        UINT64_t bound_directory_base_address : 52;
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_BIT                12
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_FLAG               0xFFFFFFFFFFFFF000
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_MASK               0xFFFFFFFFFFFFF
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS(_)                 (((_) >> 12) & 0xFFFFFFFFFFFFF)
    };

    UINT64_t flags;
} ia32_bndcfgs_register;


/**
 * Extended Supervisor State Mask.
 *
 * @remarks If ( CPUID.(0DH, 1):EAX.[3] = 1
 */
#define IA32_XSS                                                     0x00000DA0
typedef union
{
    struct
    {
        UINT64_t reserved1 : 8;

        /**
         * [Bit 8] Trace Packet Configuration State.
         */
        UINT64_t trace_packet_configuration_state : 1;
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_BIT                8
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_FLAG               0x100
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_MASK               0x01
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE(_)                 (((_) >> 8) & 0x01)
        UINT64_t reserved2 : 55;
    };

    UINT64_t flags;
} ia32_xss_register;


/**
 * Package Level Enable/disable HDC.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_PKG_HDC_CTL                                             0x00000DB0
typedef union
{
    struct
    {
        /**
         * @brief HDC_Pkg_Enable <b>(R/W)</b>
         *
         * [Bit 0] Force HDC idling or wake up HDC-idled logical processors in the package.
         *
         * @remarks If CPUID.06H:EAX.[13] = 1
         * @see Vol3B[14.5.2(Package level Enabling HDC)]
         */
        UINT64_t hdc_pkg_enable : 1;
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_BIT                          0
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_FLAG                         0x01
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_MASK                         0x01
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE(_)                           (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 63;
    };

    UINT64_t flags;
} ia32_pkg_hdc_ctl_register;


/**
 * Enable/disable HWP.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_PM_CTL1                                                 0x00000DB1
typedef union
{
    struct
    {
        /**
         * @brief HDC_Allow_Block <b>(R/W)</b>
         *
         * [Bit 0] Allow/Block this logical processor for package level HDC control.
         *
         * @remarks If CPUID.06H:EAX.[13] = 1
         * @see Vol3B[14.5.3(Logical-Processor Level HDC Control)]
         */
        UINT64_t hdc_allow_block : 1;
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK_BIT                             0
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK_FLAG                            0x01
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK_MASK                            0x01
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK(_)                              (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 63;
    };

    UINT64_t flags;
} ia32_pm_ctl1_register;


/**
 * Per-Logical_Processor HDC Idle Residency.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_THREAD_STALL                                            0x00000DB2
typedef struct
{
    /**
     * @brief Stall_Cycle_Cnt <b>(R/W)</b>
     *
     * Stalled cycles due to HDC forced idle on this logical processor.
     *
     * @remarks If CPUID.06H:EAX.[13] = 1
     * @see Vol3B[14.5.4.1(IA32_THREAD_STALL)]
     */
    UINT64_t stall_cycle_count;
} ia32_thread_stall_register;


/**
 * Extended Feature Enables.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_EFER                                                    0xC0000080
typedef union
{
    struct
    {
        /**
         * @brief SYSCALL Enable <b>(R/W)</b>
         *
         * [Bit 0] Enables SYSCALL/SYSRET instructions in 64-bit mode.
         */
        UINT64_t syscall_enable : 1;
#define IA32_EFER_SYSCALL_ENABLE_BIT                                 0
#define IA32_EFER_SYSCALL_ENABLE_FLAG                                0x01
#define IA32_EFER_SYSCALL_ENABLE_MASK                                0x01
#define IA32_EFER_SYSCALL_ENABLE(_)                                  (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 7;

        /**
         * @brief IA-32e Mode Enable <b>(R/W)</b>
         *
         * [Bit 8] Enables IA-32e mode operation.
         */
        UINT64_t ia32e_mode_enable : 1;
#define IA32_EFER_IA32E_MODE_ENABLE_BIT                              8
#define IA32_EFER_IA32E_MODE_ENABLE_FLAG                             0x100
#define IA32_EFER_IA32E_MODE_ENABLE_MASK                             0x01
#define IA32_EFER_IA32E_MODE_ENABLE(_)                               (((_) >> 8) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * @brief IA-32e Mode Active <b>(R)</b>
         *
         * [Bit 10] Indicates IA-32e mode is active when set.
         */
        UINT64_t ia32e_mode_active : 1;
#define IA32_EFER_IA32E_MODE_ACTIVE_BIT                              10
#define IA32_EFER_IA32E_MODE_ACTIVE_FLAG                             0x400
#define IA32_EFER_IA32E_MODE_ACTIVE_MASK                             0x01
#define IA32_EFER_IA32E_MODE_ACTIVE(_)                               (((_) >> 10) & 0x01)

        /**
         * [Bit 11] Execute Disable Bit Enable.
         */
        UINT64_t execute_disable_bit_enable : 1;
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_BIT                     11
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_FLAG                    0x800
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_MASK                    0x01
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE(_)                      (((_) >> 11) & 0x01)
        UINT64_t reserved3 : 52;
    };

    UINT64_t flags;
} ia32_efer_register;


/**
 * System Call Target Address.
 *
 * @remarks If CPUID.80000001:EDX.[29] = 1
 */
#define IA32_STAR                                                    0xC0000081

 /**
  * @brief IA-32e Mode System Call Target Address <b>(R/W)</b>
  *
  * Target RIP for the called procedure when SYSCALL is executed in 64-bit mode.
  *
  * @remarks If CPUID.80000001:EDX.[29] = 1
  */
#define IA32_LSTAR                                                   0xC0000082

  /**
   * @brief IA-32e Mode System Call Target Address <b>(R/W)</b>
   *
   * Not used, as the SYSCALL instruction is not recognized in compatibility mode.
   *
   * @remarks If CPUID.80000001:EDX.[29] = 1
   */
#define IA32_CSTAR                                                   0xC0000083

   /**
    * System Call Flag Mask.
    *
    * @remarks If CPUID.80000001:EDX.[29] = 1
    */
#define IA32_FMASK                                                   0xC0000084

    /**
     * Map of BASE Address of FS.
     *
     * @remarks If CPUID.80000001:EDX.[29] = 1
     */
#define IA32_FS_BASE                                                 0xC0000100

     /**
      * Map of BASE Address of GS.
      *
      * @remarks If CPUID.80000001:EDX.[29] = 1
      */
#define IA32_GS_BASE                                                 0xC0000101

      /**
       * Swap Target of BASE Address of GS.
       *
       * @remarks If CPUID.80000001:EDX.[29] = 1
       */
#define IA32_KERNEL_GS_BASE                                          0xC0000102

       /**
        * Auxiliary TSC.
        *
        * @remarks If CPUID.80000001H: EDX[27] = 1 or CPUID.(EAX=7,ECX=0):ECX[bit 22] = 1
        */
#define IA32_TSC_AUX                                                 0xC0000103
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] AUX. Auxiliary signature of TSC.
         */
        UINT64_t tsc_auxiliary_signature : 32;
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_BIT                     0
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_FLAG                    0xFFFFFFFF
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_MASK                    0xFFFFFFFF
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE(_)                      (((_) >> 0) & 0xFFFFFFFF)
        UINT64_t reserved1 : 32;
    };

    UINT64_t flags;
} ia32_tsc_aux_register;

/**
 * @}
 */

 /**
  * @defgroup paging \
  *           Paging
  * @{
  */
  /**
   * @defgroup paging_32 \
   *           32-Bit Paging
   *
   * A logical processor uses 32-bit paging if CR0.PG = 1 and CR4.PAE = 0. 32-bit paging translates 32-bit linear addresses
   * to 40-bit physical addresses. Although 40 bits corresponds to 1 TByte, linear addresses are limited to 32 bits; at most
   * 4 GBytes of linear-address space may be accessed at any given time.
   * 32-bit paging uses a hierarchy of paging structures to produce a translation for a linear address. CR3 is used to locate
   * the first paging-structure, the page directory. 32-bit paging may map linear addresses to either 4-KByte pages or
   * 4-MByte pages.
   *
   * @see Vol3A[4.5(4-LEVEL PAGING)] (reference)
   * @{
   */
   /**
    * @brief Format of a 32-Bit Page-Directory Entry that Maps a 4-MByte Page
    */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 4-MByte page.
         */
        UINT32_t present : 1;
#define PDE_4MB_32_PRESENT_BIT                                       0
#define PDE_4MB_32_PRESENT_FLAG                                      0x01
#define PDE_4MB_32_PRESENT_MASK                                      0x01
#define PDE_4MB_32_PRESENT(_)                                        (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT32_t write : 1;
#define PDE_4MB_32_WRITE_BIT                                         1
#define PDE_4MB_32_WRITE_FLAG                                        0x02
#define PDE_4MB_32_WRITE_MASK                                        0x01
#define PDE_4MB_32_WRITE(_)                                          (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT32_t supervisor : 1;
#define PDE_4MB_32_SUPERVISOR_BIT                                    2
#define PDE_4MB_32_SUPERVISOR_FLAG                                   0x04
#define PDE_4MB_32_SUPERVISOR_MASK                                   0x01
#define PDE_4MB_32_SUPERVISOR(_)                                     (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 4-MByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32_t page_level_write_through : 1;
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_BIT                      3
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                     0x08
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_MASK                     0x01
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH(_)                       (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 4-MByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32_t page_level_cache_disable : 1;
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_BIT                      4
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                     0x10
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_MASK                     0x01
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE(_)                       (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT32_t accessed : 1;
#define PDE_4MB_32_ACCESSED_BIT                                      5
#define PDE_4MB_32_ACCESSED_FLAG                                     0x20
#define PDE_4MB_32_ACCESSED_MASK                                     0x01
#define PDE_4MB_32_ACCESSED(_)                                       (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT32_t dirty : 1;
#define PDE_4MB_32_DIRTY_BIT                                         6
#define PDE_4MB_32_DIRTY_FLAG                                        0x40
#define PDE_4MB_32_DIRTY_MASK                                        0x01
#define PDE_4MB_32_DIRTY(_)                                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Page size; must be 1 (otherwise, this entry references a page table).
         */
        UINT32_t large_page : 1;
#define PDE_4MB_32_LARGE_PAGE_BIT                                    7
#define PDE_4MB_32_LARGE_PAGE_FLAG                                   0x80
#define PDE_4MB_32_LARGE_PAGE_MASK                                   0x01
#define PDE_4MB_32_LARGE_PAGE(_)                                     (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        UINT32_t global : 1;
#define PDE_4MB_32_GLOBAL_BIT                                        8
#define PDE_4MB_32_GLOBAL_FLAG                                       0x100
#define PDE_4MB_32_GLOBAL_MASK                                       0x01
#define PDE_4MB_32_GLOBAL(_)                                         (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT32_t ignored_1 : 3;
#define PDE_4MB_32_IGNORED_1_BIT                                     9
#define PDE_4MB_32_IGNORED_1_FLAG                                    0xE00
#define PDE_4MB_32_IGNORED_1_MASK                                    0x07
#define PDE_4MB_32_IGNORED_1(_)                                      (((_) >> 9) & 0x07)

        /**
         * [Bit 12] Indirectly determines the memory type used to access the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32_t pat : 1;
#define PDE_4MB_32_PAT_BIT                                           12
#define PDE_4MB_32_PAT_FLAG                                          0x1000
#define PDE_4MB_32_PAT_MASK                                          0x01
#define PDE_4MB_32_PAT(_)                                            (((_) >> 12) & 0x01)

        /**
         * [Bits 20:13] Bits (M-1):32 of physical address of the 4-MByte page referenced by this entry.
         */
        UINT32_t page_frame_number_low : 8;
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_BIT                         13
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_FLAG                        0x1FE000
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_MASK                        0xFF
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW(_)                          (((_) >> 13) & 0xFF)
        UINT32_t reserved1 : 1;

        /**
         * [Bits 31:22] Bits 31:22 of physical address of the 4-MByte page referenced by this entry.
         */
        UINT32_t page_frame_number_high : 10;
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_BIT                        22
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_FLAG                       0xFFC00000
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_MASK                       0x3FF
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH(_)                         (((_) >> 22) & 0x3FF)
    };

    UINT32_t flags;
} pde_4mb_32;

/**
 * @brief Format of a 32-Bit Page-Directory Entry that References a Page Table
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to reference a page table.
         */
        UINT32_t present : 1;
#define PDE_32_PRESENT_BIT                                           0
#define PDE_32_PRESENT_FLAG                                          0x01
#define PDE_32_PRESENT_MASK                                          0x01
#define PDE_32_PRESENT(_)                                            (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-MByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT32_t write : 1;
#define PDE_32_WRITE_BIT                                             1
#define PDE_32_WRITE_FLAG                                            0x02
#define PDE_32_WRITE_MASK                                            0x01
#define PDE_32_WRITE(_)                                              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-MByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT32_t supervisor : 1;
#define PDE_32_SUPERVISOR_BIT                                        2
#define PDE_32_SUPERVISOR_FLAG                                       0x04
#define PDE_32_SUPERVISOR_MASK                                       0x01
#define PDE_32_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page table referenced by this
         * entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32_t page_level_write_through : 1;
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page table referenced by this
         * entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32_t page_level_cache_disable : 1;
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT32_t accessed : 1;
#define PDE_32_ACCESSED_BIT                                          5
#define PDE_32_ACCESSED_FLAG                                         0x20
#define PDE_32_ACCESSED_MASK                                         0x01
#define PDE_32_ACCESSED(_)                                           (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Ignored.
         */
        UINT32_t ignored_1 : 1;
#define PDE_32_IGNORED_1_BIT                                         6
#define PDE_32_IGNORED_1_FLAG                                        0x40
#define PDE_32_IGNORED_1_MASK                                        0x01
#define PDE_32_IGNORED_1(_)                                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] If CR4.PSE = 1, must be 0 (otherwise, this entry maps a 4-MByte page); otherwise, ignored.
         */
        UINT32_t large_page : 1;
#define PDE_32_LARGE_PAGE_BIT                                        7
#define PDE_32_LARGE_PAGE_FLAG                                       0x80
#define PDE_32_LARGE_PAGE_MASK                                       0x01
#define PDE_32_LARGE_PAGE(_)                                         (((_) >> 7) & 0x01)

        /**
         * [Bits 11:8] Ignored.
         */
        UINT32_t ignored_2 : 4;
#define PDE_32_IGNORED_2_BIT                                         8
#define PDE_32_IGNORED_2_FLAG                                        0xF00
#define PDE_32_IGNORED_2_MASK                                        0x0F
#define PDE_32_IGNORED_2(_)                                          (((_) >> 8) & 0x0F)

        /**
         * [Bits 31:12] Physical address of 4-KByte aligned page table referenced by this entry.
         */
        UINT32_t page_frame_number : 20;
#define PDE_32_PAGE_FRAME_NUMBER_BIT                                 12
#define PDE_32_PAGE_FRAME_NUMBER_FLAG                                0xFFFFF000
#define PDE_32_PAGE_FRAME_NUMBER_MASK                                0xFFFFF
#define PDE_32_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFF)
    };

    UINT32_t flags;
} pde_32;

/**
 * @brief Format of a 32-Bit Page-Table Entry that Maps a 4-KByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 4-KByte page.
         */
        UINT32_t present : 1;
#define PTE_32_PRESENT_BIT                                           0
#define PTE_32_PRESENT_FLAG                                          0x01
#define PTE_32_PRESENT_MASK                                          0x01
#define PTE_32_PRESENT(_)                                            (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT32_t write : 1;
#define PTE_32_WRITE_BIT                                             1
#define PTE_32_WRITE_FLAG                                            0x02
#define PTE_32_WRITE_MASK                                            0x01
#define PTE_32_WRITE(_)                                              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT32_t supervisor : 1;
#define PTE_32_SUPERVISOR_BIT                                        2
#define PTE_32_SUPERVISOR_FLAG                                       0x04
#define PTE_32_SUPERVISOR_MASK                                       0x01
#define PTE_32_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 4-KByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32_t page_level_write_through : 1;
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 4-KByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32_t page_level_cache_disable : 1;
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT32_t accessed : 1;
#define PTE_32_ACCESSED_BIT                                          5
#define PTE_32_ACCESSED_FLAG                                         0x20
#define PTE_32_ACCESSED_MASK                                         0x01
#define PTE_32_ACCESSED(_)                                           (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT32_t dirty : 1;
#define PTE_32_DIRTY_BIT                                             6
#define PTE_32_DIRTY_FLAG                                            0x40
#define PTE_32_DIRTY_MASK                                            0x01
#define PTE_32_DIRTY(_)                                              (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Indirectly determines the memory type used to access the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32_t pat : 1;
#define PTE_32_PAT_BIT                                               7
#define PTE_32_PAT_FLAG                                              0x80
#define PTE_32_PAT_MASK                                              0x01
#define PTE_32_PAT(_)                                                (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        UINT32_t global : 1;
#define PTE_32_GLOBAL_BIT                                            8
#define PTE_32_GLOBAL_FLAG                                           0x100
#define PTE_32_GLOBAL_MASK                                           0x01
#define PTE_32_GLOBAL(_)                                             (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT32_t ignored_1 : 3;
#define PTE_32_IGNORED_1_BIT                                         9
#define PTE_32_IGNORED_1_FLAG                                        0xE00
#define PTE_32_IGNORED_1_MASK                                        0x07
#define PTE_32_IGNORED_1(_)                                          (((_) >> 9) & 0x07)

        /**
         * [Bits 31:12] Physical address of 4-KByte aligned page table referenced by this entry.
         */
        UINT32_t page_frame_number : 20;
#define PTE_32_PAGE_FRAME_NUMBER_BIT                                 12
#define PTE_32_PAGE_FRAME_NUMBER_FLAG                                0xFFFFF000
#define PTE_32_PAGE_FRAME_NUMBER_MASK                                0xFFFFF
#define PTE_32_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFF)
    };

    UINT32_t flags;
} pte_32;

/**
 * @brief Format of a common Page-Table Entry
 */
typedef union
{
    struct
    {
        UINT32_t present : 1;
#define PT_ENTRY_32_PRESENT_BIT                                      0
#define PT_ENTRY_32_PRESENT_FLAG                                     0x01
#define PT_ENTRY_32_PRESENT_MASK                                     0x01
#define PT_ENTRY_32_PRESENT(_)                                       (((_) >> 0) & 0x01)
        UINT32_t write : 1;
#define PT_ENTRY_32_WRITE_BIT                                        1
#define PT_ENTRY_32_WRITE_FLAG                                       0x02
#define PT_ENTRY_32_WRITE_MASK                                       0x01
#define PT_ENTRY_32_WRITE(_)                                         (((_) >> 1) & 0x01)
        UINT32_t supervisor : 1;
#define PT_ENTRY_32_SUPERVISOR_BIT                                   2
#define PT_ENTRY_32_SUPERVISOR_FLAG                                  0x04
#define PT_ENTRY_32_SUPERVISOR_MASK                                  0x01
#define PT_ENTRY_32_SUPERVISOR(_)                                    (((_) >> 2) & 0x01)
        UINT32_t page_level_write_through : 1;
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_BIT                     3
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                    0x08
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_MASK                    0x01
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH(_)                      (((_) >> 3) & 0x01)
        UINT32_t page_level_cache_disable : 1;
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_BIT                     4
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                    0x10
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_MASK                    0x01
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE(_)                      (((_) >> 4) & 0x01)
        UINT32_t accessed : 1;
#define PT_ENTRY_32_ACCESSED_BIT                                     5
#define PT_ENTRY_32_ACCESSED_FLAG                                    0x20
#define PT_ENTRY_32_ACCESSED_MASK                                    0x01
#define PT_ENTRY_32_ACCESSED(_)                                      (((_) >> 5) & 0x01)
        UINT32_t dirty : 1;
#define PT_ENTRY_32_DIRTY_BIT                                        6
#define PT_ENTRY_32_DIRTY_FLAG                                       0x40
#define PT_ENTRY_32_DIRTY_MASK                                       0x01
#define PT_ENTRY_32_DIRTY(_)                                         (((_) >> 6) & 0x01)
        UINT32_t large_page : 1;
#define PT_ENTRY_32_LARGE_PAGE_BIT                                   7
#define PT_ENTRY_32_LARGE_PAGE_FLAG                                  0x80
#define PT_ENTRY_32_LARGE_PAGE_MASK                                  0x01
#define PT_ENTRY_32_LARGE_PAGE(_)                                    (((_) >> 7) & 0x01)
        UINT32_t global : 1;
#define PT_ENTRY_32_GLOBAL_BIT                                       8
#define PT_ENTRY_32_GLOBAL_FLAG                                      0x100
#define PT_ENTRY_32_GLOBAL_MASK                                      0x01
#define PT_ENTRY_32_GLOBAL(_)                                        (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT32_t ignored_1 : 3;
#define PT_ENTRY_32_IGNORED_1_BIT                                    9
#define PT_ENTRY_32_IGNORED_1_FLAG                                   0xE00
#define PT_ENTRY_32_IGNORED_1_MASK                                   0x07
#define PT_ENTRY_32_IGNORED_1(_)                                     (((_) >> 9) & 0x07)

        /**
         * [Bits 31:12] Physical address of the 4-KByte page referenced by this entry.
         */
        UINT32_t page_frame_number : 20;
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_BIT                            12
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_FLAG                           0xFFFFF000
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_MASK                           0xFFFFF
#define PT_ENTRY_32_PAGE_FRAME_NUMBER(_)                             (((_) >> 12) & 0xFFFFF)
    };

    UINT32_t flags;
} pt_entry_32;

/**
 * @defgroup paging_structures_entry_count_32 \
 *           Paging structures entry counts
 *
 * Paging structures entry counts.
 * @{
 */
#define PDE_ENTRY_COUNT_32                                           0x00000400
#define PTE_ENTRY_COUNT_32                                           0x00000400
 /**
  * @}
  */

  /**
   * @}
   */

   /**
    * @defgroup paging_64 \
    *           64-Bit (4-Level) Paging
    *
    * A logical processor uses 4-level paging if CR0.PG = 1, CR4.PAE = 1, and IA32_EFER.LME = 1. With 4-level paging, linear
    * address are translated using a hierarchy of in-memory paging structures located using the contents of CR3. 4-level
    * paging translates 48-bit linear addresses to 52-bit physical addresses. Although 52 bits corresponds to 4 PBytes, linear
    * addresses are limited to 48 bits; at most 256 TBytes of linear-address space may be accessed at any given time.
    * 4-level paging uses a hierarchy of paging structures to produce a translation for a linear address. CR3 is used to
    * locate the first paging-structure, the PML4 table. Use of CR3 with 4-level paging depends on whether processcontext
    * identifiers (PCIDs) have been enabled by setting CR4.PCIDE.
    *
    * @see Vol3A[4.5(4-LEVEL PAGING)] (reference)
    * @{
    */
    /**
     * @brief Format of a 4-Level PML4 Entry (PML4E) that References a Page-Directory-Pointer Table
     */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to reference a page-directory-pointer table.
         */
        UINT64_t present : 1;
#define PML4E_64_PRESENT_BIT                                         0
#define PML4E_64_PRESENT_FLAG                                        0x01
#define PML4E_64_PRESENT_MASK                                        0x01
#define PML4E_64_PRESENT(_)                                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 512-GByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t write : 1;
#define PML4E_64_WRITE_BIT                                           1
#define PML4E_64_WRITE_FLAG                                          0x02
#define PML4E_64_WRITE_MASK                                          0x01
#define PML4E_64_WRITE(_)                                            (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 512-GByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t supervisor : 1;
#define PML4E_64_SUPERVISOR_BIT                                      2
#define PML4E_64_SUPERVISOR_FLAG                                     0x04
#define PML4E_64_SUPERVISOR_MASK                                     0x01
#define PML4E_64_SUPERVISOR(_)                                       (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page-directory-pointer table
         * referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_write_through : 1;
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_BIT                        3
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                       0x08
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_MASK                       0x01
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH(_)                         (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page-directory-pointer table
         * referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_cache_disable : 1;
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_BIT                        4
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                       0x10
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_MASK                       0x01
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE(_)                         (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64_t accessed : 1;
#define PML4E_64_ACCESSED_BIT                                        5
#define PML4E_64_ACCESSED_FLAG                                       0x20
#define PML4E_64_ACCESSED_MASK                                       0x01
#define PML4E_64_ACCESSED(_)                                         (((_) >> 5) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * [Bit 7] Reserved (must be 0).
         */
        UINT64_t must_be_zero : 1;
#define PML4E_64_MUST_BE_ZERO_BIT                                    7
#define PML4E_64_MUST_BE_ZERO_FLAG                                   0x80
#define PML4E_64_MUST_BE_ZERO_MASK                                   0x01
#define PML4E_64_MUST_BE_ZERO(_)                                     (((_) >> 7) & 0x01)

        /**
         * [Bits 11:8] Ignored.
         */
        UINT64_t ignored_1 : 4;
#define PML4E_64_IGNORED_1_BIT                                       8
#define PML4E_64_IGNORED_1_FLAG                                      0xF00
#define PML4E_64_IGNORED_1_MASK                                      0x0F
#define PML4E_64_IGNORED_1(_)                                        (((_) >> 8) & 0x0F)

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned page-directory-pointer table referenced by this entry.
         */
        UINT64_t page_frame_number : 36;
#define PML4E_64_PAGE_FRAME_NUMBER_BIT                               12
#define PML4E_64_PAGE_FRAME_NUMBER_FLAG                              0xFFFFFFFFF000
#define PML4E_64_PAGE_FRAME_NUMBER_MASK                              0xFFFFFFFFF
#define PML4E_64_PAGE_FRAME_NUMBER(_)                                (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved2 : 4;

        /**
         * [Bits 62:52] Ignored.
         */
        UINT64_t ignored_2 : 11;
#define PML4E_64_IGNORED_2_BIT                                       52
#define PML4E_64_IGNORED_2_FLAG                                      0x7FF0000000000000
#define PML4E_64_IGNORED_2_MASK                                      0x7FF
#define PML4E_64_IGNORED_2(_)                                        (((_) >> 52) & 0x7FF)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 512-GByte region
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t execute_disable : 1;
#define PML4E_64_EXECUTE_DISABLE_BIT                                 63
#define PML4E_64_EXECUTE_DISABLE_FLAG                                0x8000000000000000
#define PML4E_64_EXECUTE_DISABLE_MASK                                0x01
#define PML4E_64_EXECUTE_DISABLE(_)                                  (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} pml4e;

/**
 * @brief Format of a 4-Level Page-Directory-Pointer-Table Entry (PDPTE) that Maps a 1-GByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 1-GByte page.
         */
        UINT64_t present : 1;
#define PDPTE_1GB_64_PRESENT_BIT                                     0
#define PDPTE_1GB_64_PRESENT_FLAG                                    0x01
#define PDPTE_1GB_64_PRESENT_MASK                                    0x01
#define PDPTE_1GB_64_PRESENT(_)                                      (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 1-GByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t write : 1;
#define PDPTE_1GB_64_WRITE_BIT                                       1
#define PDPTE_1GB_64_WRITE_FLAG                                      0x02
#define PDPTE_1GB_64_WRITE_MASK                                      0x01
#define PDPTE_1GB_64_WRITE(_)                                        (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 1-GByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t supervisor : 1;
#define PDPTE_1GB_64_SUPERVISOR_BIT                                  2
#define PDPTE_1GB_64_SUPERVISOR_FLAG                                 0x04
#define PDPTE_1GB_64_SUPERVISOR_MASK                                 0x01
#define PDPTE_1GB_64_SUPERVISOR(_)                                   (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 1-GByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_write_through : 1;
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_BIT                    3
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                   0x08
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_MASK                   0x01
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH(_)                     (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 1-GByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_cache_disable : 1;
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_BIT                    4
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                   0x10
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_MASK                   0x01
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE(_)                     (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 1-GByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64_t accessed : 1;
#define PDPTE_1GB_64_ACCESSED_BIT                                    5
#define PDPTE_1GB_64_ACCESSED_FLAG                                   0x20
#define PDPTE_1GB_64_ACCESSED_MASK                                   0x01
#define PDPTE_1GB_64_ACCESSED(_)                                     (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 1-GByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64_t dirty : 1;
#define PDPTE_1GB_64_DIRTY_BIT                                       6
#define PDPTE_1GB_64_DIRTY_FLAG                                      0x40
#define PDPTE_1GB_64_DIRTY_MASK                                      0x01
#define PDPTE_1GB_64_DIRTY(_)                                        (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Page size; must be 1 (otherwise, this entry references a page directory).
         */
        UINT64_t large_page : 1;
#define PDPTE_1GB_64_LARGE_PAGE_BIT                                  7
#define PDPTE_1GB_64_LARGE_PAGE_FLAG                                 0x80
#define PDPTE_1GB_64_LARGE_PAGE_MASK                                 0x01
#define PDPTE_1GB_64_LARGE_PAGE(_)                                   (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        UINT64_t global : 1;
#define PDPTE_1GB_64_GLOBAL_BIT                                      8
#define PDPTE_1GB_64_GLOBAL_FLAG                                     0x100
#define PDPTE_1GB_64_GLOBAL_MASK                                     0x01
#define PDPTE_1GB_64_GLOBAL(_)                                       (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT64_t ignored_1 : 3;
#define PDPTE_1GB_64_IGNORED_1_BIT                                   9
#define PDPTE_1GB_64_IGNORED_1_FLAG                                  0xE00
#define PDPTE_1GB_64_IGNORED_1_MASK                                  0x07
#define PDPTE_1GB_64_IGNORED_1(_)                                    (((_) >> 9) & 0x07)

        /**
         * [Bit 12] Indirectly determines the memory type used to access the 1-GByte page referenced by this entry.
         *
         * @note The PAT is supported on all processors that support 4-level paging.
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t pat : 1;
#define PDPTE_1GB_64_PAT_BIT                                         12
#define PDPTE_1GB_64_PAT_FLAG                                        0x1000
#define PDPTE_1GB_64_PAT_MASK                                        0x01
#define PDPTE_1GB_64_PAT(_)                                          (((_) >> 12) & 0x01)
        UINT64_t reserved1 : 17;

        /**
         * [Bits 47:30] Physical address of the 1-GByte page referenced by this entry.
         */
        UINT64_t page_frame_number : 18;
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_BIT                           30
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_FLAG                          0xFFFFC0000000
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_MASK                          0x3FFFF
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER(_)                            (((_) >> 30) & 0x3FFFF)
        UINT64_t reserved2 : 4;

        /**
         * [Bits 58:52] Ignored.
         */
        UINT64_t ignored_2 : 7;
#define PDPTE_1GB_64_IGNORED_2_BIT                                   52
#define PDPTE_1GB_64_IGNORED_2_FLAG                                  0x7F0000000000000
#define PDPTE_1GB_64_IGNORED_2_MASK                                  0x7F
#define PDPTE_1GB_64_IGNORED_2(_)                                    (((_) >> 52) & 0x7F)

        /**
         * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the page; ignored otherwise.
         *
         * @see Vol3A[4.6.2(Protection Keys)]
         */
        UINT64_t protection_key : 4;
#define PDPTE_1GB_64_PROTECTION_KEY_BIT                              59
#define PDPTE_1GB_64_PROTECTION_KEY_FLAG                             0x7800000000000000
#define PDPTE_1GB_64_PROTECTION_KEY_MASK                             0x0F
#define PDPTE_1GB_64_PROTECTION_KEY(_)                               (((_) >> 59) & 0x0F)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 1-GByte page
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t execute_disable : 1;
#define PDPTE_1GB_64_EXECUTE_DISABLE_BIT                             63
#define PDPTE_1GB_64_EXECUTE_DISABLE_FLAG                            0x8000000000000000
#define PDPTE_1GB_64_EXECUTE_DISABLE_MASK                            0x01
#define PDPTE_1GB_64_EXECUTE_DISABLE(_)                              (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} pdpte_1gb_64;

/**
 * @brief Format of a 4-Level Page-Directory-Pointer-Table Entry (PDPTE) that References a Page Directory
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to reference a page directory.
         */
        UINT64_t present : 1;
#define PDPTE_64_PRESENT_BIT                                         0
#define PDPTE_64_PRESENT_FLAG                                        0x01
#define PDPTE_64_PRESENT_MASK                                        0x01
#define PDPTE_64_PRESENT(_)                                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 1-GByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t write : 1;
#define PDPTE_64_WRITE_BIT                                           1
#define PDPTE_64_WRITE_FLAG                                          0x02
#define PDPTE_64_WRITE_MASK                                          0x01
#define PDPTE_64_WRITE(_)                                            (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 1-GByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t supervisor : 1;
#define PDPTE_64_SUPERVISOR_BIT                                      2
#define PDPTE_64_SUPERVISOR_FLAG                                     0x04
#define PDPTE_64_SUPERVISOR_MASK                                     0x01
#define PDPTE_64_SUPERVISOR(_)                                       (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page directory referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_write_through : 1;
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_BIT                        3
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                       0x08
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_MASK                       0x01
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH(_)                         (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page directory referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_cache_disable : 1;
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_BIT                        4
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                       0x10
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_MASK                       0x01
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE(_)                         (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64_t accessed : 1;
#define PDPTE_64_ACCESSED_BIT                                        5
#define PDPTE_64_ACCESSED_FLAG                                       0x20
#define PDPTE_64_ACCESSED_MASK                                       0x01
#define PDPTE_64_ACCESSED(_)                                         (((_) >> 5) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * [Bit 7] Page size; must be 0 (otherwise, this entry maps a 1-GByte page).
         */
        UINT64_t large_page : 1;
#define PDPTE_64_LARGE_PAGE_BIT                                      7
#define PDPTE_64_LARGE_PAGE_FLAG                                     0x80
#define PDPTE_64_LARGE_PAGE_MASK                                     0x01
#define PDPTE_64_LARGE_PAGE(_)                                       (((_) >> 7) & 0x01)

        /**
         * [Bits 11:8] Ignored.
         */
        UINT64_t ignored_1 : 4;
#define PDPTE_64_IGNORED_1_BIT                                       8
#define PDPTE_64_IGNORED_1_FLAG                                      0xF00
#define PDPTE_64_IGNORED_1_MASK                                      0x0F
#define PDPTE_64_IGNORED_1(_)                                        (((_) >> 8) & 0x0F)

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned page directory referenced by this entry.
         */
        UINT64_t page_frame_number : 36;
#define PDPTE_64_PAGE_FRAME_NUMBER_BIT                               12
#define PDPTE_64_PAGE_FRAME_NUMBER_FLAG                              0xFFFFFFFFF000
#define PDPTE_64_PAGE_FRAME_NUMBER_MASK                              0xFFFFFFFFF
#define PDPTE_64_PAGE_FRAME_NUMBER(_)                                (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved2 : 4;

        /**
         * [Bits 62:52] Ignored.
         */
        UINT64_t ignored_2 : 11;
#define PDPTE_64_IGNORED_2_BIT                                       52
#define PDPTE_64_IGNORED_2_FLAG                                      0x7FF0000000000000
#define PDPTE_64_IGNORED_2_MASK                                      0x7FF
#define PDPTE_64_IGNORED_2(_)                                        (((_) >> 52) & 0x7FF)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 1-GByte region
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t execute_disable : 1;
#define PDPTE_64_EXECUTE_DISABLE_BIT                                 63
#define PDPTE_64_EXECUTE_DISABLE_FLAG                                0x8000000000000000
#define PDPTE_64_EXECUTE_DISABLE_MASK                                0x01
#define PDPTE_64_EXECUTE_DISABLE(_)                                  (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} pdpte;

/**
 * @brief Format of a 4-Level Page-Directory Entry that Maps a 2-MByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 2-MByte page.
         */
        UINT64_t present : 1;
#define PDE_2MB_64_PRESENT_BIT                                       0
#define PDE_2MB_64_PRESENT_FLAG                                      0x01
#define PDE_2MB_64_PRESENT_MASK                                      0x01
#define PDE_2MB_64_PRESENT(_)                                        (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 2-MByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t write : 1;
#define PDE_2MB_64_WRITE_BIT                                         1
#define PDE_2MB_64_WRITE_FLAG                                        0x02
#define PDE_2MB_64_WRITE_MASK                                        0x01
#define PDE_2MB_64_WRITE(_)                                          (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 2-MByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t supervisor : 1;
#define PDE_2MB_64_SUPERVISOR_BIT                                    2
#define PDE_2MB_64_SUPERVISOR_FLAG                                   0x04
#define PDE_2MB_64_SUPERVISOR_MASK                                   0x01
#define PDE_2MB_64_SUPERVISOR(_)                                     (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 2-MByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_write_through : 1;
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_BIT                      3
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                     0x08
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_MASK                     0x01
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH(_)                       (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 2-MByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_cache_disable : 1;
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_BIT                      4
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                     0x10
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_MASK                     0x01
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE(_)                       (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 2-MByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64_t accessed : 1;
#define PDE_2MB_64_ACCESSED_BIT                                      5
#define PDE_2MB_64_ACCESSED_FLAG                                     0x20
#define PDE_2MB_64_ACCESSED_MASK                                     0x01
#define PDE_2MB_64_ACCESSED(_)                                       (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 2-MByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64_t dirty : 1;
#define PDE_2MB_64_DIRTY_BIT                                         6
#define PDE_2MB_64_DIRTY_FLAG                                        0x40
#define PDE_2MB_64_DIRTY_MASK                                        0x01
#define PDE_2MB_64_DIRTY(_)                                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Page size; must be 1 (otherwise, this entry references a page directory).
         */
        UINT64_t large_page : 1;
#define PDE_2MB_64_LARGE_PAGE_BIT                                    7
#define PDE_2MB_64_LARGE_PAGE_FLAG                                   0x80
#define PDE_2MB_64_LARGE_PAGE_MASK                                   0x01
#define PDE_2MB_64_LARGE_PAGE(_)                                     (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        UINT64_t global : 1;
#define PDE_2MB_64_GLOBAL_BIT                                        8
#define PDE_2MB_64_GLOBAL_FLAG                                       0x100
#define PDE_2MB_64_GLOBAL_MASK                                       0x01
#define PDE_2MB_64_GLOBAL(_)                                         (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT64_t ignored_1 : 3;
#define PDE_2MB_64_IGNORED_1_BIT                                     9
#define PDE_2MB_64_IGNORED_1_FLAG                                    0xE00
#define PDE_2MB_64_IGNORED_1_MASK                                    0x07
#define PDE_2MB_64_IGNORED_1(_)                                      (((_) >> 9) & 0x07)

        /**
         * [Bit 12] Indirectly determines the memory type used to access the 2-MByte page referenced by this entry.
         *
         * @note The PAT is supported on all processors that support 4-level paging.
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t pat : 1;
#define PDE_2MB_64_PAT_BIT                                           12
#define PDE_2MB_64_PAT_FLAG                                          0x1000
#define PDE_2MB_64_PAT_MASK                                          0x01
#define PDE_2MB_64_PAT(_)                                            (((_) >> 12) & 0x01)
        UINT64_t reserved1 : 8;

        /**
         * [Bits 47:21] Physical address of the 2-MByte page referenced by this entry.
         */
        UINT64_t page_frame_number : 27;
#define PDE_2MB_64_PAGE_FRAME_NUMBER_BIT                             21
#define PDE_2MB_64_PAGE_FRAME_NUMBER_FLAG                            0xFFFFFFE00000
#define PDE_2MB_64_PAGE_FRAME_NUMBER_MASK                            0x7FFFFFF
#define PDE_2MB_64_PAGE_FRAME_NUMBER(_)                              (((_) >> 21) & 0x7FFFFFF)
        UINT64_t reserved2 : 4;

        /**
         * [Bits 58:52] Ignored.
         */
        UINT64_t ignored_2 : 7;
#define PDE_2MB_64_IGNORED_2_BIT                                     52
#define PDE_2MB_64_IGNORED_2_FLAG                                    0x7F0000000000000
#define PDE_2MB_64_IGNORED_2_MASK                                    0x7F
#define PDE_2MB_64_IGNORED_2(_)                                      (((_) >> 52) & 0x7F)

        /**
         * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the page; ignored otherwise.
         *
         * @see Vol3A[4.6.2(Protection Keys)]
         */
        UINT64_t protection_key : 4;
#define PDE_2MB_64_PROTECTION_KEY_BIT                                59
#define PDE_2MB_64_PROTECTION_KEY_FLAG                               0x7800000000000000
#define PDE_2MB_64_PROTECTION_KEY_MASK                               0x0F
#define PDE_2MB_64_PROTECTION_KEY(_)                                 (((_) >> 59) & 0x0F)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 2-MByte page
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t execute_disable : 1;
#define PDE_2MB_64_EXECUTE_DISABLE_BIT                               63
#define PDE_2MB_64_EXECUTE_DISABLE_FLAG                              0x8000000000000000
#define PDE_2MB_64_EXECUTE_DISABLE_MASK                              0x01
#define PDE_2MB_64_EXECUTE_DISABLE(_)                                (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} pde_2mb_64;

/**
 * @brief Format of a 4-Level Page-Directory Entry that References a Page Table
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to reference a page table.
         */
        UINT64_t present : 1;
#define PDE_64_PRESENT_BIT                                           0
#define PDE_64_PRESENT_FLAG                                          0x01
#define PDE_64_PRESENT_MASK                                          0x01
#define PDE_64_PRESENT(_)                                            (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 2-MByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t write : 1;
#define PDE_64_WRITE_BIT                                             1
#define PDE_64_WRITE_FLAG                                            0x02
#define PDE_64_WRITE_MASK                                            0x01
#define PDE_64_WRITE(_)                                              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 2-MByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t supervisor : 1;
#define PDE_64_SUPERVISOR_BIT                                        2
#define PDE_64_SUPERVISOR_FLAG                                       0x04
#define PDE_64_SUPERVISOR_MASK                                       0x01
#define PDE_64_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page table referenced by this
         * entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_write_through : 1;
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page table referenced by this
         * entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_cache_disable : 1;
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64_t accessed : 1;
#define PDE_64_ACCESSED_BIT                                          5
#define PDE_64_ACCESSED_FLAG                                         0x20
#define PDE_64_ACCESSED_MASK                                         0x01
#define PDE_64_ACCESSED(_)                                           (((_) >> 5) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * [Bit 7] Page size; must be 0 (otherwise, this entry maps a 2-MByte page).
         */
        UINT64_t large_page : 1;
#define PDE_64_LARGE_PAGE_BIT                                        7
#define PDE_64_LARGE_PAGE_FLAG                                       0x80
#define PDE_64_LARGE_PAGE_MASK                                       0x01
#define PDE_64_LARGE_PAGE(_)                                         (((_) >> 7) & 0x01)

        /**
         * [Bits 11:8] Ignored.
         */
        UINT64_t ignored_1 : 4;
#define PDE_64_IGNORED_1_BIT                                         8
#define PDE_64_IGNORED_1_FLAG                                        0xF00
#define PDE_64_IGNORED_1_MASK                                        0x0F
#define PDE_64_IGNORED_1(_)                                          (((_) >> 8) & 0x0F)

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned page table referenced by this entry.
         */
        UINT64_t page_frame_number : 36;
#define PDE_64_PAGE_FRAME_NUMBER_BIT                                 12
#define PDE_64_PAGE_FRAME_NUMBER_FLAG                                0xFFFFFFFFF000
#define PDE_64_PAGE_FRAME_NUMBER_MASK                                0xFFFFFFFFF
#define PDE_64_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved2 : 4;

        /**
         * [Bits 62:52] Ignored.
         */
        UINT64_t ignored_2 : 11;
#define PDE_64_IGNORED_2_BIT                                         52
#define PDE_64_IGNORED_2_FLAG                                        0x7FF0000000000000
#define PDE_64_IGNORED_2_MASK                                        0x7FF
#define PDE_64_IGNORED_2(_)                                          (((_) >> 52) & 0x7FF)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 2-MByte region
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t execute_disable : 1;
#define PDE_64_EXECUTE_DISABLE_BIT                                   63
#define PDE_64_EXECUTE_DISABLE_FLAG                                  0x8000000000000000
#define PDE_64_EXECUTE_DISABLE_MASK                                  0x01
#define PDE_64_EXECUTE_DISABLE(_)                                    (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} pde;

/**
 * @brief Format of a 4-Level Page-Table Entry that Maps a 4-KByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 4-KByte page.
         */
        UINT64_t present : 1;
#define PTE_64_PRESENT_BIT                                           0
#define PTE_64_PRESENT_FLAG                                          0x01
#define PTE_64_PRESENT_MASK                                          0x01
#define PTE_64_PRESENT(_)                                            (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t write : 1;
#define PTE_64_WRITE_BIT                                             1
#define PTE_64_WRITE_FLAG                                            0x02
#define PTE_64_WRITE_MASK                                            0x01
#define PTE_64_WRITE(_)                                              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t supervisor : 1;
#define PTE_64_SUPERVISOR_BIT                                        2
#define PTE_64_SUPERVISOR_FLAG                                       0x04
#define PTE_64_SUPERVISOR_MASK                                       0x01
#define PTE_64_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 4-KByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_write_through : 1;
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 4-KByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_cache_disable : 1;
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64_t accessed : 1;
#define PTE_64_ACCESSED_BIT                                          5
#define PTE_64_ACCESSED_FLAG                                         0x20
#define PTE_64_ACCESSED_MASK                                         0x01
#define PTE_64_ACCESSED(_)                                           (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64_t dirty : 1;
#define PTE_64_DIRTY_BIT                                             6
#define PTE_64_DIRTY_FLAG                                            0x40
#define PTE_64_DIRTY_MASK                                            0x01
#define PTE_64_DIRTY(_)                                              (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Indirectly determines the memory type used to access the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t pat : 1;
#define PTE_64_PAT_BIT                                               7
#define PTE_64_PAT_FLAG                                              0x80
#define PTE_64_PAT_MASK                                              0x01
#define PTE_64_PAT(_)                                                (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        UINT64_t global : 1;
#define PTE_64_GLOBAL_BIT                                            8
#define PTE_64_GLOBAL_FLAG                                           0x100
#define PTE_64_GLOBAL_MASK                                           0x01
#define PTE_64_GLOBAL(_)                                             (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT64_t ignored_1 : 3;
#define PTE_64_IGNORED_1_BIT                                         9
#define PTE_64_IGNORED_1_FLAG                                        0xE00
#define PTE_64_IGNORED_1_MASK                                        0x07
#define PTE_64_IGNORED_1(_)                                          (((_) >> 9) & 0x07)

        /**
         * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
         */
        UINT64_t page_frame_number : 36;
#define PTE_64_PAGE_FRAME_NUMBER_BIT                                 12
#define PTE_64_PAGE_FRAME_NUMBER_FLAG                                0xFFFFFFFFF000
#define PTE_64_PAGE_FRAME_NUMBER_MASK                                0xFFFFFFFFF
#define PTE_64_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved1 : 4;

        /**
         * [Bits 58:52] Ignored.
         */
        UINT64_t ignored_2 : 7;
#define PTE_64_IGNORED_2_BIT                                         52
#define PTE_64_IGNORED_2_FLAG                                        0x7F0000000000000
#define PTE_64_IGNORED_2_MASK                                        0x7F
#define PTE_64_IGNORED_2(_)                                          (((_) >> 52) & 0x7F)

        /**
         * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the page; ignored otherwise.
         *
         * @see Vol3A[4.6.2(Protection Keys)]
         */
        UINT64_t protection_key : 4;
#define PTE_64_PROTECTION_KEY_BIT                                    59
#define PTE_64_PROTECTION_KEY_FLAG                                   0x7800000000000000
#define PTE_64_PROTECTION_KEY_MASK                                   0x0F
#define PTE_64_PROTECTION_KEY(_)                                     (((_) >> 59) & 0x0F)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 1-GByte page
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t execute_disable : 1;
#define PTE_64_EXECUTE_DISABLE_BIT                                   63
#define PTE_64_EXECUTE_DISABLE_FLAG                                  0x8000000000000000
#define PTE_64_EXECUTE_DISABLE_MASK                                  0x01
#define PTE_64_EXECUTE_DISABLE(_)                                    (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} pte;

/**
 * @brief Format of a common Page-Table Entry
 */
typedef union
{
    struct
    {
        UINT64_t present : 1;
#define PT_ENTRY_64_PRESENT_BIT                                      0
#define PT_ENTRY_64_PRESENT_FLAG                                     0x01
#define PT_ENTRY_64_PRESENT_MASK                                     0x01
#define PT_ENTRY_64_PRESENT(_)                                       (((_) >> 0) & 0x01)
        UINT64_t write : 1;
#define PT_ENTRY_64_WRITE_BIT                                        1
#define PT_ENTRY_64_WRITE_FLAG                                       0x02
#define PT_ENTRY_64_WRITE_MASK                                       0x01
#define PT_ENTRY_64_WRITE(_)                                         (((_) >> 1) & 0x01)
        UINT64_t supervisor : 1;
#define PT_ENTRY_64_SUPERVISOR_BIT                                   2
#define PT_ENTRY_64_SUPERVISOR_FLAG                                  0x04
#define PT_ENTRY_64_SUPERVISOR_MASK                                  0x01
#define PT_ENTRY_64_SUPERVISOR(_)                                    (((_) >> 2) & 0x01)
        UINT64_t page_level_write_through : 1;
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_BIT                     3
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                    0x08
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_MASK                    0x01
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH(_)                      (((_) >> 3) & 0x01)
        UINT64_t page_level_cache_disable : 1;
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_BIT                     4
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                    0x10
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_MASK                    0x01
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE(_)                      (((_) >> 4) & 0x01)
        UINT64_t accessed : 1;
#define PT_ENTRY_64_ACCESSED_BIT                                     5
#define PT_ENTRY_64_ACCESSED_FLAG                                    0x20
#define PT_ENTRY_64_ACCESSED_MASK                                    0x01
#define PT_ENTRY_64_ACCESSED(_)                                      (((_) >> 5) & 0x01)
        UINT64_t dirty : 1;
#define PT_ENTRY_64_DIRTY_BIT                                        6
#define PT_ENTRY_64_DIRTY_FLAG                                       0x40
#define PT_ENTRY_64_DIRTY_MASK                                       0x01
#define PT_ENTRY_64_DIRTY(_)                                         (((_) >> 6) & 0x01)
        UINT64_t large_page : 1;
#define PT_ENTRY_64_LARGE_PAGE_BIT                                   7
#define PT_ENTRY_64_LARGE_PAGE_FLAG                                  0x80
#define PT_ENTRY_64_LARGE_PAGE_MASK                                  0x01
#define PT_ENTRY_64_LARGE_PAGE(_)                                    (((_) >> 7) & 0x01)
        UINT64_t global : 1;
#define PT_ENTRY_64_GLOBAL_BIT                                       8
#define PT_ENTRY_64_GLOBAL_FLAG                                      0x100
#define PT_ENTRY_64_GLOBAL_MASK                                      0x01
#define PT_ENTRY_64_GLOBAL(_)                                        (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT64_t ignored_1 : 3;
#define PT_ENTRY_64_IGNORED_1_BIT                                    9
#define PT_ENTRY_64_IGNORED_1_FLAG                                   0xE00
#define PT_ENTRY_64_IGNORED_1_MASK                                   0x07
#define PT_ENTRY_64_IGNORED_1(_)                                     (((_) >> 9) & 0x07)

        /**
         * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
         */
        UINT64_t page_frame_number : 36;
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_BIT                            12
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_FLAG                           0xFFFFFFFFF000
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_MASK                           0xFFFFFFFFF
#define PT_ENTRY_64_PAGE_FRAME_NUMBER(_)                             (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved1 : 4;

        /**
         * [Bits 58:52] Ignored.
         */
        UINT64_t ignored_2 : 7;
#define PT_ENTRY_64_IGNORED_2_BIT                                    52
#define PT_ENTRY_64_IGNORED_2_FLAG                                   0x7F0000000000000
#define PT_ENTRY_64_IGNORED_2_MASK                                   0x7F
#define PT_ENTRY_64_IGNORED_2(_)                                     (((_) >> 52) & 0x7F)
        UINT64_t protection_key : 4;
#define PT_ENTRY_64_PROTECTION_KEY_BIT                               59
#define PT_ENTRY_64_PROTECTION_KEY_FLAG                              0x7800000000000000
#define PT_ENTRY_64_PROTECTION_KEY_MASK                              0x0F
#define PT_ENTRY_64_PROTECTION_KEY(_)                                (((_) >> 59) & 0x0F)
        UINT64_t execute_disable : 1;
#define PT_ENTRY_64_EXECUTE_DISABLE_BIT                              63
#define PT_ENTRY_64_EXECUTE_DISABLE_FLAG                             0x8000000000000000
#define PT_ENTRY_64_EXECUTE_DISABLE_MASK                             0x01
#define PT_ENTRY_64_EXECUTE_DISABLE(_)                               (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} pt_entry_64;

/**
 * @defgroup paging_structures_entry_count_64 \
 *           Paging structures entry counts
 *
 * Paging structures entry counts.
 * @{
 */
#define PML4E_ENTRY_COUNT_64                                         0x00000200
#define PDPTE_ENTRY_COUNT_64                                         0x00000200
#define PDE_ENTRY_COUNT_64                                           0x00000200
#define PTE_ENTRY_COUNT_64                                           0x00000200
 /**
  * @}
  */

  /**
   * @}
   */

   /**
    * @}
    */

    /**
     * @defgroup segment_descriptors \
     *           Segment descriptors
     * @{
     */
     /**
      * @brief Pseudo-Descriptor Format (32-bit)
      *
      * @see Vol3A[3.5.1(Segment Descriptor Tables)] (reference)
      */
#pragma pack(push, 1)
typedef struct
{
    /**
     * Limit.
     */
    UINT16_t limit;

    /**
     * Base Address.
     */
    UINT32_t base_address;
} segment_descriptor_register_32;
#pragma pack(pop)

/**
 * @brief Pseudo-Descriptor Format (64-bit)
 *
 * @see Vol3A[3.5.1(Segment Descriptor Tables)] (reference)
 */
#pragma pack(push, 1)
typedef struct
{
    /**
     * Limit.
     */
    UINT16_t limit;

    /**
     * Base Address.
     */
    UINT64_t base_address;
} segment_descriptor_register_64;
#pragma pack(pop)

/**
 * @brief Segment access rights
 *
 * @see Vol2A[3.2(Instructions (A-L) | LAR-Load Access Rights Byte)] (reference)
 */
typedef union
{
    struct
    {
        UINT32_t reserved1 : 8;

        /**
         * @brief Type field
         *
         * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can be made to the segment and the
         * direction of growth. The interpretation of this field depends on whether the descriptor type flag specifies an
         * application (code or data) descriptor or a system descriptor. The encoding of the type field is different for code,
         * data, and system descriptors.
         *
         * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
         */
        UINT32_t type : 4;
#define SEGMENT_ACCESS_RIGHTS_TYPE_BIT                               8
#define SEGMENT_ACCESS_RIGHTS_TYPE_FLAG                              0xF00
#define SEGMENT_ACCESS_RIGHTS_TYPE_MASK                              0x0F
#define SEGMENT_ACCESS_RIGHTS_TYPE(_)                                (((_) >> 8) & 0x0F)

        /**
         * @brief S (descriptor type) flag
         *
         * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear) or a code or data segment (S
         * flag is set).
         */
        UINT32_t descriptor_type : 1;
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_BIT                    12
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_FLAG                   0x1000
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_MASK                   0x01
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE(_)                     (((_) >> 12) & 0x01)

        /**
         * @brief DPL (descriptor privilege level) field
         *
         * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range from 0 to 3, with 0 being the
         * most privileged level. The DPL is used to control access to the segment. See Section 5.5, "Privilege Levels", for a
         * description of the relationship of the DPL to the CPL of the executing code segment and the RPL of a segment selector.
         */
        UINT32_t descriptor_privilege_level : 2;
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_BIT         13
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_FLAG        0x6000
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_MASK        0x03
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL(_)          (((_) >> 13) & 0x03)

        /**
         * @brief P (segment-present) flag
         *
         * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear). If this flag is clear, the
         * processor generates a segment-not-present exception (\#NP) when a segment selector that points to the segment descriptor
         * is loaded into a segment register. Memory management software can use this flag to control which segments are actually
         * loaded into physical memory at a given time. It offers a control in addition to paging for managing virtual memory.
         */
        UINT32_t present : 1;
#define SEGMENT_ACCESS_RIGHTS_PRESENT_BIT                            15
#define SEGMENT_ACCESS_RIGHTS_PRESENT_FLAG                           0x8000
#define SEGMENT_ACCESS_RIGHTS_PRESENT_MASK                           0x01
#define SEGMENT_ACCESS_RIGHTS_PRESENT(_)                             (((_) >> 15) & 0x01)
        UINT32_t reserved2 : 4;

        /**
         * @brief Available bit
         *
         * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by system software.
         */
        UINT32_t system : 1;
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_BIT                             20
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_FLAG                            0x100000
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_MASK                            0x01
#define SEGMENT_ACCESS_RIGHTS_SYSTEM(_)                              (((_) >> 20) & 0x01)

        /**
         * @brief L (64-bit code segment) flag
         *
         * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor indicates whether a code segment
         * contains native 64-bit code. A value of 1 indicates instructions in this code segment are executed in 64-bit mode. A
         * value of 0 indicates the instructions in this code segment are executed in compatibility mode. If L-bit is set, then
         * D-bit must be cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved and should always be set to
         * 0.
         */
        UINT32_t long_mode : 1;
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_BIT                          21
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_FLAG                         0x200000
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_MASK                         0x01
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE(_)                           (((_) >> 21) & 0x01)

        /**
         * @brief D/B (default operation size/default stack pointer size and/or upper bound) flag
         *
         * [Bit 22] Performs different functions depending on whether the segment descriptor is an executable code segment, an
         * expand-down data segment, or a stack segment. (This flag should always be set to 1 for 32-bit code and data segments and
         * to 0 for 16-bit code and data segments.)
         * - Executable code segment. The flag is called the D flag and it indicates the default length for effective addresses and
         * operands referenced by instructions in the segment. If the flag is set, 32-bit addresses and 32-bit or 8-bit operands
         * are assumed; if it is clear, 16-bit addresses and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can
         * be used to select an operand size other than the default, and the prefix 67H can be used select an address size other
         * than the default.
         * - Stack segment (data segment pointed to by the SS register). The flag is called the B (big) flag and it specifies the
         * size of the stack pointer used for implicit stack operations (such as pushes, pops, and calls). If the flag is set, a
         * 32-bit stack pointer is used, which is stored in the 32-bit ESP register; if the flag is clear, a 16-bit stack pointer
         * is used, which is stored in the 16- bit SP register. If the stack segment is set up to be an expand-down data segment
         * (described in the next paragraph), the B flag also specifies the upper bound of the stack segment.
         * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound of the segment. If the flag
         * is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is clear, the upper bound is FFFFH (64 KBytes).
         */
        UINT32_t default_big : 1;
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_BIT                        22
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_FLAG                       0x400000
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_MASK                       0x01
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG(_)                         (((_) >> 22) & 0x01)

        /**
         * @brief G (granularity) flag
         *
         * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is clear, the segment limit is
         * interpreted in byte units; when flag is set, the segment limit is interpreted in 4-KByte units. (This flag does not
         * affect the granularity of the base address; it is always byte granular.) When the granularity flag is set, the twelve
         * least significant bits of an offset are not tested when checking the offset against the segment limit. For example, when
         * the granularity flag is set, a limit of 0 results in valid offsets from 0 to 4095.
         */
        UINT32_t granularity : 1;
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_BIT                        23
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_FLAG                       0x800000
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_MASK                       0x01
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY(_)                         (((_) >> 23) & 0x01)
        UINT32_t reserved3 : 8;
    };

    UINT32_t flags;
} segment_access_rights;

/**
 * @brief General Segment Descriptor (32-bit)
 *
 * A segment descriptor is a data structure in a GDT or LDT that provides the processor with the size and location of a
 * segment, as well as access control and status information. Segment descriptors are typically created by compilers,
 * linkers, loaders, or the operating system or executive, but not application programs.
 *
 * @see Vol3A[5.2(FIELDS AND FLAGS USED FOR SEGMENT-LEVEL AND PAGE-LEVEL PROTECTION)]
 * @see Vol3A[5.2.1(Code-Segment Descriptor in 64-bit Mode)]
 * @see Vol3A[5.8.3(Call Gates)]
 * @see Vol3A[6.11(IDT DESCRIPTORS)]
 * @see Vol3A[6.14.1(64-Bit Mode IDT)]
 * @see Vol3A[7.2.2(TSS Descriptor)]
 * @see Vol3A[7.2.3(TSS Descriptor in 64-bit mode)]
 * @see Vol3A[7.2.5(Task-Gate Descriptor)]
 * @see Vol3A[3.4.5(Segment Descriptors)] (reference)
 */
typedef struct
{
    /**
     * @brief Segment limit field (15:00)
     *
     * Specifies the size of the segment. The processor puts together the two segment limit fields to form a 20-bit value. The
     * processor interprets the segment limit in one of two ways, depending on the setting of the G (granularity) flag:
     * - If the granularity flag is clear, the segment size can range from 1 byte to 1 MByte, in byte increments.
     * - If the granularity flag is set, the segment size can range from 4 KBytes to 4 GBytes, in 4-KByte increments.
     * The processor uses the segment limit in two different ways, depending on whether the segment is an expand-up or an
     * expand-down segment. For expand-up segments, the offset in a logical address can range from 0 to the segment limit.
     * Offsets greater than the segment limit generate general-protection exceptions (\#GP, for all segments other than SS) or
     * stack-fault exceptions (\#SS for the SS segment). For expand-down segments, the segment limit has the reverse function;
     * the offset can range from the segment limit plus 1 to FFFFFFFFH or FFFFH, depending on the setting of the B flag.
     * Offsets less than or equal to the segment limit generate general-protection exceptions or stack-fault exceptions.
     * Decreasing the value in the segment limit field for an expanddown segment allocates new memory at the bottom of the
     * segment's address space, rather than at the top. IA-32 architecture stacks always grow downwards, making this mechanism
     * convenient for expandable stacks.
     *
     * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
     */
    UINT16_t segment_limit_low;

    /**
     * @brief Base address field (15:00)
     *
     * Defines the location of byte 0 of the segment within the 4-GByte linear address space. The processor puts together the
     * three base address fields to form a single 32-bit value. Segment base addresses should be aligned to 16-byte boundaries.
     * Although 16-byte alignment is not required, this alignment allows programs to maximize performance by aligning code and
     * data on 16-byte boundaries.
     */
    UINT16_t base_address_low;
    /**
     * @brief Segment descriptor fields
     */
    union
    {
        struct
        {
            /**
             * [Bits 7:0] Base address field (23:16); see description of $BASE_LOW for more details.
             */
            UINT32_t base_address_middle : 8;
#define SEGMENT__BASE_ADDRESS_MIDDLE_BIT                             0
#define SEGMENT__BASE_ADDRESS_MIDDLE_FLAG                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE_MASK                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE(_)                              (((_) >> 0) & 0xFF)

            /**
             * @brief Type field
             *
             * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can be made to the segment and the
             * direction of growth. The interpretation of this field depends on whether the descriptor type flag specifies an
             * application (code or data) descriptor or a system descriptor. The encoding of the type field is different for code,
             * data, and system descriptors.
             *
             * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
             */
            UINT32_t type : 4;
#define SEGMENT__TYPE_BIT                                            8
#define SEGMENT__TYPE_FLAG                                           0xF00
#define SEGMENT__TYPE_MASK                                           0x0F
#define SEGMENT__TYPE(_)                                             (((_) >> 8) & 0x0F)

            /**
             * @brief S (descriptor type) flag
             *
             * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear) or a code or data segment (S
             * flag is set).
             */
            UINT32_t descriptor_type : 1;
#define SEGMENT__DESCRIPTOR_TYPE_BIT                                 12
#define SEGMENT__DESCRIPTOR_TYPE_FLAG                                0x1000
#define SEGMENT__DESCRIPTOR_TYPE_MASK                                0x01
#define SEGMENT__DESCRIPTOR_TYPE(_)                                  (((_) >> 12) & 0x01)

            /**
             * @brief DPL (descriptor privilege level) field
             *
             * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range from 0 to 3, with 0 being the
             * most privileged level. The DPL is used to control access to the segment. See Section 5.5, "Privilege Levels", for a
             * description of the relationship of the DPL to the CPL of the executing code segment and the RPL of a segment selector.
             */
            UINT32_t descriptor_privilege_level : 2;
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT                      13
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG                     0x6000
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK                     0x03
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_)                       (((_) >> 13) & 0x03)

            /**
             * @brief P (segment-present) flag
             *
             * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear). If this flag is clear, the
             * processor generates a segment-not-present exception (\#NP) when a segment selector that points to the segment descriptor
             * is loaded into a segment register. Memory management software can use this flag to control which segments are actually
             * loaded into physical memory at a given time. It offers a control in addition to paging for managing virtual memory.
             */
            UINT32_t present : 1;
#define SEGMENT__PRESENT_BIT                                         15
#define SEGMENT__PRESENT_FLAG                                        0x8000
#define SEGMENT__PRESENT_MASK                                        0x01
#define SEGMENT__PRESENT(_)                                          (((_) >> 15) & 0x01)

            /**
             * [Bits 19:16] Segment limit field (19:16); see description of $LIMIT_LOW for more details.
             */
            UINT32_t segment_limit_high : 4;
#define SEGMENT__SEGMENT_LIMIT_HIGH_BIT                              16
#define SEGMENT__SEGMENT_LIMIT_HIGH_FLAG                             0xF0000
#define SEGMENT__SEGMENT_LIMIT_HIGH_MASK                             0x0F
#define SEGMENT__SEGMENT_LIMIT_HIGH(_)                               (((_) >> 16) & 0x0F)

            /**
             * @brief Available bit
             *
             * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by system software.
             */
            UINT32_t system : 1;
#define SEGMENT__SYSTEM_BIT                                          20
#define SEGMENT__SYSTEM_FLAG                                         0x100000
#define SEGMENT__SYSTEM_MASK                                         0x01
#define SEGMENT__SYSTEM(_)                                           (((_) >> 20) & 0x01)

            /**
             * @brief L (64-bit code segment) flag
             *
             * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor indicates whether a code segment
             * contains native 64-bit code. A value of 1 indicates instructions in this code segment are executed in 64-bit mode. A
             * value of 0 indicates the instructions in this code segment are executed in compatibility mode. If L-bit is set, then
             * D-bit must be cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved and should always be set to
             * 0.
             */
            UINT32_t long_mode : 1;
#define SEGMENT__LONG_MODE_BIT                                       21
#define SEGMENT__LONG_MODE_FLAG                                      0x200000
#define SEGMENT__LONG_MODE_MASK                                      0x01
#define SEGMENT__LONG_MODE(_)                                        (((_) >> 21) & 0x01)

            /**
             * @brief D/B (default operation size/default stack pointer size and/or upper bound) flag
             *
             * [Bit 22] Performs different functions depending on whether the segment descriptor is an executable code segment, an
             * expand-down data segment, or a stack segment. (This flag should always be set to 1 for 32-bit code and data segments and
             * to 0 for 16-bit code and data segments.)
             * - Executable code segment. The flag is called the D flag and it indicates the default length for effective addresses and
             * operands referenced by instructions in the segment. If the flag is set, 32-bit addresses and 32-bit or 8-bit operands
             * are assumed; if it is clear, 16-bit addresses and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can
             * be used to select an operand size other than the default, and the prefix 67H can be used select an address size other
             * than the default.
             * - Stack segment (data segment pointed to by the SS register). The flag is called the B (big) flag and it specifies the
             * size of the stack pointer used for implicit stack operations (such as pushes, pops, and calls). If the flag is set, a
             * 32-bit stack pointer is used, which is stored in the 32-bit ESP register; if the flag is clear, a 16-bit stack pointer
             * is used, which is stored in the 16- bit SP register. If the stack segment is set up to be an expand-down data segment
             * (described in the next paragraph), the B flag also specifies the upper bound of the stack segment.
             * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound of the segment. If the flag
             * is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is clear, the upper bound is FFFFH (64 KBytes).
             */
            UINT32_t default_big : 1;
#define SEGMENT__DEFAULT_BIG_BIT                                     22
#define SEGMENT__DEFAULT_BIG_FLAG                                    0x400000
#define SEGMENT__DEFAULT_BIG_MASK                                    0x01
#define SEGMENT__DEFAULT_BIG(_)                                      (((_) >> 22) & 0x01)

            /**
             * @brief G (granularity) flag
             *
             * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is clear, the segment limit is
             * interpreted in byte units; when flag is set, the segment limit is interpreted in 4-KByte units. (This flag does not
             * affect the granularity of the base address; it is always byte granular.) When the granularity flag is set, the twelve
             * least significant bits of an offset are not tested when checking the offset against the segment limit. For example, when
             * the granularity flag is set, a limit of 0 results in valid offsets from 0 to 4095.
             */
            UINT32_t granularity : 1;
#define SEGMENT__GRANULARITY_BIT                                     23
#define SEGMENT__GRANULARITY_FLAG                                    0x800000
#define SEGMENT__GRANULARITY_MASK                                    0x01
#define SEGMENT__GRANULARITY(_)                                      (((_) >> 23) & 0x01)

            /**
             * [Bits 31:24] Base address field (31:24); see description of $BASE_LOW for more details.
             */
            UINT32_t base_address_high : 8;
#define SEGMENT__BASE_ADDRESS_HIGH_BIT                               24
#define SEGMENT__BASE_ADDRESS_HIGH_FLAG                              0xFF000000
#define SEGMENT__BASE_ADDRESS_HIGH_MASK                              0xFF
#define SEGMENT__BASE_ADDRESS_HIGH(_)                                (((_) >> 24) & 0xFF)
        };

        UINT32_t flags;
    };

} segment_descriptor_32;

/**
 * @brief General Segment Descriptor (64-bit)
 *
 * A segment descriptor is a data structure in a GDT or LDT that provides the processor with the size and location of a
 * segment, as well as access control and status information. Segment descriptors are typically created by compilers,
 * linkers, loaders, or the operating system or executive, but not application programs.
 *
 * @see Vol3A[3.4.5(Segment Descriptors)] (reference)
 */
typedef struct
{
    /**
     * @brief Segment limit field (15:00)
     *
     * Specifies the size of the segment. The processor puts together the two segment limit fields to form a 20-bit value. The
     * processor interprets the segment limit in one of two ways, depending on the setting of the G (granularity) flag:
     * - If the granularity flag is clear, the segment size can range from 1 byte to 1 MByte, in byte increments.
     * - If the granularity flag is set, the segment size can range from 4 KBytes to 4 GBytes, in 4-KByte increments.
     * The processor uses the segment limit in two different ways, depending on whether the segment is an expand-up or an
     * expand-down segment. For expand-up segments, the offset in a logical address can range from 0 to the segment limit.
     * Offsets greater than the segment limit generate general-protection exceptions (\#GP, for all segments other than SS) or
     * stack-fault exceptions (\#SS for the SS segment). For expand-down segments, the segment limit has the reverse function;
     * the offset can range from the segment limit plus 1 to FFFFFFFFH or FFFFH, depending on the setting of the B flag.
     * Offsets less than or equal to the segment limit generate general-protection exceptions or stack-fault exceptions.
     * Decreasing the value in the segment limit field for an expanddown segment allocates new memory at the bottom of the
     * segment's address space, rather than at the top. IA-32 architecture stacks always grow downwards, making this mechanism
     * convenient for expandable stacks.
     *
     * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
     */
    UINT16_t segment_limit_low;

    /**
     * @brief Base address field (15:00)
     *
     * Defines the location of byte 0 of the segment within the 4-GByte linear address space. The processor puts together the
     * three base address fields to form a single 32-bit value. Segment base addresses should be aligned to 16-byte boundaries.
     * Although 16-byte alignment is not required, this alignment allows programs to maximize performance by aligning code and
     * data on 16-byte boundaries.
     */
    UINT16_t base_address_low;
    /**
     * @brief Segment descriptor fields
     */
    union
    {
        struct
        {
            /**
             * [Bits 7:0] Base address field (23:16); see description of $BASE_LOW for more details.
             */
            UINT32_t base_address_middle : 8;
#define SEGMENT__BASE_ADDRESS_MIDDLE_BIT                             0
#define SEGMENT__BASE_ADDRESS_MIDDLE_FLAG                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE_MASK                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE(_)                              (((_) >> 0) & 0xFF)

            /**
             * @brief Type field
             *
             * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can be made to the segment and the
             * direction of growth. The interpretation of this field depends on whether the descriptor type flag specifies an
             * application (code or data) descriptor or a system descriptor. The encoding of the type field is different for code,
             * data, and system descriptors.
             *
             * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
             */
            UINT32_t type : 4;
#define SEGMENT__TYPE_BIT                                            8
#define SEGMENT__TYPE_FLAG                                           0xF00
#define SEGMENT__TYPE_MASK                                           0x0F
#define SEGMENT__TYPE(_)                                             (((_) >> 8) & 0x0F)

            /**
             * @brief S (descriptor type) flag
             *
             * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear) or a code or data segment (S
             * flag is set).
             */
            UINT32_t descriptor_type : 1;
#define SEGMENT__DESCRIPTOR_TYPE_BIT                                 12
#define SEGMENT__DESCRIPTOR_TYPE_FLAG                                0x1000
#define SEGMENT__DESCRIPTOR_TYPE_MASK                                0x01
#define SEGMENT__DESCRIPTOR_TYPE(_)                                  (((_) >> 12) & 0x01)

            /**
             * @brief DPL (descriptor privilege level) field
             *
             * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range from 0 to 3, with 0 being the
             * most privileged level. The DPL is used to control access to the segment. See Section 5.5, "Privilege Levels", for a
             * description of the relationship of the DPL to the CPL of the executing code segment and the RPL of a segment selector.
             */
            UINT32_t descriptor_privilege_level : 2;
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT                      13
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG                     0x6000
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK                     0x03
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_)                       (((_) >> 13) & 0x03)

            /**
             * @brief P (segment-present) flag
             *
             * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear). If this flag is clear, the
             * processor generates a segment-not-present exception (\#NP) when a segment selector that points to the segment descriptor
             * is loaded into a segment register. Memory management software can use this flag to control which segments are actually
             * loaded into physical memory at a given time. It offers a control in addition to paging for managing virtual memory.
             */
            UINT32_t present : 1;
#define SEGMENT__PRESENT_BIT                                         15
#define SEGMENT__PRESENT_FLAG                                        0x8000
#define SEGMENT__PRESENT_MASK                                        0x01
#define SEGMENT__PRESENT(_)                                          (((_) >> 15) & 0x01)

            /**
             * [Bits 19:16] Segment limit field (19:16); see description of $LIMIT_LOW for more details.
             */
            UINT32_t segment_limit_high : 4;
#define SEGMENT__SEGMENT_LIMIT_HIGH_BIT                              16
#define SEGMENT__SEGMENT_LIMIT_HIGH_FLAG                             0xF0000
#define SEGMENT__SEGMENT_LIMIT_HIGH_MASK                             0x0F
#define SEGMENT__SEGMENT_LIMIT_HIGH(_)                               (((_) >> 16) & 0x0F)

            /**
             * @brief Available bit
             *
             * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by system software.
             */
            UINT32_t system : 1;
#define SEGMENT__SYSTEM_BIT                                          20
#define SEGMENT__SYSTEM_FLAG                                         0x100000
#define SEGMENT__SYSTEM_MASK                                         0x01
#define SEGMENT__SYSTEM(_)                                           (((_) >> 20) & 0x01)

            /**
             * @brief L (64-bit code segment) flag
             *
             * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor indicates whether a code segment
             * contains native 64-bit code. A value of 1 indicates instructions in this code segment are executed in 64-bit mode. A
             * value of 0 indicates the instructions in this code segment are executed in compatibility mode. If L-bit is set, then
             * D-bit must be cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved and should always be set to
             * 0.
             */
            UINT32_t long_mode : 1;
#define SEGMENT__LONG_MODE_BIT                                       21
#define SEGMENT__LONG_MODE_FLAG                                      0x200000
#define SEGMENT__LONG_MODE_MASK                                      0x01
#define SEGMENT__LONG_MODE(_)                                        (((_) >> 21) & 0x01)

            /**
             * @brief D/B (default operation size/default stack pointer size and/or upper bound) flag
             *
             * [Bit 22] Performs different functions depending on whether the segment descriptor is an executable code segment, an
             * expand-down data segment, or a stack segment. (This flag should always be set to 1 for 32-bit code and data segments and
             * to 0 for 16-bit code and data segments.)
             * - Executable code segment. The flag is called the D flag and it indicates the default length for effective addresses and
             * operands referenced by instructions in the segment. If the flag is set, 32-bit addresses and 32-bit or 8-bit operands
             * are assumed; if it is clear, 16-bit addresses and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can
             * be used to select an operand size other than the default, and the prefix 67H can be used select an address size other
             * than the default.
             * - Stack segment (data segment pointed to by the SS register). The flag is called the B (big) flag and it specifies the
             * size of the stack pointer used for implicit stack operations (such as pushes, pops, and calls). If the flag is set, a
             * 32-bit stack pointer is used, which is stored in the 32-bit ESP register; if the flag is clear, a 16-bit stack pointer
             * is used, which is stored in the 16- bit SP register. If the stack segment is set up to be an expand-down data segment
             * (described in the next paragraph), the B flag also specifies the upper bound of the stack segment.
             * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound of the segment. If the flag
             * is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is clear, the upper bound is FFFFH (64 KBytes).
             */
            UINT32_t default_big : 1;
#define SEGMENT__DEFAULT_BIG_BIT                                     22
#define SEGMENT__DEFAULT_BIG_FLAG                                    0x400000
#define SEGMENT__DEFAULT_BIG_MASK                                    0x01
#define SEGMENT__DEFAULT_BIG(_)                                      (((_) >> 22) & 0x01)

            /**
             * @brief G (granularity) flag
             *
             * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is clear, the segment limit is
             * interpreted in byte units; when flag is set, the segment limit is interpreted in 4-KByte units. (This flag does not
             * affect the granularity of the base address; it is always byte granular.) When the granularity flag is set, the twelve
             * least significant bits of an offset are not tested when checking the offset against the segment limit. For example, when
             * the granularity flag is set, a limit of 0 results in valid offsets from 0 to 4095.
             */
            UINT32_t granularity : 1;
#define SEGMENT__GRANULARITY_BIT                                     23
#define SEGMENT__GRANULARITY_FLAG                                    0x800000
#define SEGMENT__GRANULARITY_MASK                                    0x01
#define SEGMENT__GRANULARITY(_)                                      (((_) >> 23) & 0x01)

            /**
             * [Bits 31:24] Base address field (31:24); see description of $BASE_LOW for more details.
             */
            UINT32_t base_address_high : 8;
#define SEGMENT__BASE_ADDRESS_HIGH_BIT                               24
#define SEGMENT__BASE_ADDRESS_HIGH_FLAG                              0xFF000000
#define SEGMENT__BASE_ADDRESS_HIGH_MASK                              0xFF
#define SEGMENT__BASE_ADDRESS_HIGH(_)                                (((_) >> 24) & 0xFF)
        };

        UINT32_t flags;
    };


    /**
     * Base address field (32:63); see description of $BASE_LOW for more details.
     */
    UINT32_t base_address_upper;

    /**
     * Base address field (32:63); see description of $BASE_LOW for more details.
     */
    UINT32_t must_be_zero;
} segment_descriptor_64;

#define SEGMENT_DESCRIPTOR_TYPE_SYSTEM                               0x00000000
#define SEGMENT_DESCRIPTOR_TYPE_CODE_OR_DATA                         0x00000001
/**
 * @defgroup segment_descriptor_code_and_data_type \
 *           Code- and Data-Segment Descriptor Types
 *
 * When the S (descriptor type) flag in a segment descriptor is set, the descriptor is for either a code or a data segment.
 * The highest order bit of the type field (bit 11 of the second double word of the segment descriptor) then determines
 * whether the descriptor is for a data segment (clear) or a code segment (set). For data segments, the three low-order
 * bits of the type field (bits 8, 9, and 10) are interpreted as accessed (A), write-enable (W), and expansion-direction
 * (E). See Table 3-1 for a description of the encoding of the bits in the type field for code and data segments. Data
 * segments can be read-only or read/write segments, depending on the setting of the write-enable bit.
 *
 * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)] (reference)
 * @{
 */
 /**
  * Read-Only.
  */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY                       0x00000000

  /**
   * Data Read-Only, accessed.
   */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_ACCESSED              0x00000001

   /**
    * Data Read/Write.
    */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE                      0x00000002

    /**
     * Data Read/Write, accessed.
     */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_ACCESSED             0x00000003

     /**
      * Data Read-Only, expand-down.
      */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_EXPAND_DOWN           0x00000004

      /**
       * Data Read-Only, expand-down, accessed.
       */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_EXPAND_DOWN_ACCESSED  0x00000005

       /**
        * Data Read/Write, expand-down.
        */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_EXPAND_DOWN          0x00000006

        /**
         * Data Read/Write, expand-down, accessed.
         */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_EXPAND_DOWN_ACCESSED 0x00000007

         /**
          * Code Execute-Only.
          */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY                    0x00000008

          /**
           * Code Execute-Only, accessed.
           */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_ACCESSED           0x00000009

           /**
            * Code Execute/Read.
            */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ                    0x0000000A

            /**
             * Code Execute/Read, accessed.
             */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_ACCESSED           0x0000000B

             /**
              * Code Execute-Only, conforming.
              */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_CONFORMING         0x0000000C

              /**
               * Code Execute-Only, conforming, accessed.
               */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_CONFORMING_ACCESSED 0x0000000D

               /**
                * Code Execute/Read, conforming.
                */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_CONFORMING         0x0000000E

                /**
                 * Code Execute/Read, conforming, accessed.
                 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_CONFORMING_ACCESSED 0x0000000F
                 /**
                  * @}
                  */

                  /**
                   * @defgroup segment_descriptor_system_type \
                   *           System Descriptor Types
                   *
                   * When the S (descriptor type) flag in a segment descriptor is clear, the descriptor type is a system descriptor. The
                   * processor recognizes the following types of system descriptors:
                   * - Local descriptor-table (LDT) segment descriptor.
                   * - Task-state segment (TSS) descriptor.
                   * - Call-gate descriptor.
                   * - Interrupt-gate descriptor.
                   * - Trap-gate descriptor.
                   * - Task-gate descriptor.
                   * These descriptor types fall into two categories: system-segment descriptors and gate descriptors. Systemsegment
                   * descriptors point to system segments (LDT and TSS segments). Gate descriptors are in themselves "gates," which hold
                   * pointers to procedure entry points in code segments (call, interrupt, and trap gates) or which hold segment selectors
                   * for TSS's (task gates).
                   *
                   * @see Vol3A[3.5(SYSTEM DESCRIPTOR TYPES)] (reference)
                   * @{
                   */
                   /**
                    * - 32-Bit Mode: Reserved
                    * - IA-32e Mode: Reserved
                    */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_1                           0x00000000

                    /**
                     * - 32-Bit Mode: 16-bit TSS (Available)
                     * - IA-32e Mode: Reserved
                     */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_16_AVAILABLE                     0x00000001

                     /**
                      * - 32-Bit Mode: LDT
                      * - IA-32e Mode: LDT
                      */
#define SEGMENT_DESCRIPTOR_TYPE_LDT                                  0x00000002

                      /**
                       * - 32-Bit Mode: 16-bit TSS (Busy)
                       * - IA-32e Mode: Reserved
                       */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_16_BUSY                          0x00000003

                       /**
                        * - 32-Bit Mode: 16-bit Call Gate
                        * - IA-32e Mode: Reserved
                        */
#define SEGMENT_DESCRIPTOR_TYPE_CALL_GATE_16                         0x00000004

                        /**
                         * - 32-Bit Mode: Task Gate
                         * - IA-32e Mode: Reserved
                         */
#define SEGMENT_DESCRIPTOR_TYPE_TASK_GATE                            0x00000005

                         /**
                          * - 32-Bit Mode: 16-bit Interrupt Gate
                          * - IA-32e Mode: Reserved
                          */
#define SEGMENT_DESCRIPTOR_TYPE_INTERRUPT_GATE_16                    0x00000006

                          /**
                           * - 32-Bit Mode: 16-bit Trap Gate
                           * - IA-32e Mode: Reserved
                           */
#define SEGMENT_DESCRIPTOR_TYPE_TRAP_GATE_16                         0x00000007

                           /**
                            * - 32-Bit Mode: Reserved
                            * - IA-32e Mode: Reserved
                            */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_2                           0x00000008

                            /**
                             * - 32-Bit Mode: 32-bit TSS (Available)
                             * - IA-32e Mode: 64-bit TSS (Available)
                             */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_AVAILABLE                        0x00000009

                             /**
                              * - 32-Bit Mode: Reserved
                              * - IA-32e Mode: Reserved
                              */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_3                           0x0000000A

                              /**
                               * - 32-Bit Mode: 32-bit TSS (Busy)
                               * - IA-32e Mode: 64-bit TSS (Busy)
                               */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_BUSY                             0x0000000B

                               /**
                                * - 32-Bit Mode: 32-bit Call Gate
                                * - IA-32e Mode: 64-bit Call Gate
                                */
#define SEGMENT_DESCRIPTOR_TYPE_CALL_GATE                            0x0000000C

                                /**
                                 * - 32-Bit Mode: Reserved
                                 * - IA-32e Mode: Reserved
                                 */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_4                           0x0000000D

                                 /**
                                  * - 32-Bit Mode: 32-bit Interrupt Gate
                                  * - IA-32e Mode: 64-bit Interrupt Gate
                                  */
#define SEGMENT_DESCRIPTOR_TYPE_INTERRUPT_GATE                       0x0000000E

                                  /**
                                   * - 32-Bit Mode: 32-bit Trap Gate
                                   * - IA-32e Mode: 64-bit Trap Gate
                                   */
#define SEGMENT_DESCRIPTOR_TYPE_TRAP_GATE                            0x0000000F
                                   /**
                                    * @}
                                    */

                                    /**
                                     * @brief A segment selector is a 16-bit identifier for a segment. It does not point directly to the segment, but instead
                                     *        points to the segment descriptor that defines the segment
                                     *
                                     * @see Vol3A[3.4.2(Segment Selectors)] (reference)
                                     */
typedef union
{
    struct
    {
        /**
         * [Bits 1:0] Specifies the privilege level of the selector. The privilege level can range from 0 to 3, with 0 being the
         * most privileged level.
         *
         * @see Vol3A[5.5(Privilege Levels)]
         */
        UINT16_t request_privilege_level : 2;
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_BIT                 0
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_FLAG                0x03
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_MASK                0x03
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL(_)                  (((_) >> 0) & 0x03)

        /**
         * [Bit 2] Specifies the descriptor table to use: clearing this flag selects the GDT; setting this flag selects the current
         * LDT.
         */
        UINT16_t table : 1;
#define SEGMENT_SELECTOR_TABLE_BIT                                   2
#define SEGMENT_SELECTOR_TABLE_FLAG                                  0x04
#define SEGMENT_SELECTOR_TABLE_MASK                                  0x01
#define SEGMENT_SELECTOR_TABLE(_)                                    (((_) >> 2) & 0x01)

        /**
         * [Bits 15:3] Selects one of 8192 descriptors in the GDT or LDT. The processor multiplies the index value by 8 (the number
         * of bytes in a segment descriptor) and adds the result to the base address of the GDT or LDT (from the GDTR or LDTR
         * register, respectively).
         */
        UINT16_t index : 13;
#define SEGMENT_SELECTOR_INDEX_BIT                                   3
#define SEGMENT_SELECTOR_INDEX_FLAG                                  0xFFF8
#define SEGMENT_SELECTOR_INDEX_MASK                                  0x1FFF
#define SEGMENT_SELECTOR_INDEX(_)                                    (((_) >> 3) & 0x1FFF)
    };

    UINT16_t flags;
} segment_selector;

/**
 * @}
 */

 /**
  * @defgroup vmx \
  *           VMX
  * @{
  */
  /**
   * @{
   */
   /**
    * @defgroup vmx_basic_exit_reasons \
    *           VMX Basic Exit Reasons
    *
    * VMX Basic Exit Reasons.
    *
    * @see Vol3D[C(VMX BASIC EXIT REASONS)] (reference)
    * @{
    */
    /**
     * @brief Exception or non-maskable interrupt (NMI)
     *
     * Either:
     * -# Guest software caused an exception and the bit in the exception bitmap associated with exception's vector was 1. This
     * case includes executions of BOUND that cause \#BR, executions of INT1 (they cause \#DB), executions of INT3 (they cause
     * \#BP), executions of INTO that cause \#OF, and executions of UD0, UD1, and UD2 (they cause \#UD).
     * -# An NMI was delivered to the logical processor and the "NMI exiting" VM-execution control was 1.
     */
#define VMX_EXIT_REASON_EXCEPTION_OR_NMI                             0x00000000

     /**
      * @brief External interrupt
      *
      * An external interrupt arrived and the "external-interrupt exiting" VM-execution control was 1.
      */
#define VMX_EXIT_REASON_EXTERNAL_INTERRUPT                           0x00000001

      /**
       * @brief Triple fault
       *
       * The logical processor encountered an exception while attempting to call the double-fault handler and that exception did
       * not itself cause a VM exit due to the exception bitmap.
       */
#define VMX_EXIT_REASON_TRIPLE_FAULT                                 0x00000002

       /**
        * @brief INIT signal
        *
        * An INIT signal arrived.
        */
#define VMX_EXIT_REASON_INIT_SIGNAL                                  0x00000003

        /**
         * @brief Start-up IPI (SIPI)
         *
         * A SIPI arrived while the logical processor was in the "wait-for-SIPI" state.
         */
#define VMX_EXIT_REASON_STARTUP_IPI                                  0x00000004

         /**
          * @brief I/O system-management interrupt (SMI)
          *
          * An SMI arrived immediately after retirement of an I/O instruction and caused an SMM VM exit.
          *
          * @see Vol3C[34.15.2(SMM VM Exits)]
          */
#define VMX_EXIT_REASON_IO_SMI                                       0x00000005

          /**
           * @brief Other SMI
           *
           * An SMI arrived and caused an SMM VM exit but not immediately after retirement of an I/O instruction.
           *
           * @see Vol3C[34.15.2(SMM VM Exits)]
           */
#define VMX_EXIT_REASON_SMI                                          0x00000006

           /**
            * @brief Interrupt window exiting
            *
            * At the beginning of an instruction, RFLAGS.IF was 1; events were not blocked by STI or by MOV SS; and the
            * "interrupt-window exiting" VM-execution control was 1.
            */
#define VMX_EXIT_REASON_INTERRUPT_WINDOW                             0x00000007

            /**
             * @brief NMI window exiting
             *
             * At the beginning of an instruction, there was no virtual-NMI blocking; events were not blocked by MOV SS; and the
             * "NMI-window exiting" VM-execution control was 1.
             */
#define VMX_EXIT_REASON_NMI_WINDOW                                   0x00000008

             /**
              * @brief Task switch
              *
              * Guest software attempted a task switch.
              */
#define VMX_EXIT_REASON_TASK_SWITCH                                  0x00000009

              /**
               * @brief CPUID
               *
               * Guest software attempted to execute CPUID.
               */
#define VMX_EXIT_REASON_EXECUTE_CPUID                                0x0000000A

               /**
                * @brief GETSEC
                *
                * Guest software attempted to execute GETSEC.
                */
#define VMX_EXIT_REASON_EXECUTE_GETSEC                               0x0000000B

                /**
                 * @brief HLT
                 *
                 * Guest software attempted to execute HLT and the "HLT exiting" VM-execution control was 1.
                 */
#define VMX_EXIT_REASON_EXECUTE_HLT                                  0x0000000C

                 /**
                  * @brief INVD
                  *
                  * Guest software attempted to execute INVD.
                  */
#define VMX_EXIT_REASON_EXECUTE_INVD                                 0x0000000D

                  /**
                   * @brief INVLPG
                   *
                   * Guest software attempted to execute INVLPG and the "INVLPG exiting" VM-execution control was 1.
                   */
#define VMX_EXIT_REASON_EXECUTE_INVLPG                               0x0000000E

                   /**
                    * @brief RDPMC
                    *
                    * Guest software attempted to execute RDPMC and the "RDPMC exiting" VM-execution control was 1.
                    */
#define VMX_EXIT_REASON_EXECUTE_RDPMC                                0x0000000F

                    /**
                     * @brief RDTSC
                     *
                     * Guest software attempted to execute RDTSC and the "RDTSC exiting" VM-execution control was 1.
                     */
#define VMX_EXIT_REASON_EXECUTE_RDTSC                                0x00000010

                     /**
                      * @brief RSM in SMM
                      *
                      * Guest software attempted to execute RSM in SMM.
                      */
#define VMX_EXIT_REASON_EXECUTE_RSM_IN_SMM                           0x00000011

                      /**
                       * @brief VMCALL
                       *
                       * VMCALL was executed either by guest software (causing an ordinary VM exit) or by the executive monitor (causing an SMM
                       * VM exit).
                       *
                       * @see Vol3C[34.15.2(SMM VM Exits)]
                       */
#define VMX_EXIT_REASON_EXECUTE_VMCALL                               0x00000012

                       /**
                        * @brief VMCLEAR
                        *
                        * Guest software attempted to execute VMCLEAR.
                        */
#define VMX_EXIT_REASON_EXECUTE_VMCLEAR                              0x00000013

                        /**
                         * @brief VMLAUNCH
                         *
                         * Guest software attempted to execute VMLAUNCH.
                         */
#define VMX_EXIT_REASON_EXECUTE_VMLAUNCH                             0x00000014

                         /**
                          * @brief VMPTRLD
                          *
                          * Guest software attempted to execute VMPTRLD.
                          */
#define VMX_EXIT_REASON_EXECUTE_VMPTRLD                              0x00000015

                          /**
                           * @brief VMPTRST
                           *
                           * Guest software attempted to execute VMPTRST.
                           */
#define VMX_EXIT_REASON_EXECUTE_VMPTRST                              0x00000016

                           /**
                            * @brief VMREAD
                            *
                            * Guest software attempted to execute VMREAD.
                            */
#define VMX_EXIT_REASON_EXECUTE_VMREAD                               0x00000017

                            /**
                             * @brief VMRESUME
                             *
                             * Guest software attempted to execute VMRESUME.
                             */
#define VMX_EXIT_REASON_EXECUTE_VMRESUME                             0x00000018

                             /**
                              * @brief VMWRITE
                              *
                              * Guest software attempted to execute VMWRITE.
                              */
#define VMX_EXIT_REASON_EXECUTE_VMWRITE                              0x00000019

                              /**
                               * @brief VMXOFF
                               *
                               * Guest software attempted to execute VMXOFF.
                               */
#define VMX_EXIT_REASON_EXECUTE_VMXOFF                               0x0000001A

                               /**
                                * @brief VMXON
                                *
                                * Guest software attempted to execute VMXON.
                                */
#define VMX_EXIT_REASON_EXECUTE_VMXON                                0x0000001B

                                /**
                                 * @brief Control-register accesses
                                 *
                                 * Guest software attempted to access CR0, CR3, CR4, or CR8 using CLTS, LMSW, or MOV CR and the VM-execution control fields
                                 * indicate that a VM exit should occur. This basic exit reason is not used for trap-like VM exits following executions of
                                 * the MOV to CR8 instruction when the "use TPR shadow" VM-execution control is 1. Such VM exits instead use basic exit
                                 * reason 43.
                                 *
                                 * @see Vol3C[25.1(INSTRUCTIONS THAT CAUSE VM EXITS)]
                                 */
#define VMX_EXIT_REASON_MOV_CR                                       0x0000001C

                                 /**
                                  * @brief Debug-register accesses
                                  *
                                  * Guest software attempted a MOV to or from a debug register and the "MOV-DR exiting" VM-execution control was 1.
                                  */
#define VMX_EXIT_REASON_MOV_DR                                       0x0000001D

                                  /**
                                   * @brief I/O instruction
                                   *
                                   * Guest software attempted to execute an I/O instruction and either:
                                   * -# The "use I/O bitmaps" VM-execution control was 0 and the "unconditional I/O exiting" VM-execution control was 1.
                                   * -# The "use I/O bitmaps" VM-execution control was 1 and a bit in the I/O bitmap associated with one of the ports
                                   * accessed by the I/O instruction was 1.
                                   */
#define VMX_EXIT_REASON_EXECUTE_IO_INSTRUCTION                       0x0000001E

                                   /**
                                    * @brief RDMSR
                                    *
                                    * Guest software attempted to execute RDMSR and either:
                                    * -# The "use MSR bitmaps" VM-execution control was 0.
                                    * -# The value of RCX is neither in the range 00000000H - 00001FFFH nor in the range C0000000H - C0001FFFH.
                                    * -# The value of RCX was in the range 00000000H - 00001FFFH and the nth bit in read bitmap for low MSRs is 1, where n was
                                    * the value of RCX.
                                    * -# The value of RCX is in the range C0000000H - C0001FFFH and the nth bit in read bitmap for high MSRs is 1, where n is
                                    * the value of RCX & 00001FFFH.
                                    */
#define VMX_EXIT_REASON_EXECUTE_RDMSR                                0x0000001F

                                    /**
                                     * @brief WRMSR
                                     *
                                     * Guest software attempted to execute WRMSR and either:
                                     * -# The "use MSR bitmaps" VM-execution control was 0.
                                     * -# The value of RCX is neither in the range 00000000H - 00001FFFH nor in the range C0000000H - C0001FFFH.
                                     * -# The value of RCX was in the range 00000000H - 00001FFFH and the nth bit in write bitmap for low MSRs is 1, where n
                                     * was the value of RCX.
                                     * -# The value of RCX is in the range C0000000H - C0001FFFH and the nth bit in write bitmap for high MSRs is 1, where n is
                                     * the value of RCX & 00001FFFH.
                                     */
#define VMX_EXIT_REASON_EXECUTE_WRMSR                                0x00000020

                                     /**
                                      * @brief VM-entry failure due to invalid guest state
                                      *
                                      * A VM entry failed one of the checks identified in Section 26.3.1.
                                      */
#define VMX_EXIT_REASON_ERROR_INVALID_GUEST_STATE                    0x00000021

                                      /**
                                       * @brief VM-entry failure due to MSR loading
                                       *
                                       * A VM entry failed in an attempt to load MSRs. See Section 26.4.
                                       */
#define VMX_EXIT_REASON_ERROR_MSR_LOAD                               0x00000022

                                       /**
                                        * @brief Guest software executed MWAIT
                                        *
                                        * Guest software attempted to execute MWAIT and the "MWAIT exiting" VM-execution control was 1.
                                        */
#define VMX_EXIT_REASON_EXECUTE_MWAIT                                0x00000024

                                        /**
                                         * @brief VM-exit due to monitor trap flag
                                         *
                                         * A VM entry occurred due to the 1-setting of the "monitor trap flag" VM-execution control and injection of an MTF VM exit
                                         * as part of VM entry.
                                         *
                                         * @see Vol3C[25.5.2(Monitor Trap Flag)]
                                         */
#define VMX_EXIT_REASON_MONITOR_TRAP_FLAG                            0x00000025

                                         /**
                                          * @brief Guest software attempted to execute MONITOR
                                          *
                                          * Guest software attempted to execute MONITOR and the "MONITOR exiting" VM-execution control was 1.
                                          */
#define VMX_EXIT_REASON_EXECUTE_MONITOR                              0x00000027

                                          /**
                                           * @brief Guest software attempted to execute PAUSE
                                           *
                                           * Either guest software attempted to execute PAUSE and the "PAUSE exiting" VM-execution control was 1 or the "PAUSE-loop
                                           * exiting" VM-execution control was 1 and guest software executed a PAUSE loop with execution time exceeding PLE_Window.
                                           *
                                           * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
                                           */
#define VMX_EXIT_REASON_EXECUTE_PAUSE                                0x00000028

                                           /**
                                            * @brief VM-entry failure due to machine-check
                                            *
                                            * A machine-check event occurred during VM entry.
                                            *
                                            * @see Vol3C[26.8(MACHINE-CHECK EVENTS DURING VM ENTRY)]
                                            */
#define VMX_EXIT_REASON_ERROR_MACHINE_CHECK                          0x00000029

                                            /**
                                             * @brief TPR below threshold
                                             *
                                             * The logical processor determined that the value of bits 7:4 of the byte at offset 080H on the virtual-APIC page was
                                             * below that of the TPR threshold VM-execution control field while the "use TPR shadow" VMexecution control was 1 either
                                             * as part of TPR virtualization or VM entry.
                                             *
                                             * @see Vol3C[29.1.2(TPR Virtualization)]
                                             * @see Vol3C[26.6.7(VM Exits Induced by the TPR Threshold)]
                                             */
#define VMX_EXIT_REASON_TPR_BELOW_THRESHOLD                          0x0000002B

                                             /**
                                              * @brief APIC access
                                              *
                                              * Guest software attempted to access memory at a physical address on the APIC-access page and the "virtualize APIC
                                              * accesses" VM-execution control was 1.
                                              *
                                              * @see Vol3C[29.4(VIRTUALIZING MEMORY-MAPPED APIC ACCESSES)]
                                              */
#define VMX_EXIT_REASON_APIC_ACCESS                                  0x0000002C

                                              /**
                                               * @brief Virtualized EOI
                                               *
                                               * EOI virtualization was performed for a virtual interrupt whose vector indexed a bit set in the EOIexit bitmap.
                                               */
#define VMX_EXIT_REASON_VIRTUALIZED_EOI                              0x0000002D

                                               /**
                                                * @brief Access to GDTR or IDTR
                                                *
                                                * Guest software attempted to execute LGDT, LIDT, SGDT, or SIDT and the "descriptor-table exiting" VM-execution control
                                                * was 1.
                                                */
#define VMX_EXIT_REASON_GDTR_IDTR_ACCESS                             0x0000002E

                                                /**
                                                 * @brief Access to LDTR or TR
                                                 *
                                                 * Guest software attempted to execute LLDT, LTR, SLDT, or STR and the "descriptor-table exiting" VM-execution control was
                                                 * 1.
                                                 */
#define VMX_EXIT_REASON_LDTR_TR_ACCESS                               0x0000002F

                                                 /**
                                                  * @brief EPT violation
                                                  *
                                                  * An attempt to access memory with a guest-physical address was disallowed by the configuration of the EPT paging
                                                  * structures.
                                                  */
#define VMX_EXIT_REASON_EPT_VIOLATION                                0x00000030

                                                  /**
                                                   * @brief EPT misconfiguration
                                                   *
                                                   * An attempt to access memory with a guest-physical address encountered a misconfigured EPT paging-structure entry.
                                                   */
#define VMX_EXIT_REASON_EPT_MISCONFIGURATION                         0x00000031

                                                   /**
                                                    * @brief INVEPT
                                                    *
                                                    * Guest software attempted to execute INVEPT.
                                                    */
#define VMX_EXIT_REASON_EXECUTE_INVEPT                               0x00000032

                                                    /**
                                                     * @brief RDTSCP
                                                     *
                                                     * Guest software attempted to execute RDTSCP and the "enable RDTSCP" and "RDTSC exiting" VM-execution controls were both
                                                     * 1.
                                                     */
#define VMX_EXIT_REASON_EXECUTE_RDTSCP                               0x00000033

                                                     /**
                                                      * @brief VMX-preemption timer expired
                                                      *
                                                      * The preemption timer counted down to zero.
                                                      */
#define VMX_EXIT_REASON_VMX_PREEMPTION_TIMER_EXPIRED                 0x00000034

                                                      /**
                                                       * @brief INVVPID
                                                       *
                                                       * Guest software attempted to execute INVVPID.
                                                       */
#define VMX_EXIT_REASON_EXECUTE_INVVPID                              0x00000035

                                                       /**
                                                        * @brief WBINVD
                                                        *
                                                        * Guest software attempted to execute WBINVD and the "WBINVD exiting" VM-execution control was 1.
                                                        */
#define VMX_EXIT_REASON_EXECUTE_WBINVD                               0x00000036

                                                        /**
                                                         * @brief XSETBV - Guest software attempted to execute XSETBV
                                                         *
                                                         * Guest software attempted to execute XSETBV.
                                                         */
#define VMX_EXIT_REASON_EXECUTE_XSETBV                               0x00000037

                                                         /**
                                                          * @brief APIC write
                                                          *
                                                          * Guest software completed a write to the virtual-APIC page that must be virtualized by VMM software.
                                                          *
                                                          * @see Vol3C[29.4.3.3(APIC-Write VM Exits)]
                                                          */
#define VMX_EXIT_REASON_APIC_WRITE                                   0x00000038

                                                          /**
                                                           * @brief RDRAND
                                                           *
                                                           * Guest software attempted to execute RDRAND and the "RDRAND exiting" VM-execution control was 1.
                                                           */
#define VMX_EXIT_REASON_EXECUTE_RDRAND                               0x00000039

                                                           /**
                                                            * @brief INVPCID
                                                            *
                                                            * Guest software attempted to execute INVPCID and the "enable INVPCID" and "INVLPG exiting" VM-execution controls were
                                                            * both 1.
                                                            */
#define VMX_EXIT_REASON_EXECUTE_INVPCID                              0x0000003A

                                                            /**
                                                             * @brief VMFUNC
                                                             *
                                                             * Guest software invoked a VM function with the VMFUNC instruction and the VM function either was not enabled or generated
                                                             * a function-specific condition causing a VM exit.
                                                             */
#define VMX_EXIT_REASON_EXECUTE_VMFUNC                               0x0000003B

                                                             /**
                                                              * @brief ENCLS
                                                              *
                                                              * Guest software attempted to execute ENCLS and "enable ENCLS exiting" VM-execution control was 1 and either:
                                                              * -# EAX < 63 and the corresponding bit in the ENCLS-exiting bitmap is 1; or
                                                              * -# EAX >= 63 and bit 63 in the ENCLS-exiting bitmap is 1.
                                                              */
#define VMX_EXIT_REASON_EXECUTE_ENCLS                                0x0000003C

                                                              /**
                                                               * @brief RDSEED
                                                               *
                                                               * Guest software attempted to execute RDSEED and the "RDSEED exiting" VM-execution control was 1.
                                                               */
#define VMX_EXIT_REASON_EXECUTE_RDSEED                               0x0000003D

                                                               /**
                                                                * @brief Page-modification log full
                                                                *
                                                                * The processor attempted to create a page-modification log entry and the value of the PML index was not in the range
                                                                * 0-511.
                                                                */
#define VMX_EXIT_REASON_PAGE_MODIFICATION_LOG_FULL                   0x0000003E

                                                                /**
                                                                 * @brief XSAVES
                                                                 *
                                                                 * Guest software attempted to execute XSAVES, the "enable XSAVES/XRSTORS" was 1, and a bit was set in the logical-AND of
                                                                 * the following three values: EDX:EAX, the IA32_XSS MSR, and the XSS-exiting bitmap.
                                                                 */
#define VMX_EXIT_REASON_EXECUTE_XSAVES                               0x0000003F

                                                                 /**
                                                                  * @brief XRSTORS
                                                                  *
                                                                  * Guest software attempted to execute XRSTORS, the "enable XSAVES/XRSTORS" was 1, and a bit was set in the logical-AND of
                                                                  * the following three values: EDX:EAX, the IA32_XSS MSR, and the XSS-exiting bitmap.
                                                                  */
#define VMX_EXIT_REASON_EXECUTE_XRSTORS                              0x00000040
                                                                  /**
                                                                   * @}
                                                                   */

                                                                   /**
                                                                    * @defgroup vmx_instruction_error_numbers \
                                                                    *           VM-Instruction Error Numbers
                                                                    *
                                                                    * VM-Instruction Error Numbers.
                                                                    *
                                                                    * @see Vol3C[30.4(VM INSTRUCTION ERROR NUMBERS)] (reference)
                                                                    * @{
                                                                    */
                                                                    /**
                                                                     * VMCALL executed in VMX root operation.
                                                                     */
#define VMX_ERROR_VMCALL_IN_VMX_ROOT_OPERATION                       0x00000001

                                                                     /**
                                                                      * VMCLEAR with invalid physical address.
                                                                      */
#define VMX_ERROR_VMCLEAR_INVALID_PHYSICAL_ADDRESS                   0x00000002

                                                                      /**
                                                                       * VMCLEAR with VMXON pointer.
                                                                       */
#define VMX_ERROR_VMCLEAR_INVALID_VMXON_POINTER                      0x00000003

                                                                       /**
                                                                        * VMLAUNCH with non-clear VMCS.
                                                                        */
#define VMX_ERROR_VMLAUCH_NON_CLEAR_VMCS                             0x00000004

                                                                        /**
                                                                         * VMRESUME with non-launched VMCS.
                                                                         */
#define VMX_ERROR_VMRESUME_NON_LAUNCHED_VMCS                         0x00000005

                                                                         /**
                                                                          * VMRESUME after VMXOFF (VMXOFF and VMXON between VMLAUNCH and VMRESUME).
                                                                          */
#define VMX_ERROR_VMRESUME_AFTER_VMXOFF                              0x00000006

                                                                          /**
                                                                           * VM entry with invalid control field(s).
                                                                           */
#define VMX_ERROR_VMENTRY_INVALID_CONTROL_FIELDS                     0x00000007

                                                                           /**
                                                                            * VM entry with invalid host-state field(s).
                                                                            */
#define VMX_ERROR_VMENTRY_INVALID_HOST_STATE                         0x00000008

                                                                            /**
                                                                             * VMPTRLD with invalid physical address.
                                                                             */
#define VMX_ERROR_VMPTRLD_INVALID_PHYSICAL_ADDRESS                   0x00000009

                                                                             /**
                                                                              * VMPTRLD with VMXON pointer.
                                                                              */
#define VMX_ERROR_VMPTRLD_VMXON_POINTER                              0x0000000A

                                                                              /**
                                                                               * VMPTRLD with incorrect VMCS revision identifier.
                                                                               */
#define VMX_ERROR_VMPTRLD_INCORRECT_VMCS_REVISION_ID                 0x0000000B

                                                                               /**
                                                                                * VMREAD/VMWRITE from/to unsupported VMCS component.
                                                                                */
#define VMX_ERROR_VMREAD_VMWRITE_INVALID_COMPONENT                   0x0000000C

                                                                                /**
                                                                                 * VMWRITE to read-only VMCS component.
                                                                                 */
#define VMX_ERROR_VMWRITE_READONLY_COMPONENT                         0x0000000D

                                                                                 /**
                                                                                  * VMXON executed in VMX root operation.
                                                                                  */
#define VMX_ERROR_VMXON_IN_VMX_ROOT_OP                               0x0000000F

                                                                                  /**
                                                                                   * VM entry with invalid executive-VMCS pointer.
                                                                                   */
#define VMX_ERROR_VMENTRY_INVALID_VMCS_EXECUTIVE_POINTER             0x00000010

                                                                                   /**
                                                                                    * VM entry with non-launched executive VMCS.
                                                                                    */
#define VMX_ERROR_VMENTRY_NON_LAUNCHED_EXECUTIVE_VMCS                0x00000011

                                                                                    /**
                                                                                     * VM entry with executive-VMCS pointer not VMXON pointer (when attempting to deactivate the dual-monitor treatment of SMIs
                                                                                     * and SMM).
                                                                                     */
#define VMX_ERROR_VMENTRY_EXECUTIVE_VMCS_PTR                         0x00000012

                                                                                     /**
                                                                                      * VMCALL with non-clear VMCS (when attempting to activate the dual-monitor treatment of SMIs and SMM).
                                                                                      */
#define VMX_ERROR_VMCALL_NON_CLEAR_VMCS                              0x00000013

                                                                                      /**
                                                                                       * VMCALL with invalid VM-exit control fields.
                                                                                       */
#define VMX_ERROR_VMCALL_INVALID_VMEXIT_FIELDS                       0x00000014

                                                                                       /**
                                                                                        * VMCALL with incorrect MSEG revision identifier (when attempting to activate the dual-monitor treatment of SMIs and SMM).
                                                                                        */
#define VMX_ERROR_VMCALL_INVALID_MSEG_REVISION_ID                    0x00000016

                                                                                        /**
                                                                                         * VMXOFF under dual-monitor treatment of SMIs and SMM.
                                                                                         */
#define VMX_ERROR_VMXOFF_DUAL_MONITOR                                0x00000017

                                                                                         /**
                                                                                          * VMCALL with invalid SMM-monitor features (when attempting to activate the dual-monitor treatment of SMIs and SMM).
                                                                                          */
#define VMX_ERROR_VMCALL_INVALID_SMM_MONITOR                         0x00000018

                                                                                          /**
                                                                                           * VM entry with invalid VM-execution control fields in executive VMCS (when attempting to return from SMM).
                                                                                           */
#define VMX_ERROR_VMENTRY_INVALID_VM_EXECUTION_CONTROL               0x00000019

                                                                                           /**
                                                                                            * VM entry with events blocked by MOV SS.
                                                                                            */
#define VMX_ERROR_VMENTRY_MOV_SS                                     0x0000001A

                                                                                            /**
                                                                                             * Invalid operand to INVEPT/INVVPID.
                                                                                             */
#define VMX_ERROR_INVEPT_INVVPID_INVALID_OPERAND                     0x0000001C
                                                                                             /**
                                                                                              * @}
                                                                                              */

                                                                                              /**
                                                                                               * @defgroup vmx_exceptions \
                                                                                               *           Virtualization Exceptions
                                                                                               *
                                                                                               * Virtualization Exceptions.
                                                                                               *
                                                                                               * @see Vol3C[25.5.6(Virtualization Exceptions)] (reference)
                                                                                               * @{
                                                                                               */
typedef struct
{
    /**
     * The 32-bit value that would have been saved into the VMCS as an exit reason had a VM exit occurred instead of the
     * virtualization exception. For EPT violations, this value is 48 (00000030H).
     */
    UINT32_t reason;

    /**
     * FFFFFFFFH
     */
    UINT32_t exception_mask;

    /**
     * The 64-bit value that would have been saved into the VMCS as an exit qualification had a VM exit occurred instead of the
     * virtualization exception.
     */
    UINT64_t exit;

    /**
     * The 64-bit value that would have been saved into the VMCS as a guest-linear address had a VM exit occurred instead of
     * the virtualization exception.
     */
    UINT64_t guest_linear_address;

    /**
     * The 64-bit value that would have been saved into the VMCS as a guest-physical address had a VM exit occurred instead of
     * the virtualization exception.
     */
    UINT64_t guest_physical_address;

    /**
     * The current 16-bit value of the EPTP index VM-execution control.
     *
     * @see Vol3C[24.6.18(Controls for Virtualization Exceptions)]
     * @see Vol3C[25.5.5.3(EPTP Switching)]
     */
    UINT16_t current_eptp_index;
} vmx_virtualization_exception_information;

/**
 * @}
 */

 /**
  * @defgroup vmx_basic_exit_information \
  *           Basic VM-Exit Information
  *
  * Basic VM-Exit Information.
  *
  * @see Vol3C[27.2.1(Basic VM-Exit Information)] (reference)
  * @{
  */
  /**
   * @brief Exit Qualification for Debug Exceptions
   */
typedef union
{
    struct
    {
        /**
         * @brief B0 - B3
         *
         * [Bits 3:0] When set, each of these bits indicates that the corresponding breakpoint condition was met. Any of these bits
         * may be set even if its corresponding enabling bit in DR7 is not set.
         */
        UINT64_t breakpoint_condition : 4;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_BIT 0
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_FLAG 0x0F
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_MASK 0x0F
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION(_) (((_) >> 0) & 0x0F)
        UINT64_t reserved1 : 9;

        /**
         * @brief BD
         *
         * [Bit 13] When set, this bit indicates that the cause of the debug exception is "debug register access detected."
         */
        UINT64_t debug_register_access_detected : 1;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_BIT 13
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_FLAG 0x2000
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_MASK 0x01
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED(_) (((_) >> 13) & 0x01)

        /**
         * @brief BS
         *
         * [Bit 14] When set, this bit indicates that the cause of the debug exception is either the execution of a single
         * instruction (if RFLAGS.TF = 1 and IA32_DEBUGCTL.BTF = 0) or a taken branch (if RFLAGS.TF = DEBUGCTL.BTF = 1).
         */
        UINT64_t single_instruction : 1;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_BIT 14
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_FLAG 0x4000
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION(_) (((_) >> 14) & 0x01)
        UINT64_t reserved2 : 49;
    };

    UINT64_t flags;
} vmx_exit_qualification_debug_exception;

/**
 * @brief Exit Qualification for Task Switch
 */
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] Selector of task-state segment (TSS) to which the guest attempted to switch.
         */
        UINT64_t selector : 16;
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_BIT              0
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_FLAG             0xFFFF
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_MASK             0xFFFF
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR(_)               (((_) >> 0) & 0xFFFF)
        UINT64_t reserved1 : 14;

        /**
         * [Bits 31:30] Source of task switch initiation.
         */
        UINT64_t source : 2;
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_BIT                30
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_FLAG               0xC0000000
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_MASK               0x03
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE(_)                 (((_) >> 30) & 0x03)
#define VMX_EXIT_QUALIFICATION_TYPE_CALL_INSTRUCTION                 0x00000000
#define VMX_EXIT_QUALIFICATION_TYPE_IRET_INSTRUCTION                 0x00000001
#define VMX_EXIT_QUALIFICATION_TYPE_JMP_INSTRUCTION                  0x00000002
#define VMX_EXIT_QUALIFICATION_TYPE_TASK_GATE_IN_IDT                 0x00000003
        UINT64_t reserved2 : 32;
    };

    UINT64_t flags;
} vmx_exit_qualification_task_switch;

/**
 * @brief Exit Qualification for Control-Register Accesses
 */
typedef union
{
    struct
    {
        /**
         * [Bits 3:0] Number of control register (0 for CLTS and LMSW). Bit 3 is always 0 on processors that do not support Intel
         * 64 architecture as they do not support CR8.
         */
        UINT64_t control_register : 4;
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_BIT           0
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_FLAG          0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_MASK          0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER(_)            (((_) >> 0) & 0x0F)
#define VMX_EXIT_QUALIFICATION_REGISTER_CR0                          0x00000000
#define VMX_EXIT_QUALIFICATION_REGISTER_CR2                          0x00000002
#define VMX_EXIT_QUALIFICATION_REGISTER_CR3                          0x00000003
#define VMX_EXIT_QUALIFICATION_REGISTER_CR4                          0x00000004
#define VMX_EXIT_QUALIFICATION_REGISTER_CR8                          0x00000008

        /**
         * [Bits 5:4] Access type.
         */
        UINT64_t access_type : 2;
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_BIT                4
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_FLAG               0x30
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_MASK               0x03
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE(_)                 (((_) >> 4) & 0x03)
#define VMX_EXIT_QUALIFICATION_ACCESS_MOV_TO_CR                      0x00000000
#define VMX_EXIT_QUALIFICATION_ACCESS_MOV_FROM_CR                    0x00000001
#define VMX_EXIT_QUALIFICATION_ACCESS_CLTS                           0x00000002
#define VMX_EXIT_QUALIFICATION_ACCESS_LMSW                           0x00000003

        /**
         * [Bit 6] LMSW operand type. For CLTS and MOV CR, cleared to 0.
         */
        UINT64_t lmsw_operand_type : 1;
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_BIT          6
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_FLAG         0x40
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_MASK         0x01
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE(_)           (((_) >> 6) & 0x01)
#define VMX_EXIT_QUALIFICATION_LMSW_OP_REGISTER                      0x00000000
#define VMX_EXIT_QUALIFICATION_LMSW_OP_MEMORY                        0x00000001
        UINT64_t reserved1 : 1;

        /**
         * [Bits 11:8] For MOV CR, the general-purpose register.
         */
        UINT64_t general_purpose_register : 4;
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_BIT   8
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_FLAG  0xF00
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_MASK  0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER(_)    (((_) >> 8) & 0x0F)
#define VMX_EXIT_QUALIFICATION_GENREG_RAX                            0x00000000
#define VMX_EXIT_QUALIFICATION_GENREG_RCX                            0x00000001
#define VMX_EXIT_QUALIFICATION_GENREG_RDX                            0x00000002
#define VMX_EXIT_QUALIFICATION_GENREG_RBX                            0x00000003
#define VMX_EXIT_QUALIFICATION_GENREG_RSP                            0x00000004
#define VMX_EXIT_QUALIFICATION_GENREG_RBP                            0x00000005
#define VMX_EXIT_QUALIFICATION_GENREG_RSI                            0x00000006
#define VMX_EXIT_QUALIFICATION_GENREG_RDI                            0x00000007
#define VMX_EXIT_QUALIFICATION_GENREG_R8                             0x00000008
#define VMX_EXIT_QUALIFICATION_GENREG_R9                             0x00000009
#define VMX_EXIT_QUALIFICATION_GENREG_R10                            0x0000000A
#define VMX_EXIT_QUALIFICATION_GENREG_R11                            0x0000000B
#define VMX_EXIT_QUALIFICATION_GENREG_R12                            0x0000000C
#define VMX_EXIT_QUALIFICATION_GENREG_R13                            0x0000000D
#define VMX_EXIT_QUALIFICATION_GENREG_R14                            0x0000000E
#define VMX_EXIT_QUALIFICATION_GENREG_R15                            0x0000000F
        UINT64_t reserved2 : 4;

        /**
         * [Bits 31:16] For LMSW, the LMSW source data. For CLTS and MOV CR, cleared to 0.
         */
        UINT64_t lmsw_source_data : 16;
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_BIT           16
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_FLAG          0xFFFF0000
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_MASK          0xFFFF
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA(_)            (((_) >> 16) & 0xFFFF)
        UINT64_t reserved3 : 32;
    };

    UINT64_t flags;
} vmx_exit_qualification_mov_cr;

/**
 * @brief Exit Qualification for MOV DR
 */
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] Number of debug register.
         */
        UINT64_t debug_register : 3;
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_BIT             0
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_FLAG            0x07
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_MASK            0x07
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER(_)              (((_) >> 0) & 0x07)
#define VMX_EXIT_QUALIFICATION_REGISTER_DR0                          0x00000000
#define VMX_EXIT_QUALIFICATION_REGISTER_DR1                          0x00000001
#define VMX_EXIT_QUALIFICATION_REGISTER_DR2                          0x00000002
#define VMX_EXIT_QUALIFICATION_REGISTER_DR3                          0x00000003
#define VMX_EXIT_QUALIFICATION_REGISTER_DR6                          0x00000006
#define VMX_EXIT_QUALIFICATION_REGISTER_DR7                          0x00000007
        UINT64_t reserved1 : 1;

        /**
         * [Bit 4] Direction of access (0 = MOV to DR; 1 = MOV from DR).
         */
        UINT64_t direction_of_access : 1;
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_BIT        4
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_FLAG       0x10
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_MASK       0x01
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS(_)         (((_) >> 4) & 0x01)
#define VMX_EXIT_QUALIFICATION_DIRECTION_MOV_TO_DR                   0x00000000
#define VMX_EXIT_QUALIFICATION_DIRECTION_MOV_FROM_DR                 0x00000001
        UINT64_t reserved2 : 3;

        /**
         * [Bits 11:8] General-purpose register.
         */
        UINT64_t general_purpose_register : 4;
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_BIT   8
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_FLAG  0xF00
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_MASK  0x0F
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER(_)    (((_) >> 8) & 0x0F)
        UINT64_t reserved3 : 52;
    };

    UINT64_t flags;
} vmx_exit_qualification_mov_dr;

/**
 * @brief Exit Qualification for I/O Instructions
 */
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] Size of access.
         */
        UINT64_t size_of_access : 3;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_BIT     0
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_FLAG    0x07
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_MASK    0x07
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS(_)      (((_) >> 0) & 0x07)
#define VMX_EXIT_QUALIFICATION_WIDTH_1UINT8                          0x00000000
#define VMX_EXIT_QUALIFICATION_WIDTH_2UINT8                          0x00000001
#define VMX_EXIT_QUALIFICATION_WIDTH_4UINT8                          0x00000003

        /**
         * [Bit 3] Direction of the attempted access (0 = OUT, 1 = IN).
         */
        UINT64_t direction_of_access : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_BIT 3
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_FLAG 0x08
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS(_) (((_) >> 3) & 0x01)
#define VMX_EXIT_QUALIFICATION_DIRECTION_OUT                         0x00000000
#define VMX_EXIT_QUALIFICATION_DIRECTION_IN                          0x00000001

        /**
         * [Bit 4] String instruction (0 = not string; 1 = string).
         */
        UINT64_t string_instruction : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_BIT 4
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_FLAG 0x10
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION(_)  (((_) >> 4) & 0x01)
#define VMX_EXIT_QUALIFICATION_IS_STRING_NOT_STRING                  0x00000000
#define VMX_EXIT_QUALIFICATION_IS_STRING_STRING                      0x00000001

        /**
         * [Bit 5] REP prefixed (0 = not REP; 1 = REP).
         */
        UINT64_t rep_prefixed : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_BIT       5
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_FLAG      0x20
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_MASK      0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED(_)        (((_) >> 5) & 0x01)
#define VMX_EXIT_QUALIFICATION_IS_REP_NOT_REP                        0x00000000
#define VMX_EXIT_QUALIFICATION_IS_REP_REP                            0x00000001

        /**
         * [Bit 6] Operand encoding (0 = DX, 1 = immediate).
         */
        UINT64_t operand_encoding : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_BIT   6
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_FLAG  0x40
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_MASK  0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING(_)    (((_) >> 6) & 0x01)
#define VMX_EXIT_QUALIFICATION_ENCODING_DX                           0x00000000
#define VMX_EXIT_QUALIFICATION_ENCODING_IMMEDIATE                    0x00000001
        UINT64_t reserved1 : 9;

        /**
         * [Bits 31:16] Port number (as specified in DX or in an immediate operand).
         */
        UINT64_t port_number : 16;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_BIT        16
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_FLAG       0xFFFF0000
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_MASK       0xFFFF
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER(_)         (((_) >> 16) & 0xFFFF)
        UINT64_t reserved2 : 32;
    };

    UINT64_t flags;
} vmx_exit_qualification_io_instruction;

/**
 * @brief Exit Qualification for APIC-Access VM Exits from Linear Accesses and Guest-Physical Accesses
 */
typedef union
{
    struct
    {
        /**
         * [Bits 11:0] - If the APIC-access VM exit is due to a linear access, the offset of access within the APIC page.
         * - Undefined if the APIC-access VM exit is due a guest-physical access.
         */
        UINT64_t page_offset : 12;
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_BIT           0
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_FLAG          0xFFF
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_MASK          0xFFF
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET(_)            (((_) >> 0) & 0xFFF)

        /**
         * [Bits 15:12] Access type.
         */
        UINT64_t access_type : 4;
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_BIT           12
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_FLAG          0xF000
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_MASK          0x0F
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE(_)            (((_) >> 12) & 0x0F)
        /**
         * Linear access for a data read during instruction execution.
         */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_READ                      0x00000000

         /**
          * Linear access for a data write during instruction execution.
          */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_WRITE                     0x00000001

          /**
           * Linear access for an instruction fetch.
           */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_INSTRUCTION_FETCH         0x00000002

           /**
            * Linear access (read or write) during event delivery.
            */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_EVENT_DELIVERY            0x00000003

            /**
             * Guest-physical access during event delivery.
             */
#define VMX_EXIT_QUALIFICATION_TYPE_PHYSICAL_EVENT_DELIVERY          0x0000000A

             /**
              * Guest-physical access for an instruction fetch or during instruction execution.
              */
#define VMX_EXIT_QUALIFICATION_TYPE_PHYSICAL_INSTRUCTION_FETCH       0x0000000F
        UINT64_t reserved1 : 48;
    };

    UINT64_t flags;
} vmx_exit_qualification_apic_access;

/**
 * @brief Exit Qualification for EPT Violations
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Set if the access causing the EPT violation was a data read.
         */
        UINT64_t read_access : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_BIT         0
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_FLAG        0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_MASK        0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS(_)          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Set if the access causing the EPT violation was a data write.
         */
        UINT64_t write_access : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_BIT        1
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_FLAG       0x02
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_MASK       0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS(_)         (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Set if the access causing the EPT violation was an instruction fetch.
         */
        UINT64_t execute_access : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_BIT      2
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_FLAG     0x04
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_MASK     0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS(_)       (((_) >> 2) & 0x01)

        /**
         * [Bit 3] The logical-AND of bit 0 in the EPT paging-structure entries used to translate the guest-physical address of the
         * access causing the EPT violation (indicates whether the guest-physical address was readable).
         */
        UINT64_t ept_readable : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_BIT        3
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_FLAG       0x08
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_MASK       0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE(_)         (((_) >> 3) & 0x01)

        /**
         * [Bit 4] The logical-AND of bit 1 in the EPT paging-structure entries used to translate the guest-physical address of the
         * access causing the EPT violation (indicates whether the guest-physical address was writeable).
         */
        UINT64_t ept_writeable : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_BIT       4
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_FLAG      0x10
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_MASK      0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE(_)        (((_) >> 4) & 0x01)

        /**
         * [Bit 5] The logical-AND of bit 2 in the EPT paging-structure entries used to translate the guest-physical address of the
         * access causing the EPT violation.
         * If the "mode-based execute control for EPT" VM-execution control is 0, this indicates whether the guest-physical address
         * was executable. If that control is 1, this indicates whether the guest-physical address was executable for
         * supervisor-mode linear addresses.
         */
        UINT64_t ept_executable : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_BIT      5
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FLAG     0x20
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_MASK     0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE(_)       (((_) >> 5) & 0x01)

        /**
         * [Bit 6] If the "mode-based execute control" VM-execution control is 0, the value of this bit is undefined. If that
         * control is 1, this bit is the logical-AND of bit 10 in the EPT paging-structures entries used to translate the
         * guest-physical address of the access causing the EPT violation. In this case, it indicates whether the guest-physical
         * address was executable for user-mode linear addresses.
         */
        UINT64_t ept_executable_for_user_mode : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_BIT 6
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_FLAG 0x40
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE(_) (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Set if the guest linear-address field is valid. The guest linear-address field is valid for all EPT violations
         * except those resulting from an attempt to load the guest PDPTEs as part of the execution of the MOV CR instruction.
         */
        UINT64_t valid_guest_linear_address : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_BIT 7
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_FLAG 0x80
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS(_) (((_) >> 7) & 0x01)

        /**
         * [Bit 8] If bit 7 is 1:
         * - Set if the access causing the EPT violation is to a guest-physical address that is the translation of a linear
         * address.
         * - Clear if the access causing the EPT violation is to a paging-structure entry as part of a page walk or the update of
         * an accessed or dirty bit.
         * Reserved if bit 7 is 0 (cleared to 0).
         */
        UINT64_t caused_by_translation : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_BIT 8
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_FLAG 0x100
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION(_) (((_) >> 8) & 0x01)

        /**
         * [Bit 9] This bit is 0 if the linear address is a supervisor-mode linear address and 1 if it is a user-mode linear
         * address. Otherwise, this bit is undefined.
         *
         * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information for EPT violations. (If
         *          CR0.PG = 0, the translation of every linear address is a user-mode linear address and thus this bit will be 1.)
         */
        UINT64_t user_mode_linear_address : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_BIT 9
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_FLAG 0x200
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS(_) (((_) >> 9) & 0x01)

        /**
         * [Bit 10] This bit is 0 if paging translates the linear address to a read-only page and 1 if it translates to a
         * read/write page. Otherwise, this bit is undefined
         *
         * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information for EPT violations. (If
         *          CR0.PG = 0, every linear address is read/write and thus this bit will be 1.)
         */
        UINT64_t readable_writable_page : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_BIT 10
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_FLAG 0x400
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE(_) (((_) >> 10) & 0x01)

        /**
         * [Bit 11] This bit is 0 if paging translates the linear address to an executable page and 1 if it translates to an
         * execute-disable page. Otherwise, this bit is undefined.
         *
         * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information for EPT violations. (If
         *          CR0.PG = 0, CR4.PAE = 0, or IA32_EFER.NXE = 0, every linear address is executable and thus this bit will be 0.)
         */
        UINT64_t execute_disable_page : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_BIT 11
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_FLAG 0x800
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE(_) (((_) >> 11) & 0x01)

        /**
         * [Bit 12] NMI unblocking due to IRET.
         */
        UINT64_t nmi_unblocking : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_BIT      12
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_FLAG     0x1000
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_MASK     0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING(_)       (((_) >> 12) & 0x01)
        UINT64_t reserved1 : 51;
    };

    UINT64_t flags;
} vmx_exit_qualification_ept_violation;

/**
 * @}
 */

 /**
  * @defgroup vmx_vmexit_instruction_information \
  *           Information for VM Exits Due to Instruction Execution
  *
  * Information for VM Exits Due to Instruction Execution.
  *
  * @see Vol3C[27.2.4(Information for VM Exits Due to Instruction Execution)] (reference)
  * @{
  */
  /**
   * @brief VM-Exit Instruction-Information Field as Used for INS and OUTS
   */
typedef union
{
    struct
    {
        UINT64_t reserved1 : 7;

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used.
         */
        UINT64_t address_size : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_BIT        7
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_FLAG       0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_MASK       0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE(_)         (((_) >> 7) & 0x07)
        UINT64_t reserved2 : 5;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used. Undefined for VM exits due to execution of INS.
         */
        UINT64_t segment_register : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_BIT    15
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_FLAG   0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_MASK   0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER(_)     (((_) >> 15) & 0x07)
        UINT64_t reserved3 : 46;
    };

    UINT64_t flags;
} vmx_vmexit_instruction_info_ins_outs;

/**
 * @brief VM-Exit Instruction-Information Field as Used for INVEPT, INVPCID, and INVVPID
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64_t scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_BIT           0
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_FLAG          0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_MASK          0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING(_)            (((_) >> 0) & 0x03)
        UINT64_t reserved1 : 5;

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used.
         */
        UINT64_t address_size : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_BIT      7
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_FLAG     0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_MASK     0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE(_)       (((_) >> 7) & 0x07)
        UINT64_t reserved2 : 5;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used. Undefined for VM exits due to execution of INS.
         */
        UINT64_t segment_register : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_BIT  15
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER(_)   (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64_t general_purpose_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
         */
        UINT64_t general_purpose_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory instructions with no base register (bit 27 is
         * set).
         */
        UINT64_t base_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_BIT     23
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_FLAG    0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_MASK    0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER(_)      (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
         */
        UINT64_t base_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

        /**
         * [Bits 31:28] Reg2 (same encoding as IndexReg above).
         */
        UINT64_t register_2 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_BIT        28
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_FLAG       0xF0000000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_MASK       0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2(_)         (((_) >> 28) & 0x0F)
        UINT64_t reserved3 : 32;
    };

    UINT64_t flags;
} vmx_vmexit_instruction_info_invalidate;

/**
 * @brief VM-Exit Instruction-Information Field as Used for LIDT, LGDT, SIDT, or SGDT
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64_t scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_BIT     0
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_FLAG    0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_MASK    0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING(_)      (((_) >> 0) & 0x03)
        UINT64_t reserved1 : 5;

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used.
         */
        UINT64_t address_size : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_BIT 7
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE(_) (((_) >> 7) & 0x07)
        UINT64_t reserved2 : 1;

        /**
         * @brief Operand size
         *
         * [Bit 11] 0: 16-bit
         * 1: 32-bit
         * Undefined for VM exits from 64-bit mode.
         */
        UINT64_t operand_size : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_BIT 11
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_FLAG 0x800
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE(_) (((_) >> 11) & 0x01)
        UINT64_t reserved3 : 3;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used.
         */
        UINT64_t segment_register : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64_t general_purpose_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
         */
        UINT64_t general_purpose_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory instructions with no base register (bit 27 is
         * set).
         */
        UINT64_t base_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER(_) (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
         */
        UINT64_t base_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

        /**
         * @brief Instruction identity
         *
         * [Bits 29:28] 0: SGDT
         * 1: SIDT
         * 2: LGDT
         * 3: LIDT
         */
        UINT64_t instruction : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_BIT 28
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_FLAG 0x30000000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION(_)  (((_) >> 28) & 0x03)
        UINT64_t reserved4 : 34;
    };

    UINT64_t flags;
} vmx_vmexit_instruction_info_gdtr_idtr_access;

/**
 * @brief VM-Exit Instruction-Information Field as Used for LLDT, LTR, SLDT, and STR
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64_t scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_BIT       0
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_FLAG      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_MASK      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING(_)        (((_) >> 0) & 0x03)
        UINT64_t reserved1 : 1;

        /**
         * [Bits 6:3] Reg1. Undefined for memory instructions (bit 10 is clear).
         */
        UINT64_t reg_1 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_BIT         3
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_FLAG        0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_MASK        0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1(_)          (((_) >> 3) & 0x0F)

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used. Undefined for register instructions (bit 10 is set).
         */
        UINT64_t address_size : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)

        /**
         * [Bit 10] Mem/Reg (0 = memory; 1 = register).
         */
        UINT64_t memory_register : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_BIT 10
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_FLAG 0x400
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER(_) (((_) >> 10) & 0x01)
        UINT64_t reserved2 : 4;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used. Undefined for register instructions (bit 10 is set).
         */
        UINT64_t segment_register : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for register instructions (bit 10 is set) and for memory instructions
         * with no index register (bit 10 is clear and bit 22 is set).
         */
        UINT64_t general_purpose_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid). Undefined for register instructions (bit 10 is set).
         */
        UINT64_t general_purpose_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for register instructions (bit 10 is set) and for memory
         * instructions with no base register (bit 10 is clear and bit 27 is set).
         */
        UINT64_t base_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER(_)  (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid). Undefined for register instructions (bit 10 is set).
         */
        UINT64_t base_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

        /**
         * @brief Instruction identity
         *
         * [Bits 29:28] 0: SLDT
         * 1: STR
         * 2: LLDT
         * 3: LTR
         */
        UINT64_t instruction : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_BIT   28
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_FLAG  0x30000000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_MASK  0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION(_)    (((_) >> 28) & 0x03)
        UINT64_t reserved3 : 34;
    };

    UINT64_t flags;
} vmx_vmexit_instruction_info_ldtr_tr_access;

/**
 * @brief VM-Exit Instruction-Information Field as Used for RDRAND and RDSEED
 */
typedef union
{
    struct
    {
        UINT64_t reserved1 : 3;

        /**
         * [Bits 6:3] Destination register.
         */
        UINT64_t destination_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_BIT 3
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_FLAG 0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER(_) (((_) >> 3) & 0x0F)
        UINT64_t reserved2 : 4;

        /**
         * @brief Operand size
         *
         * [Bits 12:11] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit
         * The value 3 is not used.
         */
        UINT64_t operand_size : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_BIT   11
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_FLAG  0x1800
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_MASK  0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE(_)    (((_) >> 11) & 0x03)
        UINT64_t reserved3 : 51;
    };

    UINT64_t flags;
} vmx_vmexit_instruction_info_rdrand_rdseed;

/**
 * @brief VM-Exit Instruction-Information Field as Used for VMCLEAR, VMPTRLD, VMPTRST, VMXON, XRSTORS, and XSAVES
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64_t scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_BIT       0
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_FLAG      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_MASK      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING(_)        (((_) >> 0) & 0x03)
        UINT64_t reserved1 : 5;

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used.
         */
        UINT64_t address_size : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)
        UINT64_t reserved2 : 5;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used.
         */
        UINT64_t segment_register : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64_t general_purpose_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
         */
        UINT64_t general_purpose_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory instructions with no base register (bit 27 is
         * set).
         */
        UINT64_t base_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER(_)  (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
         */
        UINT64_t base_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)
        UINT64_t reserved3 : 36;
    };

    UINT64_t flags;
} vmx_vmexit_instruction_info_vmx_and_xsaves;

/**
 * @brief VM-Exit Instruction-Information Field as Used for VMREAD and VMWRITE
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for register instructions (bit 10 is set) and for memory instructions with no index register (bit 10 is clear
         * and bit 22 is set).
         */
        UINT64_t scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_BIT       0
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_FLAG      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_MASK      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING(_)        (((_) >> 0) & 0x03)
        UINT64_t reserved1 : 1;

        /**
         * [Bits 6:3] Reg1. Undefined for memory instructions (bit 10 is clear).
         */
        UINT64_t register_1 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_BIT    3
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_FLAG   0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_MASK   0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1(_)     (((_) >> 3) & 0x0F)

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used. Undefined for register instructions (bit 10 is set).
         */
        UINT64_t address_size : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)

        /**
         * [Bit 10] Mem/Reg (0 = memory; 1 = register).
         */
        UINT64_t memory_register : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_BIT 10
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_FLAG 0x400
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER(_) (((_) >> 10) & 0x01)
        UINT64_t reserved2 : 4;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used. Undefined for register instructions (bit 10 is set).
         */
        UINT64_t segment_register : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for register instructions (bit 10 is set) and for memory instructions
         * with no index register (bit 10 is clear and bit 22 is set).
         */
        UINT64_t general_purpose_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid). Undefined for register instructions (bit 10 is set).
         */
        UINT64_t general_purpose_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as Reg1 above). Undefined for register instructions (bit 10 is set) and for memory
         * instructions with no base register (bit 10 is clear and bit 27 is set).
         */
        UINT64_t base_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER(_)  (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
         */
        UINT64_t base_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

        /**
         * [Bits 31:28] Reg2 (same encoding as IndexReg above).
         */
        UINT64_t register_2 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_BIT    28
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_FLAG   0xF0000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_MASK   0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2(_)     (((_) >> 28) & 0x0F)
        UINT64_t reserved3 : 32;
    };

    UINT64_t flags;
} vmx_vmexit_instruction_info_vmread_vmwrite;

/**
 * @}
 */

 /**
  * @brief - The low 16 bits correspond to bits 23:8 of the upper 32 bits of a 64-bit segment descriptor. While bits 19:16
  *        of code-segment and data-segment descriptors correspond to the upper 4 bits of the segment limit, the corresponding bits
  *        (bits 11:8) are reserved in this VMCS field.
  *        - Bit 16 indicates an unusable segment. Attempts to use such a segment fault except in 64-bit mode. In general, a
  *        segment register is unusable if it has been loaded with a null selector.
  *        - Bits 31:17 are reserved
  *
  * @note There are a few exceptions to this statement. For example, a segment with a non-null selector may be unusable
  *       following a task switch that fails after its commit point. In contrast, the TR register is usable after processor reset
  *       despite having a null selector
  * @see SEGMENT_DESCRIPTOR_32
  * @see SEGMENT_DESCRIPTOR_64
  * @see XXX_ACCESS_RIGHTS fields of 32_BIT_GUEST_STATE_FIELDS
  * @see Vol3C[24.4.2(Guest Non-Register State)] (reference)
  */
typedef union
{
    struct
    {
        /**
         * [Bits 3:0] Segment type.
         */
        UINT32_t type : 4;
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_BIT                           0
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_FLAG                          0x0F
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_MASK                          0x0F
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE(_)                            (((_) >> 0) & 0x0F)

        /**
         * [Bit 4] S - Descriptor type (0 = system; 1 = code or data).
         */
        UINT32_t descriptor_type : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_BIT                4
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_FLAG               0x10
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_MASK               0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE(_)                 (((_) >> 4) & 0x01)

        /**
         * [Bits 6:5] DPL - Descriptor privilege level.
         */
        UINT32_t descriptor_privilege_level : 2;
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_BIT     5
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_FLAG    0x60
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_MASK    0x03
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL(_)      (((_) >> 5) & 0x03)

        /**
         * [Bit 7] P - Segment present.
         */
        UINT32_t present : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_BIT                        7
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_FLAG                       0x80
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_MASK                       0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT(_)                         (((_) >> 7) & 0x01)
        UINT32_t reserved1 : 4;

        /**
         * [Bit 12] AVL - Available for use by system software.
         */
        UINT32_t available_bit : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_BIT                  12
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_FLAG                 0x1000
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_MASK                 0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT(_)                   (((_) >> 12) & 0x01)

        /**
         * [Bit 13] Reserved (except for CS). L - 64-bit mode active (for CS only).
         */
        UINT32_t long_mode : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_BIT                      13
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_FLAG                     0x2000
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_MASK                     0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE(_)                       (((_) >> 13) & 0x01)

        /**
         * [Bit 14] D/B - Default operation size (0 = 16-bit segment; 1 = 32-bit segment).
         */
        UINT32_t default_big : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_BIT                    14
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_FLAG                   0x4000
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_MASK                   0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG(_)                     (((_) >> 14) & 0x01)

        /**
         * [Bit 15] G - Granularity.
         */
        UINT32_t granularity : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_BIT                    15
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_FLAG                   0x8000
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_MASK                   0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY(_)                     (((_) >> 15) & 0x01)

        /**
         * [Bit 16] Segment unusable (0 = usable; 1 = unusable).
         */
        UINT32_t unusable : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_BIT                       16
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_FLAG                      0x10000
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_MASK                      0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE(_)                        (((_) >> 16) & 0x01)
        UINT32_t reserved2 : 15;
    };

    UINT32_t flags;
} vmx_segment_access_rights;

/**
 * @brief The IA-32 architecture includes features that permit certain events to be blocked for a period of time. This
 *        field contains information about such blocking
 *
 * @see INTERRUPTIBILITY_STATE of 32_BIT_GUEST_STATE_FIELDS
 * @see Vol3C[24.4.2(Guest Non-Register State)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Execution of STI with RFLAGS.IF = 0 blocks maskable interrupts on the instruction boundary following its
         * execution.1 Setting this bit indicates that this blocking is in effect.
         *
         * @see Vol2B[4(STI-Set Interrupt Flag)]
         */
        UINT32_t blocking_by_sti : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_BIT               0
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_FLAG              0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_MASK              0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI(_)                (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Execution of a MOV to SS or a POP to SS blocks or suppresses certain debug exceptions as well as interrupts
         * (maskable and nonmaskable) on the instruction boundary following its execution. Setting this bit indicates that this
         * blocking is in effect. This document uses the term "blocking by MOV SS," but it applies equally to POP SS.
         *
         * @see Vol3A[6.8.3(Masking Exceptions and Interrupts When Switching Stacks)]
         */
        UINT32_t blocking_by_mov_ss : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_BIT            1
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_FLAG           0x02
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_MASK           0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS(_)             (((_) >> 1) & 0x01)

        /**
         * [Bit 2] System-management interrupts (SMIs) are disabled while the processor is in system-management mode (SMM). Setting
         * this bit indicates that blocking of SMIs is in effect.
         *
         * @see Vol3C[34.2(System Management Interrupt (SMI))]
         */
        UINT32_t blocking_by_smi : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_BIT               2
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_FLAG              0x04
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_MASK              0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI(_)                (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Delivery of a non-maskable interrupt (NMI) or a system-management interrupt (SMI) blocks subsequent NMIs until
         * the next execution of IRET. Setting this bit indicates that blocking of NMIs is in effect. Clearing this bit does not
         * imply that NMIs are not (temporarily) blocked for other reasons. If the "virtual NMIs" VM-execution control is 1, this
         * bit does not control the blocking of NMIs. Instead, it refers to "virtual-NMI blocking" (the fact that guest software is
         * not ready for an NMI).
         *
         * @see Vol3C[6.7.1(Handling Multiple NMIs)]
         * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
         * @see Vol3C[24.6.1(Pin-Based VM-Execution Controls)]
         */
        UINT32_t blocking_by_nmi : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_BIT               3
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_FLAG              0x08
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_MASK              0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI(_)                (((_) >> 3) & 0x01)

        /**
         * [Bit 4] A VM exit saves this bit as 1 to indicate that the VM exit was incident to enclave mode.
         */
        UINT32_t enclave_interruption : 1;
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_BIT          4
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_FLAG         0x10
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_MASK         0x01
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION(_)           (((_) >> 4) & 0x01)
        UINT32_t reserved1 : 27;
    };

    UINT32_t flags;
} vmx_interruptibility_state;

typedef enum
{
    /**
     * The logical processor is executing instructions normally.
     */
    vmx_active = 0x00000000,

    /**
     * The logical processor is inactive because it executed the HLT instruction.
     */
     vmx_hlt = 0x00000001,

     /**
      * The logical processor is inactive because it incurred a triple fault1 or some other serious error.
      */
      vmx_shutdown = 0x00000002,

      /**
       * The logical processor is inactive because it is waiting for a startup-IPI (SIPI).
       */
       vmx_wait_for_sipi = 0x00000003,
} vmx_guest_activity_state;

/**
 * @}
 */

 /**
  * @brief Format of Exit Reason
  *
  * Exit reason (32 bits). This field encodes the reason for the VM exit and has the structure.
  *
  * @see Vol3C[24.9.1(Basic VM-Exit Information)] (reference)
  */
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] Provides basic information about the cause of the VM exit (if bit 31 is clear) or of the VM-entry failure
         * (if bit 31 is set).
         */
        UINT32_t basic_exit_reason : 16;
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_BIT                      0
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_FLAG                     0xFFFF
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_MASK                     0xFFFF
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON(_)                       (((_) >> 0) & 0xFFFF)

        /**
         * [Bit 16] Always cleared to 0.
         */
        UINT32_t always0 : 1;
#define VMX_VMEXIT_REASON_ALWAYS0_BIT                                16
#define VMX_VMEXIT_REASON_ALWAYS0_FLAG                               0x10000
#define VMX_VMEXIT_REASON_ALWAYS0_MASK                               0x01
#define VMX_VMEXIT_REASON_ALWAYS0(_)                                 (((_) >> 16) & 0x01)
        UINT32_t reserved1 : 10;
#define VMX_VMEXIT_REASON_RESERVED1_BIT                              17
#define VMX_VMEXIT_REASON_RESERVED1_FLAG                             0x7FE0000
#define VMX_VMEXIT_REASON_RESERVED1_MASK                             0x3FF
#define VMX_VMEXIT_REASON_RESERVED1(_)                               (((_) >> 17) & 0x3FF)

        /**
         * [Bit 27] A VM exit saves this bit as 1 to indicate that the VM exit was incident to enclave mode.
         */
        UINT32_t enclave_mode : 1;
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_BIT                           27
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_FLAG                          0x8000000
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_MASK                          0x01
#define VMX_VMEXIT_REASON_ENCLAVE_MODE(_)                            (((_) >> 27) & 0x01)

        /**
         * [Bit 28] Pending MTF VM exit.
         */
        UINT32_t pending_mtf_vm_exit : 1;
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_BIT                    28
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_FLAG                   0x10000000
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_MASK                   0x01
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT(_)                     (((_) >> 28) & 0x01)

        /**
         * [Bit 29] VM exit from VMX root operation.
         */
        UINT32_t vm_exit_from_vmx_roor : 1;
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOR_BIT                  29
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOR_FLAG                 0x20000000
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOR_MASK                 0x01
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOR(_)                   (((_) >> 29) & 0x01)
        UINT32_t reserved2 : 1;
#define VMX_VMEXIT_REASON_RESERVED2_BIT                              30
#define VMX_VMEXIT_REASON_RESERVED2_FLAG                             0x40000000
#define VMX_VMEXIT_REASON_RESERVED2_MASK                             0x01
#define VMX_VMEXIT_REASON_RESERVED2(_)                               (((_) >> 30) & 0x01)

        /**
         * [Bit 31] VM-entry failure:
         *   - 0 = true VM exit
         *   - 1 = VM-entry failure
         */
        UINT32_t vm_entry_failure : 1;
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_BIT                       31
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_FLAG                      0x80000000
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_MASK                      0x01
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE(_)                        (((_) >> 31) & 0x01)
    };

    UINT32_t flags;
} vmx_vmexit_reason;

typedef struct
{
#define IO_BITMAP_A_MIN                                              0x00000000
#define IO_BITMAP_A_MAX                                              0x00007FFF
#define IO_BITMAP_B_MIN                                              0x00008000
#define IO_BITMAP_B_MAX                                              0x0000FFFF
    UINT8_t io_a[4096];
    UINT8_t io_b[4096];
} vmx_io_bitmap;

typedef struct
{
#define MSR_ID_LOW_MIN                                               0x00000000
#define MSR_ID_LOW_MAX                                               0x00001FFF
#define MSR_ID_HIGH_MIN                                              0xC0000000
#define MSR_ID_HIGH_MAX                                              0xC0001FFF
    UINT8_t rdmsr_low[1024];
    UINT8_t rdmsr_high[1024];
    UINT8_t wrmsr_low[1024];
    UINT8_t wrmsr_high[1024];
} vmx_msr_bitmap;

/**
 * @defgroup ept \
 *           The extended page-table mechanism
 *
 * The extended page-table mechanism (EPT) is a feature that can be used to support the virtualization of physical memory.
 * When EPT is in use, certain addresses that would normally be treated as physical addresses (and used to access memory)
 * are instead treated as guest-physical addresses. Guest-physical addresses are translated by traversing a set of EPT
 * paging structures to produce physical addresses that are used to access memory.
 *
 * @see Vol3C[28.2(THE EXTENDED PAGE TABLE MECHANISM (EPT))] (reference)
 * @{
 */
 /**
  * @brief Extended-Page-Table Pointer (EPTP)
  *
  * The extended-page-table pointer (EPTP) contains the address of the base of EPT PML4 table, as well as other EPT
  * configuration information.
  *
  * @see Vol3C[28.2.2(EPT Translation Mechanism]
  * @see Vol3C[24.6.11(Extended-Page-Table Pointer (EPTP)] (reference)
  */
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] EPT paging-structure memory type:
         * - 0 = Uncacheable (UC)
         * - 6 = Write-back (WB)
         * Other values are reserved.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64_t memory_type : 3;
#define EPT_POINTER_MEMORY_TYPE_BIT                                  0
#define EPT_POINTER_MEMORY_TYPE_FLAG                                 0x07
#define EPT_POINTER_MEMORY_TYPE_MASK                                 0x07
#define EPT_POINTER_MEMORY_TYPE(_)                                   (((_) >> 0) & 0x07)

        /**
         * [Bits 5:3] This value is 1 less than the EPT page-walk length.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64_t page_walk_length : 3;
#define EPT_POINTER_PAGE_WALK_LENGTH_BIT                             3
#define EPT_POINTER_PAGE_WALK_LENGTH_FLAG                            0x38
#define EPT_POINTER_PAGE_WALK_LENGTH_MASK                            0x07
#define EPT_POINTER_PAGE_WALK_LENGTH(_)                              (((_) >> 3) & 0x07)
#define EPT_PAGE_WALK_LENGTH_4                                       0x00000003

        /**
         * [Bit 6] Setting this control to 1 enables accessed and dirty flags for EPT.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t enable_access_and_dirty_flags : 1;
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_BIT                6
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_FLAG               0x40
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_MASK               0x01
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS(_)                 (((_) >> 6) & 0x01)
        UINT64_t reserved1 : 5;

        /**
         * [Bits 47:12] Bits N-1:12 of the physical address of the 4-KByte aligned EPT PML4 table.
         */
        UINT64_t page_frame_number : 36;
#define EPT_POINTER_PAGE_FRAME_NUMBER_BIT                            12
#define EPT_POINTER_PAGE_FRAME_NUMBER_FLAG                           0xFFFFFFFFF000
#define EPT_POINTER_PAGE_FRAME_NUMBER_MASK                           0xFFFFFFFFF
#define EPT_POINTER_PAGE_FRAME_NUMBER(_)                             (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved2 : 16;
    };

    UINT64_t flags;
} ept_pointer;

/**
 * @brief Format of an EPT PML4 Entry (PML4E) that References an EPT Page-Directory-Pointer Table
 *
 * A 4-KByte naturally aligned EPT PML4 table is located at the physical address specified in bits 51:12 of the
 * extended-page-table pointer (EPTP), a VM-execution control field. An EPT PML4 table comprises 512 64-bit entries (EPT
 * PML4Es). An EPT PML4E is selected using the physical address defined as follows:
 * - Bits 63:52 are all 0.
 * - Bits 51:12 are from the EPTP.
 * - Bits 11:3 are bits 47:39 of the guest-physical address.
 * - Bits 2:0 are all 0.
 * Because an EPT PML4E is identified using bits 47:39 of the guest-physical address, it controls access to a 512- GByte
 * region of the guest-physical-address space.
 *
 * @see Vol3C[24.6.11(Extended-Page-Table Pointer (EPTP)]
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 512-GByte region controlled by this entry.
         */
        UINT64_t read_access : 1;
#define EPT_PML4_READ_ACCESS_BIT                                     0
#define EPT_PML4_READ_ACCESS_FLAG                                    0x01
#define EPT_PML4_READ_ACCESS_MASK                                    0x01
#define EPT_PML4_READ_ACCESS(_)                                      (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 512-GByte region controlled by this entry.
         */
        UINT64_t write_access : 1;
#define EPT_PML4_WRITE_ACCESS_BIT                                    1
#define EPT_PML4_WRITE_ACCESS_FLAG                                   0x02
#define EPT_PML4_WRITE_ACCESS_MASK                                   0x01
#define EPT_PML4_WRITE_ACCESS(_)                                     (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 512-GByte region controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 512-GByte region controlled by this entry.
         */
        UINT64_t execute_access : 1;
#define EPT_PML4_EXECUTE_ACCESS_BIT                                  2
#define EPT_PML4_EXECUTE_ACCESS_FLAG                                 0x04
#define EPT_PML4_EXECUTE_ACCESS_MASK                                 0x01
#define EPT_PML4_EXECUTE_ACCESS(_)                                   (((_) >> 2) & 0x01)
        UINT64_t reserved1 : 5;

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 512-GByte region
         * controlled by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t accessed : 1;
#define EPT_PML4_ACCESSED_BIT                                        8
#define EPT_PML4_ACCESSED_FLAG                                       0x100
#define EPT_PML4_ACCESSED_MASK                                       0x01
#define EPT_PML4_ACCESSED(_)                                         (((_) >> 8) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 512-GByte region
         * controlled by this entry. If that control is 0, this bit is ignored.
         */
        UINT64_t user_mode_execute : 1;
#define EPT_PML4_USER_MODE_EXECUTE_BIT                               10
#define EPT_PML4_USER_MODE_EXECUTE_FLAG                              0x400
#define EPT_PML4_USER_MODE_EXECUTE_MASK                              0x01
#define EPT_PML4_USER_MODE_EXECUTE(_)                                (((_) >> 10) & 0x01)
        UINT64_t reserved3 : 1;

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
         */
        UINT64_t page_frame_number : 36;
#define EPT_PML4_PAGE_FRAME_NUMBER_BIT                               12
#define EPT_PML4_PAGE_FRAME_NUMBER_FLAG                              0xFFFFFFFFF000
#define EPT_PML4_PAGE_FRAME_NUMBER_MASK                              0xFFFFFFFFF
#define EPT_PML4_PAGE_FRAME_NUMBER(_)                                (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved4 : 16;
    };

    UINT64_t flags;
} ept_pml4e;

/**
 * @brief Format of an EPT Page-Directory-Pointer-Table Entry (PDPTE) that Maps a 1-GByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 1-GByte page referenced by this entry.
         */
        UINT64_t read_access : 1;
#define EPDPTE_1GB_READ_ACCESS_BIT                                   0
#define EPDPTE_1GB_READ_ACCESS_FLAG                                  0x01
#define EPDPTE_1GB_READ_ACCESS_MASK                                  0x01
#define EPDPTE_1GB_READ_ACCESS(_)                                    (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 1-GByte page referenced by this entry.
         */
        UINT64_t write_access : 1;
#define EPDPTE_1GB_WRITE_ACCESS_BIT                                  1
#define EPDPTE_1GB_WRITE_ACCESS_FLAG                                 0x02
#define EPDPTE_1GB_WRITE_ACCESS_MASK                                 0x01
#define EPDPTE_1GB_WRITE_ACCESS(_)                                   (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 1-GByte page controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 1-GByte page controlled by this entry.
         */
        UINT64_t execute_access : 1;
#define EPDPTE_1GB_EXECUTE_ACCESS_BIT                                2
#define EPDPTE_1GB_EXECUTE_ACCESS_FLAG                               0x04
#define EPDPTE_1GB_EXECUTE_ACCESS_MASK                               0x01
#define EPDPTE_1GB_EXECUTE_ACCESS(_)                                 (((_) >> 2) & 0x01)

        /**
         * [Bits 5:3] EPT memory type for this 1-GByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64_t memory_type : 3;
#define EPDPTE_1GB_MEMORY_TYPE_BIT                                   3
#define EPDPTE_1GB_MEMORY_TYPE_FLAG                                  0x38
#define EPDPTE_1GB_MEMORY_TYPE_MASK                                  0x07
#define EPDPTE_1GB_MEMORY_TYPE(_)                                    (((_) >> 3) & 0x07)

        /**
         * [Bit 6] Ignore PAT memory type for this 1-GByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64_t ignore_pat : 1;
#define EPDPTE_1GB_IGNORE_PAT_BIT                                    6
#define EPDPTE_1GB_IGNORE_PAT_FLAG                                   0x40
#define EPDPTE_1GB_IGNORE_PAT_MASK                                   0x01
#define EPDPTE_1GB_IGNORE_PAT(_)                                     (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Must be 1 (otherwise, this entry references an EPT page directory).
         */
        UINT64_t large_page : 1;
#define EPDPTE_1GB_LARGE_PAGE_BIT                                    7
#define EPDPTE_1GB_LARGE_PAGE_FLAG                                   0x80
#define EPDPTE_1GB_LARGE_PAGE_MASK                                   0x01
#define EPDPTE_1GB_LARGE_PAGE(_)                                     (((_) >> 7) & 0x01)

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 1-GByte page
         * referenced by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t accessed : 1;
#define EPDPTE_1GB_ACCESSED_BIT                                      8
#define EPDPTE_1GB_ACCESSED_FLAG                                     0x100
#define EPDPTE_1GB_ACCESSED_MASK                                     0x01
#define EPDPTE_1GB_ACCESSED(_)                                       (((_) >> 8) & 0x01)

        /**
         * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to the 1-GByte page referenced
         * by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t dirty : 1;
#define EPDPTE_1GB_DIRTY_BIT                                         9
#define EPDPTE_1GB_DIRTY_FLAG                                        0x200
#define EPDPTE_1GB_DIRTY_MASK                                        0x01
#define EPDPTE_1GB_DIRTY(_)                                          (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 1-GByte page controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        UINT64_t user_mode_execute : 1;
#define EPDPTE_1GB_USER_MODE_EXECUTE_BIT                             10
#define EPDPTE_1GB_USER_MODE_EXECUTE_FLAG                            0x400
#define EPDPTE_1GB_USER_MODE_EXECUTE_MASK                            0x01
#define EPDPTE_1GB_USER_MODE_EXECUTE(_)                              (((_) >> 10) & 0x01)
        UINT64_t reserved1 : 19;

        /**
         * [Bits 47:30] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
         */
        UINT64_t page_frame_number : 18;
#define EPDPTE_1GB_PAGE_FRAME_NUMBER_BIT                             30
#define EPDPTE_1GB_PAGE_FRAME_NUMBER_FLAG                            0xFFFFC0000000
#define EPDPTE_1GB_PAGE_FRAME_NUMBER_MASK                            0x3FFFF
#define EPDPTE_1GB_PAGE_FRAME_NUMBER(_)                              (((_) >> 30) & 0x3FFFF)
        UINT64_t reserved2 : 15;

        /**
         * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations caused by accesses to this
         * page are convertible to virtualization exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
         * 0, this bit is ignored.
         *
         * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
         */
        UINT64_t suppress_ve : 1;
#define EPDPTE_1GB_SUPPRESS_VE_BIT                                   63
#define EPDPTE_1GB_SUPPRESS_VE_FLAG                                  0x8000000000000000
#define EPDPTE_1GB_SUPPRESS_VE_MASK                                  0x01
#define EPDPTE_1GB_SUPPRESS_VE(_)                                    (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} ept_pdpte_1gb;

/**
 * @brief Format of an EPT Page-Directory-Pointer-Table Entry (PDPTE) that References an EPT Page Directory
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 1-GByte region controlled by this entry.
         */
        UINT64_t read_access : 1;
#define EPDPTE_READ_ACCESS_BIT                                       0
#define EPDPTE_READ_ACCESS_FLAG                                      0x01
#define EPDPTE_READ_ACCESS_MASK                                      0x01
#define EPDPTE_READ_ACCESS(_)                                        (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 1-GByte region controlled by this entry.
         */
        UINT64_t write_access : 1;
#define EPDPTE_WRITE_ACCESS_BIT                                      1
#define EPDPTE_WRITE_ACCESS_FLAG                                     0x02
#define EPDPTE_WRITE_ACCESS_MASK                                     0x01
#define EPDPTE_WRITE_ACCESS(_)                                       (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 1-GByte region controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 1-GByte region controlled by this entry.
         */
        UINT64_t execute_access : 1;
#define EPDPTE_EXECUTE_ACCESS_BIT                                    2
#define EPDPTE_EXECUTE_ACCESS_FLAG                                   0x04
#define EPDPTE_EXECUTE_ACCESS_MASK                                   0x01
#define EPDPTE_EXECUTE_ACCESS(_)                                     (((_) >> 2) & 0x01)
        UINT64_t reserved1 : 5;

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 1-GByte region
         * controlled by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t accessed : 1;
#define EPDPTE_ACCESSED_BIT                                          8
#define EPDPTE_ACCESSED_FLAG                                         0x100
#define EPDPTE_ACCESSED_MASK                                         0x01
#define EPDPTE_ACCESSED(_)                                           (((_) >> 8) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 1-GByte region controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        UINT64_t user_mode_execute : 1;
#define EPDPTE_USER_MODE_EXECUTE_BIT                                 10
#define EPDPTE_USER_MODE_EXECUTE_FLAG                                0x400
#define EPDPTE_USER_MODE_EXECUTE_MASK                                0x01
#define EPDPTE_USER_MODE_EXECUTE(_)                                  (((_) >> 10) & 0x01)
        UINT64_t reserved3 : 1;

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
         */
        UINT64_t page_frame_number : 36;
#define EPDPTE_PAGE_FRAME_NUMBER_BIT                                 12
#define EPDPTE_PAGE_FRAME_NUMBER_FLAG                                0xFFFFFFFFF000
#define EPDPTE_PAGE_FRAME_NUMBER_MASK                                0xFFFFFFFFF
#define EPDPTE_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved4 : 16;
    };

    UINT64_t flags;
} ept_pdpte;

/**
 * @brief Format of an EPT Page-Directory Entry (PDE) that Maps a 2-MByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 2-MByte page referenced by this entry.
         */
        UINT64_t read_access : 1;
#define EPDE_2MB_READ_ACCESS_BIT                                     0
#define EPDE_2MB_READ_ACCESS_FLAG                                    0x01
#define EPDE_2MB_READ_ACCESS_MASK                                    0x01
#define EPDE_2MB_READ_ACCESS(_)                                      (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 2-MByte page referenced by this entry.
         */
        UINT64_t write_access : 1;
#define EPDE_2MB_WRITE_ACCESS_BIT                                    1
#define EPDE_2MB_WRITE_ACCESS_FLAG                                   0x02
#define EPDE_2MB_WRITE_ACCESS_MASK                                   0x01
#define EPDE_2MB_WRITE_ACCESS(_)                                     (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 2-MByte page controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 2-MByte page controlled by this entry.
         */
        UINT64_t execute_access : 1;
#define EPDE_2MB_EXECUTE_ACCESS_BIT                                  2
#define EPDE_2MB_EXECUTE_ACCESS_FLAG                                 0x04
#define EPDE_2MB_EXECUTE_ACCESS_MASK                                 0x01
#define EPDE_2MB_EXECUTE_ACCESS(_)                                   (((_) >> 2) & 0x01)

        /**
         * [Bits 5:3] EPT memory type for this 2-MByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64_t memory_type : 3;
#define EPDE_2MB_MEMORY_TYPE_BIT                                     3
#define EPDE_2MB_MEMORY_TYPE_FLAG                                    0x38
#define EPDE_2MB_MEMORY_TYPE_MASK                                    0x07
#define EPDE_2MB_MEMORY_TYPE(_)                                      (((_) >> 3) & 0x07)

        /**
         * [Bit 6] Ignore PAT memory type for this 2-MByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64_t ignore_pat : 1;
#define EPDE_2MB_IGNORE_PAT_BIT                                      6
#define EPDE_2MB_IGNORE_PAT_FLAG                                     0x40
#define EPDE_2MB_IGNORE_PAT_MASK                                     0x01
#define EPDE_2MB_IGNORE_PAT(_)                                       (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Must be 1 (otherwise, this entry references an EPT page table).
         */
        UINT64_t large_page : 1;
#define EPDE_2MB_LARGE_PAGE_BIT                                      7
#define EPDE_2MB_LARGE_PAGE_FLAG                                     0x80
#define EPDE_2MB_LARGE_PAGE_MASK                                     0x01
#define EPDE_2MB_LARGE_PAGE(_)                                       (((_) >> 7) & 0x01)

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 2-MByte page
         * referenced by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t accessed : 1;
#define EPDE_2MB_ACCESSED_BIT                                        8
#define EPDE_2MB_ACCESSED_FLAG                                       0x100
#define EPDE_2MB_ACCESSED_MASK                                       0x01
#define EPDE_2MB_ACCESSED(_)                                         (((_) >> 8) & 0x01)

        /**
         * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to the 2-MByte page referenced
         * by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t dirty : 1;
#define EPDE_2MB_DIRTY_BIT                                           9
#define EPDE_2MB_DIRTY_FLAG                                          0x200
#define EPDE_2MB_DIRTY_MASK                                          0x01
#define EPDE_2MB_DIRTY(_)                                            (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 2-MByte page controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        UINT64_t user_mode_execute : 1;
#define EPDE_2MB_USER_MODE_EXECUTE_BIT                               10
#define EPDE_2MB_USER_MODE_EXECUTE_FLAG                              0x400
#define EPDE_2MB_USER_MODE_EXECUTE_MASK                              0x01
#define EPDE_2MB_USER_MODE_EXECUTE(_)                                (((_) >> 10) & 0x01)
        UINT64_t reserved1 : 10;

        /**
         * [Bits 47:21] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
         */
        UINT64_t page_frame_number : 27;
#define EPDE_2MB_PAGE_FRAME_NUMBER_BIT                               21
#define EPDE_2MB_PAGE_FRAME_NUMBER_FLAG                              0xFFFFFFE00000
#define EPDE_2MB_PAGE_FRAME_NUMBER_MASK                              0x7FFFFFF
#define EPDE_2MB_PAGE_FRAME_NUMBER(_)                                (((_) >> 21) & 0x7FFFFFF)
        UINT64_t reserved2 : 15;

        /**
         * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations caused by accesses to this
         * page are convertible to virtualization exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
         * 0, this bit is ignored.
         *
         * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
         */
        UINT64_t suppress_ve : 1;
#define EPDE_2MB_SUPPRESS_VE_BIT                                     63
#define EPDE_2MB_SUPPRESS_VE_FLAG                                    0x8000000000000000
#define EPDE_2MB_SUPPRESS_VE_MASK                                    0x01
#define EPDE_2MB_SUPPRESS_VE(_)                                      (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} epde_2mb;

/**
 * @brief Format of an EPT Page-Directory Entry (PDE) that References an EPT Page Table
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 2-MByte region controlled by this entry.
         */
        UINT64_t read_access : 1;
#define EPDE_READ_ACCESS_BIT                                         0
#define EPDE_READ_ACCESS_FLAG                                        0x01
#define EPDE_READ_ACCESS_MASK                                        0x01
#define EPDE_READ_ACCESS(_)                                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 2-MByte region controlled by this entry.
         */
        UINT64_t write_access : 1;
#define EPDE_WRITE_ACCESS_BIT                                        1
#define EPDE_WRITE_ACCESS_FLAG                                       0x02
#define EPDE_WRITE_ACCESS_MASK                                       0x01
#define EPDE_WRITE_ACCESS(_)                                         (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 2-MByte region controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 2-MByte region controlled by this entry.
         */
        UINT64_t execute_access : 1;
#define EPDE_EXECUTE_ACCESS_BIT                                      2
#define EPDE_EXECUTE_ACCESS_FLAG                                     0x04
#define EPDE_EXECUTE_ACCESS_MASK                                     0x01
#define EPDE_EXECUTE_ACCESS(_)                                       (((_) >> 2) & 0x01)
        UINT64_t reserved1 : 5;

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 2-MByte region
         * controlled by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t accessed : 1;
#define EPDE_ACCESSED_BIT                                            8
#define EPDE_ACCESSED_FLAG                                           0x100
#define EPDE_ACCESSED_MASK                                           0x01
#define EPDE_ACCESSED(_)                                             (((_) >> 8) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 2-MByte region controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        UINT64_t user_mode_execute : 1;
#define EPDE_USER_MODE_EXECUTE_BIT                                   10
#define EPDE_USER_MODE_EXECUTE_FLAG                                  0x400
#define EPDE_USER_MODE_EXECUTE_MASK                                  0x01
#define EPDE_USER_MODE_EXECUTE(_)                                    (((_) >> 10) & 0x01)
        UINT64_t reserved3 : 1;

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned EPT page table referenced by this entry.
         */
        UINT64_t page_frame_number : 36;
#define EPDE_PAGE_FRAME_NUMBER_BIT                                   12
#define EPDE_PAGE_FRAME_NUMBER_FLAG                                  0xFFFFFFFFF000
#define EPDE_PAGE_FRAME_NUMBER_MASK                                  0xFFFFFFFFF
#define EPDE_PAGE_FRAME_NUMBER(_)                                    (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved4 : 16;
    };

    UINT64_t flags;
} ept_pde;

/**
 * @brief Format of an EPT Page-Table Entry that Maps a 4-KByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 4-KByte page referenced by this entry.
         */
        UINT64_t read_access : 1;
#define EPTE_READ_ACCESS_BIT                                         0
#define EPTE_READ_ACCESS_FLAG                                        0x01
#define EPTE_READ_ACCESS_MASK                                        0x01
#define EPTE_READ_ACCESS(_)                                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 4-KByte page referenced by this entry.
         */
        UINT64_t write_access : 1;
#define EPTE_WRITE_ACCESS_BIT                                        1
#define EPTE_WRITE_ACCESS_FLAG                                       0x02
#define EPTE_WRITE_ACCESS_MASK                                       0x01
#define EPTE_WRITE_ACCESS(_)                                         (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 4-KByte page controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 4-KByte page controlled by this entry.
         */
        UINT64_t execute_access : 1;
#define EPTE_EXECUTE_ACCESS_BIT                                      2
#define EPTE_EXECUTE_ACCESS_FLAG                                     0x04
#define EPTE_EXECUTE_ACCESS_MASK                                     0x01
#define EPTE_EXECUTE_ACCESS(_)                                       (((_) >> 2) & 0x01)

        /**
         * [Bits 5:3] EPT memory type for this 4-KByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64_t memory_type : 3;
#define EPTE_MEMORY_TYPE_BIT                                         3
#define EPTE_MEMORY_TYPE_FLAG                                        0x38
#define EPTE_MEMORY_TYPE_MASK                                        0x07
#define EPTE_MEMORY_TYPE(_)                                          (((_) >> 3) & 0x07)

        /**
         * [Bit 6] Ignore PAT memory type for this 4-KByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64_t ignore_pat : 1;
#define EPTE_IGNORE_PAT_BIT                                          6
#define EPTE_IGNORE_PAT_FLAG                                         0x40
#define EPTE_IGNORE_PAT_MASK                                         0x01
#define EPTE_IGNORE_PAT(_)                                           (((_) >> 6) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 4-KByte page
         * referenced by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t accessed : 1;
#define EPTE_ACCESSED_BIT                                            8
#define EPTE_ACCESSED_FLAG                                           0x100
#define EPTE_ACCESSED_MASK                                           0x01
#define EPTE_ACCESSED(_)                                             (((_) >> 8) & 0x01)

        /**
         * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to the 4-KByte page referenced
         * by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t dirty : 1;
#define EPTE_DIRTY_BIT                                               9
#define EPTE_DIRTY_FLAG                                              0x200
#define EPTE_DIRTY_MASK                                              0x01
#define EPTE_DIRTY(_)                                                (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 4-KByte page controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        UINT64_t user_mode_execute : 1;
#define EPTE_USER_MODE_EXECUTE_BIT                                   10
#define EPTE_USER_MODE_EXECUTE_FLAG                                  0x400
#define EPTE_USER_MODE_EXECUTE_MASK                                  0x01
#define EPTE_USER_MODE_EXECUTE(_)                                    (((_) >> 10) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
         */
        UINT64_t page_frame_number : 36;
#define EPTE_PAGE_FRAME_NUMBER_BIT                                   12
#define EPTE_PAGE_FRAME_NUMBER_FLAG                                  0xFFFFFFFFF000
#define EPTE_PAGE_FRAME_NUMBER_MASK                                  0xFFFFFFFFF
#define EPTE_PAGE_FRAME_NUMBER(_)                                    (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved3 : 15;

        /**
         * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations caused by accesses to this
         * page are convertible to virtualization exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
         * 0, this bit is ignored.
         *
         * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
         */
        UINT64_t suppress_ve : 1;
#define EPTE_SUPPRESS_VE_BIT                                         63
#define EPTE_SUPPRESS_VE_FLAG                                        0x8000000000000000
#define EPTE_SUPPRESS_VE_MASK                                        0x01
#define EPTE_SUPPRESS_VE(_)                                          (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} ept_pte;

/**
 * @brief Format of a common EPT Entry
 */
typedef union
{
    struct
    {
        UINT64_t read_access : 1;
#define EPT_ENTRY_READ_ACCESS_BIT                                    0
#define EPT_ENTRY_READ_ACCESS_FLAG                                   0x01
#define EPT_ENTRY_READ_ACCESS_MASK                                   0x01
#define EPT_ENTRY_READ_ACCESS(_)                                     (((_) >> 0) & 0x01)
        UINT64_t write_access : 1;
#define EPT_ENTRY_WRITE_ACCESS_BIT                                   1
#define EPT_ENTRY_WRITE_ACCESS_FLAG                                  0x02
#define EPT_ENTRY_WRITE_ACCESS_MASK                                  0x01
#define EPT_ENTRY_WRITE_ACCESS(_)                                    (((_) >> 1) & 0x01)
        UINT64_t execute_access : 1;
#define EPT_ENTRY_EXECUTE_ACCESS_BIT                                 2
#define EPT_ENTRY_EXECUTE_ACCESS_FLAG                                0x04
#define EPT_ENTRY_EXECUTE_ACCESS_MASK                                0x01
#define EPT_ENTRY_EXECUTE_ACCESS(_)                                  (((_) >> 2) & 0x01)
        UINT64_t memory_type : 3;
#define EPT_ENTRY_MEMORY_TYPE_BIT                                    3
#define EPT_ENTRY_MEMORY_TYPE_FLAG                                   0x38
#define EPT_ENTRY_MEMORY_TYPE_MASK                                   0x07
#define EPT_ENTRY_MEMORY_TYPE(_)                                     (((_) >> 3) & 0x07)
        UINT64_t ignore_pat : 1;
#define EPT_ENTRY_IGNORE_PAT_BIT                                     6
#define EPT_ENTRY_IGNORE_PAT_FLAG                                    0x40
#define EPT_ENTRY_IGNORE_PAT_MASK                                    0x01
#define EPT_ENTRY_IGNORE_PAT(_)                                      (((_) >> 6) & 0x01)
        UINT64_t large_page : 1;
#define EPT_ENTRY_LARGE_PAGE_BIT                                     7
#define EPT_ENTRY_LARGE_PAGE_FLAG                                    0x80
#define EPT_ENTRY_LARGE_PAGE_MASK                                    0x01
#define EPT_ENTRY_LARGE_PAGE(_)                                      (((_) >> 7) & 0x01)
        UINT64_t accessed : 1;
#define EPT_ENTRY_ACCESSED_BIT                                       8
#define EPT_ENTRY_ACCESSED_FLAG                                      0x100
#define EPT_ENTRY_ACCESSED_MASK                                      0x01
#define EPT_ENTRY_ACCESSED(_)                                        (((_) >> 8) & 0x01)
        UINT64_t dirty : 1;
#define EPT_ENTRY_DIRTY_BIT                                          9
#define EPT_ENTRY_DIRTY_FLAG                                         0x200
#define EPT_ENTRY_DIRTY_MASK                                         0x01
#define EPT_ENTRY_DIRTY(_)                                           (((_) >> 9) & 0x01)
        UINT64_t user_mode_execute : 1;
#define EPT_ENTRY_USER_MODE_EXECUTE_BIT                              10
#define EPT_ENTRY_USER_MODE_EXECUTE_FLAG                             0x400
#define EPT_ENTRY_USER_MODE_EXECUTE_MASK                             0x01
#define EPT_ENTRY_USER_MODE_EXECUTE(_)                               (((_) >> 10) & 0x01)
        UINT64_t reserved1 : 1;
        UINT64_t page_frame_number : 36;
#define EPT_ENTRY_PAGE_FRAME_NUMBER_BIT                              12
#define EPT_ENTRY_PAGE_FRAME_NUMBER_FLAG                             0xFFFFFFFFF000
#define EPT_ENTRY_PAGE_FRAME_NUMBER_MASK                             0xFFFFFFFFF
#define EPT_ENTRY_PAGE_FRAME_NUMBER(_)                               (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved2 : 15;
        UINT64_t suppress_ve : 1;
#define EPT_ENTRY_SUPPRESS_VE_BIT                                    63
#define EPT_ENTRY_SUPPRESS_VE_FLAG                                   0x8000000000000000
#define EPT_ENTRY_SUPPRESS_VE_MASK                                   0x01
#define EPT_ENTRY_SUPPRESS_VE(_)                                     (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} ept_entry;

/**
 * @defgroup ept_table_level \
 *           EPT Table level numbers
 *
 * EPT Table level numbers.
 * @{
 */
#define EPT_LEVEL_PML4E                                              0x00000003
#define EPT_LEVEL_PDPTE                                              0x00000002
#define EPT_LEVEL_PDE                                                0x00000001
#define EPT_LEVEL_PTE                                                0x00000000
 /**
  * @}
  */

  /**
   * @defgroup ept_entry_count \
   *           EPT Entry counts
   *
   * EPT Entry counts.
   * @{
   */
#define EPT_PML4E_ENTRY_COUNT                                        0x00000200
#define EPT_PDPTE_ENTRY_COUNT                                        0x00000200
#define EPT_PDE_ENTRY_COUNT                                          0x00000200
#define EPT_PTE_ENTRY_COUNT                                          0x00000200
   /**
    * @}
    */

    /**
     * @}
     */

typedef enum
{
    /**
     * If the INVEPT type is 1, the logical processor invalidates all guest-physical mappings and combined mappings associated
     * with the EP4TA specified in the INVEPT descriptor. Combined mappings for that EP4TA are invalidated for all VPIDs and
     * all PCIDs. (The instruction may invalidate mappings associated with other EP4TAs.)
     */
    invept_single_context = 0x00000001,

    /**
     * If the INVEPT type is 2, the logical processor invalidates guest-physical mappings and combined mappings associated with
     * all EP4TAs (and, for combined mappings, for all VPIDs and PCIDs).
     */
     invept_all_context = 0x00000002,
} invept_type;

typedef enum
{
    /**
     * If the INVVPID type is 0, the logical processor invalidates linear mappings and combined mappings associated with the
     * VPID specified in the INVVPID descriptor and that would be used to translate the linear address specified in of the
     * INVVPID descriptor. Linear mappings and combined mappings for that VPID and linear address are invalidated for all PCIDs
     * and, for combined mappings, all EP4TAs. (The instruction may also invalidate mappings associated with other VPIDs and
     * for other linear addresses).
     */
    invvpid_individual_address = 0x00000000,

    /**
     * If the INVVPID type is 1, the logical processor invalidates all linear mappings and combined mappings associated with
     * the VPID specified in the INVVPID descriptor. Linear mappings and combined mappings for that VPID are invalidated for
     * all PCIDs and, for combined mappings, all EP4TAs. (The instruction may also invalidate mappings associated with other
     * VPIDs).
     */
     invvpid_single_context = 0x00000001,

     /**
      * If the INVVPID type is 2, the logical processor invalidates linear mappings and combined mappings associated with all
      * VPIDs except VPID 0000H and with all PCIDs. (The instruction may also invalidate linear mappings with VPID 0000H.)
      * Combined mappings are invalidated for all EP4TAs.
      */
      invvpid_all_context = 0x00000002,

      /**
       * If the INVVPID type is 3, the logical processor invalidates linear mappings and combined mappings associated with the
       * VPID specified in the INVVPID descriptor. Linear mappings and combined mappings for that VPID are invalidated for all
       * PCIDs and, for combined mappings, all EP4TAs. The logical processor is not required to invalidate information that was
       * used for global translations (although it may do so). (The instruction may also invalidate mappings associated with
       * other VPIDs).
       *
       * @see Vol3C[4.10(Caching Translation Information)]
       */
       invvpid_single_context_retaining_globals = 0x00000003,
} invvpid_type;

typedef struct
{
    UINT64_t ept_pointer;

    /**
     * Must be zero.
     */
    UINT64_t reserved;
} invept_descriptor;

typedef struct
{
    UINT16_t vpid;

    /**
     * Must be zero.
     */
    UINT16_t reserved1;

    /**
     * Must be zero.
     */
    UINT32_t reserved2;
    UINT64_t linear_address;
} invvpid_descriptor;

/**
 * @brief Format of the VMCS Region
 *
 * A logical processor uses virtual-machine control data structures (VMCSs) while it is in VMX operation. These manage
 * transitions into and out of VMX non-root operation (VM entries and VM exits) as well as processor behavior in VMX
 * non-root operation. This structure is manipulated by the new instructions VMCLEAR, VMPTRLD, VMREAD, and VMWRITE.
 * A VMCS region comprises up to 4-KBytes. The exact size is implementation specific and can be determined by consulting
 * the VMX capability MSR IA32_VMX_BASIC.
 *
 * @see Vol3C[24.2(FORMAT OF THE VMCS REGION)] (reference)
 */
typedef struct
{
    struct
    {
        /**
         * @brief VMCS revision identifier
         *
         * [Bits 30:0] Processors that maintain VMCS data in different formats (see below) use different VMCS revision identifiers.
         * These identifiers enable software to avoid using a VMCS region formatted for one processor on a processor that uses a
         * different format.
         * Software should write the VMCS revision identifier to the VMCS region before using that region for a VMCS. The VMCS
         * revision identifier is never written by the processor; VMPTRLD fails if its operand references a VMCS region whose VMCS
         * revision identifier differs from that used by the processor.
         * Software can discover the VMCS revision identifier that a processor uses by reading the VMX capability MSR
         * IA32_VMX_BASIC.
         *
         * @see Vol3C[24.6.2(Processor-Based VM-Execution Controls)]
         * @see Vol3D[A.1(BASIC VMX INFORMATION)]
         */
        UINT32_t revision_id : 31;

        /**
         * @brief Shadow-VMCS indicator
         *
         * [Bit 31] Software should clear or set the shadow-VMCS indicator depending on whether the VMCS is to be an ordinary VMCS
         * or a shadow VMCS. VMPTRLD fails if the shadow-VMCS indicator is set and the processor does not support the 1-setting of
         * the "VMCS shadowing" VM-execution control. Software can discover support for this setting by reading the VMX capability
         * MSR IA32_VMX_PROCBASED_CTLS2.
         *
         * @see Vol3C[24.10(VMCS TYPES ORDINARY AND SHADOW)]
         */
        UINT32_t shadow_vmcs_indicator : 1;
    };


    /**
     * @brief VMX-abort indicator
     *
     * The contents of these bits do not control processor operation in any way. A logical processor writes a non-zero value
     * into these bits if a VMX abort occurs. Software may also write into this field.
     *
     * @see Vol3D[27.7(VMX Aborts)]
     */
    UINT32_t abort_indicator;

    /**
     * @brief VMCS data (implementation-specific format)
     *
     * These parts of the VMCS control VMX non-root operation and the VMX transitions.
     * The format of these data is implementation-specific. To ensure proper behavior in VMX operation, software should
     * maintain the VMCS region and related structures in writeback cacheable memory. Future implementations may allow or
     * require a different memory type. Software should consult the VMX capability MSR IA32_VMX_BASIC.
     *
     * @see Vol3C[24.11.4(Software Access to Related Structures)]
     * @see Vol3D[A.1(BASIC VMX INFORMATION)]
     */
    UINT8_t data[4088];
} vmcs;

/**
 * @brief Format of the VMXON Region
 *
 * Before executing VMXON, software allocates a region of memory that the logical processor uses to support VMX operation.
 * This region is called the VMXON region.
 * A VMXON region comprises up to 4-KBytes. The exact size is implementation specific and can be determined by consulting
 * the VMX capability MSR IA32_VMX_BASIC.
 *
 * @see Vol3C[24.11.5(VMXON Region)] (reference)
 */
typedef struct
{
    struct
    {
        /**
         * @brief VMCS revision identifier
         *
         * [Bits 30:0] Before executing VMXON, software should write the VMCS revision identifier to the VMXON region.
         * (Specifically, it should write the 31-bit VMCS revision identifier to bits 30:0 of the first 4 bytes of the VMXON
         * region; bit 31 should be cleared to 0.)
         *
         * @see VMCS
         * @see Vol3C[24.2(FORMAT OF THE VMCS REGION)]
         * @see Vol3C[24.11.5(VMXON Region)]
         */
        UINT32_t revision_id : 31;

        /**
         * [Bit 31] Bit 31 is always 0.
         */
        UINT32_t must_be_zero : 1;
    };


    /**
     * @brief VMXON data (implementation-specific format)
     *
     * The format of these data is implementation-specific. To ensure proper behavior in VMX operation, software should not
     * access or modify the VMXON region of a logical processor between execution of VMXON and VMXOFF on that logical
     * processor. Doing otherwise may lead to unpredictable behavior.
     *
     * @see Vol3C[24.11.4(Software Access to Related Structures)]
     * @see Vol3D[A.1(BASIC VMX INFORMATION)]
     */
    UINT8_t data[4092];
} vmxon;

/**
 * @defgroup vmcs_fields \
 *           VMCS (VM Control Structure)
 *
 * Every component of the VMCS is encoded by a 32-bit field that can be used by VMREAD and VMWRITE. This enumerates all
 * fields in the VMCS and their encodings. Fields are grouped by width (16-bit, 32-bit, etc.) and type (guest-state,
 * host-state, etc.).
 *
 * @see Vol3D[B(APPENDIX B FIELD ENCODING IN VMCS)] (reference)
 * @{
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Access type (0 = full; 1 = high); must be full for 16-bit, 32-bit, and natural-width fields.
         */
        UINT16_t access_type : 1;
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_BIT                      0
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_FLAG                     0x01
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_MASK                     0x01
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE(_)                       (((_) >> 0) & 0x01)

        /**
         * [Bits 9:1] Index.
         */
        UINT16_t index : 9;
#define VMCS_COMPONENT_ENCODING_INDEX_BIT                            1
#define VMCS_COMPONENT_ENCODING_INDEX_FLAG                           0x3FE
#define VMCS_COMPONENT_ENCODING_INDEX_MASK                           0x1FF
#define VMCS_COMPONENT_ENCODING_INDEX(_)                             (((_) >> 1) & 0x1FF)

        /**
         * [Bits 11:10] Type:
         * 0: control
         * 1: VM-exit information
         * 2: guest state
         * 3: host state
         */
        UINT16_t type : 2;
#define VMCS_COMPONENT_ENCODING_TYPE_BIT                             10
#define VMCS_COMPONENT_ENCODING_TYPE_FLAG                            0xC00
#define VMCS_COMPONENT_ENCODING_TYPE_MASK                            0x03
#define VMCS_COMPONENT_ENCODING_TYPE(_)                              (((_) >> 10) & 0x03)

        /**
         * [Bit 12] Reserved (must be 0).
         */
        UINT16_t must_be_zero : 1;
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_BIT                     12
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_FLAG                    0x1000
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_MASK                    0x01
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO(_)                      (((_) >> 12) & 0x01)

        /**
         * [Bits 14:13] Width:
         * 0: 16-bit
         * 1: 64-bit
         * 2: 32-bit
         * 3: natural-width
         */
        UINT16_t width : 2;
#define VMCS_COMPONENT_ENCODING_WIDTH_BIT                            13
#define VMCS_COMPONENT_ENCODING_WIDTH_FLAG                           0x6000
#define VMCS_COMPONENT_ENCODING_WIDTH_MASK                           0x03
#define VMCS_COMPONENT_ENCODING_WIDTH(_)                             (((_) >> 13) & 0x03)
        UINT16_t reserved1 : 1;
    };

    UINT16_t flags;
} vmcs_component_encoding;

/**
 * @defgroup vmcs_16_bit \
 *           16-Bit Fields
 *
 * 16-Bit Fields.
 *
 * @see Vol3D[B.1(16-BIT FIELDS)] (reference)
 * @{
 */
 /**
  * @defgroup vmcs_16_bit_control_fields \
  *           16-Bit Control Fields
  *
  * 16-Bit Control Fields.
  * @{
  */
  /**
   * Virtual-processor identifier (VPID).
   *
   * @remarks This field exists only on processors that support the 1-setting of the "enable VPID" VM-execution control.
   */
#define VMCS_CTRL_VIRTUAL_PROCESSOR_IDENTIFIER                       0x00000000

   /**
    * Posted-interrupt notification vector.
    *
    * @remarks This field exists only on processors that support the 1-setting of the "process posted interrupts" VM-execution
    *          control.
    */
#define VMCS_CTRL_POSTED_INTERRUPT_NOTIFICATION_VECTOR               0x00000002

    /**
     * EPTP index.
     *
     * @remarks This field exists only on processors that support the 1-setting of the "EPT-violation \#VE" VM-execution
     *          control.
     */
#define VMCS_CTRL_EPTP_INDEX                                         0x00000004
     /**
      * @}
      */

      /**
       * @defgroup vmcs_16_bit_guest_state_fields \
       *           16-Bit Guest-State Fields
       *
       * 16-Bit Guest-State Fields.
       * @{
       */
       /**
        * Guest ES selector.
        */
#define VMCS_GUEST_ES_SELECTOR                                       0x00000800

        /**
         * Guest CS selector.
         */
#define VMCS_GUEST_CS_SELECTOR                                       0x00000802

         /**
          * Guest SS selector.
          */
#define VMCS_GUEST_SS_SELECTOR                                       0x00000804

          /**
           * Guest DS selector.
           */
#define VMCS_GUEST_DS_SELECTOR                                       0x00000806

           /**
            * Guest FS selector.
            */
#define VMCS_GUEST_FS_SELECTOR                                       0x00000808

            /**
             * Guest GS selector.
             */
#define VMCS_GUEST_GS_SELECTOR                                       0x0000080A

             /**
              * Guest LDTR selector.
              */
#define VMCS_GUEST_LDTR_SELECTOR                                     0x0000080C

              /**
               * Guest TR selector.
               */
#define VMCS_GUEST_TR_SELECTOR                                       0x0000080E

               /**
                * Guest interrupt status.
                *
                * @remarks This field exists only on processors that support the 1-setting of the "virtual-interrupt delivery"
                *          VM-execution control.
                */
#define VMCS_GUEST_INTERRUPT_STATUS                                  0x00000810

                /**
                 * PML index.
                 *
                 * @remarks This field exists only on processors that support the 1-setting of the "enable PML" VM-execution control.
                 */
#define VMCS_GUEST_PML_INDEX                                         0x00000812
                 /**
                  * @}
                  */

                  /**
                   * @defgroup vmcs_16_bit_host_state_fields \
                   *           16-Bit Host-State Fields
                   *
                   * 16-Bit Host-State Fields.
                   * @{
                   */
                   /**
                    * Host ES selector.
                    */
#define VMCS_HOST_ES_SELECTOR                                        0x00000C00

                    /**
                     * Host CS selector.
                     */
#define VMCS_HOST_CS_SELECTOR                                        0x00000C02

                     /**
                      * Host SS selector.
                      */
#define VMCS_HOST_SS_SELECTOR                                        0x00000C04

                      /**
                       * Host DS selector.
                       */
#define VMCS_HOST_DS_SELECTOR                                        0x00000C06

                       /**
                        * Host FS selector.
                        */
#define VMCS_HOST_FS_SELECTOR                                        0x00000C08

                        /**
                         * Host GS selector.
                         */
#define VMCS_HOST_GS_SELECTOR                                        0x00000C0A

                         /**
                          * Host TR selector.
                          */
#define VMCS_HOST_TR_SELECTOR                                        0x00000C0C
                          /**
                           * @}
                           */

                           /**
                            * @}
                            */

                            /**
                             * @defgroup vmcs_64_bit \
                             *           64-Bit Fields
                             *
                             * 64-Bit Fields.
                             *
                             * @see Vol3D[B.2(64-BIT FIELDS)] (reference)
                             * @{
                             */
                             /**
                              * @defgroup vmcs_64_bit_control_fields \
                              *           64-Bit Control Fields
                              *
                              * 64-Bit Control Fields.
                              * @{
                              */
                              /**
                               * Address of I/O bitmap A.
                               */
#define VMCS_CTRL_IO_BITMAP_A_ADDRESS                                0x00002000

                               /**
                                * Address of I/O bitmap B.
                                */
#define VMCS_CTRL_IO_BITMAP_B_ADDRESS                                0x00002002

                                /**
                                 * Address of MSR bitmaps.
                                 */
#define VMCS_CTRL_MSR_BITMAP_ADDRESS                                 0x00002004

                                 /**
                                  * VM-exit MSR-store address.
                                  */
#define VMCS_CTRL_VMEXIT_MSR_STORE_ADDRESS                           0x00002006

                                  /**
                                   * VM-exit MSR-load address.
                                   */
#define VMCS_CTRL_VMEXIT_MSR_LOAD_ADDRESS                            0x00002008

                                   /**
                                    * VM-entry MSR-load address.
                                    */
#define VMCS_CTRL_VMENTRY_MSR_LOAD_ADDRESS                           0x0000200A

                                    /**
                                     * Executive-VMCS pointer.
                                     */
#define VMCS_CTRL_EXECUTIVE_VMCS_POINTER                             0x0000200C

                                     /**
                                      * PML address.
                                      */
#define VMCS_CTRL_PML_ADDRESS                                        0x0000200E

                                      /**
                                       * TSC offset.
                                       */
#define VMCS_CTRL_TSC_OFFSET                                         0x00002010

                                       /**
                                        * Virtual-APIC address.
                                        */
#define VMCS_CTRL_VIRTUAL_APIC_ADDRESS                               0x00002012

                                        /**
                                         * APIC-access address.
                                         */
#define VMCS_CTRL_APIC_ACCESS_ADDRESS                                0x00002014

                                         /**
                                          * Posted-interrupt descriptor address
                                          */
#define VMCS_CTRL_POSTED_INTERRUPT_DESCRIPTOR_ADDRESS                0x00002016

                                          /**
                                           * VM-function controls.
                                           */
#define VMCS_CTRL_VMFUNC_CONTROLS                                    0x00002018

                                           /**
                                            * EPT pointer.
                                            */
#define VMCS_CTRL_EPT_POINTER                                        0x0000201A

                                            /**
                                             * EOI-exit bitmap 0.
                                             */
#define VMCS_CTRL_EOI_EXIT_BITMAP_0                                  0x0000201C

                                             /**
                                              * EOI-exit bitmap 1.
                                              */
#define VMCS_CTRL_EOI_EXIT_BITMAP_1                                  0x0000201E

                                              /**
                                               * EOI-exit bitmap 2.
                                               */
#define VMCS_CTRL_EOI_EXIT_BITMAP_2                                  0x00002020

                                               /**
                                                * EOI-exit bitmap 3.
                                                */
#define VMCS_CTRL_EOI_EXIT_BITMAP_3                                  0x00002022

                                                /**
                                                 * EPTP-list address.
                                                 */
#define VMCS_CTRL_EPT_POINTER_LIST_ADDRESS                           0x00002024

                                                 /**
                                                  * VMREAD-bitmap address.
                                                  */
#define VMCS_CTRL_VMREAD_BITMAP_ADDRESS                              0x00002026

                                                  /**
                                                   * VMWRITE-bitmap address.
                                                   */
#define VMCS_CTRL_VMWRITE_BITMAP_ADDRESS                             0x00002028

                                                   /**
                                                    * Virtualization-exception information address.
                                                    */
#define VMCS_CTRL_VIRTUALIZATION_EXCEPTION_INFORMATION_ADDRESS       0x0000202A

                                                    /**
                                                     * XSS-exiting bitmap.
                                                     */
#define VMCS_CTRL_XSS_EXITING_BITMAP                                 0x0000202C

                                                     /**
                                                      * ENCLS-exiting bitmap.
                                                      */
#define VMCS_CTRL_ENCLS_EXITING_BITMAP                               0x0000202E

                                                      /**
                                                       * TSC multiplier.
                                                       */
#define VMCS_CTRL_TSC_MULTIPLIER                                     0x00002032
                                                       /**
                                                        * @}
                                                        */

                                                        /**
                                                         * @defgroup vmcs_64_bit_read_only_data_fields \
                                                         *           64-Bit Read-Only Data Field
                                                         *
                                                         * 64-Bit Read-Only Data Field.
                                                         * @{
                                                         */
                                                         /**
                                                          * Guest-physical address.
                                                          */
#define VMCS_GUEST_PHYSICAL_ADDRESS                                  0x00002400
                                                          /**
                                                           * @}
                                                           */

                                                           /**
                                                            * @defgroup vmcs_64_bit_guest_state_fields \
                                                            *           64-Bit Guest-State Fields
                                                            *
                                                            * 64-Bit Guest-State Fields.
                                                            * @{
                                                            */
                                                            /**
                                                             * VMCS link pointer.
                                                             */
#define VMCS_GUEST_VMCS_LINK_POINTER                                 0x00002800

                                                             /**
                                                              * Guest IA32_DEBUGCTL.
                                                              */
#define VMCS_GUEST_DEBUGCTL                                          0x00002802

                                                              /**
                                                               * Guest IA32_PAT.
                                                               */
#define VMCS_GUEST_PAT                                               0x00002804

                                                               /**
                                                                * Guest IA32_EFER.
                                                                */
#define VMCS_GUEST_EFER                                              0x00002806

                                                                /**
                                                                 * Guest IA32_PERF_GLOBAL_CTRL.
                                                                 */
#define VMCS_GUEST_PERF_GLOBAL_CTRL                                  0x00002808

                                                                 /**
                                                                  * Guest PDPTE0.
                                                                  */
#define VMCS_GUEST_PDPTE0                                            0x0000280A

                                                                  /**
                                                                   * Guest PDPTE1.
                                                                   */
#define VMCS_GUEST_PDPTE1                                            0x0000280C

                                                                   /**
                                                                    * Guest PDPTE2.
                                                                    */
#define VMCS_GUEST_PDPTE2                                            0x0000280E

                                                                    /**
                                                                     * Guest PDPTE3.
                                                                     */
#define VMCS_GUEST_PDPTE3                                            0x00002810

                                                                     /**
                                                                      * Guest IA32_BNDCFGS.
                                                                      */
#define VMCS_GUEST_BNDCFGS                                           0x00002812

                                                                      /**
                                                                       * Guest IA32_RTIT_CTL.
                                                                       */
#define VMCS_GUEST_RTIT_CTL                                          0x00002814
                                                                       /**
                                                                        * @}
                                                                        */

                                                                        /**
                                                                         * @defgroup vmcs_64_bit_host_state_fields \
                                                                         *           64-Bit Host-State Fields
                                                                         *
                                                                         * 64-Bit Host-State Fields.
                                                                         * @{
                                                                         */
                                                                         /**
                                                                          * Host IA32_PAT.
                                                                          */
#define VMCS_HOST_PAT                                                0x00002C00

                                                                          /**
                                                                           * Host IA32_EFER.
                                                                           */
#define VMCS_HOST_EFER                                               0x00002C02

                                                                           /**
                                                                            * Host IA32_PERF_GLOBAL_CTRL.
                                                                            */
#define VMCS_HOST_PERF_GLOBAL_CTRL                                   0x00002C04
                                                                            /**
                                                                             * @}
                                                                             */

                                                                             /**
                                                                              * @}
                                                                              */

                                                                              /**
                                                                               * @defgroup vmcs_32_bit \
                                                                               *           32-Bit Fields
                                                                               *
                                                                               * 32-Bit Fields.
                                                                               *
                                                                               * @see Vol3D[B.3(32-BIT FIELDS)] (reference)
                                                                               * @{
                                                                               */
                                                                               /**
                                                                                * @defgroup vmcs_32_bit_control_fields \
                                                                                *           32-Bit Control Fields
                                                                                *
                                                                                * 32-Bit Control Fields.
                                                                                * @{
                                                                                */
                                                                                /**
                                                                                 * Pin-based VM-execution controls.
                                                                                 */
#define VMCS_CTRL_PIN_BASED_VM_EXECUTION_CONTROLS                    0x00004000

                                                                                 /**
                                                                                  * Primary processor-based VM-execution controls.
                                                                                  */
#define VMCS_CTRL_PROCESSOR_BASED_VM_EXECUTION_CONTROLS              0x00004002

                                                                                  /**
                                                                                   * Exception bitmap.
                                                                                   */
#define VMCS_CTRL_EXCEPTION_BITMAP                                   0x00004004

                                                                                   /**
                                                                                    * Page-fault error-code mask.
                                                                                    */
#define VMCS_CTRL_PAGEFAULT_ERROR_CODE_MASK                          0x00004006

                                                                                    /**
                                                                                     * Page-fault error-code match.
                                                                                     */
#define VMCS_CTRL_PAGEFAULT_ERROR_CODE_MATCH                         0x00004008

                                                                                     /**
                                                                                      * CR3-target count.
                                                                                      */
#define VMCS_CTRL_CR3_TARGET_COUNT                                   0x0000400A

                                                                                      /**
                                                                                       * VM-exit controls.
                                                                                       */
#define VMCS_CTRL_VMEXIT_CONTROLS                                    0x0000400C

                                                                                       /**
                                                                                        * VM-exit MSR-store count.
                                                                                        */
#define VMCS_CTRL_VMEXIT_MSR_STORE_COUNT                             0x0000400E

                                                                                        /**
                                                                                         * VM-exit MSR-load count.
                                                                                         */
#define VMCS_CTRL_VMEXIT_MSR_LOAD_COUNT                              0x00004010

                                                                                         /**
                                                                                          * VM-entry controls.
                                                                                          */
#define VMCS_CTRL_VMENTRY_CONTROLS                                   0x00004012

                                                                                          /**
                                                                                           * VM-entry MSR-load count.
                                                                                           */
#define VMCS_CTRL_VMENTRY_MSR_LOAD_COUNT                             0x00004014

                                                                                           /**
                                                                                            * VM-entry interruption-information field.
                                                                                            */
#define VMCS_CTRL_VMENTRY_INTERRUPTION_INFORMATION_FIELD             0x00004016

                                                                                            /**
                                                                                             * VM-entry exception error code.
                                                                                             */
#define VMCS_CTRL_VMENTRY_EXCEPTION_ERROR_CODE                       0x00004018

                                                                                             /**
                                                                                              * VM-entry instruction length.
                                                                                              */
#define VMCS_CTRL_VMENTRY_INSTRUCTION_LENGTH                         0x0000401A

                                                                                              /**
                                                                                               * TPR threshold.
                                                                                               */
#define VMCS_CTRL_TPR_THRESHOLD                                      0x0000401C

                                                                                               /**
                                                                                                * Secondary processor-based VM-execution controls.
                                                                                                */
#define VMCS_CTRL_SECONDARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS    0x0000401E

                                                                                                /**
                                                                                                 * PLE_Gap.
                                                                                                 */
#define VMCS_CTRL_PLE_GAP                                            0x00004020

                                                                                                 /**
                                                                                                  * PLE_Window.
                                                                                                  */
#define VMCS_CTRL_PLE_WINDOW                                         0x00004022
                                                                                                  /**
                                                                                                   * @}
                                                                                                   */

                                                                                                   /**
                                                                                                    * @defgroup vmcs_32_bit_read_only_data_fields \
                                                                                                    *           32-Bit Read-Only Data Fields
                                                                                                    *
                                                                                                    * 32-Bit Read-Only Data Fields.
                                                                                                    * @{
                                                                                                    */
                                                                                                    /**
                                                                                                     * VM-instruction error.
                                                                                                     */
#define VMCS_VM_INSTRUCTION_ERROR                                    0x00004400

                                                                                                     /**
                                                                                                      * Exit reason.
                                                                                                      */
#define VMCS_EXIT_REASON                                             0x00004402

                                                                                                      /**
                                                                                                       * VM-exit interruption information.
                                                                                                       */
#define VMCS_VMEXIT_INTERRUPTION_INFORMATION                         0x00004404

                                                                                                       /**
                                                                                                        * VM-exit interruption error code.
                                                                                                        */
#define VMCS_VMEXIT_INTERRUPTION_ERROR_CODE                          0x00004406

                                                                                                        /**
                                                                                                         * IDT-vectoring information field.
                                                                                                         */
#define VMCS_IDT_VECTORING_INFORMATION                               0x00004408

                                                                                                         /**
                                                                                                          * IDT-vectoring error code.
                                                                                                          */
#define VMCS_IDT_VECTORING_ERROR_CODE                                0x0000440A

                                                                                                          /**
                                                                                                           * VM-exit instruction length.
                                                                                                           */
#define VMCS_VMEXIT_INSTRUCTION_LENGTH                               0x0000440C

                                                                                                           /**
                                                                                                            * VM-exit instruction information.
                                                                                                            */
#define VMCS_VMEXIT_INSTRUCTION_INFO                                 0x0000440E
                                                                                                            /**
                                                                                                             * @}
                                                                                                             */

                                                                                                             /**
                                                                                                              * @defgroup vmcs_32_bit_guest_state_fields \
                                                                                                              *           32-Bit Guest-State Fields
                                                                                                              *
                                                                                                              * 32-Bit Guest-State Fields.
                                                                                                              * @{
                                                                                                              */
                                                                                                              /**
                                                                                                               * Guest ES limit.
                                                                                                               */
#define VMCS_GUEST_ES_LIMIT                                          0x00004800

                                                                                                               /**
                                                                                                                * Guest CS limit.
                                                                                                                */
#define VMCS_GUEST_CS_LIMIT                                          0x00004802

                                                                                                                /**
                                                                                                                 * Guest SS limit.
                                                                                                                 */
#define VMCS_GUEST_SS_LIMIT                                          0x00004804

                                                                                                                 /**
                                                                                                                  * Guest DS limit.
                                                                                                                  */
#define VMCS_GUEST_DS_LIMIT                                          0x00004806

                                                                                                                  /**
                                                                                                                   * Guest FS limit.
                                                                                                                   */
#define VMCS_GUEST_FS_LIMIT                                          0x00004808

                                                                                                                   /**
                                                                                                                    * Guest GS limit.
                                                                                                                    */
#define VMCS_GUEST_GS_LIMIT                                          0x0000480A

                                                                                                                    /**
                                                                                                                     * Guest LDTR limit.
                                                                                                                     */
#define VMCS_GUEST_LDTR_LIMIT                                        0x0000480C

                                                                                                                     /**
                                                                                                                      * Guest TR limit.
                                                                                                                      */
#define VMCS_GUEST_TR_LIMIT                                          0x0000480E

                                                                                                                      /**
                                                                                                                       * Guest GDTR limit.
                                                                                                                       */
#define VMCS_GUEST_GDTR_LIMIT                                        0x00004810

                                                                                                                       /**
                                                                                                                        * Guest IDTR limit.
                                                                                                                        */
#define VMCS_GUEST_IDTR_LIMIT                                        0x00004812

                                                                                                                        /**
                                                                                                                         * Guest ES access rights.
                                                                                                                         */
#define VMCS_GUEST_ES_ACCESS_RIGHTS                                  0x00004814

                                                                                                                         /**
                                                                                                                          * Guest CS access rights.
                                                                                                                          */
#define VMCS_GUEST_CS_ACCESS_RIGHTS                                  0x00004816

                                                                                                                          /**
                                                                                                                           * Guest SS access rights.
                                                                                                                           */
#define VMCS_GUEST_SS_ACCESS_RIGHTS                                  0x00004818

                                                                                                                           /**
                                                                                                                            * Guest DS access rights.
                                                                                                                            */
#define VMCS_GUEST_DS_ACCESS_RIGHTS                                  0x0000481A

                                                                                                                            /**
                                                                                                                             * Guest FS access rights.
                                                                                                                             */
#define VMCS_GUEST_FS_ACCESS_RIGHTS                                  0x0000481C

                                                                                                                             /**
                                                                                                                              * Guest GS access rights.
                                                                                                                              */
#define VMCS_GUEST_GS_ACCESS_RIGHTS                                  0x0000481E

                                                                                                                              /**
                                                                                                                               * Guest LDTR access rights.
                                                                                                                               */
#define VMCS_GUEST_LDTR_ACCESS_RIGHTS                                0x00004820

                                                                                                                               /**
                                                                                                                                * Guest TR access rights.
                                                                                                                                */
#define VMCS_GUEST_TR_ACCESS_RIGHTS                                  0x00004822

                                                                                                                                /**
                                                                                                                                 * Guest interruptibility state.
                                                                                                                                 */
#define VMCS_GUEST_INTERRUPTIBILITY_STATE                            0x00004824

                                                                                                                                 /**
                                                                                                                                  * Guest activity state.
                                                                                                                                  */
#define VMCS_GUEST_ACTIVITY_STATE                                    0x00004826

                                                                                                                                  /**
                                                                                                                                   * Guest SMBASE.
                                                                                                                                   */
#define VMCS_GUEST_SMBASE                                            0x00004828

                                                                                                                                   /**
                                                                                                                                    * Guest IA32_SYSENTER_CS.
                                                                                                                                    */
#define VMCS_GUEST_SYSENTER_CS                                       0x0000482A

                                                                                                                                    /**
                                                                                                                                     * VMX-preemption timer value.
                                                                                                                                     */
#define VMCS_GUEST_VMX_PREEMPTION_TIMER_VALUE                        0x0000482E
                                                                                                                                     /**
                                                                                                                                      * @}
                                                                                                                                      */

                                                                                                                                      /**
                                                                                                                                       * @defgroup vmcs_32_bit_host_state_fields \
                                                                                                                                       *           32-Bit Host-State Field
                                                                                                                                       *
                                                                                                                                       * 32-Bit Host-State Field.
                                                                                                                                       * @{
                                                                                                                                       */
                                                                                                                                       /**
                                                                                                                                        * Host IA32_SYSENTER_CS.
                                                                                                                                        */
#define VMCS_HOST_SYSENTER_CS                                        0x00004C00
                                                                                                                                        /**
                                                                                                                                         * @}
                                                                                                                                         */

                                                                                                                                         /**
                                                                                                                                          * @}
                                                                                                                                          */

                                                                                                                                          /**
                                                                                                                                           * @defgroup vmcs_natural_width \
                                                                                                                                           *           Natural-Width Fields
                                                                                                                                           *
                                                                                                                                           * Natural-Width Fields.
                                                                                                                                           *
                                                                                                                                           * @see Vol3D[B.4(NATURAL-WIDTH FIELDS)] (reference)
                                                                                                                                           * @{
                                                                                                                                           */
                                                                                                                                           /**
                                                                                                                                            * @defgroup vmcs_natural_width_control_fields \
                                                                                                                                            *           Natural-Width Control Fields
                                                                                                                                            *
                                                                                                                                            * Natural-Width Control Fields
                                                                                                                                            * @{
                                                                                                                                            */
                                                                                                                                            /**
                                                                                                                                             * CR0 guest/host mask.
                                                                                                                                             */
#define VMCS_CTRL_CR0_GUEST_HOST_MASK                                0x00006000

                                                                                                                                             /**
                                                                                                                                              * CR4 guest/host mask.
                                                                                                                                              */
#define VMCS_CTRL_CR4_GUEST_HOST_MASK                                0x00006002

                                                                                                                                              /**
                                                                                                                                               * CR0 read shadow.
                                                                                                                                               */
#define VMCS_CTRL_CR0_READ_SHADOW                                    0x00006004

                                                                                                                                               /**
                                                                                                                                                * CR4 read shadow.
                                                                                                                                                */
#define VMCS_CTRL_CR4_READ_SHADOW                                    0x00006006

                                                                                                                                                /**
                                                                                                                                                 * CR3-target value 0.
                                                                                                                                                 */
#define VMCS_CTRL_CR3_TARGET_VALUE_0                                 0x00006008

                                                                                                                                                 /**
                                                                                                                                                  * CR3-target value 1.
                                                                                                                                                  */
#define VMCS_CTRL_CR3_TARGET_VALUE_1                                 0x0000600A

                                                                                                                                                  /**
                                                                                                                                                   * CR3-target value 2.
                                                                                                                                                   */
#define VMCS_CTRL_CR3_TARGET_VALUE_2                                 0x0000600C

                                                                                                                                                   /**
                                                                                                                                                    * CR3-target value 3.
                                                                                                                                                    */
#define VMCS_CTRL_CR3_TARGET_VALUE_3                                 0x0000600E
                                                                                                                                                    /**
                                                                                                                                                     * @}
                                                                                                                                                     */

                                                                                                                                                     /**
                                                                                                                                                      * @defgroup vmcs_natural_width_read_only_data_fields \
                                                                                                                                                      *           Natural-Width Read-Only Data Fields
                                                                                                                                                      *
                                                                                                                                                      * Natural-Width Read-Only Data Fields.
                                                                                                                                                      * @{
                                                                                                                                                      */
                                                                                                                                                      /**
                                                                                                                                                       * Exit qualification.
                                                                                                                                                       */
#define VMCS_EXIT_QUALIFICATION                                      0x00006400

                                                                                                                                                       /**
                                                                                                                                                        * I/O RCX.
                                                                                                                                                        */
#define VMCS_IO_RCX                                                  0x00006402

                                                                                                                                                        /**
                                                                                                                                                         * I/O RSI.
                                                                                                                                                         */
#define VMCS_IO_RSX                                                  0x00006404

                                                                                                                                                         /**
                                                                                                                                                          * I/O RDI.
                                                                                                                                                          */
#define VMCS_IO_RDI                                                  0x00006406

                                                                                                                                                          /**
                                                                                                                                                           * I/O RIP.
                                                                                                                                                           */
#define VMCS_IO_RIP                                                  0x00006408

                                                                                                                                                           /**
                                                                                                                                                            * Guest-linear address.
                                                                                                                                                            */
#define VMCS_EXIT_GUEST_LINEAR_ADDRESS                               0x0000640A
                                                                                                                                                            /**
                                                                                                                                                             * @}
                                                                                                                                                             */

                                                                                                                                                             /**
                                                                                                                                                              * @defgroup vmcs_natural_width_guest_state_fields \
                                                                                                                                                              *           Natural-Width Guest-State Fields
                                                                                                                                                              *
                                                                                                                                                              * Natural-Width Guest-State Fields.
                                                                                                                                                              * @{
                                                                                                                                                              */
                                                                                                                                                              /**
                                                                                                                                                               * Guest CR0.
                                                                                                                                                               */
#define VMCS_GUEST_CR0                                               0x00006800

                                                                                                                                                               /**
                                                                                                                                                                * Guest CR3.
                                                                                                                                                                */
#define VMCS_GUEST_CR3                                               0x00006802

                                                                                                                                                                /**
                                                                                                                                                                 * Guest CR4.
                                                                                                                                                                 */
#define VMCS_GUEST_CR4                                               0x00006804

                                                                                                                                                                 /**
                                                                                                                                                                  * Guest ES base.
                                                                                                                                                                  */
#define VMCS_GUEST_ES_BASE                                           0x00006806

                                                                                                                                                                  /**
                                                                                                                                                                   * Guest CS base.
                                                                                                                                                                   */
#define VMCS_GUEST_CS_BASE                                           0x00006808

                                                                                                                                                                   /**
                                                                                                                                                                    * Guest SS base.
                                                                                                                                                                    */
#define VMCS_GUEST_SS_BASE                                           0x0000680A

                                                                                                                                                                    /**
                                                                                                                                                                     * Guest DS base.
                                                                                                                                                                     */
#define VMCS_GUEST_DS_BASE                                           0x0000680C

                                                                                                                                                                     /**
                                                                                                                                                                      * Guest FS base.
                                                                                                                                                                      */
#define VMCS_GUEST_FS_BASE                                           0x0000680E

                                                                                                                                                                      /**
                                                                                                                                                                       * Guest GS base.
                                                                                                                                                                       */
#define VMCS_GUEST_GS_BASE                                           0x00006810

                                                                                                                                                                       /**
                                                                                                                                                                        * Guest LDTR base.
                                                                                                                                                                        */
#define VMCS_GUEST_LDTR_BASE                                         0x00006812

                                                                                                                                                                        /**
                                                                                                                                                                         * Guest TR base.
                                                                                                                                                                         */
#define VMCS_GUEST_TR_BASE                                           0x00006814

                                                                                                                                                                         /**
                                                                                                                                                                          * Guest GDTR base.
                                                                                                                                                                          */
#define VMCS_GUEST_GDTR_BASE                                         0x00006816

                                                                                                                                                                          /**
                                                                                                                                                                           * Guest IDTR base.
                                                                                                                                                                           */
#define VMCS_GUEST_IDTR_BASE                                         0x00006818

                                                                                                                                                                           /**
                                                                                                                                                                            * Guest DR7.
                                                                                                                                                                            */
#define VMCS_GUEST_DR7                                               0x0000681A

                                                                                                                                                                            /**
                                                                                                                                                                             * Guest RSP.
                                                                                                                                                                             */
#define VMCS_GUEST_RSP                                               0x0000681C

                                                                                                                                                                             /**
                                                                                                                                                                              * Guest RIP.
                                                                                                                                                                              */
#define VMCS_GUEST_RIP                                               0x0000681E

                                                                                                                                                                              /**
                                                                                                                                                                               * Guest RFLAGS.
                                                                                                                                                                               */
#define VMCS_GUEST_RFLAGS                                            0x00006820

                                                                                                                                                                               /**
                                                                                                                                                                                * Guest pending debug exceptions.
                                                                                                                                                                                */
#define VMCS_GUEST_PENDING_DEBUG_EXCEPTIONS                          0x00006822

                                                                                                                                                                                /**
                                                                                                                                                                                 * Guest IA32_SYSENTER_ESP.
                                                                                                                                                                                 */
#define VMCS_GUEST_SYSENTER_ESP                                      0x00006824

                                                                                                                                                                                 /**
                                                                                                                                                                                  * Guest IA32_SYSENTER_EIP.
                                                                                                                                                                                  */
#define VMCS_GUEST_SYSENTER_EIP                                      0x00006826

                                                                                                                                                                                  /**
                                                                                                                                                                                   * Guest IA32_S_CET.
                                                                                                                                                                                   */
#define VMCS_GUEST_S_CET                                             0x00006C28

                                                                                                                                                                                   /**
                                                                                                                                                                                    * Guest SSP.
                                                                                                                                                                                    */
#define VMCS_GUEST_SSP                                               0x00006C2A

                                                                                                                                                                                    /**
                                                                                                                                                                                     * Guest IA32_INTERRUPT_SSP_TABLE_ADDR.
                                                                                                                                                                                     */
#define VMCS_GUEST_INTERRUPT_SSP_TABLE_ADDR                          0x00006C2C
                                                                                                                                                                                     /**
                                                                                                                                                                                      * @}
                                                                                                                                                                                      */

                                                                                                                                                                                      /**
                                                                                                                                                                                       * @defgroup vmcs_natural_width_host_state_fields \
                                                                                                                                                                                       *           Natural-Width Host-State Fields
                                                                                                                                                                                       *
                                                                                                                                                                                       * Natural-Width Host-State Fields.
                                                                                                                                                                                       * @{
                                                                                                                                                                                       */
                                                                                                                                                                                       /**
                                                                                                                                                                                        * Host CR0.
                                                                                                                                                                                        */
#define VMCS_HOST_CR0                                                0x00006C00

                                                                                                                                                                                        /**
                                                                                                                                                                                         * Host CR3.
                                                                                                                                                                                         */
#define VMCS_HOST_CR3                                                0x00006C02

                                                                                                                                                                                         /**
                                                                                                                                                                                          * Host CR4.
                                                                                                                                                                                          */
#define VMCS_HOST_CR4                                                0x00006C04

                                                                                                                                                                                          /**
                                                                                                                                                                                           * Host FS base.
                                                                                                                                                                                           */
#define VMCS_HOST_FS_BASE                                            0x00006C06

                                                                                                                                                                                           /**
                                                                                                                                                                                            * Host GS base.
                                                                                                                                                                                            */
#define VMCS_HOST_GS_BASE                                            0x00006C08

                                                                                                                                                                                            /**
                                                                                                                                                                                             * Host TR base.
                                                                                                                                                                                             */
#define VMCS_HOST_TR_BASE                                            0x00006C0A

                                                                                                                                                                                             /**
                                                                                                                                                                                              * Host GDTR base.
                                                                                                                                                                                              */
#define VMCS_HOST_GDTR_BASE                                          0x00006C0C

                                                                                                                                                                                              /**
                                                                                                                                                                                               * Host IDTR base.
                                                                                                                                                                                               */
#define VMCS_HOST_IDTR_BASE                                          0x00006C0E

                                                                                                                                                                                               /**
                                                                                                                                                                                                * Host IA32_SYSENTER_ESP.
                                                                                                                                                                                                */
#define VMCS_HOST_SYSENTER_ESP                                       0x00006C10

                                                                                                                                                                                                /**
                                                                                                                                                                                                 * Host IA32_SYSENTER_EIP.
                                                                                                                                                                                                 */
#define VMCS_HOST_SYSENTER_EIP                                       0x00006C12

                                                                                                                                                                                                 /**
                                                                                                                                                                                                  * Host RSP.
                                                                                                                                                                                                  */
#define VMCS_HOST_RSP                                                0x00006C14

                                                                                                                                                                                                  /**
                                                                                                                                                                                                   * Host RIP.
                                                                                                                                                                                                   */
#define VMCS_HOST_RIP                                                0x00006C16

                                                                                                                                                                                                   /**
                                                                                                                                                                                                    * Host IA32_S_CET.
                                                                                                                                                                                                    */
#define VMCS_HOST_S_CET                                              0x00006C18

                                                                                                                                                                                                    /**
                                                                                                                                                                                                     * Host SSP.
                                                                                                                                                                                                     */
#define VMCS_HOST_SSP                                                0x00006C1A

                                                                                                                                                                                                     /**
                                                                                                                                                                                                      * Host IA32_INTERRUPT_SSP_TABLE_ADDR.
                                                                                                                                                                                                      */
#define VMCS_HOST_INTERRUPT_SSP_TABLE_ADDR                           0x00006C1C
                                                                                                                                                                                                      /**
                                                                                                                                                                                                       * @}
                                                                                                                                                                                                       */

                                                                                                                                                                                                       /**
                                                                                                                                                                                                        * @}
                                                                                                                                                                                                        */

                                                                                                                                                                                                        /**
                                                                                                                                                                                                         * @}
                                                                                                                                                                                                         */

                                                                                                                                                                                                         /**
                                                                                                                                                                                                          * @brief Valid interruption types
                                                                                                                                                                                                          */
typedef enum
{
    /**
     * External interrupt.
     */
    external_interrupt = 0x00000000,

    /**
     * Non-maskable interrupt (NMI).
     */
     non_maskable_interrupt = 0x00000002,

     /**
      * Hardware exception (e.g,. \#PF).
      */
      hardware_exception = 0x00000003,

      /**
       * Software interrupt (INT n).
       */
       software_interrupt = 0x00000004,

       /**
        * Privileged software exception (INT1).
        */
        privileged_software_exception = 0x00000005,

        /**
         * Software exception (INT3 or INTO).
         */
         software_exception = 0x00000006,

         /**
          * Other event. This type is used for injection of events that are not delivered through the IDT.
          */
          other_event = 0x00000007,
} interruption_type;

/**
 * @brief VM entry can be configured to conclude by delivering an event through the IDT (after all guest state and MSRs
 *        have been loaded). This process is called event injection and is controlled by these VM-entry control fields
 *
 * @see Vol3A[24.8.3(VM-Entry Controls for Event Injection)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * @brief Vector of interrupt or exception
         *
         * [Bits 7:0] Determines which entry in the IDT is used or which other event is injected.
         */
        UINT32_t vector : 8;
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR_BIT                     0
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR_FLAG                    0xFF
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR_MASK                    0xFF
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR(_)                      (((_) >> 0) & 0xFF)

        /**
         * @brief Interruption type
         *
         * [Bits 10:8] Determines details of how the injection is performed.
         */
        UINT32_t interruption_type : 3;
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_BIT          8
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_FLAG         0x700
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_MASK         0x07
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE(_)           (((_) >> 8) & 0x07)

        /**
         * @brief Deliver error code (0 = do not deliver; 1 = deliver)
         *
         * [Bit 11] Determines whether delivery pushes an error code on the guest stack.
         */
        UINT32_t deliver_error_code : 1;
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_BIT         11
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_FLAG        0x800
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_MASK        0x01
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE(_)          (((_) >> 11) & 0x01)
        UINT32_t reserved1 : 19;

        /**
         * @brief Valid
         *
         * [Bit 31] VM entry injects an event if and only if the valid bit is 1. The valid bit in this field is cleared on every VM
         * exit.
         */
        UINT32_t valid : 1;
#define VMENTRY_INTERRUPT_INFORMATION_VALID_BIT                      31
#define VMENTRY_INTERRUPT_INFORMATION_VALID_FLAG                     0x80000000
#define VMENTRY_INTERRUPT_INFORMATION_VALID_MASK                     0x01
#define VMENTRY_INTERRUPT_INFORMATION_VALID(_)                       (((_) >> 31) & 0x01)
    };

    UINT32_t flags;
} vmentry_interrupt_information;

/**
 * @brief VM entry can be configured to conclude by delivering an event through the IDT (after all guest state and MSRs
 *        have been loaded). This process is called event injection and is controlled by these VM-entry control fields
 *
 * @see Vol3A[24.9.2(Information for VM Exits Due to Vectored Events)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Vector of interrupt or exception.
         */
        UINT32_t vector : 8;
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR_BIT                      0
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR_FLAG                     0xFF
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR_MASK                     0xFF
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR(_)                       (((_) >> 0) & 0xFF)

        /**
         * [Bits 10:8] Interruption type.
         */
        UINT32_t interruption_type : 3;
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_BIT           8
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_FLAG          0x700
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_MASK          0x07
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE(_)            (((_) >> 8) & 0x07)

        /**
         * [Bit 11] Deliver error code (0 = do not deliver; 1 = deliver).
         */
        UINT32_t error_code_valid : 1;
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_BIT            11
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_FLAG           0x800
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_MASK           0x01
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID(_)             (((_) >> 11) & 0x01)

        /**
         * [Bit 12] NMI unblocking due to IRET.
         */
        UINT32_t nmi_unblocking : 1;
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_BIT              12
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_FLAG             0x1000
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_MASK             0x01
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING(_)               (((_) >> 12) & 0x01)
        UINT32_t reserved1 : 18;

        /**
         * [Bit 31] Valid.
         */
        UINT32_t valid : 1;
#define VMEXIT_INTERRUPT_INFORMATION_VALID_BIT                       31
#define VMEXIT_INTERRUPT_INFORMATION_VALID_FLAG                      0x80000000
#define VMEXIT_INTERRUPT_INFORMATION_VALID_MASK                      0x01
#define VMEXIT_INTERRUPT_INFORMATION_VALID(_)                        (((_) >> 31) & 0x01)
    };

    UINT32_t flags;
} vmexit_interrupt_information;

/**
 * @}
 */

 /**
  * @defgroup apic \
  *           Advanced Programmable Interrupt Controller (APIC)
  *
  * Software interacts with the local APIC by reading and writing its registers. APIC registers are memory-mapped to a
  * 4-KByte region of the processor's physical address space with an initial starting address of FEE00000H. For correct APIC
  * operation, this address space must be mapped to an area of memory that has been designated as strong uncacheable (UC).
  *
  * @remarks Registers are 32 bits, 64 bits, or 256 bits in width; all are aligned on 128-bit boundaries. All 32-bit
  *          registers should be accessed using 128-bit aligned 32-bit loads or stores. Some processors may support loads and stores
  *          of less than 32 bits to some of the APIC registers. This is model specific behavior and is not guaranteed to work on all
  *          processors. Any FP/MMX/SSE access to an APIC register, or any access that touches bytes 4 through 15 of an APIC register
  *          may cause undefined behavior and must not be executed. This undefined behavior could include hangs, incorrect results or
  *          unexpected exceptions, including machine checks, and may vary between implementations. Wider registers (64-bit or
  *          256-bit) must be accessed using multiple 32-bit loads or stores, with all accesses being 128-bit aligned.
  * @see Vol3A[10.4.1(The Local APIC Block Diagram)] (reference)
  * @{
  */
  /**
   * Local APIC Base Address.
   *
   * @remarks Reserved.
   */
#define APIC_BASE_ADDRESS                                            0xFEE00000

   /**
    * Local APIC ID Register.
    */
#define APIC_ID                                                      0x00000020

    /**
     * Local APIC Version Register.
     */
#define APIC_VERSION                                                 0x00000030

     /**
      * Task Priority Register (TPR).
      */
#define APIC_TASK_PRIORITY                                           0x00000080

      /**
       * Arbitration Priority Register (APR).
       */
#define APIC_ARBITRATION_PRIORITY                                    0x00000090

       /**
        * Processor Priority Register (PPR).
        */
#define APIC_PROCESSOR_PRIORITY                                      0x000000A0

        /**
         * EOI Register.
         */
#define APIC_EOI                                                     0x000000B0

         /**
          * Remote Read Register (RRD).
          */
#define APIC_REMOTE_READ                                             0x000000C0

          /**
           * Logical Destination Register.
           */
#define APIC_LOGICAL_DESTINATION                                     0x000000D0

           /**
            * Destination Format Register.
            *
            * @see Vol3A[10.6.2.2(Logical Destination Mode)]
            */
#define APIC_DESTINATION_FORMAT                                      0x000000E0

            /**
             * Spurious Interrupt Vector Register.
             *
             * @see Vol3A[10.9(SPURIOUS INTERRUPT)]
             */
#define APIC_SPURIOUS_INTERRUPT_VECTOR                               0x000000F0

             /**
              * In-Service Register (ISR); bits 31:0.
              */
#define APIC_IN_SERVICE_BITS_31_0                                    0x00000100

              /**
               * In-Service Register (ISR); bits 63:32.
               */
#define APIC_IN_SERVICE_BITS_63_32                                   0x00000110

               /**
                * In-Service Register (ISR); bits 95:64.
                */
#define APIC_IN_SERVICE_BITS_95_64                                   0x00000120

                /**
                 * In-Service Register (ISR); bits 127:96.
                 */
#define APIC_IN_SERVICE_BITS_127_96                                  0x00000130

                 /**
                  * In-Service Register (ISR); bits 159:128.
                  */
#define APIC_IN_SERVICE_BITS_159_128                                 0x00000140

                  /**
                   * In-Service Register (ISR); bits 191:160.
                   */
#define APIC_IN_SERVICE_BITS_191_160                                 0x00000150

                   /**
                    * In-Service Register (ISR); bits 223:192.
                    */
#define APIC_IN_SERVICE_BITS_223_192                                 0x00000160

                    /**
                     * In-Service Register (ISR); bits 255:224.
                     */
#define APIC_IN_SERVICE_BITS_255_224                                 0x00000170

                     /**
                      * Trigger Mode Register (TMR); bits 31:0.
                      */
#define APIC_TRIGGER_MODE_BITS_31_0                                  0x00000180

                      /**
                       * Trigger Mode Register (TMR); bits 63:32.
                       */
#define APIC_TRIGGER_MODE_BITS_63_32                                 0x00000190

                       /**
                        * Trigger Mode Register (TMR); bits 95:64.
                        */
#define APIC_TRIGGER_MODE_BITS_95_64                                 0x000001A0

                        /**
                         * Trigger Mode Register (TMR); bits 127:96.
                         */
#define APIC_TRIGGER_MODE_BITS_127_96                                0x000001B0

                         /**
                          * Trigger Mode Register (TMR); bits 159:128.
                          */
#define APIC_TRIGGER_MODE_BITS_159_128                               0x000001C0

                          /**
                           * Trigger Mode Register (TMR); bits 191:160.
                           */
#define APIC_TRIGGER_MODE_BITS_191_160                               0x000001D0

                           /**
                            * Trigger Mode Register (TMR); bits 223:192.
                            */
#define APIC_TRIGGER_MODE_BITS_223_192                               0x000001E0

                            /**
                             * Trigger Mode Register (TMR); bits 255:224.
                             */
#define APIC_TRIGGER_MODE_BITS_255_224                               0x000001F0

                             /**
                              * Interrupt Request Register (IRR); bits 31:0.
                              */
#define APIC_INTERRUPT_REQUEST_BITS_31_0                             0x00000200

                              /**
                               * Interrupt Request Register (IRR); bits 63:32.
                               */
#define APIC_INTERRUPT_REQUEST_BITS_63_32                            0x00000210

                               /**
                                * Interrupt Request Register (IRR); bits 95:64.
                                */
#define APIC_INTERRUPT_REQUEST_BITS_95_64                            0x00000220

                                /**
                                 * Interrupt Request Register (IRR); bits 127:96.
                                 */
#define APIC_INTERRUPT_REQUEST_BITS_127_96                           0x00000230

                                 /**
                                  * Interrupt Request Register (IRR); bits 159:128.
                                  */
#define APIC_INTERRUPT_REQUEST_BITS_159_128                          0x00000240

                                  /**
                                   * Interrupt Request Register (IRR); bits 191:160.
                                   */
#define APIC_INTERRUPT_REQUEST_BITS_191_160                          0x00000250

                                   /**
                                    * Interrupt Request Register (IRR); bits 223:192.
                                    */
#define APIC_INTERRUPT_REQUEST_BITS_223_192                          0x00000260

                                    /**
                                     * Interrupt Request Register (IRR); bits 255:224.
                                     */
#define APIC_INTERRUPT_REQUEST_BITS_255_224                          0x00000270

                                     /**
                                      * Error Status Register.
                                      */
#define APIC_ERROR_STATUS                                            0x00000280

                                      /**
                                       * LVT Corrected Machine Check Interrupt (CMCI) Register.
                                       */
#define APIC_LVT_CORRECTED_MACHINE_CHECK_INTERRUPT                   0x000002F0

                                       /**
                                        * Interrupt Command Register (ICR); bits 0-31.
                                        */
#define APIC_INTERRUPT_COMMAND_BITS_0_31                             0x00000300

                                        /**
                                         * Interrupt Command Register (ICR); bits 32-63.
                                         */
#define APIC_INTERRUPT_COMMAND_BITS_32_63                            0x00000310

                                         /**
                                          * LVT Timer Register.
                                          */
#define APIC_LVT_TIMER                                               0x00000320

                                          /**
                                           * LVT Thermal Sensor Register.
                                           */
#define APIC_LVT_THERMAL_SENSOR                                      0x00000330

                                           /**
                                            * LVT Performance Monitoring Counters Register.
                                            */
#define APIC_LVT_PERFORMANCE_MONITORING_COUNTERS                     0x00000340

                                            /**
                                             * LVT LINT0 Register.
                                             */
#define APIC_LVT_LINT0                                               0x00000350

                                             /**
                                              * LVT LINT1 Register.
                                              */
#define APIC_LVT_LINT1                                               0x00000360

                                              /**
                                               * LVT Error Register.
                                               */
#define APIC_LVT_ERROR                                               0x00000370

                                               /**
                                                * Initial Count Register (for Timer).
                                                */
#define APIC_INITIAL_COUNT                                           0x00000380

                                                /**
                                                 * Current Count Register (for Timer).
                                                 */
#define APIC_CURRENT_COUNT                                           0x00000390

                                                 /**
                                                  * Divide Configuration Register (for Timer).
                                                  */
#define APIC_DIVIDE_CONFIGURATION                                    0x000003E0
                                                  /**
                                                   * @}
                                                   */

                                                   /**
                                                    * The 32-bit EFLAGS register contains a group of status flags, a control flag, and a group of system flags. The status
                                                    * flags (bits 0, 2, 4, 6, 7, and 11) of the EFLAGS register indicate the results of arithmetic instructions, such as the
                                                    * ADD, SUB, MUL, and DIV instructions.
                                                    * The system flags and IOPL field in the EFLAGS register control operating-system or executive operations.
                                                    *
                                                    * @see Vol1[3.4.3(EFLAGS)] (reference)
                                                    */
typedef union
{
    struct
    {
        /**
         * @brief Carry flag
         *
         * [Bit 0] Set if an arithmetic operation generates a carry or a borrow out of the mostsignificant bit of the result;
         * cleared otherwise. This flag indicates an overflow condition for unsigned-integer arithmetic. It is also used in
         * multiple-precision arithmetic.
         */
        UINT32_t carry_flag : 1;
#define EFLAGS_CARRY_FLAG_BIT                                        0
#define EFLAGS_CARRY_FLAG_FLAG                                       0x01
#define EFLAGS_CARRY_FLAG_MASK                                       0x01
#define EFLAGS_CARRY_FLAG(_)                                         (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Reserved - always 1
         */
        UINT32_t read_as_1 : 1;
#define EFLAGS_READ_AS_1_BIT                                         1
#define EFLAGS_READ_AS_1_FLAG                                        0x02
#define EFLAGS_READ_AS_1_MASK                                        0x01
#define EFLAGS_READ_AS_1(_)                                          (((_) >> 1) & 0x01)

        /**
         * @brief Parity flag
         *
         * [Bit 2] Set if the least-significant byte of the result contains an even number of 1 bits; cleared otherwise.
         */
        UINT32_t parity_flag : 1;
#define EFLAGS_PARITY_FLAG_BIT                                       2
#define EFLAGS_PARITY_FLAG_FLAG                                      0x04
#define EFLAGS_PARITY_FLAG_MASK                                      0x01
#define EFLAGS_PARITY_FLAG(_)                                        (((_) >> 2) & 0x01)
        UINT32_t reserved1 : 1;

        /**
         * @brief Auxiliary Carry flag
         *
         * [Bit 4] Set if an arithmetic operation generates a carry or a borrow out of bit 3 of the result; cleared otherwise. This
         * flag is used in binary-coded decimal (BCD) arithmetic.
         */
        UINT32_t auxiliary_carry_flag : 1;
#define EFLAGS_AUXILIARY_CARRY_FLAG_BIT                              4
#define EFLAGS_AUXILIARY_CARRY_FLAG_FLAG                             0x10
#define EFLAGS_AUXILIARY_CARRY_FLAG_MASK                             0x01
#define EFLAGS_AUXILIARY_CARRY_FLAG(_)                               (((_) >> 4) & 0x01)
        UINT32_t reserved2 : 1;

        /**
         * @brief Zero flag
         *
         * [Bit 6] Set if the result is zero; cleared otherwise.
         */
        UINT32_t zero_flag : 1;
#define EFLAGS_ZERO_FLAG_BIT                                         6
#define EFLAGS_ZERO_FLAG_FLAG                                        0x40
#define EFLAGS_ZERO_FLAG_MASK                                        0x01
#define EFLAGS_ZERO_FLAG(_)                                          (((_) >> 6) & 0x01)

        /**
         * @brief Sign flag
         *
         * [Bit 7] Set equal to the most-significant bit of the result, which is the sign bit of a signed integer. (0 indicates a
         * positive value and 1 indicates a negative value.)
         */
        UINT32_t sign_flag : 1;
#define EFLAGS_SIGN_FLAG_BIT                                         7
#define EFLAGS_SIGN_FLAG_FLAG                                        0x80
#define EFLAGS_SIGN_FLAG_MASK                                        0x01
#define EFLAGS_SIGN_FLAG(_)                                          (((_) >> 7) & 0x01)

        /**
         * @brief Trap flag
         *
         * [Bit 8] Set to enable single-step mode for debugging; clear to disable single-step mode.
         */
        UINT32_t trap_flag : 1;
#define EFLAGS_TRAP_FLAG_BIT                                         8
#define EFLAGS_TRAP_FLAG_FLAG                                        0x100
#define EFLAGS_TRAP_FLAG_MASK                                        0x01
#define EFLAGS_TRAP_FLAG(_)                                          (((_) >> 8) & 0x01)

        /**
         * @brief Interrupt enable flag
         *
         * [Bit 9] Controls the response of the processor to maskable interrupt requests. Set to respond to maskable interrupts;
         * cleared to inhibit maskable interrupts.
         */
        UINT32_t interrupt_enable_flag : 1;
#define EFLAGS_INTERRUPT_ENABLE_FLAG_BIT                             9
#define EFLAGS_INTERRUPT_ENABLE_FLAG_FLAG                            0x200
#define EFLAGS_INTERRUPT_ENABLE_FLAG_MASK                            0x01
#define EFLAGS_INTERRUPT_ENABLE_FLAG(_)                              (((_) >> 9) & 0x01)

        /**
         * @brief Direction flag
         *
         * [Bit 10] Controls string instructions (MOVS, CMPS, SCAS, LODS, and STOS). Setting the DF flag causes the string
         * instructions to auto-decrement (to process strings from high addresses to low addresses). Clearing the DF flag causes
         * the string instructions to auto-increment (process strings from low addresses to high addresses).
         */
        UINT32_t direction_flag : 1;
#define EFLAGS_DIRECTION_FLAG_BIT                                    10
#define EFLAGS_DIRECTION_FLAG_FLAG                                   0x400
#define EFLAGS_DIRECTION_FLAG_MASK                                   0x01
#define EFLAGS_DIRECTION_FLAG(_)                                     (((_) >> 10) & 0x01)

        /**
         * @brief Overflow flag
         *
         * [Bit 11] Set if the integer result is too large a positive number or too small a negative number (excluding the
         * sign-bit) to fit in the destination operand; cleared otherwise. This flag indicates an overflow condition for
         * signed-integer (two's complement) arithmetic.
         */
        UINT32_t overflow_flag : 1;
#define EFLAGS_OVERFLOW_FLAG_BIT                                     11
#define EFLAGS_OVERFLOW_FLAG_FLAG                                    0x800
#define EFLAGS_OVERFLOW_FLAG_MASK                                    0x01
#define EFLAGS_OVERFLOW_FLAG(_)                                      (((_) >> 11) & 0x01)

        /**
         * @brief I/O privilege level field
         *
         * [Bits 13:12] Indicates the I/O privilege level of the currently running program or task. The current privilege level
         * (CPL) of the currently running program or task must be less than or equal to the I/O privilege level to access the I/O
         * address space. The POPF and IRET instructions can modify this field only when operating at a CPL of 0.
         */
        UINT32_t io_privilege_level : 2;
#define EFLAGS_IO_PRIVILEGE_LEVEL_BIT                                12
#define EFLAGS_IO_PRIVILEGE_LEVEL_FLAG                               0x3000
#define EFLAGS_IO_PRIVILEGE_LEVEL_MASK                               0x03
#define EFLAGS_IO_PRIVILEGE_LEVEL(_)                                 (((_) >> 12) & 0x03)

        /**
         * @brief Nested task flag
         *
         * [Bit 14] Controls the chaining of interrupted and called tasks. Set when the current task is linked to the previously
         * executed task; cleared when the current task is not linked to another task.
         */
        UINT32_t nested_task_flag : 1;
#define EFLAGS_NESTED_TASK_FLAG_BIT                                  14
#define EFLAGS_NESTED_TASK_FLAG_FLAG                                 0x4000
#define EFLAGS_NESTED_TASK_FLAG_MASK                                 0x01
#define EFLAGS_NESTED_TASK_FLAG(_)                                   (((_) >> 14) & 0x01)
        UINT32_t reserved3 : 1;

        /**
         * @brief Resume flag
         *
         * [Bit 16] Controls the processor's response to debug exceptions.
         */
        UINT32_t resume_flag : 1;
#define EFLAGS_RESUME_FLAG_BIT                                       16
#define EFLAGS_RESUME_FLAG_FLAG                                      0x10000
#define EFLAGS_RESUME_FLAG_MASK                                      0x01
#define EFLAGS_RESUME_FLAG(_)                                        (((_) >> 16) & 0x01)

        /**
         * @brief Virtual-8086 mode flag
         *
         * [Bit 17] Set to enable virtual-8086 mode; clear to return to protected mode without virtual-8086 mode semantics.
         */
        UINT32_t virtual_8086_mode_flag : 1;
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_BIT                            17
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_FLAG                           0x20000
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_MASK                           0x01
#define EFLAGS_VIRTUAL_8086_MODE_FLAG(_)                             (((_) >> 17) & 0x01)

        /**
         * @brief Alignment check (or access control) flag
         *
         * [Bit 18] If the AM bit is set in the CR0 register, alignment checking of user-mode data accesses is enabled if and only
         * if this flag is 1. If the SMAP bit is set in the CR4 register, explicit supervisor-mode data accesses to user-mode pages
         * are allowed if and only if this bit is 1.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        UINT32_t alignment_check_flag : 1;
#define EFLAGS_ALIGNMENT_CHECK_FLAG_BIT                              18
#define EFLAGS_ALIGNMENT_CHECK_FLAG_FLAG                             0x40000
#define EFLAGS_ALIGNMENT_CHECK_FLAG_MASK                             0x01
#define EFLAGS_ALIGNMENT_CHECK_FLAG(_)                               (((_) >> 18) & 0x01)

        /**
         * @brief Virtual interrupt flag
         *
         * [Bit 19] Virtual image of the IF flag. Used in conjunction with the VIP flag. (To use this flag and the VIP flag the
         * virtual mode extensions are enabled by setting the VME flag in control register CR4.)
         */
        UINT32_t virtual_interrupt_flag : 1;
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_BIT                            19
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_FLAG                           0x80000
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_MASK                           0x01
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG(_)                             (((_) >> 19) & 0x01)

        /**
         * @brief Virtual interrupt pending flag
         *
         * [Bit 20] Set to indicate that an interrupt is pending; clear when no interrupt is pending. (Software sets and clears
         * this flag; the processor only reads it.) Used in conjunction with the VIF flag.
         */
        UINT32_t virtual_interrupt_pending_flag : 1;
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_BIT                    20
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_FLAG                   0x100000
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_MASK                   0x01
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG(_)                     (((_) >> 20) & 0x01)

        /**
         * @brief Identification flag
         *
         * [Bit 21] The ability of a program to set or clear this flag indicates support for the CPUID instruction.
         */
        UINT32_t identification_flag : 1;
#define EFLAGS_IDENTIFICATION_FLAG_BIT                               21
#define EFLAGS_IDENTIFICATION_FLAG_FLAG                              0x200000
#define EFLAGS_IDENTIFICATION_FLAG_MASK                              0x01
#define EFLAGS_IDENTIFICATION_FLAG(_)                                (((_) >> 21) & 0x01)
        UINT32_t reserved4 : 10;
    };

    UINT32_t flags;
} eflags;

/**
 * The 64-bit RFLAGS register contains a group of status flags, a control flag, and a group of system flags in 64-bit mode.
 * The upper 32 bits of RFLAGS register is reserved. The lower 32 bits of RFLAGS is the same as EFLAGS.
 *
 * @see EFLAGS
 * @see Vol1[3.4.3.4(RFLAGS Register in 64-Bit Mode)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * @brief Carry flag
         *
         * [Bit 0] See the description in EFLAGS.
         */
        UINT64_t carry_flag : 1;
#define RFLAGS_CARRY_FLAG_BIT                                        0
#define RFLAGS_CARRY_FLAG_FLAG                                       0x01
#define RFLAGS_CARRY_FLAG_MASK                                       0x01
#define RFLAGS_CARRY_FLAG(_)                                         (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Reserved - always 1
         */
        UINT64_t read_as_1 : 1;
#define RFLAGS_READ_AS_1_BIT                                         1
#define RFLAGS_READ_AS_1_FLAG                                        0x02
#define RFLAGS_READ_AS_1_MASK                                        0x01
#define RFLAGS_READ_AS_1(_)                                          (((_) >> 1) & 0x01)

        /**
         * @brief Parity flag
         *
         * [Bit 2] See the description in EFLAGS.
         */
        UINT64_t parity_flag : 1;
#define RFLAGS_PARITY_FLAG_BIT                                       2
#define RFLAGS_PARITY_FLAG_FLAG                                      0x04
#define RFLAGS_PARITY_FLAG_MASK                                      0x01
#define RFLAGS_PARITY_FLAG(_)                                        (((_) >> 2) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * @brief Auxiliary Carry flag
         *
         * [Bit 4] See the description in EFLAGS.
         */
        UINT64_t auxiliary_carry_flag : 1;
#define RFLAGS_AUXILIARY_CARRY_FLAG_BIT                              4
#define RFLAGS_AUXILIARY_CARRY_FLAG_FLAG                             0x10
#define RFLAGS_AUXILIARY_CARRY_FLAG_MASK                             0x01
#define RFLAGS_AUXILIARY_CARRY_FLAG(_)                               (((_) >> 4) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * @brief Zero flag
         *
         * [Bit 6] See the description in EFLAGS.
         */
        UINT64_t zero_flag : 1;
#define RFLAGS_ZERO_FLAG_BIT                                         6
#define RFLAGS_ZERO_FLAG_FLAG                                        0x40
#define RFLAGS_ZERO_FLAG_MASK                                        0x01
#define RFLAGS_ZERO_FLAG(_)                                          (((_) >> 6) & 0x01)

        /**
         * @brief Sign flag
         *
         * [Bit 7] See the description in EFLAGS.
         */
        UINT64_t sign_flag : 1;
#define RFLAGS_SIGN_FLAG_BIT                                         7
#define RFLAGS_SIGN_FLAG_FLAG                                        0x80
#define RFLAGS_SIGN_FLAG_MASK                                        0x01
#define RFLAGS_SIGN_FLAG(_)                                          (((_) >> 7) & 0x01)

        /**
         * @brief Trap flag
         *
         * [Bit 8] See the description in EFLAGS.
         */
        UINT64_t trap_flag : 1;
#define RFLAGS_TRAP_FLAG_BIT                                         8
#define RFLAGS_TRAP_FLAG_FLAG                                        0x100
#define RFLAGS_TRAP_FLAG_MASK                                        0x01
#define RFLAGS_TRAP_FLAG(_)                                          (((_) >> 8) & 0x01)

        /**
         * @brief Interrupt enable flag
         *
         * [Bit 9] See the description in EFLAGS.
         */
        UINT64_t interrupt_enable_flag : 1;
#define RFLAGS_INTERRUPT_ENABLE_FLAG_BIT                             9
#define RFLAGS_INTERRUPT_ENABLE_FLAG_FLAG                            0x200
#define RFLAGS_INTERRUPT_ENABLE_FLAG_MASK                            0x01
#define RFLAGS_INTERRUPT_ENABLE_FLAG(_)                              (((_) >> 9) & 0x01)

        /**
         * @brief Direction flag
         *
         * [Bit 10] See the description in EFLAGS.
         */
        UINT64_t direction_flag : 1;
#define RFLAGS_DIRECTION_FLAG_BIT                                    10
#define RFLAGS_DIRECTION_FLAG_FLAG                                   0x400
#define RFLAGS_DIRECTION_FLAG_MASK                                   0x01
#define RFLAGS_DIRECTION_FLAG(_)                                     (((_) >> 10) & 0x01)

        /**
         * @brief Overflow flag
         *
         * [Bit 11] See the description in EFLAGS.
         */
        UINT64_t overflow_flag : 1;
#define RFLAGS_OVERFLOW_FLAG_BIT                                     11
#define RFLAGS_OVERFLOW_FLAG_FLAG                                    0x800
#define RFLAGS_OVERFLOW_FLAG_MASK                                    0x01
#define RFLAGS_OVERFLOW_FLAG(_)                                      (((_) >> 11) & 0x01)

        /**
         * @brief I/O privilege level field
         *
         * [Bits 13:12] See the description in EFLAGS.
         */
        UINT64_t io_privilege_level : 2;
#define RFLAGS_IO_PRIVILEGE_LEVEL_BIT                                12
#define RFLAGS_IO_PRIVILEGE_LEVEL_FLAG                               0x3000
#define RFLAGS_IO_PRIVILEGE_LEVEL_MASK                               0x03
#define RFLAGS_IO_PRIVILEGE_LEVEL(_)                                 (((_) >> 12) & 0x03)

        /**
         * @brief Nested task flag
         *
         * [Bit 14] See the description in EFLAGS.
         */
        UINT64_t nested_task_flag : 1;
#define RFLAGS_NESTED_TASK_FLAG_BIT                                  14
#define RFLAGS_NESTED_TASK_FLAG_FLAG                                 0x4000
#define RFLAGS_NESTED_TASK_FLAG_MASK                                 0x01
#define RFLAGS_NESTED_TASK_FLAG(_)                                   (((_) >> 14) & 0x01)
        UINT64_t reserved3 : 1;

        /**
         * @brief Resume flag
         *
         * [Bit 16] See the description in EFLAGS.
         */
        UINT64_t resume_flag : 1;
#define RFLAGS_RESUME_FLAG_BIT                                       16
#define RFLAGS_RESUME_FLAG_FLAG                                      0x10000
#define RFLAGS_RESUME_FLAG_MASK                                      0x01
#define RFLAGS_RESUME_FLAG(_)                                        (((_) >> 16) & 0x01)

        /**
         * @brief Virtual-8086 mode flag
         *
         * [Bit 17] See the description in EFLAGS.
         */
        UINT64_t virtual_8086_mode_flag : 1;
#define RFLAGS_VIRTUAL_8086_MODE_FLAG_BIT                            17
#define RFLAGS_VIRTUAL_8086_MODE_FLAG_FLAG                           0x20000
#define RFLAGS_VIRTUAL_8086_MODE_FLAG_MASK                           0x01
#define RFLAGS_VIRTUAL_8086_MODE_FLAG(_)                             (((_) >> 17) & 0x01)

        /**
         * @brief Alignment check (or access control) flag
         *
         * [Bit 18] See the description in EFLAGS.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        UINT64_t alignment_check_flag : 1;
#define RFLAGS_ALIGNMENT_CHECK_FLAG_BIT                              18
#define RFLAGS_ALIGNMENT_CHECK_FLAG_FLAG                             0x40000
#define RFLAGS_ALIGNMENT_CHECK_FLAG_MASK                             0x01
#define RFLAGS_ALIGNMENT_CHECK_FLAG(_)                               (((_) >> 18) & 0x01)

        /**
         * @brief Virtual interrupt flag
         *
         * [Bit 19] See the description in EFLAGS.
         */
        UINT64_t virtual_interrupt_flag : 1;
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG_BIT                            19
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG_FLAG                           0x80000
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG_MASK                           0x01
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG(_)                             (((_) >> 19) & 0x01)

        /**
         * @brief Virtual interrupt pending flag
         *
         * [Bit 20] See the description in EFLAGS.
         */
        UINT64_t virtual_interrupt_pending_flag : 1;
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_BIT                    20
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_FLAG                   0x100000
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_MASK                   0x01
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG(_)                     (((_) >> 20) & 0x01)

        /**
         * @brief Identification flag
         *
         * [Bit 21] See the description in EFLAGS.
         */
        UINT64_t identification_flag : 1;
#define RFLAGS_IDENTIFICATION_FLAG_BIT                               21
#define RFLAGS_IDENTIFICATION_FLAG_FLAG                              0x200000
#define RFLAGS_IDENTIFICATION_FLAG_MASK                              0x01
#define RFLAGS_IDENTIFICATION_FLAG(_)                                (((_) >> 21) & 0x01)
        UINT64_t reserved4 : 42;
    };

    UINT64_t flags;
} rflags;

/**
 * @defgroup exceptions \
 *           Exceptions
 * @{
 */
 /**
  * @brief Exceptions that can occur when the instruction is executed in protected mode.
  *        Each exception is given a mnemonic that consists of a pound sign (\#) followed by two letters and an optional error code
  *        in parentheses. For example, \#GP(0) denotes a general protection exception with an error code of 0
  *
  * @see Vol2A[3.1.1.13(Protected Mode Exceptions Section)] (reference)
  * @see Vol3A[6.3.1(External Interrupts)] (reference)
  */
typedef enum
{
    /**
     * #DE - Divide Error.
     * Source: DIV and IDIV instructions.
     * Error Code: No.
     */
    divide_error = 0x00000000,

    /**
     * #DB - Debug.
     * Source: Any code or data reference.
     * Error Code: No.
     */
     debug = 0x00000001,

     /**
      * Nonmaskable Interrupt.
      * Source: Generated externally by asserting the processor's NMI pin or
      *         through an NMI request set by the I/O APIC to the local APIC.
      * Error Code: No.
      */
      nmi = 0x00000002,

      /**
       * #BP - Breakpoint.
       * Source: INT3 instruction.
       * Error Code: No.
       */
       breakpoint = 0x00000003,

       /**
        * #OF - Overflow.
        * Source: INTO instruction.
        * Error Code: No.
        */
        overflow = 0x00000004,

        /**
         * #BR - BOUND Range Exceeded.
         * Source: BOUND instruction.
         * Error Code: No.
         */
         bound_range_exceeded = 0x00000005,

         /**
          * #UD - Invalid Opcode (Undefined Opcode).
          * Source: UD instruction or reserved opcode.
          * Error Code: No.
          */
          invalid_opcode = 0x00000006,

          /**
           * #NM - Device Not Available (No Math Coprocessor).
           * Source: Floating-point or WAIT/FWAIT instruction.
           * Error Code: No.
           */
           device_not_available = 0x00000007,

           /**
            * #DF - Double Fault.
            * Source: Any instruction that can generate an exception, an NMI, or an INTR.
            * Error Code: Yes (zero).
            */
            double_fault = 0x00000008,

            /**
             * #\## - Coprocessor Segment Overrun (reserved).
             * Source: Floating-point instruction.
             * Error Code: No.
             *
             * @note Processors after the Intel386 processor do not generate this exception.
             */
             coprocessor_segment_overrun = 0x00000009,

             /**
              * #TS - Invalid TSS.
              * Source: Task switch or TSS access.
              * Error Code: Yes.
              */
              invalid_tss = 0x0000000A,

              /**
               * #NP - Segment Not Present.
               * Source: Loading segment registers or accessing system segments.
               * Error Code: Yes.
               */
               segment_not_present = 0x0000000B,

               /**
                * #SS - Stack Segment Fault.
                * Source: Stack operations and SS register loads.
                * Error Code: Yes.
                */
                stack_segment_fault = 0x0000000C,

                /**
                 * #GP - General Protection.
                 * Source: Any memory reference and other protection checks.
                 * Error Code: Yes.
                 */
                 general_protection = 0x0000000D,

                 /**
                  * #PF - Page Fault.
                  * Source: Any memory reference.
                  * Error Code: Yes.
                  */
                  page_fault = 0x0000000E,

                  /**
                   * #MF - Floating-Point Error (Math Fault).
                   * Source: Floating-point or WAIT/FWAIT instruction.
                   * Error Code: No.
                   */
                   x87_floating_point_error = 0x00000010,

                   /**
                    * #AC - Alignment Check.
                    * Source: Any data reference in memory.
                    * Error Code: Yes.
                    */
                    alignment_check = 0x00000011,

                    /**
                     * #MC - Machine Check.
                     * Source: Model dependent machine check errors.
                     * Error Code: No.
                     */
                     machine_check = 0x00000012,

                     /**
                      * #XM - SIMD Floating-Point Numeric Error.
                      * Source: SSE/SSE2/SSE3 floating-point instructions.
                      * Error Code: No.
                      */
                      simd_floating_point_error = 0x00000013,

                      /**
                       * #VE - Virtualization Exception.
                       * Source: EPT violations.
                       * Error Code: No.
                       */
                       virtualization_exception = 0x00000014,
} exception_vector;

/**
 * @brief When an exception condition is related to a specific segment selector or IDT vector, the processor pushes an
 *        error code onto the stack of the exception handler (whether it is a procedure or task). The error code resembles a
 *        segment selector; however, instead of a TI flag and RPL field, the error code contains 3 different flags
 *
 * @see Vol3A[6.13(ERROR CODE)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] When set, indicates that the exception occurred during delivery of an event external to the program, such as an
         * interrupt or an earlier exception. The bit is cleared if the exception occurred during delivery of a software interrupt
         * (INT n, INT3, or INTO).
         */
        UINT32_t external_event : 1;
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_BIT                      0
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_FLAG                     0x01
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_MASK                     0x01
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT(_)                       (((_) >> 0) & 0x01)

        /**
         * [Bit 1] When set, indicates that the index portion of the error code refers to a gate descriptor in the IDT; when clear,
         * indicates that the index refers to a descriptor in the GDT or the current LDT.
         */
        UINT32_t descriptor_location : 1;
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_BIT                 1
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_FLAG                0x02
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_MASK                0x01
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION(_)                  (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Only used when the IDT flag is clear. When set, the TI flag indicates that the index portion of the error code
         * refers to a segment or gate descriptor in the LDT; when clear, it indicates that the index refers to a descriptor in the
         * current GDT.
         */
        UINT32_t gdt_ldt : 1;
#define EXCEPTION_ERROR_CODE_GDT_LDT_BIT                             2
#define EXCEPTION_ERROR_CODE_GDT_LDT_FLAG                            0x04
#define EXCEPTION_ERROR_CODE_GDT_LDT_MASK                            0x01
#define EXCEPTION_ERROR_CODE_GDT_LDT(_)                              (((_) >> 2) & 0x01)

        /**
         * [Bits 15:3] The segment selector index field provides an index into the IDT, GDT, or current LDT to the segment or gate
         * selector being referenced by the error code. In some cases the error code is null (all bits are clear except possibly
         * EXT). A null error code indicates that the error was not caused by a reference to a specific segment or that a null
         * segment selector was referenced in an operation.
         *
         * @note The format of the error code is different for page-fault exceptions (#PF).
         */
        UINT32_t index : 13;
#define EXCEPTION_ERROR_CODE_INDEX_BIT                               3
#define EXCEPTION_ERROR_CODE_INDEX_FLAG                              0xFFF8
#define EXCEPTION_ERROR_CODE_INDEX_MASK                              0x1FFF
#define EXCEPTION_ERROR_CODE_INDEX(_)                                (((_) >> 3) & 0x1FFF)
        UINT32_t reserved1 : 16;
    };

    UINT32_t flags;
} exception_error_code;

/**
 * @brief Page fault exception
 *
 * @see Vol3A[4.7(PAGE-FAULT EXCEPTIONS)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] This flag is 0 if there is no translation for the linear address because the P flag was 0 in one of the
         * pagingstructure entries used to translate that address.
         */
        UINT32_t present : 1;
#define PAGE_FAULT_EXCEPTION_PRESENT_BIT                             0
#define PAGE_FAULT_EXCEPTION_PRESENT_FLAG                            0x01
#define PAGE_FAULT_EXCEPTION_PRESENT_MASK                            0x01
#define PAGE_FAULT_EXCEPTION_PRESENT(_)                              (((_) >> 0) & 0x01)

        /**
         * [Bit 1] If the access causing the page-fault exception was a write, this flag is 1; otherwise, it is 0. This flag
         * describes the access causing the page-fault exception, not the access rights specified by paging.
         */
        UINT32_t write : 1;
#define PAGE_FAULT_EXCEPTION_WRITE_BIT                               1
#define PAGE_FAULT_EXCEPTION_WRITE_FLAG                              0x02
#define PAGE_FAULT_EXCEPTION_WRITE_MASK                              0x01
#define PAGE_FAULT_EXCEPTION_WRITE(_)                                (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If a user-mode access caused the page-fault exception, this flag is 1; it is 0 if a supervisor-mode access did
         * so. This flag describes the access causing the page-fault exception, not the access rights specified by paging.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        UINT32_t user_mode_access : 1;
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_BIT                    2
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_FLAG                   0x04
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_MASK                   0x01
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS(_)                     (((_) >> 2) & 0x01)

        /**
         * [Bit 3] This flag is 1 if there is no translation for the linear address because a reserved bit was set in one of the
         * pagingstructure entries used to translate that address. (Because reserved bits are not checked in a paging-structure
         * entry whose P flag is 0, bit 3 of the error code can be set only if bit 0 is also set). Bits reserved in the
         * paging-structure entries are reserved for future functionality. Software developers should be aware that such bits may
         * be used in the future and that a paging-structure entry that causes a page-fault exception on one processor might not do
         * so in the future.
         */
        UINT32_t reserved_bit_violation : 1;
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_BIT              3
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_FLAG             0x08
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_MASK             0x01
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION(_)               (((_) >> 3) & 0x01)

        /**
         * [Bit 4] This flag is 1 if (1) the access causing the page-fault exception was an instruction fetch; and (2) either (a)
         * CR4.SMEP = 1; or (b) both (i) CR4.PAE = 1 (either PAE paging or 4-level paging is in use); and (ii) IA32_EFER.NXE = 1.
         * Otherwise, the flag is 0. This flag describes the access causing the page-fault exception, not the access rights
         * specified by paging.
         */
        UINT32_t execute : 1;
#define PAGE_FAULT_EXCEPTION_EXECUTE_BIT                             4
#define PAGE_FAULT_EXCEPTION_EXECUTE_FLAG                            0x10
#define PAGE_FAULT_EXCEPTION_EXECUTE_MASK                            0x01
#define PAGE_FAULT_EXCEPTION_EXECUTE(_)                              (((_) >> 4) & 0x01)

        /**
         * [Bit 5] This flag is 1 if (1) IA32_EFER.LMA = CR4.PKE = 1; (2) the access causing the page-fault exception was a data
         * access; (3) the linear address was a user-mode address with protection key i; and (5) the PKRU register is such that
         * either (a) ADi = 1; or (b) the following all hold: (i) WDi = 1; (ii) the access is a write access; and (iii) either
         * CR0.WP = 1 or the access causing the page-fault exception was a user-mode access.
         *
         * @see Vol3A[4.6.2(Protection Keys)]
         */
        UINT32_t protection_key_violation : 1;
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_BIT            5
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_FLAG           0x20
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_MASK           0x01
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION(_)             (((_) >> 5) & 0x01)
        UINT32_t reserved1 : 9;

        /**
         * [Bit 15] This flag is 1 if the exception is unrelated to paging and resulted from violation of SGX-specific
         * access-control requirements. Because such a violation can occur only if there is no ordinary page fault, this flag is
         * set only if the P flag (bit 0) is 1 and the RSVD flag (bit 3) and the PK flag (bit 5) are both 0.
         */
        UINT32_t sgx : 1;
#define PAGE_FAULT_EXCEPTION_SGX_BIT                                 15
#define PAGE_FAULT_EXCEPTION_SGX_FLAG                                0x8000
#define PAGE_FAULT_EXCEPTION_SGX_MASK                                0x01
#define PAGE_FAULT_EXCEPTION_SGX(_)                                  (((_) >> 15) & 0x01)
        UINT32_t reserved2 : 16;
    };

    UINT32_t flags;
} page_fault_exception;

/**
 * @}
 */

 /**
  * @defgroup memory_type \
  *           Memory caching type
  *
  * The processor allows any area of system memory to be cached in the L1, L2, and L3 caches. In individual pages or regions
  * of system memory, it allows the type of caching (also called memory type) to be specified.
  *
  * @see Vol3A[11.11(MEMORY TYPE RANGE REGISTERS (MTRRS))]
  * @see Vol3A[11.5(CACHE CONTROL)]
  * @see Vol3A[11.3(METHODS OF CACHING AVAILABLE)] (reference)
  * @{
  */
  /**
   * @brief Strong Uncacheable (UC)
   *
   * System memory locations are not cached. All reads and writes appear on the system bus and are executed in program order
   * without reordering. No speculative memory accesses, pagetable walks, or prefetches of speculated branch targets are
   * made. This type of cache-control is useful for memory-mapped I/O devices. When used with normal RAM, it greatly reduces
   * processor performance.
   */
#define MEMORY_TYPE_UNCACHEABLE                                      0x00000000

   /**
    * @brief Write Combining (WC)
    *
    * System memory locations are not cached (as with uncacheable memory) and coherency is not enforced by the processor's bus
    * coherency protocol. Speculative reads are allowed. Writes may be delayed and combined in the write combining buffer (WC
    * buffer) to reduce memory accesses. If the WC buffer is partially filled, the writes may be delayed until the next
    * occurrence of a serializing event; such as, an SFENCE or MFENCE instruction, CPUID execution, a read or write to
    * uncached memory, an interrupt occurrence, or a LOCK instruction execution. This type of cache-control is appropriate for
    * video frame buffers, where the order of writes is unimportant as long as the writes update memory so they can be seen on
    * the graphics display. This memory type is available in the Pentium Pro and Pentium II processors by programming the
    * MTRRs; or in processor families starting from the Pentium III processors by programming the MTRRs or by selecting it
    * through the PAT.
    *
    * @see Vol3A[11.3.1(Buffering of Write Combining Memory Locations)]
    */
#define MEMORY_TYPE_WRITE_COMBINING                                  0x00000001

    /**
     * @brief Write-through (WT)
     *
     * Writes and reads to and from system memory are cached. Reads come from cache lines on cache hits; read misses cause
     * cache fills. Speculative reads are allowed. All writes are written to a cache line (when possible) and through to system
     * memory. When writing through to memory, invalid cache lines are never filled, and valid cache lines are either filled or
     * invalidated. Write combining is allowed. This type of cache-control is appropriate for frame buffers or when there are
     * devices on the system bus that access system memory, but do not perform snooping of memory accesses. It enforces
     * coherency between caches in the processors and system memory.
     */
#define MEMORY_TYPE_WRITE_THROUGH                                    0x00000004

     /**
      * @brief Write protected (WP)
      *
      * Reads come from cache lines when possible, and read misses cause cache fills. Writes are propagated to the system bus
      * and cause corresponding cache lines on all processors on the bus to be invalidated. Speculative reads are allowed. This
      * memory type is available in processor families starting from the P6 family processors by programming the MTRRs.
      */
#define MEMORY_TYPE_WRITE_PROTECTED                                  0x00000005

      /**
       * @brief Write-back (WB)
       *
       * Writes and reads to and from system memory are cached. Reads come from cache lines on cache hits; read misses cause
       * cache fills. Speculative reads are allowed. Write misses cause cache line fills (in processor families starting with the
       * P6 family processors), and writes are performed entirely in the cache, when possible. Write combining is allowed. The
       * write-back memory type reduces bus traffic by eliminating many unnecessary writes to system memory. Writes to a cache
       * line are not immediately forwarded to system memory; instead, they are accumulated in the cache. The modified cache
       * lines are written to system memory later, when a write-back operation is performed. Write-back operations are triggered
       * when cache lines need to be deallocated, such as when new cache lines are being allocated in a cache that is already
       * full. They also are triggered by the mechanisms used to maintain cache consistency. This type of cache-control provides
       * the best performance, but it requires that all devices that access system memory on the system bus be able to snoop
       * memory accesses to insure system memory and cache coherency.
       */
#define MEMORY_TYPE_WRITE_BACK                                       0x00000006

       /**
        * @brief Uncacheable (UC-)
        *
        * Has same characteristics as the strong uncacheable (UC) memory type, except that this memory type can be overridden by
        * programming the MTRRs for the WC memory type. This memory type is available in processor families starting from the
        * Pentium III processors and can only be selected through the PAT.
        */
#define MEMORY_TYPE_UNCACHEABLE_MINUS                                0x00000007
#define MEMORY_TYPE_INVALID                                          0x000000FF
        /**
         * @}
         */

         /**
          * @}
          */


```

`PayLoad (AMD)/mm.cpp`:

```cpp
#include "mm.h"
#include "debug.h"

auto mm::map_guest_phys(guest_phys_t phys_addr, map_type_t map_type) -> u64
{
	//const auto host_phys =
		//translate_guest_physical(
			//phys_addr, map_type);

	//if (!host_phys)
		//return {};

	return map_page(phys_addr, map_type);
}

auto mm::map_guest_virt(guest_phys_t dirbase, guest_virt_t virt_addr, map_type_t map_type) -> u64
{
	const auto guest_phys = 
		translate_guest_virtual(
			dirbase, virt_addr, map_type);

	if (!guest_phys)
		return {};

	return map_guest_phys(guest_phys, map_type);
}

auto mm::map_page(host_phys_t phys_addr, map_type_t map_type) -> u64
{
	cpuid_eax_01 cpuid_value;
	__cpuid((int*)&cpuid_value, 1);

	mm::pt[(cpuid_value
		.cpuid_additional_information
		.initial_apic_id * 2)
			+ (unsigned)map_type].pfn = phys_addr >> 12;

	__invlpg(reinterpret_cast<void*>(
		get_map_virt(virt_addr_t{ phys_addr }.offset_4kb, map_type)));

	return get_map_virt(virt_addr_t{ phys_addr }.offset_4kb, map_type);
}

auto mm::get_map_virt(u16 offset, map_type_t map_type) -> u64
{
	cpuid_eax_01 cpuid_value;
	__cpuid((int*)&cpuid_value, 1);
	virt_addr_t virt_addr{ MAPPING_ADDRESS_BASE };

	virt_addr.pt_index = (cpuid_value
		.cpuid_additional_information
		.initial_apic_id * 2)
			+ (unsigned)map_type;

	return virt_addr.value + offset;
}

auto mm::translate(host_virt_t host_virt) -> u64
{
	virt_addr_t virt_addr{ host_virt };
	virt_addr_t cursor{ (u64)hyperv_pml4 };

	if (!reinterpret_cast<ppml4e>(cursor.value)[virt_addr.pml4_index].present)
		return {};

	cursor.pt_index = virt_addr.pml4_index;
	if (!reinterpret_cast<ppdpte>(cursor.value)[virt_addr.pdpt_index].present)
		return {};

	// handle 1gb large page...
	if (reinterpret_cast<ppdpte>(cursor.value)[virt_addr.pdpt_index].large_page)
		return (reinterpret_cast<ppdpte>(cursor.value)
			[virt_addr.pdpt_index].pfn << 30) + virt_addr.offset_1gb;

	cursor.pd_index = virt_addr.pml4_index;
	cursor.pt_index = virt_addr.pdpt_index;
	if (!reinterpret_cast<ppde>(cursor.value)[virt_addr.pd_index].present)
		return {};

	// handle 2mb large page...
	if (reinterpret_cast<ppde>(cursor.value)[virt_addr.pd_index].large_page)
		return (reinterpret_cast<ppde>(cursor.value)
			[virt_addr.pd_index].pfn << 21) + virt_addr.offset_2mb;

	cursor.pdpt_index = virt_addr.pml4_index;
	cursor.pd_index = virt_addr.pdpt_index;
	cursor.pt_index = virt_addr.pd_index;
	if (!reinterpret_cast<ppte>(cursor.value)[virt_addr.pt_index].present)
		return {};

	return (reinterpret_cast<ppte>(cursor.value)
		[virt_addr.pt_index].pfn << 12) + virt_addr.offset_4kb;
}

auto mm::translate_guest_virtual(guest_phys_t dirbase, guest_virt_t guest_virt, map_type_t map_type) -> u64
{
	virt_addr_t virt_addr{ guest_virt };

	const auto pml4 =
		reinterpret_cast<pml4e*>(
			map_guest_phys(dirbase, map_type));

	if (!pml4 || !pml4[virt_addr.pml4_index].present)
		return {};

	const auto pdpt =
		reinterpret_cast<pdpte*>(map_guest_phys(
			pml4[virt_addr.pml4_index].pfn << 12, map_type));

	if (!pdpt || !pdpt[virt_addr.pdpt_index].present)
		return {};

	// handle 1gb pages...
	if (pdpt[virt_addr.pdpt_index].large_page)
		return (pdpt[virt_addr.pdpt_index].pfn << 12) + virt_addr.offset_1gb;

	const auto pd =
		reinterpret_cast<pde*>(map_guest_phys(
			pdpt[virt_addr.pdpt_index].pfn << 12, map_type));

	if (!pd || !pd[virt_addr.pd_index].present)
		return {};

	// handle 2mb pages...
	if (pd[virt_addr.pd_index].large_page)
		return (pd[virt_addr.pd_index].pfn << 12) + virt_addr.offset_2mb;

	const auto pt =
		reinterpret_cast<pte*>(map_guest_phys(
			pd[virt_addr.pd_index].pfn << 12, map_type));

	if (!pt || !pt[virt_addr.pt_index].present)
		return {};

	return (pt[virt_addr.pt_index].pfn << 12) + virt_addr.offset_4kb;
}

auto mm::translate_guest_physical(guest_phys_t phys_addr, map_type_t map_type) -> u64
{
	phys_addr_t guest_phys{ phys_addr };
	const auto vmcb = svm::get_vmcb();

	const auto npt_pml4 = 
		reinterpret_cast<pnpt_pml4e>(
			map_page(vmcb->ncr3, map_type));

	if (!npt_pml4[guest_phys.pml4_index].present)
		return {};

	const auto npt_pdpt = 
		reinterpret_cast<pnpt_pdpte>(
			map_page(npt_pml4[guest_phys.pml4_index].pfn << 12, map_type));

	if (!npt_pdpt[guest_phys.pdpt_index].present)
		return {};

	const auto npt_pd = 
		reinterpret_cast<pnpt_pde>(
			map_page(npt_pdpt[guest_phys.pdpt_index].pfn << 12, map_type));

	if (!npt_pd[guest_phys.pd_index].present)
		return {};

	// handle 2mb pages...
	if (reinterpret_cast<pnpt_pde_2mb>(npt_pd)[guest_phys.pd_index].large_page)
		return (reinterpret_cast<pnpt_pde_2mb>(npt_pd)
			[guest_phys.pd_index].pfn << 21) + guest_phys.offset_2mb;

	const auto npt_pt =
		reinterpret_cast<pnpt_pte>(
			map_page(npt_pd[guest_phys.pd_index].pfn << 12, map_type));

	if (!npt_pt[guest_phys.pt_index].present)
		return {};

	return (npt_pt[guest_phys.pt_index].pfn << 12) + guest_phys.offset_4kb;
}

auto mm::init() -> svm::vmxroot_error_t
{
	const auto pdpt_phys = 
		translate(reinterpret_cast<u64>(pdpt));

	const auto pd_phys = 
		translate(reinterpret_cast<u64>(pd));

	const auto pt_phys = 
		translate(reinterpret_cast<u64>(pt));

	if (!pdpt_phys || !pd_phys || !pt_phys)
		return svm::vmxroot_error_t::invalid_host_virtual;

	// setup mapping page table entries...
	{
		hyperv_pml4[MAPPING_PML4_IDX].present = true;
		hyperv_pml4[MAPPING_PML4_IDX].pfn = pdpt_phys >> 12;
		hyperv_pml4[MAPPING_PML4_IDX].user_supervisor = false;
		hyperv_pml4[MAPPING_PML4_IDX].writeable = true;

		pdpt[511].present = true;
		pdpt[511].pfn = pd_phys >> 12;
		pdpt[511].user_supervisor = false;
		pdpt[511].rw = true;

		pd[511].present = true;
		pd[511].pfn = pt_phys >> 12;
		pd[511].user_supervisor = false;
		pd[511].rw = true;
	}

	// each core will have its own page it can use to map
	// physical memory into virtual memory :^)
	for (auto idx = 0u; idx < 512; ++idx)
	{
		pt[idx].present = true;
		pt[idx].user_supervisor = false;
		pt[idx].rw = true;
	}

	const auto mapped_pml4 =
		reinterpret_cast<ppml4e>(
			mm::map_page(__readcr3()));

	// check to make sure translate works...
	if (translate((u64)mapped_pml4) != __readcr3())
		return svm::vmxroot_error_t::vmxroot_translate_failure;

	// check to make sure the self ref pml4e is valid...
	if (mapped_pml4[SELF_REF_PML4_IDX].pfn != __readcr3() >> 12)
		return svm::vmxroot_error_t::invalid_self_ref_pml4e;

	// check to make sure the mapping pml4e is valid...
	if (mapped_pml4[MAPPING_PML4_IDX].pfn != pdpt_phys >> 12)
		return svm::vmxroot_error_t::invalid_mapping_pml4e;

	return svm::vmxroot_error_t::error_success;
}

auto mm::read_guest_phys(guest_phys_t dirbase, guest_phys_t guest_phys,
	guest_virt_t guest_virt, u64 size) -> svm::vmxroot_error_t
{
	// handle reading over page boundaries of both src and dest...
	while (size)
	{
		auto dest_current_size = PAGE_4KB - 
			virt_addr_t{ guest_virt }.offset_4kb;

		if (size < dest_current_size)
			dest_current_size = size;

		auto src_current_size = PAGE_4KB - 
			phys_addr_t{ guest_phys }.offset_4kb;

		if (size < src_current_size)
			src_current_size = size;

		auto current_size = 
			min(dest_current_size, src_current_size);

		const auto mapped_dest =
			reinterpret_cast<void*>(
				map_guest_virt(dirbase, guest_virt, map_type_t::map_dest));

		if (!mapped_dest)
			return svm::vmxroot_error_t::invalid_guest_virtual;

		const auto mapped_src =
			reinterpret_cast<void*>(
				map_guest_phys(guest_phys, map_type_t::map_src));

		if (!mapped_src)
			return svm::vmxroot_error_t::invalid_guest_physical;

		memcpy(mapped_dest, mapped_src, current_size);
		guest_phys += current_size;
		guest_virt += current_size;
		size -= current_size;
	}

	return svm::vmxroot_error_t::error_success;
}

auto mm::write_guest_phys(guest_phys_t dirbase, 
	guest_phys_t guest_phys, guest_virt_t guest_virt, u64 size) -> svm::vmxroot_error_t
{
	// handle reading over page boundaries of both src and dest...
	while (size)
	{
		auto dest_current_size = PAGE_4KB -
			virt_addr_t{ guest_virt }.offset_4kb;

		if (size < dest_current_size)
			dest_current_size = size;

		auto src_current_size = PAGE_4KB -
			phys_addr_t{ guest_phys }.offset_4kb;

		if (size < src_current_size)
			src_current_size = size;

		auto current_size =
			min(dest_current_size, src_current_size);

		const auto mapped_src =
			reinterpret_cast<void*>(
				map_guest_virt(dirbase, guest_virt, map_type_t::map_src));

		if (!mapped_src)
			return svm::vmxroot_error_t::invalid_guest_virtual;

		const auto mapped_dest =
			reinterpret_cast<void*>(
				map_guest_phys(guest_phys, map_type_t::map_dest));

		if (!mapped_src)
			return svm::vmxroot_error_t::invalid_guest_physical;

		memcpy(mapped_dest, mapped_src, current_size);
		guest_phys += current_size;
		guest_virt += current_size;
		size -= current_size;
	}

	return svm::vmxroot_error_t::error_success;
}

auto mm::copy_guest_virt(guest_phys_t dirbase_src, guest_virt_t virt_src,
	guest_virt_t dirbase_dest, guest_virt_t virt_dest, u64 size) -> svm::vmxroot_error_t
{
	while (size)
	{
		auto dest_size = PAGE_4KB - virt_addr_t{ virt_dest }.offset_4kb;
		if (size < dest_size)
			dest_size = size;

		auto src_size = PAGE_4KB - virt_addr_t{ virt_src }.offset_4kb;
		if (size < src_size)
			src_size = size;

		const auto mapped_src =
			reinterpret_cast<void*>(
				map_guest_virt(dirbase_src, virt_src, map_type_t::map_src));

		if (!mapped_src)
			return svm::vmxroot_error_t::invalid_guest_virtual;

		const auto mapped_dest =
			reinterpret_cast<void*>(
				map_guest_virt(dirbase_dest, virt_dest, map_type_t::map_dest));

		if (!mapped_dest)
			return svm::vmxroot_error_t::invalid_guest_virtual;

		auto current_size = min(dest_size, src_size);
		memcpy(mapped_dest, mapped_src, current_size);

		virt_src += current_size;
		virt_dest += current_size;
		size -= current_size;
	}

	return svm::vmxroot_error_t::error_success;
}
```

`PayLoad (AMD)/mm.h`:

```h
#pragma once
#include "types.h"

#define SELF_REF_PML4_IDX 510
#define MAPPING_PML4_IDX 100

#define MAPPING_ADDRESS_BASE 0x0000327FFFE00000
#define SELF_REF_PML4 0xFFFFFF7FBFDFE000

#define EPT_LARGE_PDPTE_OFFSET(_) (((u64)(_)) & ((0x1000 * 0x200 * 0x200) - 1))
#define EPT_LARGE_PDE_OFFSET(_) (((u64)(_)) & ((0x1000 * 0x200) - 1))

#pragma section(".pdpt", read, write)
#pragma section(".pd", read, write)
#pragma section(".pt", read, write)

namespace mm
{
    enum class map_type_t
    {
        map_src,
        map_dest
    };

    typedef union _virt_addr_t
    {
        u64 value;
        struct
        {
            u64 offset_4kb : 12;
            u64 pt_index : 9;
            u64 pd_index : 9;
            u64 pdpt_index : 9;
            u64 pml4_index : 9;
            u64 reserved : 16;
        };

        struct
        {
            u64 offset_2mb : 21;
            u64 pd_index : 9;
            u64 pdpt_index : 9;
            u64 pml4_index : 9;
            u64 reserved : 16;
        };

        struct
        {
            u64 offset_1gb : 30;
            u64 pdpt_index : 9;
            u64 pml4_index : 9;
            u64 reserved : 16;
        };

    } virt_addr_t, * pvirt_addr_t;
    using phys_addr_t = virt_addr_t;

    typedef union _pml4e
    {
        u64 value;
        struct
        {
            u64 present : 1;          
            u64 writeable : 1;       
            u64 user_supervisor : 1;   
            u64 page_write_through : 1; 
            u64 page_cache : 1; 
            u64 accessed : 1;         
            u64 ignore_1 : 1;
            u64 page_size : 1;         
            u64 ignore_2 : 4;
            u64 pfn : 36; 
            u64 reserved : 4;
            u64 ignore_3 : 11;
            u64 nx : 1; 
        };
    } pml4e, * ppml4e;

    typedef union _pdpte
    {
        u64 value;
        struct
        {
            u64 present : 1;         
            u64 rw : 1;        
            u64 user_supervisor : 1;   
            u64 page_write_through : 1;
            u64 page_cache : 1; 
            u64 accessed : 1;         
            u64 ignore_1 : 1;
            u64 large_page : 1;        
            u64 ignore_2 : 4;
            u64 pfn : 36; 
            u64 reserved : 4;
            u64 ignore_3 : 11;
            u64 nx : 1; 
        };
    } pdpte, * ppdpte;

    typedef union _pde
    {
        u64 value;
        struct
        {
            u64 present : 1;          
            u64 rw : 1;       
            u64 user_supervisor : 1;  
            u64 page_write_through : 1;
            u64 page_cache : 1; 
            u64 accessed : 1;         
            u64 ignore_1 : 1;
            u64 large_page : 1;
            u64 ignore_2 : 4;
            u64 pfn : 36; 
            u64 reserved : 4;
            u64 ignore_3 : 11;
            u64 nx : 1; 
        };
    } pde, * ppde;

    typedef union _pte
    {
        u64 value;
        struct
        {
            u64 present : 1;          
            u64 rw : 1;       
            u64 user_supervisor : 1;   
            u64 page_write_through : 1;
            u64 page_cache : 1;
            u64 accessed : 1;         
            u64 dirty : 1;            
            u64 access_type : 1;   
            u64 global : 1;           
            u64 ignore_2 : 3;
            u64 pfn : 36;
            u64 reserved : 4;
            u64 ignore_3 : 7;
            u64 pk : 4;  
            u64 nx : 1; 
        };
    } pte, * ppte;

    typedef struct _npt_pml4e
    {
        union
        {
            u64 value;
            struct
            {
                u64 present : 1;
                u64 writeable : 1;
                u64 user : 1;
                u64 write_through : 1;
                u64 cache_disable : 1;
                u64 accessed : 1;
                u64 reserved1 : 3;
                u64 avl : 3;
                u64 pfn : 40;
                u64 reserved2 : 11;
                u64 nx : 1;
            };
        };
    } npt_pml4e, *pnpt_pml4e, npt_pdpte, 
      *pnpt_pdpte, npt_pde, *pnpt_pde;

    typedef struct _npt_pte
    {
        union
        {
            u64 value;
            struct
            {
                u64 present : 1;              
                u64 writeable : 1;            
                u64 user : 1;               
                u64 write_through : 1;       
                u64 cache_disable : 1;        
                u64 accessed : 1;            
                u64 dirty : 1;              
                u64 pat : 1;                
                u64 global : 1;             
                u64 avl : 3;                 
                u64 pfn : 40;   
                u64 reserved : 11;         
                u64 nx : 1;           
            };
        };
    } npt_pte, *pnpt_pte;

    typedef struct _npt_pde_2mb
    {
        union
        {
            u64 value;
            struct
            {
                u64 present : 1;
                u64 writeable : 1;
                u64 user : 1;
                u64 write_through : 1;
                u64 cache_disable : 1;
                u64 accessed : 1;
                u64 dirty : 1;
                u64 large_page : 1;
                u64 global : 1;
                u64 avl : 3;
                u64 pat : 1;
                u64 reserved1 : 8;
                u64 pfn : 31;
                u64 reserved2 : 11;
                u64 nx : 1;
            };
        };
    } npt_pde_2mb, * pnpt_pde_2mb;

    __declspec(allocate(".pdpt")) inline pdpte pdpt[512];
    __declspec(allocate(".pd")) inline pde pd[512];
    __declspec(allocate(".pt")) inline pte pt[512];

    inline const ppml4e hyperv_pml4{ reinterpret_cast<ppml4e>(SELF_REF_PML4) };

    auto init() -> svm::vmxroot_error_t;
    auto map_guest_phys(guest_phys_t phys_addr, map_type_t map_type = map_type_t::map_src) -> u64;
    auto map_guest_virt(guest_phys_t dirbase, guest_virt_t virt_addr, map_type_t map_type = map_type_t::map_src) -> u64;

    auto map_page(host_phys_t phys_addr, map_type_t map_type = map_type_t::map_src) -> u64;
    auto get_map_virt(u16 offset = 0u, map_type_t map_type = map_type_t::map_src) -> u64;

    auto translate(host_virt_t host_virt) -> u64;
    auto translate_guest_physical(guest_phys_t guest_phys, map_type_t map_type = map_type_t::map_src) -> u64;
    auto translate_guest_virtual(guest_phys_t dirbase, guest_virt_t guest_virt, map_type_t map_type = map_type_t::map_src) -> u64;

    auto read_guest_phys(guest_phys_t dirbase, guest_phys_t guest_phys, guest_virt_t guest_virt, u64 size) -> svm::vmxroot_error_t;
    auto write_guest_phys(guest_phys_t dirbase, guest_phys_t guest_phys, guest_virt_t guest_virt, u64 size) -> svm::vmxroot_error_t;
    auto copy_guest_virt(guest_phys_t dirbase_src, guest_virt_t virt_src, guest_virt_t dirbase_dest, guest_virt_t virt_dest, u64 size) ->svm::vmxroot_error_t;
}
```

`PayLoad (AMD)/types.h`:

```h
#pragma once
#include <intrin.h>
#include <xmmintrin.h>
#include <cstddef>
#include <ntstatus.h>
#include <basetsd.h>

#include <Windows.h>
#include <ntstatus.h>
#include "ia32.hpp"

#define VMEXIT_KEY 0xDEADBEEFDEADBEEF
#define PAGE_4KB 0x1000
#define PAGE_2MB PAGE_4KB * 512
#define PAGE_1GB PAGE_2MB * 512

#define PORT_NUM_3 0x3E8
#define DBG_PRINT(arg) \
	__outbytestring(PORT_NUM_3, (unsigned char*)arg, sizeof arg);

#if WINVER == 2004
#define offset_vmcb_base 0x103B0
#define offset_vmcb_link 0x198
#define offset_vmcb 0xE80
#elif WINVER == 1909
#define offset_vmcb_base 0x83B0
#define offset_vmcb_link 0x190
#define offset_vmcb 0xD00
#elif WINVER == 1903
#define offset_vmcb_base 0x83B0
#define offset_vmcb_link 0x190
#define offset_vmcb 0xD00
#elif WINVER == 1809
#define offset_vmcb_base 0x83B0
#define offset_vmcb_link 0x198
#define offset_vmcb 0xD00
#elif WINVER == 1803
#define offset_vmcb_base 0x82F0
#define offset_vmcb_link 0x168
#define offset_vmcb 0xCC0
#elif WINVER == 1709
#define offset_vmcb_base 0x82F0
#define offset_vmcb_link 0x88
#define offset_vmcb 0xC80
#elif WINVER == 1703
#define offset_vmcb_base 0x82F0
#define offset_vmcb_link 0x80
#define offset_vmcb 0xBC0
#elif WINVER == 1607
#define offset_vmcb_base 0x82F0
#define offset_vmcb_link 0x90
#define offset_vmcb 0xBC0
#elif WINVER == 1511
#define offset_vmcb_base 0x82F0
#define offset_vmcb_link 0x90
#define offset_vmcb 0xC40
#elif WINVER == 1507
#define offset_vmcb_base 0x82F0
#define offset_vmcb_link 0x88
#define offset_vmcb 0xBC0
#endif

#define VMEXIT_CR0_READ             0x0000
#define VMEXIT_CR1_READ             0x0001
#define VMEXIT_CR2_READ             0x0002
#define VMEXIT_CR3_READ             0x0003
#define VMEXIT_CR4_READ             0x0004
#define VMEXIT_CR5_READ             0x0005
#define VMEXIT_CR6_READ             0x0006
#define VMEXIT_CR7_READ             0x0007
#define VMEXIT_CR8_READ             0x0008
#define VMEXIT_CR9_READ             0x0009
#define VMEXIT_CR10_READ            0x000a
#define VMEXIT_CR11_READ            0x000b
#define VMEXIT_CR12_READ            0x000c
#define VMEXIT_CR13_READ            0x000d
#define VMEXIT_CR14_READ            0x000e
#define VMEXIT_CR15_READ            0x000f
#define VMEXIT_CR0_WRITE            0x0010
#define VMEXIT_CR1_WRITE            0x0011
#define VMEXIT_CR2_WRITE            0x0012
#define VMEXIT_CR3_WRITE            0x0013
#define VMEXIT_CR4_WRITE            0x0014
#define VMEXIT_CR5_WRITE            0x0015
#define VMEXIT_CR6_WRITE            0x0016
#define VMEXIT_CR7_WRITE            0x0017
#define VMEXIT_CR8_WRITE            0x0018
#define VMEXIT_CR9_WRITE            0x0019
#define VMEXIT_CR10_WRITE           0x001a
#define VMEXIT_CR11_WRITE           0x001b
#define VMEXIT_CR12_WRITE           0x001c
#define VMEXIT_CR13_WRITE           0x001d
#define VMEXIT_CR14_WRITE           0x001e
#define VMEXIT_CR15_WRITE           0x001f
#define VMEXIT_DR0_READ             0x0020
#define VMEXIT_DR1_READ             0x0021
#define VMEXIT_DR2_READ             0x0022
#define VMEXIT_DR3_READ             0x0023
#define VMEXIT_DR4_READ             0x0024
#define VMEXIT_DR5_READ             0x0025
#define VMEXIT_DR6_READ             0x0026
#define VMEXIT_DR7_READ             0x0027
#define VMEXIT_DR8_READ             0x0028
#define VMEXIT_DR9_READ             0x0029
#define VMEXIT_DR10_READ            0x002a
#define VMEXIT_DR11_READ            0x002b
#define VMEXIT_DR12_READ            0x002c
#define VMEXIT_DR13_READ            0x002d
#define VMEXIT_DR14_READ            0x002e
#define VMEXIT_DR15_READ            0x002f
#define VMEXIT_DR0_WRITE            0x0030
#define VMEXIT_DR1_WRITE            0x0031
#define VMEXIT_DR2_WRITE            0x0032
#define VMEXIT_DR3_WRITE            0x0033
#define VMEXIT_DR4_WRITE            0x0034
#define VMEXIT_DR5_WRITE            0x0035
#define VMEXIT_DR6_WRITE            0x0036
#define VMEXIT_DR7_WRITE            0x0037
#define VMEXIT_DR8_WRITE            0x0038
#define VMEXIT_DR9_WRITE            0x0039
#define VMEXIT_DR10_WRITE           0x003a
#define VMEXIT_DR11_WRITE           0x003b
#define VMEXIT_DR12_WRITE           0x003c
#define VMEXIT_DR13_WRITE           0x003d
#define VMEXIT_DR14_WRITE           0x003e
#define VMEXIT_DR15_WRITE           0x003f
#define VMEXIT_EXCEPTION_DE         0x0040
#define VMEXIT_EXCEPTION_DB         0x0041
#define VMEXIT_EXCEPTION_NMI        0x0042
#define VMEXIT_EXCEPTION_BP         0x0043
#define VMEXIT_EXCEPTION_OF         0x0044
#define VMEXIT_EXCEPTION_BR         0x0045
#define VMEXIT_EXCEPTION_UD         0x0046
#define VMEXIT_EXCEPTION_NM         0x0047
#define VMEXIT_EXCEPTION_DF         0x0048
#define VMEXIT_EXCEPTION_09         0x0049
#define VMEXIT_EXCEPTION_TS         0x004a
#define VMEXIT_EXCEPTION_NP         0x004b
#define VMEXIT_EXCEPTION_SS         0x004c
#define VMEXIT_EXCEPTION_GP         0x004d
#define VMEXIT_EXCEPTION_PF         0x004e
#define VMEXIT_EXCEPTION_15         0x004f
#define VMEXIT_EXCEPTION_MF         0x0050
#define VMEXIT_EXCEPTION_AC         0x0051
#define VMEXIT_EXCEPTION_MC         0x0052
#define VMEXIT_EXCEPTION_XF         0x0053
#define VMEXIT_EXCEPTION_20         0x0054
#define VMEXIT_EXCEPTION_21         0x0055
#define VMEXIT_EXCEPTION_22         0x0056
#define VMEXIT_EXCEPTION_23         0x0057
#define VMEXIT_EXCEPTION_24         0x0058
#define VMEXIT_EXCEPTION_25         0x0059
#define VMEXIT_EXCEPTION_26         0x005a
#define VMEXIT_EXCEPTION_27         0x005b
#define VMEXIT_EXCEPTION_28         0x005c
#define VMEXIT_EXCEPTION_VC         0x005d
#define VMEXIT_EXCEPTION_SX         0x005e
#define VMEXIT_EXCEPTION_31         0x005f
#define VMEXIT_INTR                 0x0060
#define VMEXIT_NMI                  0x0061
#define VMEXIT_SMI                  0x0062
#define VMEXIT_INIT                 0x0063
#define VMEXIT_VINTR                0x0064
#define VMEXIT_CR0_SEL_WRITE        0x0065
#define VMEXIT_IDTR_READ            0x0066
#define VMEXIT_GDTR_READ            0x0067
#define VMEXIT_LDTR_READ            0x0068
#define VMEXIT_TR_READ              0x0069
#define VMEXIT_IDTR_WRITE           0x006a
#define VMEXIT_GDTR_WRITE           0x006b
#define VMEXIT_LDTR_WRITE           0x006c
#define VMEXIT_TR_WRITE             0x006d
#define VMEXIT_RDTSC                0x006e
#define VMEXIT_RDPMC                0x006f
#define VMEXIT_PUSHF                0x0070
#define VMEXIT_POPF                 0x0071
#define VMEXIT_CPUID                0x0072
#define VMEXIT_RSM                  0x0073
#define VMEXIT_IRET                 0x0074
#define VMEXIT_SWINT                0x0075
#define VMEXIT_INVD                 0x0076
#define VMEXIT_PAUSE                0x0077
#define VMEXIT_HLT                  0x0078
#define VMEXIT_INVLPG               0x0079
#define VMEXIT_INVLPGA              0x007a
#define VMEXIT_IOIO                 0x007b
#define VMEXIT_MSR                  0x007c
#define VMEXIT_TASK_SWITCH          0x007d
#define VMEXIT_FERR_FREEZE          0x007e
#define VMEXIT_SHUTDOWN             0x007f
#define VMEXIT_VMRUN                0x0080
#define VMEXIT_VMMCALL              0x0081
#define VMEXIT_VMLOAD               0x0082
#define VMEXIT_VMSAVE               0x0083
#define VMEXIT_STGI                 0x0084
#define VMEXIT_CLGI                 0x0085
#define VMEXIT_SKINIT               0x0086
#define VMEXIT_RDTSCP               0x0087
#define VMEXIT_ICEBP                0x0088
#define VMEXIT_WBINVD               0x0089
#define VMEXIT_MONITOR              0x008a
#define VMEXIT_MWAIT                0x008b
#define VMEXIT_MWAIT_CONDITIONAL    0x008c
#define VMEXIT_XSETBV               0x008d
#define VMEXIT_EFER_WRITE_TRAP      0x008f
#define VMEXIT_CR0_WRITE_TRAP       0x0090
#define VMEXIT_CR1_WRITE_TRAP       0x0091
#define VMEXIT_CR2_WRITE_TRAP       0x0092
#define VMEXIT_CR3_WRITE_TRAP       0x0093
#define VMEXIT_CR4_WRITE_TRAP       0x0094
#define VMEXIT_CR5_WRITE_TRAP       0x0095
#define VMEXIT_CR6_WRITE_TRAP       0x0096
#define VMEXIT_CR7_WRITE_TRAP       0x0097
#define VMEXIT_CR8_WRITE_TRAP       0x0098
#define VMEXIT_CR9_WRITE_TRAP       0x0099
#define VMEXIT_CR10_WRITE_TRAP      0x009a
#define VMEXIT_CR11_WRITE_TRAP      0x009b
#define VMEXIT_CR12_WRITE_TRAP      0x009c
#define VMEXIT_CR13_WRITE_TRAP      0x009d
#define VMEXIT_CR14_WRITE_TRAP      0x009e
#define VMEXIT_CR15_WRITE_TRAP      0x009f
#define VMEXIT_NPF                  0x0400
#define AVIC_INCOMPLETE_IPI         0x0401
#define AVIC_NOACCEL                0x0402
#define VMEXIT_VMGEXIT              0x0403
#define VMEXIT_INVALID              -1

using u8 = unsigned char;
using u16 = unsigned short;
using u32 = unsigned int;
using u64 = unsigned long long;
using u128 = __m128;

using guest_virt_t = u64;
using guest_phys_t = u64;
using host_virt_t = u64;
using host_phys_t = u64;

namespace svm
{
	typedef struct __declspec(align(16)) _guest_context
	{
		u8  gap0[8];
		u64 rcx;
		u64 rdx;
		u64 rbx;
		u8  gap20[8];
		u64 rbp;
		u64 rsi;
		u64 rdi;
		u64 r8;
		u64 r9;
		u64 r10;
		u64 r11;
		u64 r12;
		u64 r13;
		u64 r14;
		u64 r15;
		u128 xmm0;
		u128 xmm1;
		u128 xmm2;
		u128 xmm3;
		u128 xmm4;
		u128 xmm5;
		u128 xmm6;
		u128 xmm7;
		u128 xmm8;
		u128 xmm9;
		u128 xmm10;
		u128 xmm11;
		u128 xmm12;
		u128 xmm13;
		u128 xmm14;
		u128 xmm15;
		u8  gap180[8];
		u64 vmcb_physical_address;
	} guest_context, *pguest_context;

	typedef struct __declspec(align(16)) _vcpu_context
	{
		u8 gap0[977];
		u8 byte3D1;
		u8 byte3D2;
		u8 gap3D3[1645];
		guest_context context;
		u8 gapBD0[1];
		u8 byteBD1;
		__declspec(align(16)) u64 dr0;
		u64 dr1;
		u64 dr2;
		u64 dr3;
	} vcpu_context, *pvcpu_context;

	typedef struct __declspec(align(8)) _gs_base_struct
	{
		u8 gap0[64];
		u64* pqword40;
		u8 gap48[66392];
		vcpu_context* pvcpu_context_2;
		u8 gap103A8[8];
		vcpu_context* pvcpu_context;
	} gs_base_struct, *pgs_base_struct;

	typedef struct _vmcb
	{
		u16 interceptcrread;             // +0x000
		u16 interceptcrwrite;            // +0x002
		u16 interceptdrread;             // +0x004
		u16 interceptdrwrite;            // +0x006
		u32 interceptexception;          // +0x008
		u32 interceptmisc1;              // +0x00c
		u32 interceptmisc2;              // +0x010
		u8  reserved1[0x03c - 0x014];    // +0x014
		u16 pausefilterthreshold;        // +0x03c
		u16 pausefiltercount;            // +0x03e
		u64 iopmbasepa;                  // +0x040
		u64 msrpmbasepa;                 // +0x048
		u64 tscoffset;                   // +0x050
		u32 guestasid;                   // +0x058
		u32 tlbcontrol;                  // +0x05c
		u64 vintr;                       // +0x060
		u64 interruptshadow;             // +0x068
		u64 exitcode;                    // +0x070
		u64 exitinfo1;                   // +0x078
		u64 exitinfo2;                   // +0x080
		u64 exitintinfo;                 // +0x088
		u64 npenable;                    // +0x090
		u64 avicapicbar;                 // +0x098
		u64 guestpaofghcb;               // +0x0a0
		u64 eventinj;                    // +0x0a8
		u64 ncr3;                        // +0x0b0
		u64 lbrvirtualizationenable;     // +0x0b8
		u64 vmcbclean;                   // +0x0c0
		u64 nrip;                        // +0x0c8
		u8  numofbytesfetched;           // +0x0d0
		u8  guestinstructionbytes[15];   // +0x0d1
		u64 avicapicbackingpagepointer;  // +0x0e0
		u64 reserved2;                   // +0x0e8
		u64 aviclogicaltablepointer;     // +0x0f0
		u64 avicphysicaltablepointer;    // +0x0f8
		u64 reserved3;                   // +0x100
		u64 vmcbsavestatepointer;        // +0x108
		u8  reserved4[0x400 - 0x110];    // +0x110
		u16 esselector;                  // +0x000
		u16 esattrib;                    // +0x002
		u32 eslimit;                     // +0x004
		u64 esbase;                      // +0x008
		u16 csselector;                  // +0x010
		u16 csattrib;                    // +0x012
		u32 cslimit;                     // +0x014
		u64 csbase;                      // +0x018
		u16 ssselector;                  // +0x020
		u16 ssattrib;                    // +0x022
		u32 sslimit;                     // +0x024
		u64 ssbase;                      // +0x028
		u16 dsselector;                  // +0x030
		u16 dsattrib;                    // +0x032
		u32 dslimit;                     // +0x034
		u64 dsbase;                      // +0x038
		u16 fsselector;                  // +0x040
		u16 fsattrib;                    // +0x042
		u32 fslimit;                     // +0x044
		u64 fsbase;                      // +0x048
		u16 gsselector;                  // +0x050
		u16 gsattrib;                    // +0x052
		u32 gslimit;                     // +0x054
		u64 gsbase;                      // +0x058
		u16 gdtrselector;                // +0x060
		u16 gdtrattrib;                  // +0x062
		u32 gdtrlimit;                   // +0x064
		u64 gdtrbase;                    // +0x068
		u16 ldtrselector;                // +0x070
		u16 ldtrattrib;                  // +0x072
		u32 ldtrlimit;                   // +0x074
		u64 ldtrbase;                    // +0x078
		u16 idtrselector;                // +0x080
		u16 idtrattrib;                  // +0x082
		u32 idtrlimit;                   // +0x084
		u64 idtrbase;                    // +0x088
		u16 trselector;                  // +0x090
		u16 trattrib;                    // +0x092
		u32 trlimit;                     // +0x094
		u64 trbase;                      // +0x098
		u8  reserved_1[0x0cb - 0x0a0];   // +0x0a0
		u8  cpl;                         // +0x0cb
		u32 reserved_2;                  // +0x0cc
		u64 efer;                        // +0x0d0
		u8  reserved_3[0x148 - 0x0d8];   // +0x0d8
		u64 cr4;                         // +0x148
		u64 cr3;                         // +0x150
		u64 cr0;                         // +0x158
		u64 dr7;                         // +0x160
		u64 dr6;                         // +0x168
		u64 rflags;                      // +0x170
		u64 rip;                         // +0x178
		u8  reserved_4[0x1d8 - 0x180];   // +0x180
		u64 rsp;                         // +0x1d8
		u8  reserved5[0x1f8 - 0x1e0];    // +0x1e0
		u64 rax;                         // +0x1f8
		u64 star;                        // +0x200
		u64 lstar;                       // +0x208
		u64 cstar;                       // +0x210
		u64 sfmask;                      // +0x218
		u64 kernelgsbase;                // +0x220
		u64 sysentercs;                  // +0x228
		u64 sysenteresp;                 // +0x230
		u64 sysentereip;                 // +0x238
		u64 cr2;                         // +0x240
		u8  reserved6[0x268 - 0x248];    // +0x248
		u64 gpat;                        // +0x268
		u64 dbgctl;                      // +0x270
		u64 brfrom;                      // +0x278
		u64 brto;                        // +0x280
		u64 lastexcepfrom;               // +0x288
		u64 lastexcepto;                 // +0x290
	} vmcb, *pvmcb;

	// AMD does not have a vmread/vmwrite instruction... only a vmload
	// and vmsave instruction... this means I had to hunt down the damn
	// VMCB location... this is the pointer chain to the VMCB...
	//
	// TODO: could sig scan for this in Voyager...
	__forceinline auto get_vmcb() -> pvmcb
	{
		return *reinterpret_cast<svm::pvmcb*>(
			*reinterpret_cast<u64*>(
				*reinterpret_cast<u64*>(
					__readgsqword(0) + offset_vmcb_base)
						+ offset_vmcb_link) + offset_vmcb);
	}

	enum class vmexit_command_t
	{
		init_page_tables,
		read_guest_phys,
		write_guest_phys,
		copy_guest_virt,
		get_dirbase,
		translate
	};

	enum class vmxroot_error_t
	{
		error_success,
		pml4e_not_present,
		pdpte_not_present,
		pde_not_present,
		pte_not_present,
		vmxroot_translate_failure,
		invalid_self_ref_pml4e,
		invalid_mapping_pml4e,
		invalid_host_virtual,
		invalid_guest_physical,
		invalid_guest_virtual,
		page_table_init_failed
	};

	typedef union _command_t
	{
		struct _copy_phys
		{
			host_phys_t  phys_addr;
			guest_virt_t buffer;
			u64 size;
		} copy_phys;

		struct _copy_virt
		{
			guest_phys_t dirbase_src;
			guest_virt_t virt_src;
			guest_phys_t dirbase_dest;
			guest_virt_t virt_dest;
			u64 size;
		} copy_virt;

		struct _translate_virt
		{
			guest_virt_t virt_src;
			guest_phys_t phys_addr;
		} translate_virt;

		guest_phys_t dirbase;

	} command_t, * pcommand_t;

	using vcpu_run_t = pgs_base_struct (__fastcall*)(void*, guest_context*);

	#pragma pack(push, 1)
	typedef struct _voyager_t
	{
		u64 vcpu_run_rva;
		u64 hyperv_module_base;
		u64 hyperv_module_size;
		u64 record_base;
		u64 record_size;
	} voyager_t, * pvoyager_t;
	#pragma pack(pop)

	__declspec(dllexport) inline voyager_t voyager_context;
}
```

`PayLoad (AMD)/vmexit.cpp`:

```cpp
#include "vmexit.h"
#include "debug.h"

namespace vmexit
{
	auto get_command(guest_virt_t command_ptr) -> svm::command_t
	{
		const auto vmcb = svm::get_vmcb();
		const auto guest_dirbase = cr3{ vmcb->cr3 }.pml4_pfn << 12;

		const auto command_page = 
			mm::map_guest_virt(guest_dirbase, command_ptr);

		return *reinterpret_cast<svm::command_t*>(command_page);
	}

	auto set_command(guest_virt_t command_ptr, svm::command_t& command_data) -> void
	{
		const auto vmcb = svm::get_vmcb();
		const auto guest_dirbase = cr3{ vmcb->cr3 }.pml4_pfn << 12;

		const auto command_page =
			mm::map_guest_virt(guest_dirbase, command_ptr);

		*reinterpret_cast<svm::command_t*>(command_page) = command_data;
	}
}
```

`PayLoad (AMD)/vmexit.h`:

```h
#pragma once
#include "mm.h"

namespace vmexit
{
	auto get_command(guest_virt_t command_ptr) -> svm::command_t;
	auto set_command(guest_virt_t command_ptr, svm::command_t& command_data) -> void;
}
```

`PayLoad (AMD)/vmexit_handler.cpp`:

```cpp
#include "types.h"
#include "mm.h"
#include "vmexit.h"
#include "debug.h"

auto vmexit_handler(void* unknown, svm::pguest_context context) -> svm::pgs_base_struct
{
	const auto vmcb = svm::get_vmcb();
	if (vmcb->exitcode == VMEXIT_CPUID && context->rcx == VMEXIT_KEY)
	{
		switch ((svm::vmexit_command_t)context->rdx)
		{
		case svm::vmexit_command_t::init_page_tables:
		{
			vmcb->rax = (u64) mm::init();
			break;
		}
		case svm::vmexit_command_t::get_dirbase:
		{
			auto command_data =
				vmexit::get_command(context->r8);

			command_data.dirbase = 
				cr3{ vmcb->cr3 }.pml4_pfn << 12;

			vmcb->rax = (u64)svm::vmxroot_error_t::error_success;

			vmexit::set_command(
				context->r8, command_data);
			break;
		}
		case svm::vmexit_command_t::read_guest_phys:
		{
			auto command_data =
				vmexit::get_command(context->r8);

			const auto guest_dirbase = 
				cr3{ vmcb->cr3 }.pml4_pfn << 12;

			vmcb->rax = (u64)mm::read_guest_phys(
				guest_dirbase,
				command_data.copy_phys.phys_addr,
				command_data.copy_phys.buffer,
				command_data.copy_phys.size);

			vmexit::set_command(
				context->r8, command_data);
			break;
		}
		case svm::vmexit_command_t::write_guest_phys:
		{
			auto command_data =
				vmexit::get_command(context->r8);

			const auto guest_dirbase =
				cr3{ vmcb->cr3 }.pml4_pfn << 12;

			vmcb->rax = (u64) mm::write_guest_phys(
				guest_dirbase,
				command_data.copy_phys.phys_addr,
				command_data.copy_phys.buffer,
				command_data.copy_phys.size);

			vmexit::set_command(
				context->r8, command_data);
			break;
		}
		case svm::vmexit_command_t::copy_guest_virt:
		{
			auto command_data =
				vmexit::get_command(context->r8);

			auto virt_data = command_data.copy_virt;
			vmcb->rax = (u64) mm::copy_guest_virt(
				virt_data.dirbase_src,
				virt_data.virt_src, 
				virt_data.dirbase_dest,
				virt_data.virt_dest, 
				virt_data.size);
			break;
		}
		case svm::vmexit_command_t::translate:
		{
			auto command_data =
				vmexit::get_command(context->r8);

			const auto guest_dirbase =
				cr3{ vmcb->cr3 }.pml4_pfn << 12;

			command_data.translate_virt.phys_addr =
				mm::translate_guest_virtual(guest_dirbase, 
					command_data.translate_virt.virt_src);

			vmcb->rax = (u64)svm::vmxroot_error_t::error_success;

			vmexit::set_command(
				context->r8, command_data);
			break;
		}
		default:
			break;
		}

		vmcb->rip = vmcb->nrip;
		return reinterpret_cast<svm::pgs_base_struct>(__readgsqword(0));
	}

	return reinterpret_cast<svm::vcpu_run_t>(
		reinterpret_cast<u64>(&vmexit_handler) -
			svm::voyager_context.vcpu_run_rva)(unknown, context);
}
```

`PayLoad (Intel)/PayLoad (Intel).vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="1507|x64">
      <Configuration>1507</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1511|x64">
      <Configuration>1511</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1607|x64">
      <Configuration>1607</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1703|x64">
      <Configuration>1703</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1709|x64">
      <Configuration>1709</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1803|x64">
      <Configuration>1803</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1809|x64">
      <Configuration>1809</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1903|x64">
      <Configuration>1903</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1909|x64">
      <Configuration>1909</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="2004|x64">
      <Configuration>2004</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{223D1FDE-331E-4028-9083-1673A5161C99}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>TheGoldenRecord</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.19041.0</WindowsTargetPlatformVersion>
    <ProjectName>PayLoad (Intel)</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1909|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1903|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1809|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1803|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1709|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1703|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1607|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1507|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='2004|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1909|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetExt>.dll</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1903|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetExt>.dll</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1809|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetExt>.dll</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1803|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetExt>.dll</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1709|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetExt>.dll</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1703|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetExt>.dll</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetExt>.dll</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1607|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetExt>.dll</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1507|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetExt>.dll</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetExt>.dll</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetExt>.dll</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetExt>.dll</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetExt>.dll</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='2004|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetExt>.dll</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetExt>.dll</TargetExt>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1909|x64'">
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Link>
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <TreatWarningAsError>false</TreatWarningAsError>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <ExceptionHandling>false</ExceptionHandling>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);WINVER=1909;</PreprocessorDefinitions>
    </ClCompile>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1903|x64'">
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Link>
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <TreatWarningAsError>false</TreatWarningAsError>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <ExceptionHandling>false</ExceptionHandling>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);WINVER=1903;</PreprocessorDefinitions>
    </ClCompile>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1809|x64'">
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Link>
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <TreatWarningAsError>false</TreatWarningAsError>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <ExceptionHandling>false</ExceptionHandling>
      <PreprocessorDefinitions>WINVER=1809;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1803|x64'">
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Link>
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <TreatWarningAsError>false</TreatWarningAsError>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <ExceptionHandling>false</ExceptionHandling>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);WINVER=1803;</PreprocessorDefinitions>
    </ClCompile>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1709|x64'">
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Link>
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <TreatWarningAsError>false</TreatWarningAsError>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <ExceptionHandling>false</ExceptionHandling>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);WINVER=1709;</PreprocessorDefinitions>
    </ClCompile>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1703|x64'">
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Link>
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <TreatWarningAsError>false</TreatWarningAsError>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <ExceptionHandling>false</ExceptionHandling>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);WINVER=1703;</PreprocessorDefinitions>
    </ClCompile>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'">
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Link>
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <TreatWarningAsError>false</TreatWarningAsError>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <ExceptionHandling>false</ExceptionHandling>
    </ClCompile>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1607|x64'">
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Link>
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <TreatWarningAsError>false</TreatWarningAsError>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <ExceptionHandling>false</ExceptionHandling>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);WINVER=1607;</PreprocessorDefinitions>
    </ClCompile>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1507|x64'">
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Link>
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <TreatWarningAsError>false</TreatWarningAsError>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <ExceptionHandling>false</ExceptionHandling>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);WINVER=1507;</PreprocessorDefinitions>
    </ClCompile>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'">
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Link>
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <TreatWarningAsError>false</TreatWarningAsError>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <ExceptionHandling>false</ExceptionHandling>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);WINVER=1607;</PreprocessorDefinitions>
    </ClCompile>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'">
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Link>
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <TreatWarningAsError>false</TreatWarningAsError>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <ExceptionHandling>false</ExceptionHandling>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions);WINVER=1607;</PreprocessorDefinitions>
    </ClCompile>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'">
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Link>
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <TreatWarningAsError>false</TreatWarningAsError>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <ExceptionHandling>false</ExceptionHandling>
    </ClCompile>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'">
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Link>
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <TreatWarningAsError>false</TreatWarningAsError>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <ExceptionHandling>false</ExceptionHandling>
    </ClCompile>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='2004|x64'">
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Link>
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <TreatWarningAsError>false</TreatWarningAsError>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <ExceptionHandling>false</ExceptionHandling>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);WINVER=2004;</PreprocessorDefinitions>
    </ClCompile>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'">
    <Link>
      <EntryPointSymbol>vmexit_handler</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>libcmt.lib;libucrt.lib;libvcruntime.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Link>
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <TreatWarningAsError>false</TreatWarningAsError>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <ExceptionHandling>false</ExceptionHandling>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);WINVER=1511</PreprocessorDefinitions>
    </ClCompile>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="debug.cpp" />
    <ClCompile Include="mm.cpp" />
    <ClCompile Include="vmexit.cpp" />
    <ClCompile Include="vmexit_handler.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="debug.h" />
    <ClInclude Include="ia32.hpp" />
    <ClInclude Include="mm.h" />
    <ClInclude Include="types.h" />
    <ClInclude Include="vmexit.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`PayLoad (Intel)/PayLoad (Intel).vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="vmexit_handler.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="debug.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="vmexit.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="mm.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="types.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ia32.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="debug.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="vmexit.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="mm.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`PayLoad (Intel)/PayLoad (Intel).vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`PayLoad (Intel)/debug.cpp`:

```cpp
#include "debug.h"

auto dbg::debug_print_decimal(long long number) -> void
{
    if (number < 0) 
    {
        __outbyte(PORT_NUM, '-');
        number = -number;
    }

    for (auto d = 1000000000000000000; d != 0; d /= 10) 
        if ((number / d) != 0)
            __outbyte(PORT_NUM, alphabet[(number / d) % 10]);
}

auto dbg::debug_print_hex(u64 number, const bool show_zeros) -> void
{
    for (auto d = 0x1000000000000000; d != 0; d /= 0x10) 
        if (show_zeros || (number / d) != 0) 
            __outbyte(PORT_NUM, alphabet[(number / d) % 0x10]);
}

auto dbg::print(const char* format, ...) -> void
{
    va_list args;
    va_start(args, format);

    while (format[0]) 
    {
        if (format[0] == '%') 
        {
            switch (format[1]) 
            {
            case 'd':
                debug_print_decimal(va_arg(args, int));
                format += 2;
                continue;
            case 'x':
                debug_print_hex(va_arg(args, u32), false);
                format += 2;
                continue;
            case 'l':
                if (format[2] == 'l') 
                {
                    switch (format[3]) 
                    {
                    case 'd':
                        debug_print_decimal(va_arg(args, u64));
                        format += 4;
                        continue;
                    case 'x':
                        debug_print_hex(va_arg(args, u64), false);
                        format += 4;
                        continue;
                    }
                }
                break;
            case 'p':
                debug_print_hex(va_arg(args, u64), true);
                format += 2;
                continue;
            }
        }

        __outbyte(PORT_NUM, format[0]);
        ++format;
    }
    va_end(args);
}
```

`PayLoad (Intel)/debug.h`:

```h
#pragma once
#include <stdarg.h>
#include <stddef.h>
#include "types.h"

#define PORT_NUM 0x2F8
namespace dbg
{
	constexpr char alphabet[] = "0123456789ABCDEF";
	auto debug_print_decimal(long long number) -> void;
	auto debug_print_hex(u64 number, const bool show_zeros) -> void;
	auto print(const char* format, ...) -> void;
}
```

`PayLoad (Intel)/ia32.hpp`:

```hpp
/** @file */
#pragma once
using UINT8_t = unsigned char;
using UINT16_t = unsigned short;
using UINT32_t = unsigned int;
using UINT64_t = unsigned long long;

/**
 * @defgroup intel_manual \
 *           Intel Manual
 *
 * @remarks All references are based on <b>Intel(R) 64 and IA-32 architectures software developer's manual combined volumes:
 *          1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4</b> (May 2018).
 * @{
 */
 /**
  * @defgroup control_registers \
  *           Control registers
  *
  * Control registers (CR0, CR1, CR2, CR3, and CR4) determine operating mode of the processor and the characteristics of the
  * currently executing task. These registers are 32 bits in all 32-bit modes and compatibility mode.
  * In 64-bit mode, control registers are expanded to 64 bits. The MOV CRn instructions are used to manipulate the register
  * bits. Operand-size prefixes for these instructions are ignored. The following is also true:
  * - The control registers can be read and loaded (or modified) using the move-to-or-from-control-registers forms of the
  * MOV instruction. In protected mode, the MOV instructions allow the control registers to be read or loaded (at privilege
  * level 0 only). This restriction means that application programs or operating-system procedures (running at privilege
  * levels 1, 2, or 3) are prevented from reading or loading the control registers.
  * - Bits 63:32 of CR0 and CR4 are reserved and must be written with zeros. Writing a nonzero value to any of the upper 32
  * bits results in a general-protection exception, \#GP(0).
  * - All 64 bits of CR2 are writable by software.
  * - Bits 51:40 of CR3 are reserved and must be 0.
  * - The MOV CRn instructions do not check that addresses written to CR2 and CR3 are within the linear-address or
  * physical-address limitations of the implementation.
  * - Register CR8 is available in 64-bit mode only. The control registers are summarized below, and each architecturally
  * defined control field in these control registers is described individually.
  * - CR0 - Contains system control flags that control operating mode and states of the processor.
  * - CR1 - Reserved.
  * - CR2 - Contains the page-fault linear address (the linear address that caused a page fault).
  * - CR3 - Contains the physical address of the base of the paging-structure hierarchy and two flags (PCD and PWT). Only
  * the most-significant bits (less the lower 12 bits) of the base address are specified; the lower 12 bits of the address
  * are assumed to be 0. The first paging structure must thus be aligned to a page (4-KByte) boundary. The PCD and PWT flags
  * control caching of that paging structure in the processor's internal data caches (they do not control TLB caching of
  * page-directory information). When using the physical address extension, the CR3 register contains the base address of
  * the page-directorypointer table. In IA-32e mode, the CR3 register contains the base address of the PML4 table.
  * - CR4 - Contains a group of flags that enable several architectural extensions, and indicate operating system or
  * executive support for specific processor capabilities.
  * - CR8 - Provides read and write access to the Task Priority Register (TPR). It specifies the priority threshold value
  * that operating systems use to control the priority class of external interrupts allowed to interrupt the processor. This
  * register is available only in 64-bit mode. However, interrupt filtering continues to apply in compatibility mode.
  *
  * @see Vol3A[2.5(CONTROL REGISTERS)] (reference)
  * @{
  */
typedef union
{
    UINT64_t flags;
    struct
    {
        /**
         * @brief Protection Enable
         *
         * [Bit 0] Enables protected mode when set; enables real-address mode when clear. This flag does not enable paging
         * directly. It only enables segment-level protection. To enable paging, both the PE and PG flags must be set.
         *
         * @see Vol3A[9.9(Mode Switching)]
         */
        UINT64_t protection_enable : 1;
#define CR0_PROTECTION_ENABLE_BIT                                    0
#define CR0_PROTECTION_ENABLE_FLAG                                   0x01
#define CR0_PROTECTION_ENABLE_MASK                                   0x01
#define CR0_PROTECTION_ENABLE(_)                                     (((_) >> 0) & 0x01)

        /**
         * @brief Monitor Coprocessor
         *
         * [Bit 1] Controls the interaction of the WAIT (or FWAIT) instruction with the TS flag (bit 3 of CR0). If the MP flag is
         * set, a WAIT instruction generates a device-not-available exception (\#NM) if the TS flag is also set. If the MP flag is
         * clear, the WAIT instruction ignores the setting of the TS flag.
         */
        UINT64_t monitor_coprocessor : 1;
#define CR0_MONITOR_COPROCESSOR_BIT                                  1
#define CR0_MONITOR_COPROCESSOR_FLAG                                 0x02
#define CR0_MONITOR_COPROCESSOR_MASK                                 0x01
#define CR0_MONITOR_COPROCESSOR(_)                                   (((_) >> 1) & 0x01)

        /**
         * @brief FPU Emulation
         *
         * [Bit 2] Indicates that the processor does not have an internal or external x87 FPU when set; indicates an x87 FPU is
         * present when clear. This flag also affects the execution of MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions.
         * When the EM flag is set, execution of an x87 FPU instruction generates a device-not-available exception (\#NM). This
         * flag must be set when the processor does not have an internal x87 FPU or is not connected to an external math
         * coprocessor. Setting this flag forces all floating-point instructions to be handled by software emulation.
         * Also, when the EM flag is set, execution of an MMX instruction causes an invalid-opcode exception (\#UD) to be
         * generated. Thus, if an IA-32 or Intel 64 processor incorporates MMX technology, the EM flag must be set to 0 to enable
         * execution of MMX instructions. Similarly for SSE/SSE2/SSE3/SSSE3/SSE4 extensions, when the EM flag is set, execution of
         * most SSE/SSE2/SSE3/SSSE3/SSE4 instructions causes an invalid opcode exception (\#UD) to be generated. If an IA-32 or
         * Intel 64 processor incorporates the SSE/SSE2/SSE3/SSSE3/SSE4 extensions, the EM flag must be set to 0 to enable
         * execution of these extensions. SSE/SSE2/SSE3/SSSE3/SSE4 instructions not affected by the EM flag include: PAUSE,
         * PREFETCHh, SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
         */
        UINT64_t emulate_fpu : 1;
#define CR0_EMULATE_FPU_BIT                                          2
#define CR0_EMULATE_FPU_FLAG                                         0x04
#define CR0_EMULATE_FPU_MASK                                         0x01
#define CR0_EMULATE_FPU(_)                                           (((_) >> 2) & 0x01)

        /**
         * @brief Task Switched
         *
         * [Bit 3] Allows the saving of the x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 context on a task switch to be delayed until an
         * x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction is actually executed by the new task. The processor sets this flag on
         * every task switch and tests it when executing x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions.
         * - If the TS flag is set and the EM flag (bit 2 of CR0) is clear, a device-not-available exception (\#NM) is raised prior
         * to the execution of any x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction; with the exception of PAUSE, PREFETCHh,
         * SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
         * - If the TS flag is set and the MP flag (bit 1 of CR0) and EM flag are clear, an \#NM exception is not raised prior to
         * the execution of an x87 FPU WAIT/FWAIT instruction.
         * - If the EM flag is set, the setting of the TS flag has no effect on the execution of x87
         * FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions.
         *   The processor does not automatically save the context of the x87 FPU, XMM, and MXCSR registers on a task switch.
         *   Instead, it sets the TS flag, which causes the processor to raise an \#NM exception whenever it encounters an x87
         *   FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction in the instruction stream for the new task (with the exception of the
         *   instructions listed above).
         *   The fault handler for the \#NM exception can then be used to clear the TS flag (with the CLTS instruction) and save
         *   the context of the x87 FPU, XMM, and MXCSR registers. If the task never encounters an x87
         *   FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction, the x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 context is never saved.
         */
        UINT64_t task_switched : 1;
#define CR0_TASK_SWITCHED_BIT                                        3
#define CR0_TASK_SWITCHED_FLAG                                       0x08
#define CR0_TASK_SWITCHED_MASK                                       0x01
#define CR0_TASK_SWITCHED(_)                                         (((_) >> 3) & 0x01)

        /**
         * @brief Extension Type
         *
         * [Bit 4] Reserved in the Pentium 4, Intel Xeon, P6 family, and Pentium processors. In the Pentium 4, Intel Xeon, and P6
         * family processors, this flag is hardcoded to 1. In the Intel386 and Intel486 processors, this flag indicates support of
         * Intel 387 DX math coprocessor instructions when set.
         */
        UINT64_t extension_type : 1;
#define CR0_EXTENSION_TYPE_BIT                                       4
#define CR0_EXTENSION_TYPE_FLAG                                      0x10
#define CR0_EXTENSION_TYPE_MASK                                      0x01
#define CR0_EXTENSION_TYPE(_)                                        (((_) >> 4) & 0x01)

        /**
         * @brief Numeric Error
         *
         * [Bit 5] Enables the native (internal) mechanism for reporting x87 FPU errors when set; enables the PC-style x87 FPU
         * error reporting mechanism when clear. When the NE flag is clear and the IGNNE\# input is asserted, x87 FPU errors are
         * ignored. When the NE flag is clear and the IGNNE\# input is deasserted, an unmasked x87 FPU error causes the processor
         * to assert the FERR\# pin to generate an external interrupt and to stop instruction execution immediately before
         * executing the next waiting floating-point instruction or WAIT/FWAIT instruction.
         * The FERR\# pin is intended to drive an input to an external interrupt controller (the FERR\# pin emulates the ERROR\#
         * pin of the Intel 287 and Intel 387 DX math coprocessors). The NE flag, IGNNE\# pin, and FERR\# pin are used with
         * external logic to implement PC-style error reporting. Using FERR\# and IGNNE\# to handle floating-point exceptions is
         * deprecated by modern operating systems; this non-native approach also limits newer processors to operate with one
         * logical processor active.
         *
         * @see Vol1[8.7(Handling x87 FPU Exceptions in Software)]
         * @see Vol1[A.1(APPENDIX A | EFLAGS Cross-Reference)]
         */
        UINT64_t numeric_error : 1;
#define CR0_NUMERIC_ERROR_BIT                                        5
#define CR0_NUMERIC_ERROR_FLAG                                       0x20
#define CR0_NUMERIC_ERROR_MASK                                       0x01
#define CR0_NUMERIC_ERROR(_)                                         (((_) >> 5) & 0x01)
        UINT64_t reserved1 : 10;

        /**
         * @brief Write Protect
         *
         * [Bit 16] When set, inhibits supervisor-level procedures from writing into readonly pages; when clear, allows
         * supervisor-level procedures to write into read-only pages (regardless of the U/S bit setting). This flag facilitates
         * implementation of the copy-onwrite method of creating a new process (forking) used by operating systems such as UNIX.
         *
         * @see Vol3A[4.1.3(Paging-Mode Modifiers)]
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        UINT64_t write_protect : 1;
#define CR0_WRITE_PROTECT_BIT                                        16
#define CR0_WRITE_PROTECT_FLAG                                       0x10000
#define CR0_WRITE_PROTECT_MASK                                       0x01
#define CR0_WRITE_PROTECT(_)                                         (((_) >> 16) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * @brief Alignment Mask
         *
         * [Bit 18] Enables automatic alignment checking when set; disables alignment checking when clear. Alignment checking is
         * performed only when the AM flag is set, the AC flag in the EFLAGS register is set, CPL is 3, and the processor is
         * operating in either protected or virtual-8086 mode.
         */
        UINT64_t alignment_mask : 1;
#define CR0_ALIGNMENT_MASK_BIT                                       18
#define CR0_ALIGNMENT_MASK_FLAG                                      0x40000
#define CR0_ALIGNMENT_MASK_MASK                                      0x01
#define CR0_ALIGNMENT_MASK(_)                                        (((_) >> 18) & 0x01)
        UINT64_t reserved3 : 10;

        /**
         * @brief Not Write-through
         *
         * [Bit 29] When the NW and CD flags are clear, write-back (for Pentium 4, Intel Xeon, P6 family, and Pentium processors)
         * or write-through (for Intel486 processors) is enabled for writes that hit the cache and invalidation cycles are enabled.
         */
        UINT64_t not_write_through : 1;
#define CR0_NOT_WRITE_THROUGH_BIT                                    29
#define CR0_NOT_WRITE_THROUGH_FLAG                                   0x20000000
#define CR0_NOT_WRITE_THROUGH_MASK                                   0x01
#define CR0_NOT_WRITE_THROUGH(_)                                     (((_) >> 29) & 0x01)

        /**
         * @brief Cache Disable
         *
         * [Bit 30] When the CD and NW flags are clear, caching of memory locations for the whole of physical memory in the
         * processor's internal (and external) caches is enabled. When the CD flag is set, caching is restricted. To prevent the
         * processor from accessing and updating its caches, the CD flag must be set and the caches must be invalidated so that no
         * cache hits can occur.
         *
         * @see Vol3A[11.5.3(Preventing Caching)]
         * @see Vol3A[11.5(CACHE CONTROL)]
         */
        UINT64_t cache_disable : 1;
#define CR0_CACHE_DISABLE_BIT                                        30
#define CR0_CACHE_DISABLE_FLAG                                       0x40000000
#define CR0_CACHE_DISABLE_MASK                                       0x01
#define CR0_CACHE_DISABLE(_)                                         (((_) >> 30) & 0x01)

        /**
         * @brief Paging Enable
         *
         * [Bit 31] Enables paging when set; disables paging when clear. When paging is disabled, all linear addresses are treated
         * as physical addresses. The PG flag has no effect if the PE flag (bit 0 of register CR0) is not also set; setting the PG
         * flag when the PE flag is clear causes a general-protection exception (\#GP).
         * On Intel 64 processors, enabling and disabling IA-32e mode operation also requires modifying CR0.PG.
         *
         * @see Vol3A[4(PAGING)]
         */
        UINT64_t paging_enable : 1;
#define CR0_PAGING_ENABLE_BIT                                        31
#define CR0_PAGING_ENABLE_FLAG                                       0x80000000
#define CR0_PAGING_ENABLE_MASK                                       0x01
#define CR0_PAGING_ENABLE(_)                                         (((_) >> 31) & 0x01)
        UINT64_t reserved4 : 32;
    };
} cr0;

typedef union
{
    UINT64_t flags;
    struct
    {
        UINT64_t reserved1 : 3;

        /**
         * @brief Page-level Write-Through
         *
         * [Bit 3] Controls the memory type used to access the first paging structure of the current paging-structure hierarchy.
         * This bit is not used if paging is disabled, with PAE paging, or with 4-level paging if CR4.PCIDE=1.
         *
         * @see Vol3A[4.9(PAGING AND MEMORY TYPING)]
         */
        UINT64_t page_level_write_through : 1;
#define CR3_PAGE_LEVEL_WRITE_THROUGH_BIT                             3
#define CR3_PAGE_LEVEL_WRITE_THROUGH_FLAG                            0x08
#define CR3_PAGE_LEVEL_WRITE_THROUGH_MASK                            0x01
#define CR3_PAGE_LEVEL_WRITE_THROUGH(_)                              (((_) >> 3) & 0x01)

        /**
         * @brief Page-level Cache Disable
         *
         * [Bit 4] Controls the memory type used to access the first paging structure of the current paging-structure hierarchy.
         * This bit is not used if paging is disabled, with PAE paging, or with 4-level paging2 if CR4.PCIDE=1.
         *
         * @see Vol3A[4.9(PAGING AND MEMORY TYPING)]
         */
        UINT64_t page_level_cache_disable : 1;
#define CR3_PAGE_LEVEL_CACHE_DISABLE_BIT                             4
#define CR3_PAGE_LEVEL_CACHE_DISABLE_FLAG                            0x10
#define CR3_PAGE_LEVEL_CACHE_DISABLE_MASK                            0x01
#define CR3_PAGE_LEVEL_CACHE_DISABLE(_)                              (((_) >> 4) & 0x01)
        UINT64_t reserved2 : 7;

        /**
         * @brief Address of page directory
         *
         * [Bits 47:12] Physical address of the 4-KByte aligned page directory (32-bit paging) or PML4 table (64-bit paging) used
         * for linear-address translation.
         *
         * @see Vol3A[4.3(32-BIT PAGING)]
         * @see Vol3A[4.5(4-LEVEL PAGING)]
         */
        UINT64_t pml4_pfn : 36;
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_BIT                            12
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_FLAG                           0xFFFFFFFFF000
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_MASK                           0xFFFFFFFFF
#define CR3_ADDRESS_OF_PAGE_DIRECTORY(_)                             (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved3 : 16;
    };
} cr3;

typedef union
{
    struct
    {
        /**
         * @brief Virtual-8086 Mode Extensions
         *
         * [Bit 0] Enables interrupt- and exception-handling extensions in virtual-8086 mode when set; disables the extensions when
         * clear. Use of the virtual mode extensions can improve the performance of virtual-8086 applications by eliminating the
         * overhead of calling the virtual- 8086 monitor to handle interrupts and exceptions that occur while executing an 8086
         * program and, instead, redirecting the interrupts and exceptions back to the 8086 program's handlers. It also provides
         * hardware support for a virtual interrupt flag (VIF) to improve reliability of running 8086 programs in multitasking and
         * multiple-processor environments.
         *
         * @see Vol3B[20.3(INTERRUPT AND EXCEPTION HANDLING IN VIRTUAL-8086 MODE)]
         */
        UINT64_t virtual_mode_extensions : 1;
#define CR4_VIRTUAL_MODE_EXTENSIONS_BIT                              0
#define CR4_VIRTUAL_MODE_EXTENSIONS_FLAG                             0x01
#define CR4_VIRTUAL_MODE_EXTENSIONS_MASK                             0x01
#define CR4_VIRTUAL_MODE_EXTENSIONS(_)                               (((_) >> 0) & 0x01)

        /**
         * @brief Protected-Mode Virtual Interrupts
         *
         * [Bit 1] Enables hardware support for a virtual interrupt flag (VIF) in protected mode when set; disables the VIF flag in
         * protected mode when clear.
         *
         * @see Vol3B[20.4(PROTECTED-MODE VIRTUAL INTERRUPTS)]
         */
        UINT64_t protected_mode_virtual_interrupts : 1;
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_BIT                    1
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_FLAG                   0x02
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_MASK                   0x01
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS(_)                     (((_) >> 1) & 0x01)

        /**
         * @brief Time Stamp Disable
         *
         * [Bit 2] Restricts the execution of the RDTSC instruction to procedures running at privilege level 0 when set; allows
         * RDTSC instruction to be executed at any privilege level when clear. This bit also applies to the RDTSCP instruction if
         * supported (if CPUID.80000001H:EDX[27] = 1).
         */
        UINT64_t timestamp_disable : 1;
#define CR4_TIMESTAMP_DISABLE_BIT                                    2
#define CR4_TIMESTAMP_DISABLE_FLAG                                   0x04
#define CR4_TIMESTAMP_DISABLE_MASK                                   0x01
#define CR4_TIMESTAMP_DISABLE(_)                                     (((_) >> 2) & 0x01)

        /**
         * @brief Debugging Extensions
         *
         * [Bit 3] References to debug registers DR4 and DR5 cause an undefined opcode (\#UD) exception to be generated when set;
         * when clear, processor aliases references to registers DR4 and DR5 for compatibility with software written to run on
         * earlier IA-32 processors.
         *
         * @see Vol3B[17.2.2(Debug Registers DR4 and DR5)]
         */
        UINT64_t debugging_extensions : 1;
#define CR4_DEBUGGING_EXTENSIONS_BIT                                 3
#define CR4_DEBUGGING_EXTENSIONS_FLAG                                0x08
#define CR4_DEBUGGING_EXTENSIONS_MASK                                0x01
#define CR4_DEBUGGING_EXTENSIONS(_)                                  (((_) >> 3) & 0x01)

        /**
         * @brief Page Size Extensions
         *
         * [Bit 4] Enables 4-MByte pages with 32-bit paging when set; restricts 32-bit paging to pages of 4 KBytes when clear.
         *
         * @see Vol3A[4.3(32-BIT PAGING)]
         */
        UINT64_t page_size_extensions : 1;
#define CR4_PAGE_SIZE_EXTENSIONS_BIT                                 4
#define CR4_PAGE_SIZE_EXTENSIONS_FLAG                                0x10
#define CR4_PAGE_SIZE_EXTENSIONS_MASK                                0x01
#define CR4_PAGE_SIZE_EXTENSIONS(_)                                  (((_) >> 4) & 0x01)

        /**
         * @brief Physical Address Extension
         *
         * [Bit 5] When set, enables paging to produce physical addresses with more than 32 bits. When clear, restricts physical
         * addresses to 32 bits. PAE must be set before entering IA-32e mode.
         *
         * @see Vol3A[4(PAGING)]
         */
        UINT64_t physical_address_extension : 1;
#define CR4_PHYSICAL_ADDRESS_EXTENSION_BIT                           5
#define CR4_PHYSICAL_ADDRESS_EXTENSION_FLAG                          0x20
#define CR4_PHYSICAL_ADDRESS_EXTENSION_MASK                          0x01
#define CR4_PHYSICAL_ADDRESS_EXTENSION(_)                            (((_) >> 5) & 0x01)

        /**
         * @brief Machine-Check Enable
         *
         * [Bit 6] Enables the machine-check exception when set; disables the machine-check exception when clear.
         *
         * @see Vol3B[15(MACHINE-CHECK ARCHITECTURE)]
         */
        UINT64_t machine_check_enable : 1;
#define CR4_MACHINE_CHECK_ENABLE_BIT                                 6
#define CR4_MACHINE_CHECK_ENABLE_FLAG                                0x40
#define CR4_MACHINE_CHECK_ENABLE_MASK                                0x01
#define CR4_MACHINE_CHECK_ENABLE(_)                                  (((_) >> 6) & 0x01)

        /**
         * @brief Page Global Enable
         *
         * [Bit 7] (Introduced in the P6 family processors.) Enables the global page feature when set; disables the global page
         * feature when clear. The global page feature allows frequently used or shared pages to be marked as global to all users
         * (done with the global flag, bit 8, in a page-directory or page-table entry). Global pages are not flushed from the
         * translation-lookaside buffer (TLB) on a task switch or a write to register CR3. When enabling the global page feature,
         * paging must be enabled (by setting the PG flag in control register CR0) before the PGE flag is set. Reversing this
         * sequence may affect program correctness, and processor performance will be impacted.
         *
         * @see Vol3A[4.10(CACHING TRANSLATION INFORMATION)]
         */
        UINT64_t page_global_enable : 1;
#define CR4_PAGE_GLOBAL_ENABLE_BIT                                   7
#define CR4_PAGE_GLOBAL_ENABLE_FLAG                                  0x80
#define CR4_PAGE_GLOBAL_ENABLE_MASK                                  0x01
#define CR4_PAGE_GLOBAL_ENABLE(_)                                    (((_) >> 7) & 0x01)

        /**
         * @brief Performance-Monitoring Counter Enable
         *
         * [Bit 8] Enables execution of the RDPMC instruction for programs or procedures running at any protection level when set;
         * RDPMC instruction can be executed only at protection level 0 when clear.
         */
        UINT64_t performance_monitoring_counter_enable : 1;
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_BIT                8
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_FLAG               0x100
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_MASK               0x01
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE(_)                 (((_) >> 8) & 0x01)

        /**
         * @brief Operating System Support for FXSAVE and FXRSTOR instructions
         *
         * [Bit 9] When set, this flag:
         * -# indicates to software that the operating system supports the use of the FXSAVE and FXRSTOR instructions,
         * -# enables the FXSAVE and FXRSTOR instructions to save and restore the contents of the XMM and MXCSR registers along
         * with the contents of the x87 FPU and MMX registers, and
         * -# enables the processor to execute SSE/SSE2/SSE3/SSSE3/SSE4 instructions, with the exception of the PAUSE, PREFETCHh,
         * SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
         * If this flag is clear, the FXSAVE and FXRSTOR instructions will save and restore the contents of the x87 FPU and MMX
         * registers, but they may not save and restore the contents of the XMM and MXCSR registers. Also, the processor will
         * generate an invalid opcode exception (\#UD) if it attempts to execute any SSE/SSE2/SSE3 instruction, with the exception
         * of PAUSE, PREFETCHh, SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT. The operating system or executive must
         * explicitly set this flag.
         *
         * @remarks CPUID feature flag FXSR indicates availability of the FXSAVE/FXRSTOR instructions. The OSFXSR bit provides
         *          operating system software with a means of enabling FXSAVE/FXRSTOR to save/restore the contents of the X87 FPU, XMM and
         *          MXCSR registers. Consequently OSFXSR bit indicates that the operating system provides context switch support for
         *          SSE/SSE2/SSE3/SSSE3/SSE4.
         */
        UINT64_t os_fxsave_fxrstor_support : 1;
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_BIT                            9
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_FLAG                           0x200
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_MASK                           0x01
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT(_)                             (((_) >> 9) & 0x01)

        /**
         * @brief Operating System Support for Unmasked SIMD Floating-Point Exceptions
         *
         * [Bit 10] Operating System Support for Unmasked SIMD Floating-Point Exceptions - When set, indicates that the operating
         * system supports the handling of unmasked SIMD floating-point exceptions through an exception handler that is invoked
         * when a SIMD floating-point exception (\#XM) is generated. SIMD floating-point exceptions are only generated by
         * SSE/SSE2/SSE3/SSE4.1 SIMD floatingpoint instructions.
         * The operating system or executive must explicitly set this flag. If this flag is not set, the processor will generate an
         * invalid opcode exception (\#UD) whenever it detects an unmasked SIMD floating-point exception.
         */
        UINT64_t os_xmm_exception_support : 1;
#define CR4_OS_XMM_EXCEPTION_SUPPORT_BIT                             10
#define CR4_OS_XMM_EXCEPTION_SUPPORT_FLAG                            0x400
#define CR4_OS_XMM_EXCEPTION_SUPPORT_MASK                            0x01
#define CR4_OS_XMM_EXCEPTION_SUPPORT(_)                              (((_) >> 10) & 0x01)

        /**
         * @brief User-Mode Instruction Prevention
         *
         * [Bit 11] When set, the following instructions cannot be executed if CPL > 0: SGDT, SIDT, SLDT, SMSW, and STR. An attempt
         * at such execution causes a generalprotection exception (\#GP).
         */
        UINT64_t usermode_instruction_prevention : 1;
#define CR4_USERMODE_INSTRUCTION_PREVENTION_BIT                      11
#define CR4_USERMODE_INSTRUCTION_PREVENTION_FLAG                     0x800
#define CR4_USERMODE_INSTRUCTION_PREVENTION_MASK                     0x01
#define CR4_USERMODE_INSTRUCTION_PREVENTION(_)                       (((_) >> 11) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * @brief VMX-Enable
         *
         * [Bit 13] Enables VMX operation when set.
         *
         * @see Vol3C[23(INTRODUCTION TO VIRTUAL MACHINE EXTENSIONS)]
         */
        UINT64_t vmx_enable : 1;
#define CR4_VMX_ENABLE_BIT                                           13
#define CR4_VMX_ENABLE_FLAG                                          0x2000
#define CR4_VMX_ENABLE_MASK                                          0x01
#define CR4_VMX_ENABLE(_)                                            (((_) >> 13) & 0x01)

        /**
         * @brief SMX-Enable
         *
         * [Bit 14] Enables SMX operation when set.
         *
         * @see Vol2[6(SAFER MODE EXTENSIONS REFERENCE)]
         */
        UINT64_t smx_enable : 1;
#define CR4_SMX_ENABLE_BIT                                           14
#define CR4_SMX_ENABLE_FLAG                                          0x4000
#define CR4_SMX_ENABLE_MASK                                          0x01
#define CR4_SMX_ENABLE(_)                                            (((_) >> 14) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * @brief FSGSBASE-Enable
         *
         * [Bit 16] Enables the instructions RDFSBASE, RDGSBASE, WRFSBASE, and WRGSBASE.
         */
        UINT64_t fsgsbase_enable : 1;
#define CR4_FSGSBASE_ENABLE_BIT                                      16
#define CR4_FSGSBASE_ENABLE_FLAG                                     0x10000
#define CR4_FSGSBASE_ENABLE_MASK                                     0x01
#define CR4_FSGSBASE_ENABLE(_)                                       (((_) >> 16) & 0x01)

        /**
         * @brief PCID-Enable
         *
         * [Bit 17] Enables process-context identifiers (PCIDs) when set. Can be set only in IA-32e mode (if IA32_EFER.LMA = 1).
         *
         * @see Vol3A[4.10.1(Process-Context Identifiers (PCIDs))]
         */
        UINT64_t pcid_enable : 1;
#define CR4_PCID_ENABLE_BIT                                          17
#define CR4_PCID_ENABLE_FLAG                                         0x20000
#define CR4_PCID_ENABLE_MASK                                         0x01
#define CR4_PCID_ENABLE(_)                                           (((_) >> 17) & 0x01)

        /**
         * @brief XSAVE and Processor Extended States-Enable
         *
         * [Bit 18] When set, this flag:
         * -# indicates (via CPUID.01H:ECX.OSXSAVE[bit 27]) that the operating system supports the use of the XGETBV, XSAVE and
         * XRSTOR instructions by general software;
         * -# enables the XSAVE and XRSTOR instructions to save and restore the x87 FPU state (including MMX registers), the SSE
         * state (XMM registers and MXCSR), along with other processor extended states enabled in XCR0;
         * -# enables the processor to execute XGETBV and XSETBV instructions in order to read and write XCR0.
         *
         * @see Vol3A[2.6(EXTENDED CONTROL REGISTERS (INCLUDING XCR0))]
         * @see Vol3A[13(SYSTEM PROGRAMMING FOR INSTRUCTION SET EXTENSIONS AND PROCESSOR EXTENDED)]
         */
        UINT64_t os_xsave : 1;
#define CR4_OS_XSAVE_BIT                                             18
#define CR4_OS_XSAVE_FLAG                                            0x40000
#define CR4_OS_XSAVE_MASK                                            0x01
#define CR4_OS_XSAVE(_)                                              (((_) >> 18) & 0x01)
        UINT64_t reserved3 : 1;

        /**
         * @brief SMEP-Enable
         *
         * [Bit 20] Enables supervisor-mode execution prevention (SMEP) when set.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        UINT64_t smep_enable : 1;
#define CR4_SMEP_ENABLE_BIT                                          20
#define CR4_SMEP_ENABLE_FLAG                                         0x100000
#define CR4_SMEP_ENABLE_MASK                                         0x01
#define CR4_SMEP_ENABLE(_)                                           (((_) >> 20) & 0x01)

        /**
         * @brief SMAP-Enable
         *
         * [Bit 21] Enables supervisor-mode access prevention (SMAP) when set.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        UINT64_t smap_enable : 1;
#define CR4_SMAP_ENABLE_BIT                                          21
#define CR4_SMAP_ENABLE_FLAG                                         0x200000
#define CR4_SMAP_ENABLE_MASK                                         0x01
#define CR4_SMAP_ENABLE(_)                                           (((_) >> 21) & 0x01)

        /**
         * @brief Protection-Key-Enable
         *
         * [Bit 22] Enables 4-level paging to associate each linear address with a protection key. The PKRU register specifies, for
         * each protection key, whether user-mode linear addresses with that protection key can be read or written. This bit also
         * enables access to the PKRU register using the RDPKRU and WRPKRU instructions.
         */
        UINT64_t protection_key_enable : 1;
#define CR4_PROTECTION_KEY_ENABLE_BIT                                22
#define CR4_PROTECTION_KEY_ENABLE_FLAG                               0x400000
#define CR4_PROTECTION_KEY_ENABLE_MASK                               0x01
#define CR4_PROTECTION_KEY_ENABLE(_)                                 (((_) >> 22) & 0x01)
        UINT64_t reserved4 : 41;
    };

    UINT64_t flags;
} cr4;

typedef union
{
    struct
    {
        /**
         * @brief Task Priority Level
         *
         * [Bits 3:0] This sets the threshold value corresponding to the highestpriority interrupt to be blocked. A value of 0
         * means all interrupts are enabled. This field is available in 64- bit mode. A value of 15 means all interrupts will be
         * disabled.
         */
        UINT64_t task_priority_level : 4;
#define CR8_TASK_PRIORITY_LEVEL_BIT                                  0
#define CR8_TASK_PRIORITY_LEVEL_FLAG                                 0x0F
#define CR8_TASK_PRIORITY_LEVEL_MASK                                 0x0F
#define CR8_TASK_PRIORITY_LEVEL(_)                                   (((_) >> 0) & 0x0F)

        /**
         * @brief Reserved
         *
         * [Bits 63:4] Reserved and must be written with zeros. Failure to do this causes a general-protection exception.
         */
        UINT64_t reserved : 60;
#define CR8_RESERVED_BIT                                             4
#define CR8_RESERVED_FLAG                                            0xFFFFFFFFFFFFFFF0
#define CR8_RESERVED_MASK                                            0xFFFFFFFFFFFFFFF
#define CR8_RESERVED(_)                                              (((_) >> 4) & 0xFFFFFFFFFFFFFFF)
    };

    UINT64_t flags;
} cr8;

/**
 * @}
 */

 /**
  * @defgroup debug_registers \
  *           Debug registers
  *
  * Eight debug registers control the debug operation of the processor. These registers can be written to and read using the
  * move to/from debug register form of the MOV instruction. A debug register may be the source or destination operand for
  * one of these instructions.
  * Debug registers are privileged resources; a MOV instruction that accesses these registers can only be executed in
  * real-address mode, in SMM or in protected mode at a CPL of 0. An attempt to read or write the debug registers from any
  * other privilege level generates a general-protection exception (\#GP). The primary function of the debug registers is to
  * set up and monitor from 1 to 4 breakpoints, numbered 0 though 3. For each breakpoint, the following information can be
  * specified:
  * - The linear address where the breakpoint is to occur.
  * - The length of the breakpoint location: 1, 2, 4, or 8 bytes.
  * - The operation that must be performed at the address for a debug exception to be generated.
  * - Whether the breakpoint is enabled.
  * - Whether the breakpoint condition was present when the debug exception was generated.
  *
  * @see Vol3B[17.2.4(Debug Control Register (DR7))]
  * @see Vol3B[17.2(DEBUG REGISTERS)] (reference)
  * @{
  */
typedef union
{
    struct
    {
        /**
         * @brief B0 through B3 (breakpoint condition detected) flags
         *
         * [Bits 3:0] Indicates (when set) that its associated breakpoint condition was met when a debug exception was generated.
         * These flags are set if the condition described for each breakpoint by the LENn, and R/Wn flags in debug control register
         * DR7 is true. They may or may not be set if the breakpoint is not enabled by the Ln or the Gn flags in register DR7.
         * Therefore on a \#DB, a debug handler should check only those B0-B3 bits which correspond to an enabled breakpoint.
         */
        UINT64_t breakpoint_condition : 4;
#define DR6_BREAKPOINT_CONDITION_BIT                                 0
#define DR6_BREAKPOINT_CONDITION_FLAG                                0x0F
#define DR6_BREAKPOINT_CONDITION_MASK                                0x0F
#define DR6_BREAKPOINT_CONDITION(_)                                  (((_) >> 0) & 0x0F)
        UINT64_t reserved1 : 9;

        /**
         * @brief BD (debug register access detected) flag
         *
         * [Bit 13] Indicates that the next instruction in the instruction stream accesses one of the debug registers (DR0 through
         * DR7). This flag is enabled when the GD (general detect) flag in debug control register DR7 is set.
         *
         * @see Vol3B[17.2.4(Debug Control Register (DR7))]
         */
        UINT64_t debug_register_access_detected : 1;
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_BIT                       13
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_FLAG                      0x2000
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_MASK                      0x01
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED(_)                        (((_) >> 13) & 0x01)

        /**
         * @brief BS (single step) flag
         *
         * [Bit 14] Indicates (when set) that the debug exception was triggered by the singlestep execution mode (enabled with the
         * TF flag in the EFLAGS register). The single-step mode is the highestpriority debug exception. When the BS flag is set,
         * any of the other debug status bits also may be set.
         */
        UINT64_t single_instruction : 1;
#define DR6_SINGLE_INSTRUCTION_BIT                                   14
#define DR6_SINGLE_INSTRUCTION_FLAG                                  0x4000
#define DR6_SINGLE_INSTRUCTION_MASK                                  0x01
#define DR6_SINGLE_INSTRUCTION(_)                                    (((_) >> 14) & 0x01)

        /**
         * @brief BT (task switch) flag
         *
         * [Bit 15] Indicates (when set) that the debug exception was triggered by the singlestep execution mode (enabled with the
         * TF flag in the EFLAGS register). The single-step mode is the highestpriority debug exception. When the BS flag is set,
         * any of the other debug status bits also may be set.
         */
        UINT64_t task_switch : 1;
#define DR6_TASK_SWITCH_BIT                                          15
#define DR6_TASK_SWITCH_FLAG                                         0x8000
#define DR6_TASK_SWITCH_MASK                                         0x01
#define DR6_TASK_SWITCH(_)                                           (((_) >> 15) & 0x01)

        /**
         * @brief RTM (restricted transactional memory) flag
         *
         * [Bit 16] Indicates (when clear) that a debug exception (\#DB) or breakpoint exception (\#BP) occurred inside an RTM
         * region while advanced debugging of RTM transactional regions was enabled. This bit is set for any other debug exception
         * (including all those that occur when advanced debugging of RTM transactional regions is not enabled). This bit is always
         * 1 if the processor does not support RTM.
         *
         * @see Vol3B[17.3.3(Debug Exceptions, Breakpoint Exceptions, and Restricted Transactional Memory (RTM))]
         */
        UINT64_t restricted_transactional_memory : 1;
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_BIT                      16
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_FLAG                     0x10000
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_MASK                     0x01
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY(_)                       (((_) >> 16) & 0x01)
        UINT64_t reserved2 : 47;
    };

    UINT64_t flags;
} dr6;

typedef union
{
    struct
    {
        /**
         * @brief L0 through L3 (local breakpoint enable) flags (bits 0, 2, 4, and 6)
         *
         * [Bit 0] Enables (when set) the breakpoint condition for the associated breakpoint for the current task. When a
         * breakpoint condition is detected and its associated Ln flag is set, a debug exception is generated. The processor
         * automatically clears these flags on every task switch to avoid unwanted breakpoint conditions in the new task.
         */
        UINT64_t local_breakpoint_0 : 1;
#define DR7_LOCAL_BREAKPOINT_0_BIT                                   0
#define DR7_LOCAL_BREAKPOINT_0_FLAG                                  0x01
#define DR7_LOCAL_BREAKPOINT_0_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_0(_)                                    (((_) >> 0) & 0x01)

        /**
         * @brief G0 through G3 (global breakpoint enable) flags (bits 1, 3, 5, and 7)
         *
         * [Bit 1] Enables (when set) the breakpoint condition for the associated breakpoint for all tasks. When a breakpoint
         * condition is detected and its associated Gn flag is set, a debug exception is generated. The processor does not clear
         * these flags on a task switch, allowing a breakpoint to be enabled for all tasks.
         */
        UINT64_t global_breakpoint_0 : 1;
#define DR7_GLOBAL_BREAKPOINT_0_BIT                                  1
#define DR7_GLOBAL_BREAKPOINT_0_FLAG                                 0x02
#define DR7_GLOBAL_BREAKPOINT_0_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_0(_)                                   (((_) >> 1) & 0x01)
        UINT64_t local_breakpoint_1 : 1;
#define DR7_LOCAL_BREAKPOINT_1_BIT                                   2
#define DR7_LOCAL_BREAKPOINT_1_FLAG                                  0x04
#define DR7_LOCAL_BREAKPOINT_1_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_1(_)                                    (((_) >> 2) & 0x01)
        UINT64_t global_breakpoint_1 : 1;
#define DR7_GLOBAL_BREAKPOINT_1_BIT                                  3
#define DR7_GLOBAL_BREAKPOINT_1_FLAG                                 0x08
#define DR7_GLOBAL_BREAKPOINT_1_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_1(_)                                   (((_) >> 3) & 0x01)
        UINT64_t local_breakpoint_2 : 1;
#define DR7_LOCAL_BREAKPOINT_2_BIT                                   4
#define DR7_LOCAL_BREAKPOINT_2_FLAG                                  0x10
#define DR7_LOCAL_BREAKPOINT_2_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_2(_)                                    (((_) >> 4) & 0x01)
        UINT64_t global_breakpoint_2 : 1;
#define DR7_GLOBAL_BREAKPOINT_2_BIT                                  5
#define DR7_GLOBAL_BREAKPOINT_2_FLAG                                 0x20
#define DR7_GLOBAL_BREAKPOINT_2_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_2(_)                                   (((_) >> 5) & 0x01)
        UINT64_t local_breakpoint_3 : 1;
#define DR7_LOCAL_BREAKPOINT_3_BIT                                   6
#define DR7_LOCAL_BREAKPOINT_3_FLAG                                  0x40
#define DR7_LOCAL_BREAKPOINT_3_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_3(_)                                    (((_) >> 6) & 0x01)
        UINT64_t global_breakpoint_3 : 1;
#define DR7_GLOBAL_BREAKPOINT_3_BIT                                  7
#define DR7_GLOBAL_BREAKPOINT_3_FLAG                                 0x80
#define DR7_GLOBAL_BREAKPOINT_3_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_3(_)                                   (((_) >> 7) & 0x01)

        /**
         * @brief LE (local exact breakpoint enable)
         *
         * [Bit 8] This feature is not supported in the P6 family processors, later IA-32 processors, and Intel 64 processors. When
         * set, these flags cause the processor to detect the exact instruction that caused a data breakpoint condition. For
         * backward and forward compatibility with other Intel processors, we recommend that the LE and GE flags be set to 1 if
         * exact breakpoints are required.
         */
        UINT64_t local_exact_breakpoint : 1;
#define DR7_LOCAL_EXACT_BREAKPOINT_BIT                               8
#define DR7_LOCAL_EXACT_BREAKPOINT_FLAG                              0x100
#define DR7_LOCAL_EXACT_BREAKPOINT_MASK                              0x01
#define DR7_LOCAL_EXACT_BREAKPOINT(_)                                (((_) >> 8) & 0x01)
        UINT64_t global_exact_breakpoint : 1;
#define DR7_GLOBAL_EXACT_BREAKPOINT_BIT                              9
#define DR7_GLOBAL_EXACT_BREAKPOINT_FLAG                             0x200
#define DR7_GLOBAL_EXACT_BREAKPOINT_MASK                             0x01
#define DR7_GLOBAL_EXACT_BREAKPOINT(_)                               (((_) >> 9) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * @brief RTM (restricted transactional memory) flag
         *
         * [Bit 11] Enables (when set) advanced debugging of RTM transactional regions. This advanced debugging is enabled only if
         * IA32_DEBUGCTL.RTM is also set.
         *
         * @see Vol3B[17.3.3(Debug Exceptions, Breakpoint Exceptions, and Restricted Transactional Memory (RTM))]
         */
        UINT64_t restricted_transactional_memory : 1;
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_BIT                      11
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_FLAG                     0x800
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_MASK                     0x01
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY(_)                       (((_) >> 11) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * @brief GD (general detect enable) flag
         *
         * [Bit 13] Enables (when set) debug-register protection, which causes a debug exception to be generated prior to any MOV
         * instruction that accesses a debug register. When such a condition is detected, the BD flag in debug status register DR6
         * is set prior to generating the exception. This condition is provided to support in-circuit emulators.
         * When the emulator needs to access the debug registers, emulator software can set the GD flag to prevent interference
         * from the program currently executing on the processor.
         * The processor clears the GD flag upon entering to the debug exception handler, to allow the handler access to the debug
         * registers.
         */
        UINT64_t general_detect : 1;
#define DR7_GENERAL_DETECT_BIT                                       13
#define DR7_GENERAL_DETECT_FLAG                                      0x2000
#define DR7_GENERAL_DETECT_MASK                                      0x01
#define DR7_GENERAL_DETECT(_)                                        (((_) >> 13) & 0x01)
        UINT64_t reserved3 : 2;

        /**
         * @brief R/W0 through R/W3 (read/write) fields (bits 16, 17, 20, 21, 24, 25, 28, and 29)
         *
         * [Bits 17:16] Specifies the breakpoint condition for the corresponding breakpoint. The DE (debug extensions) flag in
         * control register CR4 determines how the bits in the R/Wn fields are interpreted. When the DE flag is set, the processor
         * interprets bits as follows:
         * - 00 - Break on instruction execution only.
         * - 01 - Break on data writes only.
         * - 10 - Break on I/O reads or writes.
         * - 11 - Break on data reads or writes but not instruction fetches.
         * When the DE flag is clear, the processor interprets the R/Wn bits the same as for the Intel386(TM) and Intel486(TM)
         * processors, which is as follows:
         * - 00 - Break on instruction execution only.
         * - 01 - Break on data writes only.
         * - 10 - Undefined.
         * - 11 - Break on data reads or writes but not instruction fetches.
         */
        UINT64_t read_write_0 : 2;
#define DR7_READ_WRITE_0_BIT                                         16
#define DR7_READ_WRITE_0_FLAG                                        0x30000
#define DR7_READ_WRITE_0_MASK                                        0x03
#define DR7_READ_WRITE_0(_)                                          (((_) >> 16) & 0x03)

        /**
         * @brief LEN0 through LEN3 (Length) fields (bits 18, 19, 22, 23, 26, 27, 30, and 31)
         *
         * [Bits 19:18] Specify the size of the memory location at the address specified in the corresponding breakpoint address
         * register (DR0 through DR3). These fields are interpreted as follows:
         * - 00 - 1-byte length.
         * - 01 - 2-byte length.
         * - 10 - Undefined (or 8 byte length, see note below).
         * - 11 - 4-byte length.
         * If the corresponding RWn field in register DR7 is 00 (instruction execution), then the LENn field should also be 00. The
         * effect of using other lengths is undefined.
         *
         * @see Vol3B[17.2.5(Breakpoint Field Recognition)]
         */
        UINT64_t length_0 : 2;
#define DR7_LENGTH_0_BIT                                             18
#define DR7_LENGTH_0_FLAG                                            0xC0000
#define DR7_LENGTH_0_MASK                                            0x03
#define DR7_LENGTH_0(_)                                              (((_) >> 18) & 0x03)
        UINT64_t read_write_1 : 2;
#define DR7_READ_WRITE_1_BIT                                         20
#define DR7_READ_WRITE_1_FLAG                                        0x300000
#define DR7_READ_WRITE_1_MASK                                        0x03
#define DR7_READ_WRITE_1(_)                                          (((_) >> 20) & 0x03)
        UINT64_t length_1 : 2;
#define DR7_LENGTH_1_BIT                                             22
#define DR7_LENGTH_1_FLAG                                            0xC00000
#define DR7_LENGTH_1_MASK                                            0x03
#define DR7_LENGTH_1(_)                                              (((_) >> 22) & 0x03)
        UINT64_t read_write_2 : 2;
#define DR7_READ_WRITE_2_BIT                                         24
#define DR7_READ_WRITE_2_FLAG                                        0x3000000
#define DR7_READ_WRITE_2_MASK                                        0x03
#define DR7_READ_WRITE_2(_)                                          (((_) >> 24) & 0x03)
        UINT64_t length_2 : 2;
#define DR7_LENGTH_2_BIT                                             26
#define DR7_LENGTH_2_FLAG                                            0xC000000
#define DR7_LENGTH_2_MASK                                            0x03
#define DR7_LENGTH_2(_)                                              (((_) >> 26) & 0x03)
        UINT64_t read_write_3 : 2;
#define DR7_READ_WRITE_3_BIT                                         28
#define DR7_READ_WRITE_3_FLAG                                        0x30000000
#define DR7_READ_WRITE_3_MASK                                        0x03
#define DR7_READ_WRITE_3(_)                                          (((_) >> 28) & 0x03)
        UINT64_t length_3 : 2;
#define DR7_LENGTH_3_BIT                                             30
#define DR7_LENGTH_3_FLAG                                            0xC0000000
#define DR7_LENGTH_3_MASK                                            0x03
#define DR7_LENGTH_3(_)                                              (((_) >> 30) & 0x03)
        UINT64_t reserved4 : 32;
    };

    UINT64_t flags;
} dr7;

/**
 * @}
 */

 /**
  * @defgroup cpuid \
  *           CPUID
  *
  * @see Vol2A[3.2(CPUID)] (reference)
  * @{
  */
  /**
   * @brief Returns CPUID's Highest Value for Basic Processor Information and the Vendor Identification String
   *
   * When CPUID executes with EAX set to 0, the processor returns the highest value the CPUID recognizes for returning basic
   * processor information. The value is returned in the EAX register and is processor specific.
   * A vendor identification string is also returned in EBX, EDX, and ECX. For Intel processors, the string is "GenuineIntel"
   * and is expressed:
   * - EBX <- 756e6547h (* "Genu", with G in the low eight bits of BL *)
   * - EDX <- 49656e69h (* "ineI", with i in the low eight bits of DL *)
   * - ECX <- 6c65746eh (* "ntel", with n in the low eight bits of CL *)
   */
#define CPUID_SIGNATURE                                              0x00000000
typedef struct
{
    /**
     * @brief EAX
     *
     * Maximum Input Value for Basic CPUID Information.
     */
    UINT32_t max_cpuid_input_value;

    /**
     * @brief EBX
     *
     * "Genu"
     */
    UINT32_t ebx_value_genu;

    /**
     * @brief ECX
     *
     * "ntel"
     */
    UINT32_t ecx_value_ntel;

    /**
     * @brief EDX
     *
     * "ineI"
     */
    UINT32_t edx_value_inei;
} cpuid_eax_00;


/**
 * @brief Returns Model, Family, Stepping Information, Additional Information and Feature Information
 *
 * Returns:
 *   * Model, Family, Stepping Information in EAX
 *   * Additional Information in EBX
 *   * Feature Information in ECX and EDX
 */
#define CPUID_VERSION_INFORMATION                                    0x00000001
typedef struct
{
    /**
     * @brief When CPUID executes with EAX set to 01H, version information is returned in EAX
     */
    union
    {
        struct
        {
            UINT32_t stepping_id : 4;
#define CPUID_VERSION_INFORMATION_STEPPING_ID_BIT                    0
#define CPUID_VERSION_INFORMATION_STEPPING_ID_FLAG                   0x0F
#define CPUID_VERSION_INFORMATION_STEPPING_ID_MASK                   0x0F
#define CPUID_VERSION_INFORMATION_STEPPING_ID(_)                     (((_) >> 0) & 0x0F)
            UINT32_t model : 4;
#define CPUID_VERSION_INFORMATION_MODEL_BIT                          4
#define CPUID_VERSION_INFORMATION_MODEL_FLAG                         0xF0
#define CPUID_VERSION_INFORMATION_MODEL_MASK                         0x0F
#define CPUID_VERSION_INFORMATION_MODEL(_)                           (((_) >> 4) & 0x0F)
            UINT32_t family_id : 4;
#define CPUID_VERSION_INFORMATION_FAMILY_ID_BIT                      8
#define CPUID_VERSION_INFORMATION_FAMILY_ID_FLAG                     0xF00
#define CPUID_VERSION_INFORMATION_FAMILY_ID_MASK                     0x0F
#define CPUID_VERSION_INFORMATION_FAMILY_ID(_)                       (((_) >> 8) & 0x0F)

            /**
             * [Bits 13:12] - 0 - Original OEM Processor
             * - 1 - Intel OverDrive(R) Processor
             * - 2 - Dual processor (not applicable to Intel486 processors)
             * - 3 - Intel reserved
             */
            UINT32_t processor_type : 2;
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_BIT                 12
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_FLAG                0x3000
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_MASK                0x03
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE(_)                  (((_) >> 12) & 0x03)
            UINT32_t reserved1 : 2;

            /**
             * [Bits 19:16] The Extended Model ID needs to be examined only when the Family ID is 06H or 0FH.
             */
            UINT32_t extended_model_id : 4;
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_BIT              16
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_FLAG             0xF0000
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_MASK             0x0F
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID(_)               (((_) >> 16) & 0x0F)

            /**
             * [Bits 27:20] The Extended Family ID needs to be examined only when the Family ID is 0FH.
             */
            UINT32_t extended_family_id : 8;
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_BIT             20
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_FLAG            0xFF00000
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_MASK            0xFF
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID(_)              (((_) >> 20) & 0xFF)
            UINT32_t reserved2 : 4;
        };

        UINT32_t flags;
    } cpuid_version_information;

    /**
     * @brief When CPUID executes with EAX set to 01H, additional information is returned to the EBX register
     */
    union
    {
        struct
        {
            /**
             * [Bits 7:0] This number provides an entry into a brand string table that contains brand strings for IA-32 processors.
             * More information about this field is provided later in this section.
             */
            UINT32_t brand_index : 8;
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_BIT                 0
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_FLAG                0xFF
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_MASK                0xFF
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX(_)                  (((_) >> 0) & 0xFF)

            /**
             * @brief Value * 8 = cache line size in bytes; used also by CLFLUSHOPT
             *
             * [Bits 15:8] This number indicates the size of the cache line flushed by the CLFLUSH and CLFLUSHOPT instructions in
             * 8-byte increments. This field was introduced in the Pentium 4 processor.
             */
            UINT32_t clflush_line_size : 8;
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_BIT           8
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_FLAG          0xFF00
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_MASK          0xFF
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE(_)            (((_) >> 8) & 0xFF)

            /**
             * [Bits 23:16] Maximum number of addressable IDs for logical processors in this physical package.
             *
             * @remarks The nearest power-of-2 integer that is not smaller than EBX[23:16] is the number of unique initial APIC IDs
             *          reserved for addressing different logical processors in a physical package. This field is only valid if
             *          CPUID.1.EDX.HTT[bit 28] = 1.
             */
            UINT32_t max_addressable_ids : 8;
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_BIT         16
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_FLAG        0xFF0000
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_MASK        0xFF
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS(_)          (((_) >> 16) & 0xFF)

            /**
             * [Bits 31:24] This number is the 8-bit ID that is assigned to the local APIC on the processor during power up. This field
             * was introduced in the Pentium 4 processor.
             */
            UINT32_t initial_apic_id : 8;
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_BIT             24
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_FLAG            0xFF000000
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_MASK            0xFF
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID(_)              (((_) >> 24) & 0xFF)
        };

        UINT32_t flags;
    } cpuid_additional_information;

    /**
     * @brief When CPUID executes with EAX set to 01H, feature information is returned in ECX and EDX
     */
    union
    {
        struct
        {
            /**
             * @brief Streaming SIMD Extensions 3 (SSE3)
             *
             * [Bit 0] A value of 1 indicates the processor supports this technology.
             */
            UINT32_t streaming_simd_extensions_3 : 1;
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_BIT 0
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_FLAG 0x01
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3(_) (((_) >> 0) & 0x01)

            /**
             * @brief PCLMULQDQ instruction
             *
             * [Bit 1] A value of 1 indicates the processor supports the PCLMULQDQ instruction.
             */
            UINT32_t pclmulqdq_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_BIT      1
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_FLAG     0x02
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_MASK     0x01
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION(_)       (((_) >> 1) & 0x01)

            /**
             * @brief 64-bit DS Area
             *
             * [Bit 2] A value of 1 indicates the processor supports DS area using 64-bit layout.
             */
            UINT32_t ds_area_64bit_layout : 1;
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_BIT       2
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_FLAG      0x04
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_MASK      0x01
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT(_)        (((_) >> 2) & 0x01)

            /**
             * @brief MONITOR/MWAIT instruction
             *
             * [Bit 3] A value of 1 indicates the processor supports this feature.
             */
            UINT32_t monitor_mwait_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_BIT  3
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_FLAG 0x08
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION(_)   (((_) >> 3) & 0x01)

            /**
             * @brief CPL Qualified Debug Store
             *
             * [Bit 4] A value of 1 indicates the processor supports the extensions to the Debug Store feature to allow for branch
             * message storage qualified by CPL.
             */
            UINT32_t cpl_qualified_debug_store : 1;
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_BIT  4
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_FLAG 0x10
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE(_)   (((_) >> 4) & 0x01)

            /**
             * @brief Virtual Machine Extensions
             *
             * [Bit 5] A value of 1 indicates that the processor supports this technology.
             */
            UINT32_t virtual_machine_extensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_BIT 5
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_FLAG 0x20
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS(_)  (((_) >> 5) & 0x01)

            /**
             * @brief Safer Mode Extensions
             *
             * [Bit 6] A value of 1 indicates that the processor supports this technology.
             *
             * @see Vol2[6(SAFER MODE EXTENSIONS REFERENCE)]
             */
            UINT32_t safer_mode_extensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_BIT      6
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_FLAG     0x40
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_MASK     0x01
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS(_)       (((_) >> 6) & 0x01)

            /**
             * @brief Enhanced Intel SpeedStep(R) technology
             *
             * [Bit 7] A value of 1 indicates that the processor supports this technology.
             */
            UINT32_t enhanced_intel_speedstep_technology : 1;
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_BIT 7
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_FLAG 0x80
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY(_) (((_) >> 7) & 0x01)

            /**
             * @brief Thermal Monitor 2
             *
             * [Bit 8] A value of 1 indicates whether the processor supports this technology.
             */
            UINT32_t thermal_monitor_2 : 1;
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_BIT          8
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_FLAG         0x100
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_MASK         0x01
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2(_)           (((_) >> 8) & 0x01)

            /**
             * @brief Supplemental Streaming SIMD Extensions 3 (SSSE3)
             *
             * [Bit 9] A value of 1 indicates the presence of the Supplemental Streaming SIMD Extensions 3 (SSSE3). A value of 0
             * indicates the instruction extensions are not present in the processor.
             */
            UINT32_t supplemental_streaming_simd_extensions_3 : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_BIT 9
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_FLAG 0x200
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3(_) (((_) >> 9) & 0x01)

            /**
             * @brief L1 Context ID
             *
             * [Bit 10] A value of 1 indicates the L1 data cache mode can be set to either adaptive mode or shared mode. A value of 0
             * indicates this feature is not supported. See definition of the IA32_MISC_ENABLE MSR Bit 24 (L1 Data Cache Context Mode)
             * for details.
             */
            UINT32_t l1_context_id : 1;
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_BIT              10
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_FLAG             0x400
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID(_)               (((_) >> 10) & 0x01)

            /**
             * @brief IA32_DEBUG_INTERFACE MSR for silicon debug
             *
             * [Bit 11] A value of 1 indicates the processor supports IA32_DEBUG_INTERFACE MSR for silicon debug.
             */
            UINT32_t silicon_debug : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_BIT              11
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_FLAG             0x800
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG(_)               (((_) >> 11) & 0x01)

            /**
             * @brief FMA extensions using YMM state
             *
             * [Bit 12] A value of 1 indicates the processor supports FMA (Fused Multiple Add) extensions using YMM state.
             */
            UINT32_t fma_extensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_BIT             12
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_FLAG            0x1000
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_MASK            0x01
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS(_)              (((_) >> 12) & 0x01)

            /**
             * @brief CMPXCHG16B instruction
             *
             * [Bit 13] A value of 1 indicates that the feature is available.
             */
            UINT32_t cmpxchg16b_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_BIT     13
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_FLAG    0x2000
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_MASK    0x01
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION(_)      (((_) >> 13) & 0x01)

            /**
             * @brief xTPR Update Control
             *
             * [Bit 14] A value of 1 indicates that the processor supports changing IA32_MISC_ENABLE[bit 23].
             */
            UINT32_t xtpr_update_control : 1;
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_BIT        14
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_FLAG       0x4000
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_MASK       0x01
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL(_)         (((_) >> 14) & 0x01)

            /**
             * @brief Perfmon and Debug Capability
             *
             * [Bit 15] A value of 1 indicates the processor supports the performance and debug feature indication MSR
             * IA32_PERF_CAPABILITIES.
             */
            UINT32_t perfmon_and_debug_capability : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_BIT 15
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_FLAG 0x8000
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY(_) (((_) >> 15) & 0x01)
            UINT32_t reserved1 : 1;

            /**
             * @brief Process-context identifiers
             *
             * [Bit 17] A value of 1 indicates that the processor supports PCIDs and that software may set CR4.PCIDE to 1.
             */
            UINT32_t process_context_identifiers : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_BIT 17
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_FLAG 0x20000
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS(_) (((_) >> 17) & 0x01)

            /**
             * @brief Direct Cache Access
             *
             * [Bit 18] A value of 1 indicates the processor supports the ability to prefetch data from a memory mapped device (Direct
             * Cache Access).
             */
            UINT32_t direct_cache_access : 1;
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_BIT        18
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_FLAG       0x40000
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_MASK       0x01
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS(_)         (((_) >> 18) & 0x01)

            /**
             * @brief SSE4.1 support
             *
             * [Bit 19] A value of 1 indicates that the processor supports SSE4.1.
             */
            UINT32_t sse41_support : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_BIT              19
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_FLAG             0x80000
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT(_)               (((_) >> 19) & 0x01)

            /**
             * @brief SSE4.2 support
             *
             * [Bit 20] A value of 1 indicates that the processor supports SSE4.2.
             */
            UINT32_t sse42_support : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_BIT              20
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_FLAG             0x100000
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT(_)               (((_) >> 20) & 0x01)

            /**
             * @brief x2APIC support
             *
             * [Bit 21] A value of 1 indicates that the processor supports x2APIC feature.
             */
            UINT32_t x2apic_support : 1;
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_BIT             21
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_FLAG            0x200000
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_MASK            0x01
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT(_)              (((_) >> 21) & 0x01)

            /**
             * @brief MOVBE instruction
             *
             * [Bit 22] A value of 1 indicates that the processor supports MOVBE instruction.
             */
            UINT32_t movbe_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_BIT          22
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_FLAG         0x400000
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_MASK         0x01
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION(_)           (((_) >> 22) & 0x01)

            /**
             * @brief POPCNT instruction
             *
             * [Bit 23] A value of 1 indicates that the processor supports the POPCNT instruction.
             */
            UINT32_t popcnt_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_BIT         23
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_FLAG        0x800000
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_MASK        0x01
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION(_)          (((_) >> 23) & 0x01)

            /**
             * @brief TSC Deadline
             *
             * [Bit 24] A value of 1 indicates that the processor's local APIC timer supports one-shot operation using a TSC deadline
             * value.
             */
            UINT32_t tsc_deadline : 1;
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_BIT               24
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_FLAG              0x1000000
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_MASK              0x01
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE(_)                (((_) >> 24) & 0x01)

            /**
             * @brief AESNI instruction extensions
             *
             * [Bit 25] A value of 1 indicates that the processor supports the AESNI instruction extensions.
             */
            UINT32_t aesni_instruction_extensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_BIT 25
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_FLAG 0x2000000
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS(_) (((_) >> 25) & 0x01)

            /**
             * @brief XSAVE/XRSTOR instruction extensions
             *
             * [Bit 26] A value of 1 indicates that the processor supports the XSAVE/XRSTOR processor extended states feature, the
             * XSETBV/XGETBV instructions, and XCR0.
             */
            UINT32_t xsave_xrstor_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_BIT   26
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_FLAG  0x4000000
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_MASK  0x01
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION(_)    (((_) >> 26) & 0x01)

            /**
             * @brief CR4.OSXSAVE[bit 18] set
             *
             * [Bit 27] A value of 1 indicates that the OS has set CR4.OSXSAVE[bit 18] to enable XSETBV/XGETBV instructions to access
             * XCR0 and to support processor extended state management using XSAVE/XRSTOR.
             */
            UINT32_t osx_save : 1;
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_BIT                   27
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_FLAG                  0x8000000
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_MASK                  0x01
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE(_)                    (((_) >> 27) & 0x01)

            /**
             * @brief AVX instruction extensions support
             *
             * [Bit 28] A value of 1 indicates the processor supports the AVX instruction extensions.
             */
            UINT32_t avx_support : 1;
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_BIT                28
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_FLAG               0x10000000
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_MASK               0x01
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT(_)                 (((_) >> 28) & 0x01)

            /**
             * @brief 16-bit floating-point conversion instructions support
             *
             * [Bit 29] A value of 1 indicates that processor supports 16-bit floating-point conversion instructions.
             */
            UINT32_t half_precision_conversion_instructions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_BIT 29
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_FLAG 0x20000000
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS(_) (((_) >> 29) & 0x01)

            /**
             * @brief RDRAND instruction support
             *
             * [Bit 30] A value of 1 indicates that processor supports RDRAND instruction.
             */
            UINT32_t rdrand_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_BIT         30
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_FLAG        0x40000000
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_MASK        0x01
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION(_)          (((_) >> 30) & 0x01)
            UINT32_t reserved2 : 1;
        };

        UINT32_t flags;
    } cpuid_feature_information_ecx;

    /**
     * @brief When CPUID executes with EAX set to 01H, feature information is returned in ECX and EDX
     */
    union
    {
        struct
        {
            /**
             * @brief Floating Point Unit On-Chip
             *
             * [Bit 0] The processor contains an x87 FPU.
             */
            UINT32_t floating_point_unit_on_chip : 1;
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_BIT 0
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_FLAG 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP(_) (((_) >> 0) & 0x01)

            /**
             * @brief Virtual 8086 Mode Enhancements
             *
             * [Bit 1] Virtual 8086 mode enhancements, including CR4.VME for controlling the feature, CR4.PVI for protected mode
             * virtual interrupts, software interrupt indirection, expansion of the TSS with the software indirection bitmap, and
             * EFLAGS.VIF and EFLAGS.VIP flags.
             */
            UINT32_t virtual_8086_mode_enhancements : 1;
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_BIT 1
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_FLAG 0x02
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS(_) (((_) >> 1) & 0x01)

            /**
             * @brief Debugging Extensions
             *
             * [Bit 2] Support for I/O breakpoints, including CR4.DE for controlling the feature, and optional trapping of accesses to
             * DR4 and DR5.
             */
            UINT32_t debugging_extensions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_BIT       2
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_FLAG      0x04
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_MASK      0x01
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS(_)        (((_) >> 2) & 0x01)

            /**
             * @brief Page Size Extension
             *
             * [Bit 3] Large pages of size 4 MByte are supported, including CR4.PSE for controlling the feature, the defined dirty bit
             * in PDE (Page Directory Entries), optional reserved bit trapping in CR3, PDEs, and PTEs.
             */
            UINT32_t page_size_extension : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_BIT        3
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_FLAG       0x08
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_MASK       0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION(_)         (((_) >> 3) & 0x01)

            /**
             * @brief Time Stamp Counter
             *
             * [Bit 4] The RDTSC instruction is supported, including CR4.TSD for controlling privilege.
             */
            UINT32_t timestamp_counter : 1;
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_BIT          4
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_FLAG         0x10
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_MASK         0x01
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER(_)           (((_) >> 4) & 0x01)

            /**
             * @brief Model Specific Registers RDMSR and WRMSR Instructions
             *
             * [Bit 5] The RDMSR and WRMSR instructions are supported. Some of the MSRs are implementation dependent.
             */
            UINT32_t rdmsr_wrmsr_instructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_BIT   5
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_FLAG  0x20
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_MASK  0x01
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS(_)    (((_) >> 5) & 0x01)

            /**
             * @brief Physical Address Extension
             *
             * [Bit 6] Physical addresses greater than 32 bits are supported: extended page table entry formats, an extra level in the
             * page translation tables is defined, 2-MByte pages are supported instead of 4 Mbyte pages if PAE bit is 1.
             */
            UINT32_t physical_address_extension : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_BIT 6
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_FLAG 0x40
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION(_)  (((_) >> 6) & 0x01)

            /**
             * @brief Machine Check Exception
             *
             * [Bit 7] Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the feature. This feature does not
             * define the model-specific implementations of machine-check error logging, reporting, and processor shutdowns. Machine
             * Check exception handlers may have to depend on processor version to do model specific processing of the exception, or
             * test for the presence of the Machine Check feature.
             */
            UINT32_t machine_check_exception : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_BIT    7
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_FLAG   0x80
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_MASK   0x01
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION(_)     (((_) >> 7) & 0x01)

            /**
             * @brief CMPXCHG8B Instruction
             *
             * [Bit 8] The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly locked and atomic).
             */
            UINT32_t cmpxchg8b : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_BIT                  8
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_FLAG                 0x100
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_MASK                 0x01
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B(_)                   (((_) >> 8) & 0x01)

            /**
             * @brief APIC On-Chip
             *
             * [Bit 9] The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to memory mapped
             * commands in the physical address range FFFE0000H to FFFE0FFFH (by default - some processors permit the APIC to be
             * relocated).
             */
            UINT32_t apic_on_chip : 1;
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_BIT               9
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_FLAG              0x200
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_MASK              0x01
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP(_)                (((_) >> 9) & 0x01)
            UINT32_t reserved1 : 1;

            /**
             * @brief SYSENTER and SYSEXIT Instructions
             *
             * [Bit 11] The SYSENTER and SYSEXIT and associated MSRs are supported.
             */
            UINT32_t sysenter_sysexit_instructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_BIT 11
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_FLAG 0x800
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS(_) (((_) >> 11) & 0x01)

            /**
             * @brief Memory Type Range Registers
             *
             * [Bit 12] MTRRs are supported. The MTRRcap MSR contains feature bits that describe what memory types are supported, how
             * many variable MTRRs are supported, and whether fixed MTRRs are supported.
             */
            UINT32_t memory_type_range_registers : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_BIT 12
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_FLAG 0x1000
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS(_) (((_) >> 12) & 0x01)

            /**
             * @brief Page Global Bit
             *
             * [Bit 13] The global bit is supported in paging-structure entries that map a page, indicating TLB entries that are common
             * to different processes and need not be flushed. The CR4.PGE bit controls this feature.
             */
            UINT32_t page_global_bit : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_BIT            13
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_FLAG           0x2000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_MASK           0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT(_)             (((_) >> 13) & 0x01)

            /**
             * @brief Machine Check Architecture
             *
             * [Bit 14] A value of 1 indicates the Machine Check Architecture of reporting machine errors is supported. The MCG_CAP MSR
             * contains feature bits describing how many banks of error reporting MSRs are supported.
             */
            UINT32_t machine_check_architecture : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_BIT 14
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_FLAG 0x4000
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE(_)  (((_) >> 14) & 0x01)

            /**
             * @brief Conditional Move Instructions
             *
             * [Bit 15] The conditional move instruction CMOV is supported. In addition, if x87 FPU is present as indicated by the
             * CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported
             */
            UINT32_t conditional_move_instructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_BIT 15
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_FLAG 0x8000
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS(_) (((_) >> 15) & 0x01)

            /**
             * @brief Page Attribute Table
             *
             * [Bit 16] Page Attribute Table is supported. This feature augments the Memory Type Range Registers (MTRRs), allowing an
             * operating system to specify attributes of memory accessed through a linear address on a 4KB granularity.
             */
            UINT32_t page_attribute_table : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_BIT       16
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_FLAG      0x10000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_MASK      0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE(_)        (((_) >> 16) & 0x01)

            /**
             * @brief 36-Bit Page Size Extension
             *
             * [Bit 17] 4-MByte pages addressing physical memory beyond 4 GBytes are supported with 32-bit paging. This feature
             * indicates that upper bits of the physical address of a 4-MByte page are encoded in bits 20:13 of the page-directory
             * entry. Such physical addresses are limited by MAXPHYADDR and may be up to 40 bits in size.
             */
            UINT32_t page_size_extension_36bit : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_BIT  17
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_FLAG 0x20000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT(_)   (((_) >> 17) & 0x01)

            /**
             * @brief Processor Serial Number
             *
             * [Bit 18] The processor supports the 96-bit processor identification number feature and the feature is enabled.
             */
            UINT32_t processor_serial_number : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_BIT    18
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_FLAG   0x40000
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_MASK   0x01
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER(_)     (((_) >> 18) & 0x01)

            /**
             * @brief CLFLUSH Instruction
             *
             * [Bit 19] CLFLUSH Instruction is supported.
             */
            UINT32_t clflush : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_BIT                    19
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_FLAG                   0x80000
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_MASK                   0x01
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH(_)                     (((_) >> 19) & 0x01)
            UINT32_t reserved2 : 1;

            /**
             * @brief Debug Store
             *
             * [Bit 21] The processor supports the ability to write debug information into a memory resident buffer. This feature is
             * used by the branch trace store (BTS) and processor event-based sampling (PEBS) facilities.
             *
             * @see Vol3C[23(INTRODUCTION TO VIRTUAL MACHINE EXTENSIONS)]
             */
            UINT32_t debug_store : 1;
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_BIT                21
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_FLAG               0x200000
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_MASK               0x01
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE(_)                 (((_) >> 21) & 0x01)

            /**
             * @brief Thermal Monitor and Software Controlled Clock Facilities
             *
             * [Bit 22] The processor implements internal MSRs that allow processor temperature to be monitored and processor
             * performance to be modulated in predefined duty cycles under software control.
             */
            UINT32_t thermal_control_msrs_for_acpi : 1;
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_BIT 22
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_FLAG 0x400000
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI(_) (((_) >> 22) & 0x01)

            /**
             * @brief Intel MMX Technology
             *
             * [Bit 23] The processor supports the Intel MMX technology.
             */
            UINT32_t mmx_support : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_BIT                23
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_FLAG               0x800000
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_MASK               0x01
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT(_)                 (((_) >> 23) & 0x01)

            /**
             * @brief FXSAVE and FXRSTOR Instructions
             *
             * [Bit 24] The FXSAVE and FXRSTOR instructions are supported for fast save and restore of the floating point context.
             * Presence of this bit also indicates that CR4.OSFXSR is available for an operating system to indicate that it supports
             * the FXSAVE and FXRSTOR instructions.
             */
            UINT32_t fxsave_fxrstor_instructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_BIT 24
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_FLAG 0x1000000
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS(_) (((_) >> 24) & 0x01)

            /**
             * @brief SSE extensions support
             *
             * [Bit 25] The processor supports the SSE extensions.
             */
            UINT32_t sse_support : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_BIT                25
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_FLAG               0x2000000
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_MASK               0x01
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT(_)                 (((_) >> 25) & 0x01)

            /**
             * @brief SSE2 extensions support
             *
             * [Bit 26] The processor supports the SSE2 extensions.
             */
            UINT32_t sse2_support : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_BIT               26
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_FLAG              0x4000000
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_MASK              0x01
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT(_)                (((_) >> 26) & 0x01)

            /**
             * @brief Self Snoop
             *
             * [Bit 27] The processor supports the management of conflicting memory types by performing a snoop of its own cache
             * structure for transactions issued to the bus.
             */
            UINT32_t self_snoop : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_BIT                 27
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_FLAG                0x8000000
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_MASK                0x01
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP(_)                  (((_) >> 27) & 0x01)

            /**
             * @brief Max APIC IDs reserved field is Valid
             *
             * [Bit 28] A value of 0 for HTT indicates there is only a single logical processor in the package and software should
             * assume only a single APIC ID is reserved. A value of 1 for HTT indicates the value in CPUID.1.EBX[23:16] (the Maximum
             * number of addressable IDs for logical processors in this package) is valid for the package.
             */
            UINT32_t hyper_threading_technology : 1;
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_BIT 28
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_FLAG 0x10000000
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY(_)  (((_) >> 28) & 0x01)

            /**
             * @brief Thermal Monitor
             *
             * [Bit 29] The processor implements the thermal monitor automatic thermal control circuitry (TCC).
             */
            UINT32_t thermal_monitor : 1;
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_BIT            29
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_FLAG           0x20000000
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_MASK           0x01
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR(_)             (((_) >> 29) & 0x01)
            UINT32_t reserved3 : 1;

            /**
             * @brief Pending Break Enable
             *
             * [Bit 31] The processor supports the use of the FERR\#/PBE\# pin when the processor is in the stop-clock state (STPCLK\#
             * is asserted) to signal the processor that an interrupt is pending and that the processor should return to normal
             * operation to handle the interrupt. Bit 10 (PBE enable) in the IA32_MISC_ENABLE MSR enables this capability.
             */
            UINT32_t pending_break_enable : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_BIT       31
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_FLAG      0x80000000
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_MASK      0x01
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE(_)        (((_) >> 31) & 0x01)
        };

        UINT32_t flags;
    } cpuid_feature_information_edx;

} cpuid_eax_01;


/**
 * @brief Deterministic Cache Parameters Leaf
 *
 * When CPUID executes with EAX set to 04H and ECX contains an index value, the processor returns encoded data that
 * describe a set of deterministic cache parameters (for the cache level associated with the input in ECX). Valid index
 * values start from 0.
 * Software can enumerate the deterministic cache parameters for each level of the cache hierarchy starting with an index
 * value of 0, until the parameters report the value associated with the cache type field is 0. The architecturally defined
 * fields reported by deterministic cache parameters are documented in Table 3-8.
 * This Cache Size in Bytes
 * - = (Ways + 1) * (Partitions + 1) * (Line_Size + 1) * (Sets + 1)
 * - = (EBX[31:22] + 1) * (EBX[21:12] + 1) * (EBX[11:0] + 1) * (ECX + 1)
 * The CPUID leaf 04H also reports data that can be used to derive the topology of processor cores in a physical package.
 * This information is constant for all valid index values. Software can query the raw data reported by executing CPUID
 * with EAX=04H and ECX=0 and use it as part of the topology enumeration algorithm.
 *
 * @see Vol3A[8(Multiple-Processor Management)]
 */
#define CPUID_CACHE_PARAMETERS                                       0x00000004
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 4:0] - 0 = Null - No more caches.
             * - 1 = Data Cache.
             * - 2 = Instruction Cache.
             * - 3 = Unified Cache.
             * - 4-31 = Reserved.
             */
            UINT32_t cache_type_field : 5;
#define CPUID_EAX_CACHE_TYPE_FIELD_BIT                               0
#define CPUID_EAX_CACHE_TYPE_FIELD_FLAG                              0x1F
#define CPUID_EAX_CACHE_TYPE_FIELD_MASK                              0x1F
#define CPUID_EAX_CACHE_TYPE_FIELD(_)                                (((_) >> 0) & 0x1F)

            /**
             * [Bits 7:5] Cache Level (starts at 1).
             */
            UINT32_t cache_level : 3;
#define CPUID_EAX_CACHE_LEVEL_BIT                                    5
#define CPUID_EAX_CACHE_LEVEL_FLAG                                   0xE0
#define CPUID_EAX_CACHE_LEVEL_MASK                                   0x07
#define CPUID_EAX_CACHE_LEVEL(_)                                     (((_) >> 5) & 0x07)

            /**
             * [Bit 8] Self Initializing cache level (does not need SW initialization).
             */
            UINT32_t self_initializing_cache_level : 1;
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_BIT                  8
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_FLAG                 0x100
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_MASK                 0x01
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL(_)                   (((_) >> 8) & 0x01)

            /**
             * [Bit 9] Fully Associative cache.
             */
            UINT32_t fully_associative_cache : 1;
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_BIT                        9
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_FLAG                       0x200
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_MASK                       0x01
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE(_)                         (((_) >> 9) & 0x01)
            UINT32_t reserved1 : 4;

            /**
             * [Bits 25:14] Maximum number of addressable IDs for logical processors sharing this cache.
             *
             * @note Add one to the return value to get the result.
             *       The nearest power-of-2 integer that is not smaller than (1 + EAX[25:14]) is the number of unique initial APIC IDs
             *       reserved for addressing different logical processors sharing this cache.
             */
            UINT32_t max_addressable_ids_for_logical_processors_sharing_this_cache : 12;
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_BIT 14
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_FLAG 0x3FFC000
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_MASK 0xFFF
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE(_) (((_) >> 14) & 0xFFF)

            /**
             * [Bits 31:26] Maximum number of addressable IDs for processor cores in the physical package.
             *
             * @note Add one to the return value to get the result.
             *       The nearest power-of-2 integer that is not smaller than (1 + EAX[31:26]) is the number of unique Core_IDs reserved for
             *       addressing different processor cores in a physical package. Core ID is a subset of bits of the initial APIC ID.
             *       The returned value is constant for valid initial values in ECX. Valid ECX values start from 0.
             */
            UINT32_t max_addressable_ids_for_processor_cores_in_physical_package : 6;
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_BIT 26
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_FLAG 0xFC000000
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_MASK 0x3F
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE(_) (((_) >> 26) & 0x3F)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 11:0] System Coherency Line Size.
             *
             * @note Add one to the return value to get the result.
             */
            UINT32_t system_coherency_line_size : 12;
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_BIT                     0
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_FLAG                    0xFFF
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_MASK                    0xFFF
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE(_)                      (((_) >> 0) & 0xFFF)

            /**
             * [Bits 21:12] Physical Line partitions.
             *
             * @note Add one to the return value to get the result.
             */
            UINT32_t physical_line_partitions : 10;
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_BIT                       12
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_FLAG                      0x3FF000
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_MASK                      0x3FF
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS(_)                        (((_) >> 12) & 0x3FF)

            /**
             * [Bits 31:22] Ways of associativity.
             *
             * @note Add one to the return value to get the result.
             */
            UINT32_t ways_of_associativity : 10;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_BIT                          22
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_FLAG                         0xFFC00000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_MASK                         0x3FF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY(_)                           (((_) >> 22) & 0x3FF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Number of Sets.
             *
             * @note Add one to the return value to get the result.
             */
            UINT32_t number_of_sets : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT                                 0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * @brief Write-Back Invalidate/Invalidate
             *
             * [Bit 0] - 0 = WBINVD/INVD from threads sharing this cache acts upon lower level caches for threads sharing this cache.
             * - 1 = WBINVD/INVD is not guaranteed to act upon lower level caches of non-originating threads sharing this cache.
             */
            UINT32_t write_back_invalidate : 1;
#define CPUID_EDX_WRITE_BACK_INVALIDATE_BIT                          0
#define CPUID_EDX_WRITE_BACK_INVALIDATE_FLAG                         0x01
#define CPUID_EDX_WRITE_BACK_INVALIDATE_MASK                         0x01
#define CPUID_EDX_WRITE_BACK_INVALIDATE(_)                           (((_) >> 0) & 0x01)

            /**
             * @brief Cache Inclusiveness
             *
             * [Bit 1] - 0 = Cache is not inclusive of lower cache levels.
             * - 1 = Cache is inclusive of lower cache levels.
             */
            UINT32_t cache_inclusiveness : 1;
#define CPUID_EDX_CACHE_INCLUSIVENESS_BIT                            1
#define CPUID_EDX_CACHE_INCLUSIVENESS_FLAG                           0x02
#define CPUID_EDX_CACHE_INCLUSIVENESS_MASK                           0x01
#define CPUID_EDX_CACHE_INCLUSIVENESS(_)                             (((_) >> 1) & 0x01)

            /**
             * @brief Complex Cache Indexing
             *
             * [Bit 2] - 0 = Direct mapped cache.
             * - 1 = A complex function is used to index the cache, potentially using all address bits.
             */
            UINT32_t complex_cache_indexing : 1;
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_BIT                         2
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_FLAG                        0x04
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_MASK                        0x01
#define CPUID_EDX_COMPLEX_CACHE_INDEXING(_)                          (((_) >> 2) & 0x01)
            UINT32_t reserved1 : 29;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_04;


/**
 * @brief MONITOR/MWAIT Leaf
 *
 * When CPUID executes with EAX set to 05H, the processor returns information about features available to MONITOR/MWAIT
 * instructions. The MONITOR instruction is used for address-range monitoring in conjunction with MWAIT instruction. The
 * MWAIT instruction optionally provides additional extensions for advanced power management.
 */
#define CPUID_MONITOR_MWAIT                                          0x00000005
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 15:0] Smallest monitor-line size in bytes (default is processor's monitor granularity).
             */
            UINT32_t smallest_monitor_line_size : 16;
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_BIT                     0
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_FLAG                    0xFFFF
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_MASK                    0xFFFF
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE(_)                      (((_) >> 0) & 0xFFFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Largest monitor-line size in bytes (default is processor's monitor granularity).
             */
            UINT32_t largest_monitor_line_size : 16;
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_BIT                      0
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_FLAG                     0xFFFF
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_MASK                     0xFFFF
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE(_)                       (((_) >> 0) & 0xFFFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] Enumeration of Monitor-Mwait extensions (beyond EAX and EBX registers) supported.
             */
            UINT32_t enumeration_of_monitor_mwait_extensions : 1;
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_BIT        0
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_FLAG       0x01
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_MASK       0x01
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS(_)         (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Supports treating interrupts as break-event for MWAIT, even when interrupts disabled.
             */
            UINT32_t supports_treating_interrupts_as_break_event_for_mwait : 1;
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_BIT 1
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_FLAG 0x02
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_MASK 0x01
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT(_) (((_) >> 1) & 0x01)
            UINT32_t reserved1 : 30;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 3:0] Number of C0 sub C-states supported using MWAIT.
             */
            UINT32_t number_of_c0_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_BIT                      0
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_FLAG                     0x0F
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES(_)                       (((_) >> 0) & 0x0F)

            /**
             * [Bits 7:4] Number of C1 sub C-states supported using MWAIT.
             */
            UINT32_t number_of_c1_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_BIT                      4
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_FLAG                     0xF0
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES(_)                       (((_) >> 4) & 0x0F)

            /**
             * [Bits 11:8] Number of C2 sub C-states supported using MWAIT.
             */
            UINT32_t number_of_c2_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_BIT                      8
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_FLAG                     0xF00
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES(_)                       (((_) >> 8) & 0x0F)

            /**
             * [Bits 15:12] Number of C3 sub C-states supported using MWAIT.
             */
            UINT32_t number_of_c3_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_BIT                      12
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_FLAG                     0xF000
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES(_)                       (((_) >> 12) & 0x0F)

            /**
             * [Bits 19:16] Number of C4 sub C-states supported using MWAIT.
             */
            UINT32_t number_of_c4_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_BIT                      16
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_FLAG                     0xF0000
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES(_)                       (((_) >> 16) & 0x0F)

            /**
             * [Bits 23:20] Number of C5 sub C-states supported using MWAIT.
             */
            UINT32_t number_of_c5_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_BIT                      20
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_FLAG                     0xF00000
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES(_)                       (((_) >> 20) & 0x0F)

            /**
             * [Bits 27:24] Number of C6 sub C-states supported using MWAIT.
             */
            UINT32_t number_of_c6_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_BIT                      24
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_FLAG                     0xF000000
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES(_)                       (((_) >> 24) & 0x0F)

            /**
             * [Bits 31:28] Number of C7 sub C-states supported using MWAIT.
             */
            UINT32_t number_of_c7_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_BIT                      28
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_FLAG                     0xF0000000
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES(_)                       (((_) >> 28) & 0x0F)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_05;


/**
 * @brief Thermal and Power Management Leaf
 *
 * When CPUID executes with EAX set to 06H, the processor returns information about thermal and power management features.
 */
#define CPUID_THERMAL_AND_POWER_MANAGEMENT                           0x00000006
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bit 0] Digital temperature sensor is supported if set.
             */
            UINT32_t temperature_sensor_supported : 1;
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_BIT                   0
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_FLAG                  0x01
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_MASK                  0x01
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED(_)                    (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Intel Turbo Boost Technology available (see description of IA32_MISC_ENABLE[38]).
             */
            UINT32_t intel_turbo_boost_technology_available : 1;
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_BIT         1
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_FLAG        0x02
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_MASK        0x01
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE(_)          (((_) >> 1) & 0x01)

            /**
             * [Bit 2] ARAT. APIC-Timer-always-running feature is supported if set.
             */
            UINT32_t apic_timer_always_running : 1;
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_BIT                      2
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_FLAG                     0x04
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_MASK                     0x01
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING(_)                       (((_) >> 2) & 0x01)
            UINT32_t reserved1 : 1;

            /**
             * [Bit 4] PLN. Power limit notification controls are supported if set.
             */
            UINT32_t power_limit_notification : 1;
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_BIT                       4
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_FLAG                      0x10
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_MASK                      0x01
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION(_)                        (((_) >> 4) & 0x01)

            /**
             * [Bit 5] ECMD. Clock modulation duty cycle extension is supported if set.
             */
            UINT32_t clock_modulation_duty : 1;
#define CPUID_EAX_CLOCK_MODULATION_DUTY_BIT                          5
#define CPUID_EAX_CLOCK_MODULATION_DUTY_FLAG                         0x20
#define CPUID_EAX_CLOCK_MODULATION_DUTY_MASK                         0x01
#define CPUID_EAX_CLOCK_MODULATION_DUTY(_)                           (((_) >> 5) & 0x01)

            /**
             * [Bit 6] PTM. Package thermal management is supported if set.
             */
            UINT32_t package_thermal_management : 1;
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_BIT                     6
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_FLAG                    0x40
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_MASK                    0x01
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT(_)                      (((_) >> 6) & 0x01)

            /**
             * [Bit 7] HWP. HWP base registers (IA32_PM_ENABLE[bit 0], IA32_HWP_CAPABILITIES, IA32_HWP_REQUEST, IA32_HWP_STATUS) are
             * supported if set.
             */
            UINT32_t hwp_base_registers : 1;
#define CPUID_EAX_HWP_BASE_REGISTERS_BIT                             7
#define CPUID_EAX_HWP_BASE_REGISTERS_FLAG                            0x80
#define CPUID_EAX_HWP_BASE_REGISTERS_MASK                            0x01
#define CPUID_EAX_HWP_BASE_REGISTERS(_)                              (((_) >> 7) & 0x01)

            /**
             * [Bit 8] HWP_Notification. IA32_HWP_INTERRUPT MSR is supported if set.
             */
            UINT32_t hwp_notification : 1;
#define CPUID_EAX_HWP_NOTIFICATION_BIT                               8
#define CPUID_EAX_HWP_NOTIFICATION_FLAG                              0x100
#define CPUID_EAX_HWP_NOTIFICATION_MASK                              0x01
#define CPUID_EAX_HWP_NOTIFICATION(_)                                (((_) >> 8) & 0x01)

            /**
             * [Bit 9] HWP_Activity_Window. IA32_HWP_REQUEST[bits 41:32] is supported if set.
             */
            UINT32_t hwp_activity_window : 1;
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_BIT                            9
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_FLAG                           0x200
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_MASK                           0x01
#define CPUID_EAX_HWP_ACTIVITY_WINDOW(_)                             (((_) >> 9) & 0x01)

            /**
             * [Bit 10] HWP_Energy_Performance_Preference. IA32_HWP_REQUEST[bits 31:24] is supported if set.
             */
            UINT32_t hwp_energy_performance_preference : 1;
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_BIT              10
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_FLAG             0x400
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_MASK             0x01
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE(_)               (((_) >> 10) & 0x01)

            /**
             * [Bit 11] HWP_Package_Level_Request. IA32_HWP_REQUEST_PKG MSR is supported if set.
             */
            UINT32_t hwp_package_level_request : 1;
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_BIT                      11
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_FLAG                     0x800
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_MASK                     0x01
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST(_)                       (((_) >> 11) & 0x01)
            UINT32_t reserved2 : 1;

            /**
             * [Bit 13] HDC. HDC base registers IA32_PKG_HDC_CTL, IA32_PM_CTL1, IA32_THREAD_STALL MSRs are supported if set.
             */
            UINT32_t hdc : 1;
#define CPUID_EAX_HDC_BIT                                            13
#define CPUID_EAX_HDC_FLAG                                           0x2000
#define CPUID_EAX_HDC_MASK                                           0x01
#define CPUID_EAX_HDC(_)                                             (((_) >> 13) & 0x01)

            /**
             * [Bit 14] Intel(R) Turbo Boost Max Technology 3.0 available.
             */
            UINT32_t intel_turbo_boost_max_technology_3_available : 1;
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_BIT   14
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_FLAG  0x4000
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_MASK  0x01
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE(_)    (((_) >> 14) & 0x01)

            /**
             * [Bit 15] HWP Capabilities. Highest Performance change is supported if set.
             */
            UINT32_t hwp_capabilities : 1;
#define CPUID_EAX_HWP_CAPABILITIES_BIT                               15
#define CPUID_EAX_HWP_CAPABILITIES_FLAG                              0x8000
#define CPUID_EAX_HWP_CAPABILITIES_MASK                              0x01
#define CPUID_EAX_HWP_CAPABILITIES(_)                                (((_) >> 15) & 0x01)

            /**
             * [Bit 16] HWP PECI override is supported if set.
             */
            UINT32_t hwp_peci_override : 1;
#define CPUID_EAX_HWP_PECI_OVERRIDE_BIT                              16
#define CPUID_EAX_HWP_PECI_OVERRIDE_FLAG                             0x10000
#define CPUID_EAX_HWP_PECI_OVERRIDE_MASK                             0x01
#define CPUID_EAX_HWP_PECI_OVERRIDE(_)                               (((_) >> 16) & 0x01)

            /**
             * [Bit 17] Flexible HWP is supported if set.
             */
            UINT32_t flexible_hwp : 1;
#define CPUID_EAX_FLEXIBLE_HWP_BIT                                   17
#define CPUID_EAX_FLEXIBLE_HWP_FLAG                                  0x20000
#define CPUID_EAX_FLEXIBLE_HWP_MASK                                  0x01
#define CPUID_EAX_FLEXIBLE_HWP(_)                                    (((_) >> 17) & 0x01)

            /**
             * [Bit 18] Fast access mode for the IA32_HWP_REQUEST MSR is supported if set.
             */
            UINT32_t fast_access_mode_for_hwp_request_msr : 1;
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_BIT           18
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_FLAG          0x40000
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_MASK          0x01
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR(_)            (((_) >> 18) & 0x01)
            UINT32_t reserved3 : 1;

            /**
             * [Bit 20] Ignoring Idle Logical Processor HWP request is supported if set.
             */
            UINT32_t ignoring_idle_logical_processor_hwp_request : 1;
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_BIT    20
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_FLAG   0x100000
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_MASK   0x01
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST(_)     (((_) >> 20) & 0x01)
            UINT32_t reserved4 : 11;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 3:0] Number of Interrupt Thresholds in Digital Thermal Sensor.
             */
            UINT32_t number_of_interrupt_thresholds_in_thermal_sensor : 4;
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_BIT 0
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_FLAG 0x0F
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_MASK 0x0F
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR(_) (((_) >> 0) & 0x0F)
            UINT32_t reserved1 : 28;
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] Hardware Coordination Feedback Capability (Presence of IA32_MPERF and IA32_APERF). The capability to provide a
             * measure of delivered processor performance (since last reset of the counters), as a percentage of the expected processor
             * performance when running at the TSC frequency.
             */
            UINT32_t hardware_coordination_feedback_capability : 1;
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_BIT      0
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_FLAG     0x01
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_MASK     0x01
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY(_)       (((_) >> 0) & 0x01)
            UINT32_t reserved1 : 2;

            /**
             * [Bit 3] The processor supports performance-energy bias preference if CPUID.06H:ECX.SETBH[bit 3] is set and it also
             * implies the presence of a new architectural MSR called IA32_ENERGY_PERF_BIAS (1B0H).
             */
            UINT32_t performance_energy_bias_preference : 1;
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_BIT             3
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_FLAG            0x08
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_MASK            0x01
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE(_)              (((_) >> 3) & 0x01)
            UINT32_t reserved2 : 28;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_06;


/**
 * @brief Structured Extended Feature Flags Enumeration Leaf (Output depends on ECX input value)
 *
 * When CPUID executes with EAX set to 07H and ECX = 0, the processor returns information about the maximum input value for
 * sub-leaves that contain extended feature flags.
 * When CPUID executes with EAX set to 07H and the input value of ECX is invalid (see leaf 07H entry in Table 3-8), the
 * processor returns 0 in EAX/EBX/ECX/EDX. In subleaf 0, EAX returns the maximum input value of the highest leaf 7
 * sub-leaf, and EBX, ECX & EDX contain information of extended feature flags.
 */
#define CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS                      0x00000007
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the maximum input value for supported leaf 7 sub-leaves.
             */
            UINT32_t number_of_sub_leaves : 32;
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_BIT                           0
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_FLAG                          0xFFFFFFFF
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_MASK                          0xFFFFFFFF
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES(_)                            (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] Supports RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE if 1.
             */
            UINT32_t fsgsbase : 1;
#define CPUID_EBX_FSGSBASE_BIT                                       0
#define CPUID_EBX_FSGSBASE_FLAG                                      0x01
#define CPUID_EBX_FSGSBASE_MASK                                      0x01
#define CPUID_EBX_FSGSBASE(_)                                        (((_) >> 0) & 0x01)

            /**
             * [Bit 1] IA32_TSC_ADJUST MSR is supported if 1.
             */
            UINT32_t ia32_tsc_adjust_msr : 1;
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_BIT                            1
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_FLAG                           0x02
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_MASK                           0x01
#define CPUID_EBX_IA32_TSC_ADJUST_MSR(_)                             (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports Intel(R) Software Guard Extensions (Intel(R) SGX Extensions) if 1.
             */
            UINT32_t sgx : 1;
#define CPUID_EBX_SGX_BIT                                            2
#define CPUID_EBX_SGX_FLAG                                           0x04
#define CPUID_EBX_SGX_MASK                                           0x01
#define CPUID_EBX_SGX(_)                                             (((_) >> 2) & 0x01)

            /**
             * [Bit 3] BMI1.
             */
            UINT32_t bmi1 : 1;
#define CPUID_EBX_BMI1_BIT                                           3
#define CPUID_EBX_BMI1_FLAG                                          0x08
#define CPUID_EBX_BMI1_MASK                                          0x01
#define CPUID_EBX_BMI1(_)                                            (((_) >> 3) & 0x01)

            /**
             * [Bit 4] HLE.
             */
            UINT32_t hle : 1;
#define CPUID_EBX_HLE_BIT                                            4
#define CPUID_EBX_HLE_FLAG                                           0x10
#define CPUID_EBX_HLE_MASK                                           0x01
#define CPUID_EBX_HLE(_)                                             (((_) >> 4) & 0x01)

            /**
             * [Bit 5] AVX2.
             */
            UINT32_t avx2 : 1;
#define CPUID_EBX_AVX2_BIT                                           5
#define CPUID_EBX_AVX2_FLAG                                          0x20
#define CPUID_EBX_AVX2_MASK                                          0x01
#define CPUID_EBX_AVX2(_)                                            (((_) >> 5) & 0x01)

            /**
             * [Bit 6] x87 FPU Data Pointer updated only on x87 exceptions if 1.
             */
            UINT32_t fdp_excptn_only : 1;
#define CPUID_EBX_FDP_EXCPTN_ONLY_BIT                                6
#define CPUID_EBX_FDP_EXCPTN_ONLY_FLAG                               0x40
#define CPUID_EBX_FDP_EXCPTN_ONLY_MASK                               0x01
#define CPUID_EBX_FDP_EXCPTN_ONLY(_)                                 (((_) >> 6) & 0x01)

            /**
             * [Bit 7] Supports Supervisor-Mode Execution Prevention if 1.
             */
            UINT32_t smep : 1;
#define CPUID_EBX_SMEP_BIT                                           7
#define CPUID_EBX_SMEP_FLAG                                          0x80
#define CPUID_EBX_SMEP_MASK                                          0x01
#define CPUID_EBX_SMEP(_)                                            (((_) >> 7) & 0x01)

            /**
             * [Bit 8] BMI2.
             */
            UINT32_t bmi2 : 1;
#define CPUID_EBX_BMI2_BIT                                           8
#define CPUID_EBX_BMI2_FLAG                                          0x100
#define CPUID_EBX_BMI2_MASK                                          0x01
#define CPUID_EBX_BMI2(_)                                            (((_) >> 8) & 0x01)

            /**
             * [Bit 9] Supports Enhanced REP MOVSB/STOSB if 1.
             */
            UINT32_t enhanced_rep_movsb_stosb : 1;
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_BIT                       9
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_FLAG                      0x200
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_MASK                      0x01
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB(_)                        (((_) >> 9) & 0x01)

            /**
             * [Bit 10] If 1, supports INVPCID instruction for system software that manages process-context identifiers.
             */
            UINT32_t invpcid : 1;
#define CPUID_EBX_INVPCID_BIT                                        10
#define CPUID_EBX_INVPCID_FLAG                                       0x400
#define CPUID_EBX_INVPCID_MASK                                       0x01
#define CPUID_EBX_INVPCID(_)                                         (((_) >> 10) & 0x01)

            /**
             * [Bit 11] RTM.
             */
            UINT32_t rtm : 1;
#define CPUID_EBX_RTM_BIT                                            11
#define CPUID_EBX_RTM_FLAG                                           0x800
#define CPUID_EBX_RTM_MASK                                           0x01
#define CPUID_EBX_RTM(_)                                             (((_) >> 11) & 0x01)

            /**
             * [Bit 12] Supports Intel(R) Resource Director Technology (Intel(R) RDT) Monitoring capability if 1.
             */
            UINT32_t rdt_m : 1;
#define CPUID_EBX_RDT_M_BIT                                          12
#define CPUID_EBX_RDT_M_FLAG                                         0x1000
#define CPUID_EBX_RDT_M_MASK                                         0x01
#define CPUID_EBX_RDT_M(_)                                           (((_) >> 12) & 0x01)

            /**
             * [Bit 13] Deprecates FPU CS and FPU DS values if 1.
             */
            UINT32_t deprecates : 1;
#define CPUID_EBX_DEPRECATES_BIT                                     13
#define CPUID_EBX_DEPRECATES_FLAG                                    0x2000
#define CPUID_EBX_DEPRECATES_MASK                                    0x01
#define CPUID_EBX_DEPRECATES(_)                                      (((_) >> 13) & 0x01)

            /**
             * [Bit 14] Supports Intel(R) Memory Protection Extensions if 1.
             */
            UINT32_t mpx : 1;
#define CPUID_EBX_MPX_BIT                                            14
#define CPUID_EBX_MPX_FLAG                                           0x4000
#define CPUID_EBX_MPX_MASK                                           0x01
#define CPUID_EBX_MPX(_)                                             (((_) >> 14) & 0x01)

            /**
             * [Bit 15] Supports Intel(R) Resource Director Technology (Intel(R) RDT) Allocation capability if 1.
             */
            UINT32_t rdt : 1;
#define CPUID_EBX_RDT_BIT                                            15
#define CPUID_EBX_RDT_FLAG                                           0x8000
#define CPUID_EBX_RDT_MASK                                           0x01
#define CPUID_EBX_RDT(_)                                             (((_) >> 15) & 0x01)

            /**
             * [Bit 16] AVX512F.
             */
            UINT32_t avx512f : 1;
#define CPUID_EBX_AVX512F_BIT                                        16
#define CPUID_EBX_AVX512F_FLAG                                       0x10000
#define CPUID_EBX_AVX512F_MASK                                       0x01
#define CPUID_EBX_AVX512F(_)                                         (((_) >> 16) & 0x01)

            /**
             * [Bit 17] AVX512DQ.
             */
            UINT32_t avx512dq : 1;
#define CPUID_EBX_AVX512DQ_BIT                                       17
#define CPUID_EBX_AVX512DQ_FLAG                                      0x20000
#define CPUID_EBX_AVX512DQ_MASK                                      0x01
#define CPUID_EBX_AVX512DQ(_)                                        (((_) >> 17) & 0x01)

            /**
             * [Bit 18] RDSEED.
             */
            UINT32_t rdseed : 1;
#define CPUID_EBX_RDSEED_BIT                                         18
#define CPUID_EBX_RDSEED_FLAG                                        0x40000
#define CPUID_EBX_RDSEED_MASK                                        0x01
#define CPUID_EBX_RDSEED(_)                                          (((_) >> 18) & 0x01)

            /**
             * [Bit 19] ADX.
             */
            UINT32_t adx : 1;
#define CPUID_EBX_ADX_BIT                                            19
#define CPUID_EBX_ADX_FLAG                                           0x80000
#define CPUID_EBX_ADX_MASK                                           0x01
#define CPUID_EBX_ADX(_)                                             (((_) >> 19) & 0x01)

            /**
             * [Bit 20] Supports Supervisor-Mode Access Prevention (and the CLAC/STAC instructions) if 1.
             */
            UINT32_t smap : 1;
#define CPUID_EBX_SMAP_BIT                                           20
#define CPUID_EBX_SMAP_FLAG                                          0x100000
#define CPUID_EBX_SMAP_MASK                                          0x01
#define CPUID_EBX_SMAP(_)                                            (((_) >> 20) & 0x01)

            /**
             * [Bit 21] AVX512_IFMA.
             */
            UINT32_t avx512_ifma : 1;
#define CPUID_EBX_AVX512_IFMA_BIT                                    21
#define CPUID_EBX_AVX512_IFMA_FLAG                                   0x200000
#define CPUID_EBX_AVX512_IFMA_MASK                                   0x01
#define CPUID_EBX_AVX512_IFMA(_)                                     (((_) >> 21) & 0x01)
            UINT32_t reserved1 : 1;

            /**
             * [Bit 23] CLFLUSHOPT.
             */
            UINT32_t clflushopt : 1;
#define CPUID_EBX_CLFLUSHOPT_BIT                                     23
#define CPUID_EBX_CLFLUSHOPT_FLAG                                    0x800000
#define CPUID_EBX_CLFLUSHOPT_MASK                                    0x01
#define CPUID_EBX_CLFLUSHOPT(_)                                      (((_) >> 23) & 0x01)

            /**
             * [Bit 24] CLWB.
             */
            UINT32_t clwb : 1;
#define CPUID_EBX_CLWB_BIT                                           24
#define CPUID_EBX_CLWB_FLAG                                          0x1000000
#define CPUID_EBX_CLWB_MASK                                          0x01
#define CPUID_EBX_CLWB(_)                                            (((_) >> 24) & 0x01)

            /**
             * [Bit 25] Intel Processor Trace.
             */
            UINT32_t intel : 1;
#define CPUID_EBX_INTEL_BIT                                          25
#define CPUID_EBX_INTEL_FLAG                                         0x2000000
#define CPUID_EBX_INTEL_MASK                                         0x01
#define CPUID_EBX_INTEL(_)                                           (((_) >> 25) & 0x01)

            /**
             * [Bit 26] (Intel(R) Xeon Phi(TM) only).
             */
            UINT32_t avx512pf : 1;
#define CPUID_EBX_AVX512PF_BIT                                       26
#define CPUID_EBX_AVX512PF_FLAG                                      0x4000000
#define CPUID_EBX_AVX512PF_MASK                                      0x01
#define CPUID_EBX_AVX512PF(_)                                        (((_) >> 26) & 0x01)

            /**
             * [Bit 27] (Intel(R) Xeon Phi(TM) only).
             */
            UINT32_t avx512er : 1;
#define CPUID_EBX_AVX512ER_BIT                                       27
#define CPUID_EBX_AVX512ER_FLAG                                      0x8000000
#define CPUID_EBX_AVX512ER_MASK                                      0x01
#define CPUID_EBX_AVX512ER(_)                                        (((_) >> 27) & 0x01)

            /**
             * [Bit 28] AVX512CD.
             */
            UINT32_t avx512cd : 1;
#define CPUID_EBX_AVX512CD_BIT                                       28
#define CPUID_EBX_AVX512CD_FLAG                                      0x10000000
#define CPUID_EBX_AVX512CD_MASK                                      0x01
#define CPUID_EBX_AVX512CD(_)                                        (((_) >> 28) & 0x01)

            /**
             * [Bit 29] Supports Intel(R) Secure Hash Algorithm Extensions (Intel(R) SHA Extensions) if 1.
             */
            UINT32_t sha : 1;
#define CPUID_EBX_SHA_BIT                                            29
#define CPUID_EBX_SHA_FLAG                                           0x20000000
#define CPUID_EBX_SHA_MASK                                           0x01
#define CPUID_EBX_SHA(_)                                             (((_) >> 29) & 0x01)

            /**
             * [Bit 30] AVX512BW.
             */
            UINT32_t avx512bw : 1;
#define CPUID_EBX_AVX512BW_BIT                                       30
#define CPUID_EBX_AVX512BW_FLAG                                      0x40000000
#define CPUID_EBX_AVX512BW_MASK                                      0x01
#define CPUID_EBX_AVX512BW(_)                                        (((_) >> 30) & 0x01)

            /**
             * [Bit 31] AVX512VL.
             */
            UINT32_t avx512vl : 1;
#define CPUID_EBX_AVX512VL_BIT                                       31
#define CPUID_EBX_AVX512VL_FLAG                                      0x80000000
#define CPUID_EBX_AVX512VL_MASK                                      0x01
#define CPUID_EBX_AVX512VL(_)                                        (((_) >> 31) & 0x01)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] (Intel(R) Xeon Phi(TM) only).
             */
            UINT32_t prefetchwt1 : 1;
#define CPUID_ECX_PREFETCHWT1_BIT                                    0
#define CPUID_ECX_PREFETCHWT1_FLAG                                   0x01
#define CPUID_ECX_PREFETCHWT1_MASK                                   0x01
#define CPUID_ECX_PREFETCHWT1(_)                                     (((_) >> 0) & 0x01)

            /**
             * [Bit 1] AVX512_VBMI.
             */
            UINT32_t avx512_vbmi : 1;
#define CPUID_ECX_AVX512_VBMI_BIT                                    1
#define CPUID_ECX_AVX512_VBMI_FLAG                                   0x02
#define CPUID_ECX_AVX512_VBMI_MASK                                   0x01
#define CPUID_ECX_AVX512_VBMI(_)                                     (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports user-mode instruction prevention if 1.
             */
            UINT32_t umip : 1;
#define CPUID_ECX_UMIP_BIT                                           2
#define CPUID_ECX_UMIP_FLAG                                          0x04
#define CPUID_ECX_UMIP_MASK                                          0x01
#define CPUID_ECX_UMIP(_)                                            (((_) >> 2) & 0x01)

            /**
             * [Bit 3] Supports protection keys for user-mode pages if 1.
             */
            UINT32_t pku : 1;
#define CPUID_ECX_PKU_BIT                                            3
#define CPUID_ECX_PKU_FLAG                                           0x08
#define CPUID_ECX_PKU_MASK                                           0x01
#define CPUID_ECX_PKU(_)                                             (((_) >> 3) & 0x01)

            /**
             * [Bit 4] If 1, OS has set CR4.PKE to enable protection keys (and the RDPKRU/WRPKRU instructions).
             */
            UINT32_t ospke : 1;
#define CPUID_ECX_OSPKE_BIT                                          4
#define CPUID_ECX_OSPKE_FLAG                                         0x10
#define CPUID_ECX_OSPKE_MASK                                         0x01
#define CPUID_ECX_OSPKE(_)                                           (((_) >> 4) & 0x01)
            UINT32_t reserved1 : 12;

            /**
             * [Bits 21:17] The value of MAWAU used by the BNDLDX and BNDSTX instructions in 64-bit mode.
             */
            UINT32_t mawau : 5;
#define CPUID_ECX_MAWAU_BIT                                          17
#define CPUID_ECX_MAWAU_FLAG                                         0x3E0000
#define CPUID_ECX_MAWAU_MASK                                         0x1F
#define CPUID_ECX_MAWAU(_)                                           (((_) >> 17) & 0x1F)

            /**
             * [Bit 22] RDPID and IA32_TSC_AUX are available if 1.
             */
            UINT32_t rdpid : 1;
#define CPUID_ECX_RDPID_BIT                                          22
#define CPUID_ECX_RDPID_FLAG                                         0x400000
#define CPUID_ECX_RDPID_MASK                                         0x01
#define CPUID_ECX_RDPID(_)                                           (((_) >> 22) & 0x01)
            UINT32_t reserved2 : 7;

            /**
             * [Bit 30] Supports SGX Launch Configuration if 1.
             */
            UINT32_t sgx_lc : 1;
#define CPUID_ECX_SGX_LC_BIT                                         30
#define CPUID_ECX_SGX_LC_FLAG                                        0x40000000
#define CPUID_ECX_SGX_LC_MASK                                        0x01
#define CPUID_ECX_SGX_LC(_)                                          (((_) >> 30) & 0x01)
            UINT32_t reserved3 : 1;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_07;


/**
 * @brief Direct Cache Access Information Leaf
 *
 * When CPUID executes with EAX set to 09H, the processor returns information about Direct Cache Access capabilities.
 */
#define CPUID_DIRECT_CACHE_ACCESS_INFORMATION                        0x00000009
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H).
             */
            UINT32_t ia32_platform_dca_cap : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT                          0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)                           (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_09;


/**
 * @brief Architectural Performance Monitoring Leaf
 *
 * When CPUID executes with EAX set to 0AH, the processor returns information about support for architectural performance
 * monitoring capabilities. Architectural performance monitoring is supported if the version ID is greater than Pn 0. For
 * each version of architectural performance monitoring capability, software must enumerate this leaf to discover the
 * programming facilities and the architectural performance events available in the processor.
 *
 * @see Vol3C[23(Introduction to Virtual-Machine Extensions)]
 */
#define CPUID_ARCHITECTURAL_PERFORMANCE_MONITORING                   0x0000000A
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 7:0] Version ID of architectural performance monitoring.
             */
            UINT32_t version_id_of_architectural_performance_monitoring : 8;
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_BIT 0
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_FLAG 0xFF
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_MASK 0xFF
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING(_) (((_) >> 0) & 0xFF)

            /**
             * [Bits 15:8] Number of general-purpose performance monitoring counter per logical processor.
             */
            UINT32_t number_of_performance_monitoring_counter_per_logical_processor : 8;
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_BIT 8
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_FLAG 0xFF00
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_MASK 0xFF
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR(_) (((_) >> 8) & 0xFF)

            /**
             * [Bits 23:16] Bit width of general-purpose, performance monitoring counter.
             */
            UINT32_t bit_width_of_performance_monitoring_counter : 8;
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_BIT    16
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_FLAG   0xFF0000
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_MASK   0xFF
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER(_)     (((_) >> 16) & 0xFF)

            /**
             * [Bits 31:24] Length of EBX bit vector to enumerate architectural performance monitoring events.
             */
            UINT32_t ebx_bit_vector_length : 8;
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_BIT                          24
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_FLAG                         0xFF000000
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_MASK                         0xFF
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH(_)                           (((_) >> 24) & 0xFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] Core cycle event not available if 1.
             */
            UINT32_t core_cycle_event_not_available : 1;
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_BIT                 0
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_FLAG                0x01
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_MASK                0x01
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE(_)                  (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Instruction retired event not available if 1.
             */
            UINT32_t instruction_retired_event_not_available : 1;
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_BIT        1
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_FLAG       0x02
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_MASK       0x01
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE(_)         (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Reference cycles event not available if 1.
             */
            UINT32_t reference_cycles_event_not_available : 1;
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_BIT           2
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_FLAG          0x04
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_MASK          0x01
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE(_)            (((_) >> 2) & 0x01)

            /**
             * [Bit 3] Last-level cache reference event not available if 1.
             */
            UINT32_t last_level_cache_reference_event_not_available : 1;
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_BIT 3
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_FLAG 0x08
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE(_)  (((_) >> 3) & 0x01)

            /**
             * [Bit 4] Last-level cache misses event not available if 1.
             */
            UINT32_t last_level_cache_misses_event_not_available : 1;
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_BIT    4
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_FLAG   0x10
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_MASK   0x01
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE(_)     (((_) >> 4) & 0x01)

            /**
             * [Bit 5] Branch instruction retired event not available if 1.
             */
            UINT32_t branch_instruction_retired_event_not_available : 1;
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_BIT 5
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_FLAG 0x20
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE(_)  (((_) >> 5) & 0x01)

            /**
             * [Bit 6] Branch mispredict retired event not available if 1.
             */
            UINT32_t branch_mispredict_retired_event_not_available : 1;
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_BIT  6
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_FLAG 0x40
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE(_)   (((_) >> 6) & 0x01)
            UINT32_t reserved1 : 25;
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 4:0] Number of fixed-function performance counters (if Version ID > 1).
             */
            UINT32_t number_of_fixed_function_performance_counters : 5;
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_BIT  0
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_FLAG 0x1F
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_MASK 0x1F
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS(_)   (((_) >> 0) & 0x1F)

            /**
             * [Bits 12:5] Bit width of fixed-function performance counters (if Version ID > 1).
             */
            UINT32_t bit_width_of_fixed_function_performance_counters : 8;
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_BIT 5
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_FLAG 0x1FE0
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_MASK 0xFF
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS(_) (((_) >> 5) & 0xFF)
            UINT32_t reserved1 : 2;

            /**
             * [Bit 15] AnyThread deprecation.
             */
            UINT32_t any_thread_deprecation : 1;
#define CPUID_EDX_ANY_THREAD_DEPRECATION_BIT                         15
#define CPUID_EDX_ANY_THREAD_DEPRECATION_FLAG                        0x8000
#define CPUID_EDX_ANY_THREAD_DEPRECATION_MASK                        0x01
#define CPUID_EDX_ANY_THREAD_DEPRECATION(_)                          (((_) >> 15) & 0x01)
            UINT32_t reserved2 : 16;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_0a;


/**
 * @brief Extended Topology Enumeration Leaf
 *
 * When CPUID executes with EAX set to 0BH, the processor returns information about extended topology enumeration data.
 * Software must detect the presence of CPUID leaf 0BH by verifying
 * - the highest leaf index supported by CPUID is >= 0BH, and
 * - CPUID.0BH:EBX[15:0] reports a non-zero value.
 *
 * @note Most of Leaf 0BH output depends on the initial value in ECX. The EDX output of leaf 0BH is always valid and does
 *       not vary with input value in ECX. Output value in ECX[7:0] always equals input value in ECX[7:0]. Sub-leaf index 0
 *       enumerates SMT level. Each subsequent higher sub-leaf index enumerates a higherlevel topological entity in hierarchical
 *       order. For sub-leaves that return an invalid level-type of 0 in ECX[15:8]; EAX and EBX will return 0. If an input value
 *       n in ECX returns the invalid level-type of 0 in ECX[15:8], other input values with ECX > n also return 0 in ECX[15:8].
 */
#define CPUID_EXTENDED_TOPOLOGY                                      0x0000000B
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 4:0] Number of bits to shift right on x2APIC ID to get a unique topology ID of the next level type. All logical
             * processors with the same next level ID share current level.
             *
             * @note Software should use this field (EAX[4:0]) to enumerate processor topology of the system.
             */
            UINT32_t x2apic_id_to_unique_topology_id_shift : 5;
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_BIT          0
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_FLAG         0x1F
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_MASK         0x1F
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT(_)           (((_) >> 0) & 0x1F)
            UINT32_t reserved1 : 27;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Number of logical processors at this level type. The number reflects configuration as shipped by Intel.
             *
             * @note Software must not use EBX[15:0] to enumerate processor topology of the system. This value in this field
             *       (EBX[15:0]) is only intended for display/diagnostic purposes. The actual number of logical processors available to
             *       BIOS/OS/Applications may be different from the value of EBX[15:0], depending on software and platform hardware
             *       configurations.
             */
            UINT32_t number_of_logical_processors_at_this_level_type : 16;
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_BIT 0
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_FLAG 0xFFFF
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_MASK 0xFFFF
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE(_) (((_) >> 0) & 0xFFFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 7:0] Level number. Same value in ECX input.
             */
            UINT32_t level_number : 8;
#define CPUID_ECX_LEVEL_NUMBER_BIT                                   0
#define CPUID_ECX_LEVEL_NUMBER_FLAG                                  0xFF
#define CPUID_ECX_LEVEL_NUMBER_MASK                                  0xFF
#define CPUID_ECX_LEVEL_NUMBER(_)                                    (((_) >> 0) & 0xFF)

            /**
             * [Bits 15:8] Level type.
             *
             * @note The value of the "level type" field is not related to level numbers in any way, higher "level type" values do not
             *       mean higher levels. Level type field has the following encoding:
             *       - 0: Invalid.
             *       - 1: SMT.
             *       - 2: Core.
             *       - 3-255: Reserved.
             */
            UINT32_t level_type : 8;
#define CPUID_ECX_LEVEL_TYPE_BIT                                     8
#define CPUID_ECX_LEVEL_TYPE_FLAG                                    0xFF00
#define CPUID_ECX_LEVEL_TYPE_MASK                                    0xFF
#define CPUID_ECX_LEVEL_TYPE(_)                                      (((_) >> 8) & 0xFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] x2APIC ID the current logical processor.
             */
            UINT32_t x2apic_id : 32;
#define CPUID_EDX_X2APIC_ID_BIT                                      0
#define CPUID_EDX_X2APIC_ID_FLAG                                     0xFFFFFFFF
#define CPUID_EDX_X2APIC_ID_MASK                                     0xFFFFFFFF
#define CPUID_EDX_X2APIC_ID(_)                                       (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_0b;

/**
 * @defgroup cpuid_eax_0d \
 *           EAX = 0x0D
 *
 * When CPUID executes with EAX set to 0DH and ECX = 0, the processor returns information about the bit-vector
 * representation of all processor state extensions that are supported in the processor and storage size requirements of
 * the XSAVE/XRSTOR area.
 * When CPUID executes with EAX set to 0DH and ECX = n (n > 1, and is a valid sub-leaf index), the processor returns
 * information about the size and offset of each processor extended state save area within the XSAVE/XRSTOR area. Software
 * can use the forward-extendable technique depicted below to query the valid sub-leaves and obtain size and offset
 * information for each processor extended state save area:
 * <pre> For i = 2 to 62 // sub-leaf 1 is reserved IF (CPUID.(EAX=0DH, ECX=0):VECTOR[i] = 1) // VECTOR is the 64-bit value
 * of EDX:EAX Execute CPUID.(EAX=0DH, ECX = i) to examine size and offset for sub-leaf i; FI; </pre>
 * @{
 */
#define CPUID_EXTENDED_STATE_INFORMATION                             0x0000000D
 /**
  * @brief Processor Extended State Enumeration Main Leaf (EAX = 0DH, ECX = 0)
  */
typedef struct
{
    /**
     * @brief Reports the supported bits of the lower 32 bits of XCR0. XCR0[n] can be set to 1 only if EAX[n] is 1
     */
    union
    {
        struct
        {
            /**
             * [Bit 0] x87 state.
             */
            UINT32_t x87_state : 1;
#define CPUID_EAX_X87_STATE_BIT                                      0
#define CPUID_EAX_X87_STATE_FLAG                                     0x01
#define CPUID_EAX_X87_STATE_MASK                                     0x01
#define CPUID_EAX_X87_STATE(_)                                       (((_) >> 0) & 0x01)

            /**
             * [Bit 1] SSE state.
             */
            UINT32_t sse_state : 1;
#define CPUID_EAX_SSE_STATE_BIT                                      1
#define CPUID_EAX_SSE_STATE_FLAG                                     0x02
#define CPUID_EAX_SSE_STATE_MASK                                     0x01
#define CPUID_EAX_SSE_STATE(_)                                       (((_) >> 1) & 0x01)

            /**
             * [Bit 2] AVX state.
             */
            UINT32_t avx_state : 1;
#define CPUID_EAX_AVX_STATE_BIT                                      2
#define CPUID_EAX_AVX_STATE_FLAG                                     0x04
#define CPUID_EAX_AVX_STATE_MASK                                     0x01
#define CPUID_EAX_AVX_STATE(_)                                       (((_) >> 2) & 0x01)

            /**
             * [Bits 4:3] MPX state.
             */
            UINT32_t mpx_state : 2;
#define CPUID_EAX_MPX_STATE_BIT                                      3
#define CPUID_EAX_MPX_STATE_FLAG                                     0x18
#define CPUID_EAX_MPX_STATE_MASK                                     0x03
#define CPUID_EAX_MPX_STATE(_)                                       (((_) >> 3) & 0x03)

            /**
             * [Bits 7:5] AVX-512 state.
             */
            UINT32_t avx_512_state : 3;
#define CPUID_EAX_AVX_512_STATE_BIT                                  5
#define CPUID_EAX_AVX_512_STATE_FLAG                                 0xE0
#define CPUID_EAX_AVX_512_STATE_MASK                                 0x07
#define CPUID_EAX_AVX_512_STATE(_)                                   (((_) >> 5) & 0x07)

            /**
             * [Bit 8] Used for IA32_XSS.
             */
            UINT32_t used_for_ia32_xss_1 : 1;
#define CPUID_EAX_USED_FOR_IA32_XSS_1_BIT                            8
#define CPUID_EAX_USED_FOR_IA32_XSS_1_FLAG                           0x100
#define CPUID_EAX_USED_FOR_IA32_XSS_1_MASK                           0x01
#define CPUID_EAX_USED_FOR_IA32_XSS_1(_)                             (((_) >> 8) & 0x01)

            /**
             * [Bit 9] PKRU state.
             */
            UINT32_t pkru_state : 1;
#define CPUID_EAX_PKRU_STATE_BIT                                     9
#define CPUID_EAX_PKRU_STATE_FLAG                                    0x200
#define CPUID_EAX_PKRU_STATE_MASK                                    0x01
#define CPUID_EAX_PKRU_STATE(_)                                      (((_) >> 9) & 0x01)
            UINT32_t reserved1 : 3;

            /**
             * [Bit 13] Used for IA32_XSS.
             */
            UINT32_t used_for_ia32_xss_2 : 1;
#define CPUID_EAX_USED_FOR_IA32_XSS_2_BIT                            13
#define CPUID_EAX_USED_FOR_IA32_XSS_2_FLAG                           0x2000
#define CPUID_EAX_USED_FOR_IA32_XSS_2_MASK                           0x01
#define CPUID_EAX_USED_FOR_IA32_XSS_2(_)                             (((_) >> 13) & 0x01)
            UINT32_t reserved2 : 18;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) required by enabled features in XCR0.
             * May be different than ECX if some features at the end of the XSAVE save area are not enabled.
             */
            UINT32_t max_size_required_by_enabled_features_in_xcr0 : 32;
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_BIT  0
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_FLAG 0xFFFFFFFF
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_MASK 0xFFFFFFFF
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0(_)   (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) of the XSAVE/XRSTOR save area
             * required by all supported features in the processor, i.e., all the valid bit fields in XCR0.
             */
            UINT32_t max_size_of_xsave_xrstor_save_area : 32;
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_BIT             0
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_FLAG            0xFFFFFFFF
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_MASK            0xFFFFFFFF
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA(_)              (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the supported bits of the upper 32 bits of XCR0. XCR0[n+32] can be set to 1 only if EDX[n] is 1.
             */
            UINT32_t xcr0_supported_bits : 32;
#define CPUID_EDX_XCR0_SUPPORTED_BITS_BIT                            0
#define CPUID_EDX_XCR0_SUPPORTED_BITS_FLAG                           0xFFFFFFFF
#define CPUID_EDX_XCR0_SUPPORTED_BITS_MASK                           0xFFFFFFFF
#define CPUID_EDX_XCR0_SUPPORTED_BITS(_)                             (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_0d_ecx_00;

/**
 * @brief Direct Cache Access Information Leaf
 */
typedef struct
{
    union
    {
        struct
        {
            UINT32_t reserved1 : 1;

            /**
             * [Bit 1] Supports XSAVEC and the compacted form of XRSTOR if set.
             */
            UINT32_t supports_xsavec_and_compacted_xrstor : 1;
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_BIT           1
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_FLAG          0x02
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_MASK          0x01
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR(_)            (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports XGETBV with ECX = 1 if set.
             */
            UINT32_t supports_xgetbv_with_ecx_1 : 1;
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_BIT                     2
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_FLAG                    0x04
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_MASK                    0x01
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1(_)                      (((_) >> 2) & 0x01)

            /**
             * [Bit 3] Supports XSAVES/XRSTORS and IA32_XSS if set.
             */
            UINT32_t supports_xsave_xrstor_and_ia32_xss : 1;
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_BIT             3
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_FLAG            0x08
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_MASK            0x01
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS(_)              (((_) >> 3) & 0x01)
            UINT32_t reserved2 : 28;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] The size in bytes of the XSAVE area containing all states enabled by XCRO | IA32_XSS.
             */
            UINT32_t size_of_xsave_aread : 32;
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_BIT                            0
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_FLAG                           0xFFFFFFFF
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_MASK                           0xFFFFFFFF
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD(_)                             (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 7:0] Used for XCR0.
             */
            UINT32_t used_for_xcr0_1 : 8;
#define CPUID_ECX_USED_FOR_XCR0_1_BIT                                0
#define CPUID_ECX_USED_FOR_XCR0_1_FLAG                               0xFF
#define CPUID_ECX_USED_FOR_XCR0_1_MASK                               0xFF
#define CPUID_ECX_USED_FOR_XCR0_1(_)                                 (((_) >> 0) & 0xFF)

            /**
             * [Bit 8] PT state.
             */
            UINT32_t pt_state : 1;
#define CPUID_ECX_PT_STATE_BIT                                       8
#define CPUID_ECX_PT_STATE_FLAG                                      0x100
#define CPUID_ECX_PT_STATE_MASK                                      0x01
#define CPUID_ECX_PT_STATE(_)                                        (((_) >> 8) & 0x01)

            /**
             * [Bit 9] Used for XCR0.
             */
            UINT32_t used_for_xcr0_2 : 1;
#define CPUID_ECX_USED_FOR_XCR0_2_BIT                                9
#define CPUID_ECX_USED_FOR_XCR0_2_FLAG                               0x200
#define CPUID_ECX_USED_FOR_XCR0_2_MASK                               0x01
#define CPUID_ECX_USED_FOR_XCR0_2(_)                                 (((_) >> 9) & 0x01)
            UINT32_t reserved1 : 3;

            /**
             * [Bit 13] HWP state.
             */
            UINT32_t hwp_state : 1;
#define CPUID_ECX_HWP_STATE_BIT                                      13
#define CPUID_ECX_HWP_STATE_FLAG                                     0x2000
#define CPUID_ECX_HWP_STATE_MASK                                     0x01
#define CPUID_ECX_HWP_STATE(_)                                       (((_) >> 13) & 0x01)
            UINT32_t reserved2 : 18;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_0d_ecx_01;

/**
 * @brief Processor Extended State Enumeration Sub-leaves (EAX = 0DH, ECX = n, n > 1)
 *
 * @note Leaf 0DH output depends on the initial value in ECX. Each sub-leaf index (starting at position 2) is supported if
 *       it corresponds to a supported bit in either the XCR0 register or the IA32_XSS MSR.
 *       If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf n (0 <= n <= 31) is invalid if sub-leaf 0
 *       returns 0 in EAX[n] and sub-leaf 1 returns 0 in ECX[n]. Sub-leaf n (32 <= n <= 63) is invalid if sub-leaf 0 returns 0 in
 *       EDX[n-32] and sub-leaf 1 returns 0 in EDX[n-32].
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] The size in bytes (from the offset specified in EBX) of the save area for an extended state feature
             * associated with a valid sub-leaf index, n.
             */
            UINT32_t ia32_platform_dca_cap : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT                          0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)                           (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] The offset in bytes of this extended state component's save area from the beginning of the XSAVE/XRSTOR
             * area.
             * This field reports 0 if the sub-leaf index, n, does not map to a valid bit in the XCR0 register.
             */
            UINT32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] Is set if the bit n (corresponding to the sub-leaf index) is supported in the IA32_XSS MSR; it is clear if bit n
             * is instead supported in XCR0.
             */
            UINT32_t ecx_2 : 1;
#define CPUID_ECX_ECX_2_BIT                                          0
#define CPUID_ECX_ECX_2_FLAG                                         0x01
#define CPUID_ECX_ECX_2_MASK                                         0x01
#define CPUID_ECX_ECX_2(_)                                           (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Is set if, when the compacted format of an XSAVE area is used, this extended state component located on the next
             * 64-byte boundary following the preceding state component (otherwise, it is located immediately following the preceding
             * state component).
             */
            UINT32_t ecx_1 : 1;
#define CPUID_ECX_ECX_1_BIT                                          1
#define CPUID_ECX_ECX_1_FLAG                                         0x02
#define CPUID_ECX_ECX_1_MASK                                         0x01
#define CPUID_ECX_ECX_1(_)                                           (((_) >> 1) & 0x01)
            UINT32_t reserved1 : 30;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] This field reports 0 if the sub-leaf index, n, is invalid; otherwise it is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_0d_ecx_n;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_0f \
  *           EAX = 0x0F
  *
  * When CPUID executes with EAX set to 0FH and ECX = 0, the processor returns information about the bit-vector
  * representation of QoS monitoring resource types that are supported in the processor and maximum range of RMID values the
  * processor can use to monitor of any supported resource types. Each bit, starting from bit 1, corresponds to a specific
  * resource type if the bit is set. The bit position corresponds to the sub-leaf index (or ResID) that software must use to
  * query QoS monitoring capability available for that type. See Table 3-8.
  * When CPUID executes with EAX set to 0FH and ECX = n (n >= 1, and is a valid ResID), the processor returns information
  * software can use to program IA32_PQR_ASSOC, IA32_QM_EVTSEL MSRs before reading QoS data from the IA32_QM_CTR MSR.
  * @{
  */
#define CPUID_INTEL_RESOURCE_DIRECTOR_TECHNOLOGY_MONITORING_INFORMATION 0x0000000F
  /**
   * @brief Intel Resource Director Technology (Intel RDT) Monitoring Enumeration Sub-leaf (EAX = 0FH, ECX = 0)
   *
   * @note Leaf 0FH output depends on the initial value in ECX. Sub-leaf index 0 reports valid resource type starting at bit
   *       position 1 of EDX.
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum range (zero-based) of RMID within this physical processor of all types.
             */
            UINT32_t rmid_max_range : 32;
#define CPUID_EBX_RMID_MAX_RANGE_BIT                                 0
#define CPUID_EBX_RMID_MAX_RANGE_FLAG                                0xFFFFFFFF
#define CPUID_EBX_RMID_MAX_RANGE_MASK                                0xFFFFFFFF
#define CPUID_EBX_RMID_MAX_RANGE(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            UINT32_t reserved1 : 1;

            /**
             * [Bit 1] Supports L3 Cache Intel RDT Monitoring if 1.
             */
            UINT32_t supports_l3_cache_intel_rdt_monitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_BIT         1
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_FLAG        0x02
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_MASK        0x01
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING(_)          (((_) >> 1) & 0x01)
            UINT32_t reserved2 : 30;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_0f_ecx_00;

/**
 * @brief L3 Cache Intel RDT Monitoring Capability Enumeration Sub-leaf (EAX = 0FH, ECX = 1)
 *
 * @note Leaf 0FH output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Conversion factor from reported IA32_QM_CTR value to occupancy metric (bytes).
             */
            UINT32_t conversion_factor : 32;
#define CPUID_EBX_CONVERSION_FACTOR_BIT                              0
#define CPUID_EBX_CONVERSION_FACTOR_FLAG                             0xFFFFFFFF
#define CPUID_EBX_CONVERSION_FACTOR_MASK                             0xFFFFFFFF
#define CPUID_EBX_CONVERSION_FACTOR(_)                               (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum range (zero-based) of RMID within this physical processor of all types.
             */
            UINT32_t rmid_max_range : 32;
#define CPUID_ECX_RMID_MAX_RANGE_BIT                                 0
#define CPUID_ECX_RMID_MAX_RANGE_FLAG                                0xFFFFFFFF
#define CPUID_ECX_RMID_MAX_RANGE_MASK                                0xFFFFFFFF
#define CPUID_ECX_RMID_MAX_RANGE(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bit 0] Supports L3 occupancy monitoring if 1.
             */
            UINT32_t supports_l3_occupancy_monitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_BIT               0
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_FLAG              0x01
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_MASK              0x01
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING(_)                (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Supports L3 Total Bandwidth monitoring if 1.
             */
            UINT32_t supports_l3_total_bandwidth_monitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_BIT         1
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_FLAG        0x02
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_MASK        0x01
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING(_)          (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports L3 Local Bandwidth monitoring if 1.
             */
            UINT32_t supports_l3_local_bandwidth_monitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_BIT         2
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_FLAG        0x04
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_MASK        0x01
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING(_)          (((_) >> 2) & 0x01)
            UINT32_t reserved1 : 29;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_0f_ecx_01;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_10 \
  *           EAX = 0x10
  *
  * When CPUID executes with EAX set to 10H and ECX = 0, the processor returns information about the bit-vector
  * representation of QoS Enforcement resource types that are supported in the processor. Each bit, starting from bit 1,
  * corresponds to a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index (or ResID)
  * that software must use to query QoS enforcement capability available for that type.
  * When CPUID executes with EAX set to 10H and ECX = n (n >= 1, and is a valid ResID), the processor returns information
  * about available classes of service and range of QoS mask MSRs that software can use to configure each class of services
  * using capability bit masks in the QoS Mask registers, IA32_resourceType_Mask_n.
  * @{
  */
#define CPUID_INTEL_RESOURCE_DIRECTOR_TECHNOLOGY_ALLOCATION_INFORMATION 0x00000010
  /**
   * @brief Intel Resource Director Technology (Intel RDT) Allocation Enumeration Sub-leaf (EAX = 10H, ECX = 0)
   *
   * @note Leaf 10H output depends on the initial value in ECX. Sub-leaf index 0 reports valid resource identification
   *       (ResID) starting at bit position 1 of EBX.
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H).
             */
            UINT32_t ia32_platform_dca_cap : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT                          0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)                           (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            UINT32_t reserved1 : 1;

            /**
             * [Bit 1] Supports L3 Cache Allocation Technology if 1.
             */
            UINT32_t supports_l3_cache_allocation_technology : 1;
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_BIT        1
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_FLAG       0x02
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_MASK       0x01
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY(_)         (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports L2 Cache Allocation Technology if 1.
             */
            UINT32_t supports_l2_cache_allocation_technology : 1;
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_BIT        2
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_FLAG       0x04
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_MASK       0x01
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY(_)         (((_) >> 2) & 0x01)

            /**
             * [Bit 3] Supports Memory Bandwidth Allocation if 1.
             */
            UINT32_t supports_memory_bandwidth_allocation : 1;
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_BIT           3
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_FLAG          0x08
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_MASK          0x01
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION(_)            (((_) >> 3) & 0x01)
            UINT32_t reserved2 : 28;
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_10_ecx_00;

/**
 * @brief L3 Cache Allocation Technology Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 1)
 *
 * @note Leaf 10H output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 4:0] Length of the capacity bit mask for the corresponding ResID using minus-one notation.
             */
            UINT32_t length_of_capacity_bit_mask : 5;
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_BIT                    0
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_FLAG                   0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_MASK                   0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK(_)                     (((_) >> 0) & 0x1F)
            UINT32_t reserved1 : 27;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Bit-granular map of isolation/contention of allocation units.
             */
            UINT32_t ebx_0 : 32;
#define CPUID_EBX_EBX_0_BIT                                          0
#define CPUID_EBX_EBX_0_FLAG                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0_MASK                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0(_)                                           (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            UINT32_t reserved1 : 2;

            /**
             * [Bit 2] Code and Data Prioritization Technology supported if 1.
             */
            UINT32_t code_and_data_priorization_technology_supported : 1;
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_BIT 2
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_FLAG 0x04
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_MASK 0x01
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED(_) (((_) >> 2) & 0x01)
            UINT32_t reserved2 : 29;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Highest COS number supported for this ResID.
             */
            UINT32_t highest_cos_number_supported : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT                   0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_)                    (((_) >> 0) & 0xFFFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_10_ecx_01;

/**
 * @brief L2 Cache Allocation Technology Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 2)
 *
 * @note Leaf 10H output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 4:0] Length of the capacity bit mask for the corresponding ResID using minus-one notation.
             */
            UINT32_t length_of_capacity_bit_mask : 5;
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_BIT                    0
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_FLAG                   0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_MASK                   0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK(_)                     (((_) >> 0) & 0x1F)
            UINT32_t reserved1 : 27;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Bit-granular map of isolation/contention of allocation units.
             */
            UINT32_t ebx_0 : 32;
#define CPUID_EBX_EBX_0_BIT                                          0
#define CPUID_EBX_EBX_0_FLAG                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0_MASK                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0(_)                                           (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Highest COS number supported for this ResID.
             */
            UINT32_t highest_cos_number_supported : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT                   0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_)                    (((_) >> 0) & 0xFFFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_10_ecx_02;

/**
 * @brief Memory Bandwidth Allocation Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 3)
 *
 * @note Leaf 10H output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 11:0] Reports the maximum MBA throttling value supported for the corresponding ResID using minus-one notation.
             */
            UINT32_t max_mba_throttling_value : 12;
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_BIT                       0
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_FLAG                      0xFFF
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_MASK                      0xFFF
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE(_)                        (((_) >> 0) & 0xFFF)
            UINT32_t reserved1 : 20;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            UINT32_t reserved1 : 2;

            /**
             * [Bit 2] Reports whether the response of the delay values is linear.
             */
            UINT32_t response_of_delay_is_linear : 1;
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_BIT                    2
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_FLAG                   0x04
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_MASK                   0x01
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR(_)                     (((_) >> 2) & 0x01)
            UINT32_t reserved2 : 29;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Highest COS number supported for this ResID.
             */
            UINT32_t highest_cos_number_supported : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT                   0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_)                    (((_) >> 0) & 0xFFFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_10_ecx_03;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_12 \
  *           EAX = 0x12
  *
  * When CPUID executes with EAX set to 12H and ECX = 0H, the processor returns information about Intel SGX capabilities.
  * When CPUID executes with EAX set to 12H and ECX = 1H, the processor returns information about Intel SGX attributes.
  * When CPUID executes with EAX set to 12H and ECX = n (n > 1), the processor returns information about Intel SGX Enclave
  * Page Cache.
  * @{
  */
#define CPUID_INTEL_SGX                                              0x00000012
  /**
   * @brief Intel SGX Capability Enumeration Leaf, sub-leaf 0 (EAX = 12H, ECX = 0)
   *
   * @note Leaf 12H sub-leaf 0 (ECX = 0) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bit 0] If 1, Indicates Intel SGX supports the collection of SGX1 leaf functions.
             */
            UINT32_t sgx1 : 1;
#define CPUID_EAX_SGX1_BIT                                           0
#define CPUID_EAX_SGX1_FLAG                                          0x01
#define CPUID_EAX_SGX1_MASK                                          0x01
#define CPUID_EAX_SGX1(_)                                            (((_) >> 0) & 0x01)

            /**
             * [Bit 1] If 1, Indicates Intel SGX supports the collection of SGX2 leaf functions.
             */
            UINT32_t sgx2 : 1;
#define CPUID_EAX_SGX2_BIT                                           1
#define CPUID_EAX_SGX2_FLAG                                          0x02
#define CPUID_EAX_SGX2_MASK                                          0x01
#define CPUID_EAX_SGX2(_)                                            (((_) >> 1) & 0x01)
            UINT32_t reserved1 : 3;

            /**
             * [Bit 5] If 1, indicates Intel SGX supports ENCLV instruction leaves EINCVIRTCHILD, EDECVIRTCHILD, and ESETCONTEXT.
             */
            UINT32_t sgx_enclv_advanced : 1;
#define CPUID_EAX_SGX_ENCLV_ADVANCED_BIT                             5
#define CPUID_EAX_SGX_ENCLV_ADVANCED_FLAG                            0x20
#define CPUID_EAX_SGX_ENCLV_ADVANCED_MASK                            0x01
#define CPUID_EAX_SGX_ENCLV_ADVANCED(_)                              (((_) >> 5) & 0x01)

            /**
             * [Bit 6] If 1, indicates Intel SGX supports ENCLS instruction leaves ETRACKC, ERDINFO, ELDBC, and ELDUC.
             */
            UINT32_t sgx_encls_advanced : 1;
#define CPUID_EAX_SGX_ENCLS_ADVANCED_BIT                             6
#define CPUID_EAX_SGX_ENCLS_ADVANCED_FLAG                            0x40
#define CPUID_EAX_SGX_ENCLS_ADVANCED_MASK                            0x01
#define CPUID_EAX_SGX_ENCLS_ADVANCED(_)                              (((_) >> 6) & 0x01)
            UINT32_t reserved2 : 25;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Bit vector of supported extended SGX features.
             */
            UINT32_t miscselect : 32;
#define CPUID_EBX_MISCSELECT_BIT                                     0
#define CPUID_EBX_MISCSELECT_FLAG                                    0xFFFFFFFF
#define CPUID_EBX_MISCSELECT_MASK                                    0xFFFFFFFF
#define CPUID_EBX_MISCSELECT(_)                                      (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 7:0] The maximum supported enclave size in non-64-bit mode is 2^(EDX[7:0]).
             */
            UINT32_t max_enclave_size_not64 : 8;
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_BIT                         0
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_FLAG                        0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_MASK                        0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64(_)                          (((_) >> 0) & 0xFF)

            /**
             * [Bits 15:8] The maximum supported enclave size in 64-bit mode is 2^(EDX[15:8]).
             */
            UINT32_t max_enclave_size_64 : 8;
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_BIT                            8
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_FLAG                           0xFF00
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_MASK                           0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64(_)                             (((_) >> 8) & 0xFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_12_ecx_00;

/**
 * @brief Intel SGX Attributes Enumeration Leaf, sub-leaf 1 (EAX = 12H, ECX = 1)
 *
 * @note Leaf 12H sub-leaf 1 (ECX = 1) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[31:0] that software can set with ECREATE.
             */
            UINT32_t valid_secs_attributes_0 : 32;
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_BIT                        0
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_FLAG                       0xFFFFFFFF
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_MASK                       0xFFFFFFFF
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[63:32] that software can set with ECREATE.
             */
            UINT32_t valid_secs_attributes_1 : 32;
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_BIT                        0
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_FLAG                       0xFFFFFFFF
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_MASK                       0xFFFFFFFF
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[95:64] that software can set with ECREATE.
             */
            UINT32_t valid_secs_attributes_2 : 32;
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_BIT                        0
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_FLAG                       0xFFFFFFFF
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_MASK                       0xFFFFFFFF
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[127:96] that software can set with ECREATE.
             */
            UINT32_t valid_secs_attributes_3 : 32;
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_BIT                        0
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_FLAG                       0xFFFFFFFF
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_MASK                       0xFFFFFFFF
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_12_ecx_01;

/**
 * @brief Intel SGX EPC Enumeration Leaf, sub-leaves (EAX = 12H, ECX = 2 or higher)
 *
 * @note Leaf 12H sub-leaf 2 or higher (ECX >= 2) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
 *       This structure describes sub-leaf type 0.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 3:0] Sub-leaf Type 0. Indicates this sub-leaf is invalid.
             */
            UINT32_t sub_leaf_type : 4;
#define CPUID_EAX_SUB_LEAF_TYPE_BIT                                  0
#define CPUID_EAX_SUB_LEAF_TYPE_FLAG                                 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE_MASK                                 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE(_)                                   (((_) >> 0) & 0x0F)
            UINT32_t reserved1 : 28;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is zero.
             */
            UINT32_t zero : 32;
#define CPUID_EBX_ZERO_BIT                                           0
#define CPUID_EBX_ZERO_FLAG                                          0xFFFFFFFF
#define CPUID_EBX_ZERO_MASK                                          0xFFFFFFFF
#define CPUID_EBX_ZERO(_)                                            (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is zero.
             */
            UINT32_t zero : 32;
#define CPUID_ECX_ZERO_BIT                                           0
#define CPUID_ECX_ZERO_FLAG                                          0xFFFFFFFF
#define CPUID_ECX_ZERO_MASK                                          0xFFFFFFFF
#define CPUID_ECX_ZERO(_)                                            (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is zero.
             */
            UINT32_t zero : 32;
#define CPUID_EDX_ZERO_BIT                                           0
#define CPUID_EDX_ZERO_FLAG                                          0xFFFFFFFF
#define CPUID_EDX_ZERO_MASK                                          0xFFFFFFFF
#define CPUID_EDX_ZERO(_)                                            (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_12_ecx_02p_slt_0;

/**
 * @brief Intel SGX EPC Enumeration Leaf, sub-leaves (EAX = 12H, ECX = 2 or higher)
 *
 * @note Leaf 12H sub-leaf 2 or higher (ECX >= 2) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
 *       This structure describes sub-leaf type 1.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 3:0] Sub-leaf Type 1. This sub-leaf enumerates an EPC section. EBX:EAX and EDX:ECX provide information on the
             * Enclave Page Cache (EPC) section.
             */
            UINT32_t sub_leaf_type : 4;
#define CPUID_EAX_SUB_LEAF_TYPE_BIT                                  0
#define CPUID_EAX_SUB_LEAF_TYPE_FLAG                                 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE_MASK                                 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE(_)                                   (((_) >> 0) & 0x0F)
            UINT32_t reserved1 : 8;

            /**
             * [Bits 31:12] Bits 31:12 of the physical address of the base of the EPC section.
             */
            UINT32_t epc_base_physical_address_1 : 20;
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_BIT                    12
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_FLAG                   0xFFFFF000
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_MASK                   0xFFFFF
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1(_)                     (((_) >> 12) & 0xFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 19:0] Bits 51:32 of the physical address of the base of the EPC section.
             */
            UINT32_t epc_base_physical_address_2 : 20;
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_BIT                    0
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_FLAG                   0xFFFFF
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_MASK                   0xFFFFF
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2(_)                     (((_) >> 0) & 0xFFFFF)
            UINT32_t reserved1 : 12;
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 3:0] EPC section property encoding defined as follows:
             * - If EAX[3:0] 0000b, then all bits of the EDX:ECX pair are enumerated as 0.
             * - If EAX[3:0] 0001b, then this section has confidentiality and integrity protection.
             * All other encodings are reserved.
             */
            UINT32_t epc_section_property : 4;
#define CPUID_ECX_EPC_SECTION_PROPERTY_BIT                           0
#define CPUID_ECX_EPC_SECTION_PROPERTY_FLAG                          0x0F
#define CPUID_ECX_EPC_SECTION_PROPERTY_MASK                          0x0F
#define CPUID_ECX_EPC_SECTION_PROPERTY(_)                            (((_) >> 0) & 0x0F)
            UINT32_t reserved1 : 8;

            /**
             * [Bits 31:12] Bits 31:12 of the size of the corresponding EPC section within the Processor Reserved Memory.
             */
            UINT32_t epc_size_1 : 20;
#define CPUID_ECX_EPC_SIZE_1_BIT                                     12
#define CPUID_ECX_EPC_SIZE_1_FLAG                                    0xFFFFF000
#define CPUID_ECX_EPC_SIZE_1_MASK                                    0xFFFFF
#define CPUID_ECX_EPC_SIZE_1(_)                                      (((_) >> 12) & 0xFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 19:0] Bits 51:32 of the size of the corresponding EPC section within the Processor Reserved Memory.
             */
            UINT32_t epc_size_2 : 20;
#define CPUID_EDX_EPC_SIZE_2_BIT                                     0
#define CPUID_EDX_EPC_SIZE_2_FLAG                                    0xFFFFF
#define CPUID_EDX_EPC_SIZE_2_MASK                                    0xFFFFF
#define CPUID_EDX_EPC_SIZE_2(_)                                      (((_) >> 0) & 0xFFFFF)
            UINT32_t reserved1 : 12;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_12_ecx_02p_slt_1;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_14 \
  *           EAX = 0x14
  *
  * When CPUID executes with EAX set to 14H and ECX = 0H, the processor returns information about Intel Processor Trace
  * extensions.
  * When CPUID executes with EAX set to 14H and ECX = n (n > 0 and less than the number of non-zero bits in CPUID.(EAX=14H,
  * ECX= 0H).EAX), the processor returns information about packet generation in Intel Processor Trace.
  * @{
  */
#define CPUID_INTEL_PROCESSOR_TRACE_INFORMATION                      0x00000014
  /**
   * @brief Intel Processor Trace Enumeration Main Leaf (EAX = 14H, ECX = 0)
   *
   * @note Leaf 14H main leaf (ECX = 0).
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the maximum sub-leaf supported in leaf 14H.
             */
            UINT32_t max_sub_leaf : 32;
#define CPUID_EAX_MAX_SUB_LEAF_BIT                                   0
#define CPUID_EAX_MAX_SUB_LEAF_FLAG                                  0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF_MASK                                  0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF(_)                                    (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] If 1, indicates that IA32_RTIT_CTL.CR3Filter can be set to 1, and that IA32_RTIT_CR3_MATCH MSR can be accessed.
             */
            UINT32_t flag0 : 1;
#define CPUID_EBX_FLAG0_BIT                                          0
#define CPUID_EBX_FLAG0_FLAG                                         0x01
#define CPUID_EBX_FLAG0_MASK                                         0x01
#define CPUID_EBX_FLAG0(_)                                           (((_) >> 0) & 0x01)

            /**
             * [Bit 1] If 1, indicates support of Configurable PSB and Cycle-Accurate Mode.
             */
            UINT32_t flag1 : 1;
#define CPUID_EBX_FLAG1_BIT                                          1
#define CPUID_EBX_FLAG1_FLAG                                         0x02
#define CPUID_EBX_FLAG1_MASK                                         0x01
#define CPUID_EBX_FLAG1(_)                                           (((_) >> 1) & 0x01)

            /**
             * [Bit 2] If 1, indicates support of IP Filtering, TraceStop filtering, and preservation of Intel PT MSRs across warm
             * reset.
             */
            UINT32_t flag2 : 1;
#define CPUID_EBX_FLAG2_BIT                                          2
#define CPUID_EBX_FLAG2_FLAG                                         0x04
#define CPUID_EBX_FLAG2_MASK                                         0x01
#define CPUID_EBX_FLAG2(_)                                           (((_) >> 2) & 0x01)

            /**
             * [Bit 3] If 1, indicates support of MTC timing packet and suppression of COFI-based packets.
             */
            UINT32_t flag3 : 1;
#define CPUID_EBX_FLAG3_BIT                                          3
#define CPUID_EBX_FLAG3_FLAG                                         0x08
#define CPUID_EBX_FLAG3_MASK                                         0x01
#define CPUID_EBX_FLAG3(_)                                           (((_) >> 3) & 0x01)

            /**
             * [Bit 4] If 1, indicates support of PTWRITE. Writes can set IA32_RTIT_CTL[12] (PTWEn) and IA32_RTIT_CTL[5] (FUPonPTW),
             * and PTWRITE can generate packets.
             */
            UINT32_t flag4 : 1;
#define CPUID_EBX_FLAG4_BIT                                          4
#define CPUID_EBX_FLAG4_FLAG                                         0x10
#define CPUID_EBX_FLAG4_MASK                                         0x01
#define CPUID_EBX_FLAG4(_)                                           (((_) >> 4) & 0x01)

            /**
             * [Bit 5] If 1, indicates support of Power Event Trace. Writes can set IA32_RTIT_CTL[4] (PwrEvtEn), enabling Power Event
             * Trace packet generation.
             */
            UINT32_t flag5 : 1;
#define CPUID_EBX_FLAG5_BIT                                          5
#define CPUID_EBX_FLAG5_FLAG                                         0x20
#define CPUID_EBX_FLAG5_MASK                                         0x01
#define CPUID_EBX_FLAG5(_)                                           (((_) >> 5) & 0x01)
            UINT32_t reserved1 : 26;
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] If 1, Tracing can be enabled with IA32_RTIT_CTL.ToPA = 1, hence utilizing the ToPA output scheme;
             * IA32_RTIT_OUTPUT_BASE and IA32_RTIT_OUTPUT_MASK_PTRS MSRs can be accessed.
             */
            UINT32_t flag0 : 1;
#define CPUID_ECX_FLAG0_BIT                                          0
#define CPUID_ECX_FLAG0_FLAG                                         0x01
#define CPUID_ECX_FLAG0_MASK                                         0x01
#define CPUID_ECX_FLAG0(_)                                           (((_) >> 0) & 0x01)

            /**
             * [Bit 1] If 1, ToPA tables can hold any number of output entries, up to the maximum allowed by the MaskOrTableOffset
             * field of IA32_RTIT_OUTPUT_MASK_PTRS.
             */
            UINT32_t flag1 : 1;
#define CPUID_ECX_FLAG1_BIT                                          1
#define CPUID_ECX_FLAG1_FLAG                                         0x02
#define CPUID_ECX_FLAG1_MASK                                         0x01
#define CPUID_ECX_FLAG1(_)                                           (((_) >> 1) & 0x01)

            /**
             * [Bit 2] If 1, indicates support of Single-Range Output scheme.
             */
            UINT32_t flag2 : 1;
#define CPUID_ECX_FLAG2_BIT                                          2
#define CPUID_ECX_FLAG2_FLAG                                         0x04
#define CPUID_ECX_FLAG2_MASK                                         0x01
#define CPUID_ECX_FLAG2(_)                                           (((_) >> 2) & 0x01)

            /**
             * [Bit 3] If 1, indicates support of output to Trace Transport subsystem.
             */
            UINT32_t flag3 : 1;
#define CPUID_ECX_FLAG3_BIT                                          3
#define CPUID_ECX_FLAG3_FLAG                                         0x08
#define CPUID_ECX_FLAG3_MASK                                         0x01
#define CPUID_ECX_FLAG3(_)                                           (((_) >> 3) & 0x01)
            UINT32_t reserved1 : 27;

            /**
             * [Bit 31] If 1, generated packets which contain IP payloads have LIP values, which include the CS base component.
             */
            UINT32_t flag31 : 1;
#define CPUID_ECX_FLAG31_BIT                                         31
#define CPUID_ECX_FLAG31_FLAG                                        0x80000000
#define CPUID_ECX_FLAG31_MASK                                        0x01
#define CPUID_ECX_FLAG31(_)                                          (((_) >> 31) & 0x01)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_14_ecx_00;

/**
 * @brief Intel Processor Trace Enumeration Sub-leaf (EAX = 14H, ECX = 1)
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 2:0] Number of configurable Address Ranges for filtering.
             */
            UINT32_t number_of_configurable_address_ranges_for_filtering : 3;
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_BIT 0
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_FLAG 0x07
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_MASK 0x07
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING(_) (((_) >> 0) & 0x07)
            UINT32_t reserved1 : 13;

            /**
             * [Bits 31:16] Bitmap of supported MTC period encodings.
             */
            UINT32_t bitmap_of_supported_mtc_period_encodings : 16;
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_BIT       16
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_FLAG      0xFFFF0000
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_MASK      0xFFFF
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS(_)        (((_) >> 16) & 0xFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Bitmap of supported Cycle Threshold value encodings.
             */
            UINT32_t bitmap_of_supported_cycle_threshold_value_encodings : 16;
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_BIT 0
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_FLAG 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_MASK 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS(_) (((_) >> 0) & 0xFFFF)

            /**
             * [Bits 31:16] Bitmap of supported Configurable PSB frequency encodings.
             */
            UINT32_t bitmap_of_supported_configurable_psb_frequency_encodings : 16;
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_BIT 16
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_FLAG 0xFFFF0000
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_MASK 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS(_) (((_) >> 16) & 0xFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_14_ecx_01;

/**
 * @}
 */


 /**
  * @brief Stamp Counter and Nominal Core Crystal Clock Information Leaf
  *
  * When CPUID executes with EAX set to 15H and ECX = 0H, the processor returns information about Time Stamp Counter and
  * Core Crystal Clock.
  *
  * @note If EBX[31:0] is 0, the TSC/"core crystal clock" ratio is not enumerated. EBX[31:0]/EAX[31:0] indicates the ratio
  *       of the TSC frequency and the core crystal clock frequency.
  *       If ECX is 0, the nominal core crystal clock frequency is not enumerated. "TSC frequency" = "core crystal clock
  *       frequency" * EBX/EAX.
  */
#define CPUID_TIME_STAMP_COUNTER_INFORMATION                         0x00000015
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] An unsigned integer which is the denominator of the TSC/"core crystal clock" ratio.
             */
            UINT32_t denominator : 32;
#define CPUID_EAX_DENOMINATOR_BIT                                    0
#define CPUID_EAX_DENOMINATOR_FLAG                                   0xFFFFFFFF
#define CPUID_EAX_DENOMINATOR_MASK                                   0xFFFFFFFF
#define CPUID_EAX_DENOMINATOR(_)                                     (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] An unsigned integer which is the numerator of the TSC/"core crystal clock" ratio.
             */
            UINT32_t numerator : 32;
#define CPUID_EBX_NUMERATOR_BIT                                      0
#define CPUID_EBX_NUMERATOR_FLAG                                     0xFFFFFFFF
#define CPUID_EBX_NUMERATOR_MASK                                     0xFFFFFFFF
#define CPUID_EBX_NUMERATOR(_)                                       (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] An unsigned integer which is the nominal frequency of the core crystal clock in Hz.
             */
            UINT32_t nominal_frequency : 32;
#define CPUID_ECX_NOMINAL_FREQUENCY_BIT                              0
#define CPUID_ECX_NOMINAL_FREQUENCY_FLAG                             0xFFFFFFFF
#define CPUID_ECX_NOMINAL_FREQUENCY_MASK                             0xFFFFFFFF
#define CPUID_ECX_NOMINAL_FREQUENCY(_)                               (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_15;


/**
 * @brief Processor Frequency Information Leaf
 *
 * When CPUID executes with EAX set to 16H, the processor returns information about Processor Frequency Information.
 *
 * @note Data is returned from this interface in accordance with the processor's specification and does not reflect actual
 *       values. Suitable use of this data includes the display of processor information in like manner to the processor brand
 *       string and for determining the appropriate range to use when displaying processor information e.g. frequency history
 *       graphs. The returned information should not be used for any other purpose as the returned information does not
 *       accurately correlate to information / counters returned by other processor interfaces.
 *       While a processor may support the Processor Frequency Information leaf, fields that return a value of zero are not
 *       supported.
 */
#define CPUID_PROCESSOR_FREQUENCY_INFORMATION                        0x00000016
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 15:0] Processor Base Frequency (in MHz).
             */
            UINT32_t procesor_base_frequency_mhz : 16;
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_BIT                    0
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_FLAG                   0xFFFF
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_MASK                   0xFFFF
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ(_)                     (((_) >> 0) & 0xFFFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Maximum Frequency (in MHz).
             */
            UINT32_t processor_maximum_frequency_mhz : 16;
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_BIT                0
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_FLAG               0xFFFF
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_MASK               0xFFFF
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ(_)                 (((_) >> 0) & 0xFFFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Bus (Reference) Frequency (in MHz).
             */
            UINT32_t bus_frequency_mhz : 16;
#define CPUID_ECX_BUS_FREQUENCY_MHZ_BIT                              0
#define CPUID_ECX_BUS_FREQUENCY_MHZ_FLAG                             0xFFFF
#define CPUID_ECX_BUS_FREQUENCY_MHZ_MASK                             0xFFFF
#define CPUID_ECX_BUS_FREQUENCY_MHZ(_)                               (((_) >> 0) & 0xFFFF)
            UINT32_t reserved1 : 16;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_16;

/**
 * @defgroup cpuid_eax_17 \
 *           EAX = 0x17
 *
 * When CPUID executes with EAX set to 17H, the processor returns information about the System-On-Chip Vendor Attribute
 * Enumeration.
 * @{
 */
#define CPUID_SOC_VENDOR_INFORMATION                                 0x00000017
 /**
  * @brief System-On-Chip Vendor Attribute Enumeration Main Leaf (EAX = 17H, ECX = 0)
  *
  * @note Leaf 17H main leaf (ECX = 0). Leaf 17H output depends on the initial value in ECX. Leaf 17H sub-leaves 1 through 3
  *       reports SOC Vendor Brand String. Leaf 17H is valid if MaxSOCID_Index >= 3. Leaf 17H sub-leaves 4 and above are reserved.
  */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the maximum input value of supported sub-leaf in leaf 17H.
             */
            UINT32_t max_soc_id_index : 32;
#define CPUID_EAX_MAX_SOC_ID_INDEX_BIT                               0
#define CPUID_EAX_MAX_SOC_ID_INDEX_FLAG                              0xFFFFFFFF
#define CPUID_EAX_MAX_SOC_ID_INDEX_MASK                              0xFFFFFFFF
#define CPUID_EAX_MAX_SOC_ID_INDEX(_)                                (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] SOC Vendor ID.
             */
            UINT32_t soc_vendor_id : 16;
#define CPUID_EBX_SOC_VENDOR_ID_BIT                                  0
#define CPUID_EBX_SOC_VENDOR_ID_FLAG                                 0xFFFF
#define CPUID_EBX_SOC_VENDOR_ID_MASK                                 0xFFFF
#define CPUID_EBX_SOC_VENDOR_ID(_)                                   (((_) >> 0) & 0xFFFF)

            /**
             * [Bit 16] If 1, the SOC Vendor ID field is assigned via an industry standard enumeration scheme. Otherwise, the SOC
             * Vendor ID field is assigned by Intel.
             */
            UINT32_t is_vendor_scheme : 1;
#define CPUID_EBX_IS_VENDOR_SCHEME_BIT                               16
#define CPUID_EBX_IS_VENDOR_SCHEME_FLAG                              0x10000
#define CPUID_EBX_IS_VENDOR_SCHEME_MASK                              0x01
#define CPUID_EBX_IS_VENDOR_SCHEME(_)                                (((_) >> 16) & 0x01)
            UINT32_t reserved1 : 15;
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] A unique number an SOC vendor assigns to its SOC projects.
             */
            UINT32_t project_id : 32;
#define CPUID_ECX_PROJECT_ID_BIT                                     0
#define CPUID_ECX_PROJECT_ID_FLAG                                    0xFFFFFFFF
#define CPUID_ECX_PROJECT_ID_MASK                                    0xFFFFFFFF
#define CPUID_ECX_PROJECT_ID(_)                                      (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] A unique number within an SOC project that an SOC vendor assigns.
             */
            UINT32_t stepping_id : 32;
#define CPUID_EDX_STEPPING_ID_BIT                                    0
#define CPUID_EDX_STEPPING_ID_FLAG                                   0xFFFFFFFF
#define CPUID_EDX_STEPPING_ID_MASK                                   0xFFFFFFFF
#define CPUID_EDX_STEPPING_ID(_)                                     (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_17_ecx_00;

/**
 * @brief System-On-Chip Vendor Attribute Enumeration Sub-leaf (EAX = 17H, ECX = 1..3)
 *
 * @note Leaf 17H output depends on the initial value in ECX. SOC Vendor Brand String is a UTF-8 encoded string padded with
 *       trailing bytes of 00H. The complete SOC Vendor Brand String is constructed by concatenating in ascending order of
 *       EAX:EBX:ECX:EDX and from the sub-leaf 1 fragment towards sub-leaf 3.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
             */
            UINT32_t soc_vendor_brand_string : 32;
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING_BIT                        0
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
             */
            UINT32_t soc_vendor_brand_string : 32;
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_BIT                        0
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
             */
            UINT32_t soc_vendor_brand_string : 32;
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_BIT                        0
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
             */
            UINT32_t soc_vendor_brand_string : 32;
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_BIT                        0
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_17_ecx_01_03;

/**
 * @brief System-On-Chip Vendor Attribute Enumeration Sub-leaves (EAX = 17H, ECX > MaxSOCID_Index)
 *
 * @note Leaf 17H output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reserved = 0.
             */
            UINT32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reserved = 0.
             */
            UINT32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reserved = 0.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reserved = 0.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_17_ecx_n;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_18 \
  *           EAX = 0x18
  *
  * When CPUID executes with EAX set to 18H, the processor returns information about the Deterministic Address Translation
  * Parameters.
  * @{
  */
#define CPUID_DETERMINISTIC_ADDRESS_TRANSLATION_PARAMETERS           0x00000018
  /**
   * @brief Deterministic Address Translation Parameters Main Leaf (EAX = 18H, ECX = 0)
   *
   * @note Each sub-leaf enumerates a different address translation structure.
   *       If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is invalid if n exceeds the value
   *       that sub-leaf 0 returns in EAX. A sub-leaf index is also invalid if EDX[4:0] returns 0. Valid sub-leaves do not need to
   *       be contiguous or in any particular order. A valid sub-leaf may be in a higher input ECX value than an invalid sub-leaf
   *       or than a valid sub-leaf of a higher or lower-level structure.
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the maximum input value of supported sub-leaf in leaf 18H.
             */
            UINT32_t max_sub_leaf : 32;
#define CPUID_EAX_MAX_SUB_LEAF_BIT                                   0
#define CPUID_EAX_MAX_SUB_LEAF_FLAG                                  0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF_MASK                                  0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF(_)                                    (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] 4K page size entries supported by this structure.
             */
            UINT32_t page_entries_4kb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_BIT                     0
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_FLAG                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED(_)                      (((_) >> 0) & 0x01)

            /**
             * [Bit 1] 2MB page size entries supported by this structure.
             */
            UINT32_t page_entries_2mb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_BIT                     1
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_FLAG                    0x02
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED(_)                      (((_) >> 1) & 0x01)

            /**
             * [Bit 2] 4MB page size entries supported by this structure.
             */
            UINT32_t page_entries_4mb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_BIT                     2
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_FLAG                    0x04
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED(_)                      (((_) >> 2) & 0x01)

            /**
             * [Bit 3] 1 GB page size entries supported by this structure.
             */
            UINT32_t page_entries_1gb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_BIT                     3
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_FLAG                    0x08
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED(_)                      (((_) >> 3) & 0x01)
            UINT32_t reserved1 : 4;

            /**
             * [Bits 10:8] Partitioning (0: Soft partitioning between the logical processors sharing this structure).
             */
            UINT32_t partitioning : 3;
#define CPUID_EBX_PARTITIONING_BIT                                   8
#define CPUID_EBX_PARTITIONING_FLAG                                  0x700
#define CPUID_EBX_PARTITIONING_MASK                                  0x07
#define CPUID_EBX_PARTITIONING(_)                                    (((_) >> 8) & 0x07)
            UINT32_t reserved2 : 5;

            /**
             * [Bits 31:16] W = Ways of associativity.
             */
            UINT32_t ways_of_associativity_00 : 16;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_BIT                       16
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_FLAG                      0xFFFF0000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_MASK                      0xFFFF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00(_)                        (((_) >> 16) & 0xFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Number of Sets.
             */
            UINT32_t number_of_sets : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT                                 0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 4:0] Translation cache type field.
             * - 00000b: Null (indicates this sub-leaf is not valid).
             * - 00001b: Data TLB.
             * - 00010b: Instruction TLB.
             * - 00011b: Unified TLB.
             * All other encodings are reserved.
             *
             * @note Some unified TLBs will allow a single TLB entry to satisfy data read/write and instruction fetches. Others will
             *       require separate entries (e.g., one loaded on data read/write and another loaded on an instruction fetch) . Please see
             *       the Intel(R) 64 and IA-32 Architectures Optimization Reference Manual for details of a particular product.
             */
            UINT32_t translation_cache_type_field : 5;
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_BIT                   0
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_FLAG                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_MASK                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD(_)                    (((_) >> 0) & 0x1F)

            /**
             * [Bits 7:5] Translation cache level (starts at 1).
             */
            UINT32_t translation_cache_level : 3;
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_BIT                        5
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_FLAG                       0xE0
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_MASK                       0x07
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL(_)                         (((_) >> 5) & 0x07)

            /**
             * [Bit 8] Fully associative structure.
             */
            UINT32_t fully_associative_structure : 1;
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_BIT                    8
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_FLAG                   0x100
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_MASK                   0x01
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE(_)                     (((_) >> 8) & 0x01)
            UINT32_t reserved1 : 5;

            /**
             * [Bits 25:14] Maximum number of addressable IDs for logical processors sharing this translation cache.
             *
             * @note Add one to the return value to get the result.
             */
            UINT32_t max_addressable_ids_for_logical_processors : 12;
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_BIT     14
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_FLAG    0x3FFC000
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_MASK    0xFFF
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS(_)      (((_) >> 14) & 0xFFF)
            UINT32_t reserved2 : 6;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_18_ecx_00;

/**
 * @brief Deterministic Address Translation Parameters Sub-leaf (EAX = 18H, ECX >= 1)
 *
 * @note Each sub-leaf enumerates a different address translation structure.
 *       If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is invalid if n exceeds the value
 *       that sub-leaf 0 returns in EAX. A sub-leaf index is also invalid if EDX[4:0] returns 0. Valid sub-leaves do not need to
 *       be contiguous or in any particular order. A valid sub-leaf may be in a higher input ECX value than an invalid sub-leaf
 *       or than a valid sub-leaf of a higher or lower-level structure.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] 4K page size entries supported by this structure.
             */
            UINT32_t page_entries_4kb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_BIT                     0
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_FLAG                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED(_)                      (((_) >> 0) & 0x01)

            /**
             * [Bit 1] 2MB page size entries supported by this structure.
             */
            UINT32_t page_entries_2mb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_BIT                     1
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_FLAG                    0x02
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED(_)                      (((_) >> 1) & 0x01)

            /**
             * [Bit 2] 4MB page size entries supported by this structure.
             */
            UINT32_t page_entries_4mb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_BIT                     2
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_FLAG                    0x04
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED(_)                      (((_) >> 2) & 0x01)

            /**
             * [Bit 3] 1 GB page size entries supported by this structure.
             */
            UINT32_t page_entries_1gb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_BIT                     3
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_FLAG                    0x08
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED(_)                      (((_) >> 3) & 0x01)
            UINT32_t reserved1 : 4;

            /**
             * [Bits 10:8] Partitioning (0: Soft partitioning between the logical processors sharing this structure).
             */
            UINT32_t partitioning : 3;
#define CPUID_EBX_PARTITIONING_BIT                                   8
#define CPUID_EBX_PARTITIONING_FLAG                                  0x700
#define CPUID_EBX_PARTITIONING_MASK                                  0x07
#define CPUID_EBX_PARTITIONING(_)                                    (((_) >> 8) & 0x07)
            UINT32_t reserved2 : 5;

            /**
             * [Bits 31:16] W = Ways of associativity.
             */
            UINT32_t ways_of_associativity_01 : 16;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_BIT                       16
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_FLAG                      0xFFFF0000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_MASK                      0xFFFF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01(_)                        (((_) >> 16) & 0xFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Number of Sets.
             */
            UINT32_t number_of_sets : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT                                 0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 4:0] Translation cache type field.
             * - 00000b: Null (indicates this sub-leaf is not valid).
             * - 00001b: Data TLB.
             * - 00010b: Instruction TLB.
             * - 00011b: Unified TLB.
             * All other encodings are reserved.
             *
             * @note Some unified TLBs will allow a single TLB entry to satisfy data read/write and instruction fetches. Others will
             *       require separate entries (e.g., one loaded on data read/write and another loaded on an instruction fetch) . Please see
             *       the Intel(R) 64 and IA-32 Architectures Optimization Reference Manual for details of a particular product.
             */
            UINT32_t translation_cache_type_field : 5;
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_BIT                   0
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_FLAG                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_MASK                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD(_)                    (((_) >> 0) & 0x1F)

            /**
             * [Bits 7:5] Translation cache level (starts at 1).
             */
            UINT32_t translation_cache_level : 3;
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_BIT                        5
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_FLAG                       0xE0
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_MASK                       0x07
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL(_)                         (((_) >> 5) & 0x07)

            /**
             * [Bit 8] Fully associative structure.
             */
            UINT32_t fully_associative_structure : 1;
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_BIT                    8
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_FLAG                   0x100
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_MASK                   0x01
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE(_)                     (((_) >> 8) & 0x01)
            UINT32_t reserved1 : 5;

            /**
             * [Bits 25:14] Maximum number of addressable IDs for logical processors sharing this translation cache.
             *
             * @note Add one to the return value to get the result.
             */
            UINT32_t max_addressable_ids_for_logical_processors : 12;
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_BIT     14
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_FLAG    0x3FFC000
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_MASK    0xFFF
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS(_)      (((_) >> 14) & 0xFFF)
            UINT32_t reserved2 : 6;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_18_ecx_01p;

/**
 * @}
 */


 /**
  * @brief Extended Function CPUID Information
  *
  * When CPUID executes with EAX set to 80000000H, the processor returns the highest value the processor recognizes for
  * returning extended processor information. The value is returned in the EAX register and is processor specific.
  */
#define CPUID_EXTENDED_FUNCTION_INFORMATION                          0x80000000
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum Input Value for Extended Function CPUID Information.
             */
            UINT32_t max_extended_functions : 32;
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_BIT                         0
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_FLAG                        0xFFFFFFFF
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_MASK                        0xFFFFFFFF
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS(_)                          (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_80000000;


/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_CPU_SIGNATURE                                 0x80000001
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] LAHF/SAHF available in 64-bit mode.
             */
            UINT32_t lahf_sahf_available_in_64_bit_mode : 1;
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_BIT             0
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_FLAG            0x01
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_MASK            0x01
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE(_)              (((_) >> 0) & 0x01)
            UINT32_t reserved1 : 4;

            /**
             * [Bit 5] LZCNT.
             */
            UINT32_t lzcnt : 1;
#define CPUID_ECX_LZCNT_BIT                                          5
#define CPUID_ECX_LZCNT_FLAG                                         0x20
#define CPUID_ECX_LZCNT_MASK                                         0x01
#define CPUID_ECX_LZCNT(_)                                           (((_) >> 5) & 0x01)
            UINT32_t reserved2 : 2;

            /**
             * [Bit 8] PREFETCHW.
             */
            UINT32_t prefetchw : 1;
#define CPUID_ECX_PREFETCHW_BIT                                      8
#define CPUID_ECX_PREFETCHW_FLAG                                     0x100
#define CPUID_ECX_PREFETCHW_MASK                                     0x01
#define CPUID_ECX_PREFETCHW(_)                                       (((_) >> 8) & 0x01)
            UINT32_t reserved3 : 23;
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            UINT32_t reserved1 : 11;

            /**
             * [Bit 11] SYSCALL/SYSRET available in 64-bit mode.
             */
            UINT32_t syscall_sysret_available_in_64_bit_mode : 1;
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_BIT        11
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_FLAG       0x800
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_MASK       0x01
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE(_)         (((_) >> 11) & 0x01)
            UINT32_t reserved2 : 8;

            /**
             * [Bit 20] Execute Disable Bit available.
             */
            UINT32_t execute_disable_bit_available : 1;
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_BIT                  20
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_FLAG                 0x100000
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_MASK                 0x01
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE(_)                   (((_) >> 20) & 0x01)
            UINT32_t reserved3 : 5;

            /**
             * [Bit 26] 1-GByte pages are available if 1.
             */
            UINT32_t pages_1gb_available : 1;
#define CPUID_EDX_PAGES_1GB_AVAILABLE_BIT                            26
#define CPUID_EDX_PAGES_1GB_AVAILABLE_FLAG                           0x4000000
#define CPUID_EDX_PAGES_1GB_AVAILABLE_MASK                           0x01
#define CPUID_EDX_PAGES_1GB_AVAILABLE(_)                             (((_) >> 26) & 0x01)

            /**
             * [Bit 27] RDTSCP and IA32_TSC_AUX are available if 1.
             */
            UINT32_t rdtscp_available : 1;
#define CPUID_EDX_RDTSCP_AVAILABLE_BIT                               27
#define CPUID_EDX_RDTSCP_AVAILABLE_FLAG                              0x8000000
#define CPUID_EDX_RDTSCP_AVAILABLE_MASK                              0x01
#define CPUID_EDX_RDTSCP_AVAILABLE(_)                                (((_) >> 27) & 0x01)
            UINT32_t reserved4 : 1;

            /**
             * [Bit 29] Intel(R) 64 Architecture available if 1.
             */
            UINT32_t ia64_available : 1;
#define CPUID_EDX_IA64_AVAILABLE_BIT                                 29
#define CPUID_EDX_IA64_AVAILABLE_FLAG                                0x20000000
#define CPUID_EDX_IA64_AVAILABLE_MASK                                0x01
#define CPUID_EDX_IA64_AVAILABLE(_)                                  (((_) >> 29) & 0x01)
            UINT32_t reserved5 : 2;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_80000001;


/**
 * Extended Function CPUID Information.
 */
#define CPUID_BRAND_STRING1                                          0x80000002

 /**
  * Extended Function CPUID Information.
  */
#define CPUID_BRAND_STRING2                                          0x80000003

  /**
   * Extended Function CPUID Information.
   */
#define CPUID_BRAND_STRING3                                          0x80000004
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String.
             */
            UINT32_t processor_brand_string_1 : 32;
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1_BIT                       0
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1_FLAG                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1_MASK                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_2 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_BIT                       0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_FLAG                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_MASK                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_3 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_BIT                       0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_FLAG                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_MASK                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_4 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_BIT                       0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_FLAG                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_MASK                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_80000002;

/**
 * @brief Extended Function CPUID Information
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_5 : 32;
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5_BIT                       0
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5_FLAG                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5_MASK                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_6 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_BIT                       0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_FLAG                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_MASK                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_7 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_BIT                       0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_FLAG                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_MASK                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_8 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_BIT                       0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_FLAG                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_MASK                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_80000003;

/**
 * @brief Extended Function CPUID Information
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_9 : 32;
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9_BIT                       0
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9_FLAG                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9_MASK                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_10 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_BIT                      0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_FLAG                     0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_MASK                     0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10(_)                       (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_11 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_BIT                      0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_FLAG                     0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_MASK                     0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11(_)                       (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            UINT32_t processor_brand_string_12 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_BIT                      0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_FLAG                     0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_MASK                     0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12(_)                       (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_80000004;

/**
 * @brief Extended Function CPUID Information
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_80000005;


/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_CACHE_INFO                                    0x80000006
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 7:0] Cache Line size in bytes.
             */
            UINT32_t cache_line_size_inUINT8s : 8;
#define CPUID_ECX_CACHE_LINE_SIZE_INUINT8S_BIT                       0
#define CPUID_ECX_CACHE_LINE_SIZE_INUINT8S_FLAG                      0xFF
#define CPUID_ECX_CACHE_LINE_SIZE_INUINT8S_MASK                      0xFF
#define CPUID_ECX_CACHE_LINE_SIZE_INUINT8S(_)                        (((_) >> 0) & 0xFF)
            UINT32_t reserved1 : 4;

            /**
             * [Bits 15:12] L2 Associativity field.
             * L2 associativity field encodings:
             * - 00H - Disabled.
             * - 01H - Direct mapped.
             * - 02H - 2-way.
             * - 04H - 4-way.
             * - 06H - 8-way.
             * - 08H - 16-way.
             * - 0FH - Fully associative.
             */
            UINT32_t l2_associativity_field : 4;
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_BIT                         12
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_FLAG                        0xF000
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_MASK                        0x0F
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD(_)                          (((_) >> 12) & 0x0F)

            /**
             * [Bits 31:16] Cache size in 1K units.
             */
            UINT32_t cache_size_in_1k_units : 16;
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_BIT                         16
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_FLAG                        0xFFFF0000
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_MASK                        0xFFFF
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS(_)                          (((_) >> 16) & 0xFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_80000006;


/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_TIME_STAMP_COUNTER                            0x80000007
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            UINT32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        UINT32_t flags;
    } ecx;

    union
    {
        struct
        {
            UINT32_t reserved1 : 8;

            /**
             * [Bit 8] Invariant TSC available if 1.
             */
            UINT32_t invariant_tsc_available : 1;
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_BIT                        8
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_FLAG                       0x100
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_MASK                       0x01
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE(_)                         (((_) >> 8) & 0x01)
            UINT32_t reserved2 : 23;
        };

        UINT32_t flags;
    } edx;

} cpuid_eax_80000007;

/**
 * @}
 */

 /**
  * @defgroup model_specific_registers \
  *           Model Specific Registers
  *
  * @see Vol2A[3.2(CPUID)] (reference)
  * @{
  */
  /**
   * @defgroup ia32_p5_mc \
   *           IA32_P5_MC_(x)
   *
   * When machine-check exceptions are enabled for the Pentium processor (MCE flag is set in control register CR4), the
   * machine-check exception handler uses the RDMSR instruction to read the error type from the P5_MC_TYPE register and the
   * machine check address from the P5_MC_ADDR register. The handler then normally reports these register values to the
   * system console before aborting execution.
   *
   * @see Vol3B[15.10.2(Pentium Processor Machine-Check Exception Handling)] (reference)
   * @{
   */
   /**
    * Machine-check exception address.
    *
    * @remarks 05_01H
    * @see Vol4[2.22(MSRS IN PENTIUM PROCESSORS)]
    */
#define IA32_P5_MC_ADDR                                              0x00000000

    /**
     * Machine-check exception type.
     *
     * @remarks 05_01H
     * @see Vol4[2.22(MSRS IN PENTIUM PROCESSORS)]
     */
#define IA32_P5_MC_TYPE                                              0x00000001
     /**
      * @}
      */

      /**
       * System coherence line size.
       *
       * @remarks 0F_03H
       * @see Vol3A[8.10.5(Monitor/Mwait Address Range Determination)]
       * @see Vol3A[8.10.5(Monitor/Mwait Address Range Determination)] (reference)
       */
#define IA32_MONITOR_FILTER_LINE_SIZE                                0x00000006

       /**
        * Value as returned by instruction RDTSC.
        *
        * @remarks 05_01H
        * @see Vol3B[17.17(TIME-STAMP COUNTER)]
        */
#define IA32_TIME_STAMP_COUNTER                                      0x00000010

        /**
         * The operating system can use this MSR to determine "slot" information for the processor and the proper microcode update
         * to load.
         *
         * @remarks 06_01H
         */
#define IA32_PLATFORM_ID                                             0x00000017
typedef union
{
    struct
    {
        UINT64_t reserved1 : 50;

        /**
         * @brief Platform Id <b>(RO)</b>
         *
         * [Bits 52:50] Contains information concerning the intended platform for the processor.
         *
         *
         * 52 | 51 | 50 | _
         * --:|:--:|:---|-----------------
         * 0  | 0  | 0  | Processor Flag 0
         * 0  | 0  | 1  | Processor Flag 1
         * 0  | 1  | 0  | Processor Flag 2
         * 0  | 1  | 1  | Processor Flag 3
         * 1  | 0  | 0  | Processor Flag 4
         * 1  | 0  | 1  | Processor Flag 5
         * 1  | 1  | 0  | Processor Flag 6
         * 1  | 1  | 1  | Processor Flag 7
         */
        UINT64_t platform_id : 3;
#define IA32_PLATFORM_ID_PLATFORM_ID_BIT                             50
#define IA32_PLATFORM_ID_PLATFORM_ID_FLAG                            0x1C000000000000
#define IA32_PLATFORM_ID_PLATFORM_ID_MASK                            0x07
#define IA32_PLATFORM_ID_PLATFORM_ID(_)                              (((_) >> 50) & 0x07)
        UINT64_t reserved2 : 11;
    };

    UINT64_t flags;
} ia32_platform_id_register;


/**
 * This register holds the APIC base address, permitting the relocation of the APIC memory map.
 *
 * @remarks 06_01H
 * @see Vol3A[10.4.4(Local APIC Status and Location)]
 * @see Vol3A[10.4.5(Relocating the Local APIC Registers)]
 */
#define IA32_APIC_BASE                                               0x0000001B
typedef union
{
    struct
    {
        UINT64_t reserved1 : 8;

        /**
         * [Bit 8] BSP flag.
         */
        UINT64_t bsp_flag : 1;
#define IA32_APIC_BASE_BSP_FLAG_BIT                                  8
#define IA32_APIC_BASE_BSP_FLAG_FLAG                                 0x100
#define IA32_APIC_BASE_BSP_FLAG_MASK                                 0x01
#define IA32_APIC_BASE_BSP_FLAG(_)                                   (((_) >> 8) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * [Bit 10] Enable x2APIC mode.
         */
        UINT64_t enable_x2apic_mode : 1;
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_BIT                        10
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_FLAG                       0x400
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_MASK                       0x01
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE(_)                         (((_) >> 10) & 0x01)

        /**
         * [Bit 11] APIC Global Enable.
         */
        UINT64_t apic_global_enable : 1;
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_BIT                        11
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_FLAG                       0x800
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_MASK                       0x01
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE(_)                         (((_) >> 11) & 0x01)

        /**
         * [Bits 47:12] APIC Base.
         */
        UINT64_t apic_base : 36;
#define IA32_APIC_BASE_APIC_BASE_BIT                                 12
#define IA32_APIC_BASE_APIC_BASE_FLAG                                0xFFFFFFFFF000
#define IA32_APIC_BASE_APIC_BASE_MASK                                0xFFFFFFFFF
#define IA32_APIC_BASE_APIC_BASE(_)                                  (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved3 : 16;
    };

    UINT64_t flags;
} ia32_apic_base_register;


/**
 * Control Features in Intel 64 Processor.
 *
 * @remarks If any one enumeration condition for defined bit field holds.
 */
#define IA32_FEATURE_CONTROL                                         0x0000003A
typedef union
{
    struct
    {
        /**
         * @brief Lock bit <b>(R/WO)</b>
         *
         * [Bit 0] When set, locks this MSR from being written; writes to this bit will result in GP(0).
         *
         * @note Once the Lock bit is set, the contents of this register cannot be modified. Therefore the lock bit must be set
         *       after configuring support for Intel Virtualization Technology and prior to transferring control to an option ROM or the
         *       OS. Hence, once the Lock bit is set, the entire IA32_FEATURE_CONTROL contents are preserved across RESET when PWRGOOD is
         *       not deasserted.
         * @remarks If any one enumeration condition for defined bit field position greater than bit 0 holds.
         */
        UINT64_t lock_bit : 1;
#define IA32_FEATURE_CONTROL_LOCK_BIT_BIT                            0
#define IA32_FEATURE_CONTROL_LOCK_BIT_FLAG                           0x01
#define IA32_FEATURE_CONTROL_LOCK_BIT_MASK                           0x01
#define IA32_FEATURE_CONTROL_LOCK_BIT(_)                             (((_) >> 0) & 0x01)

        /**
         * @brief Enable VMX inside SMX operation <b>(R/WL)</b>
         *
         * [Bit 1] This bit enables a system executive to use VMX in conjunction with SMX to support Intel(R) Trusted Execution
         * Technology. BIOS must set this bit only when the CPUID function 1 returns VMX feature flag and SMX feature flag set (ECX
         * bits 5 and 6 respectively).
         *
         * @remarks If CPUID.01H:ECX[5] = 1 && CPUID.01H:ECX[6] = 1
         */
        UINT64_t enable_vmx_inside_smx : 1;
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_BIT               1
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_FLAG              0x02
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_MASK              0x01
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX(_)                (((_) >> 1) & 0x01)

        /**
         * @brief Enable VMX outside SMX operation <b>(R/WL)</b>
         *
         * [Bit 2] This bit enables VMX for a system executive that does not require SMX. BIOS must set this bit only when the
         * CPUID function 1 returns the VMX feature flag set (ECX bit 5).
         *
         * @remarks If CPUID.01H:ECX[5] = 1
         */
        UINT64_t enable_vmx_outside_smx : 1;
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_BIT              2
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_FLAG             0x04
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_MASK             0x01
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX(_)               (((_) >> 2) & 0x01)
        UINT64_t reserved1 : 5;

        /**
         * @brief SENTER Local Function Enable <b>(R/WL)</b>
         *
         * [Bits 14:8] When set, each bit in the field represents an enable control for a corresponding SENTER function. This field
         * is supported only if CPUID.1:ECX.[bit 6] is set.
         *
         * @remarks If CPUID.01H:ECX[6] = 1
         */
        UINT64_t senter_local_function_enables : 7;
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_BIT       8
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_FLAG      0x7F00
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_MASK      0x7F
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES(_)        (((_) >> 8) & 0x7F)

        /**
         * @brief SENTER Global Enable <b>(R/WL)</b>
         *
         * [Bit 15] This bit must be set to enable SENTER leaf functions. This bit is supported only if CPUID.1:ECX.[bit 6] is set.
         *
         * @remarks If CPUID.01H:ECX[6] = 1
         */
        UINT64_t senter_global_enable : 1;
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_BIT                15
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_FLAG               0x8000
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_MASK               0x01
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE(_)                 (((_) >> 15) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * @brief SGX Launch Control Enable <b>(R/WL)</b>
         *
         * [Bit 17] This bit must be set to enable runtime reconfiguration of SGX Launch Control via the IA32_SGXLEPUBKEYHASHn MSR.
         *
         * @remarks If CPUID.(EAX=07H, ECX=0H): ECX[30] = 1
         */
        UINT64_t sgx_launch_control_enable : 1;
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_BIT           17
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_FLAG          0x20000
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_MASK          0x01
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE(_)            (((_) >> 17) & 0x01)

        /**
         * @brief SGX Global Enable <b>(R/WL)</b>
         *
         * [Bit 18] This bit must be set to enable SGX leaf functions.
         *
         * @remarks If CPUID.(EAX=07H, ECX=0H): EBX[2] = 1
         */
        UINT64_t sgx_global_enable : 1;
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_BIT                   18
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_FLAG                  0x40000
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_MASK                  0x01
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE(_)                    (((_) >> 18) & 0x01)
        UINT64_t reserved3 : 1;

        /**
         * @brief LMCE On <b>(R/WL)</b>
         *
         * [Bit 20] When set, system software can program the MSRs associated with LMCE to configure delivery of some machine check
         * exceptions to a single logical processor.
         *
         * @remarks If IA32_MCG_CAP[27] = 1
         */
        UINT64_t lmce_on : 1;
#define IA32_FEATURE_CONTROL_LMCE_ON_BIT                             20
#define IA32_FEATURE_CONTROL_LMCE_ON_FLAG                            0x100000
#define IA32_FEATURE_CONTROL_LMCE_ON_MASK                            0x01
#define IA32_FEATURE_CONTROL_LMCE_ON(_)                              (((_) >> 20) & 0x01)
        UINT64_t reserved4 : 43;
    };

    UINT64_t flags;
} ia32_feature_control_register;


/**
 * Per Logical Processor TSC Adjust.
 *
 * @remarks If CPUID.(EAX=07H, ECX=0H): EBX[1] = 1
 */
#define IA32_TSC_ADJUST                                              0x0000003B
typedef struct
{
    /**
     * Local offset value of the IA32_TSC for a logical processor. Reset value is zero. A write to IA32_TSC will modify the
     * local offset in IA32_TSC_ADJUST and the content of IA32_TSC, but does not affect the internal invariant TSC hardware.
     */
    UINT64_t thread_adjust;
} ia32_tsc_adjust_register;


/**
 * @brief BIOS Update Trigger <b>(W)</b>
 *
 * Executing a WRMSR instruction to this MSR causes a microcode update to be loaded into the processor. A processor may
 * prevent writing to this MSR when loading guest states on VM entries or saving guest states on VM exits.
 *
 * @remarks 06_01H
 * @see Vol3A[9.11.6(Microcode Update Loader)]
 */
#define IA32_BIOS_UPDATE_TRIGGER                                     0x00000079

 /**
  * @brief BIOS Update Signature <b>(RO)</b>
  *
  * Returns the microcode update signature following the execution of CPUID.01H. A processor may prevent writing to this MSR
  * when loading guest states on VM entries or saving guest states on VM exits.
  *
  * @remarks 06_01H
  */
#define IA32_BIOS_UPDATE_SIGNATURE                                   0x0000008B
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] Reserved.
         */
        UINT64_t reserved : 32;
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED_BIT                      0
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED_FLAG                     0xFFFFFFFF
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED_MASK                     0xFFFFFFFF
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED(_)                       (((_) >> 0) & 0xFFFFFFFF)

        /**
         * @brief Microcode update signature
         *
         * [Bits 63:32] This field contains the signature of the currently loaded microcode update when read following the
         * execution of the CPUID instruction, function 1. It is required that this register field be pre-loaded with zero prior to
         * executing the CPUID, function 1. If the field remains equal to zero, then there is no microcode update loaded. Another
         * nonzero value will be the signature.
         *
         * @see Vol3A[9.11.7.1(Determining the Signature)] (reference)
         */
        UINT64_t microcode_update_signature : 32;
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_BIT    32
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_FLAG   0xFFFFFFFF00000000
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_MASK   0xFFFFFFFF
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE(_)     (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64_t flags;
} ia32_bios_update_signature_register;

/**
 * @defgroup ia32_sgxlepubkeyhash \
 *           IA32_SGXLEPUBKEYHASH[(64*n+63):(64*n)]
 *
 * Bits (64*n+63):(64*n) of the SHA256 digest of the SIGSTRUCT.MODULUS for SGX Launch Enclave. On reset, the default value
 * is the digest of Intel's signing key.
 *
 * @remarks Read permitted If CPUID.(EAX=12H,ECX=0H): EAX[0]=1 && CPUID.(EAX=07H,ECX=0H):ECX[30]=1. Write permitted if
 *          CPUID.(EAX=12H,ECX=0H): EAX[0]=1 && IA32_FEATURE_CONTROL[17] = 1 && IA32_FEATURE_CONTROL[0] = 1.
 * @{
 */
#define IA32_SGXLEPUBKEYHASH0                                        0x0000008C
#define IA32_SGXLEPUBKEYHASH1                                        0x0000008D
#define IA32_SGXLEPUBKEYHASH2                                        0x0000008E
#define IA32_SGXLEPUBKEYHASH3                                        0x0000008F
 /**
  * @}
  */


  /**
   * SMM Monitor Configuration.
   *
   * @remarks If CPUID.01H: ECX[5]=1 || CPUID.01H: ECX[6] = 1
   */
#define IA32_SMM_MONITOR_CTL                                         0x0000009B
typedef union
{
    struct
    {
        /**
         * @brief Valid <b>(R/W)</b>
         *
         * [Bit 0] The STM may be invoked using VMCALL only if this bit is 1. Because VMCALL is used to activate the dual-monitor
         * treatment, the dual-monitor treatment cannot be activated if the bit is 0. This bit is cleared when the logical
         * processor is reset.
         *
         * @see Vol3C[34.15.6(Activating the Dual-Monitor Treatment)]
         * @see Vol3C[34.15.5(Enabling the Dual-Monitor Treatment)] (reference)
         */
        UINT64_t valid : 1;
#define IA32_SMM_MONITOR_CTL_VALID_BIT                               0
#define IA32_SMM_MONITOR_CTL_VALID_FLAG                              0x01
#define IA32_SMM_MONITOR_CTL_VALID_MASK                              0x01
#define IA32_SMM_MONITOR_CTL_VALID(_)                                (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * @brief Controls SMI unblocking by VMXOFF
         *
         * [Bit 2] Determines whether executions of VMXOFF unblock SMIs under the default treatment of SMIs and SMM. Executions of
         * VMXOFF unblock SMIs unless bit 2 is 1 (the value of bit 0 is irrelevant).
         *
         * @remarks If IA32_VMX_MISC[28]
         * @see Vol3C[34.14.4(VMXOFF and SMI Unblocking)]
         * @see Vol3C[34.15.5(Enabling the Dual-Monitor Treatment)] (reference)
         */
        UINT64_t smi_unblocking_by_vmxoff : 1;
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_BIT            2
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_FLAG           0x04
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_MASK           0x01
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF(_)             (((_) >> 2) & 0x01)
        UINT64_t reserved2 : 9;

        /**
         * @brief MSEG Base <b>(R/W)</b>
         *
         * [Bits 31:12] Value that, when shifted left 12 bits, is the physical address of MSEG (the MSEG base address).
         *
         * @see Vol3C[34.15.5(Enabling the Dual-Monitor Treatment)] (reference)
         */
        UINT64_t mseg_base : 20;
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_BIT                           12
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_FLAG                          0xFFFFF000
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_MASK                          0xFFFFF
#define IA32_SMM_MONITOR_CTL_MSEG_BASE(_)                            (((_) >> 12) & 0xFFFFF)
        UINT64_t reserved3 : 32;
    };

    UINT64_t flags;
} ia32_smm_monitor_ctl_register;

typedef struct
{
    /**
     * @brief MSEG revision identifier
     *
     * Different processors may use different MSEG revision identifiers. These identifiers enable software to avoid using an
     * MSEG header formatted for one processor on a processor that uses a different format. Software can discover the MSEG
     * revision identifier that a processor uses by reading the VMX capability MSR IA32_VMX_MISC.
     *
     * @see Vol3D[A.6(MISCELLANEOUS DATA)]
     */
    UINT32_t mseg_header_revision;

    /**
     * @brief SMM-transfer monitor features field
     *
     * Bits 31:1 of this field are reserved and must be zero. Bit 0 of the field is the IA-32e mode SMM feature bit. It
     * indicates whether the logical processor will be in IA-32e mode after the STM is activated.
     *
     * @see Vol3C[34.15.6(Activating the Dual-Monitor Treatment)]
     */
    UINT32_t monitor_features;

    /**
     * Define values for the MonitorFeatures field of MSEG_HEADER.
     */
#define IA32_STM_FEATURES_IA32E                                      0x00000001

     /**
      * Fields that determine how processor state is loaded when the STM is activated. SMM code should establish these fields so
      * that activating of the STM invokes the STM's initialization code.
      *
      * @see Vol3C[34.15.6.5(Loading Host State)]
      */
    UINT32_t gdtr_limit;
    UINT32_t gdtr_base_offset;
    UINT32_t cs_selector;
    UINT32_t eip_offset;
    UINT32_t esp_offset;
    UINT32_t cr3_offset;
} ia32_mseg_header;


/**
 * Base address of the logical processor's SMRAM image.
 *
 * @remarks If IA32_VMX_MISC[15]
 */
#define IA32_SMBASE                                                  0x0000009E
 /**
  * @defgroup ia32_pmc \
  *           IA32_PMC(n)
  *
  * General Performance Counters.
  *
  * @remarks If CPUID.0AH: EAX[15:8] > n
  * @{
  */
#define IA32_PMC0                                                    0x000000C1
#define IA32_PMC1                                                    0x000000C2
#define IA32_PMC2                                                    0x000000C3
#define IA32_PMC3                                                    0x000000C4
#define IA32_PMC4                                                    0x000000C5
#define IA32_PMC5                                                    0x000000C6
#define IA32_PMC6                                                    0x000000C7
#define IA32_PMC7                                                    0x000000C8
  /**
   * @}
   */


   /**
    * TSC Frequency Clock Counter.
    *
    * @remarks If CPUID.06H: ECX[0] = 1
    */
#define IA32_MPERF                                                   0x000000E7
typedef struct
{
    /**
     * @brief C0 TSC Frequency Clock Count
     *
     * Increments at fixed interval (relative to TSC freq.) when the logical processor is in C0. Cleared upon overflow /
     * wrap-around of IA32_APERF.
     */
    UINT64_t c0_mcnt;
} ia32_mperf_register;


/**
 * Actual Performance Clock Counter
 *
 * @remarks If CPUID.06H: ECX[0] = 1
 */
#define IA32_APERF                                                   0x000000E8
typedef struct
{
    /**
     * @brief C0 Actual Frequency Clock Count
     *
     * Accumulates core clock counts at the coordinated clock frequency, when the logical processor is in C0. Cleared upon
     * overflow / wrap-around of IA32_MPERF.
     */
    UINT64_t c0_acnt;
} ia32_aperf_register;


/**
 * MTRR Capability.
 *
 * @see Vol3A[11.11.2.1(IA32_MTRR_DEF_TYPE MSR)]
 * @see Vol3A[11.11.1(MTRR Feature Identification)] (reference)
 */
#define IA32_MTRR_CAPABILITIES                                       0x000000FE
typedef union
{
    struct
    {
        /**
         * @brief VCNT (variable range registers count) field
         *
         * [Bits 7:0] Indicates the number of variable ranges implemented on the processor.
         */
        UINT64_t variable_range_count : 8;
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_BIT              0
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_FLAG             0xFF
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_MASK             0xFF
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT(_)               (((_) >> 0) & 0xFF)

        /**
         * @brief FIX (fixed range registers supported) flag
         *
         * [Bit 8] Fixed range MTRRs (IA32_MTRR_FIX64K_00000 through IA32_MTRR_FIX4K_0F8000) are supported when set; no fixed range
         * registers are supported when clear.
         */
        UINT64_t fixed_range_supported : 1;
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_BIT             8
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_FLAG            0x100
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_MASK            0x01
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED(_)              (((_) >> 8) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * @brief WC (write combining) flag
         *
         * [Bit 10] The write-combining (WC) memory type is supported when set; the WC type is not supported when clear.
         */
        UINT64_t wc_supported : 1;
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_BIT                      10
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_FLAG                     0x400
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_MASK                     0x01
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED(_)                       (((_) >> 10) & 0x01)

        /**
         * @brief SMRR (System-Management Range Register) flag
         *
         * [Bit 11] The system-management range register (SMRR) interface is supported when bit 11 is set; the SMRR interface is
         * not supported when clear.
         */
        UINT64_t smrr_supported : 1;
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_BIT                    11
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_FLAG                   0x800
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_MASK                   0x01
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED(_)                     (((_) >> 11) & 0x01)
        UINT64_t reserved2 : 52;
    };

    UINT64_t flags;
} ia32_mtrr_capabilities_register;


/**
 * @brief SYSENTER_CS_MSR <b>(R/W)</b>
 *
 * The lower 16 bits of this MSR are the segment selector for the privilege level 0 code segment. This value is also used
 * to determine the segment selector of the privilege level 0 stack segment. This value cannot indicate a null selector.
 *
 * @remarks 06_01H
 * @see Vol2B[4.3(Instructions (M-U) | SYSCALL - Fast System Call)] (reference)
 */
#define IA32_SYSENTER_CS                                             0x00000174
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] CS Selector.
         */
        UINT64_t cs_selector : 16;
#define IA32_SYSENTER_CS_CS_SELECTOR_BIT                             0
#define IA32_SYSENTER_CS_CS_SELECTOR_FLAG                            0xFFFF
#define IA32_SYSENTER_CS_CS_SELECTOR_MASK                            0xFFFF
#define IA32_SYSENTER_CS_CS_SELECTOR(_)                              (((_) >> 0) & 0xFFFF)

        /**
         * [Bits 31:16] Not used.
         *
         * @remarks Can be read and written.
         */
        UINT64_t not_used_1 : 16;
#define IA32_SYSENTER_CS_NOT_USED_1_BIT                              16
#define IA32_SYSENTER_CS_NOT_USED_1_FLAG                             0xFFFF0000
#define IA32_SYSENTER_CS_NOT_USED_1_MASK                             0xFFFF
#define IA32_SYSENTER_CS_NOT_USED_1(_)                               (((_) >> 16) & 0xFFFF)

        /**
         * [Bits 63:32] Not used.
         *
         * @remarks Writes ignored; reads return zero.
         */
        UINT64_t not_used_2 : 32;
#define IA32_SYSENTER_CS_NOT_USED_2_BIT                              32
#define IA32_SYSENTER_CS_NOT_USED_2_FLAG                             0xFFFFFFFF00000000
#define IA32_SYSENTER_CS_NOT_USED_2_MASK                             0xFFFFFFFF
#define IA32_SYSENTER_CS_NOT_USED_2(_)                               (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64_t flags;
} ia32_sysenter_cs_register;


/**
 * @brief SYSENTER_ESP_MSR <b>(R/W)</b>
 *
 * The value of this MSR is loaded into RSP (thus, this value contains the stack pointer for the privilege level 0 stack).
 * This value cannot represent a non-canonical address. In protected mode, only bits 31:0 are loaded.
 *
 * @remarks 06_01H
 * @see Vol2B[4.3(Instructions (M-U) | SYSCALL - Fast System Call)] (reference)
 */
#define IA32_SYSENTER_ESP                                            0x00000175

 /**
  * @brief SYSENTER_EIP_MSR <b>(R/W)</b>
  *
  * The value of this MSR is loaded into RIP (thus, this value references the first instruction of the selected operating
  * procedure or routine). In protected mode, only bits 31:0 are loaded.
  *
  * @remarks 06_01H
  * @see Vol2B[4.3(Instructions (M-U) | SYSCALL - Fast System Call)] (reference)
  */
#define IA32_SYSENTER_EIP                                            0x00000176

  /**
   * Global Machine Check Capability.
   *
   * @remarks 06_01H
   */
#define IA32_MCG_CAP                                                 0x00000179
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Number of reporting banks.
         */
        UINT64_t count : 8;
#define IA32_MCG_CAP_COUNT_BIT                                       0
#define IA32_MCG_CAP_COUNT_FLAG                                      0xFF
#define IA32_MCG_CAP_COUNT_MASK                                      0xFF
#define IA32_MCG_CAP_COUNT(_)                                        (((_) >> 0) & 0xFF)

        /**
         * [Bit 8] IA32_MCG_CTL is present if this bit is set.
         */
        UINT64_t mcg_ctl_p : 1;
#define IA32_MCG_CAP_MCG_CTL_P_BIT                                   8
#define IA32_MCG_CAP_MCG_CTL_P_FLAG                                  0x100
#define IA32_MCG_CAP_MCG_CTL_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_CTL_P(_)                                    (((_) >> 8) & 0x01)

        /**
         * [Bit 9] Extended machine check state registers are present if this bit is set.
         */
        UINT64_t mcg_ext_p : 1;
#define IA32_MCG_CAP_MCG_EXT_P_BIT                                   9
#define IA32_MCG_CAP_MCG_EXT_P_FLAG                                  0x200
#define IA32_MCG_CAP_MCG_EXT_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_EXT_P(_)                                    (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Support for corrected MC error event is present.
         *
         * @remarks 06_01H
         */
        UINT64_t mcp_cmci_p : 1;
#define IA32_MCG_CAP_MCP_CMCI_P_BIT                                  10
#define IA32_MCG_CAP_MCP_CMCI_P_FLAG                                 0x400
#define IA32_MCG_CAP_MCP_CMCI_P_MASK                                 0x01
#define IA32_MCG_CAP_MCP_CMCI_P(_)                                   (((_) >> 10) & 0x01)

        /**
         * [Bit 11] Threshold-based error status register are present if this bit is set.
         */
        UINT64_t mcg_tes_p : 1;
#define IA32_MCG_CAP_MCG_TES_P_BIT                                   11
#define IA32_MCG_CAP_MCG_TES_P_FLAG                                  0x800
#define IA32_MCG_CAP_MCG_TES_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_TES_P(_)                                    (((_) >> 11) & 0x01)
        UINT64_t reserved1 : 4;

        /**
         * [Bits 23:16] Number of extended machine check state registers present.
         */
        UINT64_t mcg_ext_cnt : 8;
#define IA32_MCG_CAP_MCG_EXT_CNT_BIT                                 16
#define IA32_MCG_CAP_MCG_EXT_CNT_FLAG                                0xFF0000
#define IA32_MCG_CAP_MCG_EXT_CNT_MASK                                0xFF
#define IA32_MCG_CAP_MCG_EXT_CNT(_)                                  (((_) >> 16) & 0xFF)

        /**
         * [Bit 24] The processor supports software error recovery if this bit is set.
         */
        UINT64_t mcg_ser_p : 1;
#define IA32_MCG_CAP_MCG_SER_P_BIT                                   24
#define IA32_MCG_CAP_MCG_SER_P_FLAG                                  0x1000000
#define IA32_MCG_CAP_MCG_SER_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_SER_P(_)                                    (((_) >> 24) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * [Bit 26] Indicates that the processor allows platform firmware to be invoked when an error is detected so that it may
         * provide additional platform specific information in an ACPI format "Generic Error Data Entry" that augments the data
         * included in machine check bank registers.
         *
         * @remarks 06_3EH
         */
        UINT64_t mcg_elog_p : 1;
#define IA32_MCG_CAP_MCG_ELOG_P_BIT                                  26
#define IA32_MCG_CAP_MCG_ELOG_P_FLAG                                 0x4000000
#define IA32_MCG_CAP_MCG_ELOG_P_MASK                                 0x01
#define IA32_MCG_CAP_MCG_ELOG_P(_)                                   (((_) >> 26) & 0x01)

        /**
         * [Bit 27] Indicates that the processor supports extended state in IA32_MCG_STATUS and associated MSR necessary to
         * configure Local Machine Check Exception (LMCE).
         *
         * @remarks 06_3EH
         */
        UINT64_t mcg_lmce_p : 1;
#define IA32_MCG_CAP_MCG_LMCE_P_BIT                                  27
#define IA32_MCG_CAP_MCG_LMCE_P_FLAG                                 0x8000000
#define IA32_MCG_CAP_MCG_LMCE_P_MASK                                 0x01
#define IA32_MCG_CAP_MCG_LMCE_P(_)                                   (((_) >> 27) & 0x01)
        UINT64_t reserved3 : 36;
    };

    UINT64_t flags;
} ia32_mcg_cap_register;


/**
 * Global Machine Check Status.
 *
 * @remarks 06_01H
 */
#define IA32_MCG_STATUS                                              0x0000017A
typedef union
{
    struct
    {
        /**
         * [Bit 0] Restart IP valid.
         *
         * @remarks 06_01H
         */
        UINT64_t ripv : 1;
#define IA32_MCG_STATUS_RIPV_BIT                                     0
#define IA32_MCG_STATUS_RIPV_FLAG                                    0x01
#define IA32_MCG_STATUS_RIPV_MASK                                    0x01
#define IA32_MCG_STATUS_RIPV(_)                                      (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Error IP valid.
         *
         * @remarks 06_01H
         */
        UINT64_t eipv : 1;
#define IA32_MCG_STATUS_EIPV_BIT                                     1
#define IA32_MCG_STATUS_EIPV_FLAG                                    0x02
#define IA32_MCG_STATUS_EIPV_MASK                                    0x01
#define IA32_MCG_STATUS_EIPV(_)                                      (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Machine check in progress.
         *
         * @remarks 06_01H
         */
        UINT64_t mcip : 1;
#define IA32_MCG_STATUS_MCIP_BIT                                     2
#define IA32_MCG_STATUS_MCIP_FLAG                                    0x04
#define IA32_MCG_STATUS_MCIP_MASK                                    0x01
#define IA32_MCG_STATUS_MCIP(_)                                      (((_) >> 2) & 0x01)

        /**
         * [Bit 3] If IA32_MCG_CAP.LMCE_P[27] = 1.
         */
        UINT64_t lmce_s : 1;
#define IA32_MCG_STATUS_LMCE_S_BIT                                   3
#define IA32_MCG_STATUS_LMCE_S_FLAG                                  0x08
#define IA32_MCG_STATUS_LMCE_S_MASK                                  0x01
#define IA32_MCG_STATUS_LMCE_S(_)                                    (((_) >> 3) & 0x01)
        UINT64_t reserved1 : 60;
    };

    UINT64_t flags;
} ia32_mcg_status_register;


/**
 * Global Machine Check Control.
 *
 * @remarks If IA32_MCG_CAP.CTL_P[8] = 1
 */
#define IA32_MCG_CTL                                                 0x0000017B
 /**
  * @defgroup ia32_perfevtsel \
  *           IA32_PERFEVTSEL(n)
  *
  * Performance Event Select Register n.
  *
  * @remarks If CPUID.0AH: EAX[15:8] > n
  * @{
  */
#define IA32_PERFEVTSEL0                                             0x00000186
#define IA32_PERFEVTSEL1                                             0x00000187
#define IA32_PERFEVTSEL2                                             0x00000188
#define IA32_PERFEVTSEL3                                             0x00000189
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Selects a performance event logic unit.
         */
        UINT64_t event_select : 8;
#define IA32_PERFEVTSEL_EVENT_SELECT_BIT                             0
#define IA32_PERFEVTSEL_EVENT_SELECT_FLAG                            0xFF
#define IA32_PERFEVTSEL_EVENT_SELECT_MASK                            0xFF
#define IA32_PERFEVTSEL_EVENT_SELECT(_)                              (((_) >> 0) & 0xFF)

        /**
         * [Bits 15:8] Qualifies the microarchitectural condition to detect on the selected event logic.
         */
        UINT64_t u_mask : 8;
#define IA32_PERFEVTSEL_U_MASK_BIT                                   8
#define IA32_PERFEVTSEL_U_MASK_FLAG                                  0xFF00
#define IA32_PERFEVTSEL_U_MASK_MASK                                  0xFF
#define IA32_PERFEVTSEL_U_MASK(_)                                    (((_) >> 8) & 0xFF)

        /**
         * [Bit 16] Counts while in privilege level is not ring 0.
         */
        UINT64_t usr : 1;
#define IA32_PERFEVTSEL_USR_BIT                                      16
#define IA32_PERFEVTSEL_USR_FLAG                                     0x10000
#define IA32_PERFEVTSEL_USR_MASK                                     0x01
#define IA32_PERFEVTSEL_USR(_)                                       (((_) >> 16) & 0x01)

        /**
         * [Bit 17] Counts while in privilege level is ring 0.
         */
        UINT64_t os : 1;
#define IA32_PERFEVTSEL_OS_BIT                                       17
#define IA32_PERFEVTSEL_OS_FLAG                                      0x20000
#define IA32_PERFEVTSEL_OS_MASK                                      0x01
#define IA32_PERFEVTSEL_OS(_)                                        (((_) >> 17) & 0x01)

        /**
         * [Bit 18] Enables edge detection if set.
         */
        UINT64_t edge : 1;
#define IA32_PERFEVTSEL_EDGE_BIT                                     18
#define IA32_PERFEVTSEL_EDGE_FLAG                                    0x40000
#define IA32_PERFEVTSEL_EDGE_MASK                                    0x01
#define IA32_PERFEVTSEL_EDGE(_)                                      (((_) >> 18) & 0x01)

        /**
         * [Bit 19] Enables pin control.
         */
        UINT64_t pc : 1;
#define IA32_PERFEVTSEL_PC_BIT                                       19
#define IA32_PERFEVTSEL_PC_FLAG                                      0x80000
#define IA32_PERFEVTSEL_PC_MASK                                      0x01
#define IA32_PERFEVTSEL_PC(_)                                        (((_) >> 19) & 0x01)

        /**
         * [Bit 20] Enables interrupt on counter overflow.
         */
        UINT64_t intr : 1;
#define IA32_PERFEVTSEL_INTR_BIT                                     20
#define IA32_PERFEVTSEL_INTR_FLAG                                    0x100000
#define IA32_PERFEVTSEL_INTR_MASK                                    0x01
#define IA32_PERFEVTSEL_INTR(_)                                      (((_) >> 20) & 0x01)

        /**
         * [Bit 21] When set to 1, it enables counting the associated event conditions occurring across all logical processors
         * sharing a processor core. When set to 0, the counter only increments the associated event conditions occurring in the
         * logical processor which programmed the MSR.
         */
        UINT64_t any_thread : 1;
#define IA32_PERFEVTSEL_ANY_THREAD_BIT                               21
#define IA32_PERFEVTSEL_ANY_THREAD_FLAG                              0x200000
#define IA32_PERFEVTSEL_ANY_THREAD_MASK                              0x01
#define IA32_PERFEVTSEL_ANY_THREAD(_)                                (((_) >> 21) & 0x01)

        /**
         * [Bit 22] Enables the corresponding performance counter to commence counting when this bit is set.
         */
        UINT64_t en : 1;
#define IA32_PERFEVTSEL_EN_BIT                                       22
#define IA32_PERFEVTSEL_EN_FLAG                                      0x400000
#define IA32_PERFEVTSEL_EN_MASK                                      0x01
#define IA32_PERFEVTSEL_EN(_)                                        (((_) >> 22) & 0x01)

        /**
         * [Bit 23] Invert the CMASK.
         */
        UINT64_t inv : 1;
#define IA32_PERFEVTSEL_INV_BIT                                      23
#define IA32_PERFEVTSEL_INV_FLAG                                     0x800000
#define IA32_PERFEVTSEL_INV_MASK                                     0x01
#define IA32_PERFEVTSEL_INV(_)                                       (((_) >> 23) & 0x01)

        /**
         * [Bits 31:24] When CMASK is not zero, the corresponding performance counter increments each cycle if the event count is
         * greater than or equal to the CMASK.
         */
        UINT64_t cmask : 8;
#define IA32_PERFEVTSEL_CMASK_BIT                                    24
#define IA32_PERFEVTSEL_CMASK_FLAG                                   0xFF000000
#define IA32_PERFEVTSEL_CMASK_MASK                                   0xFF
#define IA32_PERFEVTSEL_CMASK(_)                                     (((_) >> 24) & 0xFF)
        UINT64_t reserved1 : 32;
    };

    UINT64_t flags;
} ia32_perfevtsel_register;

/**
 * @}
 */


 /**
  * Current Performance Status.
  *
  * @remarks 0F_03H
  * @see Vol3B[14.1.1(Software Interface For Initiating Performance State Transitions)]
  */
#define IA32_PERF_STATUS                                             0x00000198
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] Current performance State Value.
         */
        UINT64_t state_value : 16;
#define IA32_PERF_STATUS_STATE_VALUE_BIT                             0
#define IA32_PERF_STATUS_STATE_VALUE_FLAG                            0xFFFF
#define IA32_PERF_STATUS_STATE_VALUE_MASK                            0xFFFF
#define IA32_PERF_STATUS_STATE_VALUE(_)                              (((_) >> 0) & 0xFFFF)
        UINT64_t reserved1 : 48;
    };

    UINT64_t flags;
} ia32_perf_status_register;


/**
 * @brief Performance Control <b>(R/W)</b>
 *
 * Performance Control. Software makes a request for a new Performance state (P-State) by writing this MSR.
 *
 * @remarks 0F_03H
 * @see Vol3B[14.1.1(Software Interface For Initiating Performance State Transitions)]
 */
#define IA32_PERF_CTL                                                0x00000199
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] Target performance State Value.
         */
        UINT64_t target_state_value : 16;
#define IA32_PERF_CTL_TARGET_STATE_VALUE_BIT                         0
#define IA32_PERF_CTL_TARGET_STATE_VALUE_FLAG                        0xFFFF
#define IA32_PERF_CTL_TARGET_STATE_VALUE_MASK                        0xFFFF
#define IA32_PERF_CTL_TARGET_STATE_VALUE(_)                          (((_) >> 0) & 0xFFFF)
        UINT64_t reserved1 : 16;

        /**
         * [Bit 32] IDA Engage.
         *
         * @remarks 06_0FH (Mobile only)
         */
        UINT64_t ida_engage : 1;
#define IA32_PERF_CTL_IDA_ENGAGE_BIT                                 32
#define IA32_PERF_CTL_IDA_ENGAGE_FLAG                                0x100000000
#define IA32_PERF_CTL_IDA_ENGAGE_MASK                                0x01
#define IA32_PERF_CTL_IDA_ENGAGE(_)                                  (((_) >> 32) & 0x01)
        UINT64_t reserved2 : 31;
    };

    UINT64_t flags;
} ia32_perf_ctl_register;


/**
 * Clock Modulation Control.
 *
 * @remarks If CPUID.01H:EDX[22] = 1
 * @see Vol3B[14.7.3(Software Controlled Clock Modulation)]
 */
#define IA32_CLOCK_MODULATION                                        0x0000019A
typedef union
{
    struct
    {
        /**
         * [Bit 0] Extended On-Demand Clock Modulation Duty Cycle.
         *
         * @remarks If CPUID.06H:EAX[5] = 1
         */
        UINT64_t extended_on_demand_clock_modulation_duty_cycle : 1;
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_BIT 0
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_FLAG 0x01
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_MASK 0x01
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE(_) (((_) >> 0) & 0x01)

        /**
         * @brief On-Demand Clock Modulation Duty Cycle
         *
         * [Bits 3:1] On-Demand Clock Modulation Duty Cycle: Specific encoded values for target duty cycle modulation.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t on_demand_clock_modulation_duty_cycle : 3;
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_BIT 1
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_FLAG 0x0E
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_MASK 0x07
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE(_) (((_) >> 1) & 0x07)

        /**
         * @brief On-Demand Clock Modulation Enable
         *
         * [Bit 4] On-Demand Clock Modulation Enable: Set 1 to enable modulation.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t on_demand_clock_modulation_enable : 1;
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_BIT  4
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_FLAG 0x10
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_MASK 0x01
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE(_)   (((_) >> 4) & 0x01)
        UINT64_t reserved1 : 59;
    };

    UINT64_t flags;
} ia32_clock_modulation_register;


/**
 * @brief Thermal Interrupt Control <b>(R/W)</b>
 *
 * Thermal Interrupt Control. Enables and disables the generation of an interrupt on temperature transitions detected with
 * the processor's thermal sensors and thermal monitor.
 *
 * @remarks If CPUID.01H:EDX[22] = 1
 * @see Vol3B[14.7.2(Thermal Monitor)]
 */
#define IA32_THERM_INTERRUPT                                         0x0000019B
typedef union
{
    struct
    {
        /**
         * [Bit 0] High-Temperature Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t high_temperature_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_BIT   0
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_FLAG  0x01
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_MASK  0x01
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE(_)    (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Low-Temperature Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t low_temperature_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_BIT    1
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_FLAG   0x02
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_MASK   0x01
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE(_)     (((_) >> 1) & 0x01)

        /**
         * [Bit 2] PROCHOT\# Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t prochot_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_BIT            2
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_FLAG           0x04
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_MASK           0x01
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE(_)             (((_) >> 2) & 0x01)

        /**
         * [Bit 3] FORCEPR\# Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t forcepr_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_BIT            3
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_FLAG           0x08
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_MASK           0x01
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE(_)             (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Critical Temperature Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t critical_temperature_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_BIT 4
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x10
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 4) & 0x01)
        UINT64_t reserved1 : 3;

        /**
         * [Bits 14:8] Threshold \#1 Value
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t threshold1_value : 7;
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_BIT                    8
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_FLAG                   0x7F00
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_MASK                   0x7F
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE(_)                     (((_) >> 8) & 0x7F)

        /**
         * [Bit 15] Threshold \#1 Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t threshold1_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_BIT         15
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_FLAG        0x8000
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_MASK        0x01
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE(_)          (((_) >> 15) & 0x01)

        /**
         * [Bits 22:16] Threshold \#2 Value.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t threshold2_value : 7;
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_BIT                    16
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_FLAG                   0x7F0000
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_MASK                   0x7F
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE(_)                     (((_) >> 16) & 0x7F)

        /**
         * [Bit 23] Threshold \#2 Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t threshold2_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_BIT         23
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_FLAG        0x800000
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_MASK        0x01
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE(_)          (((_) >> 23) & 0x01)

        /**
         * [Bit 24] Power Limit Notification Enable.
         *
         * @remarks If CPUID.06H:EAX[4] = 1
         */
        UINT64_t power_limit_notification_enable : 1;
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_BIT     24
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_FLAG    0x1000000
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_MASK    0x01
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE(_)      (((_) >> 24) & 0x01)
        UINT64_t reserved2 : 39;
    };

    UINT64_t flags;
} ia32_therm_interrupt_register;


/**
 * @brief Thermal Status Information <b>(RO)</b>
 *
 * Thermal Status Information. Contains status information about the processor's thermal sensor and automatic thermal
 * monitoring facilities.
 *
 * @remarks If CPUID.01H:EDX[22] = 1
 * @see Vol3B[14.7.2(Thermal Monitor)]
 */
#define IA32_THERM_STATUS                                            0x0000019C
typedef union
{
    struct
    {
        /**
         * [Bit 0] Thermal Status
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t thermal_status : 1;
#define IA32_THERM_STATUS_THERMAL_STATUS_BIT                         0
#define IA32_THERM_STATUS_THERMAL_STATUS_FLAG                        0x01
#define IA32_THERM_STATUS_THERMAL_STATUS_MASK                        0x01
#define IA32_THERM_STATUS_THERMAL_STATUS(_)                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Thermal Status Log
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t thermal_status_log : 1;
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_BIT                     1
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_FLAG                    0x02
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_MASK                    0x01
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG(_)                      (((_) >> 1) & 0x01)

        /**
         * [Bit 2] PROCHOT \# or FORCEPR\# event
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t prochot_forcepr_event : 1;
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_BIT                  2
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_FLAG                 0x04
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_MASK                 0x01
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT(_)                   (((_) >> 2) & 0x01)

        /**
         * [Bit 3] PROCHOT \# or FORCEPR\# log
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t prochot_forcepr_log : 1;
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_BIT                    3
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_FLAG                   0x08
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_MASK                   0x01
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG(_)                     (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Critical Temperature Status
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t critical_temperature_status : 1;
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_BIT            4
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_FLAG           0x10
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_MASK           0x01
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS(_)             (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Critical Temperature Status log
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        UINT64_t critical_temperature_status_log : 1;
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_BIT        5
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_FLAG       0x20
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_MASK       0x01
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG(_)         (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Thermal Threshold \#1 Status
         *
         * @remarks If CPUID.01H:ECX[8] = 1
         */
        UINT64_t thermal_threshold1_status : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_BIT              6
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_FLAG             0x40
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_MASK             0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS(_)               (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Thermal Threshold \#1 log
         *
         * @remarks If CPUID.01H:ECX[8] = 1
         */
        UINT64_t thermal_threshold1_log : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_BIT                 7
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_FLAG                0x80
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_MASK                0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG(_)                  (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Thermal Threshold \#2 Status
         *
         * @remarks If CPUID.01H:ECX[8] = 1
         */
        UINT64_t thermal_threshold2_status : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_BIT              8
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_FLAG             0x100
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_MASK             0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS(_)               (((_) >> 8) & 0x01)

        /**
         * [Bit 9] Thermal Threshold \#2 log
         *
         * @remarks If CPUID.01H:ECX[8] = 1
         */
        UINT64_t thermal_threshold2_log : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_BIT                 9
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_FLAG                0x200
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_MASK                0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG(_)                  (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Power Limitation Status
         *
         * @remarks If CPUID.06H:EAX[4] = 1
         */
        UINT64_t power_limitation_status : 1;
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_BIT                10
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_FLAG               0x400
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_MASK               0x01
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS(_)                 (((_) >> 10) & 0x01)

        /**
         * [Bit 11] Power Limitation log
         *
         * @remarks If CPUID.06H:EAX[4] = 1
         */
        UINT64_t power_limitation_log : 1;
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_BIT                   11
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_FLAG                  0x800
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_MASK                  0x01
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG(_)                    (((_) >> 11) & 0x01)

        /**
         * [Bit 12] Current Limit Status
         *
         * @remarks If CPUID.06H:EAX[7] = 1
         */
        UINT64_t current_limit_status : 1;
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_BIT                   12
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_FLAG                  0x1000
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_MASK                  0x01
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS(_)                    (((_) >> 12) & 0x01)

        /**
         * [Bit 13] Current Limit log
         *
         * @remarks If CPUID.06H:EAX[7] = 1
         */
        UINT64_t current_limit_log : 1;
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_BIT                      13
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_FLAG                     0x2000
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_MASK                     0x01
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG(_)                       (((_) >> 13) & 0x01)

        /**
         * [Bit 14] Cross Domain Limit Status
         *
         * @remarks If CPUID.06H:EAX[7] = 1
         */
        UINT64_t cross_domain_limit_status : 1;
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_BIT              14
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_FLAG             0x4000
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_MASK             0x01
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS(_)               (((_) >> 14) & 0x01)

        /**
         * [Bit 15] Cross Domain Limit log
         *
         * @remarks If CPUID.06H:EAX[7] = 1
         */
        UINT64_t cross_domain_limit_log : 1;
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_BIT                 15
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_FLAG                0x8000
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_MASK                0x01
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG(_)                  (((_) >> 15) & 0x01)

        /**
         * [Bits 22:16] Digital Readout
         *
         * @remarks If CPUID.06H:EAX[0] = 1
         */
        UINT64_t digital_readout : 7;
#define IA32_THERM_STATUS_DIGITAL_READOUT_BIT                        16
#define IA32_THERM_STATUS_DIGITAL_READOUT_FLAG                       0x7F0000
#define IA32_THERM_STATUS_DIGITAL_READOUT_MASK                       0x7F
#define IA32_THERM_STATUS_DIGITAL_READOUT(_)                         (((_) >> 16) & 0x7F)
        UINT64_t reserved1 : 4;

        /**
         * [Bits 30:27] Resolution in Degrees Celsius
         *
         * @remarks If CPUID.06H:EAX[0] = 1
         */
        UINT64_t resolution_in_degrees_celsius : 4;
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_BIT          27
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_FLAG         0x78000000
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_MASK         0x0F
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS(_)           (((_) >> 27) & 0x0F)

        /**
         * [Bit 31] Reading Valid
         *
         * @remarks If CPUID.06H:EAX[0] = 1
         */
        UINT64_t reading_valid : 1;
#define IA32_THERM_STATUS_READING_VALID_BIT                          31
#define IA32_THERM_STATUS_READING_VALID_FLAG                         0x80000000
#define IA32_THERM_STATUS_READING_VALID_MASK                         0x01
#define IA32_THERM_STATUS_READING_VALID(_)                           (((_) >> 31) & 0x01)
        UINT64_t reserved2 : 32;
    };

    UINT64_t flags;
} ia32_therm_status_register;


/**
 * @brief Enable Misc. Processor Features <b>(R/W)</b>
 *
 * Allows a variety of processor functions to be enabled and disabled.
 */
#define IA32_MISC_ENABLE                                             0x000001A0
typedef union
{
    struct
    {
        /**
         * @brief Fast-Strings Enable
         *
         * [Bit 0] When set, the fast-strings feature (for REP MOVS and REP STORS) is enabled (default). When clear, fast-strings
         * are disabled.
         *
         * @remarks 0F_0H
         */
        UINT64_t fast_strings_enable : 1;
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_BIT                     0
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_FLAG                    0x01
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_MASK                    0x01
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE(_)                      (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 2;

        /**
         * @brief Automatic Thermal Control Circuit Enable <b>(R/W)</b>
         *
         * [Bit 3] - 1 = Setting this bit enables the thermal control circuit (TCC) portion of the Intel Thermal Monitor feature.
         * This allows the processor to automatically reduce power consumption in response to TCC activation.
         * - 0 = Disabled.
         *
         * @note In some products clearing this bit might be ignored in critical thermal conditions, and TM1, TM2 and adaptive
         *       thermal throttling will still be activated. The default value of this field varies with product.
         * @remarks 0F_0H
         */
        UINT64_t automatic_thermal_control_circuit_enable : 1;
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_BIT 3
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_FLAG 0x08
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_MASK 0x01
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE(_) (((_) >> 3) & 0x01)
        UINT64_t reserved2 : 3;

        /**
         * @brief Performance Monitoring Available <b>(R)</b>
         *
         * [Bit 7] - 1 = Performance monitoring enabled.
         * - 0 = Performance monitoring disabled.
         *
         * @remarks 0F_0H
         */
        UINT64_t performance_monitoring_available : 1;
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_BIT        7
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_FLAG       0x80
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_MASK       0x01
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE(_)         (((_) >> 7) & 0x01)
        UINT64_t reserved3 : 3;

        /**
         * @brief Branch Trace Storage Unavailable <b>(RO)</b>
         *
         * [Bit 11] - 1 = Processor doesn't support branch trace storage (BTS).
         * - 0 = BTS is supported.
         *
         * @remarks 0F_0H
         */
        UINT64_t branch_trace_storage_unavailable : 1;
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_BIT        11
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_FLAG       0x800
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_MASK       0x01
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE(_)         (((_) >> 11) & 0x01)

        /**
         * @brief Processor Event Based Sampling (PEBS) Unavailable <b>(RO)</b>
         *
         * [Bit 12] - 1 = PEBS is not supported.
         * - 0 = PEBS is supported.
         *
         * @remarks 06_0FH
         */
        UINT64_t processor_event_based_sampling_unavailable : 1;
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_BIT 12
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_FLAG 0x1000
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_MASK 0x01
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE(_) (((_) >> 12) & 0x01)
        UINT64_t reserved4 : 3;

        /**
         * @brief Enhanced Intel SpeedStep Technology Enable <b>(R/W)</b>
         *
         * [Bit 16] - 0 = Enhanced Intel SpeedStep Technology disabled.
         * - 1 = Enhanced Intel SpeedStep Technology enabled.
         *
         * @remarks If CPUID.01H: ECX[7] = 1
         */
        UINT64_t enhanced_intel_speedstep_technology_enable : 1;
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_BIT 16
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_FLAG 0x10000
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_MASK 0x01
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE(_) (((_) >> 16) & 0x01)
        UINT64_t reserved5 : 1;

        /**
         * @brief ENABLE MONITOR FSM <b>(R/W)</b>
         *
         * [Bit 18] When this bit is set to 0, the MONITOR feature flag is not set (CPUID.01H:ECX[bit3] = 0). This indicates that
         * MONITOR/MWAIT are not supported. Software attempts to execute MONITOR/MWAIT will cause \#UD when this bit is 0.
         * When this bit is set to 1 (default), MONITOR/MWAIT are supported (CPUID.01H:ECX[bit 3] = 1). If the SSE3 feature flag
         * ECX[0] is not set (CPUID.01H:ECX[bit 0] = 0), the OS must not attempt to alter this bit. BIOS must leave it in the
         * default state. Writing this bit when the SSE3 feature flag is set to 0 may generate a \#GP exception.
         *
         * @remarks 0F_03H
         */
        UINT64_t enable_monitor_fsm : 1;
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_BIT                      18
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_FLAG                     0x40000
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_MASK                     0x01
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM(_)                       (((_) >> 18) & 0x01)
        UINT64_t reserved6 : 3;

        /**
         * @brief Limit CPUID Maxval <b>(R/W)</b>
         *
         * [Bit 22] When this bit is set to 1, CPUID.00H returns a maximum value in EAX[7:0] of 2. BIOS should contain a setup
         * question that allows users to specify when the installed OS does not support CPUID functions greater than 2.
         * Before setting this bit, BIOS must execute the CPUID.0H and examine the maximum value returned in EAX[7:0]. If the
         * maximum value is greater than 2, this bit is supported.
         * Otherwise, this bit is not supported. Setting this bit when the maximum value is not greater than 2 may generate a \#GP
         * exception. Setting this bit may cause unexpected behavior in software that depends on the availability of CPUID leaves
         * greater than 2.
         *
         * @remarks 0F_03H
         */
        UINT64_t limit_cpuid_maxval : 1;
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_BIT                      22
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_FLAG                     0x400000
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_MASK                     0x01
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL(_)                       (((_) >> 22) & 0x01)

        /**
         * @brief xTPR Message Disable <b>(R/W)</b>
         *
         * [Bit 23] When set to 1, xTPR messages are disabled. xTPR messages are optional messages that allow the processor to
         * inform the chipset of its priority.
         *
         * @remarks If CPUID.01H:ECX[14] = 1
         */
        UINT64_t xtpr_message_disable : 1;
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_BIT                    23
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_FLAG                   0x800000
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_MASK                   0x01
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE(_)                     (((_) >> 23) & 0x01)
        UINT64_t reserved7 : 10;

        /**
         * @brief XD Bit Disable <b>(R/W)</b>
         *
         * [Bit 34] When set to 1, the Execute Disable Bit feature (XD Bit) is disabled and the XD Bit extended feature flag will
         * be clear (CPUID.80000001H: EDX[20]=0).
         * When set to a 0 (default), the Execute Disable Bit feature (if available) allows the OS to enable PAE paging and take
         * advantage of data only pages.
         * BIOS must not alter the contents of this bit location, if XD bit is not supported. Writing this bit to 1 when the XD Bit
         * extended feature flag is set to 0 may generate a \#GP exception.
         *
         * @remarks If CPUID.80000001H:EDX[20] = 1
         */
        UINT64_t xd_bit_disable : 1;
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_BIT                          34
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_FLAG                         0x400000000
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_MASK                         0x01
#define IA32_MISC_ENABLE_XD_BIT_DISABLE(_)                           (((_) >> 34) & 0x01)
        UINT64_t reserved8 : 29;
    };

    UINT64_t flags;
} ia32_misc_enable_register;


/**
 * Performance Energy Bias Hint.
 *
 * @remarks If CPUID.6H:ECX[3] = 1
 */
#define IA32_ENERGY_PERF_BIAS                                        0x000001B0
typedef union
{
    struct
    {
        /**
         * @brief Power Policy Preference
         *
         * [Bits 3:0] - 0 indicates preference to highest performance.
         * - 15 indicates preference to maximize energy saving.
         */
        UINT64_t power_policy_preference : 4;
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_BIT            0
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_FLAG           0x0F
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_MASK           0x0F
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE(_)             (((_) >> 0) & 0x0F)
        UINT64_t reserved1 : 60;
    };

    UINT64_t flags;
} ia32_energy_perf_bias_register;


/**
 * @brief Package Thermal Status Information <b>(RO)</b>
 *
 * Package Thermal Status Information. Contains status information about the package's thermal sensor.
 *
 * @remarks If CPUID.06H: EAX[6] = 1
 * @see Vol3B[14.8(PACKAGE LEVEL THERMAL MANAGEMENT)]
 */
#define IA32_PACKAGE_THERM_STATUS                                    0x000001B1
typedef union
{
    struct
    {
        /**
         * [Bit 0] Pkg Thermal Status
         */
        UINT64_t thermal_status : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_BIT                 0
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_FLAG                0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_MASK                0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS(_)                  (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Pkg Thermal Status Log
         */
        UINT64_t thermal_status_log : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_BIT             1
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_FLAG            0x02
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_MASK            0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG(_)              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Pkg PROCHOT \# event
         */
        UINT64_t prochot_event : 1;
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_BIT                  2
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_FLAG                 0x04
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_MASK                 0x01
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT(_)                   (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Pkg PROCHOT \# log
         */
        UINT64_t prochot_log : 1;
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_BIT                    3
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_FLAG                   0x08
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_MASK                   0x01
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG(_)                     (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Pkg Critical Temperature Status
         */
        UINT64_t critical_temperature_status : 1;
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_BIT    4
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_FLAG   0x10
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_MASK   0x01
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS(_)     (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Pkg Critical Temperature Status Log
         */
        UINT64_t critical_temperature_status_log : 1;
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_BIT 5
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_FLAG 0x20
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG(_) (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Pkg Thermal Threshold \#1 Status
         */
        UINT64_t thermal_threshold1_status : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_BIT      6
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_FLAG     0x40
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_MASK     0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS(_)       (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Pkg Thermal Threshold \#1 log
         */
        UINT64_t thermal_threshold1_log : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_BIT         7
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_FLAG        0x80
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_MASK        0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG(_)          (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Pkg Thermal Threshold \#2 Status
         */
        UINT64_t thermal_threshold2_status : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_BIT      8
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_FLAG     0x100
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_MASK     0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS(_)       (((_) >> 8) & 0x01)

        /**
         * [Bit 9] Pkg Thermal Threshold \#2 log
         */
        UINT64_t thermal_threshold2_log : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_BIT         9
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_FLAG        0x200
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_MASK        0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG(_)          (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Pkg Power Limitation Status
         */
        UINT64_t power_limitation_status : 1;
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_BIT        10
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_FLAG       0x400
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_MASK       0x01
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS(_)         (((_) >> 10) & 0x01)

        /**
         * [Bit 11] Pkg Power Limitation log
         */
        UINT64_t power_limitation_log : 1;
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_BIT           11
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_FLAG          0x800
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_MASK          0x01
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG(_)            (((_) >> 11) & 0x01)
        UINT64_t reserved1 : 4;

        /**
         * [Bits 22:16] Pkg Digital Readout
         */
        UINT64_t digital_readout : 7;
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_BIT                16
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_FLAG               0x7F0000
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_MASK               0x7F
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT(_)                 (((_) >> 16) & 0x7F)
        UINT64_t reserved2 : 41;
    };

    UINT64_t flags;
} ia32_package_therm_status_register;


/**
 * @brief Package Thermal Interrupt Control <b>(RO)</b>
 *
 * Enables and disables the generation of an interrupt on temperature transitions detected with the package's thermal
 * sensor.
 *
 * @remarks If CPUID.06H: EAX[6] = 1
 * @see Vol3B[14.8(PACKAGE LEVEL THERMAL MANAGEMENT)]
 */
#define IA32_PACKAGE_THERM_INTERRUPT                                 0x000001B2
typedef union
{
    struct
    {
        /**
         * [Bit 0] Pkg High-Temperature Interrupt Enable.
         */
        UINT64_t high_temperature_interrupt_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_BIT 0
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Pkg Low-Temperature Interrupt Enable.
         */
        UINT64_t low_temperature_interrupt_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_BIT 1
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x02
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Pkg PROCHOT\# Interrupt Enable.
         */
        UINT64_t prochot_interrupt_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_BIT    2
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_FLAG   0x04
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_MASK   0x01
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE(_)     (((_) >> 2) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * [Bit 4] Pkg Overheat Interrupt Enable.
         */
        UINT64_t overheat_interrupt_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_BIT   4
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_FLAG  0x10
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_MASK  0x01
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE(_)    (((_) >> 4) & 0x01)
        UINT64_t reserved2 : 3;

        /**
         * [Bits 14:8] Pkg Threshold \#1 Value
         */
        UINT64_t threshold1_value : 7;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_BIT            8
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_FLAG           0x7F00
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_MASK           0x7F
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE(_)             (((_) >> 8) & 0x7F)

        /**
         * [Bit 15] Pkg Threshold \#1 Interrupt Enable.
         */
        UINT64_t threshold1_interrupt_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_BIT 15
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_FLAG 0x8000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE(_)  (((_) >> 15) & 0x01)

        /**
         * [Bits 22:16] Pkg Threshold \#2 Value.
         */
        UINT64_t threshold2_value : 7;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_BIT            16
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_FLAG           0x7F0000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_MASK           0x7F
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE(_)             (((_) >> 16) & 0x7F)

        /**
         * [Bit 23] Pkg Threshold \#2 Interrupt Enable.
         */
        UINT64_t threshold2_interrupt_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_BIT 23
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_FLAG 0x800000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE(_)  (((_) >> 23) & 0x01)

        /**
         * [Bit 24] Pkg Power Limit Notification Enable.
         */
        UINT64_t power_limit_notification_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_BIT 24
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_FLAG 0x1000000
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE(_) (((_) >> 24) & 0x01)
        UINT64_t reserved3 : 39;
    };

    UINT64_t flags;
} ia32_package_therm_interrupt_register;


/**
 * Trace/Profile Resource Control.
 *
 * @remarks 06_0EH
 */
#define IA32_DEBUGCTL                                                0x000001D9
typedef union
{
    struct
    {
        /**
         * [Bit 0] Setting this bit to 1 enables the processor to record a running trace of the most recent branches taken by the
         * processor in the LBR stack.
         *
         * @remarks 06_01H
         */
        UINT64_t lbr : 1;
#define IA32_DEBUGCTL_LBR_BIT                                        0
#define IA32_DEBUGCTL_LBR_FLAG                                       0x01
#define IA32_DEBUGCTL_LBR_MASK                                       0x01
#define IA32_DEBUGCTL_LBR(_)                                         (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Setting this bit to 1 enables the processor to treat EFLAGS.TF as single-step on branches instead of single-step
         * on instructions.
         *
         * @remarks 06_01H
         */
        UINT64_t btf : 1;
#define IA32_DEBUGCTL_BTF_BIT                                        1
#define IA32_DEBUGCTL_BTF_FLAG                                       0x02
#define IA32_DEBUGCTL_BTF_MASK                                       0x01
#define IA32_DEBUGCTL_BTF(_)                                         (((_) >> 1) & 0x01)
        UINT64_t reserved1 : 4;

        /**
         * [Bit 6] Setting this bit to 1 enables branch trace messages to be sent.
         *
         * @remarks 06_0EH
         */
        UINT64_t tr : 1;
#define IA32_DEBUGCTL_TR_BIT                                         6
#define IA32_DEBUGCTL_TR_FLAG                                        0x40
#define IA32_DEBUGCTL_TR_MASK                                        0x01
#define IA32_DEBUGCTL_TR(_)                                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Setting this bit enables branch trace messages (BTMs) to be logged in a BTS buffer.
         *
         * @remarks 06_0EH
         */
        UINT64_t bts : 1;
#define IA32_DEBUGCTL_BTS_BIT                                        7
#define IA32_DEBUGCTL_BTS_FLAG                                       0x80
#define IA32_DEBUGCTL_BTS_MASK                                       0x01
#define IA32_DEBUGCTL_BTS(_)                                         (((_) >> 7) & 0x01)

        /**
         * [Bit 8] When clear, BTMs are logged in a BTS buffer in circular fashion. When this bit is set, an interrupt is generated
         * by the BTS facility when the BTS buffer is full.
         *
         * @remarks 06_0EH
         */
        UINT64_t btint : 1;
#define IA32_DEBUGCTL_BTINT_BIT                                      8
#define IA32_DEBUGCTL_BTINT_FLAG                                     0x100
#define IA32_DEBUGCTL_BTINT_MASK                                     0x01
#define IA32_DEBUGCTL_BTINT(_)                                       (((_) >> 8) & 0x01)

        /**
         * [Bit 9] When set, BTS or BTM is skipped if CPL = 0.
         *
         * @remarks 06_0FH
         */
        UINT64_t bts_off_os : 1;
#define IA32_DEBUGCTL_BTS_OFF_OS_BIT                                 9
#define IA32_DEBUGCTL_BTS_OFF_OS_FLAG                                0x200
#define IA32_DEBUGCTL_BTS_OFF_OS_MASK                                0x01
#define IA32_DEBUGCTL_BTS_OFF_OS(_)                                  (((_) >> 9) & 0x01)

        /**
         * [Bit 10] When set, BTS or BTM is skipped if CPL > 0.
         *
         * @remarks 06_0FH
         */
        UINT64_t bts_off_usr : 1;
#define IA32_DEBUGCTL_BTS_OFF_USR_BIT                                10
#define IA32_DEBUGCTL_BTS_OFF_USR_FLAG                               0x400
#define IA32_DEBUGCTL_BTS_OFF_USR_MASK                               0x01
#define IA32_DEBUGCTL_BTS_OFF_USR(_)                                 (((_) >> 10) & 0x01)

        /**
         * [Bit 11] When set, the LBR stack is frozen on a PMI request.
         *
         * @remarks If CPUID.01H: ECX[15] = 1 && CPUID.0AH: EAX[7:0] > 1
         */
        UINT64_t freeze_lbrs_on_pmi : 1;
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_BIT                         11
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_FLAG                        0x800
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_MASK                        0x01
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI(_)                          (((_) >> 11) & 0x01)

        /**
         * [Bit 12] When set, each ENABLE bit of the global counter control MSR are frozen (address 38FH) on a PMI request.
         *
         * @remarks If CPUID.01H: ECX[15] = 1 && CPUID.0AH: EAX[7:0] > 1
         */
        UINT64_t freeze_perfmon_on_pmi : 1;
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_BIT                      12
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_FLAG                     0x1000
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_MASK                     0x01
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI(_)                       (((_) >> 12) & 0x01)

        /**
         * [Bit 13] When set, enables the logical processor to receive and generate PMI on behalf of the uncore.
         *
         * @remarks 06_1AH
         */
        UINT64_t enable_uncore_pmi : 1;
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_BIT                          13
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_FLAG                         0x2000
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_MASK                         0x01
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI(_)                           (((_) >> 13) & 0x01)

        /**
         * [Bit 14] When set, freezes perfmon and trace messages while in SMM.
         *
         * @remarks If IA32_PERF_CAPABILITIES[12] = 1
         */
        UINT64_t freeze_while_smm : 1;
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_BIT                           14
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_FLAG                          0x4000
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_MASK                          0x01
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM(_)                            (((_) >> 14) & 0x01)

        /**
         * [Bit 15] When set, enables DR7 debug bit on XBEGIN.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[11] = 1)
         */
        UINT64_t rtm_debug : 1;
#define IA32_DEBUGCTL_RTM_DEBUG_BIT                                  15
#define IA32_DEBUGCTL_RTM_DEBUG_FLAG                                 0x8000
#define IA32_DEBUGCTL_RTM_DEBUG_MASK                                 0x01
#define IA32_DEBUGCTL_RTM_DEBUG(_)                                   (((_) >> 15) & 0x01)
        UINT64_t reserved2 : 48;
    };

    UINT64_t flags;
} ia32_debugctl_register;


/**
 * @brief SMRR Base Address <b>(Writeable only in SMM)</b>
 *
 * SMRR Base Address. Base address of SMM memory range.
 *
 * @remarks If IA32_MTRRCAP.SMRR[11] = 1
 */
#define IA32_SMRR_PHYSBASE                                           0x000001F2
typedef union
{
    struct
    {
        /**
         * @brief Type
         *
         * [Bits 7:0] Type. Specifies memory type of the range.
         */
        UINT64_t type : 8;
#define IA32_SMRR_PHYSBASE_TYPE_BIT                                  0
#define IA32_SMRR_PHYSBASE_TYPE_FLAG                                 0xFF
#define IA32_SMRR_PHYSBASE_TYPE_MASK                                 0xFF
#define IA32_SMRR_PHYSBASE_TYPE(_)                                   (((_) >> 0) & 0xFF)
        UINT64_t reserved1 : 4;

        /**
         * [Bits 31:12] SMRR physical Base Address.
         */
        UINT64_t smrr_physical_base_address : 20;
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_BIT            12
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_FLAG           0xFFFFF000
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_MASK           0xFFFFF
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS(_)             (((_) >> 12) & 0xFFFFF)
        UINT64_t reserved2 : 32;
    };

    UINT64_t flags;
} ia32_smrr_physbase_register;


/**
 * @brief SMRR Range Mask <b>(Writeable only in SMM)</b>
 *
 * Range Mask of SMM memory range.
 *
 * @remarks If IA32_MTRRCAP[SMRR] = 1
 */
#define IA32_SMRR_PHYSMASK                                           0x000001F3
typedef union
{
    struct
    {
        UINT64_t reserved1 : 11;

        /**
         * [Bit 11] Enable range mask.
         */
        UINT64_t enable_range_mask : 1;
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_BIT                     11
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_FLAG                    0x800
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_MASK                    0x01
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK(_)                      (((_) >> 11) & 0x01)

        /**
         * [Bits 31:12] SMRR address range mask.
         */
        UINT64_t smrr_address_range_mask : 20;
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_BIT               12
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_FLAG              0xFFFFF000
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_MASK              0xFFFFF
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK(_)                (((_) >> 12) & 0xFFFFF)
        UINT64_t reserved2 : 32;
    };

    UINT64_t flags;
} ia32_smrr_physmask_register;


/**
 * DCA Capability.
 *
 * @remarks If CPUID.01H: ECX[18] = 1
 */
#define IA32_PLATFORM_DCA_CAP                                        0x000001F8

 /**
  * If set, CPU supports Prefetch-Hint type.
  *
  * @remarks If CPUID.01H: ECX[18] = 1
  */
#define IA32_CPU_DCA_CAP                                             0x000001F9

  /**
   * DCA type 0 Status and Control register.
   *
   * @remarks If CPUID.01H: ECX[18] = 1
   */
#define IA32_DCA_0_CAP                                               0x000001FA
typedef union
{
    struct
    {
        /**
         * [Bit 0] Set by HW when DCA is fuseenabled and no defeatures are set.
         */
        UINT64_t dca_active : 1;
#define IA32_DCA_0_CAP_DCA_ACTIVE_BIT                                0
#define IA32_DCA_0_CAP_DCA_ACTIVE_FLAG                               0x01
#define IA32_DCA_0_CAP_DCA_ACTIVE_MASK                               0x01
#define IA32_DCA_0_CAP_DCA_ACTIVE(_)                                 (((_) >> 0) & 0x01)

        /**
         * [Bits 2:1] TRANSACTION.
         */
        UINT64_t transaction : 2;
#define IA32_DCA_0_CAP_TRANSACTION_BIT                               1
#define IA32_DCA_0_CAP_TRANSACTION_FLAG                              0x06
#define IA32_DCA_0_CAP_TRANSACTION_MASK                              0x03
#define IA32_DCA_0_CAP_TRANSACTION(_)                                (((_) >> 1) & 0x03)

        /**
         * [Bits 6:3] DCA_TYPE.
         */
        UINT64_t dca_type : 4;
#define IA32_DCA_0_CAP_DCA_TYPE_BIT                                  3
#define IA32_DCA_0_CAP_DCA_TYPE_FLAG                                 0x78
#define IA32_DCA_0_CAP_DCA_TYPE_MASK                                 0x0F
#define IA32_DCA_0_CAP_DCA_TYPE(_)                                   (((_) >> 3) & 0x0F)

        /**
         * [Bits 10:7] DCA_QUEUE_SIZE.
         */
        UINT64_t dca_queue_size : 4;
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_BIT                            7
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_FLAG                           0x780
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_MASK                           0x0F
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE(_)                             (((_) >> 7) & 0x0F)
        UINT64_t reserved1 : 2;

        /**
         * [Bits 16:13] Writes will update the register but have no HW side-effect.
         */
        UINT64_t dca_delay : 4;
#define IA32_DCA_0_CAP_DCA_DELAY_BIT                                 13
#define IA32_DCA_0_CAP_DCA_DELAY_FLAG                                0x1E000
#define IA32_DCA_0_CAP_DCA_DELAY_MASK                                0x0F
#define IA32_DCA_0_CAP_DCA_DELAY(_)                                  (((_) >> 13) & 0x0F)
        UINT64_t reserved2 : 7;

        /**
         * [Bit 24] SW can request DCA block by setting this bit.
         */
        UINT64_t sw_block : 1;
#define IA32_DCA_0_CAP_SW_BLOCK_BIT                                  24
#define IA32_DCA_0_CAP_SW_BLOCK_FLAG                                 0x1000000
#define IA32_DCA_0_CAP_SW_BLOCK_MASK                                 0x01
#define IA32_DCA_0_CAP_SW_BLOCK(_)                                   (((_) >> 24) & 0x01)
        UINT64_t reserved3 : 1;

        /**
         * [Bit 26] Set when DCA is blocked by HW (e.g. CR0.CD = 1).
         */
        UINT64_t hw_block : 1;
#define IA32_DCA_0_CAP_HW_BLOCK_BIT                                  26
#define IA32_DCA_0_CAP_HW_BLOCK_FLAG                                 0x4000000
#define IA32_DCA_0_CAP_HW_BLOCK_MASK                                 0x01
#define IA32_DCA_0_CAP_HW_BLOCK(_)                                   (((_) >> 26) & 0x01)
        UINT64_t reserved4 : 37;
    };

    UINT64_t flags;
} ia32_dca_0_cap_register;

/**
 * @defgroup ia32_mtrr_physbase \
 *           IA32_MTRR_PHYSBASE(n)
 *
 * IA32_MTRR_PHYSBASE(0-9).
 *
 * @remarks If CPUID.01H: EDX.MTRR[12] = 1
 * @see Vol3A[11.11.2.3(Variable Range MTRRs)]
 * @{
 */
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Specifies the memory type for the range.
         */
        UINT64_t type : 8;
#define IA32_MTRR_PHYSBASE_TYPE_BIT                                  0
#define IA32_MTRR_PHYSBASE_TYPE_FLAG                                 0xFF
#define IA32_MTRR_PHYSBASE_TYPE_MASK                                 0xFF
#define IA32_MTRR_PHYSBASE_TYPE(_)                                   (((_) >> 0) & 0xFF)
        UINT64_t reserved1 : 4;

        /**
         * [Bits 47:12] Specifies the base address of the address range. This 24-bit value, in the case where MAXPHYADDR is 36
         * bits, is extended by 12 bits at the low end to form the base address (this automatically aligns the address on a 4-KByte
         * boundary).
         */
        UINT64_t page_frame_number : 36;
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_BIT                     12
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_FLAG                    0xFFFFFFFFF000
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_MASK                    0xFFFFFFFFF
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER(_)                      (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved2 : 16;
    };

    UINT64_t flags;
} ia32_mtrr_physbase_register;

#define IA32_MTRR_PHYSBASE0                                          0x00000200
#define IA32_MTRR_PHYSBASE1                                          0x00000202
#define IA32_MTRR_PHYSBASE2                                          0x00000204
#define IA32_MTRR_PHYSBASE3                                          0x00000206
#define IA32_MTRR_PHYSBASE4                                          0x00000208
#define IA32_MTRR_PHYSBASE5                                          0x0000020A
#define IA32_MTRR_PHYSBASE6                                          0x0000020C
#define IA32_MTRR_PHYSBASE7                                          0x0000020E
#define IA32_MTRR_PHYSBASE8                                          0x00000210
#define IA32_MTRR_PHYSBASE9                                          0x00000212
/**
 * @}
 */

 /**
  * @defgroup ia32_mtrr_physmask \
  *           IA32_MTRR_PHYSMASK(n)
  *
  * IA32_MTRR_PHYSMASK(0-9).
  *
  * @remarks If CPUID.01H: EDX.MTRR[12] = 1
  * @see Vol3A[11.11.2.3(Variable Range MTRRs)]
  * @{
  */
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Specifies the memory type for the range.
         */
        UINT64_t type : 8;
#define IA32_MTRR_PHYSMASK_TYPE_BIT                                  0
#define IA32_MTRR_PHYSMASK_TYPE_FLAG                                 0xFF
#define IA32_MTRR_PHYSMASK_TYPE_MASK                                 0xFF
#define IA32_MTRR_PHYSMASK_TYPE(_)                                   (((_) >> 0) & 0xFF)
        UINT64_t reserved1 : 3;

        /**
         * [Bit 11] Enables the register pair when set; disables register pair when clear.
         */
        UINT64_t valid : 1;
#define IA32_MTRR_PHYSMASK_VALID_BIT                                 11
#define IA32_MTRR_PHYSMASK_VALID_FLAG                                0x800
#define IA32_MTRR_PHYSMASK_VALID_MASK                                0x01
#define IA32_MTRR_PHYSMASK_VALID(_)                                  (((_) >> 11) & 0x01)

        /**
         * [Bits 47:12] Specifies a mask (24 bits if the maximum physical address size is 36 bits, 28 bits if the maximum physical
         * address size is 40 bits). The mask determines the range of the region being mapped, according to the following
         * relationships:
         * - Address_Within_Range AND PhysMask = PhysBase AND PhysMask
         * - This value is extended by 12 bits at the low end to form the mask value.
         * - The width of the PhysMask field depends on the maximum physical address size supported by the processor.
         * CPUID.80000008H reports the maximum physical address size supported by the processor. If CPUID.80000008H is not
         * available, software may assume that the processor supports a 36-bit physical address size.
         *
         * @see Vol3A[11.11.3(Example Base and Mask Calculations)]
         */
        UINT64_t page_frame_number : 36;
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_BIT                     12
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_FLAG                    0xFFFFFFFFF000
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_MASK                    0xFFFFFFFFF
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER(_)                      (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved2 : 16;
    };

    UINT64_t flags;
} ia32_mtrr_physmask_register;

#define IA32_MTRR_PHYSMASK0                                          0x00000201
#define IA32_MTRR_PHYSMASK1                                          0x00000203
#define IA32_MTRR_PHYSMASK2                                          0x00000205
#define IA32_MTRR_PHYSMASK3                                          0x00000207
#define IA32_MTRR_PHYSMASK4                                          0x00000209
#define IA32_MTRR_PHYSMASK5                                          0x0000020B
#define IA32_MTRR_PHYSMASK6                                          0x0000020D
#define IA32_MTRR_PHYSMASK7                                          0x0000020F
#define IA32_MTRR_PHYSMASK8                                          0x00000211
#define IA32_MTRR_PHYSMASK9                                          0x00000213
/**
 * @}
 */

 /**
  * @defgroup ia32_mtrr_fix \
  *           IA32_MTRR_FIX(x)
  *
  * IA32_MTRR_FIX(x).
  *
  * @remarks If CPUID.01H: EDX.MTRR[12] = 1
  * @see Vol3A[11.11.2.2(Fixed Range MTRRs)]
  * @{
  */
  /**
   * @defgroup ia32_mtrr_fix64k \
   *           IA32_MTRR_FIX64K(x)
   *
   * IA32_MTRR_FIX64K(x).
   * @{
   */
#define IA32_MTRR_FIX64K_BASE                                        0x00000000
#define IA32_MTRR_FIX64K_SIZE                                        0x00010000
#define IA32_MTRR_FIX64K_00000                                       0x00000250
   /**
    * @}
    */

    /**
     * @defgroup ia32_mtrr_fix16k \
     *           IA32_MTRR_FIX16K(x)
     *
     * IA32_MTRR_FIX16K(x).
     * @{
     */
#define IA32_MTRR_FIX16K_BASE                                        0x00080000
#define IA32_MTRR_FIX16K_SIZE                                        0x00004000
#define IA32_MTRR_FIX16K_80000                                       0x00000258
#define IA32_MTRR_FIX16K_A0000                                       0x00000259
     /**
      * @}
      */

      /**
       * @defgroup ia32_mtrr_fix4k \
       *           IA32_MTRR_FIX4K(x)
       *
       * IA32_MTRR_FIX4K(x).
       * @{
       */
#define IA32_MTRR_FIX4K_BASE                                         0x000C0000
#define IA32_MTRR_FIX4K_SIZE                                         0x00001000
#define IA32_MTRR_FIX4K_C0000                                        0x00000268
#define IA32_MTRR_FIX4K_C8000                                        0x00000269
#define IA32_MTRR_FIX4K_D0000                                        0x0000026A
#define IA32_MTRR_FIX4K_D8000                                        0x0000026B
#define IA32_MTRR_FIX4K_E0000                                        0x0000026C
#define IA32_MTRR_FIX4K_E8000                                        0x0000026D
#define IA32_MTRR_FIX4K_F0000                                        0x0000026E
#define IA32_MTRR_FIX4K_F8000                                        0x0000026F
       /**
        * @}
        */

        /**
         * Architecture defined number of fixed range MTRRs (1 for 64k, 2 for 16k, 8 for 4k).
         */
#define IA32_MTRR_FIX_COUNT                                          ((1 + 2 + 8) * 8)

         /**
          * Architecture defined number of variable range MTRRs.
          */
#define IA32_MTRR_VARIABLE_COUNT                                     0x000000FF

          /**
           * A size of array to store all possible MTRRs.
           */
#define IA32_MTRR_COUNT                                              (IA32_MTRR_FIX_COUNT + IA32_MTRR_VARIABLE_COUNT)
           /**
            * @}
            */


            /**
             * IA32_PAT.
             *
             * @remarks If CPUID.01H: EDX.MTRR[16] = 1
             */
#define IA32_PAT                                                     0x00000277
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] PA0.
         */
        UINT64_t pa0 : 3;
#define IA32_PAT_PA0_BIT                                             0
#define IA32_PAT_PA0_FLAG                                            0x07
#define IA32_PAT_PA0_MASK                                            0x07
#define IA32_PAT_PA0(_)                                              (((_) >> 0) & 0x07)
        UINT64_t reserved1 : 5;

        /**
         * [Bits 10:8] PA1.
         */
        UINT64_t pa1 : 3;
#define IA32_PAT_PA1_BIT                                             8
#define IA32_PAT_PA1_FLAG                                            0x700
#define IA32_PAT_PA1_MASK                                            0x07
#define IA32_PAT_PA1(_)                                              (((_) >> 8) & 0x07)
        UINT64_t reserved2 : 5;

        /**
         * [Bits 18:16] PA2.
         */
        UINT64_t pa2 : 3;
#define IA32_PAT_PA2_BIT                                             16
#define IA32_PAT_PA2_FLAG                                            0x70000
#define IA32_PAT_PA2_MASK                                            0x07
#define IA32_PAT_PA2(_)                                              (((_) >> 16) & 0x07)
        UINT64_t reserved3 : 5;

        /**
         * [Bits 26:24] PA3.
         */
        UINT64_t pa3 : 3;
#define IA32_PAT_PA3_BIT                                             24
#define IA32_PAT_PA3_FLAG                                            0x7000000
#define IA32_PAT_PA3_MASK                                            0x07
#define IA32_PAT_PA3(_)                                              (((_) >> 24) & 0x07)
        UINT64_t reserved4 : 5;

        /**
         * [Bits 34:32] PA4.
         */
        UINT64_t pa4 : 3;
#define IA32_PAT_PA4_BIT                                             32
#define IA32_PAT_PA4_FLAG                                            0x700000000
#define IA32_PAT_PA4_MASK                                            0x07
#define IA32_PAT_PA4(_)                                              (((_) >> 32) & 0x07)
        UINT64_t reserved5 : 5;

        /**
         * [Bits 42:40] PA5.
         */
        UINT64_t pa5 : 3;
#define IA32_PAT_PA5_BIT                                             40
#define IA32_PAT_PA5_FLAG                                            0x70000000000
#define IA32_PAT_PA5_MASK                                            0x07
#define IA32_PAT_PA5(_)                                              (((_) >> 40) & 0x07)
        UINT64_t reserved6 : 5;

        /**
         * [Bits 50:48] PA6.
         */
        UINT64_t pa6 : 3;
#define IA32_PAT_PA6_BIT                                             48
#define IA32_PAT_PA6_FLAG                                            0x7000000000000
#define IA32_PAT_PA6_MASK                                            0x07
#define IA32_PAT_PA6(_)                                              (((_) >> 48) & 0x07)
        UINT64_t reserved7 : 5;

        /**
         * [Bits 58:56] PA7.
         */
        UINT64_t pa7 : 3;
#define IA32_PAT_PA7_BIT                                             56
#define IA32_PAT_PA7_FLAG                                            0x700000000000000
#define IA32_PAT_PA7_MASK                                            0x07
#define IA32_PAT_PA7(_)                                              (((_) >> 56) & 0x07)
        UINT64_t reserved8 : 5;
    };

    UINT64_t flags;
} ia32_pat_register;

/**
 * @defgroup ia32_mc_ctl2 \
 *           IA32_MC(i)_CTL2
 *
 * MSR to enable/disable CMCI capability for bank n.
 *
 * @remarks If IA32_MCG_CAP[10] = 1 && IA32_MCG_CAP[7:0] > n
 * @see Vol3B[15.3.2.5(IA32_MCi_CTL2 MSRs)]
 * @{
 */
#define IA32_MC0_CTL2                                                0x00000280
#define IA32_MC1_CTL2                                                0x00000281
#define IA32_MC2_CTL2                                                0x00000282
#define IA32_MC3_CTL2                                                0x00000283
#define IA32_MC4_CTL2                                                0x00000284
#define IA32_MC5_CTL2                                                0x00000285
#define IA32_MC6_CTL2                                                0x00000286
#define IA32_MC7_CTL2                                                0x00000287
#define IA32_MC8_CTL2                                                0x00000288
#define IA32_MC9_CTL2                                                0x00000289
#define IA32_MC10_CTL2                                               0x0000028A
#define IA32_MC11_CTL2                                               0x0000028B
#define IA32_MC12_CTL2                                               0x0000028C
#define IA32_MC13_CTL2                                               0x0000028D
#define IA32_MC14_CTL2                                               0x0000028E
#define IA32_MC15_CTL2                                               0x0000028F
#define IA32_MC16_CTL2                                               0x00000290
#define IA32_MC17_CTL2                                               0x00000291
#define IA32_MC18_CTL2                                               0x00000292
#define IA32_MC19_CTL2                                               0x00000293
#define IA32_MC20_CTL2                                               0x00000294
#define IA32_MC21_CTL2                                               0x00000295
#define IA32_MC22_CTL2                                               0x00000296
#define IA32_MC23_CTL2                                               0x00000297
#define IA32_MC24_CTL2                                               0x00000298
#define IA32_MC25_CTL2                                               0x00000299
#define IA32_MC26_CTL2                                               0x0000029A
#define IA32_MC27_CTL2                                               0x0000029B
#define IA32_MC28_CTL2                                               0x0000029C
#define IA32_MC29_CTL2                                               0x0000029D
#define IA32_MC30_CTL2                                               0x0000029E
#define IA32_MC31_CTL2                                               0x0000029F
typedef union
{
    struct
    {
        /**
         * [Bits 14:0] Corrected error count threshold.
         */
        UINT64_t corrected_error_count_threshold : 15;
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_BIT             0
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_FLAG            0x7FFF
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_MASK            0x7FFF
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD(_)              (((_) >> 0) & 0x7FFF)
        UINT64_t reserved1 : 15;

        /**
         * [Bit 30] CMCI_EN.
         */
        UINT64_t cmci_en : 1;
#define IA32_MC_CTL2_CMCI_EN_BIT                                     30
#define IA32_MC_CTL2_CMCI_EN_FLAG                                    0x40000000
#define IA32_MC_CTL2_CMCI_EN_MASK                                    0x01
#define IA32_MC_CTL2_CMCI_EN(_)                                      (((_) >> 30) & 0x01)
        UINT64_t reserved2 : 33;
    };

    UINT64_t flags;
} ia32_mc_ctl2_register;

/**
 * @}
 */


 /**
  * IA32_MTRR_DEF_TYPE.
  *
  * @remarks If CPUID.01H: EDX.MTRR[12] = 1
  */
#define IA32_MTRR_DEF_TYPE                                           0x000002FF
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] Default Memory Type.
         */
        UINT64_t default_memory_type : 3;
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_BIT                   0
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_FLAG                  0x07
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_MASK                  0x07
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE(_)                    (((_) >> 0) & 0x07)
        UINT64_t reserved1 : 7;

        /**
         * [Bit 10] Fixed Range MTRR Enable.
         */
        UINT64_t fixed_range_mtrr_enable : 1;
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_BIT               10
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_FLAG              0x400
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_MASK              0x01
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE(_)                (((_) >> 10) & 0x01)

        /**
         * [Bit 11] MTRR Enable.
         */
        UINT64_t mtrr_enable : 1;
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_BIT                           11
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_FLAG                          0x800
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_MASK                          0x01
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE(_)                            (((_) >> 11) & 0x01)
        UINT64_t reserved2 : 52;
    };

    UINT64_t flags;
} ia32_mtrr_def_type_register;

/**
 * @defgroup ia32_fixed_ctr \
 *           IA32_FIXED_CTR(n)
 *
 * Fixed-Function Performance Counter n.
 *
 * @remarks If CPUID.0AH: EDX[4:0] > n
 * @{
 */
 /**
  * Counts Instr_Retired.Any.
  */
#define IA32_FIXED_CTR0                                              0x00000309

  /**
   * Counts CPU_CLK_Unhalted.Core
   */
#define IA32_FIXED_CTR1                                              0x0000030A

   /**
    * Counts CPU_CLK_Unhalted.Ref
    */
#define IA32_FIXED_CTR2                                              0x0000030B
    /**
     * @}
     */


     /**
      * Read Only MSR that enumerates the existence of performance monitoring features.
      *
      * @remarks If CPUID.01H: ECX[15] = 1
      */
#define IA32_PERF_CAPABILITIES                                       0x00000345
typedef union
{
    struct
    {
        /**
         * [Bits 5:0] LBR format.
         */
        UINT64_t lbr_format : 6;
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_BIT                        0
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_FLAG                       0x3F
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_MASK                       0x3F
#define IA32_PERF_CAPABILITIES_LBR_FORMAT(_)                         (((_) >> 0) & 0x3F)

        /**
         * [Bit 6] PEBS Trap.
         */
        UINT64_t pebs_trap : 1;
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_BIT                         6
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_FLAG                        0x40
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_MASK                        0x01
#define IA32_PERF_CAPABILITIES_PEBS_TRAP(_)                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] PEBSSaveArchRegs.
         */
        UINT64_t pebs_save_arch_regs : 1;
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_BIT               7
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_FLAG              0x80
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_MASK              0x01
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS(_)                (((_) >> 7) & 0x01)

        /**
         * [Bits 11:8] PEBS Record Format.
         */
        UINT64_t pebs_record_format : 4;
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_BIT                8
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_FLAG               0xF00
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_MASK               0x0F
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT(_)                 (((_) >> 8) & 0x0F)

        /**
         * [Bit 12] Freeze while SMM is supported.
         */
        UINT64_t freeze_while_smm_is_supported : 1;
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_BIT     12
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_FLAG    0x1000
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_MASK    0x01
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED(_)      (((_) >> 12) & 0x01)

        /**
         * [Bit 13] Full width of counter writable via IA32_A_PMCx.
         */
        UINT64_t full_width_counter_write : 1;
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_BIT          13
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_FLAG         0x2000
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_MASK         0x01
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE(_)           (((_) >> 13) & 0x01)
        UINT64_t reserved1 : 50;
    };

    UINT64_t flags;
} ia32_perf_capabilities_register;


/**
 * @brief Fixed-Function Performance Counter Control <b>(R/W)</b>
 *
 * Fixed-Function Performance Counter Control. Counter increments while the results of ANDing respective enable bit in
 * IA32_PERF_GLOBAL_CTRL with the corresponding OS or USR bits in this MSR is true.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 1
 */
#define IA32_FIXED_CTR_CTRL                                          0x0000038D
typedef union
{
    struct
    {
        /**
         * [Bit 0] EN0_OS: Enable Fixed Counter 0 to count while CPL = 0.
         */
        UINT64_t en0_os : 1;
#define IA32_FIXED_CTR_CTRL_EN0_OS_BIT                               0
#define IA32_FIXED_CTR_CTRL_EN0_OS_FLAG                              0x01
#define IA32_FIXED_CTR_CTRL_EN0_OS_MASK                              0x01
#define IA32_FIXED_CTR_CTRL_EN0_OS(_)                                (((_) >> 0) & 0x01)

        /**
         * [Bit 1] EN0_Usr: Enable Fixed Counter 0 to count while CPL > 0.
         */
        UINT64_t en0_usr : 1;
#define IA32_FIXED_CTR_CTRL_EN0_USR_BIT                              1
#define IA32_FIXED_CTR_CTRL_EN0_USR_FLAG                             0x02
#define IA32_FIXED_CTR_CTRL_EN0_USR_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN0_USR(_)                               (((_) >> 1) & 0x01)

        /**
         * [Bit 2] AnyThread: When set to 1, it enables counting the associated event conditions occurring across all logical
         * processors sharing a processor core. When set to 0, the counter only increments the associated event conditions
         * occurring in the logical processor which programmed the MSR.
         */
        UINT64_t any_thread0 : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_BIT                          2
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_FLAG                         0x04
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_MASK                         0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0(_)                           (((_) >> 2) & 0x01)

        /**
         * [Bit 3] EN0_PMI: Enable PMI when fixed counter 0 overflows.
         */
        UINT64_t en0_pmi : 1;
#define IA32_FIXED_CTR_CTRL_EN0_PMI_BIT                              3
#define IA32_FIXED_CTR_CTRL_EN0_PMI_FLAG                             0x08
#define IA32_FIXED_CTR_CTRL_EN0_PMI_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN0_PMI(_)                               (((_) >> 3) & 0x01)

        /**
         * [Bit 4] EN1_OS: Enable Fixed Counter 1 to count while CPL = 0.
         */
        UINT64_t en1_os : 1;
#define IA32_FIXED_CTR_CTRL_EN1_OS_BIT                               4
#define IA32_FIXED_CTR_CTRL_EN1_OS_FLAG                              0x10
#define IA32_FIXED_CTR_CTRL_EN1_OS_MASK                              0x01
#define IA32_FIXED_CTR_CTRL_EN1_OS(_)                                (((_) >> 4) & 0x01)

        /**
         * [Bit 5] EN1_Usr: Enable Fixed Counter 1 to count while CPL > 0.
         */
        UINT64_t en1_usr : 1;
#define IA32_FIXED_CTR_CTRL_EN1_USR_BIT                              5
#define IA32_FIXED_CTR_CTRL_EN1_USR_FLAG                             0x20
#define IA32_FIXED_CTR_CTRL_EN1_USR_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN1_USR(_)                               (((_) >> 5) & 0x01)

        /**
         * [Bit 6] AnyThread: When set to 1, it enables counting the associated event conditions occurring across all logical
         * processors sharing a processor core. When set to 0, the counter only increments the associated event conditions
         * occurring in the logical processor which programmed the MSR.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 2
         */
        UINT64_t any_thread1 : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_BIT                          6
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_FLAG                         0x40
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_MASK                         0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1(_)                           (((_) >> 6) & 0x01)

        /**
         * [Bit 7] EN1_PMI: Enable PMI when fixed counter 1 overflows.
         */
        UINT64_t en1_pmi : 1;
#define IA32_FIXED_CTR_CTRL_EN1_PMI_BIT                              7
#define IA32_FIXED_CTR_CTRL_EN1_PMI_FLAG                             0x80
#define IA32_FIXED_CTR_CTRL_EN1_PMI_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN1_PMI(_)                               (((_) >> 7) & 0x01)

        /**
         * [Bit 8] EN2_OS: Enable Fixed Counter 2 to count while CPL = 0.
         */
        UINT64_t en2_os : 1;
#define IA32_FIXED_CTR_CTRL_EN2_OS_BIT                               8
#define IA32_FIXED_CTR_CTRL_EN2_OS_FLAG                              0x100
#define IA32_FIXED_CTR_CTRL_EN2_OS_MASK                              0x01
#define IA32_FIXED_CTR_CTRL_EN2_OS(_)                                (((_) >> 8) & 0x01)

        /**
         * [Bit 9] EN2_Usr: Enable Fixed Counter 2 to count while CPL > 0.
         */
        UINT64_t en2_usr : 1;
#define IA32_FIXED_CTR_CTRL_EN2_USR_BIT                              9
#define IA32_FIXED_CTR_CTRL_EN2_USR_FLAG                             0x200
#define IA32_FIXED_CTR_CTRL_EN2_USR_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN2_USR(_)                               (((_) >> 9) & 0x01)

        /**
         * [Bit 10] AnyThread: When set to 1, it enables counting the associated event conditions occurring across all logical
         * processors sharing a processor core. When set to 0, the counter only increments the associated event conditions
         * occurring in the logical processor which programmed the MSR.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 2
         */
        UINT64_t any_thread2 : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_BIT                          10
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_FLAG                         0x400
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_MASK                         0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2(_)                           (((_) >> 10) & 0x01)

        /**
         * [Bit 11] EN2_PMI: Enable PMI when fixed counter 2 overflows.
         */
        UINT64_t en2_pmi : 1;
#define IA32_FIXED_CTR_CTRL_EN2_PMI_BIT                              11
#define IA32_FIXED_CTR_CTRL_EN2_PMI_FLAG                             0x800
#define IA32_FIXED_CTR_CTRL_EN2_PMI_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN2_PMI(_)                               (((_) >> 11) & 0x01)
        UINT64_t reserved1 : 52;
    };

    UINT64_t flags;
} ia32_fixed_ctr_ctrl_register;


/**
 * Global Performance Counter Status.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 0
 */
#define IA32_PERF_GLOBAL_STATUS                                      0x0000038E
typedef union
{
    struct
    {
        /**
         * [Bit 0] Ovf_PMC0: Overflow status of IA32_PMC0.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > 0
         */
        UINT64_t ovf_pmc0 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0_BIT                         0
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0_FLAG                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0(_)                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Ovf_PMC1: Overflow status of IA32_PMC1.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > 1
         */
        UINT64_t ovf_pmc1 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_BIT                         1
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_FLAG                        0x02
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1(_)                          (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Ovf_PMC2: Overflow status of IA32_PMC2.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > 2
         */
        UINT64_t ovf_pmc2 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_BIT                         2
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_FLAG                        0x04
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2(_)                          (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Ovf_PMC3: Overflow status of IA32_PMC3.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > 3
         */
        UINT64_t ovf_pmc3 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_BIT                         3
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_FLAG                        0x08
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3(_)                          (((_) >> 3) & 0x01)
        UINT64_t reserved1 : 28;

        /**
         * [Bit 32] Ovf_FixedCtr0: Overflow status of IA32_FIXED_CTR0.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 1
         */
        UINT64_t ovf_fixedctr0 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_BIT                    32
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_FLAG                   0x100000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_MASK                   0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0(_)                     (((_) >> 32) & 0x01)

        /**
         * [Bit 33] Ovf_FixedCtr1: Overflow status of IA32_FIXED_CTR1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 1
         */
        UINT64_t ovf_fixedctr1 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_BIT                    33
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_FLAG                   0x200000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_MASK                   0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1(_)                     (((_) >> 33) & 0x01)

        /**
         * [Bit 34] Ovf_FixedCtr2: Overflow status of IA32_FIXED_CTR2.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 1
         */
        UINT64_t ovf_fixedctr2 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_BIT                    34
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_FLAG                   0x400000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_MASK                   0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2(_)                     (((_) >> 34) & 0x01)
        UINT64_t reserved2 : 20;

        /**
         * [Bit 55] Trace_ToPA_PMI: A PMI occurred due to a ToPA entry memory buffer that was completely filled.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && IA32_RTIT_CTL.ToPA = 1
         */
        UINT64_t trace_topa_pmi : 1;
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_BIT                   55
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_FLAG                  0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_MASK                  0x01
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI(_)                    (((_) >> 55) & 0x01)
        UINT64_t reserved3 : 2;

        /**
         * [Bit 58] LBR_Frz. LBRs are frozen due to:
         * * IA32_DEBUGCTL.FREEZE_LBR_ON_PMI=1.
         * * The LBR stack overflowed.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t lbr_frz : 1;
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_BIT                          58
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_FLAG                         0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_MASK                         0x01
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ(_)                           (((_) >> 58) & 0x01)

        /**
         * [Bit 59] CTR_Frz. Performance counters in the core PMU are frozen due to:
         * * IA32_DEBUGCTL.FREEZE_PERFMON_ON_PMI=1.
         * * One or more core PMU counters overflowed.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t ctr_frz : 1;
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_BIT                          59
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_FLAG                         0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_MASK                         0x01
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ(_)                           (((_) >> 59) & 0x01)

        /**
         * [Bit 60] ASCI: Data in the performance counters in the core PMU may include contributions from the direct or indirect
         * operation Intel SGX to protect an enclave.
         *
         * @remarks If CPUID.(EAX=07H, ECX=0):EBX[2] = 1
         */
        UINT64_t asci : 1;
#define IA32_PERF_GLOBAL_STATUS_ASCI_BIT                             60
#define IA32_PERF_GLOBAL_STATUS_ASCI_FLAG                            0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_ASCI_MASK                            0x01
#define IA32_PERF_GLOBAL_STATUS_ASCI(_)                              (((_) >> 60) & 0x01)

        /**
         * [Bit 61] Uncore counter overflow status.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 2
         */
        UINT64_t ovf_uncore : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_BIT                       61
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_FLAG                      0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_MASK                      0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE(_)                        (((_) >> 61) & 0x01)

        /**
         * [Bit 62] OvfBuf: DS SAVE area Buffer overflow status.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 0
         */
        UINT64_t ovf_buf : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_BIT                          62
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_FLAG                         0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_MASK                         0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF(_)                           (((_) >> 62) & 0x01)

        /**
         * [Bit 63] CondChgd: Status bits of this register have changed.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 0
         */
        UINT64_t cond_chgd : 1;
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_BIT                        63
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_FLAG                       0x8000000000000000
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_MASK                       0x01
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD(_)                         (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} ia32_perf_global_status_register;


/**
 * @brief Global Performance Counter Control <b>(R/W)</b>
 *
 * Global Performance Counter Control. Counter increments while the result of ANDing the respective enable bit in this MSR
 * with the corresponding OS or USR bits in the general-purpose or fixed counter control MSR is true.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 0
 */
#define IA32_PERF_GLOBAL_CTRL                                        0x0000038F
typedef struct
{
    /**
     * EN_PMC(n). Enable bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
     *
     * @remarks If CPUID.0AH: EAX[15:8] > n
     */
    UINT32_t en_pmcn;

    /**
     * EN_FIXED_CTR(n). Enable bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
     *
     * @remarks If CPUID.0AH: EDX[4:0] > n
     */
    UINT32_t en_fixed_ctrn;
} ia32_perf_global_ctrl_register;


/**
 * Global Performance Counter Overflow Reset Control.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PERF_GLOBAL_STATUS_RESET                                0x00000390
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] Set 1 to clear Ovf_PMC(n) bit. Clear bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > n
         */
        UINT64_t clear_ovf_pmcn : 32;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_BIT             0
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_FLAG            0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_MASK            0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN(_)              (((_) >> 0) & 0xFFFFFFFF)

        /**
         * [Bits 34:32] Set 1 to clear Ovf_FIXED_CTR(n) bit. Clear bitmask. Only the first n-1 bits are valid. Bits 31:n are
         * reserved.
         *
         * @remarks If CPUID.0AH: EDX[4:0] > n
         */
        UINT64_t clear_ovf_fixed_ctrn : 3;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_BIT       32
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_FLAG      0x700000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_MASK      0x07
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN(_)        (((_) >> 32) & 0x07)
        UINT64_t reserved1 : 20;

        /**
         * [Bit 55] Set 1 to clear Trace_ToPA_PMI bit.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && IA32_RTIT_CTL.ToPA = 1
         */
        UINT64_t clear_trace_topa_pmi : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_BIT       55
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_FLAG      0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_MASK      0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI(_)        (((_) >> 55) & 0x01)
        UINT64_t reserved2 : 2;

        /**
         * [Bit 58] Set 1 to clear LBR_Frz bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t clear_lbr_frz : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_BIT              58
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_FLAG             0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_MASK             0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ(_)               (((_) >> 58) & 0x01)

        /**
         * [Bit 59] Set 1 to clear CTR_Frz bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t clear_ctr_frz : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_BIT              59
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_FLAG             0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_MASK             0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ(_)               (((_) >> 59) & 0x01)

        /**
         * [Bit 60] Set 1 to clear ASCI bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t clear_asci : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_BIT                 60
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_FLAG                0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_MASK                0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI(_)                  (((_) >> 60) & 0x01)

        /**
         * [Bit 61] Set 1 to clear Ovf_Uncore bit.
         *
         * @remarks 06_2EH
         */
        UINT64_t clear_ovf_uncore : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_BIT           61
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_FLAG          0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_MASK          0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE(_)            (((_) >> 61) & 0x01)

        /**
         * [Bit 62] Set 1 to clear OvfBuf bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 0
         */
        UINT64_t clear_ovf_buf : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_BIT              62
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_FLAG             0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_MASK             0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF(_)               (((_) >> 62) & 0x01)

        /**
         * [Bit 63] Set 1 to clear CondChgd bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 0
         */
        UINT64_t clear_cond_chgd : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_BIT            63
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_FLAG           0x8000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_MASK           0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD(_)             (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} ia32_perf_global_status_reset_register;


/**
 * Global Performance Counter Overflow Set Control.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PERF_GLOBAL_STATUS_SET                                  0x00000391
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] Set 1 to cause Ovf_PMC(n) = 1. Set bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > n
         */
        UINT64_t ovf_pmcn : 32;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_BIT                     0
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_FLAG                    0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_MASK                    0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN(_)                      (((_) >> 0) & 0xFFFFFFFF)

        /**
         * [Bits 34:32] Set 1 to cause Ovf_FIXED_CTR(n) = 1. Set bitmask. Only the first n-1 bits are valid. Bits 31:n are
         * reserved.
         *
         * @remarks If CPUID.0AH: EDX[4:0] > n
         */
        UINT64_t ovf_fixed_ctrn : 3;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_BIT               32
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_FLAG              0x700000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_MASK              0x07
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN(_)                (((_) >> 32) & 0x07)
        UINT64_t reserved1 : 20;

        /**
         * [Bit 55] Set 1 to cause Trace_ToPA_PMI = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t trace_topa_pmi : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_BIT               55
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_FLAG              0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_MASK              0x01
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI(_)                (((_) >> 55) & 0x01)
        UINT64_t reserved2 : 2;

        /**
         * [Bit 58] Set 1 to cause LBR_Frz = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t lbr_frz : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_BIT                      58
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_FLAG                     0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_MASK                     0x01
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ(_)                       (((_) >> 58) & 0x01)

        /**
         * [Bit 59] Set 1 to cause CTR_Frz = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t ctr_frz : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_BIT                      59
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_FLAG                     0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_MASK                     0x01
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ(_)                       (((_) >> 59) & 0x01)

        /**
         * [Bit 60] Set 1 to cause ASCI = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t asci : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_BIT                         60
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_FLAG                        0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI(_)                          (((_) >> 60) & 0x01)

        /**
         * [Bit 61] Set 1 to cause Ovf_Uncore = 1.
         *
         * @remarks 06_2EH
         */
        UINT64_t ovf_uncore : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_BIT                   61
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_FLAG                  0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_MASK                  0x01
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE(_)                    (((_) >> 61) & 0x01)

        /**
         * [Bit 62] Set 1 to cause OvfBuf = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        UINT64_t ovf_buf : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_BIT                      62
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_FLAG                     0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_MASK                     0x01
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF(_)                       (((_) >> 62) & 0x01)
        UINT64_t reserved3 : 1;
    };

    UINT64_t flags;
} ia32_perf_global_status_set_register;


/**
 * Indicator that core perfmon interface is in use.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PERF_GLOBAL_INUSE                                       0x00000392
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] IA32_PERFEVTSEL(n) in use. Status bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > n
         */
        UINT64_t ia32_perfevtseln_in_use : 32;
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_BIT           0
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_FLAG          0xFFFFFFFF
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_MASK          0xFFFFFFFF
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE(_)            (((_) >> 0) & 0xFFFFFFFF)

        /**
         * [Bits 34:32] IA32_FIXED_CTR(n) in use. Status bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
         */
        UINT64_t ia32_fixed_ctrn_in_use : 3;
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_BIT            32
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_FLAG           0x700000000
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_MASK           0x07
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE(_)             (((_) >> 32) & 0x07)
        UINT64_t reserved1 : 28;

        /**
         * [Bit 63] PMI in use.
         */
        UINT64_t pmi_in_use : 1;
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_BIT                        63
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_FLAG                       0x8000000000000000
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_MASK                       0x01
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE(_)                         (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} ia32_perf_global_inuse_register;


/**
 * PEBS Control.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PEBS_ENABLE                                             0x000003F1
typedef union
{
    struct
    {
        /**
         * [Bit 0] Enable PEBS on IA32_PMC0.
         *
         * @remarks 06_0FH
         */
        UINT64_t enable_pebs : 1;
#define IA32_PEBS_ENABLE_ENABLE_PEBS_BIT                             0
#define IA32_PEBS_ENABLE_ENABLE_PEBS_FLAG                            0x01
#define IA32_PEBS_ENABLE_ENABLE_PEBS_MASK                            0x01
#define IA32_PEBS_ENABLE_ENABLE_PEBS(_)                              (((_) >> 0) & 0x01)

        /**
         * [Bits 3:1] Reserved or model specific.
         */
        UINT64_t reservedormodelspecific1 : 3;
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_BIT                1
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_FLAG               0x0E
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_MASK               0x07
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1(_)                 (((_) >> 1) & 0x07)
        UINT64_t reserved1 : 28;

        /**
         * [Bits 35:32] Reserved or model specific.
         */
        UINT64_t reservedormodelspecific2 : 4;
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_BIT                32
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_FLAG               0xF00000000
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_MASK               0x0F
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2(_)                 (((_) >> 32) & 0x0F)
        UINT64_t reserved2 : 28;
    };

    UINT64_t flags;
} ia32_pebs_enable_register;

/**
 * @defgroup ia32_mc_ctl \
 *           IA32_MC(i)_CTL
 *
 * IA32_MC(0-28)_CTL.
 *
 * @remarks If IA32_MCG_CAP.CNT > n
 * @{
 */
#define IA32_MC0_CTL                                                 0x00000400
#define IA32_MC1_CTL                                                 0x00000404
#define IA32_MC2_CTL                                                 0x00000408
#define IA32_MC3_CTL                                                 0x0000040C
#define IA32_MC4_CTL                                                 0x00000410
#define IA32_MC5_CTL                                                 0x00000414
#define IA32_MC6_CTL                                                 0x00000418
#define IA32_MC7_CTL                                                 0x0000041C
#define IA32_MC8_CTL                                                 0x00000420
#define IA32_MC9_CTL                                                 0x00000424
#define IA32_MC10_CTL                                                0x00000428
#define IA32_MC11_CTL                                                0x0000042C
#define IA32_MC12_CTL                                                0x00000430
#define IA32_MC13_CTL                                                0x00000434
#define IA32_MC14_CTL                                                0x00000438
#define IA32_MC15_CTL                                                0x0000043C
#define IA32_MC16_CTL                                                0x00000440
#define IA32_MC17_CTL                                                0x00000444
#define IA32_MC18_CTL                                                0x00000448
#define IA32_MC19_CTL                                                0x0000044C
#define IA32_MC20_CTL                                                0x00000450
#define IA32_MC21_CTL                                                0x00000454
#define IA32_MC22_CTL                                                0x00000458
#define IA32_MC23_CTL                                                0x0000045C
#define IA32_MC24_CTL                                                0x00000460
#define IA32_MC25_CTL                                                0x00000464
#define IA32_MC26_CTL                                                0x00000468
#define IA32_MC27_CTL                                                0x0000046C
#define IA32_MC28_CTL                                                0x00000470
 /**
  * @}
  */

  /**
   * @defgroup ia32_mc_status \
   *           IA32_MC(i)_STATUS
   *
   * IA32_MC(0-28)_STATUS.
   *
   * @remarks If IA32_MCG_CAP.CNT > n
   * @{
   */
#define IA32_MC0_STATUS                                              0x00000401
#define IA32_MC1_STATUS                                              0x00000405
#define IA32_MC2_STATUS                                              0x00000409
#define IA32_MC3_STATUS                                              0x0000040D
#define IA32_MC4_STATUS                                              0x00000411
#define IA32_MC5_STATUS                                              0x00000415
#define IA32_MC6_STATUS                                              0x00000419
#define IA32_MC7_STATUS                                              0x0000041D
#define IA32_MC8_STATUS                                              0x00000421
#define IA32_MC9_STATUS                                              0x00000425
#define IA32_MC10_STATUS                                             0x00000429
#define IA32_MC11_STATUS                                             0x0000042D
#define IA32_MC12_STATUS                                             0x00000431
#define IA32_MC13_STATUS                                             0x00000435
#define IA32_MC14_STATUS                                             0x00000439
#define IA32_MC15_STATUS                                             0x0000043D
#define IA32_MC16_STATUS                                             0x00000441
#define IA32_MC17_STATUS                                             0x00000445
#define IA32_MC18_STATUS                                             0x00000449
#define IA32_MC19_STATUS                                             0x0000044D
#define IA32_MC20_STATUS                                             0x00000451
#define IA32_MC21_STATUS                                             0x00000455
#define IA32_MC22_STATUS                                             0x00000459
#define IA32_MC23_STATUS                                             0x0000045D
#define IA32_MC24_STATUS                                             0x00000461
#define IA32_MC25_STATUS                                             0x00000465
#define IA32_MC26_STATUS                                             0x00000469
#define IA32_MC27_STATUS                                             0x0000046D
#define IA32_MC28_STATUS                                             0x00000471
   /**
    * @}
    */

    /**
     * @defgroup ia32_mc_addr \
     *           IA32_MC(i)_ADDR
     *
     * IA32_MC(0-28)_ADDR.
     *
     * @remarks If IA32_MCG_CAP.CNT > n
     * @{
     */
#define IA32_MC0_ADDR                                                0x00000402
#define IA32_MC1_ADDR                                                0x00000406
#define IA32_MC2_ADDR                                                0x0000040A
#define IA32_MC3_ADDR                                                0x0000040E
#define IA32_MC4_ADDR                                                0x00000412
#define IA32_MC5_ADDR                                                0x00000416
#define IA32_MC6_ADDR                                                0x0000041A
#define IA32_MC7_ADDR                                                0x0000041E
#define IA32_MC8_ADDR                                                0x00000422
#define IA32_MC9_ADDR                                                0x00000426
#define IA32_MC10_ADDR                                               0x0000042A
#define IA32_MC11_ADDR                                               0x0000042E
#define IA32_MC12_ADDR                                               0x00000432
#define IA32_MC13_ADDR                                               0x00000436
#define IA32_MC14_ADDR                                               0x0000043A
#define IA32_MC15_ADDR                                               0x0000043E
#define IA32_MC16_ADDR                                               0x00000442
#define IA32_MC17_ADDR                                               0x00000446
#define IA32_MC18_ADDR                                               0x0000044A
#define IA32_MC19_ADDR                                               0x0000044E
#define IA32_MC20_ADDR                                               0x00000452
#define IA32_MC21_ADDR                                               0x00000456
#define IA32_MC22_ADDR                                               0x0000045A
#define IA32_MC23_ADDR                                               0x0000045E
#define IA32_MC24_ADDR                                               0x00000462
#define IA32_MC25_ADDR                                               0x00000466
#define IA32_MC26_ADDR                                               0x0000046A
#define IA32_MC27_ADDR                                               0x0000046E
#define IA32_MC28_ADDR                                               0x00000472
     /**
      * @}
      */

      /**
       * @defgroup ia32_mc_misc \
       *           IA32_MC(i)_MISC
       *
       * IA32_MC(0-28)_MISC.
       *
       * @remarks If IA32_MCG_CAP.CNT > n
       * @{
       */
#define IA32_MC0_MISC                                                0x00000403
#define IA32_MC1_MISC                                                0x00000407
#define IA32_MC2_MISC                                                0x0000040B
#define IA32_MC3_MISC                                                0x0000040F
#define IA32_MC4_MISC                                                0x00000413
#define IA32_MC5_MISC                                                0x00000417
#define IA32_MC6_MISC                                                0x0000041B
#define IA32_MC7_MISC                                                0x0000041F
#define IA32_MC8_MISC                                                0x00000423
#define IA32_MC9_MISC                                                0x00000427
#define IA32_MC10_MISC                                               0x0000042B
#define IA32_MC11_MISC                                               0x0000042F
#define IA32_MC12_MISC                                               0x00000433
#define IA32_MC13_MISC                                               0x00000437
#define IA32_MC14_MISC                                               0x0000043B
#define IA32_MC15_MISC                                               0x0000043F
#define IA32_MC16_MISC                                               0x00000443
#define IA32_MC17_MISC                                               0x00000447
#define IA32_MC18_MISC                                               0x0000044B
#define IA32_MC19_MISC                                               0x0000044F
#define IA32_MC20_MISC                                               0x00000453
#define IA32_MC21_MISC                                               0x00000457
#define IA32_MC22_MISC                                               0x0000045B
#define IA32_MC23_MISC                                               0x0000045F
#define IA32_MC24_MISC                                               0x00000463
#define IA32_MC25_MISC                                               0x00000467
#define IA32_MC26_MISC                                               0x0000046B
#define IA32_MC27_MISC                                               0x0000046F
#define IA32_MC28_MISC                                               0x00000473
       /**
        * @}
        */


        /**
         * Reporting Register of Basic VMX Capabilities.
         *
         * @remarks If CPUID.01H:ECX.[5] = 1
         * @see Vol3D[A.1(BASIC VMX INFORMATION)]
         * @see Vol3D[A.1(Basic VMX Information)] (reference)
         */
#define IA32_VMX_BASIC                                               0x00000480
typedef union
{
    struct
    {
        /**
         * @brief VMCS revision identifier used by the processor
         *
         * [Bits 30:0] 31-bit VMCS revision identifier used by the processor. Processors that use the same VMCS revision identifier
         * use the same size for VMCS regions.
         */
        UINT64_t vmcs_revision_id : 31;
#define IA32_VMX_BASIC_VMCS_REVISION_ID_BIT                          0
#define IA32_VMX_BASIC_VMCS_REVISION_ID_FLAG                         0x7FFFFFFF
#define IA32_VMX_BASIC_VMCS_REVISION_ID_MASK                         0x7FFFFFFF
#define IA32_VMX_BASIC_VMCS_REVISION_ID(_)                           (((_) >> 0) & 0x7FFFFFFF)

        /**
         * [Bit 31] Bit 31 is always 0.
         */
        UINT64_t must_be_zero : 1;
#define IA32_VMX_BASIC_MUST_BE_ZERO_BIT                              31
#define IA32_VMX_BASIC_MUST_BE_ZERO_FLAG                             0x80000000
#define IA32_VMX_BASIC_MUST_BE_ZERO_MASK                             0x01
#define IA32_VMX_BASIC_MUST_BE_ZERO(_)                               (((_) >> 31) & 0x01)

        /**
         * @brief Size of the VMCS
         *
         * [Bits 44:32] Report the number of bytes that software should allocate for the VMXON region and any VMCS region. It is a
         * value greater than 0 and at most 4096 (bit 44 is set if and only if bits 43:32 are clear).
         */
        UINT64_t vmcs_size_inUINT8s : 13;
#define IA32_VMX_BASIC_VMCS_SIZE_INUINT8S_BIT                        32
#define IA32_VMX_BASIC_VMCS_SIZE_INUINT8S_FLAG                       0x1FFF00000000
#define IA32_VMX_BASIC_VMCS_SIZE_INUINT8S_MASK                       0x1FFF
#define IA32_VMX_BASIC_VMCS_SIZE_INUINT8S(_)                         (((_) >> 32) & 0x1FFF)
        UINT64_t reserved1 : 3;

        /**
         * @brief Width of physical address used for the VMCS
         *        - 0 -> limited to the available amount of physical RAM
         *        - 1 -> within the first 4 GB
         *
         * [Bit 48] Indicates the width of the physical addresses that may be used for the VMXON region, each VMCS, and data
         * structures referenced by pointers in a VMCS (I/O bitmaps, virtual-APIC page, MSR areas for VMX transitions). If the bit
         * is 0, these addresses are limited to the processor's physical-address width.2 If the bit is 1, these addresses are
         * limited to 32 bits. This bit is always 0 for processors that support Intel 64 architecture.
         */
        UINT64_t vmcs_physical_address_width : 1;
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_BIT               48
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_FLAG              0x1000000000000
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_MASK              0x01
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH(_)                (((_) >> 48) & 0x01)

        /**
         * @brief Whether the processor supports the dual-monitor treatment of system-management interrupts and system-management
         *        code (always 1)
         *
         * [Bit 49] Read as 1, the logical processor supports the dual-monitor treatment of system-management interrupts and
         * system-management mode.
         *
         * @see Vol3C[34.15(DUAL-MONITOR TREATMENT OF SMIs AND SMM)]
         */
        UINT64_t dual_monitor_support : 1;
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_BIT                      49
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_FLAG                     0x2000000000000
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_MASK                     0x01
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT(_)                       (((_) >> 49) & 0x01)

        /**
         * @brief Memory type that must be used for the VMCS
         *
         * [Bits 53:50] Report the memory type that should be used for the VMCS, for data structures referenced by pointers in the
         * VMCS (I/O bitmaps, virtual-APIC page, MSR areas for VMX transitions), and for the MSEG header. If software needs to
         * access these data structures (e.g., to modify the contents of the MSR bitmaps), it can configure the paging structures
         * to map them into the linear-address space. If it does so, it should establish mappings that use the memory type reported
         * bits 53:50 in this MSR.
         * As of this writing, all processors that support VMX operation indicate the write-back type.
         */
        UINT64_t memory_type : 4;
#define IA32_VMX_BASIC_MEMORY_TYPE_BIT                               50
#define IA32_VMX_BASIC_MEMORY_TYPE_FLAG                              0x3C000000000000
#define IA32_VMX_BASIC_MEMORY_TYPE_MASK                              0x0F
#define IA32_VMX_BASIC_MEMORY_TYPE(_)                                (((_) >> 50) & 0x0F)

        /**
         * @brief Whether the processor provides additional information for exits due to INS/OUTS
         *
         * [Bit 54] When set to 1, the processor reports information in the VM-exit instruction-information field on VM exits due
         * to execution of the INS and OUTS instructions. This reporting is done only if this bit is read as 1.
         *
         * @see Vol3C[27.2.4(Information for VM Exits Due to Instruction Execution)]
         */
        UINT64_t ins_outs_reporting : 1;
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_BIT                        54
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_FLAG                       0x40000000000000
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_MASK                       0x01
#define IA32_VMX_BASIC_INS_OUTS_REPORTING(_)                         (((_) >> 54) & 0x01)

        /**
         * @brief Whether default 1 bits in control MSRs (pin/proc/exit/entry) may be cleared to 0 and that 'true' control MSRs are
         *        supported
         *
         * [Bit 55] Is read as 1 if any VMX controls that default to 1 may be cleared to 0. It also reports support for the VMX
         * capability MSRs IA32_VMX_TRUE_PINBASED_CTLS, IA32_VMX_TRUE_PROCBASED_CTLS, IA32_VMX_TRUE_EXIT_CTLS, and
         * IA32_VMX_TRUE_ENTRY_CTLS.
         *
         * @see Vol3D[A.2(RESERVED CONTROLS AND DEFAULT SETTINGS)]
         * @see Vol3D[A.3.1(Pin-Based VM-Execution Controls)]
         * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)]
         * @see Vol3D[A.4(VM-EXIT CONTROLS)]
         * @see Vol3D[A.5(VM-ENTRY CONTROLS)]
         */
        UINT64_t vmx_controls : 1;
#define IA32_VMX_BASIC_VMX_CONTROLS_BIT                              55
#define IA32_VMX_BASIC_VMX_CONTROLS_FLAG                             0x80000000000000
#define IA32_VMX_BASIC_VMX_CONTROLS_MASK                             0x01
#define IA32_VMX_BASIC_VMX_CONTROLS(_)                               (((_) >> 55) & 0x01)
        UINT64_t reserved2 : 8;
    };

    UINT64_t flags;
} ia32_vmx_basic_register;


/**
 * Capability Reporting Register of Pin-Based VM-Execution Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.3.1(Pin-Based VM-Execution Controls)]
 * @see Vol3C[24.6.1(Pin-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PINBASED_CTLS                                       0x00000481
typedef union
{
    struct
    {
        /**
         * @brief External interrupts cause VM-exits if set; otherwise dispatched through the guest's IDT
         *
         * [Bit 0] If this control is 1, external interrupts cause VM exits. Otherwise, they are delivered normally through the
         * guest interrupt-descriptor table (IDT). If this control is 1, the value of RFLAGS.IF does not affect interrupt blocking.
         */
        UINT64_t external_interrupt_exiting : 1;
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_BIT        0
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_FLAG       0x01
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_MASK       0x01
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING(_)         (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 2;

        /**
         * @brief Non-maskable interrupts cause VM-exits if set; otherwise dispatched through the guest's IDT
         *
         * [Bit 3] If this control is 1, non-maskable interrupts (NMIs) cause VM exits. Otherwise, they are delivered normally
         * using descriptor 2 of the IDT. This control also determines interactions between IRET and blocking by NMI.
         *
         * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
         */
        UINT64_t nmi_exiting : 1;
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_BIT                       3
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_FLAG                      0x08
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_MASK                      0x01
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING(_)                        (((_) >> 3) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * @brief Virtual NMIs
         *
         * [Bit 5] If this control is 1, NMIs are never blocked and the "blocking by NMI" bit (bit 3) in the interruptibility-state
         * field indicates "virtual-NMI blocking". This control also interacts with the "NMI-window exiting" VM-execution control.
         *
         * @see Vol3C[24.6.2(Processor-Based VM-Execution Controls)]
         */
        UINT64_t virtual_nmi : 1;
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_BIT                       5
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_FLAG                      0x20
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_MASK                      0x01
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI(_)                        (((_) >> 5) & 0x01)

        /**
         * @brief Activate VMX preemption timer
         *
         * [Bit 6] If this control is 1, the VMX-preemption timer counts down in VMX non-root operation. A VM exit occurs when the
         * timer counts down to zero.
         *
         * @see Vol3C[25.5.1(VMX-Preemption Timer)]
         * @see Vol3C[25.2(OTHER CAUSES OF VM EXITS)]
         */
        UINT64_t activate_vmx_preemption_timer : 1;
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_BIT     6
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_FLAG    0x40
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_MASK    0x01
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER(_)      (((_) >> 6) & 0x01)

        /**
         * @brief Process interrupts with the posted-interrupt notification vector
         *
         * [Bit 7] If this control is 1, the processor treats interrupts with the posted-interrupt notification vector specially,
         * updating the virtual-APIC page with posted-interrupt requests.
         *
         * @see Vol3C[24.6.8(Controls for APIC Virtualization)]
         * @see Vol3C[29.6(POSTED-INTERRUPT PROCESSING)]
         */
        UINT64_t process_posted_interrupts : 1;
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_BIT         7
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_FLAG        0x80
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_MASK        0x01
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS(_)          (((_) >> 7) & 0x01)
        UINT64_t reserved3 : 56;
    };

    UINT64_t flags;
} ia32_vmx_pinbased_ctls_register;


/**
 * Capability Reporting Register of Primary Processor-Based VM-Execution Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)]
 * @see Vol3C[24.6.2(Processor-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PROCBASED_CTLS                                      0x00000482
typedef union
{
    struct
    {
        UINT64_t reserved1 : 2;

        /**
         * @brief VM-exit as soon as RFLAGS.IF=1 and no blocking is active
         *
         * [Bit 2] If this control is 1, a VM exit occurs at the beginning of any instruction if RFLAGS.IF = 1 and there are no
         * other blocking of interrupts.
         *
         * @see Vol3C[24.4.2(Guest Non-Register State)]
         */
        UINT64_t interrupt_window_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_BIT         2
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_FLAG        0x04
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_MASK        0x01
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING(_)          (((_) >> 2) & 0x01)

        /**
         * @brief Use timestamp counter offset
         *
         * [Bit 3] This control determines whether executions of RDTSC, executions of RDTSCP, and executions of RDMSR that read
         * from the IA32_TIME_STAMP_COUNTER MSR return a value modified by the TSC offset field.
         *
         * @see Vol3C[24.6.5(Time-Stamp Counter Offset and Multiplier)]
         * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
         */
        UINT64_t use_tsc_offsetting : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_BIT               3
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_FLAG              0x08
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_MASK              0x01
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING(_)                (((_) >> 3) & 0x01)
        UINT64_t reserved2 : 3;

        /**
         * @brief VM-exit when executing the HLT instruction
         *
         * [Bit 7] This control determines whether executions of HLT cause VM exits.
         */
        UINT64_t hlt_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_BIT                      7
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_FLAG                     0x80
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_MASK                     0x01
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING(_)                       (((_) >> 7) & 0x01)
        UINT64_t reserved3 : 1;

        /**
         * @brief VM-exit when executing the INVLPG instruction
         *
         * [Bit 9] This control determines whether executions of INVLPG cause VM exits.
         */
        UINT64_t invlpg_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_BIT                   9
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_FLAG                  0x200
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING(_)                    (((_) >> 9) & 0x01)

        /**
         * @brief VM-exit when executing the MWAIT instruction
         *
         * [Bit 10] This control determines whether executions of MWAIT cause VM exits.
         */
        UINT64_t mwait_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_BIT                    10
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_FLAG                   0x400
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING(_)                     (((_) >> 10) & 0x01)

        /**
         * @brief VM-exit when executing the RDPMC instruction
         *
         * [Bit 11] This control determines whether executions of RDPMC cause VM exits.
         */
        UINT64_t rdpmc_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_BIT                    11
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_FLAG                   0x800
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING(_)                     (((_) >> 11) & 0x01)

        /**
         * @brief VM-exit when executing the RDTSC/RDTSCP instruction
         *
         * [Bit 12] This control determines whether executions of RDTSC and RDTSCP cause VM exits.
         */
        UINT64_t rdtsc_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_BIT                    12
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_FLAG                   0x1000
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING(_)                     (((_) >> 12) & 0x01)
        UINT64_t reserved4 : 2;

        /**
         * @brief VM-exit when executing the MOV to CR3 instruction (forced to 1 on the 'first' VT-x capable CPUs; this actually
         *        includes the newest Nehalem CPUs)
         *
         * [Bit 15] In conjunction with the CR3-target controls, this control determines whether executions of MOV to CR3 cause VM
         * exits. The first processors to support the virtual-machine extensions supported only the 1-setting of this control.
         *
         * @see Vol3C[24.6.7(CR3-Target Controls)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        UINT64_t cr3_load_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_BIT                 15
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_FLAG                0x8000
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_MASK                0x01
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING(_)                  (((_) >> 15) & 0x01)

        /**
         * @brief VM-exit when executing the MOV from CR3 instruction (forced to 1 on the 'first' VT-x capable CPUs; this actually
         *        includes the newest Nehalem CPUs)
         *
         * [Bit 16] This control determines whether executions of MOV from CR3 cause VM exits. The first processors to support the
         * virtual-machine extensions supported only the 1-setting of this control.
         */
        UINT64_t cr3_store_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_BIT                16
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_FLAG               0x10000
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_MASK               0x01
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING(_)                 (((_) >> 16) & 0x01)
        UINT64_t reserved5 : 2;

        /**
         * @brief VM-exit on CR8 loads
         *
         * [Bit 19] This control determines whether executions of MOV to CR8 cause VM exits.
         */
        UINT64_t cr8_load_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_BIT                 19
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_FLAG                0x80000
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_MASK                0x01
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING(_)                  (((_) >> 19) & 0x01)

        /**
         * @brief VM-exit on CR8 stores
         *
         * [Bit 20] This control determines whether executions of MOV from CR8 cause VM exits.
         */
        UINT64_t cr8_store_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_BIT                20
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_FLAG               0x100000
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_MASK               0x01
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING(_)                 (((_) >> 20) & 0x01)

        /**
         * @brief Use TPR shadow
         *
         * [Bit 21] Setting this control to 1 enables TPR virtualization and other APIC-virtualization features.
         *
         * @see Vol3C[29(APIC VIRTUALIZATION AND VIRTUAL INTERRUPTS)]
         */
        UINT64_t use_tpr_shadow : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_BIT                   21
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_FLAG                  0x200000
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW(_)                    (((_) >> 21) & 0x01)

        /**
         * @brief VM-exit when virtual NMI blocking is disabled
         *
         * [Bit 22] If this control is 1, a VM exit occurs at the beginning of any instruction if there is no virtual-NMI blocking.
         *
         * @see Vol3C[24.4.2(Guest Non-Register State)]
         */
        UINT64_t nmi_window_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_BIT               22
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_FLAG              0x400000
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_MASK              0x01
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING(_)                (((_) >> 22) & 0x01)

        /**
         * @brief VM-exit when executing a MOV DRx instruction
         *
         * [Bit 23] This control determines whether executions of MOV DR cause VM exits.
         */
        UINT64_t mov_dr_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_BIT                   23
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_FLAG                  0x800000
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING(_)                    (((_) >> 23) & 0x01)

        /**
         * @brief VM-exit when executing IO instructions
         *
         * [Bit 24] This control determines whether executions of I/O instructions (IN, INS/INSB/INSW/INSD, OUT, and
         * OUTS/OUTSB/OUTSW/OUTSD) cause VM exits.
         */
        UINT64_t unconditional_io_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_BIT         24
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_FLAG        0x1000000
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_MASK        0x01
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING(_)          (((_) >> 24) & 0x01)

        /**
         * @brief Use IO bitmaps
         *
         * [Bit 25] This control determines whether I/O bitmaps are used to restrict executions of I/O instructions For this
         * control, "0" means "do not use I/O bitmaps" and "1" means "use I/O bitmaps." If the I/O bitmaps are used, the setting of
         * the "unconditional I/O exiting" control is ignored.
         *
         * @see Vol3C[24.6.4(I/O-Bitmap Addresses)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        UINT64_t use_io_bitmaps : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_BIT                   25
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_FLAG                  0x2000000
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS(_)                    (((_) >> 25) & 0x01)
        UINT64_t reserved6 : 1;

        /**
         * @brief Monitor trap flag
         *
         * [Bit 27] If this control is 1, the monitor trap flag debugging feature is enabled.
         *
         * @see Vol3C[25.5.2(Monitor Trap Flag)]
         */
        UINT64_t monitor_trap_flag : 1;
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_BIT                27
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_FLAG               0x8000000
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_MASK               0x01
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG(_)                 (((_) >> 27) & 0x01)

        /**
         * @brief Use MSR bitmaps
         *
         * [Bit 28] This control determines whether MSR bitmaps are used to control execution of the RDMSR and WRMSR instructions.
         * For this control, "0" means "do not use MSR bitmaps" and "1" means "use MSR bitmaps." If the MSR bitmaps are not used,
         * all executions of the RDMSR and WRMSR instructions cause VM exits.
         *
         * @see Vol3C[24.6.9(MSR-Bitmap Address)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        UINT64_t use_msr_bitmaps : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_BIT                  28
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_FLAG                 0x10000000
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS(_)                   (((_) >> 28) & 0x01)

        /**
         * @brief VM-exit when executing the MONITOR instruction
         *
         * [Bit 29] This control determines whether executions of MONITOR cause VM exits.
         */
        UINT64_t monitor_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_BIT                  29
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_FLAG                 0x20000000
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING(_)                   (((_) >> 29) & 0x01)

        /**
         * @brief VM-exit when executing the PAUSE instruction
         *
         * [Bit 30] This control determines whether executions of PAUSE cause VM exits.
         */
        UINT64_t pause_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_BIT                    30
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_FLAG                   0x40000000
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING(_)                     (((_) >> 30) & 0x01)

        /**
         * @brief Determines whether the secondary processor based VM-execution controls are used
         *
         * [Bit 31] This control determines whether the secondary processor-based VM-execution controls are used. If this control
         * is 0, the logical processor operates as if all the secondary processor-based VM-execution controls were also 0.
         */
        UINT64_t activate_secondary_controls : 1;
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_BIT      31
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_FLAG     0x80000000
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_MASK     0x01
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS(_)       (((_) >> 31) & 0x01)
        UINT64_t reserved7 : 32;
    };

    UINT64_t flags;
} ia32_vmx_procbased_ctls_register;


/**
 * Capability Reporting Register of VM-Exit Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.4(VM-EXIT CONTROLS)]
 * @see Vol3C[24.7.1(VM-Exit Controls)] (reference)
 */
#define IA32_VMX_EXIT_CTLS                                           0x00000483
typedef union
{
    struct
    {
        UINT64_t reserved1 : 2;

        /**
         * @brief Save guest debug controls (dr7 & IA32_DEBUGCTL_MSR) (forced to 1 on the 'first' VT-x capable CPUs; this actually
         *        includes the newest Nehalem CPUs)
         *
         * [Bit 2] This control determines whether DR7 and the IA32_DEBUGCTL MSR are saved on VM exit. The first processors to
         * support the virtual-machine extensions supported only the 1-setting of this control.
         */
        UINT64_t save_debug_controls : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_BIT                   2
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_FLAG                  0x04
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_MASK                  0x01
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS(_)                    (((_) >> 2) & 0x01)
        UINT64_t reserved2 : 6;

        /**
         * @brief Return to long mode after a VM-exit
         *
         * [Bit 9] On processors that support Intel 64 architecture, this control determines whether a logical processor is in
         * 64-bit mode after the next VM exit. Its value is loaded into CS.L, IA32_EFER.LME, and IA32_EFER.LMA on every VM exit.1
         * This control must be 0 on processors that do not support Intel 64 architecture.
         */
        UINT64_t host_address_space_size : 1;
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_BIT               9
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_FLAG              0x200
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_MASK              0x01
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE(_)                (((_) >> 9) & 0x01)
        UINT64_t reserved3 : 2;

        /**
         * @brief Whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM-exit
         *
         * [Bit 12] This control determines whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM exit.
         */
        UINT64_t load_ia32_perf_global_ctrl : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_BIT            12
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_FLAG           0x1000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_MASK           0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL(_)             (((_) >> 12) & 0x01)
        UINT64_t reserved4 : 2;

        /**
         * @brief Acknowledge external interrupts with the irq controller if one caused a VM-exit
         *
         * [Bit 15] This control affects VM exits due to external interrupts:
         * - If such a VM exit occurs and this control is 1, the logical processor acknowledges the interrupt controller, acquiring
         * the interrupt's vector. The vector is stored in the VM-exit interruption-information field, which is marked valid.
         * - If such a VM exit occurs and this control is 0, the interrupt is not acknowledged and the VM-exit
         * interruption-information field is marked invalid.
         */
        UINT64_t acknowledge_interrupt_on_exit : 1;
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_BIT         15
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_FLAG        0x8000
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_MASK        0x01
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT(_)          (((_) >> 15) & 0x01)
        UINT64_t reserved5 : 2;

        /**
         * @brief Whether the guest IA32_PAT MSR is saved on VM-exit
         *
         * [Bit 18] This control determines whether the IA32_PAT MSR is saved on VM exit.
         */
        UINT64_t save_ia32_pat : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_BIT                         18
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_FLAG                        0x40000
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_MASK                        0x01
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT(_)                          (((_) >> 18) & 0x01)

        /**
         * @brief Whether the host IA32_PAT MSR is loaded on VM-exit
         *
         * [Bit 19] This control determines whether the IA32_PAT MSR is loaded on VM exit.
         */
        UINT64_t load_ia32_pat : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_BIT                         19
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_FLAG                        0x80000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_MASK                        0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT(_)                          (((_) >> 19) & 0x01)

        /**
         * @brief Whether the guest IA32_EFER MSR is saved on VM-exit
         *
         * [Bit 20] This control determines whether the IA32_EFER MSR is saved on VM exit.
         */
        UINT64_t save_ia32_efer : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_BIT                        20
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_FLAG                       0x100000
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_MASK                       0x01
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER(_)                         (((_) >> 20) & 0x01)

        /**
         * @brief Whether the host IA32_EFER MSR is loaded on VM-exit
         *
         * [Bit 21] This control determines whether the IA32_EFER MSR is loaded on VM exit.
         */
        UINT64_t load_ia32_efer : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_BIT                        21
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_FLAG                       0x200000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_MASK                       0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER(_)                         (((_) >> 21) & 0x01)

        /**
         * @brief Whether the value of the VMX preemption timer is saved on every VM-exit
         *
         * [Bit 22] This control determines whether the value of the VMX-preemption timer is saved on VM exit.
         */
        UINT64_t save_vmx_preemption_timer_value : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_BIT       22
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_FLAG      0x400000
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_MASK      0x01
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE(_)        (((_) >> 22) & 0x01)

        /**
         * [Bit 23] This control determines whether the IA32_BNDCFGS MSR is cleared on VM exit.
         */
        UINT64_t clear_ia32_bndcfgs : 1;
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_BIT                    23
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_FLAG                   0x800000
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_MASK                   0x01
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS(_)                     (((_) >> 23) & 0x01)

        /**
         * [Bit 24] If this control is 1, Intel Processor Trace does not produce a paging information packet (PIP) on a VM exit or
         * a VMCS packet on an SMM VM exit.
         *
         * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
         */
        UINT64_t conceal_vmx_from_pt : 1;
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_BIT                   24
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_FLAG                  0x1000000
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_MASK                  0x01
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT(_)                    (((_) >> 24) & 0x01)
        UINT64_t reserved6 : 39;
    };

    UINT64_t flags;
} ia32_vmx_exit_ctls_register;


/**
 * Capability Reporting Register of VM-Entry Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.5(VM-ENTRY CONTROLS)]
 * @see Vol3D[24.8.1(VM-Entry Controls)] (reference)
 */
#define IA32_VMX_ENTRY_CTLS                                          0x00000484
typedef union
{
    struct
    {
        UINT64_t reserved1 : 2;

        /**
         * @brief Load guest debug controls (dr7 & IA32_DEBUGCTL_MSR) (forced to 1 on the 'first' VT-x capable CPUs; this actually
         *        includes the newest Nehalem CPUs)
         *
         * [Bit 2] This control determines whether DR7 and the IA32_DEBUGCTL MSR are loaded on VM entry. The first processors to
         * support the virtual-machine extensions supported only the 1-setting of this control.
         */
        UINT64_t load_debug_controls : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_BIT                  2
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_FLAG                 0x04
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_MASK                 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS(_)                   (((_) >> 2) & 0x01)
        UINT64_t reserved2 : 6;

        /**
         * @brief 64 bits guest mode. Must be 0 for CPUs that don't support AMD64
         *
         * [Bit 9] On processors that support Intel 64 architecture, this control determines whether the logical processor is in
         * IA-32e mode after VM entry. Its value is loaded into IA32_EFER.LMA as part of VM entry. This control must be 0 on
         * processors that do not support Intel 64 architecture.
         */
        UINT64_t ia32e_mode_guest : 1;
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_BIT                     9
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_FLAG                    0x200
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_MASK                    0x01
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST(_)                      (((_) >> 9) & 0x01)

        /**
         * @brief In SMM mode after VM-entry
         *
         * [Bit 10] This control determines whether the logical processor is in system-management mode (SMM) after VM entry. This
         * control must be 0 for any VM entry from outside SMM.
         */
        UINT64_t entry_to_smm : 1;
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_BIT                         10
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_FLAG                        0x400
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_MASK                        0x01
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM(_)                          (((_) >> 10) & 0x01)

        /**
         * @brief Disable dual treatment of SMI and SMM; must be zero for VM-entry outside of SMM
         *
         * [Bit 11] If set to 1, the default treatment of SMIs and SMM is in effect after the VM entry. This control must be 0 for
         * any VM entry from outside SMM
         *
         * @see Vol3C[34.15.7(Deactivating the Dual-Monitor Treatment)]
         */
        UINT64_t deactivate_dual_monitor_treatment : 1;
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_BIT    11
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_FLAG   0x800
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_MASK   0x01
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT(_)     (((_) >> 11) & 0x01)
        UINT64_t reserved3 : 1;

        /**
         * @brief Whether the guest IA32_PERF_GLOBAL_CTRL MSR is loaded on VM-entry
         *
         * [Bit 13] This control determines whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM entry.
         */
        UINT64_t load_ia32_perf_global_ctrl : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_BIT           13
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_FLAG          0x2000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_MASK          0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL(_)            (((_) >> 13) & 0x01)

        /**
         * @brief Whether the guest IA32_PAT MSR is loaded on VM-entry
         *
         * [Bit 14] This control determines whether the IA32_PAT MSR is loaded on VM entry.
         */
        UINT64_t load_ia32_pat : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_BIT                        14
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_FLAG                       0x4000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_MASK                       0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT(_)                         (((_) >> 14) & 0x01)

        /**
         * @brief Whether the guest IA32_EFER MSR is loaded on VM-entry
         *
         * [Bit 15] This control determines whether the IA32_EFER MSR is loaded on VM entry.
         */
        UINT64_t load_ia32_efer : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_BIT                       15
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_FLAG                      0x8000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_MASK                      0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER(_)                        (((_) >> 15) & 0x01)

        /**
         * [Bit 16] This control determines whether the IA32_BNDCFGS MSR is loaded on VM entry.
         */
        UINT64_t load_ia32_bndcfgs : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_BIT                    16
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_FLAG                   0x10000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_MASK                   0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS(_)                     (((_) >> 16) & 0x01)

        /**
         * [Bit 17] If this control is 1, Intel Processor Trace does not produce a paging information packet (PIP) on a VM entry or
         * a VMCS packet on a VM entry that returns from SMM.
         *
         * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
         */
        UINT64_t conceal_vmx_from_pt : 1;
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_BIT                  17
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_FLAG                 0x20000
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_MASK                 0x01
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT(_)                   (((_) >> 17) & 0x01)

        /**
         * [Bit 18] This control determines whether the IA32_RTIT_CTL MSR is loaded on VM entry.
         */
        UINT64_t load_ia32_rtit_ctl : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_BIT                   18
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_FLAG                  0x40000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_MASK                  0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL(_)                    (((_) >> 18) & 0x01)
        UINT64_t reserved4 : 1;

        /**
         * [Bit 20] This control determines whether CET-related MSRs and SPP are loaded on VM entry.
         */
        UINT64_t load_cet_state : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_BIT                       20
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_FLAG                      0x100000
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_MASK                      0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE(_)                        (((_) >> 20) & 0x01)
        UINT64_t reserved5 : 43;
    };

    UINT64_t flags;
} ia32_vmx_entry_ctls_register;


/**
 * Reporting Register of Miscellaneous VMX Capabilities.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.6(MISCELLANEOUS DATA)]
 * @see Vol3D[A.6(Miscellaneous Data)] (reference)
 */
#define IA32_VMX_MISC                                                0x00000485
typedef union
{
    struct
    {
        /**
         * @brief Relationship between the preemption timer and tsc; count down every time bit x of the tsc changes
         *
         * [Bits 4:0] Report a value X that specifies the relationship between the rate of the VMX-preemption timer and that of the
         * timestamp counter (TSC). Specifically, the VMX-preemption timer (if it is active) counts down by 1 every time bit X in
         * the TSC changes due to a TSC increment.
         */
        UINT64_t preemption_timer_tsc_relationship : 5;
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_BIT          0
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_FLAG         0x1F
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_MASK         0x1F
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP(_)           (((_) >> 0) & 0x1F)

        /**
         * @brief Whether VM-exit stores EFER.LMA into the "IA32e mode guest" field
         *
         * [Bit 5] When set to 1, VM exits store the value of IA32_EFER.LMA into the "IA-32e mode guest" VM-entry control. This bit
         * is read as 1 on any logical processor that supports the 1-setting of the "unrestricted guest" VM-execution control.
         *
         * @see Vol3C[27.2(RECORDING VM-EXIT INFORMATION AND UPDATING VM-ENTRY CONTROL FIELDS)]
         */
        UINT64_t store_efer_lma_on_vmexit : 1;
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_BIT                   5
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_FLAG                  0x20
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_MASK                  0x01
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT(_)                    (((_) >> 5) & 0x01)

        /**
         * @brief Activity states supported by the implementation
         *
         * [Bits 8:6] Report, as a bitmap, the activity states supported by the implementation:
         * - Bit 6 reports (if set) the support for activity state 1 (HLT).
         * - Bit 7 reports (if set) the support for activity state 2 (shutdown).
         * - Bit 8 reports (if set) the support for activity state 3 (wait-for-SIPI).
         * If an activity state is not supported, the implementation causes a VM entry to fail if it attempts to establish that
         * activity state. All implementations support VM entry to activity state 0 (active).
         */
        UINT64_t activity_states : 3;
#define IA32_VMX_MISC_ACTIVITY_STATES_BIT                            6
#define IA32_VMX_MISC_ACTIVITY_STATES_FLAG                           0x1C0
#define IA32_VMX_MISC_ACTIVITY_STATES_MASK                           0x07
#define IA32_VMX_MISC_ACTIVITY_STATES(_)                             (((_) >> 6) & 0x07)
        UINT64_t reserved1 : 5;

        /**
         * @brief Intel Processor Trace (Intel PT) can be used in VMX operation
         *
         * [Bit 14] When set to 1, Intel(R) Processor Trace (Intel PT) can be used in VMX operation. If the processor supports Intel
         * PT but does not allow it to be used in VMX operation, execution of VMXON clears IA32_RTIT_CTL.TraceEn; any attempt to
         * write IA32_RTIT_CTL while in VMX operation (including VMX root operation) causes a general-protection exception.
         *
         * @see Vol3C[30.3(VMX INSTRUCTIONS | VMXON-Enter VMX Operation)]
         */
        UINT64_t intel_pt_available_in_vmx : 1;
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_BIT                  14
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_FLAG                 0x4000
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_MASK                 0x01
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX(_)                   (((_) >> 14) & 0x01)

        /**
         * @brief Whether RDMSR can be used to read IA32_SMBASE_MSR in SMM
         *
         * [Bit 15] When set to 1, the RDMSR instruction can be used in system-management mode (SMM) to read the IA32_SMBASE MSR
         * (MSR address 9EH).
         *
         * @see Vol3C[34.15.6.3(Saving Guest State)]
         */
        UINT64_t rdmsr_can_read_ia32_smbase_msr_in_smm : 1;
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_BIT      15
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_FLAG     0x8000
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_MASK     0x01
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM(_)       (((_) >> 15) & 0x01)

        /**
         * @brief Number of CR3 target values supported by the processor (0-256)
         *
         * [Bits 24:16] Indicate the number of CR3-target values supported by the processor. This number is a value between 0 and
         * 256, inclusive (bit 24 is set if and only if bits 23:16 are clear).
         */
        UINT64_t cr3_target_count : 9;
#define IA32_VMX_MISC_CR3_TARGET_COUNT_BIT                           16
#define IA32_VMX_MISC_CR3_TARGET_COUNT_FLAG                          0x1FF0000
#define IA32_VMX_MISC_CR3_TARGET_COUNT_MASK                          0x1FF
#define IA32_VMX_MISC_CR3_TARGET_COUNT(_)                            (((_) >> 16) & 0x1FF)

        /**
         * @brief Maximum number of MSRs in the VMCS. (N+1)*512
         *
         * [Bits 27:25] Used to compute the recommended maximum number of MSRs that should appear in the VM-exit MSR-store list,
         * the VM-exit MSR-load list, or the VM-entry MSR-load list. Specifically, if the value bits 27:25 of IA32_VMX_MISC is N,
         * then 512 * (N + 1) is the recommended maximum number of MSRs to be included in each list. If the limit is exceeded,
         * undefined processor behavior may result (including a machine check during the VMX transition).
         */
        UINT64_t max_number_of_msr : 3;
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_BIT                          25
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_FLAG                         0xE000000
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_MASK                         0x07
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR(_)                           (((_) >> 25) & 0x07)

        /**
         * @brief Whether bit 2 of IA32_SMM_MONITOR_CTL can be set to 1
         *
         * [Bit 28] When set to 1, bit 2 of the IA32_SMM_MONITOR_CTL can be set to 1. VMXOFF unblocks SMIs unless
         * IA32_SMM_MONITOR_CTL[bit 2] is 1.
         *
         * @see Vol3C[34.14.4(VMXOFF and SMI Unblocking)]
         */
        UINT64_t smm_monitor_ctl_b2 : 1;
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_BIT                         28
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_FLAG                        0x10000000
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_MASK                        0x01
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2(_)                          (((_) >> 28) & 0x01)

        /**
         * @brief Whether VMWRITE can be used to write VM-exit information fields
         *
         * [Bit 29] When set to 1, software can use VMWRITE to write to any supported field in the VMCS; otherwise, VMWRITE cannot
         * be used to modify VM-exit information fields.
         */
        UINT64_t vmwrite_vmexit_info : 1;
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_BIT                        29
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_FLAG                       0x20000000
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_MASK                       0x01
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO(_)                         (((_) >> 29) & 0x01)

        /**
         * [Bit 30] When set to 1, VM entry allows injection of a software interrupt, software exception, or privileged software
         * exception with an instruction length of 0.
         */
        UINT64_t zero_length_instruction_vmentry_injection : 1;
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_BIT  30
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_FLAG 0x40000000
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_MASK 0x01
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION(_)   (((_) >> 30) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * @brief MSEG revision identifier used by the processor
         *
         * [Bits 63:32] Report the 32-bit MSEG revision identifier used by the processor.
         */
        UINT64_t mseg_id : 32;
#define IA32_VMX_MISC_MSEG_ID_BIT                                    32
#define IA32_VMX_MISC_MSEG_ID_FLAG                                   0xFFFFFFFF00000000
#define IA32_VMX_MISC_MSEG_ID_MASK                                   0xFFFFFFFF
#define IA32_VMX_MISC_MSEG_ID(_)                                     (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64_t flags;
} ia32_vmx_misc_register;


/**
 * Capability Reporting Register of CR0 Bits Fixed to 0.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.7(VMX-FIXED BITS IN CR0)]
 * @see Vol3D[A.7(VMX-Fixed Bits in CR0)] (reference)
 */
#define IA32_VMX_CR0_FIXED0                                          0x00000486

 /**
  * Capability Reporting Register of CR0 Bits Fixed to 1.
  *
  * @remarks If CPUID.01H:ECX.[5] = 1
  * @see Vol3D[A.7(VMX-FIXED BITS IN CR0)]
  * @see Vol3D[A.7(VMX-Fixed Bits in CR0)] (reference)
  */
#define IA32_VMX_CR0_FIXED1                                          0x00000487

  /**
   * Capability Reporting Register of CR4 Bits Fixed to 0.
   *
   * @remarks If CPUID.01H:ECX.[5] = 1
   * @see Vol3D[A.8(VMX-FIXED BITS IN CR4)]
   * @see Vol3D[A.8(VMX-Fixed Bits in CR4)] (reference)
   */
#define IA32_VMX_CR4_FIXED0                                          0x00000488

   /**
    * Capability Reporting Register of CR4 Bits Fixed to 1.
    *
    * @remarks If CPUID.01H:ECX.[5] = 1
    * @see Vol3D[A.8(VMX-FIXED BITS IN CR4)]
    * @see Vol3D[A.8(VMX-Fixed Bits in CR4)] (reference)
    */
#define IA32_VMX_CR4_FIXED1                                          0x00000489

    /**
     * Capability Reporting Register of VMCS Field Enumeration.
     *
     * @remarks If CPUID.01H:ECX.[5] = 1
     * @see Vol3D[A.9(VMCS ENUMERATION)]
     * @see Vol3D[A.9(VMCS Enumeration)] (reference)
     */
#define IA32_VMX_VMCS_ENUM                                           0x0000048A
typedef union
{
    struct
    {
        /**
         * [Bit 0] Indicates access type.
         */
        UINT64_t access_type : 1;
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE_BIT                           0
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE_FLAG                          0x01
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE_MASK                          0x01
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE(_)                            (((_) >> 0) & 0x01)

        /**
         * [Bits 9:1] Highest index value used for any VMCS encoding.
         */
        UINT64_t highest_index_value : 9;
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_BIT                   1
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_FLAG                  0x3FE
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_MASK                  0x1FF
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE(_)                    (((_) >> 1) & 0x1FF)

        /**
         * [Bits 11:10] Indicate the field's type.
         */
        UINT64_t field_type : 2;
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_BIT                            10
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_FLAG                           0xC00
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_MASK                           0x03
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE(_)                             (((_) >> 10) & 0x03)
        UINT64_t reserved1 : 1;

        /**
         * [Bits 14:13] Indicate the field's width.
         */
        UINT64_t field_width : 2;
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_BIT                           13
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_FLAG                          0x6000
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_MASK                          0x03
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH(_)                            (((_) >> 13) & 0x03)
        UINT64_t reserved2 : 49;
    };

    UINT64_t flags;
} ia32_vmx_vmcs_enum_register;


/**
 * Capability Reporting Register of Secondary Processor-Based VM-Execution Controls.
 *
 * @remarks If ( CPUID.01H:ECX.[5] && IA32_VMX_PROCBASED_CTLS[63] )
 * @see Vol3D[A.3.3(Secondary Processor-Based VM-Execution Controls)]
 * @see Vol3D[24.6.2(Processor-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PROCBASED_CTLS2                                     0x0000048B
typedef union
{
    struct
    {
        /**
         * @brief Virtualize APIC access
         *
         * [Bit 0] If this control is 1, the logical processor treats specially accesses to the page with the APICaccess address.
         *
         * @see Vol3C[29.4(VIRTUALIZING MEMORY-MAPPED APIC ACCESSES)]
         */
        UINT64_t virtualize_apic_accesses : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_BIT        0
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_FLAG       0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_MASK       0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES(_)         (((_) >> 0) & 0x01)

        /**
         * @brief EPT supported/enabled
         *
         * [Bit 1] If this control is 1, extended page tables (EPT) are enabled.
         *
         * @see Vol3C[28.2(THE EXTENDED PAGE TABLE MECHANISM (EPT))]
         */
        UINT64_t enable_ept : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_BIT                      1
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_FLAG                     0x02
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_MASK                     0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT(_)                       (((_) >> 1) & 0x01)

        /**
         * @brief Descriptor table instructions cause VM-exits
         *
         * [Bit 2] This control determines whether executions of LGDT, LIDT, LLDT, LTR, SGDT, SIDT, SLDT, and STR cause VM exits.
         */
        UINT64_t descriptor_table_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_BIT        2
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_FLAG       0x04
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_MASK       0x01
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING(_)         (((_) >> 2) & 0x01)

        /**
         * @brief RDTSCP supported/enabled
         *
         * [Bit 3] If this control is 0, any execution of RDTSCP causes an invalid-opcode exception (\#UD).
         */
        UINT64_t enable_rdtscp : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_BIT                   3
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_FLAG                  0x08
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP(_)                    (((_) >> 3) & 0x01)

        /**
         * @brief Virtualize x2APIC mode
         *
         * [Bit 4] If this control is 1, the logical processor treats specially RDMSR and WRMSR to APIC MSRs (in the range
         * 800H-8FFH).
         *
         * @see Vol3C[29.5(VIRTUALIZING MSR-BASED APIC ACCESSES)]
         */
        UINT64_t virtualize_x2apic_mode : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_BIT          4
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_FLAG         0x10
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_MASK         0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE(_)           (((_) >> 4) & 0x01)

        /**
         * @brief VPID supported/enabled
         *
         * [Bit 5] If this control is 1, cached translations of linear addresses are associated with a virtualprocessor identifier
         * (VPID).
         *
         * @see Vol3C[28.1(VIRTUAL PROCESSOR IDENTIFIERS (VPIDS))]
         */
        UINT64_t enable_vpid : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_BIT                     5
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_FLAG                    0x20
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_MASK                    0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID(_)                      (((_) >> 5) & 0x01)

        /**
         * @brief VM-exit when executing the WBINVD instruction
         *
         * [Bit 6] This control determines whether executions of WBINVD cause VM exits.
         */
        UINT64_t wbinvd_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_BIT                  6
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_FLAG                 0x40
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING(_)                   (((_) >> 6) & 0x01)

        /**
         * @brief Unrestricted guest execution
         *
         * [Bit 7] This control determines whether guest software may run in unpaged protected mode or in realaddress mode.
         */
        UINT64_t unrestricted_guest : 1;
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_BIT              7
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_FLAG             0x80
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_MASK             0x01
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST(_)               (((_) >> 7) & 0x01)

        /**
         * @brief APIC register virtualization
         *
         * [Bit 8] If this control is 1, the logical processor virtualizes certain APIC accesses.
         *
         * @see Vol3C[29.4(VIRTUALIZING MEMORY-MAPPED APIC ACCESSES)]
         * @see Vol3C[29.5(VIRTUALIZING MSR-BASED APIC ACCESSES)]
         */
        UINT64_t apic_register_virtualization : 1;
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_BIT    8
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_FLAG   0x100
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_MASK   0x01
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION(_)     (((_) >> 8) & 0x01)

        /**
         * @brief Virtual-interrupt delivery
         *
         * [Bit 9] This controls enables the evaluation and delivery of pending virtual interrupts as well as the emulation of
         * writes to the APIC registers that control interrupt prioritization.
         */
        UINT64_t virtual_interrupt_delivery : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_BIT      9
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_FLAG     0x200
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_MASK     0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY(_)       (((_) >> 9) & 0x01)

        /**
         * @brief A specified number of pause loops cause a VM-exit
         *
         * [Bit 10] This control determines whether a series of executions of PAUSE can cause a VM exit.
         *
         * @see Vol3C[24.6.13(Controls for PAUSE-Loop Exiting)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        UINT64_t pause_loop_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_BIT              10
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_FLAG             0x400
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_MASK             0x01
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING(_)               (((_) >> 10) & 0x01)

        /**
         * @brief VM-exit when executing RDRAND instructions
         *
         * [Bit 11] This control determines whether executions of RDRAND cause VM exits.
         */
        UINT64_t rdrand_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_BIT                  11
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_FLAG                 0x800
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING(_)                   (((_) >> 11) & 0x01)

        /**
         * @brief Enables INVPCID instructions
         *
         * [Bit 12] If this control is 0, any execution of INVPCID causes a \#UD.
         */
        UINT64_t enable_invpcid : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_BIT                  12
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_FLAG                 0x1000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID(_)                   (((_) >> 12) & 0x01)

        /**
         * @brief Enables VMFUNC instructions
         *
         * [Bit 13] Setting this control to 1 enables use of the VMFUNC instruction in VMX non-root operation.
         *
         * @see Vol3C[25.5.5(VM Functions)]
         */
        UINT64_t enable_vm_functions : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_BIT             13
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_FLAG            0x2000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_MASK            0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS(_)              (((_) >> 13) & 0x01)

        /**
         * @brief Enables VMCS shadowing
         *
         * [Bit 14] If this control is 1, executions of VMREAD and VMWRITE in VMX non-root operation may access a shadow VMCS
         * (instead of causing VM exits).
         *
         * @see {'Vol3C[24.10(VMCS TYPES': 'ORDINARY AND SHADOW)]'}
         * @see Vol3C[30.3(VMX INSTRUCTIONS)]
         */
        UINT64_t vmcs_shadowing : 1;
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_BIT                  14
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_FLAG                 0x4000
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING(_)                   (((_) >> 14) & 0x01)

        /**
         * @brief Enables ENCLS VM-exits
         *
         * [Bit 15] If this control is 1, executions of ENCLS consult the ENCLS-exiting bitmap to determine whether the instruction
         * causes a VM exit.
         *
         * @see Vol3C[24.6.16(ENCLS-Exiting Bitmap)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        UINT64_t enable_encls_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_BIT            15
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_FLAG           0x8000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_MASK           0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING(_)             (((_) >> 15) & 0x01)

        /**
         * @brief VM-exit when executing RDSEED
         *
         * [Bit 16] This control determines whether executions of RDSEED cause VM exits.
         */
        UINT64_t rdseed_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_BIT                  16
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_FLAG                 0x10000
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING(_)                   (((_) >> 16) & 0x01)

        /**
         * @brief Enables page-modification logging
         *
         * [Bit 17] If this control is 1, an access to a guest-physical address that sets an EPT dirty bit first adds an entry to
         * the page-modification log.
         *
         * @see Vol3C[28.2.5(Page-Modification Logging)]
         */
        UINT64_t enable_pml : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_BIT                      17
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_FLAG                     0x20000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_MASK                     0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML(_)                       (((_) >> 17) & 0x01)

        /**
         * @brief Controls whether EPT-violations may cause
         *
         * [Bit 18] If this control is 1, EPT violations may cause virtualization exceptions (\#VE) instead of VM exits.
         *
         * @see Vol3C[25.5.6(Virtualization Exceptions)]
         */
        UINT64_t ept_violation : 1;
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_BIT                   18
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_FLAG                  0x40000
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION(_)                    (((_) >> 18) & 0x01)

        /**
         * @brief Conceal VMX non-root operation from Intel processor trace (PT)
         *
         * [Bit 19] If this control is 1, Intel Processor Trace suppresses from PIPs an indication that the processor was in VMX
         * non-root operation and omits a VMCS packet from any PSB+ produced in VMX nonroot operation.
         *
         * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
         */
        UINT64_t conceal_vmx_from_pt : 1;
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_BIT             19
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_FLAG            0x80000
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_MASK            0x01
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT(_)              (((_) >> 19) & 0x01)

        /**
         * @brief Enables XSAVES/XRSTORS instructions
         *
         * [Bit 20] If this control is 0, any execution of XSAVES or XRSTORS causes a \#UD.
         */
        UINT64_t enable_xsaves : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_BIT                   20
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_FLAG                  0x100000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES(_)                    (((_) >> 20) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * [Bit 22] If this control is 1, EPT execute permissions are based on whether the linear address being accessed is
         * supervisor mode or user mode.
         *
         * @see Vol3C[28(VMX SUPPORT FOR ADDRESS TRANSLATION)]
         */
        UINT64_t mode_based_execute_control_for_ept : 1;
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_BIT 22
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_FLAG 0x400000
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT(_) (((_) >> 22) & 0x01)
        UINT64_t reserved2 : 2;

        /**
         * @brief Use TSC scaling
         *
         * [Bit 25] This control determines whether executions of RDTSC, executions of RDTSCP, and executions of RDMSR that read
         * from the IA32_TIME_STAMP_COUNTER MSR return a value modified by the TSC multiplier field.
         *
         * @see Vol3C[24.6.5(Time-Stamp Counter Offset and Multiplier)]
         * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
         */
        UINT64_t use_tsc_scaling : 1;
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_BIT                 25
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_FLAG                0x2000000
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_MASK                0x01
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING(_)                  (((_) >> 25) & 0x01)
        UINT64_t reserved3 : 38;
    };

    UINT64_t flags;
} ia32_vmx_procbased_ctls2_register;


/**
 * Capability Reporting Register of EPT and VPID.
 *
 * @remarks If ( CPUID.01H:ECX.[5] && IA32_VMX_PROCBASED_CTLS[63] && (IA32_VMX_PROCBASED_CTLS2[33] ||
 *          IA32_VMX_PROCBASED_CTLS2[37]) )
 * @see Vol3D[A.10(VPID AND EPT CAPABILITIES)]
 * @see Vol3D[A.10(VPID and EPT Capabilities)] (reference)
 */
#define IA32_VMX_EPT_VPID_CAP                                        0x0000048C
typedef union
{
    struct
    {
        /**
         * [Bit 0] When set to 1, the processor supports execute-only translations by EPT. This support allows software to
         * configure EPT paging-structure entries in which bits 1:0 are clear (indicating that data accesses are not allowed) and
         * bit 2 is set (indicating that instruction fetches are allowed).
         */
        UINT64_t execute_only_pages : 1;
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_BIT                 0
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_FLAG                0x01
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_MASK                0x01
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES(_)                  (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 5;

        /**
         * [Bit 6] Indicates support for a page-walk length of 4.
         */
        UINT64_t page_walk_length_4 : 1;
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_BIT                 6
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_FLAG                0x40
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_MASK                0x01
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4(_)                  (((_) >> 6) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * [Bit 8] When set to 1, the logical processor allows software to configure the EPT paging-structure memory type to be
         * uncacheable (UC).
         *
         * @see Vol3C[24.6.11(Extended-Page-Table Pointer (EPTP))]
         */
        UINT64_t memory_type_uncacheable : 1;
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_BIT            8
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_FLAG           0x100
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_MASK           0x01
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE(_)             (((_) >> 8) & 0x01)
        UINT64_t reserved3 : 5;

        /**
         * [Bit 14] When set to 1, the logical processor allows software to configure the EPT paging-structure memory type to be
         * write-back (WB).
         */
        UINT64_t memory_type_write_back : 1;
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_BIT             14
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_FLAG            0x4000
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_MASK            0x01
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK(_)              (((_) >> 14) & 0x01)
        UINT64_t reserved4 : 1;

        /**
         * [Bit 16] When set to 1, the logical processor allows software to configure a EPT PDE to map a 2-Mbyte page (by setting
         * bit 7 in the EPT PDE).
         */
        UINT64_t pde_2mb_pages : 1;
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_BIT                      16
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_FLAG                     0x10000
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_MASK                     0x01
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES(_)                       (((_) >> 16) & 0x01)

        /**
         * [Bit 17] When set to 1, the logical processor allows software to configure a EPT PDPTE to map a 1-Gbyte page (by setting
         * bit 7 in the EPT PDPTE).
         */
        UINT64_t pdpte_1gb_pages : 1;
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_BIT                    17
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_FLAG                   0x20000
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_MASK                   0x01
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES(_)                     (((_) >> 17) & 0x01)
        UINT64_t reserved5 : 2;

        /**
         * [Bit 20] If bit 20 is read as 1, the INVEPT instruction is supported.
         *
         * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
         * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
         */
        UINT64_t invept : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_BIT                             20
#define IA32_VMX_EPT_VPID_CAP_INVEPT_FLAG                            0x100000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_MASK                            0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT(_)                              (((_) >> 20) & 0x01)

        /**
         * [Bit 21] When set to 1, accessed and dirty flags for EPT are supported.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t ept_accessed_and_dirty_flags : 1;
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_BIT       21
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_FLAG      0x200000
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_MASK      0x01
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS(_)        (((_) >> 21) & 0x01)

        /**
         * [Bit 22] When set to 1, the processor reports advanced VM-exit information for EPT violations. This reporting is done
         * only if this bit is read as 1.
         *
         * @see Vol3C[27.2.1(Basic VM-Exit Information)]
         */
        UINT64_t advanced_vmexit_ept_violations_information : 1;
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_BIT 22
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_FLAG 0x400000
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION(_) (((_) >> 22) & 0x01)
        UINT64_t reserved6 : 2;

        /**
         * [Bit 25] When set to 1, the single-context INVEPT type is supported.
         *
         * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
         * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
         */
        UINT64_t invept_single_context : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_BIT              25
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_FLAG             0x2000000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_MASK             0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT(_)               (((_) >> 25) & 0x01)

        /**
         * [Bit 26] When set to 1, the all-context INVEPT type is supported.
         *
         * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
         * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
         */
        UINT64_t invept_all_contexts : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_BIT                26
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_FLAG               0x4000000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_MASK               0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS(_)                 (((_) >> 26) & 0x01)
        UINT64_t reserved7 : 5;

        /**
         * [Bit 32] When set to 1, the INVVPID instruction is supported.
         */
        UINT64_t invvpid : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_BIT                            32
#define IA32_VMX_EPT_VPID_CAP_INVVPID_FLAG                           0x100000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_MASK                           0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID(_)                             (((_) >> 32) & 0x01)
        UINT64_t reserved8 : 7;

        /**
         * [Bit 40] When set to 1, the individual-address INVVPID type is supported.
         */
        UINT64_t invvpid_individual_address : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_BIT         40
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_FLAG        0x10000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_MASK        0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS(_)          (((_) >> 40) & 0x01)

        /**
         * [Bit 41] When set to 1, the single-context INVVPID type is supported.
         */
        UINT64_t invvpid_single_context : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_BIT             41
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_FLAG            0x20000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_MASK            0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT(_)              (((_) >> 41) & 0x01)

        /**
         * [Bit 42] When set to 1, the all-context INVVPID type is supported.
         */
        UINT64_t invvpid_all_contexts : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_BIT               42
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_FLAG              0x40000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_MASK              0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS(_)                (((_) >> 42) & 0x01)

        /**
         * [Bit 43] When set to 1, the single-context-retaining-globals INVVPID type is supported.
         */
        UINT64_t invvpid_single_context_retain_globals : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_BIT 43
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_FLAG 0x80000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS(_) (((_) >> 43) & 0x01)
        UINT64_t reserved9 : 20;
    };

    UINT64_t flags;
} ia32_vmx_ept_vpid_cap_register;

/**
 * @defgroup ia32_vmx_true_ctls \
 *           IA32_VMX_TRUE_(x)_CTLS
 *
 * Capability Reporting Register of Pin-Based VM-Execution Flex Controls, Primary Processor-Based VM-Execution Flex
 * Controls, VM-Exit Flex Controls and VM-Entry Flex Controls.
 *
 * @remarks If ( CPUID.01H:ECX.[5] = 1 && IA32_VMX_BASIC[55] )
 * @see Vol3D[A.3.1(Pin-Based VM-Execution Controls)]
 * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)]
 * @see Vol3D[A.4(VM-EXIT CONTROLS)]
 * @see Vol3D[A.5(VM-ENTRY CONTROLS)]
 * @see Vol3D[A.3.1(Pin-Based VMExecution Controls)] (reference)
 * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)] (reference)
 * @see Vol3D[A.4(VM-Exit Controls)] (reference)
 * @see Vol3D[A.5(VM-Entry Controls)] (reference)
 * @{
 */
#define IA32_VMX_TRUE_PINBASED_CTLS                                  0x0000048D
#define IA32_VMX_TRUE_PROCBASED_CTLS                                 0x0000048E
#define IA32_VMX_TRUE_EXIT_CTLS                                      0x0000048F
#define IA32_VMX_TRUE_ENTRY_CTLS                                     0x00000490
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] Indicate the allowed 0-settings of these controls. VM entry allows control X to be 0 if bit X in the MSR is
         * cleared to 0; if bit X in the MSR is set to 1, VM entry fails if control X is 0.
         */
        UINT64_t allowed_0_settings : 32;
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_BIT                    0
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_FLAG                   0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_MASK                   0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS(_)                     (((_) >> 0) & 0xFFFFFFFF)

        /**
         * [Bits 63:32] Indicate the allowed 1-settings of these controls. VM entry allows control X to be 1 if bit 32+X in the MSR
         * is set to 1; if bit 32+X in the MSR is cleared to 0, VM entry fails if control X is 1.
         */
        UINT64_t allowed_1_settings : 32;
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_BIT                    32
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_FLAG                   0xFFFFFFFF00000000
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_MASK                   0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS(_)                     (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64_t flags;
} ia32_vmx_true_ctls_register;

/**
 * @}
 */


 /**
  * Capability Reporting Register of VMFunction Controls.
  *
  * @remarks If ( CPUID.01H:ECX.[5] = 1 && IA32_VMX_BASIC[55] )
  * @see Vol3D[A.11(VM FUNCTIONS)]
  * @see Vol3D[24.6.14(VM-Function Controls)] (reference)
  */
#define IA32_VMX_VMFUNC                                              0x00000491
typedef union
{
    struct
    {
        /**
         * [Bit 0] The EPTP-switching VM function changes the EPT pointer to a value chosen from the EPTP list.
         *
         * @see Vol3C[25.5.5.3(EPTP Switching)]
         */
        UINT64_t eptp_switching : 1;
#define IA32_VMX_VMFUNC_EPTP_SWITCHING_BIT                           0
#define IA32_VMX_VMFUNC_EPTP_SWITCHING_FLAG                          0x01
#define IA32_VMX_VMFUNC_EPTP_SWITCHING_MASK                          0x01
#define IA32_VMX_VMFUNC_EPTP_SWITCHING(_)                            (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 63;
    };

    UINT64_t flags;
} ia32_vmx_vmfunc_register;

/**
 * @defgroup ia32_a_pmc \
 *           IA32_A_PMC(n)
 *
 * Full Width Writable IA32_PMC(n) Alias.
 *
 * @remarks (If CPUID.0AH: EAX[15:8] > 0) && IA32_PERF_CAPABILITIES[13] = 1
 * @{
 */
#define IA32_A_PMC0                                                  0x000004C1
#define IA32_A_PMC1                                                  0x000004C2
#define IA32_A_PMC2                                                  0x000004C3
#define IA32_A_PMC3                                                  0x000004C4
#define IA32_A_PMC4                                                  0x000004C5
#define IA32_A_PMC5                                                  0x000004C6
#define IA32_A_PMC6                                                  0x000004C7
#define IA32_A_PMC7                                                  0x000004C8
 /**
  * @}
  */


  /**
   * Allows software to signal some MCEs to only a single logical processor in the system.
   *
   * @remarks If IA32_MCG_CAP.LMCE_P = 1
   * @see Vol3B[15.3.1.4(IA32_MCG_EXT_CTL MSR)]
   */
#define IA32_MCG_EXT_CTL                                             0x000004D0
typedef union
{
    struct
    {
        UINT64_t lmce_en : 1;
#define IA32_MCG_EXT_CTL_LMCE_EN_BIT                                 0
#define IA32_MCG_EXT_CTL_LMCE_EN_FLAG                                0x01
#define IA32_MCG_EXT_CTL_LMCE_EN_MASK                                0x01
#define IA32_MCG_EXT_CTL_LMCE_EN(_)                                  (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 63;
    };

    UINT64_t flags;
} ia32_mcg_ext_ctl_register;


/**
 * @brief Status and SVN Threshold of SGX Support for ACM <b>(RO)</b>
 *
 * Intel SGX only allows launching ACMs with an Intel SGX SVN that is at the same level or higher than the expected Intel
 * SGX SVN. The expected Intel SGX SVN is specified by BIOS and locked down by the processor on the first successful
 * execution of an Intel SGX instruction that doesn't return an error code. Intel SGX provides interfaces for system
 * software to discover whether a non faulting Intel SGX instruction has been executed, and evaluate the suitability of the
 * Intel SGX SVN value of any ACM that is expected to be launched by the OS or the VMM.
 *
 * @remarks If CPUID.(EAX=07H, ECX=0H): EBX[2] = 1
 * @see Vol3D[41.11.3(Interactions with Authenticated Code Modules (ACMs))] (reference)
 */
#define IA32_SGX_SVN_STATUS                                          0x00000500
typedef union
{
    struct
    {
        /**
         * [Bit 0] - If 1, indicates that a non-faulting Intel SGX instruction has been executed, consequently, launching a
         * properly signed ACM but with Intel SGX SVN value less than the BIOS specified Intel SGX SVN threshold would lead to an
         * TXT shutdown.
         * - If 0, indicates that the processor will allow a properly signed ACM to launch irrespective of the Intel SGX SVN value
         * of the ACM.
         *
         * @see Vol3D[41.11.3(Interactions with Authenticated Code Modules (ACMs))]
         */
        UINT64_t lock : 1;
#define IA32_SGX_SVN_STATUS_LOCK_BIT                                 0
#define IA32_SGX_SVN_STATUS_LOCK_FLAG                                0x01
#define IA32_SGX_SVN_STATUS_LOCK_MASK                                0x01
#define IA32_SGX_SVN_STATUS_LOCK(_)                                  (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 15;

        /**
         * @brief Reflects the expected threshold of Intel SGX SVN for the SINIT ACM
         *
         * [Bits 23:16] - If CPUID.01H:ECX.SMX = 1, this field reflects the expected threshold of Intel SGX SVN for the SINIT ACM.
         * - If CPUID.01H:ECX.SMX = 0, this field is reserved (0).
         *
         * @see Vol3D[41.11.3(Interactions with Authenticated Code Modules (ACMs))]
         */
        UINT64_t sgx_svn_sinit : 8;
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_BIT                        16
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_FLAG                       0xFF0000
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_MASK                       0xFF
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT(_)                         (((_) >> 16) & 0xFF)
        UINT64_t reserved2 : 40;
    };

    UINT64_t flags;
} ia32_sgx_svn_status_register;


/**
 * Trace Output Base Register.
 *
 * @remarks If ( (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && ( (CPUID.(EAX=14H,ECX=0): ECX[0] = 1) ||
 *          (CPUID.(EAX=14H,ECX=0):ECX[2] = 1) ) )
 * @see Vol3C[35.2.7.7(IA32_RTIT_OUTPUT_BASE MSR)] (reference)
 */
#define IA32_RTIT_OUTPUT_BASE                                        0x00000560
typedef union
{
    struct
    {
        UINT64_t reserved1 : 7;

        /**
         * @brief Base physical address
         *
         * [Bits 47:7] The base physical address. How this address is used depends on the value of IA32_RTIT_CTL.ToPA:
         * - 0: This is the base physical address of a single, contiguous physical output region. This could be mapped to DRAM or
         * to MMIO, depending on the value. The base address should be aligned with the size of the region, such that none of the
         * 1s in the mask value overlap with 1s in the base address. If the base is not aligned, an operational error will result.
         * - 1: The base physical address of the current ToPA table. The address must be 4K aligned. Writing an address in which
         * bits 11:7 are non-zero will not cause a \#GP, but an operational error will be signaled once TraceEn is set.
         *
         * @see Vol3C[35.2.7.8(IA32_RTIT_OUTPUT_MASK_PTRS MSR)]
         * @see Vol3C[35.3.9(Operational Errors)]
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA))]
         */
        UINT64_t base_physical_address : 41;
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_BIT              7
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_FLAG             0xFFFFFFFFFF80
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_MASK             0x1FFFFFFFFFF
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS(_)               (((_) >> 7) & 0x1FFFFFFFFFF)
        UINT64_t reserved2 : 16;
    };

    UINT64_t flags;
} ia32_rtit_output_base_register;


/**
 * Trace Output Mask Pointers Register.
 *
 * @remarks If ( (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && ( (CPUID.(EAX=14H,ECX=0):ECX[0] = 1) ||
 *          (CPUID.(EAX=14H,ECX=0):ECX[2] = 1) ) )
 * @see Vol3C[35.2.7.8(IA32_RTIT_OUTPUT_MASK_PTRS MSR)] (reference)
 */
#define IA32_RTIT_OUTPUT_MASK_PTRS                                   0x00000561
typedef union
{
    struct
    {
        /**
         * [Bits 6:0] Forced to 1, writes are ignored.
         */
        UINT64_t lower_mask : 7;
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_BIT                    0
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_FLAG                   0x7F
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_MASK                   0x7F
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK(_)                     (((_) >> 0) & 0x7F)

        /**
         * @brief MaskOrTableOffset
         *
         * [Bits 31:7] The use of this field depends on the value of IA32_RTIT_CTL.ToPA:
         * - 0: This field holds bits 31:7 of the mask value for the single, contiguous physical output region. The size of this
         * field indicates that regions can be of size 128B up to 4GB. This value (combined with the lower 7 bits, which are
         * reserved to 1) will be ANDed with the OutputOffset field to determine the next write address. All 1s in this field
         * should be consecutive and starting at bit 7, otherwise the region will not be contiguous, and an operational error will
         * be signaled when TraceEn is set.
         * - 1: This field holds bits 27:3 of the offset pointer into the current ToPA table. This value can be added to the
         * IA32_RTIT_OUTPUT_BASE value to produce a pointer to the current ToPA table entry, which itself is a pointer to the
         * current output region. In this scenario, the lower 7 reserved bits are ignored. This field supports tables up to 256
         * MBytes in size.
         *
         * @see Vol3C[35.3.9(Operational Errors)]
         */
        UINT64_t mask_or_table_offset : 25;
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_BIT          7
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_FLAG         0xFFFFFF80
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_MASK         0x1FFFFFF
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET(_)           (((_) >> 7) & 0x1FFFFFF)

        /**
         * @brief Output Offset
         *
         * [Bits 63:32] The use of this field depends on the value of IA32_RTIT_CTL.ToPA:
         * - 0: This is bits 31:0 of the offset pointer into the single, contiguous physical output region. This value will be
         * added to the IA32_RTIT_OUTPUT_BASE value to form the physical address at which the next byte of packet output data will
         * be written. This value must be less than or equal to the MaskOrTableOffset field, otherwise an operational error will be
         * signaled when TraceEn is set.
         * - 1: This field holds bits 31:0 of the offset pointer into the current ToPA output region. This value will be added to
         * the output region base field, found in the current ToPA table entry, to form the physical address at which the next byte
         * of trace output data will be written. This value must be less than the ToPA entry size, otherwise an operational error
         * will be signaled when TraceEn is set.
         *
         * @see Vol3C[35.3.9(Operational Errors)]
         */
        UINT64_t output_offset : 32;
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_BIT                 32
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_FLAG                0xFFFFFFFF00000000
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_MASK                0xFFFFFFFF
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET(_)                  (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64_t flags;
} ia32_rtit_output_mask_ptrs_register;


/**
 * Trace Control Register.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1)
 * @see Vol3C[35.2.7.2(IA32_RTIT_CTL MSR)] (reference)
 */
#define IA32_RTIT_CTL                                                0x00000570
typedef union
{
    struct
    {
        /**
         * @brief TraceEn
         *
         * [Bit 0] If 1, enables tracing; else tracing is disabled.
         * When this bit transitions from 1 to 0, all buffered packets are flushed out of internal buffers. A further store, fence,
         * or architecturally serializing instruction may be required to ensure that packet data can be observed at the trace
         * endpoint.
         * Note that the processor will clear this bit on \#SMI (Section) and warm reset. Other MSR bits of IA32_RTIT_CTL (and
         * other trace configuration MSRs) are not impacted by these events.
         *
         * @see Vol3C[35.2.7.3(Enabling and Disabling Packet Generation with TraceEn)]
         */
        UINT64_t trace_enabled : 1;
#define IA32_RTIT_CTL_TRACE_ENABLED_BIT                              0
#define IA32_RTIT_CTL_TRACE_ENABLED_FLAG                             0x01
#define IA32_RTIT_CTL_TRACE_ENABLED_MASK                             0x01
#define IA32_RTIT_CTL_TRACE_ENABLED(_)                               (((_) >> 0) & 0x01)

        /**
         * @brief CYCEn
         *
         * [Bit 1] - 0: Disables CYC Packet.
         * - 1: Enables CYC Packet.
         *
         * @remarks If CPUID.(EAX=14H, ECX=0):EBX.CPSB_CAM[bit 1] = 0
         * @see Vol3C[35.4.2.14(Cycle Count (CYC) Packet)]
         */
        UINT64_t cyc_enabled : 1;
#define IA32_RTIT_CTL_CYC_ENABLED_BIT                                1
#define IA32_RTIT_CTL_CYC_ENABLED_FLAG                               0x02
#define IA32_RTIT_CTL_CYC_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_CYC_ENABLED(_)                                 (((_) >> 1) & 0x01)

        /**
         * @brief OS
         *
         * [Bit 2] - 0: Packet generation is disabled when CPL = 0.
         * - 1: Packet generation may be enabled when CPL = 0.
         */
        UINT64_t os : 1;
#define IA32_RTIT_CTL_OS_BIT                                         2
#define IA32_RTIT_CTL_OS_FLAG                                        0x04
#define IA32_RTIT_CTL_OS_MASK                                        0x01
#define IA32_RTIT_CTL_OS(_)                                          (((_) >> 2) & 0x01)

        /**
         * @brief User
         *
         * [Bit 3] - 0: Packet generation is disabled when CPL > 0.
         * - 1: Packet generation may be enabled when CPL > 0.
         */
        UINT64_t user : 1;
#define IA32_RTIT_CTL_USER_BIT                                       3
#define IA32_RTIT_CTL_USER_FLAG                                      0x08
#define IA32_RTIT_CTL_USER_MASK                                      0x01
#define IA32_RTIT_CTL_USER(_)                                        (((_) >> 3) & 0x01)

        /**
         * @brief PwrEvtEn
         *
         * [Bit 4] - 0: Power Event Trace packets are disabled.
         * - 1: Power Event Trace packets are enabled.
         *
         * @see Vol3C[35.2.3(Power Event Tracing)]
         */
        UINT64_t power_event_trace_enabled : 1;
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_BIT                  4
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_FLAG                 0x10
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_MASK                 0x01
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED(_)                   (((_) >> 4) & 0x01)

        /**
         * @brief FUPonPTW
         *
         * [Bit 5] - 0: PTW packets are not followed by FUPs.
         * - 1: PTW packets are followed by FUPs.
         */
        UINT64_t fup_on_ptw : 1;
#define IA32_RTIT_CTL_FUP_ON_PTW_BIT                                 5
#define IA32_RTIT_CTL_FUP_ON_PTW_FLAG                                0x20
#define IA32_RTIT_CTL_FUP_ON_PTW_MASK                                0x01
#define IA32_RTIT_CTL_FUP_ON_PTW(_)                                  (((_) >> 5) & 0x01)

        /**
         * @brief FabricEn
         *
         * [Bit 6] - 0: Trace output is directed to the memory subsystem, mechanism depends on IA32_RTIT_CTL.ToPA.
         * - 1: Trace output is directed to the trace transport subsystem, IA32_RTIT_CTL.ToPA is ignored.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):ECX[3] = 1) Reserved if CPUID.(EAX=14H, ECX=0):ECX[bit 3] = 0
         */
        UINT64_t fabric_enabled : 1;
#define IA32_RTIT_CTL_FABRIC_ENABLED_BIT                             6
#define IA32_RTIT_CTL_FABRIC_ENABLED_FLAG                            0x40
#define IA32_RTIT_CTL_FABRIC_ENABLED_MASK                            0x01
#define IA32_RTIT_CTL_FABRIC_ENABLED(_)                              (((_) >> 6) & 0x01)

        /**
         * @brief CR3 filter
         *
         * [Bit 7] - 0: Disables CR3 filtering.
         * - 1: Enables CR3 filtering.
         */
        UINT64_t cr3_filter : 1;
#define IA32_RTIT_CTL_CR3_FILTER_BIT                                 7
#define IA32_RTIT_CTL_CR3_FILTER_FLAG                                0x80
#define IA32_RTIT_CTL_CR3_FILTER_MASK                                0x01
#define IA32_RTIT_CTL_CR3_FILTER(_)                                  (((_) >> 7) & 0x01)

        /**
         * @brief ToPA
         *
         * [Bit 8] - 0: Single-range output scheme enabled.
         * - 1: ToPA output scheme enabled.
         *
         * @remarks 0: If CPUID.(EAX=14H, ECX=0):ECX.SNGLRGNOUT[bit 2] = 1 and IA32_RTIT_CTL.FabricEn=0 1: If CPUID.(EAX=14H,
         *          ECX=0):ECX.TOPA[bit 0] = 1, and IA32_RTIT_CTL.FabricEn=0
         *          WRMSR to IA32_RTIT_CTL that sets TraceEn but clears this bit and FabricEn would cause \#GP: If CPUID.(EAX=14H,
         *          ECX=0):ECX.SNGLRGNOUT[bit 2] = 0 WRMSR to IA32_RTIT_CTL that sets this bit causes \#GP: If CPUID.(EAX=14H,
         *          ECX=0):ECX.TOPA[bit 0] = 0
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA))]
         */
        UINT64_t topa : 1;
#define IA32_RTIT_CTL_TOPA_BIT                                       8
#define IA32_RTIT_CTL_TOPA_FLAG                                      0x100
#define IA32_RTIT_CTL_TOPA_MASK                                      0x01
#define IA32_RTIT_CTL_TOPA(_)                                        (((_) >> 8) & 0x01)

        /**
         * @brief MTCEn
         *
         * [Bit 9] - 0: Disables MTC Packet.
         * - 1: Enables MTC Packet.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[3] = 1) Reserved if CPUID.(EAX=14H, ECX=0):EBX.MTC[bit 3] = 0
         * @see Vol3C[35.4.2.16(Overflow (OVF) Packet)]
         */
        UINT64_t mtc_enabled : 1;
#define IA32_RTIT_CTL_MTC_ENABLED_BIT                                9
#define IA32_RTIT_CTL_MTC_ENABLED_FLAG                               0x200
#define IA32_RTIT_CTL_MTC_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_MTC_ENABLED(_)                                 (((_) >> 9) & 0x01)

        /**
         * @brief TSCEn
         *
         * [Bit 10] - 0: Disable TSC packets.
         * - 1: Enable TSC packets.
         *
         * @see Vol3C[35.4.2.11(Timestamp Counter (TSC) Packet)]
         */
        UINT64_t tsc_enabled : 1;
#define IA32_RTIT_CTL_TSC_ENABLED_BIT                                10
#define IA32_RTIT_CTL_TSC_ENABLED_FLAG                               0x400
#define IA32_RTIT_CTL_TSC_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_TSC_ENABLED(_)                                 (((_) >> 10) & 0x01)

        /**
         * @brief DisRETC
         *
         * [Bit 11] - 0: Enable RET compression.
         * - 1: Disable RET compression.
         *
         * @see Vol3C[35.2.1.2(Indirect Transfer COFI)]
         */
        UINT64_t ret_compression_disabled : 1;
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_BIT                   11
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_FLAG                  0x800
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_MASK                  0x01
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED(_)                    (((_) >> 11) & 0x01)

        /**
         * @brief PTWEn
         *
         * [Bit 12] - 0: PTWRITE packet generation disabled.
         * - 1: PTWRITE packet generation enabled.
         */
        UINT64_t ptw_enabled : 1;
#define IA32_RTIT_CTL_PTW_ENABLED_BIT                                12
#define IA32_RTIT_CTL_PTW_ENABLED_FLAG                               0x1000
#define IA32_RTIT_CTL_PTW_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_PTW_ENABLED(_)                                 (((_) >> 12) & 0x01)

        /**
         * @brief BranchEn
         *
         * [Bit 13] - 0: Disable COFI-based packets.
         * - 1: Enable COFI-based packets: FUP, TIP, TIP.PGE, TIP.PGD, TNT, MODE.Exec, MODE.TSX.
         *
         * @see Vol3C[35.2.5.4(Branch Enable (BranchEn))]
         */
        UINT64_t branch_enabled : 1;
#define IA32_RTIT_CTL_BRANCH_ENABLED_BIT                             13
#define IA32_RTIT_CTL_BRANCH_ENABLED_FLAG                            0x2000
#define IA32_RTIT_CTL_BRANCH_ENABLED_MASK                            0x01
#define IA32_RTIT_CTL_BRANCH_ENABLED(_)                              (((_) >> 13) & 0x01)

        /**
         * @brief MTCFreq
         *
         * [Bits 17:14] Defines MTC packet Frequency, which is based on the core crystal clock, or Always Running Timer (ART). MTC
         * will be sent each time the selected ART bit toggles. The following Encodings are defined:
         * 0: ART(0), 1: ART(1), 2: ART(2), 3: ART(3), 4: ART(4), 5: ART(5), 6: ART(6), 7: ART(7), 8: ART(8), 9: ART(9), 10:
         * ART(10), 11: ART(11), 12: ART(12), 13: ART(13), 14: ART(14), 15: ART(15)
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[3] = 1) Reserved if CPUID.(EAX=14H, ECX=0):EBX.MTC[bit 3] = 0
         * @see Vol3C[35.3.1(Detection of Intel Processor Trace and Capability Enumeration)]
         */
        UINT64_t mtc_frequency : 4;
#define IA32_RTIT_CTL_MTC_FREQUENCY_BIT                              14
#define IA32_RTIT_CTL_MTC_FREQUENCY_FLAG                             0x3C000
#define IA32_RTIT_CTL_MTC_FREQUENCY_MASK                             0x0F
#define IA32_RTIT_CTL_MTC_FREQUENCY(_)                               (((_) >> 14) & 0x0F)
        UINT64_t reserved1 : 1;

        /**
         * @brief CYCThresh
         *
         * [Bits 22:19] CYC packet threshold. CYC packets will be sent with the first eligible packet after N cycles have passed
         * since the last CYC packet. If CycThresh is 0 then N=0, otherwise N is defined as 2(CycThresh-1). The following Encodings
         * are defined:
         * 0: 0, 1: 1, 2: 2, 3: 4, 4: 8, 5: 16, 6: 32, 7: 64, 8: 128, 9: 256, 10: 512, 11: 1024, 12: 2048, 13: 4096, 14: 8192, 15:
         * 16384
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[1] = 1) Reserved if CPUID.(EAX=14H, ECX=0):EBX.CPSB_CAM[bit 1] = 0
         * @see Vol3C[35.3.6(Cycle-Accurate Mode)]
         * @see Vol3C[35.3.1(Detection of Intel Processor Trace and Capability Enumeration)]
         */
        UINT64_t cyc_threshold : 4;
#define IA32_RTIT_CTL_CYC_THRESHOLD_BIT                              19
#define IA32_RTIT_CTL_CYC_THRESHOLD_FLAG                             0x780000
#define IA32_RTIT_CTL_CYC_THRESHOLD_MASK                             0x0F
#define IA32_RTIT_CTL_CYC_THRESHOLD(_)                               (((_) >> 19) & 0x0F)
        UINT64_t reserved2 : 1;

        /**
         * @brief PSBFreq
         *
         * [Bits 27:24] Indicates the frequency of PSB packets. PSB packet frequency is based on the number of Intel PT packet
         * bytes output, so this field allows the user to determine the increment of IA32_IA32_RTIT_STATUS.PacketByteCnt that
         * should cause a PSB to be generated. Note that PSB insertion is not precise, but the average output bytes per PSB should
         * approximate the SW selected period. The following Encodings are defined:
         * 0: 2K, 1: 4K, 2: 8K, 3: 16K, 4: 32K, 5: 64K, 6: 128K, 7: 256K, 8: 512K, 9: 1M, 10: 2M, 11: 4M, 12: 8M, 13: 16M, 14: 32M,
         * 15: 64M
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[1] = 1) Reserved if CPUID.(EAX=14H, ECX=0):EBX.CPSB_CAM[bit 1] = 0
         * @see Vol3C[35.3.1(Detection of Intel Processor Trace and Capability Enumeration)]
         */
        UINT64_t psb_frequency : 4;
#define IA32_RTIT_CTL_PSB_FREQUENCY_BIT                              24
#define IA32_RTIT_CTL_PSB_FREQUENCY_FLAG                             0xF000000
#define IA32_RTIT_CTL_PSB_FREQUENCY_MASK                             0x0F
#define IA32_RTIT_CTL_PSB_FREQUENCY(_)                               (((_) >> 24) & 0x0F)
        UINT64_t reserved3 : 4;

        /**
         * @brief ADDR0_CFG
         *
         * [Bits 35:32] Configures the base/limit register pair IA32_RTIT_ADDR0_A/B based on the following encodings:
         * - 0: ADDR0 range unused.
         * - 1: The [IA32_RTIT_ADDR0_A..IA32_RTIT_ADDR0_B] range defines a FilterEn range. FilterEn will only be set when the IP is
         * within this range, though other FilterEn ranges can additionally be used.
         * - 2: The [IA32_RTIT_ADDR0_A..IA32_RTIT_ADDR0_B] range defines a TraceStop range. TraceStop will be asserted if code
         * branches into this range.
         * - 3..15: Reserved (\#GP).
         *
         * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 0) Reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] >= 0
         * @see Vol3C[35.2.4.3(Filtering by IP)]
         * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
         */
        UINT64_t addr0_cfg : 4;
#define IA32_RTIT_CTL_ADDR0_CFG_BIT                                  32
#define IA32_RTIT_CTL_ADDR0_CFG_FLAG                                 0xF00000000
#define IA32_RTIT_CTL_ADDR0_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR0_CFG(_)                                   (((_) >> 32) & 0x0F)

        /**
         * @brief ADDR1_CFG
         *
         * [Bits 39:36] Configures the base/limit register pair IA32_RTIT_ADDR1_A/B based on the following encodings:
         * - 0: ADDR1 range unused.
         * - 1: The [IA32_RTIT_ADDR1_A..IA32_RTIT_ADDR1_B] range defines a FilterEn range. FilterEn will only be set when the IP is
         * within this range, though other FilterEn ranges can additionally be used.
         * - 2: The [IA32_RTIT_ADDR1_A..IA32_RTIT_ADDR1_B] range defines a TraceStop range. TraceStop will be asserted if code
         * branches into this range.
         * - 3..15: Reserved (\#GP).
         *
         * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 1) Reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] < 2
         * @see Vol3C[35.2.4.3(Filtering by IP)]
         * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
         */
        UINT64_t addr1_cfg : 4;
#define IA32_RTIT_CTL_ADDR1_CFG_BIT                                  36
#define IA32_RTIT_CTL_ADDR1_CFG_FLAG                                 0xF000000000
#define IA32_RTIT_CTL_ADDR1_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR1_CFG(_)                                   (((_) >> 36) & 0x0F)

        /**
         * @brief ADDR2_CFG
         *
         * [Bits 43:40] Configures the base/limit register pair IA32_RTIT_ADDR2_A/B based on the following encodings:
         * - 0: ADDR2 range unused.
         * - 1: The [IA32_RTIT_ADDR2_A..IA32_RTIT_ADDR2_B] range defines a FilterEn range. FilterEn will only be set when the IP is
         * within this range, though other FilterEn ranges can additionally be used.
         * - 2: The [IA32_RTIT_ADDR2_A..IA32_RTIT_ADDR2_B] range defines a TraceStop range. TraceStop will be asserted if code
         * branches into this range.
         * - 3..15: Reserved (\#GP).
         *
         * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 2) Reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] < 3
         * @see Vol3C[35.2.4.3(Filtering by IP)]
         * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
         */
        UINT64_t addr2_cfg : 4;
#define IA32_RTIT_CTL_ADDR2_CFG_BIT                                  40
#define IA32_RTIT_CTL_ADDR2_CFG_FLAG                                 0xF0000000000
#define IA32_RTIT_CTL_ADDR2_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR2_CFG(_)                                   (((_) >> 40) & 0x0F)

        /**
         * @brief ADDR3_CFG
         *
         * [Bits 47:44] Configures the base/limit register pair IA32_RTIT_ADDR3_A/B based on the following encodings:
         * - 0: ADDR3 range unused.
         * - 1: The [IA32_RTIT_ADDR3_A..IA32_RTIT_ADDR3_B] range defines a FilterEn range. FilterEn will only be set when the IP is
         * within this range, though other FilterEn ranges can additionally be used.
         * - 2: The [IA32_RTIT_ADDR3_A..IA32_RTIT_ADDR3_B] range defines a TraceStop range. TraceStop will be asserted if code
         * branches into this range.
         * - 3..15: Reserved (\#GP).
         *
         * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 3) Reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] < 4
         * @see Vol3C[35.2.4.3(Filtering by IP)]
         * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
         */
        UINT64_t addr3_cfg : 4;
#define IA32_RTIT_CTL_ADDR3_CFG_BIT                                  44
#define IA32_RTIT_CTL_ADDR3_CFG_FLAG                                 0xF00000000000
#define IA32_RTIT_CTL_ADDR3_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR3_CFG(_)                                   (((_) >> 44) & 0x0F)
        UINT64_t reserved4 : 8;

        /**
         * @brief InjectPsbPmiOnEnable
         *
         * [Bit 56] - 1: Enables use of IA32_RTIT_STATUS bits PendPSB[6] and PendTopaPMI[7].
         * - 0: IA32_RTIT_STATUS bits 6 and 7 are ignored.
         *
         * @remarks Reserved if CPUID.(EAX=14H, ECX=0):EBX.INJECTPSBPMI[6] = 0
         * @see Vol3C[35.2.7.4(IA32_RTIT_STATUS MSR)]
         */
        UINT64_t inject_psb_pmi_on_enable : 1;
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_BIT                   56
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_FLAG                  0x100000000000000
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_MASK                  0x01
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE(_)                    (((_) >> 56) & 0x01)
        UINT64_t reserved5 : 7;
    };

    UINT64_t flags;
} ia32_rtit_ctl_register;


/**
 * Tracing Status Register.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1)
 */
#define IA32_RTIT_STATUS                                             0x00000571
typedef union
{
    struct
    {
        /**
         * @brief FilterEn (writes ignored)
         *
         * [Bit 0] This bit is written by the processor, and indicates that tracing is allowed for the current IP. Writes are
         * ignored.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[2] = 1)
         * @see Vol3C[35.2.5.5(Filter Enable (FilterEn))]
         */
        UINT64_t filter_enabled : 1;
#define IA32_RTIT_STATUS_FILTER_ENABLED_BIT                          0
#define IA32_RTIT_STATUS_FILTER_ENABLED_FLAG                         0x01
#define IA32_RTIT_STATUS_FILTER_ENABLED_MASK                         0x01
#define IA32_RTIT_STATUS_FILTER_ENABLED(_)                           (((_) >> 0) & 0x01)

        /**
         * @brief ContexEn (writes ignored)
         *
         * [Bit 1] The processor sets this bit to indicate that tracing is allowed for the current context. Writes are ignored.
         *
         * @see Vol3C[35.2.5.3(Context Enable (ContextEn))]
         */
        UINT64_t context_enabled : 1;
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_BIT                         1
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_FLAG                        0x02
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_MASK                        0x01
#define IA32_RTIT_STATUS_CONTEXT_ENABLED(_)                          (((_) >> 1) & 0x01)

        /**
         * @brief TriggerEn (writes ignored)
         *
         * [Bit 2] The processor sets this bit to indicate that tracing is enabled. Writes are ignored.
         *
         * @see Vol3C[35.2.5.2(Trigger Enable (TriggerEn))]
         */
        UINT64_t trigger_enabled : 1;
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_BIT                         2
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_FLAG                        0x04
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_MASK                        0x01
#define IA32_RTIT_STATUS_TRIGGER_ENABLED(_)                          (((_) >> 2) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * @brief Error
         *
         * [Bit 4] The processor sets this bit to indicate that an operational error has been encountered. When this bit is set,
         * TriggerEn is cleared to 0 and packet generation is disabled.
         * When TraceEn is cleared, software can write this bit. Once it is set, only software can clear it. It is not recommended
         * that software ever set this bit, except in cases where it is restoring a prior saved state.
         *
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA) | ToPA Errors)]
         */
        UINT64_t error : 1;
#define IA32_RTIT_STATUS_ERROR_BIT                                   4
#define IA32_RTIT_STATUS_ERROR_FLAG                                  0x10
#define IA32_RTIT_STATUS_ERROR_MASK                                  0x01
#define IA32_RTIT_STATUS_ERROR(_)                                    (((_) >> 4) & 0x01)

        /**
         * @brief Stopped
         *
         * [Bit 5] The processor sets this bit to indicate that a ToPA Stop condition has been encountered. When this bit is set,
         * TriggerEn is cleared to 0 and packet generation is disabled.
         * When TraceEn is cleared, software can write this bit. Once it is set, only software can clear it. It is not recommended
         * that software ever set this bit, except in cases where it is restoring a prior saved state.
         *
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA) | ToPA STOP)]
         */
        UINT64_t stopped : 1;
#define IA32_RTIT_STATUS_STOPPED_BIT                                 5
#define IA32_RTIT_STATUS_STOPPED_FLAG                                0x20
#define IA32_RTIT_STATUS_STOPPED_MASK                                0x01
#define IA32_RTIT_STATUS_STOPPED(_)                                  (((_) >> 5) & 0x01)

        /**
         * @brief Pend PSB
         *
         * [Bit 6] If IA32_RTIT_CTL.InjectPsbPmiOnEnable[56] = 1, the processor sets this bit when the threshold for a PSB+ to be
         * inserted has been reached. The processor will clear this bit when the PSB+ has been inserted into the trace. If PendPSB
         * = 1 and InjectPsbPmiOnEnable = 1 when IA32_RTIT_CTL.TraceEn[0] transitions from 0 to 1, a PSB+ will be inserted into the
         * trace.
         *
         * @remarks If CPUID.(EAX=14H, ECX=0):EBX.INJECTPSBPMI[6] = 1
         */
        UINT64_t pend_psb : 1;
#define IA32_RTIT_STATUS_PEND_PSB_BIT                                6
#define IA32_RTIT_STATUS_PEND_PSB_FLAG                               0x40
#define IA32_RTIT_STATUS_PEND_PSB_MASK                               0x01
#define IA32_RTIT_STATUS_PEND_PSB(_)                                 (((_) >> 6) & 0x01)

        /**
         * @brief Pend ToPA PMI
         *
         * [Bit 7] If IA32_RTIT_CTL.InjectPsbPmiOnEnable[56] = 1, the processor sets this bit when the threshold for a ToPA PMI to
         * be inserted has been reached. Software should clear this bit once the ToPA PMI has been handled. If PendTopaPMI = 1 and
         * InjectPsbPmiOnEnable = 1 when IA32_RTIT_CTL.TraceEn[0] transitions from 0 to 1, a PMI will be pended.
         *
         * @remarks If CPUID.(EAX=14H, ECX=0):EBX.INJECTPSBPMI[6] = 1
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA) | ToPA PMI)]
         */
        UINT64_t pend_topa_pmi : 1;
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_BIT                           7
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_FLAG                          0x80
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_MASK                          0x01
#define IA32_RTIT_STATUS_PEND_TOPA_PMI(_)                            (((_) >> 7) & 0x01)
        UINT64_t reserved2 : 24;

        /**
         * @brief PacketByteCnt
         *
         * [Bits 48:32] This field is written by the processor, and holds a count of packet bytes that have been sent out. The
         * processor also uses this field to determine when the next PSB packet should be inserted. Note that the processor may
         * clear or modify this field at any time while IA32_RTIT_CTL.TraceEn=1. It will have a stable value when
         * IA32_RTIT_CTL.TraceEn=0.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[1] > 3)
         * @see Vol3C[35.4.2.17(Packet Stream Boundary (PSB) Packet)]
         */
        UINT64_t packetUINT8_count : 17;
#define IA32_RTIT_STATUS_PACKETUINT8_COUNT_BIT                       32
#define IA32_RTIT_STATUS_PACKETUINT8_COUNT_FLAG                      0x1FFFF00000000
#define IA32_RTIT_STATUS_PACKETUINT8_COUNT_MASK                      0x1FFFF
#define IA32_RTIT_STATUS_PACKETUINT8_COUNT(_)                        (((_) >> 32) & 0x1FFFF)
        UINT64_t reserved3 : 15;
    };

    UINT64_t flags;
} ia32_rtit_status_register;


/**
 * @brief Trace Filter CR3 Match Register <b>(R/W)</b>
 *
 * The IA32_RTIT_CR3_MATCH register is compared against CR3 when IA32_RTIT_CTL.CR3Filter is 1. Bits 63:5 hold the CR3
 * address value to match, bits 4:0 are reserved to 0.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1)
 * @see Vol3C[35.2.4.2(Filtering by CR3)]
 * @see Vol3C[35.2.7.6(IA32_RTIT_CR3_MATCH MSR)] (reference)
 */
#define IA32_RTIT_CR3_MATCH                                          0x00000572
typedef union
{
    struct
    {
        UINT64_t reserved1 : 5;

        /**
         * [Bits 63:5] CR3[63:5] value to match.
         */
        UINT64_t cr3_value_to_match : 59;
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_BIT                   5
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_FLAG                  0xFFFFFFFFFFFFFFE0
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_MASK                  0x7FFFFFFFFFFFFFF
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH(_)                    (((_) >> 5) & 0x7FFFFFFFFFFFFFF)
    };

    UINT64_t flags;
} ia32_rtit_cr3_match_register;

/**
 * @defgroup ia32_rtit_addr \
 *           IA32_RTIT_ADDR(x)
 *
 * The role of the IA32_RTIT_ADDRn_A/B register pairs, for each n, is determined by the corresponding ADDRn_CFG fields in
 * IA32_RTIT_CTL. The number of these register pairs is enumerated by CPUID.(EAX=14H, ECX=1):EAX.RANGECNT[2:0].
 *
 * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > n)
 * @see Vol3C[35.2.7.2(IA32_RTIT_CTL MSR)]
 * @see Vol3C[35.2.7.5(IA32_RTIT_ADDRn_A and IA32_RTIT_ADDRn_B MSRs)] (reference)
 * @{
 */
 /**
  * @defgroup ia32_rtit_addr_a \
  *           IA32_RTIT_ADDR(n)_A
  *
  * Region n Start Address.
  *
  * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > n)
  * @{
  */
#define IA32_RTIT_ADDR0_A                                            0x00000580
#define IA32_RTIT_ADDR1_A                                            0x00000582
#define IA32_RTIT_ADDR2_A                                            0x00000584
#define IA32_RTIT_ADDR3_A                                            0x00000586
  /**
   * @}
   */

   /**
    * @defgroup ia32_rtit_addr_b \
    *           IA32_RTIT_ADDR(n)_B
    *
    * Region n End Address.
    *
    * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > n)
    * @{
    */
#define IA32_RTIT_ADDR0_B                                            0x00000581
#define IA32_RTIT_ADDR1_B                                            0x00000583
#define IA32_RTIT_ADDR2_B                                            0x00000585
#define IA32_RTIT_ADDR3_B                                            0x00000587
    /**
     * @}
     */

typedef union
{
    struct
    {
        /**
         * [Bits 47:0] Virtual Address.
         */
        UINT64_t virtual_address : 48;
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_BIT                           0
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_FLAG                          0xFFFFFFFFFFFF
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_MASK                          0xFFFFFFFFFFFF
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS(_)                            (((_) >> 0) & 0xFFFFFFFFFFFF)

        /**
         * [Bits 63:48] SignExt_VA.
         */
        UINT64_t sign_ext_va : 16;
#define IA32_RTIT_ADDR_SIGN_EXT_VA_BIT                               48
#define IA32_RTIT_ADDR_SIGN_EXT_VA_FLAG                              0xFFFF000000000000
#define IA32_RTIT_ADDR_SIGN_EXT_VA_MASK                              0xFFFF
#define IA32_RTIT_ADDR_SIGN_EXT_VA(_)                                (((_) >> 48) & 0xFFFF)
    };

    UINT64_t flags;
} ia32_rtit_addr_register;

/**
 * @}
 */


 /**
  * DS Save Area. Points to the linear address of the first byte of the DS buffer management area, which is used to manage
  * the BTS and PEBS buffers.
  * Returns:
  * - [63:0] The linear address of the first byte of the DS buffer management area, if IA-32e mode is active.
  * - [31:0] The linear address of the first byte of the DS buffer management area, if not in IA-32e mode.
  * - [63:32] Reserved if not in IA-32e mode.
  *
  * @remarks If CPUID.01H:EDX.DS[21] = 1
  * @see Vol3B[18.6.3.4(Debug Store (DS) Mechanism)]
  */
#define IA32_DS_AREA                                                 0x00000600

  /**
   * TSC Target of Local APIC's TSC Deadline Mode.
   *
   * @remarks If CPUID.01H:ECX.[24] = 1
   */
#define IA32_TSC_DEADLINE                                            0x000006E0

   /**
    * Enable/disable HWP.
    *
    * @remarks If CPUID.06H:EAX.[7] = 1
    */
#define IA32_PM_ENABLE                                               0x00000770
typedef union
{
    struct
    {
        /**
         * [Bit 0] HWP_ENABLE.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.2(Enabling HWP)]
         */
        UINT64_t hwp_enable : 1;
#define IA32_PM_ENABLE_HWP_ENABLE_BIT                                0
#define IA32_PM_ENABLE_HWP_ENABLE_FLAG                               0x01
#define IA32_PM_ENABLE_HWP_ENABLE_MASK                               0x01
#define IA32_PM_ENABLE_HWP_ENABLE(_)                                 (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 63;
    };

    UINT64_t flags;
} ia32_pm_enable_register;


/**
 * HWP Performance Range Enumeration.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_HWP_CAPABILITIES                                        0x00000771
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Highest_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
         */
        UINT64_t highest_performance : 8;
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_BIT                0
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_FLAG               0xFF
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_MASK               0xFF
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE(_)                 (((_) >> 0) & 0xFF)

        /**
         * [Bits 15:8] Guaranteed_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
         */
        UINT64_t guaranteed_performance : 8;
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_BIT             8
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_FLAG            0xFF00
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_MASK            0xFF
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE(_)              (((_) >> 8) & 0xFF)

        /**
         * [Bits 23:16] Most_Efficient_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
         */
        UINT64_t most_efficient_performance : 8;
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_BIT         16
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_FLAG        0xFF0000
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_MASK        0xFF
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE(_)          (((_) >> 16) & 0xFF)

        /**
         * [Bits 31:24] Lowest_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
         */
        UINT64_t lowest_performance : 8;
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_BIT                 24
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_FLAG                0xFF000000
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_MASK                0xFF
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE(_)                  (((_) >> 24) & 0xFF)
        UINT64_t reserved1 : 32;
    };

    UINT64_t flags;
} ia32_hwp_capabilities_register;


/**
 * Power Management Control Hints for All Logical Processors in a Package.
 *
 * @remarks If CPUID.06H:EAX.[11] = 1
 */
#define IA32_HWP_REQUEST_PKG                                         0x00000772
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Minimum_Performance.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t minimum_performance : 8;
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_BIT                 0
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_FLAG                0xFF
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_MASK                0xFF
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE(_)                  (((_) >> 0) & 0xFF)

        /**
         * [Bits 15:8] Maximum_Performance.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t maximum_performance : 8;
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_BIT                 8
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_FLAG                0xFF00
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_MASK                0xFF
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE(_)                  (((_) >> 8) & 0xFF)

        /**
         * [Bits 23:16] Desired_Performance.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t desired_performance : 8;
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_BIT                 16
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_FLAG                0xFF0000
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_MASK                0xFF
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE(_)                  (((_) >> 16) & 0xFF)

        /**
         * [Bits 31:24] Energy_Performance_Preference.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1 && CPUID.06H:EAX.[10] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t energy_performance_preference : 8;
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_BIT       24
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_FLAG      0xFF000000
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_MASK      0xFF
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE(_)        (((_) >> 24) & 0xFF)

        /**
         * [Bits 41:32] Activity_Window.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1 && CPUID.06H:EAX.[9] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t activity_window : 10;
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_BIT                     32
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_FLAG                    0x3FF00000000
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_MASK                    0x3FF
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW(_)                      (((_) >> 32) & 0x3FF)
        UINT64_t reserved1 : 22;
    };

    UINT64_t flags;
} ia32_hwp_request_pkg_register;


/**
 * Control HWP Native Interrupts.
 *
 * @remarks If CPUID.06H:EAX.[8] = 1
 */
#define IA32_HWP_INTERRUPT                                           0x00000773
typedef union
{
    struct
    {
        /**
         * [Bit 0] EN_Guaranteed_Performance_Change.
         *
         * @remarks If CPUID.06H:EAX.[8] = 1
         * @see Vol3B[14.4.6(HWP Notifications)]
         */
        UINT64_t en_guaranteed_performance_change : 1;
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_BIT      0
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_FLAG     0x01
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_MASK     0x01
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE(_)       (((_) >> 0) & 0x01)

        /**
         * [Bit 1] EN_Excursion_Minimum.
         *
         * @remarks If CPUID.06H:EAX.[8] = 1
         * @see Vol3B[14.4.6(HWP Notifications)]
         */
        UINT64_t en_excursion_minimum : 1;
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_BIT                  1
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_FLAG                 0x02
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_MASK                 0x01
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM(_)                   (((_) >> 1) & 0x01)
        UINT64_t reserved1 : 62;
    };

    UINT64_t flags;
} ia32_hwp_interrupt_register;


/**
 * Power Management Control Hints to a Logical Processor.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_HWP_REQUEST                                             0x00000774
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Minimum_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t minimum_performance : 8;
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_BIT                     0
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_FLAG                    0xFF
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_MASK                    0xFF
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE(_)                      (((_) >> 0) & 0xFF)

        /**
         * [Bits 15:8] Maximum_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t maximum_performance : 8;
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_BIT                     8
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_FLAG                    0xFF00
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_MASK                    0xFF
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE(_)                      (((_) >> 8) & 0xFF)

        /**
         * [Bits 23:16] Desired_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t desired_performance : 8;
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_BIT                     16
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_FLAG                    0xFF0000
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_MASK                    0xFF
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE(_)                      (((_) >> 16) & 0xFF)

        /**
         * [Bits 31:24] Energy_Performance_Preference.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1 && CPUID.06H:EAX.[10] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t energy_performance_preference : 8;
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_BIT           24
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_FLAG          0xFF000000
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_MASK          0xFF
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE(_)            (((_) >> 24) & 0xFF)

        /**
         * [Bits 41:32] Activity_Window.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1 && CPUID.06H:EAX.[9] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t activity_window : 10;
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_BIT                         32
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_FLAG                        0x3FF00000000
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_MASK                        0x3FF
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW(_)                          (((_) >> 32) & 0x3FF)

        /**
         * [Bit 42] Package_Control.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1 && CPUID.06H:EAX.[11] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        UINT64_t package_control : 1;
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_BIT                         42
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_FLAG                        0x40000000000
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_MASK                        0x01
#define IA32_HWP_REQUEST_PACKAGE_CONTROL(_)                          (((_) >> 42) & 0x01)
        UINT64_t reserved1 : 21;
    };

    UINT64_t flags;
} ia32_hwp_request_register;


/**
 * Log bits indicating changes to Guaranteed & excursions to Minimum.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_HWP_STATUS                                              0x00000777
typedef union
{
    struct
    {
        /**
         * [Bit 0] Guaranteed_Performance_Change.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.5(HWP Feedback)]
         */
        UINT64_t guaranteed_performance_change : 1;
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_BIT            0
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_FLAG           0x01
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_MASK           0x01
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE(_)             (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * [Bit 2] Excursion_To_Minimum.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.5(HWP Feedback)]
         */
        UINT64_t excursion_to_minimum : 1;
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_BIT                     2
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_FLAG                    0x04
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_MASK                    0x01
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM(_)                      (((_) >> 2) & 0x01)
        UINT64_t reserved2 : 61;
    };

    UINT64_t flags;
} ia32_hwp_status_register;


/**
 * x2APIC ID Register.
 *
 * @remarks If CPUID.01H:ECX[21] = 1 && IA32_APIC_BASE.[10] = 1
 * @see Vol3A[10.12(EXTENDED XAPIC (X2APIC))]
 */
#define IA32_X2APIC_APICID                                           0x00000802

 /**
  * x2APIC Version Register.
  *
  * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
  */
#define IA32_X2APIC_VERSION                                          0x00000803

  /**
   * x2APIC Task Priority Register.
   *
   * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
   */
#define IA32_X2APIC_TPR                                              0x00000808

   /**
    * x2APIC Processor Priority Register.
    *
    * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
    */
#define IA32_X2APIC_PPR                                              0x0000080A

    /**
     * x2APIC EOI Register.
     *
     * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
     */
#define IA32_X2APIC_EOI                                              0x0000080B

     /**
      * x2APIC Logical Destination Register.
      *
      * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
      */
#define IA32_X2APIC_LDR                                              0x0000080D

      /**
       * x2APIC Spurious Interrupt Vector Register.
       *
       * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
       */
#define IA32_X2APIC_SIVR                                             0x0000080F
       /**
        * @defgroup ia32_x2apic_isr \
        *           IA32_X2APIC_ISR(n)
        *
        * x2APIC In-Service Register Bits (n * 32 + 31):(n * 32).
        *
        * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
        * @{
        */
#define IA32_X2APIC_ISR0                                             0x00000810
#define IA32_X2APIC_ISR1                                             0x00000811
#define IA32_X2APIC_ISR2                                             0x00000812
#define IA32_X2APIC_ISR3                                             0x00000813
#define IA32_X2APIC_ISR4                                             0x00000814
#define IA32_X2APIC_ISR5                                             0x00000815
#define IA32_X2APIC_ISR6                                             0x00000816
#define IA32_X2APIC_ISR7                                             0x00000817
        /**
         * @}
         */

         /**
          * @defgroup ia32_x2apic_tmr \
          *           IA32_X2APIC_TMR(n)
          *
          * x2APIC Trigger Mode Register Bits (n * 32 + 31):(n * 32).
          *
          * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
          * @{
          */
#define IA32_X2APIC_TMR0                                             0x00000818
#define IA32_X2APIC_TMR1                                             0x00000819
#define IA32_X2APIC_TMR2                                             0x0000081A
#define IA32_X2APIC_TMR3                                             0x0000081B
#define IA32_X2APIC_TMR4                                             0x0000081C
#define IA32_X2APIC_TMR5                                             0x0000081D
#define IA32_X2APIC_TMR6                                             0x0000081E
#define IA32_X2APIC_TMR7                                             0x0000081F
          /**
           * @}
           */

           /**
            * @defgroup ia32_x2apic_irr \
            *           IA32_X2APIC_IRR(n)
            *
            * x2APIC Interrupt Request Register Bits (n * 32 + 31):(n * 32).
            *
            * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
            * @{
            */
#define IA32_X2APIC_IRR0                                             0x00000820
#define IA32_X2APIC_IRR1                                             0x00000821
#define IA32_X2APIC_IRR2                                             0x00000822
#define IA32_X2APIC_IRR3                                             0x00000823
#define IA32_X2APIC_IRR4                                             0x00000824
#define IA32_X2APIC_IRR5                                             0x00000825
#define IA32_X2APIC_IRR6                                             0x00000826
#define IA32_X2APIC_IRR7                                             0x00000827
            /**
             * @}
             */


             /**
              * x2APIC Error Status Register.
              *
              * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
              */
#define IA32_X2APIC_ESR                                              0x00000828

              /**
               * x2APIC LVT Corrected Machine Check Interrupt Register.
               *
               * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
               */
#define IA32_X2APIC_LVT_CMCI                                         0x0000082F

               /**
                * x2APIC Interrupt Command Register.
                *
                * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                */
#define IA32_X2APIC_ICR                                              0x00000830

                /**
                 * x2APIC LVT Timer Interrupt Register.
                 *
                 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                 */
#define IA32_X2APIC_LVT_TIMER                                        0x00000832

                 /**
                  * x2APIC LVT Thermal Sensor Interrupt Register.
                  *
                  * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                  */
#define IA32_X2APIC_LVT_THERMAL                                      0x00000833

                  /**
                   * x2APIC LVT Performance Monitor Interrupt Register.
                   *
                   * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                   */
#define IA32_X2APIC_LVT_PMI                                          0x00000834

                   /**
                    * x2APIC LVT LINT0 Register.
                    *
                    * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                    */
#define IA32_X2APIC_LVT_LINT0                                        0x00000835

                    /**
                     * x2APIC LVT LINT1 Register.
                     *
                     * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                     */
#define IA32_X2APIC_LVT_LINT1                                        0x00000836

                     /**
                      * x2APIC LVT Error Register.
                      *
                      * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                      */
#define IA32_X2APIC_LVT_ERROR                                        0x00000837

                      /**
                       * x2APIC Initial Count Register.
                       *
                       * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                       */
#define IA32_X2APIC_INIT_COUNT                                       0x00000838

                       /**
                        * x2APIC Current Count Register.
                        *
                        * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                        */
#define IA32_X2APIC_CUR_COUNT                                        0x00000839

                        /**
                         * x2APIC Divide Configuration Register.
                         *
                         * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                         */
#define IA32_X2APIC_DIV_CONF                                         0x0000083E

                         /**
                          * x2APIC Self IPI Register.
                          *
                          * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                          */
#define IA32_X2APIC_SELF_IPI                                         0x0000083F

                          /**
                           * Silicon Debug Feature Control.
                           *
                           * @remarks If CPUID.01H:ECX.[11] = 1
                           */
#define IA32_DEBUG_INTERFACE                                         0x00000C80
typedef union
{
    struct
    {
        /**
         * @brief Enable <b>(R/W)</b>
         *
         * [Bit 0] BIOS set 1 to enable Silicon debug features. Default is 0.
         *
         * @remarks If CPUID.01H:ECX.[11] = 1
         */
        UINT64_t enable : 1;
#define IA32_DEBUG_INTERFACE_ENABLE_BIT                              0
#define IA32_DEBUG_INTERFACE_ENABLE_FLAG                             0x01
#define IA32_DEBUG_INTERFACE_ENABLE_MASK                             0x01
#define IA32_DEBUG_INTERFACE_ENABLE(_)                               (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 29;

        /**
         * @brief Lock <b>(R/W)</b>
         *
         * [Bit 30] If 1, locks any further change to the MSR. The lock bit is set automatically on the first SMI assertion even if
         * not explicitly set by BIOS. Default is 0.
         *
         * @remarks If CPUID.01H:ECX.[11] = 1
         */
        UINT64_t lock : 1;
#define IA32_DEBUG_INTERFACE_LOCK_BIT                                30
#define IA32_DEBUG_INTERFACE_LOCK_FLAG                               0x40000000
#define IA32_DEBUG_INTERFACE_LOCK_MASK                               0x01
#define IA32_DEBUG_INTERFACE_LOCK(_)                                 (((_) >> 30) & 0x01)

        /**
         * @brief Debug Occurred <b>(R/O)</b>
         *
         * [Bit 31] This "sticky bit" is set by hardware to indicate the status of bit 0. Default is 0.
         *
         * @remarks If CPUID.01H:ECX.[11] = 1
         */
        UINT64_t debug_occurred : 1;
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_BIT                      31
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_FLAG                     0x80000000
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_MASK                     0x01
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED(_)                       (((_) >> 31) & 0x01)
        UINT64_t reserved2 : 32;
    };

    UINT64_t flags;
} ia32_debug_interface_register;


/**
 * L3 QOS Configuration.
 *
 * @remarks If ( CPUID.(EAX=10H, ECX=1):ECX.[2] = 1 )
 */
#define IA32_L3_QOS_CFG                                              0x00000C81
typedef union
{
    struct
    {
        /**
         * @brief Enable <b>(R/W)</b>
         *
         * [Bit 0] Set 1 to enable L3 CAT masks and COS to operate in Code and Data Prioritization (CDP) mode.
         */
        UINT64_t enable : 1;
#define IA32_L3_QOS_CFG_ENABLE_BIT                                   0
#define IA32_L3_QOS_CFG_ENABLE_FLAG                                  0x01
#define IA32_L3_QOS_CFG_ENABLE_MASK                                  0x01
#define IA32_L3_QOS_CFG_ENABLE(_)                                    (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 63;
    };

    UINT64_t flags;
} ia32_l3_qos_cfg_register;


/**
 * L2 QOS Configuration.
 *
 * @remarks If ( CPUID.(EAX=10H, ECX=2):ECX.[2] = 1 )
 */
#define IA32_L2_QOS_CFG                                              0x00000C82
typedef union
{
    struct
    {
        /**
         * @brief Enable <b>(R/W)</b>
         *
         * [Bit 0] Set 1 to enable L2 CAT masks and COS to operate in Code and Data Prioritization (CDP) mode.
         */
        UINT64_t enable : 1;
#define IA32_L2_QOS_CFG_ENABLE_BIT                                   0
#define IA32_L2_QOS_CFG_ENABLE_FLAG                                  0x01
#define IA32_L2_QOS_CFG_ENABLE_MASK                                  0x01
#define IA32_L2_QOS_CFG_ENABLE(_)                                    (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 63;
    };

    UINT64_t flags;
} ia32_l2_qos_cfg_register;


/**
 * Monitoring Event Select Register.
 *
 * @remarks If ( CPUID.(EAX=07H, ECX=0):EBX.[12] = 1 )
 */
#define IA32_QM_EVTSEL                                               0x00000C8D
typedef union
{
    struct
    {
        /**
         * @brief Event ID
         *
         * [Bits 7:0] ID of a supported monitoring event to report via IA32_QM_CTR.
         */
        UINT64_t event_id : 8;
#define IA32_QM_EVTSEL_EVENT_ID_BIT                                  0
#define IA32_QM_EVTSEL_EVENT_ID_FLAG                                 0xFF
#define IA32_QM_EVTSEL_EVENT_ID_MASK                                 0xFF
#define IA32_QM_EVTSEL_EVENT_ID(_)                                   (((_) >> 0) & 0xFF)
        UINT64_t reserved1 : 24;

        /**
         * @brief Resource Monitoring ID
         *
         * [Bits 63:32] ID for monitoring hardware to report monitored data via IA32_QM_CTR.
         *
         * @remarks Bits [N+31:32] N = Ceil (Log2 (CPUID.(EAX= 0FH,ECX=0H).EBX[31:0] + 1))
         */
        UINT64_t resource_monitoring_id : 32;
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_BIT                    32
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_FLAG                   0xFFFFFFFF00000000
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_MASK                   0xFFFFFFFF
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID(_)                     (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64_t flags;
} ia32_qm_evtsel_register;


/**
 * Monitoring Counter Register.
 *
 * @remarks If ( CPUID.(EAX=07H, ECX=0):EBX.[12] = 1 )
 */
#define IA32_QM_CTR                                                  0x00000C8E
typedef union
{
    struct
    {
        /**
         * [Bits 61:0] Resource Monitored Data.
         */
        UINT64_t resource_monitored_data : 62;
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA_BIT                      0
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA_FLAG                     0x3FFFFFFFFFFFFFFF
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA_MASK                     0x3FFFFFFFFFFFFFFF
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA(_)                       (((_) >> 0) & 0x3FFFFFFFFFFFFFFF)

        /**
         * @brief Unavailable
         *
         * [Bit 62] If 1, indicates data for this RMID is not available or not monitored for this resource or RMID.
         */
        UINT64_t unavailable : 1;
#define IA32_QM_CTR_UNAVAILABLE_BIT                                  62
#define IA32_QM_CTR_UNAVAILABLE_FLAG                                 0x4000000000000000
#define IA32_QM_CTR_UNAVAILABLE_MASK                                 0x01
#define IA32_QM_CTR_UNAVAILABLE(_)                                   (((_) >> 62) & 0x01)

        /**
         * @brief Error
         *
         * [Bit 63] If 1, indicates an unsupported RMID or event type was written to IA32_PQR_QM_EVTSEL.
         */
        UINT64_t error : 1;
#define IA32_QM_CTR_ERROR_BIT                                        63
#define IA32_QM_CTR_ERROR_FLAG                                       0x8000000000000000
#define IA32_QM_CTR_ERROR_MASK                                       0x01
#define IA32_QM_CTR_ERROR(_)                                         (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} ia32_qm_ctr_register;


/**
 * Resource Association Register.
 *
 * @remarks If ( (CPUID.(EAX=07H, ECX=0):EBX[12] = 1) or (CPUID.(EAX=07H, ECX=0):EBX[15] = 1 ) )
 */
#define IA32_PQR_ASSOC                                               0x00000C8F
typedef union
{
    struct
    {
        /**
         * @brief Resource Monitoring ID <b>(R/W)</b>
         *
         * [Bits 31:0] ID for monitoring hardware to track internal operation, e.g., memory access.
         *
         * @remarks Bits [N-1:0] N = Ceil (Log2 (CPUID.(EAX= 0FH, ECX=0H).EBX[31:0] +1)) 31:N Reserved
         */
        UINT64_t resource_monitoring_id : 32;
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_BIT                    0
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_FLAG                   0xFFFFFFFF
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_MASK                   0xFFFFFFFF
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID(_)                     (((_) >> 0) & 0xFFFFFFFF)

        /**
         * @brief COS <b>(R/W)</b>
         *
         * [Bits 63:32] The class of service (COS) to enforce (on writes); returns the current COS when read.
         *
         * @remarks If ( CPUID.(EAX=07H, ECX=0):EBX.[15] = 1 )
         */
        UINT64_t cos : 32;
#define IA32_PQR_ASSOC_COS_BIT                                       32
#define IA32_PQR_ASSOC_COS_FLAG                                      0xFFFFFFFF00000000
#define IA32_PQR_ASSOC_COS_MASK                                      0xFFFFFFFF
#define IA32_PQR_ASSOC_COS(_)                                        (((_) >> 32) & 0xFFFFFFFF)
    };

    UINT64_t flags;
} ia32_pqr_assoc_register;


/**
 * Supervisor State of MPX Configuration.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0H):EBX[14] = 1)
 */
#define IA32_BNDCFGS                                                 0x00000D90
typedef union
{
    struct
    {
        /**
         * [Bit 0] Enable Intel MPX in supervisor mode.
         */
        UINT64_t enable : 1;
#define IA32_BNDCFGS_ENABLE_BIT                                      0
#define IA32_BNDCFGS_ENABLE_FLAG                                     0x01
#define IA32_BNDCFGS_ENABLE_MASK                                     0x01
#define IA32_BNDCFGS_ENABLE(_)                                       (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Preserve the bounds registers for near branch instructions in the absence of the BND prefix.
         */
        UINT64_t bnd_preserve : 1;
#define IA32_BNDCFGS_BND_PRESERVE_BIT                                1
#define IA32_BNDCFGS_BND_PRESERVE_FLAG                               0x02
#define IA32_BNDCFGS_BND_PRESERVE_MASK                               0x01
#define IA32_BNDCFGS_BND_PRESERVE(_)                                 (((_) >> 1) & 0x01)
        UINT64_t reserved1 : 10;

        /**
         * [Bits 63:12] Base Address of Bound Directory.
         */
        UINT64_t bound_directory_base_address : 52;
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_BIT                12
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_FLAG               0xFFFFFFFFFFFFF000
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_MASK               0xFFFFFFFFFFFFF
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS(_)                 (((_) >> 12) & 0xFFFFFFFFFFFFF)
    };

    UINT64_t flags;
} ia32_bndcfgs_register;


/**
 * Extended Supervisor State Mask.
 *
 * @remarks If ( CPUID.(0DH, 1):EAX.[3] = 1
 */
#define IA32_XSS                                                     0x00000DA0
typedef union
{
    struct
    {
        UINT64_t reserved1 : 8;

        /**
         * [Bit 8] Trace Packet Configuration State.
         */
        UINT64_t trace_packet_configuration_state : 1;
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_BIT                8
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_FLAG               0x100
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_MASK               0x01
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE(_)                 (((_) >> 8) & 0x01)
        UINT64_t reserved2 : 55;
    };

    UINT64_t flags;
} ia32_xss_register;


/**
 * Package Level Enable/disable HDC.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_PKG_HDC_CTL                                             0x00000DB0
typedef union
{
    struct
    {
        /**
         * @brief HDC_Pkg_Enable <b>(R/W)</b>
         *
         * [Bit 0] Force HDC idling or wake up HDC-idled logical processors in the package.
         *
         * @remarks If CPUID.06H:EAX.[13] = 1
         * @see Vol3B[14.5.2(Package level Enabling HDC)]
         */
        UINT64_t hdc_pkg_enable : 1;
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_BIT                          0
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_FLAG                         0x01
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_MASK                         0x01
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE(_)                           (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 63;
    };

    UINT64_t flags;
} ia32_pkg_hdc_ctl_register;


/**
 * Enable/disable HWP.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_PM_CTL1                                                 0x00000DB1
typedef union
{
    struct
    {
        /**
         * @brief HDC_Allow_Block <b>(R/W)</b>
         *
         * [Bit 0] Allow/Block this logical processor for package level HDC control.
         *
         * @remarks If CPUID.06H:EAX.[13] = 1
         * @see Vol3B[14.5.3(Logical-Processor Level HDC Control)]
         */
        UINT64_t hdc_allow_block : 1;
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK_BIT                             0
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK_FLAG                            0x01
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK_MASK                            0x01
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK(_)                              (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 63;
    };

    UINT64_t flags;
} ia32_pm_ctl1_register;


/**
 * Per-Logical_Processor HDC Idle Residency.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_THREAD_STALL                                            0x00000DB2
typedef struct
{
    /**
     * @brief Stall_Cycle_Cnt <b>(R/W)</b>
     *
     * Stalled cycles due to HDC forced idle on this logical processor.
     *
     * @remarks If CPUID.06H:EAX.[13] = 1
     * @see Vol3B[14.5.4.1(IA32_THREAD_STALL)]
     */
    UINT64_t stall_cycle_count;
} ia32_thread_stall_register;


/**
 * Extended Feature Enables.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_EFER                                                    0xC0000080
typedef union
{
    struct
    {
        /**
         * @brief SYSCALL Enable <b>(R/W)</b>
         *
         * [Bit 0] Enables SYSCALL/SYSRET instructions in 64-bit mode.
         */
        UINT64_t syscall_enable : 1;
#define IA32_EFER_SYSCALL_ENABLE_BIT                                 0
#define IA32_EFER_SYSCALL_ENABLE_FLAG                                0x01
#define IA32_EFER_SYSCALL_ENABLE_MASK                                0x01
#define IA32_EFER_SYSCALL_ENABLE(_)                                  (((_) >> 0) & 0x01)
        UINT64_t reserved1 : 7;

        /**
         * @brief IA-32e Mode Enable <b>(R/W)</b>
         *
         * [Bit 8] Enables IA-32e mode operation.
         */
        UINT64_t ia32e_mode_enable : 1;
#define IA32_EFER_IA32E_MODE_ENABLE_BIT                              8
#define IA32_EFER_IA32E_MODE_ENABLE_FLAG                             0x100
#define IA32_EFER_IA32E_MODE_ENABLE_MASK                             0x01
#define IA32_EFER_IA32E_MODE_ENABLE(_)                               (((_) >> 8) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * @brief IA-32e Mode Active <b>(R)</b>
         *
         * [Bit 10] Indicates IA-32e mode is active when set.
         */
        UINT64_t ia32e_mode_active : 1;
#define IA32_EFER_IA32E_MODE_ACTIVE_BIT                              10
#define IA32_EFER_IA32E_MODE_ACTIVE_FLAG                             0x400
#define IA32_EFER_IA32E_MODE_ACTIVE_MASK                             0x01
#define IA32_EFER_IA32E_MODE_ACTIVE(_)                               (((_) >> 10) & 0x01)

        /**
         * [Bit 11] Execute Disable Bit Enable.
         */
        UINT64_t execute_disable_bit_enable : 1;
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_BIT                     11
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_FLAG                    0x800
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_MASK                    0x01
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE(_)                      (((_) >> 11) & 0x01)
        UINT64_t reserved3 : 52;
    };

    UINT64_t flags;
} ia32_efer_register;


/**
 * System Call Target Address.
 *
 * @remarks If CPUID.80000001:EDX.[29] = 1
 */
#define IA32_STAR                                                    0xC0000081

 /**
  * @brief IA-32e Mode System Call Target Address <b>(R/W)</b>
  *
  * Target RIP for the called procedure when SYSCALL is executed in 64-bit mode.
  *
  * @remarks If CPUID.80000001:EDX.[29] = 1
  */
#define IA32_LSTAR                                                   0xC0000082

  /**
   * @brief IA-32e Mode System Call Target Address <b>(R/W)</b>
   *
   * Not used, as the SYSCALL instruction is not recognized in compatibility mode.
   *
   * @remarks If CPUID.80000001:EDX.[29] = 1
   */
#define IA32_CSTAR                                                   0xC0000083

   /**
    * System Call Flag Mask.
    *
    * @remarks If CPUID.80000001:EDX.[29] = 1
    */
#define IA32_FMASK                                                   0xC0000084

    /**
     * Map of BASE Address of FS.
     *
     * @remarks If CPUID.80000001:EDX.[29] = 1
     */
#define IA32_FS_BASE                                                 0xC0000100

     /**
      * Map of BASE Address of GS.
      *
      * @remarks If CPUID.80000001:EDX.[29] = 1
      */
#define IA32_GS_BASE                                                 0xC0000101

      /**
       * Swap Target of BASE Address of GS.
       *
       * @remarks If CPUID.80000001:EDX.[29] = 1
       */
#define IA32_KERNEL_GS_BASE                                          0xC0000102

       /**
        * Auxiliary TSC.
        *
        * @remarks If CPUID.80000001H: EDX[27] = 1 or CPUID.(EAX=7,ECX=0):ECX[bit 22] = 1
        */
#define IA32_TSC_AUX                                                 0xC0000103
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] AUX. Auxiliary signature of TSC.
         */
        UINT64_t tsc_auxiliary_signature : 32;
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_BIT                     0
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_FLAG                    0xFFFFFFFF
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_MASK                    0xFFFFFFFF
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE(_)                      (((_) >> 0) & 0xFFFFFFFF)
        UINT64_t reserved1 : 32;
    };

    UINT64_t flags;
} ia32_tsc_aux_register;

/**
 * @}
 */

 /**
  * @defgroup paging \
  *           Paging
  * @{
  */
  /**
   * @defgroup paging_32 \
   *           32-Bit Paging
   *
   * A logical processor uses 32-bit paging if CR0.PG = 1 and CR4.PAE = 0. 32-bit paging translates 32-bit linear addresses
   * to 40-bit physical addresses. Although 40 bits corresponds to 1 TByte, linear addresses are limited to 32 bits; at most
   * 4 GBytes of linear-address space may be accessed at any given time.
   * 32-bit paging uses a hierarchy of paging structures to produce a translation for a linear address. CR3 is used to locate
   * the first paging-structure, the page directory. 32-bit paging may map linear addresses to either 4-KByte pages or
   * 4-MByte pages.
   *
   * @see Vol3A[4.5(4-LEVEL PAGING)] (reference)
   * @{
   */
   /**
    * @brief Format of a 32-Bit Page-Directory Entry that Maps a 4-MByte Page
    */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 4-MByte page.
         */
        UINT32_t present : 1;
#define PDE_4MB_32_PRESENT_BIT                                       0
#define PDE_4MB_32_PRESENT_FLAG                                      0x01
#define PDE_4MB_32_PRESENT_MASK                                      0x01
#define PDE_4MB_32_PRESENT(_)                                        (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT32_t write : 1;
#define PDE_4MB_32_WRITE_BIT                                         1
#define PDE_4MB_32_WRITE_FLAG                                        0x02
#define PDE_4MB_32_WRITE_MASK                                        0x01
#define PDE_4MB_32_WRITE(_)                                          (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT32_t supervisor : 1;
#define PDE_4MB_32_SUPERVISOR_BIT                                    2
#define PDE_4MB_32_SUPERVISOR_FLAG                                   0x04
#define PDE_4MB_32_SUPERVISOR_MASK                                   0x01
#define PDE_4MB_32_SUPERVISOR(_)                                     (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 4-MByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32_t page_level_write_through : 1;
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_BIT                      3
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                     0x08
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_MASK                     0x01
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH(_)                       (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 4-MByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32_t page_level_cache_disable : 1;
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_BIT                      4
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                     0x10
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_MASK                     0x01
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE(_)                       (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT32_t accessed : 1;
#define PDE_4MB_32_ACCESSED_BIT                                      5
#define PDE_4MB_32_ACCESSED_FLAG                                     0x20
#define PDE_4MB_32_ACCESSED_MASK                                     0x01
#define PDE_4MB_32_ACCESSED(_)                                       (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT32_t dirty : 1;
#define PDE_4MB_32_DIRTY_BIT                                         6
#define PDE_4MB_32_DIRTY_FLAG                                        0x40
#define PDE_4MB_32_DIRTY_MASK                                        0x01
#define PDE_4MB_32_DIRTY(_)                                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Page size; must be 1 (otherwise, this entry references a page table).
         */
        UINT32_t large_page : 1;
#define PDE_4MB_32_LARGE_PAGE_BIT                                    7
#define PDE_4MB_32_LARGE_PAGE_FLAG                                   0x80
#define PDE_4MB_32_LARGE_PAGE_MASK                                   0x01
#define PDE_4MB_32_LARGE_PAGE(_)                                     (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        UINT32_t global : 1;
#define PDE_4MB_32_GLOBAL_BIT                                        8
#define PDE_4MB_32_GLOBAL_FLAG                                       0x100
#define PDE_4MB_32_GLOBAL_MASK                                       0x01
#define PDE_4MB_32_GLOBAL(_)                                         (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT32_t ignored_1 : 3;
#define PDE_4MB_32_IGNORED_1_BIT                                     9
#define PDE_4MB_32_IGNORED_1_FLAG                                    0xE00
#define PDE_4MB_32_IGNORED_1_MASK                                    0x07
#define PDE_4MB_32_IGNORED_1(_)                                      (((_) >> 9) & 0x07)

        /**
         * [Bit 12] Indirectly determines the memory type used to access the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32_t pat : 1;
#define PDE_4MB_32_PAT_BIT                                           12
#define PDE_4MB_32_PAT_FLAG                                          0x1000
#define PDE_4MB_32_PAT_MASK                                          0x01
#define PDE_4MB_32_PAT(_)                                            (((_) >> 12) & 0x01)

        /**
         * [Bits 20:13] Bits (M-1):32 of physical address of the 4-MByte page referenced by this entry.
         */
        UINT32_t page_frame_number_low : 8;
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_BIT                         13
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_FLAG                        0x1FE000
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_MASK                        0xFF
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW(_)                          (((_) >> 13) & 0xFF)
        UINT32_t reserved1 : 1;

        /**
         * [Bits 31:22] Bits 31:22 of physical address of the 4-MByte page referenced by this entry.
         */
        UINT32_t page_frame_number_high : 10;
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_BIT                        22
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_FLAG                       0xFFC00000
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_MASK                       0x3FF
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH(_)                         (((_) >> 22) & 0x3FF)
    };

    UINT32_t flags;
} pde_4mb_32;

/**
 * @brief Format of a 32-Bit Page-Directory Entry that References a Page Table
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to reference a page table.
         */
        UINT32_t present : 1;
#define PDE_32_PRESENT_BIT                                           0
#define PDE_32_PRESENT_FLAG                                          0x01
#define PDE_32_PRESENT_MASK                                          0x01
#define PDE_32_PRESENT(_)                                            (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-MByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT32_t write : 1;
#define PDE_32_WRITE_BIT                                             1
#define PDE_32_WRITE_FLAG                                            0x02
#define PDE_32_WRITE_MASK                                            0x01
#define PDE_32_WRITE(_)                                              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-MByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT32_t supervisor : 1;
#define PDE_32_SUPERVISOR_BIT                                        2
#define PDE_32_SUPERVISOR_FLAG                                       0x04
#define PDE_32_SUPERVISOR_MASK                                       0x01
#define PDE_32_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page table referenced by this
         * entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32_t page_level_write_through : 1;
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page table referenced by this
         * entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32_t page_level_cache_disable : 1;
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT32_t accessed : 1;
#define PDE_32_ACCESSED_BIT                                          5
#define PDE_32_ACCESSED_FLAG                                         0x20
#define PDE_32_ACCESSED_MASK                                         0x01
#define PDE_32_ACCESSED(_)                                           (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Ignored.
         */
        UINT32_t ignored_1 : 1;
#define PDE_32_IGNORED_1_BIT                                         6
#define PDE_32_IGNORED_1_FLAG                                        0x40
#define PDE_32_IGNORED_1_MASK                                        0x01
#define PDE_32_IGNORED_1(_)                                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] If CR4.PSE = 1, must be 0 (otherwise, this entry maps a 4-MByte page); otherwise, ignored.
         */
        UINT32_t large_page : 1;
#define PDE_32_LARGE_PAGE_BIT                                        7
#define PDE_32_LARGE_PAGE_FLAG                                       0x80
#define PDE_32_LARGE_PAGE_MASK                                       0x01
#define PDE_32_LARGE_PAGE(_)                                         (((_) >> 7) & 0x01)

        /**
         * [Bits 11:8] Ignored.
         */
        UINT32_t ignored_2 : 4;
#define PDE_32_IGNORED_2_BIT                                         8
#define PDE_32_IGNORED_2_FLAG                                        0xF00
#define PDE_32_IGNORED_2_MASK                                        0x0F
#define PDE_32_IGNORED_2(_)                                          (((_) >> 8) & 0x0F)

        /**
         * [Bits 31:12] Physical address of 4-KByte aligned page table referenced by this entry.
         */
        UINT32_t page_frame_number : 20;
#define PDE_32_PAGE_FRAME_NUMBER_BIT                                 12
#define PDE_32_PAGE_FRAME_NUMBER_FLAG                                0xFFFFF000
#define PDE_32_PAGE_FRAME_NUMBER_MASK                                0xFFFFF
#define PDE_32_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFF)
    };

    UINT32_t flags;
} pde_32;

/**
 * @brief Format of a 32-Bit Page-Table Entry that Maps a 4-KByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 4-KByte page.
         */
        UINT32_t present : 1;
#define PTE_32_PRESENT_BIT                                           0
#define PTE_32_PRESENT_FLAG                                          0x01
#define PTE_32_PRESENT_MASK                                          0x01
#define PTE_32_PRESENT(_)                                            (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT32_t write : 1;
#define PTE_32_WRITE_BIT                                             1
#define PTE_32_WRITE_FLAG                                            0x02
#define PTE_32_WRITE_MASK                                            0x01
#define PTE_32_WRITE(_)                                              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT32_t supervisor : 1;
#define PTE_32_SUPERVISOR_BIT                                        2
#define PTE_32_SUPERVISOR_FLAG                                       0x04
#define PTE_32_SUPERVISOR_MASK                                       0x01
#define PTE_32_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 4-KByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32_t page_level_write_through : 1;
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 4-KByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32_t page_level_cache_disable : 1;
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT32_t accessed : 1;
#define PTE_32_ACCESSED_BIT                                          5
#define PTE_32_ACCESSED_FLAG                                         0x20
#define PTE_32_ACCESSED_MASK                                         0x01
#define PTE_32_ACCESSED(_)                                           (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT32_t dirty : 1;
#define PTE_32_DIRTY_BIT                                             6
#define PTE_32_DIRTY_FLAG                                            0x40
#define PTE_32_DIRTY_MASK                                            0x01
#define PTE_32_DIRTY(_)                                              (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Indirectly determines the memory type used to access the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT32_t pat : 1;
#define PTE_32_PAT_BIT                                               7
#define PTE_32_PAT_FLAG                                              0x80
#define PTE_32_PAT_MASK                                              0x01
#define PTE_32_PAT(_)                                                (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        UINT32_t global : 1;
#define PTE_32_GLOBAL_BIT                                            8
#define PTE_32_GLOBAL_FLAG                                           0x100
#define PTE_32_GLOBAL_MASK                                           0x01
#define PTE_32_GLOBAL(_)                                             (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT32_t ignored_1 : 3;
#define PTE_32_IGNORED_1_BIT                                         9
#define PTE_32_IGNORED_1_FLAG                                        0xE00
#define PTE_32_IGNORED_1_MASK                                        0x07
#define PTE_32_IGNORED_1(_)                                          (((_) >> 9) & 0x07)

        /**
         * [Bits 31:12] Physical address of 4-KByte aligned page table referenced by this entry.
         */
        UINT32_t page_frame_number : 20;
#define PTE_32_PAGE_FRAME_NUMBER_BIT                                 12
#define PTE_32_PAGE_FRAME_NUMBER_FLAG                                0xFFFFF000
#define PTE_32_PAGE_FRAME_NUMBER_MASK                                0xFFFFF
#define PTE_32_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFF)
    };

    UINT32_t flags;
} pte_32;

/**
 * @brief Format of a common Page-Table Entry
 */
typedef union
{
    struct
    {
        UINT32_t present : 1;
#define PT_ENTRY_32_PRESENT_BIT                                      0
#define PT_ENTRY_32_PRESENT_FLAG                                     0x01
#define PT_ENTRY_32_PRESENT_MASK                                     0x01
#define PT_ENTRY_32_PRESENT(_)                                       (((_) >> 0) & 0x01)
        UINT32_t write : 1;
#define PT_ENTRY_32_WRITE_BIT                                        1
#define PT_ENTRY_32_WRITE_FLAG                                       0x02
#define PT_ENTRY_32_WRITE_MASK                                       0x01
#define PT_ENTRY_32_WRITE(_)                                         (((_) >> 1) & 0x01)
        UINT32_t supervisor : 1;
#define PT_ENTRY_32_SUPERVISOR_BIT                                   2
#define PT_ENTRY_32_SUPERVISOR_FLAG                                  0x04
#define PT_ENTRY_32_SUPERVISOR_MASK                                  0x01
#define PT_ENTRY_32_SUPERVISOR(_)                                    (((_) >> 2) & 0x01)
        UINT32_t page_level_write_through : 1;
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_BIT                     3
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                    0x08
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_MASK                    0x01
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH(_)                      (((_) >> 3) & 0x01)
        UINT32_t page_level_cache_disable : 1;
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_BIT                     4
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                    0x10
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_MASK                    0x01
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE(_)                      (((_) >> 4) & 0x01)
        UINT32_t accessed : 1;
#define PT_ENTRY_32_ACCESSED_BIT                                     5
#define PT_ENTRY_32_ACCESSED_FLAG                                    0x20
#define PT_ENTRY_32_ACCESSED_MASK                                    0x01
#define PT_ENTRY_32_ACCESSED(_)                                      (((_) >> 5) & 0x01)
        UINT32_t dirty : 1;
#define PT_ENTRY_32_DIRTY_BIT                                        6
#define PT_ENTRY_32_DIRTY_FLAG                                       0x40
#define PT_ENTRY_32_DIRTY_MASK                                       0x01
#define PT_ENTRY_32_DIRTY(_)                                         (((_) >> 6) & 0x01)
        UINT32_t large_page : 1;
#define PT_ENTRY_32_LARGE_PAGE_BIT                                   7
#define PT_ENTRY_32_LARGE_PAGE_FLAG                                  0x80
#define PT_ENTRY_32_LARGE_PAGE_MASK                                  0x01
#define PT_ENTRY_32_LARGE_PAGE(_)                                    (((_) >> 7) & 0x01)
        UINT32_t global : 1;
#define PT_ENTRY_32_GLOBAL_BIT                                       8
#define PT_ENTRY_32_GLOBAL_FLAG                                      0x100
#define PT_ENTRY_32_GLOBAL_MASK                                      0x01
#define PT_ENTRY_32_GLOBAL(_)                                        (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT32_t ignored_1 : 3;
#define PT_ENTRY_32_IGNORED_1_BIT                                    9
#define PT_ENTRY_32_IGNORED_1_FLAG                                   0xE00
#define PT_ENTRY_32_IGNORED_1_MASK                                   0x07
#define PT_ENTRY_32_IGNORED_1(_)                                     (((_) >> 9) & 0x07)

        /**
         * [Bits 31:12] Physical address of the 4-KByte page referenced by this entry.
         */
        UINT32_t page_frame_number : 20;
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_BIT                            12
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_FLAG                           0xFFFFF000
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_MASK                           0xFFFFF
#define PT_ENTRY_32_PAGE_FRAME_NUMBER(_)                             (((_) >> 12) & 0xFFFFF)
    };

    UINT32_t flags;
} pt_entry_32;

/**
 * @defgroup paging_structures_entry_count_32 \
 *           Paging structures entry counts
 *
 * Paging structures entry counts.
 * @{
 */
#define PDE_ENTRY_COUNT_32                                           0x00000400
#define PTE_ENTRY_COUNT_32                                           0x00000400
 /**
  * @}
  */

  /**
   * @}
   */

   /**
    * @defgroup paging_64 \
    *           64-Bit (4-Level) Paging
    *
    * A logical processor uses 4-level paging if CR0.PG = 1, CR4.PAE = 1, and IA32_EFER.LME = 1. With 4-level paging, linear
    * address are translated using a hierarchy of in-memory paging structures located using the contents of CR3. 4-level
    * paging translates 48-bit linear addresses to 52-bit physical addresses. Although 52 bits corresponds to 4 PBytes, linear
    * addresses are limited to 48 bits; at most 256 TBytes of linear-address space may be accessed at any given time.
    * 4-level paging uses a hierarchy of paging structures to produce a translation for a linear address. CR3 is used to
    * locate the first paging-structure, the PML4 table. Use of CR3 with 4-level paging depends on whether processcontext
    * identifiers (PCIDs) have been enabled by setting CR4.PCIDE.
    *
    * @see Vol3A[4.5(4-LEVEL PAGING)] (reference)
    * @{
    */
    /**
     * @brief Format of a 4-Level PML4 Entry (PML4E) that References a Page-Directory-Pointer Table
     */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to reference a page-directory-pointer table.
         */
        UINT64_t present : 1;
#define PML4E_64_PRESENT_BIT                                         0
#define PML4E_64_PRESENT_FLAG                                        0x01
#define PML4E_64_PRESENT_MASK                                        0x01
#define PML4E_64_PRESENT(_)                                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 512-GByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t write : 1;
#define PML4E_64_WRITE_BIT                                           1
#define PML4E_64_WRITE_FLAG                                          0x02
#define PML4E_64_WRITE_MASK                                          0x01
#define PML4E_64_WRITE(_)                                            (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 512-GByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t supervisor : 1;
#define PML4E_64_SUPERVISOR_BIT                                      2
#define PML4E_64_SUPERVISOR_FLAG                                     0x04
#define PML4E_64_SUPERVISOR_MASK                                     0x01
#define PML4E_64_SUPERVISOR(_)                                       (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page-directory-pointer table
         * referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_write_through : 1;
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_BIT                        3
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                       0x08
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_MASK                       0x01
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH(_)                         (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page-directory-pointer table
         * referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_cache_disable : 1;
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_BIT                        4
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                       0x10
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_MASK                       0x01
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE(_)                         (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64_t accessed : 1;
#define PML4E_64_ACCESSED_BIT                                        5
#define PML4E_64_ACCESSED_FLAG                                       0x20
#define PML4E_64_ACCESSED_MASK                                       0x01
#define PML4E_64_ACCESSED(_)                                         (((_) >> 5) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * [Bit 7] Reserved (must be 0).
         */
        UINT64_t must_be_zero : 1;
#define PML4E_64_MUST_BE_ZERO_BIT                                    7
#define PML4E_64_MUST_BE_ZERO_FLAG                                   0x80
#define PML4E_64_MUST_BE_ZERO_MASK                                   0x01
#define PML4E_64_MUST_BE_ZERO(_)                                     (((_) >> 7) & 0x01)

        /**
         * [Bits 11:8] Ignored.
         */
        UINT64_t ignored_1 : 4;
#define PML4E_64_IGNORED_1_BIT                                       8
#define PML4E_64_IGNORED_1_FLAG                                      0xF00
#define PML4E_64_IGNORED_1_MASK                                      0x0F
#define PML4E_64_IGNORED_1(_)                                        (((_) >> 8) & 0x0F)

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned page-directory-pointer table referenced by this entry.
         */
        UINT64_t page_frame_number : 36;
#define PML4E_64_PAGE_FRAME_NUMBER_BIT                               12
#define PML4E_64_PAGE_FRAME_NUMBER_FLAG                              0xFFFFFFFFF000
#define PML4E_64_PAGE_FRAME_NUMBER_MASK                              0xFFFFFFFFF
#define PML4E_64_PAGE_FRAME_NUMBER(_)                                (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved2 : 4;

        /**
         * [Bits 62:52] Ignored.
         */
        UINT64_t ignored_2 : 11;
#define PML4E_64_IGNORED_2_BIT                                       52
#define PML4E_64_IGNORED_2_FLAG                                      0x7FF0000000000000
#define PML4E_64_IGNORED_2_MASK                                      0x7FF
#define PML4E_64_IGNORED_2(_)                                        (((_) >> 52) & 0x7FF)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 512-GByte region
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t execute_disable : 1;
#define PML4E_64_EXECUTE_DISABLE_BIT                                 63
#define PML4E_64_EXECUTE_DISABLE_FLAG                                0x8000000000000000
#define PML4E_64_EXECUTE_DISABLE_MASK                                0x01
#define PML4E_64_EXECUTE_DISABLE(_)                                  (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} pml4e;

/**
 * @brief Format of a 4-Level Page-Directory-Pointer-Table Entry (PDPTE) that Maps a 1-GByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 1-GByte page.
         */
        UINT64_t present : 1;
#define PDPTE_1GB_64_PRESENT_BIT                                     0
#define PDPTE_1GB_64_PRESENT_FLAG                                    0x01
#define PDPTE_1GB_64_PRESENT_MASK                                    0x01
#define PDPTE_1GB_64_PRESENT(_)                                      (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 1-GByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t write : 1;
#define PDPTE_1GB_64_WRITE_BIT                                       1
#define PDPTE_1GB_64_WRITE_FLAG                                      0x02
#define PDPTE_1GB_64_WRITE_MASK                                      0x01
#define PDPTE_1GB_64_WRITE(_)                                        (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 1-GByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t supervisor : 1;
#define PDPTE_1GB_64_SUPERVISOR_BIT                                  2
#define PDPTE_1GB_64_SUPERVISOR_FLAG                                 0x04
#define PDPTE_1GB_64_SUPERVISOR_MASK                                 0x01
#define PDPTE_1GB_64_SUPERVISOR(_)                                   (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 1-GByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_write_through : 1;
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_BIT                    3
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                   0x08
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_MASK                   0x01
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH(_)                     (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 1-GByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_cache_disable : 1;
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_BIT                    4
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                   0x10
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_MASK                   0x01
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE(_)                     (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 1-GByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64_t accessed : 1;
#define PDPTE_1GB_64_ACCESSED_BIT                                    5
#define PDPTE_1GB_64_ACCESSED_FLAG                                   0x20
#define PDPTE_1GB_64_ACCESSED_MASK                                   0x01
#define PDPTE_1GB_64_ACCESSED(_)                                     (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 1-GByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64_t dirty : 1;
#define PDPTE_1GB_64_DIRTY_BIT                                       6
#define PDPTE_1GB_64_DIRTY_FLAG                                      0x40
#define PDPTE_1GB_64_DIRTY_MASK                                      0x01
#define PDPTE_1GB_64_DIRTY(_)                                        (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Page size; must be 1 (otherwise, this entry references a page directory).
         */
        UINT64_t large_page : 1;
#define PDPTE_1GB_64_LARGE_PAGE_BIT                                  7
#define PDPTE_1GB_64_LARGE_PAGE_FLAG                                 0x80
#define PDPTE_1GB_64_LARGE_PAGE_MASK                                 0x01
#define PDPTE_1GB_64_LARGE_PAGE(_)                                   (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        UINT64_t global : 1;
#define PDPTE_1GB_64_GLOBAL_BIT                                      8
#define PDPTE_1GB_64_GLOBAL_FLAG                                     0x100
#define PDPTE_1GB_64_GLOBAL_MASK                                     0x01
#define PDPTE_1GB_64_GLOBAL(_)                                       (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT64_t ignored_1 : 3;
#define PDPTE_1GB_64_IGNORED_1_BIT                                   9
#define PDPTE_1GB_64_IGNORED_1_FLAG                                  0xE00
#define PDPTE_1GB_64_IGNORED_1_MASK                                  0x07
#define PDPTE_1GB_64_IGNORED_1(_)                                    (((_) >> 9) & 0x07)

        /**
         * [Bit 12] Indirectly determines the memory type used to access the 1-GByte page referenced by this entry.
         *
         * @note The PAT is supported on all processors that support 4-level paging.
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t pat : 1;
#define PDPTE_1GB_64_PAT_BIT                                         12
#define PDPTE_1GB_64_PAT_FLAG                                        0x1000
#define PDPTE_1GB_64_PAT_MASK                                        0x01
#define PDPTE_1GB_64_PAT(_)                                          (((_) >> 12) & 0x01)
        UINT64_t reserved1 : 17;

        /**
         * [Bits 47:30] Physical address of the 1-GByte page referenced by this entry.
         */
        UINT64_t page_frame_number : 18;
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_BIT                           30
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_FLAG                          0xFFFFC0000000
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_MASK                          0x3FFFF
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER(_)                            (((_) >> 30) & 0x3FFFF)
        UINT64_t reserved2 : 4;

        /**
         * [Bits 58:52] Ignored.
         */
        UINT64_t ignored_2 : 7;
#define PDPTE_1GB_64_IGNORED_2_BIT                                   52
#define PDPTE_1GB_64_IGNORED_2_FLAG                                  0x7F0000000000000
#define PDPTE_1GB_64_IGNORED_2_MASK                                  0x7F
#define PDPTE_1GB_64_IGNORED_2(_)                                    (((_) >> 52) & 0x7F)

        /**
         * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the page; ignored otherwise.
         *
         * @see Vol3A[4.6.2(Protection Keys)]
         */
        UINT64_t protection_key : 4;
#define PDPTE_1GB_64_PROTECTION_KEY_BIT                              59
#define PDPTE_1GB_64_PROTECTION_KEY_FLAG                             0x7800000000000000
#define PDPTE_1GB_64_PROTECTION_KEY_MASK                             0x0F
#define PDPTE_1GB_64_PROTECTION_KEY(_)                               (((_) >> 59) & 0x0F)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 1-GByte page
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t execute_disable : 1;
#define PDPTE_1GB_64_EXECUTE_DISABLE_BIT                             63
#define PDPTE_1GB_64_EXECUTE_DISABLE_FLAG                            0x8000000000000000
#define PDPTE_1GB_64_EXECUTE_DISABLE_MASK                            0x01
#define PDPTE_1GB_64_EXECUTE_DISABLE(_)                              (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} pdpte_1gb_64;

/**
 * @brief Format of a 4-Level Page-Directory-Pointer-Table Entry (PDPTE) that References a Page Directory
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to reference a page directory.
         */
        UINT64_t present : 1;
#define PDPTE_64_PRESENT_BIT                                         0
#define PDPTE_64_PRESENT_FLAG                                        0x01
#define PDPTE_64_PRESENT_MASK                                        0x01
#define PDPTE_64_PRESENT(_)                                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 1-GByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t write : 1;
#define PDPTE_64_WRITE_BIT                                           1
#define PDPTE_64_WRITE_FLAG                                          0x02
#define PDPTE_64_WRITE_MASK                                          0x01
#define PDPTE_64_WRITE(_)                                            (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 1-GByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t supervisor : 1;
#define PDPTE_64_SUPERVISOR_BIT                                      2
#define PDPTE_64_SUPERVISOR_FLAG                                     0x04
#define PDPTE_64_SUPERVISOR_MASK                                     0x01
#define PDPTE_64_SUPERVISOR(_)                                       (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page directory referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_write_through : 1;
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_BIT                        3
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                       0x08
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_MASK                       0x01
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH(_)                         (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page directory referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_cache_disable : 1;
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_BIT                        4
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                       0x10
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_MASK                       0x01
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE(_)                         (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64_t accessed : 1;
#define PDPTE_64_ACCESSED_BIT                                        5
#define PDPTE_64_ACCESSED_FLAG                                       0x20
#define PDPTE_64_ACCESSED_MASK                                       0x01
#define PDPTE_64_ACCESSED(_)                                         (((_) >> 5) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * [Bit 7] Page size; must be 0 (otherwise, this entry maps a 1-GByte page).
         */
        UINT64_t large_page : 1;
#define PDPTE_64_LARGE_PAGE_BIT                                      7
#define PDPTE_64_LARGE_PAGE_FLAG                                     0x80
#define PDPTE_64_LARGE_PAGE_MASK                                     0x01
#define PDPTE_64_LARGE_PAGE(_)                                       (((_) >> 7) & 0x01)

        /**
         * [Bits 11:8] Ignored.
         */
        UINT64_t ignored_1 : 4;
#define PDPTE_64_IGNORED_1_BIT                                       8
#define PDPTE_64_IGNORED_1_FLAG                                      0xF00
#define PDPTE_64_IGNORED_1_MASK                                      0x0F
#define PDPTE_64_IGNORED_1(_)                                        (((_) >> 8) & 0x0F)

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned page directory referenced by this entry.
         */
        UINT64_t page_frame_number : 36;
#define PDPTE_64_PAGE_FRAME_NUMBER_BIT                               12
#define PDPTE_64_PAGE_FRAME_NUMBER_FLAG                              0xFFFFFFFFF000
#define PDPTE_64_PAGE_FRAME_NUMBER_MASK                              0xFFFFFFFFF
#define PDPTE_64_PAGE_FRAME_NUMBER(_)                                (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved2 : 4;

        /**
         * [Bits 62:52] Ignored.
         */
        UINT64_t ignored_2 : 11;
#define PDPTE_64_IGNORED_2_BIT                                       52
#define PDPTE_64_IGNORED_2_FLAG                                      0x7FF0000000000000
#define PDPTE_64_IGNORED_2_MASK                                      0x7FF
#define PDPTE_64_IGNORED_2(_)                                        (((_) >> 52) & 0x7FF)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 1-GByte region
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t execute_disable : 1;
#define PDPTE_64_EXECUTE_DISABLE_BIT                                 63
#define PDPTE_64_EXECUTE_DISABLE_FLAG                                0x8000000000000000
#define PDPTE_64_EXECUTE_DISABLE_MASK                                0x01
#define PDPTE_64_EXECUTE_DISABLE(_)                                  (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} pdpte;

/**
 * @brief Format of a 4-Level Page-Directory Entry that Maps a 2-MByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 2-MByte page.
         */
        UINT64_t present : 1;
#define PDE_2MB_64_PRESENT_BIT                                       0
#define PDE_2MB_64_PRESENT_FLAG                                      0x01
#define PDE_2MB_64_PRESENT_MASK                                      0x01
#define PDE_2MB_64_PRESENT(_)                                        (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 2-MByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t write : 1;
#define PDE_2MB_64_WRITE_BIT                                         1
#define PDE_2MB_64_WRITE_FLAG                                        0x02
#define PDE_2MB_64_WRITE_MASK                                        0x01
#define PDE_2MB_64_WRITE(_)                                          (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 2-MByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t supervisor : 1;
#define PDE_2MB_64_SUPERVISOR_BIT                                    2
#define PDE_2MB_64_SUPERVISOR_FLAG                                   0x04
#define PDE_2MB_64_SUPERVISOR_MASK                                   0x01
#define PDE_2MB_64_SUPERVISOR(_)                                     (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 2-MByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_write_through : 1;
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_BIT                      3
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                     0x08
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_MASK                     0x01
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH(_)                       (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 2-MByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_cache_disable : 1;
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_BIT                      4
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                     0x10
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_MASK                     0x01
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE(_)                       (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 2-MByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64_t accessed : 1;
#define PDE_2MB_64_ACCESSED_BIT                                      5
#define PDE_2MB_64_ACCESSED_FLAG                                     0x20
#define PDE_2MB_64_ACCESSED_MASK                                     0x01
#define PDE_2MB_64_ACCESSED(_)                                       (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 2-MByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64_t dirty : 1;
#define PDE_2MB_64_DIRTY_BIT                                         6
#define PDE_2MB_64_DIRTY_FLAG                                        0x40
#define PDE_2MB_64_DIRTY_MASK                                        0x01
#define PDE_2MB_64_DIRTY(_)                                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Page size; must be 1 (otherwise, this entry references a page directory).
         */
        UINT64_t large_page : 1;
#define PDE_2MB_64_LARGE_PAGE_BIT                                    7
#define PDE_2MB_64_LARGE_PAGE_FLAG                                   0x80
#define PDE_2MB_64_LARGE_PAGE_MASK                                   0x01
#define PDE_2MB_64_LARGE_PAGE(_)                                     (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        UINT64_t global : 1;
#define PDE_2MB_64_GLOBAL_BIT                                        8
#define PDE_2MB_64_GLOBAL_FLAG                                       0x100
#define PDE_2MB_64_GLOBAL_MASK                                       0x01
#define PDE_2MB_64_GLOBAL(_)                                         (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT64_t ignored_1 : 3;
#define PDE_2MB_64_IGNORED_1_BIT                                     9
#define PDE_2MB_64_IGNORED_1_FLAG                                    0xE00
#define PDE_2MB_64_IGNORED_1_MASK                                    0x07
#define PDE_2MB_64_IGNORED_1(_)                                      (((_) >> 9) & 0x07)

        /**
         * [Bit 12] Indirectly determines the memory type used to access the 2-MByte page referenced by this entry.
         *
         * @note The PAT is supported on all processors that support 4-level paging.
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t pat : 1;
#define PDE_2MB_64_PAT_BIT                                           12
#define PDE_2MB_64_PAT_FLAG                                          0x1000
#define PDE_2MB_64_PAT_MASK                                          0x01
#define PDE_2MB_64_PAT(_)                                            (((_) >> 12) & 0x01)
        UINT64_t reserved1 : 8;

        /**
         * [Bits 47:21] Physical address of the 2-MByte page referenced by this entry.
         */
        UINT64_t page_frame_number : 27;
#define PDE_2MB_64_PAGE_FRAME_NUMBER_BIT                             21
#define PDE_2MB_64_PAGE_FRAME_NUMBER_FLAG                            0xFFFFFFE00000
#define PDE_2MB_64_PAGE_FRAME_NUMBER_MASK                            0x7FFFFFF
#define PDE_2MB_64_PAGE_FRAME_NUMBER(_)                              (((_) >> 21) & 0x7FFFFFF)
        UINT64_t reserved2 : 4;

        /**
         * [Bits 58:52] Ignored.
         */
        UINT64_t ignored_2 : 7;
#define PDE_2MB_64_IGNORED_2_BIT                                     52
#define PDE_2MB_64_IGNORED_2_FLAG                                    0x7F0000000000000
#define PDE_2MB_64_IGNORED_2_MASK                                    0x7F
#define PDE_2MB_64_IGNORED_2(_)                                      (((_) >> 52) & 0x7F)

        /**
         * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the page; ignored otherwise.
         *
         * @see Vol3A[4.6.2(Protection Keys)]
         */
        UINT64_t protection_key : 4;
#define PDE_2MB_64_PROTECTION_KEY_BIT                                59
#define PDE_2MB_64_PROTECTION_KEY_FLAG                               0x7800000000000000
#define PDE_2MB_64_PROTECTION_KEY_MASK                               0x0F
#define PDE_2MB_64_PROTECTION_KEY(_)                                 (((_) >> 59) & 0x0F)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 2-MByte page
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t execute_disable : 1;
#define PDE_2MB_64_EXECUTE_DISABLE_BIT                               63
#define PDE_2MB_64_EXECUTE_DISABLE_FLAG                              0x8000000000000000
#define PDE_2MB_64_EXECUTE_DISABLE_MASK                              0x01
#define PDE_2MB_64_EXECUTE_DISABLE(_)                                (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} pde_2mb_64;

/**
 * @brief Format of a 4-Level Page-Directory Entry that References a Page Table
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to reference a page table.
         */
        UINT64_t present : 1;
#define PDE_64_PRESENT_BIT                                           0
#define PDE_64_PRESENT_FLAG                                          0x01
#define PDE_64_PRESENT_MASK                                          0x01
#define PDE_64_PRESENT(_)                                            (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 2-MByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t write : 1;
#define PDE_64_WRITE_BIT                                             1
#define PDE_64_WRITE_FLAG                                            0x02
#define PDE_64_WRITE_MASK                                            0x01
#define PDE_64_WRITE(_)                                              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 2-MByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t supervisor : 1;
#define PDE_64_SUPERVISOR_BIT                                        2
#define PDE_64_SUPERVISOR_FLAG                                       0x04
#define PDE_64_SUPERVISOR_MASK                                       0x01
#define PDE_64_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page table referenced by this
         * entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_write_through : 1;
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page table referenced by this
         * entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_cache_disable : 1;
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64_t accessed : 1;
#define PDE_64_ACCESSED_BIT                                          5
#define PDE_64_ACCESSED_FLAG                                         0x20
#define PDE_64_ACCESSED_MASK                                         0x01
#define PDE_64_ACCESSED(_)                                           (((_) >> 5) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * [Bit 7] Page size; must be 0 (otherwise, this entry maps a 2-MByte page).
         */
        UINT64_t large_page : 1;
#define PDE_64_LARGE_PAGE_BIT                                        7
#define PDE_64_LARGE_PAGE_FLAG                                       0x80
#define PDE_64_LARGE_PAGE_MASK                                       0x01
#define PDE_64_LARGE_PAGE(_)                                         (((_) >> 7) & 0x01)

        /**
         * [Bits 11:8] Ignored.
         */
        UINT64_t ignored_1 : 4;
#define PDE_64_IGNORED_1_BIT                                         8
#define PDE_64_IGNORED_1_FLAG                                        0xF00
#define PDE_64_IGNORED_1_MASK                                        0x0F
#define PDE_64_IGNORED_1(_)                                          (((_) >> 8) & 0x0F)

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned page table referenced by this entry.
         */
        UINT64_t page_frame_number : 36;
#define PDE_64_PAGE_FRAME_NUMBER_BIT                                 12
#define PDE_64_PAGE_FRAME_NUMBER_FLAG                                0xFFFFFFFFF000
#define PDE_64_PAGE_FRAME_NUMBER_MASK                                0xFFFFFFFFF
#define PDE_64_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved2 : 4;

        /**
         * [Bits 62:52] Ignored.
         */
        UINT64_t ignored_2 : 11;
#define PDE_64_IGNORED_2_BIT                                         52
#define PDE_64_IGNORED_2_FLAG                                        0x7FF0000000000000
#define PDE_64_IGNORED_2_MASK                                        0x7FF
#define PDE_64_IGNORED_2(_)                                          (((_) >> 52) & 0x7FF)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 2-MByte region
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t execute_disable : 1;
#define PDE_64_EXECUTE_DISABLE_BIT                                   63
#define PDE_64_EXECUTE_DISABLE_FLAG                                  0x8000000000000000
#define PDE_64_EXECUTE_DISABLE_MASK                                  0x01
#define PDE_64_EXECUTE_DISABLE(_)                                    (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} pde;

/**
 * @brief Format of a 4-Level Page-Table Entry that Maps a 4-KByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 4-KByte page.
         */
        UINT64_t present : 1;
#define PTE_64_PRESENT_BIT                                           0
#define PTE_64_PRESENT_FLAG                                          0x01
#define PTE_64_PRESENT_MASK                                          0x01
#define PTE_64_PRESENT(_)                                            (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t write : 1;
#define PTE_64_WRITE_BIT                                             1
#define PTE_64_WRITE_FLAG                                            0x02
#define PTE_64_WRITE_MASK                                            0x01
#define PTE_64_WRITE(_)                                              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t supervisor : 1;
#define PTE_64_SUPERVISOR_BIT                                        2
#define PTE_64_SUPERVISOR_FLAG                                       0x04
#define PTE_64_SUPERVISOR_MASK                                       0x01
#define PTE_64_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 4-KByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_write_through : 1;
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 4-KByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t page_level_cache_disable : 1;
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64_t accessed : 1;
#define PTE_64_ACCESSED_BIT                                          5
#define PTE_64_ACCESSED_FLAG                                         0x20
#define PTE_64_ACCESSED_MASK                                         0x01
#define PTE_64_ACCESSED(_)                                           (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        UINT64_t dirty : 1;
#define PTE_64_DIRTY_BIT                                             6
#define PTE_64_DIRTY_FLAG                                            0x40
#define PTE_64_DIRTY_MASK                                            0x01
#define PTE_64_DIRTY(_)                                              (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Indirectly determines the memory type used to access the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        UINT64_t pat : 1;
#define PTE_64_PAT_BIT                                               7
#define PTE_64_PAT_FLAG                                              0x80
#define PTE_64_PAT_MASK                                              0x01
#define PTE_64_PAT(_)                                                (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        UINT64_t global : 1;
#define PTE_64_GLOBAL_BIT                                            8
#define PTE_64_GLOBAL_FLAG                                           0x100
#define PTE_64_GLOBAL_MASK                                           0x01
#define PTE_64_GLOBAL(_)                                             (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT64_t ignored_1 : 3;
#define PTE_64_IGNORED_1_BIT                                         9
#define PTE_64_IGNORED_1_FLAG                                        0xE00
#define PTE_64_IGNORED_1_MASK                                        0x07
#define PTE_64_IGNORED_1(_)                                          (((_) >> 9) & 0x07)

        /**
         * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
         */
        UINT64_t page_frame_number : 36;
#define PTE_64_PAGE_FRAME_NUMBER_BIT                                 12
#define PTE_64_PAGE_FRAME_NUMBER_FLAG                                0xFFFFFFFFF000
#define PTE_64_PAGE_FRAME_NUMBER_MASK                                0xFFFFFFFFF
#define PTE_64_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved1 : 4;

        /**
         * [Bits 58:52] Ignored.
         */
        UINT64_t ignored_2 : 7;
#define PTE_64_IGNORED_2_BIT                                         52
#define PTE_64_IGNORED_2_FLAG                                        0x7F0000000000000
#define PTE_64_IGNORED_2_MASK                                        0x7F
#define PTE_64_IGNORED_2(_)                                          (((_) >> 52) & 0x7F)

        /**
         * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the page; ignored otherwise.
         *
         * @see Vol3A[4.6.2(Protection Keys)]
         */
        UINT64_t protection_key : 4;
#define PTE_64_PROTECTION_KEY_BIT                                    59
#define PTE_64_PROTECTION_KEY_FLAG                                   0x7800000000000000
#define PTE_64_PROTECTION_KEY_MASK                                   0x0F
#define PTE_64_PROTECTION_KEY(_)                                     (((_) >> 59) & 0x0F)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 1-GByte page
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        UINT64_t execute_disable : 1;
#define PTE_64_EXECUTE_DISABLE_BIT                                   63
#define PTE_64_EXECUTE_DISABLE_FLAG                                  0x8000000000000000
#define PTE_64_EXECUTE_DISABLE_MASK                                  0x01
#define PTE_64_EXECUTE_DISABLE(_)                                    (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} pte;

/**
 * @brief Format of a common Page-Table Entry
 */
typedef union
{
    struct
    {
        UINT64_t present : 1;
#define PT_ENTRY_64_PRESENT_BIT                                      0
#define PT_ENTRY_64_PRESENT_FLAG                                     0x01
#define PT_ENTRY_64_PRESENT_MASK                                     0x01
#define PT_ENTRY_64_PRESENT(_)                                       (((_) >> 0) & 0x01)
        UINT64_t write : 1;
#define PT_ENTRY_64_WRITE_BIT                                        1
#define PT_ENTRY_64_WRITE_FLAG                                       0x02
#define PT_ENTRY_64_WRITE_MASK                                       0x01
#define PT_ENTRY_64_WRITE(_)                                         (((_) >> 1) & 0x01)
        UINT64_t supervisor : 1;
#define PT_ENTRY_64_SUPERVISOR_BIT                                   2
#define PT_ENTRY_64_SUPERVISOR_FLAG                                  0x04
#define PT_ENTRY_64_SUPERVISOR_MASK                                  0x01
#define PT_ENTRY_64_SUPERVISOR(_)                                    (((_) >> 2) & 0x01)
        UINT64_t page_level_write_through : 1;
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_BIT                     3
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                    0x08
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_MASK                    0x01
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH(_)                      (((_) >> 3) & 0x01)
        UINT64_t page_level_cache_disable : 1;
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_BIT                     4
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                    0x10
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_MASK                    0x01
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE(_)                      (((_) >> 4) & 0x01)
        UINT64_t accessed : 1;
#define PT_ENTRY_64_ACCESSED_BIT                                     5
#define PT_ENTRY_64_ACCESSED_FLAG                                    0x20
#define PT_ENTRY_64_ACCESSED_MASK                                    0x01
#define PT_ENTRY_64_ACCESSED(_)                                      (((_) >> 5) & 0x01)
        UINT64_t dirty : 1;
#define PT_ENTRY_64_DIRTY_BIT                                        6
#define PT_ENTRY_64_DIRTY_FLAG                                       0x40
#define PT_ENTRY_64_DIRTY_MASK                                       0x01
#define PT_ENTRY_64_DIRTY(_)                                         (((_) >> 6) & 0x01)
        UINT64_t large_page : 1;
#define PT_ENTRY_64_LARGE_PAGE_BIT                                   7
#define PT_ENTRY_64_LARGE_PAGE_FLAG                                  0x80
#define PT_ENTRY_64_LARGE_PAGE_MASK                                  0x01
#define PT_ENTRY_64_LARGE_PAGE(_)                                    (((_) >> 7) & 0x01)
        UINT64_t global : 1;
#define PT_ENTRY_64_GLOBAL_BIT                                       8
#define PT_ENTRY_64_GLOBAL_FLAG                                      0x100
#define PT_ENTRY_64_GLOBAL_MASK                                      0x01
#define PT_ENTRY_64_GLOBAL(_)                                        (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        UINT64_t ignored_1 : 3;
#define PT_ENTRY_64_IGNORED_1_BIT                                    9
#define PT_ENTRY_64_IGNORED_1_FLAG                                   0xE00
#define PT_ENTRY_64_IGNORED_1_MASK                                   0x07
#define PT_ENTRY_64_IGNORED_1(_)                                     (((_) >> 9) & 0x07)

        /**
         * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
         */
        UINT64_t page_frame_number : 36;
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_BIT                            12
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_FLAG                           0xFFFFFFFFF000
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_MASK                           0xFFFFFFFFF
#define PT_ENTRY_64_PAGE_FRAME_NUMBER(_)                             (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved1 : 4;

        /**
         * [Bits 58:52] Ignored.
         */
        UINT64_t ignored_2 : 7;
#define PT_ENTRY_64_IGNORED_2_BIT                                    52
#define PT_ENTRY_64_IGNORED_2_FLAG                                   0x7F0000000000000
#define PT_ENTRY_64_IGNORED_2_MASK                                   0x7F
#define PT_ENTRY_64_IGNORED_2(_)                                     (((_) >> 52) & 0x7F)
        UINT64_t protection_key : 4;
#define PT_ENTRY_64_PROTECTION_KEY_BIT                               59
#define PT_ENTRY_64_PROTECTION_KEY_FLAG                              0x7800000000000000
#define PT_ENTRY_64_PROTECTION_KEY_MASK                              0x0F
#define PT_ENTRY_64_PROTECTION_KEY(_)                                (((_) >> 59) & 0x0F)
        UINT64_t execute_disable : 1;
#define PT_ENTRY_64_EXECUTE_DISABLE_BIT                              63
#define PT_ENTRY_64_EXECUTE_DISABLE_FLAG                             0x8000000000000000
#define PT_ENTRY_64_EXECUTE_DISABLE_MASK                             0x01
#define PT_ENTRY_64_EXECUTE_DISABLE(_)                               (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} pt_entry_64;

/**
 * @defgroup paging_structures_entry_count_64 \
 *           Paging structures entry counts
 *
 * Paging structures entry counts.
 * @{
 */
#define PML4E_ENTRY_COUNT_64                                         0x00000200
#define PDPTE_ENTRY_COUNT_64                                         0x00000200
#define PDE_ENTRY_COUNT_64                                           0x00000200
#define PTE_ENTRY_COUNT_64                                           0x00000200
 /**
  * @}
  */

  /**
   * @}
   */

   /**
    * @}
    */

    /**
     * @defgroup segment_descriptors \
     *           Segment descriptors
     * @{
     */
     /**
      * @brief Pseudo-Descriptor Format (32-bit)
      *
      * @see Vol3A[3.5.1(Segment Descriptor Tables)] (reference)
      */
#pragma pack(push, 1)
typedef struct
{
    /**
     * Limit.
     */
    UINT16_t limit;

    /**
     * Base Address.
     */
    UINT32_t base_address;
} segment_descriptor_register_32;
#pragma pack(pop)

/**
 * @brief Pseudo-Descriptor Format (64-bit)
 *
 * @see Vol3A[3.5.1(Segment Descriptor Tables)] (reference)
 */
#pragma pack(push, 1)
typedef struct
{
    /**
     * Limit.
     */
    UINT16_t limit;

    /**
     * Base Address.
     */
    UINT64_t base_address;
} segment_descriptor_register_64;
#pragma pack(pop)

/**
 * @brief Segment access rights
 *
 * @see Vol2A[3.2(Instructions (A-L) | LAR-Load Access Rights Byte)] (reference)
 */
typedef union
{
    struct
    {
        UINT32_t reserved1 : 8;

        /**
         * @brief Type field
         *
         * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can be made to the segment and the
         * direction of growth. The interpretation of this field depends on whether the descriptor type flag specifies an
         * application (code or data) descriptor or a system descriptor. The encoding of the type field is different for code,
         * data, and system descriptors.
         *
         * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
         */
        UINT32_t type : 4;
#define SEGMENT_ACCESS_RIGHTS_TYPE_BIT                               8
#define SEGMENT_ACCESS_RIGHTS_TYPE_FLAG                              0xF00
#define SEGMENT_ACCESS_RIGHTS_TYPE_MASK                              0x0F
#define SEGMENT_ACCESS_RIGHTS_TYPE(_)                                (((_) >> 8) & 0x0F)

        /**
         * @brief S (descriptor type) flag
         *
         * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear) or a code or data segment (S
         * flag is set).
         */
        UINT32_t descriptor_type : 1;
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_BIT                    12
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_FLAG                   0x1000
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_MASK                   0x01
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE(_)                     (((_) >> 12) & 0x01)

        /**
         * @brief DPL (descriptor privilege level) field
         *
         * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range from 0 to 3, with 0 being the
         * most privileged level. The DPL is used to control access to the segment. See Section 5.5, "Privilege Levels", for a
         * description of the relationship of the DPL to the CPL of the executing code segment and the RPL of a segment selector.
         */
        UINT32_t descriptor_privilege_level : 2;
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_BIT         13
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_FLAG        0x6000
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_MASK        0x03
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL(_)          (((_) >> 13) & 0x03)

        /**
         * @brief P (segment-present) flag
         *
         * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear). If this flag is clear, the
         * processor generates a segment-not-present exception (\#NP) when a segment selector that points to the segment descriptor
         * is loaded into a segment register. Memory management software can use this flag to control which segments are actually
         * loaded into physical memory at a given time. It offers a control in addition to paging for managing virtual memory.
         */
        UINT32_t present : 1;
#define SEGMENT_ACCESS_RIGHTS_PRESENT_BIT                            15
#define SEGMENT_ACCESS_RIGHTS_PRESENT_FLAG                           0x8000
#define SEGMENT_ACCESS_RIGHTS_PRESENT_MASK                           0x01
#define SEGMENT_ACCESS_RIGHTS_PRESENT(_)                             (((_) >> 15) & 0x01)
        UINT32_t reserved2 : 4;

        /**
         * @brief Available bit
         *
         * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by system software.
         */
        UINT32_t system : 1;
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_BIT                             20
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_FLAG                            0x100000
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_MASK                            0x01
#define SEGMENT_ACCESS_RIGHTS_SYSTEM(_)                              (((_) >> 20) & 0x01)

        /**
         * @brief L (64-bit code segment) flag
         *
         * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor indicates whether a code segment
         * contains native 64-bit code. A value of 1 indicates instructions in this code segment are executed in 64-bit mode. A
         * value of 0 indicates the instructions in this code segment are executed in compatibility mode. If L-bit is set, then
         * D-bit must be cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved and should always be set to
         * 0.
         */
        UINT32_t long_mode : 1;
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_BIT                          21
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_FLAG                         0x200000
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_MASK                         0x01
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE(_)                           (((_) >> 21) & 0x01)

        /**
         * @brief D/B (default operation size/default stack pointer size and/or upper bound) flag
         *
         * [Bit 22] Performs different functions depending on whether the segment descriptor is an executable code segment, an
         * expand-down data segment, or a stack segment. (This flag should always be set to 1 for 32-bit code and data segments and
         * to 0 for 16-bit code and data segments.)
         * - Executable code segment. The flag is called the D flag and it indicates the default length for effective addresses and
         * operands referenced by instructions in the segment. If the flag is set, 32-bit addresses and 32-bit or 8-bit operands
         * are assumed; if it is clear, 16-bit addresses and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can
         * be used to select an operand size other than the default, and the prefix 67H can be used select an address size other
         * than the default.
         * - Stack segment (data segment pointed to by the SS register). The flag is called the B (big) flag and it specifies the
         * size of the stack pointer used for implicit stack operations (such as pushes, pops, and calls). If the flag is set, a
         * 32-bit stack pointer is used, which is stored in the 32-bit ESP register; if the flag is clear, a 16-bit stack pointer
         * is used, which is stored in the 16- bit SP register. If the stack segment is set up to be an expand-down data segment
         * (described in the next paragraph), the B flag also specifies the upper bound of the stack segment.
         * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound of the segment. If the flag
         * is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is clear, the upper bound is FFFFH (64 KBytes).
         */
        UINT32_t default_big : 1;
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_BIT                        22
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_FLAG                       0x400000
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_MASK                       0x01
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG(_)                         (((_) >> 22) & 0x01)

        /**
         * @brief G (granularity) flag
         *
         * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is clear, the segment limit is
         * interpreted in byte units; when flag is set, the segment limit is interpreted in 4-KByte units. (This flag does not
         * affect the granularity of the base address; it is always byte granular.) When the granularity flag is set, the twelve
         * least significant bits of an offset are not tested when checking the offset against the segment limit. For example, when
         * the granularity flag is set, a limit of 0 results in valid offsets from 0 to 4095.
         */
        UINT32_t granularity : 1;
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_BIT                        23
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_FLAG                       0x800000
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_MASK                       0x01
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY(_)                         (((_) >> 23) & 0x01)
        UINT32_t reserved3 : 8;
    };

    UINT32_t flags;
} segment_access_rights;

/**
 * @brief General Segment Descriptor (32-bit)
 *
 * A segment descriptor is a data structure in a GDT or LDT that provides the processor with the size and location of a
 * segment, as well as access control and status information. Segment descriptors are typically created by compilers,
 * linkers, loaders, or the operating system or executive, but not application programs.
 *
 * @see Vol3A[5.2(FIELDS AND FLAGS USED FOR SEGMENT-LEVEL AND PAGE-LEVEL PROTECTION)]
 * @see Vol3A[5.2.1(Code-Segment Descriptor in 64-bit Mode)]
 * @see Vol3A[5.8.3(Call Gates)]
 * @see Vol3A[6.11(IDT DESCRIPTORS)]
 * @see Vol3A[6.14.1(64-Bit Mode IDT)]
 * @see Vol3A[7.2.2(TSS Descriptor)]
 * @see Vol3A[7.2.3(TSS Descriptor in 64-bit mode)]
 * @see Vol3A[7.2.5(Task-Gate Descriptor)]
 * @see Vol3A[3.4.5(Segment Descriptors)] (reference)
 */
typedef struct
{
    /**
     * @brief Segment limit field (15:00)
     *
     * Specifies the size of the segment. The processor puts together the two segment limit fields to form a 20-bit value. The
     * processor interprets the segment limit in one of two ways, depending on the setting of the G (granularity) flag:
     * - If the granularity flag is clear, the segment size can range from 1 byte to 1 MByte, in byte increments.
     * - If the granularity flag is set, the segment size can range from 4 KBytes to 4 GBytes, in 4-KByte increments.
     * The processor uses the segment limit in two different ways, depending on whether the segment is an expand-up or an
     * expand-down segment. For expand-up segments, the offset in a logical address can range from 0 to the segment limit.
     * Offsets greater than the segment limit generate general-protection exceptions (\#GP, for all segments other than SS) or
     * stack-fault exceptions (\#SS for the SS segment). For expand-down segments, the segment limit has the reverse function;
     * the offset can range from the segment limit plus 1 to FFFFFFFFH or FFFFH, depending on the setting of the B flag.
     * Offsets less than or equal to the segment limit generate general-protection exceptions or stack-fault exceptions.
     * Decreasing the value in the segment limit field for an expanddown segment allocates new memory at the bottom of the
     * segment's address space, rather than at the top. IA-32 architecture stacks always grow downwards, making this mechanism
     * convenient for expandable stacks.
     *
     * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
     */
    UINT16_t segment_limit_low;

    /**
     * @brief Base address field (15:00)
     *
     * Defines the location of byte 0 of the segment within the 4-GByte linear address space. The processor puts together the
     * three base address fields to form a single 32-bit value. Segment base addresses should be aligned to 16-byte boundaries.
     * Although 16-byte alignment is not required, this alignment allows programs to maximize performance by aligning code and
     * data on 16-byte boundaries.
     */
    UINT16_t base_address_low;
    /**
     * @brief Segment descriptor fields
     */
    union
    {
        struct
        {
            /**
             * [Bits 7:0] Base address field (23:16); see description of $BASE_LOW for more details.
             */
            UINT32_t base_address_middle : 8;
#define SEGMENT__BASE_ADDRESS_MIDDLE_BIT                             0
#define SEGMENT__BASE_ADDRESS_MIDDLE_FLAG                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE_MASK                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE(_)                              (((_) >> 0) & 0xFF)

            /**
             * @brief Type field
             *
             * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can be made to the segment and the
             * direction of growth. The interpretation of this field depends on whether the descriptor type flag specifies an
             * application (code or data) descriptor or a system descriptor. The encoding of the type field is different for code,
             * data, and system descriptors.
             *
             * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
             */
            UINT32_t type : 4;
#define SEGMENT__TYPE_BIT                                            8
#define SEGMENT__TYPE_FLAG                                           0xF00
#define SEGMENT__TYPE_MASK                                           0x0F
#define SEGMENT__TYPE(_)                                             (((_) >> 8) & 0x0F)

            /**
             * @brief S (descriptor type) flag
             *
             * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear) or a code or data segment (S
             * flag is set).
             */
            UINT32_t descriptor_type : 1;
#define SEGMENT__DESCRIPTOR_TYPE_BIT                                 12
#define SEGMENT__DESCRIPTOR_TYPE_FLAG                                0x1000
#define SEGMENT__DESCRIPTOR_TYPE_MASK                                0x01
#define SEGMENT__DESCRIPTOR_TYPE(_)                                  (((_) >> 12) & 0x01)

            /**
             * @brief DPL (descriptor privilege level) field
             *
             * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range from 0 to 3, with 0 being the
             * most privileged level. The DPL is used to control access to the segment. See Section 5.5, "Privilege Levels", for a
             * description of the relationship of the DPL to the CPL of the executing code segment and the RPL of a segment selector.
             */
            UINT32_t descriptor_privilege_level : 2;
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT                      13
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG                     0x6000
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK                     0x03
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_)                       (((_) >> 13) & 0x03)

            /**
             * @brief P (segment-present) flag
             *
             * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear). If this flag is clear, the
             * processor generates a segment-not-present exception (\#NP) when a segment selector that points to the segment descriptor
             * is loaded into a segment register. Memory management software can use this flag to control which segments are actually
             * loaded into physical memory at a given time. It offers a control in addition to paging for managing virtual memory.
             */
            UINT32_t present : 1;
#define SEGMENT__PRESENT_BIT                                         15
#define SEGMENT__PRESENT_FLAG                                        0x8000
#define SEGMENT__PRESENT_MASK                                        0x01
#define SEGMENT__PRESENT(_)                                          (((_) >> 15) & 0x01)

            /**
             * [Bits 19:16] Segment limit field (19:16); see description of $LIMIT_LOW for more details.
             */
            UINT32_t segment_limit_high : 4;
#define SEGMENT__SEGMENT_LIMIT_HIGH_BIT                              16
#define SEGMENT__SEGMENT_LIMIT_HIGH_FLAG                             0xF0000
#define SEGMENT__SEGMENT_LIMIT_HIGH_MASK                             0x0F
#define SEGMENT__SEGMENT_LIMIT_HIGH(_)                               (((_) >> 16) & 0x0F)

            /**
             * @brief Available bit
             *
             * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by system software.
             */
            UINT32_t system : 1;
#define SEGMENT__SYSTEM_BIT                                          20
#define SEGMENT__SYSTEM_FLAG                                         0x100000
#define SEGMENT__SYSTEM_MASK                                         0x01
#define SEGMENT__SYSTEM(_)                                           (((_) >> 20) & 0x01)

            /**
             * @brief L (64-bit code segment) flag
             *
             * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor indicates whether a code segment
             * contains native 64-bit code. A value of 1 indicates instructions in this code segment are executed in 64-bit mode. A
             * value of 0 indicates the instructions in this code segment are executed in compatibility mode. If L-bit is set, then
             * D-bit must be cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved and should always be set to
             * 0.
             */
            UINT32_t long_mode : 1;
#define SEGMENT__LONG_MODE_BIT                                       21
#define SEGMENT__LONG_MODE_FLAG                                      0x200000
#define SEGMENT__LONG_MODE_MASK                                      0x01
#define SEGMENT__LONG_MODE(_)                                        (((_) >> 21) & 0x01)

            /**
             * @brief D/B (default operation size/default stack pointer size and/or upper bound) flag
             *
             * [Bit 22] Performs different functions depending on whether the segment descriptor is an executable code segment, an
             * expand-down data segment, or a stack segment. (This flag should always be set to 1 for 32-bit code and data segments and
             * to 0 for 16-bit code and data segments.)
             * - Executable code segment. The flag is called the D flag and it indicates the default length for effective addresses and
             * operands referenced by instructions in the segment. If the flag is set, 32-bit addresses and 32-bit or 8-bit operands
             * are assumed; if it is clear, 16-bit addresses and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can
             * be used to select an operand size other than the default, and the prefix 67H can be used select an address size other
             * than the default.
             * - Stack segment (data segment pointed to by the SS register). The flag is called the B (big) flag and it specifies the
             * size of the stack pointer used for implicit stack operations (such as pushes, pops, and calls). If the flag is set, a
             * 32-bit stack pointer is used, which is stored in the 32-bit ESP register; if the flag is clear, a 16-bit stack pointer
             * is used, which is stored in the 16- bit SP register. If the stack segment is set up to be an expand-down data segment
             * (described in the next paragraph), the B flag also specifies the upper bound of the stack segment.
             * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound of the segment. If the flag
             * is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is clear, the upper bound is FFFFH (64 KBytes).
             */
            UINT32_t default_big : 1;
#define SEGMENT__DEFAULT_BIG_BIT                                     22
#define SEGMENT__DEFAULT_BIG_FLAG                                    0x400000
#define SEGMENT__DEFAULT_BIG_MASK                                    0x01
#define SEGMENT__DEFAULT_BIG(_)                                      (((_) >> 22) & 0x01)

            /**
             * @brief G (granularity) flag
             *
             * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is clear, the segment limit is
             * interpreted in byte units; when flag is set, the segment limit is interpreted in 4-KByte units. (This flag does not
             * affect the granularity of the base address; it is always byte granular.) When the granularity flag is set, the twelve
             * least significant bits of an offset are not tested when checking the offset against the segment limit. For example, when
             * the granularity flag is set, a limit of 0 results in valid offsets from 0 to 4095.
             */
            UINT32_t granularity : 1;
#define SEGMENT__GRANULARITY_BIT                                     23
#define SEGMENT__GRANULARITY_FLAG                                    0x800000
#define SEGMENT__GRANULARITY_MASK                                    0x01
#define SEGMENT__GRANULARITY(_)                                      (((_) >> 23) & 0x01)

            /**
             * [Bits 31:24] Base address field (31:24); see description of $BASE_LOW for more details.
             */
            UINT32_t base_address_high : 8;
#define SEGMENT__BASE_ADDRESS_HIGH_BIT                               24
#define SEGMENT__BASE_ADDRESS_HIGH_FLAG                              0xFF000000
#define SEGMENT__BASE_ADDRESS_HIGH_MASK                              0xFF
#define SEGMENT__BASE_ADDRESS_HIGH(_)                                (((_) >> 24) & 0xFF)
        };

        UINT32_t flags;
    };

} segment_descriptor_32;

/**
 * @brief General Segment Descriptor (64-bit)
 *
 * A segment descriptor is a data structure in a GDT or LDT that provides the processor with the size and location of a
 * segment, as well as access control and status information. Segment descriptors are typically created by compilers,
 * linkers, loaders, or the operating system or executive, but not application programs.
 *
 * @see Vol3A[3.4.5(Segment Descriptors)] (reference)
 */
typedef struct
{
    /**
     * @brief Segment limit field (15:00)
     *
     * Specifies the size of the segment. The processor puts together the two segment limit fields to form a 20-bit value. The
     * processor interprets the segment limit in one of two ways, depending on the setting of the G (granularity) flag:
     * - If the granularity flag is clear, the segment size can range from 1 byte to 1 MByte, in byte increments.
     * - If the granularity flag is set, the segment size can range from 4 KBytes to 4 GBytes, in 4-KByte increments.
     * The processor uses the segment limit in two different ways, depending on whether the segment is an expand-up or an
     * expand-down segment. For expand-up segments, the offset in a logical address can range from 0 to the segment limit.
     * Offsets greater than the segment limit generate general-protection exceptions (\#GP, for all segments other than SS) or
     * stack-fault exceptions (\#SS for the SS segment). For expand-down segments, the segment limit has the reverse function;
     * the offset can range from the segment limit plus 1 to FFFFFFFFH or FFFFH, depending on the setting of the B flag.
     * Offsets less than or equal to the segment limit generate general-protection exceptions or stack-fault exceptions.
     * Decreasing the value in the segment limit field for an expanddown segment allocates new memory at the bottom of the
     * segment's address space, rather than at the top. IA-32 architecture stacks always grow downwards, making this mechanism
     * convenient for expandable stacks.
     *
     * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
     */
    UINT16_t segment_limit_low;

    /**
     * @brief Base address field (15:00)
     *
     * Defines the location of byte 0 of the segment within the 4-GByte linear address space. The processor puts together the
     * three base address fields to form a single 32-bit value. Segment base addresses should be aligned to 16-byte boundaries.
     * Although 16-byte alignment is not required, this alignment allows programs to maximize performance by aligning code and
     * data on 16-byte boundaries.
     */
    UINT16_t base_address_low;
    /**
     * @brief Segment descriptor fields
     */
    union
    {
        struct
        {
            /**
             * [Bits 7:0] Base address field (23:16); see description of $BASE_LOW for more details.
             */
            UINT32_t base_address_middle : 8;
#define SEGMENT__BASE_ADDRESS_MIDDLE_BIT                             0
#define SEGMENT__BASE_ADDRESS_MIDDLE_FLAG                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE_MASK                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE(_)                              (((_) >> 0) & 0xFF)

            /**
             * @brief Type field
             *
             * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can be made to the segment and the
             * direction of growth. The interpretation of this field depends on whether the descriptor type flag specifies an
             * application (code or data) descriptor or a system descriptor. The encoding of the type field is different for code,
             * data, and system descriptors.
             *
             * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
             */
            UINT32_t type : 4;
#define SEGMENT__TYPE_BIT                                            8
#define SEGMENT__TYPE_FLAG                                           0xF00
#define SEGMENT__TYPE_MASK                                           0x0F
#define SEGMENT__TYPE(_)                                             (((_) >> 8) & 0x0F)

            /**
             * @brief S (descriptor type) flag
             *
             * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear) or a code or data segment (S
             * flag is set).
             */
            UINT32_t descriptor_type : 1;
#define SEGMENT__DESCRIPTOR_TYPE_BIT                                 12
#define SEGMENT__DESCRIPTOR_TYPE_FLAG                                0x1000
#define SEGMENT__DESCRIPTOR_TYPE_MASK                                0x01
#define SEGMENT__DESCRIPTOR_TYPE(_)                                  (((_) >> 12) & 0x01)

            /**
             * @brief DPL (descriptor privilege level) field
             *
             * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range from 0 to 3, with 0 being the
             * most privileged level. The DPL is used to control access to the segment. See Section 5.5, "Privilege Levels", for a
             * description of the relationship of the DPL to the CPL of the executing code segment and the RPL of a segment selector.
             */
            UINT32_t descriptor_privilege_level : 2;
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT                      13
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG                     0x6000
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK                     0x03
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_)                       (((_) >> 13) & 0x03)

            /**
             * @brief P (segment-present) flag
             *
             * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear). If this flag is clear, the
             * processor generates a segment-not-present exception (\#NP) when a segment selector that points to the segment descriptor
             * is loaded into a segment register. Memory management software can use this flag to control which segments are actually
             * loaded into physical memory at a given time. It offers a control in addition to paging for managing virtual memory.
             */
            UINT32_t present : 1;
#define SEGMENT__PRESENT_BIT                                         15
#define SEGMENT__PRESENT_FLAG                                        0x8000
#define SEGMENT__PRESENT_MASK                                        0x01
#define SEGMENT__PRESENT(_)                                          (((_) >> 15) & 0x01)

            /**
             * [Bits 19:16] Segment limit field (19:16); see description of $LIMIT_LOW for more details.
             */
            UINT32_t segment_limit_high : 4;
#define SEGMENT__SEGMENT_LIMIT_HIGH_BIT                              16
#define SEGMENT__SEGMENT_LIMIT_HIGH_FLAG                             0xF0000
#define SEGMENT__SEGMENT_LIMIT_HIGH_MASK                             0x0F
#define SEGMENT__SEGMENT_LIMIT_HIGH(_)                               (((_) >> 16) & 0x0F)

            /**
             * @brief Available bit
             *
             * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by system software.
             */
            UINT32_t system : 1;
#define SEGMENT__SYSTEM_BIT                                          20
#define SEGMENT__SYSTEM_FLAG                                         0x100000
#define SEGMENT__SYSTEM_MASK                                         0x01
#define SEGMENT__SYSTEM(_)                                           (((_) >> 20) & 0x01)

            /**
             * @brief L (64-bit code segment) flag
             *
             * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor indicates whether a code segment
             * contains native 64-bit code. A value of 1 indicates instructions in this code segment are executed in 64-bit mode. A
             * value of 0 indicates the instructions in this code segment are executed in compatibility mode. If L-bit is set, then
             * D-bit must be cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved and should always be set to
             * 0.
             */
            UINT32_t long_mode : 1;
#define SEGMENT__LONG_MODE_BIT                                       21
#define SEGMENT__LONG_MODE_FLAG                                      0x200000
#define SEGMENT__LONG_MODE_MASK                                      0x01
#define SEGMENT__LONG_MODE(_)                                        (((_) >> 21) & 0x01)

            /**
             * @brief D/B (default operation size/default stack pointer size and/or upper bound) flag
             *
             * [Bit 22] Performs different functions depending on whether the segment descriptor is an executable code segment, an
             * expand-down data segment, or a stack segment. (This flag should always be set to 1 for 32-bit code and data segments and
             * to 0 for 16-bit code and data segments.)
             * - Executable code segment. The flag is called the D flag and it indicates the default length for effective addresses and
             * operands referenced by instructions in the segment. If the flag is set, 32-bit addresses and 32-bit or 8-bit operands
             * are assumed; if it is clear, 16-bit addresses and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can
             * be used to select an operand size other than the default, and the prefix 67H can be used select an address size other
             * than the default.
             * - Stack segment (data segment pointed to by the SS register). The flag is called the B (big) flag and it specifies the
             * size of the stack pointer used for implicit stack operations (such as pushes, pops, and calls). If the flag is set, a
             * 32-bit stack pointer is used, which is stored in the 32-bit ESP register; if the flag is clear, a 16-bit stack pointer
             * is used, which is stored in the 16- bit SP register. If the stack segment is set up to be an expand-down data segment
             * (described in the next paragraph), the B flag also specifies the upper bound of the stack segment.
             * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound of the segment. If the flag
             * is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is clear, the upper bound is FFFFH (64 KBytes).
             */
            UINT32_t default_big : 1;
#define SEGMENT__DEFAULT_BIG_BIT                                     22
#define SEGMENT__DEFAULT_BIG_FLAG                                    0x400000
#define SEGMENT__DEFAULT_BIG_MASK                                    0x01
#define SEGMENT__DEFAULT_BIG(_)                                      (((_) >> 22) & 0x01)

            /**
             * @brief G (granularity) flag
             *
             * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is clear, the segment limit is
             * interpreted in byte units; when flag is set, the segment limit is interpreted in 4-KByte units. (This flag does not
             * affect the granularity of the base address; it is always byte granular.) When the granularity flag is set, the twelve
             * least significant bits of an offset are not tested when checking the offset against the segment limit. For example, when
             * the granularity flag is set, a limit of 0 results in valid offsets from 0 to 4095.
             */
            UINT32_t granularity : 1;
#define SEGMENT__GRANULARITY_BIT                                     23
#define SEGMENT__GRANULARITY_FLAG                                    0x800000
#define SEGMENT__GRANULARITY_MASK                                    0x01
#define SEGMENT__GRANULARITY(_)                                      (((_) >> 23) & 0x01)

            /**
             * [Bits 31:24] Base address field (31:24); see description of $BASE_LOW for more details.
             */
            UINT32_t base_address_high : 8;
#define SEGMENT__BASE_ADDRESS_HIGH_BIT                               24
#define SEGMENT__BASE_ADDRESS_HIGH_FLAG                              0xFF000000
#define SEGMENT__BASE_ADDRESS_HIGH_MASK                              0xFF
#define SEGMENT__BASE_ADDRESS_HIGH(_)                                (((_) >> 24) & 0xFF)
        };

        UINT32_t flags;
    };


    /**
     * Base address field (32:63); see description of $BASE_LOW for more details.
     */
    UINT32_t base_address_upper;

    /**
     * Base address field (32:63); see description of $BASE_LOW for more details.
     */
    UINT32_t must_be_zero;
} segment_descriptor_64;

#define SEGMENT_DESCRIPTOR_TYPE_SYSTEM                               0x00000000
#define SEGMENT_DESCRIPTOR_TYPE_CODE_OR_DATA                         0x00000001
/**
 * @defgroup segment_descriptor_code_and_data_type \
 *           Code- and Data-Segment Descriptor Types
 *
 * When the S (descriptor type) flag in a segment descriptor is set, the descriptor is for either a code or a data segment.
 * The highest order bit of the type field (bit 11 of the second double word of the segment descriptor) then determines
 * whether the descriptor is for a data segment (clear) or a code segment (set). For data segments, the three low-order
 * bits of the type field (bits 8, 9, and 10) are interpreted as accessed (A), write-enable (W), and expansion-direction
 * (E). See Table 3-1 for a description of the encoding of the bits in the type field for code and data segments. Data
 * segments can be read-only or read/write segments, depending on the setting of the write-enable bit.
 *
 * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)] (reference)
 * @{
 */
 /**
  * Read-Only.
  */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY                       0x00000000

  /**
   * Data Read-Only, accessed.
   */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_ACCESSED              0x00000001

   /**
    * Data Read/Write.
    */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE                      0x00000002

    /**
     * Data Read/Write, accessed.
     */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_ACCESSED             0x00000003

     /**
      * Data Read-Only, expand-down.
      */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_EXPAND_DOWN           0x00000004

      /**
       * Data Read-Only, expand-down, accessed.
       */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_EXPAND_DOWN_ACCESSED  0x00000005

       /**
        * Data Read/Write, expand-down.
        */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_EXPAND_DOWN          0x00000006

        /**
         * Data Read/Write, expand-down, accessed.
         */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_EXPAND_DOWN_ACCESSED 0x00000007

         /**
          * Code Execute-Only.
          */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY                    0x00000008

          /**
           * Code Execute-Only, accessed.
           */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_ACCESSED           0x00000009

           /**
            * Code Execute/Read.
            */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ                    0x0000000A

            /**
             * Code Execute/Read, accessed.
             */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_ACCESSED           0x0000000B

             /**
              * Code Execute-Only, conforming.
              */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_CONFORMING         0x0000000C

              /**
               * Code Execute-Only, conforming, accessed.
               */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_CONFORMING_ACCESSED 0x0000000D

               /**
                * Code Execute/Read, conforming.
                */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_CONFORMING         0x0000000E

                /**
                 * Code Execute/Read, conforming, accessed.
                 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_CONFORMING_ACCESSED 0x0000000F
                 /**
                  * @}
                  */

                  /**
                   * @defgroup segment_descriptor_system_type \
                   *           System Descriptor Types
                   *
                   * When the S (descriptor type) flag in a segment descriptor is clear, the descriptor type is a system descriptor. The
                   * processor recognizes the following types of system descriptors:
                   * - Local descriptor-table (LDT) segment descriptor.
                   * - Task-state segment (TSS) descriptor.
                   * - Call-gate descriptor.
                   * - Interrupt-gate descriptor.
                   * - Trap-gate descriptor.
                   * - Task-gate descriptor.
                   * These descriptor types fall into two categories: system-segment descriptors and gate descriptors. Systemsegment
                   * descriptors point to system segments (LDT and TSS segments). Gate descriptors are in themselves "gates," which hold
                   * pointers to procedure entry points in code segments (call, interrupt, and trap gates) or which hold segment selectors
                   * for TSS's (task gates).
                   *
                   * @see Vol3A[3.5(SYSTEM DESCRIPTOR TYPES)] (reference)
                   * @{
                   */
                   /**
                    * - 32-Bit Mode: Reserved
                    * - IA-32e Mode: Reserved
                    */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_1                           0x00000000

                    /**
                     * - 32-Bit Mode: 16-bit TSS (Available)
                     * - IA-32e Mode: Reserved
                     */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_16_AVAILABLE                     0x00000001

                     /**
                      * - 32-Bit Mode: LDT
                      * - IA-32e Mode: LDT
                      */
#define SEGMENT_DESCRIPTOR_TYPE_LDT                                  0x00000002

                      /**
                       * - 32-Bit Mode: 16-bit TSS (Busy)
                       * - IA-32e Mode: Reserved
                       */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_16_BUSY                          0x00000003

                       /**
                        * - 32-Bit Mode: 16-bit Call Gate
                        * - IA-32e Mode: Reserved
                        */
#define SEGMENT_DESCRIPTOR_TYPE_CALL_GATE_16                         0x00000004

                        /**
                         * - 32-Bit Mode: Task Gate
                         * - IA-32e Mode: Reserved
                         */
#define SEGMENT_DESCRIPTOR_TYPE_TASK_GATE                            0x00000005

                         /**
                          * - 32-Bit Mode: 16-bit Interrupt Gate
                          * - IA-32e Mode: Reserved
                          */
#define SEGMENT_DESCRIPTOR_TYPE_INTERRUPT_GATE_16                    0x00000006

                          /**
                           * - 32-Bit Mode: 16-bit Trap Gate
                           * - IA-32e Mode: Reserved
                           */
#define SEGMENT_DESCRIPTOR_TYPE_TRAP_GATE_16                         0x00000007

                           /**
                            * - 32-Bit Mode: Reserved
                            * - IA-32e Mode: Reserved
                            */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_2                           0x00000008

                            /**
                             * - 32-Bit Mode: 32-bit TSS (Available)
                             * - IA-32e Mode: 64-bit TSS (Available)
                             */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_AVAILABLE                        0x00000009

                             /**
                              * - 32-Bit Mode: Reserved
                              * - IA-32e Mode: Reserved
                              */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_3                           0x0000000A

                              /**
                               * - 32-Bit Mode: 32-bit TSS (Busy)
                               * - IA-32e Mode: 64-bit TSS (Busy)
                               */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_BUSY                             0x0000000B

                               /**
                                * - 32-Bit Mode: 32-bit Call Gate
                                * - IA-32e Mode: 64-bit Call Gate
                                */
#define SEGMENT_DESCRIPTOR_TYPE_CALL_GATE                            0x0000000C

                                /**
                                 * - 32-Bit Mode: Reserved
                                 * - IA-32e Mode: Reserved
                                 */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_4                           0x0000000D

                                 /**
                                  * - 32-Bit Mode: 32-bit Interrupt Gate
                                  * - IA-32e Mode: 64-bit Interrupt Gate
                                  */
#define SEGMENT_DESCRIPTOR_TYPE_INTERRUPT_GATE                       0x0000000E

                                  /**
                                   * - 32-Bit Mode: 32-bit Trap Gate
                                   * - IA-32e Mode: 64-bit Trap Gate
                                   */
#define SEGMENT_DESCRIPTOR_TYPE_TRAP_GATE                            0x0000000F
                                   /**
                                    * @}
                                    */

                                    /**
                                     * @brief A segment selector is a 16-bit identifier for a segment. It does not point directly to the segment, but instead
                                     *        points to the segment descriptor that defines the segment
                                     *
                                     * @see Vol3A[3.4.2(Segment Selectors)] (reference)
                                     */
typedef union
{
    struct
    {
        /**
         * [Bits 1:0] Specifies the privilege level of the selector. The privilege level can range from 0 to 3, with 0 being the
         * most privileged level.
         *
         * @see Vol3A[5.5(Privilege Levels)]
         */
        UINT16_t request_privilege_level : 2;
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_BIT                 0
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_FLAG                0x03
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_MASK                0x03
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL(_)                  (((_) >> 0) & 0x03)

        /**
         * [Bit 2] Specifies the descriptor table to use: clearing this flag selects the GDT; setting this flag selects the current
         * LDT.
         */
        UINT16_t table : 1;
#define SEGMENT_SELECTOR_TABLE_BIT                                   2
#define SEGMENT_SELECTOR_TABLE_FLAG                                  0x04
#define SEGMENT_SELECTOR_TABLE_MASK                                  0x01
#define SEGMENT_SELECTOR_TABLE(_)                                    (((_) >> 2) & 0x01)

        /**
         * [Bits 15:3] Selects one of 8192 descriptors in the GDT or LDT. The processor multiplies the index value by 8 (the number
         * of bytes in a segment descriptor) and adds the result to the base address of the GDT or LDT (from the GDTR or LDTR
         * register, respectively).
         */
        UINT16_t index : 13;
#define SEGMENT_SELECTOR_INDEX_BIT                                   3
#define SEGMENT_SELECTOR_INDEX_FLAG                                  0xFFF8
#define SEGMENT_SELECTOR_INDEX_MASK                                  0x1FFF
#define SEGMENT_SELECTOR_INDEX(_)                                    (((_) >> 3) & 0x1FFF)
    };

    UINT16_t flags;
} segment_selector;

/**
 * @}
 */

 /**
  * @defgroup vmx \
  *           VMX
  * @{
  */
  /**
   * @{
   */
   /**
    * @defgroup vmx_basic_exit_reasons \
    *           VMX Basic Exit Reasons
    *
    * VMX Basic Exit Reasons.
    *
    * @see Vol3D[C(VMX BASIC EXIT REASONS)] (reference)
    * @{
    */
    /**
     * @brief Exception or non-maskable interrupt (NMI)
     *
     * Either:
     * -# Guest software caused an exception and the bit in the exception bitmap associated with exception's vector was 1. This
     * case includes executions of BOUND that cause \#BR, executions of INT1 (they cause \#DB), executions of INT3 (they cause
     * \#BP), executions of INTO that cause \#OF, and executions of UD0, UD1, and UD2 (they cause \#UD).
     * -# An NMI was delivered to the logical processor and the "NMI exiting" VM-execution control was 1.
     */
#define VMX_EXIT_REASON_EXCEPTION_OR_NMI                             0x00000000

     /**
      * @brief External interrupt
      *
      * An external interrupt arrived and the "external-interrupt exiting" VM-execution control was 1.
      */
#define VMX_EXIT_REASON_EXTERNAL_INTERRUPT                           0x00000001

      /**
       * @brief Triple fault
       *
       * The logical processor encountered an exception while attempting to call the double-fault handler and that exception did
       * not itself cause a VM exit due to the exception bitmap.
       */
#define VMX_EXIT_REASON_TRIPLE_FAULT                                 0x00000002

       /**
        * @brief INIT signal
        *
        * An INIT signal arrived.
        */
#define VMX_EXIT_REASON_INIT_SIGNAL                                  0x00000003

        /**
         * @brief Start-up IPI (SIPI)
         *
         * A SIPI arrived while the logical processor was in the "wait-for-SIPI" state.
         */
#define VMX_EXIT_REASON_STARTUP_IPI                                  0x00000004

         /**
          * @brief I/O system-management interrupt (SMI)
          *
          * An SMI arrived immediately after retirement of an I/O instruction and caused an SMM VM exit.
          *
          * @see Vol3C[34.15.2(SMM VM Exits)]
          */
#define VMX_EXIT_REASON_IO_SMI                                       0x00000005

          /**
           * @brief Other SMI
           *
           * An SMI arrived and caused an SMM VM exit but not immediately after retirement of an I/O instruction.
           *
           * @see Vol3C[34.15.2(SMM VM Exits)]
           */
#define VMX_EXIT_REASON_SMI                                          0x00000006

           /**
            * @brief Interrupt window exiting
            *
            * At the beginning of an instruction, RFLAGS.IF was 1; events were not blocked by STI or by MOV SS; and the
            * "interrupt-window exiting" VM-execution control was 1.
            */
#define VMX_EXIT_REASON_INTERRUPT_WINDOW                             0x00000007

            /**
             * @brief NMI window exiting
             *
             * At the beginning of an instruction, there was no virtual-NMI blocking; events were not blocked by MOV SS; and the
             * "NMI-window exiting" VM-execution control was 1.
             */
#define VMX_EXIT_REASON_NMI_WINDOW                                   0x00000008

             /**
              * @brief Task switch
              *
              * Guest software attempted a task switch.
              */
#define VMX_EXIT_REASON_TASK_SWITCH                                  0x00000009

              /**
               * @brief CPUID
               *
               * Guest software attempted to execute CPUID.
               */
#define VMX_EXIT_REASON_EXECUTE_CPUID                                0x0000000A

               /**
                * @brief GETSEC
                *
                * Guest software attempted to execute GETSEC.
                */
#define VMX_EXIT_REASON_EXECUTE_GETSEC                               0x0000000B

                /**
                 * @brief HLT
                 *
                 * Guest software attempted to execute HLT and the "HLT exiting" VM-execution control was 1.
                 */
#define VMX_EXIT_REASON_EXECUTE_HLT                                  0x0000000C

                 /**
                  * @brief INVD
                  *
                  * Guest software attempted to execute INVD.
                  */
#define VMX_EXIT_REASON_EXECUTE_INVD                                 0x0000000D

                  /**
                   * @brief INVLPG
                   *
                   * Guest software attempted to execute INVLPG and the "INVLPG exiting" VM-execution control was 1.
                   */
#define VMX_EXIT_REASON_EXECUTE_INVLPG                               0x0000000E

                   /**
                    * @brief RDPMC
                    *
                    * Guest software attempted to execute RDPMC and the "RDPMC exiting" VM-execution control was 1.
                    */
#define VMX_EXIT_REASON_EXECUTE_RDPMC                                0x0000000F

                    /**
                     * @brief RDTSC
                     *
                     * Guest software attempted to execute RDTSC and the "RDTSC exiting" VM-execution control was 1.
                     */
#define VMX_EXIT_REASON_EXECUTE_RDTSC                                0x00000010

                     /**
                      * @brief RSM in SMM
                      *
                      * Guest software attempted to execute RSM in SMM.
                      */
#define VMX_EXIT_REASON_EXECUTE_RSM_IN_SMM                           0x00000011

                      /**
                       * @brief VMCALL
                       *
                       * VMCALL was executed either by guest software (causing an ordinary VM exit) or by the executive monitor (causing an SMM
                       * VM exit).
                       *
                       * @see Vol3C[34.15.2(SMM VM Exits)]
                       */
#define VMX_EXIT_REASON_EXECUTE_VMCALL                               0x00000012

                       /**
                        * @brief VMCLEAR
                        *
                        * Guest software attempted to execute VMCLEAR.
                        */
#define VMX_EXIT_REASON_EXECUTE_VMCLEAR                              0x00000013

                        /**
                         * @brief VMLAUNCH
                         *
                         * Guest software attempted to execute VMLAUNCH.
                         */
#define VMX_EXIT_REASON_EXECUTE_VMLAUNCH                             0x00000014

                         /**
                          * @brief VMPTRLD
                          *
                          * Guest software attempted to execute VMPTRLD.
                          */
#define VMX_EXIT_REASON_EXECUTE_VMPTRLD                              0x00000015

                          /**
                           * @brief VMPTRST
                           *
                           * Guest software attempted to execute VMPTRST.
                           */
#define VMX_EXIT_REASON_EXECUTE_VMPTRST                              0x00000016

                           /**
                            * @brief VMREAD
                            *
                            * Guest software attempted to execute VMREAD.
                            */
#define VMX_EXIT_REASON_EXECUTE_VMREAD                               0x00000017

                            /**
                             * @brief VMRESUME
                             *
                             * Guest software attempted to execute VMRESUME.
                             */
#define VMX_EXIT_REASON_EXECUTE_VMRESUME                             0x00000018

                             /**
                              * @brief VMWRITE
                              *
                              * Guest software attempted to execute VMWRITE.
                              */
#define VMX_EXIT_REASON_EXECUTE_VMWRITE                              0x00000019

                              /**
                               * @brief VMXOFF
                               *
                               * Guest software attempted to execute VMXOFF.
                               */
#define VMX_EXIT_REASON_EXECUTE_VMXOFF                               0x0000001A

                               /**
                                * @brief VMXON
                                *
                                * Guest software attempted to execute VMXON.
                                */
#define VMX_EXIT_REASON_EXECUTE_VMXON                                0x0000001B

                                /**
                                 * @brief Control-register accesses
                                 *
                                 * Guest software attempted to access CR0, CR3, CR4, or CR8 using CLTS, LMSW, or MOV CR and the VM-execution control fields
                                 * indicate that a VM exit should occur. This basic exit reason is not used for trap-like VM exits following executions of
                                 * the MOV to CR8 instruction when the "use TPR shadow" VM-execution control is 1. Such VM exits instead use basic exit
                                 * reason 43.
                                 *
                                 * @see Vol3C[25.1(INSTRUCTIONS THAT CAUSE VM EXITS)]
                                 */
#define VMX_EXIT_REASON_MOV_CR                                       0x0000001C

                                 /**
                                  * @brief Debug-register accesses
                                  *
                                  * Guest software attempted a MOV to or from a debug register and the "MOV-DR exiting" VM-execution control was 1.
                                  */
#define VMX_EXIT_REASON_MOV_DR                                       0x0000001D

                                  /**
                                   * @brief I/O instruction
                                   *
                                   * Guest software attempted to execute an I/O instruction and either:
                                   * -# The "use I/O bitmaps" VM-execution control was 0 and the "unconditional I/O exiting" VM-execution control was 1.
                                   * -# The "use I/O bitmaps" VM-execution control was 1 and a bit in the I/O bitmap associated with one of the ports
                                   * accessed by the I/O instruction was 1.
                                   */
#define VMX_EXIT_REASON_EXECUTE_IO_INSTRUCTION                       0x0000001E

                                   /**
                                    * @brief RDMSR
                                    *
                                    * Guest software attempted to execute RDMSR and either:
                                    * -# The "use MSR bitmaps" VM-execution control was 0.
                                    * -# The value of RCX is neither in the range 00000000H - 00001FFFH nor in the range C0000000H - C0001FFFH.
                                    * -# The value of RCX was in the range 00000000H - 00001FFFH and the nth bit in read bitmap for low MSRs is 1, where n was
                                    * the value of RCX.
                                    * -# The value of RCX is in the range C0000000H - C0001FFFH and the nth bit in read bitmap for high MSRs is 1, where n is
                                    * the value of RCX & 00001FFFH.
                                    */
#define VMX_EXIT_REASON_EXECUTE_RDMSR                                0x0000001F

                                    /**
                                     * @brief WRMSR
                                     *
                                     * Guest software attempted to execute WRMSR and either:
                                     * -# The "use MSR bitmaps" VM-execution control was 0.
                                     * -# The value of RCX is neither in the range 00000000H - 00001FFFH nor in the range C0000000H - C0001FFFH.
                                     * -# The value of RCX was in the range 00000000H - 00001FFFH and the nth bit in write bitmap for low MSRs is 1, where n
                                     * was the value of RCX.
                                     * -# The value of RCX is in the range C0000000H - C0001FFFH and the nth bit in write bitmap for high MSRs is 1, where n is
                                     * the value of RCX & 00001FFFH.
                                     */
#define VMX_EXIT_REASON_EXECUTE_WRMSR                                0x00000020

                                     /**
                                      * @brief VM-entry failure due to invalid guest state
                                      *
                                      * A VM entry failed one of the checks identified in Section 26.3.1.
                                      */
#define VMX_EXIT_REASON_ERROR_INVALID_GUEST_STATE                    0x00000021

                                      /**
                                       * @brief VM-entry failure due to MSR loading
                                       *
                                       * A VM entry failed in an attempt to load MSRs. See Section 26.4.
                                       */
#define VMX_EXIT_REASON_ERROR_MSR_LOAD                               0x00000022

                                       /**
                                        * @brief Guest software executed MWAIT
                                        *
                                        * Guest software attempted to execute MWAIT and the "MWAIT exiting" VM-execution control was 1.
                                        */
#define VMX_EXIT_REASON_EXECUTE_MWAIT                                0x00000024

                                        /**
                                         * @brief VM-exit due to monitor trap flag
                                         *
                                         * A VM entry occurred due to the 1-setting of the "monitor trap flag" VM-execution control and injection of an MTF VM exit
                                         * as part of VM entry.
                                         *
                                         * @see Vol3C[25.5.2(Monitor Trap Flag)]
                                         */
#define VMX_EXIT_REASON_MONITOR_TRAP_FLAG                            0x00000025

                                         /**
                                          * @brief Guest software attempted to execute MONITOR
                                          *
                                          * Guest software attempted to execute MONITOR and the "MONITOR exiting" VM-execution control was 1.
                                          */
#define VMX_EXIT_REASON_EXECUTE_MONITOR                              0x00000027

                                          /**
                                           * @brief Guest software attempted to execute PAUSE
                                           *
                                           * Either guest software attempted to execute PAUSE and the "PAUSE exiting" VM-execution control was 1 or the "PAUSE-loop
                                           * exiting" VM-execution control was 1 and guest software executed a PAUSE loop with execution time exceeding PLE_Window.
                                           *
                                           * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
                                           */
#define VMX_EXIT_REASON_EXECUTE_PAUSE                                0x00000028

                                           /**
                                            * @brief VM-entry failure due to machine-check
                                            *
                                            * A machine-check event occurred during VM entry.
                                            *
                                            * @see Vol3C[26.8(MACHINE-CHECK EVENTS DURING VM ENTRY)]
                                            */
#define VMX_EXIT_REASON_ERROR_MACHINE_CHECK                          0x00000029

                                            /**
                                             * @brief TPR below threshold
                                             *
                                             * The logical processor determined that the value of bits 7:4 of the byte at offset 080H on the virtual-APIC page was
                                             * below that of the TPR threshold VM-execution control field while the "use TPR shadow" VMexecution control was 1 either
                                             * as part of TPR virtualization or VM entry.
                                             *
                                             * @see Vol3C[29.1.2(TPR Virtualization)]
                                             * @see Vol3C[26.6.7(VM Exits Induced by the TPR Threshold)]
                                             */
#define VMX_EXIT_REASON_TPR_BELOW_THRESHOLD                          0x0000002B

                                             /**
                                              * @brief APIC access
                                              *
                                              * Guest software attempted to access memory at a physical address on the APIC-access page and the "virtualize APIC
                                              * accesses" VM-execution control was 1.
                                              *
                                              * @see Vol3C[29.4(VIRTUALIZING MEMORY-MAPPED APIC ACCESSES)]
                                              */
#define VMX_EXIT_REASON_APIC_ACCESS                                  0x0000002C

                                              /**
                                               * @brief Virtualized EOI
                                               *
                                               * EOI virtualization was performed for a virtual interrupt whose vector indexed a bit set in the EOIexit bitmap.
                                               */
#define VMX_EXIT_REASON_VIRTUALIZED_EOI                              0x0000002D

                                               /**
                                                * @brief Access to GDTR or IDTR
                                                *
                                                * Guest software attempted to execute LGDT, LIDT, SGDT, or SIDT and the "descriptor-table exiting" VM-execution control
                                                * was 1.
                                                */
#define VMX_EXIT_REASON_GDTR_IDTR_ACCESS                             0x0000002E

                                                /**
                                                 * @brief Access to LDTR or TR
                                                 *
                                                 * Guest software attempted to execute LLDT, LTR, SLDT, or STR and the "descriptor-table exiting" VM-execution control was
                                                 * 1.
                                                 */
#define VMX_EXIT_REASON_LDTR_TR_ACCESS                               0x0000002F

                                                 /**
                                                  * @brief EPT violation
                                                  *
                                                  * An attempt to access memory with a guest-physical address was disallowed by the configuration of the EPT paging
                                                  * structures.
                                                  */
#define VMX_EXIT_REASON_EPT_VIOLATION                                0x00000030

                                                  /**
                                                   * @brief EPT misconfiguration
                                                   *
                                                   * An attempt to access memory with a guest-physical address encountered a misconfigured EPT paging-structure entry.
                                                   */
#define VMX_EXIT_REASON_EPT_MISCONFIGURATION                         0x00000031

                                                   /**
                                                    * @brief INVEPT
                                                    *
                                                    * Guest software attempted to execute INVEPT.
                                                    */
#define VMX_EXIT_REASON_EXECUTE_INVEPT                               0x00000032

                                                    /**
                                                     * @brief RDTSCP
                                                     *
                                                     * Guest software attempted to execute RDTSCP and the "enable RDTSCP" and "RDTSC exiting" VM-execution controls were both
                                                     * 1.
                                                     */
#define VMX_EXIT_REASON_EXECUTE_RDTSCP                               0x00000033

                                                     /**
                                                      * @brief VMX-preemption timer expired
                                                      *
                                                      * The preemption timer counted down to zero.
                                                      */
#define VMX_EXIT_REASON_VMX_PREEMPTION_TIMER_EXPIRED                 0x00000034

                                                      /**
                                                       * @brief INVVPID
                                                       *
                                                       * Guest software attempted to execute INVVPID.
                                                       */
#define VMX_EXIT_REASON_EXECUTE_INVVPID                              0x00000035

                                                       /**
                                                        * @brief WBINVD
                                                        *
                                                        * Guest software attempted to execute WBINVD and the "WBINVD exiting" VM-execution control was 1.
                                                        */
#define VMX_EXIT_REASON_EXECUTE_WBINVD                               0x00000036

                                                        /**
                                                         * @brief XSETBV - Guest software attempted to execute XSETBV
                                                         *
                                                         * Guest software attempted to execute XSETBV.
                                                         */
#define VMX_EXIT_REASON_EXECUTE_XSETBV                               0x00000037

                                                         /**
                                                          * @brief APIC write
                                                          *
                                                          * Guest software completed a write to the virtual-APIC page that must be virtualized by VMM software.
                                                          *
                                                          * @see Vol3C[29.4.3.3(APIC-Write VM Exits)]
                                                          */
#define VMX_EXIT_REASON_APIC_WRITE                                   0x00000038

                                                          /**
                                                           * @brief RDRAND
                                                           *
                                                           * Guest software attempted to execute RDRAND and the "RDRAND exiting" VM-execution control was 1.
                                                           */
#define VMX_EXIT_REASON_EXECUTE_RDRAND                               0x00000039

                                                           /**
                                                            * @brief INVPCID
                                                            *
                                                            * Guest software attempted to execute INVPCID and the "enable INVPCID" and "INVLPG exiting" VM-execution controls were
                                                            * both 1.
                                                            */
#define VMX_EXIT_REASON_EXECUTE_INVPCID                              0x0000003A

                                                            /**
                                                             * @brief VMFUNC
                                                             *
                                                             * Guest software invoked a VM function with the VMFUNC instruction and the VM function either was not enabled or generated
                                                             * a function-specific condition causing a VM exit.
                                                             */
#define VMX_EXIT_REASON_EXECUTE_VMFUNC                               0x0000003B

                                                             /**
                                                              * @brief ENCLS
                                                              *
                                                              * Guest software attempted to execute ENCLS and "enable ENCLS exiting" VM-execution control was 1 and either:
                                                              * -# EAX < 63 and the corresponding bit in the ENCLS-exiting bitmap is 1; or
                                                              * -# EAX >= 63 and bit 63 in the ENCLS-exiting bitmap is 1.
                                                              */
#define VMX_EXIT_REASON_EXECUTE_ENCLS                                0x0000003C

                                                              /**
                                                               * @brief RDSEED
                                                               *
                                                               * Guest software attempted to execute RDSEED and the "RDSEED exiting" VM-execution control was 1.
                                                               */
#define VMX_EXIT_REASON_EXECUTE_RDSEED                               0x0000003D

                                                               /**
                                                                * @brief Page-modification log full
                                                                *
                                                                * The processor attempted to create a page-modification log entry and the value of the PML index was not in the range
                                                                * 0-511.
                                                                */
#define VMX_EXIT_REASON_PAGE_MODIFICATION_LOG_FULL                   0x0000003E

                                                                /**
                                                                 * @brief XSAVES
                                                                 *
                                                                 * Guest software attempted to execute XSAVES, the "enable XSAVES/XRSTORS" was 1, and a bit was set in the logical-AND of
                                                                 * the following three values: EDX:EAX, the IA32_XSS MSR, and the XSS-exiting bitmap.
                                                                 */
#define VMX_EXIT_REASON_EXECUTE_XSAVES                               0x0000003F

                                                                 /**
                                                                  * @brief XRSTORS
                                                                  *
                                                                  * Guest software attempted to execute XRSTORS, the "enable XSAVES/XRSTORS" was 1, and a bit was set in the logical-AND of
                                                                  * the following three values: EDX:EAX, the IA32_XSS MSR, and the XSS-exiting bitmap.
                                                                  */
#define VMX_EXIT_REASON_EXECUTE_XRSTORS                              0x00000040
                                                                  /**
                                                                   * @}
                                                                   */

                                                                   /**
                                                                    * @defgroup vmx_instruction_error_numbers \
                                                                    *           VM-Instruction Error Numbers
                                                                    *
                                                                    * VM-Instruction Error Numbers.
                                                                    *
                                                                    * @see Vol3C[30.4(VM INSTRUCTION ERROR NUMBERS)] (reference)
                                                                    * @{
                                                                    */
                                                                    /**
                                                                     * VMCALL executed in VMX root operation.
                                                                     */
#define VMX_ERROR_VMCALL_IN_VMX_ROOT_OPERATION                       0x00000001

                                                                     /**
                                                                      * VMCLEAR with invalid physical address.
                                                                      */
#define VMX_ERROR_VMCLEAR_INVALID_PHYSICAL_ADDRESS                   0x00000002

                                                                      /**
                                                                       * VMCLEAR with VMXON pointer.
                                                                       */
#define VMX_ERROR_VMCLEAR_INVALID_VMXON_POINTER                      0x00000003

                                                                       /**
                                                                        * VMLAUNCH with non-clear VMCS.
                                                                        */
#define VMX_ERROR_VMLAUCH_NON_CLEAR_VMCS                             0x00000004

                                                                        /**
                                                                         * VMRESUME with non-launched VMCS.
                                                                         */
#define VMX_ERROR_VMRESUME_NON_LAUNCHED_VMCS                         0x00000005

                                                                         /**
                                                                          * VMRESUME after VMXOFF (VMXOFF and VMXON between VMLAUNCH and VMRESUME).
                                                                          */
#define VMX_ERROR_VMRESUME_AFTER_VMXOFF                              0x00000006

                                                                          /**
                                                                           * VM entry with invalid control field(s).
                                                                           */
#define VMX_ERROR_VMENTRY_INVALID_CONTROL_FIELDS                     0x00000007

                                                                           /**
                                                                            * VM entry with invalid host-state field(s).
                                                                            */
#define VMX_ERROR_VMENTRY_INVALID_HOST_STATE                         0x00000008

                                                                            /**
                                                                             * VMPTRLD with invalid physical address.
                                                                             */
#define VMX_ERROR_VMPTRLD_INVALID_PHYSICAL_ADDRESS                   0x00000009

                                                                             /**
                                                                              * VMPTRLD with VMXON pointer.
                                                                              */
#define VMX_ERROR_VMPTRLD_VMXON_POINTER                              0x0000000A

                                                                              /**
                                                                               * VMPTRLD with incorrect VMCS revision identifier.
                                                                               */
#define VMX_ERROR_VMPTRLD_INCORRECT_VMCS_REVISION_ID                 0x0000000B

                                                                               /**
                                                                                * VMREAD/VMWRITE from/to unsupported VMCS component.
                                                                                */
#define VMX_ERROR_VMREAD_VMWRITE_INVALID_COMPONENT                   0x0000000C

                                                                                /**
                                                                                 * VMWRITE to read-only VMCS component.
                                                                                 */
#define VMX_ERROR_VMWRITE_READONLY_COMPONENT                         0x0000000D

                                                                                 /**
                                                                                  * VMXON executed in VMX root operation.
                                                                                  */
#define VMX_ERROR_VMXON_IN_VMX_ROOT_OP                               0x0000000F

                                                                                  /**
                                                                                   * VM entry with invalid executive-VMCS pointer.
                                                                                   */
#define VMX_ERROR_VMENTRY_INVALID_VMCS_EXECUTIVE_POINTER             0x00000010

                                                                                   /**
                                                                                    * VM entry with non-launched executive VMCS.
                                                                                    */
#define VMX_ERROR_VMENTRY_NON_LAUNCHED_EXECUTIVE_VMCS                0x00000011

                                                                                    /**
                                                                                     * VM entry with executive-VMCS pointer not VMXON pointer (when attempting to deactivate the dual-monitor treatment of SMIs
                                                                                     * and SMM).
                                                                                     */
#define VMX_ERROR_VMENTRY_EXECUTIVE_VMCS_PTR                         0x00000012

                                                                                     /**
                                                                                      * VMCALL with non-clear VMCS (when attempting to activate the dual-monitor treatment of SMIs and SMM).
                                                                                      */
#define VMX_ERROR_VMCALL_NON_CLEAR_VMCS                              0x00000013

                                                                                      /**
                                                                                       * VMCALL with invalid VM-exit control fields.
                                                                                       */
#define VMX_ERROR_VMCALL_INVALID_VMEXIT_FIELDS                       0x00000014

                                                                                       /**
                                                                                        * VMCALL with incorrect MSEG revision identifier (when attempting to activate the dual-monitor treatment of SMIs and SMM).
                                                                                        */
#define VMX_ERROR_VMCALL_INVALID_MSEG_REVISION_ID                    0x00000016

                                                                                        /**
                                                                                         * VMXOFF under dual-monitor treatment of SMIs and SMM.
                                                                                         */
#define VMX_ERROR_VMXOFF_DUAL_MONITOR                                0x00000017

                                                                                         /**
                                                                                          * VMCALL with invalid SMM-monitor features (when attempting to activate the dual-monitor treatment of SMIs and SMM).
                                                                                          */
#define VMX_ERROR_VMCALL_INVALID_SMM_MONITOR                         0x00000018

                                                                                          /**
                                                                                           * VM entry with invalid VM-execution control fields in executive VMCS (when attempting to return from SMM).
                                                                                           */
#define VMX_ERROR_VMENTRY_INVALID_VM_EXECUTION_CONTROL               0x00000019

                                                                                           /**
                                                                                            * VM entry with events blocked by MOV SS.
                                                                                            */
#define VMX_ERROR_VMENTRY_MOV_SS                                     0x0000001A

                                                                                            /**
                                                                                             * Invalid operand to INVEPT/INVVPID.
                                                                                             */
#define VMX_ERROR_INVEPT_INVVPID_INVALID_OPERAND                     0x0000001C
                                                                                             /**
                                                                                              * @}
                                                                                              */

                                                                                              /**
                                                                                               * @defgroup vmx_exceptions \
                                                                                               *           Virtualization Exceptions
                                                                                               *
                                                                                               * Virtualization Exceptions.
                                                                                               *
                                                                                               * @see Vol3C[25.5.6(Virtualization Exceptions)] (reference)
                                                                                               * @{
                                                                                               */
typedef struct
{
    /**
     * The 32-bit value that would have been saved into the VMCS as an exit reason had a VM exit occurred instead of the
     * virtualization exception. For EPT violations, this value is 48 (00000030H).
     */
    UINT32_t reason;

    /**
     * FFFFFFFFH
     */
    UINT32_t exception_mask;

    /**
     * The 64-bit value that would have been saved into the VMCS as an exit qualification had a VM exit occurred instead of the
     * virtualization exception.
     */
    UINT64_t exit;

    /**
     * The 64-bit value that would have been saved into the VMCS as a guest-linear address had a VM exit occurred instead of
     * the virtualization exception.
     */
    UINT64_t guest_linear_address;

    /**
     * The 64-bit value that would have been saved into the VMCS as a guest-physical address had a VM exit occurred instead of
     * the virtualization exception.
     */
    UINT64_t guest_physical_address;

    /**
     * The current 16-bit value of the EPTP index VM-execution control.
     *
     * @see Vol3C[24.6.18(Controls for Virtualization Exceptions)]
     * @see Vol3C[25.5.5.3(EPTP Switching)]
     */
    UINT16_t current_eptp_index;
} vmx_virtualization_exception_information;

/**
 * @}
 */

 /**
  * @defgroup vmx_basic_exit_information \
  *           Basic VM-Exit Information
  *
  * Basic VM-Exit Information.
  *
  * @see Vol3C[27.2.1(Basic VM-Exit Information)] (reference)
  * @{
  */
  /**
   * @brief Exit Qualification for Debug Exceptions
   */
typedef union
{
    struct
    {
        /**
         * @brief B0 - B3
         *
         * [Bits 3:0] When set, each of these bits indicates that the corresponding breakpoint condition was met. Any of these bits
         * may be set even if its corresponding enabling bit in DR7 is not set.
         */
        UINT64_t breakpoint_condition : 4;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_BIT 0
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_FLAG 0x0F
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_MASK 0x0F
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION(_) (((_) >> 0) & 0x0F)
        UINT64_t reserved1 : 9;

        /**
         * @brief BD
         *
         * [Bit 13] When set, this bit indicates that the cause of the debug exception is "debug register access detected."
         */
        UINT64_t debug_register_access_detected : 1;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_BIT 13
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_FLAG 0x2000
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_MASK 0x01
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED(_) (((_) >> 13) & 0x01)

        /**
         * @brief BS
         *
         * [Bit 14] When set, this bit indicates that the cause of the debug exception is either the execution of a single
         * instruction (if RFLAGS.TF = 1 and IA32_DEBUGCTL.BTF = 0) or a taken branch (if RFLAGS.TF = DEBUGCTL.BTF = 1).
         */
        UINT64_t single_instruction : 1;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_BIT 14
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_FLAG 0x4000
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION(_) (((_) >> 14) & 0x01)
        UINT64_t reserved2 : 49;
    };

    UINT64_t flags;
} vmx_exit_qualification_debug_exception;

/**
 * @brief Exit Qualification for Task Switch
 */
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] Selector of task-state segment (TSS) to which the guest attempted to switch.
         */
        UINT64_t selector : 16;
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_BIT              0
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_FLAG             0xFFFF
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_MASK             0xFFFF
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR(_)               (((_) >> 0) & 0xFFFF)
        UINT64_t reserved1 : 14;

        /**
         * [Bits 31:30] Source of task switch initiation.
         */
        UINT64_t source : 2;
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_BIT                30
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_FLAG               0xC0000000
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_MASK               0x03
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE(_)                 (((_) >> 30) & 0x03)
#define VMX_EXIT_QUALIFICATION_TYPE_CALL_INSTRUCTION                 0x00000000
#define VMX_EXIT_QUALIFICATION_TYPE_IRET_INSTRUCTION                 0x00000001
#define VMX_EXIT_QUALIFICATION_TYPE_JMP_INSTRUCTION                  0x00000002
#define VMX_EXIT_QUALIFICATION_TYPE_TASK_GATE_IN_IDT                 0x00000003
        UINT64_t reserved2 : 32;
    };

    UINT64_t flags;
} vmx_exit_qualification_task_switch;

/**
 * @brief Exit Qualification for Control-Register Accesses
 */
typedef union
{
    struct
    {
        /**
         * [Bits 3:0] Number of control register (0 for CLTS and LMSW). Bit 3 is always 0 on processors that do not support Intel
         * 64 architecture as they do not support CR8.
         */
        UINT64_t control_register : 4;
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_BIT           0
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_FLAG          0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_MASK          0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER(_)            (((_) >> 0) & 0x0F)
#define VMX_EXIT_QUALIFICATION_REGISTER_CR0                          0x00000000
#define VMX_EXIT_QUALIFICATION_REGISTER_CR2                          0x00000002
#define VMX_EXIT_QUALIFICATION_REGISTER_CR3                          0x00000003
#define VMX_EXIT_QUALIFICATION_REGISTER_CR4                          0x00000004
#define VMX_EXIT_QUALIFICATION_REGISTER_CR8                          0x00000008

        /**
         * [Bits 5:4] Access type.
         */
        UINT64_t access_type : 2;
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_BIT                4
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_FLAG               0x30
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_MASK               0x03
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE(_)                 (((_) >> 4) & 0x03)
#define VMX_EXIT_QUALIFICATION_ACCESS_MOV_TO_CR                      0x00000000
#define VMX_EXIT_QUALIFICATION_ACCESS_MOV_FROM_CR                    0x00000001
#define VMX_EXIT_QUALIFICATION_ACCESS_CLTS                           0x00000002
#define VMX_EXIT_QUALIFICATION_ACCESS_LMSW                           0x00000003

        /**
         * [Bit 6] LMSW operand type. For CLTS and MOV CR, cleared to 0.
         */
        UINT64_t lmsw_operand_type : 1;
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_BIT          6
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_FLAG         0x40
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_MASK         0x01
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE(_)           (((_) >> 6) & 0x01)
#define VMX_EXIT_QUALIFICATION_LMSW_OP_REGISTER                      0x00000000
#define VMX_EXIT_QUALIFICATION_LMSW_OP_MEMORY                        0x00000001
        UINT64_t reserved1 : 1;

        /**
         * [Bits 11:8] For MOV CR, the general-purpose register.
         */
        UINT64_t general_purpose_register : 4;
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_BIT   8
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_FLAG  0xF00
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_MASK  0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER(_)    (((_) >> 8) & 0x0F)
#define VMX_EXIT_QUALIFICATION_GENREG_RAX                            0x00000000
#define VMX_EXIT_QUALIFICATION_GENREG_RCX                            0x00000001
#define VMX_EXIT_QUALIFICATION_GENREG_RDX                            0x00000002
#define VMX_EXIT_QUALIFICATION_GENREG_RBX                            0x00000003
#define VMX_EXIT_QUALIFICATION_GENREG_RSP                            0x00000004
#define VMX_EXIT_QUALIFICATION_GENREG_RBP                            0x00000005
#define VMX_EXIT_QUALIFICATION_GENREG_RSI                            0x00000006
#define VMX_EXIT_QUALIFICATION_GENREG_RDI                            0x00000007
#define VMX_EXIT_QUALIFICATION_GENREG_R8                             0x00000008
#define VMX_EXIT_QUALIFICATION_GENREG_R9                             0x00000009
#define VMX_EXIT_QUALIFICATION_GENREG_R10                            0x0000000A
#define VMX_EXIT_QUALIFICATION_GENREG_R11                            0x0000000B
#define VMX_EXIT_QUALIFICATION_GENREG_R12                            0x0000000C
#define VMX_EXIT_QUALIFICATION_GENREG_R13                            0x0000000D
#define VMX_EXIT_QUALIFICATION_GENREG_R14                            0x0000000E
#define VMX_EXIT_QUALIFICATION_GENREG_R15                            0x0000000F
        UINT64_t reserved2 : 4;

        /**
         * [Bits 31:16] For LMSW, the LMSW source data. For CLTS and MOV CR, cleared to 0.
         */
        UINT64_t lmsw_source_data : 16;
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_BIT           16
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_FLAG          0xFFFF0000
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_MASK          0xFFFF
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA(_)            (((_) >> 16) & 0xFFFF)
        UINT64_t reserved3 : 32;
    };

    UINT64_t flags;
} vmx_exit_qualification_mov_cr;

/**
 * @brief Exit Qualification for MOV DR
 */
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] Number of debug register.
         */
        UINT64_t debug_register : 3;
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_BIT             0
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_FLAG            0x07
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_MASK            0x07
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER(_)              (((_) >> 0) & 0x07)
#define VMX_EXIT_QUALIFICATION_REGISTER_DR0                          0x00000000
#define VMX_EXIT_QUALIFICATION_REGISTER_DR1                          0x00000001
#define VMX_EXIT_QUALIFICATION_REGISTER_DR2                          0x00000002
#define VMX_EXIT_QUALIFICATION_REGISTER_DR3                          0x00000003
#define VMX_EXIT_QUALIFICATION_REGISTER_DR6                          0x00000006
#define VMX_EXIT_QUALIFICATION_REGISTER_DR7                          0x00000007
        UINT64_t reserved1 : 1;

        /**
         * [Bit 4] Direction of access (0 = MOV to DR; 1 = MOV from DR).
         */
        UINT64_t direction_of_access : 1;
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_BIT        4
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_FLAG       0x10
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_MASK       0x01
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS(_)         (((_) >> 4) & 0x01)
#define VMX_EXIT_QUALIFICATION_DIRECTION_MOV_TO_DR                   0x00000000
#define VMX_EXIT_QUALIFICATION_DIRECTION_MOV_FROM_DR                 0x00000001
        UINT64_t reserved2 : 3;

        /**
         * [Bits 11:8] General-purpose register.
         */
        UINT64_t general_purpose_register : 4;
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_BIT   8
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_FLAG  0xF00
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_MASK  0x0F
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER(_)    (((_) >> 8) & 0x0F)
        UINT64_t reserved3 : 52;
    };

    UINT64_t flags;
} vmx_exit_qualification_mov_dr;

/**
 * @brief Exit Qualification for I/O Instructions
 */
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] Size of access.
         */
        UINT64_t size_of_access : 3;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_BIT     0
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_FLAG    0x07
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_MASK    0x07
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS(_)      (((_) >> 0) & 0x07)
#define VMX_EXIT_QUALIFICATION_WIDTH_1UINT8                          0x00000000
#define VMX_EXIT_QUALIFICATION_WIDTH_2UINT8                          0x00000001
#define VMX_EXIT_QUALIFICATION_WIDTH_4UINT8                          0x00000003

        /**
         * [Bit 3] Direction of the attempted access (0 = OUT, 1 = IN).
         */
        UINT64_t direction_of_access : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_BIT 3
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_FLAG 0x08
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS(_) (((_) >> 3) & 0x01)
#define VMX_EXIT_QUALIFICATION_DIRECTION_OUT                         0x00000000
#define VMX_EXIT_QUALIFICATION_DIRECTION_IN                          0x00000001

        /**
         * [Bit 4] String instruction (0 = not string; 1 = string).
         */
        UINT64_t string_instruction : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_BIT 4
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_FLAG 0x10
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION(_)  (((_) >> 4) & 0x01)
#define VMX_EXIT_QUALIFICATION_IS_STRING_NOT_STRING                  0x00000000
#define VMX_EXIT_QUALIFICATION_IS_STRING_STRING                      0x00000001

        /**
         * [Bit 5] REP prefixed (0 = not REP; 1 = REP).
         */
        UINT64_t rep_prefixed : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_BIT       5
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_FLAG      0x20
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_MASK      0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED(_)        (((_) >> 5) & 0x01)
#define VMX_EXIT_QUALIFICATION_IS_REP_NOT_REP                        0x00000000
#define VMX_EXIT_QUALIFICATION_IS_REP_REP                            0x00000001

        /**
         * [Bit 6] Operand encoding (0 = DX, 1 = immediate).
         */
        UINT64_t operand_encoding : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_BIT   6
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_FLAG  0x40
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_MASK  0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING(_)    (((_) >> 6) & 0x01)
#define VMX_EXIT_QUALIFICATION_ENCODING_DX                           0x00000000
#define VMX_EXIT_QUALIFICATION_ENCODING_IMMEDIATE                    0x00000001
        UINT64_t reserved1 : 9;

        /**
         * [Bits 31:16] Port number (as specified in DX or in an immediate operand).
         */
        UINT64_t port_number : 16;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_BIT        16
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_FLAG       0xFFFF0000
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_MASK       0xFFFF
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER(_)         (((_) >> 16) & 0xFFFF)
        UINT64_t reserved2 : 32;
    };

    UINT64_t flags;
} vmx_exit_qualification_io_instruction;

/**
 * @brief Exit Qualification for APIC-Access VM Exits from Linear Accesses and Guest-Physical Accesses
 */
typedef union
{
    struct
    {
        /**
         * [Bits 11:0] - If the APIC-access VM exit is due to a linear access, the offset of access within the APIC page.
         * - Undefined if the APIC-access VM exit is due a guest-physical access.
         */
        UINT64_t page_offset : 12;
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_BIT           0
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_FLAG          0xFFF
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_MASK          0xFFF
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET(_)            (((_) >> 0) & 0xFFF)

        /**
         * [Bits 15:12] Access type.
         */
        UINT64_t access_type : 4;
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_BIT           12
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_FLAG          0xF000
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_MASK          0x0F
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE(_)            (((_) >> 12) & 0x0F)
        /**
         * Linear access for a data read during instruction execution.
         */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_READ                      0x00000000

         /**
          * Linear access for a data write during instruction execution.
          */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_WRITE                     0x00000001

          /**
           * Linear access for an instruction fetch.
           */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_INSTRUCTION_FETCH         0x00000002

           /**
            * Linear access (read or write) during event delivery.
            */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_EVENT_DELIVERY            0x00000003

            /**
             * Guest-physical access during event delivery.
             */
#define VMX_EXIT_QUALIFICATION_TYPE_PHYSICAL_EVENT_DELIVERY          0x0000000A

             /**
              * Guest-physical access for an instruction fetch or during instruction execution.
              */
#define VMX_EXIT_QUALIFICATION_TYPE_PHYSICAL_INSTRUCTION_FETCH       0x0000000F
        UINT64_t reserved1 : 48;
    };

    UINT64_t flags;
} vmx_exit_qualification_apic_access;

/**
 * @brief Exit Qualification for EPT Violations
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Set if the access causing the EPT violation was a data read.
         */
        UINT64_t read_access : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_BIT         0
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_FLAG        0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_MASK        0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS(_)          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Set if the access causing the EPT violation was a data write.
         */
        UINT64_t write_access : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_BIT        1
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_FLAG       0x02
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_MASK       0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS(_)         (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Set if the access causing the EPT violation was an instruction fetch.
         */
        UINT64_t execute_access : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_BIT      2
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_FLAG     0x04
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_MASK     0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS(_)       (((_) >> 2) & 0x01)

        /**
         * [Bit 3] The logical-AND of bit 0 in the EPT paging-structure entries used to translate the guest-physical address of the
         * access causing the EPT violation (indicates whether the guest-physical address was readable).
         */
        UINT64_t ept_readable : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_BIT        3
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_FLAG       0x08
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_MASK       0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE(_)         (((_) >> 3) & 0x01)

        /**
         * [Bit 4] The logical-AND of bit 1 in the EPT paging-structure entries used to translate the guest-physical address of the
         * access causing the EPT violation (indicates whether the guest-physical address was writeable).
         */
        UINT64_t ept_writeable : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_BIT       4
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_FLAG      0x10
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_MASK      0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE(_)        (((_) >> 4) & 0x01)

        /**
         * [Bit 5] The logical-AND of bit 2 in the EPT paging-structure entries used to translate the guest-physical address of the
         * access causing the EPT violation.
         * If the "mode-based execute control for EPT" VM-execution control is 0, this indicates whether the guest-physical address
         * was executable. If that control is 1, this indicates whether the guest-physical address was executable for
         * supervisor-mode linear addresses.
         */
        UINT64_t ept_executable : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_BIT      5
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FLAG     0x20
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_MASK     0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE(_)       (((_) >> 5) & 0x01)

        /**
         * [Bit 6] If the "mode-based execute control" VM-execution control is 0, the value of this bit is undefined. If that
         * control is 1, this bit is the logical-AND of bit 10 in the EPT paging-structures entries used to translate the
         * guest-physical address of the access causing the EPT violation. In this case, it indicates whether the guest-physical
         * address was executable for user-mode linear addresses.
         */
        UINT64_t ept_executable_for_user_mode : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_BIT 6
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_FLAG 0x40
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE(_) (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Set if the guest linear-address field is valid. The guest linear-address field is valid for all EPT violations
         * except those resulting from an attempt to load the guest PDPTEs as part of the execution of the MOV CR instruction.
         */
        UINT64_t valid_guest_linear_address : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_BIT 7
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_FLAG 0x80
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS(_) (((_) >> 7) & 0x01)

        /**
         * [Bit 8] If bit 7 is 1:
         * - Set if the access causing the EPT violation is to a guest-physical address that is the translation of a linear
         * address.
         * - Clear if the access causing the EPT violation is to a paging-structure entry as part of a page walk or the update of
         * an accessed or dirty bit.
         * Reserved if bit 7 is 0 (cleared to 0).
         */
        UINT64_t caused_by_translation : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_BIT 8
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_FLAG 0x100
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION(_) (((_) >> 8) & 0x01)

        /**
         * [Bit 9] This bit is 0 if the linear address is a supervisor-mode linear address and 1 if it is a user-mode linear
         * address. Otherwise, this bit is undefined.
         *
         * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information for EPT violations. (If
         *          CR0.PG = 0, the translation of every linear address is a user-mode linear address and thus this bit will be 1.)
         */
        UINT64_t user_mode_linear_address : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_BIT 9
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_FLAG 0x200
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS(_) (((_) >> 9) & 0x01)

        /**
         * [Bit 10] This bit is 0 if paging translates the linear address to a read-only page and 1 if it translates to a
         * read/write page. Otherwise, this bit is undefined
         *
         * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information for EPT violations. (If
         *          CR0.PG = 0, every linear address is read/write and thus this bit will be 1.)
         */
        UINT64_t readable_writable_page : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_BIT 10
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_FLAG 0x400
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE(_) (((_) >> 10) & 0x01)

        /**
         * [Bit 11] This bit is 0 if paging translates the linear address to an executable page and 1 if it translates to an
         * execute-disable page. Otherwise, this bit is undefined.
         *
         * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information for EPT violations. (If
         *          CR0.PG = 0, CR4.PAE = 0, or IA32_EFER.NXE = 0, every linear address is executable and thus this bit will be 0.)
         */
        UINT64_t execute_disable_page : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_BIT 11
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_FLAG 0x800
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE(_) (((_) >> 11) & 0x01)

        /**
         * [Bit 12] NMI unblocking due to IRET.
         */
        UINT64_t nmi_unblocking : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_BIT      12
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_FLAG     0x1000
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_MASK     0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING(_)       (((_) >> 12) & 0x01)
        UINT64_t reserved1 : 51;
    };

    UINT64_t flags;
} vmx_exit_qualification_ept_violation;

/**
 * @}
 */

 /**
  * @defgroup vmx_vmexit_instruction_information \
  *           Information for VM Exits Due to Instruction Execution
  *
  * Information for VM Exits Due to Instruction Execution.
  *
  * @see Vol3C[27.2.4(Information for VM Exits Due to Instruction Execution)] (reference)
  * @{
  */
  /**
   * @brief VM-Exit Instruction-Information Field as Used for INS and OUTS
   */
typedef union
{
    struct
    {
        UINT64_t reserved1 : 7;

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used.
         */
        UINT64_t address_size : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_BIT        7
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_FLAG       0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_MASK       0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE(_)         (((_) >> 7) & 0x07)
        UINT64_t reserved2 : 5;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used. Undefined for VM exits due to execution of INS.
         */
        UINT64_t segment_register : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_BIT    15
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_FLAG   0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_MASK   0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER(_)     (((_) >> 15) & 0x07)
        UINT64_t reserved3 : 46;
    };

    UINT64_t flags;
} vmx_vmexit_instruction_info_ins_outs;

/**
 * @brief VM-Exit Instruction-Information Field as Used for INVEPT, INVPCID, and INVVPID
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64_t scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_BIT           0
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_FLAG          0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_MASK          0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING(_)            (((_) >> 0) & 0x03)
        UINT64_t reserved1 : 5;

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used.
         */
        UINT64_t address_size : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_BIT      7
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_FLAG     0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_MASK     0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE(_)       (((_) >> 7) & 0x07)
        UINT64_t reserved2 : 5;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used. Undefined for VM exits due to execution of INS.
         */
        UINT64_t segment_register : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_BIT  15
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER(_)   (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64_t general_purpose_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
         */
        UINT64_t general_purpose_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory instructions with no base register (bit 27 is
         * set).
         */
        UINT64_t base_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_BIT     23
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_FLAG    0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_MASK    0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER(_)      (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
         */
        UINT64_t base_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

        /**
         * [Bits 31:28] Reg2 (same encoding as IndexReg above).
         */
        UINT64_t register_2 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_BIT        28
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_FLAG       0xF0000000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_MASK       0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2(_)         (((_) >> 28) & 0x0F)
        UINT64_t reserved3 : 32;
    };

    UINT64_t flags;
} vmx_vmexit_instruction_info_invalidate;

/**
 * @brief VM-Exit Instruction-Information Field as Used for LIDT, LGDT, SIDT, or SGDT
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64_t scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_BIT     0
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_FLAG    0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_MASK    0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING(_)      (((_) >> 0) & 0x03)
        UINT64_t reserved1 : 5;

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used.
         */
        UINT64_t address_size : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_BIT 7
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE(_) (((_) >> 7) & 0x07)
        UINT64_t reserved2 : 1;

        /**
         * @brief Operand size
         *
         * [Bit 11] 0: 16-bit
         * 1: 32-bit
         * Undefined for VM exits from 64-bit mode.
         */
        UINT64_t operand_size : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_BIT 11
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_FLAG 0x800
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE(_) (((_) >> 11) & 0x01)
        UINT64_t reserved3 : 3;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used.
         */
        UINT64_t segment_register : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64_t general_purpose_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
         */
        UINT64_t general_purpose_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory instructions with no base register (bit 27 is
         * set).
         */
        UINT64_t base_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER(_) (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
         */
        UINT64_t base_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

        /**
         * @brief Instruction identity
         *
         * [Bits 29:28] 0: SGDT
         * 1: SIDT
         * 2: LGDT
         * 3: LIDT
         */
        UINT64_t instruction : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_BIT 28
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_FLAG 0x30000000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION(_)  (((_) >> 28) & 0x03)
        UINT64_t reserved4 : 34;
    };

    UINT64_t flags;
} vmx_vmexit_instruction_info_gdtr_idtr_access;

/**
 * @brief VM-Exit Instruction-Information Field as Used for LLDT, LTR, SLDT, and STR
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64_t scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_BIT       0
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_FLAG      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_MASK      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING(_)        (((_) >> 0) & 0x03)
        UINT64_t reserved1 : 1;

        /**
         * [Bits 6:3] Reg1. Undefined for memory instructions (bit 10 is clear).
         */
        UINT64_t reg_1 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_BIT         3
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_FLAG        0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_MASK        0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1(_)          (((_) >> 3) & 0x0F)

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used. Undefined for register instructions (bit 10 is set).
         */
        UINT64_t address_size : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)

        /**
         * [Bit 10] Mem/Reg (0 = memory; 1 = register).
         */
        UINT64_t memory_register : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_BIT 10
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_FLAG 0x400
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER(_) (((_) >> 10) & 0x01)
        UINT64_t reserved2 : 4;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used. Undefined for register instructions (bit 10 is set).
         */
        UINT64_t segment_register : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for register instructions (bit 10 is set) and for memory instructions
         * with no index register (bit 10 is clear and bit 22 is set).
         */
        UINT64_t general_purpose_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid). Undefined for register instructions (bit 10 is set).
         */
        UINT64_t general_purpose_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for register instructions (bit 10 is set) and for memory
         * instructions with no base register (bit 10 is clear and bit 27 is set).
         */
        UINT64_t base_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER(_)  (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid). Undefined for register instructions (bit 10 is set).
         */
        UINT64_t base_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

        /**
         * @brief Instruction identity
         *
         * [Bits 29:28] 0: SLDT
         * 1: STR
         * 2: LLDT
         * 3: LTR
         */
        UINT64_t instruction : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_BIT   28
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_FLAG  0x30000000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_MASK  0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION(_)    (((_) >> 28) & 0x03)
        UINT64_t reserved3 : 34;
    };

    UINT64_t flags;
} vmx_vmexit_instruction_info_ldtr_tr_access;

/**
 * @brief VM-Exit Instruction-Information Field as Used for RDRAND and RDSEED
 */
typedef union
{
    struct
    {
        UINT64_t reserved1 : 3;

        /**
         * [Bits 6:3] Destination register.
         */
        UINT64_t destination_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_BIT 3
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_FLAG 0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER(_) (((_) >> 3) & 0x0F)
        UINT64_t reserved2 : 4;

        /**
         * @brief Operand size
         *
         * [Bits 12:11] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit
         * The value 3 is not used.
         */
        UINT64_t operand_size : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_BIT   11
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_FLAG  0x1800
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_MASK  0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE(_)    (((_) >> 11) & 0x03)
        UINT64_t reserved3 : 51;
    };

    UINT64_t flags;
} vmx_vmexit_instruction_info_rdrand_rdseed;

/**
 * @brief VM-Exit Instruction-Information Field as Used for VMCLEAR, VMPTRLD, VMPTRST, VMXON, XRSTORS, and XSAVES
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64_t scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_BIT       0
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_FLAG      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_MASK      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING(_)        (((_) >> 0) & 0x03)
        UINT64_t reserved1 : 5;

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used.
         */
        UINT64_t address_size : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)
        UINT64_t reserved2 : 5;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used.
         */
        UINT64_t segment_register : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for instructions with no index register (bit 22 is set).
         */
        UINT64_t general_purpose_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
         */
        UINT64_t general_purpose_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory instructions with no base register (bit 27 is
         * set).
         */
        UINT64_t base_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER(_)  (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
         */
        UINT64_t base_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)
        UINT64_t reserved3 : 36;
    };

    UINT64_t flags;
} vmx_vmexit_instruction_info_vmx_and_xsaves;

/**
 * @brief VM-Exit Instruction-Information Field as Used for VMREAD and VMWRITE
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for register instructions (bit 10 is set) and for memory instructions with no index register (bit 10 is clear
         * and bit 22 is set).
         */
        UINT64_t scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_BIT       0
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_FLAG      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_MASK      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING(_)        (((_) >> 0) & 0x03)
        UINT64_t reserved1 : 1;

        /**
         * [Bits 6:3] Reg1. Undefined for memory instructions (bit 10 is clear).
         */
        UINT64_t register_1 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_BIT    3
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_FLAG   0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_MASK   0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1(_)     (((_) >> 3) & 0x0F)

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used. Undefined for register instructions (bit 10 is set).
         */
        UINT64_t address_size : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)

        /**
         * [Bit 10] Mem/Reg (0 = memory; 1 = register).
         */
        UINT64_t memory_register : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_BIT 10
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_FLAG 0x400
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER(_) (((_) >> 10) & 0x01)
        UINT64_t reserved2 : 4;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used. Undefined for register instructions (bit 10 is set).
         */
        UINT64_t segment_register : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for register instructions (bit 10 is set) and for memory instructions
         * with no index register (bit 10 is clear and bit 22 is set).
         */
        UINT64_t general_purpose_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid). Undefined for register instructions (bit 10 is set).
         */
        UINT64_t general_purpose_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as Reg1 above). Undefined for register instructions (bit 10 is set) and for memory
         * instructions with no base register (bit 10 is clear and bit 27 is set).
         */
        UINT64_t base_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER(_)  (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
         */
        UINT64_t base_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

        /**
         * [Bits 31:28] Reg2 (same encoding as IndexReg above).
         */
        UINT64_t register_2 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_BIT    28
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_FLAG   0xF0000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_MASK   0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2(_)     (((_) >> 28) & 0x0F)
        UINT64_t reserved3 : 32;
    };

    UINT64_t flags;
} vmx_vmexit_instruction_info_vmread_vmwrite;

/**
 * @}
 */

 /**
  * @brief - The low 16 bits correspond to bits 23:8 of the upper 32 bits of a 64-bit segment descriptor. While bits 19:16
  *        of code-segment and data-segment descriptors correspond to the upper 4 bits of the segment limit, the corresponding bits
  *        (bits 11:8) are reserved in this VMCS field.
  *        - Bit 16 indicates an unusable segment. Attempts to use such a segment fault except in 64-bit mode. In general, a
  *        segment register is unusable if it has been loaded with a null selector.
  *        - Bits 31:17 are reserved
  *
  * @note There are a few exceptions to this statement. For example, a segment with a non-null selector may be unusable
  *       following a task switch that fails after its commit point. In contrast, the TR register is usable after processor reset
  *       despite having a null selector
  * @see SEGMENT_DESCRIPTOR_32
  * @see SEGMENT_DESCRIPTOR_64
  * @see XXX_ACCESS_RIGHTS fields of 32_BIT_GUEST_STATE_FIELDS
  * @see Vol3C[24.4.2(Guest Non-Register State)] (reference)
  */
typedef union
{
    struct
    {
        /**
         * [Bits 3:0] Segment type.
         */
        UINT32_t type : 4;
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_BIT                           0
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_FLAG                          0x0F
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_MASK                          0x0F
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE(_)                            (((_) >> 0) & 0x0F)

        /**
         * [Bit 4] S - Descriptor type (0 = system; 1 = code or data).
         */
        UINT32_t descriptor_type : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_BIT                4
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_FLAG               0x10
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_MASK               0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE(_)                 (((_) >> 4) & 0x01)

        /**
         * [Bits 6:5] DPL - Descriptor privilege level.
         */
        UINT32_t descriptor_privilege_level : 2;
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_BIT     5
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_FLAG    0x60
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_MASK    0x03
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL(_)      (((_) >> 5) & 0x03)

        /**
         * [Bit 7] P - Segment present.
         */
        UINT32_t present : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_BIT                        7
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_FLAG                       0x80
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_MASK                       0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT(_)                         (((_) >> 7) & 0x01)
        UINT32_t reserved1 : 4;

        /**
         * [Bit 12] AVL - Available for use by system software.
         */
        UINT32_t available_bit : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_BIT                  12
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_FLAG                 0x1000
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_MASK                 0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT(_)                   (((_) >> 12) & 0x01)

        /**
         * [Bit 13] Reserved (except for CS). L - 64-bit mode active (for CS only).
         */
        UINT32_t long_mode : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_BIT                      13
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_FLAG                     0x2000
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_MASK                     0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE(_)                       (((_) >> 13) & 0x01)

        /**
         * [Bit 14] D/B - Default operation size (0 = 16-bit segment; 1 = 32-bit segment).
         */
        UINT32_t default_big : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_BIT                    14
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_FLAG                   0x4000
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_MASK                   0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG(_)                     (((_) >> 14) & 0x01)

        /**
         * [Bit 15] G - Granularity.
         */
        UINT32_t granularity : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_BIT                    15
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_FLAG                   0x8000
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_MASK                   0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY(_)                     (((_) >> 15) & 0x01)

        /**
         * [Bit 16] Segment unusable (0 = usable; 1 = unusable).
         */
        UINT32_t unusable : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_BIT                       16
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_FLAG                      0x10000
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_MASK                      0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE(_)                        (((_) >> 16) & 0x01)
        UINT32_t reserved2 : 15;
    };

    UINT32_t flags;
} vmx_segment_access_rights;

/**
 * @brief The IA-32 architecture includes features that permit certain events to be blocked for a period of time. This
 *        field contains information about such blocking
 *
 * @see INTERRUPTIBILITY_STATE of 32_BIT_GUEST_STATE_FIELDS
 * @see Vol3C[24.4.2(Guest Non-Register State)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Execution of STI with RFLAGS.IF = 0 blocks maskable interrupts on the instruction boundary following its
         * execution.1 Setting this bit indicates that this blocking is in effect.
         *
         * @see Vol2B[4(STI-Set Interrupt Flag)]
         */
        UINT32_t blocking_by_sti : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_BIT               0
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_FLAG              0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_MASK              0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI(_)                (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Execution of a MOV to SS or a POP to SS blocks or suppresses certain debug exceptions as well as interrupts
         * (maskable and nonmaskable) on the instruction boundary following its execution. Setting this bit indicates that this
         * blocking is in effect. This document uses the term "blocking by MOV SS," but it applies equally to POP SS.
         *
         * @see Vol3A[6.8.3(Masking Exceptions and Interrupts When Switching Stacks)]
         */
        UINT32_t blocking_by_mov_ss : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_BIT            1
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_FLAG           0x02
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_MASK           0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS(_)             (((_) >> 1) & 0x01)

        /**
         * [Bit 2] System-management interrupts (SMIs) are disabled while the processor is in system-management mode (SMM). Setting
         * this bit indicates that blocking of SMIs is in effect.
         *
         * @see Vol3C[34.2(System Management Interrupt (SMI))]
         */
        UINT32_t blocking_by_smi : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_BIT               2
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_FLAG              0x04
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_MASK              0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI(_)                (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Delivery of a non-maskable interrupt (NMI) or a system-management interrupt (SMI) blocks subsequent NMIs until
         * the next execution of IRET. Setting this bit indicates that blocking of NMIs is in effect. Clearing this bit does not
         * imply that NMIs are not (temporarily) blocked for other reasons. If the "virtual NMIs" VM-execution control is 1, this
         * bit does not control the blocking of NMIs. Instead, it refers to "virtual-NMI blocking" (the fact that guest software is
         * not ready for an NMI).
         *
         * @see Vol3C[6.7.1(Handling Multiple NMIs)]
         * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
         * @see Vol3C[24.6.1(Pin-Based VM-Execution Controls)]
         */
        UINT32_t blocking_by_nmi : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_BIT               3
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_FLAG              0x08
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_MASK              0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI(_)                (((_) >> 3) & 0x01)

        /**
         * [Bit 4] A VM exit saves this bit as 1 to indicate that the VM exit was incident to enclave mode.
         */
        UINT32_t enclave_interruption : 1;
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_BIT          4
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_FLAG         0x10
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_MASK         0x01
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION(_)           (((_) >> 4) & 0x01)
        UINT32_t reserved1 : 27;
    };

    UINT32_t flags;
} vmx_interruptibility_state;

typedef enum
{
    /**
     * The logical processor is executing instructions normally.
     */
    vmx_active = 0x00000000,

    /**
     * The logical processor is inactive because it executed the HLT instruction.
     */
     vmx_hlt = 0x00000001,

     /**
      * The logical processor is inactive because it incurred a triple fault1 or some other serious error.
      */
      vmx_shutdown = 0x00000002,

      /**
       * The logical processor is inactive because it is waiting for a startup-IPI (SIPI).
       */
       vmx_wait_for_sipi = 0x00000003,
} vmx_guest_activity_state;

/**
 * @}
 */

 /**
  * @brief Format of Exit Reason
  *
  * Exit reason (32 bits). This field encodes the reason for the VM exit and has the structure.
  *
  * @see Vol3C[24.9.1(Basic VM-Exit Information)] (reference)
  */
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] Provides basic information about the cause of the VM exit (if bit 31 is clear) or of the VM-entry failure
         * (if bit 31 is set).
         */
        UINT32_t basic_exit_reason : 16;
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_BIT                      0
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_FLAG                     0xFFFF
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_MASK                     0xFFFF
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON(_)                       (((_) >> 0) & 0xFFFF)

        /**
         * [Bit 16] Always cleared to 0.
         */
        UINT32_t always0 : 1;
#define VMX_VMEXIT_REASON_ALWAYS0_BIT                                16
#define VMX_VMEXIT_REASON_ALWAYS0_FLAG                               0x10000
#define VMX_VMEXIT_REASON_ALWAYS0_MASK                               0x01
#define VMX_VMEXIT_REASON_ALWAYS0(_)                                 (((_) >> 16) & 0x01)
        UINT32_t reserved1 : 10;
#define VMX_VMEXIT_REASON_RESERVED1_BIT                              17
#define VMX_VMEXIT_REASON_RESERVED1_FLAG                             0x7FE0000
#define VMX_VMEXIT_REASON_RESERVED1_MASK                             0x3FF
#define VMX_VMEXIT_REASON_RESERVED1(_)                               (((_) >> 17) & 0x3FF)

        /**
         * [Bit 27] A VM exit saves this bit as 1 to indicate that the VM exit was incident to enclave mode.
         */
        UINT32_t enclave_mode : 1;
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_BIT                           27
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_FLAG                          0x8000000
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_MASK                          0x01
#define VMX_VMEXIT_REASON_ENCLAVE_MODE(_)                            (((_) >> 27) & 0x01)

        /**
         * [Bit 28] Pending MTF VM exit.
         */
        UINT32_t pending_mtf_vm_exit : 1;
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_BIT                    28
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_FLAG                   0x10000000
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_MASK                   0x01
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT(_)                     (((_) >> 28) & 0x01)

        /**
         * [Bit 29] VM exit from VMX root operation.
         */
        UINT32_t vm_exit_from_vmx_roor : 1;
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOR_BIT                  29
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOR_FLAG                 0x20000000
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOR_MASK                 0x01
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOR(_)                   (((_) >> 29) & 0x01)
        UINT32_t reserved2 : 1;
#define VMX_VMEXIT_REASON_RESERVED2_BIT                              30
#define VMX_VMEXIT_REASON_RESERVED2_FLAG                             0x40000000
#define VMX_VMEXIT_REASON_RESERVED2_MASK                             0x01
#define VMX_VMEXIT_REASON_RESERVED2(_)                               (((_) >> 30) & 0x01)

        /**
         * [Bit 31] VM-entry failure:
         *   - 0 = true VM exit
         *   - 1 = VM-entry failure
         */
        UINT32_t vm_entry_failure : 1;
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_BIT                       31
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_FLAG                      0x80000000
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_MASK                      0x01
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE(_)                        (((_) >> 31) & 0x01)
    };

    UINT32_t flags;
} vmx_vmexit_reason;

typedef struct
{
#define IO_BITMAP_A_MIN                                              0x00000000
#define IO_BITMAP_A_MAX                                              0x00007FFF
#define IO_BITMAP_B_MIN                                              0x00008000
#define IO_BITMAP_B_MAX                                              0x0000FFFF
    UINT8_t io_a[4096];
    UINT8_t io_b[4096];
} vmx_io_bitmap;

typedef struct
{
#define MSR_ID_LOW_MIN                                               0x00000000
#define MSR_ID_LOW_MAX                                               0x00001FFF
#define MSR_ID_HIGH_MIN                                              0xC0000000
#define MSR_ID_HIGH_MAX                                              0xC0001FFF
    UINT8_t rdmsr_low[1024];
    UINT8_t rdmsr_high[1024];
    UINT8_t wrmsr_low[1024];
    UINT8_t wrmsr_high[1024];
} vmx_msr_bitmap;

/**
 * @defgroup ept \
 *           The extended page-table mechanism
 *
 * The extended page-table mechanism (EPT) is a feature that can be used to support the virtualization of physical memory.
 * When EPT is in use, certain addresses that would normally be treated as physical addresses (and used to access memory)
 * are instead treated as guest-physical addresses. Guest-physical addresses are translated by traversing a set of EPT
 * paging structures to produce physical addresses that are used to access memory.
 *
 * @see Vol3C[28.2(THE EXTENDED PAGE TABLE MECHANISM (EPT))] (reference)
 * @{
 */
 /**
  * @brief Extended-Page-Table Pointer (EPTP)
  *
  * The extended-page-table pointer (EPTP) contains the address of the base of EPT PML4 table, as well as other EPT
  * configuration information.
  *
  * @see Vol3C[28.2.2(EPT Translation Mechanism]
  * @see Vol3C[24.6.11(Extended-Page-Table Pointer (EPTP)] (reference)
  */
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] EPT paging-structure memory type:
         * - 0 = Uncacheable (UC)
         * - 6 = Write-back (WB)
         * Other values are reserved.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64_t memory_type : 3;
#define EPT_POINTER_MEMORY_TYPE_BIT                                  0
#define EPT_POINTER_MEMORY_TYPE_FLAG                                 0x07
#define EPT_POINTER_MEMORY_TYPE_MASK                                 0x07
#define EPT_POINTER_MEMORY_TYPE(_)                                   (((_) >> 0) & 0x07)

        /**
         * [Bits 5:3] This value is 1 less than the EPT page-walk length.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64_t page_walk_length : 3;
#define EPT_POINTER_PAGE_WALK_LENGTH_BIT                             3
#define EPT_POINTER_PAGE_WALK_LENGTH_FLAG                            0x38
#define EPT_POINTER_PAGE_WALK_LENGTH_MASK                            0x07
#define EPT_POINTER_PAGE_WALK_LENGTH(_)                              (((_) >> 3) & 0x07)
#define EPT_PAGE_WALK_LENGTH_4                                       0x00000003

        /**
         * [Bit 6] Setting this control to 1 enables accessed and dirty flags for EPT.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t enable_access_and_dirty_flags : 1;
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_BIT                6
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_FLAG               0x40
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_MASK               0x01
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS(_)                 (((_) >> 6) & 0x01)
        UINT64_t reserved1 : 5;

        /**
         * [Bits 47:12] Bits N-1:12 of the physical address of the 4-KByte aligned EPT PML4 table.
         */
        UINT64_t page_frame_number : 36;
#define EPT_POINTER_PAGE_FRAME_NUMBER_BIT                            12
#define EPT_POINTER_PAGE_FRAME_NUMBER_FLAG                           0xFFFFFFFFF000
#define EPT_POINTER_PAGE_FRAME_NUMBER_MASK                           0xFFFFFFFFF
#define EPT_POINTER_PAGE_FRAME_NUMBER(_)                             (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved2 : 16;
    };

    UINT64_t flags;
} ept_pointer;

/**
 * @brief Format of an EPT PML4 Entry (PML4E) that References an EPT Page-Directory-Pointer Table
 *
 * A 4-KByte naturally aligned EPT PML4 table is located at the physical address specified in bits 51:12 of the
 * extended-page-table pointer (EPTP), a VM-execution control field. An EPT PML4 table comprises 512 64-bit entries (EPT
 * PML4Es). An EPT PML4E is selected using the physical address defined as follows:
 * - Bits 63:52 are all 0.
 * - Bits 51:12 are from the EPTP.
 * - Bits 11:3 are bits 47:39 of the guest-physical address.
 * - Bits 2:0 are all 0.
 * Because an EPT PML4E is identified using bits 47:39 of the guest-physical address, it controls access to a 512- GByte
 * region of the guest-physical-address space.
 *
 * @see Vol3C[24.6.11(Extended-Page-Table Pointer (EPTP)]
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 512-GByte region controlled by this entry.
         */
        UINT64_t read_access : 1;
#define EPT_PML4_READ_ACCESS_BIT                                     0
#define EPT_PML4_READ_ACCESS_FLAG                                    0x01
#define EPT_PML4_READ_ACCESS_MASK                                    0x01
#define EPT_PML4_READ_ACCESS(_)                                      (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 512-GByte region controlled by this entry.
         */
        UINT64_t write_access : 1;
#define EPT_PML4_WRITE_ACCESS_BIT                                    1
#define EPT_PML4_WRITE_ACCESS_FLAG                                   0x02
#define EPT_PML4_WRITE_ACCESS_MASK                                   0x01
#define EPT_PML4_WRITE_ACCESS(_)                                     (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 512-GByte region controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 512-GByte region controlled by this entry.
         */
        UINT64_t execute_access : 1;
#define EPT_PML4_EXECUTE_ACCESS_BIT                                  2
#define EPT_PML4_EXECUTE_ACCESS_FLAG                                 0x04
#define EPT_PML4_EXECUTE_ACCESS_MASK                                 0x01
#define EPT_PML4_EXECUTE_ACCESS(_)                                   (((_) >> 2) & 0x01)
        UINT64_t reserved1 : 5;

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 512-GByte region
         * controlled by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t accessed : 1;
#define EPT_PML4_ACCESSED_BIT                                        8
#define EPT_PML4_ACCESSED_FLAG                                       0x100
#define EPT_PML4_ACCESSED_MASK                                       0x01
#define EPT_PML4_ACCESSED(_)                                         (((_) >> 8) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 512-GByte region
         * controlled by this entry. If that control is 0, this bit is ignored.
         */
        UINT64_t user_mode_execute : 1;
#define EPT_PML4_USER_MODE_EXECUTE_BIT                               10
#define EPT_PML4_USER_MODE_EXECUTE_FLAG                              0x400
#define EPT_PML4_USER_MODE_EXECUTE_MASK                              0x01
#define EPT_PML4_USER_MODE_EXECUTE(_)                                (((_) >> 10) & 0x01)
        UINT64_t reserved3 : 1;

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
         */
        UINT64_t page_frame_number : 36;
#define EPT_PML4_PAGE_FRAME_NUMBER_BIT                               12
#define EPT_PML4_PAGE_FRAME_NUMBER_FLAG                              0xFFFFFFFFF000
#define EPT_PML4_PAGE_FRAME_NUMBER_MASK                              0xFFFFFFFFF
#define EPT_PML4_PAGE_FRAME_NUMBER(_)                                (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved4 : 16;
    };

    UINT64_t flags;
} ept_pml4e;

/**
 * @brief Format of an EPT Page-Directory-Pointer-Table Entry (PDPTE) that Maps a 1-GByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 1-GByte page referenced by this entry.
         */
        UINT64_t read_access : 1;
#define EPDPTE_1GB_READ_ACCESS_BIT                                   0
#define EPDPTE_1GB_READ_ACCESS_FLAG                                  0x01
#define EPDPTE_1GB_READ_ACCESS_MASK                                  0x01
#define EPDPTE_1GB_READ_ACCESS(_)                                    (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 1-GByte page referenced by this entry.
         */
        UINT64_t write_access : 1;
#define EPDPTE_1GB_WRITE_ACCESS_BIT                                  1
#define EPDPTE_1GB_WRITE_ACCESS_FLAG                                 0x02
#define EPDPTE_1GB_WRITE_ACCESS_MASK                                 0x01
#define EPDPTE_1GB_WRITE_ACCESS(_)                                   (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 1-GByte page controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 1-GByte page controlled by this entry.
         */
        UINT64_t execute_access : 1;
#define EPDPTE_1GB_EXECUTE_ACCESS_BIT                                2
#define EPDPTE_1GB_EXECUTE_ACCESS_FLAG                               0x04
#define EPDPTE_1GB_EXECUTE_ACCESS_MASK                               0x01
#define EPDPTE_1GB_EXECUTE_ACCESS(_)                                 (((_) >> 2) & 0x01)

        /**
         * [Bits 5:3] EPT memory type for this 1-GByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64_t memory_type : 3;
#define EPDPTE_1GB_MEMORY_TYPE_BIT                                   3
#define EPDPTE_1GB_MEMORY_TYPE_FLAG                                  0x38
#define EPDPTE_1GB_MEMORY_TYPE_MASK                                  0x07
#define EPDPTE_1GB_MEMORY_TYPE(_)                                    (((_) >> 3) & 0x07)

        /**
         * [Bit 6] Ignore PAT memory type for this 1-GByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64_t ignore_pat : 1;
#define EPDPTE_1GB_IGNORE_PAT_BIT                                    6
#define EPDPTE_1GB_IGNORE_PAT_FLAG                                   0x40
#define EPDPTE_1GB_IGNORE_PAT_MASK                                   0x01
#define EPDPTE_1GB_IGNORE_PAT(_)                                     (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Must be 1 (otherwise, this entry references an EPT page directory).
         */
        UINT64_t large_page : 1;
#define EPDPTE_1GB_LARGE_PAGE_BIT                                    7
#define EPDPTE_1GB_LARGE_PAGE_FLAG                                   0x80
#define EPDPTE_1GB_LARGE_PAGE_MASK                                   0x01
#define EPDPTE_1GB_LARGE_PAGE(_)                                     (((_) >> 7) & 0x01)

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 1-GByte page
         * referenced by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t accessed : 1;
#define EPDPTE_1GB_ACCESSED_BIT                                      8
#define EPDPTE_1GB_ACCESSED_FLAG                                     0x100
#define EPDPTE_1GB_ACCESSED_MASK                                     0x01
#define EPDPTE_1GB_ACCESSED(_)                                       (((_) >> 8) & 0x01)

        /**
         * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to the 1-GByte page referenced
         * by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t dirty : 1;
#define EPDPTE_1GB_DIRTY_BIT                                         9
#define EPDPTE_1GB_DIRTY_FLAG                                        0x200
#define EPDPTE_1GB_DIRTY_MASK                                        0x01
#define EPDPTE_1GB_DIRTY(_)                                          (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 1-GByte page controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        UINT64_t user_mode_execute : 1;
#define EPDPTE_1GB_USER_MODE_EXECUTE_BIT                             10
#define EPDPTE_1GB_USER_MODE_EXECUTE_FLAG                            0x400
#define EPDPTE_1GB_USER_MODE_EXECUTE_MASK                            0x01
#define EPDPTE_1GB_USER_MODE_EXECUTE(_)                              (((_) >> 10) & 0x01)
        UINT64_t reserved1 : 19;

        /**
         * [Bits 47:30] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
         */
        UINT64_t page_frame_number : 18;
#define EPDPTE_1GB_PAGE_FRAME_NUMBER_BIT                             30
#define EPDPTE_1GB_PAGE_FRAME_NUMBER_FLAG                            0xFFFFC0000000
#define EPDPTE_1GB_PAGE_FRAME_NUMBER_MASK                            0x3FFFF
#define EPDPTE_1GB_PAGE_FRAME_NUMBER(_)                              (((_) >> 30) & 0x3FFFF)
        UINT64_t reserved2 : 15;

        /**
         * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations caused by accesses to this
         * page are convertible to virtualization exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
         * 0, this bit is ignored.
         *
         * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
         */
        UINT64_t suppress_ve : 1;
#define EPDPTE_1GB_SUPPRESS_VE_BIT                                   63
#define EPDPTE_1GB_SUPPRESS_VE_FLAG                                  0x8000000000000000
#define EPDPTE_1GB_SUPPRESS_VE_MASK                                  0x01
#define EPDPTE_1GB_SUPPRESS_VE(_)                                    (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} ept_pdpte_1gb;

/**
 * @brief Format of an EPT Page-Directory-Pointer-Table Entry (PDPTE) that References an EPT Page Directory
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 1-GByte region controlled by this entry.
         */
        UINT64_t read_access : 1;
#define EPDPTE_READ_ACCESS_BIT                                       0
#define EPDPTE_READ_ACCESS_FLAG                                      0x01
#define EPDPTE_READ_ACCESS_MASK                                      0x01
#define EPDPTE_READ_ACCESS(_)                                        (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 1-GByte region controlled by this entry.
         */
        UINT64_t write_access : 1;
#define EPDPTE_WRITE_ACCESS_BIT                                      1
#define EPDPTE_WRITE_ACCESS_FLAG                                     0x02
#define EPDPTE_WRITE_ACCESS_MASK                                     0x01
#define EPDPTE_WRITE_ACCESS(_)                                       (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 1-GByte region controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 1-GByte region controlled by this entry.
         */
        UINT64_t execute_access : 1;
#define EPDPTE_EXECUTE_ACCESS_BIT                                    2
#define EPDPTE_EXECUTE_ACCESS_FLAG                                   0x04
#define EPDPTE_EXECUTE_ACCESS_MASK                                   0x01
#define EPDPTE_EXECUTE_ACCESS(_)                                     (((_) >> 2) & 0x01)
        UINT64_t reserved1 : 5;

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 1-GByte region
         * controlled by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t accessed : 1;
#define EPDPTE_ACCESSED_BIT                                          8
#define EPDPTE_ACCESSED_FLAG                                         0x100
#define EPDPTE_ACCESSED_MASK                                         0x01
#define EPDPTE_ACCESSED(_)                                           (((_) >> 8) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 1-GByte region controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        UINT64_t user_mode_execute : 1;
#define EPDPTE_USER_MODE_EXECUTE_BIT                                 10
#define EPDPTE_USER_MODE_EXECUTE_FLAG                                0x400
#define EPDPTE_USER_MODE_EXECUTE_MASK                                0x01
#define EPDPTE_USER_MODE_EXECUTE(_)                                  (((_) >> 10) & 0x01)
        UINT64_t reserved3 : 1;

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
         */
        UINT64_t page_frame_number : 36;
#define EPDPTE_PAGE_FRAME_NUMBER_BIT                                 12
#define EPDPTE_PAGE_FRAME_NUMBER_FLAG                                0xFFFFFFFFF000
#define EPDPTE_PAGE_FRAME_NUMBER_MASK                                0xFFFFFFFFF
#define EPDPTE_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved4 : 16;
    };

    UINT64_t flags;
} ept_pdpte;

/**
 * @brief Format of an EPT Page-Directory Entry (PDE) that Maps a 2-MByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 2-MByte page referenced by this entry.
         */
        UINT64_t read_access : 1;
#define EPDE_2MB_READ_ACCESS_BIT                                     0
#define EPDE_2MB_READ_ACCESS_FLAG                                    0x01
#define EPDE_2MB_READ_ACCESS_MASK                                    0x01
#define EPDE_2MB_READ_ACCESS(_)                                      (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 2-MByte page referenced by this entry.
         */
        UINT64_t write_access : 1;
#define EPDE_2MB_WRITE_ACCESS_BIT                                    1
#define EPDE_2MB_WRITE_ACCESS_FLAG                                   0x02
#define EPDE_2MB_WRITE_ACCESS_MASK                                   0x01
#define EPDE_2MB_WRITE_ACCESS(_)                                     (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 2-MByte page controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 2-MByte page controlled by this entry.
         */
        UINT64_t execute_access : 1;
#define EPDE_2MB_EXECUTE_ACCESS_BIT                                  2
#define EPDE_2MB_EXECUTE_ACCESS_FLAG                                 0x04
#define EPDE_2MB_EXECUTE_ACCESS_MASK                                 0x01
#define EPDE_2MB_EXECUTE_ACCESS(_)                                   (((_) >> 2) & 0x01)

        /**
         * [Bits 5:3] EPT memory type for this 2-MByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64_t memory_type : 3;
#define EPDE_2MB_MEMORY_TYPE_BIT                                     3
#define EPDE_2MB_MEMORY_TYPE_FLAG                                    0x38
#define EPDE_2MB_MEMORY_TYPE_MASK                                    0x07
#define EPDE_2MB_MEMORY_TYPE(_)                                      (((_) >> 3) & 0x07)

        /**
         * [Bit 6] Ignore PAT memory type for this 2-MByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64_t ignore_pat : 1;
#define EPDE_2MB_IGNORE_PAT_BIT                                      6
#define EPDE_2MB_IGNORE_PAT_FLAG                                     0x40
#define EPDE_2MB_IGNORE_PAT_MASK                                     0x01
#define EPDE_2MB_IGNORE_PAT(_)                                       (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Must be 1 (otherwise, this entry references an EPT page table).
         */
        UINT64_t large_page : 1;
#define EPDE_2MB_LARGE_PAGE_BIT                                      7
#define EPDE_2MB_LARGE_PAGE_FLAG                                     0x80
#define EPDE_2MB_LARGE_PAGE_MASK                                     0x01
#define EPDE_2MB_LARGE_PAGE(_)                                       (((_) >> 7) & 0x01)

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 2-MByte page
         * referenced by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t accessed : 1;
#define EPDE_2MB_ACCESSED_BIT                                        8
#define EPDE_2MB_ACCESSED_FLAG                                       0x100
#define EPDE_2MB_ACCESSED_MASK                                       0x01
#define EPDE_2MB_ACCESSED(_)                                         (((_) >> 8) & 0x01)

        /**
         * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to the 2-MByte page referenced
         * by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t dirty : 1;
#define EPDE_2MB_DIRTY_BIT                                           9
#define EPDE_2MB_DIRTY_FLAG                                          0x200
#define EPDE_2MB_DIRTY_MASK                                          0x01
#define EPDE_2MB_DIRTY(_)                                            (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 2-MByte page controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        UINT64_t user_mode_execute : 1;
#define EPDE_2MB_USER_MODE_EXECUTE_BIT                               10
#define EPDE_2MB_USER_MODE_EXECUTE_FLAG                              0x400
#define EPDE_2MB_USER_MODE_EXECUTE_MASK                              0x01
#define EPDE_2MB_USER_MODE_EXECUTE(_)                                (((_) >> 10) & 0x01)
        UINT64_t reserved1 : 10;

        /**
         * [Bits 47:21] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
         */
        UINT64_t page_frame_number : 27;
#define EPDE_2MB_PAGE_FRAME_NUMBER_BIT                               21
#define EPDE_2MB_PAGE_FRAME_NUMBER_FLAG                              0xFFFFFFE00000
#define EPDE_2MB_PAGE_FRAME_NUMBER_MASK                              0x7FFFFFF
#define EPDE_2MB_PAGE_FRAME_NUMBER(_)                                (((_) >> 21) & 0x7FFFFFF)
        UINT64_t reserved2 : 15;

        /**
         * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations caused by accesses to this
         * page are convertible to virtualization exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
         * 0, this bit is ignored.
         *
         * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
         */
        UINT64_t suppress_ve : 1;
#define EPDE_2MB_SUPPRESS_VE_BIT                                     63
#define EPDE_2MB_SUPPRESS_VE_FLAG                                    0x8000000000000000
#define EPDE_2MB_SUPPRESS_VE_MASK                                    0x01
#define EPDE_2MB_SUPPRESS_VE(_)                                      (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} epde_2mb;

/**
 * @brief Format of an EPT Page-Directory Entry (PDE) that References an EPT Page Table
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 2-MByte region controlled by this entry.
         */
        UINT64_t read_access : 1;
#define EPDE_READ_ACCESS_BIT                                         0
#define EPDE_READ_ACCESS_FLAG                                        0x01
#define EPDE_READ_ACCESS_MASK                                        0x01
#define EPDE_READ_ACCESS(_)                                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 2-MByte region controlled by this entry.
         */
        UINT64_t write_access : 1;
#define EPDE_WRITE_ACCESS_BIT                                        1
#define EPDE_WRITE_ACCESS_FLAG                                       0x02
#define EPDE_WRITE_ACCESS_MASK                                       0x01
#define EPDE_WRITE_ACCESS(_)                                         (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 2-MByte region controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 2-MByte region controlled by this entry.
         */
        UINT64_t execute_access : 1;
#define EPDE_EXECUTE_ACCESS_BIT                                      2
#define EPDE_EXECUTE_ACCESS_FLAG                                     0x04
#define EPDE_EXECUTE_ACCESS_MASK                                     0x01
#define EPDE_EXECUTE_ACCESS(_)                                       (((_) >> 2) & 0x01)
        UINT64_t reserved1 : 5;

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 2-MByte region
         * controlled by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t accessed : 1;
#define EPDE_ACCESSED_BIT                                            8
#define EPDE_ACCESSED_FLAG                                           0x100
#define EPDE_ACCESSED_MASK                                           0x01
#define EPDE_ACCESSED(_)                                             (((_) >> 8) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 2-MByte region controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        UINT64_t user_mode_execute : 1;
#define EPDE_USER_MODE_EXECUTE_BIT                                   10
#define EPDE_USER_MODE_EXECUTE_FLAG                                  0x400
#define EPDE_USER_MODE_EXECUTE_MASK                                  0x01
#define EPDE_USER_MODE_EXECUTE(_)                                    (((_) >> 10) & 0x01)
        UINT64_t reserved3 : 1;

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned EPT page table referenced by this entry.
         */
        UINT64_t page_frame_number : 36;
#define EPDE_PAGE_FRAME_NUMBER_BIT                                   12
#define EPDE_PAGE_FRAME_NUMBER_FLAG                                  0xFFFFFFFFF000
#define EPDE_PAGE_FRAME_NUMBER_MASK                                  0xFFFFFFFFF
#define EPDE_PAGE_FRAME_NUMBER(_)                                    (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved4 : 16;
    };

    UINT64_t flags;
} ept_pde;

/**
 * @brief Format of an EPT Page-Table Entry that Maps a 4-KByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 4-KByte page referenced by this entry.
         */
        UINT64_t read_access : 1;
#define EPTE_READ_ACCESS_BIT                                         0
#define EPTE_READ_ACCESS_FLAG                                        0x01
#define EPTE_READ_ACCESS_MASK                                        0x01
#define EPTE_READ_ACCESS(_)                                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 4-KByte page referenced by this entry.
         */
        UINT64_t write_access : 1;
#define EPTE_WRITE_ACCESS_BIT                                        1
#define EPTE_WRITE_ACCESS_FLAG                                       0x02
#define EPTE_WRITE_ACCESS_MASK                                       0x01
#define EPTE_WRITE_ACCESS(_)                                         (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 4-KByte page controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 4-KByte page controlled by this entry.
         */
        UINT64_t execute_access : 1;
#define EPTE_EXECUTE_ACCESS_BIT                                      2
#define EPTE_EXECUTE_ACCESS_FLAG                                     0x04
#define EPTE_EXECUTE_ACCESS_MASK                                     0x01
#define EPTE_EXECUTE_ACCESS(_)                                       (((_) >> 2) & 0x01)

        /**
         * [Bits 5:3] EPT memory type for this 4-KByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64_t memory_type : 3;
#define EPTE_MEMORY_TYPE_BIT                                         3
#define EPTE_MEMORY_TYPE_FLAG                                        0x38
#define EPTE_MEMORY_TYPE_MASK                                        0x07
#define EPTE_MEMORY_TYPE(_)                                          (((_) >> 3) & 0x07)

        /**
         * [Bit 6] Ignore PAT memory type for this 4-KByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        UINT64_t ignore_pat : 1;
#define EPTE_IGNORE_PAT_BIT                                          6
#define EPTE_IGNORE_PAT_FLAG                                         0x40
#define EPTE_IGNORE_PAT_MASK                                         0x01
#define EPTE_IGNORE_PAT(_)                                           (((_) >> 6) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 4-KByte page
         * referenced by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t accessed : 1;
#define EPTE_ACCESSED_BIT                                            8
#define EPTE_ACCESSED_FLAG                                           0x100
#define EPTE_ACCESSED_MASK                                           0x01
#define EPTE_ACCESSED(_)                                             (((_) >> 8) & 0x01)

        /**
         * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to the 4-KByte page referenced
         * by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        UINT64_t dirty : 1;
#define EPTE_DIRTY_BIT                                               9
#define EPTE_DIRTY_FLAG                                              0x200
#define EPTE_DIRTY_MASK                                              0x01
#define EPTE_DIRTY(_)                                                (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 4-KByte page controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        UINT64_t user_mode_execute : 1;
#define EPTE_USER_MODE_EXECUTE_BIT                                   10
#define EPTE_USER_MODE_EXECUTE_FLAG                                  0x400
#define EPTE_USER_MODE_EXECUTE_MASK                                  0x01
#define EPTE_USER_MODE_EXECUTE(_)                                    (((_) >> 10) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
         */
        UINT64_t page_frame_number : 36;
#define EPTE_PAGE_FRAME_NUMBER_BIT                                   12
#define EPTE_PAGE_FRAME_NUMBER_FLAG                                  0xFFFFFFFFF000
#define EPTE_PAGE_FRAME_NUMBER_MASK                                  0xFFFFFFFFF
#define EPTE_PAGE_FRAME_NUMBER(_)                                    (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved3 : 15;

        /**
         * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations caused by accesses to this
         * page are convertible to virtualization exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
         * 0, this bit is ignored.
         *
         * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
         */
        UINT64_t suppress_ve : 1;
#define EPTE_SUPPRESS_VE_BIT                                         63
#define EPTE_SUPPRESS_VE_FLAG                                        0x8000000000000000
#define EPTE_SUPPRESS_VE_MASK                                        0x01
#define EPTE_SUPPRESS_VE(_)                                          (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} ept_pte;

/**
 * @brief Format of a common EPT Entry
 */
typedef union
{
    struct
    {
        UINT64_t read_access : 1;
#define EPT_ENTRY_READ_ACCESS_BIT                                    0
#define EPT_ENTRY_READ_ACCESS_FLAG                                   0x01
#define EPT_ENTRY_READ_ACCESS_MASK                                   0x01
#define EPT_ENTRY_READ_ACCESS(_)                                     (((_) >> 0) & 0x01)
        UINT64_t write_access : 1;
#define EPT_ENTRY_WRITE_ACCESS_BIT                                   1
#define EPT_ENTRY_WRITE_ACCESS_FLAG                                  0x02
#define EPT_ENTRY_WRITE_ACCESS_MASK                                  0x01
#define EPT_ENTRY_WRITE_ACCESS(_)                                    (((_) >> 1) & 0x01)
        UINT64_t execute_access : 1;
#define EPT_ENTRY_EXECUTE_ACCESS_BIT                                 2
#define EPT_ENTRY_EXECUTE_ACCESS_FLAG                                0x04
#define EPT_ENTRY_EXECUTE_ACCESS_MASK                                0x01
#define EPT_ENTRY_EXECUTE_ACCESS(_)                                  (((_) >> 2) & 0x01)
        UINT64_t memory_type : 3;
#define EPT_ENTRY_MEMORY_TYPE_BIT                                    3
#define EPT_ENTRY_MEMORY_TYPE_FLAG                                   0x38
#define EPT_ENTRY_MEMORY_TYPE_MASK                                   0x07
#define EPT_ENTRY_MEMORY_TYPE(_)                                     (((_) >> 3) & 0x07)
        UINT64_t ignore_pat : 1;
#define EPT_ENTRY_IGNORE_PAT_BIT                                     6
#define EPT_ENTRY_IGNORE_PAT_FLAG                                    0x40
#define EPT_ENTRY_IGNORE_PAT_MASK                                    0x01
#define EPT_ENTRY_IGNORE_PAT(_)                                      (((_) >> 6) & 0x01)
        UINT64_t large_page : 1;
#define EPT_ENTRY_LARGE_PAGE_BIT                                     7
#define EPT_ENTRY_LARGE_PAGE_FLAG                                    0x80
#define EPT_ENTRY_LARGE_PAGE_MASK                                    0x01
#define EPT_ENTRY_LARGE_PAGE(_)                                      (((_) >> 7) & 0x01)
        UINT64_t accessed : 1;
#define EPT_ENTRY_ACCESSED_BIT                                       8
#define EPT_ENTRY_ACCESSED_FLAG                                      0x100
#define EPT_ENTRY_ACCESSED_MASK                                      0x01
#define EPT_ENTRY_ACCESSED(_)                                        (((_) >> 8) & 0x01)
        UINT64_t dirty : 1;
#define EPT_ENTRY_DIRTY_BIT                                          9
#define EPT_ENTRY_DIRTY_FLAG                                         0x200
#define EPT_ENTRY_DIRTY_MASK                                         0x01
#define EPT_ENTRY_DIRTY(_)                                           (((_) >> 9) & 0x01)
        UINT64_t user_mode_execute : 1;
#define EPT_ENTRY_USER_MODE_EXECUTE_BIT                              10
#define EPT_ENTRY_USER_MODE_EXECUTE_FLAG                             0x400
#define EPT_ENTRY_USER_MODE_EXECUTE_MASK                             0x01
#define EPT_ENTRY_USER_MODE_EXECUTE(_)                               (((_) >> 10) & 0x01)
        UINT64_t reserved1 : 1;
        UINT64_t page_frame_number : 36;
#define EPT_ENTRY_PAGE_FRAME_NUMBER_BIT                              12
#define EPT_ENTRY_PAGE_FRAME_NUMBER_FLAG                             0xFFFFFFFFF000
#define EPT_ENTRY_PAGE_FRAME_NUMBER_MASK                             0xFFFFFFFFF
#define EPT_ENTRY_PAGE_FRAME_NUMBER(_)                               (((_) >> 12) & 0xFFFFFFFFF)
        UINT64_t reserved2 : 15;
        UINT64_t suppress_ve : 1;
#define EPT_ENTRY_SUPPRESS_VE_BIT                                    63
#define EPT_ENTRY_SUPPRESS_VE_FLAG                                   0x8000000000000000
#define EPT_ENTRY_SUPPRESS_VE_MASK                                   0x01
#define EPT_ENTRY_SUPPRESS_VE(_)                                     (((_) >> 63) & 0x01)
    };

    UINT64_t flags;
} ept_entry;

/**
 * @defgroup ept_table_level \
 *           EPT Table level numbers
 *
 * EPT Table level numbers.
 * @{
 */
#define EPT_LEVEL_PML4E                                              0x00000003
#define EPT_LEVEL_PDPTE                                              0x00000002
#define EPT_LEVEL_PDE                                                0x00000001
#define EPT_LEVEL_PTE                                                0x00000000
 /**
  * @}
  */

  /**
   * @defgroup ept_entry_count \
   *           EPT Entry counts
   *
   * EPT Entry counts.
   * @{
   */
#define EPT_PML4E_ENTRY_COUNT                                        0x00000200
#define EPT_PDPTE_ENTRY_COUNT                                        0x00000200
#define EPT_PDE_ENTRY_COUNT                                          0x00000200
#define EPT_PTE_ENTRY_COUNT                                          0x00000200
   /**
    * @}
    */

    /**
     * @}
     */

typedef enum
{
    /**
     * If the INVEPT type is 1, the logical processor invalidates all guest-physical mappings and combined mappings associated
     * with the EP4TA specified in the INVEPT descriptor. Combined mappings for that EP4TA are invalidated for all VPIDs and
     * all PCIDs. (The instruction may invalidate mappings associated with other EP4TAs.)
     */
    invept_single_context = 0x00000001,

    /**
     * If the INVEPT type is 2, the logical processor invalidates guest-physical mappings and combined mappings associated with
     * all EP4TAs (and, for combined mappings, for all VPIDs and PCIDs).
     */
     invept_all_context = 0x00000002,
} invept_type;

typedef enum
{
    /**
     * If the INVVPID type is 0, the logical processor invalidates linear mappings and combined mappings associated with the
     * VPID specified in the INVVPID descriptor and that would be used to translate the linear address specified in of the
     * INVVPID descriptor. Linear mappings and combined mappings for that VPID and linear address are invalidated for all PCIDs
     * and, for combined mappings, all EP4TAs. (The instruction may also invalidate mappings associated with other VPIDs and
     * for other linear addresses).
     */
    invvpid_individual_address = 0x00000000,

    /**
     * If the INVVPID type is 1, the logical processor invalidates all linear mappings and combined mappings associated with
     * the VPID specified in the INVVPID descriptor. Linear mappings and combined mappings for that VPID are invalidated for
     * all PCIDs and, for combined mappings, all EP4TAs. (The instruction may also invalidate mappings associated with other
     * VPIDs).
     */
     invvpid_single_context = 0x00000001,

     /**
      * If the INVVPID type is 2, the logical processor invalidates linear mappings and combined mappings associated with all
      * VPIDs except VPID 0000H and with all PCIDs. (The instruction may also invalidate linear mappings with VPID 0000H.)
      * Combined mappings are invalidated for all EP4TAs.
      */
      invvpid_all_context = 0x00000002,

      /**
       * If the INVVPID type is 3, the logical processor invalidates linear mappings and combined mappings associated with the
       * VPID specified in the INVVPID descriptor. Linear mappings and combined mappings for that VPID are invalidated for all
       * PCIDs and, for combined mappings, all EP4TAs. The logical processor is not required to invalidate information that was
       * used for global translations (although it may do so). (The instruction may also invalidate mappings associated with
       * other VPIDs).
       *
       * @see Vol3C[4.10(Caching Translation Information)]
       */
       invvpid_single_context_retaining_globals = 0x00000003,
} invvpid_type;

typedef struct
{
    UINT64_t ept_pointer;

    /**
     * Must be zero.
     */
    UINT64_t reserved;
} invept_descriptor;

typedef struct
{
    UINT16_t vpid;

    /**
     * Must be zero.
     */
    UINT16_t reserved1;

    /**
     * Must be zero.
     */
    UINT32_t reserved2;
    UINT64_t linear_address;
} invvpid_descriptor;

/**
 * @brief Format of the VMCS Region
 *
 * A logical processor uses virtual-machine control data structures (VMCSs) while it is in VMX operation. These manage
 * transitions into and out of VMX non-root operation (VM entries and VM exits) as well as processor behavior in VMX
 * non-root operation. This structure is manipulated by the new instructions VMCLEAR, VMPTRLD, VMREAD, and VMWRITE.
 * A VMCS region comprises up to 4-KBytes. The exact size is implementation specific and can be determined by consulting
 * the VMX capability MSR IA32_VMX_BASIC.
 *
 * @see Vol3C[24.2(FORMAT OF THE VMCS REGION)] (reference)
 */
typedef struct
{
    struct
    {
        /**
         * @brief VMCS revision identifier
         *
         * [Bits 30:0] Processors that maintain VMCS data in different formats (see below) use different VMCS revision identifiers.
         * These identifiers enable software to avoid using a VMCS region formatted for one processor on a processor that uses a
         * different format.
         * Software should write the VMCS revision identifier to the VMCS region before using that region for a VMCS. The VMCS
         * revision identifier is never written by the processor; VMPTRLD fails if its operand references a VMCS region whose VMCS
         * revision identifier differs from that used by the processor.
         * Software can discover the VMCS revision identifier that a processor uses by reading the VMX capability MSR
         * IA32_VMX_BASIC.
         *
         * @see Vol3C[24.6.2(Processor-Based VM-Execution Controls)]
         * @see Vol3D[A.1(BASIC VMX INFORMATION)]
         */
        UINT32_t revision_id : 31;

        /**
         * @brief Shadow-VMCS indicator
         *
         * [Bit 31] Software should clear or set the shadow-VMCS indicator depending on whether the VMCS is to be an ordinary VMCS
         * or a shadow VMCS. VMPTRLD fails if the shadow-VMCS indicator is set and the processor does not support the 1-setting of
         * the "VMCS shadowing" VM-execution control. Software can discover support for this setting by reading the VMX capability
         * MSR IA32_VMX_PROCBASED_CTLS2.
         *
         * @see Vol3C[24.10(VMCS TYPES ORDINARY AND SHADOW)]
         */
        UINT32_t shadow_vmcs_indicator : 1;
    };


    /**
     * @brief VMX-abort indicator
     *
     * The contents of these bits do not control processor operation in any way. A logical processor writes a non-zero value
     * into these bits if a VMX abort occurs. Software may also write into this field.
     *
     * @see Vol3D[27.7(VMX Aborts)]
     */
    UINT32_t abort_indicator;

    /**
     * @brief VMCS data (implementation-specific format)
     *
     * These parts of the VMCS control VMX non-root operation and the VMX transitions.
     * The format of these data is implementation-specific. To ensure proper behavior in VMX operation, software should
     * maintain the VMCS region and related structures in writeback cacheable memory. Future implementations may allow or
     * require a different memory type. Software should consult the VMX capability MSR IA32_VMX_BASIC.
     *
     * @see Vol3C[24.11.4(Software Access to Related Structures)]
     * @see Vol3D[A.1(BASIC VMX INFORMATION)]
     */
    UINT8_t data[4088];
} vmcs;

/**
 * @brief Format of the VMXON Region
 *
 * Before executing VMXON, software allocates a region of memory that the logical processor uses to support VMX operation.
 * This region is called the VMXON region.
 * A VMXON region comprises up to 4-KBytes. The exact size is implementation specific and can be determined by consulting
 * the VMX capability MSR IA32_VMX_BASIC.
 *
 * @see Vol3C[24.11.5(VMXON Region)] (reference)
 */
typedef struct
{
    struct
    {
        /**
         * @brief VMCS revision identifier
         *
         * [Bits 30:0] Before executing VMXON, software should write the VMCS revision identifier to the VMXON region.
         * (Specifically, it should write the 31-bit VMCS revision identifier to bits 30:0 of the first 4 bytes of the VMXON
         * region; bit 31 should be cleared to 0.)
         *
         * @see VMCS
         * @see Vol3C[24.2(FORMAT OF THE VMCS REGION)]
         * @see Vol3C[24.11.5(VMXON Region)]
         */
        UINT32_t revision_id : 31;

        /**
         * [Bit 31] Bit 31 is always 0.
         */
        UINT32_t must_be_zero : 1;
    };


    /**
     * @brief VMXON data (implementation-specific format)
     *
     * The format of these data is implementation-specific. To ensure proper behavior in VMX operation, software should not
     * access or modify the VMXON region of a logical processor between execution of VMXON and VMXOFF on that logical
     * processor. Doing otherwise may lead to unpredictable behavior.
     *
     * @see Vol3C[24.11.4(Software Access to Related Structures)]
     * @see Vol3D[A.1(BASIC VMX INFORMATION)]
     */
    UINT8_t data[4092];
} vmxon;

/**
 * @defgroup vmcs_fields \
 *           VMCS (VM Control Structure)
 *
 * Every component of the VMCS is encoded by a 32-bit field that can be used by VMREAD and VMWRITE. This enumerates all
 * fields in the VMCS and their encodings. Fields are grouped by width (16-bit, 32-bit, etc.) and type (guest-state,
 * host-state, etc.).
 *
 * @see Vol3D[B(APPENDIX B FIELD ENCODING IN VMCS)] (reference)
 * @{
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Access type (0 = full; 1 = high); must be full for 16-bit, 32-bit, and natural-width fields.
         */
        UINT16_t access_type : 1;
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_BIT                      0
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_FLAG                     0x01
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_MASK                     0x01
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE(_)                       (((_) >> 0) & 0x01)

        /**
         * [Bits 9:1] Index.
         */
        UINT16_t index : 9;
#define VMCS_COMPONENT_ENCODING_INDEX_BIT                            1
#define VMCS_COMPONENT_ENCODING_INDEX_FLAG                           0x3FE
#define VMCS_COMPONENT_ENCODING_INDEX_MASK                           0x1FF
#define VMCS_COMPONENT_ENCODING_INDEX(_)                             (((_) >> 1) & 0x1FF)

        /**
         * [Bits 11:10] Type:
         * 0: control
         * 1: VM-exit information
         * 2: guest state
         * 3: host state
         */
        UINT16_t type : 2;
#define VMCS_COMPONENT_ENCODING_TYPE_BIT                             10
#define VMCS_COMPONENT_ENCODING_TYPE_FLAG                            0xC00
#define VMCS_COMPONENT_ENCODING_TYPE_MASK                            0x03
#define VMCS_COMPONENT_ENCODING_TYPE(_)                              (((_) >> 10) & 0x03)

        /**
         * [Bit 12] Reserved (must be 0).
         */
        UINT16_t must_be_zero : 1;
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_BIT                     12
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_FLAG                    0x1000
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_MASK                    0x01
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO(_)                      (((_) >> 12) & 0x01)

        /**
         * [Bits 14:13] Width:
         * 0: 16-bit
         * 1: 64-bit
         * 2: 32-bit
         * 3: natural-width
         */
        UINT16_t width : 2;
#define VMCS_COMPONENT_ENCODING_WIDTH_BIT                            13
#define VMCS_COMPONENT_ENCODING_WIDTH_FLAG                           0x6000
#define VMCS_COMPONENT_ENCODING_WIDTH_MASK                           0x03
#define VMCS_COMPONENT_ENCODING_WIDTH(_)                             (((_) >> 13) & 0x03)
        UINT16_t reserved1 : 1;
    };

    UINT16_t flags;
} vmcs_component_encoding;

/**
 * @defgroup vmcs_16_bit \
 *           16-Bit Fields
 *
 * 16-Bit Fields.
 *
 * @see Vol3D[B.1(16-BIT FIELDS)] (reference)
 * @{
 */
 /**
  * @defgroup vmcs_16_bit_control_fields \
  *           16-Bit Control Fields
  *
  * 16-Bit Control Fields.
  * @{
  */
  /**
   * Virtual-processor identifier (VPID).
   *
   * @remarks This field exists only on processors that support the 1-setting of the "enable VPID" VM-execution control.
   */
#define VMCS_CTRL_VIRTUAL_PROCESSOR_IDENTIFIER                       0x00000000

   /**
    * Posted-interrupt notification vector.
    *
    * @remarks This field exists only on processors that support the 1-setting of the "process posted interrupts" VM-execution
    *          control.
    */
#define VMCS_CTRL_POSTED_INTERRUPT_NOTIFICATION_VECTOR               0x00000002

    /**
     * EPTP index.
     *
     * @remarks This field exists only on processors that support the 1-setting of the "EPT-violation \#VE" VM-execution
     *          control.
     */
#define VMCS_CTRL_EPTP_INDEX                                         0x00000004
     /**
      * @}
      */

      /**
       * @defgroup vmcs_16_bit_guest_state_fields \
       *           16-Bit Guest-State Fields
       *
       * 16-Bit Guest-State Fields.
       * @{
       */
       /**
        * Guest ES selector.
        */
#define VMCS_GUEST_ES_SELECTOR                                       0x00000800

        /**
         * Guest CS selector.
         */
#define VMCS_GUEST_CS_SELECTOR                                       0x00000802

         /**
          * Guest SS selector.
          */
#define VMCS_GUEST_SS_SELECTOR                                       0x00000804

          /**
           * Guest DS selector.
           */
#define VMCS_GUEST_DS_SELECTOR                                       0x00000806

           /**
            * Guest FS selector.
            */
#define VMCS_GUEST_FS_SELECTOR                                       0x00000808

            /**
             * Guest GS selector.
             */
#define VMCS_GUEST_GS_SELECTOR                                       0x0000080A

             /**
              * Guest LDTR selector.
              */
#define VMCS_GUEST_LDTR_SELECTOR                                     0x0000080C

              /**
               * Guest TR selector.
               */
#define VMCS_GUEST_TR_SELECTOR                                       0x0000080E

               /**
                * Guest interrupt status.
                *
                * @remarks This field exists only on processors that support the 1-setting of the "virtual-interrupt delivery"
                *          VM-execution control.
                */
#define VMCS_GUEST_INTERRUPT_STATUS                                  0x00000810

                /**
                 * PML index.
                 *
                 * @remarks This field exists only on processors that support the 1-setting of the "enable PML" VM-execution control.
                 */
#define VMCS_GUEST_PML_INDEX                                         0x00000812
                 /**
                  * @}
                  */

                  /**
                   * @defgroup vmcs_16_bit_host_state_fields \
                   *           16-Bit Host-State Fields
                   *
                   * 16-Bit Host-State Fields.
                   * @{
                   */
                   /**
                    * Host ES selector.
                    */
#define VMCS_HOST_ES_SELECTOR                                        0x00000C00

                    /**
                     * Host CS selector.
                     */
#define VMCS_HOST_CS_SELECTOR                                        0x00000C02

                     /**
                      * Host SS selector.
                      */
#define VMCS_HOST_SS_SELECTOR                                        0x00000C04

                      /**
                       * Host DS selector.
                       */
#define VMCS_HOST_DS_SELECTOR                                        0x00000C06

                       /**
                        * Host FS selector.
                        */
#define VMCS_HOST_FS_SELECTOR                                        0x00000C08

                        /**
                         * Host GS selector.
                         */
#define VMCS_HOST_GS_SELECTOR                                        0x00000C0A

                         /**
                          * Host TR selector.
                          */
#define VMCS_HOST_TR_SELECTOR                                        0x00000C0C
                          /**
                           * @}
                           */

                           /**
                            * @}
                            */

                            /**
                             * @defgroup vmcs_64_bit \
                             *           64-Bit Fields
                             *
                             * 64-Bit Fields.
                             *
                             * @see Vol3D[B.2(64-BIT FIELDS)] (reference)
                             * @{
                             */
                             /**
                              * @defgroup vmcs_64_bit_control_fields \
                              *           64-Bit Control Fields
                              *
                              * 64-Bit Control Fields.
                              * @{
                              */
                              /**
                               * Address of I/O bitmap A.
                               */
#define VMCS_CTRL_IO_BITMAP_A_ADDRESS                                0x00002000

                               /**
                                * Address of I/O bitmap B.
                                */
#define VMCS_CTRL_IO_BITMAP_B_ADDRESS                                0x00002002

                                /**
                                 * Address of MSR bitmaps.
                                 */
#define VMCS_CTRL_MSR_BITMAP_ADDRESS                                 0x00002004

                                 /**
                                  * VM-exit MSR-store address.
                                  */
#define VMCS_CTRL_VMEXIT_MSR_STORE_ADDRESS                           0x00002006

                                  /**
                                   * VM-exit MSR-load address.
                                   */
#define VMCS_CTRL_VMEXIT_MSR_LOAD_ADDRESS                            0x00002008

                                   /**
                                    * VM-entry MSR-load address.
                                    */
#define VMCS_CTRL_VMENTRY_MSR_LOAD_ADDRESS                           0x0000200A

                                    /**
                                     * Executive-VMCS pointer.
                                     */
#define VMCS_CTRL_EXECUTIVE_VMCS_POINTER                             0x0000200C

                                     /**
                                      * PML address.
                                      */
#define VMCS_CTRL_PML_ADDRESS                                        0x0000200E

                                      /**
                                       * TSC offset.
                                       */
#define VMCS_CTRL_TSC_OFFSET                                         0x00002010

                                       /**
                                        * Virtual-APIC address.
                                        */
#define VMCS_CTRL_VIRTUAL_APIC_ADDRESS                               0x00002012

                                        /**
                                         * APIC-access address.
                                         */
#define VMCS_CTRL_APIC_ACCESS_ADDRESS                                0x00002014

                                         /**
                                          * Posted-interrupt descriptor address
                                          */
#define VMCS_CTRL_POSTED_INTERRUPT_DESCRIPTOR_ADDRESS                0x00002016

                                          /**
                                           * VM-function controls.
                                           */
#define VMCS_CTRL_VMFUNC_CONTROLS                                    0x00002018

                                           /**
                                            * EPT pointer.
                                            */
#define VMCS_CTRL_EPT_POINTER                                        0x0000201A

                                            /**
                                             * EOI-exit bitmap 0.
                                             */
#define VMCS_CTRL_EOI_EXIT_BITMAP_0                                  0x0000201C

                                             /**
                                              * EOI-exit bitmap 1.
                                              */
#define VMCS_CTRL_EOI_EXIT_BITMAP_1                                  0x0000201E

                                              /**
                                               * EOI-exit bitmap 2.
                                               */
#define VMCS_CTRL_EOI_EXIT_BITMAP_2                                  0x00002020

                                               /**
                                                * EOI-exit bitmap 3.
                                                */
#define VMCS_CTRL_EOI_EXIT_BITMAP_3                                  0x00002022

                                                /**
                                                 * EPTP-list address.
                                                 */
#define VMCS_CTRL_EPT_POINTER_LIST_ADDRESS                           0x00002024

                                                 /**
                                                  * VMREAD-bitmap address.
                                                  */
#define VMCS_CTRL_VMREAD_BITMAP_ADDRESS                              0x00002026

                                                  /**
                                                   * VMWRITE-bitmap address.
                                                   */
#define VMCS_CTRL_VMWRITE_BITMAP_ADDRESS                             0x00002028

                                                   /**
                                                    * Virtualization-exception information address.
                                                    */
#define VMCS_CTRL_VIRTUALIZATION_EXCEPTION_INFORMATION_ADDRESS       0x0000202A

                                                    /**
                                                     * XSS-exiting bitmap.
                                                     */
#define VMCS_CTRL_XSS_EXITING_BITMAP                                 0x0000202C

                                                     /**
                                                      * ENCLS-exiting bitmap.
                                                      */
#define VMCS_CTRL_ENCLS_EXITING_BITMAP                               0x0000202E

                                                      /**
                                                       * TSC multiplier.
                                                       */
#define VMCS_CTRL_TSC_MULTIPLIER                                     0x00002032
                                                       /**
                                                        * @}
                                                        */

                                                        /**
                                                         * @defgroup vmcs_64_bit_read_only_data_fields \
                                                         *           64-Bit Read-Only Data Field
                                                         *
                                                         * 64-Bit Read-Only Data Field.
                                                         * @{
                                                         */
                                                         /**
                                                          * Guest-physical address.
                                                          */
#define VMCS_GUEST_PHYSICAL_ADDRESS                                  0x00002400
                                                          /**
                                                           * @}
                                                           */

                                                           /**
                                                            * @defgroup vmcs_64_bit_guest_state_fields \
                                                            *           64-Bit Guest-State Fields
                                                            *
                                                            * 64-Bit Guest-State Fields.
                                                            * @{
                                                            */
                                                            /**
                                                             * VMCS link pointer.
                                                             */
#define VMCS_GUEST_VMCS_LINK_POINTER                                 0x00002800

                                                             /**
                                                              * Guest IA32_DEBUGCTL.
                                                              */
#define VMCS_GUEST_DEBUGCTL                                          0x00002802

                                                              /**
                                                               * Guest IA32_PAT.
                                                               */
#define VMCS_GUEST_PAT                                               0x00002804

                                                               /**
                                                                * Guest IA32_EFER.
                                                                */
#define VMCS_GUEST_EFER                                              0x00002806

                                                                /**
                                                                 * Guest IA32_PERF_GLOBAL_CTRL.
                                                                 */
#define VMCS_GUEST_PERF_GLOBAL_CTRL                                  0x00002808

                                                                 /**
                                                                  * Guest PDPTE0.
                                                                  */
#define VMCS_GUEST_PDPTE0                                            0x0000280A

                                                                  /**
                                                                   * Guest PDPTE1.
                                                                   */
#define VMCS_GUEST_PDPTE1                                            0x0000280C

                                                                   /**
                                                                    * Guest PDPTE2.
                                                                    */
#define VMCS_GUEST_PDPTE2                                            0x0000280E

                                                                    /**
                                                                     * Guest PDPTE3.
                                                                     */
#define VMCS_GUEST_PDPTE3                                            0x00002810

                                                                     /**
                                                                      * Guest IA32_BNDCFGS.
                                                                      */
#define VMCS_GUEST_BNDCFGS                                           0x00002812

                                                                      /**
                                                                       * Guest IA32_RTIT_CTL.
                                                                       */
#define VMCS_GUEST_RTIT_CTL                                          0x00002814
                                                                       /**
                                                                        * @}
                                                                        */

                                                                        /**
                                                                         * @defgroup vmcs_64_bit_host_state_fields \
                                                                         *           64-Bit Host-State Fields
                                                                         *
                                                                         * 64-Bit Host-State Fields.
                                                                         * @{
                                                                         */
                                                                         /**
                                                                          * Host IA32_PAT.
                                                                          */
#define VMCS_HOST_PAT                                                0x00002C00

                                                                          /**
                                                                           * Host IA32_EFER.
                                                                           */
#define VMCS_HOST_EFER                                               0x00002C02

                                                                           /**
                                                                            * Host IA32_PERF_GLOBAL_CTRL.
                                                                            */
#define VMCS_HOST_PERF_GLOBAL_CTRL                                   0x00002C04
                                                                            /**
                                                                             * @}
                                                                             */

                                                                             /**
                                                                              * @}
                                                                              */

                                                                              /**
                                                                               * @defgroup vmcs_32_bit \
                                                                               *           32-Bit Fields
                                                                               *
                                                                               * 32-Bit Fields.
                                                                               *
                                                                               * @see Vol3D[B.3(32-BIT FIELDS)] (reference)
                                                                               * @{
                                                                               */
                                                                               /**
                                                                                * @defgroup vmcs_32_bit_control_fields \
                                                                                *           32-Bit Control Fields
                                                                                *
                                                                                * 32-Bit Control Fields.
                                                                                * @{
                                                                                */
                                                                                /**
                                                                                 * Pin-based VM-execution controls.
                                                                                 */
#define VMCS_CTRL_PIN_BASED_VM_EXECUTION_CONTROLS                    0x00004000

                                                                                 /**
                                                                                  * Primary processor-based VM-execution controls.
                                                                                  */
#define VMCS_CTRL_PROCESSOR_BASED_VM_EXECUTION_CONTROLS              0x00004002

                                                                                  /**
                                                                                   * Exception bitmap.
                                                                                   */
#define VMCS_CTRL_EXCEPTION_BITMAP                                   0x00004004

                                                                                   /**
                                                                                    * Page-fault error-code mask.
                                                                                    */
#define VMCS_CTRL_PAGEFAULT_ERROR_CODE_MASK                          0x00004006

                                                                                    /**
                                                                                     * Page-fault error-code match.
                                                                                     */
#define VMCS_CTRL_PAGEFAULT_ERROR_CODE_MATCH                         0x00004008

                                                                                     /**
                                                                                      * CR3-target count.
                                                                                      */
#define VMCS_CTRL_CR3_TARGET_COUNT                                   0x0000400A

                                                                                      /**
                                                                                       * VM-exit controls.
                                                                                       */
#define VMCS_CTRL_VMEXIT_CONTROLS                                    0x0000400C

                                                                                       /**
                                                                                        * VM-exit MSR-store count.
                                                                                        */
#define VMCS_CTRL_VMEXIT_MSR_STORE_COUNT                             0x0000400E

                                                                                        /**
                                                                                         * VM-exit MSR-load count.
                                                                                         */
#define VMCS_CTRL_VMEXIT_MSR_LOAD_COUNT                              0x00004010

                                                                                         /**
                                                                                          * VM-entry controls.
                                                                                          */
#define VMCS_CTRL_VMENTRY_CONTROLS                                   0x00004012

                                                                                          /**
                                                                                           * VM-entry MSR-load count.
                                                                                           */
#define VMCS_CTRL_VMENTRY_MSR_LOAD_COUNT                             0x00004014

                                                                                           /**
                                                                                            * VM-entry interruption-information field.
                                                                                            */
#define VMCS_CTRL_VMENTRY_INTERRUPTION_INFORMATION_FIELD             0x00004016

                                                                                            /**
                                                                                             * VM-entry exception error code.
                                                                                             */
#define VMCS_CTRL_VMENTRY_EXCEPTION_ERROR_CODE                       0x00004018

                                                                                             /**
                                                                                              * VM-entry instruction length.
                                                                                              */
#define VMCS_CTRL_VMENTRY_INSTRUCTION_LENGTH                         0x0000401A

                                                                                              /**
                                                                                               * TPR threshold.
                                                                                               */
#define VMCS_CTRL_TPR_THRESHOLD                                      0x0000401C

                                                                                               /**
                                                                                                * Secondary processor-based VM-execution controls.
                                                                                                */
#define VMCS_CTRL_SECONDARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS    0x0000401E

                                                                                                /**
                                                                                                 * PLE_Gap.
                                                                                                 */
#define VMCS_CTRL_PLE_GAP                                            0x00004020

                                                                                                 /**
                                                                                                  * PLE_Window.
                                                                                                  */
#define VMCS_CTRL_PLE_WINDOW                                         0x00004022
                                                                                                  /**
                                                                                                   * @}
                                                                                                   */

                                                                                                   /**
                                                                                                    * @defgroup vmcs_32_bit_read_only_data_fields \
                                                                                                    *           32-Bit Read-Only Data Fields
                                                                                                    *
                                                                                                    * 32-Bit Read-Only Data Fields.
                                                                                                    * @{
                                                                                                    */
                                                                                                    /**
                                                                                                     * VM-instruction error.
                                                                                                     */
#define VMCS_VM_INSTRUCTION_ERROR                                    0x00004400

                                                                                                     /**
                                                                                                      * Exit reason.
                                                                                                      */
#define VMCS_EXIT_REASON                                             0x00004402

                                                                                                      /**
                                                                                                       * VM-exit interruption information.
                                                                                                       */
#define VMCS_VMEXIT_INTERRUPTION_INFORMATION                         0x00004404

                                                                                                       /**
                                                                                                        * VM-exit interruption error code.
                                                                                                        */
#define VMCS_VMEXIT_INTERRUPTION_ERROR_CODE                          0x00004406

                                                                                                        /**
                                                                                                         * IDT-vectoring information field.
                                                                                                         */
#define VMCS_IDT_VECTORING_INFORMATION                               0x00004408

                                                                                                         /**
                                                                                                          * IDT-vectoring error code.
                                                                                                          */
#define VMCS_IDT_VECTORING_ERROR_CODE                                0x0000440A

                                                                                                          /**
                                                                                                           * VM-exit instruction length.
                                                                                                           */
#define VMCS_VMEXIT_INSTRUCTION_LENGTH                               0x0000440C

                                                                                                           /**
                                                                                                            * VM-exit instruction information.
                                                                                                            */
#define VMCS_VMEXIT_INSTRUCTION_INFO                                 0x0000440E
                                                                                                            /**
                                                                                                             * @}
                                                                                                             */

                                                                                                             /**
                                                                                                              * @defgroup vmcs_32_bit_guest_state_fields \
                                                                                                              *           32-Bit Guest-State Fields
                                                                                                              *
                                                                                                              * 32-Bit Guest-State Fields.
                                                                                                              * @{
                                                                                                              */
                                                                                                              /**
                                                                                                               * Guest ES limit.
                                                                                                               */
#define VMCS_GUEST_ES_LIMIT                                          0x00004800

                                                                                                               /**
                                                                                                                * Guest CS limit.
                                                                                                                */
#define VMCS_GUEST_CS_LIMIT                                          0x00004802

                                                                                                                /**
                                                                                                                 * Guest SS limit.
                                                                                                                 */
#define VMCS_GUEST_SS_LIMIT                                          0x00004804

                                                                                                                 /**
                                                                                                                  * Guest DS limit.
                                                                                                                  */
#define VMCS_GUEST_DS_LIMIT                                          0x00004806

                                                                                                                  /**
                                                                                                                   * Guest FS limit.
                                                                                                                   */
#define VMCS_GUEST_FS_LIMIT                                          0x00004808

                                                                                                                   /**
                                                                                                                    * Guest GS limit.
                                                                                                                    */
#define VMCS_GUEST_GS_LIMIT                                          0x0000480A

                                                                                                                    /**
                                                                                                                     * Guest LDTR limit.
                                                                                                                     */
#define VMCS_GUEST_LDTR_LIMIT                                        0x0000480C

                                                                                                                     /**
                                                                                                                      * Guest TR limit.
                                                                                                                      */
#define VMCS_GUEST_TR_LIMIT                                          0x0000480E

                                                                                                                      /**
                                                                                                                       * Guest GDTR limit.
                                                                                                                       */
#define VMCS_GUEST_GDTR_LIMIT                                        0x00004810

                                                                                                                       /**
                                                                                                                        * Guest IDTR limit.
                                                                                                                        */
#define VMCS_GUEST_IDTR_LIMIT                                        0x00004812

                                                                                                                        /**
                                                                                                                         * Guest ES access rights.
                                                                                                                         */
#define VMCS_GUEST_ES_ACCESS_RIGHTS                                  0x00004814

                                                                                                                         /**
                                                                                                                          * Guest CS access rights.
                                                                                                                          */
#define VMCS_GUEST_CS_ACCESS_RIGHTS                                  0x00004816

                                                                                                                          /**
                                                                                                                           * Guest SS access rights.
                                                                                                                           */
#define VMCS_GUEST_SS_ACCESS_RIGHTS                                  0x00004818

                                                                                                                           /**
                                                                                                                            * Guest DS access rights.
                                                                                                                            */
#define VMCS_GUEST_DS_ACCESS_RIGHTS                                  0x0000481A

                                                                                                                            /**
                                                                                                                             * Guest FS access rights.
                                                                                                                             */
#define VMCS_GUEST_FS_ACCESS_RIGHTS                                  0x0000481C

                                                                                                                             /**
                                                                                                                              * Guest GS access rights.
                                                                                                                              */
#define VMCS_GUEST_GS_ACCESS_RIGHTS                                  0x0000481E

                                                                                                                              /**
                                                                                                                               * Guest LDTR access rights.
                                                                                                                               */
#define VMCS_GUEST_LDTR_ACCESS_RIGHTS                                0x00004820

                                                                                                                               /**
                                                                                                                                * Guest TR access rights.
                                                                                                                                */
#define VMCS_GUEST_TR_ACCESS_RIGHTS                                  0x00004822

                                                                                                                                /**
                                                                                                                                 * Guest interruptibility state.
                                                                                                                                 */
#define VMCS_GUEST_INTERRUPTIBILITY_STATE                            0x00004824

                                                                                                                                 /**
                                                                                                                                  * Guest activity state.
                                                                                                                                  */
#define VMCS_GUEST_ACTIVITY_STATE                                    0x00004826

                                                                                                                                  /**
                                                                                                                                   * Guest SMBASE.
                                                                                                                                   */
#define VMCS_GUEST_SMBASE                                            0x00004828

                                                                                                                                   /**
                                                                                                                                    * Guest IA32_SYSENTER_CS.
                                                                                                                                    */
#define VMCS_GUEST_SYSENTER_CS                                       0x0000482A

                                                                                                                                    /**
                                                                                                                                     * VMX-preemption timer value.
                                                                                                                                     */
#define VMCS_GUEST_VMX_PREEMPTION_TIMER_VALUE                        0x0000482E
                                                                                                                                     /**
                                                                                                                                      * @}
                                                                                                                                      */

                                                                                                                                      /**
                                                                                                                                       * @defgroup vmcs_32_bit_host_state_fields \
                                                                                                                                       *           32-Bit Host-State Field
                                                                                                                                       *
                                                                                                                                       * 32-Bit Host-State Field.
                                                                                                                                       * @{
                                                                                                                                       */
                                                                                                                                       /**
                                                                                                                                        * Host IA32_SYSENTER_CS.
                                                                                                                                        */
#define VMCS_HOST_SYSENTER_CS                                        0x00004C00
                                                                                                                                        /**
                                                                                                                                         * @}
                                                                                                                                         */

                                                                                                                                         /**
                                                                                                                                          * @}
                                                                                                                                          */

                                                                                                                                          /**
                                                                                                                                           * @defgroup vmcs_natural_width \
                                                                                                                                           *           Natural-Width Fields
                                                                                                                                           *
                                                                                                                                           * Natural-Width Fields.
                                                                                                                                           *
                                                                                                                                           * @see Vol3D[B.4(NATURAL-WIDTH FIELDS)] (reference)
                                                                                                                                           * @{
                                                                                                                                           */
                                                                                                                                           /**
                                                                                                                                            * @defgroup vmcs_natural_width_control_fields \
                                                                                                                                            *           Natural-Width Control Fields
                                                                                                                                            *
                                                                                                                                            * Natural-Width Control Fields
                                                                                                                                            * @{
                                                                                                                                            */
                                                                                                                                            /**
                                                                                                                                             * CR0 guest/host mask.
                                                                                                                                             */
#define VMCS_CTRL_CR0_GUEST_HOST_MASK                                0x00006000

                                                                                                                                             /**
                                                                                                                                              * CR4 guest/host mask.
                                                                                                                                              */
#define VMCS_CTRL_CR4_GUEST_HOST_MASK                                0x00006002

                                                                                                                                              /**
                                                                                                                                               * CR0 read shadow.
                                                                                                                                               */
#define VMCS_CTRL_CR0_READ_SHADOW                                    0x00006004

                                                                                                                                               /**
                                                                                                                                                * CR4 read shadow.
                                                                                                                                                */
#define VMCS_CTRL_CR4_READ_SHADOW                                    0x00006006

                                                                                                                                                /**
                                                                                                                                                 * CR3-target value 0.
                                                                                                                                                 */
#define VMCS_CTRL_CR3_TARGET_VALUE_0                                 0x00006008

                                                                                                                                                 /**
                                                                                                                                                  * CR3-target value 1.
                                                                                                                                                  */
#define VMCS_CTRL_CR3_TARGET_VALUE_1                                 0x0000600A

                                                                                                                                                  /**
                                                                                                                                                   * CR3-target value 2.
                                                                                                                                                   */
#define VMCS_CTRL_CR3_TARGET_VALUE_2                                 0x0000600C

                                                                                                                                                   /**
                                                                                                                                                    * CR3-target value 3.
                                                                                                                                                    */
#define VMCS_CTRL_CR3_TARGET_VALUE_3                                 0x0000600E
                                                                                                                                                    /**
                                                                                                                                                     * @}
                                                                                                                                                     */

                                                                                                                                                     /**
                                                                                                                                                      * @defgroup vmcs_natural_width_read_only_data_fields \
                                                                                                                                                      *           Natural-Width Read-Only Data Fields
                                                                                                                                                      *
                                                                                                                                                      * Natural-Width Read-Only Data Fields.
                                                                                                                                                      * @{
                                                                                                                                                      */
                                                                                                                                                      /**
                                                                                                                                                       * Exit qualification.
                                                                                                                                                       */
#define VMCS_EXIT_QUALIFICATION                                      0x00006400

                                                                                                                                                       /**
                                                                                                                                                        * I/O RCX.
                                                                                                                                                        */
#define VMCS_IO_RCX                                                  0x00006402

                                                                                                                                                        /**
                                                                                                                                                         * I/O RSI.
                                                                                                                                                         */
#define VMCS_IO_RSX                                                  0x00006404

                                                                                                                                                         /**
                                                                                                                                                          * I/O RDI.
                                                                                                                                                          */
#define VMCS_IO_RDI                                                  0x00006406

                                                                                                                                                          /**
                                                                                                                                                           * I/O RIP.
                                                                                                                                                           */
#define VMCS_IO_RIP                                                  0x00006408

                                                                                                                                                           /**
                                                                                                                                                            * Guest-linear address.
                                                                                                                                                            */
#define VMCS_EXIT_GUEST_LINEAR_ADDRESS                               0x0000640A
                                                                                                                                                            /**
                                                                                                                                                             * @}
                                                                                                                                                             */

                                                                                                                                                             /**
                                                                                                                                                              * @defgroup vmcs_natural_width_guest_state_fields \
                                                                                                                                                              *           Natural-Width Guest-State Fields
                                                                                                                                                              *
                                                                                                                                                              * Natural-Width Guest-State Fields.
                                                                                                                                                              * @{
                                                                                                                                                              */
                                                                                                                                                              /**
                                                                                                                                                               * Guest CR0.
                                                                                                                                                               */
#define VMCS_GUEST_CR0                                               0x00006800

                                                                                                                                                               /**
                                                                                                                                                                * Guest CR3.
                                                                                                                                                                */
#define VMCS_GUEST_CR3                                               0x00006802

                                                                                                                                                                /**
                                                                                                                                                                 * Guest CR4.
                                                                                                                                                                 */
#define VMCS_GUEST_CR4                                               0x00006804

                                                                                                                                                                 /**
                                                                                                                                                                  * Guest ES base.
                                                                                                                                                                  */
#define VMCS_GUEST_ES_BASE                                           0x00006806

                                                                                                                                                                  /**
                                                                                                                                                                   * Guest CS base.
                                                                                                                                                                   */
#define VMCS_GUEST_CS_BASE                                           0x00006808

                                                                                                                                                                   /**
                                                                                                                                                                    * Guest SS base.
                                                                                                                                                                    */
#define VMCS_GUEST_SS_BASE                                           0x0000680A

                                                                                                                                                                    /**
                                                                                                                                                                     * Guest DS base.
                                                                                                                                                                     */
#define VMCS_GUEST_DS_BASE                                           0x0000680C

                                                                                                                                                                     /**
                                                                                                                                                                      * Guest FS base.
                                                                                                                                                                      */
#define VMCS_GUEST_FS_BASE                                           0x0000680E

                                                                                                                                                                      /**
                                                                                                                                                                       * Guest GS base.
                                                                                                                                                                       */
#define VMCS_GUEST_GS_BASE                                           0x00006810

                                                                                                                                                                       /**
                                                                                                                                                                        * Guest LDTR base.
                                                                                                                                                                        */
#define VMCS_GUEST_LDTR_BASE                                         0x00006812

                                                                                                                                                                        /**
                                                                                                                                                                         * Guest TR base.
                                                                                                                                                                         */
#define VMCS_GUEST_TR_BASE                                           0x00006814

                                                                                                                                                                         /**
                                                                                                                                                                          * Guest GDTR base.
                                                                                                                                                                          */
#define VMCS_GUEST_GDTR_BASE                                         0x00006816

                                                                                                                                                                          /**
                                                                                                                                                                           * Guest IDTR base.
                                                                                                                                                                           */
#define VMCS_GUEST_IDTR_BASE                                         0x00006818

                                                                                                                                                                           /**
                                                                                                                                                                            * Guest DR7.
                                                                                                                                                                            */
#define VMCS_GUEST_DR7                                               0x0000681A

                                                                                                                                                                            /**
                                                                                                                                                                             * Guest RSP.
                                                                                                                                                                             */
#define VMCS_GUEST_RSP                                               0x0000681C

                                                                                                                                                                             /**
                                                                                                                                                                              * Guest RIP.
                                                                                                                                                                              */
#define VMCS_GUEST_RIP                                               0x0000681E

                                                                                                                                                                              /**
                                                                                                                                                                               * Guest RFLAGS.
                                                                                                                                                                               */
#define VMCS_GUEST_RFLAGS                                            0x00006820

                                                                                                                                                                               /**
                                                                                                                                                                                * Guest pending debug exceptions.
                                                                                                                                                                                */
#define VMCS_GUEST_PENDING_DEBUG_EXCEPTIONS                          0x00006822

                                                                                                                                                                                /**
                                                                                                                                                                                 * Guest IA32_SYSENTER_ESP.
                                                                                                                                                                                 */
#define VMCS_GUEST_SYSENTER_ESP                                      0x00006824

                                                                                                                                                                                 /**
                                                                                                                                                                                  * Guest IA32_SYSENTER_EIP.
                                                                                                                                                                                  */
#define VMCS_GUEST_SYSENTER_EIP                                      0x00006826

                                                                                                                                                                                  /**
                                                                                                                                                                                   * Guest IA32_S_CET.
                                                                                                                                                                                   */
#define VMCS_GUEST_S_CET                                             0x00006C28

                                                                                                                                                                                   /**
                                                                                                                                                                                    * Guest SSP.
                                                                                                                                                                                    */
#define VMCS_GUEST_SSP                                               0x00006C2A

                                                                                                                                                                                    /**
                                                                                                                                                                                     * Guest IA32_INTERRUPT_SSP_TABLE_ADDR.
                                                                                                                                                                                     */
#define VMCS_GUEST_INTERRUPT_SSP_TABLE_ADDR                          0x00006C2C
                                                                                                                                                                                     /**
                                                                                                                                                                                      * @}
                                                                                                                                                                                      */

                                                                                                                                                                                      /**
                                                                                                                                                                                       * @defgroup vmcs_natural_width_host_state_fields \
                                                                                                                                                                                       *           Natural-Width Host-State Fields
                                                                                                                                                                                       *
                                                                                                                                                                                       * Natural-Width Host-State Fields.
                                                                                                                                                                                       * @{
                                                                                                                                                                                       */
                                                                                                                                                                                       /**
                                                                                                                                                                                        * Host CR0.
                                                                                                                                                                                        */
#define VMCS_HOST_CR0                                                0x00006C00

                                                                                                                                                                                        /**
                                                                                                                                                                                         * Host CR3.
                                                                                                                                                                                         */
#define VMCS_HOST_CR3                                                0x00006C02

                                                                                                                                                                                         /**
                                                                                                                                                                                          * Host CR4.
                                                                                                                                                                                          */
#define VMCS_HOST_CR4                                                0x00006C04

                                                                                                                                                                                          /**
                                                                                                                                                                                           * Host FS base.
                                                                                                                                                                                           */
#define VMCS_HOST_FS_BASE                                            0x00006C06

                                                                                                                                                                                           /**
                                                                                                                                                                                            * Host GS base.
                                                                                                                                                                                            */
#define VMCS_HOST_GS_BASE                                            0x00006C08

                                                                                                                                                                                            /**
                                                                                                                                                                                             * Host TR base.
                                                                                                                                                                                             */
#define VMCS_HOST_TR_BASE                                            0x00006C0A

                                                                                                                                                                                             /**
                                                                                                                                                                                              * Host GDTR base.
                                                                                                                                                                                              */
#define VMCS_HOST_GDTR_BASE                                          0x00006C0C

                                                                                                                                                                                              /**
                                                                                                                                                                                               * Host IDTR base.
                                                                                                                                                                                               */
#define VMCS_HOST_IDTR_BASE                                          0x00006C0E

                                                                                                                                                                                               /**
                                                                                                                                                                                                * Host IA32_SYSENTER_ESP.
                                                                                                                                                                                                */
#define VMCS_HOST_SYSENTER_ESP                                       0x00006C10

                                                                                                                                                                                                /**
                                                                                                                                                                                                 * Host IA32_SYSENTER_EIP.
                                                                                                                                                                                                 */
#define VMCS_HOST_SYSENTER_EIP                                       0x00006C12

                                                                                                                                                                                                 /**
                                                                                                                                                                                                  * Host RSP.
                                                                                                                                                                                                  */
#define VMCS_HOST_RSP                                                0x00006C14

                                                                                                                                                                                                  /**
                                                                                                                                                                                                   * Host RIP.
                                                                                                                                                                                                   */
#define VMCS_HOST_RIP                                                0x00006C16

                                                                                                                                                                                                   /**
                                                                                                                                                                                                    * Host IA32_S_CET.
                                                                                                                                                                                                    */
#define VMCS_HOST_S_CET                                              0x00006C18

                                                                                                                                                                                                    /**
                                                                                                                                                                                                     * Host SSP.
                                                                                                                                                                                                     */
#define VMCS_HOST_SSP                                                0x00006C1A

                                                                                                                                                                                                     /**
                                                                                                                                                                                                      * Host IA32_INTERRUPT_SSP_TABLE_ADDR.
                                                                                                                                                                                                      */
#define VMCS_HOST_INTERRUPT_SSP_TABLE_ADDR                           0x00006C1C
                                                                                                                                                                                                      /**
                                                                                                                                                                                                       * @}
                                                                                                                                                                                                       */

                                                                                                                                                                                                       /**
                                                                                                                                                                                                        * @}
                                                                                                                                                                                                        */

                                                                                                                                                                                                        /**
                                                                                                                                                                                                         * @}
                                                                                                                                                                                                         */

                                                                                                                                                                                                         /**
                                                                                                                                                                                                          * @brief Valid interruption types
                                                                                                                                                                                                          */
typedef enum
{
    /**
     * External interrupt.
     */
    external_interrupt = 0x00000000,

    /**
     * Non-maskable interrupt (NMI).
     */
     non_maskable_interrupt = 0x00000002,

     /**
      * Hardware exception (e.g,. \#PF).
      */
      hardware_exception = 0x00000003,

      /**
       * Software interrupt (INT n).
       */
       software_interrupt = 0x00000004,

       /**
        * Privileged software exception (INT1).
        */
        privileged_software_exception = 0x00000005,

        /**
         * Software exception (INT3 or INTO).
         */
         software_exception = 0x00000006,

         /**
          * Other event. This type is used for injection of events that are not delivered through the IDT.
          */
          other_event = 0x00000007,
} interruption_type;

/**
 * @brief VM entry can be configured to conclude by delivering an event through the IDT (after all guest state and MSRs
 *        have been loaded). This process is called event injection and is controlled by these VM-entry control fields
 *
 * @see Vol3A[24.8.3(VM-Entry Controls for Event Injection)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * @brief Vector of interrupt or exception
         *
         * [Bits 7:0] Determines which entry in the IDT is used or which other event is injected.
         */
        UINT32_t vector : 8;
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR_BIT                     0
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR_FLAG                    0xFF
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR_MASK                    0xFF
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR(_)                      (((_) >> 0) & 0xFF)

        /**
         * @brief Interruption type
         *
         * [Bits 10:8] Determines details of how the injection is performed.
         */
        UINT32_t interruption_type : 3;
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_BIT          8
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_FLAG         0x700
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_MASK         0x07
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE(_)           (((_) >> 8) & 0x07)

        /**
         * @brief Deliver error code (0 = do not deliver; 1 = deliver)
         *
         * [Bit 11] Determines whether delivery pushes an error code on the guest stack.
         */
        UINT32_t deliver_error_code : 1;
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_BIT         11
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_FLAG        0x800
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_MASK        0x01
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE(_)          (((_) >> 11) & 0x01)
        UINT32_t reserved1 : 19;

        /**
         * @brief Valid
         *
         * [Bit 31] VM entry injects an event if and only if the valid bit is 1. The valid bit in this field is cleared on every VM
         * exit.
         */
        UINT32_t valid : 1;
#define VMENTRY_INTERRUPT_INFORMATION_VALID_BIT                      31
#define VMENTRY_INTERRUPT_INFORMATION_VALID_FLAG                     0x80000000
#define VMENTRY_INTERRUPT_INFORMATION_VALID_MASK                     0x01
#define VMENTRY_INTERRUPT_INFORMATION_VALID(_)                       (((_) >> 31) & 0x01)
    };

    UINT32_t flags;
} vmentry_interrupt_information;

/**
 * @brief VM entry can be configured to conclude by delivering an event through the IDT (after all guest state and MSRs
 *        have been loaded). This process is called event injection and is controlled by these VM-entry control fields
 *
 * @see Vol3A[24.9.2(Information for VM Exits Due to Vectored Events)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Vector of interrupt or exception.
         */
        UINT32_t vector : 8;
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR_BIT                      0
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR_FLAG                     0xFF
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR_MASK                     0xFF
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR(_)                       (((_) >> 0) & 0xFF)

        /**
         * [Bits 10:8] Interruption type.
         */
        UINT32_t interruption_type : 3;
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_BIT           8
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_FLAG          0x700
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_MASK          0x07
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE(_)            (((_) >> 8) & 0x07)

        /**
         * [Bit 11] Deliver error code (0 = do not deliver; 1 = deliver).
         */
        UINT32_t error_code_valid : 1;
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_BIT            11
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_FLAG           0x800
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_MASK           0x01
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID(_)             (((_) >> 11) & 0x01)

        /**
         * [Bit 12] NMI unblocking due to IRET.
         */
        UINT32_t nmi_unblocking : 1;
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_BIT              12
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_FLAG             0x1000
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_MASK             0x01
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING(_)               (((_) >> 12) & 0x01)
        UINT32_t reserved1 : 18;

        /**
         * [Bit 31] Valid.
         */
        UINT32_t valid : 1;
#define VMEXIT_INTERRUPT_INFORMATION_VALID_BIT                       31
#define VMEXIT_INTERRUPT_INFORMATION_VALID_FLAG                      0x80000000
#define VMEXIT_INTERRUPT_INFORMATION_VALID_MASK                      0x01
#define VMEXIT_INTERRUPT_INFORMATION_VALID(_)                        (((_) >> 31) & 0x01)
    };

    UINT32_t flags;
} vmexit_interrupt_information;

/**
 * @}
 */

 /**
  * @defgroup apic \
  *           Advanced Programmable Interrupt Controller (APIC)
  *
  * Software interacts with the local APIC by reading and writing its registers. APIC registers are memory-mapped to a
  * 4-KByte region of the processor's physical address space with an initial starting address of FEE00000H. For correct APIC
  * operation, this address space must be mapped to an area of memory that has been designated as strong uncacheable (UC).
  *
  * @remarks Registers are 32 bits, 64 bits, or 256 bits in width; all are aligned on 128-bit boundaries. All 32-bit
  *          registers should be accessed using 128-bit aligned 32-bit loads or stores. Some processors may support loads and stores
  *          of less than 32 bits to some of the APIC registers. This is model specific behavior and is not guaranteed to work on all
  *          processors. Any FP/MMX/SSE access to an APIC register, or any access that touches bytes 4 through 15 of an APIC register
  *          may cause undefined behavior and must not be executed. This undefined behavior could include hangs, incorrect results or
  *          unexpected exceptions, including machine checks, and may vary between implementations. Wider registers (64-bit or
  *          256-bit) must be accessed using multiple 32-bit loads or stores, with all accesses being 128-bit aligned.
  * @see Vol3A[10.4.1(The Local APIC Block Diagram)] (reference)
  * @{
  */
  /**
   * Local APIC Base Address.
   *
   * @remarks Reserved.
   */
#define APIC_BASE_ADDRESS                                            0xFEE00000

   /**
    * Local APIC ID Register.
    */
#define APIC_ID                                                      0x00000020

    /**
     * Local APIC Version Register.
     */
#define APIC_VERSION                                                 0x00000030

     /**
      * Task Priority Register (TPR).
      */
#define APIC_TASK_PRIORITY                                           0x00000080

      /**
       * Arbitration Priority Register (APR).
       */
#define APIC_ARBITRATION_PRIORITY                                    0x00000090

       /**
        * Processor Priority Register (PPR).
        */
#define APIC_PROCESSOR_PRIORITY                                      0x000000A0

        /**
         * EOI Register.
         */
#define APIC_EOI                                                     0x000000B0

         /**
          * Remote Read Register (RRD).
          */
#define APIC_REMOTE_READ                                             0x000000C0

          /**
           * Logical Destination Register.
           */
#define APIC_LOGICAL_DESTINATION                                     0x000000D0

           /**
            * Destination Format Register.
            *
            * @see Vol3A[10.6.2.2(Logical Destination Mode)]
            */
#define APIC_DESTINATION_FORMAT                                      0x000000E0

            /**
             * Spurious Interrupt Vector Register.
             *
             * @see Vol3A[10.9(SPURIOUS INTERRUPT)]
             */
#define APIC_SPURIOUS_INTERRUPT_VECTOR                               0x000000F0

             /**
              * In-Service Register (ISR); bits 31:0.
              */
#define APIC_IN_SERVICE_BITS_31_0                                    0x00000100

              /**
               * In-Service Register (ISR); bits 63:32.
               */
#define APIC_IN_SERVICE_BITS_63_32                                   0x00000110

               /**
                * In-Service Register (ISR); bits 95:64.
                */
#define APIC_IN_SERVICE_BITS_95_64                                   0x00000120

                /**
                 * In-Service Register (ISR); bits 127:96.
                 */
#define APIC_IN_SERVICE_BITS_127_96                                  0x00000130

                 /**
                  * In-Service Register (ISR); bits 159:128.
                  */
#define APIC_IN_SERVICE_BITS_159_128                                 0x00000140

                  /**
                   * In-Service Register (ISR); bits 191:160.
                   */
#define APIC_IN_SERVICE_BITS_191_160                                 0x00000150

                   /**
                    * In-Service Register (ISR); bits 223:192.
                    */
#define APIC_IN_SERVICE_BITS_223_192                                 0x00000160

                    /**
                     * In-Service Register (ISR); bits 255:224.
                     */
#define APIC_IN_SERVICE_BITS_255_224                                 0x00000170

                     /**
                      * Trigger Mode Register (TMR); bits 31:0.
                      */
#define APIC_TRIGGER_MODE_BITS_31_0                                  0x00000180

                      /**
                       * Trigger Mode Register (TMR); bits 63:32.
                       */
#define APIC_TRIGGER_MODE_BITS_63_32                                 0x00000190

                       /**
                        * Trigger Mode Register (TMR); bits 95:64.
                        */
#define APIC_TRIGGER_MODE_BITS_95_64                                 0x000001A0

                        /**
                         * Trigger Mode Register (TMR); bits 127:96.
                         */
#define APIC_TRIGGER_MODE_BITS_127_96                                0x000001B0

                         /**
                          * Trigger Mode Register (TMR); bits 159:128.
                          */
#define APIC_TRIGGER_MODE_BITS_159_128                               0x000001C0

                          /**
                           * Trigger Mode Register (TMR); bits 191:160.
                           */
#define APIC_TRIGGER_MODE_BITS_191_160                               0x000001D0

                           /**
                            * Trigger Mode Register (TMR); bits 223:192.
                            */
#define APIC_TRIGGER_MODE_BITS_223_192                               0x000001E0

                            /**
                             * Trigger Mode Register (TMR); bits 255:224.
                             */
#define APIC_TRIGGER_MODE_BITS_255_224                               0x000001F0

                             /**
                              * Interrupt Request Register (IRR); bits 31:0.
                              */
#define APIC_INTERRUPT_REQUEST_BITS_31_0                             0x00000200

                              /**
                               * Interrupt Request Register (IRR); bits 63:32.
                               */
#define APIC_INTERRUPT_REQUEST_BITS_63_32                            0x00000210

                               /**
                                * Interrupt Request Register (IRR); bits 95:64.
                                */
#define APIC_INTERRUPT_REQUEST_BITS_95_64                            0x00000220

                                /**
                                 * Interrupt Request Register (IRR); bits 127:96.
                                 */
#define APIC_INTERRUPT_REQUEST_BITS_127_96                           0x00000230

                                 /**
                                  * Interrupt Request Register (IRR); bits 159:128.
                                  */
#define APIC_INTERRUPT_REQUEST_BITS_159_128                          0x00000240

                                  /**
                                   * Interrupt Request Register (IRR); bits 191:160.
                                   */
#define APIC_INTERRUPT_REQUEST_BITS_191_160                          0x00000250

                                   /**
                                    * Interrupt Request Register (IRR); bits 223:192.
                                    */
#define APIC_INTERRUPT_REQUEST_BITS_223_192                          0x00000260

                                    /**
                                     * Interrupt Request Register (IRR); bits 255:224.
                                     */
#define APIC_INTERRUPT_REQUEST_BITS_255_224                          0x00000270

                                     /**
                                      * Error Status Register.
                                      */
#define APIC_ERROR_STATUS                                            0x00000280

                                      /**
                                       * LVT Corrected Machine Check Interrupt (CMCI) Register.
                                       */
#define APIC_LVT_CORRECTED_MACHINE_CHECK_INTERRUPT                   0x000002F0

                                       /**
                                        * Interrupt Command Register (ICR); bits 0-31.
                                        */
#define APIC_INTERRUPT_COMMAND_BITS_0_31                             0x00000300

                                        /**
                                         * Interrupt Command Register (ICR); bits 32-63.
                                         */
#define APIC_INTERRUPT_COMMAND_BITS_32_63                            0x00000310

                                         /**
                                          * LVT Timer Register.
                                          */
#define APIC_LVT_TIMER                                               0x00000320

                                          /**
                                           * LVT Thermal Sensor Register.
                                           */
#define APIC_LVT_THERMAL_SENSOR                                      0x00000330

                                           /**
                                            * LVT Performance Monitoring Counters Register.
                                            */
#define APIC_LVT_PERFORMANCE_MONITORING_COUNTERS                     0x00000340

                                            /**
                                             * LVT LINT0 Register.
                                             */
#define APIC_LVT_LINT0                                               0x00000350

                                             /**
                                              * LVT LINT1 Register.
                                              */
#define APIC_LVT_LINT1                                               0x00000360

                                              /**
                                               * LVT Error Register.
                                               */
#define APIC_LVT_ERROR                                               0x00000370

                                               /**
                                                * Initial Count Register (for Timer).
                                                */
#define APIC_INITIAL_COUNT                                           0x00000380

                                                /**
                                                 * Current Count Register (for Timer).
                                                 */
#define APIC_CURRENT_COUNT                                           0x00000390

                                                 /**
                                                  * Divide Configuration Register (for Timer).
                                                  */
#define APIC_DIVIDE_CONFIGURATION                                    0x000003E0
                                                  /**
                                                   * @}
                                                   */

                                                   /**
                                                    * The 32-bit EFLAGS register contains a group of status flags, a control flag, and a group of system flags. The status
                                                    * flags (bits 0, 2, 4, 6, 7, and 11) of the EFLAGS register indicate the results of arithmetic instructions, such as the
                                                    * ADD, SUB, MUL, and DIV instructions.
                                                    * The system flags and IOPL field in the EFLAGS register control operating-system or executive operations.
                                                    *
                                                    * @see Vol1[3.4.3(EFLAGS)] (reference)
                                                    */
typedef union
{
    struct
    {
        /**
         * @brief Carry flag
         *
         * [Bit 0] Set if an arithmetic operation generates a carry or a borrow out of the mostsignificant bit of the result;
         * cleared otherwise. This flag indicates an overflow condition for unsigned-integer arithmetic. It is also used in
         * multiple-precision arithmetic.
         */
        UINT32_t carry_flag : 1;
#define EFLAGS_CARRY_FLAG_BIT                                        0
#define EFLAGS_CARRY_FLAG_FLAG                                       0x01
#define EFLAGS_CARRY_FLAG_MASK                                       0x01
#define EFLAGS_CARRY_FLAG(_)                                         (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Reserved - always 1
         */
        UINT32_t read_as_1 : 1;
#define EFLAGS_READ_AS_1_BIT                                         1
#define EFLAGS_READ_AS_1_FLAG                                        0x02
#define EFLAGS_READ_AS_1_MASK                                        0x01
#define EFLAGS_READ_AS_1(_)                                          (((_) >> 1) & 0x01)

        /**
         * @brief Parity flag
         *
         * [Bit 2] Set if the least-significant byte of the result contains an even number of 1 bits; cleared otherwise.
         */
        UINT32_t parity_flag : 1;
#define EFLAGS_PARITY_FLAG_BIT                                       2
#define EFLAGS_PARITY_FLAG_FLAG                                      0x04
#define EFLAGS_PARITY_FLAG_MASK                                      0x01
#define EFLAGS_PARITY_FLAG(_)                                        (((_) >> 2) & 0x01)
        UINT32_t reserved1 : 1;

        /**
         * @brief Auxiliary Carry flag
         *
         * [Bit 4] Set if an arithmetic operation generates a carry or a borrow out of bit 3 of the result; cleared otherwise. This
         * flag is used in binary-coded decimal (BCD) arithmetic.
         */
        UINT32_t auxiliary_carry_flag : 1;
#define EFLAGS_AUXILIARY_CARRY_FLAG_BIT                              4
#define EFLAGS_AUXILIARY_CARRY_FLAG_FLAG                             0x10
#define EFLAGS_AUXILIARY_CARRY_FLAG_MASK                             0x01
#define EFLAGS_AUXILIARY_CARRY_FLAG(_)                               (((_) >> 4) & 0x01)
        UINT32_t reserved2 : 1;

        /**
         * @brief Zero flag
         *
         * [Bit 6] Set if the result is zero; cleared otherwise.
         */
        UINT32_t zero_flag : 1;
#define EFLAGS_ZERO_FLAG_BIT                                         6
#define EFLAGS_ZERO_FLAG_FLAG                                        0x40
#define EFLAGS_ZERO_FLAG_MASK                                        0x01
#define EFLAGS_ZERO_FLAG(_)                                          (((_) >> 6) & 0x01)

        /**
         * @brief Sign flag
         *
         * [Bit 7] Set equal to the most-significant bit of the result, which is the sign bit of a signed integer. (0 indicates a
         * positive value and 1 indicates a negative value.)
         */
        UINT32_t sign_flag : 1;
#define EFLAGS_SIGN_FLAG_BIT                                         7
#define EFLAGS_SIGN_FLAG_FLAG                                        0x80
#define EFLAGS_SIGN_FLAG_MASK                                        0x01
#define EFLAGS_SIGN_FLAG(_)                                          (((_) >> 7) & 0x01)

        /**
         * @brief Trap flag
         *
         * [Bit 8] Set to enable single-step mode for debugging; clear to disable single-step mode.
         */
        UINT32_t trap_flag : 1;
#define EFLAGS_TRAP_FLAG_BIT                                         8
#define EFLAGS_TRAP_FLAG_FLAG                                        0x100
#define EFLAGS_TRAP_FLAG_MASK                                        0x01
#define EFLAGS_TRAP_FLAG(_)                                          (((_) >> 8) & 0x01)

        /**
         * @brief Interrupt enable flag
         *
         * [Bit 9] Controls the response of the processor to maskable interrupt requests. Set to respond to maskable interrupts;
         * cleared to inhibit maskable interrupts.
         */
        UINT32_t interrupt_enable_flag : 1;
#define EFLAGS_INTERRUPT_ENABLE_FLAG_BIT                             9
#define EFLAGS_INTERRUPT_ENABLE_FLAG_FLAG                            0x200
#define EFLAGS_INTERRUPT_ENABLE_FLAG_MASK                            0x01
#define EFLAGS_INTERRUPT_ENABLE_FLAG(_)                              (((_) >> 9) & 0x01)

        /**
         * @brief Direction flag
         *
         * [Bit 10] Controls string instructions (MOVS, CMPS, SCAS, LODS, and STOS). Setting the DF flag causes the string
         * instructions to auto-decrement (to process strings from high addresses to low addresses). Clearing the DF flag causes
         * the string instructions to auto-increment (process strings from low addresses to high addresses).
         */
        UINT32_t direction_flag : 1;
#define EFLAGS_DIRECTION_FLAG_BIT                                    10
#define EFLAGS_DIRECTION_FLAG_FLAG                                   0x400
#define EFLAGS_DIRECTION_FLAG_MASK                                   0x01
#define EFLAGS_DIRECTION_FLAG(_)                                     (((_) >> 10) & 0x01)

        /**
         * @brief Overflow flag
         *
         * [Bit 11] Set if the integer result is too large a positive number or too small a negative number (excluding the
         * sign-bit) to fit in the destination operand; cleared otherwise. This flag indicates an overflow condition for
         * signed-integer (two's complement) arithmetic.
         */
        UINT32_t overflow_flag : 1;
#define EFLAGS_OVERFLOW_FLAG_BIT                                     11
#define EFLAGS_OVERFLOW_FLAG_FLAG                                    0x800
#define EFLAGS_OVERFLOW_FLAG_MASK                                    0x01
#define EFLAGS_OVERFLOW_FLAG(_)                                      (((_) >> 11) & 0x01)

        /**
         * @brief I/O privilege level field
         *
         * [Bits 13:12] Indicates the I/O privilege level of the currently running program or task. The current privilege level
         * (CPL) of the currently running program or task must be less than or equal to the I/O privilege level to access the I/O
         * address space. The POPF and IRET instructions can modify this field only when operating at a CPL of 0.
         */
        UINT32_t io_privilege_level : 2;
#define EFLAGS_IO_PRIVILEGE_LEVEL_BIT                                12
#define EFLAGS_IO_PRIVILEGE_LEVEL_FLAG                               0x3000
#define EFLAGS_IO_PRIVILEGE_LEVEL_MASK                               0x03
#define EFLAGS_IO_PRIVILEGE_LEVEL(_)                                 (((_) >> 12) & 0x03)

        /**
         * @brief Nested task flag
         *
         * [Bit 14] Controls the chaining of interrupted and called tasks. Set when the current task is linked to the previously
         * executed task; cleared when the current task is not linked to another task.
         */
        UINT32_t nested_task_flag : 1;
#define EFLAGS_NESTED_TASK_FLAG_BIT                                  14
#define EFLAGS_NESTED_TASK_FLAG_FLAG                                 0x4000
#define EFLAGS_NESTED_TASK_FLAG_MASK                                 0x01
#define EFLAGS_NESTED_TASK_FLAG(_)                                   (((_) >> 14) & 0x01)
        UINT32_t reserved3 : 1;

        /**
         * @brief Resume flag
         *
         * [Bit 16] Controls the processor's response to debug exceptions.
         */
        UINT32_t resume_flag : 1;
#define EFLAGS_RESUME_FLAG_BIT                                       16
#define EFLAGS_RESUME_FLAG_FLAG                                      0x10000
#define EFLAGS_RESUME_FLAG_MASK                                      0x01
#define EFLAGS_RESUME_FLAG(_)                                        (((_) >> 16) & 0x01)

        /**
         * @brief Virtual-8086 mode flag
         *
         * [Bit 17] Set to enable virtual-8086 mode; clear to return to protected mode without virtual-8086 mode semantics.
         */
        UINT32_t virtual_8086_mode_flag : 1;
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_BIT                            17
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_FLAG                           0x20000
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_MASK                           0x01
#define EFLAGS_VIRTUAL_8086_MODE_FLAG(_)                             (((_) >> 17) & 0x01)

        /**
         * @brief Alignment check (or access control) flag
         *
         * [Bit 18] If the AM bit is set in the CR0 register, alignment checking of user-mode data accesses is enabled if and only
         * if this flag is 1. If the SMAP bit is set in the CR4 register, explicit supervisor-mode data accesses to user-mode pages
         * are allowed if and only if this bit is 1.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        UINT32_t alignment_check_flag : 1;
#define EFLAGS_ALIGNMENT_CHECK_FLAG_BIT                              18
#define EFLAGS_ALIGNMENT_CHECK_FLAG_FLAG                             0x40000
#define EFLAGS_ALIGNMENT_CHECK_FLAG_MASK                             0x01
#define EFLAGS_ALIGNMENT_CHECK_FLAG(_)                               (((_) >> 18) & 0x01)

        /**
         * @brief Virtual interrupt flag
         *
         * [Bit 19] Virtual image of the IF flag. Used in conjunction with the VIP flag. (To use this flag and the VIP flag the
         * virtual mode extensions are enabled by setting the VME flag in control register CR4.)
         */
        UINT32_t virtual_interrupt_flag : 1;
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_BIT                            19
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_FLAG                           0x80000
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_MASK                           0x01
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG(_)                             (((_) >> 19) & 0x01)

        /**
         * @brief Virtual interrupt pending flag
         *
         * [Bit 20] Set to indicate that an interrupt is pending; clear when no interrupt is pending. (Software sets and clears
         * this flag; the processor only reads it.) Used in conjunction with the VIF flag.
         */
        UINT32_t virtual_interrupt_pending_flag : 1;
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_BIT                    20
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_FLAG                   0x100000
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_MASK                   0x01
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG(_)                     (((_) >> 20) & 0x01)

        /**
         * @brief Identification flag
         *
         * [Bit 21] The ability of a program to set or clear this flag indicates support for the CPUID instruction.
         */
        UINT32_t identification_flag : 1;
#define EFLAGS_IDENTIFICATION_FLAG_BIT                               21
#define EFLAGS_IDENTIFICATION_FLAG_FLAG                              0x200000
#define EFLAGS_IDENTIFICATION_FLAG_MASK                              0x01
#define EFLAGS_IDENTIFICATION_FLAG(_)                                (((_) >> 21) & 0x01)
        UINT32_t reserved4 : 10;
    };

    UINT32_t flags;
} eflags;

/**
 * The 64-bit RFLAGS register contains a group of status flags, a control flag, and a group of system flags in 64-bit mode.
 * The upper 32 bits of RFLAGS register is reserved. The lower 32 bits of RFLAGS is the same as EFLAGS.
 *
 * @see EFLAGS
 * @see Vol1[3.4.3.4(RFLAGS Register in 64-Bit Mode)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * @brief Carry flag
         *
         * [Bit 0] See the description in EFLAGS.
         */
        UINT64_t carry_flag : 1;
#define RFLAGS_CARRY_FLAG_BIT                                        0
#define RFLAGS_CARRY_FLAG_FLAG                                       0x01
#define RFLAGS_CARRY_FLAG_MASK                                       0x01
#define RFLAGS_CARRY_FLAG(_)                                         (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Reserved - always 1
         */
        UINT64_t read_as_1 : 1;
#define RFLAGS_READ_AS_1_BIT                                         1
#define RFLAGS_READ_AS_1_FLAG                                        0x02
#define RFLAGS_READ_AS_1_MASK                                        0x01
#define RFLAGS_READ_AS_1(_)                                          (((_) >> 1) & 0x01)

        /**
         * @brief Parity flag
         *
         * [Bit 2] See the description in EFLAGS.
         */
        UINT64_t parity_flag : 1;
#define RFLAGS_PARITY_FLAG_BIT                                       2
#define RFLAGS_PARITY_FLAG_FLAG                                      0x04
#define RFLAGS_PARITY_FLAG_MASK                                      0x01
#define RFLAGS_PARITY_FLAG(_)                                        (((_) >> 2) & 0x01)
        UINT64_t reserved1 : 1;

        /**
         * @brief Auxiliary Carry flag
         *
         * [Bit 4] See the description in EFLAGS.
         */
        UINT64_t auxiliary_carry_flag : 1;
#define RFLAGS_AUXILIARY_CARRY_FLAG_BIT                              4
#define RFLAGS_AUXILIARY_CARRY_FLAG_FLAG                             0x10
#define RFLAGS_AUXILIARY_CARRY_FLAG_MASK                             0x01
#define RFLAGS_AUXILIARY_CARRY_FLAG(_)                               (((_) >> 4) & 0x01)
        UINT64_t reserved2 : 1;

        /**
         * @brief Zero flag
         *
         * [Bit 6] See the description in EFLAGS.
         */
        UINT64_t zero_flag : 1;
#define RFLAGS_ZERO_FLAG_BIT                                         6
#define RFLAGS_ZERO_FLAG_FLAG                                        0x40
#define RFLAGS_ZERO_FLAG_MASK                                        0x01
#define RFLAGS_ZERO_FLAG(_)                                          (((_) >> 6) & 0x01)

        /**
         * @brief Sign flag
         *
         * [Bit 7] See the description in EFLAGS.
         */
        UINT64_t sign_flag : 1;
#define RFLAGS_SIGN_FLAG_BIT                                         7
#define RFLAGS_SIGN_FLAG_FLAG                                        0x80
#define RFLAGS_SIGN_FLAG_MASK                                        0x01
#define RFLAGS_SIGN_FLAG(_)                                          (((_) >> 7) & 0x01)

        /**
         * @brief Trap flag
         *
         * [Bit 8] See the description in EFLAGS.
         */
        UINT64_t trap_flag : 1;
#define RFLAGS_TRAP_FLAG_BIT                                         8
#define RFLAGS_TRAP_FLAG_FLAG                                        0x100
#define RFLAGS_TRAP_FLAG_MASK                                        0x01
#define RFLAGS_TRAP_FLAG(_)                                          (((_) >> 8) & 0x01)

        /**
         * @brief Interrupt enable flag
         *
         * [Bit 9] See the description in EFLAGS.
         */
        UINT64_t interrupt_enable_flag : 1;
#define RFLAGS_INTERRUPT_ENABLE_FLAG_BIT                             9
#define RFLAGS_INTERRUPT_ENABLE_FLAG_FLAG                            0x200
#define RFLAGS_INTERRUPT_ENABLE_FLAG_MASK                            0x01
#define RFLAGS_INTERRUPT_ENABLE_FLAG(_)                              (((_) >> 9) & 0x01)

        /**
         * @brief Direction flag
         *
         * [Bit 10] See the description in EFLAGS.
         */
        UINT64_t direction_flag : 1;
#define RFLAGS_DIRECTION_FLAG_BIT                                    10
#define RFLAGS_DIRECTION_FLAG_FLAG                                   0x400
#define RFLAGS_DIRECTION_FLAG_MASK                                   0x01
#define RFLAGS_DIRECTION_FLAG(_)                                     (((_) >> 10) & 0x01)

        /**
         * @brief Overflow flag
         *
         * [Bit 11] See the description in EFLAGS.
         */
        UINT64_t overflow_flag : 1;
#define RFLAGS_OVERFLOW_FLAG_BIT                                     11
#define RFLAGS_OVERFLOW_FLAG_FLAG                                    0x800
#define RFLAGS_OVERFLOW_FLAG_MASK                                    0x01
#define RFLAGS_OVERFLOW_FLAG(_)                                      (((_) >> 11) & 0x01)

        /**
         * @brief I/O privilege level field
         *
         * [Bits 13:12] See the description in EFLAGS.
         */
        UINT64_t io_privilege_level : 2;
#define RFLAGS_IO_PRIVILEGE_LEVEL_BIT                                12
#define RFLAGS_IO_PRIVILEGE_LEVEL_FLAG                               0x3000
#define RFLAGS_IO_PRIVILEGE_LEVEL_MASK                               0x03
#define RFLAGS_IO_PRIVILEGE_LEVEL(_)                                 (((_) >> 12) & 0x03)

        /**
         * @brief Nested task flag
         *
         * [Bit 14] See the description in EFLAGS.
         */
        UINT64_t nested_task_flag : 1;
#define RFLAGS_NESTED_TASK_FLAG_BIT                                  14
#define RFLAGS_NESTED_TASK_FLAG_FLAG                                 0x4000
#define RFLAGS_NESTED_TASK_FLAG_MASK                                 0x01
#define RFLAGS_NESTED_TASK_FLAG(_)                                   (((_) >> 14) & 0x01)
        UINT64_t reserved3 : 1;

        /**
         * @brief Resume flag
         *
         * [Bit 16] See the description in EFLAGS.
         */
        UINT64_t resume_flag : 1;
#define RFLAGS_RESUME_FLAG_BIT                                       16
#define RFLAGS_RESUME_FLAG_FLAG                                      0x10000
#define RFLAGS_RESUME_FLAG_MASK                                      0x01
#define RFLAGS_RESUME_FLAG(_)                                        (((_) >> 16) & 0x01)

        /**
         * @brief Virtual-8086 mode flag
         *
         * [Bit 17] See the description in EFLAGS.
         */
        UINT64_t virtual_8086_mode_flag : 1;
#define RFLAGS_VIRTUAL_8086_MODE_FLAG_BIT                            17
#define RFLAGS_VIRTUAL_8086_MODE_FLAG_FLAG                           0x20000
#define RFLAGS_VIRTUAL_8086_MODE_FLAG_MASK                           0x01
#define RFLAGS_VIRTUAL_8086_MODE_FLAG(_)                             (((_) >> 17) & 0x01)

        /**
         * @brief Alignment check (or access control) flag
         *
         * [Bit 18] See the description in EFLAGS.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        UINT64_t alignment_check_flag : 1;
#define RFLAGS_ALIGNMENT_CHECK_FLAG_BIT                              18
#define RFLAGS_ALIGNMENT_CHECK_FLAG_FLAG                             0x40000
#define RFLAGS_ALIGNMENT_CHECK_FLAG_MASK                             0x01
#define RFLAGS_ALIGNMENT_CHECK_FLAG(_)                               (((_) >> 18) & 0x01)

        /**
         * @brief Virtual interrupt flag
         *
         * [Bit 19] See the description in EFLAGS.
         */
        UINT64_t virtual_interrupt_flag : 1;
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG_BIT                            19
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG_FLAG                           0x80000
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG_MASK                           0x01
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG(_)                             (((_) >> 19) & 0x01)

        /**
         * @brief Virtual interrupt pending flag
         *
         * [Bit 20] See the description in EFLAGS.
         */
        UINT64_t virtual_interrupt_pending_flag : 1;
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_BIT                    20
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_FLAG                   0x100000
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_MASK                   0x01
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG(_)                     (((_) >> 20) & 0x01)

        /**
         * @brief Identification flag
         *
         * [Bit 21] See the description in EFLAGS.
         */
        UINT64_t identification_flag : 1;
#define RFLAGS_IDENTIFICATION_FLAG_BIT                               21
#define RFLAGS_IDENTIFICATION_FLAG_FLAG                              0x200000
#define RFLAGS_IDENTIFICATION_FLAG_MASK                              0x01
#define RFLAGS_IDENTIFICATION_FLAG(_)                                (((_) >> 21) & 0x01)
        UINT64_t reserved4 : 42;
    };

    UINT64_t flags;
} rflags;

/**
 * @defgroup exceptions \
 *           Exceptions
 * @{
 */
 /**
  * @brief Exceptions that can occur when the instruction is executed in protected mode.
  *        Each exception is given a mnemonic that consists of a pound sign (\#) followed by two letters and an optional error code
  *        in parentheses. For example, \#GP(0) denotes a general protection exception with an error code of 0
  *
  * @see Vol2A[3.1.1.13(Protected Mode Exceptions Section)] (reference)
  * @see Vol3A[6.3.1(External Interrupts)] (reference)
  */
typedef enum
{
    /**
     * #DE - Divide Error.
     * Source: DIV and IDIV instructions.
     * Error Code: No.
     */
    divide_error = 0x00000000,

    /**
     * #DB - Debug.
     * Source: Any code or data reference.
     * Error Code: No.
     */
     debug = 0x00000001,

     /**
      * Nonmaskable Interrupt.
      * Source: Generated externally by asserting the processor's NMI pin or
      *         through an NMI request set by the I/O APIC to the local APIC.
      * Error Code: No.
      */
      nmi = 0x00000002,

      /**
       * #BP - Breakpoint.
       * Source: INT3 instruction.
       * Error Code: No.
       */
       breakpoint = 0x00000003,

       /**
        * #OF - Overflow.
        * Source: INTO instruction.
        * Error Code: No.
        */
        overflow = 0x00000004,

        /**
         * #BR - BOUND Range Exceeded.
         * Source: BOUND instruction.
         * Error Code: No.
         */
         bound_range_exceeded = 0x00000005,

         /**
          * #UD - Invalid Opcode (Undefined Opcode).
          * Source: UD instruction or reserved opcode.
          * Error Code: No.
          */
          invalid_opcode = 0x00000006,

          /**
           * #NM - Device Not Available (No Math Coprocessor).
           * Source: Floating-point or WAIT/FWAIT instruction.
           * Error Code: No.
           */
           device_not_available = 0x00000007,

           /**
            * #DF - Double Fault.
            * Source: Any instruction that can generate an exception, an NMI, or an INTR.
            * Error Code: Yes (zero).
            */
            double_fault = 0x00000008,

            /**
             * #\## - Coprocessor Segment Overrun (reserved).
             * Source: Floating-point instruction.
             * Error Code: No.
             *
             * @note Processors after the Intel386 processor do not generate this exception.
             */
             coprocessor_segment_overrun = 0x00000009,

             /**
              * #TS - Invalid TSS.
              * Source: Task switch or TSS access.
              * Error Code: Yes.
              */
              invalid_tss = 0x0000000A,

              /**
               * #NP - Segment Not Present.
               * Source: Loading segment registers or accessing system segments.
               * Error Code: Yes.
               */
               segment_not_present = 0x0000000B,

               /**
                * #SS - Stack Segment Fault.
                * Source: Stack operations and SS register loads.
                * Error Code: Yes.
                */
                stack_segment_fault = 0x0000000C,

                /**
                 * #GP - General Protection.
                 * Source: Any memory reference and other protection checks.
                 * Error Code: Yes.
                 */
                 general_protection = 0x0000000D,

                 /**
                  * #PF - Page Fault.
                  * Source: Any memory reference.
                  * Error Code: Yes.
                  */
                  page_fault = 0x0000000E,

                  /**
                   * #MF - Floating-Point Error (Math Fault).
                   * Source: Floating-point or WAIT/FWAIT instruction.
                   * Error Code: No.
                   */
                   x87_floating_point_error = 0x00000010,

                   /**
                    * #AC - Alignment Check.
                    * Source: Any data reference in memory.
                    * Error Code: Yes.
                    */
                    alignment_check = 0x00000011,

                    /**
                     * #MC - Machine Check.
                     * Source: Model dependent machine check errors.
                     * Error Code: No.
                     */
                     machine_check = 0x00000012,

                     /**
                      * #XM - SIMD Floating-Point Numeric Error.
                      * Source: SSE/SSE2/SSE3 floating-point instructions.
                      * Error Code: No.
                      */
                      simd_floating_point_error = 0x00000013,

                      /**
                       * #VE - Virtualization Exception.
                       * Source: EPT violations.
                       * Error Code: No.
                       */
                       virtualization_exception = 0x00000014,
} exception_vector;

/**
 * @brief When an exception condition is related to a specific segment selector or IDT vector, the processor pushes an
 *        error code onto the stack of the exception handler (whether it is a procedure or task). The error code resembles a
 *        segment selector; however, instead of a TI flag and RPL field, the error code contains 3 different flags
 *
 * @see Vol3A[6.13(ERROR CODE)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] When set, indicates that the exception occurred during delivery of an event external to the program, such as an
         * interrupt or an earlier exception. The bit is cleared if the exception occurred during delivery of a software interrupt
         * (INT n, INT3, or INTO).
         */
        UINT32_t external_event : 1;
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_BIT                      0
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_FLAG                     0x01
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_MASK                     0x01
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT(_)                       (((_) >> 0) & 0x01)

        /**
         * [Bit 1] When set, indicates that the index portion of the error code refers to a gate descriptor in the IDT; when clear,
         * indicates that the index refers to a descriptor in the GDT or the current LDT.
         */
        UINT32_t descriptor_location : 1;
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_BIT                 1
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_FLAG                0x02
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_MASK                0x01
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION(_)                  (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Only used when the IDT flag is clear. When set, the TI flag indicates that the index portion of the error code
         * refers to a segment or gate descriptor in the LDT; when clear, it indicates that the index refers to a descriptor in the
         * current GDT.
         */
        UINT32_t gdt_ldt : 1;
#define EXCEPTION_ERROR_CODE_GDT_LDT_BIT                             2
#define EXCEPTION_ERROR_CODE_GDT_LDT_FLAG                            0x04
#define EXCEPTION_ERROR_CODE_GDT_LDT_MASK                            0x01
#define EXCEPTION_ERROR_CODE_GDT_LDT(_)                              (((_) >> 2) & 0x01)

        /**
         * [Bits 15:3] The segment selector index field provides an index into the IDT, GDT, or current LDT to the segment or gate
         * selector being referenced by the error code. In some cases the error code is null (all bits are clear except possibly
         * EXT). A null error code indicates that the error was not caused by a reference to a specific segment or that a null
         * segment selector was referenced in an operation.
         *
         * @note The format of the error code is different for page-fault exceptions (#PF).
         */
        UINT32_t index : 13;
#define EXCEPTION_ERROR_CODE_INDEX_BIT                               3
#define EXCEPTION_ERROR_CODE_INDEX_FLAG                              0xFFF8
#define EXCEPTION_ERROR_CODE_INDEX_MASK                              0x1FFF
#define EXCEPTION_ERROR_CODE_INDEX(_)                                (((_) >> 3) & 0x1FFF)
        UINT32_t reserved1 : 16;
    };

    UINT32_t flags;
} exception_error_code;

/**
 * @brief Page fault exception
 *
 * @see Vol3A[4.7(PAGE-FAULT EXCEPTIONS)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] This flag is 0 if there is no translation for the linear address because the P flag was 0 in one of the
         * pagingstructure entries used to translate that address.
         */
        UINT32_t present : 1;
#define PAGE_FAULT_EXCEPTION_PRESENT_BIT                             0
#define PAGE_FAULT_EXCEPTION_PRESENT_FLAG                            0x01
#define PAGE_FAULT_EXCEPTION_PRESENT_MASK                            0x01
#define PAGE_FAULT_EXCEPTION_PRESENT(_)                              (((_) >> 0) & 0x01)

        /**
         * [Bit 1] If the access causing the page-fault exception was a write, this flag is 1; otherwise, it is 0. This flag
         * describes the access causing the page-fault exception, not the access rights specified by paging.
         */
        UINT32_t write : 1;
#define PAGE_FAULT_EXCEPTION_WRITE_BIT                               1
#define PAGE_FAULT_EXCEPTION_WRITE_FLAG                              0x02
#define PAGE_FAULT_EXCEPTION_WRITE_MASK                              0x01
#define PAGE_FAULT_EXCEPTION_WRITE(_)                                (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If a user-mode access caused the page-fault exception, this flag is 1; it is 0 if a supervisor-mode access did
         * so. This flag describes the access causing the page-fault exception, not the access rights specified by paging.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        UINT32_t user_mode_access : 1;
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_BIT                    2
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_FLAG                   0x04
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_MASK                   0x01
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS(_)                     (((_) >> 2) & 0x01)

        /**
         * [Bit 3] This flag is 1 if there is no translation for the linear address because a reserved bit was set in one of the
         * pagingstructure entries used to translate that address. (Because reserved bits are not checked in a paging-structure
         * entry whose P flag is 0, bit 3 of the error code can be set only if bit 0 is also set). Bits reserved in the
         * paging-structure entries are reserved for future functionality. Software developers should be aware that such bits may
         * be used in the future and that a paging-structure entry that causes a page-fault exception on one processor might not do
         * so in the future.
         */
        UINT32_t reserved_bit_violation : 1;
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_BIT              3
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_FLAG             0x08
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_MASK             0x01
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION(_)               (((_) >> 3) & 0x01)

        /**
         * [Bit 4] This flag is 1 if (1) the access causing the page-fault exception was an instruction fetch; and (2) either (a)
         * CR4.SMEP = 1; or (b) both (i) CR4.PAE = 1 (either PAE paging or 4-level paging is in use); and (ii) IA32_EFER.NXE = 1.
         * Otherwise, the flag is 0. This flag describes the access causing the page-fault exception, not the access rights
         * specified by paging.
         */
        UINT32_t execute : 1;
#define PAGE_FAULT_EXCEPTION_EXECUTE_BIT                             4
#define PAGE_FAULT_EXCEPTION_EXECUTE_FLAG                            0x10
#define PAGE_FAULT_EXCEPTION_EXECUTE_MASK                            0x01
#define PAGE_FAULT_EXCEPTION_EXECUTE(_)                              (((_) >> 4) & 0x01)

        /**
         * [Bit 5] This flag is 1 if (1) IA32_EFER.LMA = CR4.PKE = 1; (2) the access causing the page-fault exception was a data
         * access; (3) the linear address was a user-mode address with protection key i; and (5) the PKRU register is such that
         * either (a) ADi = 1; or (b) the following all hold: (i) WDi = 1; (ii) the access is a write access; and (iii) either
         * CR0.WP = 1 or the access causing the page-fault exception was a user-mode access.
         *
         * @see Vol3A[4.6.2(Protection Keys)]
         */
        UINT32_t protection_key_violation : 1;
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_BIT            5
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_FLAG           0x20
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_MASK           0x01
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION(_)             (((_) >> 5) & 0x01)
        UINT32_t reserved1 : 9;

        /**
         * [Bit 15] This flag is 1 if the exception is unrelated to paging and resulted from violation of SGX-specific
         * access-control requirements. Because such a violation can occur only if there is no ordinary page fault, this flag is
         * set only if the P flag (bit 0) is 1 and the RSVD flag (bit 3) and the PK flag (bit 5) are both 0.
         */
        UINT32_t sgx : 1;
#define PAGE_FAULT_EXCEPTION_SGX_BIT                                 15
#define PAGE_FAULT_EXCEPTION_SGX_FLAG                                0x8000
#define PAGE_FAULT_EXCEPTION_SGX_MASK                                0x01
#define PAGE_FAULT_EXCEPTION_SGX(_)                                  (((_) >> 15) & 0x01)
        UINT32_t reserved2 : 16;
    };

    UINT32_t flags;
} page_fault_exception;

/**
 * @}
 */

 /**
  * @defgroup memory_type \
  *           Memory caching type
  *
  * The processor allows any area of system memory to be cached in the L1, L2, and L3 caches. In individual pages or regions
  * of system memory, it allows the type of caching (also called memory type) to be specified.
  *
  * @see Vol3A[11.11(MEMORY TYPE RANGE REGISTERS (MTRRS))]
  * @see Vol3A[11.5(CACHE CONTROL)]
  * @see Vol3A[11.3(METHODS OF CACHING AVAILABLE)] (reference)
  * @{
  */
  /**
   * @brief Strong Uncacheable (UC)
   *
   * System memory locations are not cached. All reads and writes appear on the system bus and are executed in program order
   * without reordering. No speculative memory accesses, pagetable walks, or prefetches of speculated branch targets are
   * made. This type of cache-control is useful for memory-mapped I/O devices. When used with normal RAM, it greatly reduces
   * processor performance.
   */
#define MEMORY_TYPE_UNCACHEABLE                                      0x00000000

   /**
    * @brief Write Combining (WC)
    *
    * System memory locations are not cached (as with uncacheable memory) and coherency is not enforced by the processor's bus
    * coherency protocol. Speculative reads are allowed. Writes may be delayed and combined in the write combining buffer (WC
    * buffer) to reduce memory accesses. If the WC buffer is partially filled, the writes may be delayed until the next
    * occurrence of a serializing event; such as, an SFENCE or MFENCE instruction, CPUID execution, a read or write to
    * uncached memory, an interrupt occurrence, or a LOCK instruction execution. This type of cache-control is appropriate for
    * video frame buffers, where the order of writes is unimportant as long as the writes update memory so they can be seen on
    * the graphics display. This memory type is available in the Pentium Pro and Pentium II processors by programming the
    * MTRRs; or in processor families starting from the Pentium III processors by programming the MTRRs or by selecting it
    * through the PAT.
    *
    * @see Vol3A[11.3.1(Buffering of Write Combining Memory Locations)]
    */
#define MEMORY_TYPE_WRITE_COMBINING                                  0x00000001

    /**
     * @brief Write-through (WT)
     *
     * Writes and reads to and from system memory are cached. Reads come from cache lines on cache hits; read misses cause
     * cache fills. Speculative reads are allowed. All writes are written to a cache line (when possible) and through to system
     * memory. When writing through to memory, invalid cache lines are never filled, and valid cache lines are either filled or
     * invalidated. Write combining is allowed. This type of cache-control is appropriate for frame buffers or when there are
     * devices on the system bus that access system memory, but do not perform snooping of memory accesses. It enforces
     * coherency between caches in the processors and system memory.
     */
#define MEMORY_TYPE_WRITE_THROUGH                                    0x00000004

     /**
      * @brief Write protected (WP)
      *
      * Reads come from cache lines when possible, and read misses cause cache fills. Writes are propagated to the system bus
      * and cause corresponding cache lines on all processors on the bus to be invalidated. Speculative reads are allowed. This
      * memory type is available in processor families starting from the P6 family processors by programming the MTRRs.
      */
#define MEMORY_TYPE_WRITE_PROTECTED                                  0x00000005

      /**
       * @brief Write-back (WB)
       *
       * Writes and reads to and from system memory are cached. Reads come from cache lines on cache hits; read misses cause
       * cache fills. Speculative reads are allowed. Write misses cause cache line fills (in processor families starting with the
       * P6 family processors), and writes are performed entirely in the cache, when possible. Write combining is allowed. The
       * write-back memory type reduces bus traffic by eliminating many unnecessary writes to system memory. Writes to a cache
       * line are not immediately forwarded to system memory; instead, they are accumulated in the cache. The modified cache
       * lines are written to system memory later, when a write-back operation is performed. Write-back operations are triggered
       * when cache lines need to be deallocated, such as when new cache lines are being allocated in a cache that is already
       * full. They also are triggered by the mechanisms used to maintain cache consistency. This type of cache-control provides
       * the best performance, but it requires that all devices that access system memory on the system bus be able to snoop
       * memory accesses to insure system memory and cache coherency.
       */
#define MEMORY_TYPE_WRITE_BACK                                       0x00000006

       /**
        * @brief Uncacheable (UC-)
        *
        * Has same characteristics as the strong uncacheable (UC) memory type, except that this memory type can be overridden by
        * programming the MTRRs for the WC memory type. This memory type is available in processor families starting from the
        * Pentium III processors and can only be selected through the PAT.
        */
#define MEMORY_TYPE_UNCACHEABLE_MINUS                                0x00000007
#define MEMORY_TYPE_INVALID                                          0x000000FF
        /**
         * @}
         */

         /**
          * @}
          */


```

`PayLoad (Intel)/mm.cpp`:

```cpp
#include "mm.h"

auto mm::map_guest_phys(guest_phys_t phys_addr, map_type_t map_type) -> u64
{
	const auto host_phys =
		translate_guest_physical(
			phys_addr, map_type);

	if (!host_phys)
		return {};

	return map_page(host_phys, map_type);
}

auto mm::map_guest_virt(guest_phys_t dirbase, guest_virt_t virt_addr, map_type_t map_type) -> u64
{
	const auto guest_phys = 
		translate_guest_virtual(
			dirbase, virt_addr, map_type);

	if (!guest_phys)
		return {};

	return map_guest_phys(guest_phys, map_type);
}

auto mm::map_page(host_phys_t phys_addr, map_type_t map_type) -> u64
{
	cpuid_eax_01 cpuid_value;
	__cpuid((int*)&cpuid_value, 1);

	mm::pt[(cpuid_value
		.cpuid_additional_information
		.initial_apic_id * 2)
			+ (unsigned)map_type].pfn = phys_addr >> 12;

	__invlpg(reinterpret_cast<void*>(
		get_map_virt(virt_addr_t{ phys_addr }.offset_4kb, map_type)));

	return get_map_virt(virt_addr_t{ phys_addr }.offset_4kb, map_type);
}

auto mm::get_map_virt(u16 offset, map_type_t map_type) -> u64
{
	cpuid_eax_01 cpuid_value;
	__cpuid((int*)&cpuid_value, 1);
	virt_addr_t virt_addr{ MAPPING_ADDRESS_BASE };

	virt_addr.pt_index = (cpuid_value
		.cpuid_additional_information
		.initial_apic_id * 2)
			+ (unsigned)map_type;

	return virt_addr.value + offset;
}

auto mm::translate(host_virt_t host_virt) -> u64
{
	virt_addr_t virt_addr{ host_virt };
	virt_addr_t cursor{ (u64)hyperv_pml4 };

	if (!reinterpret_cast<ppml4e>(cursor.value)[virt_addr.pml4_index].present)
		return {};

	cursor.pt_index = virt_addr.pml4_index;
	if (!reinterpret_cast<ppdpte>(cursor.value)[virt_addr.pdpt_index].present)
		return {};

	// handle 1gb large page...
	if (reinterpret_cast<ppdpte>(cursor.value)[virt_addr.pdpt_index].large_page)
		return (reinterpret_cast<ppdpte>(cursor.value)
			[virt_addr.pdpt_index].pfn << 12) + virt_addr.offset_1gb;

	cursor.pd_index = virt_addr.pml4_index;
	cursor.pt_index = virt_addr.pdpt_index;
	if (!reinterpret_cast<ppde>(cursor.value)[virt_addr.pd_index].present)
		return {};

	// handle 2mb large page...
	if (reinterpret_cast<ppde>(cursor.value)[virt_addr.pd_index].large_page)
		return (reinterpret_cast<ppde>(cursor.value)
			[virt_addr.pd_index].pfn << 12) + virt_addr.offset_2mb;

	cursor.pdpt_index = virt_addr.pml4_index;
	cursor.pd_index = virt_addr.pdpt_index;
	cursor.pt_index = virt_addr.pd_index;
	if (!reinterpret_cast<ppte>(cursor.value)[virt_addr.pt_index].present)
		return {};

	return (reinterpret_cast<ppte>(cursor.value)
		[virt_addr.pt_index].pfn << 12) + virt_addr.offset_4kb;
}

auto mm::translate_guest_virtual(guest_phys_t dirbase, guest_virt_t guest_virt, map_type_t map_type) -> u64
{
	virt_addr_t virt_addr{ guest_virt };
	const auto pml4 =
		reinterpret_cast<pml4e*>(map_guest_phys(dirbase, map_type));

	if (!pml4[virt_addr.pml4_index].present)
		return {};

	const auto pdpt =
		reinterpret_cast<pdpte*>(map_guest_phys(
			pml4[virt_addr.pml4_index].pfn << 12, map_type));

	if (!pdpt[virt_addr.pdpt_index].present)
		return {};

	// handle 1gb pages...
	if (pdpt[virt_addr.pdpt_index].large_page)
		return (pdpt[virt_addr.pdpt_index].pfn << 12) + virt_addr.offset_1gb;

	const auto pd =
		reinterpret_cast<pde*>(map_guest_phys(
			pdpt[virt_addr.pdpt_index].pfn << 12, map_type));

	if (!pd[virt_addr.pd_index].present)
		return {};

	// handle 2mb pages...
	if (pd[virt_addr.pd_index].large_page)
		return (pd[virt_addr.pd_index].pfn << 12) + virt_addr.offset_2mb;

	const auto pt =
		reinterpret_cast<pte*>(map_guest_phys(
			pd[virt_addr.pd_index].pfn << 12, map_type));

	if (!pt[virt_addr.pt_index].present)
		return {};

	return (pt[virt_addr.pt_index].pfn << 12) + virt_addr.offset_4kb;
}

auto mm::translate_guest_physical(guest_phys_t phys_addr, map_type_t map_type) -> u64
{
	ept_pointer eptp;
	phys_addr_t guest_phys{ phys_addr };
	__vmx_vmread(VMCS_CTRL_EPT_POINTER, (size_t*)&eptp);

	const auto epml4 = reinterpret_cast<ept_pml4e*>(
		map_page(eptp.page_frame_number << 12, map_type));

	const auto epdpt_large =
		reinterpret_cast<ept_pdpte_1gb*>(map_page(
			epml4[guest_phys.pml4_index].page_frame_number << 12, map_type));

	// handle 1gb page...
	if (epdpt_large[guest_phys.pdpt_index].large_page)
		return (epdpt_large[guest_phys.pdpt_index].page_frame_number
			* 0x1000 * 0x200 * 0x200) + EPT_LARGE_PDPTE_OFFSET(phys_addr);

	const auto epdpt =
		reinterpret_cast<ept_pdpte*>(epdpt_large);

	const auto epd_large =
		reinterpret_cast<epde_2mb*>(map_page(
			epdpt[guest_phys.pdpt_index].page_frame_number << 12, map_type));

	// handle 2mb page...
	if (epd_large[guest_phys.pd_index].large_page)
		return (epd_large[guest_phys.pd_index].page_frame_number
			* 0x1000 * 0x200) + EPT_LARGE_PDE_OFFSET(phys_addr);

	const auto epd =
		reinterpret_cast<ept_pde*>(epd_large);

	const auto ept =
		reinterpret_cast<ept_pte*>(map_page(
			epd[guest_phys.pd_index].page_frame_number << 12, map_type));

	auto result = ept[guest_phys.pt_index].page_frame_number << 12;
	return result;
}

auto mm::init() -> vmxroot_error_t
{
	const auto pdpt_phys = 
		translate(reinterpret_cast<u64>(pdpt));

	const auto pd_phys = 
		translate(reinterpret_cast<u64>(pd));

	const auto pt_phys = 
		translate(reinterpret_cast<u64>(pt));

	if (!pdpt_phys || !pd_phys || !pt_phys)
		return vmxroot_error_t::invalid_host_virtual;

	// setup mapping page table entries...
	{
		hyperv_pml4[MAPPING_PML4_IDX].present = true;
		hyperv_pml4[MAPPING_PML4_IDX].pfn = pdpt_phys >> 12;
		hyperv_pml4[MAPPING_PML4_IDX].user_supervisor = false;
		hyperv_pml4[MAPPING_PML4_IDX].writeable = true;

		pdpt[511].present = true;
		pdpt[511].pfn = pd_phys >> 12;
		pdpt[511].user_supervisor = false;
		pdpt[511].rw = true;

		pd[511].present = true;
		pd[511].pfn = pt_phys >> 12;
		pd[511].user_supervisor = false;
		pd[511].rw = true;
	}

	// each core will have its own page it can use to map
	// physical memory into virtual memory :^)
	for (auto idx = 0u; idx < 512; ++idx)
	{
		pt[idx].present = true;
		pt[idx].user_supervisor = false;
		pt[idx].rw = true;
	}

	const auto mapped_pml4 =
		reinterpret_cast<ppml4e>(
			mm::map_page(__readcr3()));

	// check to make sure translate works...
	if (translate((u64)mapped_pml4) != __readcr3())
		return vmxroot_error_t::vmxroot_translate_failure;

	// check to make sure the self ref pml4e is valid...
	if (mapped_pml4[SELF_REF_PML4_IDX].pfn != __readcr3() >> 12)
		return vmxroot_error_t::invalid_self_ref_pml4e;

	// check to make sure the mapping pml4e is valid...
	if (mapped_pml4[MAPPING_PML4_IDX].pfn != pdpt_phys >> 12)
		return vmxroot_error_t::invalid_mapping_pml4e;

	return vmxroot_error_t::error_success;
}

auto mm::read_guest_phys(guest_phys_t dirbase, guest_phys_t guest_phys,
	guest_virt_t guest_virt, u64 size) -> vmxroot_error_t
{
	// handle reading over page boundaries of both src and dest...
	while (size)
	{
		auto dest_current_size = PAGE_4KB - 
			virt_addr_t{ guest_virt }.offset_4kb;

		if (size < dest_current_size)
			dest_current_size = size;

		auto src_current_size = PAGE_4KB - 
			phys_addr_t{ guest_phys }.offset_4kb;

		if (size < src_current_size)
			src_current_size = size;

		auto current_size = 
			min(dest_current_size, src_current_size);

		const auto mapped_dest =
			reinterpret_cast<void*>(
				map_guest_virt(dirbase, guest_virt, map_type_t::map_dest));

		if (!mapped_dest)
			return vmxroot_error_t::invalid_guest_virtual;

		const auto mapped_src =
			reinterpret_cast<void*>(
				map_guest_phys(guest_phys, map_type_t::map_src));

		if (!mapped_src)
			return vmxroot_error_t::invalid_guest_physical;

		memcpy(mapped_dest, mapped_src, current_size);
		guest_phys += current_size;
		guest_virt += current_size;
		size -= current_size;
	}

	return vmxroot_error_t::error_success;
}

auto mm::write_guest_phys(guest_phys_t dirbase, 
	guest_phys_t guest_phys, guest_virt_t guest_virt, u64 size) -> vmxroot_error_t
{
	// handle reading over page boundaries of both src and dest...
	while (size)
	{
		auto dest_current_size = PAGE_4KB -
			virt_addr_t{ guest_virt }.offset_4kb;

		if (size < dest_current_size)
			dest_current_size = size;

		auto src_current_size = PAGE_4KB -
			phys_addr_t{ guest_phys }.offset_4kb;

		if (size < src_current_size)
			src_current_size = size;

		auto current_size =
			min(dest_current_size, src_current_size);

		const auto mapped_src =
			reinterpret_cast<void*>(
				map_guest_virt(dirbase, guest_virt, map_type_t::map_src));

		if (!mapped_src)
			return vmxroot_error_t::invalid_guest_virtual;

		const auto mapped_dest =
			reinterpret_cast<void*>(
				map_guest_phys(guest_phys, map_type_t::map_dest));

		if (!mapped_src)
			return vmxroot_error_t::invalid_guest_physical;

		memcpy(mapped_dest, mapped_src, current_size);
		guest_phys += current_size;
		guest_virt += current_size;
		size -= current_size;
	}

	return vmxroot_error_t::error_success;
}

auto mm::copy_guest_virt(guest_phys_t dirbase_src, guest_virt_t virt_src,
	guest_virt_t dirbase_dest, guest_virt_t virt_dest, u64 size) -> vmxroot_error_t
{
	while (size)
	{
		auto dest_size = PAGE_4KB - virt_addr_t{ virt_dest }.offset_4kb;
		if (size < dest_size)
			dest_size = size;

		auto src_size = PAGE_4KB - virt_addr_t{ virt_src }.offset_4kb;
		if (size < src_size)
			src_size = size;

		const auto mapped_src = 
			reinterpret_cast<void*>(
				map_guest_virt(dirbase_src, virt_src, map_type_t::map_src));

		if (!mapped_src) 
			return vmxroot_error_t::invalid_guest_virtual;

		const auto mapped_dest = 
			reinterpret_cast<void*>(
				map_guest_virt(dirbase_dest, virt_dest, map_type_t::map_dest));

		if (!mapped_dest) 
			return vmxroot_error_t::invalid_guest_virtual;

		auto current_size = min(dest_size, src_size);
		memcpy(mapped_dest, mapped_src, current_size);

		virt_src += current_size;
		virt_dest += current_size;
		size -= current_size;
	}

	return vmxroot_error_t::error_success;
}
```

`PayLoad (Intel)/mm.h`:

```h
#pragma once
#include "types.h"
#include "debug.h"

#define SELF_REF_PML4_IDX 510
#define MAPPING_PML4_IDX 100

#define MAPPING_ADDRESS_BASE 0x0000327FFFE00000
#define SELF_REF_PML4 0xFFFFFF7FBFDFE000

#define EPT_LARGE_PDPTE_OFFSET(_) (((u64)(_)) & ((0x1000 * 0x200 * 0x200) - 1))
#define EPT_LARGE_PDE_OFFSET(_) (((u64)(_)) & ((0x1000 * 0x200) - 1))

#pragma section(".pdpt", read, write)
#pragma section(".pd", read, write)
#pragma section(".pt", read, write)

namespace mm
{
    enum class map_type_t
    {
        map_src,
        map_dest
    };

    typedef union _virt_addr_t
    {
        u64 value;
        struct
        {
            u64 offset_4kb : 12;
            u64 pt_index : 9;
            u64 pd_index : 9;
            u64 pdpt_index : 9;
            u64 pml4_index : 9;
            u64 reserved : 16;
        };

        struct
        {
            u64 offset_2mb : 21;
            u64 pd_index : 9;
            u64 pdpt_index : 9;
            u64 pml4_index : 9;
            u64 reserved : 16;
        };

        struct
        {
            u64 offset_1gb : 30;
            u64 pdpt_index : 9;
            u64 pml4_index : 9;
            u64 reserved : 16;
        };

    } virt_addr_t, * pvirt_addr_t;
    using phys_addr_t = virt_addr_t;

    typedef union _pml4e
    {
        u64 value;
        struct
        {
            u64 present : 1;
            u64 writeable : 1;
            u64 user_supervisor : 1;
            u64 page_write_through : 1;
            u64 page_cache : 1;
            u64 accessed : 1;
            u64 ignore_1 : 1;
            u64 page_size : 1;
            u64 ignore_2 : 4;
            u64 pfn : 36;
            u64 reserved : 4;
            u64 ignore_3 : 11;
            u64 nx : 1;
        };
    } pml4e, * ppml4e;

    typedef union _pdpte
    {
        u64 value;
        struct
        {
            u64 present : 1;
            u64 rw : 1;
            u64 user_supervisor : 1;
            u64 page_write_through : 1;
            u64 page_cache : 1;
            u64 accessed : 1;
            u64 ignore_1 : 1;
            u64 large_page : 1;
            u64 ignore_2 : 4;
            u64 pfn : 36;
            u64 reserved : 4;
            u64 ignore_3 : 11;
            u64 nx : 1;
        };
    } pdpte, * ppdpte;

    typedef union _pde
    {
        u64 value;
        struct
        {
            u64 present : 1;
            u64 rw : 1;
            u64 user_supervisor : 1;
            u64 page_write_through : 1;
            u64 page_cache : 1;
            u64 accessed : 1;
            u64 ignore_1 : 1;
            u64 large_page : 1;
            u64 ignore_2 : 4;
            u64 pfn : 36;
            u64 reserved : 4;
            u64 ignore_3 : 11;
            u64 nx : 1;
        };
    } pde, * ppde;

    typedef union _pte
    {
        u64 value;
        struct
        {
            u64 present : 1;
            u64 rw : 1;
            u64 user_supervisor : 1;
            u64 page_write_through : 1;
            u64 page_cache : 1;
            u64 accessed : 1;
            u64 dirty : 1;
            u64 access_type : 1;
            u64 global : 1;
            u64 ignore_2 : 3;
            u64 pfn : 36;
            u64 reserved : 4;
            u64 ignore_3 : 7;
            u64 pk : 4;
            u64 nx : 1;
        };
    } pte, * ppte;

    __declspec(allocate(".pdpt")) inline pdpte pdpt[512];
    __declspec(allocate(".pd")) inline pde pd[512];
    __declspec(allocate(".pt")) inline pte pt[512];

    inline const ppml4e hyperv_pml4{ reinterpret_cast<ppml4e>(SELF_REF_PML4) };

    auto init() -> vmxroot_error_t;
    auto map_guest_phys(guest_phys_t phys_addr, map_type_t map_type = map_type_t::map_src) -> u64;
    auto map_guest_virt(guest_phys_t dirbase, guest_virt_t virt_addr, map_type_t map_type = map_type_t::map_src) -> u64;

    auto map_page(host_phys_t phys_addr, map_type_t map_type = map_type_t::map_src) -> u64;
    auto get_map_virt(u16 offset = 0u, map_type_t map_type = map_type_t::map_src) -> u64;

    auto translate(host_virt_t host_virt) -> u64;
    auto translate_guest_physical(guest_phys_t guest_phys, map_type_t map_type = map_type_t::map_src) -> u64;
    auto translate_guest_virtual(guest_phys_t dirbase, guest_virt_t guest_virt, map_type_t map_type = map_type_t::map_src) -> u64;

    auto read_guest_phys(guest_phys_t dirbase, guest_phys_t guest_phys, guest_virt_t guest_virt, u64 size) -> vmxroot_error_t;
    auto write_guest_phys(guest_phys_t dirbase, guest_phys_t guest_phys, guest_virt_t guest_virt, u64 size) -> vmxroot_error_t;
    auto copy_guest_virt(guest_phys_t dirbase_src, guest_virt_t virt_src, guest_virt_t dirbase_dest, guest_virt_t virt_dest, u64 size) -> vmxroot_error_t;
}
```

`PayLoad (Intel)/types.h`:

```h
#pragma once
#include <intrin.h>
#include <xmmintrin.h>
#include <cstddef>

#include <Windows.h>
#include <ntstatus.h>
#include "ia32.hpp"

#define VMEXIT_KEY 0xDEADBEEFDEADBEEF
#define PAGE_4KB 0x1000
#define PAGE_2MB PAGE_4KB * 512
#define PAGE_1GB PAGE_2MB * 512

using u8 = unsigned char;
using u16 = unsigned short;
using u32 = unsigned int;
using u64 = unsigned long long;
using u128 = __m128;

using guest_virt_t = u64;
using guest_phys_t = u64;
using host_virt_t = u64;
using host_phys_t = u64;

enum class vmexit_command_t
{
	init_page_tables,
	read_guest_phys,
	write_guest_phys,
	copy_guest_virt,
	get_dirbase,
	translate
};

enum class vmxroot_error_t
{
	error_success,
	pml4e_not_present,
	pdpte_not_present,
	pde_not_present,
	pte_not_present,
	vmxroot_translate_failure,
	invalid_self_ref_pml4e,
	invalid_mapping_pml4e,
	invalid_host_virtual,
	invalid_guest_physical,
	invalid_guest_virtual,
	page_table_init_failed
};

typedef union _command_t
{
	struct _copy_phys
	{
		host_phys_t  phys_addr;
		guest_virt_t buffer;
		u64 size;
	} copy_phys;

	struct _copy_virt
	{
		guest_phys_t dirbase_src;
		guest_virt_t virt_src;
		guest_phys_t dirbase_dest;
		guest_virt_t virt_dest;
		u64 size;
	} copy_virt;

	struct _translate_virt
	{
		guest_virt_t virt_src;
		guest_phys_t phys_addr;
	} translate_virt;

	guest_phys_t dirbase;

} command_t, * pcommand_t;

typedef struct _context_t
{
	u64 rax;
	u64 rcx;
	u64 rdx;
	u64 rbx;
	u64 rsp;
	u64 rbp;
	u64 rsi;
	u64 rdi;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
	u128 xmm0;
	u128 xmm1;
	u128 xmm2;
	u128 xmm3;
	u128 xmm4;
	u128 xmm5;
} context_t, *pcontext_t;

#if WINVER > 1803
using vmexit_handler_t = void (__fastcall*)(pcontext_t* context, void* unknown);
#else
using vmexit_handler_t = void(__fastcall*)(pcontext_t context, void* unknown);
#endif

#pragma pack(push, 1)
typedef struct _voyager_t
{
	u64 vmexit_handler_rva;
	u64 hyperv_module_base;
	u64 hyperv_module_size;
	u64 payload_base;
	u64 payload_size;
} voyager_t, *pvoyager_t;
#pragma pack(pop)

__declspec(dllexport) inline voyager_t voyager_context;
```

`PayLoad (Intel)/vmexit.cpp`:

```cpp
#include "vmexit.h"

namespace vmexit
{
	auto get_command(guest_virt_t command_ptr) -> command_t
	{
		u64 guest_dirbase;
		__vmx_vmread(VMCS_GUEST_CR3, &guest_dirbase);

		// cr3 can contain other high bits so just to be safe
		// get the pfn and bitshift it...
		guest_dirbase = cr3{ guest_dirbase }.pml4_pfn << 12;

		const auto command_page = 
			mm::map_guest_virt(guest_dirbase, command_ptr);

		return *reinterpret_cast<command_t*>(command_page);
	}

	auto set_command(guest_virt_t command_ptr, command_t& command_data) -> void
	{
		u64 guest_dirbase;
		__vmx_vmread(VMCS_GUEST_CR3, &guest_dirbase);

		// cr3 can contain other high bits so just to be safe
		// get the pfn and bitshift it...
		guest_dirbase = cr3{ guest_dirbase }.pml4_pfn << 12;

		const auto command_page =
			mm::map_guest_virt(guest_dirbase, command_ptr);

		*reinterpret_cast<command_t*>(command_page) = command_data;
	}
}
```

`PayLoad (Intel)/vmexit.h`:

```h
#pragma once
#include "mm.h"
#include "debug.h"

namespace vmexit
{
	auto get_command(guest_virt_t command_ptr) -> command_t;
	auto set_command(guest_virt_t command_ptr, command_t& command_data) -> void;
}
```

`PayLoad (Intel)/vmexit_handler.cpp`:

```cpp
#include "vmexit.h"

#if WINVER > 1803
void vmexit_handler(pcontext_t* context, void* unknown)
#else
void vmexit_handler(pcontext_t context, void* unknown)
#endif
{

#if WINVER > 1803
	pcontext_t guest_registers = *context;
#else
	pcontext_t guest_registers = context;
#endif

	size_t vmexit_reason;
	__vmx_vmread(VMCS_EXIT_REASON, &vmexit_reason);
	if (vmexit_reason == VMX_EXIT_REASON_EXECUTE_CPUID)
	{
		if (guest_registers->rcx == VMEXIT_KEY)
		{
			switch ((vmexit_command_t)guest_registers->rdx)
			{
			case vmexit_command_t::init_page_tables:
			{
				guest_registers->rax = (u64) mm::init();
				break;
			}
			case vmexit_command_t::get_dirbase:
			{
				auto command_data =
					vmexit::get_command(guest_registers->r8);

				u64 guest_dirbase;
				__vmx_vmread(VMCS_GUEST_CR3, &guest_dirbase);

				// cr3 can contain other high bits so just to be safe
				// get the pfn and bitshift it...
				guest_dirbase = cr3{ guest_dirbase }.pml4_pfn << 12;
				command_data.dirbase = guest_dirbase;
				guest_registers->rax = (u64) vmxroot_error_t::error_success;

				vmexit::set_command(
					guest_registers->r8, command_data);
				break;
			}
			case vmexit_command_t::read_guest_phys:
			{
				auto command_data =
					vmexit::get_command(guest_registers->r8);

				u64 guest_dirbase;
				__vmx_vmread(VMCS_GUEST_CR3, &guest_dirbase);
				// from 1809-1909 PCIDE is enabled in CR4 and so cr3 contains some other stuff...
				guest_dirbase = cr3{ guest_dirbase }.pml4_pfn << 12;

				guest_registers->rax =
					(u64) mm::read_guest_phys(
						guest_dirbase,
						command_data.copy_phys.phys_addr,
						command_data.copy_phys.buffer,
						command_data.copy_phys.size);

				vmexit::set_command(
					guest_registers->r8, command_data);
				break;
			}
			case vmexit_command_t::write_guest_phys:
			{
				auto command_data =
					vmexit::get_command(guest_registers->r8);

				u64 guest_dirbase;
				__vmx_vmread(VMCS_GUEST_CR3, &guest_dirbase);
				// from 1809-1909 PCIDE is enabled in CR4 and so cr3 contains some other stuff...
				guest_dirbase = cr3{ guest_dirbase }.pml4_pfn << 12;

				guest_registers->rax =
					(u64) mm::write_guest_phys(
						guest_dirbase,
						command_data.copy_phys.phys_addr,
						command_data.copy_phys.buffer,
						command_data.copy_phys.size);

				vmexit::set_command(
					guest_registers->r8, command_data);
				break;
			}
			case vmexit_command_t::copy_guest_virt:
			{
				auto command_data =
					vmexit::get_command(guest_registers->r8);

				auto virt_data = command_data.copy_virt;
				guest_registers->rax =
					(u64)mm::copy_guest_virt(
						virt_data.dirbase_src,
						virt_data.virt_src,
						virt_data.dirbase_dest,
						virt_data.virt_dest,
						virt_data.size);
				break;
			}
			case vmexit_command_t::translate:
			{
				auto command_data =
					vmexit::get_command(guest_registers->r8);

				u64 guest_dirbase;
				__vmx_vmread(VMCS_GUEST_CR3, &guest_dirbase);
				guest_dirbase = cr3{ guest_dirbase }.pml4_pfn << 12;

				command_data.translate_virt.phys_addr =
					mm::translate_guest_virtual(guest_dirbase, 
						command_data.translate_virt.virt_src);

				guest_registers->rax = 
					(u64) vmxroot_error_t::error_success;

				vmexit::set_command(
					guest_registers->r8, command_data);
				break;
			}
			default:
				break;
			}

			// advance instruction pointer...
			size_t rip, exec_len;
			__vmx_vmread(VMCS_GUEST_RIP, &rip);
			__vmx_vmread(VMCS_VMEXIT_INSTRUCTION_LENGTH, &exec_len);
			__vmx_vmwrite(VMCS_GUEST_RIP, rip + exec_len);
			return;
		}
	}

	// call original vmexit handler...
	reinterpret_cast<vmexit_handler_t>(
		reinterpret_cast<u64>(&vmexit_handler) -
			voyager_context.vmexit_handler_rva)(context, unknown);
}
```

`PayLoad.c`:

```c
#include "PayLoad.h"

// this can also just be set at compile time if you want too, but for PoC im going
// to read the payload from disk and delete it after...
// x64-86

VOID* PayLoad = NULL;

UINT32 PayLoadSize(VOID)
{
	EFI_IMAGE_DOS_HEADER* RecordDosImageHeader = PayLoad;
	if (RecordDosImageHeader->e_magic != EFI_IMAGE_DOS_SIGNATURE)
		return NULL;

	EFI_IMAGE_NT_HEADERS64* RecordNtHeaders = (UINT64)RecordDosImageHeader + RecordDosImageHeader->e_lfanew;
	if (RecordNtHeaders->Signature != EFI_IMAGE_NT_SIGNATURE)
		return NULL;

	return RecordNtHeaders->OptionalHeader.SizeOfImage + 0x1000;
}

VOID* PayLoadEntry(VOID* ModuleBase)
{
	EFI_IMAGE_DOS_HEADER* RecordDosImageHeader = PayLoad;
	if (RecordDosImageHeader->e_magic != EFI_IMAGE_DOS_SIGNATURE)
		return NULL;

	EFI_IMAGE_NT_HEADERS64* RecordNtHeaders = (UINT64)RecordDosImageHeader + RecordDosImageHeader->e_lfanew;
	if (RecordNtHeaders->Signature != EFI_IMAGE_NT_SIGNATURE)
		return NULL;

	return (UINT64)ModuleBase + RecordNtHeaders->OptionalHeader.AddressOfEntryPoint;
}

// programmed by: hMihaiDavid
// taken from: https://github.com/hMihaiDavid/addscn/blob/master/addscn/addscn.cpp#L89
VOID* AddSection(VOID* ImageBase, CHAR8* SectionName, UINT32 VirtualSize, UINT32 Characteristics)
{
	EFI_IMAGE_DOS_HEADER* dosHeader = (EFI_IMAGE_DOS_HEADER*)ImageBase;
	EFI_IMAGE_NT_HEADERS64* ntHeaders = (EFI_IMAGE_NT_HEADERS64*)((UINT64)ImageBase + dosHeader->e_lfanew);

	UINT16 sizeOfOptionalHeader = ntHeaders->FileHeader.SizeOfOptionalHeader;
	EFI_IMAGE_FILE_HEADER* fileHeader = &(ntHeaders->FileHeader);

	EFI_IMAGE_SECTION_HEADER* firstSectionHeader = 
		(EFI_IMAGE_SECTION_HEADER*)(((UINT64)fileHeader) + 
			sizeof(EFI_IMAGE_FILE_HEADER) + sizeOfOptionalHeader);

	UINT32 numberOfSections = ntHeaders->FileHeader.NumberOfSections;
	UINT32 sectionAlignment = ntHeaders->OptionalHeader.SectionAlignment;
	UINT32 fileAlignment = ntHeaders->OptionalHeader.FileAlignment;

	EFI_IMAGE_SECTION_HEADER* newSectionHeader = &firstSectionHeader[numberOfSections];
	EFI_IMAGE_SECTION_HEADER* lastSectionHeader = &firstSectionHeader[numberOfSections - 1];

	MemCopy(&newSectionHeader->Name, SectionName, AsciiStrLen(SectionName));
	newSectionHeader->Misc.VirtualSize = VirtualSize;
	newSectionHeader->VirtualAddress = 
		P2ALIGNUP(lastSectionHeader->VirtualAddress + 
			lastSectionHeader->Misc.VirtualSize, sectionAlignment);

	newSectionHeader->SizeOfRawData = P2ALIGNUP(VirtualSize, fileAlignment);
	newSectionHeader->Characteristics = Characteristics;

	newSectionHeader->PointerToRawData = 
		(UINT32)(lastSectionHeader->PointerToRawData +
			lastSectionHeader->SizeOfRawData);

	++ntHeaders->FileHeader.NumberOfSections;
	ntHeaders->OptionalHeader.SizeOfImage = 
		P2ALIGNUP(newSectionHeader->VirtualAddress + 
			newSectionHeader->Misc.VirtualSize, sectionAlignment);

	return ((UINT64)ImageBase) + newSectionHeader->VirtualAddress;
}

EFI_STATUS LoadPayLoadFromDisk(VOID** PayLoadBufferPtr)
{
	EFI_STATUS Result = EFI_SUCCESS;
	UINTN HandleCount = NULL;
	EFI_HANDLE* Handles = NULL;
	EFI_FILE_HANDLE VolumeHandle;
	EFI_FILE_HANDLE PayLoadFileHandle;
	EFI_DEVICE_PATH* PayLoadDevicePath = NULL;
	EFI_FILE_IO_INTERFACE* FileSystem = NULL;
	EFI_FILE_PROTOCOL* PayLoadFile = NULL;

	if (EFI_ERROR((Result = gBS->LocateHandleBuffer(ByProtocol, &gEfiSimpleFileSystemProtocolGuid, NULL, &HandleCount, &Handles))))
	{
		Print(L"error getting file system handles -> 0x%p\n", Result);
		return Result;
	}

	for (UINT32 Idx = 0u; Idx < HandleCount; ++Idx)
	{
		if (EFI_ERROR((Result = gBS->OpenProtocol(Handles[Idx], &gEfiSimpleFileSystemProtocolGuid, (VOID**)&FileSystem, gImageHandle, NULL, EFI_OPEN_PROTOCOL_GET_PROTOCOL))))
		{
			Print(L"error opening protocol -> 0x%p\n", Result);
			return Result;
		}

		if (EFI_ERROR((Result = FileSystem->OpenVolume(FileSystem, &VolumeHandle))))
		{
			Print(L"error opening file system -> 0x%p\n", Result);
			return Result;
		}

		if (!EFI_ERROR((Result = VolumeHandle->Open(VolumeHandle, &PayLoadFileHandle, PAYLOAD_PATH, EFI_FILE_MODE_READ, EFI_FILE_READ_ONLY))))
		{
			VolumeHandle->Close(VolumeHandle);
			PayLoadDevicePath = FileDevicePath(Handles[Idx], PAYLOAD_PATH);

			if (EFI_ERROR((Result = EfiOpenFileByDevicePath(&PayLoadDevicePath, &PayLoadFile, EFI_FILE_MODE_WRITE | EFI_FILE_MODE_READ, NULL))))
			{
				Print(L"failed to open payload file... reason -> %r\n", Result);
				return Result;
			}

			EFI_FILE_INFO* FileInfoPtr = NULL;
			UINTN FileInfoSize = NULL;

			if (EFI_ERROR((Result = PayLoadFile->GetInfo(PayLoadFile, &gEfiFileInfoGuid, &FileInfoSize, NULL))))
			{
				if (Result == EFI_BUFFER_TOO_SMALL)
				{
					gBS->AllocatePool(EfiBootServicesData, FileInfoSize, &FileInfoPtr);
					if (EFI_ERROR(Result = PayLoadFile->GetInfo(PayLoadFile, &gEfiFileInfoGuid, &FileInfoSize, FileInfoPtr)))
					{
						Print(L"get backup file information failed... reason -> %r\n", Result);
						return Result;
					}
				}
				else
				{
					Print(L"Failed to get file information... reason -> %r\n", Result);
					return Result;
				}
			}

			VOID* PayLoadBuffer = NULL;
			UINTN PayLoadSize = FileInfoPtr->FileSize;
			gBS->AllocatePool(EfiBootServicesData, FileInfoPtr->FileSize, &PayLoadBuffer);

			if (EFI_ERROR((Result = PayLoadFile->Read(PayLoadFile, &PayLoadSize, PayLoadBuffer))))
			{
				Print(L"Failed to read payload file into buffer... reason -> %r\n", Result);
				return Result;
			}

			if (EFI_ERROR((Result = PayLoadFile->Delete(PayLoadFile))))
			{
				Print(L"unable to delete payload file... reason -> %r\n", Result);
				return Result;
			}

			*PayLoadBufferPtr = PayLoadBuffer;
			gBS->FreePool(FileInfoPtr);
			return EFI_SUCCESS;
		}
	}

	Print(L"unable to find payload on disk...\n");
	return EFI_ABORTED;
}

```

`PayLoad.h`:

```h
#pragma once
#include "Utils.h"
#include "PagingTables.h"
#include <Library/ShellLib.h>

#define NT_HEADER(x) ((EFI_IMAGE_NT_HEADERS64*)(((UINT64)(x)) + ((EFI_IMAGE_DOS_HEADER*)(x))->e_lfanew))

#define SECTION_RWX ((EFI_IMAGE_SCN_MEM_WRITE | \
	EFI_IMAGE_SCN_CNT_CODE | \
	EFI_IMAGE_SCN_CNT_UNINITIALIZED_DATA | \
	EFI_IMAGE_SCN_MEM_EXECUTE | \
	EFI_IMAGE_SCN_CNT_INITIALIZED_DATA | \
	EFI_IMAGE_SCN_MEM_READ))

// Source: https://blogs.oracle.com/jwadams/macros-and-powers-of-two
// align x down to the nearest multiple of align. align must be a power of 2.
#define P2ALIGNDOWN(x, align) ((x) & -(align))
// align x up to the nearest multiple of align. align must be a power of 2.
#define P2ALIGNUP(x, align) (-(-(x) & -(align)))

extern VOID* PayLoad;
#pragma pack(push, 1)
typedef struct _VOYAGER_T
{
	UINT64 VmExitHandlerRva;
	UINT64 HypervModuleBase;
	UINT64 HypervModuleSize;
	UINT64 ModuleBase;
	UINT64 ModuleSize;
} VOYAGER_T, *PVOYAGER_T;
#pragma pack(pop)

#define WINDOWS_BOOTMGFW_PATH L"\\efi\\microsoft\\boot\\bootmgfw.efi"
#define PAYLOAD_PATH L"\\efi\\microsoft\\boot\\payload.dll"

UINT32 PayLoadSize(VOID);
VOID* PayLoadEntry(VOID* ModuleBase);
EFI_STATUS LoadPayLoadFromDisk(VOID** PayLoadBufferPtr);
VOID* AddSection(VOID* ImageBase, CHAR8* SectionName, UINT32 VirtualSize, UINT32 Characteristics);
```

`README.md`:

```md
<div align="center">
    <div>
        <img src="https://git.back.engineering/_xeroxz/Voyager/raw/branch/master/img/unknown.png"/>
    </div>
    <img src="https://git.back.engineering/_xeroxz/Voyager/raw/branch/master/img/amd_badge.svg"/>
    <img src="https://git.back.engineering/_xeroxz/Voyager/raw/branch/master/img/Intel-supported-green.svg"/>
    <img src="https://git.back.engineering/_xeroxz/Voyager/raw/branch/master/img/2004--1507-supported-green.svg"/>
    <img src="https://git.back.engineering/_xeroxz/Voyager/raw/branch/master/img/Secure%20Boot-Unsupported-red.svg"/>
    <img src="https://git.back.engineering/_xeroxz/Voyager/raw/branch/master/img/Legacy_BIOS-Unsupported-red.svg"/>
</div>

***

### Credit

* [cr4sh](https://blog.cr4.sh/) - cr4sh has done something like this a few years back. A link to it can be found [here](https://github.com/Cr4sh/s6_pcie_microblaze/tree/master/python/payloads/DmaBackdoorHv).
* [btbd](https://github.com/btbd) - offering suggestions and providing input... also stole utils.c/utils.h :thumbsup:

# Voyager - A Hyper-V Hacking Framework For Windows 10 x64 (AMD & Intel)

Voyager is a project designed to offer module injection and vmexit hooking for both AMD & Intel versions of Hyper-V. 
This project works on all versions of Windows 10-x64 (2004-1507).

# Compiling - VisualUefi, EDK2

Please follow the instructions on this page https://github.com/ionescu007/VisualUefi. After you have compiled the EDK2 libraries, copy the ones
used by Voyager into the edk2 folder inside of the Voyager folder. You should then be able to compile Voyager.

Note you will need to install nasm and add it to your PATH system variable. This is detailed on `VisualUefi` repo.

*At first install NASM (https://www.nasm.us/) and check, that environment variable NASM_PREFIX is correctly set to NASM installation path. No other 3rd party tools are needed. Than you should be able to open the EDK-II.SLN file and build without any issues in either Visual Studio 2015 or 2017. WDK is not needed. Once the EDK-II libraries are built, you should be able to open the SAMPLES.SLN file and build the samples, which will create UefiApplication.efi, UefiDriver.efi, Cryptest.efi, and FtdiUsbSerialDxe.efi*

# HookChain - information and order of hooks...

<img src="https://git.back.engineering/_xeroxz/Voyager/raw/branch/master/img/hookchain.png"/>

***

### bootmgfw.efi

`bootmgfw.ImgArchStartBootApplication` between windows versions 2004-1709 is invoked to start winload.efi. A hook is place on this function in order to install hooks in winload.efi before
winload.efi starts execution. On windows 1703-1511 the symbol/name is different but parameters and return type are the same: `bootmgfw.BlImgStartBootApplication`.

### winload.efi

winload.efi between Windows 10-x64 versions 2004-1709 export a bunch of functions. Some of those functions are then imported by hvloader.dll such as `BlLdrLoadImage`. 
Older versions of windows 10-x64 (1703-1507) have another efi file by the name of hvloader.efi. Hvloader.efi contains alot of the same functions that are inside of winload. 
You can see that Microsoft simplified hvloader.efi in later versions of Windows 10-x64 by making winload export the functions that were also defined in hvloader.efi.

If you look at the project you will see hvloader.c/hvloader.h, these contain the hooks that are placed inside of hvloader and are installed from a hook inside of winload. 1703-1507
requires an extra set of hooks to get to where Hyper-v is loaded into memory.

### hvloader.efi

Hvloader.efi (found in windows versions 1703-1507) contains alot of the same functions that can be found inside of winload.efi as explained in the section above. In Windows 10-x64 versions spanning 1703-1507, 
Hyper-v is not loaded from a function found in winload.efi but instead of the same function found inside of hvloader.efi. These functions are `hvloader.BlImgLoadPEImageEx` 
and `hvloader.BlImgLoadPEImageFromSourceBuffer` for 1703 specifically.

### hvix64.exe (Intel)

hvix64.exe is the intel version of hyper-v. This module along with hvax64.exe does not have any symbols (no PDB). To find the vmexit handler I simply signature scanned for `0F 78` (vmread instruction)
and then xreferenced the functions that contained this instruction to see if they were called from a stub of code that pushes all registers including xmm's. It took me a little to find the correct
function but once I found the stub (vmexit handler) and c/c++ vmexit handler I was able to make a good enough signature to find the vmexit handler on all of the other Intel
versions of hyper-v.

### hvax64.exe (AMD)

hvax64.exe is the AMD version of hyper-v. This module along with hvix64.exe does not have any symbols (no PDB). To find the "vmexit handler" if you want to call it that for AMD hypervisors,
I simply signature scanned for `0f 01 d8` (VMRUN). AMD Hypervisors are basiclly a loop, first executing VMLOAD, then VMRUN (which runs the guest until an exit happens), and then
VMSAVE instruction is executed, the registers are pushed onto the stack, the exit is handled, then VMLOAD/VMRUN is executed again the cycle continues...

# Usage 

Please enable hyper-v in "turn windows features on or off". Then run launch.bat as admin, this will mount the EFI partition and move some files around then reboot you.
Voyager is designed to recover from a crash. The first thing Voyager will do when executed is restore bootmgfw on disk. If any complications occur during boot you can simply reboot.

<div align="center">
<img src="https://imgur.com/uOpcCp7.png"/>
</div>


### Compiling

Simply select the windows version you want to compile for and then compile the entire solution... Rename `Voyager.efi` to `bootmgfw.efi`, do the same for `Payload (xxx).dll`, 
rename it to `payload.dll`. Put both `bootmgfw.efi` (Voyager.efi rename), and `payload.dll` in the same folder as `launch.bat`. 

<div align="center">
    <div>
        <img src="https://githacks.org/xerox/voyager/uploads/fb3b24b28282a0cfe4c1b0440246844f/image.png"/>
    </div>
</div>

### libvoyager

libvoyager is a tiny lib that allows a programmer to integrate voyager into VDM or other projects that require reading and writing to physical and virtual memory. There is
an example in the repo which contains example code for integrating into VDM. 

```cpp
vdm::read_phys_t _read_phys = 
	[&](void* addr, void* buffer, std::size_t size) -> bool
{
	const auto read_result = 
		voyager::read_phys((u64)addr, (u64)buffer, size);

	return read_result == 
		voyager::vmxroot_error_t::error_success;
};

vdm::write_phys_t _write_phys =
	[&](void* addr, void* buffer, std::size_t size) -> bool
{
	const auto write_result = 
		voyager::write_phys((u64)addr, (u64)buffer, size);

	return write_result ==
		voyager::vmxroot_error_t::error_success;
};
```

Any project that uses VDM can now use Voyager instead of a vulnerable driver. This includes all PTM projects.

### Page Table Code

mm.cpp and mm.hpp contain all of the memory managment code. Hyper-v has a self referencing PML4E at index 510. This is the same index for all versions of Hyper-v. 
This is crucial as without knowing where the PML4 of the current logical processor is located in virtual memory, there is no way to interface with physical memory.
Each logical processor running under hyper-v has its own host cr3 value (each core has its own host PML4).

<img src="https://git.back.engineering/_xeroxz/Voyager/raw/branch/master/img/sections.PNG"/>

###### Mapping PTE's

In the Intel and AMD payloads of this project, there is a section for PDPT, PD, and PT. These sections need to be page aligned in 
order for them to work (they are just putting this here as a warning). Each logical processor has two PTE's, one for source and one for destination. This allows for
copying of physical memory between two pages without requiring a buffer. 

```cpp
auto mm::map_page(host_phys_t phys_addr, map_type_t map_type) -> u64
{
	cpuid_eax_01 cpuid_value;
	__cpuid((int*)&cpuid_value, 1);

	mm::pt[(cpuid_value
		.cpuid_additional_information
		.initial_apic_id * 2)
			+ (unsigned)map_type].pfn = phys_addr >> 12;

	__invlpg(reinterpret_cast<void*>(
		get_map_virt(virt_addr_t{ phys_addr }.offset_4kb, map_type)));

	return get_map_virt(virt_addr_t{ phys_addr }.offset_4kb, map_type);
}
```

As you can see from the code above, the logical processor number which is obtained from CPUID instruction is mulitplied by the `map_type`. There can be a max of 256 cores on the system, if there
are more then 256 cores on the system then this code above will not work.


# Demo - Virtual/Physical Read/Write + VDM Integration

The demo project contains everything one would need to start coding using libvoyager. The demo uses VDM to get the dirbase of explorer.exe and the hypervisor
to read/write to explorer.exe

<img src="https://imgur.com/OYu188i.png"/>

Creds: _xeroxz (back.engineering) for *

```

`ShellPkg/Include/Guid/ShellAliasGuid.h`:

```h
/** @file
  GUID for Shell Variable for Get/Set via runtime services.

  Copyright (c) 2009 - 2010, Intel Corporation. All rights reserved.<BR>
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#ifndef _SHELL_ALIAS_VARIABLE_GUID_H_
#define _SHELL_ALIAS_VARIABLE_GUID_H_

#define SHELL_ALIAS_VARIABLE_GUID \
{ \
  0x0053d9d6, 0x2659, 0x4599, { 0xa2, 0x6b, 0xef, 0x45, 0x36, 0xe6, 0x31, 0xa9 } \
}

extern EFI_GUID gShellAliasGuid;

#endif

```

`ShellPkg/Include/Guid/ShellEnvironment2Ext.h`:

```h
/** @file
  GUID for EFI shell Environment2 Extension.

  Copyright (c) 2009 - 2010, Intel Corporation. All rights reserved.<BR>
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#ifndef _SHELLPKG_SHELL_ENV2_EXT_GUID_H_
#define _SHELLPKG_SHELL_ENV2_EXT_GUID_H_

#define SHELLPKG_SHELL_ENV2_EXT_GUID \
{ \
  0xd2c18636, 0x40e5, 0x4eb5, {0xa3, 0x1b, 0x36, 0x69, 0x5f, 0xd4, 0x2c, 0x87} \
}

extern EFI_GUID gEfiShellEnvironment2ExtGuid;

#endif

```

`ShellPkg/Include/Guid/ShellLibHiiGuid.h`:

```h
/** @file
  GUIDs for HII package list installed by Shell libraries.

  Copyright (c) 2011 - 2016, Intel Corporation. All rights reserved.<BR>
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#ifndef _SHELLLIB_HII_GUID_H_
#define _SHELLLIB_HII_GUID_H_

#define HANDLE_PARSING_HII_GUID \
  { \
  0xb8969637, 0x81de, 0x43af, { 0xbc, 0x9a, 0x24, 0xd9, 0x89, 0x13, 0xf2, 0xf6 } \
  }

#define SHELL_DEBUG1_HII_GUID \
  { \
    0x25f200aa, 0xd3cb, 0x470a, { 0xbf, 0x51, 0xe7, 0xd1, 0x62, 0xd2, 0x2e, 0x6f } \
  }

#define SHELL_DRIVER1_HII_GUID \
  { \
  0xaf0b742, 0x63ec, 0x45bd, {0x8d, 0xb6, 0x71, 0xad, 0x7f, 0x2f, 0xe8, 0xe8} \
  }

#define SHELL_INSTALL1_HII_GUID \
  { \
    0x7d574d54, 0xd364, 0x4d4a, { 0x95, 0xe3, 0x49, 0x45, 0xdb, 0x7a, 0xd3, 0xee } \
  }

#define SHELL_LEVEL1_HII_GUID \
  { \
    0xdec5daa4, 0x6781, 0x4820, { 0x9c, 0x63, 0xa7, 0xb0, 0xe4, 0xf1, 0xdb, 0x31 } \
  }

#define SHELL_LEVEL2_HII_GUID \
  { \
    0xf95a7ccc, 0x4c55, 0x4426, { 0xa7, 0xb4, 0xdc, 0x89, 0x61, 0x95, 0xb, 0xae } \
  }

#define SHELL_LEVEL3_HII_GUID \
  { \
    0x4344558d, 0x4ef9, 0x4725, { 0xb1, 0xe4, 0x33, 0x76, 0xe8, 0xd6, 0x97, 0x4f } \
  }

#define SHELL_NETWORK1_HII_GUID \
  { \
    0xf3d301bb, 0xf4a5, 0x45a8, { 0xb0, 0xb7, 0xfa, 0x99, 0x9c, 0x62, 0x37, 0xae } \
  }

#define SHELL_NETWORK2_HII_GUID \
  { \
    0x174b2b5, 0xf505, 0x4b12, { 0xaa, 0x60, 0x59, 0xdf, 0xf8, 0xd6, 0xea, 0x37 } \
  }

#define SHELL_TFTP_HII_GUID \
  { \
    0x738a9314, 0x82c1, 0x4592, { 0x8f, 0xf7, 0xc1, 0xbd, 0xf1, 0xb2, 0x0e, 0xd4 } \
  }


#define SHELL_BCFG_HII_GUID \
  { \
    0x5f5f605d, 0x1583, 0x4a2d, {0xa6, 0xb2, 0xeb, 0x12, 0xda, 0xb4, 0xa2, 0xb6 } \
  }

extern EFI_GUID gHandleParsingHiiGuid;
extern EFI_GUID gShellDebug1HiiGuid;
extern EFI_GUID gShellDriver1HiiGuid;
extern EFI_GUID gShellInstall1HiiGuid;
extern EFI_GUID gShellLevel1HiiGuid;
extern EFI_GUID gShellLevel2HiiGuid;
extern EFI_GUID gShellLevel3HiiGuid;
extern EFI_GUID gShellNetwork1HiiGuid;
extern EFI_GUID gShellNetwork2HiiGuid;
extern EFI_GUID gShellTftpHiiGuid;
extern EFI_GUID gShellBcfgHiiGuid;

#endif

```

`ShellPkg/Include/Guid/ShellMapGuid.h`:

```h
/** @file
  GUID for Shell Map for Get/Set via runtime services.

  Copyright (c) 2009 - 2018, Intel Corporation. All rights reserved.<BR>
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#ifndef _SHELL_MAP_GUID_H_
#define _SHELL_MAP_GUID_H_

#define SHELL_MAP_GUID \
{ \
  0x51271e13, 0x7de3, 0x43af, { 0x8b, 0xc2, 0x71, 0xad, 0x3b, 0x82, 0x43, 0x25 } \
}

extern EFI_GUID gShellMapGuid;

#endif

```

`ShellPkg/Include/Guid/ShellPkgTokenSpace.h`:

```h
/** @file
  GUID for ShellPkg PCD Token Space.

  Copyright (c) 2009 - 2010, Intel Corporation. All rights reserved.<BR>
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#ifndef _SHELLPKG_TOKEN_SPACE_GUID_H_
#define _SHELLPKG_TOKEN_SPACE_GUID_H_

#define EFI_SHELLPKG_TOKEN_SPACE_GUID \
{ \
  0x171e9188, 0x31d3, 0x40f5, { 0xb1, 0xc, 0x53, 0x9b, 0x2d, 0xb9, 0x40, 0xcd } \
}

extern EFI_GUID gEfiShellPkgTokenSpaceGuid;

#endif

```

`ShellPkg/Include/Guid/ShellVariableGuid.h`:

```h
/** @file
  GUID for Shell Variable for Get/Set via runtime services.

  Copyright (c) 2009 - 2010, Intel Corporation. All rights reserved.<BR>
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#ifndef _SHELL_VARIABLE_GUID_H_
#define _SHELL_VARIABLE_GUID_H_

#define SHELL_VARIABLE_GUID \
{ \
  0x158def5a, 0xf656, 0x419c, { 0xb0, 0x27, 0x7a, 0x31, 0x92, 0xc0, 0x79, 0xd2 } \
}

extern EFI_GUID gShellVariableGuid;

#endif

```

`ShellPkg/Include/Library/BcfgCommandLib.h`:

```h
/** @file
  Header file for BCFG command library.

  Copyright (c) 2014, Intel Corporation. All rights reserved.<BR>
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#ifndef _BCFG_COMMAND_LIB_H_
#define _BCFG_COMMAND_LIB_H_

/**
  "Constructor" for the library.

  This will register the handler for the bcfg command.

  @param[in] ImageHandle    the image handle of the process
  @param[in] SystemTable    the EFI System Table pointer
  @param[in] Name           the profile name to use

  @retval EFI_SUCCESS        the shell command handlers were installed sucessfully
  @retval EFI_UNSUPPORTED    the shell level required was not found.
**/
EFI_STATUS
EFIAPI
BcfgLibraryRegisterBcfgCommand (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable,
  IN CONST CHAR16      *Name
  );

/**
  "Destructor" for the library.  free any resources.

  @param ImageHandle            The image handle of the process.
  @param SystemTable            The EFI System Table pointer.
**/
EFI_STATUS
EFIAPI
BcfgLibraryUnregisterBcfgCommand (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  );

#endif


```

`ShellPkg/Include/Library/HandleParsingLib.h`:

```h
/** @file
  Provides interface to advanced shell functionality for parsing both handle and protocol database.

  Copyright (c) 2010 - 2018, Intel Corporation. All rights reserved.<BR>
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#ifndef __HANDLE_PARSING_LIB__
#define __HANDLE_PARSING_LIB__

#include <Uefi.h>

/**
  Function to add a new GUID/Name mapping.

  This cannot overwrite an existing mapping.

  @param[in] Guid       The Guid
  @param[in] TheName    The Guid's name
  @param[in] Lang       RFC4646 language code list or NULL

  @retval EFI_SUCCESS           The operation was sucessful
  @retval EFI_ACCESS_DENIED     There was a duplicate
  @retval EFI_OUT_OF_RESOURCES  A memory allocation failed
**/
EFI_STATUS
EFIAPI
AddNewGuidNameMapping(
  IN CONST EFI_GUID *Guid,
  IN CONST CHAR16   *TheName,
  IN CONST CHAR8    *Lang OPTIONAL
  );

/**
  Function to get the name of a protocol or struct from it's GUID.

  If Guid is NULL, then ASSERT.

  @param[in] Guid               The GUID to look for the name of.
  @param[in] Lang               The language to use.

  @return                       The pointer to a string of the name.  The caller
                                is responsible to free this memory.
**/
CHAR16*
EFIAPI
GetStringNameFromGuid(
  IN CONST EFI_GUID *Guid,
  IN CONST CHAR8    *Lang OPTIONAL
  );

/**
  Function to get the Guid for a protocol or struct based on it's string name.

  Do not free or modify the returned GUID.

  @param[in] Name           The pointer to the string name.
  @param[in] Lang           The pointer to the language code (string).
  @param[out] Guid          The pointer to the pointer to the Guid.

  @retval EFI_SUCCESS       The operation was successful.
**/
EFI_STATUS
EFIAPI
GetGuidFromStringName(
  IN CONST CHAR16 *Name,
  IN CONST CHAR8  *Lang OPTIONAL,
  OUT EFI_GUID    **Guid
  );

/**
  Function to dump protocol information from a handle.

  This function will return a allocated string buffer containing the
  information.  The caller is responsible for freeing the memory.

  If Guid is NULL, ASSERT().
  If TheHandle is NULL, ASSERT().

  @param[in] TheHandle      The handle to dump information from.
  @param[in] Guid           The GUID of the protocol to dump.
  @param[in] Verbose        TRUE for extra info.  FALSE otherwise.

  @return                   The pointer to string.
  @retval NULL              An error was encountered.
**/
CHAR16*
EFIAPI
GetProtocolInformationDump(
  IN CONST EFI_HANDLE TheHandle,
  IN CONST EFI_GUID   *Guid,
  IN CONST BOOLEAN    Verbose
  );

/**
  Function to retrieve the driver name (if possible) from the ComponentName or
  ComponentName2 protocol.

  The string returned must be callee freed.

  @param[in] TheHandle      The driver handle to get the name of.
  @param[in] Language       The language to use.

  @retval NULL              The name could not be found.
  @return                   A pointer to the string name.  Do not de-allocate the memory.
**/
CONST CHAR16*
EFIAPI
GetStringNameFromHandle(
  IN CONST EFI_HANDLE TheHandle,
  IN CONST CHAR8      *Language
  );

/**
  Get best support language for this driver.

  First base on the user input language  to search, second base on the current
  platform used language to search, third get the first language from the
  support language list. The caller need to free the buffer of the best language.

  @param[in] SupportedLanguages      The support languages for this driver.
  @param[in] InputLanguage           The user input language.
  @param[in] Iso639Language          Whether get language for ISO639.

  @return                            The best support language for this driver.
**/
CHAR8 *
EFIAPI
GetBestLanguageForDriver (
  IN CONST CHAR8  *SupportedLanguages,
  IN CONST CHAR8  *InputLanguage,
  IN BOOLEAN      Iso639Language
  );

#define HR_UNKNOWN                     0
#define HR_IMAGE_HANDLE                BIT1
#define HR_DRIVER_BINDING_HANDLE       BIT2 // has driver binding
#define HR_DEVICE_DRIVER               BIT3 // device driver (hybrid?)
#define HR_BUS_DRIVER                  BIT4 // a bus driver  (hybrid?)
#define HR_DRIVER_CONFIGURATION_HANDLE BIT5
#define HR_DRIVER_DIAGNOSTICS_HANDLE   BIT6
#define HR_COMPONENT_NAME_HANDLE       BIT7
#define HR_DEVICE_HANDLE               BIT8
#define HR_PARENT_HANDLE               BIT9
#define HR_CONTROLLER_HANDLE           BIT10
#define HR_CHILD_HANDLE                BIT11
#define HR_VALID_MASK                  (BIT1|BIT2|BIT3|BIT4|BIT5|BIT6|BIT7|BIT8|BIT9|BIT10|BIT11)

/**
  Gets all the related EFI_HANDLEs based on the mask supplied.

  This function will scan all EFI_HANDLES in the UEFI environment's handle database
  and return all the ones with the specified relationship (Mask) to the specified
  controller handle.

  If both DriverBindingHandle and ControllerHandle are NULL, then ASSERT.
  If MatchingHandleCount is NULL, then ASSERT.

  If MatchingHandleBuffer is not NULL upon a successful return, the memory must be
  caller freed.

  @param[in] DriverBindingHandle    The handle with Driver Binding protocol on it.
  @param[in] ControllerHandle       The handle with Device Path protocol on it.
  @param[in] Mask                   The mask of what relationship(s) is desired.
  @param[in] MatchingHandleCount    The pointer to UINTN specifying number of HANDLES in
                                    MatchingHandleBuffer.
  @param[out] MatchingHandleBuffer  On a successful return, a buffer of MatchingHandleCount
                                    EFI_HANDLEs with a terminating NULL EFI_HANDLE.

  @retval EFI_SUCCESS               The operation was successful, and any related handles
                                    are in MatchingHandleBuffer.
  @retval EFI_NOT_FOUND             No matching handles were found.
  @retval EFI_INVALID_PARAMETER     A parameter was invalid or out of range.
  @sa ParseHandleDatabaseByRelationshipWithType
**/
EFI_STATUS
EFIAPI
ParseHandleDatabaseByRelationship (
  IN CONST EFI_HANDLE       DriverBindingHandle OPTIONAL,
  IN CONST EFI_HANDLE       ControllerHandle OPTIONAL,
  IN CONST UINTN            Mask,
  IN UINTN                  *MatchingHandleCount,
  OUT EFI_HANDLE            **MatchingHandleBuffer OPTIONAL
  );

/**
  Gets all the related EFI_HANDLEs based on the mask supplied.

  This function scans all EFI_HANDLES in the UEFI environment's handle database
  and returns the ones with the specified relationship (Mask) to the specified
  controller handle.

  If both DriverBindingHandle and ControllerHandle are NULL, then ASSERT.
  If MatchingHandleCount is NULL, then ASSERT.

  If MatchingHandleBuffer is not NULL upon a successful return the memory must be
  caller freed.

  @param[in] DriverBindingHandle    The handle with Driver Binding protocol on it.
  @param[in] ControllerHandle       The handle with Device Path protocol on it.
  @param[in] MatchingHandleCount    The pointer to UINTN that specifies the number of HANDLES in
                                    MatchingHandleBuffer.
  @param[out] MatchingHandleBuffer  On a successful return, a buffer of MatchingHandleCount
                                    EFI_HANDLEs with a terminating NULL EFI_HANDLE.
  @param[out] HandleType            An array of type information.

  @retval EFI_SUCCESS               The operation was successful, and any related handles
                                    are in MatchingHandleBuffer.
  @retval EFI_NOT_FOUND             No matching handles were found.
  @retval EFI_INVALID_PARAMETER     A parameter was invalid or out of range.
**/
EFI_STATUS
EFIAPI
ParseHandleDatabaseByRelationshipWithType (
  IN CONST EFI_HANDLE DriverBindingHandle OPTIONAL,
  IN CONST EFI_HANDLE ControllerHandle OPTIONAL,
  IN UINTN            *HandleCount,
  OUT EFI_HANDLE      **HandleBuffer,
  OUT UINTN           **HandleType
  );

/**
  Gets handles for any parents of the passed in controller.

  @param[in] ControllerHandle       The handle of the controller.
  @param[in] Count                  The pointer to the number of handles in
                                    MatchingHandleBuffer on return.
  @param[out] Buffer                The buffer containing handles on a successful
                                    return.
  @retval EFI_SUCCESS               The operation was successful.
  @sa ParseHandleDatabaseByRelationship
**/
#define PARSE_HANDLE_DATABASE_PARENTS(ControllerHandle, Count, Buffer) \
  ParseHandleDatabaseByRelationship(NULL, ControllerHandle, HR_PARENT_HANDLE, Count, Buffer)

/**
  Gets handles for any UEFI drivers of the passed in controller.

  @param[in] ControllerHandle       The handle of the controller.
  @param[in] Count                  The pointer to the number of handles in
                                    MatchingHandleBuffer on return.
  @param[out] Buffer                The buffer containing handles on a successful
                                    return.
  @retval EFI_SUCCESS               The operation was successful.
  @sa ParseHandleDatabaseByRelationship
**/
#define PARSE_HANDLE_DATABASE_UEFI_DRIVERS(ControllerHandle, Count, Buffer) \
  ParseHandleDatabaseByRelationship(NULL, ControllerHandle, HR_DRIVER_BINDING_HANDLE|HR_DEVICE_DRIVER, Count, Buffer)

/**
  Gets handles for any children of the passed in controller by the passed in driver handle.

  @param[in] DriverHandle           The handle of the driver.
  @param[in] ControllerHandle       The handle of the controller.
  @param[in] Count                  The pointer to the number of handles in
                                    MatchingHandleBuffer on return.
  @param[out] Buffer                The buffer containing handles on a successful
                                    return.
  @retval EFI_SUCCESS               The operation was successful.
  @sa ParseHandleDatabaseByRelationship
**/
#define PARSE_HANDLE_DATABASE_MANAGED_CHILDREN(DriverHandle, ControllerHandle, Count, Buffer) \
  ParseHandleDatabaseByRelationship(DriverHandle, ControllerHandle, HR_CHILD_HANDLE|HR_DEVICE_HANDLE, Count, Buffer)

/**
  Gets handles for any devices managed by the passed in driver.

  @param[in] DriverHandle           The handle of the driver.
  @param[in] Count                  The pointer to the number of handles in
                                    MatchingHandleBuffer on return.
  @param[out] Buffer                The buffer containing handles on a successful
                                    return.
  @retval EFI_SUCCESS               The operation was successful.
  @sa ParseHandleDatabaseByRelationship
**/
#define PARSE_HANDLE_DATABASE_DEVICES(DriverHandle, Count, Buffer) \
  ParseHandleDatabaseByRelationship(DriverHandle, NULL, HR_CONTROLLER_HANDLE|HR_DEVICE_HANDLE, Count, Buffer)

/**
  Gets handles for any child devices produced by the passed in driver.

  @param[in] DriverHandle           The handle of the driver.
  @param[in] MatchingHandleCount    The pointer to the number of handles in
                                    MatchingHandleBuffer on return.
  @param[out] MatchingHandleBuffer  The buffer containing handles on a successful
                                    return.
  @retval EFI_SUCCESS               The operation was successful.
  @sa ParseHandleDatabaseByRelationship
**/
EFI_STATUS
EFIAPI
ParseHandleDatabaseForChildDevices(
  IN CONST EFI_HANDLE       DriverHandle,
  IN UINTN                  *MatchingHandleCount,
  OUT EFI_HANDLE            **MatchingHandleBuffer OPTIONAL
  );

/**
  Gets handles for any child controllers of the passed in controller.

  @param[in] ControllerHandle       The handle of the "parent controller".
  @param[out] MatchingHandleCount   The pointer to the number of handles in
                                    MatchingHandleBuffer on return.
  @param[out] MatchingHandleBuffer  The buffer containing handles on a successful
                                    return.
  @retval EFI_SUCCESS               The operation was successful.
  @sa ParseHandleDatabaseByRelationship
**/
EFI_STATUS
EFIAPI
ParseHandleDatabaseForChildControllers(
  IN CONST EFI_HANDLE       ControllerHandle,
  OUT UINTN                 *MatchingHandleCount,
  OUT EFI_HANDLE            **MatchingHandleBuffer OPTIONAL
  );


/**
  Function to retrieve the human-friendly index of a given handle.  If the handle
  does not have a index one will be automatically assigned.  The index value is valid
  until the termination of the shell application.

  @param[in] TheHandle    The handle to retrieve an index for.

  @retval 0               A memory allocation failed.
  @return                 The index of the handle.

**/
UINTN
EFIAPI
ConvertHandleToHandleIndex(
  IN CONST EFI_HANDLE TheHandle
  );

/**
  Function to retrieve the EFI_HANDLE from the human-friendly index.

  @param[in] TheIndex     The index to retrieve the EFI_HANDLE for.

  @retval NULL            The index was invalid.
  @return                 The EFI_HANDLE that index represents.

**/
EFI_HANDLE
EFIAPI
ConvertHandleIndexToHandle(
  IN CONST UINTN TheIndex
  );

/**
  Function to get all handles that support a given protocol or all handles.

  The caller is responsible to free this memory.

  @param[in] ProtocolGuid The guid of the protocol to get handles for.  If NULL
                          then the function will return all handles.

  @retval NULL            A memory allocation failed.
  @return                 A NULL terminated list of handles.
**/
EFI_HANDLE*
EFIAPI
GetHandleListByProtocol (
  IN CONST EFI_GUID *ProtocolGuid OPTIONAL
  );

/**
  Function to get all handles that support some protocols.

  The caller is responsible to free this memory.

  @param[in] ProtocolGuids  A NULL terminated list of protocol GUIDs.

  @retval NULL              A memory allocation failed.
  @retval NULL              ProtocolGuids was NULL.
  @return                   A NULL terminated list of EFI_HANDLEs.
**/
EFI_HANDLE*
EFIAPI
GetHandleListByProtocolList (
  IN CONST EFI_GUID **ProtocolGuids
  );


/**
  Return all supported GUIDs.

  @param[out]      Guids  The buffer to return all supported GUIDs.
  @param[in, out]  Count  On input, the count of GUIDs the buffer can hold,
                         On output, the count of GUIDs to return.

  @retval EFI_INVALID_PARAMETER Count is NULL.
  @retval EFI_BUFFER_TOO_SMALL  Buffer is not enough to hold all GUIDs.
  @retval EFI_SUCCESS           GUIDs are returned successfully.
**/
EFI_STATUS
EFIAPI
GetAllMappingGuids (
  OUT EFI_GUID *Guids,
  IN OUT UINTN *Count
  );

#endif // __HANDLE_PARSING_LIB__

```

`ShellPkg/Include/Library/ShellCEntryLib.h`:

```h
/** @file
  Provides application point extension for "C" style main function.

  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#ifndef _SHELL_C_ENTRY_LIB_
#define _SHELL_C_ENTRY_LIB_

/**
  UEFI application entry point which has an interface similar to a
  standard C main function.

  The ShellCEntryLib library instance wrappers the actual UEFI application
  entry point and calls this ShellAppMain function.

  @param[in]  Argc  The number of parameters.
  @param[in]  Argv  The array of pointers to parameters.

  @retval  0               The application exited normally.
  @retval  Other           An error occurred.

**/
INTN
EFIAPI
ShellAppMain (
  IN UINTN Argc,
  IN CHAR16 **Argv
  );

#endif


```

`ShellPkg/Include/Library/ShellCommandLib.h`:

```h
/** @file
  Provides interface to shell internal functions for shell commands.

  This library is for use ONLY by shell commands linked into the shell application.
  This library will not function if it is used for UEFI Shell 2.0 Applications.

  Copyright (c) 2009 - 2018, Intel Corporation. All rights reserved.<BR>
  (C) Copyright 2016 Hewlett Packard Enterprise Development LP<BR>
  (C) Copyright 2013-2014 Hewlett-Packard Development Company, L.P.<BR>
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php.

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#ifndef _SHELL_COMMAND_LIB_
#define _SHELL_COMMAND_LIB_

#include <Uefi.h>

#include <Protocol/Shell.h>
#include <Protocol/ShellParameters.h>
#include <Protocol/UnicodeCollation.h>
#include <Protocol/SimpleFileSystem.h>

#include <Library/UefiBootServicesTableLib.h>

//
// The extern global protocol poionters.
//
extern        EFI_UNICODE_COLLATION_PROTOCOL    *gUnicodeCollation;
extern        CONST CHAR16*                     SupportLevel[];

//
// The map list objects.
//
typedef struct {
  LIST_ENTRY                    Link;
  EFI_DEVICE_PATH_PROTOCOL      *DevicePath;
  CHAR16                        *MapName;
  CHAR16                        *CurrentDirectoryPath;
  UINT64                         Flags;
} SHELL_MAP_LIST;
/// List of Mappings - DeviceName and Drive Letter(ism).
extern        SHELL_MAP_LIST                      gShellMapList;
/// Pointer to node of current directory in the mMapList.
extern        SHELL_MAP_LIST                      *gShellCurMapping;

/**
  Returns the help MAN fileName for a given shell command.

  @retval !NULL   The unicode string of the MAN filename.
  @retval NULL    An error ocurred.

**/
typedef
CONST CHAR16 *
(EFIAPI *SHELL_GET_MAN_FILENAME)(
  VOID
  );

/**
  Runs a shell command on a given command line.

  The specific operation of a given shell command is specified in the UEFI Shell
  Specification 2.0, or in the source of the given command.

  Upon completion of the command run the shell protocol and environment variables
  may have been updated due to the operation.

  @param[in] ImageHandle              The ImageHandle to the app, or NULL if
                                      the command built into shell.
  @param[in] SystemTable              The pointer to the system table.

  @retval  RETURN_SUCCESS             The shell command was sucessful.
  @retval  RETURN_UNSUPPORTED         The command is not supported.
**/
typedef
SHELL_STATUS
(EFIAPI *SHELL_RUN_COMMAND)(
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  );

/**
  Registers the handlers of type SHELL_RUN_COMMAND and
  SHELL_GET_MAN_FILENAME for each shell command.

  If the ShellSupportLevel is greater than the value of
  PcdShellSupportLevel, then return RETURN_UNSUPPORTED.

  Registers the the handlers specified by GetHelpInfoHandler and CommandHandler
  with the command specified by CommandString. If the command named by
  CommandString has already been registered, then return
  RETURN_ALREADY_STARTED.

  If there are not enough resources available to register the handlers, then
  RETURN_OUT_OF_RESOURCES is returned.

  If CommandString is NULL, then ASSERT().
  If GetHelpInfoHandler is NULL, then ASSERT().
  If CommandHandler is NULL, then ASSERT().
  If ProfileName is NULL, then ASSERT().

  @param[in]  CommandString         The pointer to the command name.  This is the
                                    name to look for on the command line in
                                    the shell.
  @param[in]  CommandHandler        The pointer to a function that runs the
                                    specified command.
  @param[in]  GetManFileName        The pointer to a function that provides man
                                    filename.
  @param[in]  ShellMinSupportLevel  The minimum Shell Support Level which has this
                                    function.
  @param[in]  ProfileName           The profile name to require for support of this
                                    function.
  @param[in]  CanAffectLE           Indicates whether this command's return value
                                    can change the LASTERROR environment variable.
  @param[in]  HiiHandle             The handle of this command's HII entry.
  @param[in]  ManFormatHelp         The HII locator for the help text.

  @retval  RETURN_SUCCESS           The handlers were registered.
  @retval  RETURN_OUT_OF_RESOURCES  There are not enough resources available to
                                    register the shell command.
  @retval RETURN_UNSUPPORTED        The ShellMinSupportLevel was higher than the
                                    currently allowed support level.
  @retval RETURN_ALREADY_STARTED    The CommandString represents a command that
                                    is already registered.  Only one handler set for
                                    a given command is allowed.
  @sa SHELL_GET_MAN_FILENAME
  @sa SHELL_RUN_COMMAND
**/
RETURN_STATUS
EFIAPI
ShellCommandRegisterCommandName (
  IN CONST  CHAR16                      *CommandString,
  IN        SHELL_RUN_COMMAND           CommandHandler,
  IN        SHELL_GET_MAN_FILENAME      GetManFileName,
  IN        UINT32                      ShellMinSupportLevel,
  IN CONST  CHAR16                      *ProfileName,
  IN CONST  BOOLEAN                     CanAffectLE,
  IN CONST  EFI_HANDLE                  HiiHandle,
  IN CONST  EFI_STRING_ID               ManFormatHelp
  );

/**
  Checks if a command string has been registered for CommandString, and if so, it runs
  the previously registered handler for that command with the command line.

  If CommandString is NULL, then ASSERT().

  If Sections is specified, then each section name listed will be compared in a case sensitive
  manner to the section names described in Appendix B UEFI Shell 2.0 Specification. If the section exists,
  it is appended to the returned help text. If the section does not exist, no
  information is returned. If Sections is NULL, then all help text information
  available is returned.

  @param[in]   CommandString         The pointer to the command name.  This is the name
                                     found on the command line in the shell.
  @param[in, out] RetVal             The pointer to the return value from the command handler.

  @param[in, out]  CanAffectLE       Indicates whether this command's return value
                                     needs to be placed into LASTERROR environment variable.

  @retval RETURN_SUCCESS            The handler was run.
  @retval RETURN_NOT_FOUND          The CommandString did not match a registered
                                    command name.
  @sa SHELL_RUN_COMMAND
**/
RETURN_STATUS
EFIAPI
ShellCommandRunCommandHandler (
  IN CONST CHAR16               *CommandString,
  IN OUT SHELL_STATUS           *RetVal,
  IN OUT BOOLEAN                *CanAffectLE OPTIONAL
  );

/**
  Checks if a command string has been registered for CommandString, and if so, it
  returns the MAN filename specified for that command.

  If CommandString is NULL, then ASSERT().

  @param[in]  CommandString         The pointer to the command name.  This is the name
                                    found on the command line in the shell.

  @retval NULL                      The CommandString was not a registered command.
  @retval other                     The name of the MAN file.
  @sa SHELL_GET_MAN_FILENAME
**/
CONST CHAR16*
EFIAPI
ShellCommandGetManFileNameHandler (
  IN CONST CHAR16               *CommandString
  );


typedef struct {
  LIST_ENTRY  Link;
  CHAR16      *CommandString;
} COMMAND_LIST;

/**
  Get the list of all available shell internal commands.  This is a linked list,
  via the LIST_ENTRY structure.  Enumerate through it using the BaseLib linked
  list functions.  Do not modify the values.

  @param[in] Sort       TRUE to alphabetically sort the values first.  FALSE otherwise.

  @return A linked list of all available shell commands.
**/
CONST COMMAND_LIST*
EFIAPI
ShellCommandGetCommandList (
  IN CONST BOOLEAN Sort
  );

typedef struct {
  LIST_ENTRY  Link;
  CHAR16      *CommandString;
  CHAR16      *Alias;
} ALIAS_LIST;

/**
  Registers aliases to be set as part of the initialization of the shell application.

  If Command is NULL, then ASSERT().
  If Alias is NULL, then ASSERT().

  @param[in]  Command               The pointer to the Command.
  @param[in]  Alias                 The pointer to Alias.

  @retval  RETURN_SUCCESS           The handlers were registered.
  @retval  RETURN_OUT_OF_RESOURCES  There are not enough resources available to
                                    register the shell command.
**/
RETURN_STATUS
EFIAPI
ShellCommandRegisterAlias (
  IN CONST CHAR16                       *Command,
  IN CONST CHAR16                       *Alias
  );

/**
  Get the list of all shell alias commands.  This is a linked list,
  via LIST_ENTRY structure.  Enumerate through it using the BaseLib linked
  list functions.  Do not modify the values.

  @return A linked list of all requested shell aliases.
**/
CONST ALIAS_LIST*
EFIAPI
ShellCommandGetInitAliasList (
  VOID
  );

/**
  Determine if a given alias is on the list of built in aliases.

  @param[in] Alias              The alias to test for.

  @retval TRUE                  The alias is a built in alias.
  @retval FALSE                 The alias is not a built in alias.
**/
BOOLEAN
EFIAPI
ShellCommandIsOnAliasList (
  IN CONST CHAR16 *Alias
  );

/**
  Checks if a command is already on the list.

  @param[in] CommandString        The command string to check for on the list.

  @retval TRUE  CommandString represents a registered command.
  @retval FALSE CommandString does not represent a registered command.
**/
BOOLEAN
EFIAPI
ShellCommandIsCommandOnList (
  IN CONST  CHAR16                      *CommandString
  );

/**
  Get the help text for a command.

  @param[in] CommandString        The command name.

  @retval NULL  No help text was found.
  @return       The string of the help text.  The caller required to free.
**/
CHAR16*
EFIAPI
ShellCommandGetCommandHelp (
  IN CONST  CHAR16                      *CommandString
  );

/**
  Function to make sure that the above pointers are valid.
**/
EFI_STATUS
EFIAPI
CommandInit (
  VOID
  );

/**
  Function to determine current state of ECHO.  Echo determines if lines from scripts
  and ECHO commands are enabled.

  @retval TRUE    Echo is currently enabled.
  @retval FALSE   Echo is currently disabled.
**/
BOOLEAN
EFIAPI
ShellCommandGetEchoState (
  VOID
  );

/**
  Function to set current state of ECHO.  Echo determines if lines from scripts
  and ECHO commands are enabled.

  @param[in] State    TRUE to enable Echo, FALSE otherwise.
**/
VOID
EFIAPI
ShellCommandSetEchoState (
  IN BOOLEAN State
  );



/**
  Indicate that the current shell or script should exit.

  @param[in] ScriptOnly   TRUE if exiting a script; FALSE otherwise.
  @param[in] ErrorCode    The 64 bit error code to return.
**/
VOID
EFIAPI
ShellCommandRegisterExit (
  IN BOOLEAN      ScriptOnly,
  IN CONST UINT64 ErrorCode
  );

/**
  Retrieve the Exit code.

  @return the value passed into RegisterExit.
**/
UINT64
EFIAPI
ShellCommandGetExitCode (
  VOID
  );

/**
  Retrieve the Exit indicator.

  @retval TRUE      Exit was indicated.
  @retval FALSE     Exit was not indicated.
**/
BOOLEAN
EFIAPI
ShellCommandGetExit (
  VOID
  );

/**
  Retrieve the Exit script indicator.

  If ShellCommandGetExit returns FALSE, then the return from this is undefined.

  @retval TRUE      ScriptOnly was indicated.
  @retval FALSE     ScriptOnly was not indicated.
**/
BOOLEAN
EFIAPI
ShellCommandGetScriptExit (
  VOID
  );

typedef struct {
  LIST_ENTRY      Link;     ///< List enumerator items.
  UINTN           Line;     ///< What line of the script file this was on.
  CHAR16          *Cl;      ///< The original command line.
  VOID            *Data;    ///< The data structure format dependant upon Command. (not always used)
  BOOLEAN         Reset;    ///< Reset the command (it must be treated like a initial run (but it may have data already))
} SCRIPT_COMMAND_LIST;

typedef struct {
  CHAR16              *ScriptName;        ///< The filename of this script.
  CHAR16              **Argv;             ///< The parmameters to the script file.
  UINTN               Argc;               ///< The count of parameters.
  LIST_ENTRY          CommandList;        ///< The script converted to a list of commands (SCRIPT_COMMAND_LIST objects).
  SCRIPT_COMMAND_LIST *CurrentCommand;    ///< The command currently being operated.  If !=NULL must be a member of CommandList.
  LIST_ENTRY          SubstList;          ///< A list of current script loop alias' (ALIAS_LIST objects) (Used for the for %-based replacement).
} SCRIPT_FILE;

/**
  Function to return a pointer to the currently running script file object.

  @retval NULL        A script file is not currently running.
  @return             A pointer to the current script file object.
**/
SCRIPT_FILE*
EFIAPI
ShellCommandGetCurrentScriptFile (
  VOID
  );

/**
  Function to set a new script as the currently running one.

  This function will correctly stack and unstack nested scripts.

  @param[in] Script   The pointer to new script information structure.  If NULL,
                      it removes and de-allocates the topmost Script structure.

  @return             A pointer to the current running script file after this
                      change.  It is NULL if removing the final script.
**/
SCRIPT_FILE*
EFIAPI
ShellCommandSetNewScript (
  IN SCRIPT_FILE *Script OPTIONAL
  );

/**
  Function to cleanup all memory from a SCRIPT_FILE structure.

  @param[in] Script     The pointer to the structure to cleanup.
**/
VOID
EFIAPI
DeleteScriptFileStruct (
  IN SCRIPT_FILE *Script
  );

/**
  Function to get the current Profile string.

  This is used to retrieve what profiles were installed.

  @retval NULL  There are no installed profiles.
  @return       A semicolon-delimited list of profiles.
**/
CONST CHAR16 *
EFIAPI
ShellCommandGetProfileList (
  VOID
  );

typedef enum {
  MappingTypeFileSystem,
  MappingTypeBlockIo,
  MappingTypeMax
} SHELL_MAPPING_TYPE;

/**
  Function to generate the next default mapping name.

  If the return value is not NULL then it must be callee freed.

  @param Type                   What kind of mapping name to make.

  @retval NULL                  a memory allocation failed.
  @return a new map name string
**/
CHAR16*
EFIAPI
ShellCommandCreateNewMappingName(
  IN CONST SHELL_MAPPING_TYPE Type
  );

/**
  Function to initialize the table for creating consistent map names.

  @param[out] Table             The pointer to pointer to pointer to DevicePathProtocol object.

  @retval EFI_SUCCESS           The table was created successfully.
**/
EFI_STATUS
EFIAPI
ShellCommandConsistMappingInitialize (
  EFI_DEVICE_PATH_PROTOCOL           ***Table
  );

/**
  Function to uninitialize the table for creating consistent map names.

  The parameter must have been received from ShellCommandConsistMappingInitialize.

  @param[out] Table             The pointer to pointer to DevicePathProtocol object.

  @retval EFI_SUCCESS           The table was deleted successfully.
**/
EFI_STATUS
EFIAPI
ShellCommandConsistMappingUnInitialize (
  EFI_DEVICE_PATH_PROTOCOL      **Table
  );

/**
  Create a consistent mapped name for the device specified by DevicePath
  based on the Table.

  This must be called after ShellCommandConsistMappingInitialize() and
  before ShellCommandConsistMappingUnInitialize() is called.

  @param[in] DevicePath   The pointer to the dev path for the device.
  @param[in] Table        The Table of mapping information.

  @retval NULL            A consistent mapped name could not be created.
  @return                 A pointer to a string allocated from pool with the device name.
**/
CHAR16*
EFIAPI
ShellCommandConsistMappingGenMappingName (
  IN EFI_DEVICE_PATH_PROTOCOL      *DevicePath,
  IN EFI_DEVICE_PATH_PROTOCOL      **Table
  );

/**
  Function to search the list of mappings for the first matching node on the
  list based on the MapKey.

  @param[in] MapKey             The pointer to the string key to search for in the map.

  @return the node on the list.
**/
SHELL_MAP_LIST*
EFIAPI
ShellCommandFindMapItem (
  IN CONST CHAR16               *MapKey
  );

/**
  Function to add a map node to the list of map items and update the "path" environment variable (optionally).

  If Path is TRUE (during initialization only), the path environment variable will also be updated to include
  default paths on the new map name...

  Path should be FALSE when this function is called from the protocol SetMap function.

  @param[in] Name               The human readable mapped name.
  @param[in] DevicePath         The Device Path for this map.
  @param[in] Flags              The Flags attribute for this map item.
  @param[in] Path               TRUE to update path, FALSE to skip this step (should only be TRUE during initialization).

  @retval EFI_SUCCESS           The addition was sucessful.
  @retval EFI_OUT_OF_RESOURCES  A memory allocation failed.
  @retval EFI_INVALID_PARAMETER A parameter was invalid.
**/
EFI_STATUS
EFIAPI
ShellCommandAddMapItemAndUpdatePath(
  IN CONST CHAR16                   *Name,
  IN CONST EFI_DEVICE_PATH_PROTOCOL *DevicePath,
  IN CONST UINT64                   Flags,
  IN CONST BOOLEAN                  Path
  );

/**
  Creates the default map names for each device path in the system with
  a protocol depending on the Type.

  Also sets up the default path environment variable if Type is FileSystem.

  @retval EFI_SUCCESS           All map names were created sucessfully.
  @retval EFI_NOT_FOUND         No protocols were found in the system.
  @return                       Error returned from gBS->LocateHandle().

  @sa LocateHandle
**/
EFI_STATUS
EFIAPI
ShellCommandCreateInitialMappingsAndPaths(
  VOID
  );

/**
  Add mappings for any devices without one.  Do not change any existing maps.

  @retval EFI_SUCCESS   The operation was successful.
**/
EFI_STATUS
EFIAPI
ShellCommandUpdateMapping (
  VOID
  );

/**
  Converts a SHELL_FILE_HANDLE to an EFI_FILE_PROTOCOL*.

  @param[in] Handle     The SHELL_FILE_HANDLE to convert.

  @return a EFI_FILE_PROTOCOL* representing the same file.
**/
EFI_FILE_PROTOCOL*
EFIAPI
ConvertShellHandleToEfiFileProtocol(
  IN CONST SHELL_FILE_HANDLE Handle
  );

/**
  Remove a SHELL_FILE_HANDLE frmo the list of SHELL_FILE_HANDLES.

  @param[in] Handle     The SHELL_FILE_HANDLE to remove.

  @retval TRUE          The item was removed.
  @retval FALSE         The item was not found.
**/
BOOLEAN
EFIAPI
ShellFileHandleRemove(
  IN CONST SHELL_FILE_HANDLE Handle
  );

/**
  Converts a EFI_FILE_PROTOCOL* to an SHELL_FILE_HANDLE.

  @param[in] Handle     The pointer to EFI_FILE_PROTOCOL to convert.
  @param[in] Path       The path to the file for verification.

  @return a SHELL_FILE_HANDLE representing the same file.
**/
SHELL_FILE_HANDLE
EFIAPI
ConvertEfiFileProtocolToShellHandle(
  IN CONST EFI_FILE_PROTOCOL *Handle,
  IN CONST CHAR16            *Path
  );

/**
  Find the path that was logged with the specified SHELL_FILE_HANDLE.

  @param[in] Handle     The SHELL_FILE_HANDLE to query on.

  @return A pointer to the path for the file.
**/
CONST CHAR16*
EFIAPI
ShellFileHandleGetPath(
  IN CONST SHELL_FILE_HANDLE Handle
  );


/**
  Function to determine if a SHELL_FILE_HANDLE is at the end of the file.

  This will NOT work on directories.

  If Handle is NULL, then ASSERT.

  @param[in] Handle     the file handle

  @retval TRUE          the position is at the end of the file
  @retval FALSE         the position is not at the end of the file
**/
BOOLEAN
EFIAPI
ShellFileHandleEof(
  IN SHELL_FILE_HANDLE Handle
  );

typedef struct {
  LIST_ENTRY    Link;
  void          *Buffer;
} BUFFER_LIST;

/**
  Frees any BUFFER_LIST defined type.

  @param[in] List   The pointer to the list head.
**/
VOID
EFIAPI
FreeBufferList (
  IN BUFFER_LIST *List
  );

/**
  Function printing hex output to the console.

  @param[in] Indent       Number of spaces to indent.
  @param[in] Offset       Offset to start with.
  @param[in] DataSize     Length of data.
  @param[in] UserData     Pointer to some data.
**/
VOID
EFIAPI
DumpHex (
  IN UINTN        Indent,
  IN UINTN        Offset,
  IN UINTN        DataSize,
  IN VOID         *UserData
  );

/**
  Dump HEX data into buffer.

  @param[in] Buffer     HEX data to be dumped in Buffer.
  @param[in] Indent     How many spaces to indent the output.
  @param[in] Offset     The offset of the printing.
  @param[in] DataSize   The size in bytes of UserData.
  @param[in] UserData   The data to print out.
**/
CHAR16*
EFIAPI
CatSDumpHex (
  IN CHAR16  *Buffer,
  IN UINTN   Indent,
  IN UINTN   Offset,
  IN UINTN   DataSize,
  IN VOID    *UserData
  );
#endif //_SHELL_COMMAND_LIB_

```

`ShellPkg/Include/Library/ShellLib.h`:

```h
/** @file
  Provides interface to shell functionality for shell commands and applications.

  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
  Copyright 2018 Dell Technologies.<BR>
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#ifndef __SHELL_LIB__
#define __SHELL_LIB__

#include <Uefi.h>
#include <Guid/FileInfo.h>
#include <Protocol/SimpleFileSystem.h>
#include <Protocol/LoadedImage.h>
#include <Protocol/EfiShellInterface.h>
#include <Protocol/EfiShellEnvironment2.h>
#include <Protocol/Shell.h>
#include <Protocol/ShellParameters.h>

#define SHELL_FREE_NON_NULL(Pointer)  \
  do {                                \
    if ((Pointer) != NULL) {          \
      FreePool((Pointer));            \
      (Pointer) = NULL;               \
    }                                 \
  } while(FALSE)

extern EFI_SHELL_PARAMETERS_PROTOCOL *gEfiShellParametersProtocol;
extern EFI_SHELL_PROTOCOL            *gEfiShellProtocol;

/**
  Return a clean, fully-qualified version of an input path.  If the return value
  is non-NULL the caller must free the memory when it is no longer needed.

  If asserts are disabled, and if the input parameter is NULL, NULL is returned.

  If there is not enough memory available to create the fully-qualified path or
  a copy of the input path, NULL is returned.

  If there is no working directory, a clean copy of Path is returned.

  Otherwise, the current file system or working directory (as appropriate) is
  prepended to Path and the resulting path is cleaned and returned.

  NOTE: If the input path is an empty string, then the current working directory
  (if it exists) is returned.  In other words, an empty input path is treated
  exactly the same as ".".

  @param[in] Path  A pointer to some file or directory path.

  @retval NULL          The input path is NULL or out of memory.

  @retval non-NULL      A pointer to a clean, fully-qualified version of Path.
                        If there is no working directory, then a pointer to a
                        clean, but not necessarily fully-qualified version of
                        Path.  The caller must free this memory when it is no
                        longer needed.
**/
CHAR16*
EFIAPI
FullyQualifyPath(
  IN     CONST CHAR16     *Path
  );

/**
  This function will retrieve the information about the file for the handle
  specified and store it in allocated pool memory.

  This function allocates a buffer to store the file's information. It is the
  caller's responsibility to free the buffer.

  @param[in] FileHandle         The file handle of the file for which information is
                                being requested.

  @retval NULL                  Information could not be retrieved.

  @return                       The information about the file.
**/
EFI_FILE_INFO*
EFIAPI
ShellGetFileInfo (
  IN SHELL_FILE_HANDLE          FileHandle
  );

/**
  This function sets the information about the file for the opened handle
  specified.

  @param[in]  FileHandle        The file handle of the file for which information
                                is being set.

  @param[in]  FileInfo          The information to set.

  @retval EFI_SUCCESS           The information was set.
  @retval EFI_INVALID_PARAMETER A parameter was out of range or invalid.
  @retval EFI_UNSUPPORTED       The FileHandle does not support FileInfo.
  @retval EFI_NO_MEDIA          The device has no medium.
  @retval EFI_DEVICE_ERROR      The device reported an error.
  @retval EFI_VOLUME_CORRUPTED  The file system structures are corrupted.
  @retval EFI_WRITE_PROTECTED   The file or medium is write protected.
  @retval EFI_ACCESS_DENIED     The file was opened read only.
  @retval EFI_VOLUME_FULL       The volume is full.
**/
EFI_STATUS
EFIAPI
ShellSetFileInfo (
  IN SHELL_FILE_HANDLE          FileHandle,
  IN EFI_FILE_INFO              *FileInfo
  );

/**
  This function will open a file or directory referenced by DevicePath.

  This function opens a file with the open mode according to the file path. The
  Attributes is valid only for EFI_FILE_MODE_CREATE.

  @param[in, out]  FilePath      On input, the device path to the file.  On output,
                                 the remaining device path.
  @param[out]   FileHandle       Pointer to the file handle.
  @param[in]    OpenMode         The mode to open the file with.
  @param[in]    Attributes       The file's file attributes.

  @retval EFI_SUCCESS         The information was set.
  @retval EFI_INVALID_PARAMETER One of the parameters has an invalid value.
  @retval EFI_UNSUPPORTED       Could not open the file path.
  @retval EFI_NOT_FOUND         The specified file could not be found on the
                                device or the file system could not be found on
                                the device.
  @retval EFI_NO_MEDIA          The device has no medium.
  @retval EFI_MEDIA_CHANGED     The device has a different medium in it or the
                                medium is no longer supported.
  @retval EFI_DEVICE_ERROR      The device reported an error.
  @retval EFI_VOLUME_CORRUPTED  The file system structures are corrupted.
  @retval EFI_WRITE_PROTECTED   The file or medium is write protected.
  @retval EFI_ACCESS_DENIED     The file was opened read only.
  @retval EFI_OUT_OF_RESOURCES  Not enough resources were available to open the
                                file.
  @retval EFI_VOLUME_FULL       The volume is full.
**/
EFI_STATUS
EFIAPI
ShellOpenFileByDevicePath(
  IN OUT EFI_DEVICE_PATH_PROTOCOL     **FilePath,
  OUT SHELL_FILE_HANDLE               *FileHandle,
  IN UINT64                           OpenMode,
  IN UINT64                           Attributes
  );

/**
  This function will open a file or directory referenced by filename.

  If return is EFI_SUCCESS, the Filehandle is the opened file's handle;
  otherwise, the Filehandle is NULL. Attributes is valid only for
  EFI_FILE_MODE_CREATE.

  @param[in] FileName           The pointer to file name.
  @param[out] FileHandle        The pointer to the file handle.
  @param[in] OpenMode           The mode to open the file with.
  @param[in] Attributes         The file's file attributes.

  @retval EFI_SUCCESS         The information was set.
  @retval EFI_INVALID_PARAMETER One of the parameters has an invalid value.
  @retval EFI_UNSUPPORTED       Could not open the file path.
  @retval EFI_NOT_FOUND         The specified file could not be found on the
                                device or the file system could not be found
                                on the device.
  @retval EFI_NO_MEDIA          The device has no medium.
  @retval EFI_MEDIA_CHANGED     The device has a different medium in it or the
                                medium is no longer supported.
  @retval EFI_DEVICE_ERROR      The device reported an error.
  @retval EFI_VOLUME_CORRUPTED  The file system structures are corrupted.
  @retval EFI_WRITE_PROTECTED   The file or medium is write protected.
  @retval EFI_ACCESS_DENIED     The file was opened read only.
  @retval EFI_OUT_OF_RESOURCES  Not enough resources were available to open the
                                file.
  @retval EFI_VOLUME_FULL       The volume is full.
**/
EFI_STATUS
EFIAPI
ShellOpenFileByName(
  IN CONST CHAR16               *FileName,
  OUT SHELL_FILE_HANDLE         *FileHandle,
  IN UINT64                     OpenMode,
  IN UINT64                     Attributes
  );

/**
  This function creates a directory.

  If return is EFI_SUCCESS, the Filehandle is the opened directory's handle;
  otherwise, the Filehandle is NULL. If the directory already existed, this
  function opens the existing directory.

  @param[in]  DirectoryName     The pointer to Directory name.
  @param[out] FileHandle        The pointer to the file handle.

  @retval EFI_SUCCESS         The information was set.
  @retval EFI_INVALID_PARAMETER One of the parameters has an invalid value.
  @retval EFI_UNSUPPORTED       Could not open the file path.
  @retval EFI_NOT_FOUND         The specified file could not be found on the
                                device, or the file system could not be found
                                on the device.
  @retval EFI_NO_MEDIA          The device has no medium.
  @retval EFI_MEDIA_CHANGED     The device has a different medium in it or the
                                medium is no longer supported.
  @retval EFI_DEVICE_ERROR      The device reported an error.
  @retval EFI_VOLUME_CORRUPTED  The file system structures are corrupted.
  @retval EFI_WRITE_PROTECTED   The file or medium is write protected.
  @retval EFI_ACCESS_DENIED     The file was opened read only.
  @retval EFI_OUT_OF_RESOURCES  Not enough resources were available to open the
                                file.
  @retval EFI_VOLUME_FULL       The volume is full.
**/
EFI_STATUS
EFIAPI
ShellCreateDirectory(
  IN CONST CHAR16             *DirectoryName,
  OUT SHELL_FILE_HANDLE       *FileHandle
  );

/**
  This function reads information from an opened file.

  If FileHandle is not a directory, the function reads the requested number of
  bytes from the file at the file's current position and returns them in Buffer.
  If the read goes beyond the end of the file, the read length is truncated to the
  end of the file. The file's current position is increased by the number of bytes
  returned.  If FileHandle is a directory, the function reads the directory entry
  at the file's current position and returns the entry in Buffer. If the Buffer
  is not large enough to hold the current directory entry, then
  EFI_BUFFER_TOO_SMALL is returned and the current file position is not updated.
  BufferSize is set to be the size of the buffer needed to read the entry. On
  success, the current position is updated to the next directory entry. If there
  are no more directory entries, the read returns a zero-length buffer.
  EFI_FILE_INFO is the structure returned as the directory entry.

  @param[in] FileHandle          The opened file handle.
  @param[in, out] ReadSize       On input the size of buffer in bytes.  On return
                                 the number of bytes written.
  @param[out] Buffer             The buffer to put read data into.

  @retval EFI_SUCCESS           Data was read.
  @retval EFI_NO_MEDIA          The device has no media.
  @retval EFI_DEVICE_ERROR      The device reported an error.
  @retval EFI_VOLUME_CORRUPTED  The file system structures are corrupted.
  @retval EFI_BUFFER_TO_SMALL   Buffer is too small. ReadSize contains required
                                size.

**/
EFI_STATUS
EFIAPI
ShellReadFile(
  IN SHELL_FILE_HANDLE          FileHandle,
  IN OUT UINTN                  *ReadSize,
  OUT VOID                      *Buffer
  );

/**
  Write data to a file.

  This function writes the specified number of bytes to the file at the current
  file position. The current file position is advanced the actual number of bytes
  written, which is returned in BufferSize. Partial writes only occur when there
  has been a data error during the write attempt (such as "volume space full").
  The file is automatically grown to hold the data if required. Direct writes to
  opened directories are not supported.

  @param[in] FileHandle          The opened file for writing.

  @param[in, out] BufferSize     On input the number of bytes in Buffer.  On output
                                 the number of bytes written.

  @param[in] Buffer              The buffer containing data to write is stored.

  @retval EFI_SUCCESS           Data was written.
  @retval EFI_UNSUPPORTED       Writes to an open directory are not supported.
  @retval EFI_NO_MEDIA          The device has no media.
  @retval EFI_DEVICE_ERROR      The device reported an error.
  @retval EFI_VOLUME_CORRUPTED  The file system structures are corrupted.
  @retval EFI_WRITE_PROTECTED   The device is write-protected.
  @retval EFI_ACCESS_DENIED     The file was open for read only.
  @retval EFI_VOLUME_FULL       The volume is full.
**/
EFI_STATUS
EFIAPI
ShellWriteFile(
  IN SHELL_FILE_HANDLE          FileHandle,
  IN OUT UINTN                  *BufferSize,
  IN VOID                       *Buffer
  );

/**
  Close an open file handle.

  This function closes a specified file handle. All "dirty" cached file data is
  flushed to the device, and the file is closed. In all cases the handle is
  closed.

  @param[in] FileHandle           The file handle to close.

  @retval EFI_SUCCESS             The file handle was closed sucessfully.
  @retval INVALID_PARAMETER       One of the parameters has an invalid value.
**/
EFI_STATUS
EFIAPI
ShellCloseFile (
  IN SHELL_FILE_HANDLE          *FileHandle
  );

/**
  Delete a file and close the handle

  This function closes and deletes a file. In all cases the file handle is closed.
  If the file cannot be deleted, the warning code EFI_WARN_DELETE_FAILURE is
  returned, but the handle is still closed.

  @param[in] FileHandle             The file handle to delete.

  @retval EFI_SUCCESS               The file was closed sucessfully.
  @retval EFI_WARN_DELETE_FAILURE   The handle was closed, but the file was not
                                    deleted.
  @retval INVALID_PARAMETER         One of the parameters has an invalid value.
**/
EFI_STATUS
EFIAPI
ShellDeleteFile (
  IN SHELL_FILE_HANDLE          *FileHandle
  );

/**
  Set the current position in a file.

  This function sets the current file position for the handle to the position
  supplied. With the exception of seeking to position 0xFFFFFFFFFFFFFFFF, only
  absolute positioning is supported, and moving past the end of the file is
  allowed (a subsequent write would grow the file). Moving to position
  0xFFFFFFFFFFFFFFFF causes the current position to be set to the end of the file.
  If FileHandle is a directory, the only position that may be set is zero. This
  has the effect of starting the read process of the directory entries over.

  @param[in] FileHandle         The file handle on which the position is being set.

  @param[in] Position           The byte position from the begining of the file.

  @retval EFI_SUCCESS           Operation completed sucessfully.
  @retval EFI_UNSUPPORTED       The seek request for non-zero is not valid on
                                directories.
  @retval INVALID_PARAMETER     One of the parameters has an invalid value.
**/
EFI_STATUS
EFIAPI
ShellSetFilePosition (
  IN SHELL_FILE_HANDLE  FileHandle,
  IN UINT64             Position
  );

/**
  Gets a file's current position

  This function retrieves the current file position for the file handle. For
  directories, the current file position has no meaning outside of the file
  system driver and as such the operation is not supported. An error is returned
  if FileHandle is a directory.

  @param[in] FileHandle         The open file handle on which to get the position.
  @param[out] Position          The byte position from the begining of the file.

  @retval EFI_SUCCESS           The operation completed sucessfully.
  @retval INVALID_PARAMETER     One of the parameters has an invalid value.
  @retval EFI_UNSUPPORTED       The request is not valid on directories.
**/
EFI_STATUS
EFIAPI
ShellGetFilePosition (
  IN SHELL_FILE_HANDLE          FileHandle,
  OUT UINT64                    *Position
  );

/**
  Flushes data on a file

  This function flushes all modified data associated with a file to a device.

  @param[in] FileHandle         The file handle on which to flush data.

  @retval EFI_SUCCESS           The data was flushed.
  @retval EFI_NO_MEDIA          The device has no media.
  @retval EFI_DEVICE_ERROR      The device reported an error.
  @retval EFI_VOLUME_CORRUPTED  The file system structures are corrupted.
  @retval EFI_WRITE_PROTECTED   The file or medium is write protected.
  @retval EFI_ACCESS_DENIED     The file was opened for read only.
**/
EFI_STATUS
EFIAPI
ShellFlushFile (
  IN SHELL_FILE_HANDLE          FileHandle
  );

/** Retrieve first entry from a directory.

  This function takes an open directory handle and gets information from the
  first entry in the directory.  A buffer is allocated to contain
  the information and a pointer to the buffer is returned in *Buffer.  The
  caller can use ShellFindNextFile() to get subsequent directory entries.

  The buffer will be freed by ShellFindNextFile() when the last directory
  entry is read.  Otherwise, the caller must free the buffer, using FreePool,
  when finished with it.

  @param[in]  DirHandle         The file handle of the directory to search.
  @param[out] Buffer            The pointer to the buffer for the file's information.

  @retval EFI_SUCCESS           Found the first file.
  @retval EFI_NOT_FOUND         Cannot find the directory.
  @retval EFI_NO_MEDIA          The device has no media.
  @retval EFI_DEVICE_ERROR      The device reported an error.
  @retval EFI_VOLUME_CORRUPTED  The file system structures are corrupted.
  @return Others                Status of ShellGetFileInfo, ShellSetFilePosition,
                                or ShellReadFile.

  @sa ShellReadFile
**/
EFI_STATUS
EFIAPI
ShellFindFirstFile (
  IN      SHELL_FILE_HANDLE       DirHandle,
     OUT  EFI_FILE_INFO         **Buffer
  );

/** Retrieve next entries from a directory.

  To use this function, the caller must first call the ShellFindFirstFile()
  function to get the first directory entry.  Subsequent directory entries are
  retrieved by using the ShellFindNextFile() function.  This function can
  be called several times to get each entry from the directory.  If the call of
  ShellFindNextFile() retrieved the last directory entry, the next call of
  this function will set *NoFile to TRUE and free the buffer.

  @param[in]  DirHandle         The file handle of the directory.
  @param[in, out] Buffer        The pointer to buffer for file's information.
  @param[in, out] NoFile        The pointer to boolean when last file is found.

  @retval EFI_SUCCESS           Found the next file.
  @retval EFI_NO_MEDIA          The device has no media.
  @retval EFI_DEVICE_ERROR      The device reported an error.
  @retval EFI_VOLUME_CORRUPTED  The file system structures are corrupted.

  @sa ShellReadFile
**/
EFI_STATUS
EFIAPI
ShellFindNextFile(
  IN      SHELL_FILE_HANDLE       DirHandle,
  IN OUT  EFI_FILE_INFO          *Buffer,
  IN OUT  BOOLEAN                *NoFile
  );

/**
  Retrieve the size of a file.

  This function extracts the file size info from the FileHandle's EFI_FILE_INFO
  data.

  @param[in] FileHandle         The file handle from which size is retrieved.
  @param[out] Size              The pointer to size.

  @retval EFI_SUCCESS           The operation was completed sucessfully.
  @retval EFI_DEVICE_ERROR      Cannot access the file.
**/
EFI_STATUS
EFIAPI
ShellGetFileSize (
  IN SHELL_FILE_HANDLE          FileHandle,
  OUT UINT64                    *Size
  );

/**
  Retrieves the status of the break execution flag

  This function is useful to check whether the application is being asked to halt by the shell.

  @retval TRUE                  The execution break is enabled.
  @retval FALSE                 The execution break is not enabled.
**/
BOOLEAN
EFIAPI
ShellGetExecutionBreakFlag(
  VOID
  );

/**
  Return the value of an environment variable.

  This function gets the value of the environment variable set by the
  ShellSetEnvironmentVariable function.

  @param[in] EnvKey             The key name of the environment variable.

  @retval NULL                  The named environment variable does not exist.
  @return != NULL               The pointer to the value of the environment variable.
**/
CONST CHAR16*
EFIAPI
ShellGetEnvironmentVariable (
  IN CONST CHAR16                *EnvKey
  );

/**
  Set the value of an environment variable.

  This function changes the current value of the specified environment variable. If the
  environment variable exists and the Value is an empty string, then the environment
  variable is deleted. If the environment variable exists and the Value is not an empty
  string, then the value of the environment variable is changed. If the environment
  variable does not exist and the Value is an empty string, there is no action. If the
  environment variable does not exist and the Value is a non-empty string, then the
  environment variable is created and assigned the specified value.

  This is not supported pre-UEFI Shell 2.0.

  @param[in] EnvKey             The key name of the environment variable.
  @param[in] EnvVal             The Value of the environment variable
  @param[in] Volatile           Indicates whether the variable is non-volatile (FALSE) or volatile (TRUE).

  @retval EFI_SUCCESS           The operation completed sucessfully
  @retval EFI_UNSUPPORTED       This operation is not allowed in pre-UEFI 2.0 Shell environments.
**/
EFI_STATUS
EFIAPI
ShellSetEnvironmentVariable (
  IN CONST CHAR16               *EnvKey,
  IN CONST CHAR16               *EnvVal,
  IN BOOLEAN                    Volatile
  );

/**
  Cause the shell to parse and execute a command line.

  This function creates a nested instance of the shell and executes the specified
  command (CommandLine) with the specified environment (Environment). Upon return,
  the status code returned by the specified command is placed in StatusCode.
  If Environment is NULL, then the current environment is used and all changes made
  by the commands executed will be reflected in the current environment. If the
  Environment is non-NULL, then the changes made will be discarded.
  The CommandLine is executed from the current working directory on the current
  device.

  The EnvironmentVariables and Status parameters are ignored in a pre-UEFI Shell 2.0
  environment.  The values pointed to by the parameters will be unchanged by the
  ShellExecute() function.  The Output parameter has no effect in a
  UEFI Shell 2.0 environment.

  @param[in] ParentHandle         The parent image starting the operation.
  @param[in] CommandLine          The pointer to a NULL terminated command line.
  @param[in] Output               True to display debug output.  False to hide it.
  @param[in] EnvironmentVariables Optional pointer to array of environment variables
                                  in the form "x=y".  If NULL, the current set is used.
  @param[out] Status              The status of the run command line.

  @retval EFI_SUCCESS             The operation completed sucessfully.  Status
                                  contains the status code returned.
  @retval EFI_INVALID_PARAMETER   A parameter contains an invalid value.
  @retval EFI_OUT_OF_RESOURCES    Out of resources.
  @retval EFI_UNSUPPORTED         The operation is not allowed.
**/
EFI_STATUS
EFIAPI
ShellExecute (
  IN EFI_HANDLE                 *ParentHandle,
  IN CHAR16                     *CommandLine,
  IN BOOLEAN                    Output,
  IN CHAR16                     **EnvironmentVariables,
  OUT EFI_STATUS                *Status
  );

/**
  Retreives the current directory path.

  If the DeviceName is NULL, it returns the current device's current directory
  name. If the DeviceName is not NULL, it returns the current directory name
  on specified drive.

  Note that the current directory string should exclude the tailing backslash character.

  @param[in] DeviceName         The name of the file system to get directory on.

  @retval NULL                  The directory does not exist.
  @retval != NULL               The directory.
**/
CONST CHAR16*
EFIAPI
ShellGetCurrentDir (
  IN CHAR16                     * CONST DeviceName OPTIONAL
  );

/**
  Sets (enabled or disabled) the page break mode.

  When page break mode is enabled the screen will stop scrolling
  and wait for operator input before scrolling a subsequent screen.

  @param[in] CurrentState       TRUE to enable and FALSE to disable.
**/
VOID
EFIAPI
ShellSetPageBreakMode (
  IN BOOLEAN                    CurrentState
  );

/**
  Opens a group of files based on a path.

  This function uses the Arg to open all the matching files. Each matched
  file has a SHELL_FILE_ARG structure to record the file information. These
  structures are placed on the list ListHead. Users can get the SHELL_FILE_ARG
  structures from ListHead to access each file. This function supports wildcards
  and will process '?' and '*' as such.  The list must be freed with a call to
  ShellCloseFileMetaArg().

  If you are NOT appending to an existing list *ListHead must be NULL.  If
  *ListHead is NULL then it must be callee freed.

  @param[in] Arg                 The pointer to path string.
  @param[in] OpenMode            Mode to open files with.
  @param[in, out] ListHead       Head of linked list of results.

  @retval EFI_SUCCESS           The operation was sucessful and the list head
                                contains the list of opened files.
  @retval != EFI_SUCCESS        The operation failed.

  @sa InternalShellConvertFileListType
**/
EFI_STATUS
EFIAPI
ShellOpenFileMetaArg (
  IN CHAR16                     *Arg,
  IN UINT64                     OpenMode,
  IN OUT EFI_SHELL_FILE_INFO    **ListHead
  );

/**
  Free the linked list returned from ShellOpenFileMetaArg.

  @param[in, out] ListHead       The pointer to free.

  @retval EFI_SUCCESS           The operation was sucessful.
  @retval EFI_INVALID_PARAMETER A parameter was invalid.
**/
EFI_STATUS
EFIAPI
ShellCloseFileMetaArg (
  IN OUT EFI_SHELL_FILE_INFO    **ListHead
  );

/**
  Find a file by searching the CWD and then the path.

  If FileName is NULL, then ASSERT.

  If the return value is not NULL then the memory must be caller freed.

  @param[in] FileName           Filename string.

  @retval NULL                  The file was not found.
  @retval !NULL                 The path to the file.
**/
CHAR16 *
EFIAPI
ShellFindFilePath (
  IN CONST CHAR16 *FileName
  );

/**
  Find a file by searching the CWD and then the path with a variable set of file
  extensions.  If the file is not found it will append each extension in the list
  in the order provided and return the first one that is successful.

  If FileName is NULL, then ASSERT.
  If FileExtension is NULL, then the behavior is identical to ShellFindFilePath.

  If the return value is not NULL then the memory must be caller freed.

  @param[in] FileName           The filename string.
  @param[in] FileExtension      Semicolon delimited list of possible extensions.

  @retval NULL                  The file was not found.
  @retval !NULL                 The path to the file.
**/
CHAR16 *
EFIAPI
ShellFindFilePathEx (
  IN CONST CHAR16 *FileName,
  IN CONST CHAR16 *FileExtension
  );

typedef enum {
  TypeFlag  = 0,    ///< A flag that is present or not present only (IE "-a").
  TypeValue,        ///< A flag that has some data following it with a space (IE "-a 1").
  TypePosition,     ///< Some data that did not follow a parameter (IE "filename.txt").
  TypeStart,        ///< A flag that has variable value appended to the end (IE "-ad", "-afd", "-adf", etc...).
  TypeDoubleValue,  ///< A flag that has 2 space seperated value data following it (IE "-a 1 2").
  TypeMaxValue,     ///< A flag followed by all the command line data before the next flag.
  TypeTimeValue,    ///< A flag that has a time value following it (IE "-a -5:00").
  TypeMax,
} SHELL_PARAM_TYPE;

typedef struct {
  CHAR16             *Name;
  SHELL_PARAM_TYPE   Type;
} SHELL_PARAM_ITEM;


/// Helper structure for no parameters (besides -? and -b)
extern SHELL_PARAM_ITEM EmptyParamList[];

/// Helper structure for -sfo only (besides -? and -b)
extern SHELL_PARAM_ITEM SfoParamList[];

/**
  Checks the command line arguments passed against the list of valid ones.
  Optionally removes NULL values first.

  If no initialization is required, then return RETURN_SUCCESS.

  @param[in] CheckList          The pointer to list of parameters to check.
  @param[out] CheckPackage      The package of checked values.
  @param[out] ProblemParam      Optional pointer to pointer to unicode string for
                                the paramater that caused failure.
  @param[in] AutoPageBreak      Will automatically set PageBreakEnabled.
  @param[in] AlwaysAllowNumbers Will never fail for number based flags.

  @retval EFI_SUCCESS           The operation completed sucessfully.
  @retval EFI_OUT_OF_RESOURCES  A memory allocation failed.
  @retval EFI_INVALID_PARAMETER A parameter was invalid.
  @retval EFI_VOLUME_CORRUPTED  The command line was corrupt.
  @retval EFI_DEVICE_ERROR      The commands contained 2 opposing arguments.  One
                                of the command line arguments was returned in
                                ProblemParam if provided.
  @retval EFI_NOT_FOUND         A argument required a value that was missing.
                                The invalid command line argument was returned in
                                ProblemParam if provided.
**/
EFI_STATUS
EFIAPI
ShellCommandLineParseEx (
  IN CONST SHELL_PARAM_ITEM     *CheckList,
  OUT LIST_ENTRY                **CheckPackage,
  OUT CHAR16                    **ProblemParam OPTIONAL,
  IN BOOLEAN                    AutoPageBreak,
  IN BOOLEAN                    AlwaysAllowNumbers
  );

/// Make it easy to upgrade from older versions of the shell library.
#define ShellCommandLineParse(CheckList,CheckPackage,ProblemParam,AutoPageBreak) ShellCommandLineParseEx(CheckList,CheckPackage,ProblemParam,AutoPageBreak,FALSE)

/**
  Frees shell variable list that was returned from ShellCommandLineParse.

  This function will free all the memory that was used for the CheckPackage
  list of postprocessed shell arguments.

  If CheckPackage is NULL, then return.

  @param[in] CheckPackage       The list to de-allocate.
  **/
VOID
EFIAPI
ShellCommandLineFreeVarList (
  IN LIST_ENTRY                 *CheckPackage
  );

/**
  Checks for presence of a flag parameter.

  Flag arguments are in the form of "-<Key>" or "/<Key>", but do not have a value following the key.

  If CheckPackage is NULL then return FALSE.
  If KeyString is NULL then ASSERT().

  @param[in] CheckPackage       The package of parsed command line arguments.
  @param[in] KeyString          The Key of the command line argument to check for.

  @retval TRUE                  The flag is on the command line.
  @retval FALSE                 The flag is not on the command line.
**/
BOOLEAN
EFIAPI
ShellCommandLineGetFlag (
  IN CONST LIST_ENTRY         * CONST CheckPackage,
  IN CONST CHAR16             * CONST KeyString
  );

/**
  Returns value from command line argument.

  Value parameters are in the form of "-<Key> value" or "/<Key> value".

  If CheckPackage is NULL, then return NULL.

  @param[in] CheckPackage       The package of parsed command line arguments.
  @param[in] KeyString          The Key of the command line argument to check for.

  @retval NULL                  The flag is not on the command line.
  @retval !=NULL                The pointer to unicode string of the value.
**/
CONST CHAR16*
EFIAPI
ShellCommandLineGetValue (
  IN CONST LIST_ENTRY              *CheckPackage,
  IN CHAR16                        *KeyString
  );

/**
  Returns raw value from command line argument.

  Raw value parameters are in the form of "value" in a specific position in the list.

  If CheckPackage is NULL, then return NULL.

  @param[in] CheckPackage       The package of parsed command line arguments.
  @param[in] Position           The position of the value.

  @retval NULL                  The flag is not on the command line.
  @retval !=NULL                The pointer to unicode string of the value.
**/
CONST CHAR16*
EFIAPI
ShellCommandLineGetRawValue (
  IN CONST LIST_ENTRY              * CONST CheckPackage,
  IN UINTN                         Position
  );

/**
  Returns the number of command line value parameters that were parsed.

  This will not include flags.

  @param[in] CheckPackage       The package of parsed command line arguments.

  @retval (UINTN)-1             No parsing has occurred.
  @retval other                 The number of value parameters found.
**/
UINTN
EFIAPI
ShellCommandLineGetCount(
  IN CONST LIST_ENTRY              *CheckPackage
  );

/**
  Determines if a parameter is duplicated.

  If Param is not NULL, then it will point to a callee-allocated string buffer
  with the parameter value, if a duplicate is found.

  If CheckPackage is NULL, then ASSERT.

  @param[in] CheckPackage       The package of parsed command line arguments.
  @param[out] Param             Upon finding one, a pointer to the duplicated parameter.

  @retval EFI_SUCCESS           No parameters were duplicated.
  @retval EFI_DEVICE_ERROR      A duplicate was found.
  **/
EFI_STATUS
EFIAPI
ShellCommandLineCheckDuplicate (
  IN CONST LIST_ENTRY              *CheckPackage,
  OUT CHAR16                       **Param
  );

/**
  This function causes the shell library to initialize itself.  If the shell library
  is already initialized it will de-initialize all the current protocol pointers and
  re-populate them again.

  When the library is used with PcdShellLibAutoInitialize set to true this function
  will return EFI_SUCCESS and perform no actions.

  This function is intended for internal access for shell commands only.

  @retval EFI_SUCCESS   The initialization was complete sucessfully.

**/
EFI_STATUS
EFIAPI
ShellInitialize (
  VOID
  );

/**
  Print at a specific location on the screen.

  This function will move the cursor to a given screen location and print the specified string.

  If -1 is specified for either the Row or Col the current screen location for BOTH
  will be used.

  If either Row or Col is out of range for the current console, then ASSERT.
  If Format is NULL, then ASSERT.

  In addition to the standard %-based flags as supported by UefiLib Print() this supports
  the following additional flags:
    %N       -   Set output attribute to normal
    %H       -   Set output attribute to highlight
    %E       -   Set output attribute to error
    %B       -   Set output attribute to blue color
    %V       -   Set output attribute to green color

  Note: The background color is controlled by the shell command cls.

  @param[in] Col        The column to print at.
  @param[in] Row        The row to print at.
  @param[in] Format     The format string.
  @param[in] ...        The variable argument list.

  @return EFI_SUCCESS           The printing was successful.
  @return EFI_DEVICE_ERROR      The console device reported an error.
**/
EFI_STATUS
EFIAPI
ShellPrintEx(
  IN INT32                Col OPTIONAL,
  IN INT32                Row OPTIONAL,
  IN CONST CHAR16         *Format,
  ...
  );

/**
  Print at a specific location on the screen.

  This function will move the cursor to a given screen location and print the specified string.

  If -1 is specified for either the Row or Col the current screen location for BOTH
  will be used.

  If either Row or Col is out of range for the current console, then ASSERT.
  If Format is NULL, then ASSERT.

  In addition to the standard %-based flags as supported by UefiLib Print() this supports
  the following additional flags:
    %N       -   Set output attribute to normal.
    %H       -   Set output attribute to highlight.
    %E       -   Set output attribute to error.
    %B       -   Set output attribute to blue color.
    %V       -   Set output attribute to green color.

  Note: The background color is controlled by the shell command cls.

  @param[in] Col                The column to print at.
  @param[in] Row                The row to print at.
  @param[in] Language           The language of the string to retrieve.  If this parameter
                                is NULL, then the current platform language is used.
  @param[in] HiiFormatStringId  The format string Id for getting from Hii.
  @param[in] HiiFormatHandle    The format string Handle for getting from Hii.
  @param[in] ...                The variable argument list.

  @return EFI_SUCCESS           The printing was successful.
  @return EFI_DEVICE_ERROR      The console device reported an error.
**/
EFI_STATUS
EFIAPI
ShellPrintHiiEx(
  IN INT32                Col OPTIONAL,
  IN INT32                Row OPTIONAL,
  IN CONST CHAR8          *Language OPTIONAL,
  IN CONST EFI_STRING_ID  HiiFormatStringId,
  IN CONST EFI_HANDLE     HiiFormatHandle,
  ...
  );

/**
  Function to determine if a given filename represents a directory.

  If DirName is NULL, then ASSERT.

  @param[in] DirName      Path to directory to test.

  @retval EFI_SUCCESS     The Path represents a directory.
  @retval EFI_NOT_FOUND   The Path does not represent a directory.
  @retval other           The path failed to open.
**/
EFI_STATUS
EFIAPI
ShellIsDirectory(
  IN CONST CHAR16 *DirName
  );

/**
  Function to determine if a given filename represents a file.

  This will search the CWD only.

  If Name is NULL, then ASSERT.

  @param[in] Name         Path to file to test.

  @retval EFI_SUCCESS     The Path represents a file.
  @retval EFI_NOT_FOUND   The Path does not represent a file.
  @retval other           The path failed to open.
**/
EFI_STATUS
EFIAPI
ShellIsFile(
  IN CONST CHAR16 *Name
  );

/**
  Function to determine if a given filename represents a file.

  This will search the CWD and then the Path.

  If Name is NULL, then ASSERT.

  @param[in] Name         Path to file to test.

  @retval EFI_SUCCESS     The Path represents a file.
  @retval EFI_NOT_FOUND   The Path does not represent a file.
  @retval other           The path failed to open.
**/
EFI_STATUS
EFIAPI
ShellIsFileInPath(
  IN CONST CHAR16 *Name
  );

/**
  Function to determine whether a string is decimal or hex representation of a number
  and return the number converted from the string.

  Note: this function cannot be used when (UINTN)(-1), (0xFFFFFFFF) may be a valid
  result.  Use ShellConvertStringToUint64 instead.

  @param[in] String   String representation of a number.

  @return             The unsigned integer result of the conversion.
  @retval (UINTN)(-1) An error occured.
**/
UINTN
EFIAPI
ShellStrToUintn(
  IN CONST CHAR16 *String
  );

/**
  Function return the number converted from a hex representation of a number.

  Note: this function cannot be used when (UINTN)(-1), (0xFFFFFFFF) may be a valid
  result.  Use ShellConvertStringToUint64 instead.

  @param[in] String   String representation of a number.

  @return             The unsigned integer result of the conversion.
  @retval (UINTN)(-1) An error occured.
**/
UINTN
EFIAPI
ShellHexStrToUintn(
  IN CONST CHAR16 *String
  );

/**
  Safely append with automatic string resizing given length of Destination and
  desired length of copy from Source.

  Append the first D characters of Source to the end of Destination, where D is
  the lesser of Count and the StrLen() of Source. If appending those D characters
  will fit within Destination (whose Size is given as CurrentSize) and
  still leave room for a NULL terminator, then those characters are appended,
  starting at the original terminating NULL of Destination, and a new terminating
  NULL is appended.

  If appending D characters onto Destination will result in a overflow of the size
  given in CurrentSize the string will be grown such that the copy can be performed
  and CurrentSize will be updated to the new size.

  If Source is NULL, there is nothing to append, so return the current buffer in
  Destination.

  If Destination is NULL, then ASSERT().
  If Destination's current length (including NULL terminator) is already more than
  CurrentSize, then ASSERT().

  @param[in, out] Destination    The String to append onto.
  @param[in, out] CurrentSize    On call, the number of bytes in Destination.  On
                                 return, possibly the new size (still in bytes).  If NULL,
                                 then allocate whatever is needed.
  @param[in]      Source         The String to append from.
  @param[in]      Count          The maximum number of characters to append.  If 0, then
                                 all are appended.

  @return                       The Destination after appending the Source.
**/
CHAR16*
EFIAPI
StrnCatGrow (
  IN OUT CHAR16           **Destination,
  IN OUT UINTN            *CurrentSize,
  IN     CONST CHAR16     *Source,
  IN     UINTN            Count
  );

/**
  This is a find and replace function.  Upon successful return the NewString is a copy of
  SourceString with each instance of FindTarget replaced with ReplaceWith.

  If SourceString and NewString overlap the behavior is undefined.

  If the string would grow bigger than NewSize it will halt and return error.

  @param[in] SourceString              The string with source buffer.
  @param[in, out] NewString            The string with resultant buffer.
  @param[in] NewSize                   The size in bytes of NewString.
  @param[in] FindTarget                The string to look for.
  @param[in] ReplaceWith               The string to replace FindTarget with.
  @param[in] SkipPreCarrot             If TRUE will skip a FindTarget that has a '^'
                                       immediately before it.
  @param[in] ParameterReplacing        If TRUE will add "" around items with spaces.

  @retval EFI_INVALID_PARAMETER       SourceString was NULL.
  @retval EFI_INVALID_PARAMETER       NewString was NULL.
  @retval EFI_INVALID_PARAMETER       FindTarget was NULL.
  @retval EFI_INVALID_PARAMETER       ReplaceWith was NULL.
  @retval EFI_INVALID_PARAMETER       FindTarget had length < 1.
  @retval EFI_INVALID_PARAMETER       SourceString had length < 1.
  @retval EFI_BUFFER_TOO_SMALL        NewSize was less than the minimum size to hold
                                      the new string (truncation occurred).
  @retval EFI_SUCCESS                 The string was successfully copied with replacement.
**/
EFI_STATUS
EFIAPI
ShellCopySearchAndReplace(
  IN CHAR16 CONST                     *SourceString,
  IN OUT CHAR16                       *NewString,
  IN UINTN                            NewSize,
  IN CONST CHAR16                     *FindTarget,
  IN CONST CHAR16                     *ReplaceWith,
  IN CONST BOOLEAN                    SkipPreCarrot,
  IN CONST BOOLEAN                    ParameterReplacing
  );

/**
  Check if a Unicode character is a hexadecimal character.

  This internal function checks if a Unicode character is a
  numeric character.  The valid hexadecimal characters are
  L'0' to L'9', L'a' to L'f', or L'A' to L'F'.


  @param  Char  The character to check against.

  @retval TRUE  The Char is a hexadecmial character.
  @retval FALSE The Char is not a hexadecmial character.

**/
BOOLEAN
EFIAPI
ShellIsHexaDecimalDigitCharacter (
  IN      CHAR16                    Char
  );

/**
  Check if a Unicode character is a decimal character.

  This internal function checks if a Unicode character is a
  decimal character.  The valid characters are
  L'0' to L'9'.


  @param  Char  The character to check against.

  @retval TRUE  The Char is a hexadecmial character.
  @retval FALSE The Char is not a hexadecmial character.

**/
BOOLEAN
EFIAPI
ShellIsDecimalDigitCharacter (
  IN      CHAR16                    Char
  );

///
/// What type of answer is requested.
///
typedef enum {
  ShellPromptResponseTypeYesNo,
  ShellPromptResponseTypeYesNoCancel,
  ShellPromptResponseTypeFreeform,
  ShellPromptResponseTypeQuitContinue,
  ShellPromptResponseTypeYesNoAllCancel,
  ShellPromptResponseTypeEnterContinue,
  ShellPromptResponseTypeAnyKeyContinue,
  ShellPromptResponseTypeMax
} SHELL_PROMPT_REQUEST_TYPE;

///
/// What answer was given.
///
typedef enum {
  ShellPromptResponseYes,
  ShellPromptResponseNo,
  ShellPromptResponseCancel,
  ShellPromptResponseQuit,
  ShellPromptResponseContinue,
  ShellPromptResponseAll,
  ShellPromptResponseMax
} SHELL_PROMPT_RESPONSE;

/**
  Prompt the user and return the resultant answer to the requestor.

  This function will display the requested question on the shell prompt and then
  wait for an appropriate answer to be input from the console.

  If the SHELL_PROMPT_REQUEST_TYPE is SHELL_PROMPT_REQUEST_TYPE_YESNO, ShellPromptResponseTypeQuitContinue
  or SHELL_PROMPT_REQUEST_TYPE_YESNOCANCEL then *Response is of type SHELL_PROMPT_RESPONSE.

  If the SHELL_PROMPT_REQUEST_TYPE is ShellPromptResponseTypeFreeform then *Response is of type
  CHAR16*.

  In either case *Response must be callee freed if Response was not NULL;

  @param Type                     What type of question is asked.  This is used to filter the input
                                  to prevent invalid answers to question.
  @param Prompt                   The pointer to a string prompt used to request input.
  @param Response                 The pointer to Response, which will be populated upon return.

  @retval EFI_SUCCESS             The operation was successful.
  @retval EFI_UNSUPPORTED         The operation is not supported as requested.
  @retval EFI_INVALID_PARAMETER   A parameter was invalid.
  @return other                   The operation failed.
**/
EFI_STATUS
EFIAPI
ShellPromptForResponse (
  IN SHELL_PROMPT_REQUEST_TYPE   Type,
  IN CHAR16         *Prompt OPTIONAL,
  IN OUT VOID       **Response OPTIONAL
  );

/**
  Prompt the user and return the resultant answer to the requestor.

  This function is the same as ShellPromptForResponse, except that the prompt is
  automatically pulled from HII.

  @param[in] Type What type of question is asked.  This is used to filter the input
                  to prevent invalid answers to question.
  @param[in] HiiFormatStringId   The format string Id for getting from Hii.
  @param[in] HiiFormatHandle     The format string Handle for getting from Hii.
  @param[in, out] Response       The pointer to Response, which will be populated upon return.

  @retval EFI_SUCCESS The operation was sucessful.
  @return other       The operation failed.

  @sa ShellPromptForResponse
**/
EFI_STATUS
EFIAPI
ShellPromptForResponseHii (
  IN SHELL_PROMPT_REQUEST_TYPE         Type,
  IN CONST EFI_STRING_ID  HiiFormatStringId,
  IN CONST EFI_HANDLE     HiiFormatHandle,
  IN OUT VOID             **Response
  );

/**
  Function to determin if an entire string is a valid number.

  If Hex it must be preceeded with a 0x, 0X, or has ForceHex set TRUE.

  @param[in] String       The string to evaluate.
  @param[in] ForceHex     TRUE - always assume hex.
  @param[in] StopAtSpace  TRUE to halt upon finding a space, FALSE to keep going.

  @retval TRUE        It is all numeric (dec/hex) characters.
  @retval FALSE       There is a non-numeric character.
**/
BOOLEAN
EFIAPI
ShellIsHexOrDecimalNumber (
  IN CONST CHAR16   *String,
  IN CONST BOOLEAN  ForceHex,
  IN CONST BOOLEAN  StopAtSpace
  );

/**
  Function to verify and convert a string to its numerical 64 bit representation.

  If Hex it must be preceeded with a 0x, 0X, or has ForceHex set TRUE.

  @param[in] String       The string to evaluate.
  @param[out] Value       Upon a successful return the value of the conversion.
  @param[in] ForceHex     TRUE - always assume hex.
  @param[in] StopAtSpace  TRUE to halt upon finding a space, FALSE to
                          process the entire String.

  @retval EFI_SUCCESS             The conversion was successful.
  @retval EFI_INVALID_PARAMETER   String contained an invalid character.
  @retval EFI_NOT_FOUND           String was a number, but Value was NULL.
**/
EFI_STATUS
EFIAPI
ShellConvertStringToUint64(
  IN CONST CHAR16   *String,
     OUT   UINT64   *Value,
  IN CONST BOOLEAN  ForceHex,
  IN CONST BOOLEAN  StopAtSpace
  );

/**
  Function to determine if a given filename exists.

  @param[in] Name         Path to test.

  @retval EFI_SUCCESS     The Path represents a file.
  @retval EFI_NOT_FOUND   The Path does not represent a file.
  @retval other           The path failed to open.
**/
EFI_STATUS
EFIAPI
ShellFileExists(
  IN CONST CHAR16 *Name
  );

/**
  Function to read a single line from a SHELL_FILE_HANDLE. The \n is not included in the returned
  buffer.  The returned buffer must be callee freed.

  If the position upon start is 0, then the Ascii Boolean will be set.  This should be
  maintained and not changed for all operations with the same file.

  @param[in]       Handle        SHELL_FILE_HANDLE to read from.
  @param[in, out]  Ascii         Boolean value for indicating whether the file is
                                 Ascii (TRUE) or UCS2 (FALSE).

  @return                        The line of text from the file.

  @sa ShellFileHandleReadLine
**/
CHAR16*
EFIAPI
ShellFileHandleReturnLine(
  IN SHELL_FILE_HANDLE            Handle,
  IN OUT BOOLEAN                *Ascii
  );

/**
  Function to read a single line (up to but not including the \n) from a SHELL_FILE_HANDLE.

  If the position upon start is 0, then the Ascii Boolean will be set.  This should be
  maintained and not changed for all operations with the same file.

  @param[in]       Handle        SHELL_FILE_HANDLE to read from.
  @param[in, out]  Buffer        The pointer to buffer to read into.
  @param[in, out]  Size          The pointer to number of bytes in Buffer.
  @param[in]       Truncate      If the buffer is large enough, this has no effect.
                                 If the buffer is is too small and Truncate is TRUE,
                                 the line will be truncated.
                                 If the buffer is is too small and Truncate is FALSE,
                                 then no read will occur.

  @param[in, out]  Ascii         Boolean value for indicating whether the file is
                                 Ascii (TRUE) or UCS2 (FALSE).

  @retval EFI_SUCCESS           The operation was successful.  The line is stored in
                                Buffer.
  @retval EFI_END_OF_FILE       There are no more lines in the file.
  @retval EFI_INVALID_PARAMETER Handle was NULL.
  @retval EFI_INVALID_PARAMETER Size was NULL.
  @retval EFI_BUFFER_TOO_SMALL  Size was not large enough to store the line.
                                Size was updated to the minimum space required.
**/
EFI_STATUS
EFIAPI
ShellFileHandleReadLine(
  IN SHELL_FILE_HANDLE          Handle,
  IN OUT CHAR16                 *Buffer,
  IN OUT UINTN                  *Size,
  IN BOOLEAN                    Truncate,
  IN OUT BOOLEAN                *Ascii
  );

/**
  Function to delete a file by name

  @param[in]       FileName       Pointer to file name to delete.

  @retval EFI_SUCCESS             the file was deleted sucessfully
  @retval EFI_WARN_DELETE_FAILURE the handle was closed, but the file was not
                                  deleted
  @retval EFI_INVALID_PARAMETER   One of the parameters has an invalid value.
  @retval EFI_NOT_FOUND           The specified file could not be found on the
                                  device or the file system could not be found
                                  on the device.
  @retval EFI_NO_MEDIA            The device has no medium.
  @retval EFI_MEDIA_CHANGED       The device has a different medium in it or the
                                  medium is no longer supported.
  @retval EFI_DEVICE_ERROR        The device reported an error.
  @retval EFI_VOLUME_CORRUPTED    The file system structures are corrupted.
  @retval EFI_WRITE_PROTECTED     The file or medium is write protected.
  @retval EFI_ACCESS_DENIED       The file was opened read only.
  @retval EFI_OUT_OF_RESOURCES    Not enough resources were available to open the
                                  file.
  @retval other                   The file failed to open
**/
EFI_STATUS
EFIAPI
ShellDeleteFileByName(
  IN CONST CHAR16               *FileName
  );

/**
  Function to print help file / man page content in the spec from the UEFI Shell protocol GetHelpText function.

  @param[in] CommandToGetHelpOn  Pointer to a string containing the command name of help file to be printed.
  @param[in] SectionToGetHelpOn  Pointer to the section specifier(s).
  @param[in] PrintCommandText    If TRUE, prints the command followed by the help content, otherwise prints
                                 the help content only.
  @retval EFI_DEVICE_ERROR       The help data format was incorrect.
  @retval EFI_NOT_FOUND          The help data could not be found.
  @retval EFI_SUCCESS            The operation was successful.
**/
EFI_STATUS
EFIAPI
ShellPrintHelp (
  IN CONST CHAR16     *CommandToGetHelpOn,
  IN CONST CHAR16     *SectionToGetHelpOn,
  IN BOOLEAN          PrintCommandText
  );

#endif // __SHELL_LIB__

```

`ShellPkg/Include/Protocol/EfiShellEnvironment2.h`:

```h
/** @file
  Defines for EFI shell environment 2 ported to EDK II build environment. (no spec)

  Copyright (c) 2005 - 2010, Intel Corporation. All rights reserved.<BR>
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/


#ifndef _SHELL_ENVIRONMENT_2_PROTOCOL_H_
#define _SHELL_ENVIRONMENT_2_PROTOCOL_H_

#define DEFAULT_INIT_ROW    1
#define DEFAULT_AUTO_LF     FALSE

/**
  This function is a prototype for a function that dumps information on a protocol
  to a given location.  The location is dependant on the implementation.  This is
  used when programatically adding shell commands.

  @param[in] Handle                 The handle the protocol is on.
  @param[in] Interface              The interface to the protocol.

**/
typedef
VOID
(EFIAPI *SHELLENV_DUMP_PROTOCOL_INFO) (
  IN EFI_HANDLE                   Handle,
  IN VOID                         *Interface
  );

/**
  This function is a prototype for each command internal to the EFI shell
  implementation.  The specific command depends on the implementation.  This is
  used when programatically adding shell commands.

  @param[in] ImageHandle        The handle to the binary shell.
  @param[in] SystemTable        The pointer to the system table.

  @retval EFI_SUCCESS           The command completed.
  @retval other                 An error occurred.  Any error is possible
                                depending on the implementation of the shell
                                command.

**/
typedef
EFI_STATUS
(EFIAPI *SHELLENV_INTERNAL_COMMAND) (
  IN EFI_HANDLE                   ImageHandle,
  IN EFI_SYSTEM_TABLE             *SystemTable
  );

/**
  This function is a prototype for one that gets a help string for a given command.
  This is used when programatically adding shell commands.  Upon successful return
  the memory allocated is up to the caller to free.

  @param[in, out] Str              Pointer to pointer to string to display for help.

  @retval EFI_SUCCESS             The help string is in the parameter Str.

**/
typedef
EFI_STATUS
(EFIAPI *SHELLCMD_GET_LINE_HELP) (
  IN OUT CHAR16                 **Str
  );

/**
Structure returned from functions that open multiple files.
**/
typedef struct {
  UINT32                    Signature;            ///< SHELL_FILE_ARG_SIGNATURE.
  LIST_ENTRY                Link;                 ///< Linked list helper.
  EFI_STATUS                Status;               ///< File's status.

  EFI_FILE_HANDLE           Parent;               ///< What is the Parent file of this file.
  UINT64                    OpenMode;             ///< How was the file opened.
  CHAR16                    *ParentName;          ///< String representation of parent.
  EFI_DEVICE_PATH_PROTOCOL  *ParentDevicePath;    ///< DevicePath for Parent.

  CHAR16                    *FullName;            ///< Path and file name for this file.
  CHAR16                    *FileName;            ///< File name for this file.

  EFI_FILE_HANDLE           Handle;               ///< Handle to this file.
  EFI_FILE_INFO             *Info;                ///< Pointer to file info for this file.
} SHELL_FILE_ARG;

/// Signature for SHELL_FILE_ARG.
#define SHELL_FILE_ARG_SIGNATURE  SIGNATURE_32 ('g', 'r', 'a', 'f')

/**
GUID for the shell environment2 and shell environment.
**/
#define SHELL_ENVIRONMENT_PROTOCOL_GUID \
  { \
    0x47c7b221, 0xc42a, 0x11d2, {0x8e, 0x57, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} \
  }

/**
GUID for the shell environment2 extension (main GUID above).
**/
#define EFI_SE_EXT_SIGNATURE_GUID \
  { \
    0xd2c18636, 0x40e5, 0x4eb5, {0xa3, 0x1b, 0x36, 0x69, 0x5f, 0xd4, 0x2c, 0x87} \
  }

#define EFI_SHELL_MAJOR_VER 0x00000001 ///< Major version of the EFI_SHELL_ENVIRONMENT2.
#define EFI_SHELL_MINOR_VER 0x00000000 ///< Minor version of the EFI_SHELL_ENVIRONMENT2.

/**
  Execute a command line.

  This function will run the CommandLine.  This includes loading any required images,
  parsing any requires scripts, and if DebugOutput is TRUE printing errors
  encountered directly to the screen.

  @param[in] ParentImageHandle  Handle of the image executing this operation.
  @param[in] CommandLine        The string command line to execute.
  @param[in] DebugOutput        TRUE indicates that errors should be printed directly.
                                FALSE suppresses error messages.

  @retval EFI_SUCCESS           The command line executed and completed.
  @retval EFI_ABORTED           The operation aborted.
  @retval EFI_INVALID_PARAMETER A parameter did not have a valid value.
  @retval EFI_OUT_OF_RESOURCES  A required memory allocation failed.

@sa HandleProtocol
**/
typedef
EFI_STATUS
(EFIAPI *SHELLENV_EXECUTE) (
  IN EFI_HANDLE   *ParentImageHandle,
  IN CHAR16       *CommandLine,
  IN BOOLEAN      DebugOutput
  );

/**
  This function returns a shell environment variable value.

  @param[in] Name               The pointer to the string with the shell environment
                                variable name.

  @retval NULL                  The shell environment variable's value could not be found.
  @retval !=NULL                The value of the shell environment variable Name.

**/
typedef
CHAR16 *
(EFIAPI *SHELLENV_GET_ENV) (
  IN CHAR16 *Name
  );

/**
  This function returns a shell environment map value.

  @param[in] Name               The pointer to the string with the shell environment
                                map name.

  @retval NULL                  The shell environment map's value could not be found.
  @retval !=NULL                The value of the shell environment map Name.

**/
typedef
CHAR16 *
(EFIAPI *SHELLENV_GET_MAP) (
  IN CHAR16 *Name
  );

/**
  This function will add an internal command to the shell interface.

  This will allocate all required memory, put the new command on the command
  list in the correct location.

  @param[in] Handler                The handler function to call when the command gets called.
  @param[in] Cmd                    The command name.
  @param[in] GetLineHelp            The function to call of type "get help" for this command.

  @retval EFI_SUCCESS           The command is now part of the command list.
  @retval EFI_OUT_OF_RESOURCES  A memory allocation failed.
  @sa SHELLENV_INTERNAL_COMMAND
  @sa SHELLCMD_GET_LINE_HELP
**/
typedef
EFI_STATUS
(EFIAPI *SHELLENV_ADD_CMD) (
  IN SHELLENV_INTERNAL_COMMAND    Handler,
  IN CHAR16                       *Cmd,
  IN SHELLCMD_GET_LINE_HELP       GetLineHelp
  );

/**
  Internal interface to add protocol handlers.

  This function is for internal shell use only.  This is how protocol handlers are added.
  This will get the current protocol info and add the new info or update existing info
  and then resave the info.

  @param[in] Protocol           The pointer to the protocol's GUID.
  @param[in] DumpToken          The function pointer to dump token function or
                                NULL.
  @param[in] DumpInfo           The function pointer to dump infomation function
                                or NULL.
  @param[in] IdString           The English name of the protocol.
**/
typedef
VOID
(EFIAPI *SHELLENV_ADD_PROT) (
  IN EFI_GUID                     *Protocol,
  IN SHELLENV_DUMP_PROTOCOL_INFO  DumpToken OPTIONAL,
  IN SHELLENV_DUMP_PROTOCOL_INFO  DumpInfo OPTIONAL,
  IN CHAR16                       *IdString
  );

/**
  This function finds a protocol handle by a GUID.

  This function will check for already known protocols by GUID and if one is
  found it will return the name of that protocol.  If no name is found and
  GenId is TRUE it will generate ths string.

  @param[in] Protocol          The GUID of the protocol to look for.
  @param[in] GenId             Whether to generate a name string if it is not found.

  @return !NULL                The Name of the protocol.
  @retval NULL                 The Name was not found, and GenId was not TRUE.
**/
typedef
CHAR16*
(EFIAPI *SHELLENV_GET_PROT) (
  IN EFI_GUID *Protocol,
  IN BOOLEAN GenId
  );

/**
  This function returns a string array containing the current directory on
  a given device.

  If DeviceName is specified, then return the current shell directory on that
  device.  If DeviceName is NULL, then return the current directory on the
  current device.  The caller us responsible to free the returned string when
  no longer required.

  @param[in] DeviceName         The name of the device to get the current
                                directory on, or NULL for current device.

  @return String array with the current directory on the current or specified device.

**/
typedef
CHAR16*
(EFIAPI *SHELLENV_CUR_DIR) (
  IN CHAR16 *DeviceName OPTIONAL
  );

/**
  This function will open a group of files that match the Arg path, including
  support for wildcard characters ('?' and '*') in the Arg path.  If there are
  any wildcard characters in the path this function will find any and all files
  that match the wildcards.  It returns a double linked list based on the
  LIST_ENTRY linked list structure.  Use this in conjunction with the
  SHELL_FILE_ARG_SIGNATURE to get the SHELL_FILE_ARG structures that are returned.
  The memory allocated by the callee for this list is freed by making a call to
  SHELLENV_FREE_FILE_LIST.

  @param[in] Arg                 The pointer Path to files to open.
  @param[in, out] ListHead       The pointer to the allocated and initialized list head
                                 upon which to append all opened file structures.

  @retval EFI_SUCCESS           One or more files was opened and a struct of each file's
                                information was appended to ListHead.
  @retval EFI_OUT_OF_RESOURCES  A memory allocation failed.
  @retval EFI_NOT_FOUND         No matching files could be found.
  @sa SHELLENV_FREE_FILE_LIST
**/typedef
EFI_STATUS
(EFIAPI *SHELLENV_FILE_META_ARG) (
  IN CHAR16               *Arg,
  IN OUT LIST_ENTRY       *ListHead
  );

/**
  This frees all of the nodes under the ListHead, but not ListHead itself.

  @param[in, out] ListHead       Pointer to list to free all nodes of.

  @retval EFI_SUCCESS           This function always returns EFI_SUCCESS.
**/
typedef
EFI_STATUS
(EFIAPI *SHELLENV_FREE_FILE_LIST) (
  IN OUT LIST_ENTRY       *ListHead
  );

/**
  This function creates a new instance of the ShellInterface protocol for use on
  the ImageHandle.

  This function is for internal shell usage.  This will allocate and then populate
  EFI_SHELL_INTERFACE protocol.  It is the caller's responsibility to free the
  memory.

  @param[in] ImageHandle        The handle which will use the new ShellInterface
                                protocol.

  @return The newly allocated shell interface protocol.

**/
typedef
EFI_SHELL_INTERFACE*
(EFIAPI *SHELLENV_NEW_SHELL) (
  IN EFI_HANDLE ImageHandle
  );

/**
  This function determines whether a script file is currently being processed.

  A script file (.nsh file) can contain a series of commands and this is useful to
  know for some shell commands whether they are being run manually or as part of a
  script.

  @retval TRUE                  A script file is being processed.
  @retval FALSE                 A script file is not being processed.
**/
typedef
BOOLEAN
(EFIAPI *SHELLENV_BATCH_IS_ACTIVE) (
  VOID
  );

/**
  This is an internal shell function to free any and all allocated resources.
  This should be called immediately prior to closing the shell.
**/
typedef
VOID
(EFIAPI *SHELLENV_FREE_RESOURCES) (
  VOID
  );

/**
  This function enables the page break mode.

  This mode causes the output to pause after each complete screen to enable a
  user to more easily read it.  If AutoWrap is TRUE, then rows with too many
  characters will be chopped and divided into 2 rows.  If FALSE, then rows with
  too many characters may not be fully visible to the user on the screen.

  @param[in] StartRow               The row number to start this on.
  @param[in] AutoWrap               Whether to auto wrap rows that are too long.
**/
typedef
VOID
(EFIAPI *SHELLENV_ENABLE_PAGE_BREAK) (
  IN INT32      StartRow,
  IN BOOLEAN    AutoWrap
  );

/**
  This function disables the page break mode.

  Disabling this causes the output to print out exactly as coded, with no breaks
  for readability.
**/
typedef
VOID
(EFIAPI *SHELLENV_DISABLE_PAGE_BREAK) (
  VOID
  );

/**
  Get the status of the page break output mode.

  @retval FALSE                 Page break output mode is not enabled.
  @retval TRUE                  Page break output mode is enabled.
**/
typedef
BOOLEAN
(EFIAPI *SHELLENV_GET_PAGE_BREAK) (
  VOID
  );

/**
  This function sets the keys to filter for for the console in.  The valid
  values to set are:

  #define EFI_OUTPUT_SCROLL   0x00000001
  #define EFI_OUTPUT_PAUSE    0x00000002
  #define EFI_EXECUTION_BREAK 0x00000004

  @param[in] KeyFilter              The new key filter to use.
**/
typedef
VOID
(EFIAPI *SHELLENV_SET_KEY_FILTER) (
  IN UINT32      KeyFilter
  );

/**
  This function gets the keys to filter for for the console in.

  The valid values to get are:
  #define EFI_OUTPUT_SCROLL   0x00000001
  #define EFI_OUTPUT_PAUSE    0x00000002
  #define EFI_EXECUTION_BREAK 0x00000004

  @retval The current filter mask.
**/
typedef
UINT32
(EFIAPI *SHELLENV_GET_KEY_FILTER) (
  VOID
  );

/**
  This function determines if the shell application should break.

  This is used to inform a shell application that a break condition has been
  initiated.  Long loops should check this to prevent delays to the break.

  @retval TRUE                  A break has been signaled.  The application
                                should exit with EFI_ABORTED as soon as possible.
  @retval FALSE                 Continue as normal.
**/
typedef
BOOLEAN
(EFIAPI *SHELLENV_GET_EXECUTION_BREAK) (
  VOID
  );

/**
  This is an internal shell function used to increment the shell nesting level.

**/
typedef
VOID
(EFIAPI *SHELLENV_INCREMENT_SHELL_NESTING_LEVEL) (
  VOID
  );

/**
  This is an internal shell function used to decrement the shell nesting level.
**/
typedef
VOID
(EFIAPI *SHELLENV_DECREMENT_SHELL_NESTING_LEVEL) (
  VOID
  );

/**
  This function determines if the caller is running under the root shell.

  @retval TRUE                  The caller is running under the root shell.
  @retval FALSE                 The caller is not running under the root shell.

**/
typedef
BOOLEAN
(EFIAPI *SHELLENV_IS_ROOT_SHELL) (
  VOID
  );

/**
  Close the console proxy to restore the original console.

  This is an internal shell function to handle shell cascading.  It restores the
  original set of console protocols.

  @param[in] ConInHandle         The handle of ConIn.
  @param[in, out] ConIn          The pointer to the location to return the pointer to
                                 the original console input.
  @param[in] ConOutHandle        The handle of ConOut
  @param[in, out] ConOut         The pointer to the location to return the pointer to
                                 the original console output.
**/
typedef
VOID
(EFIAPI *SHELLENV_CLOSE_CONSOLE_PROXY) (
  IN     EFI_HANDLE                       ConInHandle,
  IN OUT EFI_SIMPLE_TEXT_INPUT_PROTOCOL   **ConIn,
  IN     EFI_HANDLE                       ConOutHandle,
  IN OUT EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  **ConOut
  );

//
// declarations of handle enumerator
//
/**
  For ease of use the shell maps handle #'s to short numbers.
  This is only done on request for various internal commands and the references
  are immediately freed when the internal command completes.
**/
typedef
VOID
(EFIAPI *INIT_HANDLE_ENUMERATOR) (
  VOID
  );

/**
  This is an internal shell function to enumerate the handle database.

  This function gets the next handle in the handle database.  If no handles are
  found, EFI_NOT_FOUND is returned.  If the previous Handle was the last handle,
  it is set to NULL before returning.

  This must be called after INIT_HANDLE_ENUMERATOR and before CLOSE_HANDLE_ENUMERATOR.

  @param[in, out] Handle         The pointer to pointer to Handle.  It is set
                                 on a sucessful return.

  @retval EFI_SUCCESS           The next handle in the handle database is *Handle.
  @retval EFI_NOT_FOUND         There is not another handle.
**/
typedef
EFI_STATUS
(EFIAPI *NEXT_HANDLE) (
  IN OUT EFI_HANDLE             **Handle
  );

/**
  This is an internal shell function to enumerate the handle database.

  This function skips the next SkipNum handles in the handle database.  If there
  are not enough handles left to skip that many EFI_ACCESS_DENIED is returned and
  no skip is performed.

  This must be called after INIT_HANDLE_ENUMERATOR and before CLOSE_HANDLE_ENUMERATOR.

  @param[in] SkipNum            How many handles to skip

  @retval EFI_SUCCESS           The next handle in the handle database is *Handle
  @retval EFI_ACCESS_DENIED     There are not SkipNum handles left in the database
**/
typedef
EFI_STATUS
(EFIAPI *SKIP_HANDLE) (
  IN UINTN                   SkipNum
  );

/**
  This is an internal shell function to enumerate the handle database.

  This function resets the the handle database so that NEXT_HANDLE and SKIP_HANDLE
  will start from EnumIndex on the next call.

  This must be called after INIT_HANDLE_ENUMERATOR and before CLOSE_HANDLE_ENUMERATOR.

  @param[in] EnumIndex          Where to start.

  @return The number of handles either read out or skipped before this reset.
**/
typedef
UINTN
(EFIAPI *RESET_HANDLE_ENUMERATOR) (
  IN UINTN                  EnumIndex
  );

/**
  This is an internal shell function to enumerate the handle database.

  This must be called after INIT_HANDLE_ENUMERATOR.

  This function releases all memory and resources associated with the handle database.
  After this no other handle enumerator functions except INIT_HANDLE_ENUMERATOR will
  function properly.
**/
typedef
VOID
(EFIAPI *CLOSE_HANDLE_ENUMERATOR) (
  VOID
  );

/**
  This is an internal shell function to enumerate the handle database.

  This function returns the number of handles in the handle database.

  This must be called after INIT_HANDLE_ENUMERATOR and before CLOSE_HANDLE_ENUMERATOR.

  @return The number of handles in the handle database.
**/
typedef
UINTN
(EFIAPI *GET_NUM) (
  VOID
  );

/**
Handle Enumerator structure.
**/
typedef struct {
  INIT_HANDLE_ENUMERATOR  Init;   ///< The pointer to INIT_HANDLE_ENUMERATOR function.
  NEXT_HANDLE             Next;   ///< The pointer to NEXT_HANDLE function.
  SKIP_HANDLE             Skip;   ///< The pointer to SKIP_HANDLE function.
  RESET_HANDLE_ENUMERATOR Reset;  ///< The pointer to RESET_HANDLE_ENUMERATOR function.
  CLOSE_HANDLE_ENUMERATOR Close;  ///< The pointer to CLOSE_HANDLE_ENUMERATOR function.
  GET_NUM                 GetNum; ///< The pointer to GET_NUM function.
} HANDLE_ENUMERATOR;

/**
  Signature for the PROTOCOL_INFO structure.
**/
#define PROTOCOL_INFO_SIGNATURE SIGNATURE_32 ('s', 'p', 'i', 'n')

/**
  PROTOCOL_INFO structure for protocol enumerator functions.
**/
typedef struct {
  UINTN                       Signature;   ///< PROTOCOL_INFO_SIGNATURE.
  LIST_ENTRY                  Link;        ///< Standard linked list helper member.
  //
  // The parsing info for the protocol.
  //
  EFI_GUID                    ProtocolId;  ///< The GUID for the protocol.
  CHAR16                      *IdString;   ///< The name of the protocol.
  SHELLENV_DUMP_PROTOCOL_INFO DumpToken;   ///< The pointer to DumpToken function for the protocol.
  SHELLENV_DUMP_PROTOCOL_INFO DumpInfo;    ///< The pointer to DumpInfo function for the protocol.
  //
  // Patabase info on which handles are supporting this protocol.
  //
  UINTN                       NoHandles;   ///< The number of handles producing this protocol.
  EFI_HANDLE                  *Handles;    ///< The array of handles.

} PROTOCOL_INFO;

//
// Declarations of protocol info enumerator.
//
/**
  This is an internal shell function to initialize the protocol enumerator.

  This must be called before NEXT_PROTOCOL_INFO, SKIP_PROTOCOL_INFO,
  RESET_PROTOCOL_INFO_ENUMERATOR, and CLOSE_PROTOCOL_INFO_ENUMERATOR are
  called.
**/
typedef
VOID
(EFIAPI *INIT_PROTOCOL_INFO_ENUMERATOR) (
  VOID
  );

/**
  This function is an internal shell function for enumeration of protocols.

  This function returns the next protocol on the list.  If this is called
  immediately after initialization, it will return the first protocol on the list.
  If this is called immediately after reset, it will return the first protocol again.

  This cannot be called after CLOSE_PROTOCOL_INFO_ENUMERATOR, but it must be
  called after INIT_PROTOCOL_INFO_ENUMERATOR.

  @param[in, out] ProtocolInfo   The pointer to pointer to protocol information structure.

  @retval EFI_SUCCESS           The next protocol's information was sucessfully returned.
  @retval NULL                  There are no more protocols.
**/
typedef
EFI_STATUS
(EFIAPI *NEXT_PROTOCOL_INFO) (
  IN OUT PROTOCOL_INFO            **ProtocolInfo
  );

/**
  This function is an internal shell function for enumeration of protocols.

  This cannot be called after CLOSE_PROTOCOL_INFO_ENUMERATOR, but it must be
  called after INIT_PROTOCOL_INFO_ENUMERATOR.

  This function does nothing and always returns EFI_SUCCESS.

  @retval EFI_SUCCESS           Always returned (see above).
**/
typedef
EFI_STATUS
(EFIAPI *SKIP_PROTOCOL_INFO) (
  IN UINTN                         SkipNum
  );

/**
  This function is an internal shell function for enumeration of protocols.

  This cannot be called after CLOSE_PROTOCOL_INFO_ENUMERATOR, but it must be
  called after INIT_PROTOCOL_INFO_ENUMERATOR.

  This function resets the list of protocols such that the next one in the
  list is the begining of the list.
**/
typedef
VOID
(EFIAPI *RESET_PROTOCOL_INFO_ENUMERATOR) (
  VOID
  );


/**
  This function is an internal shell function for enumeration of protocols.

  This must be called after INIT_PROTOCOL_INFO_ENUMERATOR.  After this call
  no protocol enumerator calls except INIT_PROTOCOL_INFO_ENUMERATOR may be made.

  This function frees any memory or resources associated with the protocol
  enumerator.
**/
typedef
VOID
(EFIAPI *CLOSE_PROTOCOL_INFO_ENUMERATOR) (
  VOID
  );

/**
  Protocol enumerator structure of function pointers.
**/
typedef struct {
  INIT_PROTOCOL_INFO_ENUMERATOR   Init;   ///< The pointer to INIT_PROTOCOL_INFO_ENUMERATOR function.
  NEXT_PROTOCOL_INFO              Next;   ///< The pointer to NEXT_PROTOCOL_INFO function.
  SKIP_PROTOCOL_INFO              Skip;   ///< The pointer to SKIP_PROTOCOL_INFO function.
  RESET_PROTOCOL_INFO_ENUMERATOR  Reset;  ///< The pointer to RESET_PROTOCOL_INFO_ENUMERATOR function.
  CLOSE_PROTOCOL_INFO_ENUMERATOR  Close;  ///< The pointer to CLOSE_PROTOCOL_INFO_ENUMERATOR function.
} PROTOCOL_INFO_ENUMERATOR;

/**
  This function is used to retrieve a user-friendly display name for a handle.

  If UseComponentName is TRUE then the component name protocol for this device
  or it's parent device (if required) will be used to obtain the name of the
  device.  If UseDevicePath is TRUE it will get the human readable device path
  and return that.  If both are TRUE it will try to use component name first
  and device path if that fails.

  It will use either ComponentName or ComponentName2 protocol, depending on
  what is present.

  This function will furthur verify whether the handle in question produced either
  EFI_DRIVER_CONFIGRATION_PROTOCOL or EFI_DRIVER_CONFIGURATION2_PROTOCOL and also
  whether the handle in question produced either EFI_DRIVER_DIAGNOSTICS_PROTOCOL or
  EFI_DRIVER_DIAGNOSTICS2_PROTOCOL.

  Upon successful return, the memory for *BestDeviceName is up to the caller to free.

  @param[in] DeviceHandle            The device handle whose name is desired.
  @param[in] UseComponentName        Whether to use the ComponentName protocol at all.
  @param[in] UseDevicePath           Whether to use the DevicePath protocol at all.
  @param[in] Language                The pointer to the language string to use.
  @param[in, out] BestDeviceName     The pointer to pointer to string allocated with the name.
  @param[out] ConfigurationStatus    The pointer to status for opening a Configuration protocol.
  @param[out] DiagnosticsStatus      The pointer to status for opening a Diagnostics protocol.
  @param[in] Display                 Whether to Print this out to default Print location.
  @param[in] Indent                  How many characters to indent the printing.

  @retval EFI_SUCCESS           This function always returns EFI_SUCCESS.
**/
typedef
EFI_STATUS
(EFIAPI *GET_DEVICE_NAME) (
  IN EFI_HANDLE  DeviceHandle,
  IN BOOLEAN     UseComponentName,
  IN BOOLEAN     UseDevicePath,
  IN CHAR8       *Language,
  IN OUT CHAR16  **BestDeviceName,
  OUT EFI_STATUS *ConfigurationStatus,
  OUT EFI_STATUS *DiagnosticsStatus,
  IN BOOLEAN     Display,
  IN UINTN       Indent
  );

#define EFI_SHELL_COMPATIBLE_MODE_VER L"1.1.1" ///< The string for lowest version this shell supports.
#define EFI_SHELL_ENHANCED_MODE_VER   L"1.1.2" ///< The string for highest version this shell supports.

/**
  This function gets the shell mode as stored in the shell environment
  "efishellmode".  It will not fail.

  @param[out] Mode              Returns a string representing one of the
                                2 supported modes of the shell.

  @retval EFI_SUCCESS           This function always returns success.
**/
typedef
EFI_STATUS
(EFIAPI *GET_SHELL_MODE) (
  OUT CHAR16     **Mode
  );

/**
  Convert a file system style name to a device path.

  This function will convert a shell path name to a Device Path Protocol path.
  This function will allocate any required memory for this operation and it
  is the responsibility of the caller to free that memory when no longer required.

  If anything prevents the complete conversion free any allocated memory and
  return NULL.

  @param[in] Path               The path to convert.

  @retval !NULL                 A pointer to the callee allocated Device Path.
  @retval NULL                  The operation could not be completed.
**/
typedef
EFI_DEVICE_PATH_PROTOCOL*
(EFIAPI *SHELLENV_NAME_TO_PATH) (
  IN CHAR16 *Path
  );

/**
  Converts a device path into a file system map name.

  If DevPath is NULL, then ASSERT.

  This function looks through the shell environment map for a map whose device
  path matches the DevPath parameter.  If one is found the Name is returned via
  Name parameter.  If sucessful the caller must free the memory allocated for
  Name.

  This function will use the internal lock to prevent changes to the map during
  the lookup operation.

  @param[in] DevPath                The device path to search for a name for.
  @param[in] ConsistMapping         What state to verify map flag VAR_ID_CONSIST.
  @param[out] Name                  On sucessful return the name of that device path.

  @retval EFI_SUCCESS           The DevPath was found and the name returned
                                in Name.
  @retval EFI_OUT_OF_RESOURCES  A required memory allocation failed.
  @retval EFI_UNSUPPORTED       The DevPath was not found in the map.
**/
typedef
EFI_STATUS
(EFIAPI *SHELLENV_GET_FS_NAME) (
  IN EFI_DEVICE_PATH_PROTOCOL     * DevPath,
  IN BOOLEAN                      ConsistMapping,
  OUT CHAR16                      **Name
  );

/**
  This function will open a group of files that match the Arg path, but will not
  support the wildcard characters ('?' and '*') in the Arg path.  If there are
  any wildcard characters in the path this function will return
  EFI_INVALID_PARAMETER.  The return is a double linked list based on the
  LIST_ENTRY linked list structure.  Use this in conjunction with the
  SHELL_FILE_ARG_SIGNATURE to get the SHELL_FILE_ARG structures that are returned.
  The memory allocated by the callee for this list is freed by making a call to
  SHELLENV_FREE_FILE_LIST.

  @param[in] Arg                 The pointer to the path of the files to be opened.
  @param[in, out] ListHead       The pointer to allocated and initialized list head
                                 upon which to append all the opened file structures.

  @retval EFI_SUCCESS           One or more files was opened and a struct of each file's
                                information was appended to ListHead.
  @retval EFI_OUT_OF_RESOURCES  A memory allocation failed.
  @retval EFI_NOT_FOUND         No matching files could be found.
  @sa SHELLENV_FREE_FILE_LIST
**/
typedef
EFI_STATUS
(EFIAPI *SHELLENV_FILE_META_ARG_NO_WILDCARD) (
  IN CHAR16               *Arg,
  IN OUT LIST_ENTRY       *ListHead
  );

/**
  This function removes duplicate file listings from lists.

  This is a function for use with SHELLENV_FILE_META_ARG_NO_WILDCARD and
  SHELLENV_FILE_META_ARG.  This function will verify that there are no duplicate
  files in the list of returned files.  Any file listed twice will have one of its
  instances removed.

  @param[in] ListHead           The pointer to linked list head that was returned from
                                SHELLENV_FILE_META_ARG_NO_WILDCARD or
                                SHELLENV_FILE_META_ARG.

  @retval EFI_SUCCESS           This function always returns success.

**/
typedef
EFI_STATUS
(EFIAPI *SHELLENV_DEL_DUP_FILE) (
  IN LIST_ENTRY   * ListHead
  );

/**
  Converts a File System map name to a device path.

  If DevPath is NULL, then ASSERT().

  This function looks through the shell environment map for a map whose Name
  matches the Name parameter.  If one is found, the device path pointer is
  updated to point to that file systems device path.  The caller should not
  free the memory from that device path.

  This function will use the internal lock to prevent changes to the map during
  the lookup operation.

  @param[in] Name               The pointer to the NULL terminated UNICODE string of the
                                file system name.
  @param[out] DevPath           The pointer to pointer to DevicePath.  Only valid on
                                successful return.

  @retval EFI_SUCCESS           The conversion was successful, and the device
                                path was returned.
  @retval EFI_NOT_FOUND         The file system could not be found in the map.
**/
typedef
EFI_STATUS
(EFIAPI *SHELLENV_GET_FS_DEVICE_PATH) (
  IN CHAR16                        *Name,
  OUT EFI_DEVICE_PATH_PROTOCOL     **DevPath
  );

/// EFI_SHELL_ENVIRONMENT2 protocol structure.
typedef struct {
  SHELLENV_EXECUTE                        Execute;
  SHELLENV_GET_ENV                        GetEnv;
  SHELLENV_GET_MAP                        GetMap;
  SHELLENV_ADD_CMD                        AddCmd;
  SHELLENV_ADD_PROT                       AddProt;
  SHELLENV_GET_PROT                       GetProt;
  SHELLENV_CUR_DIR                        CurDir;
  SHELLENV_FILE_META_ARG                  FileMetaArg;
  SHELLENV_FREE_FILE_LIST                 FreeFileList;

  //
  // The following services are only used by the shell itself.
  //
  SHELLENV_NEW_SHELL                      NewShell;
  SHELLENV_BATCH_IS_ACTIVE                BatchIsActive;

  SHELLENV_FREE_RESOURCES                 FreeResources;

  //
  // GUID to differentiate ShellEnvironment2 from ShellEnvironment.
  //
  EFI_GUID                                SESGuid;
  //
  // Major Version grows if shell environment interface has been changes.
  //
  UINT32                                  MajorVersion;
  UINT32                                  MinorVersion;
  SHELLENV_ENABLE_PAGE_BREAK              EnablePageBreak;
  SHELLENV_DISABLE_PAGE_BREAK             DisablePageBreak;
  SHELLENV_GET_PAGE_BREAK                 GetPageBreak;

  SHELLENV_SET_KEY_FILTER                 SetKeyFilter;
  SHELLENV_GET_KEY_FILTER                 GetKeyFilter;

  SHELLENV_GET_EXECUTION_BREAK            GetExecutionBreak;
  SHELLENV_INCREMENT_SHELL_NESTING_LEVEL  IncrementShellNestingLevel;
  SHELLENV_DECREMENT_SHELL_NESTING_LEVEL  DecrementShellNestingLevel;
  SHELLENV_IS_ROOT_SHELL                  IsRootShell;

  SHELLENV_CLOSE_CONSOLE_PROXY            CloseConsoleProxy;
  HANDLE_ENUMERATOR                       HandleEnumerator;
  PROTOCOL_INFO_ENUMERATOR                ProtocolInfoEnumerator;
  GET_DEVICE_NAME                         GetDeviceName;
  GET_SHELL_MODE                          GetShellMode;
  SHELLENV_NAME_TO_PATH                   NameToPath;
  SHELLENV_GET_FS_NAME                    GetFsName;
  SHELLENV_FILE_META_ARG_NO_WILDCARD      FileMetaArgNoWildCard;
  SHELLENV_DEL_DUP_FILE                   DelDupFileArg;
  SHELLENV_GET_FS_DEVICE_PATH             GetFsDevicePath;
} EFI_SHELL_ENVIRONMENT2;

extern EFI_GUID gEfiShellEnvironment2Guid;
extern EFI_GUID gEfiShellEnvironment2ExtGuid;

#endif // _SHELL_ENVIRONMENT_2_PROTOCOL_H_

```

`ShellPkg/Include/Protocol/EfiShellInterface.h`:

```h
/** @file
  EFI Shell Interface protocol from EDK shell (no spec).

  Shell Interface - additional information (over image_info) provided
  to an application started by the shell.

  ConIo provides a file-style interface to the console.

  The shell interface's and data (including ConIo) are only valid during
  the applications Entry Point.  Once the application returns from it's
  entry point the data is freed by the invoking shell.

  Copyright (c) 2006 - 2010, Intel Corporation. All rights reserved.<BR>
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#ifndef _SHELLINTERFACE_H_
#define _SHELLINTERFACE_H_

#include <Protocol/SimpleFileSystem.h>

#define SHELL_INTERFACE_PROTOCOL_GUID \
  { \
    0x47c7b223, 0xc42a, 0x11d2, {0x8e, 0x57, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} \
  }

///
/// Bit definitions for EFI_SHELL_ARG_INFO
///
typedef enum {
  ARG_NO_ATTRIB         = 0x0,
  ARG_IS_QUOTED         = BIT0,
  ARG_PARTIALLY_QUOTED  = BIT1,
  ARG_FIRST_HALF_QUOTED = BIT2,
  ARG_FIRST_CHAR_IS_ESC = BIT3
} EFI_SHELL_ARG_INFO_TYPES;

///
/// Attributes for an argument.
///
typedef struct _EFI_SHELL_ARG_INFO {
  UINT32  Attributes;
} EFI_SHELL_ARG_INFO;

///
/// This protocol provides access to additional information about a shell application.
///
typedef struct {
  ///
  /// Handle back to original image handle & image information.
  ///
  EFI_HANDLE                ImageHandle;
  EFI_LOADED_IMAGE_PROTOCOL *Info;

  ///
  /// Parsed arg list converted more C-like format.
  ///
  CHAR16                    **Argv;
  UINTN                     Argc;

  ///
  /// Storage for file redirection args after parsing.
  ///
  CHAR16                    **RedirArgv;
  UINTN                     RedirArgc;

  ///
  /// A file style handle for console io.
  ///
  EFI_FILE_PROTOCOL         *StdIn;
  EFI_FILE_PROTOCOL         *StdOut;
  EFI_FILE_PROTOCOL         *StdErr;

  ///
  /// List of attributes for each argument.
  ///
  EFI_SHELL_ARG_INFO        *ArgInfo;

  ///
  /// Whether we are echoing.
  ///
  BOOLEAN                   EchoOn;
} EFI_SHELL_INTERFACE;

extern EFI_GUID gEfiShellInterfaceGuid;

#endif

```

`SplashScreen.c`:

```c
#include "SplashScreen.h"

unsigned char AsciiArt[1473] =
{
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x5F, 0x00, 0x5F, 0x00, 0x5F, 0x00, 0x5F, 0x00, 0x5F, 0x00, 0x5F, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x2C, 0x00, 0x27, 0x00, 0x22, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x22, 0x00, 0x2D, 0x00, 0x2E, 0x00, 0x5F, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x2C, 0x00, 0x27, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x22, 0x00,
	0x2D, 0x00, 0x2E, 0x00, 0x5F, 0x00, 0x20, 0x00, 0x5F, 0x00, 0x2E, 0x00, 0x5F, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x3B, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x5F, 0x00, 0x5F, 0x00, 0x2C, 0x00, 0x2D, 0x00,
	0x27, 0x00, 0x2F, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x7C, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x3B, 0x00, 0x7C, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x2C, 0x00, 0x2D, 0x00, 0x27, 0x00, 0x20, 0x00, 0x5F, 0x00, 0x2C, 0x00, 0x27, 0x00, 0x22, 0x00,
	0x27, 0x00, 0x2E, 0x00, 0x5F, 0x00, 0x2C, 0x00, 0x2E, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x7C, 0x00, 0x3A, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x5F, 0x00, 0x2C, 0x00, 0x27, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x7C, 0x00, 0x5C, 0x00, 0x20, 0x00, 0x60, 0x00, 0x2E, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x3A, 0x00, 0x20, 0x00, 0x5C, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x5F, 0x00, 0x2C, 0x00, 0x2D, 0x00, 0x27, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x7C, 0x00, 0x20, 0x00, 0x5C, 0x00, 0x20, 0x00, 0x20, 0x00, 0x60, 0x00, 0x2E, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x5C, 0x00, 0x20, 0x00, 0x5C, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x2C, 0x00, 0x2D, 0x00, 0x27, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x7C, 0x00, 0x20, 0x00, 0x20, 0x00, 0x5C, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x5C, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x5C, 0x00, 0x20, 0x00, 0x27, 0x00, 0x2E, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x2E, 0x00, 0x2D, 0x00, 0x2E, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x7C, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x5C, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x5C, 0x00, 0x20, 0x00, 0x20, 0x00, 0x5C, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x22, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x7C, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x3A, 0x00,
	0x0D, 0x00, 0x0A, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x60, 0x00, 0x2E, 0x00, 0x20, 0x00, 0x60, 0x00, 0x2E, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x7C, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x7C, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x60, 0x00, 0x2E, 0x00, 0x20, 0x00,
	0x22, 0x00, 0x2D, 0x00, 0x2E, 0x00, 0x5F, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x7C, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x3B, 0x00,
	0x0D, 0x00, 0x0A, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x2F, 0x00, 0x20, 0x00, 0x7C, 0x00, 0x60, 0x00, 0x2E, 0x00, 0x5F, 0x00, 0x20, 0x00, 0x60, 0x00, 0x2D, 0x00,
	0x2E, 0x00, 0x5F, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x4C, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x2F, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x2F, 0x00, 0x20, 0x00, 0x20, 0x00, 0x7C, 0x00, 0x20, 0x00,
	0x5C, 0x00, 0x20, 0x00, 0x60, 0x00, 0x2E, 0x00, 0x5F, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x22, 0x00, 0x2D, 0x00, 0x2E, 0x00, 0x5F, 0x00,
	0x5F, 0x00, 0x5F, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x5F, 0x00, 0x2C, 0x00, 0x27, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x2F, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x7C, 0x00, 0x20, 0x00, 0x20, 0x00, 0x5C, 0x00, 0x5F, 0x00, 0x2E, 0x00, 0x2D, 0x00, 0x22, 0x00, 0x2D, 0x00, 0x2E, 0x00,
	0x5F, 0x00, 0x5F, 0x00, 0x5F, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x0D, 0x00, 0x0A, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x5C, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x3A, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x2F, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x60, 0x00, 0x2E, 0x00,
	0x5F, 0x00, 0x5C, 0x00, 0x5F, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x5F, 0x00, 0x5F, 0x00,
	0x2E, 0x00, 0x27, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x5F, 0x00, 0x20, 0x00, 0x27, 0x00, 0x20, 0x00, 0x22, 0x00, 0x2D, 0x00,
	0x2D, 0x00, 0x27, 0x00, 0x27, 0x00, 0x27, 0x00, 0x27, 0x00, 0x20, 0x00, 0x5C, 0x00, 0x5F, 0x00, 0x20, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x2F, 0x00, 0x5F, 0x00, 0x20, 0x00, 0x20, 0x00, 0x7C, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x5F, 0x00, 0x5F, 0x00, 0x2E, 0x00, 0x20, 0x00,
	0x60, 0x00, 0x2D, 0x00, 0x2E, 0x00, 0x5F, 0x00, 0x20, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x60, 0x00, 0x2E, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x60, 0x00, 0x2D, 0x00, 0x2E, 0x00, 0x2D, 0x00, 0x27, 0x00, 0x27, 0x00, 0x20, 0x00, 0x20, 0x00, 0x5F, 0x00, 0x5F, 0x00, 0x2C, 0x00, 0x2D, 0x00,
	0x27, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x60, 0x00, 0x2E, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x5F, 0x00,
	0x2C, 0x00, 0x2D, 0x00, 0x27, 0x00, 0x22, 0x00, 0x00
};
```

`SplashScreen.h`:

```h
#pragma once
unsigned char AsciiArt[1473];
```

`UefiMain.c`:

```c
#include "BootMgfw.h"
#include "SplashScreen.h"

CHAR8* gEfiCallerBaseName = "Voyager";
const UINT32 _gUefiDriverRevision = 0x200;

EFI_STATUS EFIAPI UefiUnload(EFI_HANDLE ImageHandle)
{
    return EFI_SUCCESS;
}

EFI_STATUS EFIAPI UefiMain(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE* SystemTable)
{
    EFI_STATUS Result;
    EFI_HANDLE BootMgfwHandle;
    EFI_DEVICE_PATH* BootMgfwPath = NULL;

    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->OutputString(gST->ConOut, AsciiArt);
    Print(L"\n");

    // since we replaced bootmgfw on disk, we are going to need to restore the image back
    // this is simply just moving bootmgfw.efi.backup to bootmgfw.efi...
    // x64-86
    if (EFI_ERROR((Result = RestoreBootMgfw())))
    {
        Print(L"unable to restore bootmgfw... reason -> %r\n", Result);
        gBS->Stall(SEC_TO_MS(5));
        return Result;
    }

    // the payload is sitting on disk... we are going to load it into memory then delete it...
    if (EFI_ERROR((Result = LoadPayLoadFromDisk(&PayLoad))))
    {
        Print(L"failed to read payload from disk... reason -> %r\n", Result);
        gBS->Stall(SEC_TO_MS(5));
        return Result;
    }

    // get the device path to bootmgfw...
    if (EFI_ERROR((Result = GetBootMgfwPath(&BootMgfwPath))))
    {
        Print(L"getting bootmgfw device path failed... reason -> %r\n", Result);
        gBS->Stall(SEC_TO_MS(5));
        return Result;
    }

    // load bootmgfw into memory...
    if (EFI_ERROR((Result = gBS->LoadImage(TRUE, ImageHandle, BootMgfwPath, NULL, NULL, &BootMgfwHandle))))
    {
        Print(L"failed to load bootmgfw.efi... reason -> %r\n", Result);
        gBS->Stall(SEC_TO_MS(5));
        return EFI_ABORTED;
    }

    // install hooks on bootmgfw...
    if (EFI_ERROR((Result = InstallBootMgfwHooks(BootMgfwHandle))))
    {
        Print(L"Failed to install bootmgfw hooks... reason -> %r\n", Result);
        gBS->Stall(SEC_TO_MS(5));
        return Result;
    }

    // wait 5 seconds then call the entry point of bootmgfw...
    gBS->Stall(SEC_TO_MS(5));
    if (EFI_ERROR((Result = gBS->StartImage(BootMgfwHandle, NULL, NULL))))
    {
        Print(L"Failed to start bootmgfw.efi... reason -> %r\n", Result);
        gBS->Stall(SEC_TO_MS(5));
        return EFI_ABORTED;
    }
    return EFI_SUCCESS;
}

```

`Utils.c`:

```c
#include "Utils.h"

BOOLEAN CheckMask(CHAR8* base, CHAR8* pattern, CHAR8* mask)
{
	for (; *mask; ++base, ++pattern, ++mask)
		if (*mask == 'x' && *base != *pattern)
			return FALSE;

	return TRUE;
}

VOID* FindPattern(CHAR8* base, UINTN size, CHAR8* pattern, CHAR8* mask)
{
	size -= AsciiStrLen(mask);
	for (UINTN i = 0; i <= size; ++i)
	{
		VOID* addr = &base[i];
		if (CheckMask(addr, pattern, mask))
			return addr;
	}
	return NULL;
}

VOID* GetExport(UINT8* ModuleBase, CHAR8* export)
{
	EFI_IMAGE_DOS_HEADER* dosHeaders = (EFI_IMAGE_DOS_HEADER*)ModuleBase;
	if (dosHeaders->e_magic != EFI_IMAGE_DOS_SIGNATURE)
		return NULL;

	EFI_IMAGE_NT_HEADERS64* ntHeaders = (EFI_IMAGE_NT_HEADERS64*)(ModuleBase + dosHeaders->e_lfanew);
	UINT32 exportsRva = ntHeaders->OptionalHeader.DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	EFI_IMAGE_EXPORT_DIRECTORY* exports = (EFI_IMAGE_EXPORT_DIRECTORY*)(ModuleBase + exportsRva);
	UINT32* nameRva = (UINT32*)(ModuleBase + exports->AddressOfNames);

	for (UINT32 i = 0; i < exports->NumberOfNames; ++i)
	{
		CHAR8* func = (CHAR8*)(ModuleBase + nameRva[i]);
		if (AsciiStrCmp(func, export) == 0)
		{
			UINT32* funcRva = (UINT32*)(ModuleBase + exports->AddressOfFunctions);
			UINT16* ordinalRva = (UINT16*)(ModuleBase + exports->AddressOfNameOrdinals);
			return (VOID*)(((UINT64)ModuleBase) + funcRva[ordinalRva[i]]);
		}
	}
	return NULL;
}

VOID MemCopy(VOID* dest, VOID* src, UINTN size) 
{
	for (UINT8* d = dest, *s = src; size--; *d++ = *s++);
}
```

`Utils.h`:

```h
#pragma once
#include <Uefi.h>
#include <Library/UefiLib.h>
#include <Library/DebugLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Library/UefiRuntimeServicesTableLib.h>
#include <Library/DevicePathLib.h>
#include <Library/PrintLib.h>
#include <Protocol/SimpleFileSystem.h>
#include <Protocol/LoadedImage.h>
#include <IndustryStandard/PeImage.h>
#include <Guid/GlobalVariable.h>

#define PORT_NUM 0x2F8
#define BL_MEMORY_ATTRIBUTE_RWX 0x424000
#define SEC_TO_MS(seconds) seconds * 1000000
#define SECTION_RWX (EFI_IMAGE_SCN_MEM_READ | EFI_IMAGE_SCN_MEM_WRITE | EFI_IMAGE_SCN_MEM_EXECUTE)

void __outdword(unsigned short, unsigned long);
VOID __outbytestring(UINT16 Port, UINT8* Buffer, UINT32 Count);
void __outbyte(unsigned short Port, unsigned char Data);
#pragma intrinsic(__outbytestring)
#pragma intrinsic(__outbyte)

static CHAR8 dbg_buffer[0x100];
#define DBG_PRINT(...) \
	AsciiSPrint(dbg_buffer, sizeof dbg_buffer, __VA_ARGS__); \
	__outbytestring(PORT_NUM, dbg_buffer, AsciiStrLen(dbg_buffer))

#define RESOLVE_RVA(SIG_RESULT, RIP_OFFSET, RVA_OFFSET) \
	(*(INT32*)(((UINT64)SIG_RESULT) + RVA_OFFSET)) + ((UINT64)SIG_RESULT) + RIP_OFFSET

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;	// 16
	LIST_ENTRY InMemoryOrderLinks;	// 32
	LIST_ENTRY InInitializationOrderLinks; // 48
	UINT64 ModuleBase; // 56
	UINT64 EntryPoint; // 64
	UINTN SizeOfImage; // 72
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY, **PPLDR_DATA_TABLE_ENTRY;

// taken from umap (btbd)
BOOLEAN CheckMask(CHAR8* base, CHAR8* pattern, CHAR8* mask);
VOID* FindPattern(CHAR8* base, UINTN size, CHAR8* pattern, CHAR8* mask);
VOID* GetExport(UINT8* base, CHAR8* export);
VOID MemCopy(VOID* dest, VOID* src, UINTN size);
```

`Voyager.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30503.244
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PayLoad (Intel)", "PayLoad (Intel)\PayLoad (Intel).vcxproj", "{223D1FDE-331E-4028-9083-1673A5161C99}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PayLoad (AMD)", "PayLoad (AMD)\PayLoad (AMD).vcxproj", "{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Voyager", "Voyager\Voyager.vcxproj", "{540D433F-C2DF-49A6-895C-F5C74B014777}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "example", "example\example.vcxproj", "{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libvoyager", "libvoyager\libvoyager.vcxproj", "{F468E79E-CC93-4A7F-844E-984117B5B08B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		1507|x64 = 1507|x64
		1511|x64 = 1511|x64
		1607|x64 = 1607|x64
		1703|x64 = 1703|x64
		1709|x64 = 1709|x64
		1803|x64 = 1803|x64
		1809|x64 = 1809|x64
		1903|x64 = 1903|x64
		1909|x64 = 1909|x64
		2004|x64 = 2004|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{223D1FDE-331E-4028-9083-1673A5161C99}.1507|x64.ActiveCfg = 1507|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.1507|x64.Build.0 = 1507|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.1511|x64.ActiveCfg = 1511|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.1511|x64.Build.0 = 1511|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.1511|x64.Deploy.0 = 1511|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.1607|x64.ActiveCfg = 1607|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.1607|x64.Build.0 = 1607|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.1703|x64.ActiveCfg = 1703|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.1703|x64.Build.0 = 1703|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.1709|x64.ActiveCfg = 1709|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.1709|x64.Build.0 = 1709|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.1803|x64.ActiveCfg = 1803|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.1803|x64.Build.0 = 1803|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.1809|x64.ActiveCfg = 1809|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.1809|x64.Build.0 = 1809|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.1903|x64.ActiveCfg = 1903|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.1903|x64.Build.0 = 1903|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.1909|x64.ActiveCfg = 1909|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.1909|x64.Build.0 = 1909|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.2004|x64.ActiveCfg = 2004|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.2004|x64.Build.0 = 2004|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.Release|x64.ActiveCfg = 2004|x64
		{223D1FDE-331E-4028-9083-1673A5161C99}.Release|x64.Build.0 = 2004|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.1507|x64.ActiveCfg = 1507|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.1507|x64.Build.0 = 1507|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.1511|x64.ActiveCfg = 1511|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.1511|x64.Build.0 = 1511|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.1607|x64.ActiveCfg = 1607|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.1607|x64.Build.0 = 1607|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.1703|x64.ActiveCfg = 1703|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.1703|x64.Build.0 = 1703|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.1709|x64.ActiveCfg = 1709|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.1709|x64.Build.0 = 1709|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.1803|x64.ActiveCfg = 1803|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.1803|x64.Build.0 = 1803|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.1809|x64.ActiveCfg = 1809|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.1809|x64.Build.0 = 1809|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.1903|x64.ActiveCfg = 1903|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.1903|x64.Build.0 = 1903|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.1909|x64.ActiveCfg = 1909|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.1909|x64.Build.0 = 1909|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.2004|x64.ActiveCfg = 2004|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.2004|x64.Build.0 = 2004|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.Release|x64.ActiveCfg = 2004|x64
		{C5122D8B-DEC8-458F-9342-3A4AC3152BEF}.Release|x64.Build.0 = 2004|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.1507|x64.ActiveCfg = 1507|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.1507|x64.Build.0 = 1507|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.1511|x64.ActiveCfg = 1511|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.1511|x64.Build.0 = 1511|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.1607|x64.ActiveCfg = 1607|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.1607|x64.Build.0 = 1607|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.1703|x64.ActiveCfg = 1703|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.1703|x64.Build.0 = 1703|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.1709|x64.ActiveCfg = 1709|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.1709|x64.Build.0 = 1709|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.1803|x64.ActiveCfg = 1803|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.1803|x64.Build.0 = 1803|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.1809|x64.ActiveCfg = 1809|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.1809|x64.Build.0 = 1809|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.1903|x64.ActiveCfg = 1903|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.1903|x64.Build.0 = 1903|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.1909|x64.ActiveCfg = 1909|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.1909|x64.Build.0 = 1909|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.2004|x64.ActiveCfg = 2004|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.2004|x64.Build.0 = 2004|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.Release|x64.ActiveCfg = 2004|x64
		{540D433F-C2DF-49A6-895C-F5C74B014777}.Release|x64.Build.0 = 2004|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.1507|x64.ActiveCfg = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.1507|x64.Build.0 = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.1511|x64.ActiveCfg = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.1511|x64.Build.0 = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.1607|x64.ActiveCfg = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.1607|x64.Build.0 = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.1703|x64.ActiveCfg = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.1703|x64.Build.0 = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.1709|x64.ActiveCfg = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.1709|x64.Build.0 = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.1803|x64.ActiveCfg = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.1803|x64.Build.0 = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.1809|x64.ActiveCfg = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.1809|x64.Build.0 = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.1903|x64.ActiveCfg = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.1903|x64.Build.0 = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.1909|x64.ActiveCfg = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.1909|x64.Build.0 = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.2004|x64.ActiveCfg = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.2004|x64.Build.0 = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.Release|x64.ActiveCfg = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.Release|x64.Build.0 = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.1507|x64.ActiveCfg = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.1507|x64.Build.0 = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.1511|x64.ActiveCfg = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.1511|x64.Build.0 = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.1607|x64.ActiveCfg = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.1607|x64.Build.0 = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.1703|x64.ActiveCfg = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.1703|x64.Build.0 = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.1709|x64.ActiveCfg = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.1709|x64.Build.0 = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.1803|x64.ActiveCfg = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.1803|x64.Build.0 = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.1809|x64.ActiveCfg = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.1809|x64.Build.0 = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.1903|x64.ActiveCfg = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.1903|x64.Build.0 = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.1909|x64.ActiveCfg = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.1909|x64.Build.0 = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.2004|x64.ActiveCfg = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.2004|x64.Build.0 = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.Release|x64.ActiveCfg = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {8471BE1E-8BEA-4731-A57A-A1569FF59915}
	EndGlobalSection
EndGlobal

```

`Voyager.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="1507|x64">
      <Configuration>1507</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1511|x64">
      <Configuration>1511</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1607|x64">
      <Configuration>1607</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1703|x64">
      <Configuration>1703</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1709|x64">
      <Configuration>1709</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1803|x64">
      <Configuration>1803</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1809|x64">
      <Configuration>1809</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1903|x64">
      <Configuration>1903</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="1909|x64">
      <Configuration>1909</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="2004|x64">
      <Configuration>2004</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{540d433f-c2df-49a6-895c-f5c74b014777}</ProjectGuid>
    <RootNamespace>HyperMe</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>Voyager</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1909|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PreferredToolArchitecture>x86</PreferredToolArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1903|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PreferredToolArchitecture>x86</PreferredToolArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1809|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PreferredToolArchitecture>x86</PreferredToolArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1803|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PreferredToolArchitecture>x86</PreferredToolArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1709|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PreferredToolArchitecture>x86</PreferredToolArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1703|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PreferredToolArchitecture>x86</PreferredToolArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1607|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PreferredToolArchitecture>x86</PreferredToolArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PreferredToolArchitecture>x86</PreferredToolArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1507|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PreferredToolArchitecture>x86</PreferredToolArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='2004|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PreferredToolArchitecture>x86</PreferredToolArchitecture>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='1909|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='1903|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='1809|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='1803|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='1709|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='1703|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='1607|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='1507|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='2004|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1909|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(ProjectDir)edk2\CryptoPkg\Include;$(ProjectDir)edk2\ShellPkg\Include;$(ProjectDir)edk2\MdePkg\Include\X64;$(ProjectDir)edk2\MdePkg\Include;$(ProjectDir)edk2\StdLib\Include;$(ProjectDir)</IncludePath>
    <LibraryPath>$(ProjectDir)edk2</LibraryPath>
    <GenerateManifest>false</GenerateManifest>
    <TargetExt>.efi</TargetExt>
    <SourcePath>$(ProjectDir)</SourcePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1903|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(ProjectDir)edk2\CryptoPkg\Include;$(ProjectDir)edk2\ShellPkg\Include;$(ProjectDir)edk2\MdePkg\Include\X64;$(ProjectDir)edk2\MdePkg\Include;$(ProjectDir)edk2\StdLib\Include;$(ProjectDir)</IncludePath>
    <LibraryPath>$(ProjectDir)edk2</LibraryPath>
    <GenerateManifest>false</GenerateManifest>
    <TargetExt>.efi</TargetExt>
    <SourcePath>$(ProjectDir)</SourcePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1809|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(ProjectDir)edk2\CryptoPkg\Include;$(ProjectDir)edk2\ShellPkg\Include;$(ProjectDir)edk2\MdePkg\Include\X64;$(ProjectDir)edk2\MdePkg\Include;$(ProjectDir)edk2\StdLib\Include;$(ProjectDir)</IncludePath>
    <LibraryPath>$(ProjectDir)edk2</LibraryPath>
    <GenerateManifest>false</GenerateManifest>
    <TargetExt>.efi</TargetExt>
    <SourcePath>$(ProjectDir)</SourcePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1803|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(ProjectDir)edk2\CryptoPkg\Include;$(ProjectDir)edk2\ShellPkg\Include;$(ProjectDir)edk2\MdePkg\Include\X64;$(ProjectDir)edk2\MdePkg\Include;$(ProjectDir)edk2\StdLib\Include;$(ProjectDir)</IncludePath>
    <LibraryPath>$(ProjectDir)edk2</LibraryPath>
    <GenerateManifest>false</GenerateManifest>
    <TargetExt>.efi</TargetExt>
    <SourcePath>$(ProjectDir)</SourcePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1709|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(ProjectDir)edk2\CryptoPkg\Include;$(ProjectDir)edk2\ShellPkg\Include;$(ProjectDir)edk2\MdePkg\Include\X64;$(ProjectDir)edk2\MdePkg\Include;$(ProjectDir)edk2\StdLib\Include;$(ProjectDir)</IncludePath>
    <LibraryPath>$(ProjectDir)edk2</LibraryPath>
    <GenerateManifest>false</GenerateManifest>
    <TargetExt>.efi</TargetExt>
    <SourcePath>$(ProjectDir)</SourcePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1703|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(ProjectDir)edk2\CryptoPkg\Include;$(ProjectDir)edk2\ShellPkg\Include;$(ProjectDir)edk2\MdePkg\Include\X64;$(ProjectDir)edk2\MdePkg\Include;$(ProjectDir)edk2\StdLib\Include;$(ProjectDir)</IncludePath>
    <LibraryPath>$(ProjectDir)edk2</LibraryPath>
    <GenerateManifest>false</GenerateManifest>
    <TargetExt>.efi</TargetExt>
    <SourcePath>$(ProjectDir)</SourcePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1607|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(ProjectDir)edk2\CryptoPkg\Include;$(ProjectDir)edk2\ShellPkg\Include;$(ProjectDir)edk2\MdePkg\Include\X64;$(ProjectDir)edk2\MdePkg\Include;$(ProjectDir)edk2\StdLib\Include;$(ProjectDir)</IncludePath>
    <LibraryPath>$(ProjectDir)edk2</LibraryPath>
    <GenerateManifest>false</GenerateManifest>
    <TargetExt>.efi</TargetExt>
    <SourcePath>$(ProjectDir)</SourcePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(ProjectDir)edk2\CryptoPkg\Include;$(ProjectDir)edk2\ShellPkg\Include;$(ProjectDir)edk2\MdePkg\Include\X64;$(ProjectDir)edk2\MdePkg\Include;$(ProjectDir)edk2\StdLib\Include;$(ProjectDir)</IncludePath>
    <LibraryPath>$(ProjectDir)edk2</LibraryPath>
    <GenerateManifest>false</GenerateManifest>
    <TargetExt>.efi</TargetExt>
    <SourcePath>$(ProjectDir)</SourcePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='1507|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(ProjectDir)edk2\CryptoPkg\Include;$(ProjectDir)edk2\ShellPkg\Include;$(ProjectDir)edk2\MdePkg\Include\X64;$(ProjectDir)edk2\MdePkg\Include;$(ProjectDir)edk2\StdLib\Include;$(ProjectDir)</IncludePath>
    <LibraryPath>$(ProjectDir)edk2</LibraryPath>
    <GenerateManifest>false</GenerateManifest>
    <TargetExt>.efi</TargetExt>
    <SourcePath>$(ProjectDir)</SourcePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='2004|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(ProjectDir)edk2\CryptoPkg\Include;$(ProjectDir)edk2\ShellPkg\Include;$(ProjectDir)edk2\MdePkg\Include\X64;$(ProjectDir)edk2\MdePkg\Include;$(ProjectDir)edk2\StdLib\Include;$(ProjectDir)</IncludePath>
    <LibraryPath>$(ProjectDir)edk2</LibraryPath>
    <GenerateManifest>false</GenerateManifest>
    <TargetExt>.efi</TargetExt>
    <SourcePath>$(ProjectDir)</SourcePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1909|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;WINVER=1909;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>SyncCThrow</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <Optimization>Disabled</Optimization>
      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
    </ClCompile>
    <Link>
      <SubSystem>EFI Application</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <AdditionalDependencies>UefiHiiLib.lib;UefiHiiServicesLib.lib;UefiSortLib.lib;UefiShellLib.lib;GlueLib.lib;BaseLib.lib;BaseDebugPrintErrorLevelLib.lib;BasePrintLib.lib;UefiLib.lib;UefiBootServicesTableLib.lib;UefiRuntimeServicesTableLib.lib;UefiDevicePathLibDevicePathProtocol.lib;UefiDebugLibConOut.lib;UefiMemoryLib.lib;UefiMemoryAllocationLib.lib;BaseSynchronizationLib.lib;UefiFileHandleLib.lib;UefiApplicationEntryPoint.lib</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>EfiMain</EntryPointSymbol>
      <GenerateMapFile>true</GenerateMapFile>
      <MapFileName>Voyager.map</MapFileName>
      <MapExports>true</MapExports>
    </Link>
    <ProjectReference>
      <UseLibraryDependencyInputs>true</UseLibraryDependencyInputs>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1903|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;WINVER=1903;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>SyncCThrow</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <Optimization>Disabled</Optimization>
      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
    </ClCompile>
    <Link>
      <SubSystem>EFI Application</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <AdditionalDependencies>UefiHiiLib.lib;UefiHiiServicesLib.lib;UefiSortLib.lib;UefiShellLib.lib;GlueLib.lib;BaseLib.lib;BaseDebugPrintErrorLevelLib.lib;BasePrintLib.lib;UefiLib.lib;UefiBootServicesTableLib.lib;UefiRuntimeServicesTableLib.lib;UefiDevicePathLibDevicePathProtocol.lib;UefiDebugLibConOut.lib;UefiMemoryLib.lib;UefiMemoryAllocationLib.lib;BaseSynchronizationLib.lib;UefiFileHandleLib.lib;UefiApplicationEntryPoint.lib</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>EfiMain</EntryPointSymbol>
      <GenerateMapFile>true</GenerateMapFile>
      <MapFileName>Voyager.map</MapFileName>
      <MapExports>true</MapExports>
    </Link>
    <ProjectReference>
      <UseLibraryDependencyInputs>true</UseLibraryDependencyInputs>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1809|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;WINVER=1809;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>SyncCThrow</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <Optimization>Disabled</Optimization>
      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
    </ClCompile>
    <Link>
      <SubSystem>EFI Application</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <AdditionalDependencies>UefiHiiLib.lib;UefiHiiServicesLib.lib;UefiSortLib.lib;UefiShellLib.lib;GlueLib.lib;BaseLib.lib;BaseDebugPrintErrorLevelLib.lib;BasePrintLib.lib;UefiLib.lib;UefiBootServicesTableLib.lib;UefiRuntimeServicesTableLib.lib;UefiDevicePathLibDevicePathProtocol.lib;UefiDebugLibConOut.lib;UefiMemoryLib.lib;UefiMemoryAllocationLib.lib;BaseSynchronizationLib.lib;UefiFileHandleLib.lib;UefiApplicationEntryPoint.lib</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>EfiMain</EntryPointSymbol>
      <GenerateMapFile>true</GenerateMapFile>
      <MapFileName>Voyager.map</MapFileName>
      <MapExports>true</MapExports>
    </Link>
    <ProjectReference>
      <UseLibraryDependencyInputs>true</UseLibraryDependencyInputs>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1803|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;WINVER=1803;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>SyncCThrow</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <Optimization>Disabled</Optimization>
      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
    </ClCompile>
    <Link>
      <SubSystem>EFI Application</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <AdditionalDependencies>UefiHiiLib.lib;UefiHiiServicesLib.lib;UefiSortLib.lib;UefiShellLib.lib;GlueLib.lib;BaseLib.lib;BaseDebugPrintErrorLevelLib.lib;BasePrintLib.lib;UefiLib.lib;UefiBootServicesTableLib.lib;UefiRuntimeServicesTableLib.lib;UefiDevicePathLibDevicePathProtocol.lib;UefiDebugLibConOut.lib;UefiMemoryLib.lib;UefiMemoryAllocationLib.lib;BaseSynchronizationLib.lib;UefiFileHandleLib.lib;UefiApplicationEntryPoint.lib</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>EfiMain</EntryPointSymbol>
      <GenerateMapFile>true</GenerateMapFile>
      <MapFileName>Voyager.map</MapFileName>
      <MapExports>true</MapExports>
    </Link>
    <ProjectReference>
      <UseLibraryDependencyInputs>true</UseLibraryDependencyInputs>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1709|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;WINVER=1709;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>SyncCThrow</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <Optimization>Disabled</Optimization>
      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
    </ClCompile>
    <Link>
      <SubSystem>EFI Application</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <AdditionalDependencies>UefiHiiLib.lib;UefiHiiServicesLib.lib;UefiSortLib.lib;UefiShellLib.lib;GlueLib.lib;BaseLib.lib;BaseDebugPrintErrorLevelLib.lib;BasePrintLib.lib;UefiLib.lib;UefiBootServicesTableLib.lib;UefiRuntimeServicesTableLib.lib;UefiDevicePathLibDevicePathProtocol.lib;UefiDebugLibConOut.lib;UefiMemoryLib.lib;UefiMemoryAllocationLib.lib;BaseSynchronizationLib.lib;UefiFileHandleLib.lib;UefiApplicationEntryPoint.lib</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>EfiMain</EntryPointSymbol>
      <GenerateMapFile>true</GenerateMapFile>
      <MapFileName>Voyager.map</MapFileName>
      <MapExports>true</MapExports>
    </Link>
    <ProjectReference>
      <UseLibraryDependencyInputs>true</UseLibraryDependencyInputs>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1703|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;WINVER=1703;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>SyncCThrow</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <Optimization>Disabled</Optimization>
      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
    </ClCompile>
    <Link>
      <SubSystem>EFI Application</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <AdditionalDependencies>UefiHiiLib.lib;UefiHiiServicesLib.lib;UefiSortLib.lib;UefiShellLib.lib;GlueLib.lib;BaseLib.lib;BaseDebugPrintErrorLevelLib.lib;BasePrintLib.lib;UefiLib.lib;UefiBootServicesTableLib.lib;UefiRuntimeServicesTableLib.lib;UefiDevicePathLibDevicePathProtocol.lib;UefiDebugLibConOut.lib;UefiMemoryLib.lib;UefiMemoryAllocationLib.lib;BaseSynchronizationLib.lib;UefiFileHandleLib.lib;UefiApplicationEntryPoint.lib</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>EfiMain</EntryPointSymbol>
      <GenerateMapFile>true</GenerateMapFile>
      <MapFileName>Voyager.map</MapFileName>
      <MapExports>true</MapExports>
    </Link>
    <ProjectReference>
      <UseLibraryDependencyInputs>true</UseLibraryDependencyInputs>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1607|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;WINVER=1607;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>SyncCThrow</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <Optimization>Disabled</Optimization>
      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
    </ClCompile>
    <Link>
      <SubSystem>EFI Application</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <AdditionalDependencies>UefiHiiLib.lib;UefiHiiServicesLib.lib;UefiSortLib.lib;UefiShellLib.lib;GlueLib.lib;BaseLib.lib;BaseDebugPrintErrorLevelLib.lib;BasePrintLib.lib;UefiLib.lib;UefiBootServicesTableLib.lib;UefiRuntimeServicesTableLib.lib;UefiDevicePathLibDevicePathProtocol.lib;UefiDebugLibConOut.lib;UefiMemoryLib.lib;UefiMemoryAllocationLib.lib;BaseSynchronizationLib.lib;UefiFileHandleLib.lib;UefiApplicationEntryPoint.lib</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>EfiMain</EntryPointSymbol>
      <GenerateMapFile>true</GenerateMapFile>
      <MapFileName>Voyager.map</MapFileName>
      <MapExports>true</MapExports>
    </Link>
    <ProjectReference>
      <UseLibraryDependencyInputs>true</UseLibraryDependencyInputs>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1511|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;WINVER=1511;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>SyncCThrow</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <Optimization>Disabled</Optimization>
      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
    </ClCompile>
    <Link>
      <SubSystem>EFI Application</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <AdditionalDependencies>UefiHiiLib.lib;UefiHiiServicesLib.lib;UefiSortLib.lib;UefiShellLib.lib;GlueLib.lib;BaseLib.lib;BaseDebugPrintErrorLevelLib.lib;BasePrintLib.lib;UefiLib.lib;UefiBootServicesTableLib.lib;UefiRuntimeServicesTableLib.lib;UefiDevicePathLibDevicePathProtocol.lib;UefiDebugLibConOut.lib;UefiMemoryLib.lib;UefiMemoryAllocationLib.lib;BaseSynchronizationLib.lib;UefiFileHandleLib.lib;UefiApplicationEntryPoint.lib</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>EfiMain</EntryPointSymbol>
      <GenerateMapFile>true</GenerateMapFile>
      <MapFileName>Voyager.map</MapFileName>
      <MapExports>true</MapExports>
    </Link>
    <ProjectReference>
      <UseLibraryDependencyInputs>true</UseLibraryDependencyInputs>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='1507|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;WINVER=1507;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>SyncCThrow</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <Optimization>Disabled</Optimization>
      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
    </ClCompile>
    <Link>
      <SubSystem>EFI Application</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <AdditionalDependencies>UefiHiiLib.lib;UefiHiiServicesLib.lib;UefiSortLib.lib;UefiShellLib.lib;GlueLib.lib;BaseLib.lib;BaseDebugPrintErrorLevelLib.lib;BasePrintLib.lib;UefiLib.lib;UefiBootServicesTableLib.lib;UefiRuntimeServicesTableLib.lib;UefiDevicePathLibDevicePathProtocol.lib;UefiDebugLibConOut.lib;UefiMemoryLib.lib;UefiMemoryAllocationLib.lib;BaseSynchronizationLib.lib;UefiFileHandleLib.lib;UefiApplicationEntryPoint.lib</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>EfiMain</EntryPointSymbol>
      <GenerateMapFile>true</GenerateMapFile>
      <MapFileName>Voyager.map</MapFileName>
      <MapExports>true</MapExports>
    </Link>
    <ProjectReference>
      <UseLibraryDependencyInputs>true</UseLibraryDependencyInputs>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='2004|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;WINVER=2004;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>SyncCThrow</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <Optimization>Disabled</Optimization>
      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
    </ClCompile>
    <Link>
      <SubSystem>EFI Application</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <AdditionalDependencies>UefiHiiLib.lib;UefiHiiServicesLib.lib;UefiSortLib.lib;UefiShellLib.lib;GlueLib.lib;BaseLib.lib;BaseDebugPrintErrorLevelLib.lib;BasePrintLib.lib;UefiLib.lib;UefiBootServicesTableLib.lib;UefiRuntimeServicesTableLib.lib;UefiDevicePathLibDevicePathProtocol.lib;UefiDebugLibConOut.lib;UefiMemoryLib.lib;UefiMemoryAllocationLib.lib;BaseSynchronizationLib.lib;UefiFileHandleLib.lib;UefiApplicationEntryPoint.lib</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>EfiMain</EntryPointSymbol>
      <GenerateMapFile>true</GenerateMapFile>
      <MapFileName>
      </MapFileName>
      <MapExports>true</MapExports>
    </Link>
    <ProjectReference>
      <UseLibraryDependencyInputs>true</UseLibraryDependencyInputs>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="BootMgfw.c" />
    <ClCompile Include="Hv.c" />
    <ClCompile Include="HvLoader.c" />
    <ClCompile Include="InlineHook.c" />
    <ClCompile Include="PayLoad.c" />
    <ClCompile Include="SplashScreen.c" />
    <ClCompile Include="UefiMain.c" />
    <ClCompile Include="Utils.c" />
    <ClCompile Include="WinLoad.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="BootMgfw.h" />
    <ClInclude Include="Hv.h" />
    <ClInclude Include="HvLoader.h" />
    <ClInclude Include="PagingTables.h" />
    <ClInclude Include="InlineHook.h" />
    <ClInclude Include="PayLoad.h" />
    <ClInclude Include="SplashScreen.h" />
    <ClInclude Include="Utils.h" />
    <ClInclude Include="WinLoad.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Voyager.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="UefiMain.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="WinLoad.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="BootMgfw.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PayLoad.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SplashScreen.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HvLoader.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Hv.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="InlineHook.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="BootMgfw.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="WinLoad.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PayLoad.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="SplashScreen.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="HvLoader.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Hv.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PagingTables.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="InlineHook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Voyager.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`WinLoad.c`:

```c
#include "WinLoad.h"

INLINE_HOOK WinLoadImageShitHook;
INLINE_HOOK WinLoadAllocateImageHook;

BOOLEAN HyperVloading = FALSE;
BOOLEAN InstalledHvLoaderHook = FALSE;

BOOLEAN ExtendedAllocation = FALSE;
BOOLEAN HookedHyperV = FALSE;
UINT64 AllocationCount = 0;

EFI_STATUS EFIAPI BlLdrLoadImage
(
	VOID* Arg1,
	CHAR16* ModulePath, 
	CHAR16* ModuleName,
	VOID* Arg4,
	VOID* Arg5, 
	VOID* Arg6, 
	VOID* Arg7, 
	PPLDR_DATA_TABLE_ENTRY lplpTableEntry,
	VOID* Arg9,
	VOID* Arg10,
	VOID* Arg11, 
	VOID* Arg12,
	VOID* Arg13,
	VOID* Arg14,
	VOID* Arg15,
	VOID* Arg16
)
{
	if (!StrCmp(ModuleName, L"hv.exe"))
		HyperVloading = TRUE;

	// disable shithook and call the original function...
	DisableInlineHook(&WinLoadImageShitHook);
	EFI_STATUS Result = ((LDR_LOAD_IMAGE)WinLoadImageShitHook.Address)
	(
		Arg1,
		ModulePath, 
		ModuleName, 
		Arg4,
		Arg5,
		Arg6,
		Arg7,
		lplpTableEntry,
		Arg9,
		Arg10, 
		Arg11,
		Arg12,
		Arg13,
		Arg14,
		Arg15, 
		Arg16
	);

	// continue hooking until we inject/hook into hyper-v...
	if (!HookedHyperV)
		EnableInlineHook(&WinLoadImageShitHook);

	if (!StrCmp(ModuleName, L"hv.exe"))
	{
		HookedHyperV = TRUE;
		VOYAGER_T VoyagerData;
		PLDR_DATA_TABLE_ENTRY TableEntry = *lplpTableEntry;

		// add a new section to hyper-v called "payload", then fill in voyager data
		// and hook the vmexit handler...
		MakeVoyagerData
		(
			&VoyagerData, 
			TableEntry->ModuleBase,
			TableEntry->SizeOfImage, 
			AddSection
			(
				TableEntry->ModuleBase,
				"payload",
				PayLoadSize(),
				SECTION_RWX
			),
			PayLoadSize()
		);

		HookVmExit
		(
			VoyagerData.HypervModuleBase,
			VoyagerData.HypervModuleSize,
			MapModule(&VoyagerData, PayLoad)
		);

		// extend the size of the image in hyper-v's nt headers and LDR data entry...
		// this is required, if this is not done, then hyper-v will simply not be loaded...
		TableEntry->SizeOfImage = NT_HEADER(TableEntry->ModuleBase)->OptionalHeader.SizeOfImage;
	}
	return Result;
}

EFI_STATUS EFIAPI BlImgLoadPEImageEx
(
	VOID* a1,
	VOID* a2,
	CHAR16* ImagePath,
	UINT64* ImageBasePtr,
	UINT32* ImageSize,
	VOID* a6,
	VOID* a7,
	VOID* a8,
	VOID* a9, 
	VOID* a10,
	VOID* a11,
	VOID* a12,
	VOID* a13, 
	VOID* a14
)
{
	// disable shithook and call the original function...
	DisableInlineHook(&WinLoadImageShitHook);
	EFI_STATUS Result = ((LDR_LOAD_IMAGE)WinLoadImageShitHook.Address)
	(
		a1,
		a2, 
		ImagePath,
		ImageBasePtr,
		ImageSize,
		a6,
		a7, 
		a8,
		a9, 
		a10, 
		a11,
		a12, 
		a13, 
		a14
	);

	// continue hooking BlImgLoadPEImageEx until we have shithooked hvloader...
	if (!InstalledHvLoaderHook)
		EnableInlineHook(&WinLoadImageShitHook);

	if (StrStr(ImagePath, L"hvloader.efi"))
	{
#if WINVER == 1703
		VOID* LoadImage =
			FindPattern(
				*ImageBasePtr,
				*ImageSize,
				HV_LOAD_PE_IMG_FROM_BUFFER_SIG,
				HV_LOAD_PE_IMG_FROM_BUFFER_MASK
			);

#elif WINVER <= 1607 
		VOID* LoadImage =
			FindPattern(
				*ImageBasePtr,
				*ImageSize,
				HV_LOAD_PE_IMG_SIG,
				HV_LOAD_PE_IMG_MASK
			);

#endif
		VOID* AllocImage =
			FindPattern(
				*ImageBasePtr,
				*ImageSize,
				HV_ALLOCATE_IMAGE_BUFFER_SIG,
				HV_ALLOCATE_IMAGE_BUFFER_MASK
			);

#if WINVER == 1703
		MakeInlineHook(&HvLoadImageBufferHook, RESOLVE_RVA(LoadImage, 5, 1), &HvBlImgLoadPEImageFromSourceBuffer, TRUE);
#elif WINVER <= 1607 
		MakeInlineHook(&HvLoadImageHook, RESOLVE_RVA(LoadImage, 10, 6), &HvBlImgLoadPEImageEx, TRUE);
	#endif

		MakeInlineHook(&HvLoadAllocImageHook, RESOLVE_RVA(AllocImage, 5, 1), &HvBlImgAllocateImageBuffer, TRUE);
		InstalledHvLoaderHook = TRUE;
	}
	return Result;
}

UINT64 EFIAPI BlImgAllocateImageBuffer
(
	VOID** imageBuffer,
	UINTN imageSize,
	UINT32 memoryType, 
	UINT32 attributes, 
	VOID* unused, 
	UINT32 Value
)
{
	//
	// The second allocation for hv.exe is used for the actual image... Wait for the second allocation before extending the allocation...
	// these allocations are not subject to change. its not a randomized or controlled order. It is what it is :|
	//
	// hv.exe
	// [BlImgAllocateImageBuffer] Alloc Base -> 0x7FFFF9FE000, Alloc Size -> 0x17C548
	// [BlImgAllocateImageBuffer] Alloc Base -> 0xFFFFF80608120000, Alloc Size -> 0x1600000
	// [BlImgAllocateImageBuffer] Alloc Base -> 0xFFFFF80606D68000, Alloc Size -> 0x2148
	// [BlLdrLoadImage] Image Base -> 0xFFFFF80608120000, Image Size -> 0x1600000
	//

	if (HyperVloading && !ExtendedAllocation && ++AllocationCount == 2)
	{
		ExtendedAllocation = TRUE;
		imageSize += PayLoadSize();

		// allocate the entire hyper-v module as rwx...
		memoryType = BL_MEMORY_ATTRIBUTE_RWX;
	}
	
	// disable shithook and call the original function...
	DisableInlineHook(&WinLoadAllocateImageHook);
	UINT64 Result = ((ALLOCATE_IMAGE_BUFFER)WinLoadAllocateImageHook.Address)
	(
		imageBuffer,
		imageSize,
		memoryType,
		attributes, 
		unused,
		Value
	);

	// keep hooking until we extend an allocation...
	if(!ExtendedAllocation)
		EnableInlineHook(&WinLoadAllocateImageHook);

	return Result;
}
```

`WinLoad.h`:

```h
#pragma once
#include "HvLoader.h"
#include "PayLoad.h"

extern INLINE_HOOK WinLoadImageShitHook;
extern INLINE_HOOK WinLoadAllocateImageHook;

// 2004-1511 winload.BlImgAllocateImageBuffer
#define ALLOCATE_IMAGE_BUFFER_SIG "\xE8\x00\x00\x00\x00\x8B\xD8\x85\xC0\x78\x7C\x21\x7C\x24\x00\x45\x33\xC0"
#define ALLOCATE_IMAGE_BUFFER_MASK "x????xxxxxxxxx?xxx"

// 1703-1511
//
// for 1703-1511, we are going to want to hook BlImgAllocateImageBuffer inside of hvloader.efi
// not winload. We will have to scan for BlImgLoadPEImageEx in winload and then wait for hvloader
// to be loaded to install hooks in hvloader...
#define LOAD_PE_IMG_SIG "\x48\x89\x44\x24\x00\xE8\x00\x00\x00\x00\x44\x8B\xF0\x85\xC0\x79\x11"
#define LOAD_PE_IMG_MASK "xxxx?x????xxxxxxx"

static_assert(sizeof(ALLOCATE_IMAGE_BUFFER_SIG) == sizeof(ALLOCATE_IMAGE_BUFFER_MASK), "signature and mask do not match size!");

typedef UINT64 (EFIAPI* ALLOCATE_IMAGE_BUFFER)(VOID** imageBuffer, UINTN imageSize, UINT32 memoryType, 
	UINT32 attributes, VOID* unused, UINT32 Value);

typedef EFI_STATUS(EFIAPI* LDR_LOAD_IMAGE)(VOID* a1, VOID* a2, CHAR16* ImagePath, UINT64* ImageBasePtr, UINT32* ImageSize,
	VOID* a6, VOID* a7, VOID* a8, VOID* a9, VOID* a10, VOID* a11, VOID* a12, VOID* a13, VOID* a14);

/// <summary>
/// for 1703-1507, we are going to want to install hooks inside 
/// of hvloader.efi... in order to know when hvloader.efi is loaded into memory
/// we are going to install a hook on winload.BlImgLoadPEImageEx...
/// </summary>
/// <param name="a1">unknown</param>
/// <param name="a2">unknown</param>
/// <param name="ImagePath">
/// unicode string path to image being loaded into memory...
/// </param>
/// <param name="ImageBasePtr">
/// pointer to a void pointer which will contain the base 
/// address of the module after its loaded...
/// </param>
/// <param name="ImageSize">pass by ref size of the image loaded into memory...</param>
/// <param name="a6">unknown</param>
/// <param name="a7">unknown</param>
/// <param name="a8">unknown</param>
/// <param name="a9">unknown</param>
/// <param name="a10">unknown</param>
/// <param name="a11">unknown</param>
/// <param name="a12">unknown</param>
/// <param name="a13">unknown</param>
/// <param name="a14">unknown</param>
/// <returns>status of image loaded...</returns>
EFI_STATUS EFIAPI BlImgLoadPEImageEx
(
	VOID* a1,
	VOID* a2,
	CHAR16* ImagePath, 
	UINT64* ImageBasePtr,
	UINT32* ImageSize,
	VOID* a6,
	VOID* a7,
	VOID* a8,
	VOID* a9, 
	VOID* a10, 
	VOID* a11,
	VOID* a12,
	VOID* a13, 
	VOID* a14
);

/// <summary>
/// for 2004-1709, winload exports a bunch of functions... specifically BlLdrLoadImage,
/// which hvloader calls to load hyper-v into memory... BlLdrLoadImage calls BlImgAllocateImageBuffer
/// to allocate memory for hyper-v's module, we are hooking BlImgAllocateImageBuffer to extend
/// the allocations size and to make the entire allocation RWX...
/// </summary>
/// <param name="imageBuffer">pass by ref of a pointer to the allocation base...</param>
/// <param name="imageSize">size of the allocation...</param>
/// <param name="memoryType"></param>
/// <param name="attributes"></param>
/// <param name="unused"></param>
/// <param name="flags"></param>
/// <returns></returns>
EFI_STATUS EFIAPI BlImgAllocateImageBuffer
(
	VOID** imageBuffer,
	UINTN imageSize,
	UINT32 memoryType,
	UINT32 attributes, 
	VOID* unused,
	UINT32 Value
);

/// <summary>
/// 2004-1709, BlLdrLoadImage is exported from winload... I shithook this and
/// when hyper-v is loaded I install my hooks/extend hyper-v's allocation...
/// </summary>
/// <param name="Arg1"></param>
/// <param name="ModulePath"></param>
/// <param name="ModuleName"></param>
/// <param name="Arg4"></param>
/// <param name="Arg5"></param>
/// <param name="Arg6"></param>
/// <param name="Arg7"></param>
/// <param name="lplpTableEntry"></param>
/// <param name="Arg9"></param>
/// <param name="Arg10"></param>
/// <param name="Arg11"></param>
/// <param name="Arg12"></param>
/// <param name="Arg13"></param>
/// <param name="Arg14"></param>
/// <param name="Arg15"></param>
/// <param name="Arg16"></param>
/// <returns></returns>
EFI_STATUS EFIAPI BlLdrLoadImage
(
	VOID* Arg1, 
	CHAR16* ModulePath,
	CHAR16* ModuleName,
	VOID* Arg4,
	VOID* Arg5, 
	VOID* Arg6,
	VOID* Arg7,
	PPLDR_DATA_TABLE_ENTRY lplpTableEntry,
	VOID* Arg9,
	VOID* Arg10, 
	VOID* Arg11,
	VOID* Arg12,
	VOID* Arg13,
	VOID* Arg14,
	VOID* Arg15, 
	VOID* Arg16
);
```

`example/example.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{1770c4fb-345f-40dd-b4a2-2a5dc8a50866}</ProjectGuid>
    <RootNamespace>example</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions);_CRT_SECURE_NO_WARNINGS</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>libvoyager.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="vdm_ctx\vdm_ctx.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="libvoyager.hpp" />
    <ClInclude Include="util\nt.hpp" />
    <ClInclude Include="util\util.hpp" />
    <ClInclude Include="vdm_ctx\vdm_ctx.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`example/example.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Header Files\util">
      <UniqueIdentifier>{a575c9e1-1d0c-410a-8456-2743e2f93f86}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="vdm_ctx\vdm_ctx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="libvoyager.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="util\nt.hpp">
      <Filter>Header Files\util</Filter>
    </ClInclude>
    <ClInclude Include="util\util.hpp">
      <Filter>Header Files\util</Filter>
    </ClInclude>
    <ClInclude Include="vdm_ctx\vdm_ctx.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`example/example.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`example/libvoyager.hpp`:

```hpp
#pragma once
#include <intrin.h>
#include <type_traits>

#define VMEXIT_KEY 0xDEADBEEFDEADBEEF
#define PAGE_4KB 0x1000
#define PAGE_2MB PAGE_4KB * 512
#define PAGE_1GB PAGE_2MB * 512

using u8 = unsigned char;
using u16 = unsigned short;
using u32 = unsigned int;
using u64 = unsigned long long;

namespace voyager
{
	// code comments itself...
	using guest_virt_t = u64;
	using guest_phys_t = u64;
	using host_virt_t = u64;
	using host_phys_t = u64;

	enum class vmexit_command_t
	{
		init_page_tables,
		read_guest_phys,
		write_guest_phys,
		copy_guest_virt,
		get_dirbase,
		translate
	};

	enum class vmxroot_error_t
	{
		error_success,
		pml4e_not_present,
		pdpte_not_present,
		pde_not_present,
		pte_not_present,
		vmxroot_translate_failure,
		invalid_self_ref_pml4e,
		invalid_mapping_pml4e,
		invalid_host_virtual,
		invalid_guest_physical,
		invalid_guest_virtual,
		page_table_init_failed
	};

	typedef union _command_t
	{
		struct _copy_phys
		{
			host_phys_t  phys_addr;
			guest_virt_t buffer;
			u64 size;
		} copy_phys;

		struct _copy_virt
		{
			guest_phys_t dirbase_src;
			guest_virt_t virt_src;
			guest_phys_t dirbase_dest;
			guest_virt_t virt_dest;
			u64 size;
		} copy_virt;

		struct _translate_virt
		{
			guest_virt_t virt_src;
			guest_phys_t phys_addr;
		} translate_virt;

		guest_phys_t dirbase;

	} command_t, * pcommand_t;

	/// <summary>
	/// this function is used to cause a vmexit as though its calling a function...
	/// </summary>
	extern "C" auto hypercall(u64 key, vmexit_command_t, pcommand_t command)->vmxroot_error_t;

	/// <summary>
	/// gets the current cores CR3 value (current address space pml4)...
	/// </summary>
	/// <returns>returns the guest cr3 value...</returns>
	auto current_dirbase()->guest_phys_t;

	/// <summary>
	/// initalizies page tables for all cores...
	/// </summary>
	/// <returns>status of the initalization...</returns>
	auto init()->vmxroot_error_t;

	/// <summary>
	/// translate a linear virtual address of the current address space
	/// to a linear physical address...
	/// </summary>
	/// <param name="virt_addr">virtual address in the vmexiting core's address space...</param>
	/// <returns>guest physical address...</returns>
	auto translate(guest_virt_t virt_addr)->guest_phys_t;

	/// <summary>
	/// reads guest physical memory...
	/// </summary>
	/// <param name="phys_addr">physical address to read...</param>
	/// <param name="buffer">buffer (guest virtual address) to read into...</param>
	/// <param name="size">number of bytes to read (can only be 0x1000 or less)...</param>
	/// <returns>STATUS_SUCCESS if the read was successful...</returns>
	auto read_phys(guest_phys_t phys_addr, guest_virt_t buffer, u64 size)->vmxroot_error_t;

	/// <summary>
	/// write guest physical memory...
	/// </summary>
	/// <param name="phys_addr">physical address to read</param>
	/// <param name="buffer">guest virtual address to write from...</param>
	/// <param name="size">number of bytes to write</param>
	/// <returns></returns>
	auto write_phys(guest_phys_t phys_addr, guest_virt_t buffer, u64 size)->vmxroot_error_t;

	/// <summary>
	/// copy guest virtual memory between virtual address spaces...
	/// </summary>
	/// <param name="dirbase_src">dirbase of the source address space</param>
	/// <param name="virt_src">virtual address in the source address space</param>
	/// <param name="dirbase_dest">dirbase of the destination address space</param>
	/// <param name="virt_dest">virtual address of the destination address</param>
	/// <param name="size">size to copy between address spaces</param>
	/// <returns>returns error_success on successful copy and invalid_guest_virt when an address is invalid...</returns>
	auto copy_virt(guest_phys_t dirbase_src, guest_virt_t virt_src, guest_phys_t dirbase_dest,
		guest_virt_t virt_dest, u64 size)->vmxroot_error_t;

	template <class T>
	auto rpm(guest_phys_t dirbase, guest_virt_t virt_addr) -> T
	{
		T buffer;
		auto result = copy_virt(dirbase, virt_addr,
			current_dirbase(), (guest_virt_t)&buffer, sizeof T);

		if (result != vmxroot_error_t::error_success)
			return {};

		return buffer;
	}

	template <class T>
	auto wpm(guest_phys_t dirbase, guest_virt_t virt_addr, const T& data) -> void
	{
		copy_virt(current_dirbase(), (guest_virt_t)&data,
			dirbase, virt_addr, sizeof T);
	}
}
```

`example/main.cpp`:

```cpp
#include <iostream>
#include "libvoyager.hpp"
#include "util/util.hpp"
#include "vdm_ctx/vdm_ctx.hpp"

int __cdecl main(int argc, char** argv)
{
	vdm::read_phys_t _read_phys = 
		[&](void* addr, void* buffer, std::size_t size) -> bool
	{
		const auto read_result = 
			voyager::read_phys((u64)addr, (u64)buffer, size);

		return read_result == 
			voyager::vmxroot_error_t::error_success;
	};

	vdm::write_phys_t _write_phys =
		[&](void* addr, void* buffer, std::size_t size) -> bool
	{
		const auto write_result = 
			voyager::write_phys((u64)addr, (u64)buffer, size);

		return write_result ==
			voyager::vmxroot_error_t::error_success;
	};

	std::printf("[+] voyager init result -> 0x%x (0x0 == success)\n", voyager::init());
	std::printf("[+] current dirbase -> 0x%p\n", voyager::current_dirbase());
	std::printf("[+] please wait... this may take up to 30 seconds...\n");

	const auto nt_shutdown_system = 
		util::get_kmodule_export(
			"ntoskrnl.exe", vdm::syscall_hook.first);
	
	const auto nt_shutdown_phys = 
		voyager::translate(reinterpret_cast<
			voyager::guest_virt_t>(nt_shutdown_system));

	std::printf("NtShutdownSystem -> 0x%p\n", nt_shutdown_system);
	std::printf("NtShutdownSystem (phys) -> 0x%p\n", nt_shutdown_phys);
	vdm::syscall_address.store(reinterpret_cast<void*>(nt_shutdown_phys));

	vdm::vdm_ctx vdm(_read_phys, _write_phys);
	const auto ntoskrnl_base =
		reinterpret_cast<void*>(
			util::get_kmodule_base("ntoskrnl.exe"));

	const auto ntoskrnl_memcpy =
		util::get_kmodule_export("ntoskrnl.exe", "memcpy");

	std::printf("[+] %s physical address -> 0x%p\n", vdm::syscall_hook.first, vdm::syscall_address.load());
	std::printf("[+] %s page offset -> 0x%x\n", vdm::syscall_hook.first, vdm::nt_page_offset);
	std::printf("[+] ntoskrnl base address -> 0x%p\n", ntoskrnl_base);
	std::printf("[+] ntoskrnl memcpy address -> 0x%p\n", ntoskrnl_memcpy);

	short mz_bytes = 0;
	vdm.syscall<decltype(&memcpy)>(
		ntoskrnl_memcpy,
		&mz_bytes,
		ntoskrnl_base,
		sizeof mz_bytes
	);

	std::printf("[+] ntoskrnl MZ -> 0x%x\n", mz_bytes);
	const auto explorer_dirbase = 
		vdm.get_dirbase(util::get_pid("explorer.exe"));

	const auto ntdll_base = 
		reinterpret_cast<std::uintptr_t>(
			GetModuleHandleA("ntdll.dll"));

	std::printf("explorer.exe dirbase -> 0x%p\n", explorer_dirbase);
	std::printf("current process dirbase -> %p\n", voyager::current_dirbase());
	std::printf("ntdll.dll base -> 0x%p\n", ntdll_base);
	std::printf("ntdll.dll MZ in explorer.exe -> 0x%x\n",
		voyager::rpm<short>(explorer_dirbase, ntdll_base));

	std::printf("[+] press any key to close...\n");
	std::getchar();
}

```

`example/util/nt.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <winternl.h>

#pragma comment(lib, "ntdll.lib")
#define PAGE_4KB 0x1000

constexpr auto SystemModuleInformation = 11;
typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef LARGE_INTEGER PHYSICAL_ADDRESS, * PPHYSICAL_ADDRESS;

using PEPROCESS = PVOID;
using PsLookupProcessByProcessId = NTSTATUS(__fastcall*)(
	HANDLE     ProcessId,
	PEPROCESS* Process
);

typedef union
{
    std::uint64_t flags;
    struct
    {
        std::uint64_t reserved1 : 3;

        /**
         * @brief Page-level Write-Through
         *
         * [Bit 3] Controls the memory type used to access the first paging structure of the current paging-structure hierarchy.
         * This bit is not used if paging is disabled, with PAE paging, or with 4-level paging if CR4.PCIDE=1.
         *
         * @see Vol3A[4.9(PAGING AND MEMORY TYPING)]
         */
        std::uint64_t page_level_write_through : 1;
#define CR3_PAGE_LEVEL_WRITE_THROUGH_BIT                             3
#define CR3_PAGE_LEVEL_WRITE_THROUGH_FLAG                            0x08
#define CR3_PAGE_LEVEL_WRITE_THROUGH_MASK                            0x01
#define CR3_PAGE_LEVEL_WRITE_THROUGH(_)                              (((_) >> 3) & 0x01)

        /**
         * @brief Page-level Cache Disable
         *
         * [Bit 4] Controls the memory type used to access the first paging structure of the current paging-structure hierarchy.
         * This bit is not used if paging is disabled, with PAE paging, or with 4-level paging2 if CR4.PCIDE=1.
         *
         * @see Vol3A[4.9(PAGING AND MEMORY TYPING)]
         */
        std::uint64_t page_level_cache_disable : 1;
#define CR3_PAGE_LEVEL_CACHE_DISABLE_BIT                             4
#define CR3_PAGE_LEVEL_CACHE_DISABLE_FLAG                            0x10
#define CR3_PAGE_LEVEL_CACHE_DISABLE_MASK                            0x01
#define CR3_PAGE_LEVEL_CACHE_DISABLE(_)                              (((_) >> 4) & 0x01)
        std::uint64_t reserved2 : 7;

        /**
         * @brief Address of page directory
         *
         * [Bits 47:12] Physical address of the 4-KByte aligned page directory (32-bit paging) or PML4 table (64-bit paging) used
         * for linear-address translation.
         *
         * @see Vol3A[4.3(32-BIT PAGING)]
         * @see Vol3A[4.5(4-LEVEL PAGING)]
         */
        std::uint64_t pml4_pfn : 36;
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_BIT                            12
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_FLAG                           0xFFFFFFFFF000
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_MASK                           0xFFFFFFFFF
#define CR3_ADDRESS_OF_PAGE_DIRECTORY(_)                             (((_) >> 12) & 0xFFFFFFFFF)
        std::uint64_t reserved3 : 16;
    };
} cr3;
```

`example/util/util.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <ntstatus.h>

#include <cstdint>
#include <string_view>
#include <algorithm>
#include <string_view>
#include <tlhelp32.h>
#include <map>
#include "nt.hpp"

namespace util
{
	inline std::map<std::uintptr_t, std::size_t> pmem_ranges{};
	__forceinline auto is_valid(std::uintptr_t addr) -> bool
	{
		for (auto range : pmem_ranges)
			if (addr >= range.first && addr <= range.first + range.second)
				return true;

		return false;
	}

#pragma pack (push, 1)
	struct PhysicalMemoryPage//CM_PARTIAL_RESOURCE_DESCRIPTOR
	{
		uint8_t type;
		uint8_t shareDisposition;
		uint16_t flags;
		uint64_t pBegin;
		uint32_t sizeButNotExactly;
		uint32_t pad;

		static constexpr uint16_t cm_resource_memory_large_40{ 0x200 };
		static constexpr uint16_t cm_resource_memory_large_48{ 0x400 };
		static constexpr uint16_t cm_resource_memory_large_64{ 0x800 };

		uint64_t size()const noexcept
		{
			if (flags & cm_resource_memory_large_40)
				return uint64_t{ sizeButNotExactly } << 8;
			else if (flags & cm_resource_memory_large_48)
				return uint64_t{ sizeButNotExactly } << 16;
			else if (flags & cm_resource_memory_large_64)
				return uint64_t{ sizeButNotExactly } << 32;
			else
				return uint64_t{ sizeButNotExactly };
		}
	};
	static_assert(sizeof(PhysicalMemoryPage) == 20);
#pragma pack (pop)

	inline const auto init_ranges = ([&]() -> bool
	{
			HKEY h_key;
			DWORD type, size;
			LPBYTE data;
			RegOpenKeyEx(HKEY_LOCAL_MACHINE, "HARDWARE\\RESOURCEMAP\\System Resources\\Physical Memory", 0, KEY_READ, &h_key);
			RegQueryValueEx(h_key, ".Translated", NULL, &type, NULL, &size); //get size
			data = new BYTE[size];
			RegQueryValueEx(h_key, ".Translated", NULL, &type, data, &size);
			DWORD count = *(DWORD*)(data + 16);
			auto pmi = data + 24;
			for (int dwIndex = 0; dwIndex < count; dwIndex++)
			{
#if 0
				pmem_ranges.emplace(*(uint64_t*)(pmi + 0), *(uint64_t*)(pmi + 8));
#else
				const PhysicalMemoryPage& page{ *(PhysicalMemoryPage*)(pmi - 4) };
				pmem_ranges.emplace(page.pBegin, page.size());
#endif
				pmi += 20;
			}
			delete[] data;
			RegCloseKey(h_key);
			return true;
	})();

	__forceinline auto get_file_header(void* base_addr) -> PIMAGE_FILE_HEADER
	{
		PIMAGE_DOS_HEADER dos_headers =
			reinterpret_cast<PIMAGE_DOS_HEADER>(base_addr);

		PIMAGE_NT_HEADERS nt_headers =
			reinterpret_cast<PIMAGE_NT_HEADERS>(
				reinterpret_cast<DWORD_PTR>(base_addr) + dos_headers->e_lfanew);

		return &nt_headers->FileHeader;
	}

	__forceinline auto get_kmodule_base(const char* module_name) -> std::uintptr_t
	{
		void* buffer = nullptr;
		DWORD buffer_size = NULL;

		auto status = NtQuerySystemInformation(
			static_cast<SYSTEM_INFORMATION_CLASS>(SystemModuleInformation),
				buffer, buffer_size, &buffer_size);

		while (status == STATUS_INFO_LENGTH_MISMATCH)
		{
			VirtualFree(buffer, NULL, MEM_RELEASE);
			buffer = VirtualAlloc(nullptr, buffer_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
			status = NtQuerySystemInformation(
				static_cast<SYSTEM_INFORMATION_CLASS>(SystemModuleInformation), 
					buffer, buffer_size, &buffer_size);
		}

		if (!NT_SUCCESS(status))
		{
			VirtualFree(buffer, NULL, MEM_RELEASE);
			return NULL;
		}

		const auto modules = static_cast<PRTL_PROCESS_MODULES>(buffer);
		for (auto idx = 0u; idx < modules->NumberOfModules; ++idx)
		{
			const std::string current_module_name = std::string(reinterpret_cast<char*>(modules->Modules[idx].FullPathName) + modules->Modules[idx].OffsetToFileName);
			if (!_stricmp(current_module_name.c_str(), module_name))
			{
				const uint64_t result = reinterpret_cast<uint64_t>(modules->Modules[idx].ImageBase);
				VirtualFree(buffer, NULL, MEM_RELEASE);
				return result;
			}
		}

		VirtualFree(buffer, NULL, MEM_RELEASE);
		return NULL;
	}

	__forceinline auto get_kmodule_export(const char* module_name, const char* export_name, bool rva = false) -> void*
	{
		void* buffer = nullptr;
		DWORD buffer_size = NULL;

		NTSTATUS status = NtQuerySystemInformation(
			static_cast<SYSTEM_INFORMATION_CLASS>(SystemModuleInformation),
			buffer,
			buffer_size,
			&buffer_size
		);

		while (status == STATUS_INFO_LENGTH_MISMATCH)
		{
			VirtualFree(buffer, 0, MEM_RELEASE);
			buffer = VirtualAlloc(nullptr, buffer_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
			status = NtQuerySystemInformation(
				static_cast<SYSTEM_INFORMATION_CLASS>(SystemModuleInformation), 
				buffer, 
				buffer_size, 
				&buffer_size
			);
		}

		if (!NT_SUCCESS(status))
		{
			VirtualFree(buffer, 0, MEM_RELEASE);
			return nullptr;
		}

		const auto modules = static_cast<PRTL_PROCESS_MODULES>(buffer);
		for (auto idx = 0u; idx < modules->NumberOfModules; ++idx)
		{
			// find module and then load library it
			const std::string current_module_name = 
				std::string(reinterpret_cast<char*>(
					modules->Modules[idx].FullPathName) +
					modules->Modules[idx].OffsetToFileName
				);

			if (!_stricmp(current_module_name.c_str(), module_name))
			{
				std::string full_path = reinterpret_cast<char*>(modules->Modules[idx].FullPathName);
				full_path.replace(full_path.find("\\SystemRoot\\"), 
					sizeof("\\SystemRoot\\") - 1, std::string(getenv("SYSTEMROOT")).append("\\"));

				const auto module_base = 
					LoadLibraryEx(
						full_path.c_str(),
						NULL, 
						DONT_RESOLVE_DLL_REFERENCES
					);

				PIMAGE_DOS_HEADER p_idh;
				PIMAGE_NT_HEADERS p_inh;
				PIMAGE_EXPORT_DIRECTORY p_ied;

				PDWORD addr, name;
				PWORD ordinal;

				p_idh = (PIMAGE_DOS_HEADER)module_base;
				if (p_idh->e_magic != IMAGE_DOS_SIGNATURE)
					return NULL;

				p_inh = (PIMAGE_NT_HEADERS)((LPBYTE)module_base + p_idh->e_lfanew);
				if (p_inh->Signature != IMAGE_NT_SIGNATURE)
					return NULL;

				if (p_inh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress == 0)
					return NULL;

				p_ied = (PIMAGE_EXPORT_DIRECTORY)((LPBYTE)module_base +
					p_inh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

				addr = (PDWORD)((LPBYTE)module_base + p_ied->AddressOfFunctions);
				name = (PDWORD)((LPBYTE)module_base + p_ied->AddressOfNames);
				ordinal = (PWORD)((LPBYTE)module_base + p_ied->AddressOfNameOrdinals);

				// find exported function
				for (auto i = 0; i < p_ied->AddressOfFunctions; i++)
				{
					if (!strcmp(export_name, (char*)module_base + name[i]))
					{
						if (!rva)
						{
							auto result = (void*)((std::uintptr_t)modules->Modules[idx].ImageBase + addr[ordinal[i]]);
							VirtualFree(buffer, NULL, MEM_RELEASE);
							return result;
						}
						else
						{
							auto result = (void*)addr[ordinal[i]];
							VirtualFree(buffer, NULL, MEM_RELEASE);
							return result;
						}
					}
				}
			}
		}

		VirtualFree(buffer, NULL, MEM_RELEASE);
		return nullptr;
	}

	__forceinline auto get_pid(const char* proc_name) -> std::uint32_t
	{
		PROCESSENTRY32 proc_info;
		proc_info.dwSize = sizeof(proc_info);

		HANDLE proc_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
		if (proc_snapshot == INVALID_HANDLE_VALUE)
			return NULL;

		Process32First(proc_snapshot, &proc_info);
		if (!strcmp(proc_info.szExeFile, proc_name))
		{
			CloseHandle(proc_snapshot);
			return proc_info.th32ProcessID;
		}

		while (Process32Next(proc_snapshot, &proc_info))
		{
			if (!strcmp(proc_info.szExeFile, proc_name))
			{
				CloseHandle(proc_snapshot);
				return proc_info.th32ProcessID;
			}
		}

		CloseHandle(proc_snapshot);
		return NULL;
	}
}
```

`example/vdm_ctx/vdm_ctx.cpp`:

```cpp
#include "vdm_ctx.hpp"

namespace vdm
{
	vdm_ctx::vdm_ctx(read_phys_t& read_func, write_phys_t& write_func)
		:
		read_phys(read_func),
		write_phys(write_func)
	{
		// already found the syscall's physical page...
		if (vdm::syscall_address.load())
			return;

		vdm::ntoskrnl = reinterpret_cast<std::uint8_t*>(
			LoadLibraryExA("ntoskrnl.exe", NULL,
				DONT_RESOLVE_DLL_REFERENCES));

		nt_rva = reinterpret_cast<std::uint32_t>(
			util::get_kmodule_export(
				"ntoskrnl.exe",
				syscall_hook.first,
				true
			));

		vdm::nt_page_offset = nt_rva % PAGE_4KB;
		std::vector<std::thread> search_threads;

		for (auto ranges : util::pmem_ranges)
			search_threads.emplace_back(std::thread(
				&vdm_ctx::locate_syscall,
				this,
				ranges.first,
				ranges.second
			));

		for (std::thread& search_thread : search_threads)
			search_thread.join();
	}

	void vdm_ctx::set_read(read_phys_t& read_func)
	{
		this->read_phys = read_func;
	}

	void vdm_ctx::set_write(write_phys_t& write_func)
	{
		this->write_phys = write_func;
	}

	void vdm_ctx::rkm(void* dst, void* src, std::size_t size)
	{
		static const auto ntoskrnl_memcpy =
			util::get_kmodule_export("ntoskrnl.exe", "memcpy");

		this->syscall<decltype(&memcpy)>(
			ntoskrnl_memcpy, dst, src, size);
	}

	void vdm_ctx::wkm(void* dst, void* src, std::size_t size)
	{
		static const auto ntoskrnl_memcpy =
			util::get_kmodule_export("ntoskrnl.exe", "memcpy");

		this->syscall<decltype(&memcpy)>(
			ntoskrnl_memcpy, dst, src, size);
	}

	void vdm_ctx::locate_syscall(std::uintptr_t address, std::uintptr_t length) const
	{
		const auto page_data =
			reinterpret_cast<std::uint8_t*>(
				VirtualAlloc(
					nullptr,
					PAGE_4KB, MEM_COMMIT | MEM_RESERVE,
					PAGE_READWRITE
				));

		// accesses the page in order to make PTE...
		memset(page_data, NULL, PAGE_4KB);
		for (auto page = 0u; page < length; page += PAGE_4KB)
		{
			if (vdm::syscall_address.load())
				break;

			if (!read_phys(reinterpret_cast<void*>(address + page), page_data, PAGE_4KB))
				continue;

			// check the first 32 bytes of the syscall, if its the same, test that its the correct
			// occurrence of these bytes (since dxgkrnl is loaded into physical memory at least 2 times now)...
			if (!memcmp(page_data + nt_page_offset, ntoskrnl + nt_rva, 32))
				if (valid_syscall(reinterpret_cast<void*>(address + page + nt_page_offset)))
					syscall_address.store(
						reinterpret_cast<void*>(
							address + page + nt_page_offset));
		}
		VirtualFree(page_data, PAGE_4KB, MEM_DECOMMIT);
	}

	bool vdm_ctx::valid_syscall(void* syscall_addr) const
	{
		static std::mutex syscall_mutex;
		syscall_mutex.lock();

		static const auto proc =
			GetProcAddress(
				LoadLibraryA(syscall_hook.second),
				syscall_hook.first
			);

		// 0:  48 31 c0    xor rax, rax
		// 3 : c3          ret
		std::uint8_t shellcode[] = { 0x48, 0x31, 0xC0, 0xC3 };
		std::uint8_t orig_bytes[sizeof shellcode];

		// save original bytes and install shellcode...
		read_phys(syscall_addr, orig_bytes, sizeof orig_bytes);
		write_phys(syscall_addr, shellcode, sizeof shellcode);

		auto result = reinterpret_cast<NTSTATUS(__fastcall*)(void)>(proc)();
		write_phys(syscall_addr, orig_bytes, sizeof orig_bytes);
		syscall_mutex.unlock();
		return result == STATUS_SUCCESS;
	}
}
```

`example/vdm_ctx/vdm_ctx.hpp`:

```hpp
#pragma once
#include <windows.h>
#include <string_view>
#include <vector>
#include <thread>
#include <atomic>
#include <mutex>
#include <functional>
#include "../util/util.hpp"

namespace vdm
{
	// change this to whatever you want :^)
	constexpr std::pair<const char*, const char*> syscall_hook = { "NtShutdownSystem", "ntdll.dll" };
	inline std::atomic<bool> is_page_found = false;
	inline std::atomic<void*> syscall_address = nullptr;
	inline std::uint16_t nt_page_offset;
	inline std::uint32_t nt_rva;
	inline std::uint8_t* ntoskrnl;

	using read_phys_t = std::function<bool(void*, void*, std::size_t)>;
	using write_phys_t = std::function<bool(void*, void*, std::size_t)>;

	class vdm_ctx
	{
	public:
		explicit vdm_ctx(read_phys_t& read_func, write_phys_t& write_func);
		void set_read(read_phys_t& read_func);
		void set_write(write_phys_t& write_func);
		void rkm(void* dst, void* src, std::size_t size);
		void wkm(void* dst, void* src, std::size_t size);

		template <class T, class ... Ts>
		__forceinline std::invoke_result_t<T, Ts...> syscall(void* addr, Ts ... args) const
		{
			static const auto proc =
				GetProcAddress(
					LoadLibraryA(syscall_hook.second),
					syscall_hook.first
				);

			static std::mutex syscall_mutex;
			syscall_mutex.lock();

			// jmp [rip+0x0]
			std::uint8_t jmp_code[] =
			{
				0xff, 0x25, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00
			};

			std::uint8_t orig_bytes[sizeof jmp_code];
			*reinterpret_cast<void**>(jmp_code + 6) = addr;
			read_phys(vdm::syscall_address.load(), orig_bytes, sizeof orig_bytes);

			// execute hook...
			write_phys(vdm::syscall_address.load(), jmp_code, sizeof jmp_code);
			auto result = reinterpret_cast<T>(proc)(args ...);
			write_phys(vdm::syscall_address.load(), orig_bytes, sizeof orig_bytes);

			syscall_mutex.unlock();
			return result;
		}

		template <class T>
		__forceinline auto rkm(std::uintptr_t addr) -> T
		{
			T buffer;
			rkm((void*)&buffer, (void*)addr, sizeof T);
			return buffer;
		}

		template <class T>
		__forceinline void wkm(std::uintptr_t addr, const T& value)
		{
			wkm((void*)addr, (void*)&value, sizeof T);
		}

		__forceinline auto get_peprocess(std::uint32_t pid) -> PEPROCESS
		{
			static const auto ps_lookup_peproc =
				util::get_kmodule_export(
					"ntoskrnl.exe",
					"PsLookupProcessByProcessId");

			PEPROCESS peproc = nullptr;
			this->syscall<PsLookupProcessByProcessId>(
				ps_lookup_peproc,
				(HANDLE)pid,
				&peproc
			);
			return peproc;
		}

		__forceinline auto get_dirbase(std::uint32_t pid) -> std::uintptr_t
		{
			const auto peproc = get_peprocess(pid);

			if (!peproc) 
				return {};

			return rkm<cr3>(
				reinterpret_cast<std::uintptr_t>(peproc) + 0x28).pml4_pfn << 12;
		}

		__forceinline auto get_peb(std::uint32_t pid) -> PPEB
		{
			static const auto get_peb = 
				util::get_kmodule_export(
					"ntoskrnl.exe", "PsGetProcessPeb");

			return this->syscall<PPEB(*)(PEPROCESS)>(
				get_peb, get_peprocess(pid));
		}

	private:
		void locate_syscall(std::uintptr_t begin, std::uintptr_t end) const;
		bool valid_syscall(void* syscall_addr) const;

		read_phys_t read_phys;
		write_phys_t write_phys;
	};
}
```

`libvoyager/com.asm`:

```asm
_text segment
hypercall proc
cpuid
ret
hypercall endp
_text ends
end
```

`libvoyager/libvoyager.cpp`:

```cpp
#include "libvoyager.hpp"
#include <Windows.h>
#include <iostream>

// taken from hvpp (wbenny). this code runs specific code on each logical processor...
// this is required since hyper-v has its own PML4 for each core...
// https://github.com/wbenny/hvpp/blob/master/src/hvppctrl/lib/mp.cpp#L4
auto voyager::init() -> vmxroot_error_t
{
    GROUP_AFFINITY orig_group_affinity;
    GetThreadGroupAffinity(GetCurrentThread(), &orig_group_affinity);
    const auto group_count = GetActiveProcessorGroupCount();

    // each core we are going to vmexit on and ask the payload
    // to setup the mapping pml4e. for some reason each core on
    // hyper-v has its own pml4... Not sure why? just is...
    for (auto group_number = 0u; group_number < group_count; ++group_number)
    {
        const auto processor_count = GetActiveProcessorCount(group_number);
        for (auto processor_number = 0u; processor_number < processor_count; ++processor_number)
        {
            GROUP_AFFINITY group_affinity = { 0 };
            group_affinity.Mask = (KAFFINITY)(1) << processor_number;
            group_affinity.Group = group_number;
            SetThreadGroupAffinity(GetCurrentThread(), &group_affinity, NULL);

            auto result = hypercall(VMEXIT_KEY, vmexit_command_t::init_page_tables, nullptr);
            if (result != vmxroot_error_t::error_success)
                return result;
        }
    }

    SetThreadGroupAffinity(GetCurrentThread(), &orig_group_affinity, NULL);
    return vmxroot_error_t::error_success;
}

auto voyager::current_dirbase()->guest_phys_t
{
    command_t command;
    auto result = hypercall(VMEXIT_KEY, vmexit_command_t::get_dirbase, &command);

    if (result != vmxroot_error_t::error_success)
        return {};

    return command.dirbase;
}

auto voyager::translate(guest_virt_t virt_addr) -> guest_phys_t
{
    command_t command;
    command.translate_virt.virt_src = virt_addr;

    const auto result = hypercall(VMEXIT_KEY, vmexit_command_t::translate, &command);

    if (result != vmxroot_error_t::error_success)
        return {};

    return command.translate_virt.phys_addr;
}

auto voyager::read_phys(guest_phys_t phys_addr, guest_virt_t buffer, u64 size) -> vmxroot_error_t
{
    command_t command;
    command.copy_phys = { phys_addr, buffer, size };
    return hypercall(VMEXIT_KEY, vmexit_command_t::read_guest_phys, &command);
}

auto voyager::write_phys(guest_phys_t phys_addr, guest_virt_t buffer, u64 size) -> vmxroot_error_t
{
    command_t command;
    command.copy_phys = { phys_addr, buffer, size };
    return hypercall(VMEXIT_KEY, vmexit_command_t::write_guest_phys, &command);
}

auto voyager::copy_virt(guest_phys_t dirbase_src, guest_virt_t virt_src, guest_phys_t dirbase_dest,
    guest_virt_t virt_dest, u64 size) -> vmxroot_error_t
{
    command_t command;
    command.copy_virt = { dirbase_src, virt_src, dirbase_dest, virt_dest, size };
    return hypercall(VMEXIT_KEY, vmexit_command_t::copy_guest_virt, &command);
}
```

`libvoyager/libvoyager.hpp`:

```hpp
#pragma once
#include <intrin.h>
#include <type_traits>

#define VMEXIT_KEY 0xDEADBEEFDEADBEEF
#define PAGE_4KB 0x1000
#define PAGE_2MB PAGE_4KB * 512
#define PAGE_1GB PAGE_2MB * 512

using u8 = unsigned char;
using u16 = unsigned short;
using u32 = unsigned int;
using u64 = unsigned long long;

namespace voyager
{
	// code comments itself...
	using guest_virt_t = u64;
	using guest_phys_t = u64;
	using host_virt_t = u64;
	using host_phys_t = u64;

	enum class vmexit_command_t
	{
		init_page_tables,
		read_guest_phys,
		write_guest_phys,
		copy_guest_virt,
		get_dirbase,
		translate
	};

	enum class vmxroot_error_t
	{
		error_success,
		pml4e_not_present,
		pdpte_not_present,
		pde_not_present,
		pte_not_present,
		vmxroot_translate_failure,
		invalid_self_ref_pml4e,
		invalid_mapping_pml4e,
		invalid_host_virtual,
		invalid_guest_physical,
		invalid_guest_virtual,
		page_table_init_failed
	};

	typedef union _command_t
	{
		struct _copy_phys
		{
			host_phys_t  phys_addr;
			guest_virt_t buffer;
			u64 size;
		} copy_phys;

		struct _copy_virt
		{
			guest_phys_t dirbase_src;
			guest_virt_t virt_src;
			guest_phys_t dirbase_dest;
			guest_virt_t virt_dest;
			u64 size;
		} copy_virt;

		struct _translate_virt
		{
			guest_virt_t virt_src;
			guest_phys_t phys_addr;
		} translate_virt;

		guest_phys_t dirbase;

	} command_t, * pcommand_t;

	/// <summary>
	/// this function is used to cause a vmexit as though its calling a function...
	/// </summary>
	extern "C" auto hypercall(u64 key, vmexit_command_t, pcommand_t command)->vmxroot_error_t;

	/// <summary>
	/// gets the current cores CR3 value (current address space pml4)...
	/// </summary>
	/// <returns>returns the guest cr3 value...</returns>
	auto current_dirbase()->guest_phys_t;

	/// <summary>
	/// initalizies page tables for all cores...
	/// </summary>
	/// <returns>status of the initalization...</returns>
	auto init()->vmxroot_error_t;

	/// <summary>
	/// translate a linear virtual address of the current address space
	/// to a linear physical address...
	/// </summary>
	/// <param name="virt_addr">virtual address in the vmexiting core's address space...</param>
	/// <returns>guest physical address...</returns>
	auto translate(guest_virt_t virt_addr)->guest_phys_t;

	/// <summary>
	/// reads guest physical memory...
	/// </summary>
	/// <param name="phys_addr">physical address to read...</param>
	/// <param name="buffer">buffer (guest virtual address) to read into...</param>
	/// <param name="size">number of bytes to read (can only be 0x1000 or less)...</param>
	/// <returns>STATUS_SUCCESS if the read was successful...</returns>
	auto read_phys(guest_phys_t phys_addr, guest_virt_t buffer, u64 size)->vmxroot_error_t;

	/// <summary>
	/// write guest physical memory...
	/// </summary>
	/// <param name="phys_addr">physical address to read</param>
	/// <param name="buffer">guest virtual address to write from...</param>
	/// <param name="size">number of bytes to write</param>
	/// <returns></returns>
	auto write_phys(guest_phys_t phys_addr, guest_virt_t buffer, u64 size)->vmxroot_error_t;

	/// <summary>
	/// copy guest virtual memory between virtual address spaces...
	/// </summary>
	/// <param name="dirbase_src">dirbase of the source address space</param>
	/// <param name="virt_src">virtual address in the source address space</param>
	/// <param name="dirbase_dest">dirbase of the destination address space</param>
	/// <param name="virt_dest">virtual address of the destination address</param>
	/// <param name="size">size to copy between address spaces</param>
	/// <returns>returns error_success on successful copy and invalid_guest_virt when an address is invalid...</returns>
	auto copy_virt(guest_phys_t dirbase_src, guest_virt_t virt_src, guest_phys_t dirbase_dest,
		guest_virt_t virt_dest, u64 size)->vmxroot_error_t;

	template <class T>
	auto rpm(guest_phys_t dirbase, guest_virt_t virt_addr) -> T
	{
		T buffer;
		auto result = copy_virt(dirbase, virt_addr,
			current_dirbase(), (guest_virt_t)&buffer, sizeof T);

		if (result != vmxroot_error_t::error_success)
			return {};

		return buffer;
	}

	template <class T>
	auto wpm(guest_phys_t dirbase, guest_virt_t virt_addr, const T& data) -> void
	{
		copy_virt(current_dirbase(), (guest_virt_t)&data,
			dirbase, virt_addr, sizeof T);
	}
}
```

`libvoyager/libvoyager.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30621.155
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libvoyager", "libvoyager\libvoyager.vcxproj", "{F468E79E-CC93-4A7F-844E-984117B5B08B}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "example", "example\example.vcxproj", "{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.Debug|x64.ActiveCfg = Debug|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.Debug|x64.Build.0 = Debug|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.Release|x64.ActiveCfg = Release|x64
		{F468E79E-CC93-4A7F-844E-984117B5B08B}.Release|x64.Build.0 = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.Debug|x64.ActiveCfg = Debug|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.Debug|x64.Build.0 = Debug|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.Release|x64.ActiveCfg = Release|x64
		{1770C4FB-345F-40DD-B4A2-2A5DC8A50866}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {BA7C21A6-0410-4D98-92D4-1F66944EAC47}
	EndGlobalSection
EndGlobal

```

`libvoyager/libvoyager.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="libvoyager.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="libvoyager.hpp" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="com.asm">
      <FileType>Document</FileType>
    </MASM>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{f468e79e-cc93-4a7f-844e-984117b5b08b}</ProjectGuid>
    <RootNamespace>libvoyager</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`libvoyager/libvoyager.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="libvoyager.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="libvoyager.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="com.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`libvoyager/libvoyager.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```