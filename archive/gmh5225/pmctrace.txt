Project Path: arc_gmh5225_pmctrace_c37u2yrf

Source Tree:

```txt
arc_gmh5225_pmctrace_c37u2yrf
├── LICENSE
├── README.md
├── build.bat
├── pmctrace.cpp
├── pmctrace.h
├── pmctrace_simple_test.cpp
├── pmctrace_test_asm.asm
└── pmctrace_threaded_test.cpp

```

`LICENSE`:

```
Computer Enhance License

All Computer Enhance source code, articles, videos, binaries, 
and related materials are provided "as is" without warranty 
of any kind, either express or implied, including without
limitation any implied warranties of condition, uninterrupted 
use, merchantability, fitness for a particular purpose, 
or non-infringement.

All of the source code published for the Computer Enhance programming
series are Copyright by Molly Rocket, Inc., as of their publication
date, and all rights are reserved. Paying subscribers to Computer
Enhance are granted a personal, non-assignable, non-transferable,
non-commercial license to use the source code for their own personal
educational purposes. Any other use, including any redistribution
in whole or in part, requires a special subscription as described
below.

Founding Member subscribers to Computer Enhance may use the source
code for any purpose, including commercial purposes, subject to two
conditions:

1) That they maintain their Founding Member subscription for the 
duration of their use of the source code,

2) That their use of the source code is not done in such a way as
to negatively impact the value of a Computer Enhance subscription.
Examples of prohibited uses include, but are not limited to:
creating a competing course using the source code; reselling the
source code as a product; providing the source code to 
non-subscribers; training an AI on the source code.

If you are unsure about whether your use of any Computer Enhance
source code is compliant with this license, you may ask for
clarification by email at license@mollyrocket.com.

```

`README.md`:

```md
# pmctrace

Performance Monitoring Counter collection via Event Tracing for Windows – from [The Computer Enhance 2024 International Event Tracing for Windows Halloween Spooktacular Challenge](https://www.computerenhance.com/p/announcing-the-etw-halloween-spooktacular).

After much blood, sweat, and tears – both mine and Mārtiņš Možeiko's (see [Special Thanks](#special-thanks)) – pmctrace is a complete working demonstration of live _region-based_ PMC collection on Windows _without_ any third-party driver requirements.

Based on the ETW API documentation alone, one would think it impossible to have "rdpmc"-style access to PMCs on Windows. However, if you combine custom events with some careful abuse of DPC tracing, it turns out you _can_ make it work. It is still way more code – and way more overhead – than would have been necessary were the ETW API sane, but, at least we have now proven it's _possible_ to have PMC collection markup like this:

```
    pmc_traced_region Region;

    StartCountingPMCs(Tracer, &Region);
    // ... any code you want to measure goes here ...
    StopCountingPMCs(Tracer, &Region);
```

provide accurate, real-time PMC measurements on a vanilla install of Windows – no third-party kernel drivers required. It works properly with multiple regions, across multiple threads, and returns results directly to the program while it's running.

# Limitations

Unfortunately, several unavoidable limitations of the ETW API persist despite our best efforts. Specifically:

* This method requires SysCall event collection, which introduces unnecessary overhead when profiling code that performs a lot of actual system calls. This is not an issue for microbenchmarking runs, but could be prohibitive for inline profiling of full applications.
* You have to run as administrator. Sadly, there is no policy option on Windows that will allow a regular user to access the PMCs.
* For no obvious reason, Intel CPUs do not provide most of their PMCs via ETW. You can only collect a fraction of the statistics you would get if you had real Intel PMC access.
* Although AMD CPUs provide a large number of their PMCs via ETW, they notably fail to include one of the most important – a core cycle counter – making microbenchmarking with this method much more cumbersome than it otherwise would be. The user will have to do their own rdpru separately, and it will not track properly across context switches.
* Unlike rdpmc, results have some latency, so users who don't want to stall must write their code to poll rather than block

# Special Thanks

I would once again like to thank [Mārtiņš Možeiko](https://gist.github.com/mmozeiko) for fearlessly producing great reference material for some of the world’s most finicky tools and APIs. The startup code for pmctrace was modeled after [Mārtiņš' epic miniperf gist](https://gist.github.com/mmozeiko/bd5923bcd9d20b5b9946691932ec95fa). ETW is incredibly flakey, and often fails to work for undocumented or convoluted system configuration reasons. Having miniperf to work from and check against was of the few things that allowed me to stay (mostly) sane in the process.

```

`build.bat`:

```bat
@echo off
mkdir build
pushd build
call cl -FC -nologo -Zi -Od ..\pmctrace_simple_test.cpp -Fepmctrace_simple_test_dm.exe
call cl -FC -nologo -Zi -O2 ..\pmctrace_simple_test.cpp -Fepmctrace_simple_test_rm.exe

where /q nasm || (echo WARNING: nasm not found -- threaded test will not be built)
call nasm -f win64 ..\pmctrace_test_asm.asm -o pmctrace_test_asm.obj
call lib -nologo pmctrace_test_asm.obj
call cl -FC -nologo -Zi -Od ..\pmctrace_threaded_test.cpp -Fepmctrace_threaded_test_dm.exe
call cl -FC -nologo -Zi -O2 ..\pmctrace_threaded_test.cpp -Fepmctrace_threaded_test_rm.exe

popd build

```

`pmctrace.cpp`:

```cpp
/* ========================================================================

   (C) Copyright 2024 by Molly Rocket, Inc., All Rights Reserved.
   
   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   
   Please see https://computerenhance.com for more information
   
   ======================================================================== */

#if !defined(PMC_DEBUG_LOG)
#define PMC_DEBUG_LOG 0
#endif

#if PMC_DEBUG_LOG
#define DEBUG_PRINT(Format, ...) \
{ \
    u64 Max = Tracer->LogEnd - Tracer->LogAt; \
    u64 Temp = snprintf(Tracer->LogAt, Max, Format, __VA_ARGS__); \
    if((Temp > 0) && (Temp < Max)) {Tracer->LogAt += Temp;} \
}
#else
#define DEBUG_PRINT(...)
#endif

enum trace_marker_type : u32
{
    TraceMarker_None,
    
    TraceMarker_Open,
    TraceMarker_Close,
    
    TraceMarker_Count,
};

struct win32_trace_description
{
    EVENT_TRACE_PROPERTIES_V2 Properties;
    WCHAR Name[1024];
};

struct pmc_tracer_etw_marker_userdata
{
    u64 TraceKey;
    pmc_traced_region *Dest;
};
struct pmc_tracer_etw_marker
{
    EVENT_TRACE_HEADER Header;
    pmc_tracer_etw_marker_userdata UserData;
};

struct etw_thread_switch_userdata
{
    DWORD NewThreadId;
    DWORD OldThreadId;
};

struct pmc_tracer_cpu
{
    pmc_traced_region *FirstRunningRegion;
    pmc_traced_region *WaitingForSysExitToStart;
    
    u64 LastSysEnterCounters[MAX_TRACE_PMC_COUNT];
    u64 LastSysEnterTSC;
    b32 LastSysEnterValid;
};

#define PMC_TRACE_RESULT_MASK 0xff
struct pmc_tracer
{
    win32_trace_description Win32TraceDesc;
    TRACEHANDLE MarkerRegistrationHandle;
    TRACEHANDLE TraceHandle;
    TRACEHANDLE TraceSession;
    HANDLE ProcessingThread;
    
    pmc_source_mapping Mapping;
    pmc_tracer_cpu *CPUs; // NOTE(casey): [CPUCount]
    pmc_traced_region *FirstSuspendedRegion;
    
    u32 CPUCount;
    
    b32 Error;
    char const *ErrorMessage;
    
    u64 TraceKey;

#if PMC_DEBUG_LOG
    char *Log;
    char *LogAt;
    char *LogEnd;
#endif
};

#define WIN32_TRACE_OPCODE_SWITCH_THREAD 36
#define WIN32_TRACE_OPCODE_SYSTEMCALL_ENTER 51
#define WIN32_TRACE_OPCODE_SYSTEMCALL_EXIT 52

static GUID Win32ThreadEventGuid = {0x3d6fa8d1, 0xfe05, 0x11d0, {0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c}};
static GUID Win32DPCEventGuid = {0xce1dbfb4, 0x137e, 0x4da6, {0x87, 0xb0, 0x3f, 0x59, 0xaa, 0x10, 0x2c, 0xbc}};

static GUID TraceMarkerProviderGuid = {0xb877a9af, 0x4155, 0x40f2, {0xa9, 0xba, 0x34, 0xbe, 0xdf, 0xaf, 0xd1, 0x22}};
static GUID TraceMarkerCategoryGuid = {0x5c96d7f7, 0xb1ea, 0x4fbe, {0x86, 0x55, 0xe0, 0x43, 0x1e, 0x23, 0x2e, 0x53}};

static void *Win32AllocateSize(u64 Size)
{
    void *Result = VirtualAlloc(0, Size, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
    return Result;
}

static void Win32Deallocate(void *Memory)
{
    if(Memory)
    {
        VirtualFree(Memory, 0, MEM_RELEASE);
    }
}

static b32 GUIDsAreEqual(GUID A, GUID B)
{
    __m128i Compare = _mm_cmpeq_epi8(_mm_loadu_si128((__m128i *)&A), _mm_loadu_si128((__m128i *)&B));
    int Mask = _mm_movemask_epi8(Compare);
    b32 Result = (Mask == 0xffff);
    return Result;
}

static b32 NoErrors(pmc_tracer *Tracer)
{
    b32 Result = !Tracer->Error;
    return Result;
}

static char const *GetErrorMessage(pmc_tracer *Tracer)
{
    char const *Result = Tracer->ErrorMessage;
    return Result;
}

static char const *GetDebugLog(pmc_tracer *Tracer)
{
    char const *Result = "(debug log not enabled - define PMC_DEBUG_LOG to 1 to enable)";
#if PMC_DEBUG_LOG
    Result = Tracer->Log;
#endif
    return Result;
}

static void TraceError(pmc_tracer *Tracer, char const *Message)
{
    DEBUG_PRINT("%s\n", Message);
    if(!Tracer->Error)
    {
        Tracer->Error = true;
        Tracer->ErrorMessage = Message;
    }
}

static void Win32FindPMCData(pmc_tracer *Tracer, EVENT_RECORD *Event, u32 PMCCount, u64 *PMCData)
{
    EVENT_EXTENDED_ITEM_PMC_COUNTERS *PMC = 0;
    u64 PMCDataSize = 0;
    u32 PMCPresent = 0;
    for(u32 EDIndex = 0; EDIndex < Event->ExtendedDataCount; ++EDIndex)
    {
        EVENT_HEADER_EXTENDED_DATA_ITEM *Item = Event->ExtendedData + EDIndex;
        if(Item->ExtType == EVENT_HEADER_EXT_TYPE_PMC_COUNTERS)
        {
            PMC = (EVENT_EXTENDED_ITEM_PMC_COUNTERS *)Item->DataPtr;
            PMCDataSize = Item->DataSize;
            ++PMCPresent;
        }
    }

    if(PMCDataSize != (sizeof(u64)*PMCCount))
    {
        TraceError(Tracer, "Unexpected PMC data size");
    }
    
    if(PMCPresent != 1)
    {
        TraceError(Tracer, "Unexpected PMC data count");
    }
    
    if(NoErrors(Tracer))
    {
        for(u32 PMCIndex = 0; PMCIndex < PMCCount; ++PMCIndex)
        {
            PMCData[PMCIndex] = PMC->Counter[PMCIndex];
        }
    }
}

static void ApplyPMCsAsOpen(pmc_traced_region *Region, u32 PMCCount, u64 *PMCData, u64 TSC)
{
    pmc_trace_result *Results = &Region->Results;
    
    for(u32 PMCIndex = 0; PMCIndex < PMCCount; ++PMCIndex)
    {
        Results->Counters[PMCIndex] -= PMCData[PMCIndex];
    }
    
    Results->TSCElapsed -= TSC;
}

static void ApplyPMCsAsClose(pmc_traced_region *Region, u32 PMCCount, u64 *PMCData, u64 TSC)
{
    pmc_trace_result *Results = &Region->Results;
    
    for(u32 PMCIndex = 0; PMCIndex < PMCCount; ++PMCIndex)
    {
        Results->Counters[PMCIndex] += PMCData[PMCIndex];
    }
    
    Results->TSCElapsed += TSC;
}

static void CALLBACK Win32ProcessETWEvent(EVENT_RECORD *Event)
{
    pmc_tracer *Tracer = (pmc_tracer *)Event->UserContext;
    
    GUID EventGUID = Event->EventHeader.ProviderId;
	UCHAR Opcode = Event->EventHeader.EventDescriptor.Opcode;
    u32 CPUID = GetEventProcessorIndex(Event);
    u32 PMCCount = Tracer->Mapping.PMCCount;
    u64 TSC = Event->EventHeader.TimeStamp.QuadPart;
    u64 PMCData[MAX_TRACE_PMC_COUNT] = {};
    
    if(CPUID < Tracer->CPUCount)
    {
        pmc_tracer_cpu *CPU = &Tracer->CPUs[CPUID];
        
        if(GUIDsAreEqual(EventGUID, TraceMarkerCategoryGuid))
        {
            pmc_tracer_etw_marker_userdata *Marker = (pmc_tracer_etw_marker_userdata *)Event->UserData;
            u64 MarkerKey = Marker->TraceKey;
            pmc_traced_region *Region = Marker->Dest;
            
            // NOTE(casey): Only process marker events if the keys match. If they don't match, they
            // are events that were inserted by another instance of the tracer, so we don't want
            // to accidentally start counting them as if they came from our own trace.
            if(Tracer->TraceKey == MarkerKey)
            {
                if(Opcode == TraceMarker_Open)
                {
                    DEBUG_PRINT("OPEN\n");
                    
                    // NOTE(casey): Add this region to the list of regions running on this CPU core
                    Region->Next = CPU->FirstRunningRegion;
                    CPU->FirstRunningRegion = Region;
                    
                    // NOTE(casey): Mark that this region will get its starting counter values from the next SysExit event
                    if(CPU->WaitingForSysExitToStart)
                    {
                        TraceError(Tracer, "Additional region opened on the same thread before SysExit event started the prior region");
                    }
                    CPU->WaitingForSysExitToStart = Region;
                }
                else if(Opcode == TraceMarker_Close)
                {
                    DEBUG_PRINT("CLOSE\n");
                    
                    pmc_trace_result *Results = &Region->Results;
                    
                    if(CPU->LastSysEnterValid)
                    {
                        // NOTE(casey): Apply the counters and TSC we saved from the preceeding SysEnter event
                        ApplyPMCsAsClose(Region, PMCCount, CPU->LastSysEnterCounters, CPU->LastSysEnterTSC);
                        
                        CPU->LastSysEnterValid = false;
                    }
                    else
                    {
                        TraceError(Tracer, "No ENTER for CLOSE event");
                    }
                    
                    // NOTE(casey): Remove this trace from the list of traces running on this CPU core
                    pmc_traced_region **FindRegion = &CPU->FirstRunningRegion;
                    while(*FindRegion)
                    {
                        if(*FindRegion == Region)
                        {
                            *FindRegion = Region->Next;
                            break;
                        }
                        
                        FindRegion = &(*FindRegion)->Next;
                    }
                    
                    // NOTE(casey): Make sure everything is written back before signaling completion
                    _mm_mfence(); // NOTE(casey): This is a stronger memory barrier than necessary, but should not be harmful
                    
                    // NOTE(casey): Signal completion to anyone waiting for these results
                    Results->Completed = true;
                }
                else
                {
                    TraceError(Tracer, "Unrecognized ETW marker type");
                }
            }
        }
        else if(GUIDsAreEqual(EventGUID, Win32ThreadEventGuid))
        {
            if(Opcode == WIN32_TRACE_OPCODE_SWITCH_THREAD)
            {
                if(Event->UserDataLength == 24)
                {
                    etw_thread_switch_userdata *Switch = (etw_thread_switch_userdata *)Event->UserData;
                    
                    // NOTE(casey): Get the PMC data once, since we may need it multiple times as we
                    // process suspending and resuming regions
                    if(CPU->FirstRunningRegion || Tracer->FirstSuspendedRegion)
                    {
                        Win32FindPMCData(Tracer, Event, PMCCount, PMCData);
                    }
                    
                    // NOTE(casey): Suspend any existing regions running on this CPU core
                    while(CPU->FirstRunningRegion)
                    {
                        DEBUG_PRINT("SWITCH FROM\n");
                        
                        pmc_traced_region *Region = CPU->FirstRunningRegion;
                        
                        if(Switch->OldThreadId != Region->OnThreadID)
                        {
                            TraceError(Tracer, "Switched thread ID mismatch");
                        }
                        
                        // NOTE(casey): Apply the current PMCs as "ending" counters
                        ApplyPMCsAsClose(Region, PMCCount, PMCData, TSC);
                        
                        // NOTE(casey): Record that this region has incurred a context switch
                        ++Region->Results.ContextSwitchCount;
                        
                        // NOTE(casey): Remove this region from the running set
                        CPU->FirstRunningRegion = Region->Next;
                        
                        // NOTE(casey): Put this region on the suspended list
                        Region->Next = Tracer->FirstSuspendedRegion;
                        Tracer->FirstSuspendedRegion = Region;
                    }
                    
                    // NOTE(casey): Look for matching region IDs that will be resumed
                    pmc_traced_region **FindRegion = &Tracer->FirstSuspendedRegion;
                    while(*FindRegion)
                    {
                        if((*FindRegion)->OnThreadID == Switch->NewThreadId)
                        {
                            DEBUG_PRINT("SWITCH TO\n");
                            
                            pmc_traced_region *Region = *FindRegion;
                            
                            // NOTE(casey): Apply the current PMCs as "begin" counters
                            ApplyPMCsAsOpen(Region, PMCCount, PMCData, TSC);
                            
                            // NOTE(casey): Remove this region from the suspended list
                            *FindRegion = (*FindRegion)->Next;
                            
                            // NOTE(casey): Put this region on the running list
                            Region->Next = CPU->FirstRunningRegion;
                            CPU->FirstRunningRegion = Region;
                        }
                        else
                        {
                            FindRegion = &(*FindRegion)->Next;
                        }
                    }
                }
                else
                {
                    TraceError(Tracer, "Unexpected CSwitch data size");
                }
            }
        }
        else if(GUIDsAreEqual(EventGUID, Win32DPCEventGuid))
        {
            if(Opcode == WIN32_TRACE_OPCODE_SYSTEMCALL_ENTER)
            {
                DEBUG_PRINT("ENTER\n");
                
                // NOTE(casey): Remember the state at this SysEnter so it can be applied to a
                // region later if there is a following Close event.
                if(CPU->FirstRunningRegion)
                {
                    CPU->LastSysEnterValid = true;
                    CPU->LastSysEnterTSC = TSC;
                    Win32FindPMCData(Tracer, Event, PMCCount, CPU->LastSysEnterCounters);
                }
            }
            else if(Opcode == WIN32_TRACE_OPCODE_SYSTEMCALL_EXIT)
            {
                DEBUG_PRINT("EXIT\n");
                
                // NOTE(casey): If there was a region waiting to open on the next syscall exit,
                // apply the PMCs to that region
                if(CPU->WaitingForSysExitToStart)
                {
                    pmc_traced_region *Region = CPU->WaitingForSysExitToStart;
                    CPU->WaitingForSysExitToStart = 0;
                
                    Win32FindPMCData(Tracer, Event, PMCCount, PMCData);
                    ApplyPMCsAsOpen(Region, PMCCount, PMCData, TSC);
                }
            }
        }
    }
    else
    {
        TraceError(Tracer, "Out-of-bounds CPUID in ETW event");
    }
}

static DWORD CALLBACK Win32ProcessEventThread(void *Arg)
{
    TRACEHANDLE Session = (TRACEHANDLE)Arg;
    ProcessTrace(&Session, 1, 0, 0);
    return 0;
}

static ULONG WINAPI ControlCallback(WMIDPREQUESTCODE, void *, ULONG *, void *)
{
    return ERROR_SUCCESS;
}

static b32 IsValid(pmc_source_mapping *Mapping)
{
    b32 Result = Mapping->Valid;
    return Result;
}

static pmc_source_mapping MapPMCNames(pmc_name_array *SourceNames)
{
    pmc_source_mapping Result = {};
    
    ULONG BufferSize;
    TraceQueryInformation(0, TraceProfileSourceListInfo, 0, 0, &BufferSize);
    BYTE *Buffer = (BYTE *)Win32AllocateSize(BufferSize);
    if(Buffer)
    {
        if(TraceQueryInformation(0, TraceProfileSourceListInfo, Buffer, BufferSize, &BufferSize) == ERROR_SUCCESS)
        {
            u32 FoundCount = 0;
            
            for(PROFILE_SOURCE_INFO *Info = (PROFILE_SOURCE_INFO *)Buffer;
                ;
                Info = (PROFILE_SOURCE_INFO *)((u8 *)Info + Info->NextEntryOffset))
            {
                for(u32 SourceNameIndex = 0; SourceNameIndex < ArrayCount(SourceNames->Strings); ++SourceNameIndex)
                {
                    wchar_t const *SourceString = SourceNames->Strings[SourceNameIndex];
                    if(SourceString)
                    {
                        Result.PMCCount = SourceNameIndex + 1;
                        if(lstrcmpW(Info->Description, SourceString) == 0)
                        {
                            Result.SourceIndex[SourceNameIndex] = Info->Source;
                            ++FoundCount;
                            break;
                        }
                    }
                }
                
                if(Info->NextEntryOffset == 0)
                {
                    break;
                }
            }
            
            Result.Valid = (Result.PMCCount == FoundCount);
        }
    }
    
    Win32Deallocate(Buffer);
    
    return Result;
}

static void SetTracePMCSources(pmc_tracer *Tracer, pmc_source_mapping *Mapping)
{
    ULONG Status = TraceSetInformation(Tracer->TraceHandle, TracePmcCounterListInfo,
                                       Mapping->SourceIndex, Mapping->PMCCount * sizeof(Mapping->SourceIndex[0]));
    if(Status != ERROR_SUCCESS)
    {
        TraceError(Tracer, "Unable to select PMCs");
    }
    
    CLASSIC_EVENT_ID EventIDs[] =
    {
        {Win32ThreadEventGuid, WIN32_TRACE_OPCODE_SWITCH_THREAD},
        {Win32DPCEventGuid, WIN32_TRACE_OPCODE_SYSTEMCALL_ENTER},
        {Win32DPCEventGuid, WIN32_TRACE_OPCODE_SYSTEMCALL_EXIT},
    };
    
    ULONG EventListStatus = TraceSetInformation(Tracer->TraceHandle, TracePmcEventListInfo, EventIDs, sizeof(EventIDs));
    if(EventListStatus != ERROR_SUCCESS)
    {
        TraceError(Tracer, "Unable to select events");
    }
}

static void Win32RegisterTraceMarker(pmc_tracer *Tracer)
{
    TRACE_GUID_REGISTRATION MarkerEventClassGuids[] = {(LPGUID)&TraceMarkerCategoryGuid, 0};
    ULONG Status = RegisterTraceGuids((WMIDPREQUEST)ControlCallback, 0, (LPGUID)&TraceMarkerProviderGuid,
                                      sizeof(MarkerEventClassGuids)/sizeof(TRACE_GUID_REGISTRATION),
                                      MarkerEventClassGuids,
                                      0, 0, &Tracer->MarkerRegistrationHandle);
    if(Status != ERROR_SUCCESS)
    {
        TraceError(Tracer, "ETW marker registration failed");
    }
}

static void Win32CreateTrace(pmc_tracer *Tracer, pmc_source_mapping *SourceMapping)
{
    const WCHAR TraceName[] = L"Win32PMCTrace";
    
    EVENT_TRACE_PROPERTIES_V2 *Props = &Tracer->Win32TraceDesc.Properties;
    Props->Wnode.BufferSize = sizeof(Tracer->Win32TraceDesc);
    Props->LoggerNameOffset = offsetof(win32_trace_description, Name);
    
    // NOTE(casey): Attempt to stop any existing orphaned trace from a previous run
    ControlTraceW(0, TraceName, (EVENT_TRACE_PROPERTIES *)Props, EVENT_TRACE_CONTROL_STOP);
    
    /* NOTE(casey): Attempt to start the trace. Note that the fields we care about MUST
       be filled in after the EVENT_TRACE_CONTROL_STOP ControlTraceW call, because
       that call will overwrite the properties! */
    Props->Wnode.ClientContext = 3;
    Props->Wnode.Flags = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_VERSIONED_PROPERTIES;
    Props->LogFileMode = EVENT_TRACE_REAL_TIME_MODE | EVENT_TRACE_SYSTEM_LOGGER_MODE;
    Props->VersionNumber = 2;
    Props->EnableFlags = EVENT_TRACE_FLAG_CSWITCH | EVENT_TRACE_FLAG_NO_SYSCONFIG | EVENT_TRACE_FLAG_SYSTEMCALL;
    ULONG StartStatus = StartTraceW(&Tracer->TraceHandle, TraceName, (EVENT_TRACE_PROPERTIES*)Props);
    
    if(StartStatus != ERROR_SUCCESS)
    {
        TraceError(Tracer, "Unable to start trace - may occur if not run as admin");
    }
    
    Tracer->Mapping = *SourceMapping;
    if(IsValid(&Tracer->Mapping))
    {
        SetTracePMCSources(Tracer, &Tracer->Mapping);
    }
    else
    {
        TraceError(Tracer, "PMC source mapping failed");
    }
    
    EVENT_TRACE_LOGFILEW Log = {};
    Log.LoggerName = Tracer->Win32TraceDesc.Name;
    Log.EventRecordCallback = Win32ProcessETWEvent;
    Log.ProcessTraceMode = PROCESS_TRACE_MODE_EVENT_RECORD | PROCESS_TRACE_MODE_RAW_TIMESTAMP | PROCESS_TRACE_MODE_REAL_TIME;
    Log.Context = Tracer;
    
    Tracer->TraceSession = OpenTraceW(&Log);
    if(Tracer->TraceSession == INVALID_PROCESSTRACE_HANDLE)
    {
        TraceError(Tracer, "Unable to open trace");
    }
    
    Tracer->ProcessingThread = CreateThread(0, 0, Win32ProcessEventThread, (void *)Tracer->TraceSession, 0, 0);
    if(Tracer->ProcessingThread == 0)
    {
        TraceError(Tracer, "Unable to create processing thread");
    }
}

static void StartTracing(pmc_tracer *Tracer, pmc_source_mapping *SourceMapping)
{
    *Tracer = {};
    
    Tracer->TraceKey = __rdtsc();
    
#if PMC_DEBUG_LOG
    u64 RequestedLogSize = 1024*1024*1024;
    Tracer->Log = Tracer->LogAt = (char *)Win32AllocateSize(RequestedLogSize);
    if(Tracer->Log)
    {
        Tracer->LogEnd = Tracer->Log + RequestedLogSize;
    }
#endif

    SYSTEM_INFO SysInfo = {};
    GetSystemInfo(&SysInfo);
    Tracer->CPUCount = SysInfo.dwNumberOfProcessors;
    
    Tracer->CPUs = (pmc_tracer_cpu *)Win32AllocateSize(Tracer->CPUCount * sizeof(pmc_tracer_cpu));
    if(Tracer->CPUs)
    {
        Win32RegisterTraceMarker(Tracer);
        Win32CreateTrace(Tracer, SourceMapping);
    }
    else
    {
        TraceError(Tracer, "Unable to allocate memory for CPU core tracking");
    }
}

static void StopTracing(pmc_tracer *Tracer)
{
    // TODO(casey): Try to verify that 0 is never a valid trace handle - it's unclear from the documentation
    if(Tracer->TraceHandle)
    {
        ControlTraceW(Tracer->TraceHandle, 0, (EVENT_TRACE_PROPERTIES *)&Tracer->Win32TraceDesc.Properties, EVENT_TRACE_CONTROL_STOP);
    }
    
    if(Tracer->TraceSession != INVALID_PROCESSTRACE_HANDLE)
    {
        CloseTrace(Tracer->TraceSession);
    }
    
    if(Tracer->ProcessingThread)
    {
        WaitForSingleObject(Tracer->ProcessingThread, INFINITE);
        CloseHandle(Tracer->ProcessingThread);
    }
    
    if(Tracer->MarkerRegistrationHandle)
    {
        UnregisterTraceGuids(Tracer->MarkerRegistrationHandle);
    }
    
#if PMC_DEBUG_LOG
    Win32Deallocate(Tracer->Log);
#endif
    Win32Deallocate(Tracer->CPUs);
}

static void StartCountingPMCs(pmc_tracer *Tracer, pmc_traced_region *ResultDest)
{
    pmc_tracer_etw_marker TraceMarker = {};
    TraceMarker.Header.Size = sizeof(TraceMarker);
    TraceMarker.Header.Flags = WNODE_FLAG_TRACED_GUID;
    TraceMarker.Header.Guid = TraceMarkerCategoryGuid;
    TraceMarker.Header.Class.Type = TraceMarker_Open;
    
    TraceMarker.UserData.TraceKey = Tracer->TraceKey;
    TraceMarker.UserData.Dest = ResultDest;
    
    /* TODO(casey): Is this necessary, or is it safe to pick up the thread index from the OPEN marker?
       If we never see an error where the open marker differs from the thread ID recorded here, then
       presumably this is not necessary, */
    ResultDest->OnThreadID = GetCurrentThreadId();
    ResultDest->Results = {};
    ResultDest->Results.PMCCount = Tracer->Mapping.PMCCount;
    
    if(TraceEvent(Tracer->TraceHandle, &TraceMarker.Header) != ERROR_SUCCESS)
    {
        TraceError(Tracer, "Unable to insert ETW open marker");
    }
}

static void StopCountingPMCs(pmc_tracer *Tracer, pmc_traced_region *ResultDest)
{
    pmc_tracer_etw_marker TraceMarker = {};
    TraceMarker.Header.Size = sizeof(TraceMarker);
    TraceMarker.Header.Flags = WNODE_FLAG_TRACED_GUID;
    TraceMarker.Header.Guid = TraceMarkerCategoryGuid;
    TraceMarker.Header.Class.Type = TraceMarker_Close;
    
    TraceMarker.UserData.TraceKey = Tracer->TraceKey;
    TraceMarker.UserData.Dest = ResultDest;
    
    /* TODO(casey): In some circumstances, I believe this can fail due to ETW's internal buffers being
       full. In that case, I _think_ it should be possible to mark the particular trace results as
       invalid, but keep trying to issue the TraceEvent, succeed, and then continune without having
       to error out of the entire run. However, I have not found a reliable repro case for this
       yet, so I haven't yet tried to implement such a recovery case. */
    if(TraceEvent(Tracer->TraceHandle, &TraceMarker.Header) != ERROR_SUCCESS)
    {
        TraceError(Tracer, "Unable to insert ETW close marker");
    }
}

static b32 IsComplete(pmc_traced_region *Region)
{
    b32 Result = Region->Results.Completed;
    return Result;
}

static pmc_trace_result GetOrWaitForResult(pmc_tracer *Tracer, pmc_traced_region *Region)
{
    while(NoErrors(Tracer) && !IsComplete(Region))
    {
        /* NOTE(casey): This is a spin-lock loop on purpose, because if there was a Sleep() in here
           or some other yield, it might cause Windows to demote this region, which we don't want.
           Ideally, we rarely spin here, because there are enough traces in flight to ensure that,
           whenever we check for results, there are some waiting, except perhaps at the very end of a
           batch. */
        
        _mm_pause();
    }
    
    _mm_mfence(); // NOTE(casey): This is a stronger memory barrier than necessary, but should not be harmful
    
    pmc_trace_result Result = Region->Results;
    return Result;
}
```

`pmctrace.h`:

```h
/* ========================================================================

   (C) Copyright 2024 by Molly Rocket, Inc., All Rights Reserved.
   
   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   
   Please see https://computerenhance.com for more information
   
   ======================================================================== */

//
// NOTE(casey): Interface
//

// NOTE(casey): This MAX is conservative. In practice, the CPU usually allows fewer PMC counters.
#define MAX_TRACE_PMC_COUNT 8

struct pmc_name_array
{
    wchar_t const *Strings[MAX_TRACE_PMC_COUNT];
};

struct pmc_source_mapping
{
    u32 SourceIndex[MAX_TRACE_PMC_COUNT];
    u32 PMCCount;
    b32 Valid;
};

struct pmc_trace_result
{
    u64 Counters[MAX_TRACE_PMC_COUNT];
    
    u64 TSCElapsed;
    u64 ContextSwitchCount;
    u32 PMCCount;
    b32 Completed;
};

struct pmc_traced_region
{
    pmc_trace_result Results;
    pmc_traced_region *Next;
    u32 OnThreadID;
};

struct pmc_tracer;

// NOTE(casey): Although MapPMCNames can take an array of up to MAX_TRACE_PMC_COUNT entries, the underlying CPU
// imposes its own limits, so the mapping may fail if you try to use more names than the CPU supports. It's best
// to use 4 or less names for compatibility, although some CPUs will allow more.
static b32 IsValid(pmc_source_mapping *Mapping);
static pmc_source_mapping MapPMCNames(pmc_name_array *SourceNames);

static b32 NoErrors(pmc_tracer *Tracer);
static char const *GetErrorMessage(pmc_tracer *Tracer);

// NOTE(casey): By default, no debug log is kept, so GetDebugLog will return 0. To enable logging, you must
// build with PMC_DEBUG_LOG defined to 1.
static char const *GetDebugLog(pmc_tracer *Tracer);

static void StartTracing(pmc_tracer *Tracer, pmc_source_mapping *Mapping);
static void StopTracing(pmc_tracer *Tracer);

static void StartCountingPMCs(pmc_tracer *Tracer, pmc_traced_region *ResultDest);
static void StopCountingPMCs(pmc_tracer *Tracer, pmc_traced_region *ResultDest);

// NOTE(casey): Region results can be read as soon as IsComplete returns true. GetOrWaitForResult will read results
// instantly if they are complete, so if you already know the results are complete via IsComplete, you can call
// GetOrWaitForResult to retrieve the results without waiting - it only waits when the results are incomplete.
static b32 IsComplete(pmc_traced_region *Region);
static pmc_trace_result GetOrWaitForResult(pmc_tracer *Tracer, pmc_traced_region *Region);

```

`pmctrace_simple_test.cpp`:

```cpp
/* ========================================================================

   (C) Copyright 2024 by Molly Rocket, Inc., All Rights Reserved.
   
   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   
   Please see https://computerenhance.com for more information
   
   ======================================================================== */

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <intrin.h>
#include <windows.h>
#include <psapi.h>
#include <evntrace.h>
#include <evntcons.h>

#pragma comment (lib, "advapi32.lib")

typedef uint8_t u8;
typedef uint32_t u32;
typedef uint64_t u64;

typedef int32_t b32;

typedef float f32;
typedef double f64;

#define ArrayCount(Array) (sizeof(Array)/sizeof((Array)[0]))

#include "pmctrace.h"
#include "pmctrace.cpp"

int main(void)
{
    pmc_name_array AMDNameArray =
    {
        L"TotalIssues",
        L"BranchMispredictions",
        L"DcacheMisses",
        L"IcacheMisses",
    };
    
    pmc_name_array IntelNameArray =
    {
        L"TotalIssues",
        L"UnhaltedCoreCycles"
        L"BranchInstructions",
        L"BranchMispredictions",
    };
    
    printf("Looking for AMD PMCs...\n");
    pmc_name_array *UsedNames = &AMDNameArray;
    pmc_source_mapping PMCMapping = MapPMCNames(&AMDNameArray);
    if(!IsValid(&PMCMapping))
    {
        printf("Looking for Intel PMCs...\n");
        UsedNames = &IntelNameArray;
        PMCMapping = MapPMCNames(&IntelNameArray);
    }
    
    //
    // NOTE(casey): Collect PMCs
    //
    
    if(IsValid(&PMCMapping))
    {
        pmc_tracer Tracer;
        
        printf("Starting trace...\n");
        StartTracing(&Tracer, &PMCMapping);
     
        pmc_traced_region Region[2];
        
        StartCountingPMCs(&Tracer, &Region[0]);
        printf("... This printf is measured only by Region[0].\n");
        StartCountingPMCs(&Tracer, &Region[1]);
        printf("... This printf is measured by both.\n");
        StopCountingPMCs(&Tracer, &Region[0]);
        StopCountingPMCs(&Tracer, &Region[1]);
        
        printf("Getting results...\n");
        for(u32 ResultIndex = 0; ResultIndex < ArrayCount(Region); ++ResultIndex)
        {
            pmc_trace_result Result = GetOrWaitForResult(&Tracer, &Region[ResultIndex]);
            if(NoErrors(&Tracer))
            {
                printf("\n%llu TSC elapsed [%llu context switch%s]\n",
                       Result.TSCElapsed, Result.ContextSwitchCount, 
                       (Result.ContextSwitchCount != 1) ? "es" : "");
                for(u32 CI = 0; CI < Result.PMCCount; ++CI)
                {
                    printf("  %llu %S\n", Result.Counters[CI], UsedNames->Strings[CI]);
                }
            }
            else
            {
                printf("ERROR: %s\n", GetErrorMessage(&Tracer));
                printf("LOG:\n%s\n", GetDebugLog(&Tracer));
                break;
            }
        }
        
        printf("Stopping trace...\n");
        StopTracing(&Tracer);
    }
    else
    {
        printf("ERROR: Unable to find suitable ETW PMCs\n");
    }
    
    return 0;
}

```

`pmctrace_test_asm.asm`:

```asm
;  ========================================================================
;
;  (C) Copyright 2024 by Molly Rocket, Inc., All Rights Reserved.
;
;  This software is provided 'as-is', without any express or implied
;  warranty. In no event will the authors be held liable for any damages
;  arising from the use of this software.
;
;  Please see https://computerenhance.com for more information
;
;  ========================================================================

global CountNonZeroesWithBranch

section .text

CountNonZeroesWithBranch:
    xor rax, rax
    xor r10, r10

.loop:
    mov al, [rdx + r10]
    
    cmp al, 0
    jz .skipsum
    inc rax
.skipsum:

    inc r10
    cmp r10, rcx
    jb .loop
    ret

```

`pmctrace_threaded_test.cpp`:

```cpp
/* ========================================================================

   (C) Copyright 2024 by Molly Rocket, Inc., All Rights Reserved.
   
   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   
   Please see https://computerenhance.com for more information
   
   ======================================================================== */

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <intrin.h>
#include <windows.h>
#include <psapi.h>
#include <evntrace.h>
#include <evntcons.h>

#pragma comment (lib, "advapi32.lib")

typedef uint8_t u8;
typedef uint32_t u32;
typedef uint64_t u64;

typedef int32_t b32;

typedef float f32;
typedef double f64;

#define ArrayCount(Array) (sizeof(Array)/sizeof((Array)[0]))

#include "pmctrace.h"
#include "pmctrace.cpp"

extern "C" void CountNonZeroesWithBranch(u64 Count, u8 *Data);
#pragma comment (lib, "pmctrace_test_asm")

struct thread_context
{
    HANDLE ThreadHandle;
    
    pmc_tracer *Tracer;
    
    u64 BufferCount;
    u64 NonZeroCount;
    
    pmc_trace_result BestResult;

    // NOTE(casey): The scratch space is in the thread_context rather than on the thread's stack
    // because if there is an error, the thread may exit before the tracer is finished writing back
    // results, which would lead to a crash - so the scratch targets must remain valid until after
    // the tracer's receiver thread exits.
    pmc_traced_region ScratchResults[32];
};

static DWORD CALLBACK TestThread(void *Arg)
{
    thread_context *Context = (thread_context *)Arg;
    pmc_tracer *Tracer = Context->Tracer;
    
    u64 BufferCount = Context->BufferCount;
    u64 NonZeroCount = Context->NonZeroCount;
    
    u8 *BufferData = (u8 *)VirtualAlloc(0, BufferCount, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
    if(BufferData)
    {
        for(u64 Index = 0; Index < NonZeroCount; ++Index)
        {
            u64 Random;
            while(_rdrand64_step(&Random) == 0) {}
            BufferData[Random % BufferCount] = 1;
        }
        
        Context->BestResult.TSCElapsed = (u64)-1ll;
        for(u32 Iteration = 0; NoErrors(Tracer) && (Iteration < 10); ++Iteration)
        {
            u32 BatchSize = ArrayCount(Context->ScratchResults);
            for(u32 BatchIndex = 0; NoErrors(Tracer) && (BatchIndex < BatchSize); ++BatchIndex)
            {
                pmc_traced_region *TracedThread = &Context->ScratchResults[BatchIndex];
                StartCountingPMCs(Tracer, TracedThread);
                CountNonZeroesWithBranch(BufferCount, BufferData);
                StopCountingPMCs(Tracer, TracedThread);
            }
            
            for(u32 BatchIndex = 0; BatchIndex < BatchSize; ++BatchIndex)
            {
                pmc_trace_result Result = GetOrWaitForResult(Tracer, &Context->ScratchResults[BatchIndex]);
                if(NoErrors(Tracer) && (Context->BestResult.TSCElapsed > Result.TSCElapsed))
                {
                    Context->BestResult = Result;
                }
            }
        }
    }
    else
    {
        printf("ERROR: Unable to allocate test memory\n");
    }
    
    return 0;
}

int main(void)
{
    printf("Looking for PMC names...\n");
    pmc_name_array SharedNameArray =
    {
        L"TotalIssues",
        L"BranchInstructions",
        L"BranchMispredictions",
    };
    
    pmc_name_array *UsedNames = &SharedNameArray;
    pmc_source_mapping PMCMapping = MapPMCNames(&SharedNameArray);
    if(IsValid(&PMCMapping))
    {
        pmc_tracer Tracer;
        
        printf("Starting trace...\n");
        StartTracing(&Tracer, &PMCMapping);
        
        thread_context Threads[16] = {};
        HANDLE ThreadHandles[ArrayCount(Threads)] = {};
        
        printf("Launching threads...\n");
        for(u32 ThreadIndex = 0; ThreadIndex < ArrayCount(ThreadHandles); ++ThreadIndex)
        {
            thread_context *Thread = Threads + ThreadIndex;
            Thread->Tracer = &Tracer;
            Thread->BufferCount = 64*1024*1024;
            Thread->NonZeroCount = ThreadIndex*8192;
            
            ThreadHandles[ThreadIndex] = CreateThread(0, 0, TestThread, Thread, 0, 0);
        }

        printf("Waiting for threads to complete...\n");
        WaitForMultipleObjects(ArrayCount(Threads), ThreadHandles, TRUE, INFINITE);
        
        if(NoErrors(&Tracer))
        {
            for(u32 ThreadIndex = 0; ThreadIndex < ArrayCount(ThreadHandles); ++ThreadIndex)
            {
                thread_context *Thread = Threads + ThreadIndex;
                pmc_trace_result BestResult = Thread->BestResult;
                
                printf("\nTHREAD %u - %llu non-zeroes:\n", ThreadIndex, Thread->NonZeroCount);
                printf("  %llu TSC elapsed / %llu iterations [%llu switch%s]\n",
                       BestResult.TSCElapsed, Thread->BufferCount, BestResult.ContextSwitchCount,
                       (BestResult.ContextSwitchCount != 1) ? "es" : "");
                for(u32 CI = 0; CI < BestResult.PMCCount; ++CI)
                {
                    printf("  %llu %S\n", BestResult.Counters[CI], UsedNames->Strings[CI]);
                }
            }
        }
        else
        {
            printf("ERROR: %s\n", GetErrorMessage(&Tracer));
            printf("LOG:\n%s\n", GetDebugLog(&Tracer));
        }
        
        StopTracing(&Tracer);
    }
    else
    {
        printf("ERROR: Unable to find suitable ETW PMCs\n");
    }
    
    return 0;
}

```