Project Path: arc_gmh5225_EFT-MonoEFT_954kypdp

Source Tree:

```txt
arc_gmh5225_EFT-MonoEFT_954kypdp
├── Core
│   ├── Container_1
│   │   ├── Features
│   │   │   └── Visuals.cs
│   │   ├── Hooks
│   │   │   ├── ApplyShot.cs
│   │   │   ├── BulletMovement.cs
│   │   │   ├── CanStand.cs
│   │   │   ├── CanStartNewSearchOperation.cs
│   │   │   ├── CreateShot.cs
│   │   │   ├── Deflects.cs
│   │   │   ├── GetLevel.cs
│   │   │   ├── GetShotInfo.cs
│   │   │   ├── GetStateForHandInput.cs
│   │   │   ├── GroundCheck.cs
│   │   │   ├── IsPenetrated.cs
│   │   │   ├── OverallScreenShow.cs
│   │   │   ├── SetFov.cs
│   │   │   ├── SilentAim.cs
│   │   │   └── Test.cs
│   │   └── Hooks.cs
│   ├── Container_2
│   │   ├── Globals
│   │   │   └── Globals.cs
│   │   └── Menu
│   │       ├── Menu.cs
│   │       └── Settings.cs
│   ├── Container_3
│   │   ├── Camera
│   │   │   └── Cam.cs
│   │   ├── CheatStructs
│   │   │   └── CheatStructs.cs
│   │   └── Hook_Lib
│   │       └── Hook_Lib.cs
│   ├── Container_4
│   │   └── Rendering
│   │       └── Rendering.cs
│   └── MonoCheat.cs
├── Entrypoint.cs
├── Properties
│   └── AssemblyInfo.cs
├── README.md
├── assets.assets
├── monoeft.csproj
└── monoeft.sln

```

`Core/Container_1/Features/Visuals.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
using EFT;

namespace eft
{
    public static class Visuals
    {
        public static void Run()
        {
            if( !Globals.World || !Globals.Local )
                return;

            foreach(var Player in Globals.World.RegisteredPlayers)
            {
                if( Player != Globals.Local ) 
                {
                    if(Settings.Visuals)
                    {
                        if( !Player.HealthController.IsAlive )
                            continue;

                        Vector3 HeadPos = CheatCam.w2s( Player.PlayerBones.Head.position );

                        var position = CheatCam.w2s( Player.Transform.position );

                        var distance = Mathf.Round( Vector3.Distance( Globals.Cam.transform.position , position ) );

            
                        var shoulder = CheatCam.w2s( Player.PlayerBones.LeftShoulder.position );
                        var height_offset = Mathf.Abs( HeadPos.y - shoulder.y );
                        var BoxHeight = Mathf.Abs( HeadPos.y - position.y ) + height_offset * 3;
                        var BoxWitdh = BoxHeight * 0.4f;


                        var BoxPosX = position.x - BoxWitdh / 2f;
                        var BoxPosY = HeadPos.y - height_offset * 2f;

                        if(Settings.Box)
                        {
                            Rendering.Rect( BoxPosX , BoxPosY , BoxWitdh , BoxHeight , Color.cyan );
                        }

                        float health = 0f;
                        float healthmax = 0f;
                        for( int i = 0 ; i < 6 ; i++ ) {
                            var bodyPartHealth = Player.HealthController.GetBodyPartHealth( ( EBodyPart ) i, false );
                            health += bodyPartHealth.Current;
                            healthmax += bodyPartHealth.Maximum;
                        }

                        if( Settings.ShowHealth ) {
                            var healthbox = health / healthmax * ( BoxHeight - 2f );
                            Rendering.RectFilled( BoxPosX - 7f, BoxPosY, 4f, BoxHeight , new Color32( 0 , 0 , 0 , 180 ) );
                            Rendering.RectFilled( BoxPosX - 6f, BoxPosY + BoxHeight - healthbox - 1f, 2f, healthbox, Color.green );
                        }


                        if( Settings.Name )
                        {
                            var playerName = Player.Profile.Nickname;
                            var Distance = $"{distance}";
                            Rendering.Label( BoxPosX , BoxPosY - 30 , 200 , 50 , Distance , new Color32( 108 , 168 , 189 , 120 ) , true );
                            Rendering.Label( BoxPosX , BoxPosY - 20, 200 , 50 , playerName , Color.white , true );
                        }

                        if( Settings.Chams1 ) 
                        {
                            if(Player != Globals.Local)
                            {
                                var skins = Player.PlayerBody.BodySkins.Values;
                                foreach( var skin in skins )
                                {
                                    foreach( var renderer in skin.GetRenderers( ) )
                                    {
                                        var material = renderer.material;
                                        
                                        material.shader = Globals.Bundle.LoadAsset<Shader>( "chams.shader" );
                                        material.SetColor( "_ColorVisible" , new Color32( 255 , 255 , 255 , 255 ) );
                                        material.SetColor( "_ColorBehind" , new Color32( 0 , 255 , 229 , 255 ) );
                                    }
                                }
                            }

                        }
                    }
                }

                if( Settings.WeaponChams )
                {
                    var component = Globals.Local.GetComponentsInChildren<Renderer>( );

                    foreach( var render in component )
                    {
                        var material = render.material;
                        if( !material )
                            continue;
                        
                        var name = material.name;

                       // EFT.UI.ConsoleScreen.Log( $"{name}" );

                        if( name.Contains( "weapon") || name.Contains( "ammo" ) || name.Contains( "sight" ) || name.Contains( "grip" ) || name.Contains( "mount" )|| name.Contains( "item" ) || name.Contains( "mag" ) || name.Contains( "tactical" ) || name.Contains( "scope" ) || name.Contains( "barrel" ) || name.Contains( "patron" ) || name.Contains( "muzzle" )) {
                            material.shader = Globals.Bundle.LoadAsset<Shader>( "chams.shader" );
                            material.SetColor( "_ColorVisible" , new Color32( 0 , 255 , 229 , 255 ) );
                            material.SetColor( "_ColorBehind" , new Color32( 0 , 255 , 229 , 255 ) );
                        }

                    }
                }

                if(Settings.HitMarker)
                {
                    for( int i = 0 ; i < Globals.HitList.Count ; i++ ) 
                    {
                        var hitMarker = Globals.HitList [ i ];
                      
                        if( Mathf.Abs( hitMarker.Time - Time.time ) > 2f )
                            Globals.TracerList.RemoveAt( i );

                        var HitPos = CheatCam.w2s( hitMarker.HitPos );

                        Rendering.Label( HitPos.x , HitPos.y , 200 , 50 , "x" , Color.red , true , true );
                    }
                }

                if( Settings.RicochetPrediction )
                {
                    var ShotDirection = Globals.Local.ProceduralWeaponAnimation._shotDirection;
                    Globals.Local.ProceduralWeaponAnimation._shotDirection = Vector3.down;
                    var WeaponDir = Globals.Local.GetComponent<Player.FirearmController>( ).WeaponDirection;
                    Globals.Local.ProceduralWeaponAnimation._shotDirection = ShotDirection;

                    RaycastHit hit;
                    if( Physics.Raycast( Globals.Local.PlayerBones.Fireport.Original.position , WeaponDir , out hit , 9999f , 1082202128 ) )
                    {
                        var Fireport = CheatCam.w2s( Globals.Local.PlayerBones.Fireport.Original.position );
                        var HitPoint = CheatCam.w2s( hit.point );

                        if( HitPoint.z > 0.01f )
                            Rendering.Line( new Vector2( HitPoint.x , HitPoint.y ) , new Vector2( Fireport.x , Fireport.y ) , 1 , Color.red );
                    }
                }
            }
        }
    }
}

```

`Core/Container_1/Hooks.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace eft
{
    public static class Hooks
    {
	private static bool is_hooked = true;
	public static DumbHook Penetrated_hk;
        public static DumbHook CreateShot_hk;
	public static DumbHook SetFov_hk;
	public static DumbHook Always_sprint_hk;
	public static DumbHook SilentAim_hk;
	public static DumbHook BulletMovement_hk;
	public static DumbHook Deflects_hk;
	public static DumbHook ApplyShot_hk;
	public static DumbHook CanStand_hk;
	public static DumbHook HasGround_hk;
	public static DumbHook Console_hk;
	public static DumbHook Level_hk;
	public static DumbHook Xp_hk;
	public static DumbHook Bought;
	public static DumbHook Des_hk;
	public static DumbHook ShotInfo_hk;
        public static DumbHook CanStartNewSearchOperation_hk;

	public static Type Find( string type )
	{
		foreach( Type type2 in System.Reflection.Assembly.GetAssembly( typeof( AICell ) ).GetTypes( ) )
		{
			if( type == type2.Name || type == type2.FullName )
			{
				return type2;
			}
		}
		return null;
	}

	public static void run()
        {


		if( Globals.World || Globals.Local )
            	{
			if( is_hooked )
              	 	{
				SilentAim_hk = new DumbHook( );
				SilentAim_hk.Init( typeof( EFT.Ballistics.BallisticsCalculator ).GetMethod( "CreateShot" ) , typeof( SilentAim ).GetMethod( "SilentAim_Hook" ) );
				SilentAim_hk.Emplace( );

				var CreateShotMethod = Find( "\uEA7D" ).GetMethod( "\uE004" , System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic );
				CreateShot_hk = new DumbHook( );
				CreateShot_hk.Init( CreateShotMethod , typeof( CreateShot ).GetMethod( "CreateShot_hook" ) );
				CreateShot_hk.Emplace( );

		 		var SetFovMethod = Find( "\uE776" ).GetMethod( "SetFov" , System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public );
				SetFov_hk = new DumbHook( );
				SetFov_hk.Init( SetFovMethod , typeof( SetFov ).GetMethod( "SetFov_Hook" ) );
				SetFov_hk.Emplace( );

				Always_sprint_hk = new DumbHook( );
				Always_sprint_hk.Init( typeof( EFT.Player ).GetMethod( "get_StateIsSuitableForHandInput" , System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public ), typeof( GetStateForHandInput ).GetMethod( "GetStateForHandInput_Hook" ) );
				Always_sprint_hk.Emplace( );

				var BulletMovementMethod = Find( "\uEA7D" ).GetMethod( "\uE00F" , System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic );
				BulletMovement_hk = new DumbHook( );
				BulletMovement_hk.Init( BulletMovementMethod , typeof( BulletMovement ).GetMethod( "BulletMovement_Hook" ) );
				BulletMovement_hk.Emplace( );

				var DelflectsMethod = Find( "\uEA7D" ).GetMethod( "\uE00D", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic ); 
				Deflects_hk = new DumbHook( );
				Deflects_hk.Init( DelflectsMethod , typeof( Deflects ).GetMethod( "Deflects_Hook" ) ); 
				Deflects_hk.Emplace( );

				Penetrated_hk = new DumbHook( );
				Penetrated_hk.Init( typeof( EFT.Ballistics.BallisticCollider ).GetMethod( "IsPenetrated" ) , typeof( IsPenetrated ).GetMethod( "IsPenetrated_Hook" ) );
				Penetrated_hk.Emplace( );

				var CanStandMethod = Find( "\uE61C" ).GetMethod( "CanStandAt" , System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public );
				CanStand_hk = new DumbHook( );
				CanStand_hk.Init( CanStandMethod , typeof( CanStand ).GetMethod( "CanStandAt_Hook" ) );
				CanStand_hk.Emplace( );

				var HasGroundMethod = Find( "\uE61C" ).GetMethod( "HasGround" , System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public );
				HasGround_hk = new DumbHook( );
				HasGround_hk.Init( HasGroundMethod , typeof( GroundCheck ).GetMethod( "HasGround_hook" ) );
				HasGround_hk.Emplace( );

				//ApplyShot_hk = new DumbHook( );
				//ApplyShot_hk.Init( typeof( EFT.Player ).GetMethod( "ApplyShot" , System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public ) , typeof( ApplyShot ).GetMethod( "ApplyShit_Hook" ) );
				//ApplyShot_hk.Emplace( );

				var GetShotInfoMethod = Find( "\uE5F7" ).GetMethod( "GetShotInfo" , System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public );
				ShotInfo_hk = new DumbHook( );
				ShotInfo_hk.Init( GetShotInfoMethod , typeof( GetShotInfo ).GetMethod( "GetShotInfo_Hook" ) );
				ShotInfo_hk.Emplace( );

				 var canStartNewSearchOperationMethod = Find( "\uE96E" ).GetMethod( "CanStartNewSearchOperation" , BindingFlags.Instance | BindingFlags.Public );
				CanStartNewSearchOperation_hk = new DumbHook( );
				CanStartNewSearchOperation_hk.Init( canStartNewSearchOperationMethod, typeof(CanStartNewSearchOperation).GetMethod( "CanStartNewSearchOperation_hook" ) );
				CanStartNewSearchOperation_hk.Emplace(  );

				//SetRoundIntoWeapon AddHit ToWeaponMalfunctionState //UpdateProfile //ForceLogout //ShowScreen 
				//uE672 uE001 | OnEnemyKill | \uE65E LogDamage | AddDoorExperience | \uE61F SetCharacterMovementSpeed | \uE4EC MeetsRequirements
				is_hooked = false;
			}			
        	 }			
        }

    }
}

```

`Core/Container_1/Hooks/ApplyShot.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace eft
{
    public class ApplyShot
    {
        public object ApplyShit_Hook( object damageInfo, EBodyPart eBodyPart , object shotid )
        {
          
                
              Hooks.ApplyShot_hk.remove( );
              var ret = Hooks.ApplyShot_hk.OriginalMethod.Invoke( this , new object [ ] { damageInfo , eBodyPart , shotid } );
              Hooks.ApplyShot_hk.Emplace( );
              return ret;
            
        }
    }
}

```

`Core/Container_1/Hooks/BulletMovement.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
using EFT;

namespace eft
{
    public class BulletMovement
    {
        public bool BulletMovement_Hook(Vector3 prev, Vector3 next)
        {
            Hooks.BulletMovement_hk.remove( );
            bool ret = (bool)Hooks.BulletMovement_hk.OriginalMethod.Invoke( this , new object [ ] { prev , next } );
            Hooks.BulletMovement_hk.Emplace( );
            //Class \uEA7D | Hit field: \uE009
            var TimeSinceShot = (float)typeof( EFT.Player ).Assembly.GetType( "\uEA7D" ).GetField( "TimeSinceShot" , System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public ).GetValue( this );
            var Player = ( EFT.Player )typeof( EFT.Player ).Assembly.GetType( "\uEA7D" ).GetField( "Player" , System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public ).GetValue( this );
            var hit = ( RaycastHit )typeof( EFT.Player ).Assembly.GetType( "\uEA7D" ).GetField( "\uE009" , System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic ).GetValue( this );

            if( Player == Globals.Local && TimeSinceShot < 3f ) 
            {
                CheatStructs.Tracer tracer = new CheatStructs.Tracer( );
                tracer.Time = Time.time;
                tracer.StartPos = prev;
                tracer.EndPos = hit.point;

                if( tracer.EndPos.x == 0f && tracer.EndPos.y == 0f && tracer.EndPos.z == 0f )
                    tracer.EndPos = next;

                Globals.TracerList.Add( tracer );
            }

            return ret;
        }

    }
}

```

`Core/Container_1/Hooks/CanStand.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using EFT;
using UnityEngine;

namespace eft
{
    public class CanStand
    {
        public bool CanStandAt_Hook( float h )
        {
            if( Settings.Phase )
                return true;


            Hooks.CanStand_hk.remove( );
            var ret = Hooks.CanStand_hk.OriginalMethod.Invoke( this, new object [ ] { h } );
            Hooks.CanStand_hk.Emplace( );
            return (bool) ret;
        }
    }
}
```

`Core/Container_1/Hooks/CanStartNewSearchOperation.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using EFT;
using UnityEngine;


namespace eft
{
    public class CanStartNewSearchOperation
    {
        public bool CanStartNewSearchOperation_hook( )
        {
            if( Settings.MultiSearch )
                return true;

            Hooks.CanStartNewSearchOperation_hk.remove(  );
            var ret = Hooks.CanStartNewSearchOperation_hk.OriginalMethod.Invoke( this, new object [ ] { } );
            Hooks.CanStartNewSearchOperation_hk.Emplace(  );
            return (bool) ret;
        }
    }
}

```

`Core/Container_1/Hooks/CreateShot.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using EFT;
using EFT.InventoryLogic;
using UnityEngine;

namespace eft
{
    public class CreateShot
    {
        public void CreateShot_hook( global::EFT.InventoryLogic.Item ammo , int fragmentIndex , int seed , UnityEngine.Vector3 origin , UnityEngine.Vector3 direction , float initialSpeed , float speed , float bulletMassKg , float bulletDiameterM , float damage , float penetrationPower , float penetrationChance , float ricochetChance , float fragmentationChance , float deviationChance , int minFragmentsCount , int maxFragmentsCount , global::EFT.Ballistics.BallisticCollider defaultBallisticCollider , object randoms , float ballisticCoefficient , global::EFT.Player player , global::EFT.InventoryLogic.Item weapon , int fireIndex , object parent )
        {
			
			if( Globals.Target != null )
			{
				if( Settings.Ricochet && parent != null )
				{				
					var Target = Globals.Target;
					var pos = Globals.BestPos( Target , Target.PlayerBones.Head.position );
					var _weapon = Globals.Local.HandsController.Item as Weapon;

					if( Target && _weapon != null ) 
					{
						direction = ( Target.PlayerBones.Head.position - origin ).normalized;
					}
				}
			}


			Hooks.CreateShot_hk.remove( );
			object [ ] parameters = new object [ ]
				{
					ammo,
					fragmentIndex,
					seed,
					origin,
					direction,
					initialSpeed,
					speed,
					bulletMassKg,
					bulletDiameterM,
					damage,
					penetrationPower,
					penetrationChance,
					ricochetChance,
					fragmentationChance,
					deviationChance,
					minFragmentsCount,
					maxFragmentsCount,
					defaultBallisticCollider,
					randoms,
					ballisticCoefficient,
					player,
					weapon,
					fireIndex,
					parent
				};
			Hooks.CreateShot_hk.OriginalMethod.Invoke( this , parameters );
			Hooks.CreateShot_hk.Emplace( );
		}
    }
}

```

`Core/Container_1/Hooks/Deflects.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace eft
{
    public class Deflects
    {
        public bool Deflects_Hook(object shot)
        {
            //Class \uEA7D Method \uE00E
            var m_method = typeof( EFT.Player ).Assembly.GetType( "\uEA7D" ).GetMethod( "\uE00E" , System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.NonPublic );
            int num = 0;
            int test = ( int )m_method.Invoke( null , new object [ ] { this , num } );

            bool result;
            if(Settings.Ricochet)
            {
                result = ( test < 4 );
            }else
            {
                Hooks.Deflects_hk.remove( );
                var obj = Hooks.Deflects_hk.OriginalMethod.Invoke( this , new object [ ] { shot } );
                Hooks.Deflects_hk.Emplace( );
                result = ( bool )obj;
            }
            return result;       
        }
    }
}

```

`Core/Container_1/Hooks/GetLevel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace eft
{
    public class GetLevel
    {
        public static int GetLevel_Hook( int experience )
        {
            return 70;
        }

        public static int GetExperience_Hook( int level )
        {
            return 100;
        }

        public bool CanBeBought_Hook()
        {
            return true;
        }

        public object Des_hook( )
        {
            Hooks.Des_hk.remove( );
            var ret = Hooks.Des_hk.OriginalMethod.Invoke( this , new object [ ] { } );
            Hooks.Des_hk.Emplace( );

            typeof( EFT.Player ).Assembly.GetType( "\uE6C7" ).GetField( "loyaltyLevel" , System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public ).SetValue( this , 200 );
            typeof( EFT.Player ).Assembly.GetType( "\uE6C7" ).GetField( "locked" , System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public ).SetValue( this, false );
            typeof( EFT.Player ).Assembly.GetType( "\uE6C7" ).GetField( "itemsCost" , System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public ).SetValue( this , 0 );
          //  itemsCost

            return ret;
        }
    }
}

```

`Core/Container_1/Hooks/GetShotInfo.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
using EFT;


namespace eft
{
    public class GetShotInfo
    {
        public object GetShotInfo_Hook(object shot)
        {
            Hooks.ShotInfo_hk.remove( );
            var ret = Hooks.ApplyShot_hk.OriginalMethod.Invoke( null , new object [ ] { shot } );
            Hooks.ShotInfo_hk.Emplace( );

            if(Settings.Hitsounds)
                Globals.Cam.GetComponent<AudioSource>( ).PlayOneShot( Globals.Hitclip );

            return ret;
        }

    }
}

```

`Core/Container_1/Hooks/GetStateForHandInput.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using EFT;
using UnityEngine;

namespace eft
{
    public class GetStateForHandInput
    {
        public bool GetStateForHandInput_Hook()
        {
            if( Settings.ShotRunCancel )
                return true;

            Hooks.Always_sprint_hk.remove( );
            var ret = Hooks.Always_sprint_hk.OriginalMethod.Invoke( this , new object [ ] { } );
            Hooks.Always_sprint_hk.Emplace( );

            return ( bool )ret;
        }
    }
}

```

`Core/Container_1/Hooks/GroundCheck.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using EFT;
using UnityEngine;

namespace eft
{
    public class GroundCheck
    {
        public bool HasGround_hook(float depth, Vector3 axis, float extra)
        {
            if( Settings.Phase )
                return true;
            Hooks.HasGround_hk.remove( );
            var ret = Hooks.HasGround_hk.OriginalMethod.Invoke( this , new object [ ] { depth , axis , extra } );
            Hooks.HasGround_hk.Emplace( );
            return ( bool )ret;
        }

    }
}

```

`Core/Container_1/Hooks/IsPenetrated.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using EFT;
using UnityEngine;

namespace eft
{
    public class IsPenetrated
    {
        public bool IsPenetrated_Hook(object shot, Vector3 hitPoint)
        {
            bool ret;
            if( Settings.Ricochet )
                ret = false;
            else
            {
                Hooks.Penetrated_hk.remove( );
                var obj = Hooks.Penetrated_hk.OriginalMethod.Invoke( this , new object [ ] { shot , hitPoint } );
                Hooks.Penetrated_hk.Emplace( );
                ret = ( bool )obj;
            }

            return ret;
        }
    
    }
}

```

`Core/Container_1/Hooks/OverallScreenShow.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
using EFT;

namespace eft
{
    public class OverallScreenShow
    {
        public void Show_Hook( EFT.Profile profile ,  object inventoryController)
        {

        }
    }
}

```

`Core/Container_1/Hooks/SetFov.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace eft
{
    public class SetFov
    {
        public void SetFov_Hook( float x , float time , bool applyFovOnCamera )
        {
            if( Settings.Fov )
                x += 30f;

            Hooks.SetFov_hk.remove( );
            Hooks.SetFov_hk.OriginalMethod.Invoke( this , new object [ ] { x , time , applyFovOnCamera } );
            Hooks.SetFov_hk.Emplace( );
        }
    }
}

```

`Core/Container_1/Hooks/SilentAim.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using EFT;
using UnityEngine;

namespace eft
{
    public class SilentAim
    {
        public object SilentAim_Hook(object ammo, Vector3 origin, Vector3 direction, int fireIndex , Player player , EFT.InventoryLogic.Item weapon , float speedFactor , int fragmentIndex )
        {
            if(Settings.SilentAim)
            {
                if(Globals.Target != null)
                {
                    direction = ( Globals.Target.PlayerBones.Head.position - origin ).normalized;
                }
            }

            Hooks.SilentAim_hk.remove( );
            var ret = Hooks.SilentAim_hk.OriginalMethod.Invoke( this , new object [ ] { ammo , origin , direction , fireIndex , player , weapon , speedFactor , fragmentIndex } );
            Hooks.SilentAim_hk.Emplace( );
            return ret;
        }
          

    }
}

```

`Core/Container_1/Hooks/Test.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
using EFT;

namespace eft
{
    public class Test
    {
        public void InitConsole_Hook( )
        {
            return;
        }
    }
}

```

`Core/Container_2/Globals/Globals.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
namespace eft
{
    public static class Globals
    {
        public static AssetBundle Bundle;
        public static GUISkin MenuSkin;
        public static Camera Cam;
        public static EFT.Player Local;
        public static EFT.GameWorld World;
		public static EFT.Player Target;
		public static AudioClip Hitclip;
		public static List<CheatStructs.Tracer> TracerList = new List<CheatStructs.Tracer>( );
		public static List<CheatStructs.HitMarker> HitList = new List<CheatStructs.HitMarker>( );
		public static Vector3 test;
		public static float CalcFov( global::UnityEngine.Vector3 pos )
		{
			var position = Camera.main.transform.position;
			var forward = Camera.main.transform.forward;
			var normalized = ( pos - position ).normalized;
			return Mathf.Acos( Mathf.Clamp( Vector3.Dot( forward , normalized ) , -1f , 1f ) ) * 57.29578f;
		}


		public static Vector3 BestPos(EFT.Player player, Vector3 aimpos )
        {
			var position = Local.Fireport.position;
			var vector = Local.Fireport.position + Cam.transform.forward * 2f;
			var vector2 = Local.Fireport.position + Cam.transform.up * 2f;
			var vector3 = Local.Fireport.position + Cam.transform.up * 2f;
			var vector4 = Local.Fireport.position + Cam.transform.right * 2f;
			var vector5 = Local.Fireport.position + Cam.transform.right * 2f;
			Vector3 result;
			if( is_visible( player.gameObject , position , aimpos ) )
			{
				result = position;
			}
			else
			{
			
				if( is_visible( player.gameObject , vector , aimpos ) )
				{
					result = vector;
				}
				else
				{
					if( is_visible( player.gameObject , vector4 , aimpos ) )
					{
						result = vector4;
					}
					else
					{
						if( is_visible( player.gameObject , vector5 , aimpos ) )
						{
							result = vector5;
						}
						else
						{
							if( is_visible( player.gameObject , vector2 , aimpos ) )
							{
								result = vector2;
							}
							else
							{ 
								if( is_visible( player.gameObject , vector3 , aimpos ) )
								{
									result = vector3;
								}
								else
								{
									result = position;
								}
							}
						}
					}
				}
			}
			return result;
		}
        public static bool w2s( global::UnityEngine.Vector3 pos , ref global::UnityEngine.Vector3 screen )
        {
            var vector = Cam.WorldToScreenPoint( pos );
            vector.y = Screen.height - vector.y;
            screen = vector;
            return screen.z > 0.01f;
        }
		public static bool is_visible( GameObject obj , Vector3 Pos , Vector3 Position, out RaycastHit raycastHit )
		{
			return Physics.Linecast( Pos , Position , out raycastHit , -2142957568 ) && raycastHit.collider && raycastHit.collider.gameObject.transform.root.gameObject == obj.transform.root.gameObject;
		}

		public static bool is_visible( GameObject obj , Vector3 Pos , Vector3 Position )
        {
            RaycastHit raycastHit;
            return Physics.Linecast( Pos , Position , out raycastHit , -2142957568 ) && raycastHit.collider && raycastHit.collider.gameObject.transform.root.gameObject == obj.transform.root.gameObject;
        }
    }
}

```

`Core/Container_2/Menu/Menu.cs`:

```cs
using System;
using UnityEngine;

namespace eft
{
    public static class Menu
    {
        public static bool open = true;
        public static int tab;
        public static bool BoundPhase;
        public static Rect rect = new Rect( ( float )( Screen.width / 2 - 200 ) , ( float )( Screen.height / 2 - 200 ) , 500f , 600f );
        public static void Draw( int id )
        {
            tab = UnityEngine.GUILayout.Toolbar( tab , new GUIContent [ ]
            {
                new GUIContent("Combat"),
                new GUIContent("Visuals"),
                new GUIContent("Misc"),
                new GUIContent("Removals"),
                new GUIContent("Exploits")
            } , Array.Empty<GUILayoutOption>( ) ) ;

            switch(tab)
            {
                case 0:
                    CombatTab( );
                    break;
                case 1:
                    VisualTab( );
                    break;
                case 2: 
                    MiscTab( );
                    break;
                case 3:
                    RemovalsTab( );
                    break;
                case 4:
                    ExploitsTab( );
                    break;
            }

            GUI.DragWindow( );
        }

        private static void CombatTab()
        {
            GUILayout.Label( "Aimbot" );
            GUILayout.Space( 2f );

            Settings.Aimbot = GUILayout.Toggle( Settings.Aimbot , "Enabled" , Array.Empty<GUILayoutOption>( ) );
            Settings.MemoryAim = GUILayout.Toggle( Settings.MemoryAim , "Memory Aim" , Array.Empty<GUILayoutOption>( ) );
            Settings.SilentAim = GUILayout.Toggle( Settings.SilentAim , "Silent Aim" , Array.Empty<GUILayoutOption>( ) );
        }

        private static void VisualTab()
        {
            GUILayout.Label( "Players" );
            GUILayout.Space( 2f );

            Settings.Visuals = GUILayout.Toggle( Settings.Visuals , "Enabled" , Array.Empty<GUILayoutOption>( ) );
            Settings.Name = GUILayout.Toggle( Settings.Name , "Name" , Array.Empty<GUILayoutOption>( ) );
            Settings.Box = GUILayout.Toggle( Settings.Box , "Box" , Array.Empty<GUILayoutOption>( ) );
            Settings.ShowHealth = GUILayout.Toggle( Settings.ShowHealth , "Healthbar" , Array.Empty<GUILayoutOption>( ) );
            Settings.Skeleton = GUILayout.Toggle( Settings.Skeleton , "Skeleton" , Array.Empty<GUILayoutOption>( ) );
            Settings.Chams1 = GUILayout.Toggle( Settings.Chams1 , "Chams ( 1 )" , Array.Empty<GUILayoutOption>( ) );
            Settings.Chams2 = GUILayout.Toggle( Settings.Chams2 , "Chams ( 2 )" , Array.Empty<GUILayoutOption>( ) );
            GUILayout.Label( "LocalPlayer" , Array.Empty<GUILayoutOption>( ) );
            GUILayout.Space( 2f );
            Settings.LocalPlayerChams = GUILayout.Toggle( Settings.LocalPlayerChams , "Apply Chams to Localplayer" , Array.Empty<GUILayoutOption>( ) );
            Settings.WeaponChams = GUILayout.Toggle( Settings.WeaponChams , "Weapon Chams" , Array.Empty<GUILayoutOption>( ) );
            Settings.BulletTracers = GUILayout.Toggle( Settings.BulletTracers , "Bullet Tracers" , Array.Empty<GUILayoutOption>( ) );
            Settings.HitMarker = GUILayout.Toggle( Settings.HitMarker , "Hitmarkers" , Array.Empty<GUILayoutOption>( ) );
            Settings.ThirdPerson = GUILayout.Toggle( Settings.ThirdPerson , "Third Person" , Array.Empty<GUILayoutOption>( ) );
            Settings.Fov = GUILayout.Toggle( Settings.Fov , "More Fov" , Array.Empty<GUILayoutOption>( ) );
            Settings.Fanta = GUILayout.Toggle( Settings.Fanta , "Fanta Moment" , Array.Empty<GUILayoutOption>( ) );
            Settings.RicochetPrediction = GUILayout.Toggle( Settings.RicochetPrediction , "Ricochet Indicator" , Array.Empty<GUILayoutOption>( ) );
            GUILayout.BeginArea( new Rect( 250 , 80f , 150f , 200f ) );
            GUILayout.Label( "World" , Array.Empty<GUILayoutOption>( ) );
            Settings.SkyMod = GUILayout.Toggle( Settings.SkyMod , "Sky modification" , Array.Empty<GUILayoutOption>( ) );
            GUILayout.EndArea( );
        }

        private static void MiscTab()
        {
            GUILayout.Label( "Misc" );
            GUILayout.Space( 2f );

            Settings.Hitsounds = GUILayout.Toggle( Settings.Hitsounds , "Hitsounds" , Array.Empty<GUILayoutOption>( ) );
            Settings.AlwaysSprint = GUILayout.Toggle( Settings.AlwaysSprint, "Always Sprint" , Array.Empty<GUILayoutOption>( ) );

        }

        private static void RemovalsTab()
        {
            GUILayout.Label( "Removals" );
            GUILayout.Space( 2f );

            Settings.AutoGun = GUILayout.Toggle( Settings.AutoGun , "Automatic Gun" , Array.Empty<GUILayoutOption>( ) );
            Settings.Stamina = GUILayout.Toggle( Settings.Stamina , "Stamina" , Array.Empty<GUILayoutOption>( ) );
            Settings.RemoveRecoil = GUILayout.Toggle( Settings.RemoveRecoil , "Remove Recoil" , Array.Empty<GUILayoutOption>( ) );
            Settings.RemoveSpread = GUILayout.Toggle( Settings.RemoveSpread , "Remove Spread" , Array.Empty<GUILayoutOption>( ) );
            GUILayout.Label( "Visual" );
            GUILayout.Space( 2f );
            Settings.NoVisor = GUILayout.Toggle( Settings.NoVisor , "No Visor" , Array.Empty<GUILayoutOption>( ) );
            Settings.FullBright = GUILayout.Toggle( Settings.FullBright , "Fullbright" , Array.Empty<GUILayoutOption>( ) );
        }

        private static void ExploitsTab()
        {
            GUILayout.Label( "Weapon" );
            Settings.Ricochet = GUILayout.Toggle( Settings.Ricochet , "Ricochet" , Array.Empty<GUILayoutOption>( ) );
            Settings.ShootThroughWall = GUILayout.Toggle( Settings.ShootThroughWall , "Manipulation" , Array.Empty<GUILayoutOption>( ) );
            Settings.RapidFire = GUILayout.Toggle( Settings.RapidFire , "Rapid Fire" , Array.Empty<GUILayoutOption>( ) );
            Settings.RiochetTest = GUILayout.Toggle( Settings.RiochetTest , "Ricochet 5 walls" , Array.Empty<GUILayoutOption>( ) );


            GUILayout.Label( "Movement" );
            Settings.ShotRunCancel = GUILayout.Toggle( Settings.ShotRunCancel , "Shoot while Running" , Array.Empty<GUILayoutOption>( ) );
            Settings.Phase = GUILayout.Toggle( Settings.Phase , "Phase" , Array.Empty<GUILayoutOption>( ) );
            Settings.HighJump = GUILayout.Toggle( Settings.HighJump , "Jump High" , Array.Empty<GUILayoutOption>( ) );

            Settings.Flyhack = GUILayout.Toggle( Settings.Flyhack , "Flyhack" , Array.Empty<GUILayoutOption>( ) );
            Settings.Speedhack = GUILayout.Toggle( Settings.Speedhack , "Speedhack" , Array.Empty<GUILayoutOption>( ) );
            Settings.TestSpeedhack = GUILayout.Toggle( Settings.TestSpeedhack , "Speedhack (Test)" , Array.Empty<GUILayoutOption>( ) );

            GUILayout.Label( "Other" );
            Settings.MultiSearch = GUILayout.Toggle( Settings.MultiSearch, "Multi Search", Array.Empty < GUILayoutOption >( ) );
            Settings.LootThroughWalls = GUILayout.Toggle( Settings.LootThroughWalls, "Loot Through Walls", Array.Empty < GUILayoutOption >( ) );
            Settings.InstanceExamine = GUILayout.Toggle( Settings.InstanceExamine, "Instant Examine", Array.Empty < GUILayoutOption >( ) );
        }
    }
}

```

`Core/Container_2/Menu/Settings.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace eft
{
    public static class Settings
    {
        public static bool Aimbot;
        public static bool MemoryAim;
        public static bool SilentAim;
        public static bool AutoShoot;


        public static bool Visuals;
        public static bool Name;
        public static bool Box;
        public static bool Skeleton;
        public static bool ShowHealth;
        public static bool WeaponChams;
        public static bool BulletTracers;
        public static bool LocalPlayerChams;
        public static bool Chams1;
        public static bool Chams2;
        public static bool Chams3;
        public static bool FullBright;
        public static bool FreeCam;
        public static bool Fov;
        public static bool Fanta;
        public static bool SkyMod;
        public static bool HitMarker;

        public static bool AlwaysSprint;
        public static bool Hitsounds;

        public static bool Stamina;
        public static bool RemoveRecoil;
        public static bool RemoveSpread;
        public static bool NoVisor;
        public static bool NightVision;
        public static bool ShotRunCancel;
        public static bool AutoGun;

        public static bool MultiSearch;
        public static bool InstanceExamine;
        public static bool TestSpeedhack;
        public static bool UltimateRaycast;
        public static bool HighJump;
        public static bool RapidFire;
        public static bool BunnyHop;
        public static bool Speedhack;
        public static bool Flyhack;
        public static bool LootThroughWalls;
        public static bool Ricochet;
        public static bool RiochetTest;
        public static bool RicochetPrediction;
        public static bool ShootThroughWall;
        public static bool Phase;
        public static KeyCode PhaseKey;
    }
}

```

`Core/Container_3/Camera/Cam.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace eft
{
    public static class CheatCam
    {
        public static Vector3 w2s(Vector3 pos )
        {
            var cam = Globals.Cam;
            if( !cam )
                return new Vector3( 0 , 0 , 0 );

            var w2s_point = Globals.Cam.WorldToScreenPoint( pos );
            w2s_point.y = Screen.height - w2s_point.y;

            if( w2s_point.z < 0.01f )
                return new Vector3( 0 , 0 , 0 );

            return w2s_point;
        }
    }
}

```

`Core/Container_3/CheatStructs/CheatStructs.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace eft
{
    public static class CheatStructs
    {

        public class Box
        {
            public Vector2 Position;
            public Vector2 Size;
        }

        public class HitMarker
        {
            public Vector3 HitPos;
            public float Time;
        }
        public class Tracer
        {
            public Vector3 StartPos;
            public Vector3 EndPos;
            public float Time;
        }

    }
}

```

`Core/Container_3/Hook_Lib/Hook_Lib.cs`:

```cs
using System;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace eft
{

    public class DumbHook
    {
        private const uint HOOK_SIZE_X64 = 12;
        private const uint HOOK_SIZE_X86 = 7;
        private byte [ ] original;

        public MethodInfo OriginalMethod { get; private set; }
        public MethodInfo HookMethod { get; private set; }

        public MethodInfo GetMethodByName( Type typeOrig , string nameOrig )
        {
            return typeOrig.GetMethod( nameOrig );
        }
        public DumbHook( )
        {
            original = null;
            OriginalMethod = HookMethod = null;
        }

        public DumbHook( MethodInfo orig , MethodInfo hook )
        {
            original = null;
            Init( orig , hook );
        }

        public DumbHook( Type typeOrig , string nameOrig , Type typeHook , string nameHook )
        {
            original = null;
            Init( GetMethodByName( typeOrig , nameOrig ) , GetMethodByName( typeHook , nameHook ) );
        }

        public void Init( MethodInfo orig , MethodInfo hook )
        {
            if( orig == null || hook == null )
                throw new ArgumentException( "Both original and hook need to be valid methods" );

            RuntimeHelpers.PrepareMethod( orig.MethodHandle );
            RuntimeHelpers.PrepareMethod( hook.MethodHandle );

            OriginalMethod = orig;
            HookMethod = hook;
        }

        public unsafe void Emplace( )
        {
            if( OriginalMethod == null || HookMethod == null )
                throw new ArgumentException( "no init retard" );
            if( original != null )
                return;

            // Patch it
            IntPtr funcFrom = OriginalMethod.MethodHandle.GetFunctionPointer( );
            IntPtr funcTo = HookMethod.MethodHandle.GetFunctionPointer( );
            uint oldProt;

            if( IntPtr.Size == 8 ) //x86-64
            {
                original = new byte [ HOOK_SIZE_X64 ];

                Import.VirtualProtect( funcFrom , HOOK_SIZE_X64 , 0x40 , out oldProt );

                byte* ptr = ( byte* )funcFrom;

                for( int i = 0 ; i < HOOK_SIZE_X64 ; ++i )
                {
                    original [ i ] = ptr [ i ];
                }

                // movabs rax, addy
                // jmp rax
                *( ptr ) = 0x48;
                *( ptr + 1 ) = 0xb8;
                *( IntPtr* )( ptr + 2 ) = funcTo;
                *( ptr + 10 ) = 0xff;
                *( ptr + 11 ) = 0xe0;

                Import.VirtualProtect( funcFrom , HOOK_SIZE_X64 , oldProt , out oldProt );
            }
        }


        public unsafe void remove( )
        {
            if( original == null )
                return;

            // Restore original code
            uint oldProt;
            uint codeSize = ( uint )original.Length;
            IntPtr origAddr = OriginalMethod.MethodHandle.GetFunctionPointer( );
            Import.VirtualProtect( origAddr , codeSize , 0x40 , out oldProt );
            unsafe
            {
                byte* ptr = ( byte* )origAddr;
                for( var i = 0 ; i < codeSize ; ++i )
                {
                    ptr [ i ] = original [ i ];
                }
            }
            Import.VirtualProtect( origAddr , codeSize , 0x40 , out oldProt );

  
            original = null;
        }


        internal class Import
        {
            [DllImport( "kernel32.dll" , SetLastError = true )]
            internal static extern bool VirtualProtect( IntPtr address , uint size , uint newProtect , out uint oldProtect );
        }

    }

}

```

`Core/Container_4/Rendering/Rendering.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection.Emit;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace eft
{
    public static class Rendering
    {
        private static Texture2D texture;
        public static Material material;
        private static int GL_Mode;
        public static Font font;
        private static int last_gl_mode;
        private static Color BoxColor;

        private static void SetMode(int mode)
        {

        }

        public static void MatrixLine(Vector3 start, Vector3 end, Color color)
        {
            material.SetPass( 0 );
            GL.PushMatrix( );
            GL.LoadProjectionMatrix( Globals.Cam.projectionMatrix );
            GL.modelview = Globals.Cam.worldToCameraMatrix;
            GL.Begin( 1 );
            GL.Color( color );
            GL.Vertex( start );
            GL.Vertex( end );
            GL.End( );
            GL.PopMatrix( );
        }

        public static void Line(Vector2 start, Vector2 end, int thickness, Color color)
        {
            if( !texture )
                texture = new Texture2D( 1 , 1 );

            texture.filterMode = FilterMode.Point;
            var backup_matrix = GUI.matrix;
            var backup_color = GUI.color;
            GUI.color = color;
            var width = end - start;
            float rotate = ( float )( 57.29577951308232 * ( double )Mathf.Atan( width.y / width.x ) );
            if( width.x < 0f )
                rotate += 180f;

            if( thickness < 1 )
                thickness = 1;

            int rotate2 = ( int )Mathf.Ceil( ( float )( thickness / 2 ) );
            GUIUtility.RotateAroundPivot( rotate , start );
            GUI.DrawTexture( new Rect( start.x , start.y - ( float )rotate2 , width.magnitude , ( float )thickness ) , texture );
            GUIUtility.RotateAroundPivot( -rotate , start );
            GUI.color = backup_color;
            GUI.matrix = backup_matrix;
        }

        public static void GlRect(float x, float y, float x1, float y1, Color color)
        {

        }
        public static void Label( float x , float y , float w , float h , string text,  Color color , bool outline, bool center = true )
        {
            var labelStyle = new GUIStyle( );

            labelStyle.font = font;
            labelStyle.fontSize = 9;


            var FontSize = labelStyle.CalcSize( new GUIContent( text ) );

            if( outline )
            {
                labelStyle.normal.textColor = Color.black;
                GUI.Label( new Rect( x , y + 1 , w , h ) , text , labelStyle );
                GUI.Label( new Rect( x , y - 1 , w , h ) , text , labelStyle );
                GUI.Label( new Rect( x - 1 , y , w , h ) , text , labelStyle );
                GUI.Label( new Rect( x + 1 , y , w , h ) , text , labelStyle );
            }

            labelStyle.normal.textColor = color;
            GUI.Label( new Rect( x , y , w , h ) , text , labelStyle );
        }


        public static void RectFilled( float x, float y, float w, float h, Color color )
        {
            if( texture == null )
                texture = new Texture2D( 1, 1 );

            GUI.color = color;
            GUI.DrawTexture( new Rect( x, y, w, h ), texture );
        }
        public static void Rect(float x, float y, float w, float h, Color color)
        {
            Line( new Vector2( x , y ) , new Vector2( x + w , y ) , 1 , color );
            Line( new Vector2( x , y ) , new Vector2( x , y + h ) , 1 , color );
            Line( new Vector2( x + w , y ) , new Vector2( x + w , y + h ) , 1 , color );
            Line( new Vector2( x , y + h ) , new Vector2( x + w , y + h ) , 1 , color );
        }

    }
}

```

`Core/MonoCheat.cs`:

```cs
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
using EFT;
using Comfort.Common;
using EFT.InventoryLogic;
using EFT.UI.Ragfair;

namespace eft
{
    public class MonoCheat : MonoBehaviour
    {
        private static bool Console_hooked = false;
        private static bool FullbrightCalled = false;
        private void Start()
        {
            Globals.Bundle = AssetBundle.LoadFromMemory( System.IO.File.ReadAllBytes( "C:\\Asset\\assets.assets" ) );
            Globals.Hitclip = Globals.Bundle.LoadAsset<AudioClip>( "bonk.mp3" );
            Rendering.font = Globals.Bundle.LoadAsset < Font >( "RUBIK-REGULAR.ttf" );
            Rendering.material = new Material( Shader.Find( "Hidden/Internal-Colored" ) )
            {
                hideFlags = HideFlags.HideAndDontSave
            };
 
            Rendering.material.SetInt( "_SrcBlend" , 5 );
            Rendering.material.SetInt( "_DstBlend" , 0xA );
            Rendering.material.SetInt( "_Cull" , 0 );
            Rendering.material.SetInt( "_ZWrite" , 0 );
        }

        private void Update()
        {
            if( Input.GetKeyDown( KeyCode.Insert ) )
                Menu.open = !Menu.open;

 
            Globals.Cam = Camera.main;

            if( Singleton<EFT.GameWorld>.Instantiated && !Globals.World )
                Globals.World = Singleton<EFT.GameWorld>.Instance;
            
            if(!Globals.Local)
            {
                foreach(var player in Globals.World.RegisteredPlayers)
                {
                    if( player.IsYourPlayer )
                        Globals.Local = player;
                }
            }    

            if(Settings.Fanta)
            {
                Globals.Cam.GetComponent<ThermalVision>( ).On = true;
            } 
            else
                Globals.Cam.GetComponent<ThermalVision>( ).On = false;


            if( Settings.RemoveRecoil ) 
            {
                Globals.Local.ProceduralWeaponAnimation.Breath.Intensity = 0f;
                Globals.Local.ProceduralWeaponAnimation.Mask = EFT.Animations.EProceduralAnimationMask.Breathing;
            }

            if(Settings.NoVisor)
                Globals.Cam.GetComponent<VisorEffect>( ).Intensity = 0f;

            if(Settings.Stamina)
            {
                var Params = Globals.Local.Physical.StaminaParameters;
                if( Params == null )
                    return;

                Params.AimDrainRate = 0f;
                Params.SprintDrainRate = 0f;
                Params.JumpConsumption = 0f;
                Params.ProneConsumption = 0f;
                Params.AimConsumptionByPose = Vector3.zero;
                Params.OverweightConsumptionByPose = Vector3.zero;
                Params.CrouchConsumption = Vector2.zero;
                Params.StandupConsumption = Vector2.zero;
                Params.WalkConsumption = Vector2.zero;
                Params.OxygenRestoration = 100000f;
                Params.ExhaustedMeleeSpeed = 100000f;
                Params.BaseRestorationRate = Params.Capacity;
            }

            if(Settings.LootThroughWalls)
            {
                var Instance = EFTHardSettings.Instance;
                Instance.LOOT_RAYCAST_DISTANCE = 4f;
            }

            if(Settings.FullBright)
            {
                if( !FullbrightCalled ) 
                {
                    var FullBrightObject = new GameObject("");
                    var Light = FullBrightObject.AddComponent<Light>( );
                    Light.color = Color.white;
                    Light.intensity = 0.5f;

                    FullbrightCalled = true;
                }
            }

            if(Settings.SkyMod)
            {
                /*
                var Instance = TOD_Sky.Instance;
                if( Instance == null )
                    return;

                var gradient = new Gradient( );
                var gradientColorKey = new GradientColorKey [ 2 ];
                gradientColorKey [ 0 ].color = Color.cyan;
                gradientColorKey [ 0 ].time = 0.0f;
                gradientColorKey [ 1 ].color = Color.blue;
                gradientColorKey [ 1 ].time = 1.0f;
                var alphakey = new GradientAlphaKey [ 2 ];
                alphakey [ 0 ].alpha = 1.0f;
                alphakey [ 0 ].time = 0.0f;
                alphakey [ 1 ].alpha = 0.0f;
                alphakey [ 1 ].time = 1.0f;

                gradient.SetKeys( colorKeys: gradientColorKey , alphaKeys: alphakey );

                Instance.Day.SkyColor = gradient;
                Instance.Night.SkyColor = gradient;
                */
            }

            if( Settings.FreeCam )
            {
                if( Input.GetKey( KeyCode.C ) )
                    Globals.Local.PointOfView = EPointOfView.FreeCamera;
                else
                    Globals.Local.PointOfView = EPointOfView.FirstPerson;
            }
      

            if(Settings.RapidFire)
            {
                if(Globals.Local.HandsController.Item is Weapon weapon)
                {
                    weapon.GetItemComponent<FireModeComponent>( ).FireMode = Weapon.EFireMode.fullauto;
                    weapon.Template.bFirerate = 2;
                    weapon.Template.isBoltCatch = false;
                    weapon.Template.BoltAction = false;          
                }
            }

            if( Settings.HighJump ) 
            {
                Globals.Local.Skills.StrengthBuffJumpHeightInc.Value = 0.7f;
            }

            if(Settings.Speedhack)
            {
                if( Input.GetKey( KeyCode.LeftShift ) )
                    Time.timeScale = 1.5f;
                else
                    Time.timeScale = 1f;              
            }

            if( Settings.AlwaysSprint ) 
            {
                var MovementContext = Globals.Local.MovementContext;
                MovementContext.AddStateSpeedLimit( 0 , Player.ESpeedLimit.BarbedWire );
                MovementContext.AddStateSpeedLimit( 0 , Player.ESpeedLimit.Aiming );
                MovementContext.EnableSprint( true );
            }

            if(Settings.TestSpeedhack)
            {
                var MovementContext = Globals.Local.MovementContext;
                if(Input.GetKey(KeyCode.LeftShift))
                {
                    Globals.Local.Transform.position += 4f * Time.deltaTime * Globals.Cam.transform.forward;
                }
            }

            if( Settings.Phase ) 
            {
                bool noclip_toggle = false;
                LayerMask mask = ~0;
                typeof( Player ).Assembly.GetType( "\uE61C" ).GetField( "\uE01A" , System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.SetField ).SetValue( Globals.Local.MovementContext , mask );
                typeof( Player ).Assembly.GetType( "\uE61C" ).GetField( "\uE01B" , System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.SetField ).SetValue( Globals.Local.MovementContext , mask );
                typeof( Player ).Assembly.GetType( "\uE61C" ).GetField( "\uE01C" , System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.SetField ).SetValue( Globals.Local.MovementContext , mask );
                float direction = 0f;

                if(Input.GetKey(KeyCode.F))
                {
                    if(Input.GetKey(KeyCode.Space))
                    {
                        direction = -1f;
                        Globals.Local.Transform.position += Globals.Local.Transform.up / 3 * 0.050f;
                    }

                    if(Input.GetKey(KeyCode.LeftControl))
                    {
                        direction = 1f;
                        Globals.Local.Transform.position -= Globals.Local.Transform.up / 3 * 0.050f;
                    }

                    Globals.Local.MovementContext.GrounderSetActive( false );
                    Globals.Local.MovementContext.IsGrounded = false;
                }

                Globals.Local.MovementContext.FreefallTime = direction;
                Globals.Local.MovementContext.InertiaSettings.MoveTime = 0;
                Globals.Local.MovementContext.InertiaSettings.MinDirectionBlendTime = 0;
                Globals.Local.MovementContext.InertiaSettings.PenaltyPower = 0;
                Globals.Local.MovementContext.InertiaSettings.DurationPower = 0;
                Globals.Local.MovementContext.InertiaSettings.BaseJumpPenaltyDuration = 0;
                Globals.Local.MovementContext.InertiaSettings.FallThreshold = 99999;

                noclip_toggle = true;
            }

            if( Settings.InstanceExamine) {
            }

            float fov = 120f; //hardcoded fov p
            if( Settings.Aimbot )
            {
                if( Settings.SilentAim )
                {
                    foreach( var Player in Globals.World.RegisteredPlayers ) {
                        if( Player == Globals.Local || !Player.ActiveHealthController.IsAlive ) 
                            continue;

                        float bestFov = Globals.CalcFov( Player.PlayerBones.Head.position );
                        if( bestFov < fov )
                        {
                            Globals.Target = Player;
                            fov = bestFov;
                        }
                    }
                }
            }

            if( Settings.Ricochet )
            {
                for( int i = 0 ; i < Globals.World._sharedBallisticsCalculator.Shots.Count ; i++ )
                {
                    var shot = Globals.World._sharedBallisticsCalculator.Shots [ i ];
                    if( shot.TimeSinceShot > 3f )
                        shot.IsForwardHit = true;
                }
            }

            Hooks.run( );
        }

        private void OnGUI()
        {
         
            Visuals.Run( );


            if( Menu.open )
            {
                Cursor.lockState = CursorLockMode.None;
                GUI.skin.label.normal.textColor = new Color32( 0 , 0 , 0 , byte.MaxValue );
                Menu.rect = GUI.Window( 0 , Menu.rect , new GUI.WindowFunction( Menu.Draw ) , "" );
            }

            Rendering.Label( Screen.width / 2 - 100 , 100 , 200 , 50 , "Halalcheats ( Insert )" , Color.cyan , true , true );

            if( Globals.Local ) {
                Rendering.Label( Screen.width / 2 , Screen.height / 2 , 200 , 50 , "x" , Color.red , true );

                if( Globals.Local.HandsController.Item is EFT.InventoryLogic.Weapon weapon )
                {
                    var mag = weapon.GetCurrentMagazine( );
                    if( mag == null )
                        return;
                    Rendering.Label( Screen.width / 2 - 10 , 700 , 200 , 50 , $"{mag.Count} | {weapon.SelectedFireMode}" , Color.white , true );
                }

                if( Settings.Ricochet )
                {                    
                    Rendering.Label( 40 , 500 , 200 , 50 , "Ricochet Aimbot Enabled" , Color.red , true );                  
                }
                if( Settings.TestSpeedhack )
                {                
                    Rendering.Label( 40 , 510 , 200 , 50 , "Speedhack ( Left Shift )" , Color.red , true );            
                }

                if(Settings.SilentAim)
                {
                    var HeadPos = CheatCam.w2s( Globals.Target.PlayerBones.Head.position );
                    Rendering.Line( new Vector2( Screen.width / 2 , Screen.height / 2 + 2 ) , new Vector2( HeadPos.x , HeadPos.y ) , 1 , new Color32( 255 , 255 , 255 , 30 ) );                  
                }

                if( Settings.Phase )
                {
                        if( Input.GetKey( KeyCode.F ) )
                            Rendering.Label( Screen.width / 2 - 10 , Screen.height / 2 + 50 , 200 , 50 , "[ Noclipping ] " , Color.red , true );               
                }
            }

            if( Settings.BulletTracers )
            {
                for( int i = 0 ; i < Globals.TracerList.Count ; i++ )
                {
                    var tracer = Globals.TracerList [ i ];

                    if( Mathf.Abs( tracer.Time - Time.time ) > 2f )
                        Globals.TracerList.RemoveAt( i );

                    Rendering.MatrixLine( tracer.StartPos , tracer.EndPos , new Color32( 255 , 255 , 255 , 30 ) );
                }
            }         
    
        }
    }
}

```

`Entrypoint.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace eft
{
    public static class entry
    {
        private static GameObject @object;
        public static void init()
        {
            @object = new GameObject( );
            @object.AddComponent<MonoCheat>( );
            UnityEngine.Object.DontDestroyOnLoad( @object );
        }
    }
}

```

`Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("monoeft")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("monoeft")]
[assembly: AssemblyCopyright("Copyright ©  2022")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("afd1de65-ea10-4c62-bfd7-7f6f6f4362d1")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`README.md`:

```md
# MonoEFT
EFT Mono Internal

```

`monoeft.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{AFD1DE65-EA10-4C62-BFD7-7F6F6F4362D1}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>monoeft</RootNamespace>
    <AssemblyName>monoeft</AssemblyName>
    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <Deterministic>true</Deterministic>
    <TargetFrameworkProfile>
    </TargetFrameworkProfile>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\build\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Assembly-CSharp">
      <HintPath>..\..\..\..\..\..\Battlestate Games\EFT\EscapeFromTarkov_Data\Managed\Assembly-CSharp.dll</HintPath>
    </Reference>
    <Reference Include="Comfort, Version=1.0.0.4, Culture=neutral, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>..\..\..\..\..\..\Battlestate Games\EFT\EscapeFromTarkov_Data\Managed\Comfort.dll</HintPath>
    </Reference>
    <Reference Include="Comfort.Unity, Version=1.0.0.4, Culture=neutral, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>..\..\..\..\..\..\Battlestate Games\EFT\EscapeFromTarkov_Data\Managed\Comfort.Unity.dll</HintPath>
    </Reference>
    <Reference Include="ItemComponent.Types">
      <HintPath>..\..\..\..\..\..\Battlestate Games\EFT\EscapeFromTarkov_Data\Managed\ItemComponent.Types.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
    <Reference Include="UnityEngine.AssetBundleModule, Version=0.0.0.0, Culture=neutral, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>..\..\..\..\..\..\Battlestate Games\EFT\EscapeFromTarkov_Data\Managed\UnityEngine.AssetBundleModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.AudioModule, Version=0.0.0.0, Culture=neutral, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>..\..\..\..\..\..\Battlestate Games\EFT\EscapeFromTarkov_Data\Managed\UnityEngine.AudioModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.CoreModule, Version=0.0.0.0, Culture=neutral, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>..\..\..\..\..\..\Battlestate Games\EFT\EscapeFromTarkov_Data\Managed\UnityEngine.CoreModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.IMGUIModule, Version=0.0.0.0, Culture=neutral, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>..\..\..\..\..\..\Battlestate Games\EFT\EscapeFromTarkov_Data\Managed\UnityEngine.IMGUIModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.InputLegacyModule, Version=0.0.0.0, Culture=neutral, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>..\..\..\..\..\..\Battlestate Games\EFT\EscapeFromTarkov_Data\Managed\UnityEngine.InputLegacyModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.PhysicsModule">
      <HintPath>..\..\..\..\..\..\Battlestate Games\EFT\EscapeFromTarkov_Data\Managed\UnityEngine.PhysicsModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.TextCoreModule">
      <HintPath>..\..\..\..\..\..\Battlestate Games\EFT\EscapeFromTarkov_Data\Managed\UnityEngine.TextCoreModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.TextRenderingModule">
      <HintPath>..\..\..\..\..\..\Battlestate Games\EFT\EscapeFromTarkov_Data\Managed\UnityEngine.TextRenderingModule.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Core\Container_1\Features\Visuals.cs" />
    <Compile Include="Core\Container_1\Hooks.cs" />
    <Compile Include="Core\Container_1\Hooks\ApplyShot.cs" />
    <Compile Include="Core\Container_1\Hooks\BulletMovement.cs" />
    <Compile Include="Core\Container_1\Hooks\CanStand.cs" />
    <Compile Include="Core\Container_1\Hooks\CanStartNewSearchOperation.cs" />
    <Compile Include="Core\Container_1\Hooks\CreateShot.cs" />
    <Compile Include="Core\Container_1\Hooks\Deflects.cs" />
    <Compile Include="Core\Container_1\Hooks\GetLevel.cs" />
    <Compile Include="Core\Container_1\Hooks\GetShotInfo.cs" />
    <Compile Include="Core\Container_1\Hooks\GetStateForHandInput.cs" />
    <Compile Include="Core\Container_1\Hooks\GroundCheck.cs" />
    <Compile Include="Core\Container_1\Hooks\IsPenetrated.cs" />
    <Compile Include="Core\Container_1\Hooks\OverallScreenShow.cs" />
    <Compile Include="Core\Container_1\Hooks\SetFov.cs" />
    <Compile Include="Core\Container_1\Hooks\SilentAim.cs" />
    <Compile Include="Core\Container_1\Hooks\Test.cs" />
    <Compile Include="Core\Container_2\Globals\Globals.cs" />
    <Compile Include="Core\Container_2\Menu\Menu.cs" />
    <Compile Include="Core\Container_2\Menu\Settings.cs" />
    <Compile Include="Core\Container_3\Camera\Cam.cs" />
    <Compile Include="Core\Container_3\CheatStructs\CheatStructs.cs" />
    <Compile Include="Core\Container_3\Hook_Lib\Hook_Lib.cs" />
    <Compile Include="Core\Container_4\Rendering\Rendering.cs" />
    <Compile Include="Core\MonoCheat.cs" />
    <Compile Include="Entrypoint.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <Folder Include="Core\Container_4\Raycast\" />
    <Folder Include="Core\Container_4\Utils\" />
  </ItemGroup>
  <ItemGroup>
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\Assembly-CSharp-firstpass.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\Assembly-CSharp.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.AssetBundleModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.AudioModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.ClothModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.ClusterRendererModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.CoreModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.ImageConversionModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.IMGUIModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.InputLegacyModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.InputModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.JSONSerializeModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.LocalizationModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.ParticleSystemModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.Physics2DModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.PhysicsModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.TerrainModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.TextCoreModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.TextRenderingModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.UI.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.UIElementsModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.UIModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.UNETModule.dll" />
    <Analyzer Include="..\..\..\..\..\..\ret\EscapeFromTarkov_Data\Managed\UnityEngine.UnityWebRequestAssetBundleModule.dll" />
    <Analyzer Include="bin\Debug\Accessibility.dll" />
    <Analyzer Include="bin\Debug\Aki.Build.dll" />
    <Analyzer Include="bin\Debug\Aki.Common.dll" />
    <Analyzer Include="bin\Debug\Aki.Reflection.dll" />
    <Analyzer Include="bin\Debug\AmplifyMotion.dll" />
    <Analyzer Include="bin\Debug\Autodesk.Fbx.dll" />
    <Analyzer Include="bin\Debug\bsg.componentace.compression.libs.zlib.dll" />
    <Analyzer Include="bin\Debug\bsg.microsoft.extensions.objectpool.dll" />
    <Analyzer Include="bin\Debug\bsg.system.buffers.dll" />
    <Analyzer Include="bin\Debug\Cinemachine.dll" />
    <Analyzer Include="bin\Debug\com.nvidia.reflex.Runtime.dll" />
    <Analyzer Include="bin\Debug\com.unity.multiplayer-hlapi.Runtime.dll" />
    <Analyzer Include="bin\Debug\Comfort.dll" />
    <Analyzer Include="bin\Debug\Comfort.Unity.dll" />
    <Analyzer Include="bin\Debug\ItemComponent.Types.dll" />
    <Analyzer Include="bin\Debug\NLog.dll" />
    <Analyzer Include="bin\Debug\Unity.Postprocessing.Runtime.dll" />
    <Analyzer Include="bin\Debug\Unity.ProBuilder.Csg.dll" />
    <Analyzer Include="bin\Debug\Unity.TextMeshPro.dll" />
    <Analyzer Include="bin\Debug\UnityEngine.DirectorModule.dll" />
    <Analyzer Include="bin\Debug\UnityEngine.ProfilerModule.dll" />
    <Analyzer Include="bin\Debug\UnityEngine.TerrainPhysicsModule.dll" />
    <Analyzer Include="bin\Debug\UnityEngine.TLSModule.dll" />
    <Analyzer Include="bin\Debug\UnityEngine.UmbraModule.dll" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`monoeft.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32126.315
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "monoeft", "monoeft.csproj", "{AFD1DE65-EA10-4C62-BFD7-7F6F6F4362D1}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{AFD1DE65-EA10-4C62-BFD7-7F6F6F4362D1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{AFD1DE65-EA10-4C62-BFD7-7F6F6F4362D1}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{AFD1DE65-EA10-4C62-BFD7-7F6F6F4362D1}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{AFD1DE65-EA10-4C62-BFD7-7F6F6F4362D1}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B66A47EE-DB2C-4D0C-AEB9-F13982D018C0}
	EndGlobalSection
EndGlobal

```